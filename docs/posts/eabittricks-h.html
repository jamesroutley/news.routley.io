<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/electronicarts/EAStdC/blob/master/include/EAStdC/EABitTricks.h">Original</a>
    <h1>EABitTricks.h</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="" data-tab-size="8" data-paste-markdown-skip="" data-tagsearch-lang="C++" data-tagsearch-path="include/EAStdC/EABitTricks.h">
        <tbody><tr>
          <td id="L1" data-line-number="1"></td>
          <td id="LC1"><span><span>//</span>/////////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L2" data-line-number="2"></td>
          <td id="LC2"><span><span>//</span> Copyright (c) Electronic Arts Inc. All rights reserved.</span></td>
        </tr>
        <tr>
          <td id="L3" data-line-number="3"></td>
          <td id="LC3"><span><span>//</span>/////////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L4" data-line-number="4"></td>
          <td id="LC4">
</td>
        </tr>
        <tr>
          <td id="L5" data-line-number="5"></td>
          <td id="LC5"><span><span>//</span>///////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L6" data-line-number="6"></td>
          <td id="LC6"><span><span>//</span> This is a list of C/C++ bit manipulation tricks. For example, it is </span></td>
        </tr>
        <tr>
          <td id="L7" data-line-number="7"></td>
          <td id="LC7"><span><span>//</span> well-known that (x * 2) can be also accomplished with (x &lt;&lt; 1). </span></td>
        </tr>
        <tr>
          <td id="L8" data-line-number="8"></td>
          <td id="LC8"><span><span>//</span> And while this example may not be useful in practice, there are many </span></td>
        </tr>
        <tr>
          <td id="L9" data-line-number="9"></td>
          <td id="LC9"><span><span>//</span> more such tricks which have real use, particularly for speeding up code.</span></td>
        </tr>
        <tr>
          <td id="L10" data-line-number="10"></td>
          <td id="LC10"><span><span>//</span> </span></td>
        </tr>
        <tr>
          <td id="L11" data-line-number="11"></td>
          <td id="LC11"><span><span>//</span> Notes:</span></td>
        </tr>
        <tr>
          <td id="L12" data-line-number="12"></td>
          <td id="LC12"><span><span>//</span>     * Twos-complement integer storage is assumed. Nearly all modern </span></td>
        </tr>
        <tr>
          <td id="L13" data-line-number="13"></td>
          <td id="LC13"><span><span>//</span>       processors use twos-complement storage.</span></td>
        </tr>
        <tr>
          <td id="L14" data-line-number="14"></td>
          <td id="LC14"><span><span>//</span>     * Some tricks assume that right shifts of signed values preserve </span></td>
        </tr>
        <tr>
          <td id="L15" data-line-number="15"></td>
          <td id="LC15"><span><span>//</span>       the sign. While nearly all modern processors and C/C++ compilers </span></td>
        </tr>
        <tr>
          <td id="L16" data-line-number="16"></td>
          <td id="LC16"><span><span>//</span>       support this, some primitive processors don&#39;t. By preserving sign, </span></td>
        </tr>
        <tr>
          <td id="L17" data-line-number="17"></td>
          <td id="LC17"><span><span>//</span>       we mean that signed binary (10000000 &gt;&gt; 1) gives (11000000).</span></td>
        </tr>
        <tr>
          <td id="L18" data-line-number="18"></td>
          <td id="LC18"><span><span>//</span>     * Only &#39;tricky&#39; efficient solutions are provided. Obvious brute force loops </span></td>
        </tr>
        <tr>
          <td id="L19" data-line-number="19"></td>
          <td id="LC19"><span><span>//</span>       to do useful things aren&#39;t included. We attempt to use branchless and  </span></td>
        </tr>
        <tr>
          <td id="L20" data-line-number="20"></td>
          <td id="LC20"><span><span>//</span>       loopless logic where possible.</span></td>
        </tr>
        <tr>
          <td id="L21" data-line-number="21"></td>
          <td id="LC21"><span><span>//</span>     * We don&#39;t cover magic number tricks for simplifying multiplication and </span></td>
        </tr>
        <tr>
          <td id="L22" data-line-number="22"></td>
          <td id="LC22"><span><span>//</span>       division by constants. For example (x * 17) can also be quickly accomplished </span></td>
        </tr>
        <tr>
          <td id="L23" data-line-number="23"></td>
          <td id="LC23"><span><span>//</span>       with ((x &lt;&lt; 4) + x). Optimized integer multiplication and division tricks </span></td>
        </tr>
        <tr>
          <td id="L24" data-line-number="24"></td>
          <td id="LC24"><span><span>//</span>       such as this is something for a separate library.</span></td>
        </tr>
        <tr>
          <td id="L25" data-line-number="25"></td>
          <td id="LC25"><span><span>//</span>     * We don&#39;t cover floating point tricks. That is something for a separate library. </span></td>
        </tr>
        <tr>
          <td id="L26" data-line-number="26"></td>
          <td id="LC26"><span><span>//</span>     * Implementations here are written as standalone functions for readability. </span></td>
        </tr>
        <tr>
          <td id="L27" data-line-number="27"></td>
          <td id="LC27"><span><span>//</span>       However, the user may find that it&#39;s better in some cases to copy the implementation </span></td>
        </tr>
        <tr>
          <td id="L28" data-line-number="28"></td>
          <td id="LC28"><span><span>//</span>       to a macro or to simply copy the implementation directly inline into source </span></td>
        </tr>
        <tr>
          <td id="L29" data-line-number="29"></td>
          <td id="LC29"><span><span>//</span>       code. EABitTricks is meant to be a reference for copy and paste as much as </span></td>
        </tr>
        <tr>
          <td id="L30" data-line-number="30"></td>
          <td id="LC30"><span><span>//</span>       it is meant to be used as-is.</span></td>
        </tr>
        <tr>
          <td id="L31" data-line-number="31"></td>
          <td id="LC31"><span><span>//</span>     * Many of these functions are templated instead of taking a given integer </span></td>
        </tr>
        <tr>
          <td id="L32" data-line-number="32"></td>
          <td id="LC32"><span><span>//</span>       type such as uint32_t. The reason for this is that we want 64 bit support </span></td>
        </tr>
        <tr>
          <td id="L33" data-line-number="33"></td>
          <td id="LC33"><span><span>//</span>       and that can be had automatically in most cases by the use of templates. The </span></td>
        </tr>
        <tr>
          <td id="L34" data-line-number="34"></td>
          <td id="LC34"><span><span>//</span>       generated code will be exactly as fast as the case when templates are not used.</span></td>
        </tr>
        <tr>
          <td id="L35" data-line-number="35"></td>
          <td id="LC35"><span><span>//</span> </span></td>
        </tr>
        <tr>
          <td id="L36" data-line-number="36"></td>
          <td id="LC36"><span><span>//</span>/////////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L37" data-line-number="37"></td>
          <td id="LC37">
</td>
        </tr>
        <tr>
          <td id="L38" data-line-number="38"></td>
          <td id="LC38">
</td>
        </tr>
        <tr>
          <td id="L39" data-line-number="39"></td>
          <td id="LC39">#<span>ifndef</span> EASTDC_EABITTRICKS_H</td>
        </tr>
        <tr>
          <td id="L40" data-line-number="40"></td>
          <td id="LC40">#<span>define</span> <span>EASTDC_EABITTRICKS_H</span></td>
        </tr>
        <tr>
          <td id="L41" data-line-number="41"></td>
          <td id="LC41">
</td>
        </tr>
        <tr>
          <td id="L42" data-line-number="42"></td>
          <td id="LC42">
</td>
        </tr>
        <tr>
          <td id="L43" data-line-number="43"></td>
          <td id="LC43">#<span>include</span> <span><span>&lt;</span>EAStdC/internal/Config.h<span>&gt;</span></span></td>
        </tr>
        <tr>
          <td id="L44" data-line-number="44"></td>
          <td id="LC44">#<span>include</span> <span><span>&lt;</span>EABase/eabase.h<span>&gt;</span></span></td>
        </tr>
        <tr>
          <td id="L45" data-line-number="45"></td>
          <td id="LC45">#<span>include</span> <span><span>&lt;</span>limits.h<span>&gt;</span></span></td>
        </tr>
        <tr>
          <td id="L46" data-line-number="46"></td>
          <td id="LC46">
</td>
        </tr>
        <tr>
          <td id="L47" data-line-number="47"></td>
          <td id="LC47">
</td>
        </tr>
        <tr>
          <td id="L48" data-line-number="48"></td>
          <td id="LC48">
</td>
        </tr>
        <tr>
          <td id="L49" data-line-number="49"></td>
          <td id="LC49">#<span>if</span> defined(EA_COMPILER_MSVC) &amp;&amp; (defined(EA_PROCESSOR_X86) || defined(EA_PROCESSOR_X86_64))</td>
        </tr>
        <tr>
          <td id="L50" data-line-number="50"></td>
          <td id="LC50">	<span><span>//</span> We can use assembly intrinsics for some of these functions.</span></td>
        </tr>
        <tr>
          <td id="L51" data-line-number="51"></td>
          <td id="LC51">	<span>EA_DISABLE_ALL_VC_WARNINGS</span>()</td>
        </tr>
        <tr>
          <td id="L52" data-line-number="52"></td>
          <td id="LC52">	#include &lt;math.h&gt;       <span><span>//</span> VS2008 has an acknowledged bug that requires math.h (and possibly also string.h) to be #included before intrin.h.</span></td>
        </tr>
        <tr>
          <td id="L53" data-line-number="53"></td>
          <td id="LC53">	#<span>include</span> <span><span>&lt;</span>intrin.h<span>&gt;</span></span></td>
        </tr>
        <tr>
          <td id="L54" data-line-number="54"></td>
          <td id="LC54">	<span>EA_RESTORE_ALL_VC_WARNINGS</span>()</td>
        </tr>
        <tr>
          <td id="L55" data-line-number="55"></td>
          <td id="LC55">	#pragma <span>intrinsic</span>(_BitScanForward)</td>
        </tr>
        <tr>
          <td id="L56" data-line-number="56"></td>
          <td id="LC56">	#pragma <span>intrinsic</span>(_BitScanReverse)</td>
        </tr>
        <tr>
          <td id="L57" data-line-number="57"></td>
          <td id="LC57">	#<span>if</span> <span>defined</span>(EA_PROCESSOR_X86_64)</td>
        </tr>
        <tr>
          <td id="L58" data-line-number="58"></td>
          <td id="LC58">		#pragma <span>intrinsic</span>(_BitScanForward64)</td>
        </tr>
        <tr>
          <td id="L59" data-line-number="59"></td>
          <td id="LC59">		#pragma <span>intrinsic</span>(_BitScanReverse64)</td>
        </tr>
        <tr>
          <td id="L60" data-line-number="60"></td>
          <td id="LC60">	#endif</td>
        </tr>
        <tr>
          <td id="L61" data-line-number="61"></td>
          <td id="LC61">#<span>elif</span> (defined(EA_COMPILER_GNUC) || defined(EA_COMPILER_CLANG)) &amp;&amp; (defined(EA_PROCESSOR_X86) || defined(EA_PROCESSOR_X86_64))</td>
        </tr>
        <tr>
          <td id="L62" data-line-number="62"></td>
          <td id="LC62">    #<span>include</span> <span><span>&lt;</span>x86intrin.h<span>&gt;</span></span></td>
        </tr>
        <tr>
          <td id="L63" data-line-number="63"></td>
          <td id="LC63">#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L64" data-line-number="64"></td>
          <td id="LC64">
</td>
        </tr>
        <tr>
          <td id="L65" data-line-number="65"></td>
          <td id="LC65"><span>EA_DISABLE_VC_WARNING</span>(<span>6326</span> <span>4146</span>) <span><span>//</span> C6326: Potential comparison of a constant with another constant</span></td>
        </tr>
        <tr>
          <td id="L66" data-line-number="66"></td>
          <td id="LC66">								 <span><span>//</span> C4146: unary minus operator applied to unsigned type, result still unsigned</span></td>
        </tr>
        <tr>
          <td id="L67" data-line-number="67"></td>
          <td id="LC67">
</td>
        </tr>
        <tr>
          <td id="L68" data-line-number="68"></td>
          <td id="LC68">
</td>
        </tr>
        <tr>
          <td id="L69" data-line-number="69"></td>
          <td id="LC69">
</td>
        </tr>
        <tr>
          <td id="L70" data-line-number="70"></td>
          <td id="LC70">namespace EA</td>
        </tr>
        <tr>
          <td id="L71" data-line-number="71"></td>
          <td id="LC71">{</td>
        </tr>
        <tr>
          <td id="L72" data-line-number="72"></td>
          <td id="LC72"><span>namespace</span> <span>StdC</span></td>
        </tr>
        <tr>
          <td id="L73" data-line-number="73"></td>
          <td id="LC73">{</td>
        </tr>
        <tr>
          <td id="L74" data-line-number="74"></td>
          <td id="LC74">	<span>namespace</span> <span>helper</span></td>
        </tr>
        <tr>
          <td id="L75" data-line-number="75"></td>
          <td id="LC75">	{</td>
        </tr>
        <tr>
          <td id="L76" data-line-number="76"></td>
          <td id="LC76">		<span><span>//</span>/////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L77" data-line-number="77"></td>
          <td id="LC77">		<span><span>//</span> is_signed</span></td>
        </tr>
        <tr>
          <td id="L78" data-line-number="78"></td>
          <td id="LC78">		<span><span>//</span>/////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L79" data-line-number="79"></td>
          <td id="LC79">
</td>
        </tr>
        <tr>
          <td id="L80" data-line-number="80"></td>
          <td id="LC80">		<span>struct</span> <span>false_type</span> { <span>static</span> <span>const</span> <span>bool</span> value = <span>false</span>; };</td>
        </tr>
        <tr>
          <td id="L81" data-line-number="81"></td>
          <td id="LC81">		<span>struct</span> <span>true_type</span>  { <span>static</span> <span>const</span> <span>bool</span> value = <span>true</span>;  };</td>
        </tr>
        <tr>
          <td id="L82" data-line-number="82"></td>
          <td id="LC82">
</td>
        </tr>
        <tr>
          <td id="L83" data-line-number="83"></td>
          <td id="LC83">		<span>template </span>&lt;<span>typename</span> T&gt; <span>struct</span> <span>is_signed</span> : <span>public</span> <span>false_type</span>{};</td>
        </tr>
        <tr>
          <td id="L84" data-line-number="84"></td>
          <td id="LC84">
</td>
        </tr>
        <tr>
          <td id="L85" data-line-number="85"></td>
          <td id="LC85">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>signed</span> <span>char</span>&gt;              : public true_type{};</td>
        </tr>
        <tr>
          <td id="L86" data-line-number="86"></td>
          <td id="LC86">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>signed</span> <span>char</span>&gt;        : public true_type{};</td>
        </tr>
        <tr>
          <td id="L87" data-line-number="87"></td>
          <td id="LC87">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>signed</span> <span>short</span>&gt;             : public true_type{};</td>
        </tr>
        <tr>
          <td id="L88" data-line-number="88"></td>
          <td id="LC88">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>signed</span> <span>short</span>&gt;       : public true_type{};</td>
        </tr>
        <tr>
          <td id="L89" data-line-number="89"></td>
          <td id="LC89">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>signed</span> <span>int</span>&gt;               : public true_type{};</td>
        </tr>
        <tr>
          <td id="L90" data-line-number="90"></td>
          <td id="LC90">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>signed</span> <span>int</span>&gt;         : public true_type{};</td>
        </tr>
        <tr>
          <td id="L91" data-line-number="91"></td>
          <td id="LC91">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>signed</span> <span>long</span>&gt;              : public true_type{};</td>
        </tr>
        <tr>
          <td id="L92" data-line-number="92"></td>
          <td id="LC92">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>signed</span> <span>long</span>&gt;        : public true_type{};</td>
        </tr>
        <tr>
          <td id="L93" data-line-number="93"></td>
          <td id="LC93">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>signed</span> <span>long</span> <span>long</span>&gt;         : public true_type{};</td>
        </tr>
        <tr>
          <td id="L94" data-line-number="94"></td>
          <td id="LC94">		<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>signed</span> <span>long</span> <span>long</span>&gt;   : public true_type{};</td>
        </tr>
        <tr>
          <td id="L95" data-line-number="95"></td>
          <td id="LC95">
</td>
        </tr>
        <tr>
          <td id="L96" data-line-number="96"></td>
          <td id="LC96">		#<span>if</span> (CHAR_MAX == SCHAR_MAX)</td>
        </tr>
        <tr>
          <td id="L97" data-line-number="97"></td>
          <td id="LC97">			<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>char</span>&gt;            : public true_type{};</td>
        </tr>
        <tr>
          <td id="L98" data-line-number="98"></td>
          <td id="LC98">			<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>char</span>&gt;      : public true_type{};</td>
        </tr>
        <tr>
          <td id="L99" data-line-number="99"></td>
          <td id="LC99">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L100" data-line-number="100"></td>
          <td id="LC100">		#<span>ifndef</span> EA_WCHAR_T_NON_NATIVE <span><span>//</span> If wchar_t is a native type instead of simply a define to an existing type...</span></td>
        </tr>
        <tr>
          <td id="L101" data-line-number="101"></td>
          <td id="LC101">			#<span>if</span> defined(__WCHAR_MAX__) &amp;&amp; ((__WCHAR_MAX__ == 2147483647) || (__WCHAR_MAX__ == 32767)) <span><span>//</span> GCC defines __WCHAR_MAX__ for most platforms.</span></td>
        </tr>
        <tr>
          <td id="L102" data-line-number="102"></td>
          <td id="LC102">				<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>wchar_t</span>&gt;         : public true_type{};</td>
        </tr>
        <tr>
          <td id="L103" data-line-number="103"></td>
          <td id="LC103">				<span>template </span>&lt;&gt; <span>struct</span> <span>is_signed</span>&lt;<span>const</span> <span>wchar_t</span>&gt;   : public true_type{};</td>
        </tr>
        <tr>
          <td id="L104" data-line-number="104"></td>
          <td id="LC104">			#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L105" data-line-number="105"></td>
          <td id="LC105">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L106" data-line-number="106"></td>
          <td id="LC106">	</td>
        </tr>
        <tr>
          <td id="L107" data-line-number="107"></td>
          <td id="LC107">		#<span>define</span> <span>bt_is_signed</span> helper::is_signed&lt;T&gt;::value</td>
        </tr>
        <tr>
          <td id="L108" data-line-number="108"></td>
          <td id="LC108">		</td>
        </tr>
        <tr>
          <td id="L109" data-line-number="109"></td>
          <td id="LC109">
</td>
        </tr>
        <tr>
          <td id="L110" data-line-number="110"></td>
          <td id="LC110">		<span><span>//</span>////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L111" data-line-number="111"></td>
          <td id="LC111">		<span><span>//</span> add_signed</span></td>
        </tr>
        <tr>
          <td id="L112" data-line-number="112"></td>
          <td id="LC112">		<span><span>//</span>////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L113" data-line-number="113"></td>
          <td id="LC113">		</td>
        </tr>
        <tr>
          <td id="L114" data-line-number="114"></td>
          <td id="LC114">		<span>template</span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L115" data-line-number="115"></td>
          <td id="LC115">		<span>struct</span> <span>add_signed</span></td>
        </tr>
        <tr>
          <td id="L116" data-line-number="116"></td>
          <td id="LC116">		{ <span>typedef</span> T type; };</td>
        </tr>
        <tr>
          <td id="L117" data-line-number="117"></td>
          <td id="LC117">
</td>
        </tr>
        <tr>
          <td id="L118" data-line-number="118"></td>
          <td id="LC118">		<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L119" data-line-number="119"></td>
          <td id="LC119">		<span>struct</span> <span>add_signed</span>&lt;<span>unsigned</span> <span>char</span>&gt;</td>
        </tr>
        <tr>
          <td id="L120" data-line-number="120"></td>
          <td id="LC120">		{ <span>typedef</span> <span>signed</span> <span>char</span> type; };</td>
        </tr>
        <tr>
          <td id="L121" data-line-number="121"></td>
          <td id="LC121">
</td>
        </tr>
        <tr>
          <td id="L122" data-line-number="122"></td>
          <td id="LC122">		#<span>if</span> (defined(CHAR_MAX) &amp;&amp; defined(UCHAR_MAX) &amp;&amp; (CHAR_MAX == UCHAR_MAX)) <span><span>//</span> If char is unsigned (which is usually not the case)...</span></td>
        </tr>
        <tr>
          <td id="L123" data-line-number="123"></td>
          <td id="LC123">			<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L124" data-line-number="124"></td>
          <td id="LC124">			<span>struct</span> <span>add_signed</span>&lt;<span>char</span>&gt;</td>
        </tr>
        <tr>
          <td id="L125" data-line-number="125"></td>
          <td id="LC125">			{ <span>typedef</span> <span>signed</span> <span>char</span> type; };</td>
        </tr>
        <tr>
          <td id="L126" data-line-number="126"></td>
          <td id="LC126">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L127" data-line-number="127"></td>
          <td id="LC127">
</td>
        </tr>
        <tr>
          <td id="L128" data-line-number="128"></td>
          <td id="LC128">		<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L129" data-line-number="129"></td>
          <td id="LC129">		<span>struct</span> <span>add_signed</span>&lt;<span>unsigned</span> <span>short</span>&gt;</td>
        </tr>
        <tr>
          <td id="L130" data-line-number="130"></td>
          <td id="LC130">		{ <span>typedef</span> <span>short</span> type; };</td>
        </tr>
        <tr>
          <td id="L131" data-line-number="131"></td>
          <td id="LC131">
</td>
        </tr>
        <tr>
          <td id="L132" data-line-number="132"></td>
          <td id="LC132">		<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L133" data-line-number="133"></td>
          <td id="LC133">		<span>struct</span> <span>add_signed</span>&lt;<span>unsigned</span> <span>int</span>&gt;</td>
        </tr>
        <tr>
          <td id="L134" data-line-number="134"></td>
          <td id="LC134">		{ <span>typedef</span> <span>int</span> type; };</td>
        </tr>
        <tr>
          <td id="L135" data-line-number="135"></td>
          <td id="LC135">
</td>
        </tr>
        <tr>
          <td id="L136" data-line-number="136"></td>
          <td id="LC136">		<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L137" data-line-number="137"></td>
          <td id="LC137">		<span>struct</span> <span>add_signed</span>&lt;<span>unsigned</span> <span>long</span>&gt;</td>
        </tr>
        <tr>
          <td id="L138" data-line-number="138"></td>
          <td id="LC138">		{ <span>typedef</span> <span>long</span> type; };</td>
        </tr>
        <tr>
          <td id="L139" data-line-number="139"></td>
          <td id="LC139">
</td>
        </tr>
        <tr>
          <td id="L140" data-line-number="140"></td>
          <td id="LC140">		<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L141" data-line-number="141"></td>
          <td id="LC141">		<span>struct</span> <span>add_signed</span>&lt;<span>unsigned</span> <span>long</span> <span>long</span>&gt;</td>
        </tr>
        <tr>
          <td id="L142" data-line-number="142"></td>
          <td id="LC142">		{ <span>typedef</span> <span>long</span> <span>long</span> type; };</td>
        </tr>
        <tr>
          <td id="L143" data-line-number="143"></td>
          <td id="LC143">
</td>
        </tr>
        <tr>
          <td id="L144" data-line-number="144"></td>
          <td id="LC144">		#<span>ifndef</span> EA_WCHAR_T_NON_NATIVE <span><span>//</span> If wchar_t is a native type instead of simply a define to an existing type...</span></td>
        </tr>
        <tr>
          <td id="L145" data-line-number="145"></td>
          <td id="LC145">			#<span>if</span> (defined(__WCHAR_MAX__) &amp;&amp; (__WCHAR_MAX__ == 4294967295U)) <span><span>//</span> If wchar_t is a 32 bit unsigned value...</span></td>
        </tr>
        <tr>
          <td id="L146" data-line-number="146"></td>
          <td id="LC146">				<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L147" data-line-number="147"></td>
          <td id="LC147">				<span>struct</span> <span>add_signed</span>&lt;<span>wchar_t</span>&gt;</td>
        </tr>
        <tr>
          <td id="L148" data-line-number="148"></td>
          <td id="LC148">				{ <span>typedef</span> <span>int32_t</span> type; };</td>
        </tr>
        <tr>
          <td id="L149" data-line-number="149"></td>
          <td id="LC149">			#<span>elif</span> (defined(__WCHAR_MAX__) &amp;&amp; (__WCHAR_MAX__ == 65535)) <span><span>//</span> If wchar_t is a 16 bit unsigned value...</span></td>
        </tr>
        <tr>
          <td id="L150" data-line-number="150"></td>
          <td id="LC150">				<span>template</span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L151" data-line-number="151"></td>
          <td id="LC151">				<span>struct</span> <span>add_signed</span>&lt;<span>wchar_t</span>&gt;</td>
        </tr>
        <tr>
          <td id="L152" data-line-number="152"></td>
          <td id="LC152">				{ <span>typedef</span> <span>int16_t</span> type; };</td>
        </tr>
        <tr>
          <td id="L153" data-line-number="153"></td>
          <td id="LC153">			#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L154" data-line-number="154"></td>
          <td id="LC154">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L155" data-line-number="155"></td>
          <td id="LC155">
</td>
        </tr>
        <tr>
          <td id="L156" data-line-number="156"></td>
          <td id="LC156">		#<span>define</span> <span>bt_signed</span> <span>typename</span> helper::add_signed&lt;T&gt;::type <span><span>//</span> Must be used as part of a cast, as in (bt_signed) or static_cast&lt;bt_signed&gt;()</span></td>
        </tr>
        <tr>
          <td id="L157" data-line-number="157"></td>
          <td id="LC157">	}</td>
        </tr>
        <tr>
          <td id="L158" data-line-number="158"></td>
          <td id="LC158">	</td>
        </tr>
        <tr>
          <td id="L159" data-line-number="159"></td>
          <td id="LC159">
</td>
        </tr>
        <tr>
          <td id="L160" data-line-number="160"></td>
          <td id="LC160">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L161" data-line-number="161"></td>
          <td id="LC161">	<span><span>//</span> Bit manipulation</span></td>
        </tr>
        <tr>
          <td id="L162" data-line-number="162"></td>
          <td id="LC162">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L163" data-line-number="163"></td>
          <td id="LC163">
</td>
        </tr>
        <tr>
          <td id="L164" data-line-number="164"></td>
          <td id="LC164">	<span><span>//</span>/ TurnOffLowestBit</span></td>
        </tr>
        <tr>
          <td id="L165" data-line-number="165"></td>
          <td id="LC165">	<span><span>//</span>/ How to turn off the lowest 1 bit in an integer.</span></td>
        </tr>
        <tr>
          <td id="L166" data-line-number="166"></td>
          <td id="LC166">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L167" data-line-number="167"></td>
          <td id="LC167">	<span><span>//</span>/ Works with signed and unsigned integers.</span></td>
        </tr>
        <tr>
          <td id="L168" data-line-number="168"></td>
          <td id="LC168">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L169" data-line-number="169"></td>
          <td id="LC169">	<span><span>//</span>/     01011000 -&gt; 01010000</span></td>
        </tr>
        <tr>
          <td id="L170" data-line-number="170"></td>
          <td id="LC170">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L171" data-line-number="171"></td>
          <td id="LC171">	<span>inline</span> T <span>TurnOffLowestBit</span>(T x){</td>
        </tr>
        <tr>
          <td id="L172" data-line-number="172"></td>
          <td id="LC172">		<span>return</span> (T)(x &amp; (x - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L173" data-line-number="173"></td>
          <td id="LC173">	}</td>
        </tr>
        <tr>
          <td id="L174" data-line-number="174"></td>
          <td id="LC174">
</td>
        </tr>
        <tr>
          <td id="L175" data-line-number="175"></td>
          <td id="LC175">	<span><span>//</span>/ IsolateLowestBit</span></td>
        </tr>
        <tr>
          <td id="L176" data-line-number="176"></td>
          <td id="LC176">	<span><span>//</span>/ How to isolate the lowest 1 bit.</span></td>
        </tr>
        <tr>
          <td id="L177" data-line-number="177"></td>
          <td id="LC177">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L178" data-line-number="178"></td>
          <td id="LC178">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L179" data-line-number="179"></td>
          <td id="LC179">	<span><span>//</span>/     01011000 -&gt; 00001000</span></td>
        </tr>
        <tr>
          <td id="L180" data-line-number="180"></td>
          <td id="LC180">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L181" data-line-number="181"></td>
          <td id="LC181">	<span>inline</span> T <span>IsolateLowestBit</span>(T x){</td>
        </tr>
        <tr>
          <td id="L182" data-line-number="182"></td>
          <td id="LC182">		<span>return</span> (T)(x &amp; (<span>0</span> - x));</td>
        </tr>
        <tr>
          <td id="L183" data-line-number="183"></td>
          <td id="LC183">	}</td>
        </tr>
        <tr>
          <td id="L184" data-line-number="184"></td>
          <td id="LC184">
</td>
        </tr>
        <tr>
          <td id="L185" data-line-number="185"></td>
          <td id="LC185">	<span><span>//</span>/ IsolateLowest0Bit</span></td>
        </tr>
        <tr>
          <td id="L186" data-line-number="186"></td>
          <td id="LC186">	<span><span>//</span>/ How to isolate the lowest 0 bit.</span></td>
        </tr>
        <tr>
          <td id="L187" data-line-number="187"></td>
          <td id="LC187">	<span><span>//</span>/ Returns 0 for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L188" data-line-number="188"></td>
          <td id="LC188">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L189" data-line-number="189"></td>
          <td id="LC189">	<span><span>//</span>/     10100111 -&gt; 00001000</span></td>
        </tr>
        <tr>
          <td id="L190" data-line-number="190"></td>
          <td id="LC190">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L191" data-line-number="191"></td>
          <td id="LC191">	<span>inline</span> T <span>IsolateLowest0Bit</span>(T x){</td>
        </tr>
        <tr>
          <td id="L192" data-line-number="192"></td>
          <td id="LC192">		<span>return</span> (T)(~x &amp; (x + <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L193" data-line-number="193"></td>
          <td id="LC193">	}</td>
        </tr>
        <tr>
          <td id="L194" data-line-number="194"></td>
          <td id="LC194">
</td>
        </tr>
        <tr>
          <td id="L195" data-line-number="195"></td>
          <td id="LC195">	<span><span>//</span>/ GetTrailing0Bits</span></td>
        </tr>
        <tr>
          <td id="L196" data-line-number="196"></td>
          <td id="LC196">	<span><span>//</span>/ How to produce a mask of all low zeroes.</span></td>
        </tr>
        <tr>
          <td id="L197" data-line-number="197"></td>
          <td id="LC197">	<span><span>//</span>/ Returns 0 for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L198" data-line-number="198"></td>
          <td id="LC198">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L199" data-line-number="199"></td>
          <td id="LC199">	<span><span>//</span>/     01011000 -&gt; 00000111</span></td>
        </tr>
        <tr>
          <td id="L200" data-line-number="200"></td>
          <td id="LC200">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L201" data-line-number="201"></td>
          <td id="LC201">	<span>inline</span> T <span>GetTrailing0Bits</span>(T x){</td>
        </tr>
        <tr>
          <td id="L202" data-line-number="202"></td>
          <td id="LC202">		<span>return</span> (T)(~x &amp; (x - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L203" data-line-number="203"></td>
          <td id="LC203">	}</td>
        </tr>
        <tr>
          <td id="L204" data-line-number="204"></td>
          <td id="LC204">
</td>
        </tr>
        <tr>
          <td id="L205" data-line-number="205"></td>
          <td id="LC205">	<span><span>//</span>/ GetTrailing1And0Bits</span></td>
        </tr>
        <tr>
          <td id="L206" data-line-number="206"></td>
          <td id="LC206">	<span><span>//</span>/ How to produce a mask of lowest 1 bit and all lower zeroes.</span></td>
        </tr>
        <tr>
          <td id="L207" data-line-number="207"></td>
          <td id="LC207">	<span><span>//</span>/ Returns all bits set for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L208" data-line-number="208"></td>
          <td id="LC208">	<span><span>//</span>/ Returns 1 for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L209" data-line-number="209"></td>
          <td id="LC209">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L210" data-line-number="210"></td>
          <td id="LC210">	<span><span>//</span>/     01011000 -&gt; 00001111</span></td>
        </tr>
        <tr>
          <td id="L211" data-line-number="211"></td>
          <td id="LC211">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L212" data-line-number="212"></td>
          <td id="LC212">	<span>inline</span> T <span>GetTrailing1And0Bits</span>(T x){</td>
        </tr>
        <tr>
          <td id="L213" data-line-number="213"></td>
          <td id="LC213">		<span>return</span> (T)(x ^ (x - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L214" data-line-number="214"></td>
          <td id="LC214">	}</td>
        </tr>
        <tr>
          <td id="L215" data-line-number="215"></td>
          <td id="LC215">
</td>
        </tr>
        <tr>
          <td id="L216" data-line-number="216"></td>
          <td id="LC216">	<span><span>//</span>/ PropogateLowestBitDownward</span></td>
        </tr>
        <tr>
          <td id="L217" data-line-number="217"></td>
          <td id="LC217">	<span><span>//</span>/ How to propogate the lowest 1 bit downward.</span></td>
        </tr>
        <tr>
          <td id="L218" data-line-number="218"></td>
          <td id="LC218">	<span><span>//</span>/ Returns all bits set for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L219" data-line-number="219"></td>
          <td id="LC219">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L220" data-line-number="220"></td>
          <td id="LC220">	<span><span>//</span>/     01011000 -&gt; 01011111</span></td>
        </tr>
        <tr>
          <td id="L221" data-line-number="221"></td>
          <td id="LC221">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L222" data-line-number="222"></td>
          <td id="LC222">	<span>inline</span> T <span>PropogateLowestBitDownward</span>(T x){</td>
        </tr>
        <tr>
          <td id="L223" data-line-number="223"></td>
          <td id="LC223">		<span>return</span> (T)(x | (x - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L224" data-line-number="224"></td>
          <td id="LC224">	}</td>
        </tr>
        <tr>
          <td id="L225" data-line-number="225"></td>
          <td id="LC225">
</td>
        </tr>
        <tr>
          <td id="L226" data-line-number="226"></td>
          <td id="LC226">	<span><span>//</span>/ TurnOffLowestContiguousBits</span></td>
        </tr>
        <tr>
          <td id="L227" data-line-number="227"></td>
          <td id="LC227">	<span><span>//</span>/ How to turn off the lowest contiguous string of 1 bits.</span></td>
        </tr>
        <tr>
          <td id="L228" data-line-number="228"></td>
          <td id="LC228">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L229" data-line-number="229"></td>
          <td id="LC229">	<span><span>//</span>/ Returns 0 for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L230" data-line-number="230"></td>
          <td id="LC230">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L231" data-line-number="231"></td>
          <td id="LC231">	<span><span>//</span>/     01011000 -&gt; 01000000</span></td>
        </tr>
        <tr>
          <td id="L232" data-line-number="232"></td>
          <td id="LC232">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L233" data-line-number="233"></td>
          <td id="LC233">	<span>inline</span> T <span>TurnOffLowestContiguousBits</span>(T x){</td>
        </tr>
        <tr>
          <td id="L234" data-line-number="234"></td>
          <td id="LC234">		<span>return</span> (T)(((x | (x - <span>1</span>)) + <span>1</span>) &amp; x);</td>
        </tr>
        <tr>
          <td id="L235" data-line-number="235"></td>
          <td id="LC235">	}</td>
        </tr>
        <tr>
          <td id="L236" data-line-number="236"></td>
          <td id="LC236">
</td>
        </tr>
        <tr>
          <td id="L237" data-line-number="237"></td>
          <td id="LC237">	<span><span>//</span>/ TurnOnLowest0Bit</span></td>
        </tr>
        <tr>
          <td id="L238" data-line-number="238"></td>
          <td id="LC238">	<span><span>//</span>/ How to turn off the lowest 0 bit in an integer.</span></td>
        </tr>
        <tr>
          <td id="L239" data-line-number="239"></td>
          <td id="LC239">	<span><span>//</span>/ Returns all bits set for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L240" data-line-number="240"></td>
          <td id="LC240">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L241" data-line-number="241"></td>
          <td id="LC241">	<span><span>//</span>/     10100111 -&gt; 10101111</span></td>
        </tr>
        <tr>
          <td id="L242" data-line-number="242"></td>
          <td id="LC242">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L243" data-line-number="243"></td>
          <td id="LC243">	<span>inline</span> T <span>TurnOnLowest0Bit</span>(T x){</td>
        </tr>
        <tr>
          <td id="L244" data-line-number="244"></td>
          <td id="LC244">		<span>return</span> (T)(x | (x + <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L245" data-line-number="245"></td>
          <td id="LC245">	}</td>
        </tr>
        <tr>
          <td id="L246" data-line-number="246"></td>
          <td id="LC246">
</td>
        </tr>
        <tr>
          <td id="L247" data-line-number="247"></td>
          <td id="LC247">	<span><span>//</span>/ GetNextWithEqualBitCount</span></td>
        </tr>
        <tr>
          <td id="L248" data-line-number="248"></td>
          <td id="LC248">	<span><span>//</span>/ How to get the next higher integer with the same number of bits set.</span></td>
        </tr>
        <tr>
          <td id="L249" data-line-number="249"></td>
          <td id="LC249">	<span><span>//</span>/ This function is supposed (claim by original author) to be able to </span></td>
        </tr>
        <tr>
          <td id="L250" data-line-number="250"></td>
          <td id="LC250">	<span><span>//</span>/ wrap around and continue properly, but testing indicates otherwise.</span></td>
        </tr>
        <tr>
          <td id="L251" data-line-number="251"></td>
          <td id="LC251">	<span><span>//</span>/ Do not call this with x = 0; as that causes a divide by 0.</span></td>
        </tr>
        <tr>
          <td id="L252" data-line-number="252"></td>
          <td id="LC252">	<span><span>//</span>/ Doesn&#39;t work for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L253" data-line-number="253"></td>
          <td id="LC253">	<span><span>//</span>/ Do not assign the result of this to a type of less size than the input argument.</span></td>
        </tr>
        <tr>
          <td id="L254" data-line-number="254"></td>
          <td id="LC254">	<span><span>//</span>/ This function has certain real-world applications.</span></td>
        </tr>
        <tr>
          <td id="L255" data-line-number="255"></td>
          <td id="LC255">	<span><span>//</span>/ This function has been called &#39;snoob&#39; by some. </span></td>
        </tr>
        <tr>
          <td id="L256" data-line-number="256"></td>
          <td id="LC256">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L257" data-line-number="257"></td>
          <td id="LC257">	<span><span>//</span>/     01010110 -&gt; 01011001</span></td>
        </tr>
        <tr>
          <td id="L258" data-line-number="258"></td>
          <td id="LC258">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L259" data-line-number="259"></td>
          <td id="LC259">	<span>inline</span> T <span>GetNextWithEqualBitCount</span>(T x){</td>
        </tr>
        <tr>
          <td id="L260" data-line-number="260"></td>
          <td id="LC260">		T smallest, ripple, ones;</td>
        </tr>
        <tr>
          <td id="L261" data-line-number="261"></td>
          <td id="LC261">
</td>
        </tr>
        <tr>
          <td id="L262" data-line-number="262"></td>
          <td id="LC262">		smallest = x &amp; -(bt_signed)x;</td>
        </tr>
        <tr>
          <td id="L263" data-line-number="263"></td>
          <td id="LC263">		ripple   = x + smallest;</td>
        </tr>
        <tr>
          <td id="L264" data-line-number="264"></td>
          <td id="LC264">		ones     = x ^ ripple;</td>
        </tr>
        <tr>
          <td id="L265" data-line-number="265"></td>
          <td id="LC265">		ones     = (ones &gt;&gt; <span>2</span>) / smallest;</td>
        </tr>
        <tr>
          <td id="L266" data-line-number="266"></td>
          <td id="LC266">		<span>return</span> ripple | ones;</td>
        </tr>
        <tr>
          <td id="L267" data-line-number="267"></td>
          <td id="LC267">	}</td>
        </tr>
        <tr>
          <td id="L268" data-line-number="268"></td>
          <td id="LC268">
</td>
        </tr>
        <tr>
          <td id="L269" data-line-number="269"></td>
          <td id="LC269">
</td>
        </tr>
        <tr>
          <td id="L270" data-line-number="270"></td>
          <td id="LC270">	<span><span>//</span>/ IsolateSingleBits</span></td>
        </tr>
        <tr>
          <td id="L271" data-line-number="271"></td>
          <td id="LC271">	<span><span>//</span>/ How to isolate single bits in an integer.</span></td>
        </tr>
        <tr>
          <td id="L272" data-line-number="272"></td>
          <td id="LC272">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L273" data-line-number="273"></td>
          <td id="LC273">	<span><span>//</span>/        10101011 -&gt; 10101000</span></td>
        </tr>
        <tr>
          <td id="L274" data-line-number="274"></td>
          <td id="LC274">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L275" data-line-number="275"></td>
          <td id="LC275">	<span>inline</span> T <span>IsolateSingleBits</span>(T x){</td>
        </tr>
        <tr>
          <td id="L276" data-line-number="276"></td>
          <td id="LC276">		<span>return</span> x &amp; ~((x &lt;&lt; <span>1</span>) | (x &gt;&gt; <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L277" data-line-number="277"></td>
          <td id="LC277">	}</td>
        </tr>
        <tr>
          <td id="L278" data-line-number="278"></td>
          <td id="LC278">
</td>
        </tr>
        <tr>
          <td id="L279" data-line-number="279"></td>
          <td id="LC279">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L280" data-line-number="280"></td>
          <td id="LC280">	<span>inline</span> T <span>IsolateSingle0Bits</span>(T x){</td>
        </tr>
        <tr>
          <td id="L281" data-line-number="281"></td>
          <td id="LC281">		<span>return</span> <span>IsolateSingleBits</span>(~x);</td>
        </tr>
        <tr>
          <td id="L282" data-line-number="282"></td>
          <td id="LC282">	}</td>
        </tr>
        <tr>
          <td id="L283" data-line-number="283"></td>
          <td id="LC283">
</td>
        </tr>
        <tr>
          <td id="L284" data-line-number="284"></td>
          <td id="LC284">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L285" data-line-number="285"></td>
          <td id="LC285">	<span>inline</span> T <span>IsolateSingle0And1Bits</span>(T x){</td>
        </tr>
        <tr>
          <td id="L286" data-line-number="286"></td>
          <td id="LC286">		<span>return</span> (x ^ (x &lt;&lt; <span>1</span>)) &amp; (x ^ (x &gt;&gt; <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L287" data-line-number="287"></td>
          <td id="LC287">	}</td>
        </tr>
        <tr>
          <td id="L288" data-line-number="288"></td>
          <td id="LC288">
</td>
        </tr>
        <tr>
          <td id="L289" data-line-number="289"></td>
          <td id="LC289">	<span><span>//</span>/ ShiftRightSigned</span></td>
        </tr>
        <tr>
          <td id="L290" data-line-number="290"></td>
          <td id="LC290">	<span><span>//</span>/ How to do a signed right shift portably.</span></td>
        </tr>
        <tr>
          <td id="L291" data-line-number="291"></td>
          <td id="LC291">	<span><span>//</span>/ Some platform/compiler combinations don&#39;t support sign extension </span></td>
        </tr>
        <tr>
          <td id="L292" data-line-number="292"></td>
          <td id="LC292">	<span><span>//</span>/ with right shifts of signed values. The C language standard doesn&#39;t </span></td>
        </tr>
        <tr>
          <td id="L293" data-line-number="293"></td>
          <td id="LC293">	<span><span>//</span>/ guarantee such functionality. Most advanced CPUs and nearly all C </span></td>
        </tr>
        <tr>
          <td id="L294" data-line-number="294"></td>
          <td id="LC294">	<span><span>//</span>/ compilers support this. Weak embedded processors may possibly not.</span></td>
        </tr>
        <tr>
          <td id="L295" data-line-number="295"></td>
          <td id="LC295">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L296" data-line-number="296"></td>
          <td id="LC296">	<span><span>//</span>/     10000000 - by 2-&gt; 11100000</span></td>
        </tr>
        <tr>
          <td id="L297" data-line-number="297"></td>
          <td id="LC297">	<span><span>//</span>/     00000000 - by 2-&gt; 00000000</span></td>
        </tr>
        <tr>
          <td id="L298" data-line-number="298"></td>
          <td id="LC298">	<span>inline</span> <span>int32_t</span> <span>ShiftRightSigned</span>(<span>int32_t</span> x, <span>uint32_t</span> n){</td>
        </tr>
        <tr>
          <td id="L299" data-line-number="299"></td>
          <td id="LC299">		<span>return</span> <span>int32_t</span>((((<span>uint32_t</span>)x + <span>UINT32_C</span>(<span>0x80000000</span>)) &gt;&gt; n) - (<span>UINT32_C</span>(<span>0x80000000</span>) &gt;&gt; n));</td>
        </tr>
        <tr>
          <td id="L300" data-line-number="300"></td>
          <td id="LC300">	}</td>
        </tr>
        <tr>
          <td id="L301" data-line-number="301"></td>
          <td id="LC301">
</td>
        </tr>
        <tr>
          <td id="L302" data-line-number="302"></td>
          <td id="LC302">	<span>inline</span> <span>int64_t</span> <span>ShiftRightSigned</span>(<span>int64_t</span> x, <span>uint64_t</span> n){</td>
        </tr>
        <tr>
          <td id="L303" data-line-number="303"></td>
          <td id="LC303">		<span>return</span> <span>int64_t</span>((((<span>uint64_t</span>)x + <span>UINT64_C</span>(<span>0x8000000000000000</span>)) &gt;&gt; n) - (<span>UINT64_C</span>(<span>0x8000000000000000</span>) &gt;&gt; n));</td>
        </tr>
        <tr>
          <td id="L304" data-line-number="304"></td>
          <td id="LC304">	}</td>
        </tr>
        <tr>
          <td id="L305" data-line-number="305"></td>
          <td id="LC305">
</td>
        </tr>
        <tr>
          <td id="L306" data-line-number="306"></td>
          <td id="LC306">	<span><span>//</span>/ CountTrailing0Bits</span></td>
        </tr>
        <tr>
          <td id="L307" data-line-number="307"></td>
          <td id="LC307">	<span><span>//</span>/ How to count the number of trailing zeroes in an unsigned 32 bit integer.</span></td>
        </tr>
        <tr>
          <td id="L308" data-line-number="308"></td>
          <td id="LC308">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L309" data-line-number="309"></td>
          <td id="LC309">	<span><span>//</span>/     ...10101000 -&gt; 3</span></td>
        </tr>
        <tr>
          <td id="L310" data-line-number="310"></td>
          <td id="LC310">	<span><span>//</span>/     ...11111111 -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L311" data-line-number="311"></td>
          <td id="LC311">	<span><span>//</span>/     ...00000000 -&gt; 32</span></td>
        </tr>
        <tr>
          <td id="L312" data-line-number="312"></td>
          <td id="LC312">	<span>inline</span> <span>int</span> <span>CountTrailing0Bits</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L313" data-line-number="313"></td>
          <td id="LC313">		#<span>if</span> defined(EA_COMPILER_MSVC) &amp;&amp; (defined(EA_PROCESSOR_X86) || defined(EA_PROCESSOR_X86_64))</td>
        </tr>
        <tr>
          <td id="L314" data-line-number="314"></td>
          <td id="LC314">			<span><span>//</span> This has been benchmarked as significantly faster than the generic code below.</span></td>
        </tr>
        <tr>
          <td id="L315" data-line-number="315"></td>
          <td id="LC315">			<span>unsigned</span> <span>char</span> isNonZero;</td>
        </tr>
        <tr>
          <td id="L316" data-line-number="316"></td>
          <td id="LC316">			<span>unsigned</span> <span>long</span> <span>index</span>;</td>
        </tr>
        <tr>
          <td id="L317" data-line-number="317"></td>
          <td id="LC317">			isNonZero = <span>_BitScanForward</span>(&amp;<span>index</span>, x);</td>
        </tr>
        <tr>
          <td id="L318" data-line-number="318"></td>
          <td id="LC318">			<span>return</span> isNonZero ? (<span>int</span>)<span>index</span> : <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L319" data-line-number="319"></td>
          <td id="LC319">		#<span>elif</span> defined(EA_COMPILER_GNUC) &amp;&amp; !defined(EA_COMPILER_EDG)</td>
        </tr>
        <tr>
          <td id="L320" data-line-number="320"></td>
          <td id="LC320">			<span>if</span>(x)</td>
        </tr>
        <tr>
          <td id="L321" data-line-number="321"></td>
          <td id="LC321">				<span>return</span> <span>__builtin_ctz</span>(x);</td>
        </tr>
        <tr>
          <td id="L322" data-line-number="322"></td>
          <td id="LC322">			<span>return</span> <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L323" data-line-number="323"></td>
          <td id="LC323">		#<span>else</span></td>
        </tr>
        <tr>
          <td id="L324" data-line-number="324"></td>
          <td id="LC324">			<span>if</span>(x){</td>
        </tr>
        <tr>
          <td id="L325" data-line-number="325"></td>
          <td id="LC325">				<span>int</span> n = <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L326" data-line-number="326"></td>
          <td id="LC326">				<span>if</span>((x &amp; <span>0x0000FFFF</span>) == <span>0</span>) {n += <span>16</span>; x &gt;&gt;= <span>16</span>;}</td>
        </tr>
        <tr>
          <td id="L327" data-line-number="327"></td>
          <td id="LC327">				<span>if</span>((x &amp; <span>0x000000FF</span>) == <span>0</span>) {n +=  <span>8</span>; x &gt;&gt;=  <span>8</span>;}</td>
        </tr>
        <tr>
          <td id="L328" data-line-number="328"></td>
          <td id="LC328">				<span>if</span>((x &amp; <span>0x0000000F</span>) == <span>0</span>) {n +=  <span>4</span>; x &gt;&gt;=  <span>4</span>;}</td>
        </tr>
        <tr>
          <td id="L329" data-line-number="329"></td>
          <td id="LC329">				<span>if</span>((x &amp; <span>0x00000003</span>) == <span>0</span>) {n +=  <span>2</span>; x &gt;&gt;=  <span>2</span>;}</td>
        </tr>
        <tr>
          <td id="L330" data-line-number="330"></td>
          <td id="LC330">				<span>return</span> n - <span>int</span>(x &amp; <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L331" data-line-number="331"></td>
          <td id="LC331">			}</td>
        </tr>
        <tr>
          <td id="L332" data-line-number="332"></td>
          <td id="LC332">			<span>return</span> <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L333" data-line-number="333"></td>
          <td id="LC333">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L334" data-line-number="334"></td>
          <td id="LC334">	}</td>
        </tr>
        <tr>
          <td id="L335" data-line-number="335"></td>
          <td id="LC335">
</td>
        </tr>
        <tr>
          <td id="L336" data-line-number="336"></td>
          <td id="LC336">	<span><span>//</span>/ CountTrailing0Bits</span></td>
        </tr>
        <tr>
          <td id="L337" data-line-number="337"></td>
          <td id="LC337">	<span><span>//</span>/ How to count the number of trailing zeroes in an unsigned 64 bit integer.</span></td>
        </tr>
        <tr>
          <td id="L338" data-line-number="338"></td>
          <td id="LC338">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L339" data-line-number="339"></td>
          <td id="LC339">	<span><span>//</span>/     ...10101000 -&gt; 3</span></td>
        </tr>
        <tr>
          <td id="L340" data-line-number="340"></td>
          <td id="LC340">	<span><span>//</span>/     ...11111111 -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L341" data-line-number="341"></td>
          <td id="LC341">	<span><span>//</span>/     ...00000000 -&gt; 64</span></td>
        </tr>
        <tr>
          <td id="L342" data-line-number="342"></td>
          <td id="LC342">	<span>inline</span> <span>int</span> <span>CountTrailing0Bits</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L343" data-line-number="343"></td>
          <td id="LC343">		#<span>if</span> defined(EA_COMPILER_MSVC) &amp;&amp; defined(EA_PROCESSOR_X86_64)</td>
        </tr>
        <tr>
          <td id="L344" data-line-number="344"></td>
          <td id="LC344">			<span><span>//</span> This has been benchmarked as significantly faster than the generic code below.</span></td>
        </tr>
        <tr>
          <td id="L345" data-line-number="345"></td>
          <td id="LC345">			<span>unsigned</span> <span>char</span> isNonZero;</td>
        </tr>
        <tr>
          <td id="L346" data-line-number="346"></td>
          <td id="LC346">			<span>unsigned</span> <span>long</span> <span>index</span>;</td>
        </tr>
        <tr>
          <td id="L347" data-line-number="347"></td>
          <td id="LC347">			isNonZero = <span>_BitScanForward64</span>(&amp;<span>index</span>, x);</td>
        </tr>
        <tr>
          <td id="L348" data-line-number="348"></td>
          <td id="LC348">			<span>return</span> isNonZero ? (<span>int</span>)<span>index</span> : <span>64</span>;</td>
        </tr>
        <tr>
          <td id="L349" data-line-number="349"></td>
          <td id="LC349">		#<span>elif</span> defined(EA_COMPILER_GNUC) &amp;&amp; !defined(EA_COMPILER_EDG)</td>
        </tr>
        <tr>
          <td id="L350" data-line-number="350"></td>
          <td id="LC350">			<span>if</span>(x)</td>
        </tr>
        <tr>
          <td id="L351" data-line-number="351"></td>
          <td id="LC351">				<span>return</span> <span>__builtin_ctzll</span>(x);</td>
        </tr>
        <tr>
          <td id="L352" data-line-number="352"></td>
          <td id="LC352">			<span>return</span> <span>64</span>;</td>
        </tr>
        <tr>
          <td id="L353" data-line-number="353"></td>
          <td id="LC353">		#<span>else</span></td>
        </tr>
        <tr>
          <td id="L354" data-line-number="354"></td>
          <td id="LC354">			<span>if</span>(x){</td>
        </tr>
        <tr>
          <td id="L355" data-line-number="355"></td>
          <td id="LC355">				<span>int</span> n = <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L356" data-line-number="356"></td>
          <td id="LC356">				<span>if</span>((x &amp; <span>0xFFFFFFFF</span>) == <span>0</span>) { n += <span>32</span>; x &gt;&gt;= <span>32</span>; }</td>
        </tr>
        <tr>
          <td id="L357" data-line-number="357"></td>
          <td id="LC357">				<span>if</span>((x &amp; <span>0x0000FFFF</span>) == <span>0</span>) { n += <span>16</span>; x &gt;&gt;= <span>16</span>; }</td>
        </tr>
        <tr>
          <td id="L358" data-line-number="358"></td>
          <td id="LC358">				<span>if</span>((x &amp; <span>0x000000FF</span>) == <span>0</span>) { n +=  <span>8</span>; x &gt;&gt;=  <span>8</span>; }</td>
        </tr>
        <tr>
          <td id="L359" data-line-number="359"></td>
          <td id="LC359">				<span>if</span>((x &amp; <span>0x0000000F</span>) == <span>0</span>) { n +=  <span>4</span>; x &gt;&gt;=  <span>4</span>; }</td>
        </tr>
        <tr>
          <td id="L360" data-line-number="360"></td>
          <td id="LC360">				<span>if</span>((x &amp; <span>0x00000003</span>) == <span>0</span>) { n +=  <span>2</span>; x &gt;&gt;=  <span>2</span>; }</td>
        </tr>
        <tr>
          <td id="L361" data-line-number="361"></td>
          <td id="LC361">				<span>return</span> n - (<span>int</span>)(<span>unsigned</span>)(x &amp; <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L362" data-line-number="362"></td>
          <td id="LC362">			}</td>
        </tr>
        <tr>
          <td id="L363" data-line-number="363"></td>
          <td id="LC363">			<span>return</span> <span>64</span>;</td>
        </tr>
        <tr>
          <td id="L364" data-line-number="364"></td>
          <td id="LC364">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L365" data-line-number="365"></td>
          <td id="LC365">	}</td>
        </tr>
        <tr>
          <td id="L366" data-line-number="366"></td>
          <td id="LC366">
</td>
        </tr>
        <tr>
          <td id="L367" data-line-number="367"></td>
          <td id="LC367">	<span><span>//</span>/ CountLeading0Bits</span></td>
        </tr>
        <tr>
          <td id="L368" data-line-number="368"></td>
          <td id="LC368">	<span><span>//</span>/ How to count the number of leading zeroes in an unsigned integer.</span></td>
        </tr>
        <tr>
          <td id="L369" data-line-number="369"></td>
          <td id="LC369">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L370" data-line-number="370"></td>
          <td id="LC370">	<span><span>//</span>/   ..00000000 -&gt; 32</span></td>
        </tr>
        <tr>
          <td id="L371" data-line-number="371"></td>
          <td id="LC371">	<span><span>//</span>/     00110111 -&gt;  2</span></td>
        </tr>
        <tr>
          <td id="L372" data-line-number="372"></td>
          <td id="LC372">	<span><span>//</span>/     11111111 -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L373" data-line-number="373"></td>
          <td id="LC373">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L374" data-line-number="374"></td>
          <td id="LC374">	<span>inline</span> <span>int</span> <span>CountLeading0Bits</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L375" data-line-number="375"></td>
          <td id="LC375">		#<span>if</span> defined(EA_COMPILER_MSVC) &amp;&amp; (defined(EA_PROCESSOR_X86) || defined(EA_PROCESSOR_X86_64))</td>
        </tr>
        <tr>
          <td id="L376" data-line-number="376"></td>
          <td id="LC376">			<span><span>//</span> This has been benchmarked as significantly faster than the generic code below.</span></td>
        </tr>
        <tr>
          <td id="L377" data-line-number="377"></td>
          <td id="LC377">			<span>unsigned</span> <span>char</span> isNonZero;</td>
        </tr>
        <tr>
          <td id="L378" data-line-number="378"></td>
          <td id="LC378">			<span>unsigned</span> <span>long</span> <span>index</span>;</td>
        </tr>
        <tr>
          <td id="L379" data-line-number="379"></td>
          <td id="LC379">			isNonZero = <span>_BitScanReverse</span>(&amp;<span>index</span>, x);</td>
        </tr>
        <tr>
          <td id="L380" data-line-number="380"></td>
          <td id="LC380">			<span>return</span> isNonZero ? (<span>31</span> - (<span>int</span>)<span>index</span>) : <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L381" data-line-number="381"></td>
          <td id="LC381">		#<span>elif</span> defined(EA_COMPILER_GNUC) &amp;&amp; !defined(EA_COMPILER_EDG)</td>
        </tr>
        <tr>
          <td id="L382" data-line-number="382"></td>
          <td id="LC382">			<span>if</span>(x)</td>
        </tr>
        <tr>
          <td id="L383" data-line-number="383"></td>
          <td id="LC383">				<span>return</span> <span>__builtin_clz</span>(x);</td>
        </tr>
        <tr>
          <td id="L384" data-line-number="384"></td>
          <td id="LC384">			<span>return</span> <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L385" data-line-number="385"></td>
          <td id="LC385">		#<span>else</span></td>
        </tr>
        <tr>
          <td id="L386" data-line-number="386"></td>
          <td id="LC386">			<span><span>//</span>/ This implementation isn&#39;t highly compact, but would likely be </span></td>
        </tr>
        <tr>
          <td id="L387" data-line-number="387"></td>
          <td id="LC387">			<span><span>//</span>/ faster than a brute force solution.</span></td>
        </tr>
        <tr>
          <td id="L388" data-line-number="388"></td>
          <td id="LC388">			<span><span>//</span>/ x86 function which is claimed to be faster:</span></td>
        </tr>
        <tr>
          <td id="L389" data-line-number="389"></td>
          <td id="LC389">			<span><span>//</span>/    double ff = (double)(v|1);</span></td>
        </tr>
        <tr>
          <td id="L390" data-line-number="390"></td>
          <td id="LC390">			<span><span>//</span>/    return ((*(1+(unsigned long *)&amp;ff))&gt;&gt;20)-1023;</span></td>
        </tr>
        <tr>
          <td id="L391" data-line-number="391"></td>
          <td id="LC391">			<span>if</span>(x){</td>
        </tr>
        <tr>
          <td id="L392" data-line-number="392"></td>
          <td id="LC392">				<span>int</span> n = <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L393" data-line-number="393"></td>
          <td id="LC393">				<span>if</span>(x &lt;= <span>0x0000FFFF</span>) { n += <span>16</span>; x &lt;&lt;= <span>16</span>; }</td>
        </tr>
        <tr>
          <td id="L394" data-line-number="394"></td>
          <td id="LC394">				<span>if</span>(x &lt;= <span>0x00FFFFFF</span>) { n +=  <span>8</span>; x &lt;&lt;=  <span>8</span>; }</td>
        </tr>
        <tr>
          <td id="L395" data-line-number="395"></td>
          <td id="LC395">				<span>if</span>(x &lt;= <span>0x0FFFFFFF</span>) { n +=  <span>4</span>; x &lt;&lt;=  <span>4</span>; }</td>
        </tr>
        <tr>
          <td id="L396" data-line-number="396"></td>
          <td id="LC396">				<span>if</span>(x &lt;= <span>0x3FFFFFFF</span>) { n +=  <span>2</span>; x &lt;&lt;=  <span>2</span>; }</td>
        </tr>
        <tr>
          <td id="L397" data-line-number="397"></td>
          <td id="LC397">				<span>if</span>(x &lt;= <span>0x7FFFFFFF</span>) { n +=  <span>1</span>;           }</td>
        </tr>
        <tr>
          <td id="L398" data-line-number="398"></td>
          <td id="LC398">				<span>return</span> n;</td>
        </tr>
        <tr>
          <td id="L399" data-line-number="399"></td>
          <td id="LC399">			}</td>
        </tr>
        <tr>
          <td id="L400" data-line-number="400"></td>
          <td id="LC400">			<span>return</span> <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L401" data-line-number="401"></td>
          <td id="LC401">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L402" data-line-number="402"></td>
          <td id="LC402">	}</td>
        </tr>
        <tr>
          <td id="L403" data-line-number="403"></td>
          <td id="LC403">
</td>
        </tr>
        <tr>
          <td id="L404" data-line-number="404"></td>
          <td id="LC404">	<span><span>//</span>/ CountLeading0Bits</span></td>
        </tr>
        <tr>
          <td id="L405" data-line-number="405"></td>
          <td id="LC405">	<span><span>//</span>/ How to count the number of leading zeroes in an unsigned integer.</span></td>
        </tr>
        <tr>
          <td id="L406" data-line-number="406"></td>
          <td id="LC406">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L407" data-line-number="407"></td>
          <td id="LC407">	<span><span>//</span>/   ..00000000 -&gt; 64</span></td>
        </tr>
        <tr>
          <td id="L408" data-line-number="408"></td>
          <td id="LC408">	<span><span>//</span>/   ..00110111 -&gt;  2</span></td>
        </tr>
        <tr>
          <td id="L409" data-line-number="409"></td>
          <td id="LC409">	<span><span>//</span>/   ..11111111 -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L410" data-line-number="410"></td>
          <td id="LC410">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L411" data-line-number="411"></td>
          <td id="LC411">	<span>inline</span> <span>int</span> <span>CountLeading0Bits</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L412" data-line-number="412"></td>
          <td id="LC412">		#<span>if</span> defined(EA_COMPILER_MSVC) &amp;&amp; defined(EA_PROCESSOR_X86_64)</td>
        </tr>
        <tr>
          <td id="L413" data-line-number="413"></td>
          <td id="LC413">			<span><span>//</span> This has been benchmarked as significantly faster than the generic code below.</span></td>
        </tr>
        <tr>
          <td id="L414" data-line-number="414"></td>
          <td id="LC414">			<span>unsigned</span> <span>char</span> isNonZero;</td>
        </tr>
        <tr>
          <td id="L415" data-line-number="415"></td>
          <td id="LC415">			<span>unsigned</span> <span>long</span> <span>index</span>;</td>
        </tr>
        <tr>
          <td id="L416" data-line-number="416"></td>
          <td id="LC416">			isNonZero = <span>_BitScanReverse64</span>(&amp;<span>index</span>, x);</td>
        </tr>
        <tr>
          <td id="L417" data-line-number="417"></td>
          <td id="LC417">			<span>return</span> isNonZero ? (<span>63</span> - (<span>int</span>)<span>index</span>) : <span>64</span>;</td>
        </tr>
        <tr>
          <td id="L418" data-line-number="418"></td>
          <td id="LC418">		#<span>elif</span> defined(EA_COMPILER_GNUC) &amp;&amp; !defined(EA_COMPILER_EDG)</td>
        </tr>
        <tr>
          <td id="L419" data-line-number="419"></td>
          <td id="LC419">			<span>if</span>(x)</td>
        </tr>
        <tr>
          <td id="L420" data-line-number="420"></td>
          <td id="LC420">				<span>return</span> <span>__builtin_clzll</span>(x);</td>
        </tr>
        <tr>
          <td id="L421" data-line-number="421"></td>
          <td id="LC421">			<span>return</span> <span>64</span>;</td>
        </tr>
        <tr>
          <td id="L422" data-line-number="422"></td>
          <td id="LC422">		#<span>else</span></td>
        </tr>
        <tr>
          <td id="L423" data-line-number="423"></td>
          <td id="LC423">			<span>if</span>(x){ <span><span>//</span> We use a slightly different algorithm than the 32 bit version above because this version avoids slow large 64 bit constants, especially on RISC processors.</span></td>
        </tr>
        <tr>
          <td id="L424" data-line-number="424"></td>
          <td id="LC424">				<span>int</span> n = <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L425" data-line-number="425"></td>
          <td id="LC425">				<span>if</span>(x &amp; <span>UINT64_C</span>(<span>0xFFFFFFFF00000000</span>)) { n += <span>32</span>; x &gt;&gt;= <span>32</span>; }</td>
        </tr>
        <tr>
          <td id="L426" data-line-number="426"></td>
          <td id="LC426">				<span>if</span>(x &amp; <span>0xFFFF0000</span>)                   { n += <span>16</span>; x &gt;&gt;= <span>16</span>; }</td>
        </tr>
        <tr>
          <td id="L427" data-line-number="427"></td>
          <td id="LC427">				<span>if</span>(x &amp; <span>0xFFFFFF00</span>)                   { n +=  <span>8</span>; x &gt;&gt;=  <span>8</span>; }</td>
        </tr>
        <tr>
          <td id="L428" data-line-number="428"></td>
          <td id="LC428">				<span>if</span>(x &amp; <span>0xFFFFFFF0</span>)                   { n +=  <span>4</span>; x &gt;&gt;=  <span>4</span>; }</td>
        </tr>
        <tr>
          <td id="L429" data-line-number="429"></td>
          <td id="LC429">				<span>if</span>(x &amp; <span>0xFFFFFFFC</span>)                   { n +=  <span>2</span>; x &gt;&gt;=  <span>2</span>; }</td>
        </tr>
        <tr>
          <td id="L430" data-line-number="430"></td>
          <td id="LC430">				<span>if</span>(x &amp; <span>0xFFFFFFFE</span>)                   { n +=  <span>1</span>;           }</td>
        </tr>
        <tr>
          <td id="L431" data-line-number="431"></td>
          <td id="LC431">				<span>return</span> <span>63</span> - n;</td>
        </tr>
        <tr>
          <td id="L432" data-line-number="432"></td>
          <td id="LC432">			}</td>
        </tr>
        <tr>
          <td id="L433" data-line-number="433"></td>
          <td id="LC433">			<span>return</span> <span>64</span>;</td>
        </tr>
        <tr>
          <td id="L434" data-line-number="434"></td>
          <td id="LC434">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L435" data-line-number="435"></td>
          <td id="LC435">	}</td>
        </tr>
        <tr>
          <td id="L436" data-line-number="436"></td>
          <td id="LC436">
</td>
        </tr>
        <tr>
          <td id="L437" data-line-number="437"></td>
          <td id="LC437">
</td>
        </tr>
        <tr>
          <td id="L438" data-line-number="438"></td>
          <td id="LC438">	<span><span>//</span>/ CountBits</span></td>
        </tr>
        <tr>
          <td id="L439" data-line-number="439"></td>
          <td id="LC439">	<span><span>//</span>/ How to count the number of bits in an unsigned integer.</span></td>
        </tr>
        <tr>
          <td id="L440" data-line-number="440"></td>
          <td id="LC440">	<span><span>//</span>/ There are multiple variations of this function available, </span></td>
        </tr>
        <tr>
          <td id="L441" data-line-number="441"></td>
          <td id="LC441">	<span><span>//</span>/ each tuned to the expected bit counts and locations. </span></td>
        </tr>
        <tr>
          <td id="L442" data-line-number="442"></td>
          <td id="LC442">	<span><span>//</span>/ The version presented here has a large number of logical </span></td>
        </tr>
        <tr>
          <td id="L443" data-line-number="443"></td>
          <td id="LC443">	<span><span>//</span>/ operations but has no looping or branching.</span></td>
        </tr>
        <tr>
          <td id="L444" data-line-number="444"></td>
          <td id="LC444">	<span><span>//</span>/ This implementation is taken from the AMD x86 optimization guide.</span></td>
        </tr>
        <tr>
          <td id="L445" data-line-number="445"></td>
          <td id="LC445">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L446" data-line-number="446"></td>
          <td id="LC446">	<span><span>//</span>/     11001010 -&gt; 4</span></td>
        </tr>
        <tr>
          <td id="L447" data-line-number="447"></td>
          <td id="LC447">	<span>inline</span> <span>int</span> <span>CountBits</span>(<span>uint32_t</span> x) <span><span>//</span> Branchless version</span></td>
        </tr>
        <tr>
          <td id="L448" data-line-number="448"></td>
          <td id="LC448">	{ </td>
        </tr>
        <tr>
          <td id="L449" data-line-number="449"></td>
          <td id="LC449">	#<span>if</span> defined(EASTDC_SSE_POPCNT)</td>
        </tr>
        <tr>
          <td id="L450" data-line-number="450"></td>
          <td id="LC450">		<span>return</span> <span>_mm_popcnt_u32</span>(x);</td>
        </tr>
        <tr>
          <td id="L451" data-line-number="451"></td>
          <td id="LC451">	#<span>else</span></td>
        </tr>
        <tr>
          <td id="L452" data-line-number="452"></td>
          <td id="LC452">		x = x - ((x &gt;&gt; <span>1</span>) &amp; <span>0x55555555</span>);</td>
        </tr>
        <tr>
          <td id="L453" data-line-number="453"></td>
          <td id="LC453">		x = (x &amp; <span>0x33333333</span>) + ((x &gt;&gt; <span>2</span>) &amp; <span>0x33333333</span>);</td>
        </tr>
        <tr>
          <td id="L454" data-line-number="454"></td>
          <td id="LC454">		x = (x + (x &gt;&gt; <span>4</span>)) &amp; <span>0x0F0F0F0F</span>;</td>
        </tr>
        <tr>
          <td id="L455" data-line-number="455"></td>
          <td id="LC455">		<span>return</span> (<span>int</span>)((x * <span>0x01010101</span>) &gt;&gt; <span>24</span>);</td>
        </tr>
        <tr>
          <td id="L456" data-line-number="456"></td>
          <td id="LC456">	#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L457" data-line-number="457"></td>
          <td id="LC457">	}</td>
        </tr>
        <tr>
          <td id="L458" data-line-number="458"></td>
          <td id="LC458">
</td>
        </tr>
        <tr>
          <td id="L459" data-line-number="459"></td>
          <td id="LC459">	<span>inline</span> <span>int</span> <span>CountBits64</span>(<span>uint64_t</span> x) <span><span>//</span> Branchless version</span></td>
        </tr>
        <tr>
          <td id="L460" data-line-number="460"></td>
          <td id="LC460">	{ </td>
        </tr>
        <tr>
          <td id="L461" data-line-number="461"></td>
          <td id="LC461">	#<span>if</span> defined(EASTDC_SSE_POPCNT) &amp;&amp; defined(EA_PROCESSOR_X86_64)</td>
        </tr>
        <tr>
          <td id="L462" data-line-number="462"></td>
          <td id="LC462">		<span>return</span> (<span>int</span>)<span>_mm_popcnt_u64</span>(x);</td>
        </tr>
        <tr>
          <td id="L463" data-line-number="463"></td>
          <td id="LC463">	#<span>else</span></td>
        </tr>
        <tr>
          <td id="L464" data-line-number="464"></td>
          <td id="LC464">		#<span>if</span> (EA_PLATFORM_WORD_SIZE &lt; 8)</td>
        </tr>
        <tr>
          <td id="L465" data-line-number="465"></td>
          <td id="LC465">			<span>return</span> <span>CountBits</span>((<span>uint32_t</span>)(x &gt;&gt; <span>32</span>)) + <span>CountBits</span>((<span>uint32_t</span>)x);</td>
        </tr>
        <tr>
          <td id="L466" data-line-number="466"></td>
          <td id="LC466">		#<span>else</span></td>
        </tr>
        <tr>
          <td id="L467" data-line-number="467"></td>
          <td id="LC467">			x = x - ((x &gt;&gt; <span>1</span>) &amp; <span>UINT64_C</span>(<span>0x5555555555555555</span>));</td>
        </tr>
        <tr>
          <td id="L468" data-line-number="468"></td>
          <td id="LC468">			x = (x &amp; <span>UINT64_C</span>(<span>0x3333333333333333</span>)) + ((x &gt;&gt; <span>2</span>) &amp; <span>UINT64_C</span>(<span>0x3333333333333333</span>));</td>
        </tr>
        <tr>
          <td id="L469" data-line-number="469"></td>
          <td id="LC469">			x = (x + (x &gt;&gt; <span>4</span>)) &amp; <span>UINT64_C</span>(<span>0x0F0F0F0F0F0F0F0F</span>);</td>
        </tr>
        <tr>
          <td id="L470" data-line-number="470"></td>
          <td id="LC470">			<span>return</span> (<span>int</span>)((x * <span>UINT64_C</span>(<span>0x0101010101010101</span>)) &gt;&gt; <span>56</span>);</td>
        </tr>
        <tr>
          <td id="L471" data-line-number="471"></td>
          <td id="LC471">		#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L472" data-line-number="472"></td>
          <td id="LC472">	#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L473" data-line-number="473"></td>
          <td id="LC473">	}</td>
        </tr>
        <tr>
          <td id="L474" data-line-number="474"></td>
          <td id="LC474">
</td>
        </tr>
        <tr>
          <td id="L475" data-line-number="475"></td>
          <td id="LC475">	<span><span>//</span>/ RotateLeft</span></td>
        </tr>
        <tr>
          <td id="L476" data-line-number="476"></td>
          <td id="LC476">	<span><span>//</span>/ How to rotate an integer left.</span></td>
        </tr>
        <tr>
          <td id="L477" data-line-number="477"></td>
          <td id="LC477">	<span><span>//</span>/ Bit rotations can often be accomplished with inline assembly </span></td>
        </tr>
        <tr>
          <td id="L478" data-line-number="478"></td>
          <td id="LC478">	<span><span>//</span>/ that uses the processor&#39;s native bit rotation capabilities.</span></td>
        </tr>
        <tr>
          <td id="L479" data-line-number="479"></td>
          <td id="LC479">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L480" data-line-number="480"></td>
          <td id="LC480">	<span><span>//</span>/     11110000 -&gt; left 2 -&gt; 11000011</span></td>
        </tr>
        <tr>
          <td id="L481" data-line-number="481"></td>
          <td id="LC481">	<span>inline</span> <span>uint32_t</span> <span>RotateLeft</span>(<span>uint32_t</span> x, <span>uint32_t</span> n){</td>
        </tr>
        <tr>
          <td id="L482" data-line-number="482"></td>
          <td id="LC482">		<span>return</span> (<span>uint32_t</span>)((x &lt;&lt; n) | (x &gt;&gt; (<span>32</span> - n)));</td>
        </tr>
        <tr>
          <td id="L483" data-line-number="483"></td>
          <td id="LC483">	}</td>
        </tr>
        <tr>
          <td id="L484" data-line-number="484"></td>
          <td id="LC484">
</td>
        </tr>
        <tr>
          <td id="L485" data-line-number="485"></td>
          <td id="LC485">	<span>inline</span> <span>uint64_t</span> <span>RotateLeft</span>(<span>uint64_t</span> x, <span>uint64_t</span> n){</td>
        </tr>
        <tr>
          <td id="L486" data-line-number="486"></td>
          <td id="LC486">		<span>return</span> (<span>uint64_t</span>)((x &lt;&lt; n) | (x &gt;&gt; (<span>64</span> - n)));</td>
        </tr>
        <tr>
          <td id="L487" data-line-number="487"></td>
          <td id="LC487">	}</td>
        </tr>
        <tr>
          <td id="L488" data-line-number="488"></td>
          <td id="LC488">
</td>
        </tr>
        <tr>
          <td id="L489" data-line-number="489"></td>
          <td id="LC489">	<span>inline</span> <span>uint32_t</span> <span>RotateRight</span>(<span>uint32_t</span> x, <span>uint32_t</span> n){</td>
        </tr>
        <tr>
          <td id="L490" data-line-number="490"></td>
          <td id="LC490">		<span>return</span> (<span>uint32_t</span>)((x &gt;&gt; n) | (x &lt;&lt; (<span>32</span> - n)));</td>
        </tr>
        <tr>
          <td id="L491" data-line-number="491"></td>
          <td id="LC491">	}</td>
        </tr>
        <tr>
          <td id="L492" data-line-number="492"></td>
          <td id="LC492">
</td>
        </tr>
        <tr>
          <td id="L493" data-line-number="493"></td>
          <td id="LC493">	<span>inline</span> <span>uint64_t</span> <span>RotateRight</span>(<span>uint64_t</span> x, <span>uint64_t</span> n){</td>
        </tr>
        <tr>
          <td id="L494" data-line-number="494"></td>
          <td id="LC494">		<span>return</span> (<span>uint64_t</span>)((x &gt;&gt; n) | (x &lt;&lt; (<span>64</span> - n)));</td>
        </tr>
        <tr>
          <td id="L495" data-line-number="495"></td>
          <td id="LC495">	}</td>
        </tr>
        <tr>
          <td id="L496" data-line-number="496"></td>
          <td id="LC496">
</td>
        </tr>
        <tr>
          <td id="L497" data-line-number="497"></td>
          <td id="LC497">
</td>
        </tr>
        <tr>
          <td id="L498" data-line-number="498"></td>
          <td id="LC498">	<span><span>//</span>/ ReverseBits</span></td>
        </tr>
        <tr>
          <td id="L499" data-line-number="499"></td>
          <td id="LC499">	<span><span>//</span>/ How to reverse the bits in an integer.</span></td>
        </tr>
        <tr>
          <td id="L500" data-line-number="500"></td>
          <td id="LC500">	<span><span>//</span>/ There are other mechansims for accomplishing this. </span></td>
        </tr>
        <tr>
          <td id="L501" data-line-number="501"></td>
          <td id="LC501">	<span><span>//</span>/ The version presented here has no branches, looping, nor table lookups.</span></td>
        </tr>
        <tr>
          <td id="L502" data-line-number="502"></td>
          <td id="LC502">	<span><span>//</span>/ Table lookups are the fastest when done on large amounts of data, but slower</span></td>
        </tr>
        <tr>
          <td id="L503" data-line-number="503"></td>
          <td id="LC503">	<span><span>//</span>/ when just done once due to the initial lookup cost.</span></td>
        </tr>
        <tr>
          <td id="L504" data-line-number="504"></td>
          <td id="LC504">	<span><span>//</span>/ Some ARM results: http://corner.squareup.com/2013/07/reversing-bits-on-arm.html</span></td>
        </tr>
        <tr>
          <td id="L505" data-line-number="505"></td>
          <td id="LC505">	<span><span>//</span>/ http://stackoverflow.com/questions/746171/best-algorithm-for-bit-reversal-from-msb-lsb-to-lsb-msb-in-c</span></td>
        </tr>
        <tr>
          <td id="L506" data-line-number="506"></td>
          <td id="LC506">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L507" data-line-number="507"></td>
          <td id="LC507">	<span><span>//</span>/    11100001 -&gt; 10000111</span></td>
        </tr>
        <tr>
          <td id="L508" data-line-number="508"></td>
          <td id="LC508">	<span>inline</span> <span>uint32_t</span> <span>ReverseBits</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L509" data-line-number="509"></td>
          <td id="LC509">		x = ((x &amp; <span>0x55555555</span>) &lt;&lt; <span>1</span>) | ((x &gt;&gt; <span>1</span>) &amp; <span>0x55555555</span>);</td>
        </tr>
        <tr>
          <td id="L510" data-line-number="510"></td>
          <td id="LC510">		x = ((x &amp; <span>0x33333333</span>) &lt;&lt; <span>2</span>) | ((x &gt;&gt; <span>2</span>) &amp; <span>0x33333333</span>);</td>
        </tr>
        <tr>
          <td id="L511" data-line-number="511"></td>
          <td id="LC511">		x = ((x &amp; <span>0x0F0F0F0F</span>) &lt;&lt; <span>4</span>) | ((x &gt;&gt; <span>4</span>) &amp; <span>0x0F0F0F0F</span>);</td>
        </tr>
        <tr>
          <td id="L512" data-line-number="512"></td>
          <td id="LC512">		x = (x &lt;&lt; <span>24</span>) | ((x &amp; <span>0xFF00</span>) &lt;&lt; <span>8</span>) | ((x &gt;&gt; <span>8</span>) &amp; <span>0xFF00</span>) | (x &gt;&gt; <span>24</span>);</td>
        </tr>
        <tr>
          <td id="L513" data-line-number="513"></td>
          <td id="LC513">		<span>return</span> x;</td>
        </tr>
        <tr>
          <td id="L514" data-line-number="514"></td>
          <td id="LC514">	}</td>
        </tr>
        <tr>
          <td id="L515" data-line-number="515"></td>
          <td id="LC515">
</td>
        </tr>
        <tr>
          <td id="L516" data-line-number="516"></td>
          <td id="LC516">	<span><span>//</span> This is surely not the fastest way to do this, and is here for completeness only.</span></td>
        </tr>
        <tr>
          <td id="L517" data-line-number="517"></td>
          <td id="LC517">	<span><span>//</span> To do: Make a better version of this.</span></td>
        </tr>
        <tr>
          <td id="L518" data-line-number="518"></td>
          <td id="LC518">	<span>inline</span> <span>uint64_t</span> <span>ReverseBits</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L519" data-line-number="519"></td>
          <td id="LC519">		<span>uint32_t</span> x1 = (<span>uint32_t</span>)(x &amp; <span>0xffffffff</span>);</td>
        </tr>
        <tr>
          <td id="L520" data-line-number="520"></td>
          <td id="LC520">		<span>uint32_t</span> x2 = (<span>uint32_t</span>)(x &gt;&gt; <span>32</span>);</td>
        </tr>
        <tr>
          <td id="L521" data-line-number="521"></td>
          <td id="LC521">		<span>return</span> ((<span>uint64_t</span>)<span>ReverseBits</span>(x1) &lt;&lt; <span>32</span>) | <span>ReverseBits</span>(x2);</td>
        </tr>
        <tr>
          <td id="L522" data-line-number="522"></td>
          <td id="LC522">	}</td>
        </tr>
        <tr>
          <td id="L523" data-line-number="523"></td>
          <td id="LC523">
</td>
        </tr>
        <tr>
          <td id="L524" data-line-number="524"></td>
          <td id="LC524">
</td>
        </tr>
        <tr>
          <td id="L525" data-line-number="525"></td>
          <td id="LC525">	<span><span>//</span>/ IsolateHighestBit</span></td>
        </tr>
        <tr>
          <td id="L526" data-line-number="526"></td>
          <td id="LC526">	<span><span>//</span>/ How to isolate the highest 1 bit.</span></td>
        </tr>
        <tr>
          <td id="L527" data-line-number="527"></td>
          <td id="LC527">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L528" data-line-number="528"></td>
          <td id="LC528">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L529" data-line-number="529"></td>
          <td id="LC529">	<span><span>//</span>/    01000100 -&gt; 01000000</span></td>
        </tr>
        <tr>
          <td id="L530" data-line-number="530"></td>
          <td id="LC530">	<span><span>//</span>/    00000000 -&gt; 00000000</span></td>
        </tr>
        <tr>
          <td id="L531" data-line-number="531"></td>
          <td id="LC531">	<span>inline</span> <span>uint32_t</span> <span>IsolateHighestBit</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L532" data-line-number="532"></td>
          <td id="LC532">		x |= x &gt;&gt; <span>1</span>; </td>
        </tr>
        <tr>
          <td id="L533" data-line-number="533"></td>
          <td id="LC533">		x |= x &gt;&gt; <span>2</span>; </td>
        </tr>
        <tr>
          <td id="L534" data-line-number="534"></td>
          <td id="LC534">		x |= x &gt;&gt; <span>4</span>; </td>
        </tr>
        <tr>
          <td id="L535" data-line-number="535"></td>
          <td id="LC535">		x |= x &gt;&gt; <span>8</span>; </td>
        </tr>
        <tr>
          <td id="L536" data-line-number="536"></td>
          <td id="LC536">		x |= x &gt;&gt; <span>16</span>;</td>
        </tr>
        <tr>
          <td id="L537" data-line-number="537"></td>
          <td id="LC537">		<span>return</span> x ^ (x &gt;&gt; <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L538" data-line-number="538"></td>
          <td id="LC538">	}</td>
        </tr>
        <tr>
          <td id="L539" data-line-number="539"></td>
          <td id="LC539">
</td>
        </tr>
        <tr>
          <td id="L540" data-line-number="540"></td>
          <td id="LC540">	<span>inline</span> <span>uint64_t</span> <span>IsolateHighestBit</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L541" data-line-number="541"></td>
          <td id="LC541">		x |= x &gt;&gt; <span>1</span>; </td>
        </tr>
        <tr>
          <td id="L542" data-line-number="542"></td>
          <td id="LC542">		x |= x &gt;&gt; <span>2</span>; </td>
        </tr>
        <tr>
          <td id="L543" data-line-number="543"></td>
          <td id="LC543">		x |= x &gt;&gt; <span>4</span>; </td>
        </tr>
        <tr>
          <td id="L544" data-line-number="544"></td>
          <td id="LC544">		x |= x &gt;&gt; <span>8</span>; </td>
        </tr>
        <tr>
          <td id="L545" data-line-number="545"></td>
          <td id="LC545">		x |= x &gt;&gt; <span>16</span>;</td>
        </tr>
        <tr>
          <td id="L546" data-line-number="546"></td>
          <td id="LC546">		x |= x &gt;&gt; <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L547" data-line-number="547"></td>
          <td id="LC547">		<span>return</span> x ^ (x &gt;&gt; <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L548" data-line-number="548"></td>
          <td id="LC548">	}</td>
        </tr>
        <tr>
          <td id="L549" data-line-number="549"></td>
          <td id="LC549">
</td>
        </tr>
        <tr>
          <td id="L550" data-line-number="550"></td>
          <td id="LC550">	<span>inline</span> <span>uint32_t</span> <span>IsolateHighest0Bit</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L551" data-line-number="551"></td>
          <td id="LC551">		<span>return</span> <span>IsolateHighestBit</span>(~x);</td>
        </tr>
        <tr>
          <td id="L552" data-line-number="552"></td>
          <td id="LC552">	}</td>
        </tr>
        <tr>
          <td id="L553" data-line-number="553"></td>
          <td id="LC553">
</td>
        </tr>
        <tr>
          <td id="L554" data-line-number="554"></td>
          <td id="LC554">	<span>inline</span> <span>uint64_t</span> <span>IsolateHighest0Bit</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L555" data-line-number="555"></td>
          <td id="LC555">		<span>return</span> <span>IsolateHighestBit</span>(~x);</td>
        </tr>
        <tr>
          <td id="L556" data-line-number="556"></td>
          <td id="LC556">	}</td>
        </tr>
        <tr>
          <td id="L557" data-line-number="557"></td>
          <td id="LC557">
</td>
        </tr>
        <tr>
          <td id="L558" data-line-number="558"></td>
          <td id="LC558">	<span><span>//</span>/ PropogateHighestBitDownward</span></td>
        </tr>
        <tr>
          <td id="L559" data-line-number="559"></td>
          <td id="LC559">	<span><span>//</span>/ How to set all bits from the highest 1 bit downward.</span></td>
        </tr>
        <tr>
          <td id="L560" data-line-number="560"></td>
          <td id="LC560">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L561" data-line-number="561"></td>
          <td id="LC561">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L562" data-line-number="562"></td>
          <td id="LC562">	<span><span>//</span>/    01001000 -&gt; 01111111</span></td>
        </tr>
        <tr>
          <td id="L563" data-line-number="563"></td>
          <td id="LC563">	<span><span>//</span>/    00000000 -&gt; 00000000</span></td>
        </tr>
        <tr>
          <td id="L564" data-line-number="564"></td>
          <td id="LC564">	<span>inline</span> <span>uint32_t</span> <span>PropogateHighestBitDownward</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L565" data-line-number="565"></td>
          <td id="LC565">		x |= (x &gt;&gt;  <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L566" data-line-number="566"></td>
          <td id="LC566">		x |= (x &gt;&gt;  <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L567" data-line-number="567"></td>
          <td id="LC567">		x |= (x &gt;&gt;  <span>4</span>);</td>
        </tr>
        <tr>
          <td id="L568" data-line-number="568"></td>
          <td id="LC568">		x |= (x &gt;&gt;  <span>8</span>);</td>
        </tr>
        <tr>
          <td id="L569" data-line-number="569"></td>
          <td id="LC569">		x |= (x &gt;&gt; <span>16</span>);</td>
        </tr>
        <tr>
          <td id="L570" data-line-number="570"></td>
          <td id="LC570">		<span>return</span>  x;</td>
        </tr>
        <tr>
          <td id="L571" data-line-number="571"></td>
          <td id="LC571">	}</td>
        </tr>
        <tr>
          <td id="L572" data-line-number="572"></td>
          <td id="LC572">
</td>
        </tr>
        <tr>
          <td id="L573" data-line-number="573"></td>
          <td id="LC573">	<span>inline</span> <span>uint64_t</span> <span>PropogateHighestBitDownward</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L574" data-line-number="574"></td>
          <td id="LC574">		x |= (x &gt;&gt;  <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L575" data-line-number="575"></td>
          <td id="LC575">		x |= (x &gt;&gt;  <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L576" data-line-number="576"></td>
          <td id="LC576">		x |= (x &gt;&gt;  <span>4</span>);</td>
        </tr>
        <tr>
          <td id="L577" data-line-number="577"></td>
          <td id="LC577">		x |= (x &gt;&gt;  <span>8</span>);</td>
        </tr>
        <tr>
          <td id="L578" data-line-number="578"></td>
          <td id="LC578">		x |= (x &gt;&gt; <span>16</span>);</td>
        </tr>
        <tr>
          <td id="L579" data-line-number="579"></td>
          <td id="LC579">		x |= (x &gt;&gt; <span>32</span>);</td>
        </tr>
        <tr>
          <td id="L580" data-line-number="580"></td>
          <td id="LC580">		<span>return</span>  x;</td>
        </tr>
        <tr>
          <td id="L581" data-line-number="581"></td>
          <td id="LC581">	}</td>
        </tr>
        <tr>
          <td id="L582" data-line-number="582"></td>
          <td id="LC582">
</td>
        </tr>
        <tr>
          <td id="L583" data-line-number="583"></td>
          <td id="LC583">	<span><span>//</span>/ GetHighestContiguous0Bits</span></td>
        </tr>
        <tr>
          <td id="L584" data-line-number="584"></td>
          <td id="LC584">	<span><span>//</span>/ How to set the highest contiguous 0 bits.</span></td>
        </tr>
        <tr>
          <td id="L585" data-line-number="585"></td>
          <td id="LC585">	<span><span>//</span>/ Returns 0 for an input of all bits set.</span></td>
        </tr>
        <tr>
          <td id="L586" data-line-number="586"></td>
          <td id="LC586">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L587" data-line-number="587"></td>
          <td id="LC587">	<span><span>//</span>/    00011001 -&gt; 11100000</span></td>
        </tr>
        <tr>
          <td id="L588" data-line-number="588"></td>
          <td id="LC588">	<span><span>//</span>/    11111111 -&gt; 00000000</span></td>
        </tr>
        <tr>
          <td id="L589" data-line-number="589"></td>
          <td id="LC589">	<span>inline</span> <span>uint32_t</span> <span>GetHighestContiguous0Bits</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L590" data-line-number="590"></td>
          <td id="LC590">		x |= (x &gt;&gt;  <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L591" data-line-number="591"></td>
          <td id="LC591">		x |= (x &gt;&gt;  <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L592" data-line-number="592"></td>
          <td id="LC592">		x |= (x &gt;&gt;  <span>4</span>);</td>
        </tr>
        <tr>
          <td id="L593" data-line-number="593"></td>
          <td id="LC593">		x |= (x &gt;&gt;  <span>8</span>);</td>
        </tr>
        <tr>
          <td id="L594" data-line-number="594"></td>
          <td id="LC594">		x |= (x &gt;&gt; <span>16</span>);</td>
        </tr>
        <tr>
          <td id="L595" data-line-number="595"></td>
          <td id="LC595">		<span>return</span>  ~x;</td>
        </tr>
        <tr>
          <td id="L596" data-line-number="596"></td>
          <td id="LC596">	}</td>
        </tr>
        <tr>
          <td id="L597" data-line-number="597"></td>
          <td id="LC597">
</td>
        </tr>
        <tr>
          <td id="L598" data-line-number="598"></td>
          <td id="LC598">	<span>inline</span> <span>uint64_t</span> <span>GetHighestContiguous0Bits</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L599" data-line-number="599"></td>
          <td id="LC599">		x |= (x &gt;&gt;  <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L600" data-line-number="600"></td>
          <td id="LC600">		x |= (x &gt;&gt;  <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L601" data-line-number="601"></td>
          <td id="LC601">		x |= (x &gt;&gt;  <span>4</span>);</td>
        </tr>
        <tr>
          <td id="L602" data-line-number="602"></td>
          <td id="LC602">		x |= (x &gt;&gt;  <span>8</span>);</td>
        </tr>
        <tr>
          <td id="L603" data-line-number="603"></td>
          <td id="LC603">		x |= (x &gt;&gt; <span>16</span>);</td>
        </tr>
        <tr>
          <td id="L604" data-line-number="604"></td>
          <td id="LC604">		x |= (x &gt;&gt; <span>32</span>);</td>
        </tr>
        <tr>
          <td id="L605" data-line-number="605"></td>
          <td id="LC605">		<span>return</span>  ~x;</td>
        </tr>
        <tr>
          <td id="L606" data-line-number="606"></td>
          <td id="LC606">	}</td>
        </tr>
        <tr>
          <td id="L607" data-line-number="607"></td>
          <td id="LC607">
</td>
        </tr>
        <tr>
          <td id="L608" data-line-number="608"></td>
          <td id="LC608">	<span><span>//</span>/ GetBitwiseEquivalence</span></td>
        </tr>
        <tr>
          <td id="L609" data-line-number="609"></td>
          <td id="LC609">	<span><span>//</span>/ How to calculate bitwise equivalence.</span></td>
        </tr>
        <tr>
          <td id="L610" data-line-number="610"></td>
          <td id="LC610">	<span><span>//</span>/ Bitwise equivalence is the opposite of xor. It sets all bits that </span></td>
        </tr>
        <tr>
          <td id="L611" data-line-number="611"></td>
          <td id="LC611">	<span><span>//</span>/ are the same to 1, whereas xor sets all bits that are different to 1. </span></td>
        </tr>
        <tr>
          <td id="L612" data-line-number="612"></td>
          <td id="LC612">	<span><span>//</span>/ Thus, you can simply use ~ to get bitwise equivalence from xor.</span></td>
        </tr>
        <tr>
          <td id="L613" data-line-number="613"></td>
          <td id="LC613">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L614" data-line-number="614"></td>
          <td id="LC614">	<span><span>//</span>/    11001100, 11110000 -&gt; 11000011</span></td>
        </tr>
        <tr>
          <td id="L615" data-line-number="615"></td>
          <td id="LC615">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L616" data-line-number="616"></td>
          <td id="LC616">	<span>inline</span> T <span>GetBitwiseEquivalence</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L617" data-line-number="617"></td>
          <td id="LC617">		<span>return</span> (T)(~(x ^ y));</td>
        </tr>
        <tr>
          <td id="L618" data-line-number="618"></td>
          <td id="LC618">	}</td>
        </tr>
        <tr>
          <td id="L619" data-line-number="619"></td>
          <td id="LC619">
</td>
        </tr>
        <tr>
          <td id="L620" data-line-number="620"></td>
          <td id="LC620">	<span><span>//</span>/ AreLessThan2BitsSet</span></td>
        </tr>
        <tr>
          <td id="L621" data-line-number="621"></td>
          <td id="LC621">	<span><span>//</span>/ How to tell if at least two bits are set in an integer.</span></td>
        </tr>
        <tr>
          <td id="L622" data-line-number="622"></td>
          <td id="LC622">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L623" data-line-number="623"></td>
          <td id="LC623">	<span><span>//</span>/    00001000 -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L624" data-line-number="624"></td>
          <td id="LC624">	<span><span>//</span>/    01001110 -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L625" data-line-number="625"></td>
          <td id="LC625">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L626" data-line-number="626"></td>
          <td id="LC626">	<span>inline</span> <span>bool</span> <span>AreLessThan2BitsSet</span>(T x){</td>
        </tr>
        <tr>
          <td id="L627" data-line-number="627"></td>
          <td id="LC627">		<span>return</span> (x &amp; (x - <span>1</span>)) == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L628" data-line-number="628"></td>
          <td id="LC628">	}</td>
        </tr>
        <tr>
          <td id="L629" data-line-number="629"></td>
          <td id="LC629">
</td>
        </tr>
        <tr>
          <td id="L630" data-line-number="630"></td>
          <td id="LC630">#<span>if</span> defined(EASTDC_SSE_POPCNT)</td>
        </tr>
        <tr>
          <td id="L631" data-line-number="631"></td>
          <td id="LC631">	<span>template </span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L632" data-line-number="632"></td>
          <td id="LC632">	<span>inline</span> <span>bool</span> AreLessThan2BitsSet&lt;<span>uint32_t</span>&gt;(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L633" data-line-number="633"></td>
          <td id="LC633">		<span>uint32_t</span> rv = (<span>uint32_t</span>)<span>_mm_popcnt_u32</span>(x);</td>
        </tr>
        <tr>
          <td id="L634" data-line-number="634"></td>
          <td id="LC634">		<span>return</span> (rv &lt; <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L635" data-line-number="635"></td>
          <td id="LC635">	}</td>
        </tr>
        <tr>
          <td id="L636" data-line-number="636"></td>
          <td id="LC636">
</td>
        </tr>
        <tr>
          <td id="L637" data-line-number="637"></td>
          <td id="LC637">#<span>if</span> defined(EA_PROCESSOR_X86_64)</td>
        </tr>
        <tr>
          <td id="L638" data-line-number="638"></td>
          <td id="LC638">	<span>template </span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L639" data-line-number="639"></td>
          <td id="LC639">	<span>inline</span> <span>bool</span> AreLessThan2BitsSet&lt;<span>uint64_t</span>&gt;(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L640" data-line-number="640"></td>
          <td id="LC640">		<span>uint64_t</span> rv = (<span>uint64_t</span>)<span>_mm_popcnt_u64</span>(x);</td>
        </tr>
        <tr>
          <td id="L641" data-line-number="641"></td>
          <td id="LC641">		<span>return</span> (rv &lt; <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L642" data-line-number="642"></td>
          <td id="LC642">	}</td>
        </tr>
        <tr>
          <td id="L643" data-line-number="643"></td>
          <td id="LC643">#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L644" data-line-number="644"></td>
          <td id="LC644">#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L645" data-line-number="645"></td>
          <td id="LC645">
</td>
        </tr>
        <tr>
          <td id="L646" data-line-number="646"></td>
          <td id="LC646">
</td>
        </tr>
        <tr>
          <td id="L647" data-line-number="647"></td>
          <td id="LC647">	<span><span>//</span>/ GetHighestBit</span></td>
        </tr>
        <tr>
          <td id="L648" data-line-number="648"></td>
          <td id="LC648">	<span><span>//</span>/ How to refer to the high bit of any integer data type where the </span></td>
        </tr>
        <tr>
          <td id="L649" data-line-number="649"></td>
          <td id="LC649">	<span><span>//</span>/ data type size is not known.</span></td>
        </tr>
        <tr>
          <td id="L650" data-line-number="650"></td>
          <td id="LC650">	<span><span>//</span>/ There are cases where you may want to refer to the higest bit in </span></td>
        </tr>
        <tr>
          <td id="L651" data-line-number="651"></td>
          <td id="LC651">	<span><span>//</span>/ an integer in a portable way. If you can&#39;t know the size of the </span></td>
        </tr>
        <tr>
          <td id="L652" data-line-number="652"></td>
          <td id="LC652">	<span><span>//</span>/ destination platform&#39;s int type, you can use this to refer to such a bit.</span></td>
        </tr>
        <tr>
          <td id="L653" data-line-number="653"></td>
          <td id="LC653">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L654" data-line-number="654"></td>
          <td id="LC654">	<span><span>//</span>/    GetHighestBit(uint32_t(0)) -&gt; 0x80000000</span></td>
        </tr>
        <tr>
          <td id="L655" data-line-number="655"></td>
          <td id="LC655">	<span><span>//</span>/    GetHighestBit(uint16_t(0)) -&gt;     0x8000</span></td>
        </tr>
        <tr>
          <td id="L656" data-line-number="656"></td>
          <td id="LC656">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L657" data-line-number="657"></td>
          <td id="LC657">	<span>inline</span> T <span>GetHighestBit</span>(T <span><span>/*</span>t<span>*/</span></span>){</td>
        </tr>
        <tr>
          <td id="L658" data-line-number="658"></td>
          <td id="LC658">		<span>return</span> (T)((T)<span>1</span> &lt;&lt; (T)((<span>sizeof</span>(T) * <span>8</span>) - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L659" data-line-number="659"></td>
          <td id="LC659">	}</td>
        </tr>
        <tr>
          <td id="L660" data-line-number="660"></td>
          <td id="LC660">
</td>
        </tr>
        <tr>
          <td id="L661" data-line-number="661"></td>
          <td id="LC661">
</td>
        </tr>
        <tr>
          <td id="L662" data-line-number="662"></td>
          <td id="LC662">
</td>
        </tr>
        <tr>
          <td id="L663" data-line-number="663"></td>
          <td id="LC663">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L664" data-line-number="664"></td>
          <td id="LC664">	<span><span>//</span> Alignment / Power of 2</span></td>
        </tr>
        <tr>
          <td id="L665" data-line-number="665"></td>
          <td id="LC665">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L666" data-line-number="666"></td>
          <td id="LC666">
</td>
        </tr>
        <tr>
          <td id="L667" data-line-number="667"></td>
          <td id="LC667">	<span><span>//</span>/ IsPowerOf2</span></td>
        </tr>
        <tr>
          <td id="L668" data-line-number="668"></td>
          <td id="LC668">	<span><span>//</span>/ How to tell if an unsigned integer is a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L669" data-line-number="669"></td>
          <td id="LC669">	<span><span>//</span>/ Works with unsigned integers only.</span></td>
        </tr>
        <tr>
          <td id="L670" data-line-number="670"></td>
          <td id="LC670">	<span><span>//</span>/ Returns true for x == 0.</span></td>
        </tr>
        <tr>
          <td id="L671" data-line-number="671"></td>
          <td id="LC671">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L672" data-line-number="672"></td>
          <td id="LC672">	<span><span>//</span>/    01000010 (66) -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L673" data-line-number="673"></td>
          <td id="LC673">	<span><span>//</span>/    00001100 (12) -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L674" data-line-number="674"></td>
          <td id="LC674">	<span><span>//</span>/    00000100  (4) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L675" data-line-number="675"></td>
          <td id="LC675">	<span><span>//</span>/    00000000  (0) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L676" data-line-number="676"></td>
          <td id="LC676">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L677" data-line-number="677"></td>
          <td id="LC677">	<span>inline</span> <span>bool</span> <span>IsPowerOf2</span>(T x){</td>
        </tr>
        <tr>
          <td id="L678" data-line-number="678"></td>
          <td id="LC678">		<span>return</span> (x &amp; (x - <span>1</span>)) == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L679" data-line-number="679"></td>
          <td id="LC679">	}</td>
        </tr>
        <tr>
          <td id="L680" data-line-number="680"></td>
          <td id="LC680">
</td>
        </tr>
        <tr>
          <td id="L681" data-line-number="681"></td>
          <td id="LC681">#<span>if</span> defined(EASTDC_SSE_POPCNT)</td>
        </tr>
        <tr>
          <td id="L682" data-line-number="682"></td>
          <td id="LC682">	<span>template </span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L683" data-line-number="683"></td>
          <td id="LC683">	<span>inline</span> <span>bool</span> IsPowerOf2&lt;<span>uint32_t</span>&gt;(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L684" data-line-number="684"></td>
          <td id="LC684">		<span>uint32_t</span> rv = (<span>uint32_t</span>)<span>_mm_popcnt_u32</span>(x);</td>
        </tr>
        <tr>
          <td id="L685" data-line-number="685"></td>
          <td id="LC685">		<span>return</span> (rv &lt; <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L686" data-line-number="686"></td>
          <td id="LC686">	}</td>
        </tr>
        <tr>
          <td id="L687" data-line-number="687"></td>
          <td id="LC687">
</td>
        </tr>
        <tr>
          <td id="L688" data-line-number="688"></td>
          <td id="LC688">#<span>if</span> defined(EA_PROCESSOR_X86_64)</td>
        </tr>
        <tr>
          <td id="L689" data-line-number="689"></td>
          <td id="LC689">	<span>template </span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L690" data-line-number="690"></td>
          <td id="LC690">	<span>inline</span> <span>bool</span> IsPowerOf2&lt;<span>uint64_t</span>&gt;(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L691" data-line-number="691"></td>
          <td id="LC691">		<span>uint64_t</span> rv = (<span>uint64_t</span>)<span>_mm_popcnt_u64</span>(x);</td>
        </tr>
        <tr>
          <td id="L692" data-line-number="692"></td>
          <td id="LC692">		<span>return</span> (rv &lt; <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L693" data-line-number="693"></td>
          <td id="LC693">	}</td>
        </tr>
        <tr>
          <td id="L694" data-line-number="694"></td>
          <td id="LC694">#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L695" data-line-number="695"></td>
          <td id="LC695">#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L696" data-line-number="696"></td>
          <td id="LC696">
</td>
        </tr>
        <tr>
          <td id="L697" data-line-number="697"></td>
          <td id="LC697">
</td>
        </tr>
        <tr>
          <td id="L698" data-line-number="698"></td>
          <td id="LC698">	<span><span>//</span>/ RoundUpToPowerOf2</span></td>
        </tr>
        <tr>
          <td id="L699" data-line-number="699"></td>
          <td id="LC699">	<span><span>//</span>/ Rounds an integer up to the nearest power of 2.</span></td>
        </tr>
        <tr>
          <td id="L700" data-line-number="700"></td>
          <td id="LC700">	<span><span>//</span>/ Returns 16 for x == 16, 32 for x == 32, etc.</span></td>
        </tr>
        <tr>
          <td id="L701" data-line-number="701"></td>
          <td id="LC701">	<span><span>//</span>/ Returns 0 for x == 0.</span></td>
        </tr>
        <tr>
          <td id="L702" data-line-number="702"></td>
          <td id="LC702">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L703" data-line-number="703"></td>
          <td id="LC703">	<span><span>//</span>/    01000010 (66) -&gt; 10000000 (128)</span></td>
        </tr>
        <tr>
          <td id="L704" data-line-number="704"></td>
          <td id="LC704">	<span><span>//</span>/    00001100 (12) -&gt; 00010000 (16)</span></td>
        </tr>
        <tr>
          <td id="L705" data-line-number="705"></td>
          <td id="LC705">	<span><span>//</span>/    00000100  (4) -&gt; 00000100 (4)</span></td>
        </tr>
        <tr>
          <td id="L706" data-line-number="706"></td>
          <td id="LC706">	<span><span>//</span>/    00000000  (0) -&gt; 00000000 (0)</span></td>
        </tr>
        <tr>
          <td id="L707" data-line-number="707"></td>
          <td id="LC707">	<span>inline</span> <span>uint32_t</span> <span>RoundUpToPowerOf2</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L708" data-line-number="708"></td>
          <td id="LC708">		--x;</td>
        </tr>
        <tr>
          <td id="L709" data-line-number="709"></td>
          <td id="LC709">		x |= (x &gt;&gt; <span>16</span>);</td>
        </tr>
        <tr>
          <td id="L710" data-line-number="710"></td>
          <td id="LC710">		x |= (x &gt;&gt;  <span>8</span>);</td>
        </tr>
        <tr>
          <td id="L711" data-line-number="711"></td>
          <td id="LC711">		x |= (x &gt;&gt;  <span>4</span>);</td>
        </tr>
        <tr>
          <td id="L712" data-line-number="712"></td>
          <td id="LC712">		x |= (x &gt;&gt;  <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L713" data-line-number="713"></td>
          <td id="LC713">		x |= (x &gt;&gt;  <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L714" data-line-number="714"></td>
          <td id="LC714">		<span>return</span> ++x;</td>
        </tr>
        <tr>
          <td id="L715" data-line-number="715"></td>
          <td id="LC715">	}</td>
        </tr>
        <tr>
          <td id="L716" data-line-number="716"></td>
          <td id="LC716">
</td>
        </tr>
        <tr>
          <td id="L717" data-line-number="717"></td>
          <td id="LC717">	<span>inline</span> <span>uint64_t</span> <span>RoundUpToPowerOf2</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L718" data-line-number="718"></td>
          <td id="LC718">		--x;</td>
        </tr>
        <tr>
          <td id="L719" data-line-number="719"></td>
          <td id="LC719">		x |= (x &gt;&gt; <span>32</span>);</td>
        </tr>
        <tr>
          <td id="L720" data-line-number="720"></td>
          <td id="LC720">		x |= (x &gt;&gt; <span>16</span>);</td>
        </tr>
        <tr>
          <td id="L721" data-line-number="721"></td>
          <td id="LC721">		x |= (x &gt;&gt;  <span>8</span>);</td>
        </tr>
        <tr>
          <td id="L722" data-line-number="722"></td>
          <td id="LC722">		x |= (x &gt;&gt;  <span>4</span>);</td>
        </tr>
        <tr>
          <td id="L723" data-line-number="723"></td>
          <td id="LC723">		x |= (x &gt;&gt;  <span>2</span>);</td>
        </tr>
        <tr>
          <td id="L724" data-line-number="724"></td>
          <td id="LC724">		x |= (x &gt;&gt;  <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L725" data-line-number="725"></td>
          <td id="LC725">		<span>return</span> ++x;</td>
        </tr>
        <tr>
          <td id="L726" data-line-number="726"></td>
          <td id="LC726">	}</td>
        </tr>
        <tr>
          <td id="L727" data-line-number="727"></td>
          <td id="LC727">
</td>
        </tr>
        <tr>
          <td id="L728" data-line-number="728"></td>
          <td id="LC728">
</td>
        </tr>
        <tr>
          <td id="L729" data-line-number="729"></td>
          <td id="LC729">	<span><span>//</span>/ IsPowerOf2Multiple</span></td>
        </tr>
        <tr>
          <td id="L730" data-line-number="730"></td>
          <td id="LC730">	<span><span>//</span>/ How to tell if an unsigned integer is a multiple of some specific power of 2.</span></td>
        </tr>
        <tr>
          <td id="L731" data-line-number="731"></td>
          <td id="LC731">	<span><span>//</span>/ Template constant n is required to be a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L732" data-line-number="732"></td>
          <td id="LC732">	<span><span>//</span>/ Works with an input unsigned integers only. &#39;k&#39; must be an even power of 2, such as 1, 2, 4, 8, etc.</span></td>
        </tr>
        <tr>
          <td id="L733" data-line-number="733"></td>
          <td id="LC733">	<span><span>//</span>/ Returns true for x == 0.</span></td>
        </tr>
        <tr>
          <td id="L734" data-line-number="734"></td>
          <td id="LC734">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L735" data-line-number="735"></td>
          <td id="LC735">	<span><span>//</span>/     IsPowerOf2Multiple&lt;4&gt;(3)   -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L736" data-line-number="736"></td>
          <td id="LC736">	<span><span>//</span>/     IsPowerOf2Multiple&lt;16&gt;(32) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L737" data-line-number="737"></td>
          <td id="LC737">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L738" data-line-number="738"></td>
          <td id="LC738">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L739" data-line-number="739"></td>
          <td id="LC739">	<span>inline</span> <span>bool</span> <span>IsPowerOf2Multiple</span>(T x){</td>
        </tr>
        <tr>
          <td id="L740" data-line-number="740"></td>
          <td id="LC740">		<span>return</span> (x &amp; (n - <span>1</span>)) == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L741" data-line-number="741"></td>
          <td id="LC741">	}</td>
        </tr>
        <tr>
          <td id="L742" data-line-number="742"></td>
          <td id="LC742">	<span><span>//</span> *** The following is deprecated, as it doesn&#39;t use &#34;power of 2&#34; in its name ***</span></td>
        </tr>
        <tr>
          <td id="L743" data-line-number="743"></td>
          <td id="LC743">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L744" data-line-number="744"></td>
          <td id="LC744">	<span>inline</span> <span>bool</span> <span>IsMultipleOf</span>(T x){</td>
        </tr>
        <tr>
          <td id="L745" data-line-number="745"></td>
          <td id="LC745">		<span>return</span> (x &amp; (n - <span>1</span>)) == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L746" data-line-number="746"></td>
          <td id="LC746">	}</td>
        </tr>
        <tr>
          <td id="L747" data-line-number="747"></td>
          <td id="LC747">
</td>
        </tr>
        <tr>
          <td id="L748" data-line-number="748"></td>
          <td id="LC748">
</td>
        </tr>
        <tr>
          <td id="L749" data-line-number="749"></td>
          <td id="LC749">	<span><span>//</span>/ IsPowerOf2Minus1</span></td>
        </tr>
        <tr>
          <td id="L750" data-line-number="750"></td>
          <td id="LC750">	<span><span>//</span>/ How to tell if an unsigned integer is of the form 2n-1 (e.g. 0x0fff, 0x000fffff).</span></td>
        </tr>
        <tr>
          <td id="L751" data-line-number="751"></td>
          <td id="LC751">	<span><span>//</span>/ Returns true for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L752" data-line-number="752"></td>
          <td id="LC752">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L753" data-line-number="753"></td>
          <td id="LC753">	<span><span>//</span>/    00001111 (15) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L754" data-line-number="754"></td>
          <td id="LC754">	<span><span>//</span>/    00001011 (11) -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L755" data-line-number="755"></td>
          <td id="LC755">	<span><span>//</span>/    00000000  (0) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L756" data-line-number="756"></td>
          <td id="LC756">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L757" data-line-number="757"></td>
          <td id="LC757">	<span>inline</span> <span>bool</span> <span>IsPowerOf2Minus1</span>(T x){</td>
        </tr>
        <tr>
          <td id="L758" data-line-number="758"></td>
          <td id="LC758">		<span>return</span> (x &amp; (x + <span>1</span>)) == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L759" data-line-number="759"></td>
          <td id="LC759">	}</td>
        </tr>
        <tr>
          <td id="L760" data-line-number="760"></td>
          <td id="LC760">
</td>
        </tr>
        <tr>
          <td id="L761" data-line-number="761"></td>
          <td id="LC761">	<span><span>//</span>/ CrossesPowerOf2</span></td>
        </tr>
        <tr>
          <td id="L762" data-line-number="762"></td>
          <td id="LC762">	<span><span>//</span>/ How to detect any power of two crossing between two integers.</span></td>
        </tr>
        <tr>
          <td id="L763" data-line-number="763"></td>
          <td id="LC763">	<span><span>//</span>/ Useful for telling if an increasing value is about to go over a power of two boundary.</span></td>
        </tr>
        <tr>
          <td id="L764" data-line-number="764"></td>
          <td id="LC764">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L765" data-line-number="765"></td>
          <td id="LC765">	<span><span>//</span>/    4, 5, 8 -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L766" data-line-number="766"></td>
          <td id="LC766">	<span><span>//</span>/    5, 9, 8 -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L767" data-line-number="767"></td>
          <td id="LC767">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L768" data-line-number="768"></td>
          <td id="LC768">	<span>inline</span> <span>bool</span> <span>CrossesPowerOf2</span>(T x, T y, T n){</td>
        </tr>
        <tr>
          <td id="L769" data-line-number="769"></td>
          <td id="LC769">		<span>return</span> (n - (x &amp; (n - <span>1</span>))) &lt; (y - x);</td>
        </tr>
        <tr>
          <td id="L770" data-line-number="770"></td>
          <td id="LC770">	}</td>
        </tr>
        <tr>
          <td id="L771" data-line-number="771"></td>
          <td id="LC771">
</td>
        </tr>
        <tr>
          <td id="L772" data-line-number="772"></td>
          <td id="LC772">	<span><span>//</span>/ CrossesPowerOf2</span></td>
        </tr>
        <tr>
          <td id="L773" data-line-number="773"></td>
          <td id="LC773">	<span><span>//</span>/ How to detect a specific power of two crossing between two integers.</span></td>
        </tr>
        <tr>
          <td id="L774" data-line-number="774"></td>
          <td id="LC774">	<span><span>//</span>/ Template parameter n must be an even power of 2, such as 1, 2, 4, 8, 16, etc.</span></td>
        </tr>
        <tr>
          <td id="L775" data-line-number="775"></td>
          <td id="LC775">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L776" data-line-number="776"></td>
          <td id="LC776">	<span><span>//</span>/    CrossesPowerOf2&lt;8&gt;(3, 5)  -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L777" data-line-number="777"></td>
          <td id="LC777">	<span><span>//</span>/    CrossesPowerOf2&lt;8&gt;(7, 30) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L778" data-line-number="778"></td>
          <td id="LC778">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L779" data-line-number="779"></td>
          <td id="LC779">	<span>inline</span> <span>bool</span> <span>CrossesPowerOf2</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L780" data-line-number="780"></td>
          <td id="LC780">		<span>return</span> (n - (x &amp; (n - <span>1</span>))) &lt; (y - x);</td>
        </tr>
        <tr>
          <td id="L781" data-line-number="781"></td>
          <td id="LC781">	}</td>
        </tr>
        <tr>
          <td id="L782" data-line-number="782"></td>
          <td id="LC782">
</td>
        </tr>
        <tr>
          <td id="L783" data-line-number="783"></td>
          <td id="LC783">	<span><span>//</span>///////////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L784" data-line-number="784"></td>
          <td id="LC784">	<span><span>//</span> GetHighestBitPowerOf2 template</span></td>
        </tr>
        <tr>
          <td id="L785" data-line-number="785"></td>
          <td id="LC785">	<span><span>//</span></span></td>
        </tr>
        <tr>
          <td id="L786" data-line-number="786"></td>
          <td id="LC786">	<span><span>//</span> There is a templated compile-time constant version of GetHighestBitPowerOf2</span></td>
        </tr>
        <tr>
          <td id="L787" data-line-number="787"></td>
          <td id="LC787">	<span><span>//</span> but it is called Log2Uint32 / Log2Int32 / Log2Uint64 / Log2Int64. See below</span></td>
        </tr>
        <tr>
          <td id="L788" data-line-number="788"></td>
          <td id="LC788">	<span><span>//</span> for that template definition.</span></td>
        </tr>
        <tr>
          <td id="L789" data-line-number="789"></td>
          <td id="LC789">	<span><span>//</span>///////////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L790" data-line-number="790"></td>
          <td id="LC790">
</td>
        </tr>
        <tr>
          <td id="L791" data-line-number="791"></td>
          <td id="LC791">
</td>
        </tr>
        <tr>
          <td id="L792" data-line-number="792"></td>
          <td id="LC792">	<span><span>//</span>/ GetHighestBitPowerOf2 (a.k.a. GetHighestBitIndex)</span></td>
        </tr>
        <tr>
          <td id="L793" data-line-number="793"></td>
          <td id="LC793">	<span><span>//</span>/ How to detect the power of 2 of the highest bit set in a uint32_t.</span></td>
        </tr>
        <tr>
          <td id="L794" data-line-number="794"></td>
          <td id="LC794">	<span><span>//</span>/ The power of 2 is the same as the bit index, so this could also be </span></td>
        </tr>
        <tr>
          <td id="L795" data-line-number="795"></td>
          <td id="LC795">	<span><span>//</span>/ called GetHighestBitIndex.</span></td>
        </tr>
        <tr>
          <td id="L796" data-line-number="796"></td>
          <td id="LC796">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L797" data-line-number="797"></td>
          <td id="LC797">	<span><span>//</span>/ Returns a value in the range of [0, 31]</span></td>
        </tr>
        <tr>
          <td id="L798" data-line-number="798"></td>
          <td id="LC798">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L799" data-line-number="799"></td>
          <td id="LC799">	<span><span>//</span>/    GetHighestBitPowerOf2(0)  -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L800" data-line-number="800"></td>
          <td id="LC800">	<span><span>//</span>/    GetHighestBitPowerOf2(1)  -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L801" data-line-number="801"></td>
          <td id="LC801">	<span><span>//</span>/    GetHighestBitPowerOf2(2)  -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L802" data-line-number="802"></td>
          <td id="LC802">	<span><span>//</span>/    GetHighestBitPowerOf2(3)  -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L803" data-line-number="803"></td>
          <td id="LC803">	<span><span>//</span>/    GetHighestBitPowerOf2(4)  -&gt; 2</span></td>
        </tr>
        <tr>
          <td id="L804" data-line-number="804"></td>
          <td id="LC804">	<span><span>//</span>/    GetHighestBitPowerOf2(7)  -&gt; 2</span></td>
        </tr>
        <tr>
          <td id="L805" data-line-number="805"></td>
          <td id="LC805">	<span><span>//</span>/    GetHighestBitPowerOf2(8)  -&gt; 3</span></td>
        </tr>
        <tr>
          <td id="L806" data-line-number="806"></td>
          <td id="LC806">	<span>inline</span> <span>uint32_t</span> <span>GetHighestBitPowerOf2</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L807" data-line-number="807"></td>
          <td id="LC807">		<span>uint32_t</span> r = <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L808" data-line-number="808"></td>
          <td id="LC808">
</td>
        </tr>
        <tr>
          <td id="L809" data-line-number="809"></td>
          <td id="LC809">		<span>if</span>(x &amp; <span>0xffff0000</span>){</td>
        </tr>
        <tr>
          <td id="L810" data-line-number="810"></td>
          <td id="LC810">			r  += <span>16</span>;</td>
        </tr>
        <tr>
          <td id="L811" data-line-number="811"></td>
          <td id="LC811">			x &gt;&gt;= <span>16</span>;</td>
        </tr>
        <tr>
          <td id="L812" data-line-number="812"></td>
          <td id="LC812">		}</td>
        </tr>
        <tr>
          <td id="L813" data-line-number="813"></td>
          <td id="LC813">		<span>if</span>(x &amp; <span>0xff00</span>){</td>
        </tr>
        <tr>
          <td id="L814" data-line-number="814"></td>
          <td id="LC814">			r  += <span>8</span>;</td>
        </tr>
        <tr>
          <td id="L815" data-line-number="815"></td>
          <td id="LC815">			x &gt;&gt;= <span>8</span>;</td>
        </tr>
        <tr>
          <td id="L816" data-line-number="816"></td>
          <td id="LC816">		}</td>
        </tr>
        <tr>
          <td id="L817" data-line-number="817"></td>
          <td id="LC817">		<span>if</span>(x &amp; <span>0xf0</span>){</td>
        </tr>
        <tr>
          <td id="L818" data-line-number="818"></td>
          <td id="LC818">			r  += <span>4</span>;</td>
        </tr>
        <tr>
          <td id="L819" data-line-number="819"></td>
          <td id="LC819">			x &gt;&gt;= <span>4</span>;</td>
        </tr>
        <tr>
          <td id="L820" data-line-number="820"></td>
          <td id="LC820">		}</td>
        </tr>
        <tr>
          <td id="L821" data-line-number="821"></td>
          <td id="LC821">		<span>if</span>(x &amp; <span>0x0c</span>){</td>
        </tr>
        <tr>
          <td id="L822" data-line-number="822"></td>
          <td id="LC822">			r  += <span>2</span>;</td>
        </tr>
        <tr>
          <td id="L823" data-line-number="823"></td>
          <td id="LC823">			x &gt;&gt;= <span>2</span>;</td>
        </tr>
        <tr>
          <td id="L824" data-line-number="824"></td>
          <td id="LC824">		}</td>
        </tr>
        <tr>
          <td id="L825" data-line-number="825"></td>
          <td id="LC825">		<span>if</span>(x &amp; <span>0x02</span>){</td>
        </tr>
        <tr>
          <td id="L826" data-line-number="826"></td>
          <td id="LC826">			r  += <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L827" data-line-number="827"></td>
          <td id="LC827">		}</td>
        </tr>
        <tr>
          <td id="L828" data-line-number="828"></td>
          <td id="LC828">
</td>
        </tr>
        <tr>
          <td id="L829" data-line-number="829"></td>
          <td id="LC829">		<span>return</span> r;</td>
        </tr>
        <tr>
          <td id="L830" data-line-number="830"></td>
          <td id="LC830">	}</td>
        </tr>
        <tr>
          <td id="L831" data-line-number="831"></td>
          <td id="LC831">
</td>
        </tr>
        <tr>
          <td id="L832" data-line-number="832"></td>
          <td id="LC832">
</td>
        </tr>
        <tr>
          <td id="L833" data-line-number="833"></td>
          <td id="LC833">	<span><span>//</span>/ GetHighestBitPowerOf2 (a.k.a. GetHighestBitIndex)</span></td>
        </tr>
        <tr>
          <td id="L834" data-line-number="834"></td>
          <td id="LC834">	<span><span>//</span>/ How to detect the power of 2 of the highest bit set in a uint64_t.</span></td>
        </tr>
        <tr>
          <td id="L835" data-line-number="835"></td>
          <td id="LC835">	<span><span>//</span>/ The power of 2 is the same as the bit index, so this could also be </span></td>
        </tr>
        <tr>
          <td id="L836" data-line-number="836"></td>
          <td id="LC836">	<span><span>//</span>/ called GetHighestBitIndex.</span></td>
        </tr>
        <tr>
          <td id="L837" data-line-number="837"></td>
          <td id="LC837">	<span><span>//</span>/ Returns a value in the range of [0, 63]</span></td>
        </tr>
        <tr>
          <td id="L838" data-line-number="838"></td>
          <td id="LC838">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L839" data-line-number="839"></td>
          <td id="LC839">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L840" data-line-number="840"></td>
          <td id="LC840">	<span><span>//</span>/    GetHighestBitPowerOf2(0)  -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L841" data-line-number="841"></td>
          <td id="LC841">	<span><span>//</span>/    GetHighestBitPowerOf2(1)  -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L842" data-line-number="842"></td>
          <td id="LC842">	<span><span>//</span>/    GetHighestBitPowerOf2(2)  -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L843" data-line-number="843"></td>
          <td id="LC843">	<span><span>//</span>/    GetHighestBitPowerOf2(3)  -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L844" data-line-number="844"></td>
          <td id="LC844">	<span><span>//</span>/    GetHighestBitPowerOf2(4)  -&gt; 2</span></td>
        </tr>
        <tr>
          <td id="L845" data-line-number="845"></td>
          <td id="LC845">	<span><span>//</span>/    GetHighestBitPowerOf2(7)  -&gt; 2</span></td>
        </tr>
        <tr>
          <td id="L846" data-line-number="846"></td>
          <td id="LC846">	<span><span>//</span>/    GetHighestBitPowerOf2(8)  -&gt; 3</span></td>
        </tr>
        <tr>
          <td id="L847" data-line-number="847"></td>
          <td id="LC847">	<span>inline</span> <span>uint32_t</span> <span>GetHighestBitPowerOf2</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L848" data-line-number="848"></td>
          <td id="LC848">		<span>uint32_t</span> r = <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L849" data-line-number="849"></td>
          <td id="LC849">
</td>
        </tr>
        <tr>
          <td id="L850" data-line-number="850"></td>
          <td id="LC850">		<span>if</span>(x &amp; <span>UINT64_C</span>(<span>0xffffffff00000000</span>)){</td>
        </tr>
        <tr>
          <td id="L851" data-line-number="851"></td>
          <td id="LC851">			r  += <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L852" data-line-number="852"></td>
          <td id="LC852">			x &gt;&gt;= <span>32</span>;</td>
        </tr>
        <tr>
          <td id="L853" data-line-number="853"></td>
          <td id="LC853">		}</td>
        </tr>
        <tr>
          <td id="L854" data-line-number="854"></td>
          <td id="LC854">
</td>
        </tr>
        <tr>
          <td id="L855" data-line-number="855"></td>
          <td id="LC855">		<span>return</span> <span>GetHighestBitPowerOf2</span>((<span>uint32_t</span>)x) + r;</td>
        </tr>
        <tr>
          <td id="L856" data-line-number="856"></td>
          <td id="LC856">	}</td>
        </tr>
        <tr>
          <td id="L857" data-line-number="857"></td>
          <td id="LC857">
</td>
        </tr>
        <tr>
          <td id="L858" data-line-number="858"></td>
          <td id="LC858">
</td>
        </tr>
        <tr>
          <td id="L859" data-line-number="859"></td>
          <td id="LC859">	<span><span>//</span>/ GetNextGreaterEven</span></td>
        </tr>
        <tr>
          <td id="L860" data-line-number="860"></td>
          <td id="LC860">	<span><span>//</span>/ Returns the next higher even integer. </span></td>
        </tr>
        <tr>
          <td id="L861" data-line-number="861"></td>
          <td id="LC861">	<span><span>//</span>/ Returns an even number, not necessarily a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L862" data-line-number="862"></td>
          <td id="LC862">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L863" data-line-number="863"></td>
          <td id="LC863">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;(-3)  -&gt; -2</span></td>
        </tr>
        <tr>
          <td id="L864" data-line-number="864"></td>
          <td id="LC864">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;(-2)  -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L865" data-line-number="865"></td>
          <td id="LC865">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;(-1)  -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L866" data-line-number="866"></td>
          <td id="LC866">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;( 0)  -&gt;  2</span></td>
        </tr>
        <tr>
          <td id="L867" data-line-number="867"></td>
          <td id="LC867">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;( 1)  -&gt;  2</span></td>
        </tr>
        <tr>
          <td id="L868" data-line-number="868"></td>
          <td id="LC868">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;( 2)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L869" data-line-number="869"></td>
          <td id="LC869">	<span><span>//</span>/    GetNextGreaterEven&lt;int&gt;( 3)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L870" data-line-number="870"></td>
          <td id="LC870">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L871" data-line-number="871"></td>
          <td id="LC871">	<span>inline</span> T <span>GetNextGreaterEven</span>(T x)</td>
        </tr>
        <tr>
          <td id="L872" data-line-number="872"></td>
          <td id="LC872">	{</td>
        </tr>
        <tr>
          <td id="L873" data-line-number="873"></td>
          <td id="LC873">		<span>return</span> (x + <span>2</span>) &amp; -<span>2</span>;</td>
        </tr>
        <tr>
          <td id="L874" data-line-number="874"></td>
          <td id="LC874">	}</td>
        </tr>
        <tr>
          <td id="L875" data-line-number="875"></td>
          <td id="LC875">
</td>
        </tr>
        <tr>
          <td id="L876" data-line-number="876"></td>
          <td id="LC876">	<span><span>//</span>/ GetNextGreaterOdd</span></td>
        </tr>
        <tr>
          <td id="L877" data-line-number="877"></td>
          <td id="LC877">	<span><span>//</span>/ Returns the next higher odd integer. </span></td>
        </tr>
        <tr>
          <td id="L878" data-line-number="878"></td>
          <td id="LC878">	<span><span>//</span>/ Returns an even number, not necessarily a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L879" data-line-number="879"></td>
          <td id="LC879">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L880" data-line-number="880"></td>
          <td id="LC880">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;(-3)  -&gt; -1</span></td>
        </tr>
        <tr>
          <td id="L881" data-line-number="881"></td>
          <td id="LC881">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;(-2)  -&gt; -1</span></td>
        </tr>
        <tr>
          <td id="L882" data-line-number="882"></td>
          <td id="LC882">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;(-1)  -&gt;  1</span></td>
        </tr>
        <tr>
          <td id="L883" data-line-number="883"></td>
          <td id="LC883">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;( 0)  -&gt;  1</span></td>
        </tr>
        <tr>
          <td id="L884" data-line-number="884"></td>
          <td id="LC884">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;( 1)  -&gt;  3</span></td>
        </tr>
        <tr>
          <td id="L885" data-line-number="885"></td>
          <td id="LC885">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;( 2)  -&gt;  3</span></td>
        </tr>
        <tr>
          <td id="L886" data-line-number="886"></td>
          <td id="LC886">	<span><span>//</span>/    GetNextGreaterOdd&lt;int&gt;( 3)  -&gt;  5</span></td>
        </tr>
        <tr>
          <td id="L887" data-line-number="887"></td>
          <td id="LC887">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L888" data-line-number="888"></td>
          <td id="LC888">	<span>inline</span> T <span>GetNextGreaterOdd</span>(T x)</td>
        </tr>
        <tr>
          <td id="L889" data-line-number="889"></td>
          <td id="LC889">	{</td>
        </tr>
        <tr>
          <td id="L890" data-line-number="890"></td>
          <td id="LC890">		<span>return</span> ((x + <span>1</span>) &amp; -<span>2</span>) + <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L891" data-line-number="891"></td>
          <td id="LC891">	}</td>
        </tr>
        <tr>
          <td id="L892" data-line-number="892"></td>
          <td id="LC892">
</td>
        </tr>
        <tr>
          <td id="L893" data-line-number="893"></td>
          <td id="LC893">	<span><span>//</span>/ RoundUpTo</span></td>
        </tr>
        <tr>
          <td id="L894" data-line-number="894"></td>
          <td id="LC894">	<span><span>//</span>/ Template constant n is required to be a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L895" data-line-number="895"></td>
          <td id="LC895">	<span><span>//</span>/ Rounds values towards positive infinity.</span></td>
        </tr>
        <tr>
          <td id="L896" data-line-number="896"></td>
          <td id="LC896">	<span><span>//</span>/ Returns 0 for an input of 0.  </span></td>
        </tr>
        <tr>
          <td id="L897" data-line-number="897"></td>
          <td id="LC897">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L898" data-line-number="898"></td>
          <td id="LC898">	<span><span>//</span>/    RoundUpTo&lt;int, 4&gt;(3)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L899" data-line-number="899"></td>
          <td id="LC899">	<span><span>//</span>/    RoundUpTo&lt;int, 4&gt;(8)  -&gt;  8</span></td>
        </tr>
        <tr>
          <td id="L900" data-line-number="900"></td>
          <td id="LC900">	<span><span>//</span>/    RoundUpTo&lt;int, 4&gt;(0)  -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L901" data-line-number="901"></td>
          <td id="LC901">	<span><span>//</span>/    RoundUpTo&lt;int, 4&gt;(-7) -&gt; -4</span></td>
        </tr>
        <tr>
          <td id="L902" data-line-number="902"></td>
          <td id="LC902">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L903" data-line-number="903"></td>
          <td id="LC903">	<span>inline</span> T <span>RoundUpTo</span>(T x){</td>
        </tr>
        <tr>
          <td id="L904" data-line-number="904"></td>
          <td id="LC904">		<span>return</span> (T)((x + (n - <span>1</span>)) &amp; (T)-n);</td>
        </tr>
        <tr>
          <td id="L905" data-line-number="905"></td>
          <td id="LC905">	}</td>
        </tr>
        <tr>
          <td id="L906" data-line-number="906"></td>
          <td id="LC906">
</td>
        </tr>
        <tr>
          <td id="L907" data-line-number="907"></td>
          <td id="LC907">
</td>
        </tr>
        <tr>
          <td id="L908" data-line-number="908"></td>
          <td id="LC908">	<span><span>//</span>/ RoundUpToEx</span></td>
        </tr>
        <tr>
          <td id="L909" data-line-number="909"></td>
          <td id="LC909">	<span><span>//</span>/ Template constant n is required to be a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L910" data-line-number="910"></td>
          <td id="LC910">	<span><span>//</span>/ Rounds values away from zero.</span></td>
        </tr>
        <tr>
          <td id="L911" data-line-number="911"></td>
          <td id="LC911">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L912" data-line-number="912"></td>
          <td id="LC912">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L913" data-line-number="913"></td>
          <td id="LC913">	<span><span>//</span>/    RoundUpToEx&lt;int, 4&gt;(3)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L914" data-line-number="914"></td>
          <td id="LC914">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L915" data-line-number="915"></td>
          <td id="LC915">	<span>template </span>&lt;<span>bool</span> is_signed&gt;</td>
        </tr>
        <tr>
          <td id="L916" data-line-number="916"></td>
          <td id="LC916">	<span>struct</span> <span>RoundUpToExStruct</span></td>
        </tr>
        <tr>
          <td id="L917" data-line-number="917"></td>
          <td id="LC917">	{</td>
        </tr>
        <tr>
          <td id="L918" data-line-number="918"></td>
          <td id="LC918">		<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L919" data-line-number="919"></td>
          <td id="LC919">		<span>static</span> T <span>RoundUpToEx</span>(T x){</td>
        </tr>
        <tr>
          <td id="L920" data-line-number="920"></td>
          <td id="LC920">			<span>if</span>(x &gt;= <span>0</span>)</td>
        </tr>
        <tr>
          <td id="L921" data-line-number="921"></td>
          <td id="LC921">				<span>return</span> (T)((x + (n - <span>1</span>)) &amp; (T)-n);</td>
        </tr>
        <tr>
          <td id="L922" data-line-number="922"></td>
          <td id="LC922">			<span>return</span> (T)-(bt_signed)((-(bt_signed)x + (n - <span>1</span>)) &amp; (T)-n);</td>
        </tr>
        <tr>
          <td id="L923" data-line-number="923"></td>
          <td id="LC923">		}</td>
        </tr>
        <tr>
          <td id="L924" data-line-number="924"></td>
          <td id="LC924">	};</td>
        </tr>
        <tr>
          <td id="L925" data-line-number="925"></td>
          <td id="LC925">
</td>
        </tr>
        <tr>
          <td id="L926" data-line-number="926"></td>
          <td id="LC926">	<span>template </span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L927" data-line-number="927"></td>
          <td id="LC927">	<span>struct</span> <span>RoundUpToExStruct</span>&lt;<span>false</span>&gt;</td>
        </tr>
        <tr>
          <td id="L928" data-line-number="928"></td>
          <td id="LC928">	{</td>
        </tr>
        <tr>
          <td id="L929" data-line-number="929"></td>
          <td id="LC929">		<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L930" data-line-number="930"></td>
          <td id="LC930">		<span>static</span> T <span>RoundUpToEx</span>(T x){</td>
        </tr>
        <tr>
          <td id="L931" data-line-number="931"></td>
          <td id="LC931">			<span>return</span> (T)((x + (n - <span>1</span>)) &amp; (T)-n);</td>
        </tr>
        <tr>
          <td id="L932" data-line-number="932"></td>
          <td id="LC932">		}</td>
        </tr>
        <tr>
          <td id="L933" data-line-number="933"></td>
          <td id="LC933">	};</td>
        </tr>
        <tr>
          <td id="L934" data-line-number="934"></td>
          <td id="LC934">
</td>
        </tr>
        <tr>
          <td id="L935" data-line-number="935"></td>
          <td id="LC935">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L936" data-line-number="936"></td>
          <td id="LC936">	<span>inline</span> T <span>RoundUpToEx</span>(T x){</td>
        </tr>
        <tr>
          <td id="L937" data-line-number="937"></td>
          <td id="LC937">		<span>return</span> RoundUpToExStruct&lt;bt_is_signed&gt;::<span>template</span> RoundUpToEx&lt;T, n&gt;(x);</td>
        </tr>
        <tr>
          <td id="L938" data-line-number="938"></td>
          <td id="LC938">	}</td>
        </tr>
        <tr>
          <td id="L939" data-line-number="939"></td>
          <td id="LC939">	</td>
        </tr>
        <tr>
          <td id="L940" data-line-number="940"></td>
          <td id="LC940">
</td>
        </tr>
        <tr>
          <td id="L941" data-line-number="941"></td>
          <td id="LC941">	<span><span>//</span>/ RoundDownTo</span></td>
        </tr>
        <tr>
          <td id="L942" data-line-number="942"></td>
          <td id="LC942">	<span><span>//</span>/ Template constant n is required to be a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L943" data-line-number="943"></td>
          <td id="LC943">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L944" data-line-number="944"></td>
          <td id="LC944">	<span><span>//</span>/ Rounds values towards negative infinity.</span></td>
        </tr>
        <tr>
          <td id="L945" data-line-number="945"></td>
          <td id="LC945">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L946" data-line-number="946"></td>
          <td id="LC946">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(5)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L947" data-line-number="947"></td>
          <td id="LC947">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(4)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L948" data-line-number="948"></td>
          <td id="LC948">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(0)  -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L949" data-line-number="949"></td>
          <td id="LC949">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(-7) -&gt; -8</span></td>
        </tr>
        <tr>
          <td id="L950" data-line-number="950"></td>
          <td id="LC950">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L951" data-line-number="951"></td>
          <td id="LC951">	<span>inline</span> T <span>RoundDownTo</span>(T x){</td>
        </tr>
        <tr>
          <td id="L952" data-line-number="952"></td>
          <td id="LC952">		<span>return</span> (T)(x &amp; ~(n - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L953" data-line-number="953"></td>
          <td id="LC953">	}</td>
        </tr>
        <tr>
          <td id="L954" data-line-number="954"></td>
          <td id="LC954">
</td>
        </tr>
        <tr>
          <td id="L955" data-line-number="955"></td>
          <td id="LC955">	<span><span>//</span>/ RoundDownToEx</span></td>
        </tr>
        <tr>
          <td id="L956" data-line-number="956"></td>
          <td id="LC956">	<span><span>//</span>/ Template constant n is required to be a power of 2.</span></td>
        </tr>
        <tr>
          <td id="L957" data-line-number="957"></td>
          <td id="LC957">	<span><span>//</span>/ Returns 0 for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L958" data-line-number="958"></td>
          <td id="LC958">	<span><span>//</span>/ Rounds values towards zero.</span></td>
        </tr>
        <tr>
          <td id="L959" data-line-number="959"></td>
          <td id="LC959">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L960" data-line-number="960"></td>
          <td id="LC960">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(5)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L961" data-line-number="961"></td>
          <td id="LC961">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(4)  -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L962" data-line-number="962"></td>
          <td id="LC962">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(0)  -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L963" data-line-number="963"></td>
          <td id="LC963">	<span><span>//</span>/    RoundDownTo&lt;int, 4&gt;(-7) -&gt; -4</span></td>
        </tr>
        <tr>
          <td id="L964" data-line-number="964"></td>
          <td id="LC964">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L965" data-line-number="965"></td>
          <td id="LC965">	<span>template </span>&lt;<span>bool</span> is_signed&gt;</td>
        </tr>
        <tr>
          <td id="L966" data-line-number="966"></td>
          <td id="LC966">	<span>struct</span> <span>RoundDownToExStruct</span></td>
        </tr>
        <tr>
          <td id="L967" data-line-number="967"></td>
          <td id="LC967">	{</td>
        </tr>
        <tr>
          <td id="L968" data-line-number="968"></td>
          <td id="LC968">		<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L969" data-line-number="969"></td>
          <td id="LC969">		<span>static</span> T <span>RoundDownToEx</span>(T x){</td>
        </tr>
        <tr>
          <td id="L970" data-line-number="970"></td>
          <td id="LC970">			<span>if</span>(x &gt;= <span>0</span>)</td>
        </tr>
        <tr>
          <td id="L971" data-line-number="971"></td>
          <td id="LC971">				<span>return</span> (T)(x &amp; ~(n - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L972" data-line-number="972"></td>
          <td id="LC972">			<span>return</span> (T)-(bt_signed)(-(bt_signed)x &amp; ~(n - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L973" data-line-number="973"></td>
          <td id="LC973">		}</td>
        </tr>
        <tr>
          <td id="L974" data-line-number="974"></td>
          <td id="LC974">	};</td>
        </tr>
        <tr>
          <td id="L975" data-line-number="975"></td>
          <td id="LC975">
</td>
        </tr>
        <tr>
          <td id="L976" data-line-number="976"></td>
          <td id="LC976">	<span>template </span>&lt;&gt;</td>
        </tr>
        <tr>
          <td id="L977" data-line-number="977"></td>
          <td id="LC977">	<span>struct</span> <span>RoundDownToExStruct</span>&lt;<span>false</span>&gt;</td>
        </tr>
        <tr>
          <td id="L978" data-line-number="978"></td>
          <td id="LC978">	{</td>
        </tr>
        <tr>
          <td id="L979" data-line-number="979"></td>
          <td id="LC979">		<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L980" data-line-number="980"></td>
          <td id="LC980">		<span>static</span> T <span>RoundDownToEx</span>(T x){</td>
        </tr>
        <tr>
          <td id="L981" data-line-number="981"></td>
          <td id="LC981">			<span>return</span> (T)(x &amp; ~(n - <span>1</span>));</td>
        </tr>
        <tr>
          <td id="L982" data-line-number="982"></td>
          <td id="LC982">		}</td>
        </tr>
        <tr>
          <td id="L983" data-line-number="983"></td>
          <td id="LC983">	};</td>
        </tr>
        <tr>
          <td id="L984" data-line-number="984"></td>
          <td id="LC984">
</td>
        </tr>
        <tr>
          <td id="L985" data-line-number="985"></td>
          <td id="LC985">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L986" data-line-number="986"></td>
          <td id="LC986">	<span>inline</span> T <span>RoundDownToEx</span>(T x){</td>
        </tr>
        <tr>
          <td id="L987" data-line-number="987"></td>
          <td id="LC987">		<span>return</span> RoundDownToExStruct&lt;bt_is_signed&gt;::<span>template</span> RoundDownToEx&lt;T, n&gt;(x);</td>
        </tr>
        <tr>
          <td id="L988" data-line-number="988"></td>
          <td id="LC988">	}</td>
        </tr>
        <tr>
          <td id="L989" data-line-number="989"></td>
          <td id="LC989">
</td>
        </tr>
        <tr>
          <td id="L990" data-line-number="990"></td>
          <td id="LC990">
</td>
        </tr>
        <tr>
          <td id="L991" data-line-number="991"></td>
          <td id="LC991">
</td>
        </tr>
        <tr>
          <td id="L992" data-line-number="992"></td>
          <td id="LC992">	<span><span>//</span>/ RoundUpToMultiple</span></td>
        </tr>
        <tr>
          <td id="L993" data-line-number="993"></td>
          <td id="LC993">	<span><span>//</span>/ This is a non-power of 2 function; n may be any value &gt; zero.</span></td>
        </tr>
        <tr>
          <td id="L994" data-line-number="994"></td>
          <td id="LC994">	<span><span>//</span>/ Rounds values towards infinity.</span></td>
        </tr>
        <tr>
          <td id="L995" data-line-number="995"></td>
          <td id="LC995">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L996" data-line-number="996"></td>
          <td id="LC996">	<span><span>//</span>/    RoundUpToMultiple&lt;int, 6&gt;(37)  -&gt;  42</span></td>
        </tr>
        <tr>
          <td id="L997" data-line-number="997"></td>
          <td id="LC997">	<span><span>//</span>/    RoundUpToMultiple&lt;int, 6&gt;(42)  -&gt;  42</span></td>
        </tr>
        <tr>
          <td id="L998" data-line-number="998"></td>
          <td id="LC998">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L999" data-line-number="999"></td>
          <td id="LC999">	<span>inline</span> T <span>RoundUpToMultiple</span>(T x){</td>
        </tr>
        <tr>
          <td id="L1000" data-line-number="1000"></td>
          <td id="LC1000">		<span>return</span> (T)(((x + (n - <span>1</span>)) / n) * n);</td>
        </tr>
        <tr>
          <td id="L1001" data-line-number="1001"></td>
          <td id="LC1001">	}</td>
        </tr>
        <tr>
          <td id="L1002" data-line-number="1002"></td>
          <td id="LC1002">
</td>
        </tr>
        <tr>
          <td id="L1003" data-line-number="1003"></td>
          <td id="LC1003">	<span><span>//</span>/ RoundDownToMultiple</span></td>
        </tr>
        <tr>
          <td id="L1004" data-line-number="1004"></td>
          <td id="LC1004">	<span><span>//</span>/ This is a non-power of 2 function; n may be any value &gt; zero.</span></td>
        </tr>
        <tr>
          <td id="L1005" data-line-number="1005"></td>
          <td id="LC1005">	<span><span>//</span>/ Rounds values towards zero.</span></td>
        </tr>
        <tr>
          <td id="L1006" data-line-number="1006"></td>
          <td id="LC1006">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1007" data-line-number="1007"></td>
          <td id="LC1007">	<span><span>//</span>/    RoundDownToMultiple&lt;int, 6&gt;(37)  -&gt;  36</span></td>
        </tr>
        <tr>
          <td id="L1008" data-line-number="1008"></td>
          <td id="LC1008">	<span><span>//</span>/    RoundDownToMultiple&lt;int, 6&gt;(36)  -&gt;  36</span></td>
        </tr>
        <tr>
          <td id="L1009" data-line-number="1009"></td>
          <td id="LC1009">	<span>template </span>&lt;<span>typename</span> T, <span>int</span> n&gt;</td>
        </tr>
        <tr>
          <td id="L1010" data-line-number="1010"></td>
          <td id="LC1010">	<span>inline</span> T <span>RoundDownToMultiple</span>(T x){</td>
        </tr>
        <tr>
          <td id="L1011" data-line-number="1011"></td>
          <td id="LC1011">		<span>return</span> (T)((x / n) * n);</td>
        </tr>
        <tr>
          <td id="L1012" data-line-number="1012"></td>
          <td id="LC1012">	}</td>
        </tr>
        <tr>
          <td id="L1013" data-line-number="1013"></td>
          <td id="LC1013">
</td>
        </tr>
        <tr>
          <td id="L1014" data-line-number="1014"></td>
          <td id="LC1014">
</td>
        </tr>
        <tr>
          <td id="L1015" data-line-number="1015"></td>
          <td id="LC1015">	<span><span>//</span>/ ZeroPresent8</span></td>
        </tr>
        <tr>
          <td id="L1016" data-line-number="1016"></td>
          <td id="LC1016">	<span><span>//</span>/ Returns true if a 0 byte is present in x.</span></td>
        </tr>
        <tr>
          <td id="L1017" data-line-number="1017"></td>
          <td id="LC1017">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1018" data-line-number="1018"></td>
          <td id="LC1018">	<span><span>//</span>/    ZeroPresent8(0xffffffff)  -&gt;  false</span></td>
        </tr>
        <tr>
          <td id="L1019" data-line-number="1019"></td>
          <td id="LC1019">	<span><span>//</span>/    ZeroPresent8(0xffff00ff)  -&gt;  true</span></td>
        </tr>
        <tr>
          <td id="L1020" data-line-number="1020"></td>
          <td id="LC1020">	<span>inline</span> <span>bool</span> <span>ZeroPresent8</span>(<span>uint32_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1021" data-line-number="1021"></td>
          <td id="LC1021">	{</td>
        </tr>
        <tr>
          <td id="L1022" data-line-number="1022"></td>
          <td id="LC1022">		<span>return</span> ((((x - <span>0x01010101</span>) &amp; ~x) &amp; <span>0x80808080</span>) != <span>0</span>); <span><span>//</span> Works because 0 is the only value for which subtracting 1 results in its high bit going from 0 to 1.</span></td>
        </tr>
        <tr>
          <td id="L1023" data-line-number="1023"></td>
          <td id="LC1023">	}</td>
        </tr>
        <tr>
          <td id="L1024" data-line-number="1024"></td>
          <td id="LC1024">
</td>
        </tr>
        <tr>
          <td id="L1025" data-line-number="1025"></td>
          <td id="LC1025">	<span>inline</span> <span>bool</span> <span>ZeroPresent8</span>(<span>uint64_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1026" data-line-number="1026"></td>
          <td id="LC1026">	{</td>
        </tr>
        <tr>
          <td id="L1027" data-line-number="1027"></td>
          <td id="LC1027">		<span>return</span> ((((x - <span>UINT64_C</span>(<span>0x0101010101010101</span>)) &amp; ~x) &amp; <span>UINT64_C</span>(<span>0x8080808080808080</span>)) != <span>0</span>);</td>
        </tr>
        <tr>
          <td id="L1028" data-line-number="1028"></td>
          <td id="LC1028">	}</td>
        </tr>
        <tr>
          <td id="L1029" data-line-number="1029"></td>
          <td id="LC1029">
</td>
        </tr>
        <tr>
          <td id="L1030" data-line-number="1030"></td>
          <td id="LC1030">
</td>
        </tr>
        <tr>
          <td id="L1031" data-line-number="1031"></td>
          <td id="LC1031">	<span><span>//</span>/ ZeroPresent16</span></td>
        </tr>
        <tr>
          <td id="L1032" data-line-number="1032"></td>
          <td id="LC1032">	<span><span>//</span>/ Returns true if an aligned uint16_t of 0 is present in x.</span></td>
        </tr>
        <tr>
          <td id="L1033" data-line-number="1033"></td>
          <td id="LC1033">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1034" data-line-number="1034"></td>
          <td id="LC1034">	<span><span>//</span>/    ZeroPresent16(0xffffffff)  -&gt;  false</span></td>
        </tr>
        <tr>
          <td id="L1035" data-line-number="1035"></td>
          <td id="LC1035">	<span><span>//</span>/    ZeroPresent16(0xff0000ff)  -&gt;  false   (There are 16 contiguous 0 bits, but they are not uint16_t aligned)</span></td>
        </tr>
        <tr>
          <td id="L1036" data-line-number="1036"></td>
          <td id="LC1036">	<span><span>//</span>/    ZeroPresent16(0x0000ffff)  -&gt;  true</span></td>
        </tr>
        <tr>
          <td id="L1037" data-line-number="1037"></td>
          <td id="LC1037">	<span>inline</span> <span>bool</span> <span>ZeroPresent16</span>(<span>uint32_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1038" data-line-number="1038"></td>
          <td id="LC1038">	{</td>
        </tr>
        <tr>
          <td id="L1039" data-line-number="1039"></td>
          <td id="LC1039">		<span>return</span> ((((x - <span>0x00010001</span>) &amp; ~x) &amp; <span>0x80008000</span>) != <span>0</span>);</td>
        </tr>
        <tr>
          <td id="L1040" data-line-number="1040"></td>
          <td id="LC1040">	}</td>
        </tr>
        <tr>
          <td id="L1041" data-line-number="1041"></td>
          <td id="LC1041">
</td>
        </tr>
        <tr>
          <td id="L1042" data-line-number="1042"></td>
          <td id="LC1042">	<span>inline</span> <span>bool</span> <span>ZeroPresent16</span>(<span>uint64_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1043" data-line-number="1043"></td>
          <td id="LC1043">	{</td>
        </tr>
        <tr>
          <td id="L1044" data-line-number="1044"></td>
          <td id="LC1044">		<span>return</span> ((((x - <span>UINT64_C</span>(<span>0x0001000100010001</span>)) &amp; ~x) &amp; <span>UINT64_C</span>(<span>0x8000800080008000</span>)) != <span>0</span>);</td>
        </tr>
        <tr>
          <td id="L1045" data-line-number="1045"></td>
          <td id="LC1045">	}</td>
        </tr>
        <tr>
          <td id="L1046" data-line-number="1046"></td>
          <td id="LC1046">
</td>
        </tr>
        <tr>
          <td id="L1047" data-line-number="1047"></td>
          <td id="LC1047">
</td>
        </tr>
        <tr>
          <td id="L1048" data-line-number="1048"></td>
          <td id="LC1048">	<span><span>//</span>/ ZeroPresent32</span></td>
        </tr>
        <tr>
          <td id="L1049" data-line-number="1049"></td>
          <td id="LC1049">	<span><span>//</span>/ Returns true if an aligned uint32_t of 0 is present in x.</span></td>
        </tr>
        <tr>
          <td id="L1050" data-line-number="1050"></td>
          <td id="LC1050">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1051" data-line-number="1051"></td>
          <td id="LC1051">	<span><span>//</span>/    ZeroPresent16(0xffffffffffffffff)  -&gt;  false</span></td>
        </tr>
        <tr>
          <td id="L1052" data-line-number="1052"></td>
          <td id="LC1052">	<span><span>//</span>/    ZeroPresent16(0xffffff00000000ff)  -&gt;  false   (There are 32 contiguous 0 bits, but they are not uint32_t aligned)</span></td>
        </tr>
        <tr>
          <td id="L1053" data-line-number="1053"></td>
          <td id="LC1053">	<span><span>//</span>/    ZeroPresent16(0xffffffff00000000)  -&gt;  true</span></td>
        </tr>
        <tr>
          <td id="L1054" data-line-number="1054"></td>
          <td id="LC1054">	<span>inline</span> <span>bool</span> <span>ZeroPresent32</span>(<span>uint64_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1055" data-line-number="1055"></td>
          <td id="LC1055">	{</td>
        </tr>
        <tr>
          <td id="L1056" data-line-number="1056"></td>
          <td id="LC1056">		<span>return</span> ((((x - <span>UINT64_C</span>(<span>0x0000000100000001</span>)) &amp; ~x) &amp; <span>UINT64_C</span>(<span>0x8000000080000000</span>)) != <span>0</span>);</td>
        </tr>
        <tr>
          <td id="L1057" data-line-number="1057"></td>
          <td id="LC1057">	  <span><span>//</span>return (((x &amp; 0xffffffff) == 0) || (x &gt;&gt; 32) == 0); // Alternative implementation which is slower.</span></td>
        </tr>
        <tr>
          <td id="L1058" data-line-number="1058"></td>
          <td id="LC1058">	}</td>
        </tr>
        <tr>
          <td id="L1059" data-line-number="1059"></td>
          <td id="LC1059">
</td>
        </tr>
        <tr>
          <td id="L1060" data-line-number="1060"></td>
          <td id="LC1060">
</td>
        </tr>
        <tr>
          <td id="L1061" data-line-number="1061"></td>
          <td id="LC1061">	<span><span>//</span>/ Log2</span></td>
        </tr>
        <tr>
          <td id="L1062" data-line-number="1062"></td>
          <td id="LC1062">	<span><span>//</span>/ How to find the integer base 2 log of an integer.</span></td>
        </tr>
        <tr>
          <td id="L1063" data-line-number="1063"></td>
          <td id="LC1063">	<span><span>//</span>/ It is frequently useful to tell what power of 2 a value corresponds to.</span></td>
        </tr>
        <tr>
          <td id="L1064" data-line-number="1064"></td>
          <td id="LC1064">	<span><span>//</span>/ This function rounds the input value down to the nearest power of </span></td>
        </tr>
        <tr>
          <td id="L1065" data-line-number="1065"></td>
          <td id="LC1065">	<span><span>//</span>/ 2 before testing. Thus an input of 17 returns 4. The function can be </span></td>
        </tr>
        <tr>
          <td id="L1066" data-line-number="1066"></td>
          <td id="LC1066">	<span><span>//</span>/ made to round up by doing a standard power of 2 round-up at the </span></td>
        </tr>
        <tr>
          <td id="L1067" data-line-number="1067"></td>
          <td id="LC1067">	<span><span>//</span>/ beginning of the function.</span></td>
        </tr>
        <tr>
          <td id="L1068" data-line-number="1068"></td>
          <td id="LC1068">	<span><span>//</span>/ This function doesn&#39;t work for an input of 0.</span></td>
        </tr>
        <tr>
          <td id="L1069" data-line-number="1069"></td>
          <td id="LC1069">	<span><span>//</span>/ This function only works for unsigned integers.</span></td>
        </tr>
        <tr>
          <td id="L1070" data-line-number="1070"></td>
          <td id="LC1070">	<span><span>//</span>/ For example, given &#34;2^y = x&#34; and you want to solve for y, you say:</span></td>
        </tr>
        <tr>
          <td id="L1071" data-line-number="1071"></td>
          <td id="LC1071">	<span><span>//</span>/     y = Log2(x);</span></td>
        </tr>
        <tr>
          <td id="L1072" data-line-number="1072"></td>
          <td id="LC1072">	<span><span>//</span>/ Assumes 32 bit IEEE float.</span></td>
        </tr>
        <tr>
          <td id="L1073" data-line-number="1073"></td>
          <td id="LC1073">	<span><span>//</span>/ Note: This function yields incorrect answers for very large integers.</span></td>
        </tr>
        <tr>
          <td id="L1074" data-line-number="1074"></td>
          <td id="LC1074">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1075" data-line-number="1075"></td>
          <td id="LC1075">	<span><span>//</span>/     4 -&gt; 2</span></td>
        </tr>
        <tr>
          <td id="L1076" data-line-number="1076"></td>
          <td id="LC1076">	<span><span>//</span>/     8 -&gt; 3</span></td>
        </tr>
        <tr>
          <td id="L1077" data-line-number="1077"></td>
          <td id="LC1077">	<span><span>//</span>/    11 -&gt; 3</span></td>
        </tr>
        <tr>
          <td id="L1078" data-line-number="1078"></td>
          <td id="LC1078">	<span><span>//</span>/    16 -&gt; 4</span></td>
        </tr>
        <tr>
          <td id="L1079" data-line-number="1079"></td>
          <td id="LC1079">	<span><span>//</span>/     0 -&gt; error</span></td>
        </tr>
        <tr>
          <td id="L1080" data-line-number="1080"></td>
          <td id="LC1080">	<span><span>//</span>/     </span></td>
        </tr>
        <tr>
          <td id="L1081" data-line-number="1081"></td>
          <td id="LC1081">	<span>inline</span> <span>uint32_t</span> <span>Log2</span>(<span>uint32_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1082" data-line-number="1082"></td>
          <td id="LC1082">	{</td>
        </tr>
        <tr>
          <td id="L1083" data-line-number="1083"></td>
          <td id="LC1083">		<span>const</span> <span>union</span> { <span>float</span> f; <span>uint32_t</span> i; } converter = { (<span>float</span>)x };</td>
        </tr>
        <tr>
          <td id="L1084" data-line-number="1084"></td>
          <td id="LC1084">		<span>return</span> (converter.<span>i</span> &gt;&gt; <span>23</span>) - <span>127</span>;</td>
        </tr>
        <tr>
          <td id="L1085" data-line-number="1085"></td>
          <td id="LC1085">	}</td>
        </tr>
        <tr>
          <td id="L1086" data-line-number="1086"></td>
          <td id="LC1086">
</td>
        </tr>
        <tr>
          <td id="L1087" data-line-number="1087"></td>
          <td id="LC1087">	<span>inline</span> <span>uint64_t</span> <span>Log2</span>(<span>uint64_t</span> x)</td>
        </tr>
        <tr>
          <td id="L1088" data-line-number="1088"></td>
          <td id="LC1088">	{</td>
        </tr>
        <tr>
          <td id="L1089" data-line-number="1089"></td>
          <td id="LC1089">		<span>const</span> <span>union</span> { <span>double</span> f; <span>uint64_t</span> i; } converter = { (<span>double</span>)x };</td>
        </tr>
        <tr>
          <td id="L1090" data-line-number="1090"></td>
          <td id="LC1090">		<span>return</span> ((converter.<span>i</span> &gt;&gt; <span>52</span>) &amp; <span>0x7ff</span>) - <span>1023</span>;</td>
        </tr>
        <tr>
          <td id="L1091" data-line-number="1091"></td>
          <td id="LC1091">	}</td>
        </tr>
        <tr>
          <td id="L1092" data-line-number="1092"></td>
          <td id="LC1092">
</td>
        </tr>
        <tr>
          <td id="L1093" data-line-number="1093"></td>
          <td id="LC1093">
</td>
        </tr>
        <tr>
          <td id="L1094" data-line-number="1094"></td>
          <td id="LC1094">	<span><span>//</span>/ CeilLog2</span></td>
        </tr>
        <tr>
          <td id="L1095" data-line-number="1095"></td>
          <td id="LC1095">	<span><span>//</span>/ Generates the ceiling of Log2.</span></td>
        </tr>
        <tr>
          <td id="L1096" data-line-number="1096"></td>
          <td id="LC1096">	<span><span>//</span>/ This function exists to deal with errors generated by Log2 under</span></td>
        </tr>
        <tr>
          <td id="L1097" data-line-number="1097"></td>
          <td id="LC1097">	<span><span>//</span>/ the case of very large numbers.</span></td>
        </tr>
        <tr>
          <td id="L1098" data-line-number="1098"></td>
          <td id="LC1098">	<span>inline</span> <span>uint32_t</span> <span>CeilLog2</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1099" data-line-number="1099"></td>
          <td id="LC1099">		<span>const</span> <span>union</span> { <span>float</span> f; <span>uint32_t</span> i; } converter = { (<span>float</span>)x };</td>
        </tr>
        <tr>
          <td id="L1100" data-line-number="1100"></td>
          <td id="LC1100">		<span>return</span> (converter.<span>i</span> - <span>0x3F000001</span>) &gt;&gt; <span>23</span>;</td>
        </tr>
        <tr>
          <td id="L1101" data-line-number="1101"></td>
          <td id="LC1101">	}</td>
        </tr>
        <tr>
          <td id="L1102" data-line-number="1102"></td>
          <td id="LC1102">
</td>
        </tr>
        <tr>
          <td id="L1103" data-line-number="1103"></td>
          <td id="LC1103">	<span><span>//</span>inline uint64_t CeilLog2(uint64_t x){</span></td>
        </tr>
        <tr>
          <td id="L1104" data-line-number="1104"></td>
          <td id="LC1104">	<span><span>//</span>    const union { double f; uint64_t i; } converter = { (double)x };</span></td>
        </tr>
        <tr>
          <td id="L1105" data-line-number="1105"></td>
          <td id="LC1105">	<span><span>//</span>    return (converter.i - UINT64_C(0x________________)) &gt;&gt; 52;</span></td>
        </tr>
        <tr>
          <td id="L1106" data-line-number="1106"></td>
          <td id="LC1106">	<span><span>//</span>}</span></td>
        </tr>
        <tr>
          <td id="L1107" data-line-number="1107"></td>
          <td id="LC1107">
</td>
        </tr>
        <tr>
          <td id="L1108" data-line-number="1108"></td>
          <td id="LC1108">
</td>
        </tr>
        <tr>
          <td id="L1109" data-line-number="1109"></td>
          <td id="LC1109">	<span><span>//</span>/ Log2Uint32 / Log2Int32 / Log2Uint64 / Log2Int64</span></td>
        </tr>
        <tr>
          <td id="L1110" data-line-number="1110"></td>
          <td id="LC1110">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1111" data-line-number="1111"></td>
          <td id="LC1111">	<span><span>//</span>/ Evaluates to floor(log2(N)) for a compile-time constant value of N, </span></td>
        </tr>
        <tr>
          <td id="L1112" data-line-number="1112"></td>
          <td id="LC1112">	<span><span>//</span>/ with no runtime cost, for any N &gt; 0. This is the equivalent of a </span></td>
        </tr>
        <tr>
          <td id="L1113" data-line-number="1113"></td>
          <td id="LC1113">	<span><span>//</span>/ compile-time version of GetHighestBitPowerOf2, which gets the </span></td>
        </tr>
        <tr>
          <td id="L1114" data-line-number="1114"></td>
          <td id="LC1114">	<span><span>//</span>/ highest bit set in a value.</span></td>
        </tr>
        <tr>
          <td id="L1115" data-line-number="1115"></td>
          <td id="LC1115">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1116" data-line-number="1116"></td>
          <td id="LC1116">	<span><span>//</span>/ Example usage of Log2Uint32:</span></td>
        </tr>
        <tr>
          <td id="L1117" data-line-number="1117"></td>
          <td id="LC1117">	<span><span>//</span>/   Log2Uint32&lt;8&gt;::value evaluates to 3</span></td>
        </tr>
        <tr>
          <td id="L1118" data-line-number="1118"></td>
          <td id="LC1118">	<span><span>//</span>/   Log2Uint32&lt;0x7fffffff&gt;::value evaluates to 30</span></td>
        </tr>
        <tr>
          <td id="L1119" data-line-number="1119"></td>
          <td id="LC1119">	<span><span>//</span>/   Log2Uint64&lt;UINT64_C(0x1000000000000000)&gt;::value evaluates to 60</span></td>
        </tr>
        <tr>
          <td id="L1120" data-line-number="1120"></td>
          <td id="LC1120">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1121" data-line-number="1121"></td>
          <td id="LC1121">	<span>template </span>&lt;<span>uint32_t</span> N&gt; <span>struct</span> <span>Log2Uint32</span>    { <span>static</span> <span>const</span> <span>uint32_t</span> value = (<span>1</span> + Log2Uint32&lt;N/<span>2</span>&gt;::value); };</td>
        </tr>
        <tr>
          <td id="L1122" data-line-number="1122"></td>
          <td id="LC1122">	<span>template </span>&lt;&gt;           <span>struct</span> <span>Log2Uint32</span>&lt;<span>1</span>&gt; { <span>static</span> <span>const</span> <span>uint32_t</span> value =  <span>0</span>; };</td>
        </tr>
        <tr>
          <td id="L1123" data-line-number="1123"></td>
          <td id="LC1123">
</td>
        </tr>
        <tr>
          <td id="L1124" data-line-number="1124"></td>
          <td id="LC1124">	<span>template </span>&lt;<span>int32_t</span> N&gt;  <span>struct</span> <span>Log2Int32</span>     { <span>static</span> <span>const</span> <span>int32_t</span> value = (<span>1</span> + Log2Int32&lt;N/<span>2</span>&gt;::value); };</td>
        </tr>
        <tr>
          <td id="L1125" data-line-number="1125"></td>
          <td id="LC1125">	<span>template </span>&lt;&gt;           <span>struct</span> <span>Log2Int32</span>&lt;<span>1</span>&gt;  { <span>static</span> <span>const</span> <span>int32_t</span> value =  <span>0</span>; };</td>
        </tr>
        <tr>
          <td id="L1126" data-line-number="1126"></td>
          <td id="LC1126">
</td>
        </tr>
        <tr>
          <td id="L1127" data-line-number="1127"></td>
          <td id="LC1127">	<span>template </span>&lt;<span>uint64_t</span> N&gt; <span>struct</span> <span>Log2Uint64</span>    { <span>static</span> <span>const</span> <span>uint64_t</span> value = (<span>1</span> + Log2Uint64&lt;N/<span>2</span>&gt;::value); };</td>
        </tr>
        <tr>
          <td id="L1128" data-line-number="1128"></td>
          <td id="LC1128">	<span>template </span>&lt;&gt;           <span>struct</span> <span>Log2Uint64</span>&lt;<span>1</span>&gt; { <span>static</span> <span>const</span> <span>uint64_t</span> value =  <span>0</span>; };</td>
        </tr>
        <tr>
          <td id="L1129" data-line-number="1129"></td>
          <td id="LC1129">
</td>
        </tr>
        <tr>
          <td id="L1130" data-line-number="1130"></td>
          <td id="LC1130">	<span>template </span>&lt;<span>int64_t</span> N&gt;  <span>struct</span> <span>Log2Int64</span>     { <span>static</span> <span>const</span> <span>int64_t</span> value = (<span>1</span> + Log2Int64&lt;N/<span>2</span>&gt;::value); };</td>
        </tr>
        <tr>
          <td id="L1131" data-line-number="1131"></td>
          <td id="LC1131">	<span>template </span>&lt;&gt;           <span>struct</span> <span>Log2Int64</span>&lt;<span>1</span>&gt;  { <span>static</span> <span>const</span> <span>int64_t</span> value =  <span>0</span>; };</td>
        </tr>
        <tr>
          <td id="L1132" data-line-number="1132"></td>
          <td id="LC1132">
</td>
        </tr>
        <tr>
          <td id="L1133" data-line-number="1133"></td>
          <td id="LC1133">
</td>
        </tr>
        <tr>
          <td id="L1134" data-line-number="1134"></td>
          <td id="LC1134">	<span><span>//</span>/ DivideByPowerOf2Rounded</span></td>
        </tr>
        <tr>
          <td id="L1135" data-line-number="1135"></td>
          <td id="LC1135">	<span><span>//</span>/ Divides a number x by 2^n, and rounds the result instead of </span></td>
        </tr>
        <tr>
          <td id="L1136" data-line-number="1136"></td>
          <td id="LC1136">	<span><span>//</span>/ chopping the result. This is useful for certain kinds of </span></td>
        </tr>
        <tr>
          <td id="L1137" data-line-number="1137"></td>
          <td id="LC1137">	<span><span>//</span>/ bit manipulation.</span></td>
        </tr>
        <tr>
          <td id="L1138" data-line-number="1138"></td>
          <td id="LC1138">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1139" data-line-number="1139"></td>
          <td id="LC1139">	<span><span>//</span>/     DivideByPowerOf2Rounded&lt;uint32_t, 8&gt;(  0)   -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L1140" data-line-number="1140"></td>
          <td id="LC1140">	<span><span>//</span>/     DivideByPowerOf2Rounded&lt;uint32_t, 8&gt;(127)   -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L1141" data-line-number="1141"></td>
          <td id="LC1141">	<span><span>//</span>/     DivideByPowerOf2Rounded&lt;uint32_t, 8&gt;(128)   -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L1142" data-line-number="1142"></td>
          <td id="LC1142">	<span><span>//</span>/     DivideByPowerOf2Rounded&lt;uint32_t, 8&gt;(256)   -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L1143" data-line-number="1143"></td>
          <td id="LC1143">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1144" data-line-number="1144"></td>
          <td id="LC1144">	<span><span>//</span> This is not yet tested.</span></td>
        </tr>
        <tr>
          <td id="L1145" data-line-number="1145"></td>
          <td id="LC1145">	<span><span>//</span>template&lt;typename T, int n&gt;</span></td>
        </tr>
        <tr>
          <td id="L1146" data-line-number="1146"></td>
          <td id="LC1146">	<span><span>//</span>inline T DivideByPowerOf2Rounded(T x)</span></td>
        </tr>
        <tr>
          <td id="L1147" data-line-number="1147"></td>
          <td id="LC1147">	<span><span>//</span>{</span></td>
        </tr>
        <tr>
          <td id="L1148" data-line-number="1148"></td>
          <td id="LC1148">	<span><span>//</span>    return ((x + (1 &lt;&lt; (n - 1))) &gt;&gt; n);</span></td>
        </tr>
        <tr>
          <td id="L1149" data-line-number="1149"></td>
          <td id="LC1149">	<span><span>//</span>}</span></td>
        </tr>
        <tr>
          <td id="L1150" data-line-number="1150"></td>
          <td id="LC1150">
</td>
        </tr>
        <tr>
          <td id="L1151" data-line-number="1151"></td>
          <td id="LC1151">
</td>
        </tr>
        <tr>
          <td id="L1152" data-line-number="1152"></td>
          <td id="LC1152">	<span><span>//</span> EAGetAlignment</span></td>
        </tr>
        <tr>
          <td id="L1153" data-line-number="1153"></td>
          <td id="LC1153">	<span><span>//</span> This functionality and other alignment assistance functions have been</span></td>
        </tr>
        <tr>
          <td id="L1154" data-line-number="1154"></td>
          <td id="LC1154">	<span><span>//</span> moved to EAAlignment.h. The best way to portably and reliably detect</span></td>
        </tr>
        <tr>
          <td id="L1155" data-line-number="1155"></td>
          <td id="LC1155">	<span><span>//</span> alignment in both C and C++ is to use a compiler intrinsic or use </span></td>
        </tr>
        <tr>
          <td id="L1156" data-line-number="1156"></td>
          <td id="LC1156">	<span><span>//</span> some fancy C++ templates. In either case, the solution is outside the</span></td>
        </tr>
        <tr>
          <td id="L1157" data-line-number="1157"></td>
          <td id="LC1157">	<span><span>//</span> realm of bit tricks.</span></td>
        </tr>
        <tr>
          <td id="L1158" data-line-number="1158"></td>
          <td id="LC1158">
</td>
        </tr>
        <tr>
          <td id="L1159" data-line-number="1159"></td>
          <td id="LC1159">
</td>
        </tr>
        <tr>
          <td id="L1160" data-line-number="1160"></td>
          <td id="LC1160">
</td>
        </tr>
        <tr>
          <td id="L1161" data-line-number="1161"></td>
          <td id="LC1161">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L1162" data-line-number="1162"></td>
          <td id="LC1162">	<span><span>//</span> Overflow</span></td>
        </tr>
        <tr>
          <td id="L1163" data-line-number="1163"></td>
          <td id="LC1163">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L1164" data-line-number="1164"></td>
          <td id="LC1164">
</td>
        </tr>
        <tr>
          <td id="L1165" data-line-number="1165"></td>
          <td id="LC1165">	<span>EA_DISABLE_VC_WARNING</span>(<span>4310</span>) <span><span>//</span> cast truncates constant value</span></td>
        </tr>
        <tr>
          <td id="L1166" data-line-number="1166"></td>
          <td id="LC1166">
</td>
        </tr>
        <tr>
          <td id="L1167" data-line-number="1167"></td>
          <td id="LC1167">	<span><span>//</span>/ SignedAdditionWouldOverflow</span></td>
        </tr>
        <tr>
          <td id="L1168" data-line-number="1168"></td>
          <td id="LC1168">	<span><span>//</span>/ How to detect that an addition or subtraction of signed values will overflow.</span></td>
        </tr>
        <tr>
          <td id="L1169" data-line-number="1169"></td>
          <td id="LC1169">	<span><span>//</span>/ This is a useful operation to test for when writing robust applications.</span></td>
        </tr>
        <tr>
          <td id="L1170" data-line-number="1170"></td>
          <td id="LC1170">	<span><span>//</span>/ Signed integer overflow of addition or subtraction occurs if and only if </span></td>
        </tr>
        <tr>
          <td id="L1171" data-line-number="1171"></td>
          <td id="LC1171">	<span><span>//</span>/ the operands have the same sign and the result of the operation has the </span></td>
        </tr>
        <tr>
          <td id="L1172" data-line-number="1172"></td>
          <td id="LC1172">	<span><span>//</span>/ opposite of this sign.</span></td>
        </tr>
        <tr>
          <td id="L1173" data-line-number="1173"></td>
          <td id="LC1173">	<span><span>//</span>/ Some platforms generate exceptions upon an overflow, and the functions </span></td>
        </tr>
        <tr>
          <td id="L1174" data-line-number="1174"></td>
          <td id="LC1174">	<span><span>//</span>/ presented here work by possibly causing overflow. Alternative versions of </span></td>
        </tr>
        <tr>
          <td id="L1175" data-line-number="1175"></td>
          <td id="LC1175">	<span><span>//</span>/ these functions exist which are slightly more complex but can work without </span></td>
        </tr>
        <tr>
          <td id="L1176" data-line-number="1176"></td>
          <td id="LC1176">	<span><span>//</span>/ generating overflows themselves. However, no platform that you </span></td>
        </tr>
        <tr>
          <td id="L1177" data-line-number="1177"></td>
          <td id="LC1177">	<span><span>//</span>/ are likely to be using generates such exceptions.</span></td>
        </tr>
        <tr>
          <td id="L1178" data-line-number="1178"></td>
          <td id="LC1178">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1179" data-line-number="1179"></td>
          <td id="LC1179">	<span><span>//</span>/    SignedAdditionWouldOverflow&lt;int&gt;(2, 3)                   -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L1180" data-line-number="1180"></td>
          <td id="LC1180">	<span><span>//</span>/    SignedAdditionWouldOverflow&lt;int&gt;(0x7fffffff, 0x7fffffff) -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L1181" data-line-number="1181"></td>
          <td id="LC1181">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1182" data-line-number="1182"></td>
          <td id="LC1182">	<span><span>//</span>/ EA_NO_UBSAN is included because this function is designed to overflow </span></td>
        </tr>
        <tr>
          <td id="L1183" data-line-number="1183"></td>
          <td id="LC1183">	<span><span>//</span>/ and it UBSAN correctly warns here.</span></td>
        </tr>
        <tr>
          <td id="L1184" data-line-number="1184"></td>
          <td id="LC1184">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1185" data-line-number="1185"></td>
          <td id="LC1185">	EA_NO_UBSAN <span>inline</span> <span>bool</span> <span>SignedAdditionWouldOverflow</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1186" data-line-number="1186"></td>
          <td id="LC1186">		<span>const</span> T temp = (T)(x + y);</td>
        </tr>
        <tr>
          <td id="L1187" data-line-number="1187"></td>
          <td id="LC1187">		<span>return</span> (((temp ^ x) &amp; (temp ^ y)) &gt;&gt; ((<span>sizeof</span>(T) * (T)<span>8</span>) - <span>1</span>)) != <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L1188" data-line-number="1188"></td>
          <td id="LC1188">	}</td>
        </tr>
        <tr>
          <td id="L1189" data-line-number="1189"></td>
          <td id="LC1189">
</td>
        </tr>
        <tr>
          <td id="L1190" data-line-number="1190"></td>
          <td id="LC1190">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1191" data-line-number="1191"></td>
          <td id="LC1191">	<span>inline</span> <span>bool</span> <span>SignedSubtractionWouldOverflow</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1192" data-line-number="1192"></td>
          <td id="LC1192">		<span>const</span> T tMin = (T)((T)<span>1</span> &lt;&lt; (T)((<span>sizeof</span>(T) * <span>8</span>) - <span>1</span>)); <span><span>//</span> This is not strictly portable.</span></td>
        </tr>
        <tr>
          <td id="L1193" data-line-number="1193"></td>
          <td id="LC1193">		<span>return</span> (x &gt;= <span>0</span>) ? (y &lt; (T)(x - (T)-(tMin + <span>1</span>))) : (y &gt; (T)(x - tMin));</td>
        </tr>
        <tr>
          <td id="L1194" data-line-number="1194"></td>
          <td id="LC1194">	}</td>
        </tr>
        <tr>
          <td id="L1195" data-line-number="1195"></td>
          <td id="LC1195">
</td>
        </tr>
        <tr>
          <td id="L1196" data-line-number="1196"></td>
          <td id="LC1196">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1197" data-line-number="1197"></td>
          <td id="LC1197">	<span>inline</span> <span>bool</span> <span>UnsignedAdditionWouldOverflow</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1198" data-line-number="1198"></td>
          <td id="LC1198">		<span>const</span> T temp = (T)(x + y);</td>
        </tr>
        <tr>
          <td id="L1199" data-line-number="1199"></td>
          <td id="LC1199">		<span>return</span> (temp &lt; x) &amp;&amp; (temp &lt; y);</td>
        </tr>
        <tr>
          <td id="L1200" data-line-number="1200"></td>
          <td id="LC1200">	}</td>
        </tr>
        <tr>
          <td id="L1201" data-line-number="1201"></td>
          <td id="LC1201">
</td>
        </tr>
        <tr>
          <td id="L1202" data-line-number="1202"></td>
          <td id="LC1202">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1203" data-line-number="1203"></td>
          <td id="LC1203">	<span>inline</span> <span>bool</span> <span>UnsignedSubtractionWouldOverflow</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1204" data-line-number="1204"></td>
          <td id="LC1204">		<span>return</span> y &gt; x;</td>
        </tr>
        <tr>
          <td id="L1205" data-line-number="1205"></td>
          <td id="LC1205">	}</td>
        </tr>
        <tr>
          <td id="L1206" data-line-number="1206"></td>
          <td id="LC1206">
</td>
        </tr>
        <tr>
          <td id="L1207" data-line-number="1207"></td>
          <td id="LC1207">	<span><span>//</span>/ UnsignedMultiplyWouldOverflow</span></td>
        </tr>
        <tr>
          <td id="L1208" data-line-number="1208"></td>
          <td id="LC1208">	<span><span>//</span>/ How to detect that a multiplication will overflow.</span></td>
        </tr>
        <tr>
          <td id="L1209" data-line-number="1209"></td>
          <td id="LC1209">	<span><span>//</span>/ This is a useful operation to test for when writing robust applications.</span></td>
        </tr>
        <tr>
          <td id="L1210" data-line-number="1210"></td>
          <td id="LC1210">	<span><span>//</span>/ Some platforms generate exceptions upon an overflow, and the functions </span></td>
        </tr>
        <tr>
          <td id="L1211" data-line-number="1211"></td>
          <td id="LC1211">	<span><span>//</span>/ presented here work by possibly causing overflow. Alternative versions of </span></td>
        </tr>
        <tr>
          <td id="L1212" data-line-number="1212"></td>
          <td id="LC1212">	<span><span>//</span>/ these functions exist which are slightly more complex but can work without </span></td>
        </tr>
        <tr>
          <td id="L1213" data-line-number="1213"></td>
          <td id="LC1213">	<span><span>//</span>/ generating overflows themselves. However, no platform that you </span></td>
        </tr>
        <tr>
          <td id="L1214" data-line-number="1214"></td>
          <td id="LC1214">	<span><span>//</span>/ are likely to be using generates such exceptions.</span></td>
        </tr>
        <tr>
          <td id="L1215" data-line-number="1215"></td>
          <td id="LC1215">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1216" data-line-number="1216"></td>
          <td id="LC1216">	<span><span>//</span>/    4 * 5 -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L1217" data-line-number="1217"></td>
          <td id="LC1217">	<span><span>//</span>/    0xffffffff * 0xffffffff -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L1218" data-line-number="1218"></td>
          <td id="LC1218">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1219" data-line-number="1219"></td>
          <td id="LC1219">	<span>inline</span> <span>bool</span> <span>UnsignedMultiplyWouldOverflow</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1220" data-line-number="1220"></td>
          <td id="LC1220">		<span>if</span>(y)</td>
        </tr>
        <tr>
          <td id="L1221" data-line-number="1221"></td>
          <td id="LC1221">			<span>return</span> (((x * y) / y) != x);</td>
        </tr>
        <tr>
          <td id="L1222" data-line-number="1222"></td>
          <td id="LC1222">		<span>return</span> <span>false</span>;</td>
        </tr>
        <tr>
          <td id="L1223" data-line-number="1223"></td>
          <td id="LC1223">	}</td>
        </tr>
        <tr>
          <td id="L1224" data-line-number="1224"></td>
          <td id="LC1224">
</td>
        </tr>
        <tr>
          <td id="L1225" data-line-number="1225"></td>
          <td id="LC1225">	<span>inline</span> <span>bool</span> <span>SignedMultiplyWouldOverflow</span>(<span>int32_t</span> x, <span>int32_t</span> y){</td>
        </tr>
        <tr>
          <td id="L1226" data-line-number="1226"></td>
          <td id="LC1226">		<span>if</span>((y &lt; <span>0</span>) &amp;&amp; (x == (<span>int32_t</span>)<span>INT32_C</span>(<span>0x80000000</span>)))</td>
        </tr>
        <tr>
          <td id="L1227" data-line-number="1227"></td>
          <td id="LC1227">			<span>return</span> <span>true</span>;</td>
        </tr>
        <tr>
          <td id="L1228" data-line-number="1228"></td>
          <td id="LC1228">		<span>if</span>(y)</td>
        </tr>
        <tr>
          <td id="L1229" data-line-number="1229"></td>
          <td id="LC1229">			<span>return</span> (((x * y) / y) != x);</td>
        </tr>
        <tr>
          <td id="L1230" data-line-number="1230"></td>
          <td id="LC1230">		<span>return</span> <span>false</span>;</td>
        </tr>
        <tr>
          <td id="L1231" data-line-number="1231"></td>
          <td id="LC1231">	}</td>
        </tr>
        <tr>
          <td id="L1232" data-line-number="1232"></td>
          <td id="LC1232">
</td>
        </tr>
        <tr>
          <td id="L1233" data-line-number="1233"></td>
          <td id="LC1233">	<span>inline</span> <span>bool</span> <span>SignedMultiplyWouldOverflow</span>(<span>int64_t</span> x, <span>int64_t</span> y){</td>
        </tr>
        <tr>
          <td id="L1234" data-line-number="1234"></td>
          <td id="LC1234">		<span>if</span>((y &lt; <span>0</span>) &amp;&amp; (x == (<span>int64_t</span>)<span>INT64_C</span>(<span>0x8000000000000000</span>)))</td>
        </tr>
        <tr>
          <td id="L1235" data-line-number="1235"></td>
          <td id="LC1235">			<span>return</span> <span>true</span>;</td>
        </tr>
        <tr>
          <td id="L1236" data-line-number="1236"></td>
          <td id="LC1236">		<span>if</span>(y)</td>
        </tr>
        <tr>
          <td id="L1237" data-line-number="1237"></td>
          <td id="LC1237">			<span>return</span> (((x * y) / y) != x);</td>
        </tr>
        <tr>
          <td id="L1238" data-line-number="1238"></td>
          <td id="LC1238">		<span>return</span> <span>false</span>;</td>
        </tr>
        <tr>
          <td id="L1239" data-line-number="1239"></td>
          <td id="LC1239">	}</td>
        </tr>
        <tr>
          <td id="L1240" data-line-number="1240"></td>
          <td id="LC1240">
</td>
        </tr>
        <tr>
          <td id="L1241" data-line-number="1241"></td>
          <td id="LC1241">	<span><span>//</span>/ UnsignedDivisionWouldOverflow</span></td>
        </tr>
        <tr>
          <td id="L1242" data-line-number="1242"></td>
          <td id="LC1242">	<span><span>//</span>/ How to detect that a division will overflow.</span></td>
        </tr>
        <tr>
          <td id="L1243" data-line-number="1243"></td>
          <td id="LC1243">	<span><span>//</span>/ This is a useful operation to test for when writing robust applications.</span></td>
        </tr>
        <tr>
          <td id="L1244" data-line-number="1244"></td>
          <td id="LC1244">	<span><span>//</span>/ Some platforms generate exceptions upon an overflow, and the functions </span></td>
        </tr>
        <tr>
          <td id="L1245" data-line-number="1245"></td>
          <td id="LC1245">	<span><span>//</span>/ presented here work by possibly causing overflow. Alternative versions </span></td>
        </tr>
        <tr>
          <td id="L1246" data-line-number="1246"></td>
          <td id="LC1246">	<span><span>//</span>/ of these functions exist which are slightly more complex but can work </span></td>
        </tr>
        <tr>
          <td id="L1247" data-line-number="1247"></td>
          <td id="LC1247">	<span><span>//</span>/ without generating overflows themselves. However, no platform that you </span></td>
        </tr>
        <tr>
          <td id="L1248" data-line-number="1248"></td>
          <td id="LC1248">	<span><span>//</span>/ are likely to be using generates such exceptions.</span></td>
        </tr>
        <tr>
          <td id="L1249" data-line-number="1249"></td>
          <td id="LC1249">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1250" data-line-number="1250"></td>
          <td id="LC1250">	<span><span>//</span>/    5 / 4 -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L1251" data-line-number="1251"></td>
          <td id="LC1251">	<span><span>//</span>/    3 / 0 -&gt; true</span></td>
        </tr>
        <tr>
          <td id="L1252" data-line-number="1252"></td>
          <td id="LC1252">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1253" data-line-number="1253"></td>
          <td id="LC1253">	<span>inline</span> <span>bool</span> <span>UnsignedDivisionWouldOverflow</span>(T <span><span>/*</span>x<span>*/</span></span>, T y){</td>
        </tr>
        <tr>
          <td id="L1254" data-line-number="1254"></td>
          <td id="LC1254">		<span>return</span> y == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L1255" data-line-number="1255"></td>
          <td id="LC1255">	}</td>
        </tr>
        <tr>
          <td id="L1256" data-line-number="1256"></td>
          <td id="LC1256">
</td>
        </tr>
        <tr>
          <td id="L1257" data-line-number="1257"></td>
          <td id="LC1257">	<span><span>//</span>/ SignedDivisionWouldOverflow</span></td>
        </tr>
        <tr>
          <td id="L1258" data-line-number="1258"></td>
          <td id="LC1258">	<span><span>//</span>/ How to detect that a division will overflow.</span></td>
        </tr>
        <tr>
          <td id="L1259" data-line-number="1259"></td>
          <td id="LC1259">	<span>inline</span> <span>bool</span> <span>SignedDivisionWouldOverflow</span>(<span>int32_t</span> x, <span>int32_t</span> y){</td>
        </tr>
        <tr>
          <td id="L1260" data-line-number="1260"></td>
          <td id="LC1260">		<span>return</span> (y == <span>0</span>) || ((x == (<span>int32_t</span>)<span>INT32_C</span>(<span>0x80000000</span>)) &amp;&amp; (y == -<span>1</span>));</td>
        </tr>
        <tr>
          <td id="L1261" data-line-number="1261"></td>
          <td id="LC1261">	}</td>
        </tr>
        <tr>
          <td id="L1262" data-line-number="1262"></td>
          <td id="LC1262">
</td>
        </tr>
        <tr>
          <td id="L1263" data-line-number="1263"></td>
          <td id="LC1263">	<span>inline</span> <span>bool</span> <span>SignedDivisionWouldOverflow</span>(<span>int64_t</span> x, <span>int64_t</span> y){</td>
        </tr>
        <tr>
          <td id="L1264" data-line-number="1264"></td>
          <td id="LC1264">		<span>return</span> (y == <span>0</span>) || ((x == (<span>int64_t</span>)<span>INT64_C</span>(<span>0x8000000000000000</span>)) &amp;&amp; (y == -<span>1</span>));</td>
        </tr>
        <tr>
          <td id="L1265" data-line-number="1265"></td>
          <td id="LC1265">	}</td>
        </tr>
        <tr>
          <td id="L1266" data-line-number="1266"></td>
          <td id="LC1266">
</td>
        </tr>
        <tr>
          <td id="L1267" data-line-number="1267"></td>
          <td id="LC1267">
</td>
        </tr>
        <tr>
          <td id="L1268" data-line-number="1268"></td>
          <td id="LC1268">	<span><span>//</span>/ GetAverage</span></td>
        </tr>
        <tr>
          <td id="L1269" data-line-number="1269"></td>
          <td id="LC1269">	<span><span>//</span>/ How to compute average of two integers without possible overflow errors.</span></td>
        </tr>
        <tr>
          <td id="L1270" data-line-number="1270"></td>
          <td id="LC1270">	<span><span>//</span>/ Returns floor of the average; Rounds to negative infinity.</span></td>
        </tr>
        <tr>
          <td id="L1271" data-line-number="1271"></td>
          <td id="LC1271">	<span><span>//</span>/ This is useful for averaging two integers whereby the standard mechanism </span></td>
        </tr>
        <tr>
          <td id="L1272" data-line-number="1272"></td>
          <td id="LC1272">	<span><span>//</span>/ of returning (x + y) / 2  may overflow and yield an incorrect answer.</span></td>
        </tr>
        <tr>
          <td id="L1273" data-line-number="1273"></td>
          <td id="LC1273">	<span><span>//</span>/ Normally, you want the floor (as opposed to ceiling) of the average, </span></td>
        </tr>
        <tr>
          <td id="L1274" data-line-number="1274"></td>
          <td id="LC1274">	<span><span>//</span>/ at least for positive values.</span></td>
        </tr>
        <tr>
          <td id="L1275" data-line-number="1275"></td>
          <td id="LC1275">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1276" data-line-number="1276"></td>
          <td id="LC1276">	<span><span>//</span>/     3,  4 -&gt;  3</span></td>
        </tr>
        <tr>
          <td id="L1277" data-line-number="1277"></td>
          <td id="LC1277">	<span><span>//</span>/     3,  3 -&gt;  3</span></td>
        </tr>
        <tr>
          <td id="L1278" data-line-number="1278"></td>
          <td id="LC1278">	<span><span>//</span>/    -3, -4 -&gt; -4</span></td>
        </tr>
        <tr>
          <td id="L1279" data-line-number="1279"></td>
          <td id="LC1279">	<span><span>//</span>/    -4,  5 -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L1280" data-line-number="1280"></td>
          <td id="LC1280">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1281" data-line-number="1281"></td>
          <td id="LC1281">	<span>inline</span> <span>int</span> <span>GetAverage</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1282" data-line-number="1282"></td>
          <td id="LC1282">		<span>return</span> (x &amp; y) + ((x ^ y) &gt;&gt; <span>1</span>); <span><span>//</span> Need to use &#39;&gt;&gt; 1&#39; instead of &#39;/ 2&#39;</span></td>
        </tr>
        <tr>
          <td id="L1283" data-line-number="1283"></td>
          <td id="LC1283">	}</td>
        </tr>
        <tr>
          <td id="L1284" data-line-number="1284"></td>
          <td id="LC1284">
</td>
        </tr>
        <tr>
          <td id="L1285" data-line-number="1285"></td>
          <td id="LC1285">	<span><span>//</span>/ GetAverage_Ceiling</span></td>
        </tr>
        <tr>
          <td id="L1286" data-line-number="1286"></td>
          <td id="LC1286">	<span><span>//</span>/ Returns ceiling of the average; Rounds to positive infinity.</span></td>
        </tr>
        <tr>
          <td id="L1287" data-line-number="1287"></td>
          <td id="LC1287">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1288" data-line-number="1288"></td>
          <td id="LC1288">	<span><span>//</span>/     3,  4 -&gt;  4</span></td>
        </tr>
        <tr>
          <td id="L1289" data-line-number="1289"></td>
          <td id="LC1289">	<span><span>//</span>/     3,  3 -&gt;  3</span></td>
        </tr>
        <tr>
          <td id="L1290" data-line-number="1290"></td>
          <td id="LC1290">	<span><span>//</span>/    -3, -4 -&gt; -3</span></td>
        </tr>
        <tr>
          <td id="L1291" data-line-number="1291"></td>
          <td id="LC1291">	<span><span>//</span>/    -4,  5 -&gt;  1</span></td>
        </tr>
        <tr>
          <td id="L1292" data-line-number="1292"></td>
          <td id="LC1292">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1293" data-line-number="1293"></td>
          <td id="LC1293">	<span>inline</span> <span>int</span> <span>GetAverage_Ceiling</span>(T x, T y){</td>
        </tr>
        <tr>
          <td id="L1294" data-line-number="1294"></td>
          <td id="LC1294">		<span>return</span> (x | y) - ((x ^ y) &gt;&gt; <span>1</span>); <span><span>//</span> Need to use &#39;&gt;&gt; 1&#39; instead of &#39;/ 2&#39;</span></td>
        </tr>
        <tr>
          <td id="L1295" data-line-number="1295"></td>
          <td id="LC1295">	}</td>
        </tr>
        <tr>
          <td id="L1296" data-line-number="1296"></td>
          <td id="LC1296">
</td>
        </tr>
        <tr>
          <td id="L1297" data-line-number="1297"></td>
          <td id="LC1297">	<span>EA_RESTORE_VC_WARNING</span>()  <span><span>//</span> 4310</span></td>
        </tr>
        <tr>
          <td id="L1298" data-line-number="1298"></td>
          <td id="LC1298">
</td>
        </tr>
        <tr>
          <td id="L1299" data-line-number="1299"></td>
          <td id="LC1299">
</td>
        </tr>
        <tr>
          <td id="L1300" data-line-number="1300"></td>
          <td id="LC1300">
</td>
        </tr>
        <tr>
          <td id="L1301" data-line-number="1301"></td>
          <td id="LC1301">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L1302" data-line-number="1302"></td>
          <td id="LC1302">	<span><span>//</span> Miscellaneous</span></td>
        </tr>
        <tr>
          <td id="L1303" data-line-number="1303"></td>
          <td id="LC1303">	<span><span>//</span>//////////////////////////////////////////////////////////////////////////</span></td>
        </tr>
        <tr>
          <td id="L1304" data-line-number="1304"></td>
          <td id="LC1304">
</td>
        </tr>
        <tr>
          <td id="L1305" data-line-number="1305"></td>
          <td id="LC1305">	<span><span>//</span>/ GetParity</span></td>
        </tr>
        <tr>
          <td id="L1306" data-line-number="1306"></td>
          <td id="LC1306">	<span><span>//</span>/ How to calculate parity of an integer.</span></td>
        </tr>
        <tr>
          <td id="L1307" data-line-number="1307"></td>
          <td id="LC1307">	<span><span>//</span>/ Parity is defined as the oddness or evenness of the count of 1 bits.</span></td>
        </tr>
        <tr>
          <td id="L1308" data-line-number="1308"></td>
          <td id="LC1308">	<span><span>//</span>/ There are other mechansims for accomplishing this. The version </span></td>
        </tr>
        <tr>
          <td id="L1309" data-line-number="1309"></td>
          <td id="LC1309">	<span><span>//</span>/ presented here has no branches, looping, nor table lookups.</span></td>
        </tr>
        <tr>
          <td id="L1310" data-line-number="1310"></td>
          <td id="LC1310">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1311" data-line-number="1311"></td>
          <td id="LC1311">	<span><span>//</span>/    01100011 -&gt; 0 (even)</span></td>
        </tr>
        <tr>
          <td id="L1312" data-line-number="1312"></td>
          <td id="LC1312">	<span><span>//</span>/    00101010 -&gt; 1 (odd)</span></td>
        </tr>
        <tr>
          <td id="L1313" data-line-number="1313"></td>
          <td id="LC1313">	<span>inline</span> <span>int</span> <span>GetParity</span>(<span>uint32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1314" data-line-number="1314"></td>
          <td id="LC1314">		x ^= x &gt;&gt; <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L1315" data-line-number="1315"></td>
          <td id="LC1315">		x ^= x &gt;&gt; <span>2</span>;</td>
        </tr>
        <tr>
          <td id="L1316" data-line-number="1316"></td>
          <td id="LC1316">		x = (x &amp; <span>UINT32_C</span>(<span>0x11111111</span>)) * <span>UINT32_C</span>(<span>0x11111111</span>);</td>
        </tr>
        <tr>
          <td id="L1317" data-line-number="1317"></td>
          <td id="LC1317">		<span>return</span> (<span>int</span>)((x &gt;&gt; <span>28</span>) &amp; <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L1318" data-line-number="1318"></td>
          <td id="LC1318">	}</td>
        </tr>
        <tr>
          <td id="L1319" data-line-number="1319"></td>
          <td id="LC1319">
</td>
        </tr>
        <tr>
          <td id="L1320" data-line-number="1320"></td>
          <td id="LC1320">	<span>inline</span> <span>int</span> <span>GetParity</span>(<span>uint64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1321" data-line-number="1321"></td>
          <td id="LC1321">		x ^= x &gt;&gt; <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L1322" data-line-number="1322"></td>
          <td id="LC1322">		x ^= x &gt;&gt; <span>2</span>;</td>
        </tr>
        <tr>
          <td id="L1323" data-line-number="1323"></td>
          <td id="LC1323">		x = (x &amp; <span>UINT64_C</span>(<span>0x1111111111111111</span>)) * <span>UINT64_C</span>(<span>0x1111111111111111</span>);</td>
        </tr>
        <tr>
          <td id="L1324" data-line-number="1324"></td>
          <td id="LC1324">		<span>return</span> (<span>int</span>)((x &gt;&gt; <span>60</span>) &amp; <span>1</span>);</td>
        </tr>
        <tr>
          <td id="L1325" data-line-number="1325"></td>
          <td id="LC1325">	}</td>
        </tr>
        <tr>
          <td id="L1326" data-line-number="1326"></td>
          <td id="LC1326">
</td>
        </tr>
        <tr>
          <td id="L1327" data-line-number="1327"></td>
          <td id="LC1327">
</td>
        </tr>
        <tr>
          <td id="L1328" data-line-number="1328"></td>
          <td id="LC1328">	<span><span>//</span>/ GetIsBigEndian</span></td>
        </tr>
        <tr>
          <td id="L1329" data-line-number="1329"></td>
          <td id="LC1329">	<span><span>//</span>/ How to test (or verify) that the current machine is big-endian.</span></td>
        </tr>
        <tr>
          <td id="L1330" data-line-number="1330"></td>
          <td id="LC1330">	<span><span>//</span>/ It is not normally possible with C/C++ to tell at compile-time what </span></td>
        </tr>
        <tr>
          <td id="L1331" data-line-number="1331"></td>
          <td id="LC1331">	<span><span>//</span>/ the machine endian-ness is. However, you might be able to check a </span></td>
        </tr>
        <tr>
          <td id="L1332" data-line-number="1332"></td>
          <td id="LC1332">	<span><span>//</span>/ predefined value, such as EABase&#39;s EA_SYSTEM_BIG_ENDIAN.</span></td>
        </tr>
        <tr>
          <td id="L1333" data-line-number="1333"></td>
          <td id="LC1333">	<span>inline</span> <span>bool</span> <span>GetIsBigEndian</span>(){</td>
        </tr>
        <tr>
          <td id="L1334" data-line-number="1334"></td>
          <td id="LC1334">		<span>const</span> <span>int</span> temp = <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L1335" data-line-number="1335"></td>
          <td id="LC1335">		<span>return</span> ((<span>char</span>*)&amp;temp)[<span>0</span>] == <span>0</span>;</td>
        </tr>
        <tr>
          <td id="L1336" data-line-number="1336"></td>
          <td id="LC1336">	}</td>
        </tr>
        <tr>
          <td id="L1337" data-line-number="1337"></td>
          <td id="LC1337">
</td>
        </tr>
        <tr>
          <td id="L1338" data-line-number="1338"></td>
          <td id="LC1338">	<span><span>//</span>/ ToggleBetween0And1</span></td>
        </tr>
        <tr>
          <td id="L1339" data-line-number="1339"></td>
          <td id="LC1339">	<span><span>//</span>/ How to toggle an integer between 0 and 1.</span></td>
        </tr>
        <tr>
          <td id="L1340" data-line-number="1340"></td>
          <td id="LC1340">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1341" data-line-number="1341"></td>
          <td id="LC1341">	<span><span>//</span>/    1 -&gt; 0</span></td>
        </tr>
        <tr>
          <td id="L1342" data-line-number="1342"></td>
          <td id="LC1342">	<span><span>//</span>/    0 -&gt; 1</span></td>
        </tr>
        <tr>
          <td id="L1343" data-line-number="1343"></td>
          <td id="LC1343">	<span>inline</span> <span>int</span> <span>ToggleBetween0And1</span>(<span>int</span> x){</td>
        </tr>
        <tr>
          <td id="L1344" data-line-number="1344"></td>
          <td id="LC1344">		<span>return</span> x ^ <span>1</span>;</td>
        </tr>
        <tr>
          <td id="L1345" data-line-number="1345"></td>
          <td id="LC1345">	}</td>
        </tr>
        <tr>
          <td id="L1346" data-line-number="1346"></td>
          <td id="LC1346">
</td>
        </tr>
        <tr>
          <td id="L1347" data-line-number="1347"></td>
          <td id="LC1347">	<span><span>//</span>/ ToggleBetweenIntegers</span></td>
        </tr>
        <tr>
          <td id="L1348" data-line-number="1348"></td>
          <td id="LC1348">	<span><span>//</span>/ How to toggle between any two integers.     </span></td>
        </tr>
        <tr>
          <td id="L1349" data-line-number="1349"></td>
          <td id="LC1349">	<span><span>//</span>/ Toggling between three or more values is possible but requires </span></td>
        </tr>
        <tr>
          <td id="L1350" data-line-number="1350"></td>
          <td id="LC1350">	<span><span>//</span>/ code that is a bit more complicated.</span></td>
        </tr>
        <tr>
          <td id="L1351" data-line-number="1351"></td>
          <td id="LC1351">	<span><span>//</span>/ You can do this in place with:</span></td>
        </tr>
        <tr>
          <td id="L1352" data-line-number="1352"></td>
          <td id="LC1352">	<span><span>//</span>/    x ^= a ^ b;</span></td>
        </tr>
        <tr>
          <td id="L1353" data-line-number="1353"></td>
          <td id="LC1353">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1354" data-line-number="1354"></td>
          <td id="LC1354">	<span><span>//</span>/    5, 4, 5 -&gt; 4</span></td>
        </tr>
        <tr>
          <td id="L1355" data-line-number="1355"></td>
          <td id="LC1355">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1356" data-line-number="1356"></td>
          <td id="LC1356">	<span>inline</span> T <span>ToggleBetweenIntegers</span>(T x, T a, T b){</td>
        </tr>
        <tr>
          <td id="L1357" data-line-number="1357"></td>
          <td id="LC1357">		<span>return</span> (T)(x ^ a ^ b);</td>
        </tr>
        <tr>
          <td id="L1358" data-line-number="1358"></td>
          <td id="LC1358">	}</td>
        </tr>
        <tr>
          <td id="L1359" data-line-number="1359"></td>
          <td id="LC1359">
</td>
        </tr>
        <tr>
          <td id="L1360" data-line-number="1360"></td>
          <td id="LC1360">	<span><span>//</span>/ IsBetween0AndValue</span></td>
        </tr>
        <tr>
          <td id="L1361" data-line-number="1361"></td>
          <td id="LC1361">	<span><span>//</span>/ How to quickly see if an int is &gt;= 0 and &lt; some value.</span></td>
        </tr>
        <tr>
          <td id="L1362" data-line-number="1362"></td>
          <td id="LC1362">	<span><span>//</span>/ The purpose of this is to save a comparison to zero and thus </span></td>
        </tr>
        <tr>
          <td id="L1363" data-line-number="1363"></td>
          <td id="LC1363">	<span><span>//</span>/ execute faster because you get two comparisons for the price of one. </span></td>
        </tr>
        <tr>
          <td id="L1364" data-line-number="1364"></td>
          <td id="LC1364">	<span><span>//</span>/ This method can be extended to any integer range by adding a </span></td>
        </tr>
        <tr>
          <td id="L1365" data-line-number="1365"></td>
          <td id="LC1365">	<span><span>//</span>/ value to x before the comparison.</span></td>
        </tr>
        <tr>
          <td id="L1366" data-line-number="1366"></td>
          <td id="LC1366">	<span><span>//</span>/ Normally you wouldn&#39;t call a function as with this example, </span></td>
        </tr>
        <tr>
          <td id="L1367" data-line-number="1367"></td>
          <td id="LC1367">	<span><span>//</span>/ but instead you would just say something like:</span></td>
        </tr>
        <tr>
          <td id="L1368" data-line-number="1368"></td>
          <td id="LC1368">	<span><span>//</span>/    if((unsigned)x &lt; 4) ...</span></td>
        </tr>
        <tr>
          <td id="L1369" data-line-number="1369"></td>
          <td id="LC1369">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1370" data-line-number="1370"></td>
          <td id="LC1370">	<span><span>//</span>/    3, 4 -&gt; true </span></td>
        </tr>
        <tr>
          <td id="L1371" data-line-number="1371"></td>
          <td id="LC1371">	<span><span>//</span>/   -3, 4 -&gt; false</span></td>
        </tr>
        <tr>
          <td id="L1372" data-line-number="1372"></td>
          <td id="LC1372">	<span><span>//</span>/ Example function:</span></td>
        </tr>
        <tr>
          <td id="L1373" data-line-number="1373"></td>
          <td id="LC1373">	<span><span>//</span>/    inline bool IsBetween8And12(int x){</span></td>
        </tr>
        <tr>
          <td id="L1374" data-line-number="1374"></td>
          <td id="LC1374">	<span><span>//</span>/        return ((unsigned)x + 8) &lt; 12;</span></td>
        </tr>
        <tr>
          <td id="L1375" data-line-number="1375"></td>
          <td id="LC1375">	<span><span>//</span>/    }</span></td>
        </tr>
        <tr>
          <td id="L1376" data-line-number="1376"></td>
          <td id="LC1376">	<span>inline</span> <span>bool</span> <span>IsBetween0AndValue</span>(<span>int32_t</span> x, <span>int32_t</span> a){</td>
        </tr>
        <tr>
          <td id="L1377" data-line-number="1377"></td>
          <td id="LC1377">		<span>return</span> (<span>uint32_t</span>)x &lt; (<span>uint32_t</span>)a;</td>
        </tr>
        <tr>
          <td id="L1378" data-line-number="1378"></td>
          <td id="LC1378">	}</td>
        </tr>
        <tr>
          <td id="L1379" data-line-number="1379"></td>
          <td id="LC1379">
</td>
        </tr>
        <tr>
          <td id="L1380" data-line-number="1380"></td>
          <td id="LC1380">	<span>inline</span> <span>bool</span> <span>IsBetween0AndValue</span>(<span>int64_t</span> x, <span>int64_t</span> a){</td>
        </tr>
        <tr>
          <td id="L1381" data-line-number="1381"></td>
          <td id="LC1381">		<span>return</span> (<span>uint64_t</span>)x &lt; (<span>uint64_t</span>)a;</td>
        </tr>
        <tr>
          <td id="L1382" data-line-number="1382"></td>
          <td id="LC1382">	}</td>
        </tr>
        <tr>
          <td id="L1383" data-line-number="1383"></td>
          <td id="LC1383">
</td>
        </tr>
        <tr>
          <td id="L1384" data-line-number="1384"></td>
          <td id="LC1384">	<span><span>//</span>/ ExchangeValues</span></td>
        </tr>
        <tr>
          <td id="L1385" data-line-number="1385"></td>
          <td id="LC1385">	<span><span>//</span>/ How to exchange two values in place.</span></td>
        </tr>
        <tr>
          <td id="L1386" data-line-number="1386"></td>
          <td id="LC1386">	<span><span>//</span>/ It is well-known that xor-ing two values like this exchanges them in place.</span></td>
        </tr>
        <tr>
          <td id="L1387" data-line-number="1387"></td>
          <td id="LC1387">	<span><span>//</span>/ This trick is perhaps of little practical value and is instead more of a curiosity.</span></td>
        </tr>
        <tr>
          <td id="L1388" data-line-number="1388"></td>
          <td id="LC1388">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1389" data-line-number="1389"></td>
          <td id="LC1389">	<span><span>//</span>/    2, 3 -&gt; 3, 2</span></td>
        </tr>
        <tr>
          <td id="L1390" data-line-number="1390"></td>
          <td id="LC1390">	<span>template </span>&lt;<span>typename</span> T&gt;</td>
        </tr>
        <tr>
          <td id="L1391" data-line-number="1391"></td>
          <td id="LC1391">	<span>inline</span> <span>void</span> <span>ExchangeValues</span>(T&amp; x, T&amp; y){</td>
        </tr>
        <tr>
          <td id="L1392" data-line-number="1392"></td>
          <td id="LC1392">		x = (T)(x ^ y);</td>
        </tr>
        <tr>
          <td id="L1393" data-line-number="1393"></td>
          <td id="LC1393">		y = (T)(x ^ y);</td>
        </tr>
        <tr>
          <td id="L1394" data-line-number="1394"></td>
          <td id="LC1394">		x = (T)(x ^ y);</td>
        </tr>
        <tr>
          <td id="L1395" data-line-number="1395"></td>
          <td id="LC1395">	}</td>
        </tr>
        <tr>
          <td id="L1396" data-line-number="1396"></td>
          <td id="LC1396">
</td>
        </tr>
        <tr>
          <td id="L1397" data-line-number="1397"></td>
          <td id="LC1397">	<span><span>//</span>/ FloorMod</span></td>
        </tr>
        <tr>
          <td id="L1398" data-line-number="1398"></td>
          <td id="LC1398">	<span><span>//</span>/ The normal C modulo operator (%) operates on the assumption that</span></td>
        </tr>
        <tr>
          <td id="L1399" data-line-number="1399"></td>
          <td id="LC1399">	<span><span>//</span>/ division rounds towards zero, which means that the result of a</span></td>
        </tr>
        <tr>
          <td id="L1400" data-line-number="1400"></td>
          <td id="LC1400">	<span><span>//</span>/ modulus operation on a negative number is also negative. (The</span></td>
        </tr>
        <tr>
          <td id="L1401" data-line-number="1401"></td>
          <td id="LC1401">	<span><span>//</span>/ modulus operator in C is defined as the remainder after a division,</span></td>
        </tr>
        <tr>
          <td id="L1402" data-line-number="1402"></td>
          <td id="LC1402">	<span><span>//</span>/ so in the case where a negative number is rounded up, the remainder</span></td>
        </tr>
        <tr>
          <td id="L1403" data-line-number="1403"></td>
          <td id="LC1403">	<span><span>//</span>/ will be negative.) FloorMod instead returns the remainder of</span></td>
        </tr>
        <tr>
          <td id="L1404" data-line-number="1404"></td>
          <td id="LC1404">	<span><span>//</span>/ a division rounded towards negative infinity; the modulus will always </span></td>
        </tr>
        <tr>
          <td id="L1405" data-line-number="1405"></td>
          <td id="LC1405">	<span><span>//</span>/ be a positive number.</span></td>
        </tr>
        <tr>
          <td id="L1406" data-line-number="1406"></td>
          <td id="LC1406">	<span>template</span>&lt;<span>class</span> <span>T</span>&gt;</td>
        </tr>
        <tr>
          <td id="L1407" data-line-number="1407"></td>
          <td id="LC1407">	T <span>FloorMod</span>(T n, T mod){</td>
        </tr>
        <tr>
          <td id="L1408" data-line-number="1408"></td>
          <td id="LC1408">		<span>const</span> T v = n % mod;</td>
        </tr>
        <tr>
          <td id="L1409" data-line-number="1409"></td>
          <td id="LC1409">		<span>return</span> v + ((v &gt;&gt; ((<span>sizeof</span>(v) * <span>8</span>) - <span>1</span>)) &amp; mod);</td>
        </tr>
        <tr>
          <td id="L1410" data-line-number="1410"></td>
          <td id="LC1410">	}</td>
        </tr>
        <tr>
          <td id="L1411" data-line-number="1411"></td>
          <td id="LC1411">
</td>
        </tr>
        <tr>
          <td id="L1412" data-line-number="1412"></td>
          <td id="LC1412">	<span><span>//</span>/ GetSign</span></td>
        </tr>
        <tr>
          <td id="L1413" data-line-number="1413"></td>
          <td id="LC1413">	<span><span>//</span>/ How to get the sign of an integer.</span></td>
        </tr>
        <tr>
          <td id="L1414" data-line-number="1414"></td>
          <td id="LC1414">	<span><span>//</span>/ Negative inputs return -1, positive inputs return +1, a zero input returns 0.</span></td>
        </tr>
        <tr>
          <td id="L1415" data-line-number="1415"></td>
          <td id="LC1415">	<span><span>//</span>/ These functions are significantly faster than brute force if/else statements.</span></td>
        </tr>
        <tr>
          <td id="L1416" data-line-number="1416"></td>
          <td id="LC1416">	<span><span>//</span>/ Requires signed right shift support. Note that most compilers/platforms </span></td>
        </tr>
        <tr>
          <td id="L1417" data-line-number="1417"></td>
          <td id="LC1417">	<span><span>//</span>/ support signed numerical right shifts.</span></td>
        </tr>
        <tr>
          <td id="L1418" data-line-number="1418"></td>
          <td id="LC1418">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1419" data-line-number="1419"></td>
          <td id="LC1419">	<span><span>//</span>/     -5  -&gt; -1</span></td>
        </tr>
        <tr>
          <td id="L1420" data-line-number="1420"></td>
          <td id="LC1420">	<span><span>//</span>/      0  -&gt;  0</span></td>
        </tr>
        <tr>
          <td id="L1421" data-line-number="1421"></td>
          <td id="LC1421">	<span><span>//</span>/     250 -&gt;  1</span></td>
        </tr>
        <tr>
          <td id="L1422" data-line-number="1422"></td>
          <td id="LC1422">	<span>inline</span> <span>int</span> <span>GetSign</span>(<span>int32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1423" data-line-number="1423"></td>
          <td id="LC1423">		<span>return</span> (<span>int</span>)((x &gt;&gt; <span>31</span>) | (-(<span>uint32_t</span>)x &gt;&gt; <span>31</span>)); <span><span>//</span> negation of signed int is undefined behaviour</span></td>
        </tr>
        <tr>
          <td id="L1424" data-line-number="1424"></td>
          <td id="LC1424">	}</td>
        </tr>
        <tr>
          <td id="L1425" data-line-number="1425"></td>
          <td id="LC1425">
</td>
        </tr>
        <tr>
          <td id="L1426" data-line-number="1426"></td>
          <td id="LC1426">	<span>inline</span> <span>int</span> <span>GetSign</span>(<span>int64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1427" data-line-number="1427"></td>
          <td id="LC1427">		<span>return</span> (<span>int</span>)((x &gt;&gt; <span>63</span>) | (-(<span>uint64_t</span>)x &gt;&gt; <span>63</span>)); <span><span>//</span> negation of signed int is undefined behaviour</span></td>
        </tr>
        <tr>
          <td id="L1428" data-line-number="1428"></td>
          <td id="LC1428">	}</td>
        </tr>
        <tr>
          <td id="L1429" data-line-number="1429"></td>
          <td id="LC1429">
</td>
        </tr>
        <tr>
          <td id="L1430" data-line-number="1430"></td>
          <td id="LC1430">	<span><span>//</span>/ GetSignEx</span></td>
        </tr>
        <tr>
          <td id="L1431" data-line-number="1431"></td>
          <td id="LC1431">	<span><span>//</span>/ How to get the sign of an integer.</span></td>
        </tr>
        <tr>
          <td id="L1432" data-line-number="1432"></td>
          <td id="LC1432">	<span><span>//</span>/ Returns 1 for &gt; 0, 0 for 0, and -1 for &lt; 0.</span></td>
        </tr>
        <tr>
          <td id="L1433" data-line-number="1433"></td>
          <td id="LC1433">	<span><span>//</span>/ This version doesn&#39;t work for input of 0x80000000 / 0x8000000000000000. </span></td>
        </tr>
        <tr>
          <td id="L1434" data-line-number="1434"></td>
          <td id="LC1434">	<span>inline</span> <span>int</span> <span>GetSignEx</span>(<span>int32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1435" data-line-number="1435"></td>
          <td id="LC1435">		<span>return</span> (x &gt;&gt; <span>31</span>) - (-x &gt;&gt; <span>31</span>);</td>
        </tr>
        <tr>
          <td id="L1436" data-line-number="1436"></td>
          <td id="LC1436">	}</td>
        </tr>
        <tr>
          <td id="L1437" data-line-number="1437"></td>
          <td id="LC1437">
</td>
        </tr>
        <tr>
          <td id="L1438" data-line-number="1438"></td>
          <td id="LC1438">	<span>inline</span> <span>int</span> <span>GetSignEx</span>(<span>int64_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1439" data-line-number="1439"></td>
          <td id="LC1439">		<span>return</span> (x &gt;&gt; <span>63</span>) - (-x &gt;&gt; <span>63</span>);</td>
        </tr>
        <tr>
          <td id="L1440" data-line-number="1440"></td>
          <td id="LC1440">	}</td>
        </tr>
        <tr>
          <td id="L1441" data-line-number="1441"></td>
          <td id="LC1441">
</td>
        </tr>
        <tr>
          <td id="L1442" data-line-number="1442"></td>
          <td id="LC1442">	<span><span>//</span>/ SignExtend12</span></td>
        </tr>
        <tr>
          <td id="L1443" data-line-number="1443"></td>
          <td id="LC1443">	<span><span>//</span>/ How to do fast sign extension of a 12 bit value to 32 bits.</span></td>
        </tr>
        <tr>
          <td id="L1444" data-line-number="1444"></td>
          <td id="LC1444">	<span><span>//</span>/ Say you have a signed 12 bit value stored in an integer and you want to </span></td>
        </tr>
        <tr>
          <td id="L1445" data-line-number="1445"></td>
          <td id="LC1445">	<span><span>//</span>/ make it be a proper 32 bit int. To do this, you want to take the high bit </span></td>
        </tr>
        <tr>
          <td id="L1446" data-line-number="1446"></td>
          <td id="LC1446">	<span><span>//</span>/ of the 12 bit value and replicate it leftward.</span></td>
        </tr>
        <tr>
          <td id="L1447" data-line-number="1447"></td>
          <td id="LC1447">	<span><span>//</span>/ To do this in a generic way, create a mask of the high bits in the </span></td>
        </tr>
        <tr>
          <td id="L1448" data-line-number="1448"></td>
          <td id="LC1448">	<span><span>//</span>/ larger operand plus the sign bit of the smaller, add, and xor.</span></td>
        </tr>
        <tr>
          <td id="L1449" data-line-number="1449"></td>
          <td id="LC1449">	<span><span>//</span>/ Example:</span></td>
        </tr>
        <tr>
          <td id="L1450" data-line-number="1450"></td>
          <td id="LC1450">	<span><span>//</span>/    0x00000fff -&gt; 12 -&gt; 0xffffffff</span></td>
        </tr>
        <tr>
          <td id="L1451" data-line-number="1451"></td>
          <td id="LC1451">	<span><span>//</span>/    0x00000aaa -&gt; 12 -&gt; 0x00000aaa</span></td>
        </tr>
        <tr>
          <td id="L1452" data-line-number="1452"></td>
          <td id="LC1452">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1453" data-line-number="1453"></td>
          <td id="LC1453">	<span><span>//</span>/    0x00ffffff -&gt; 24 -&gt; 0xffffffff</span></td>
        </tr>
        <tr>
          <td id="L1454" data-line-number="1454"></td>
          <td id="LC1454">	<span><span>//</span>/    0x00aaaaaa -&gt; 24 -&gt; 0x00aaaaaa</span></td>
        </tr>
        <tr>
          <td id="L1455" data-line-number="1455"></td>
          <td id="LC1455">	<span>inline</span> <span>int32_t</span> <span>SignExtend12</span>(<span>int32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1456" data-line-number="1456"></td>
          <td id="LC1456">		<span>return</span> (<span>int32_t</span>)((x + <span>0xfffff800</span>) ^ <span>0xfffff800</span>);</td>
        </tr>
        <tr>
          <td id="L1457" data-line-number="1457"></td>
          <td id="LC1457">	}</td>
        </tr>
        <tr>
          <td id="L1458" data-line-number="1458"></td>
          <td id="LC1458">
</td>
        </tr>
        <tr>
          <td id="L1459" data-line-number="1459"></td>
          <td id="LC1459">	<span>inline</span> <span>int32_t</span> <span>SignExtend24</span>(<span>int32_t</span> x){</td>
        </tr>
        <tr>
          <td id="L1460" data-line-number="1460"></td>
          <td id="LC1460">		<span>return</span> (<span>int32_t</span>)((x + <span>0xff800000</span>) ^ <span>0xff800000</span>);</td>
        </tr>
        <tr>
          <td id="L1461" data-line-number="1461"></td>
          <td id="LC1461">	}</td>
        </tr>
        <tr>
          <td id="L1462" data-line-number="1462"></td>
          <td id="LC1462">
</td>
        </tr>
        <tr>
          <td id="L1463" data-line-number="1463"></td>
          <td id="LC1463">	<span><span>//</span>/ IsUnsigned</span></td>
        </tr>
        <tr>
          <td id="L1464" data-line-number="1464"></td>
          <td id="LC1464">	<span><span>//</span>/ This version requires signed right shift support. It should work for most </span></td>
        </tr>
        <tr>
          <td id="L1465" data-line-number="1465"></td>
          <td id="LC1465">	<span><span>//</span>/ modern computers and compilers, as they have a signed right shift.</span></td>
        </tr>
        <tr>
          <td id="L1466" data-line-number="1466"></td>
          <td id="LC1466">	<span>template </span>&lt;<span>class</span> <span>T</span>&gt;</td>
        </tr>
        <tr>
          <td id="L1467" data-line-number="1467"></td>
          <td id="LC1467">	<span>bool</span> <span>IsUnsigned</span>(T <span><span>/*</span>x<span>*/</span></span>){</td>
        </tr>
        <tr>
          <td id="L1468" data-line-number="1468"></td>
          <td id="LC1468">		<span>return</span> (((T)(-<span>1</span>) &gt;&gt; <span>1</span>) != (T)(-<span>1</span>));</td>
        </tr>
        <tr>
          <td id="L1469" data-line-number="1469"></td>
          <td id="LC1469">	}</td>
        </tr>
        <tr>
          <td id="L1470" data-line-number="1470"></td>
          <td id="LC1470">
</td>
        </tr>
        <tr>
          <td id="L1471" data-line-number="1471"></td>
          <td id="LC1471">	<span><span>//</span>/ EAIsUnsigned</span></td>
        </tr>
        <tr>
          <td id="L1472" data-line-number="1472"></td>
          <td id="LC1472">	<span><span>//</span>/ How to tell if an integer variable is an unsigned type at runtime.</span></td>
        </tr>
        <tr>
          <td id="L1473" data-line-number="1473"></td>
          <td id="LC1473">	<span><span>//</span>/ </span></td>
        </tr>
        <tr>
          <td id="L1474" data-line-number="1474"></td>
          <td id="LC1474">	<span><span>//</span>/ Note that this isn&#39;t a test to see of a given variable is negative; </span></td>
        </tr>
        <tr>
          <td id="L1475" data-line-number="1475"></td>
          <td id="LC1475">	<span><span>//</span>/ this is a test to see if a data type is signed or unsigned. </span></td>
        </tr>
        <tr>
          <td id="L1476" data-line-number="1476"></td>
          <td id="LC1476">	<span><span>//</span>/ With some data types, such as wchar_t and size_t, you can&#39;t know </span></td>
        </tr>
        <tr>
          <td id="L1477" data-line-number="1477"></td>
          <td id="LC1477">	<span><span>//</span>/ if the type is signed or unsigned at compile time.</span></td>
        </tr>
        <tr>
          <td id="L1478" data-line-number="1478"></td>
          <td id="LC1478">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1479" data-line-number="1479"></td>
          <td id="LC1479">	<span><span>//</span>/ This is a notoriously tricky problem, as commonly published solutions </span></td>
        </tr>
        <tr>
          <td id="L1480" data-line-number="1480"></td>
          <td id="LC1480">	<span><span>//</span>/ don&#39;t work for integer types other than int or make assumptions about </span></td>
        </tr>
        <tr>
          <td id="L1481" data-line-number="1481"></td>
          <td id="LC1481">	<span><span>//</span>/ how right shifting of signed values occur.</span></td>
        </tr>
        <tr>
          <td id="L1482" data-line-number="1482"></td>
          <td id="LC1482">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1483" data-line-number="1483"></td>
          <td id="LC1483">	<span><span>//</span>/ This could also be solved for C++ with templates. That would be a better</span></td>
        </tr>
        <tr>
          <td id="L1484" data-line-number="1484"></td>
          <td id="LC1484">	<span><span>//</span>/ solution that this and would effectively be a compile-time check as opposed </span></td>
        </tr>
        <tr>
          <td id="L1485" data-line-number="1485"></td>
          <td id="LC1485">	<span><span>//</span>/ to a runtime check. See EASTL type traits for this.</span></td>
        </tr>
        <tr>
          <td id="L1486" data-line-number="1486"></td>
          <td id="LC1486">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1487" data-line-number="1487"></td>
          <td id="LC1487">	<span><span>//</span>/ Example usage:</span></td>
        </tr>
        <tr>
          <td id="L1488" data-line-number="1488"></td>
          <td id="LC1488">	<span><span>//</span>/     uint8_t u8  = 0;</span></td>
        </tr>
        <tr>
          <td id="L1489" data-line-number="1489"></td>
          <td id="LC1489">	<span><span>//</span>/     int64_t i64 = 0;</span></td>
        </tr>
        <tr>
          <td id="L1490" data-line-number="1490"></td>
          <td id="LC1490">	<span><span>//</span>/     assert( EAIsUnsigned(u8)));</span></td>
        </tr>
        <tr>
          <td id="L1491" data-line-number="1491"></td>
          <td id="LC1491">	<span><span>//</span>/     assert(!EAIsUnsigned(i64)));</span></td>
        </tr>
        <tr>
          <td id="L1492" data-line-number="1492"></td>
          <td id="LC1492">	#<span>ifndef</span> EAIsUnsigned</td>
        </tr>
        <tr>
          <td id="L1493" data-line-number="1493"></td>
          <td id="LC1493">		#<span>define</span> <span>EAIsUnsigned</span>(<span>x</span>) ((((x = ~x) &gt;= <span>0</span>) || (((x = ~x) != <span>0</span>) &amp;&amp; <span>0</span>)) &amp;&amp; ((x = ~x) &gt;= <span>0</span>))</td>
        </tr>
        <tr>
          <td id="L1494" data-line-number="1494"></td>
          <td id="LC1494">	#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L1495" data-line-number="1495"></td>
          <td id="LC1495">
</td>
        </tr>
        <tr>
          <td id="L1496" data-line-number="1496"></td>
          <td id="LC1496">
</td>
        </tr>
        <tr>
          <td id="L1497" data-line-number="1497"></td>
          <td id="LC1497">	<span><span>//</span> How to tell the integer representation of the computer.</span></td>
        </tr>
        <tr>
          <td id="L1498" data-line-number="1498"></td>
          <td id="LC1498">	<span><span>//</span> Just about every computer you are likely to work with will be twos-complement.</span></td>
        </tr>
        <tr>
          <td id="L1499" data-line-number="1499"></td>
          <td id="LC1499">	<span><span>//</span> You can look these terms up on the Internet to get detailed descriptions of them.</span></td>
        </tr>
        <tr>
          <td id="L1500" data-line-number="1500"></td>
          <td id="LC1500">	<span>inline</span> <span>bool</span> <span>IsTwosComplement</span>(){</td>
        </tr>
        <tr>
          <td id="L1501" data-line-number="1501"></td>
          <td id="LC1501">		<span>return</span> ((-<span>2</span> | -<span>3</span>) == -<span>1</span>);</td>
        </tr>
        <tr>
          <td id="L1502" data-line-number="1502"></td>
          <td id="LC1502">	}</td>
        </tr>
        <tr>
          <td id="L1503" data-line-number="1503"></td>
          <td id="LC1503">
</td>
        </tr>
        <tr>
          <td id="L1504" data-line-number="1504"></td>
          <td id="LC1504">	<span>inline</span> <span>bool</span> <span>IsOnesComplement</span>(){</td>
        </tr>
        <tr>
          <td id="L1505" data-line-number="1505"></td>
          <td id="LC1505">		<span>return</span> ((-<span>1</span> &amp; -<span>2</span>) == -<span>3</span>);</td>
        </tr>
        <tr>
          <td id="L1506" data-line-number="1506"></td>
          <td id="LC1506">	}</td>
        </tr>
        <tr>
          <td id="L1507" data-line-number="1507"></td>
          <td id="LC1507">
</td>
        </tr>
        <tr>
          <td id="L1508" data-line-number="1508"></td>
          <td id="LC1508">	<span>inline</span> <span>bool</span> <span>IsSignMagnitude</span>(){</td>
        </tr>
        <tr>
          <td id="L1509" data-line-number="1509"></td>
          <td id="LC1509">		<span>return</span> ((-<span>1</span> | -<span>2</span>) == -<span>3</span>);</td>
        </tr>
        <tr>
          <td id="L1510" data-line-number="1510"></td>
          <td id="LC1510">	}</td>
        </tr>
        <tr>
          <td id="L1511" data-line-number="1511"></td>
          <td id="LC1511">
</td>
        </tr>
        <tr>
          <td id="L1512" data-line-number="1512"></td>
          <td id="LC1512">	<span>inline</span> <span>bool</span> <span>IsOffsetBinary</span>(){</td>
        </tr>
        <tr>
          <td id="L1513" data-line-number="1513"></td>
          <td id="LC1513">		<span>return</span> ((<span>1u</span> &lt;&lt; (<span>sizeof</span>(<span>int</span>) * <span>8</span> - <span>1</span>)) == <span>0</span>);</td>
        </tr>
        <tr>
          <td id="L1514" data-line-number="1514"></td>
          <td id="LC1514">	}</td>
        </tr>
        <tr>
          <td id="L1515" data-line-number="1515"></td>
          <td id="LC1515">
</td>
        </tr>
        <tr>
          <td id="L1516" data-line-number="1516"></td>
          <td id="LC1516">
</td>
        </tr>
        <tr>
          <td id="L1517" data-line-number="1517"></td>
          <td id="LC1517">	<span><span>//</span>/ EAOffsetOf</span></td>
        </tr>
        <tr>
          <td id="L1518" data-line-number="1518"></td>
          <td id="LC1518">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1519" data-line-number="1519"></td>
          <td id="LC1519">	<span><span>//</span>/ The offsetof macro is guaranteed to only work with POD types. However we wish to use</span></td>
        </tr>
        <tr>
          <td id="L1520" data-line-number="1520"></td>
          <td id="LC1520">	<span><span>//</span>/ it for non-POD types but where we know that offsetof will still work for the cases </span></td>
        </tr>
        <tr>
          <td id="L1521" data-line-number="1521"></td>
          <td id="LC1521">	<span><span>//</span>/ in which we use it. </span></td>
        </tr>
        <tr>
          <td id="L1522" data-line-number="1522"></td>
          <td id="LC1522">	#<span>ifndef</span> EAOffsetOf</td>
        </tr>
        <tr>
          <td id="L1523" data-line-number="1523"></td>
          <td id="LC1523">		#<span>define</span> <span>EAOffsetOf</span> EA_OFFSETOF</td>
        </tr>
        <tr>
          <td id="L1524" data-line-number="1524"></td>
          <td id="LC1524">	#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L1525" data-line-number="1525"></td>
          <td id="LC1525">
</td>
        </tr>
        <tr>
          <td id="L1526" data-line-number="1526"></td>
          <td id="LC1526">
</td>
        </tr>
        <tr>
          <td id="L1527" data-line-number="1527"></td>
          <td id="LC1527">	<span><span>//</span>/ EAOffsetOfBase</span></td>
        </tr>
        <tr>
          <td id="L1528" data-line-number="1528"></td>
          <td id="LC1528">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1529" data-line-number="1529"></td>
          <td id="LC1529">	<span><span>//</span>/ Returns the offset of the class Base within the subclass Class.</span></td>
        </tr>
        <tr>
          <td id="L1530" data-line-number="1530"></td>
          <td id="LC1530">	<span><span>//</span>/ Fails to compile for cases where Base is multiply inherited by Class.</span></td>
        </tr>
        <tr>
          <td id="L1531" data-line-number="1531"></td>
          <td id="LC1531">	<span><span>//</span>/ Example usage:</span></td>
        </tr>
        <tr>
          <td id="L1532" data-line-number="1532"></td>
          <td id="LC1532">	<span><span>//</span>/     struct A{ int a; };</span></td>
        </tr>
        <tr>
          <td id="L1533" data-line-number="1533"></td>
          <td id="LC1533">	<span><span>//</span>/     struct B{ int b; };</span></td>
        </tr>
        <tr>
          <td id="L1534" data-line-number="1534"></td>
          <td id="LC1534">	<span><span>//</span>/     struct C : public A, public B{ int c; };</span></td>
        </tr>
        <tr>
          <td id="L1535" data-line-number="1535"></td>
          <td id="LC1535">	<span><span>//</span>/     EAOffsetOfBase&lt;C, B&gt;() =&gt; 4</span></td>
        </tr>
        <tr>
          <td id="L1536" data-line-number="1536"></td>
          <td id="LC1536">	<span><span>//</span>/ </span></td>
        </tr>
        <tr>
          <td id="L1537" data-line-number="1537"></td>
          <td id="LC1537">	<span><span>//</span>/ EAOffsetOfBase is not guaranteed to be a compile-time constant expression, </span></td>
        </tr>
        <tr>
          <td id="L1538" data-line-number="1538"></td>
          <td id="LC1538">	<span><span>//</span>/ due to the use of reinterpret_cast of a pointer. </span></td>
        </tr>
        <tr>
          <td id="L1539" data-line-number="1539"></td>
          <td id="LC1539">	<span><span>//</span>/</span></td>
        </tr>
        <tr>
          <td id="L1540" data-line-number="1540"></td>
          <td id="LC1540">	#<span>if</span> !defined(EAOffsetOfBaseDefined)</td>
        </tr>
        <tr>
          <td id="L1541" data-line-number="1541"></td>
          <td id="LC1541">		#<span>define</span> <span>EAOffsetOfBaseDefined</span> <span>1</span></td>
        </tr>
        <tr>
          <td id="L1542" data-line-number="1542"></td>
          <td id="LC1542">
</td>
        </tr>
        <tr>
          <td id="L1543" data-line-number="1543"></td>
          <td id="LC1543">		<span>template </span>&lt;<span>typename</span> Class, <span>typename</span> Base&gt;</td>
        </tr>
        <tr>
          <td id="L1544" data-line-number="1544"></td>
          <td id="LC1544">		EA_NO_UBSAN <span>size_t</span> <span>EAOffsetOfBase</span>() <span><span>//</span> Disable UBSAN because we are using an address which doesn&#39;t respect type alignment.</span></td>
        </tr>
        <tr>
          <td id="L1545" data-line-number="1545"></td>
          <td id="LC1545">		{    </td>
        </tr>
        <tr>
          <td id="L1546" data-line-number="1546"></td>
          <td id="LC1546">			<span>return</span> (<span>size_t</span>)((Base*)<span>reinterpret_cast</span>&lt;Class*&gt;(<span>1</span>)) - <span>1</span>; <span><span>//</span> Use 1 instead of 0 because compilers often treat 0 specially and warn.</span></td>
        </tr>
        <tr>
          <td id="L1547" data-line-number="1547"></td>
          <td id="LC1547">		}</td>
        </tr>
        <tr>
          <td id="L1548" data-line-number="1548"></td>
          <td id="LC1548">	#<span>endif</span></td>
        </tr>
        <tr>
          <td id="L1549" data-line-number="1549"></td>
          <td id="LC1549">
</td>
        </tr>
        <tr>
          <td id="L1550" data-line-number="1550"></td>
          <td id="LC1550">
</td>
        </tr>
        <tr>
          <td id="L1551" data-line-number="1551"></td>
          <td id="LC1551">} <span><span>//</span> namespace StdC</span></td>
        </tr>
        <tr>
          <td id="L1552" data-line-number="1552"></td>
          <td id="LC1552">} <span><span>//</span> namespace EA</span></td>
        </tr>
        <tr>
          <td id="L1553" data-line-number="1553"></td>
          <td id="LC1553">
</td>
        </tr>
        <tr>
          <td id="L1554" data-line-number="1554"></td>
          <td id="LC1554">
</td>
        </tr>
        <tr>
          <td id="L1555" data-line-number="1555"></td>
          <td id="LC1555"><span>EA_RESTORE_VC_WARNING</span>()</td>
        </tr>
        <tr>
          <td id="L1556" data-line-number="1556"></td>
          <td id="LC1556">
</td>
        </tr>
        <tr>
          <td id="L1557" data-line-number="1557"></td>
          <td id="LC1557">
</td>
        </tr>
        <tr>
          <td id="L1558" data-line-number="1558"></td>
          <td id="LC1558">#<span>endif</span> <span><span>//</span> Header include guard</span></td>
        </tr>
        <tr>
          <td id="L1559" data-line-number="1559"></td>
          <td id="LC1559">
</td>
        </tr>
        <tr>
          <td id="L1560" data-line-number="1560"></td>
          <td id="LC1560">
</td>
        </tr>
        <tr>
          <td id="L1561" data-line-number="1561"></td>
          <td id="LC1561">
</td>
        </tr>
        <tr>
          <td id="L1562" data-line-number="1562"></td>
          <td id="LC1562"> </td>
        </tr>
        <tr>
          <td id="L1563" data-line-number="1563"></td>
          <td id="LC1563">
</td>
        </tr>
        <tr>
          <td id="L1564" data-line-number="1564"></td>
          <td id="LC1564">
</td>
        </tr>
        <tr>
          <td id="L1565" data-line-number="1565"></td>
          <td id="LC1565">
</td>
        </tr>
        <tr>
          <td id="L1566" data-line-number="1566"></td>
          <td id="LC1566">
</td>
        </tr>
  </tbody></div></div>
  </body>
</html>
