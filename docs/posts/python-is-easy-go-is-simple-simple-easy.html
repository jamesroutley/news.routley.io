<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://preslav.me/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/">Original</a>
    <h1>Python Is Easy. Go Is Simple. Simple != Easy</h1>
    
    <div id="readability-page-1" class="page"><article><header></header><section><div><p>Python and Go have distinct qualities that can complement each other.</p><figure><img srcset="/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/cover_huf1433fb1d8c7ca998d42f11cbcd49a88_386468_330x0_resize_q75_box.jpg 330w,
/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/cover_huf1433fb1d8c7ca998d42f11cbcd49a88_386468_660x0_resize_q75_box.jpg 660w,
/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/cover_huf1433fb1d8c7ca998d42f11cbcd49a88_386468_1024x0_resize_q75_box.jpg 1024w,
/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/cover_huf1433fb1d8c7ca998d42f11cbcd49a88_386468_1320x0_resize_q75_box.jpg 2x" src="https://preslav.me/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/cover_huf1433fb1d8c7ca998d42f11cbcd49a88_386468_660x0_resize_q75_box.jpg" alt=""/><figcaption>Image Credits: <a href="https://www.midjourney.com">Midjourney</a></figcaption></figure><p>There is a common misconception that <em>simple</em> and <em>easy</em> refer to the same thing. After all, if something is easy to use, its inner workings must be simple to understand, right? Or vice versa? Actually, it is quite the opposite. While the two concepts spiritually point to the same outcome, making something seem easy on the outside requires enormous complexity under the hood.</p><p>Take Python, a language known for its low barrier to entry and, therefore, a favorite choice for entry programming language. Schools, universities, research centers, and a large number of businesses across the globe have chosen Python precisely because of its accessibility to anyone, regardless of their level of education or academic background (or total lack thereof). One rarely needs much type theory or understanding of how and where things get stored in memory, which threads some piece of code is running on, etc. Moreover, Python is the entry gateway to some of the most profound scientific and system-level libraries. Being able to control this amount of power with a single line of code speaks a lot in favor of it becoming one of the most popular programming languages on the planet.</p><p>And here comes the catch - the easiness of expressing things in Python code comes at a cost. Under the hood, the Python interpreter is massive, and many operations must take place for even a single line of code to be executed. When you hear someone referring to Python as a “slow” language, much of the perceived “slowness” comes from the number of decisions the interpreter makes at runtime. But that’s not even the biggest issue, in my view. The complexity of the Python runtime ecosystem, together with some liberal design decisions around its package management, makes for a very fragile environment, and updates often lead to incompatibilities and runtime crashes. It is not uncommon to leave a Python application to go back to it after a few months, only to realize that the host environment has changed enough that it is no longer possible to even to start the application anymore.</p><p>Of course, this is a gross over-simplification, and even kids nowadays know that containers exist to solve problems like this. Indeed, thanks to Docker and its likes, it is possible to “freeze” a Python codebase’s dependencies in time so that it can practically run forever. However, this comes at the cost of shifting the responsibility and complexity to the OS infrastructure. It is not the end of the world, but it is also not something to underestimate and overlook.</p><h2 id="from-easiness-to-simplicity">From Easiness to Simplicity <span><a href="#from-easiness-to-simplicity" aria-label="Anchor">#</a></span></h2><p>If we were to address the issues with Python, we would end up with something like Rust - extremely performant but with a notoriously high barrier to entry. Rust is in my view, not easy to use, and what is more, not simple. While it is in total hype these days, despite 20 years of programming and having had my first steps in C and C++, I cannot look at a piece of Rust code and say with certainty that I understand what is going on there.</p><p>I discovered Go about five years ago while working on a Python-based system. While it took me a few tries to get to like the syntax, I immediately fell for the simplicity idea. Go is meant to be simple to understand by anyone in an organization - from the junior developer fresh out of school to the senior-level engineering manager who only occasionally looks at code. What’s more, being a simple language, Go gets syntax updates very rarely - the last significant one has been the addition of generics in v1.18, which is only after a decade of serious discussion. For the most part, whether you look at Go code written five days ago or five years ago, it is mostly the same and should just work.</p><p>Simplicity requires discipline, though. It can feel limiting and even somewhat backward at first. Especially when compared to a succinct expression, such as a list or a dictionary comprehension in Python:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>temperatures</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>{</span><span>&#34;city&#34;</span><span>:</span> <span>&#34;City1&#34;</span><span>,</span> <span>&#34;temp&#34;</span><span>:</span> <span>19</span><span>},</span>
</span></span><span><span>    <span>{</span><span>&#34;city&#34;</span><span>:</span> <span>&#34;City2&#34;</span><span>,</span> <span>&#34;temp&#34;</span><span>:</span> <span>22</span><span>},</span>
</span></span><span><span>    <span>{</span><span>&#34;city&#34;</span><span>:</span> <span>&#34;City3&#34;</span><span>,</span> <span>&#34;temp&#34;</span><span>:</span> <span>21</span><span>},</span>
</span></span><span><span><span>]</span>
</span></span><span><span>
</span></span><span><span><span>filtered_temps</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>entry</span><span>[</span><span>&#34;city&#34;</span><span>]:</span> <span>entry</span><span>[</span><span>&#34;temp&#34;</span><span>]</span> <span>for</span> <span>entry</span> <span>in</span> <span>temperatures</span> <span>if</span> <span>entry</span><span>[</span><span>&#34;temp&#34;</span><span>]</span> <span>&gt;</span> <span>20</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The same code in Go requires a few more keystrokes but should be ideally one idea closer to what the Python interpreter is doing under the hood:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>CityTemperature</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>City</span>      <span>string</span>
</span></span><span><span>    <span>Temp</span> <span>float64</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span>
</span></span><span><span><span>temperatures</span> <span>:=</span> <span>[]</span><span>CityTemperature</span><span>{</span>
</span></span><span><span>    <span>{</span><span>&#34;City1&#34;</span><span>,</span> <span>19</span><span>},</span>
</span></span><span><span>    <span>{</span><span>&#34;City2&#34;</span><span>,</span> <span>22</span><span>},</span>
</span></span><span><span>    <span>{</span><span>&#34;City3&#34;</span><span>,</span> <span>21</span><span>},</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>filteredTemps</span> <span>:=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>float64</span><span>)</span>
</span></span><span><span><span>for</span> <span>_</span><span>,</span> <span>ct</span> <span>:=</span> <span>range</span> <span>temperatures</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>ct</span><span>.</span><span>Temp</span> <span>&gt;</span> <span>20</span> <span>{</span>
</span></span><span><span>        <span>filteredTemps</span><span>[</span><span>ct</span><span>.</span><span>City</span><span>]</span> <span>=</span> <span>ct</span><span>.</span><span>Temp</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>While you can write equivalent code in Python, an unwritten rule in programming says that if the language provides an <em>easier</em> (as in, more concise, more elegant) option, programmers will gravitate towards it. But easy is subjective, and simple should be equally applicable to everyone. The availability of alternatives to perform the same action leads to different programming styles, and one can often find multiple styles within the same codebase.</p><p>With Go being verbose and “boring,” it naturally ticks another box - the Go compiler has much less work to do when compiling an executable. Compiling and running a Go application is often as fast, or even quicker, than getting the Python interpreter or Java’s virtual machine to load before even running the actual application. Not surprisingly, being a native executable is as fast as one executable can be. It’s not as fast as its C/C++ or Rust counterparts but at a fraction of the code complexity. I am willing to neglect this minor “drawback” of Go. Last but not least, Go binaries are statically-bound, meaning you can build one anywhere and run it on the target host - without any runtimes or library dependencies whatsoever. For the sake of convenience, we still wrap our Go applications in Docker containers. Still, those are significantly smaller and have a fraction of the memory and CPU consumption of their Python or Java counterparts.</p><h2 id="how-we-use-both-python-and-go-to-our-advantage">How we use both Python and Go to our advantage <span><a href="#how-we-use-both-python-and-go-to-our-advantage" aria-label="Anchor">#</a></span></h2><p>The most pragmatic solution we have found in our work is combining the powers of Python’s <em>easiness</em> and Go’s <em>simplicity</em>. For us, Python is a great prototyping playground. It’s where ideas are born and where scientific hypotheses get accepted and rejected. Python is a natural fit for data science and machine learning, and since we deal with lots of that stuff, it makes little sense to try and reinvent the wheel with something else. Python is also at the core of Django, which speaks to its motto of allowing rapid application development like few other tools (of course, Ruby on Rails and Elixir’s Phoenix deserve a noteworthy mention here).</p><p>Suppose a project needs the slightest bit of user management and internal data administration (like most of our projects do). In that case, we’d start with a Django skeleton because of its built-in Admin, which is fantastic. Once the rough Django proof-of-concept starts resembling a product, we identify how much of it can be rewritten in Go. Since the Django application has already defined the structure of the database and how data models look, writing the Go code that steps up on top of it is quite easy. After a few iterations, we reach a symbiosis, where the two sides peacefully co-exist on top of the same database and use bare-bones messaging to communicate with one another. Eventually, the Django “shell” becomes an orchestrator - it serves our administration purposes and triggers tasks that are then handled by its Go counterpart. The Go part serves everything else, from the front-facing APIs and endpoints to the business logic and backend job processing.</p><p>It’s a symbiosis that has worked well so far, and I hope it stays this way in the future. In a future post, I will outline some more details on the architecture itself.</p><p>Thanks for reading!</p></div></section><div><div><h2>You may also find these interesting</h2><article><p><a href="https://preslav.me/2023/06/28/podcasts-for-golang-developers/" aria-label="Podcasts for Go Developers"><img alt="" src="https://images.unsplash.com/photo-1556761175-129418cb2dfe?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80"/></a></p></article><article><p><a href="https://preslav.me/2023/06/14/golang-focus-on-the-happy-path-with-step-functions/" aria-label="Focus on the Happy Path With Step Functions"><img alt="" src="https://images.unsplash.com/photo-1516522184673-de15e930962f?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1478&amp;q=80"/></a></p></article><article><p><a href="https://preslav.me/2023/06/02/my-golang-conference-talk-proposal-got-declined-a-few-times/" aria-label="My Go Talk Proposal Got Declined. A Few Times."><img alt="" src="https://images.unsplash.com/photo-1517664946321-87d2e16ebaa6?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1771&amp;q=80"/></a></p></article></div></div></article></div>
  </body>
</html>
