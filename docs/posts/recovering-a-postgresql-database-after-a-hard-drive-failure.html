<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sambhav.saggis.com/en/blog/recovering-postgresql-hard-drive-fail">Original</a>
    <h1>Recovering a PostgreSQL database after a hard drive failure</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>I walked past my server, but I noticed something amiss: the console was spitting out read errors for my hard drive. So, I shut the whole server down (which is why the server was down for the past week). I got a new Samsung 870 EVO 1TB for Christmas, then installed it and copied over the data. However, some data was unreadable on the disk. Most of it was inconsequential, such as old journal files. Some of it was important, such as part of my Postgres database. Uh oh.</p>
<hr/>

<p>Problem number one is that I did not have backups. Lesson learned.</p>
<p>As some of you can guess, I&#39;m a <a href="https://ersei.saggis.com/en/blog/rss-with-grav">big fan of RSS</a>. I run my own <a href="https://www.freshrss.org/">FreshRSS</a> instance, which is backed by my Postgres database. As I logged on to view what I had missed over the past week, nothing showed up. SSH-ing to my server, opening the <code>psql</code> shell, and running a <code>select * from fr_me_entry</code> gave me an error: <code>ERROR:  could not read block 912 in file &#34;base/16504/278344&#34;: read only 0 of 8192 bytes</code>.</p>

<p>First things first, I shut down the Postgres server. Then, I made a full backup of the current state. However, some files did not copy over from the old disk to the new disk properly. So, step one was to use <a href="https://www.gnu.org/software/ddrescue/">ddrescue</a> to get as much of the broken file as possible from the old hard drive.</p>
<pre><code>root@server:/mnt/lib/postgresql/14/main/base/16504# ddrescue 278344 ~/278344
GNU ddrescue 1.23
Press Ctrl-C to interrupt
     ipos:    7642 kB, non-trimmed:        0 B,  current rate:       0 B/s
     opos:    7642 kB, non-scraped:        0 B,  average rate:   69792 B/s
non-tried:        0 B,  bad-sector:    32768 B,    error rate:     256 B/s
  rescued:   12492 kB,   bad areas:        4,        run time:      2m 59s
pct rescued:   99.73%, read errors:       67,  remaining time:          0s
                              time since last successful read:         35s
Finished</code></pre>
<p>Great! I got most of the file!</p>
<p>I replaced the broken file in Postgres with the recovered file, crossed my fingers, and ran <code>select * from fr_me_entries</code>.</p>
<p><code>ERROR:  unexpected chunk number 2 (expected 0) for toast value 298148 in pg_toast_278344</code></p>
<p>Ugh.</p>

<p>After scouring the internet, it seemed like the <a href="https://wiki.postgresql.org/wiki/TOAST">PostgreSQL Toast</a> data in some lines were corrupted. Some more searching brought me to <a href="https://www.databasesoup.com/2013/10/de-corrupting-toast-tables.html">this lifesaver of a website</a>. Time to remove the broken rows.</p>
<p>First, because I&#39;m wonderful at following directions, I reindexed the toast table: <code>REINDEX TABLE pg_toast.pg_toast_278344;</code></p>
<p>I knew the toasted values in the rows was the message, or the body of the RSS item. So, I used the script on the website (with a few modifications) to locate broken lines.</p>
<pre><code>DO $f$
declare
    curid BIGINT := 0;
    vcontent TEXT;
    badid BIGINT;
begin
FOR badid IN SELECT id FROM fr_me_entry LOOP
    curid = curid + 1;
    if curid % 1000 = 0 then
        raise notice &#39;% rows inspected&#39;, curid;
    end if;
    begin
        SELECT content
        INTO vcontent
        FROM fr_me_entry where id = badid;
        vcontent := substr(vcontent,1000,2000);
    exception
        when others then
            raise notice &#39;data for message % is corrupt.&#39;, badid;
            continue;
    end;
end loop;
end;
$f$;</code></pre>
<p>I got the output of the script.</p>
<pre><code>NOTICE:  data for message 1621857039614111 is corrupt
NOTICE:  data for message 1621857039614117 is corrupt
NOTICE:  1000 rows inspected
NOTICE:  data for message 1638760466010399 is corrupt
NOTICE:  data for message 1639844468285335 is corrupt
NOTICE:  data for message 1621857039614110 is corrupt
NOTICE:  2000 rows inspected
NOTICE:  data for message 1621857039614112 is corrupt
NOTICE:  data for message 1628270672577036 is corrupt
NOTICE:  3000 rows inspected
NOTICE:  data for message 1621857039614109 is corrupt
NOTICE:  data for message 1622960448368537 is corrupt
NOTICE:  data for message 1621857039614122 is corrupt
NOTICE:  data for message 1631013697483559 is corrupt
NOTICE:  4000 rows inspected
NOTICE:  data for message 1621857039614115 is corrupt
NOTICE:  data for message 1628270672577039 is corrupt
NOTICE:  data for message 1628270672577038 is corrupt
NOTICE:  data for message 1637457642679647 is corrupt
NOTICE:  data for message 1621857039614116 is corrupt
NOTICE:  data for message 1621857039614119 is corrupt
NOTICE:  5000 rows inspected
NOTICE:  6000 rows inspected
NOTICE:  7000 rows inspected
NOTICE:  data for message 1628270672577034 is corrupt
NOTICE:  data for message 1628270672577041 is corrupt
NOTICE:  8000 rows inspected
NOTICE:  9000 rows inspected
NOTICE:  10000 rows inspected
NOTICE:  11000 rows inspected
NOTICE:  12000 rows inspected
NOTICE:  13000 rows inspected
NOTICE:  14000 rows inspected
NOTICE:  15000 rows inspected</code></pre>
<p>The website said to unlink the rows by updating the values to no longer use the toast values with an <code>UPDATE</code> command.</p>
<p><code>UPDATE fr_me_entry SET content = &#39;&#39; WHERE id = 1621857039614111;</code></p>
<p>Rerunning the script gave the exact same results, but without the line <code>NOTICE:  data for message 1621857039614111 is corrupt</code>. Wonderful. I modified the script slightly to automatically unlink the information.</p>
<pre><code>DO $f$
declare
    curid BIGINT := 0;
    vcontent TEXT;
    badid BIGINT;
begin
FOR badid IN SELECT id FROM fr_me_entry LOOP
    curid = curid + 1;
    if curid % 1000 = 0 then
        raise notice &#39;% rows inspected&#39;, curid;
    end if;
    begin
        SELECT content
        INTO vcontent
        FROM fr_me_entry where id = badid;
        vcontent := substr(vcontent,1000,2000);
    exception
        when others then
            raise notice &#39;data for message % is corrupt. unlinking.&#39;, badid;
            update fr_me_entry set content = &#39;&#39; where id = badid;
            continue;
    end;
end loop;
end;
$f$;</code></pre>
<p>Let&#39;s open FreshRSS.</p>
<p><img alt="FreshRSS Showing Unread Articles" src="https://sambhav.saggis.com/user/pages/03.blog/11.recovering-postgresql-hard-drive-fail/freshrss.webp"/></p>
<p>Success. Oh wow, 1385 unread articles. This may take a while...</p>
    </div></div>
  </body>
</html>
