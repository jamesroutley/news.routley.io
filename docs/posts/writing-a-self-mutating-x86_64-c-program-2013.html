<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ephemeral.cx/2013/12/writing-a-self-mutating-x86_64-c-program/">Original</a>
    <h1>Writing a Self-Mutating x86_64 C Program (2013)</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
  

  <article>
    <p>“Why would you ever want to write a program that changes its code while it’s running? That’s a horrible idea!”</p>

<p>Yes, yes it is. It’s a good learning experience though. This is not something you would ever do outside of exploring a curiosity.</p>

<p>Self-mutating/self-modifying programs aren’t useful for a whole lot. They make for difficult debugging, the program becomes hardware dependent, and the code is extremely tedious and confusing to read unless you are an expert assembly programmer. The only good use for self-mutating programs in the wild I know of is as a cloaking mechanism for malware. My goal is purely academic so I venture into nothing of the sort here.</p>

<p><strong>Warning: This post is heavy on x86_64 assembly of which I am no expert. A fair amount of research went into writing this and it’s possible (almost expected) that mistakes were made. If you find one, send an email so that it may be corrected.</strong></p>

<p>The first step of writing a self-mutating program is being able to change the code at runtime. Programmers figured out long ago that this was a bad idea and since then protections have been added to prevent a program’s code from being changed at runtime. We first need to understand where the program’s instructions live when the program is being executed. When a program is to be executed, the loader will load the entire program into memory. The program then executes inside of a virtual address space that is managed by the kernel. This address space is broken up into different segments as illustrated below.</p>

<p><img src="https://ephemeral.cx/assets/images/2013/12/address_space.png" alt=""/></p>

<p>In this case, we’re only concerned with the text segment. This is where the instructions of the process are stored. Behind the address space are pages which are handled by the kernel. These pages map to the physical memory of the computer. The kernel controls permissions to each of these pages. By default, the text segment pages are set to read and execute. You may not write to them. In order to change the instructions at runtime, we’ll need to change the permissions of the text segment pages so that we write to them.</p>

<p>Changing the permissions of a page can be done with the <code>mprotect()</code> function. The only tricky part of <code>mprotect()</code> is that the pointer you give it must be aligned to a page boundary. Here is a function that given a pointer, moves the pointer to the page boundary and then changes that page to read, write, and execute permissions.</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>int</span> <span>change_page_permissions_of_address</span><span>(</span><span>void</span> <span>*</span><span>addr</span><span>)</span> <span>{</span>
    <span>int</span> <span>page_size</span> <span>=</span> <span>getpagesize</span><span>();</span>
    <span>addr</span> <span>-=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>addr</span> <span>%</span> <span>page_size</span><span>;</span>

    <span>if</span><span>(</span><span>mprotect</span><span>(</span><span>addr</span><span>,</span> <span>page_size</span><span>,</span> <span>PROT_READ</span> <span>|</span> <span>PROT_WRITE</span> <span>|</span> <span>PROT_EXEC</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<!--more-->

<p>If we give this function a pointer that points to an address in the text segment, that page in the text segment will now be writeable. It is important to note that the OS may refuse to allow the text segment to be writeable. I’m working on Linux, which does allow for writing to the text segment. If you are using another OS, make sure you’re checking the return value to see if the call to <code>mprotect()</code> failed. In the examples below, we assume that the function we’ll be changing is contained entirely on a single page. For long functions, this may not be the case.</p>

<hr/>

<p>Now that we can write to the text segment, the next question is: what do we write?</p>

<p>Let’s start with something simple. Say I have the following function:</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span>
    <span>i</span><span>++</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;i: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code>foo()</code> creates and initializes a local variable, <code>i</code>, to 0, then increments it by 1 and prints it to stdout. Let’s see if we can change the value that <code>i</code> is incremented by.</p>

<p>To accomplish this goal, we’ll need to see not just the instructions that <code>foo()</code> compiles to, but the actual machine code that <code>foo()</code> is assembled to. Let’s put <code>foo()</code> is a full program so it’s easier to do this.</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span>
<span>void</span> <span>foo</span><span>(</span><span>void</span><span>);</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span>
    <span>i</span><span>++</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;i: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now that we have <code>foo()</code> in a full C program, we can go ahead and compile it. Let’s go ahead and compile it with:</p>

<figure><pre><code data-lang="bash"><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>$ </span>gcc <span>-o</span> foo foo.c
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is where things start to get interesting. We need to disassemble the binary gcc created for us to see the instructions that comprise <code>foo()</code>. We can do this with the objdump utility like so:</p>

<figure><pre><code data-lang="bash"><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>$ </span>objdump <span>-d</span> foo <span>&gt;</span> foo.dis
</pre></td></tr></tbody></table></code></pre></figure>

<p>If you open the foo.dis file in a text editor, around line 128 (depending on the version of gcc used, <code>foo</code> may have slightly different instructions) you should see the disassembled <code>foo()</code> function. It looks like the following:</p>

<figure><pre><code data-lang="text"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre>0000000000400538 &lt;foo&gt;
  400538:	55                   	push   %rbp
  400539:	48 89 e5             	mov    %rsp,%rbp
  40053c:	48 83 ec 10          	sub    $0x10,%rsp
  400540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400547:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  40054b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40054e:	89 c6                	mov    %eax,%esi
  400550:	bf 14 06 40 00       	mov    $0x400614,%edi
  400555:	b8 00 00 00 00       	mov    $0x0,%eax
  40055a:	e8 b1 fe ff ff       	callq  400410
&lt;printf@plt&gt;
  40055f:	c9                   	leaveq
  400560:	c3                   	retq
  400561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  400568:	00 00 00
  40056b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
</pre></td></tr></tbody></table></code></pre></figure>

<p>If you have never worked with x86_64 code before, this might look a little foreign. Basically what’s going on here is that we are pushing the stack down 4 bytes (the size of an integer on my system) to use as the storage location for the variable <code>i</code>. We then initialize these 4 bytes to 0 and then add 1 to this value. Everything after this (40054b) is moving values around to prepare for calling the printf() function.</p>

<p>That said, if we want to change the value that i is incremented by, we need to change the following instruction:</p>

<figure><pre><code data-lang="text"><table><tbody><tr><td><pre>1
</pre></td><td><pre>400547:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
</pre></td></tr></tbody></table></code></pre></figure>

<p>Before going any further though, let’s break this instruction down.</p>

<table>
  <thead>
    <tr>
      <th><code>400547</code></th>
      <th><code>83 45 fc 01</code></th>
      <th><code>addl $0x1,-0x4(%rbp)</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>The first column is the memory location of this instruction.</td>
      <td>The second column is the machine code of the instruction. These are the bytes that the CPU will read and react to.</td>  
      <td>The third column is the human readable (well, readable to humans with some prior knowledge), disassembled machine code from the second column.</td>  
    </tr>
  </tbody>
</table>

<p>Going further, we can break down the instruction to understand its operands:</p>

<table>
  <thead>
    <tr>
      <th><code>addl</code></th>
      <th><code>$0x1</code></th>
      <th><code>-0x4(%rbp)</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>addl</code> is the instruction. There are multiple add commands in the x86_64 instruction set. This one means add an 8bit value to a register or memory location.</td>
      <td><code>$0x1</code> is an immediate value. Dollar signs denote immediate values and the <code>0x</code> prefix denotes a hexadecimal number follows. In this case, the number is just 1 since <code>0x1 = 1</code> in base 10.</td>  
      <td><code>-0x4(%rbp)</code> is the memory address to add the value to. Here it is saying to add it to the current location of the base stack pointer offset by 4 bytes. This is where our <code>i</code> variable was put on the stack.</td>  
    </tr>
  </tbody>
</table>

<p>Now that we understand the human readable form of the instruction, let’s dive into the machine instruction. All x86_64 instructions have the following format:</p>

<p><img src="https://ephemeral.cx/assets/images/2013/12/Instruction-Format.png" alt=""/></p>

<p>This is where x86_64 gets really complicated. x86_64 instructions have a variable length so to the unfamiliar, decoding instructions by hand can be a confusing and time consuming process. To make it easier, there are various documentation sources. x86ref.net has great documentation once you learn how to read it <a href="http://ref.x86asm.net/coder64.html#x83">such as the reference for the <code>addl</code> instruction</a>. For the brave, there is also the <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html">Intel 64 and IA-32 Architectures Developer’s Manual: Combined Vols. 1, 2, and 3</a> (warning: 3,000 page PDF).</p>

<p>In our case, these bytes mean the following:</p>

<table>
  <thead>
    <tr>
      <th><code>83</code></th>
      <th><code>45</code></th>
      <th><code>fc</code></th>
      <th><code>01</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>83</code> is the opcode of the <code>addl</code> instruction. All instructions have an opcode that tells the CPU what instruction to perform.</td>
      <td><code>45</code> is the ModR/M byte. Per Intel&#39;s documentation, <code>0x45 = [RBP/EBP]+disp8</code>. This means that <code>0x45</code> denotes the <code>%rbp</code> register is the destination and the byte that follows (in this case, <code>0xfc</code>) is the displacement byte.</td>  
      <td><code>fc</code> is the displacement byte. <code>0xfc = 0b11111100</code>. The displacement byte is sign-extended so this value is really just <code>0b100</code> or 4.</td>  
      <td><code>01</code> is the immediate value that will be added to the given memory address. <strong>This is the byte we need to change in order to change the value that <code>i</code> is incremented by.</strong></td>  
    </tr>
  </tbody>
</table>

<p>How did I determine what the ModR/M byte meant? There is a <a href="http://ref.x86asm.net/coder64.html#modrm_byte_32_64">handy table in the documentation that explains what each ModR/M byte means</a>. This table is also available in the Intel manual linked to above as Table 2-2 in section 2-5 of volume 2A (or page 445 of the PDF).</p>

<hr/>

<p>Moving right along, we now are able to change the instruction and know what to change; we just need to know how to change it.</p>

<p>To recap, we want to change the 01 byte in the <code>addl $0x1,-0x4(%rbp)</code> instruction.</p>

<p>To do this, we need to get the address of that byte. It’s trivial to get the address of <code>foo()</code> at runtime so all we need to do is find the offset of this byte from start of <code>foo()</code>. There’s two ways we can do this:</p>

<ol>
  <li>Use the objdump disassembly from earlier to count the number of bytes between the start of the function and the byte we want.</li>
  <li>Write a function to print the instructions of <code>foo()</code> and their offset from the start of the function.</li>
</ol>

<p>Why not do both?</p>

<p>Let’s look at the objdump method first. The disassembly of <code>foo()</code> up to the <code>addl</code> instruction we’re interested in is:</p>

<figure><pre><code data-lang="text"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre>0000000000400538 &lt;foo&gt;:
  400538:	55                   	push   %rbp
  400539:	48 89 e5             	mov    %rsp,%rbp
  40053c:	48 83 ec 10          	sub    $0x10,%rsp
  400540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400547:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
</pre></td></tr></tbody></table></code></pre></figure>

<p>The function starts at <code>400538</code> and the byte we’re interested in is at <code>40055a (400547 + 3)</code> (remember, these are hex values!) so that means the offset is <code>40055a - 400538 = 12</code>. Because this is a hex value, when we’re calculating offsets we need to either use hex values or convert it to base 10. The latter is easier so let’s say that an offset of <code>0x12 = 18</code> is what we’re looking for.</p>

<p>We can confirm this by writing a short function to print the instructions of a given function. Here’s the modified program from above:</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td><pre><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span>
<span>void</span> <span>foo</span><span>(</span><span>void</span><span>);</span>
<span>void</span> <span>bar</span><span>(</span><span>void</span><span>);</span>
<span>void</span> <span>print_function_instructions</span><span>(</span><span>void</span> <span>*</span><span>func_ptr</span><span>,</span> <span>size_t</span> <span>func_len</span><span>);</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>void</span> <span>*</span><span>foo_addr</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>foo</span><span>;</span>
    <span>void</span> <span>*</span><span>bar_addr</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>bar</span><span>;</span>

    <span>print_function_instructions</span><span>(</span><span>foo_addr</span><span>,</span> <span>bar_addr</span> <span>-</span> <span>foo_addr</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span>
    <span>i</span><span>++</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;i: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>);</span>
<span>}</span>

<span>void</span> <span>bar</span><span>(</span><span>void</span><span>)</span> <span>{}</span>

<span>void</span> <span>print_function_instructions</span><span>(</span><span>void</span> <span>*</span><span>func_ptr</span><span>,</span> <span>size_t</span> <span>func_len</span><span>)</span> <span>{</span>
    <span>for</span><span>(</span><span>unsigned</span> <span>char</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span><span>&lt;</span><span>func_len</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>unsigned</span> <span>char</span> <span>*</span><span>instruction</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>*</span><span>)</span><span>func_ptr</span><span>+</span><span>i</span><span>;</span>
        <span>printf</span><span>(</span><span>&#34;%p (%2u): %x</span><span>\n</span><span>&#34;</span><span>,</span> <span>func_ptr</span><span>+</span><span>i</span><span>,</span> <span>i</span><span>,</span> <span>*</span><span>instruction</span><span>);</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that to determine the length of <code>foo()</code>, we added an empty function, <code>bar()</code>, that immediately follows <code>foo()</code>. By subtracting the address of <code>bar()</code> from <code>foo()</code> we can determine the length in bytes of <code>foo()</code>. This, of course, assumes that <code>bar()</code> immediately follows <code>foo()</code>.</p>

<p>The output of running this:</p>

<figure><pre><code data-lang="text"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td><pre>$  ./foo
0x40056c ( 0): 55
0x40056d ( 1): 48
0x40056e ( 2): 89
0x40056f ( 3): e5
0x400570 ( 4): 48
0x400571 ( 5): 83
0x400572 ( 6): ec
0x400573 ( 7): 10
0x400574 ( 8): c7
0x400575 ( 9): 45
0x400576 (10): fc
0x400577 (11): 0
0x400578 (12): 0
0x400579 (13): 0
0x40057a (14): 0
0x40057b (15): 83
0x40057c (16): 45
0x40057d (17): fc
0x40057e (18): 1           &lt;-- Here&#39;s the byte we want!
0x40057f (19): 8b
0x400580 (20): 45
0x400581 (21): fc
0x400582 (22): 89
0x400583 (23): c6
0x400584 (24): bf
0x400585 (25): b4
0x400586 (26): 6
0x400587 (27): 40
0x400588 (28): 0
0x400589 (29): b8
0x40058a (30): 0
0x40058b (31): 0
0x40058c (32): 0
0x40058d (33): 0
0x40058e (34): e8
0x40058f (35): 7d
0x400590 (36): fe
0x400591 (37): ff
0x400592 (38): ff
0x400593 (39): c9
0x400594 (40): c3
</pre></td></tr></tbody></table></code></pre></figure>

<p>At address <code>0x40057e</code> is our <code>0x1</code> byte. As you can see, the offset is indeed 18.</p>

<p>We’re finally read to change some code! Given a pointer to <code>foo()</code>, we can create an unsigned char pointer to the exact byte we want to change as such:</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>unsigned</span> <span>char</span> <span>*</span><span>instruction</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>*</span><span>)</span><span>foo_addr</span> <span>+</span> <span>18</span><span>;</span>

<span>*</span><span>instruction</span> <span>=</span> <span>0x2A</span><span>;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Assuming we did everything right, this will change the immediate value in the <code>addl</code> instruction to <code>0x2A</code> or 42. Now when we call <code>foo()</code>, it will print 42 instead of 1.</p>

<p>And putting it all together:</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td><pre><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;unistd.h&gt;</span><span>
#include</span> <span>&lt;errno.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
#include</span> <span>&lt;sys/mman.h&gt;</span><span>
</span>
<span>void</span> <span>foo</span><span>(</span><span>void</span><span>);</span>
<span>int</span> <span>change_page_permissions_of_address</span><span>(</span><span>void</span> <span>*</span><span>addr</span><span>);</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>void</span> <span>*</span><span>foo_addr</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>foo</span><span>;</span>

    <span>// Change the permissions of the page that contains foo() to read, write, and execute</span>
    <span>// This assumes that foo() is fully contained by a single page</span>
    <span>if</span><span>(</span><span>change_page_permissions_of_address</span><span>(</span><span>foo_addr</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Error while changing page permissions of foo(): %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>strerror</span><span>(</span><span>errno</span><span>));</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>// Call the unmodified foo()</span>
    <span>puts</span><span>(</span><span>&#34;Calling foo...&#34;</span><span>);</span>
    <span>foo</span><span>();</span>

    <span>// Change the immediate value in the addl instruction in foo() to 42</span>
    <span>unsigned</span> <span>char</span> <span>*</span><span>instruction</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>*</span><span>)</span><span>foo_addr</span> <span>+</span> <span>18</span><span>;</span>
    <span>*</span><span>instruction</span> <span>=</span> <span>0x2A</span><span>;</span>

    <span>// Call the modified foo()</span>
    <span>puts</span><span>(</span><span>&#34;Calling foo...&#34;</span><span>);</span>
    <span>foo</span><span>();</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span>
    <span>i</span><span>++</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;i: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>);</span>
<span>}</span>

<span>int</span> <span>change_page_permissions_of_address</span><span>(</span><span>void</span> <span>*</span><span>addr</span><span>)</span> <span>{</span>
    <span>// Move the pointer to the page boundary</span>
    <span>int</span> <span>page_size</span> <span>=</span> <span>getpagesize</span><span>();</span>
    <span>addr</span> <span>-=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>addr</span> <span>%</span> <span>page_size</span><span>;</span>

    <span>if</span><span>(</span><span>mprotect</span><span>(</span><span>addr</span><span>,</span> <span>page_size</span><span>,</span> <span>PROT_READ</span> <span>|</span> <span>PROT_WRITE</span> <span>|</span> <span>PROT_EXEC</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Compile it with:</p>

<figure><pre><code data-lang="bash"><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>$ </span>gcc <span>-std</span><span>=</span>c99 <span>-D_BSD_SOURCE</span> <span>-o</span> foo foo.c
</pre></td></tr></tbody></table></code></pre></figure>

<p>Running it gives the output:</p>

<figure><pre><code data-lang="bash"><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>$ </span>./foo
Calling foo...
i: 1
Calling foo...
i: 42
</pre></td></tr></tbody></table></code></pre></figure>

<p>Success! The first time we call <code>foo()</code> it prints 1 just as its source code says it should. Then after we modify it it prints 42.</p>

<hr/>

<p>And there you have it, a self-mutating C program. However, this is pretty boring; all it does is change a number. Wouldn’t it be more far more interesting if we could change <code>foo()</code> to do something else entirely? How about <code>exec()</code> a shell?</p>

<p>How would we go about starting a shell when we call <code>foo()</code> though? The natural choice is to use the <code>execve</code> syscall, but that’s a lot more involved than just changing a single byte.</p>

<p>If we’re going to change <code>foo()</code> to exec a shell, we’re going to need the instructions for doing as such. Fortunately for us, the security community loves using machine code for exec’ing shells so this is easy to get our hands on. A quick search for “x86_64 shellcode” and we have the instructions for exec’ing a shell. These are as follows:</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>char</span> <span>shellcode</span><span>[]</span> <span>=</span>
    <span>&#34;</span><span>\x48\x31\xd2</span><span>&#34;</span>                              <span>// xor    %rdx, %rdx</span>
    <span>&#34;</span><span>\x48\x31\xc0</span><span>&#34;</span>                              <span>// xor    %rax, %rax</span>
    <span>&#34;</span><span>\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00</span><span>&#34;</span>  <span>// mov    $0x68732f6e69622f, %rbx</span>
    <span>&#34;</span><span>\x53</span><span>&#34;</span>                                      <span>// push   %rbx</span>
    <span>&#34;</span><span>\x48\x89\xe7</span><span>&#34;</span>                              <span>// mov    %rsp, %rdi</span>
    <span>&#34;</span><span>\x50</span><span>&#34;</span>                                      <span>// push   %rax</span>
    <span>&#34;</span><span>\x57</span><span>&#34;</span>                                      <span>// push   %rdi</span>
    <span>&#34;</span><span>\x48\x89\xe6</span><span>&#34;</span>                              <span>// mov    %rsp, %rsi</span>
    <span>&#34;</span><span>\xb0\x3b</span><span>&#34;</span>                                  <span>// mov    $0x3b, %al</span>
    <span>&#34;</span><span>\x0f\x05</span><span>&#34;</span><span>;</span>                                 <span>// syscall</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This code was taken from <a href="http://www.exploit-db.com/exploits/13691/">http://www.exploit-db.com/exploits/13691/</a> with two modifications by me as outlined below.</p>

<ul>
  <li>I added <code>xor %rax, %rax</code> so that the <code>%rax</code> register is zero’d. Otherwise, it may not be and this would cause a segfault.</li>
  <li>I changed the immediate value <code>$0x68732f6e69622f2f</code> to <code>$0x68732f6e69622f00</code>. This allowed me to remove a shift instruction which kept the total length at 30 bytes. Normally, shellcode like this is injected via buffer overflows or other kinds of malicious attacks that exploit flaws in a program’s string handling. C-strings are terminated with the NUL character which has a value of 0. Thus, most of the string.h functions will return when they read a NUL byte. Security people like to avoid NUL’s for this reason. In this case, NUL characters are perfectly fine so we can just replace the extra <code>0x2f</code> with an <code>0x00</code> and drop the shift command. See the original code in the link above for how my modifications differ.</li>
</ul>

<p>Before going further, let’s explain what the shellcode above is doing. First we need to understand how a syscall works. A syscall, or system call, is a function call to the kernel asking that the kernel do something for us. This may be something that only the kernel has the permissions to do so we have to ask it to do it for us. In this case, the execve syscall tells the kernel that we would like it to start another process and replace our process address space with this new process’s address space. This means that, assuming execve succeeds, our process is essentially done executing.</p>

<p>In order to make a syscall on x86_64, we have to prepare for the syscall by moving the correct values to the correct registers and then issuing with <code>syscall</code> instruction. These correct values and registers are unique to each OS. I’m focusing on Linux here so let’s look at the documentation for the <code>execve</code> syscall:</p>

<table>
  <thead>
    <tr>
      <th><code>%rax</code></th>
      <th>Syscall</th>
      <th><code>%rdi</code></th>
      <th><code>%rsi</code></th>
      <th><code>%rdx</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>59</code></td>
      <td><code>sys_execve</code></td>  
      <td><code>const char *filename</code></td>  
      <td><code>const char *const argv[]</code></td>  
      <td><code>const char *const envp[]</code></td>  
    </tr>
  </tbody>
</table>

<p>It’s important to note that <strong>the values of these registers should be pointers to the memory location of their respective values</strong>. This means that we’ll have to push all the values to the stack and then copy the correct stack locations to the registers above. And you thought you would never say “wow, I miss the simplicity of pointers in C.”</p>

<p>A full list of syscalls can be found at <a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64</a>.</p>

<p>If you’re familiar with the C prototype for the <code>execve()</code> function (below for reference), you’ll see that how similar the syscall setup is to calling the function from a C program.</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>int</span> <span>execve</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>,</span> <span>char</span> <span>*</span><span>const</span> <span>argv</span><span>[],</span> <span>char</span> <span>*</span><span>const</span> <span>envp</span><span>[]);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>For those familiar with x86, it’s important to note that the syscall procedure is quite different between x86 and x86_64. The syscall instruction does not exist in the x86 instruction set. In x86 syscalls are made by triggering an interrupt. Furthermore, in Linux, the syscall number for <code>execve</code> is different between x86 and x86_64. (11 on x86; 59 on x86_64).</p>

<p>Now that we know how to set up a syscall, let’s explain each step of the shellcode.</p>

<table>
  <thead>
    <tr>
      <th>Machine code</th>
      <th>Instruction</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>\x48\x31\xd2</code></td>
      <td><code>xor %rdx, %rdx</code></td>
      <td>Zero the <code>%rdx</code> register</td>
    </tr>
    <tr>
      <td><code>\x48\x31\xc0</code></td>
      <td><code>xor %rax, %rax</code></td>
      <td>Zero the <code>%rax</code> register. We use this for <code>NULL</code> values later so it must zero&#39;d.</td>
    </tr>
    <tr>
      <td><code>\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00</code></td>
      <td><code>mov $0x68732f6e69622f, %rbx</code></td>
      <td>Set the value of the <code>%rbx</code> register to <code>hs/nib/</code>. Intel processors are little endian so the string must be backwards. A quick way to do this with Python is <code>&#39;/bin/sh&#39;[::-1].encode(&#39;hex&#39;)</code>. It is convenient that &#34;/bin/sh&#34; is 64bits so it fits within a single register. Anything longer would require some trickery to concatenate longer strings together.</td>
    </tr>
    <tr>
      <td><code>\x53</code></td>
      <td><code>push %rbx</code></td>
      <td>Push the /bin/sh string (currently in register <code>%rbx</code>) to the stack. The push instruction will adjust the stack pointer for us.</td>
    </tr>
    <tr>
      <td><code>\x48\x89\xe7</code></td>
      <td><code>mov %rsp, %rdi</code></td>
      <td>As per the syscall documentation, the <code>%rdi</code> register should point to the memory location of the program to execute. The stack pointer (register <code>%rsp</code>) is currently pointing at this string so copy the stack pointer to <code>%rdi</code>.</td>
    </tr>
    <tr>
      <td><code>\x50</code></td>
      <td><code>push %rax</code></td>
      <td>The second argument to the <code>execve()</code> function is the argv array. This array should be NULL terminated. Intel processors are little endian so we have to push a NULL value to denote the end of the array onto the stack first. Remember that we zero&#39;d <code>%rax</code> earlier so we only have to push this register to the stack to get our <code>NULL</code> value.</td>
    </tr>
    <tr>
      <td><code>\x57</code></td>
      <td><code>push %rdi</code></td>
      <td>By convention, the first argument in the argv array is the name of the program. Remember that the argv array is really a pointer to an array of pointers to strings. In this case, the only value in the array is the name of the program. Also remember that the <code>%rdi</code> register now contains the memory location of the /bin/sh string on the stack. If we push this address to the stack, we now have an array of pointers to the strings that make up the argv array.</td>
    </tr>
    <tr>
      <td><code>\x48\x89\xe6</code></td>
      <td><code>mov %rsp, %rsi</code></td>
      <td>As per the syscall documentation, the <code>%rsi</code> register should point to the memory location of the argv array. Since we just pushed the argv array to the stack, the stack pointer is pointing to the first element of argv. All we have to do is copy the stack pointer to the <code>%rsi</code> register.</td>
    </tr>
    <tr>
      <td><code>\xb0\x3b</code></td>
      <td><code>mov $0x3b, %al</code></td>
      <td>The last step is to put the syscall number (<code>59 = 0x3b</code>) into register <code>%rax</code>. Here, <code>%al</code> refers to the first byte of the <code>%rax</code> register. This puts 59 in the first byte of the <code>%rax</code> register. All other bits in <code>%rax</code> are still zero&#39;d from before.</td>
    </tr>
    <tr>
      <td><code>\x0f\x05</code></td>
      <td><code>syscall</code></td>
      <td>Once we&#39;re ready to go, issue the syscall instruction and the kernel will take it from here. Cross your fingers!</td>
    </tr>
  </tbody>
</table>

<hr/>

<p>Now we’re ready to change <code>foo()</code> to execute this shellcode. Instead of changing a single byte in <code>foo()</code> like before, we now want to replace <code>foo()</code> entirely. This looks like a job for <code>memcpy()</code>. Given a pointer to the start of <code>foo()</code> and a pointer to our shellcode, we can copy the shellcode to the location of <code>foo()</code> as such:</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre>    <span>void</span> <span>*</span><span>foo_addr</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>foo</span><span>;</span>

    <span>// http://www.exploit-db.com/exploits/13691/</span>
    <span>char</span> <span>shellcode</span><span>[]</span> <span>=</span>
        <span>&#34;</span><span>\x48\x31\xd2</span><span>&#34;</span>                              <span>// xor    %rdx, %rdx</span>
        <span>&#34;</span><span>\x48\x31\xc0</span><span>&#34;</span>                              <span>// xor    %rax, %rax</span>
        <span>&#34;</span><span>\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00</span><span>&#34;</span>  <span>// mov    $0x68732f6e69622f2f, %rbx</span>
        <span>&#34;</span><span>\x53</span><span>&#34;</span>                                      <span>// push   %rbx</span>
        <span>&#34;</span><span>\x48\x89\xe7</span><span>&#34;</span>                              <span>// mov    %rsp, %rdi</span>
        <span>&#34;</span><span>\x50</span><span>&#34;</span>                                      <span>// push   %rax</span>
        <span>&#34;</span><span>\x57</span><span>&#34;</span>                                      <span>// push   %rdi</span>
        <span>&#34;</span><span>\x48\x89\xe6</span><span>&#34;</span>                              <span>// mov    %rsp, %rsi</span>
        <span>&#34;</span><span>\xb0\x3b</span><span>&#34;</span>                                  <span>// mov    $0x3b, %al</span>
        <span>&#34;</span><span>\x0f\x05</span><span>&#34;</span><span>;</span>                                 <span>// syscall</span>

    <span>// Careful with the length of the shellcode here depending on what is after foo</span>
    <span>memcpy</span><span>(</span><span>foo_addr</span><span>,</span> <span>shellcode</span><span>,</span> <span>sizeof</span><span>(</span><span>shellcode</span><span>)</span><span>-</span><span>1</span><span>);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The only thing we have to be careful of writing past the end of <code>foo()</code>. In this case, we’re safe because <code>foo()</code> is 41 bytes long and the shellcode is 29 bytes. Note that because the shellcode is a C string, it has a NUL character at the end. We only want to copy the actual shellcode bytes so we subtract 1 from the <code>sizeof</code> shellcode in the length argument of <code>memcpy</code>.</p>

<p>Awesome! Let’s put it all together into a final program now.</p>

<figure><pre><code data-lang="c"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td><pre><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;unistd.h&gt;</span><span>
#include</span> <span>&lt;errno.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
#include</span> <span>&lt;sys/mman.h&gt;</span><span>
</span>
<span>void</span> <span>foo</span><span>(</span><span>void</span><span>);</span>
<span>int</span> <span>change_page_permissions_of_address</span><span>(</span><span>void</span> <span>*</span><span>addr</span><span>);</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>void</span> <span>*</span><span>foo_addr</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>foo</span><span>;</span>

    <span>// Change the permissions of the page that contains foo() to read, write, and execute</span>
    <span>// This assumes that foo() is fully contained by a single page</span>
    <span>if</span><span>(</span><span>change_page_permissions_of_address</span><span>(</span><span>foo_addr</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Error while changing page permissions of foo(): %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>strerror</span><span>(</span><span>errno</span><span>));</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>puts</span><span>(</span><span>&#34;Calling foo&#34;</span><span>);</span>
    <span>foo</span><span>();</span>

    <span>// http://www.exploit-db.com/exploits/13691/</span>
    <span>char</span> <span>shellcode</span><span>[]</span> <span>=</span>
        <span>&#34;</span><span>\x48\x31\xd2</span><span>&#34;</span>                              <span>// xor    %rdx, %rdx</span>
        <span>&#34;</span><span>\x48\x31\xc0</span><span>&#34;</span>                              <span>// xor    %rax, %rax</span>
        <span>&#34;</span><span>\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00</span><span>&#34;</span>  <span>// mov    $0x68732f6e69622f2f, %rbx</span>
        <span>&#34;</span><span>\x53</span><span>&#34;</span>                                      <span>// push   %rbx</span>
        <span>&#34;</span><span>\x48\x89\xe7</span><span>&#34;</span>                              <span>// mov    %rsp, %rdi</span>
        <span>&#34;</span><span>\x50</span><span>&#34;</span>                                      <span>// push   %rax</span>
        <span>&#34;</span><span>\x57</span><span>&#34;</span>                                      <span>// push   %rdi</span>
        <span>&#34;</span><span>\x48\x89\xe6</span><span>&#34;</span>                              <span>// mov    %rsp, %rsi</span>
        <span>&#34;</span><span>\xb0\x3b</span><span>&#34;</span>                                  <span>// mov    $0x3b, %al</span>
        <span>&#34;</span><span>\x0f\x05</span><span>&#34;</span><span>;</span>                                 <span>// syscall</span>

    <span>// Careful with the length of the shellcode here depending on what is after foo</span>
    <span>memcpy</span><span>(</span><span>foo_addr</span><span>,</span> <span>shellcode</span><span>,</span> <span>sizeof</span><span>(</span><span>shellcode</span><span>)</span><span>-</span><span>1</span><span>);</span>

    <span>puts</span><span>(</span><span>&#34;Calling foo&#34;</span><span>);</span>
    <span>foo</span><span>();</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span>
    <span>i</span><span>++</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;i: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>);</span>
<span>}</span>

<span>int</span> <span>change_page_permissions_of_address</span><span>(</span><span>void</span> <span>*</span><span>addr</span><span>)</span> <span>{</span>
    <span>// Move the pointer to the page boundary</span>
    <span>int</span> <span>page_size</span> <span>=</span> <span>getpagesize</span><span>();</span>
    <span>addr</span> <span>-=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>addr</span> <span>%</span> <span>page_size</span><span>;</span>

    <span>if</span><span>(</span><span>mprotect</span><span>(</span><span>addr</span><span>,</span> <span>page_size</span><span>,</span> <span>PROT_READ</span> <span>|</span> <span>PROT_WRITE</span> <span>|</span> <span>PROT_EXEC</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Compile it with:</p>

<figure><pre><code data-lang="bash"><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>$ </span>gcc <span>-o</span> mutate mutate.c
</pre></td></tr></tbody></table></code></pre></figure>

<p>Time to rub your lucky rabbit foot and execute this thing:</p>

<figure><pre><code data-lang="bash"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>$ </span>./mutate
Calling foo
i: 1
Calling foo
<span>$ </span><span>echo</span> <span>&#34;it works! we exec&#39;d a shell!&#34;</span>
it works! we <span>exec</span><span>&#39;d a shell!</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And there you have it, a self-mutating C program.</p>

  </article>
</div></div>
  </body>
</html>
