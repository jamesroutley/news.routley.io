<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dataswamp.org/~solene/2023-07-12-intro-to-immutable-os.html">Original</a>
    <h1>Introduction to Immutable Linux Systems</h1>
    
    <div id="readability-page-1" class="page"><div>
<article id="20230712">
  <header>
  
    
    <p>Written by <em>Solène</em>, on 12 July 2023.</p>
    
    
  </header>
  
<p>If you reach this page, you may be interested into this new category of Linux distributions labeled &#34;immutable&#34;.
</p>
<p>In this category, one can find by age (oldest → youngest) NixOS, Guix, Endless OS, Fedora Silverblue, OpenSUSE MicroOS, Vanilla OS and many new to come.
</p>
<p>I will give examples of immutability implementation, then detail my thoughts about immutability, and why I think this naming can be misleading.  I spent a few months running all of those distributions on my main computers (NAS, Gaming, laptop, workstation) to be able to write this text.
</p>

<p>The word immutability itself refers to an object that can&#39;t change.
</p>
<p>However, when it comes to an immutable operating system, the definition immediately become vague.  What would be an operating system that can&#39;t change?  What would you be supposed to do with it?
</p>
<p>We could say that a Linux LIVE-CD is immutable, because every time you boot it, you get the exact same programs running, and you can&#39;t change anything as the disk media is read only.  But while the LIVE-CD is running, you can make changes to it, you can create files and directories, install packages, it&#39;s not stuck in an immutable state.
</p>
<p>Unfortunately, this example was nice but the immutability approach by those Linux distribution is totally different, so we need to think a bit further.
</p>
<p>There are three common principles in these systems:
</p>
<ul>

  <li>system upgrades aren&#39;t done on the live system</li>
  <li>packages changes are applied on the next boot</li>
  <li>you can roll back a change</li>
</ul>

<p>Depending on the implementation, a system may offer more features.  But this list is what a Linux distribution should have to be labelled &#34;immutable&#34; at the moment.
</p>

<p>Now we found what are the minimum requirements to be called immutable, let&#39;s go through each implementation, by their order of appearance.
</p>
<h2 id="_NixOS_/_Guix">3.1. NixOS / Guix <a href="#_NixOS_/_Guix">§</a></h2>
<p>In this section, I&#39;m mixing NixOS and Guix as they both rely on the same implementation.  NixOS is based on Nix (first appearance in 2003), which has been forked into early 2010s into the Guix package manager to be 100% libre, which gave birth to an eponym operating system also 100% free.
</p>
<p><a href="https://nixos.org/">NixOS official project website</a></p>
<p><a href="https://guix.gnu.org/">Guix official project website</a></p>
<p><a href="https://jonathanlorimer.dev/posts/nix-thesis.html">Jonathan Lorimer&#39;s blog post explaining Eelco Dolstra&#39;s thesis about Nix</a></p>
<p>These two systems are really different than a traditional Unix like system we are used to, and immutability is a main principle.  To make it quick, they are based on their package manager (being Nix or Guix) that contains every package or built file into a special read-only directory (where only the package manager can write) where each package has its own unique entry, and the operating system itself is a byproduct of the package manager.
</p>
<p>What does that imply?  If the operating system is built, this is because it&#39;s made of source code, you literally describe what you want your system to be in a declarative way.  You have to list users, their shells, installed packages, running services and their configurations, partitions to mount with which options etc... Fortunately, it&#39;s made a lot easier by the use of modules which provide sane defaults, so if you create a user, you don&#39;t have to specify its UID, GID, shell, home etc...
</p>
<p>So, as the system is built and stored in the special read-only directory, all your system is derived from that (using symbolic links), so all the files handled by the package manager are read-only.  A concrete example is that /etc/fstab or /bin/sh ARE read-only, if you want to make a change in those, you have to do it through the package manager.
</p>
<p>I&#39;m not going into details, because this store based package manager is really different than everything else but:
</p>
<ul>

  <li>you can switch between two configurations on the fly as it&#39;s just a symlink dance to go from a configuration to another</li>
  <li>you can select your configuration at boot time, so you can roll back to a previous version if something is wrong</li>
  <li>you can&#39;t make change to a package file or system file as they are read only</li>
  <li>the mount points except the special store directory are all mutable, so you can write changes in /home or /etc or /var etc... You can remove the system symlinks by a modified version, but you can&#39;t modify the symlink source itself.</li>
</ul>

<p>This is the immutability as seen through the Nix lens.
</p>
<p>I&#39;ve spent a few years running NixOS systems, this is really a blast for me, and the best &#34;immutable&#34; implementation around, but unfortunately it&#39;s too different, so its adoption rate is very low, despite all the benefits.
</p>
<p><a href="https://discourse.nixos.org/t/my-issues-when-pushing-nixos-to-companies/28629/1">NixOS forum: My issues when pushing NixOS to companies</a></p>
<h2 id="_Endless_OS">3.2. Endless OS <a href="#_Endless_OS">§</a></h2>
<p>While this one is not the oldest immutable OS around, it&#39;s the first one to be released for the average user, while NixOS and Guix are older but for a niche user category.  The company behind Endless OS is trying to offer a solid and reliable system, free and open source, that can works without Internet, to be used in countries with a low Internet / powergrid coverage.  They even provide a version with &#34;offline internet included&#34; containing Wikipedia dumps, class lessons and many things to make a computer useful while offline (I love their work).
</p>
<p><a href="https://www.endlessos.org/">Endless OS official project website</a></p>
<p>Endless OS is based on Debian, but uses the OSTree tool to make it immutable.  OSTree allows you to manage a core system image, and add layers on top of it, think of packages as layers.  But it can also prepare a new system image for the next boot.
</p>
<p>With OSTree, you can apply package changes in a new version of the system that will be available at next boot, and revert to a previous version at boot time.
</p>
<p>The partitions are mounted writable, except for <code>/usr</code>, the land of packages handled by OSTree, which is mounted read-only.  There are no rollbacks possible for <code>/etc</code>.
</p>
<p>Programs meant to be for the user (not the packages to be used by the system like grub, X display or drivers) are installed from Flatpak (which also uses OSTree, but unrelated to the system), this avoids the need to reboot each time you install a new package.
</p>
<p>My experience with Endless OS is mixed, it is an excellent and solid operating system, it&#39;s working well, never failed, but I&#39;m just not the target audience.  They provide a modified GNOME desktop that looks like a smartphone menu, because this is what most non-tech users are comfortable with (but I hate it).  And installing DevOps tools isn&#39;t practical but not impossible, so I keep Endless OS for my multimedia netbook and I really enjoy it.
</p>
<h2 id="_Fedora_Silverblue">3.3. Fedora Silverblue <a href="#_Fedora_Silverblue">§</a></h2>
<p>This linux distribution is the long descendant of Project Atomic, an old initiative to make Fedora / CentOS/ RHEL immutable.  It&#39;s now part of the Fedora releases along with Fedora Workstation.
</p>
<p><a href="https://projectatomic.io/">Project Atomic website</a></p>
<p><a href="https://fedoraproject.org/silverblue/">Fedora Silverblue project website</a></p>
<p>Fedora Silverblue is also using OSTree, but with a twist.  It&#39;s using rpm-OSTree, a tool built on top of OSTree to let your RPM packages apply the changes through OSTree.
</p>
<p>The system consists of a single core image for the release, let&#39;s say fedora-38, and for each package installed, a new layer is added on top of the core.  At anytime, you can list all the layers to know what packages have been installed on top of the core, if you remove a package, the whole stack is generated again (which is terribly SLOW) without the package, there is absolutely no leftover after a package removal.
</p>
<p>On boot, you can choose an older version of the system, in case something broke after an upgrade.  If you install a package, you need to reboot to have it available as the change isn&#39;t applied on the current booted system, however rpm-OSTree received a nice upgrade, you can temporarily merge the changes of the next boot into the live system (using a tmpfs overlay) to use the changes.
</p>
<p>The mountpount management is a bit different, everything is read-only except <code>/etc/</code>, <code>/root</code> and <code>/var</code>, but your home directory is by default in <code>/var/home</code> which sometimes breaks expectations.  There are no rollbacks possible for <code>/etc</code>.
</p>
<p>As installing a new package is slow due to rpm-OSTree and requires a reboot to be fully usable (the live change back port store the extra changes in memory), they recommend to use Flatpak for programs, or <code>toolbox</code>, some kind of wrapper that create a rootless fedora container where you can install packages and use it in your terminal.  toolbox is meant to provide development libraries or tool you wouldn&#39;t have in Flatpak, but that you wouldn&#39;t want to install in your base Fedora system.
</p>
<p><a href="https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox/">toolbox website</a></p>
<p>My experience with Fedora Silverblue has been quite good, it&#39;s stable, the updates are smooth even if they are slow.  <code>toolbox</code> was working fine despite I don&#39;t find this practical.
</p>
<h2 id="_OpenSUSE_MicroOS">3.4. OpenSUSE MicroOS <a href="#_OpenSUSE_MicroOS">§</a></h2>
<p>This spin of OpenSUSE Tumbleweed (rolling-release OpenSUSE) features immutability, but with its own implementation.  The idea of MicroOS is really simple, the whole system except a few directories like <code>/home</code> or <code>/var</code> lives on a btrfs snapshot, if you want to make a change to the system, the current snapshot is forked into a new snapshot, and the changes are applied there, ready for the next boot.
</p>
<p><a href="https://microos.opensuse.org/">OpenSUSE MicroOS official project website</a></p>
<p>What&#39;s interesting here is that <code>/etc</code> IS part of the snapshots, and can be roll backed, which wasn&#39;t possible in the OSTree based systems.  It&#39;s also possible to make changes to any file of the file system (in a new snapshot, not the live one) using a shell, which can be very practical for injecting files to solve a driver issue.  The downside it&#39;s not guaranteed that your system is &#34;pure&#34; if you start making changes, because they won&#39;t be tracked, the snapshots are just numbered, and you don&#39;t know what changes were made in each of them.
</p>
<p>Changes must be done through the command <code>transactional-update</code> which do all the snapshot work for you, and you could either manipulate package by adding/removing a package, or just start a shell in the new snapshot to make all the changes you want.  I said <code>/etc</code> is part of the snapshots, it&#39;s true, but it&#39;s never read-only, so you could make a change live in <code>/etc</code>, then create a new snapshot, the change would be immediately inherited.  This can create troubles if you roll back to a previous state after an upgrade if you also made changes to <code>/etc</code> just before.
</p>
<p>The default approach of MicroOS is disturbing at first, a reboot is planned every day after a system update, this is because it&#39;s a rolling-release system and there are updates every day, and you won&#39;t benefit from them until you reboot.  While you can disable this automatic reboot, it makes sense to use the newest packages anyway, so it&#39;s something to consider if you plan to use MicroOS.
</p>
<p>There is currently no way to apply the changes into the live system (like Silverblue is offering), it&#39;s still experimental, but I&#39;m confident this will be doable soon.  As such, it&#39;s recommended to use <code>distrobox</code> to use rootless containers of various distributions to install your favorite tools for your users, instead of using the base system packages.  I don&#39;t really like this because this adds maintenance, and I often had issues of distrobox refusing to start a container after a reboot, I had to destroy and recreate it entirely to solve.
</p>
<p><a href="https://github.com/89luca89/distrobox">distrobox GitHub project page</a></p>
<p>My experience with OpenSUSE MicroOS has been wonderful, it&#39;s in dual-boot with OpenBSD on my main laptop, it&#39;s my Linux Gaming OS, and it&#39;s also my NAS operating system, so I don&#39;t have to care about updates.  I like that the snapshots system doesn&#39;t restrict me, while OSTree systems just doesn&#39;t allow you to make changes without installing a package.
</p>
<h2 id="_Vanilla_OS">3.5. Vanilla OS <a href="#_Vanilla_OS">§</a></h2>
<p>Finally, the really new (but mature enough to be usable) system in the immutable family is Vanilla OS based on Ubuntu (but soon on Debian), using ABroot for immutability.  With Vanilla OS, we have another implementation that really differs from what we saw above.
</p>
<p><a href="https://vanillaos.org/">Vanilla OS project website</a></p>
<p>ABroot named is well thought, the idea is to have a root partition A, another root partition B, and a partition for persistent data like <code>/home</code> or <code>/var</code>.
</p>
<p>Here is the boot dance done by ABroot:
</p>
<ul>

  <li>first boot is done on A, it&#39;s mounted in read-only</li>
  <li>changes to the system like new packages or file changes in <code>/etc</code> are done on B (and can be applied live using a tmpfs overlay)</li>
  <li>upon reboot, if previous boot was A, you boot on B, then if the boot is successful, ABroot scan for all the changes between A and B, and apply all the changes from B to A</li>
  <li>when you are using your system, until you make a change, A and B are always identical</li>
</ul>

<p>This implementation has downsides, you can only roll back a change until you boot on the new version, then the changes are also applied on the previous boot, and you can&#39;t roll back.  This implementation mostly protects you from a failing upgrade, or if you made changes and tried them live, but you prefer to rollback.
</p>
<p>Vanilla OS features the package manager apx, written by distrobox author.  That&#39;s for sure an interesting piece of software, allowing your non-root user to install packages from many distributions (arch linux, fedora, ubuntu, nix, etc...) and integrates them into the system as if they were installed locally.  I suppose it&#39;s some kind of layer on top of distrobox.
</p>
<p><a href="https://github.com/Vanilla-OS/apx">apx package manager GitHub project page</a></p>
<p>My experience wasn&#39;t very good, I didn&#39;t find ABroot to be really useful, and the version 22.10 I tried was using an old Ubuntu LTS release which didn&#39;t make my gaming computer really happy.  The overall state of Vanilla OS, ABroot and apx is that they are young, I think it can become a great distribution, but it still has some rough edges.
</p>
<h2 id="_Alpine_Linux_(with_LBU)">3.6. Alpine Linux (with LBU) <a href="#_Alpine_Linux_(with_LBU)">§</a></h2>
<p>I&#39;ve been told that it was possible to achieve immutability on Alpine Linux using the &#34;lbu&#34; command.
</p>
<p><a href="https://wiki.alpinelinux.org/wiki/Alpine_local_backup">Alpine Linux wiki: Local backup</a></p>
<p>I don&#39;t want to go much into details, but here is the short version: you can use Alpine Linux installer as a base system to boot from, and create tarballs of &#34;saved configurations&#34; that are automatically applied upon boot (it&#39;s just tarred directories and some automation to install packages).  At every boot, everything is untarred again, and packages are installed again (you should use an apk cache directory), everything in live memory, fully writable.
</p>
<p>What does this achieve?  You always start from a clean state, changes are applied on top of it at every boot, you can roll back the changes and start fresh again.  Immutability as we defined above here isn&#39;t achieved because changes are applied on the base system, but it&#39;s quite close to fulfill (my own) requirements.
</p>
<p>I&#39;ve been using it a few days only, not as my main system, and it requires a very good understanding of what you are doing because the system is fully in memory, and you need to take care about what you want to save/restore, which can create big archives.
</p>
<p>On top of that, it&#39;s poorly documented.
</p>

<p>Now I gave some details about all the major immutable systems (Linux based) around, I think it&#39;s time to list the real pros and cons I found from my experimentation.
</p>
<h2 id="_Pros">4.1. Pros <a href="#_Pros">§</a></h2>
<ul>

  <li>you can roll back changes if something went wrong.</li>
  <li>transactional-updates allows you to keep the system running correctly during packages changes.</li>
</ul>

<h2 id="_Cons">4.2. Cons <a href="#_Cons">§</a></h2>
<ul>

  <li>configuration management tool (ansible, salt, puppet etc..) integrate VERY badly, they received updates to know how to apply package changes, but you will mostly hit walls if you want to manage those like regular systems.</li>
  <li>having to reboot after a change is annoying (except for NixOS and Guix which don&#39;t require rebooting for each change).</li>
  <li>OSTree based systems aren&#39;t flexible, my netbook requires some extra files in alsa directories to get sound (fortunately Endless OS have them!), you just can&#39;t add the files without making a package deploying them.</li>
  <li>blind rollbacks, it&#39;s hard to figure what was done in each version of the system, so when you roll back it&#39;s hard to figure what you are doing exactly.</li>
  <li>it can be hard to install programs like Nix/Guix which require a directory at the root of the file system, or install non-packaged software system-wide (this is often bad practice, but sometimes a necessary evil).</li>
</ul>

<h2 id="_Facts">4.3. Facts <a href="#_Facts">§</a></h2>
<ul>

  <li>immutability is a lie, many parts of the systems are mutable, although I don&#39;t know how to describe this family with a different word (transactional something?).</li>
  <li>immutable doesn&#39;t imply stateless.</li>
  <li>NixOS / Guix are doing it right in my opinion, you can track your whole system through a reliable package manager, and you can use a version control system on the sources, it has the right philosophy from the ground up.</li>
  <li>immutability is often associated with security benefits, I don&#39;t understand why.  If someone obtains root access on your system, they can still manipulate the live system and have fun with the <code>/boot</code> partition, nothing prevent them to install a backdoor for the next boot.</li>
  <li>immutability requires discipline and maintenance, because you have to care about the versioning, you have extra programs like apx / distrobox / devbox that must be updated in parallel of the system (while this is all integrated into NixOS/Guix).</li>
</ul>


<p>Immutable operating systems are making the news in our small community of open source systems, but behind this word lies many implementations with different use cases.  The word immutable certainly creates expectations from users, but it&#39;s really nothing more than transactional updates for your operating system, and I&#39;m happy we can have this feature now.
</p>
<p>But transactional updates aren&#39;t new, I think it started a while ago with Solaris and ZFS allowing you to select a system snapshot at boot time, then I&#39;m quite sure FreeBSD implemented this a decade ago, and it turns out that on any linux distribution with regular btrfs snapshots you could select a snapshot at boot time.
</p>
<p><a href="https://dataswamp.org/~solene/2023-01-04-boot-on-btrfs-snapshot.html">Previous blog post about booting on a BTRFS snapshot without any special setup</a></p>
<p>In the end, what&#39;s REALLY new is the ability to apply a transactional change on a non-live environment, integrates this into the bootloader, and give the user the tooling to handle this easily.
</p>

<p>I recommend reading the blog post &#34;“Immutable” → reprovisionable, anti-hysteresis&#34; by Colin Walters.
</p>
<p><a href="https://blog.verbum.org/2020/08/22/immutable-%E2%86%92-reprovisionable-anti-hysteresis/">“Immutable” → reprovisionable, anti-hysteresis</a></p>

</article>
</div></div>
  </body>
</html>
