<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nietras.com/2025/05/09/sep-0-10-0/">Original</a>
    <h1>21 GB/s CSV Parsing Using SIMD on AMD 9950X</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><a href="https://github.com/nietras/Sep/releases/tag/v0.10.0">Sep 0.10.0 was released April 22nd,
2025</a> with optimizations
for <a href="https://en.wikipedia.org/wiki/AVX-512">AVX-512</a> capable CPUs like the AMD
9950X (<a href="https://en.wikipedia.org/wiki/Zen_5">Zen 5</a>) and updated benchmarks
including the 9950X. Sep now achieves a staggering <strong>21 GB/s on the 9950X</strong> for
the low-level CSV parsing. 🚀 Before 0.10.0, Sep achieved ~18 GB/s on 9950X.</p>

<p>See <a href="https://github.com/nietras/Sep/releases/tag/v0.10.0">v0.10.0 release</a> for
all changes for the release, and <a href="https://github.com/nietras/Sep">Sep README on
GitHub</a> for full details.</p>

<p>In this blog post, I will dive into how .NET 9.0 machine code for AVX-512 is
sub-optimal and what changes were made to speed up Sep for AVX-512 by
circumventing this, showing interesting code and assembly along the way, so get
ready for SIMD C# code, x64 SIMD assembly and tons of benchmark numbers.</p>

<p>However, first let’s take a look at the progression of Sep’s performance from
early 0.1.0 to 0.10.0, from .NET 7.0 to .NET 9.0 and from AMD Ryzen 9 5950X (Zen
3) to 9950X (Zen 5), as I have also recently upgraded my work PC.</p>

<h2 id="sep-performance-progression">Sep Performance Progression</h2>

<p><img src="https://nietras.com/images/2025-05-sep-0.10.0/sep-perf-progression-0.1.0-to-0.10.0.png" alt="Sep Perf Progression 0.1.0 To 0.10.0"/></p>

<p>The benchmark numbers above are for the package assets CSV data and the low
level parse <code>Rows</code> only scope, see <a href="https://github.com/nietras/Sep">Sep README on
GitHub</a> or code on GitHub for details on this.
Note that all numbers here are single-threaded and are also shown in the table
below. Note that there can be a few percentage points variation in the numbers,
so for a given release Sep might see minor regressions.</p>

<p>The main take away is that Sep has seen incremental improvements to performance
driven by both major (e.g. almost complete rewrite of <a href="https://nietras.com/2023/08/07/sep-0-2-0/">internals in 0.2.0</a>) and minor code changes. While also
seeing improved performance on new .NET versions. And finally here showing
improvement for going from the AMD 5950X (<a href="https://en.wikipedia.org/wiki/Zen_3">Zen
3</a>) to AMD 9950X (<a href="https://en.wikipedia.org/wiki/Zen_5">Zen
5</a>). Hence, this showcases how software
together with hardware improvements can boost performance to the next level.</p>

<p>We can see Sep progressing:</p>

<ul>
  <li><code>~ 7 GB/s</code> (0.1.0, 5950X and .NET 7.0)</li>
  <li><code>~12 GB/s</code> (0.3.0, 5950X and .NET 8.0)</li>
  <li><code>~13 GB/s</code> (0.6.0, 5950X and .NET 9.0)</li>
  <li><code>~18 GB/s</code> (0.9.0, 9950X and .NET 9.0)</li>
  <li><code>~21 GB/s</code> (0.10.0, 9950X and .NET 9.0)</li>
</ul>

<p>This is a staggering <strong>~3x</strong> improvement in just under 2 years since <a href="https://nietras.com/2023/06/05/introducing-sep">Sep was
introduced June, 2023</a>.</p>

<table>
  <thead>
    <tr>
      <th>Sep</th>
      <th>.NET</th>
      <th>CPU</th>
      <th>Rows</th>
      <th>Mean [ms]</th>
      <th>MB</th>
      <th>MB/s</th>
      <th>Ratio</th>
      <th>ns/row</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.1.0</td>
      <td>7.0</td>
      <td>5950X</td>
      <td>1000000</td>
      <td>79.590</td>
      <td>583</td>
      <td>` 7335.3`</td>
      <td>1.00</td>
      <td>79.6</td>
    </tr>
    <tr>
      <td>0.2.0</td>
      <td>7.0</td>
      <td>5950X</td>
      <td>1000000</td>
      <td>57.280</td>
      <td>583</td>
      <td><code>10191.6</code></td>
      <td>1.39</td>
      <td>57.3</td>
    </tr>
    <tr>
      <td>0.2.1</td>
      <td>7.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.624</td>
      <td>29</td>
      <td><code>11120.2</code></td>
      <td>1.52</td>
      <td>52.5</td>
    </tr>
    <tr>
      <td>0.3.0</td>
      <td>7.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.537</td>
      <td>29</td>
      <td><code>11503.7</code></td>
      <td>1.57</td>
      <td>50.7</td>
    </tr>
    <tr>
      <td>0.3.0</td>
      <td>8.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.409</td>
      <td>29</td>
      <td><code>12111.6</code></td>
      <td>1.65</td>
      <td>48.2</td>
    </tr>
    <tr>
      <td>0.4.0</td>
      <td>8.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.319</td>
      <td>29</td>
      <td><code>12581.3</code></td>
      <td>1.72</td>
      <td>46.4</td>
    </tr>
    <tr>
      <td>0.4.1</td>
      <td>8.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.278</td>
      <td>29</td>
      <td><code>12811.2</code></td>
      <td>1.75</td>
      <td>45.6</td>
    </tr>
    <tr>
      <td>0.5.0</td>
      <td>8.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.326</td>
      <td>29</td>
      <td><code>12544.5</code></td>
      <td>1.71</td>
      <td>46.5</td>
    </tr>
    <tr>
      <td>0.6.0</td>
      <td>9.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.188</td>
      <td>29</td>
      <td><code>13339.9</code></td>
      <td>1.82</td>
      <td>43.8</td>
    </tr>
    <tr>
      <td>0.9.0</td>
      <td>9.0</td>
      <td>5950X</td>
      <td>50000</td>
      <td>2.230</td>
      <td>29</td>
      <td><code>13088.4</code></td>
      <td>1.78</td>
      <td>44.6</td>
    </tr>
    <tr>
      <td>0.9.0</td>
      <td>9.0</td>
      <td>9950X</td>
      <td>50000</td>
      <td>1.603</td>
      <td>29</td>
      <td><code>18202.7</code></td>
      <td>2.48</td>
      <td>32.1</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>9.0</td>
      <td>9950X</td>
      <td>50000</td>
      <td>1.365</td>
      <td>29</td>
      <td><code>21384.9</code></td>
      <td>2.92</td>
      <td>27.3</td>
    </tr>
  </tbody>
</table>

<p>The improvement from <code>5950X w. Sep 0.9.0</code> to <code>9950X w. Sep 0.10.0</code> is <strong>~1.6x</strong>
which is a pretty good improvement from Zen 3 to Zen 5. Note the 9950X has a 5.7
GHz boost frequency vs 4.9 GHz for 5950X, so this alone probably explains 1.2x.</p>

<h2 id="avx-512-code-generation-and-mask-register-issues">AVX-512 Code Generation and Mask Register Issues</h2>

<p>Sep has had support for AVX-512 since <a href="https://nietras.com/2023/09/05/sep-0-2-3/">0.2.3</a> and back then I noted that:</p>

<blockquote>
  <p>different here is the use of the <a href="https://en.wikipedia.org/wiki/AVX-512">mask registers (<code>k1-k8</code>) introduced with
AVX-512</a>. However, .NET 8 does not have
explicit support for these and the code generation is a bit suboptimal, given
mask register are moved to normal registers each time. And then back.</p>
</blockquote>

<p>I did not have direct access to an AVX-512 capable CPU then, so I could not test
the performance of the AVX-512 in detail, but did verify it on the Xeon Silver
4316 which based on some quick tests showed the AVX-512 parser to be the fastest
on that CPU despite the issues with the mask registers.</p>

<h2 id="9950x-upgrade-and-avx-512-vs-avx2-performance">9950X Upgrade and AVX-512 vs AVX2 Performance</h2>

<p>Recently, I then upgraded from an AMD 5950X (Zen 3) CPU to an AMD 9950X (Zen 5)
CPU. Zen 3 does not support AVX-512, but Zen 5 does. One of the first things I
did on the new CPU was of course to run the Sep benchmarks, and this showed,
that Sep hit ~18 GB/s on the 9950X for the low-level parsing of CSV files. This
was great and ~1.4x faster than on the 5950X. A pretty good improvement from Zen
3 to Zen 5.</p>

<p>However, I still wanted to compare AVX-512 to
<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX2</a>. Sep has,
unofficial, support for overriding the default selected parser via an
environment variable. This is also used for testing all possible parsers fully
no matter which parser is selected as best. A bit surprisingly the AVX2 parser
on 9950X hit ~20GB/s! That is, it was better than the AVX-512 based parser by
~10%, which is pretty significant for Sep. Hence, it would seem the mask
register issue was still an issue.</p>

<h2 id="parser-codeassembly-comparison-and-new-avx-512-to-256-parser">Parser Code/Assembly Comparison and New AVX-512-to-256 Parser</h2>

<p>Let’s examine the code and assembly (via
<a href="https://github.com/EgorBo/Disasmo">Disasmo</a>) for the AVX-512-based parser
(0.9.0), a tweaked version (0.10.0), compare it to the AVX2-based parser, and
finally review a new AVX-512-to-256-based parser that circumvents the mask
register issue and is even faster than the AVX2-based parser, achieving ~21 GB/s
as shown above.</p>

<h3 id="parse-methods">Parse Methods</h3>

<p>All parsers in Sep follow the same basic layout as shown below and have a single
generic <code>Parse</code> method to support both parsing for when handling quotes
(<code>ParseColInfos</code>) and when not (<code>ParseColEnds</code>). The former requires keeping
track of more state, and is slightly slower.</p>

<p>In Sep the <code>Parse</code> method is marked with <code>AggressiveInlining</code> to ensure it is
inlined, which means one can in principle go to <code>ParseColEnds</code> in Visual Studio
with Disasmo installed and hit <code>ALT + SHIFT + D</code>. Unfortunately, for some reason
this does not work currently unless you change the parser from a <code>class</code> to
<code>struct</code>. So readers are aware if they want to follow along. See GitHub issue
<a href="https://github.com/EgorBo/Disasmo/issues/68">Empty disassembly for method with inlined generic method (used to
work)</a> for more.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>public</span> <span>void</span> <span>ParseColEnds</span><span>(</span><span>SepReaderState</span> <span>s</span><span>)</span>
<span>{</span>
    <span>Parse</span><span>&lt;</span><span>int</span><span>,</span> <span>SepColEndMethods</span><span>&gt;(</span><span>s</span><span>);</span>
<span>}</span>

<span>public</span> <span>void</span> <span>ParseColInfos</span><span>(</span><span>SepReaderState</span> <span>s</span><span>)</span>
<span>{</span>
    <span>Parse</span><span>&lt;</span><span>SepColInfo</span><span>,</span> <span>SepColInfoMethods</span><span>&gt;(</span><span>s</span><span>);</span>
<span>}</span>

<span>void</span> <span>Parse</span><span>&lt;</span><span>TColInfo</span><span>,</span> <span>TColInfoMethods</span><span>&gt;(</span><span>SepReaderState</span> <span>s</span><span>)</span>
    <span>where</span> <span>TColInfo</span> <span>:</span> <span>unmanaged</span>
    <span>where</span> <span>TColInfoMethods</span> <span>:</span> <span>ISepColInfoMethods</span><span>&lt;</span><span>TColInfo</span><span>&gt;</span>
<span>{</span>
    <span>// Implementation</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To recap, parsing in Sep is done on a span of <code>char</code>s (from an array) e.g. 16K
and outputs a set of column end indices and row column counts for that span.
This ensures parsing is done on a significant yet small enough chunk of data to
fit in the CPU cache, and facilitates efficient multi-threading after too.</p>

<p>Parsing of the span is basically then just a loop where one or two SIMD
registers (e.g. <code>Vector256</code>) are loaded (as unsigned 16-bit integers e.g.
<code>ushort</code>) and converted to <code>byte</code> SIMD register and then compared to the special
characters (e.g. <code>\n</code>, <code>\r</code>, <code>&#34;</code>, <code>;</code>) using SIMD compare instructions. The
compare results are then converted to bit masks and each set bit in that mask is
sequentially parsed after.</p>

<p>The interesting part here is the SIMD code and how it’s JIT’ed to machine code
on .NET and how efficient that is. Below this specific code and assembly is
shown for the parsers mentioned before.</p>

<h3 id="sepparseravx512packcmpormovemasktzcntcs-090"><code>SepParserAvx512PackCmpOrMoveMaskTzcnt.cs</code> (0.9.0)</h3>

<p>A breakdown of the below code snippet:</p>

<ol>
  <li><strong>Data Loading and Packing</strong>:
    <ul>
      <li>Two 16-bit integer vectors (<code>v0</code> and <code>v1</code>) are read from memory using
unaligned reads.</li>
      <li>These vectors are packed into a single byte vector using
<code>PackUnsignedSaturate</code>, ensuring values fit within the byte range.</li>
      <li>For AVX-512 this means loading two 512-bit SIMD registers each with
32 <code>char</code>s and then packing it to single 512-bit SIMD register with 64
bytes. This means 64 <code>char</code>s are handled in each loop.</li>
    </ul>
  </li>
  <li><strong>Reordering Packed Data</strong>:
    <ul>
      <li>The packed data is interleaved, so a permutation operation
(<code>PermuteVar8x64</code>) is applied to reorder the bytes into the correct
sequence.</li>
    </ul>
  </li>
  <li><strong>Character Comparisons</strong>:
    <ul>
      <li>The byte vector is compared against specific characters (e.g. <code>\n</code>, <code>\r</code>,
<code>&#34;</code>, <code>;</code>) using SIMD equality operations. These comparisons identify
special characters relevant to CSV parsing.</li>
    </ul>
  </li>
  <li><strong>Combine Comparison Results</strong>:
    <ul>
      <li>The results of the comparisons are combined using logical operations.</li>
    </ul>
  </li>
  <li><strong>Bitmask Generation and Check</strong>:
    <ul>
      <li>A <code>MoveMask</code> operation extracts a bitmask from the SIMD register, allowing
for a quick check to skip further processing if no special characters are
found.</li>
    </ul>
  </li>
</ol>

<p>All parsers follow the same basic approach, so this description will be omitted
going forward. Note how <code>ISA</code> and <code>Vec</code> are aliases used to make the different
parsers more similar which makes it easier to compare and maintain the different
parsers.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>var</span> <span>v0</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecI16</span><span>&gt;(</span><span>ref</span> <span>byteRef</span><span>);</span>
<span>var</span> <span>v1</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecI16</span><span>&gt;(</span><span>ref</span> <span>Add</span><span>(</span><span>ref</span> <span>byteRef</span><span>,</span> <span>VecUI8</span><span>.</span><span>Count</span><span>));</span>
<span>var</span> <span>packed</span> <span>=</span> <span>ISA</span><span>.</span><span>PackUnsignedSaturate</span><span>(</span><span>v0</span><span>,</span> <span>v1</span><span>);</span>
<span>// Pack interleaves the two vectors need to permute them back</span>
<span>var</span> <span>permuteIndices</span> <span>=</span> <span>Vec</span><span>.</span><span>Create</span><span>(</span><span>0L</span><span>,</span> <span>2L</span><span>,</span> <span>4L</span><span>,</span> <span>6L</span><span>,</span> <span>1L</span><span>,</span> <span>3L</span><span>,</span> <span>5L</span><span>,</span> <span>7L</span><span>);</span>
<span>var</span> <span>bytes</span> <span>=</span> <span>ISA</span><span>.</span><span>PermuteVar8x64</span><span>(</span><span>packed</span><span>.</span><span>AsInt64</span><span>(),</span> <span>permuteIndices</span><span>).</span><span>AsByte</span><span>();</span>

<span>var</span> <span>nlsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>nls</span><span>);</span>
<span>var</span> <span>crsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>crs</span><span>);</span>
<span>var</span> <span>qtsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>qts</span><span>);</span>
<span>var</span> <span>spsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>sps</span><span>);</span>

<span>var</span> <span>lineEndings</span> <span>=</span> <span>nlsEq</span> <span>|</span> <span>crsEq</span><span>;</span>
<span>var</span> <span>lineEndingsSeparators</span> <span>=</span> <span>spsEq</span> <span>|</span> <span>lineEndings</span><span>;</span>
<span>var</span> <span>specialChars</span> <span>=</span> <span>lineEndingsSeparators</span> <span>|</span> <span>qtsEq</span><span>;</span>

<span>// Optimize for the case of no special character</span>
<span>var</span> <span>specialCharMask</span> <span>=</span> <span>MoveMask</span><span>(</span><span>specialChars</span><span>);</span>
<span>if</span> <span>(</span><span>specialCharMask</span> <span>!=</span> <span>0u</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Assembly is shown below for a 64-bit CPU with AVX-512 support e.g. the 9950X.
What is most interesting here is that each compare <code>Vec.Equals</code> ends up being
two instructions <code>vpcmpeqb</code> (<code>c</code>o<code>mp</code>are <code>eq</code>ual <code>b</code>ytes) and <code>vpmovm2b</code>
(<code>mov</code>e <code>m</code>ask to <code>b</code>yte). That is, there is a lot of going from the mask
register, e.g. <code>k1</code>, to a normal 512-bit register, e.g. <code>zmm5</code>, and back again.</p>

<p>Note that the C# code does not deal with vector mask registers directly. This is
not supported in .NET and hence it is the JIT that is responsible for code
generation around this. Unfortunately, here it does not do a good job and the
AVX-512 is not as fast as it could be.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>mov</span>      <span>edi</span><span>,</span> <span>r9d</span>
<span>lea</span>      <span>rdi</span><span>,</span> <span>bword</span> <span>ptr</span> <span>[</span><span>r10</span><span>+</span><span>2</span><span>*</span><span>rdi</span><span>]</span>
<span>vmovups</span>  <span>zmm4</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
<span>vpackuswb</span> <span>zmm4</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>+</span><span>0x40</span><span>]</span>
<span>vmovups</span>  <span>zmm5</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>reloc</span> <span>@</span><span>RWD00</span><span>]</span>
<span>vpermq</span>   <span>zmm4</span><span>,</span> <span>zmm5</span><span>,</span> <span>zmm4</span>
<span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm0</span>
<span>vpmovm2b</span> <span>zmm5</span><span>,</span> <span>k1</span>
<span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm1</span>
<span>vpmovm2b</span> <span>zmm16</span><span>,</span> <span>k1</span>
<span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm2</span>
<span>vpmovm2b</span> <span>zmm17</span><span>,</span> <span>k1</span>
<span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm3</span>
<span>vpmovm2b</span> <span>zmm4</span><span>,</span> <span>k1</span>
<span>vpternlogd</span> <span>zmm5</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm16</span><span>,</span> <span>-</span><span>2</span>
<span>vpord</span>    <span>zmm16</span><span>,</span> <span>zmm5</span><span>,</span> <span>zmm17</span>
<span>vpmovb2m</span> <span>k1</span><span>,</span> <span>zmm16</span>
<span>kmovq</span>    <span>r15</span><span>,</span> <span>k1</span>
<span>test</span>     <span>r15</span><span>,</span> <span>r15</span>
<span>je</span>       <span>G_M000_IG03</span>
<span>vpmovb2m</span> <span>k1</span><span>,</span> <span>zmm4</span>
<span>kmovq</span>    <span>r13</span><span>,</span> <span>k1</span>
<span>lea</span>      <span>r12</span><span>,</span> <span>[</span><span>r15</span><span>+</span><span>r8</span><span>]</span>
<span>cmp</span>      <span>r13</span><span>,</span> <span>r12</span>
<span>je</span>       <span>G_M000_IG43</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="sepparseravx512packcmpormovemasktzcntcs-0100"><code>SepParserAvx512PackCmpOrMoveMaskTzcnt.cs</code> (0.10.0)</h3>

<p>To address the above code generation issues, in Sep 0.10.0 I changed the AVX-512
based parser by moving the <code>MoveMask</code> calls earlier to avoid the whole mask
register back and forth as shown below. For other parsers, <code>MoveMask</code> is only
called when necessary to reduce instructions in the “happy”/skip path.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>var</span> <span>v0</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecI16</span><span>&gt;(</span><span>ref</span> <span>byteRef</span><span>);</span>
<span>var</span> <span>v1</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecI16</span><span>&gt;(</span><span>ref</span> <span>Add</span><span>(</span><span>ref</span> <span>byteRef</span><span>,</span> <span>VecUI8</span><span>.</span><span>Count</span><span>));</span>
<span>var</span> <span>packed</span> <span>=</span> <span>ISA</span><span>.</span><span>PackUnsignedSaturate</span><span>(</span><span>v0</span><span>,</span> <span>v1</span><span>);</span>
<span>// Pack interleaves the two vectors need to permute them back</span>
<span>var</span> <span>permuteIndices</span> <span>=</span> <span>Vec</span><span>.</span><span>Create</span><span>(</span><span>0L</span><span>,</span> <span>2L</span><span>,</span> <span>4L</span><span>,</span> <span>6L</span><span>,</span> <span>1L</span><span>,</span> <span>3L</span><span>,</span> <span>5L</span><span>,</span> <span>7L</span><span>);</span>
<span>var</span> <span>bytes</span> <span>=</span> <span>ISA</span><span>.</span><span>PermuteVar8x64</span><span>(</span><span>packed</span><span>.</span><span>AsInt64</span><span>(),</span> <span>permuteIndices</span><span>).</span><span>AsByte</span><span>();</span>

<span>var</span> <span>nlsEq</span> <span>=</span> <span>MoveMask</span><span>(</span><span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>nls</span><span>));</span>
<span>var</span> <span>crsEq</span> <span>=</span> <span>MoveMask</span><span>(</span><span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>crs</span><span>));</span>
<span>var</span> <span>qtsEq</span> <span>=</span> <span>MoveMask</span><span>(</span><span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>qts</span><span>));</span>
<span>var</span> <span>spsEq</span> <span>=</span> <span>MoveMask</span><span>(</span><span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>sps</span><span>));</span>

<span>var</span> <span>lineEndings</span> <span>=</span> <span>nlsEq</span> <span>|</span> <span>crsEq</span><span>;</span>
<span>var</span> <span>lineEndingsSeparators</span> <span>=</span> <span>spsEq</span> <span>|</span> <span>lineEndings</span><span>;</span>
<span>var</span> <span>specialChars</span> <span>=</span> <span>lineEndingsSeparators</span> <span>|</span> <span>qtsEq</span><span>;</span>

<span>// Optimize for the case of no special character</span>
<span>var</span> <span>specialCharMask</span> <span>=</span> <span>specialChars</span><span>;</span>
<span>if</span> <span>(</span><span>specialCharMask</span> <span>!=</span> <span>0u</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This improves the assembly for the parser quite a bit as can be seen below.
Basically, less instructions. We are still going to mask register to normal
register but at least only once.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td><pre> <span>mov</span>      <span>edi</span><span>,</span> <span>r9d</span>
 <span>lea</span>      <span>rdi</span><span>,</span> <span>bword</span> <span>ptr</span> <span>[</span><span>r10</span><span>+</span><span>2</span><span>*</span><span>rdi</span><span>]</span>
 <span>vmovups</span>  <span>zmm4</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
 <span>vpackuswb</span> <span>zmm4</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>+</span><span>0x40</span><span>]</span>
 <span>vmovups</span>  <span>zmm5</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>reloc</span> <span>@</span><span>RWD00</span><span>]</span>
 <span>vpermq</span>   <span>zmm4</span><span>,</span> <span>zmm5</span><span>,</span> <span>zmm4</span>
 <span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm0</span>
 <span>kmovq</span>    <span>r15</span><span>,</span> <span>k1</span>
 <span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm1</span>
 <span>kmovq</span>    <span>r13</span><span>,</span> <span>k1</span>
 <span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm2</span>
 <span>kmovq</span>    <span>r12</span><span>,</span> <span>k1</span>
 <span>vpcmpeqb</span> <span>k1</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm3</span>
 <span>kmovq</span>    <span>rcx</span><span>,</span> <span>k1</span>
 <span>or</span>       <span>r15</span><span>,</span> <span>rcx</span>
 <span>or</span>       <span>r15</span><span>,</span> <span>r13</span>
 <span>or</span>       <span>r12</span><span>,</span> <span>r15</span>
 <span>je</span>       <span>SHORT</span> <span>G_M000_IG03</span>
 <span>mov</span>      <span>r13</span><span>,</span> <span>rcx</span>
 <span>lea</span>      <span>rcx</span><span>,</span> <span>[</span><span>r12</span><span>+</span><span>r8</span><span>]</span>
 <span>cmp</span>      <span>r13</span><span>,</span> <span>rcx</span>
 <span>je</span>       <span>G_M000_IG43</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="sepparseravx2packcmpormovemasktzcntcs-0100"><code>SepParserAvx2PackCmpOrMoveMaskTzcnt.cs</code> (0.10.0)</h3>

<p>Let’s compare the AVX-512 to the AVX2 based parser. C# code is shown below.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td><pre><span>var</span> <span>v0</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecI16</span><span>&gt;(</span><span>ref</span> <span>byteRef</span><span>);</span>
<span>var</span> <span>v1</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecI16</span><span>&gt;(</span><span>ref</span> <span>Add</span><span>(</span><span>ref</span> <span>byteRef</span><span>,</span> <span>VecUI8</span><span>.</span><span>Count</span><span>));</span>
<span>var</span> <span>packed</span> <span>=</span> <span>ISA</span><span>.</span><span>PackUnsignedSaturate</span><span>(</span><span>v0</span><span>,</span> <span>v1</span><span>);</span>
<span>// Pack interleaves the two vectors need to permute them back</span>
<span>var</span> <span>bytes</span> <span>=</span> <span>ISA</span><span>.</span><span>Permute4x64</span><span>(</span><span>packed</span><span>.</span><span>AsInt64</span><span>(),</span> <span>0</span><span>b_11_01_10_00</span><span>).</span><span>AsByte</span><span>();</span>

<span>var</span> <span>nlsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>nls</span><span>);</span>
<span>var</span> <span>crsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>crs</span><span>);</span>
<span>var</span> <span>qtsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>qts</span><span>);</span>
<span>var</span> <span>spsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>sps</span><span>);</span>

<span>var</span> <span>lineEndings</span> <span>=</span> <span>nlsEq</span> <span>|</span> <span>crsEq</span><span>;</span>
<span>var</span> <span>lineEndingsSeparators</span> <span>=</span> <span>spsEq</span> <span>|</span> <span>lineEndings</span><span>;</span>
<span>var</span> <span>specialChars</span> <span>=</span> <span>lineEndingsSeparators</span> <span>|</span> <span>qtsEq</span><span>;</span>

<span>// Optimize for the case of no special character</span>
<span>var</span> <span>specialCharMask</span> <span>=</span> <span>MoveMask</span><span>(</span><span>specialChars</span><span>);</span>
<span>if</span> <span>(</span><span>specialCharMask</span> <span>!=</span> <span>0u</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The assembly below is, however, clearly more straightforward as there are no mask
registers involved. This explains why the AVX2 based parser is faster than the
old (0.9.0) AVX-512 based parser.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td><pre><span>mov</span>      <span>edi</span><span>,</span> <span>r9d</span>
<span>lea</span>      <span>rdi</span><span>,</span> <span>bword</span> <span>ptr</span> <span>[</span><span>r10</span><span>+</span><span>2</span><span>*</span><span>rdi</span><span>]</span>
<span>vmovups</span>  <span>ymm4</span><span>,</span> <span>ymmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
<span>vpackuswb</span> <span>ymm4</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>+</span><span>0x20</span><span>]</span>
<span>vpermq</span>   <span>ymm4</span><span>,</span> <span>ymm4</span><span>,</span> <span>-</span><span>40</span>
<span>vpcmpeqb</span> <span>ymm5</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm0</span>
<span>vpcmpeqb</span> <span>ymm6</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm1</span>
<span>vpcmpeqb</span> <span>ymm7</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm2</span>
<span>vpcmpeqb</span> <span>ymm4</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm3</span>
<span>vpternlogd</span> <span>ymm5</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm6</span><span>,</span> <span>-</span><span>2</span>
<span>vpor</span>     <span>ymm6</span><span>,</span> <span>ymm5</span><span>,</span> <span>ymm7</span>
<span>vpmovmskb</span> <span>r15d</span><span>,</span> <span>ymm6</span>
<span>mov</span>      <span>r15d</span><span>,</span> <span>r15d</span>
<span>test</span>     <span>r15</span><span>,</span> <span>r15</span>
<span>je</span>       <span>SHORT</span> <span>G_M000_IG03</span>
<span>vpmovmskb</span> <span>r13d</span><span>,</span> <span>ymm4</span>
<span>mov</span>      <span>r13d</span><span>,</span> <span>r13d</span>
<span>lea</span>      <span>r12</span><span>,</span> <span>[</span><span>r15</span><span>+</span><span>r8</span><span>]</span>
<span>cmp</span>      <span>r13</span><span>,</span> <span>r12</span>
<span>je</span>       <span>G_M000_IG43</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="sepparseravx512to256cmpormovemasktzcntcs-0100"><code>SepParserAvx512To256CmpOrMoveMaskTzcnt.cs</code> (0.10.0)</h3>

<p>Given that even the tweaked AVX-512 (0.10.0) based parser had issues with mask
registers, I kept thinking that perhaps there was a more straightforward way to
do this, and then after some searching and unfruitful discussions with LLMs I
figured out that one could just use AVX-512 instructions for loading the <code>char</code>s
and then convert the 16-bit to 8-bit bytes saturated as a 256-bit register,
avoiding the 512-bit mask registers, by using
<code>ConvertToVector256ByteWithSaturation</code> (<code>vpmovuswb</code>) as shown below. This “only”
parses 32 <code>char</code>s at a time, but it is much simpler and avoids the mask register
issue.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>var</span> <span>v</span> <span>=</span> <span>ReadUnaligned</span><span>&lt;</span><span>VecUI16</span><span>&gt;(</span><span>ref</span> <span>byteRef</span><span>);</span>
<span>var</span> <span>bytes</span> <span>=</span> <span>ISA</span><span>.</span><span>ConvertToVector256ByteWithSaturation</span><span>(</span><span>v</span><span>);</span>

<span>var</span> <span>nlsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>nls</span><span>);</span>
<span>var</span> <span>crsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>crs</span><span>);</span>
<span>var</span> <span>qtsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>qts</span><span>);</span>
<span>var</span> <span>spsEq</span> <span>=</span> <span>Vec</span><span>.</span><span>Equals</span><span>(</span><span>bytes</span><span>,</span> <span>sps</span><span>);</span>

<span>var</span> <span>lineEndings</span> <span>=</span> <span>nlsEq</span> <span>|</span> <span>crsEq</span><span>;</span>
<span>var</span> <span>lineEndingsSeparators</span> <span>=</span> <span>spsEq</span> <span>|</span> <span>lineEndings</span><span>;</span>
<span>var</span> <span>specialChars</span> <span>=</span> <span>lineEndingsSeparators</span> <span>|</span> <span>qtsEq</span><span>;</span>

<span>// Optimize for the case of no special character</span>
<span>var</span> <span>specialCharMask</span> <span>=</span> <span>MoveMask</span><span>(</span><span>specialChars</span><span>);</span>
<span>if</span> <span>(</span><span>specialCharMask</span> <span>!=</span> <span>0u</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The assembly then is much simpler and direct (closer to AVX2) and not only
avoids the mask register issues but also has more straightforward saturated
conversion since no permutation is needed as the packed data is already in order
just in the <code>ymm4</code> register (that is the 256-bit part of <code>zmm4</code>).</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>mov</span>      <span>edi</span><span>,</span> <span>r9d</span>
<span>lea</span>      <span>rdi</span><span>,</span> <span>bword</span> <span>ptr</span> <span>[</span><span>r10</span><span>+</span><span>2</span><span>*</span><span>rdi</span><span>]</span>
<span>vmovups</span>  <span>zmm4</span><span>,</span> <span>zmmword</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
<span>vpmovuswb</span> <span>zmm4</span><span>,</span> <span>zmm4</span>
<span>vpcmpeqb</span> <span>ymm5</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm0</span>
<span>vpcmpeqb</span> <span>ymm6</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm1</span>
<span>vpcmpeqb</span> <span>ymm7</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm2</span>
<span>vpcmpeqb</span> <span>ymm4</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm3</span>
<span>vpternlogd</span> <span>ymm5</span><span>,</span> <span>ymm4</span><span>,</span> <span>ymm6</span><span>,</span> <span>-</span><span>2</span>
<span>vpor</span>     <span>ymm6</span><span>,</span> <span>ymm5</span><span>,</span> <span>ymm7</span>
<span>vpmovmskb</span> <span>r15d</span><span>,</span> <span>ymm6</span>
<span>mov</span>      <span>r15d</span><span>,</span> <span>r15d</span>
<span>test</span>     <span>r15</span><span>,</span> <span>r15</span>
<span>je</span>       <span>SHORT</span> <span>G_M000_IG03</span>
<span>vpmovmskb</span> <span>r13d</span><span>,</span> <span>ymm4</span>
<span>mov</span>      <span>r13d</span><span>,</span> <span>r13d</span>
<span>lea</span>      <span>r12</span><span>,</span> <span>[</span><span>r15</span><span>+</span><span>r8</span><span>]</span>
<span>cmp</span>      <span>r13</span><span>,</span> <span>r12</span>
<span>je</span>       <span>G_M000_IG43</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>And this is what brings Sep parsing up to a staggering 21 GB/s on the 9950X! 🚀</p>

<h3 id="all-parsers-benchmarks">All Parsers Benchmarks</h3>

<p>Finally, given all the parsers available in Sep I have added a benchmark, that
uses the aforementioned environment variable, to run all parsers and compare
their performance on the low level row parsing to better gauge their individual
performance on the same CPU. Here the AMD 9950X.</p>

<p>The new AVX-512-to-256 parser is the fastest parser of all hitting ~21.5 GB/s,
but the Vector256/AVX2 based parsers are not far behind (about 5%).
<code>SepParserVector256NrwCmpExtMsbTzcnt</code> is the cross-platform <code>Vector256</code> based
parser and it is notably now on par with the AVX2, but note how the other
cross-platform <code>Vector128</code> and <code>Vector512</code> based parsers are not (still fast but
5-10% slower), and even worse that the <code>Vector512</code> one is slower than the
<code>Vector128</code>.</p>

<p><code>SepParserIndexOfAny</code> is far behind, and should make it clear that any ideas
that this could be used to compete with Sep are not realistic. 😉 <code>Vector64</code> is
not accelerated on the 9950X and therefore very slow. It’s just there for
completeness.</p>

<table>
  <thead>
    <tr>
      <th>Parser</th>
      <th>MB/s</th>
      <th>ns/row</th>
      <th>Mean</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SepParserAvx512To256CmpOrMoveMaskTzcnt</td>
      <td><code>21597.7</code></td>
      <td>27.0</td>
      <td>1.351 ms</td>
    </tr>
    <tr>
      <td>SepParserVector256NrwCmpExtMsbTzcnt</td>
      <td><code>20608.5</code></td>
      <td>28.3</td>
      <td>1.416 ms</td>
    </tr>
    <tr>
      <td>SepParserAvx2PackCmpOrMoveMaskTzcnt</td>
      <td><code>20599.3</code></td>
      <td>28.3</td>
      <td>1.417 ms</td>
    </tr>
    <tr>
      <td>SepParserAvx512PackCmpOrMoveMaskTzcnt</td>
      <td><code>19944.3</code></td>
      <td>29.3</td>
      <td>1.463 ms</td>
    </tr>
    <tr>
      <td>SepParserAvx256To128CmpOrMoveMaskTzcnt</td>
      <td><code>19465.5</code></td>
      <td>30.0</td>
      <td>1.499 ms</td>
    </tr>
    <tr>
      <td>SepParserSse2PackCmpOrMoveMaskTzcnt</td>
      <td><code>19312.5</code></td>
      <td>30.2</td>
      <td>1.511 ms</td>
    </tr>
    <tr>
      <td>SepParserVector128NrwCmpExtMsbTzcnt</td>
      <td><code>18252.1</code></td>
      <td>32.0</td>
      <td>1.599 ms</td>
    </tr>
    <tr>
      <td>SepParserVector512NrwCmpExtMsbTzcnt</td>
      <td><code>18067.4</code></td>
      <td>32.3</td>
      <td>1.615 ms</td>
    </tr>
    <tr>
      <td>SepParserIndexOfAny</td>
      <td>` 2787.0`</td>
      <td>209.4</td>
      <td>10.471 ms</td>
    </tr>
    <tr>
      <td>SepParserVector64NrwCmpExtMsbTzcnt</td>
      <td>`  459.9`</td>
      <td>1268.9</td>
      <td>63.446 ms</td>
    </tr>
  </tbody>
</table>

<h3 id="top-level-5950x-vs-9950x-benchmarks">Top Level 5950X vs 9950X Benchmarks</h3>

<p>Finally, the table below shows the top level benchmarks for the 5950X and 9950X
CPUs for the package assets and floats data.</p>

<p>Note how on the 9950X the one million package assets rows are parsed in just 72
ms for <code>Sep_MT</code> (multi-threaded Sep) compared to 119 ms on the 5950X. Or 8 GB/s
on 9950X vs 4.9 GB/s on 5950X. <strong>~8 GB/s!</strong> 🚀</p>

<p>Similarly, for floats Sep can parse 8 GB/s of floating point CSV data
multi-threaded. <strong>~8 GB/s</strong>! 🌪</p>

<p>That’s, about 1.5x-1.6x improvement, similarly to the low level benchmarks,
going from 5950X to 9950X. That’s significant generational improvements to CPU
performance. Kudos to AMD and TSMC.</p>

<h5 id="package-assets-5950x">Package Assets 5950X</h5>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Rows</th>
      <th>Mean</th>
      <th>Ratio</th>
      <th>MB/s</th>
      <th>ns/row</th>
      <th>Allocated</th>
      <th>Alloc Ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sep</td>
      <td>1000000</td>
      <td>432.887 ms</td>
      <td>1.00</td>
      <td><code>1348.6</code></td>
      <td>432.9</td>
      <td>260.41 MB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>Sep_MT</td>
      <td>1000000</td>
      <td>119.430 ms</td>
      <td>0.28</td>
      <td><code>4888.1</code></td>
      <td>119.4</td>
      <td>261.39 MB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>Sylvan</td>
      <td>1000000</td>
      <td>559.550 ms</td>
      <td>1.29</td>
      <td><code>1043.3</code></td>
      <td>559.6</td>
      <td>260.57 MB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>ReadLine_</td>
      <td>1000000</td>
      <td>573.637 ms</td>
      <td>1.33</td>
      <td><code>1017.7</code></td>
      <td>573.6</td>
      <td>1991.05 MB</td>
      <td>7.65</td>
    </tr>
    <tr>
      <td>CsvHelper</td>
      <td>1000000</td>
      <td>1,537.602 ms</td>
      <td>3.55</td>
      <td>` 379.7`</td>
      <td>1537.6</td>
      <td>260.58 MB</td>
      <td>1.00</td>
    </tr>
  </tbody>
</table>

<h5 id="package-assets-9950x">Package Assets 9950X</h5>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Rows</th>
      <th>Mean</th>
      <th>Ratio</th>
      <th>MB/s</th>
      <th>ns/row</th>
      <th>Allocated</th>
      <th>Alloc Ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sep</td>
      <td>1000000</td>
      <td>291.979 ms</td>
      <td>1.00</td>
      <td><code>1999.4</code></td>
      <td>292.0</td>
      <td>260.41 MB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>Sep_MT</td>
      <td>1000000</td>
      <td>72.213 ms</td>
      <td>0.25</td>
      <td><code>8084.1</code></td>
      <td>72.2</td>
      <td>261.63 MB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>Sylvan</td>
      <td>1000000</td>
      <td>413.265 ms</td>
      <td>1.42</td>
      <td><code>1412.6</code></td>
      <td>413.3</td>
      <td>260.57 MB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>ReadLine_</td>
      <td>1000000</td>
      <td>377.033 ms</td>
      <td>1.29</td>
      <td><code>1548.4</code></td>
      <td>377.0</td>
      <td>1991.04 MB</td>
      <td>7.65</td>
    </tr>
    <tr>
      <td>CsvHelper</td>
      <td>1000000</td>
      <td>1,005.323 ms</td>
      <td>3.44</td>
      <td>` 580.7`</td>
      <td>1005.3</td>
      <td>260.58 MB</td>
      <td>1.00</td>
    </tr>
  </tbody>
</table>

<h5 id="floats-5950x">Floats 5950X</h5>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Rows</th>
      <th>Mean</th>
      <th>Ratio</th>
      <th>MB/s</th>
      <th>ns/row</th>
      <th>Allocated</th>
      <th>Alloc Ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sep</td>
      <td>25000</td>
      <td>20.297 ms</td>
      <td>1.00</td>
      <td><code>1001.1</code></td>
      <td>811.9</td>
      <td>7.97 KB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>Sep_MT</td>
      <td>25000</td>
      <td>3.780 ms</td>
      <td>0.19</td>
      <td><code>5375.6</code></td>
      <td>151.2</td>
      <td>179.49 KB</td>
      <td>22.51</td>
    </tr>
    <tr>
      <td>Sylvan</td>
      <td>25000</td>
      <td>52.343 ms</td>
      <td>2.58</td>
      <td>` 388.2`</td>
      <td>2093.7</td>
      <td>18.88 KB</td>
      <td>2.37</td>
    </tr>
    <tr>
      <td>ReadLine_</td>
      <td>25000</td>
      <td>68.698 ms</td>
      <td>3.38</td>
      <td>` 295.8`</td>
      <td>2747.9</td>
      <td>73493.12 KB</td>
      <td>9,215.89</td>
    </tr>
    <tr>
      <td>CsvHelper</td>
      <td>25000</td>
      <td>100.913 ms</td>
      <td>4.97</td>
      <td>` 201.4`</td>
      <td>4036.5</td>
      <td>22061.69 KB</td>
      <td>2,766.49</td>
    </tr>
  </tbody>
</table>

<h5 id="floats-9950x">Floats 9950X</h5>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Rows</th>
      <th>Mean</th>
      <th>Ratio</th>
      <th>MB/s</th>
      <th>ns/row</th>
      <th>Allocated</th>
      <th>Alloc Ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sep</td>
      <td>25000</td>
      <td>16.182 ms</td>
      <td>1.00</td>
      <td><code>1255.7</code></td>
      <td>647.3</td>
      <td>7.94 KB</td>
      <td>1.00</td>
    </tr>
    <tr>
      <td>Sep_MT</td>
      <td>25000</td>
      <td>2.497 ms</td>
      <td>0.15</td>
      <td><code>8136.8</code></td>
      <td>99.9</td>
      <td>179.81 KB</td>
      <td>22.64</td>
    </tr>
    <tr>
      <td>Sylvan</td>
      <td>25000</td>
      <td>38.800 ms</td>
      <td>2.40</td>
      <td>` 523.7`</td>
      <td>1552.0</td>
      <td>18.72 KB</td>
      <td>2.36</td>
    </tr>
    <tr>
      <td>ReadLine_</td>
      <td>25000</td>
      <td>54.117 ms</td>
      <td>3.34</td>
      <td>` 375.5`</td>
      <td>2164.7</td>
      <td>73493.05 KB</td>
      <td>9,253.27</td>
    </tr>
    <tr>
      <td>CsvHelper</td>
      <td>25000</td>
      <td>71.601 ms</td>
      <td>4.42</td>
      <td>` 283.8`</td>
      <td>2864.1</td>
      <td>22061.55 KB</td>
      <td>2,777.70</td>
    </tr>
  </tbody>
</table>

<h2 id="-summary-highlights">🌟 Summary Highlights</h2>

<p>AI generated summary highlights 😁</p>

<ul>
  <li>🚀 <strong>Blazing Fast Parsing</strong>: Sep 0.10.0 achieves an incredible <strong>21 GB/s</strong> CSV
parsing speed on AMD 9950X, a <strong>~3x improvement</strong> since its first release in
2023!</li>
  <li>🖥 <strong>Hardware Boost</strong>: Upgrading from AMD 5950X (Zen 3) to AMD 9950X (Zen 5)
delivers a <strong>~1.6x performance gain</strong>, thanks to AVX-512 support and higher
clock speeds.</li>
  <li>🧠 <strong>Smarter Parsers</strong>: The new <strong>AVX-512-to-256 parser</strong> circumvents mask
register inefficiencies, outperforming AVX2 and older AVX-512 parsers,
achieving <strong>~21 GB/s</strong>!</li>
  <li>📊 <strong>Cross-Platform Excellence</strong>: The <code>Vector256</code> based cross-platform parser
is now on par with AVX2, ensuring top-tier performance across platforms.</li>
  <li>🔬 <strong>Deep Dive</strong>: Explored .NET 9.0 JIT optimizations, SIMD assembly, and
parser design for CSV parsing.</li>
  <li>🏆 <strong>Multi-Threaded Power</strong>: Sep parses <strong>1 million rows in just 72 ms</strong> on
the 9950X, achieving <strong>8 GB/s</strong> for real-world CSV workloads.</li>
  <li>🔧 <strong>Continuous Improvement</strong>: Incremental optimizations and hardware
advancements have propelled Sep to new heights in just under 2 years.</li>
</ul>

<p>🎉 Sep is a testament to the power of software and hardware working together
to push the boundaries of performance!</p>

<p>That’s all!</p>

  </div></div>
  </body>
</html>
