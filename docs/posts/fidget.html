<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mattkeeter.com/projects/fidget/">Original</a>
    <h1>Fidget</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<!-- End header -->









<h2>Introduction</h2>
<p><a href="https://github.com/mkeeter/fidget">Fidget</a> is a library for representing,
compiling, and evaluating large-scale math expressions, i.e. hundreds or
thousands of arithmetic clauses.  It&#39;s mainly designed as a backend for
<a href="https://en.wikipedia.org/wiki/Implicit_surface">implicit surfaces</a>, but the
library is flexible enough for many different uses!</p>
<p><a href="https://www.mattkeeter.com/projects/fidget/demo/"><img src="https://www.mattkeeter.com/projects/fidget/demo.png" alt="Demo, showing a script on one side and rendering on the other"/></a></p>
<p>
<a href="https://www.mattkeeter.com/projects/fidget/demo/">Try the demo</a>
</p>
<h3>What are implicit surfaces?</h3>
<p>Implicit surfaces are expressions of the form
$f(x, y, z) \rightarrow d$
returning a single distance value $d$.
If that value is positive, then the point $(x, y, z)$ is outside the model;
if it&#39;s negative, then the point is inside the model.</p>
<p>For example, a sphere of radius 1 can be expressed
as</p>
<p>$$ f(x, y, z) = \sqrt{x^2 + y^2 + z^2} - 1 $$</p>
<p>By evaluating the expression at many points in space and checking its sign, we
can render this function into an image.  In this example, we&#39;ll render a
<strong>heightmap</strong>, where filled-in voxels are colored based on their distance to the
camera:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/sphere.png" alt="Picture of a shaded sphere"/></p>
<p>Fidget focuses on <strong>closed-form</strong> implicit surfaces, which build their
expressions out of basic arithmetic operations. This is in contrast with more
flexible representations (e.g. GLSL in a pixel shader), which may run entire
Turing-complete programs to compute the distance value.</p>
<p>I like to think of these functions as an &#34;assembly language for shapes&#34;: a
low-level representation that you&#39;re unlikely to write by hand, but easy to
target from higher-level representations.</p>
<h3>Why implicit surfaces?</h3>
<p>Implicit surfaces are a particularly pleasant representation: they&#39;re compact,
philosophically straight-forward, and amenable to massively parallel evaluation
(e.g. using SIMD instructions or on the GPU).</p>
<p>In addition, <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">constructive solid geometry (CSG)</a>
operations like union or intersection – famously difficult for meshes and NURBS
– are trivial!  Here&#39;s the union of two exactly-coincident cylinders,
which is just <code>min(a, b)</code>:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/cylinders.png" alt="Picture of two cylinders overlapping in a cross shape"/></p>
<p>Having a closed-form equation opens the door to interesting optimizations.  For
example, Fidget can capture a <em>trace</em> showing which branches are taken during
evaluation; this trace can be used to simplify the expression, reducing the cost
of future evaluation.</p>
<p>Finally, for the computer enthusiasts, implicit surfaces offer a deep well of
entertaining research topics: everything from compilers to meshing algorithms
to GPGPU programming.</p>
<p>In other words, <a href="https://www.mattkeeter.com/projects/fidget/neat.png">I just think they&#39;re neat</a>.</p>
<h3>Origins</h3>
<p>Over the past ten years, I&#39;ve spent a lot of time thinking about
rendering and evaluation of implicit surfaces:</p>
<ul>
<li>I&#39;ve written <a href="https://www.mattkeeter.com/blog/2017-01-09-lineage/">4-5 kernels</a>
in various languages, at least <a href="https://libfive.com">one of which</a> was used
in commercial CAD software.</li>
<li>Back in 2020, I published a <a href="https://www.mattkeeter.com/research/mpr">SIGGRAPH paper</a> presenting a new
strategy for fast rendering on modern GPUs</li>
</ul>
<p>So, why write something completely new, when the industrial-strength <code>libfive</code>
kernel is sitting right there?</p>
<p>This is personal-scale, mostly-unpaid research, so I have to optimize
for my own motivation and energy.  The questions that I&#39;m currently finding
interesting would be hard or frustrating to investigate using <code>libfive</code> as a
foundation:</p>
<ul>
<li>Finding the &#34;right&#34; APIs for implicit kernels, with the possibility of making
substantial compatibility breaks</li>
<li>Experimenting with native (JIT) compilation, to improve performance without
moving to the GPU</li>
<li>Cross-compiling to WebAssembly and building easily-accessible web demos</li>
</ul>
<p><code>libfive</code> is 40K lines of mostly C++, and is extremely challenging to hack on,
even as the original author.  It&#39;s also frustrating to touch: if it&#39;s been a few
months since I last compiled it, it&#39;s inevitable that the build will have
broken, and I&#39;ll have to mess with CMake for 10 minutes to unbreak it.</p>
<p>Fidget is written in Rust, which I&#39;m also using
<a href="https://oxide.computer">professionally</a>.  It compiles
with a single <code>cargo build</code>, cross-compiles to WebAssembly seamlessly, and can
be refactored with confidence (thanks to Rust&#39;s strong type system and memory
safety).</p>
<p>With all that context, let&#39;s get started on our tour of the library!</p>
<h2>Library structure</h2>
<p>The library is built as a stack of three mostly-decoupled layers, along with
demo applications.  Click on one to jump to that section of the writeup, or keep
scrolling to read through in order.</p>


<h2>Frontend: building math expressions</h2>
<p>The frontend of Fidget goes from input script to bytecode:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/frontend.svg" alt="Diagram showing the following pipeline: Script, evaluation, Math tree, deduplication, Math graph, flattening, SSA tape, register allocation, Bytecode "/></p>
<p>It&#39;s not mandatory to use this specific workflow; users of the library can
show up at any point in this diagram.</p>
<p>Let&#39;s walk through step by step and see how things look at each stage!</p>
<h3>Scripting</h3>
<p>Fidget includes bindings for <a href="https://rhai.rs/">Rhai</a>, an embedded scripting
language for Rust.  Using operator overloading, it&#39;s easy to write scripts to
build up math expressions:</p>
<pre><code>let scale = 30;

let x = x * scale;
let y = y * scale;
let z = z * scale;

let gyroid = sin(x)*cos(y) + sin(y)*cos(z) + sin(z)*cos(x);
let fill = abs(gyroid) - 0.2;

let sphere = sqrt(square(x) + square(y) + square(z)) - 25;
draw(max(sphere, fill));
</code></pre>
<p>The value passed to <code>draw</code> is a <strong>math tree</strong> which represents the expression
built up by the script.</p>
<h3>Tree and graph</h3>
<p>The math tree is deduplicated to produce a directed acyclic graph:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/gyroid.svg" alt="math graph"/></p>
<h3>SSA tape</h3>
<p>Doing a <a href="https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis/">topological sort</a>
lets us flatten the graph into straight-line code.</p>
<p>This code is in <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">single static assignment form</a>;
there are arbitrarily many pseudo-registers (named <code>rX</code>), and each one is only
written once.</p>
<pre><code>r7  = Input[0]
r6  = MulRegImm(r7, 30.0)
r26 = SquareReg(r6)
r16 = Input[2]
r15 = MulRegImm(r16, 30.0)
r25 = SquareReg(r15)
r24 = AddRegReg(r26, r25)
r10 = Input[1]
r9  = MulRegImm(r10, 30.0)
r23 = SquareReg(r9)
r22 = AddRegReg(r24, r23)
r21 = SqrtReg(r22)
r20 = SubRegImm(r21, 25.0)
r19 = SinReg(r6)
r18 = CosReg(r15)
r17 = MulRegReg(r19, r18)
r14 = SinReg(r15)
r13 = CosReg(r9)
r12 = MulRegReg(r14, r13)
r11 = AddRegReg(r17, r12)
r8  = SinReg(r9)
r5  = CosReg(r6)
r4  = MulRegReg(r8, r5)
r3  = AddRegReg(r11, r4)
r2  = AbsReg(r3)
r1  = SubRegImm(r2, 0.2)
r0  = MaxRegReg(r20, 1)
Output[0] = r0
</code></pre>
<p>It&#39;s possible to evaluate this tape, but it doesn&#39;t scale well: you have to
allocate a memory location for every single operation, since pseudo-registers
aren&#39;t reused.</p>
<h3>Bytecode</h3>
<p>To improve evaluation, it&#39;s helpful to map from pseduo-registers to
physical(ish) registers, which can be reused.</p>
<p>For example, the tape above can be packed into 6 reuseable registers:</p>
<pre><code>r3 = Input[0]
r3 = MulRegImm(r3, 30.0)
r0 = SquareReg(r3)
r4 = Input[2]
r4 = MulRegImm(r4, 30.0)
r2 = SquareReg(r4)
r0 = AddRegReg(r0, r2)
r2 = Input[1]
r2 = MulRegImm(r2, 30.0)
r1 = SquareReg(r2)
r0 = AddRegReg(r0, r1)
r0 = SqrtReg(r0)
r0 = SubRegImm(r0, 25.0)
r1 = SinReg(r3)
r5 = CosReg(r4)
r1 = MulRegReg(r1, r5)
r4 = SinReg(r4)
r5 = CosReg(r2)
r4 = MulRegReg(r4, r5)
r1 = AddRegReg(r1, r4)
r2 = SinReg(r2)
r3 = CosReg(r3)
r2 = MulRegReg(r2, r3)
r1 = AddRegReg(r1, r2)
r1 = AbsReg(r1)
r1 = SubRegImm(r1, 0.2)
r0 = MaxRegReg(r0, r1)
Output[0] = r0
</code></pre>
<p>Register allocation uses the <a href="https://www.mattkeeter.com/blog/2022-10-04-ssra/">simple algorithm</a> that I
blogged about a few years back.  It&#39;s a single-pass algorithm that trades
efficienty for speed and determinism; that blog post has much more detail and
interactive demos.</p>
<p>The bytecode interpreter uses 256 registers, so the register index is stored in
a <code>u8</code>. If we run out of registers, then the allocator inserts <code>LOAD</code> and
<code>STORE</code> operations to write to secondary memory (using a <code>u32</code> index).</p>
<p>This bytecode tape is the end of the front-end; we now proceed to the backend
for evaluation!</p>

<h2>Backend: fast, flexible evaluation</h2>
<p>The Fidget backend is decoupled from the front-end with a set of traits
(<a href="https://docs.rs/fidget/latest/fidget/eval/trait.Function.html"><code>Function</code></a>,
<a href="https://docs.rs/fidget/latest/fidget/eval/trait.TracingEvaluator.html"><code>TracingEvaluator</code></a>, and
<a href="https://docs.rs/fidget/latest/fidget/eval/trait.BulkEvaluator.html"><code>BulkEvaluator</code></a>),
which roughly represent &#34;things that can be evaluated&#34;.</p>
<p>This decoupling means that algorithms can target a generic <code>Function</code>, instead
of being tightly coupled to our math tree implementation.  Right now, there
aren&#39;t any non-math-tree implementers of the <code>Function</code> trait, but this could
change in the future.  In the current implementation, we have two different
<em>flavors</em> of math tree evaluation: interpreted bytecode, and JIT-compiled
functions.</p>
<p>Here&#39;s a high-level sketch of the evaluation process:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/backend_tracing.svg" alt="Diagram showing the following pipeline: Function -&gt; Tape, Tape + Input arrays -&gt; Evaluator -&gt; Output arrays + Trace "/></p>
<p>For our math expressions, the <strong>Tape</strong> object is the same bytecode tape that we
constructed earlier.  The <strong>Evaluator</strong> is a very simple interpreter, which
iterates over the bytecode tape and executes each opcode.</p>
<p>There are four different evaluation modes:</p>
<ul>
<li>Single-point and array (SIMD) evaluation</li>
<li>Forward-mode automatic differentiation</li>
<li><a href="https://en.wikipedia.org/wiki/Interval_arithmetic">Interval arithmetic</a></li>
</ul>
<h3>Bulk and SIMD evaluation</h3>
<p>Bulk evaluation is straight-forward: the user provides an array of input values,
and receives an array of outputs.  When using the JIT backend, we generate SIMD
code which processes 4 (<code>AArch64</code>) or 8 (<code>x86-64</code>) element at a time.</p>
<p>$$ [1, 2, 3, 4] + [5, 6, 7, 8] = [6, 8, 10, 12]$$</p>
<h3>Forward-mode automatic differentiation</h3>
<p>The derivative evaluator calculates both a value and up to three partial
derivatives (with respect to some variables).  For implicit surfaces, it&#39;s
typically used to calculate the tuple</p>
<p>$$(f, \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z})(x, y, z)$$</p>
<p>At the surface (where $f(x, y, z) = 0$), the partial derivatives are a good
approximation of the surface normal, which can be used for shading:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/sphere_norm.png" alt="Sphere with cutouts, showing normals"/></p>
<p>Evaluation uses <a href="https://en.wikipedia.org/wiki/Automatic_differentiation#Forward_and_reverse_accumulation">forward-mode automatic differentiation</a>;
values in registers are augmented with derivatives, and the chain rule is used
at each step of evaluation.  The JIT evaluator packs the value and three
derivatives into a single <code>4 x f32</code> register for efficiency.</p>
<h3>Interval arithmetic</h3>
<p>Interval arithmetic lets us evaluate expressions over ranges of input values:
instead of assigning $x = 1$, we can say $1 \le x \le 5$.  The output will also
be an interval, e.g. $2 \le f(x, y, z) \le 20$.</p>
<p>The results of interval arithemetic are conservative: they may not tightly bound
the true range of the function, but they are guaranteed to contain all possible
outputs (for input values within the given input intervals).</p>
<p>Interval arithmetic is a core building block for evaluation of implicit
surfaces. If you evaluate a spatial region (using intervals for $x$, $y$, $z$)
and find an interval that&#39;s unambiguously greater than 0, that entire region is
outside your shape and doesn&#39;t need to be considered any further!</p>
<p>In the render below, green and red regions were proved inside / outside the
shape by interval arithmetic; only the black and white pixels were evaluated by
the point-wise evaluation.</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/hello.png" alt="hello world"/></p>
<p>Skipping regions based on interval arithmetic results is already a significant
optimization over bulk evaluation, but wait – there&#39;s more!</p>
<h3>Tracing evaluation and simplification</h3>
<p>Our interval arithmetic evaluator also captures a <strong>trace</strong> of its execution.
For example, consider the following <code>min</code>, evaluated using interval arithmetic:</p>
<p>$$\min(a, b) \text{ where } 0 \le a \le 1 \text{ and } 4 \le b \le 5$$</p>
<p>Because $a$ is unambiguously less than $b$ (within this interval), the
expression can be simplified from $\min(a, b) \rightarrow a$.</p>
<p>Each <code>min</code> and <code>max</code> operation records a single <strong>choice</strong>, indicating which
arguments affect the result (left-hand side, right-hand side, or both). These
choices can be used to simplify the original function.  In our $\min(a, b)$
example, we don&#39;t need to calculate $b$ or $\min$ if we&#39;ve simplified the
expression to just $a$.</p>
<h3>The One Weird Trick</h3>
<p>The combination of interval arithmetic and tape simplification is the <strong>One Weird
Trick</strong> that makes working with large-scale expressions feasible.  I&#39;m going to
circle around this idea from a few different angles, because it&#39;s critically
important!</p>
<p>Interval arithmetic and tape simplification have a positive synergy: we can both
skip inactive (empty / full) regions of space, <em>and</em> evaluating the remaining
active regions becomes cheaper.</p>
<p>You can also think of tape simplification as analogous to a spatial acceleration
data structure: we&#39;re computing a simplified expression that&#39;s only valid in a
particular spatial region.  Unlike typical raytracing acceleration data
structures, we&#39;re building the accelerator dynamically during evaluation.</p>
<p>For rasterization, the cost of interval evaluation is <strong>amortized</strong> across many
pixels in the interval.  Interval evaluation of an $N \times N$ pixel region
with a tape length of $T$ is $O(T)$, i.e. only proportional to the tape length,
and independent of pixel count.</p>
<p>By the time we get down to single-pixel evaluation (e.g. for an $M \times M$
region, $M &lt; N$), we&#39;re working on dramatically shorter tapes.  At this point,
evaluation must be done for every pixel, but the cost is $O(T&#39; \times M \times
M)$, where $T&#39; &lt; T$ (the tape is significantly shorter).</p>
<p>Both of these effects are even more significant for 3D rendering, where we&#39;re
dealing with $N^3$ voxels instead of $N^2$ pixels!</p>
<p>To get some concrete numbers, let&#39;s take a closer look at the <code>hello, world</code>
image above.  We&#39;re rendering a 256×256 image (2D), and the original tape is 254
clauses.  Here&#39;s how things go down:</p>
<ul>
<li>Interval evaluation of 32×32 pixel tiles, of which there are 64
<ul>
<li>Empty regions are skipped, leaving 47 active tiles</li>
<li>The average tape length in active tiles has shrunk to 73 clauses</li>
</ul>
</li>
<li>Each of these tiles is subdivided into 16 smaller tiles (8×8 pixel)</li>
<li>Interval evaluation of 8×8 pixel tiles, of which there are 752
<ul>
<li>Empty regions are skipped, leaving 351 active tiles</li>
<li>The average tape length in active tiles has shrunk to 20 clauses</li>
</ul>
</li>
<li>Per-pixel evaluation of remaining 8×8 pixel tiles, of which there are 351</li>
</ul>
<p>Here are the active tiles positions and tape lengths after simplification:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/tape_len.png" alt="diagram of tape lengths, showing the same data as above"/></p>
<p>By the time we&#39;re doing per-pixel evaluation, the tape is more than 10× shorter
than its original length!</p>
<p>Of course, not every shape is amenable to this kind of on-the-fly
simplification.  Fidget supports simplifying <code>min</code> and <code>max</code> operations (used in
CSG), as well as logical ops (<code>and</code> and <code>or</code>).  Shapes without CSG or logic
won&#39;t benefit from simplification; however, they may still benefit from
interval-arithmetic-based skipping of empty and full regions.</p>
<h3>JIT compilation</h3>
<p>The bytecode interpreter is a tight loop, but suffers from inevitable overhead:</p>
<ul>
<li>Instruction dispatch is a single unpredictable branch
(see <a href="https://www.mattkeeter.com/blog/2024-07-12-interpreter/">&#34;Beating the compiler&#34;</a>
for details on interpreter optimization)</li>
<li>Each instruction reads and writes to memory, in the form of register slots
within the VM evaluator</li>
</ul>
<p>For maximum performance, Fidget also includes a JIT compiler, which lowers
bytecode down to machine instructions!  The machine instructions are
straight-line code (without any dispatch), and use physical registers directly
(so no reading and writing to memory).</p>
<p>Consider $\sqrt{x^2 + y^2} - 1$, which generates the following bytecode:</p>
<pre><code>r0 = Input[1]
r0 = SquareReg(r0)
r1 = Input[0]
r1 = SquareReg(r1)
r0 = AddRegReg(r0, r1)
r0 = SqrtReg(r0)
r0 = SubRegImm(r0, 1.0)
Output[0] = r0
</code></pre>
<p>The input to the JIT compiler is the same bytecode tape as before, but planned
with 12 (<code>x86-64</code>) or 24 (<code>AArch64</code>) physical registers, instead of the VM
default of 255.  (This isn&#39;t visible in the bytecode above, which only uses two
registers)</p>
<p>These register limits mean that bytecode registers can directly be mapped to
physical registers in hardware: <code>v8-31</code> on <code>AArch64</code>, and <code>xmm4-15</code> on <code>x86-64</code>.</p>
<p>With the help of <a href="https://godbolt.org">godbolt.org</a>, I hand-wrote snippets of
assembly for every single opcode × data type × architecture.  This was very
tedious!  However, it makes JIT compilation simple: patch in the desired
physical registers within each snippet, then copy them into an <code>mmap</code>&#39;d region
of memory.</p>
<p>The bytecode above is turned into the following function on an <code>AArch64</code> system:</p>
<pre><code>; Preserve frame and link register, and set up the frame pointer
stp   x29, x30, [sp, 0x0]
mov   x29, sp

; Preserve callee-saved floating-point registers
stp   d8, d9, [sp, 0x10]

ldr s8, [x0, 4]         ; r0 = Input[1]
fmul s8, s8, s8         ; r0 = SquareReg(r0)
ldr s9, [x0, 0]         ; r1 = Input[0]
fmul s9, s9, s9         ; r1 = SquareReg(r1)
fadd s8, s8, s9         ; r0 = AddRegReg(r0, r1)
fsqrt s8, s8            ; r0 = SqrtReg(r0)
movz w9, 0x3f80, lsl 16 ; load 1.0 into s3
fmov s3, w9
fsub s8, s8, s3         ; r0 = SubRegImm(r0, 1.0)
str s8, [x1, 0]         ; Output[0] = r0

; Restore frame and link register
ldp   x29, x30, [sp, 0x0]

; Restore callee-saved floating-point registers
ldp   d8, d9, [sp, 0x10]

ret
</code></pre>
<p>At the Rust level, this chunk of memory can be cast to a function pointer, i.e.</p>
<pre><code>unsafe extern &#34;C&#34; fn(
    *const f32, // x0: inputs
    *mut f32    // x1: outputs
);
</code></pre>
<p>Rust slices can be cast to raw pointers for inputs and outputs, e.g.</p>
<pre><code>let in = [0.0, 1.0]; // [x, y]
let mut out = [0.0];

unsafe {
    (fn_ptr)(in.as_ptr(), out.as_mut_ptr());
}
println!(&#34;{out:?}&#34;);
</code></pre>
<p>JIT compilation has a dramatic effect on evaluation time.  Here&#39;s a relatively
complex example, built from <a href="https://github.com/mkeeter/fidget/blob/main/models/prospero.vm">7867 expressions</a>:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/prospero.png" alt="monologue from The Tempest"/></p>
<p>Doing brute force evaluation on 1024² pixels, the bytecode interpreter takes 5.8
seconds, while the JIT backend takes 182 <em>milliseconds</em> – a 31× speedup!</p>
<p>Note that the speedup is less dramatic with smarter algorithms; brute force
doesn&#39;t take advantage of interval arithmetic or tape simplification!  The
optimized rendering implementation in Fidget draws this image in 6 ms using the
bytecode interpreter, or 4.6 ms using the JIT backend, so the improvement is
only about 25%.</p>

<h2>Algorithms</h2>
<p>With a foundation of fast evaluation, the sky&#39;s the limit!</p>
<h3>Rendering</h3>
<p>All of the models in this writeup are rendered using algorithms from
<a href="https://docs.rs/fidget/latest/fidget/render/index.html"><code>fidget::render</code></a>.
Rendering uses the same core algorithm presented in <a href="https://www.mattkeeter.com/research/mpr">my SIGGRAPH
paper</a>:</p>
<ul>
<li>Render large spatial regions using interval arithmetic</li>
<li>Generate shortened tapes based on traces</li>
<li>Subdivide and recurse on ambiguous regions</li>
<li>Calculate normals using partial derivatives (3D rendering only)</li>
</ul>
<p>(There&#39;s nothing particularly exotic here, for folks familiar with the
literature; it&#39;s a particularly well-tuned implementation of ideas dating back
<a href="http://fab.cba.mit.edu/classes/S62.12/docs/Duff_interval_CSG.pdf">to the 90s</a>)</p>
<p>Models are transformed by a 4×4 homogeneous matrix as part of rendering, which
means that perspective transforms are supported.  Rendering typically produces
two images: a heightmap, and per-pixel normals.</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/arch.png" alt="Architectural model, shown with depth and normals"/></p>
<p>These can be drawn using standard deferred rendering techniques, e.g.
<a href="https://en.wikipedia.org/wiki/Screen_space_ambient_occlusion">SSAO</a>
(left as an exercise for the reader).</p>
<h3>Meshing</h3>
<p>Fidget implements <a href="https://people.engr.tamu.edu/schaefer/research/dualsimp_tvcg.pdf">Manifold Dual Contouring</a> for meshing.</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/arch_wireframe.png" alt="Architectural model, shown as a model + wireframe"/></p>
<p>The implementation in Fidget should always produce meshes that are</p>
<ul>
<li>Watertight</li>
<li>Manifold</li>
<li>Preserving sharp features (edges / corners)</li>
<li>Adaptive; triangles are less dense in mostly-flat regions</li>
</ul>
<p>However, it has the following deficiencies:</p>
<ul>
<li>It will not necessarily preserve thin features</li>
<li>The resulting meshes may include self-intersections</li>
<li>Vertex positioning is susceptible to <a href="https://www.mattkeeter.com/blog/2023-04-23-adversarial/">adversarial cases</a></li>
</ul>
<p>Looking closely at the model, the topology leaves something to be desired:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/arch_wire_close.png" alt="Architectural model, wireframe close-up"/></p>
<p>It may seem weird to write out all of the ways meshing can go wrong – why not
just make it better? – but good meshing of arbitrary implicit surfaces remains
an unsolved problem!</p>
<p>Whenever someone publishes a new meshing strategy, I go through my checklist and
see how it scores; Manifold Dual Contouring, while not perfect, currently
occupies a sweet spot of simplicity and performance.</p>

<h2>Demos</h2>
<p>The <a href="https://github.com/mkeeter/fidget">Fidget repository</a> includes
<a href="https://github.com/mkeeter/fidget/tree/main/demos">a handful of demos</a>, with a
great deal of implementation variety.
I&#39;d like to focus on the web GUI, because it&#39;s the most interesting; there&#39;s
also a simple CLI (<code>fidget-cli</code>) and native script viewer (<code>fidget-viewer</code>).</p>
<p>You may remember the web editor from the very beginning of the writeup, some
3000 words ago!  You can still <a href="https://www.mattkeeter.com/projects/fidget/demo/">try it out</a>:</p>
<p><a href="https://www.mattkeeter.com/projects/fidget/demo/"><img src="https://www.mattkeeter.com/projects/fidget/web_editor.png" alt="A text editor and render pane side by side"/></a></p>
<p>This demo was an opportunity for me to explore more modern (and in some cases,
bleeding-edge) web development.  There&#39;s a lot going on:</p>
<ul>
<li>The GUI is written in TypeScript!</li>
<li>The Fidget crate is used as a library, rather than driving the event loop.</li>
<li>The text editor is <a href="https://codemirror.net/">CodeMirror</a>, so I have to use
Node modules...</li>
<li>...which requires a bundler; I picked <a href="https://webpack.js.org/">webpack</a>
somewhat arbitrarily.</li>
<li>Script evaluation and rendering are both done by web worker threads, to avoid
blocking the main event loop.</li>
<li>Rendering is parallelized, using
<a href="https://github.com/RReverser/wasm-bindgen-rayon"><code>wasm-bindgen-rayon</code></a> to
work around the lack of <code>std::thread</code> in the browser.</li>
<li>Workers share memory with the main event loop.  We can cancel long-running
renders if the user provides new input, by setting a flag in an
<code>Arc&lt;AtomicBool&gt;</code> that&#39;s shared with the worker thread.</li>
</ul>
<p>All of this was a terrible nightmare!  Each individual component deserves praise
for including a working example; unfortunately, they all used mutually exclusive
bundlers, settings, servers, etc. Combining them all into a working system was
quite a challenge!</p>
<p>(For example, I had to pin an old version
of <a href="https://github.com/rustwasm/wasm-bindgen/issues/4233"><code>wasm-bindgen</code></a>
because they recently fixed a bug that was load-bearing for
<a href="https://github.com/rustwasm/wasm-bindgen/issues/4233"><code>wasm-bindgen-rayon</code></a>)</p>
<p>Still, I&#39;m pleased with how it turned out.  It even works on my phone, albeit
without camera controls (since I&#39;m using mouse events instead of touch events).</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/phone.png" alt="Fidget demo running on my phone"/></p>
<h2>Aside: Meditations on demos</h2>
<p>I always have mixed feelings about making demos for my projects.  Fidget is
first and foremost a <strong>library</strong>; people should be embedding it into their own
projects as infrastructure, not using my demos as actual CAD tools.</p>
<p>However, the population of Weird CAD People (which is small to begin with!)
breaks down into roughly the following groups:</p>
<p><img src="https://www.mattkeeter.com/projects/fidget/venn.svg" alt="Venn diagram of people who want to use weird CAD tools versus write their own weird CAD tools"/>
<br/></p>
<p><em>Many</em> more people will be interacting with the demos – even to the point of
using them for design work – than building tools with the libraries.  There&#39;s a
tension between making the demos more useful for this larger audience, versus
making the libraries better for a smaller set of users.</p>
<p>Historically, I&#39;ve struggled to maintain a kernel <strong>and</strong> full-fledged CAD UI
simultaneously, and have been reducing the scope of demos accordingly – but as
you can tell from the web editor, even a &#34;minimal&#34; demo is a significant
project.</p>
<p>I don&#39;t know how this will turn out with Fidget!  My plan is roughly the
following:</p>
<ul>
<li>Keep following my interests, to preserve my motivation and focus</li>
<li>Accept suggestions from people using the tools, while setting expectations at
a reasonable level</li>
<li>Prioritize feedback from people in the smaller circles of tool-builders,
because – in an ideal world – they would take pressure off my demos by
building full-fledged tools that others could use</li>
</ul>
<h2>Future possibilities</h2>
<p>I&#39;ve been quietly working on Fidget for about 2.5 years.  In that time, it has
evolved significantly – for example, it started as an LLVM-backed evaluator!  I
expect it to continue evolving, albeit at a slower pace, as I continue to find
the &#34;right&#34; APIs and abstractions.</p>
<p>Let me discuss a few obvious future directions, before wrapping up.</p>
<h3>Doing stuff on the GPU</h3>
<p>I wrote <a href="https://www.mattkeeter.com/research/mpr/">a whole paper</a> about this, so adding a GPU backend
seems like an obvious extension.  In fact, I have already done this, in the
<a href="https://github.com/mkeeter/fidget/tree/wgpu-bytecode"><code>wgpu-bytecode</code></a> branch!</p>
<p>However, performance isn&#39;t particularly compelling, at least on my Apple M1 Max
laptop.  In particular, the bytecode interpreter loop appears to be <em>incredibly</em>
inefficient.  I&#39;m continuing to investigate the root cause, and will likely
write up a blog post with more details.</p>
<p>(If you&#39;re familiar with Metal shader optimization, feel free to reach out, and
I will happily brain-dump in your direction)</p>
<h3>Better meshing</h3>
<p>For serious users of the library, this is the elephant in the room.  Fidget is
using the same meshing strategy as <code>libfive</code>, but without a bunch of fine-tuning
that makes the latter more robust.</p>
<p>I haven&#39;t spent much time on this, because I&#39;m fundamentally unsatisfied with
the available options.  I would rather spend time implementing a bulletproof
meshing algorithm, rather than adding epicycles to dual contouring.
Unfortunately, I haven&#39;t seen anything in the literature that meets my
requirements, and haven&#39;t yet devised anything better myself.</p>
<p>We&#39;ll see how things shake out!  Depending on user demand, I would probably be
willing to do <em>some</em> fine-tuning, but also want to keep an eye out for better
options.</p>
<h3>Standard library of shapes and transforms</h3>
<p>Over the past few generations of software, I&#39;ve been porting the
<a href="https://kokompe.cba.mit.edu/downloads.html">Fab Modules</a>&#39;s
standard library of shapes into each new tool.  This is tedious, but gives a
somewhat-standard foundation for higher-level modeling.</p>
<p><code>libfive</code> hit a high point in complexity, where I wrote each shape in C++, then
automatically generated C, Python, and Scheme bindings from the header file.
The explanation in the
<a href="https://github.com/libfive/libfive/tree/master/libfive/stdlib">README</a>
has a certain &#34;statements dreamed up by the utterly deranged&#34; energy to it:</p>
<blockquote>
<p><code>libfive_stdlib.h</code> is both a C header and a structured document parsed by a
helper script.</p>
</blockquote>
<p>We&#39;re still brainstorming the right approach for Fidget; see
<a href="https://github.com/mkeeter/fidget/issues/145">fidget#145</a> for ongoing
discussions.
Dragging the fab shapes
library into Rust would work, but I&#39;m wondering if we can do better – for
example,
<a href="https://iquilezles.org/articles/distfunctions/">Inigo Quilez&#39;s library of primitives</a>
takes advantage of GLSL vectors to produce much more elegant code.</p>
<h3>Bindings to higher-level languages</h3>
<p>I&#39;m a big fan of wrapping interactive shells around a compiled core.  Right now,
Fidget only has bindings to <a href="https://rhai.rs">Rhai</a>, which was chosen because
it&#39;s one of the few mature Rust-first scripting languages.  Rhai has been very
easy to integrate (and I love that it compiles into WebAssembly), but I suspect
that most users would prefer Python or Node bindings.</p>
<p>Then, there&#39;s the question of <em>how</em> to write those bindings: a C API would let
people lean on the FFI libraries of their favorite languages, but feels like a
step down from Fidget&#39;s Rust-first design.  Similarly, once we have a standard
library (discussed above), it would be great for it to be automatically exposed
in each binding, with proper ergonomics (docstrings, default arguments, etc).</p>
<p>As always, feel free to reach out if you have thoughts!</p>
<h2>Conclusion</h2>
<p>Ever since initial publication, Fidget&#39;s <code>README</code> has described it as &#34;quietly
public&#34;; 19 versions have been published to
<a href="https://crates.io/crates/fidget">crates.io</a>,
and a few people have started to build on it,
but I haven&#39;t been talking about it outside of semi-private spaces.</p>
<p>This blog posts marks the end of the quietly public phase:
it&#39;s now <strong>loudly public</strong>.</p>
<p>Go try it out, build some stuff, tell your friends, and
<a href="https://www.mattkeeter.com/about#contact">let me know</a>
how it goes!</p>
<p>The source code is <a href="https://github.com/mkeeter/fidget">on Github</a>
and can be added to a Rust project with <code>cargo add fidget</code>.
It is released under a weak copyleft license
(<a href="https://github.com/mkeeter/fidget/blob/main/LICENSE.txt">MPL 2.0</a>),
which is friendly for both OSS and commercial usage.</p>
<p>Thanks to everyone who contributed to this post and the project as a whole:
Martin Galese,
Bruce Mitchener,
Avi Bryant,
Blake Courter,
Johnathon Selstad,
Bradley Rothenberg,
Moritz Mœller,
Luke V,
and various others in all the group chats.</p>

<!-- Begin footer -->
</div></div>
  </body>
</html>
