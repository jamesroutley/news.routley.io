<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://valberg.dk/django-sse-postgresql-listen-notify.html">Original</a>
    <h1>Writing a chat application in Django 4.2 using async StreamingHttpResponse</h1>
    
    <div id="readability-page-1" class="page"><div>
    <hr/>
<p>With the release of Django 4.2 we got the following <sup id="fnref:0"><a href="#fn:0">1</a></sup>:</p>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/4.2/ref/request-response/#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> now supports async iterators when Django is served via ASGI.</p>
</blockquote>
<p>And the documentation has been expanded with the following <sup id="fnref:1"><a href="#fn:1">2</a></sup>:</p>
<blockquote>
<p>When serving under ASGI, however, a <a href="https://docs.djangoproject.com/en/4.2/ref/request-response/#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> need not stop other requests from being served whilst waiting for I/O. This opens up the possibility of long-lived requests for streaming content and implementing patterns such as long-polling, and server-sent events.</p>
</blockquote>
<p>Being a sucker for simplicity I got quite intrigued by the possibility to serve
server-sent events (also known as SSE) from Django in an asynchronous manner.</p>
<p>So I set out to write a small, drumroll please, chat application!</p>
<p>This blog post documents my process of writing this application and how the bits
and pieces fit together.</p>
<p>The code for the chat application can be found at
<a href="https://github.com/valberg/django-sse">github.com/valberg/django-sse</a>.</p>
<p><strong>Table of contents</strong></p>

<h3 id="what-are-server-sent-events-and-why-do-we-want-to-use-them">What are server-sent events and why do we want to use them?</h3>
<p>Server-sent events is &#34;old tech&#34;, as in that is has been supported in major
browser since around 2010-2011 <sup id="fnref:2"><a href="#fn:2">3</a></sup>. The idea is that the client &#34;subscribes&#34; to
an HTTP endpoint, and the server can then issue data to the client as long as
the connection is open. This is a great performance boost compared to other
techniques as for instance polling the server.</p>
<p><em>But wait, isn&#39;t websockets &#34;shinier&#34;?</em></p>
<p>It depends. In many situations when it comes to developing web applications, we
just want a way to push data to the client, and here a bidirectional
connection like websockets feel like an overkill. Also, I would argue that using
POST/PUT requests from the client and SSE to the client might be &#34;just enough&#34;
compared to websockets.</p>
<p>SSE also has the added benefit of having a built-in reconnection mechanism, 
which is something we would have to implement ourselves with websockets.</p>
<p>All in all SSE is a much simpler solution than websockets, and in many (most?) 
cases that is all we need.</p>
<h3 id="a-simple-implementation-of-an-sse-endpoint">A simple implementation of an SSE endpoint</h3>
<p>So lets get to some code! </p>
<p>First we need our model for storing the chat messages:</p>
<div><pre><span></span><code><span>class</span> <span>ChatMessage</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span>
    <span>user</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>255</span><span>)</span>
    <span>text</span> <span>=</span> <span>models</span><span>.</span><span>CharField</span><span>(</span><span>max_length</span><span>=</span><span>255</span><span>)</span>
</code></pre></div>

<p>With the model defined we can write our view to stream the messages.</p>
<p>The following is something along the lines of my initial attempt. First we have
to define the view, which in fact will not change for the remainder of this
blog post. The juicy bits are in the  <code>stream_messages()</code> function. Note that
the view is an async view, denoted by the <code>async</code> keyword.</p>
<div><pre><span></span><code><span>async</span> <span>def</span> <span>stream_messages_view</span><span>(</span><span>request</span><span>:</span> <span>HttpRequest</span><span>)</span> <span>-&gt;</span> <span>StreamingHttpResponse</span><span>:</span>
    <span>return</span> <span>StreamingHttpResponse</span><span>(</span>
        <span>streaming_content</span><span>=</span><span>stream_messages</span><span>(),</span>
        <span>content_type</span><span>=</span><span>&#34;text/event-stream&#34;</span><span>,</span>
    <span>)</span>
</code></pre></div>

<p>We tell the <code>StreamingHttpResponse</code> class to get its streaming content from the
<code>stream_messages</code> function. The following is my first initial implementation of 
<code>stream_messages</code>:</p>
<div><pre><span></span><code><span>async</span> <span>def</span> <span>stream_messages</span><span>()</span> <span>-&gt;</span> <span>AsyncGenerator</span><span>[</span><span>str</span><span>,</span> <span>None</span><span>]:</span>
    <span>latest_message</span> <span>=</span> <span>None</span>

    <span>while</span> <span>True</span><span>:</span>
        <span>current_message</span> <span>=</span> <span>await</span> <span>ChatMessage</span><span>.</span><span>objects</span><span>.</span><span>order_by</span><span>(</span><span>&#34;-id&#34;</span><span>)</span><span>.</span><span>afirst</span><span>()</span>

        <span># If we have a new message yield that</span>
        <span>if</span> <span>latest_message</span> <span>!=</span> <span>current_message</span><span>:</span>
            <span>yield</span> <span>&#34;data: </span><span>{current_message.text}</span><span>\n\n</span><span>&#34;</span>
            <span>latest_message</span> <span>=</span> <span>current_message</span>

        <span>await</span> <span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>5</span><span>)</span>
</code></pre></div>

<p>So we&#39;ve gotten rid of the HTTP overhead of polling by not having to do a
request from the client every 5 seconds. But we are still doing a query to the
database every 5 seconds, and that for each client. This is not ideal and is 
probably something we could have done with a synchronous view.</p>
<p>Let&#39;s see if we can do better.</p>
<h3 id="more-old-tech-to-the-rescue-postgresql-listennotify">More old tech to the rescue: PostgreSQL LISTEN/NOTIFY</h3>
<p>This is where we could reach for more infrastructure which could help us giving
the database a break. This could be listening for data in Redis (this is what
django-channels does), or even having a queue in RabbitMQ. No matter what, it
is means more infrastructure.</p>
<p>But I use PostgreSQL - and PostgreSQL is, like Django, &#34;batteries included&#34;.</p>
<p>PostgreSQL has a mechanism called &#34;LISTEN/NOTIFY&#34; where a client can <code>LISTEN</code> 
to a &#34;channel&#34; and then other clients can <code>NOTIFY</code> on that same channel which
will be broadcasted to all listeners .</p>
<p>This seems like something we can use, but the good ol&#39; psycopg2 doesn&#39;t have async support, and I&#39;m not
even sure if <code>asgiref</code>&#39;s <code>sync_to_async</code><sup id="fnref:3"><a href="#fn:3">4</a></sup> would help us here.</p>
<h4 id="enter-psycopg-3">Enter psycopg 3</h4>
<p>I had put the whole thing on ice until I realized that another big thing (maybe
a bit bigger than StreamingHttpResponse) in Django 4.2 is the support for
psycopg 3 - and psycopg 3 is very much async!</p>
<p>So I went for a stroll in the psycopg 3 documentation and struck gold<sup id="fnref:4"><a href="#fn:4">5</a></sup>:</p>
<div><pre><span></span><code><span>import</span> <span>psycopg</span>
<span>conn</span> <span>=</span> <span>psycopg</span><span>.</span><span>connect</span><span>(</span><span>&#34;&#34;</span><span>,</span> <span>autocommit</span><span>=</span><span>True</span><span>)</span>
<span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;LISTEN mychan&#34;</span><span>)</span>
<span>gen</span> <span>=</span> <span>conn</span><span>.</span><span>notifies</span><span>()</span>
<span>for</span> <span>notify</span> <span>in</span> <span>gen</span><span>:</span>
    <span>print</span><span>(</span><span>notify</span><span>)</span>
    <span>if</span> <span>notify</span><span>.</span><span>payload</span> <span>==</span> <span>&#34;stop&#34;</span><span>:</span>
        <span>gen</span><span>.</span><span>close</span><span>()</span>
<span>print</span><span>(</span><span>&#34;there, I stopped&#34;</span><span>)</span>
</code></pre></div>

<p>This does almost what we want! It just isn&#39;t async and isn&#39;t getting connection
info from Django.</p>
<p>So by combining the snippet from the psycopg 3 documentation and my previous
<code>stream_messages</code> I came up with this:</p>
<div><pre><span></span><code><span>from</span> <span>collections.abc</span> <span>import</span> <span>AsyncGenerator</span>
<span>import</span> <span>psycopg</span>
<span>from</span> <span>django.db</span> <span>import</span> <span>connection</span>

<span>async</span> <span>def</span> <span>stream_messages</span><span>()</span> <span>-&gt;</span> <span>AsyncGenerator</span><span>[</span><span>str</span><span>,</span> <span>None</span><span>]:</span>

    <span># Get the connection params from Django</span>
    <span>connection_params</span> <span>=</span> <span>connection</span><span>.</span><span>get_connection_params</span><span>()</span>

    <span># Somehow Django 4.2.1 sets the cursor_factory to </span>
    <span># django.db.backends.postgresql.base.Cursor</span>
    <span># which causes problems. Read more about it in the </span>
    <span># &#34;Differences between 4.2 and 4.2.1&#34; section in the Appendix.</span>
    <span># Removing it from the connection parameters works around this.</span>
    <span>connection_params</span><span>.</span><span>pop</span><span>(</span><span>&#39;cursor_factory&#39;</span><span>)</span>

    <span>aconnection</span> <span>=</span> <span>await</span> <span>psycopg</span><span>.</span><span>AsyncConnection</span><span>.</span><span>connect</span><span>(</span>
        <span>**</span><span>connection_params</span><span>,</span>
        <span>autocommit</span><span>=</span><span>True</span><span>,</span>
    <span>)</span>

    <span>channel_name</span> <span>=</span> <span>&#34;lobby&#34;</span>

    <span>async</span> <span>with</span> <span>aconnection</span><span>.</span><span>cursor</span><span>()</span> <span>as</span> <span>acursor</span><span>:</span>
        <span>await</span> <span>acursor</span><span>.</span><span>execute</span><span>(</span><span>f</span><span>&#34;LISTEN </span><span>{</span><span>channel_name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>gen</span> <span>=</span> <span>aconnection</span><span>.</span><span>notifies</span><span>()</span>
        <span>async</span> <span>for</span> <span>notify</span> <span>in</span> <span>gen</span><span>:</span>
            <span>yield</span> <span>f</span><span>&#34;data: </span><span>{</span><span>notify</span><span>.</span><span>payload</span><span>}</span><span>\n\n</span><span>&#34;</span>
</code></pre></div>

<p>Appart from problems with the <code>cursor_factory</code> (which I&#39;ll get back to in the 
<a href="#difference-between-42-and-421">appendix</a>), this code is pretty straight forward and, most importantly, works!</p>
<p>Whenever a <code>NOTIFY lobby, &#39;&lt;message&gt;&#39;</code> is issued, the <code>stream_messages</code> function
will yield the message to the listener.</p>
<h3 id="test-the-endpoint-with-curl">Test the endpoint with curl</h3>
<p>So now we&#39;ve got the <code>LISTEN</code> part in place.</p>
<p>If we connect to the endpoint using curl (<code>-N</code> disables buffering and is a way to consume streming content with curl):</p>
<div><pre><span></span><code><span>$ </span>curl<span> </span>-N<span> </span>http://localhost:8000/messages/
</code></pre></div>

<p>And connect to our database and run:</p>
<div><pre><span></span><code><span>NOTIFY</span><span> </span><span>lobby</span><span>,</span><span> </span><span>&#39;Hello, world!&#39;</span><span>;</span>
</code></pre></div>

<p>We, excitingly, get the following result :</p>


<p>Amazing!</p>
<h3 id="issuing-the-notify-command-from-django">Issuing the NOTIFY command from Django</h3>
<p>But we want the <code>NOTIFY</code> command to be issued when a new chat message is submitted.</p>
<p>For this we&#39;ll have a small utility function which does the heavy lifting. Note
that this is just a very simple synchronous function since everything is just
happening within a single request-response cycle.</p>
<div><pre><span></span><code><span>from</span> <span>django.db</span> <span>import</span> <span>connection</span>


<span>def</span> <span>notify</span><span>(</span><span>*</span><span>,</span> <span>channel</span><span>:</span> <span>str</span><span>,</span> <span>event</span><span>:</span> <span>str</span><span>,</span> <span>payload</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>payload</span> <span>=</span> <span>json</span><span>.</span><span>dumps</span><span>({</span>
        <span>&#34;event&#34;</span><span>:</span> <span>event</span><span>,</span>
        <span>&#34;content&#34;</span><span>:</span> <span>payload</span><span>,</span>
    <span>})</span>
    <span>with</span> <span>connection</span><span>.</span><span>cursor</span><span>()</span> <span>as</span> <span>cursor</span><span>:</span>
        <span>cursor</span><span>.</span><span>execute</span><span>(</span>
            <span>f</span><span>&#34;NOTIFY </span><span>{</span><span>channel</span><span>}</span><span>, &#39;</span><span>{</span><span>payload</span><span>}</span><span>&#39;&#34;</span><span>,</span>
        <span>)</span>
</code></pre></div>

<p>And then we can use this in our view (I&#39;m using <code>@csrf_exempt</code> here since this is just a quick proof of concept):</p>
<div><pre><span></span><code><span>@csrf_exempt</span>
<span>@require_POST</span>
<span>def</span> <span>post_message_view</span><span>(</span><span>request</span><span>:</span> <span>HttpRequest</span><span>)</span> <span>-&gt;</span> <span>HttpResponse</span><span>:</span>
    <span>message</span> <span>=</span> <span>request</span><span>.</span><span>POST</span><span>.</span><span>get</span><span>(</span><span>&#34;message&#34;</span><span>)</span>
    <span>user</span> <span>=</span> <span>request</span><span>.</span><span>POST</span><span>.</span><span>get</span><span>(</span><span>&#34;user&#34;</span><span>)</span>
    <span>message</span> <span>=</span> <span>ChatMessage</span><span>.</span><span>objects</span><span>.</span><span>create</span><span>(</span><span>user</span><span>=</span><span>user</span><span>,</span> <span>text</span><span>=</span><span>message</span><span>)</span>
    <span>notify</span><span>(</span>
        <span>channel</span><span>=</span><span>&#34;lobby&#34;</span><span>,</span>
        <span>event</span><span>=</span><span>&#34;message_created&#34;</span><span>,</span>
        <span>content</span><span>=</span><span>json</span><span>.</span><span>dumps</span><span>({</span>
            <span>&#34;text&#34;</span><span>:</span> <span>message</span><span>.</span><span>text</span><span>,</span>
            <span>&#34;user&#34;</span><span>:</span> <span>message</span><span>.</span><span>user</span><span>,</span>
        <span>})</span>
    <span>)</span>
    <span>return</span> <span>HttpResponse</span><span>(</span><span>&#34;OK&#34;</span><span>)</span>
</code></pre></div>

<p>The keen observer will notice that we are storing the payload content as a JSON string within a JSON string.</p>
<p>This is because we have two recipients of the payload. The first is the <code>stream_messages</code> function which is going to
send the payload to the client with a <code>event</code>, and the second is the browser which is going to parse the payload and use
the <code>event</code> to determine what to do with the payload.</p>
<p>For this we&#39;ll have to update our <code>stream_messages</code> function as follows:</p>
<div><pre><span></span><code><span>async</span> <span>def</span> <span>stream_messages</span><span>()</span> <span>-&gt;</span> <span>AsyncGenerator</span><span>[</span><span>str</span><span>,</span> <span>None</span><span>]:</span>
    <span>connection_params</span> <span>=</span> <span>connection</span><span>.</span><span>get_connection_params</span><span>()</span>

    <span># Remove the cursor_factory parameter since I can&#39;t get</span>
    <span># the default from Django 4.2.1 to work.</span>
    <span># Django 4.2 didn&#39;t have the parameter and that worked.</span>
    <span>connection_params</span><span>.</span><span>pop</span><span>(</span><span>&#39;cursor_factory&#39;</span><span>)</span>

    <span>aconnection</span> <span>=</span> <span>await</span> <span>psycopg</span><span>.</span><span>AsyncConnection</span><span>.</span><span>connect</span><span>(</span>
        <span>**</span><span>connection_params</span><span>,</span>
        <span>autocommit</span><span>=</span><span>True</span><span>,</span>
    <span>)</span>
    <span>channel_name</span> <span>=</span> <span>&#34;lobby&#34;</span>
    <span>async</span> <span>with</span> <span>aconnection</span><span>.</span><span>cursor</span><span>()</span> <span>as</span> <span>acursor</span><span>:</span>
        <span>await</span> <span>acursor</span><span>.</span><span>execute</span><span>(</span><span>f</span><span>&#34;LISTEN </span><span>{</span><span>channel_name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>gen</span> <span>=</span> <span>aconnection</span><span>.</span><span>notifies</span><span>()</span>
        <span>async</span> <span>for</span> <span>notify</span> <span>in</span> <span>gen</span><span>:</span>
            <span>payload</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>notify</span><span>.</span><span>payload</span><span>)</span>
            <span>event</span> <span>=</span> <span>payload</span><span>.</span><span>pop</span><span>(</span><span>&#34;event&#34;</span><span>)</span>
            <span>data</span> <span>=</span> <span>payload</span><span>.</span><span>pop</span><span>(</span><span>&#34;data&#34;</span><span>)</span>
            <span>yield</span> <span>f</span><span>&#34;event: </span><span>{</span><span>event</span><span>}</span><span>\n</span><span>data: </span><span>{</span><span>data</span><span>}</span><span>\n\n</span><span>&#34;</span>
</code></pre></div>

<p>Everything is the same except that we now parse the payload from the <code>NOTIFY</code> command and construct the SSE payload with
an <code>event</code> and a <code>data</code> field. This will come in handy when dealing with the frontend.</p>
<p>Another way to do this would be to use Django&#39;s
<a href="https://docs.djangoproject.com/en/4.2/topics/signals/">signals</a> or event
writing a PostgreSQL
<a href="https://www.postgresql.org/docs/15/plpgsql-trigger.html">trigger</a> which issues
the <code>NOTIFY</code> command.</p>
<h3 id="hooking-up-the-frontend">Hooking up the frontend</h3>
<p>Now that we&#39;ve got the backend in place, we can get something up and running on
the frontend.</p>
<p>We could use HTMX&#39;s <a href="https://htmx.org/extensions/server-sent-events/">SSE
extension</a> but for this
example we&#39;ll just use the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">EventSource</a> API
directly.</p>
<div><pre><span></span><code><span>&lt;</span><span>template</span> <span>id</span><span>=</span><span>&#34;message&#34;</span><span>&gt;</span>
    <span>&lt;</span><span>div</span> <span>style</span><span>=</span><span>&#34;border: 1px solid black; margin: 5px; padding: 5px;&#34;</span><span>&gt;</span>
        <span>&lt;</span><span>strong</span> <span>class</span><span>=</span><span>&#34;user&#34;</span><span>&gt;&lt;/</span><span>strong</span><span>&gt;</span>: <span>&lt;</span><span>span</span> <span>class</span><span>=</span><span>&#34;message&#34;</span><span>&gt;&lt;/</span><span>span</span><span>&gt;</span>
    <span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>template</span><span>&gt;</span>

<span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;messages&#34;</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span>

<span>&lt;</span><span>script</span><span>&gt;</span>
<span>    </span><span>const</span><span> </span><span>source</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>EventSource</span><span>(</span><span>&#34;/messages/&#34;</span><span>);</span>

<span>    </span><span>// Note that the event we gave our notify utility function is called &#34;message_created&#34;</span>
<span>    </span><span>// so that&#39;s what we listen for here.</span>
<span>    </span><span>source</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;message_created&#34;</span><span>,</span><span> </span><span>function</span><span>(</span><span>evt</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>// Parse the payload</span>
<span>        </span><span>let</span><span> </span><span>payload</span><span> </span><span>=</span><span> </span><span>JSON</span><span>.</span><span>parse</span><span>(</span><span>evt</span><span>.</span><span>data</span><span>);</span>

<span>        </span><span>// Get and clone our template</span>
<span>        </span><span>let</span><span> </span><span>template</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;message&#39;</span><span>);</span>
<span>        </span><span>let</span><span> </span><span>clone</span><span> </span><span>=</span><span> </span><span>template</span><span>.</span><span>content</span><span>.</span><span>cloneNode</span><span>(</span><span>true</span><span>);</span>

<span>        </span><span>// Update our cloned template</span>
<span>        </span><span>clone</span><span>.</span><span>querySelector</span><span>(</span><span>&#39;.user&#39;</span><span>).</span><span>innerText</span><span> </span><span>=</span><span> </span><span>payload</span><span>.</span><span>user</span><span>;</span>
<span>        </span><span>clone</span><span>.</span><span>querySelector</span><span>(</span><span>&#39;.message&#39;</span><span>).</span><span>innerText</span><span> </span><span>=</span><span> </span><span>payload</span><span>.</span><span>text</span><span>;</span>

<span>        </span><span>// Append the cloned template to our list of messages</span>
<span>        </span><span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;messages&#39;</span><span>).</span><span>appendChild</span><span>(</span><span>clone</span><span>);</span>
<span>    </span><span>});</span>
<span>&lt;/</span><span>script</span><span>&gt;</span>
</code></pre></div>

<p>And that&#39;s it! We can now open two browser windows and see the messages appear in real time.</p>
<p>Check out the repo for the full code where I&#39;ve also added a simple form for submitting new messages.</p>
<h3 id="dealing-with-reconnections">Dealing with reconnections</h3>
<p>One of the nice things about SSE is that it will automatically reconnect if the connection is lost. It even has a
mechanism for dealing with the fact that the client might have missed some events while it was disconnected.</p>
<p>This is done by sending a <code>Last-Event-ID</code> header with the request. The value of this header is the <code>id</code> of the last
event that the client received. The server can then use this to determine which events to send to the client.</p>
<p>To deal with this we can expand on our <code>stream_messages</code> function and view as follows:</p>
<div><pre><span></span><code><span>async</span> <span>def</span> <span>stream_messages</span><span>(</span><span>last_id</span><span>:</span> <span>int</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span><span>)</span> <span>-&gt;</span> <span>AsyncGenerator</span><span>[</span><span>str</span><span>,</span> <span>None</span><span>]:</span>
    <span>connection_params</span> <span>=</span> <span>connection</span><span>.</span><span>get_connection_params</span><span>()</span>
    <span>connection_params</span><span>.</span><span>pop</span><span>(</span><span>&#39;cursor_factory&#39;</span><span>)</span>
    <span>aconnection</span> <span>=</span> <span>await</span> <span>psycopg</span><span>.</span><span>AsyncConnection</span><span>.</span><span>connect</span><span>(</span>
        <span>**</span><span>connection_params</span><span>,</span>
        <span>autocommit</span><span>=</span><span>True</span><span>,</span>
    <span>)</span>
    <span>channel_name</span> <span>=</span> <span>&#34;lobby&#34;</span>

    <span>if</span> <span>last_id</span><span>:</span>
        <span>messages</span> <span>=</span> <span>ChatMessage</span><span>.</span><span>objects</span><span>.</span><span>filter</span><span>(</span><span>id__gt</span><span>=</span><span>last_id</span><span>)</span>
        <span>async</span> <span>for</span> <span>message</span> <span>in</span> <span>messages</span><span>:</span>
            <span>yield</span> <span>f</span><span>&#34;id: </span><span>{</span><span>message</span><span>.</span><span>id</span><span>}</span><span>\n</span><span>event: message_created</span><span>\n</span><span>data: </span><span>{</span><span>message</span><span>.</span><span>as_json</span><span>()</span><span>}</span><span>\n\n</span><span>&#34;</span>

    <span>async</span> <span>with</span> <span>aconnection</span><span>.</span><span>cursor</span><span>()</span> <span>as</span> <span>acursor</span><span>:</span>
        <span>await</span> <span>acursor</span><span>.</span><span>execute</span><span>(</span><span>f</span><span>&#34;LISTEN </span><span>{</span><span>channel_name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>gen</span> <span>=</span> <span>aconnection</span><span>.</span><span>notifies</span><span>()</span>
        <span>async</span> <span>for</span> <span>notify</span> <span>in</span> <span>gen</span><span>:</span>
            <span>payload</span> <span>=</span> <span>json</span><span>.</span><span>loads</span><span>(</span><span>notify</span><span>.</span><span>payload</span><span>)</span>
            <span>event</span> <span>=</span> <span>payload</span><span>.</span><span>get</span><span>(</span><span>&#34;event&#34;</span><span>)</span>
            <span>event_id</span> <span>=</span> <span>payload</span><span>.</span><span>get</span><span>(</span><span>&#34;event_id&#34;</span><span>)</span>
            <span>data</span> <span>=</span> <span>payload</span><span>.</span><span>get</span><span>(</span><span>&#34;data&#34;</span><span>)</span>
            <span>yield</span> <span>f</span><span>&#34;id: </span><span>{</span><span>event_id</span><span>}</span><span>\n</span><span>event: </span><span>{</span><span>event</span><span>}</span><span>\n</span><span>data: </span><span>{</span><span>data</span><span>}</span><span>\n\n</span><span>&#34;</span>


<span>async</span> <span>def</span> <span>stream_messages_view</span><span>(</span>
    <span>request</span><span>:</span> <span>HttpRequest</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>StreamingHttpResponse</span><span>:</span>
    <span>last_id</span> <span>=</span> <span>request</span><span>.</span><span>headers</span><span>.</span><span>get</span><span>(</span><span>&#34;Last-Event-ID&#34;</span><span>)</span>
    <span>return</span> <span>StreamingHttpResponse</span><span>(</span>
        <span>streaming_content</span><span>=</span><span>stream_messages</span><span>(</span><span>last_id</span><span>=</span><span>last_id</span><span>),</span>
        <span>content_type</span><span>=</span><span>&#34;text/event-stream&#34;</span><span>,</span>
    <span>)</span>
</code></pre></div>

<p>We now send the <code>id</code> of each message, and whenever a (re)connection is made we check if the client sent a <code>Last-Event-ID</code>
and if so we send all messages with an <code>id</code> greater than that.</p>
<p>This change does also require some changes to our utility functions and model. Those are to be found in the git repo.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Django is boring, which is a good thing, to the degree where it is always the safe option. But with the advances in
async support it is becoming a viable, and shiny, option for doing real time stuff. Mix in some other solid and boring 
tech like PostgreSQL and SSE, and you end up with a very solid foundation for building real time applications.</p>
<h3 id="appendix">Appendix</h3>
<h4 id="how-to-run-asgi-applications-in-development">How to run ASGI applications in development</h4>
<p>One thing that took me some time to realise is that the Django runserver is not
capable of running async views returning <code>StreamingHttpResponse</code>.</p>
<p>Running the view with the builtin runserver results in the following error:</p>
<div><pre><span></span><code>.../django/http/response.py:514: Warning: StreamingHttpResponse must
consume asynchronous iterators in order to serve them synchronously. 
Use a synchronous iterator instead.
</code></pre></div>

<p>Fortunately Daphne, the ASGI server which was developed to power Django Channels, has an async runserver which we can use:</p>
<p>To set this up we&#39;ll have to install the <code>daphne</code> package, add <code>daphne</code> to the top of our installed apps, and set
the <code>ASGI_APPLICATION</code> setting to point to our ASGI application.</p>
<div><pre><span></span><code><span>INSTALLED_APPS</span> <span>=</span> <span>[</span>
    <span>&#34;daphne&#34;</span><span>,</span>
    <span>...</span>
    <span>&#34;chat&#34;</span><span>,</span>  <span># Our app</span>
<span>]</span>

<span>ASGI_APPLICATION</span> <span>=</span> <span>&#34;project.asgi.application&#34;</span>
</code></pre></div>

<p>Now we can just run <code>./manage.py runserver</code> as before and we are async ready!</p>
<h4 id="difference-between-42-and-421">Difference between 4.2 and 4.2.1</h4>
<p>The code worked initially in 4.2, but 4.2.1 fixed a regression regarding
setting a custom cursor in the database configuration.</p>
<p>In 4.2 we get this from <code>connection.get_connection_params()</code>:</p>
<div><pre><span></span><code><span>{</span>
<span>    </span><span>&#39;dbname&#39;</span><span>:</span><span> </span><span>&#39;postgres&#39;</span><span>,</span>
<span>    </span><span>&#39;user&#39;</span><span>:</span><span> </span><span>&#39;postgres&#39;</span><span>,</span>
<span>    </span><span>&#39;password&#39;</span><span>:</span><span> </span><span>&#39;postgres&#39;</span><span>,</span>
<span>    </span><span>&#39;host&#39;</span><span>:</span><span> </span><span>&#39;localhost&#39;</span><span>,</span>
<span>    </span><span>&#39;port&#39;</span><span>:</span><span> </span><span>5432</span><span>,</span>
<span>    </span><span>&#39;context&#39;</span><span>:</span><span> </span><span>&lt;</span><span>psycopg</span><span>.</span><span>adapt</span><span>.</span><span>AdaptersMap</span><span> </span><span>object</span><span> </span><span>at</span><span> </span><span>0x7f019cda7a60</span><span>&gt;</span><span>,</span>
<span>    </span><span>&#39;prepare_threshold&#39;</span><span>:</span><span> </span><span>None</span>
<span>}</span>
</code></pre></div>

<p>in 4.2.1 we get this:</p>
<div><pre><span></span><code><span>{</span>
<span>    </span><span>&#39;dbname&#39;</span><span>:</span><span> </span><span>&#39;postgres&#39;</span><span>,</span>
<span>    </span><span>&#39;client_encoding&#39;</span><span>:</span><span> </span><span>&#39;UTF8&#39;</span><span>,</span>
<span>    </span><span>&#39;cursor_factory&#39;</span><span>:</span><span> </span><span>&lt;</span><span>class</span><span> </span><span>&#39;django.db.backends.postgresql.base.Cursor&#39;</span><span>&gt;</span><span>,</span>
<span>    </span><span>&#39;user&#39;</span><span>:</span><span> </span><span>&#39;postgres&#39;</span><span>,</span>
<span>    </span><span>&#39;password&#39;</span><span>:</span><span> </span><span>&#39;postgres&#39;</span><span>,</span>
<span>    </span><span>&#39;host&#39;</span><span>:</span><span> </span><span>&#39;localhost&#39;</span><span>,</span>
<span>    </span><span>&#39;port&#39;</span><span>:</span><span> </span><span>&#39;5432&#39;</span><span>,</span>
<span>    </span><span>&#39;context&#39;</span><span>:</span><span> </span><span>&lt;</span><span>psycopg</span><span>.</span><span>adapt</span><span>.</span><span>AdaptersMap</span><span> </span><span>object</span><span> </span><span>at</span><span> </span><span>0x7f56464bcdd0</span><span>&gt;</span><span>,</span>
<span>    </span><span>&#39;prepare_threshold&#39;</span><span>:</span><span> </span><span>None</span>
<span>}</span>
</code></pre></div>

<p><code>django.db.backends.postgresql.base.Cursor</code> is not async iterable.</p>
<p>So we can probably try to set our own <code>cursor_factory</code> in settings:</p>
<div><pre><span></span><code><span>from</span> <span>psycopg</span> <span>import</span> <span>AsyncCursor</span>

<span>DATABASES</span> <span>=</span> <span>{</span>
    <span>&#39;default&#39;</span><span>:</span> <span>{</span>
        <span>&#39;ENGINE&#39;</span><span>:</span> <span>&#39;django.db.backends.postgresql&#39;</span><span>,</span>
        <span>&#39;NAME&#39;</span><span>:</span> <span>&#39;postgres&#39;</span><span>,</span>
        <span>&#39;USER&#39;</span><span>:</span> <span>&#39;postgres&#39;</span><span>,</span>
        <span>&#39;PASSWORD&#39;</span><span>:</span> <span>&#39;postgres&#39;</span><span>,</span>
        <span>&#39;HOST&#39;</span><span>:</span> <span>&#39;localhost&#39;</span><span>,</span>
        <span>&#39;PORT&#39;</span><span>:</span> <span>&#39;5432&#39;</span><span>,</span>
        <span>&#39;OPTIONS&#39;</span><span>:</span> <span>{</span>
            <span>&#34;cursor_factory&#34;</span><span>:</span> <span>AsyncCursor</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div>

<p>But alas. For some reason this does not work. I guess that Django does some
wrapping of the cursor - or maybe I&#39;ve just encountered a bug. The cursor is at
least not treated as an async cursor and thus we get the following error:</p>
<div><pre><span></span><code><span>.../django-sse/venv/lib/python3.11/site-packages/django/db/backends/utils.py:41: </span>
<span>RuntimeWarning: coroutine &#39;AsyncCursor.close&#39; was never awaited</span>

<span>  self.close()</span>

<span>RuntimeWarning: Enable tracemalloc to get the object allocation traceback</span>

<span>.../django-sse/venv/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1560:</span>
<span>RuntimeWarning: coroutine &#39;AsyncCursor.execute&#39; was never awaited</span>

<span>  cursor.execute(sql, params)</span>

<span>RuntimeWarning: Enable tracemalloc to get the object allocation traceback</span>
</code></pre></div>

<p>So instead I opted for removing the <code>cursor_factory</code> in the streaming function.
So that now looks like so:</p>
<div><pre><span></span><code><span>async</span> <span>def</span> <span>stream_messages</span><span>()</span> <span>-&gt;</span> <span>AsyncGenerator</span><span>[</span><span>str</span><span>,</span> <span>None</span><span>]:</span>
    <span>connection_params</span> <span>=</span> <span>connection</span><span>.</span><span>get_connection_params</span><span>()</span>
    <span>connection_params</span><span>.</span><span>pop</span><span>(</span><span>&#39;cursor_factory&#39;</span><span>)</span>
    <span>aconnection</span> <span>=</span> <span>await</span> <span>psycopg</span><span>.</span><span>AsyncConnection</span><span>.</span><span>connect</span><span>(</span>
        <span>**</span><span>connection_params</span><span>,</span>
        <span>autocommit</span><span>=</span><span>True</span><span>,</span>
    <span>)</span>
    <span>channel_name</span> <span>=</span> <span>&#34;lobby&#34;</span>
    <span>async</span> <span>with</span> <span>aconnection</span><span>.</span><span>cursor</span><span>()</span> <span>as</span> <span>acursor</span><span>:</span>
        <span>print</span><span>(</span><span>type</span><span>(</span><span>acursor</span><span>))</span>
        <span>await</span> <span>acursor</span><span>.</span><span>execute</span><span>(</span><span>f</span><span>&#34;LISTEN </span><span>{</span><span>channel_name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>gen</span> <span>=</span> <span>aconnection</span><span>.</span><span>notifies</span><span>()</span>
        <span>async</span> <span>for</span> <span>notify</span> <span>in</span> <span>gen</span><span>:</span>
            <span>yield</span> <span>f</span><span>&#34;data: </span><span>{</span><span>notify</span><span>.</span><span>payload</span><span>}</span><span>\n\n</span><span>&#34;</span>
</code></pre></div>


  </div></div>
  </body>
</html>
