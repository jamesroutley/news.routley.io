<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/writing/building-large-technical-projects">Original</a>
    <h1>My approach to building large technical projects (2023)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Whether it&#39;s building a new project from scratch, implementing a big feature,
or beginning a large refactor, it can be difficult to stay motivated and
complete large technical projects. A method that works really well for me
is to continuously see real results and to order my work based on that.</p>
<p>We&#39;ve all experienced that feeling of excitement starting a new project.
The first few weeks you can&#39;t wait to get on the computer to work. Then
slowly over time you get distracted or make up excuses and work on it less.
If this is for real work, you forcibly slog your way to the finish line but
every day is painful. If this is for fun, you look back years from now and
remember what could&#39;ve been.</p>
<p>I&#39;ve learned that when I break down my large tasks in chunks that result
in seeing tangible forward progress, I tend to finish my work and retain
my excitement throughout the project. People are all motivated and driven
in different ways, so this may not work for you, but as a broad generalization
I&#39;ve not found an engineer who doesn&#39;t get excited by a good demo. And the
goal is to always give yourself a good demo.</p>
<p>I&#39;m not claiming that anything I say in this post is novel. It definitely
shares various aspects of well-known software engineering or management
practices. I&#39;m just sharing the way I approach the larger technical work
that I do and why I do it this way.</p>
<p>I&#39;ll use <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/mitchellh/status/1662217955424493570">my terminal emulator project</a>
as an example throughout this post so that there is realistic, concrete
experience I can share. There&#39;s plenty of other projects I could&#39;ve used but
I&#39;ll choose this one since it&#39;s not related to my professional work and
it is recent enough to be fresh in my mind.</p>
<div><p>I want to be crystal clear that I am not shaming anyone for not completing
projects. As long as you&#39;re having fun and feel accomplished (or simply don&#39;t
care), good for you and more power to you. This blog post is aimed
at people who <em>want to finish projects more</em> or simply want to learn how
I strive to finish projects more.</p></div>
<hr/>

<p>Initially, you have some large project and you have to figure <em>how to start</em>.
For me, this is the hardest part and I can spend hours
-- sometimes days -- waffling over the right starting point.</p>
<p>For my terminal emulator, there were a number of large components that
I knew would have to exist if I ever intended to finish this project:
terminal parsing, running and managing a shell process, font rendering,
grid rendering, input handling (keyboard/mouse), etc. There are hundreds
of relatively large sub-projects on the path to &#34;done.&#34;</p>
<p>If my initial goal was to see a launchable terminal that could run Neovim,
I&#39;d be in big trouble. Even with <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/There_are_unknown_unknowns">unknown unknowns</a>,
this goal just <em>sounds too big</em>. I can intuitively realize that
there are a lot of components on that path: rendering a GUI, process launching,
terminal parsing and state management. This is a bad goal, it&#39;s too big and
I&#39;d probably lose interest a month or two in.</p>
<p>Instead, I try to think what a <em>realistic</em> project is where I can
<em>see results as soon as possible</em>. Once you apply that filter, the number
of viable sub-projects shrinks dramatically. Here are some examples:</p>
<ul>
<li>VT Parsing - parsing the terminal escape sequences</li>
<li>Blank window rendering - open a window and draw a blank canvas</li>
<li>Child process lanching - launch a child shell such as bash, zsh, fish,
setup the TTY and be able to read output from it (i.e. the initial
shell prompt)</li>
</ul>
<p>I don&#39;t try to enumerate all the big sub-projects at this stage. I just
kind of get an idea of the <em>rough shape</em> the project will take and find
one that I can build in isolation and also physically see some sort of
real results.</p>
<div><p>This is the phase where experience helps the most. Engineers with
more experience are usually able to more effectively paint the picture
of the rough shape a project will take. They can identify various
subcomponents with more accuracy and see how they pieces fit together.
With less experience, or in a domain I&#39;m unfamiliar with, I just take
a best guess and expect there is a higher likelihood I&#39;ll throw my work
away at some point.</p></div>
<hr/>

<p>Early work tends to not be very <em>visible</em> and that makes seeing
tangible results seem difficult. For example, if I chose to work on
VT parsing for my terminal, I can&#39;t <em>see</em> it work without also hooking up
a UI of some sort. Or for some other project if I chose to work on a
database schema and minimal API, I similarly can&#39;t see that work without
writing a client along with a CLI or GUI.</p>
<p>If the initial subproject you choose to work on is a UI, then you can
quickly see some results of course! For various reasons, I rarely start
frontend first and usually start backend first. And in any situation, you&#39;ll
eventually get to the backend and reach a similar challenge.</p>
<p>The best tool to get past this phase is automated testing (usually unit
testing at this stage). Automated tests let you actually run some code and
see it is working and also has the benefit of being good hygiene.</p>
<p>This gives you another guiding point for picking out your first few tasks:
if it isn&#39;t graphical, you want to pick something that is testable without
too much fuss so you can see some results.</p>
<p>For my terminal, I decided to start with VT parsing first, because it
was a part of a terminal at the time that I didn&#39;t know too much about and
it felt like something that I could very easily test: give it some example
input as a string, expect some parsed action or event as output.</p>
<p>Seeing the progression of &#34;1 test passed&#34;, &#34;4 tests passed,&#34; &#34;13 tests passed&#34;
and so on is super exciting to me. I&#39;m running some code I wrote <em>and it&#39;s
working</em>. And I know that I&#39;m progressing on some critical sub-component of
a larger project.</p>
<hr/>

<p>My goal with the early sub-projects isn&#39;t to build a <em>finished sub-component</em>,
it is to build a <em>good enough sub-component</em> so I can move on to the next
thing on the path to a <em>demo</em>. âœ¨</p>
<p>This tradeoff isn&#39;t just manifested in functionality. It may be manifested
in algorithmic or design considerations. For example, you may know that
in the future, you&#39;ll need to use something like a real database or a fancy
data structure or support streaming data. But for the initial set of work,
you can just use in-memory contents, built-in data structures such as
dictionaries, and require all your inputs/outputs up front.</p>
<p>I think this is an important tradeoff so I will repeat it: <strong>do not let
perfection be an enemy of progress.</strong> Going further, do not let future
improvements you <em>know you&#39;ll have to make</em> stop you from moving on to
the next thing. The goal is to get to a demo.</p>
<p>No matter what I&#39;m working on, I try to build one or two demos per week
intermixed with automated test feedback as explained in the previous section.</p>
<p>Building a demo also provides you with invaluable product feedback. You
can quickly intuit whether something <em>feels good</em>, even if it isn&#39;t fully
functional. These aren&#39;t &#34;minimum viable products&#34;, because they really aren&#39;t
viable, but they&#39;re good enough to provide an engineer some valuable
self-reflection.</p>
<div><p>This is an area where I think experience actually hurts. I&#39;ve seen senior
engineers get bogged down building the perfect thing and by the time
they get a demo, they realize <em>it sucks</em>. The implementation doesn&#39;t suck,
but the product or feature itself actually sucks.</p></div>
<p>Recall that for the terminal the first task I chose was VT parsing. In
the early stages, I only saw automated tests work. To get to my first demo,
I built a shell script that would run some command, capture its output,
feed it to my VT parser, and output everything it parsed (or couldn&#39;t).
Over time, I iterated on this CLI as my first &#34;UI&#34; -- I would render
the terminal grid using ASCII.</p>
<p>This gave me immense satisfaction since I could run simple programs like
<code>man</code> or <code>ls</code> or more complex programs like <code>vim</code> and see my parser work (or break,
which is equally exciting in its own way).</p>
<p>In this scenario, the CLI I was writing was relatively useless long term
(I ended up throwing it away rather quickly). But the day or two I spent
building it as a demo provided me with an important feeling of progress and
<em>seeing</em> something work helped keep me motivated.</p>
<hr/>

<p>This section will apply more to personal projects than to work-assigned
projects. Even if you aspire to release some software for others, build
<em>only what you need as you need it</em> and <em>adopt your software as quickly
as possible</em>.</p>
<p>I&#39;m always more motivated working on a problem I&#39;m experiencing myself<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>.
And if a product designed for you doesn&#39;t work for you, it&#39;s very likely
not going to work well for others, either.
Therefore, my path from demos to an actual real-world usable product is
to find the shortest path to building only the functionality I think I need.</p>
<p>For my terminal, that meant first being able to load my shell configuration
(fish) and from there being able to launch and use Neovim. So I beelined
all my work to only the functionality needed for that: only the escape
sequences those programs used, only rendering the font I use daily, etc.
Examples of features I initially omitted: scrolling, mouse selection,
search, tabs/splits, etc.</p>
<p>Then I started using my terminal as a daily driver. This step usually
has a few false starts; you realize you actually need some feature
you omitted or forgot. In my initial runs of my terminal, I realized my
arrow keys didn&#39;t do anything, there were subtle (but workflow-breaking)
rendering bugs, etc. So I&#39;d go abandon using it, but it gave me tangible
tasks to work on next.</p>
<p>Additionally, I always feel a lot of pride using software with code
that I wrote and that usually helps keep me motivated to continue
working on it.</p>
<hr/>

<ol>
<li>
<p>Decompose a large problem into smaller problems. Importantly,
each small problem must have some clear way you can see the results
of your work.</p>
</li>
<li>
<p>Only solve the smaller problem enough to progress on a demo-aspect
of the larger problem, then move on to the next small problem.</p>
</li>
<li>
<p>Only solve enough small problems to be able to begin building
runnable demos of your software, then continue to iterate on more
functionality. Make demos as frequently as you can.</p>
</li>
<li>
<p>Prioritize functionality that enables you to adopt your own software,
if applicable (a personal project, a work project solving a problem
you actually have, etc.). Then continue to solve your own problems first.</p>
</li>
<li>
<p>Go back and iterate on each component as needed for future improvements,
repeating this process as needed.</p>
</li>
</ol>
<hr/>

<p>And that&#39;s pretty much it. I&#39;ve followed this general pattern on personal
projects, group projects, work projects, school projects, etc. and it&#39;s
how I keep myself motivated<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>.</p>
<p>Note that I didn&#39;t mention a lot of things! I don&#39;t talk about shipping.
I know a lot of people find shipping motivational. I don&#39;t think you need
to ship a project for it to be successful. And for me, I find shipping
too big of an event to motivate me long-term. I don&#39;t talk about tooling
(Git workflows, CI, etc.). I&#39;ve used my process across multiple jobs and fit
it into whatever process is established. And so on.</p>
<p>I think that helps show how much of a <em>personal process</em> this is. Everyone
I think needs to find some process to reinforce their motivation in a healthy
way. I realized seeing results motivates me really strongly, I&#39;ve
built my work style around that, and it has worked well for me thus far.</p>
</div></div>
  </body>
</html>
