<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shipilev.net/jvm/anatomy-quarks/10-string-intern/">Original</a>
    <h1>JVM Anatomy Quark #10: String.intern (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>But what would trigger the most dramatic consequence of native String table is that it is the part of GC roots! Which means, it should be scanned/updated by the garbage collector specially. In OpenJDK, that means doing hard work during the pause. Indeed, for <a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Shenandoah</a> where pauses depend mostly on GC root set size, having just 1M records in String table yields this:</p>
<div>
<div>
<pre><code>$ ... StringIntern -p size=1000000 --jvmArgs &#34;-XX:+UseShenandoahGC -Xlog:gc+stats -Xmx1g -Xms1g&#34;
...
Initial Mark Pauses (G)    = 0.03 s (a = 15667 us) (n = 2) (lvls, us = 15039, 15039, 15039, 15039, 16260)
Initial Mark Pauses (N)    = 0.03 s (a = 15516 us) (n = 2) (lvls, us = 14844, 14844, 14844, 14844, 16088)
  Scan Roots               = 0.03 s (a = 15448 us) (n = 2) (lvls, us = 14844, 14844, 14844, 14844, 16018)
    S: Thread Roots        = 0.00 s (a =    64 us) (n = 2) (lvls, us =    41,    41,    41,    41,    87)
    S: String Table Roots  = 0.03 s (a = 13210 us) (n = 2) (lvls, us = 12695, 12695, 12695, 12695, 13544)
    S: Universe Roots      = 0.00 s (a =     2 us) (n = 2) (lvls, us =     2,     2,     2,     2,     2)
    S: JNI Roots           = 0.00 s (a =     3 us) (n = 2) (lvls, us =     2,     2,     2,     2,     4)
    S: JNI Weak Roots      = 0.00 s (a =    35 us) (n = 2) (lvls, us =    29,    29,    29,    29,    42)
    S: Synchronizer Roots  = 0.00 s (a =     0 us) (n = 2) (lvls, us =     0,     0,     0,     0,     0)
    S: Flat Profiler Roots = 0.00 s (a =     0 us) (n = 2) (lvls, us =     0,     0,     0,     0,     0)
    S: Management Roots    = 0.00 s (a =     1 us) (n = 2) (lvls, us =     1,     1,     1,     1,     1)
    S: System Dict Roots   = 0.00 s (a =     9 us) (n = 2) (lvls, us =     8,     8,     8,     8,    11)
    S: CLDG Roots          = 0.00 s (a =    75 us) (n = 2) (lvls, us =    68,    68,    68,    68,    81)
    S: JVMTI Roots         = 0.00 s (a =     0 us) (n = 2) (lvls, us =     0,     0,     0,     0,     1)</code></pre>
</div>
</div>
<p>So, you have +13 ms per pause <em>just because</em> we decided to put more stuff in the root set.</p>
<p>This prompts some GC implementations to only do the String table cleanups when something heavy is also done. For example, it makes little sense from JVM perspective to clean String table if classes were not unloaded — because loaded classes are the major sources of interned Strings. So, this workload would exhibit interesting behaviors at least in G1 and CMS:</p>
<div>
<div>
<pre><code data-lang="java">public class InternMuch {
  public static void main(String... args) {
    for (int c = 0; c &lt; 1_000_000_000; c++) {
      String s = &#34;&#34; + c + &#34;root&#34;;
      s.intern();
    }
  }
}</code></pre>
</div>
</div>
<p>Running with CMS:</p>
<div>
<div>
<pre><code data-lang="shell">$ java -XX:+UseConcMarkSweepGC -Xmx2g -Xms2g -verbose:gc -XX:StringTableSize=6661443 InternMuch

GC(7) Pause Young (Allocation Failure) 349M-&gt;349M(989M) 357.485ms
GC(8) Pause Initial Mark 354M-&gt;354M(989M) 3.605ms
GC(8) Concurrent Mark
GC(8) Concurrent Mark 1.711ms
GC(8) Concurrent Preclean
GC(8) Concurrent Preclean 0.523ms
GC(8) Concurrent Abortable Preclean
GC(8) Concurrent Abortable Preclean 935.176ms
GC(8) Pause Remark 512M-&gt;512M(989M) 512.290ms
GC(8) Concurrent Sweep
GC(8) Concurrent Sweep 310.167ms
GC(8) Concurrent Reset
GC(8) Concurrent Reset 0.404ms
GC(9) Pause Young (Allocation Failure) 349M-&gt;349M(989M) 369.925ms</code></pre>
</div>
</div>
<p>So far so relatively good. Walking the overloaded String table takes a while. But the most damning thing would be to disable class unloading with <code>-XX:-ClassUnloading</code>. This <a href="http://hg.openjdk.java.net/jdk9/jdk9/hotspot/file/385668275400/src/share/vm/gc/cms/concurrentMarkSweepGeneration.cpp#l2559">effectively</a> <a href="http://hg.openjdk.java.net/jdk9/jdk9/hotspot/file/385668275400/src/share/vm/gc/cms/concurrentMarkSweepGeneration.cpp#l5239">disables</a> String table cleanup in regular GC cycles! You can guess what happens next:</p>
<div>
<div>
<pre><code data-lang="shell">$ java -XX:+UseConcMarkSweepGC -Xmx2g -Xms2g -verbose:gc -XX:-ClassUnloading -XX:StringTableSize=6661443 InternMuch

GC(11) Pause Young (Allocation Failure) 273M-&gt;308M(989M) 338.999ms
GC(12) Pause Initial Mark 314M-&gt;314M(989M) 66.586ms
GC(12) Concurrent Mark
GC(12) Concurrent Mark 175.625ms
GC(12) Concurrent Preclean
GC(12) Concurrent Preclean 0.539ms
GC(12) Concurrent Abortable Preclean
GC(12) Concurrent Abortable Preclean 2549.523ms
GC(12) Pause Remark 696M-&gt;696M(989M) 133.920ms
GC(12) Concurrent Sweep
GC(12) Concurrent Sweep 175.949ms
GC(12) Concurrent Reset
GC(12) Concurrent Reset 0.463ms
GC(14) Pause Full (Allocation Failure) 859M-&gt;0M(989M) 1541.465ms  &lt;---- !!!
GC(13) Pause Young (Allocation Failure) 859M-&gt;0M(989M) 1541.515ms</code></pre>
</div>
</div>
<p>Full STW GC, my old friend. For CMS, there is <code>ExplicitGCInvokesConcurrentAndUnloadsClasses</code> that kinda alleviates that, assuming user will call <code>System.gc()</code> sometimes.</p>
</div></div>
  </body>
</html>
