<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brianmckenna.org/blog/architecture_code">Original</a>
    <h1>Architecture diagrams should be code</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>For the past few years I’ve been the most senior developer on my teams in Atlassian, in both position (Principal Engineer) and time (almost 9 <em>years</em>) - this means I usually take on the responsibility of managing our software architecture.</p>
<p>Architecture is the relationships between systems, which can be fairly tricky to talk about. Probably the best form of communication is a diagram, with boxes representing systems (or components) and lines representing relationships between them. This can still have issues.</p>
<p>When my previous engineering manager joined the Atlassian Marketplace team, he asked everyone to draw an architecture diagram. Each came out extremely different. The people focused on frontend had things like Jira, Embedded Marketplace, Commerce, Provisioning, Atlassian Connect, then an arrow to a huge box - just labelled <em>Marketplace backend</em>.</p>
<p><img src="http://brianmckenna.org/blog/static/images/c4_code_frontend.png"/></p>
<p>The people focused on backend had the reverse - a huge box just labelled <em>frontend</em>!</p>
<p><img src="http://brianmckenna.org/blog/static/images/c4_code_backend.png"/></p>
<!--
@startuml
!include  [https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml](https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml "‌")

title Marketplace from frontend view

AddElementTag("highlight", $bgColor="orange")

System(emcee, "Embedded Marketplace")
System(jira, "Jira")
System(commerce, "Commerce")
System(provisioning, "Provisioning")
System(upm, "Universal Plugin Manager")
System(tcs, "Tenant Context Service")
System(marketplace, "Marketplace BACKEND", $tags="highlight")

Rel(jira, emcee, "Embeds")
Rel(emcee, marketplace, "Fetches app details")
Rel(emcee, commerce, "Fetches pricing")
Rel(emcee, upm, "Triggers install")
Rel(upm, provisioning, "Triggers license")
Rel(provisioning, tcs, "Creates license")
Rel(upm, tcs, "Polls license")

SHOW_LEGEND()
@enduml

@startuml
!include  [https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml](https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml "‌")

title Marketplace from frontend view

AddElementTag("highlight", $bgColor="orange")

System(marketplace, "Marketplace")
System(commerce, "Commerce")
System(hams, "HAMS")
System(identity, "Atlassian Identity")
System(pako, "People Atlassian Knows Of")
System(frontend, "Marketplace FRONTEND", $tags="highlight")
System(algolia, "Algolia")
System(upm, "Universal Plugin Manager")

Rel(marketplace, commerce, "Fetches pricing")
Rel(marketplace, hams, "Fetches legacy pricing")
Rel(marketplace, identity, "Fetches users")
Rel(marketplace, pako, "Queries reports")
Rel(marketplace, algolia, "Searches")
Rel(frontend, marketplace, "Queries")
Rel(upm, marketplace, "Queries")

SHOW_LEGEND()

@enduml
-->
<p>Actual relationships do exist between systems (e.g. network calls, shared storage) but an architecture diagram can’t give all details without becoming the code it’s meant to represent. That means all architecture diagrams are <em>views</em> into an abstraction. It’s not wrong to have a big box representing your backend; it’s just one way of viewing an abstraction.</p>
<p>Some teams and projects will have a diagram and point to it as “here is <em>the</em> architecture” - but it’s not <em>the</em> architecture, it’s just one particular view.</p>
<p>Ideally, we’d have dozens of architecture diagrams - from various views, from various proposals, from various teams. We don’t see this very much and I think part of the problem is that architecture diagrams can be costly.</p>
<p>Most diagramming tools require you to use the mouse, pointing and clicking and dragging and drawing. They can be very fiddly and even buggy; e.g. there’s one architecture diagram for Atlassian Marketplace with an old outdated box that can’t be deleted using the software it was diagrammed in, it just won’t allow that, for some reason.</p>
<p>If someone adds a relationship to a new system, will they even remember to visit the Confluence page to click and drag and draw over the architecture diagrams?</p>
<p>Maybe we should write architecture diagrams using code instead. With code, we can update architecture diagrams within a pull request, version them and quickly modify many of them at once.</p>
<p>We can also add some formality. Instead of modelling things with lines and boxes, we can directly model systems and relationships.</p>
<p>The <a href="https://c4model.com/" title="‌">C4 Model</a> formalises architecture into 4 abstractions: system context, containers, components and code. I only use system context and containers; components and code are too detailed. A container is something which runs, such as an application server, database, filesystem, etc. A system represents some group of software, and it can have containers which that software is deployed within.</p>
<p>There are a bunch of tools for using C4. There are two which you might have already used for other things, such as PlantUML and Mermaid. One of the above images was generated from this PlantUML code:</p>
<pre><code>@startuml
!include  https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

title Marketplace from backend view

AddElementTag(&#34;highlight&#34;, $bgColor=&#34;orange&#34;)

System(marketplace, &#34;Marketplace&#34;)
System(commerce, &#34;Commerce&#34;)
System(hams, &#34;HAMS&#34;)
System(identity, &#34;Atlassian Identity&#34;)
System(pako, &#34;People Atlassian Knows Of&#34;)
System(frontend, &#34;Marketplace FRONTEND&#34;, $tags=&#34;highlight&#34;)
System(algolia, &#34;Algolia&#34;)
System(upm, &#34;Universal Plugin Manager&#34;)

Rel(marketplace, commerce, &#34;Fetches pricing&#34;)
Rel(marketplace, hams, &#34;Fetches legacy pricing&#34;)
Rel(marketplace, identity, &#34;Fetches users&#34;)
Rel(marketplace, pako, &#34;Queries reports&#34;)
Rel(marketplace, algolia, &#34;Searches&#34;)
Rel(frontend, marketplace, &#34;Queries&#34;)
Rel(upm, marketplace, &#34;Queries&#34;)

SHOW_LEGEND()

@enduml</code></pre>
<p>But instead of writing PlantUML, I use Haskell to model architecture. A simple example would look like:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>AtlassianSystem</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Marketplace</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Identity</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Pako</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Ord</span>, <span>Show</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>AtlassianTechnology</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>REST</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>SQL</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Ord</span>, <span>Show</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span>marketplaceSystem ::</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span>SoftwareSystem</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span>AtlassianSystem</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    ()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span>AtlassianTechnology</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    ()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>marketplaceSystem <span>=</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  softwareSystem</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span>&amp;</span> relationships <span>.</span> at <span>Identity</span> <span>?~</span> relationship <span>REST</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span>&amp;</span> relationships <span>.</span> at <span>Pako</span> <span>?~</span> relationship <span>SQL</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span>marketplace ::</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span>Model</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    ()</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    ()</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span>AtlassianSystem</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    ()</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span>AtlassianTechnology</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    ()</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>marketplace <span>=</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>  model</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span>&amp;</span> softwareSystems <span>.</span> at <span>Marketplace</span> <span>?~</span> marketplaceSystem</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span>&amp;</span> softwareSystems <span>.</span> at <span>Identity</span> <span>?~</span> softwareSystem</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span>&amp;</span> softwareSystems <span>.</span> at <span>Pako</span> <span>?~</span> softwareSystem</span></code></pre></div>
<p>And the Haskell library can spit out PlantUML from this model. There’s a few checks which can be implemented on this model, e.g. do any components reference systems which their container doesn’t?</p>
<p>Going further into code, most systems have a consistent way of communicating with services. Atlassian has a Service Proxy to handle common service to service communication. When configuring Service Proxy, you give it a list of services that your service depends on. We can easily write some Haskell which takes that configuration and spits out a C4 Model, allowing us to create a bunch of diagrams.</p>
<p>We can also generate a model from running tests. Each test can generate a sequence diagram using something like <a href="https://github.com/sonyxperiadev/dataflow">DataFlow</a>. Collecting the systems used in all tests can generate a C4 system context and container diagram for our whole system. Here’s an example sequence diagram generated by running a single test:</p>
<p><img src="https://brianmckenna.org/blog/static/create-vendor-and-app.png"/></p>
<p>I’m pretty convinced that we should be using code to generate architecture diagrams. Code allows making quick changes. Architecture code can be versioned with the code which implements it. We can write algorithms to check our architecture. I’d like to see more tools available to describe architecture as part of code, allowing us to generate as many diagrams as we want, for accurate and easy communication.</p>
<p>Do you use code to diagram architecture? Do you do something other than just write PlantUML or Mermaid, by hand? I’d love to hear more!</p>
  </div></div>
  </body>
</html>
