<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.galois.com/articles/introducing-grease">Original</a>
    <h1>Grease: An Open-Source Tool for Uncovering Hidden Vulnerabilities in Binary Code</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Proactively and defensively ensuring the absence of vulnerabilities in binary code is crucial for deploying high-assurance systems. <a href="https://galoisinc.github.io/grease/">GREASE</a> is an open-source tool leveraging under-constrained symbolic execution to help software reverse engineers analyze binaries and uncover hard-to-spot bugs, ultimately enhancing system security. This kind of binary analysis is especially important for systems that include COTS software that is only provided in binary form.</p><figure><p><img src="https://cdn.prod.website-files.com/673b407e535dbf3b547179ff/67db0a06d42ee05b2a38b28b_GREASE%20Logo%20-%20Transparent.png" loading="lazy" alt=""/></p></figure><p>‍</p><p>GREASE can be used as a plug-in for the <a href="https://ghidra-sre.org/">Ghidra</a> reverse engineering framework, as a standalone command-line tool, or as a Haskell library. GREASE supports analysis of AArch32, PPC32, PPC64, and x86_64 Linux ELF binaries, as well as LLVM bitcode.</p><h2>Demo</h2><p>GREASE can help software reverse engineers discover bugs in binaries. For example, consider the following code derived from <a href="http://www.libpng.org/pub/png/libpng.html">libpng</a>, demonstrating <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-13785">CVE-2018-13785</a>. Even at the source level, the bug is hard to spot. Can you see it? (Don’t worry about studying the code in detail, it won’t be necessary for understanding the rest of this post.)</p><pre contenteditable="false"><code><span>void</span><span> </span><span>/* PRIVATE */</span><span>
</span><span></span><span>png_check_chunk_length</span><span>(</span><span>png_const_structrp png_ptr, </span><span>const</span><span> unsigned int length</span><span>)</span><span>
</span>{
   png_alloc_size_t limit = PNG_UINT_31_MAX;

# ifdef PNG_SET_USER_LIMITS_SUPPORTED
<span>   </span><span>if</span><span> (png_ptr-&gt;user_chunk_malloc_max &gt; </span><span>0</span><span> &amp;&amp;
</span>       png_ptr-&gt;user_chunk_malloc_max &lt; limit)
      limit = png_ptr-&gt;user_chunk_malloc_max;
<span># elif PNG_USER_CHUNK_MALLOC_MAX &gt; </span><span>0</span><span>
</span><span>   </span><span>if</span><span> (PNG_USER_CHUNK_MALLOC_MAX &lt; limit)
</span>      limit = PNG_USER_CHUNK_MALLOC_MAX;
# endif
<span>   </span><span>if</span><span> (png_ptr-&gt;chunk_name == png_IDAT)
</span>   {
      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
      size_t row_factor =
<span>         (png_ptr-&gt;width * png_ptr-&gt;channels * (png_ptr-&gt;bit_depth &gt; </span><span>8</span><span>? </span><span>2</span><span>: </span><span>1</span><span>)
</span><span>          + </span><span>1</span><span> + (png_ptr-&gt;interlaced? </span><span>6</span><span>: </span><span>0</span><span>));
</span><span>      </span><span>if</span><span> (png_ptr-&gt;height &gt; PNG_UINT_32_MAX/row_factor)
</span>         idat_limit=PNG_UINT_31_MAX;
<span>      </span><span>else</span><span>
</span>         idat_limit = png_ptr-&gt;height * row_factor;
<span>      row_factor = row_factor &gt; </span><span>32566</span><span>? </span><span>32566</span><span> : row_factor;
</span><span>      idat_limit += </span><span>6</span><span> + </span><span>5</span><span>*(idat_limit/row_factor+</span><span>1</span><span>); </span><span>/* zlib+deflate overhead */</span><span>
</span>      idat_limit=idat_limit &lt; PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
      limit = limit &lt; idat_limit? idat_limit : limit;
   }
<span>   </span><span>// ...</span><span>
</span>}</code></pre><p>‍</p><p>GREASE can automatically find this hard-to-spot bug:</p><pre contenteditable="false"><code><span>$ clang test.c -o test
</span>$ grease test

<span>Finished analyzing </span><span>&#39;png_check_chunk_length&#39;</span><span>. Possible bug(s):
</span>
<span>At </span><span>0x100011bd</span><span>:
</span>div: denominator was zero
<span>Concretized </span><span>arguments</span><span>:
</span>
<span>rcx: </span><span>0000000000000000</span><span>
</span><span></span><span>rdx</span><span>: </span><span>0000000000000000</span><span>
</span><span></span><span>rsi</span><span>: </span><span>0000000000000000</span><span>
</span><span></span><span>rdi</span><span>: </span><span>000000</span><span>+</span><span>0000000000000000</span><span>
</span><span></span><span>r8</span><span>: </span><span>0000000000000000</span><span>
</span><span></span><span>r9</span><span>: </span><span>0000000000000000</span><span>
</span><span></span><span>r10</span><span>: </span><span>0000000000000000</span><span>
</span>
<span></span><span>000000</span><span>: </span><span>54</span><span> </span><span>41</span><span> </span><span>44</span><span> </span><span>49</span><span> </span><span>01</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> f9 ff ff ff </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>80</span></code></pre><p>‍</p><p>This output says that<code> png_check_chunk_length</code> will divide by zero when the register <code>rdi</code> holds a pointer to an allocation containing the bytes <code>54 41 44</code>... Indeed, if we add the following main function:</p><pre contenteditable="false"><code><span>int </span><span>main</span><span>(</span><span>)</span><span> {
</span><span>  char data[] = {</span><span>0x54</span><span>, </span><span>0x41</span><span>, </span><span>0x44</span><span>, </span><span>0x49</span><span>, </span><span>0xf9</span><span>, </span><span>0x00</span><span>, </span><span>0x00</span><span>, </span><span>0x00</span><span>, </span><span>0x01</span><span>, </span><span>0xb7</span><span>, </span><span>0x3e</span><span>, </span><span>0x9b</span><span>, </span><span>0x00</span><span>, </span><span>0x00</span><span>, </span><span>0x00</span><span>, </span><span>0x00</span><span>, </span><span>0x00</span><span>, </span><span>0x80</span><span>};
</span><span>  png_check_chunk_length((png_const_structrp)data, </span><span>0</span><span>);
</span><span>  </span><span>return</span><span> </span><span>0</span><span>;
</span>}</code></pre><p>‍</p><p>We see exactly what GREASE described:</p><pre contenteditable="false"><code><span>$ clang test.c -o test
</span>$ ./test
Floating point exception (core dumped)</code></pre><h2>How it works</h2><p>Fundamentally, GREASE works quite similarly to <a href="https://github.com/GaloisInc/crucible/blob/master/uc-crux-llvm/README.md">UC-Crux</a>, our tool for under-constrained symbolic execution of LLVM. Essentially, GREASE analyzes each function in the target binary by running it on a slate of fully symbolic registers. When errors occur (for example, if the program reads from uninitialized memory), GREASE uses heuristics to refine this initial symbolic precondition (e.g., by initializing some memory) and re-runs the target function. This process continues until GREASE finds a bug, or concludes that the function is safe under some reasonable precondition on its inputs. The <a href="https://www.galois.com/articles/under-constrained-symbolic-execution-with-crucible">blog post introducing UC-Crux</a> describes this algorithm in considerable detail. Further information is also available in <a href="https://galoisinc.github.io/grease/refinement.html">the GREASE documentation</a>.</p><p>In contrast with the above example from libpng, GREASE’s heuristics will <em>not</em> flag the following program as potentially problematic.</p><pre contenteditable="false"><code><span>$ cat test.c
</span><span>int </span><span>test</span><span>(</span><span>int *x</span><span>)</span><span> { </span><span>return</span><span> *x + </span><span>1</span><span>; }
</span>
$ clang test.c -o test
$ grease test

– snip –
All goals passed!</code></pre><p>‍</p><p>If we ask GREASE for additional details, we can see that it deduces that <code>rdi</code> must point to (at least) four initialized bytes. The heuristics deem this a reasonable precondition for the test function.</p><pre contenteditable="false"><code><span>$ grease test -v
</span>
<span></span><span>rip</span><span>: </span><span>0000000000401010</span><span>
</span>– snip –
<span></span><span>rdi</span><span>: </span><span>000007</span><span>+</span><span>0000000000000000</span><span>
</span>– snip –
<span></span><span>000007</span><span>: XX XX XX XX</span></code></pre><p>‍</p><p>(In the above output, <code>XX</code> indicates a byte of memory initialized to a symbolic value. The syntax of the language used in GREASE’s output is detailed <a href="https://galoisinc.github.io/grease/shape-dsl.html">in the documentation</a>.)</p><h2>Limitations</h2><p>GREASE has several key limitations. Most importantly, GREASE relies on heuristics to determine whether a fallible memory access should be reported as a bug or not. These heuristics may cause false positives (reporting a normal program behavior as suspicious) or false negatives (missing real bugs).</p><p>Like most program analysis tools, GREASE is subject to a litany of constraints and caveats. GREASE suffers from <a href="https://en.wikipedia.org/wiki/Path_explosion">path explosion</a>. GREASE’s memory model cannot express unbounded heap data structures (e.g., linked lists of symbolic length). Like other tools based on symbolic execution, GREASE unrolls loops and recursion (optionally up to a maximum bound), and can get stuck when loop conditions remain symbolic. GREASE cannot analyze certain pathological behaviors of machine code, such as run-time code generation (JITs), self-modifying code, or jumps to the “middle” of instructions. A more complete accounting of GREASE’s limitations can be found <a href="https://galoisinc.github.io/grease/limitations.html">in the documentation</a>.</p><h2>Comparison to other tools</h2><p>Where does GREASE fit into the landscape of binary analysis, symbolic execution, and software reverse engineering tools?</p><ul role="list"><li>Concrete testing tools such as fuzzers (e.g., AFL) have the advantage of reporting complete inputs that cause crashes. However, they are more susceptible to path explosion (that is, they can struggle to reach code deep inside the target), and can only test a vanishingly small fraction of possible inputs to a program. Using symbolic execution, GREASE can effectively cover more of the input space.</li><li><a href="https://angr.io/">angr</a> is a toolkit for symbolic execution of binaries. angr is much more mature than GREASE, and is intended for a wider variety of use-cases. angr is first and foremost a Python API that reverse engineers can use to build tools, whereas GREASE provides a ready-to-use CLI. angr performs traditional symbolic execution by default, whereas GREASE performs under-constrained symbolic execution. Like fuzzing, traditional symbolic execution can struggle to reach code deep in the program due to path explosion. angr aggressively concretizes pointers, whereas GREASE’s memory model is capable of sophisticated symbolic memory operations such as reads and writes involving symbolic pointers and symbolic sizes.</li><li><a href="http://klee-se.org/">KLEE</a> is a widely-used symbolic execution tool for LLVM. In contrast to KLEE, GREASE supports analysis of binaries in addition to LLVM, and performs under-constrained symbolic execution.</li><li>UC-KLEE was an under-constrained symbolic execution tool for LLVM described in “Under-Constrained Symbolic Execution: Correctness Checking for Real Code”. To our knowledge, it was never open-sourced. In contrast to UC-KLEE, GREASE supports analysis of binaries in addition to LLVM. UC-KLEE used a lazy memory model, whereas GREASE’s approach to under-constrained symbolic execution is more iterative in nature.</li><li>UC-Crux was our previous tool for under-constrained symbolic execution of LLVM. Unfortunately, we made two fundamental mistakes in the design of UC-Crux: (1) its core is specialized to analysis of LLVM, limiting its potential applicability to binaries, and (2) its analysis makes use of the types of LLVM pointers. LLVM has phased such types out in favor of the “opaque pointer” type ptr, and accordingly it would be difficult to adapt UC-Crux to work well on recent versions of LLVM. We plan to deprecate UC-Crux in favor of GREASE.</li><li><a href="https://github.com/GaloisInc/macaw">Macaw</a> is a binary analysis framework similar to angr, which is described in the <a href="http://www.arxiv.org/abs/2407.06375">pre-print</a> “Macaw: A Machine Code Toolbox for the Busy Binary Analyst”. GREASE is built on top of Macaw.</li><li>GREASE can be integrated into binary analysis platforms such as <a href="https://ghidra-sre.org/">Ghidra</a> and <a href="https://binary.ninja/">Binary Ninja</a> as a plugin.</li></ul><h2>Conclusion</h2><p>We are happy to share GREASE with the binary analysis research community under the BSD 3-clause license. GREASE is under active development. Pull requests, issues, and questions are welcome! Please reach out to grease@galois.com to start a conversation.</p><p>‍</p><p><em>This material is based upon work supported by the Defense Advanced Research Projects Agency under Contract No. W31P4Q-22-C-0017 and W31P4Q-23-C-0020.</em></p><p>‍</p></div></div></div>
  </body>
</html>
