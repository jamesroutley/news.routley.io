<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://applied-langua.ge/posts/zero-feet.html">Original</a>
    <h1>Zero Feet: a proposal for a systems-free Lisp</h1>
    
    <div id="readability-page-1" class="page"><div id="text-org24b0538">
<p>
We believe an implementation written entirely in the language it
implements has some engineering benefits. The first is that a
programmer does not need to know any other language, in order to
modify any part of their implementation.
</p>

<p>
Implementations which are written in another language and use an
interpreter also have a very large difference in performance between
code written in the language used for the implementation, and the
language being implemented. A common approach to improving the
performance of the implementation is to write more modules in the host
language; for example, dictionaries and sets in CPython are written in
C, rather than Python. Even if a programmer has identified a data
structure with better performance in theory<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>, finding a
performance improvement may be very difficult, because the performance
of individual operations is worse, regardless of the complexity of
particular algorithms.
</p>

<p>
This form of optimisation can also lead to security bugs: errors in
the implemented language are checked and handled, whereas the
implementation language may be <a href="https://plover.com/~mjd/misc/hbaker-archive/letters/CACM-DubiousAchievement.html">unsafe by default</a>. The forementioned
performance hacks would require more code to be written in the
implementation language, exacerbating the problem and leading to more
ways the code can fail, and less of the implementation being
approachable to a programmer who is not familiar with the host
language.
</p>

<p>
When it is necessary to use unsafe operations, we may introduce them
to a high-level and safe language in a <i>gradual</i> manner, and all other
operations can remain safe. The Jikes RVM, a Java virtual machine
implemented in Java, <a href="http://users.cecs.anu.edu.au/~steveb/pubs/papers/vmmagic-vee-2009.pdf">includes &#34;magic&#34; operations</a> for this
purpose. Newer &#34;system&#34; languages, such as Rust, also allow for
marking code as &#34;unsafe&#34;, with any other code being safe, but we can
provide very fine-grained control over magic using the object-capability
model.
</p>

<p>
The object-capability model also allows for replacing magic operations
with simulations. If an implementation is implemented in two languages
(say, Lisp and C), some information invariably gets duplicated between
Lisp code and C code. The <i>genesis</i> stage of <a href="https://research.gold.ac.uk/id/eprint/2336/1/sbcl.pdf">bootstrapping SBCL</a>
manages this duplication brilliantly; some Lisp code run during
bootstrapping generates C headers describing constants and structures,
so that constants and object layouts only need to be defined once in
Lisp. But more complex algorithms cannot be generated in the same
way. As SBCL is designed to be bootstrapped from any Common Lisp
implementation, genesis is able to dump out a &#34;native&#34; image from just
Common Lisp, which requires a Lisp implementation of the heap
allocator to be used during bootstrapping, whereas the allocator in
the C runtime is used after bootstrapping. The allocator implemented
in genesis does differ to the C allocator, as the former is designed
to pack more objects into pages than the latter, but essentially the
same algorithm is implemented twice.
</p>

<p>
As <a href="https://gbracha.blogspot.com/2009/07/ban-on-imports-continued.html">all modules are implicitly parameterised</a> and all dependencies can
be replaced transparently, making the allocator manipulate a simulated
heap rather than a real heap just requires instantiating the allocator
with a module that affects a simulated memory, rather than a module
that affects raw memory. Other parts of the runtime could be tested in
a similar way, by having operations on raw memory instead modify a
simulated memory, and these parts could be debugged from the comfort
of the usual debugging tools used by the user, rather than a separate
debugger like GDB, or a &#34;low-level&#34; debugger like ldb in SBCL.
</p>

<p>
This technique is used in the Jikes RVM: the memory management can be
&#34;rehosted&#34; to target a simulated heap, by using a different
implementation of the memory interface. However, the technique is used
for debugging rather than bootstrapping (which, granted, isn&#39;t too
important) and replacing modules can be performed transparently with
the module system inherited from Newspeak, whereas it cannot with the
Java module system. The <a href="http://files.squeak.org/docs/OOPSLA.Squeak.html">implementation of Squeak</a> can also be debugged
inside a Smalltalk environment, because the implementation is written
in a subset of Smalltalk (which can &#34;conveniently&#34; also be translated
to C with little effort), and thus is a perfectly fine Smalltalk program.
</p>
</div></div>
  </body>
</html>
