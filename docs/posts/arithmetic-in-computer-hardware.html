<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thelast19digitsofpi.github.io/hardware-explorations/dist/index.html">Original</a>
    <h1>Arithmetic in Computer Hardware</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>[NOTE: This is an entry in the <a href="https://www.3blue1brown.com/blog/some1">3Blue1Brown Summer of Math Exposition</a> for 2021. <strong>Full disclosure</strong>: Originally, I wrote the <a href="https://thelast19digitsofpi.github.io/hardware-explorations/dist/multDivOnly">multiplier and divider visuals</a> without the detailed explanation as a project for a class this spring. Over the summer I&#39;ve been extending it to the broader 3-part explanation that does addition and subtraction as well. I was already somewhat into the design when I heard about SoME, but apart from the original form, this has not been published previously.]</p> <h4> <a href="https://thelast19digitsofpi.github.io/hardware-explorations/dist/part2.html">Skip right to Part 2</a> </h4> <h3>The Basics</h3> <p>You&#39;re probably aware that computers store numbers as a series of 0&#39;s and 1&#39;s. Using just 0&#39;s and 1&#39;s is called &#34;binary&#34;, and the <strong>bi</strong>nary digi<strong>ts</strong> are called <strong>bits</strong>. These bits, the 0s and 1s, are sent around in various complicated circuits to do calculations.</p> <p>But how does the computer actually do arithmetic? Before we can get into that, we need to learn how the computer actually stores numbers in the first place. There are a few different methods, but we&#39;ll focus on whole numbers for now.</p> <p>Humans generally use base ten notation, which means that a number like 314 means three hundreds, one ten, and four units. Computer wiring generally uses base two, or binary, where the only digits are 0 and 1 and the digits use powers of two (1, 2, 4, 8, 16, 32, ...). For example, <code>110</code> in binary means not &#34;one hundred and ten&#34; but &#34;one four and one two&#34;, or 6. To help avoid confusion, I&#39;ll use <code>this font and color</code> for binary numbers with multiple digits: <code>10</code> means two; &#34;10&#34; in normal font means ten, the number after nine.</p> <p>I promised this would be interactive. Here&#39;s a simple exploration to show how binary numbers work. I&#39;ve included six bits, which means the maximum number you can reach is 2<sup>6</sup> - 1, or 63. (With six decimal digits you could reach 10<sup>6</sup> - 1 = 999,999.)</p> <h4>Exploration Instructions</h4> <ul> <li><strong>Dark Red</strong> indicates a <strong>zero/off</strong> bit.</li> <li><strong>Green</strong> indicates a <strong>one/on</strong> bit. (In the explorations the green is lighter.)</li> <li>Clicking on <strong>circular</strong> (&#34;input&#34;) bits switches them.</li> <li>Other components <em>cannot</em> be interacted with directly.</li> </ul> <p>This one just shows you the value of a 6-bit number. You can click on the bits to change them.</p>  <h3>Simple Operations</h3> <p>Now, in order to do anything useful with these numbers, we need to have ways do to computations on bits. As is common in computer design, we start with the most basic possible components, and work our way up.</p> <p>What are the simplest possible operations? Well, taking the opposite of a bit (change 0 to 1 and vice versa) is useful. That&#39;s called a &#34;NOT gate&#34;, because it takes in a value and outputs whatever that value is <em>not</em>.</p> <p>But to do real computations, we need bits to interact with each other. The next simplest kind of operation involves <em>two</em> inputs. There are many possibilities, but the simplest ones that come to mind are the following:</p> <ul> <li>AND: Gives a 1 if both of the inputs are 1&#39;s. Otherwise it gives 0.</li> <li>OR: Gives a 1 if either, or both, inputs are 1&#39;s. If both are zero, it outputs 0.</li> </ul> <p>The English word &#34;or&#34; is annoyingly ambiguous; sometimes it allows both (&#34;you must be 48 inches tall or accompanied by an adult&#34;; they wouldn&#39;t turn away two tall adults who want to ride together!) and other times it does not (&#34;it comes with salad or fries&#34; probably means you pick one). Computer scientists cannot tolerate this kind of ambiguity, and so they have decided to call the &#34;one or both&#34; option &#34;OR&#34;. When you want &#34;one or the other, but <em>not</em> both&#34;, they call it &#34;exclusive or&#34;, also known as &#34;XOR&#34;.</p> <p>Why am I saying this? Well, first, I want to make it clear what an &#34;OR&#34; gate does when you see it in a circuit. Second, the XOR gate, though more complicated, is surprisingly useful later on...</p> <table> <thead> <tr> <th>First Input</th> <th>Second Input</th> <th>AND</th> <th>OR</th> <th>XOR</th> </tr> </thead> <tbody> <tr> <th>0</th> <th>0</th> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <th>0</th> <th>1</th> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <th>1</th> <th>0</th> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <th>1</th> <th>1</th> <td>1</td> <td>1</td> <td>0</td> </tr> </tbody> </table> <p>The above is a &#34;truth table&#34; for three of the four main operations. (The fourth, NOT, only has one input.)</p> <p>Now, I will not go into how one actually builds a NOT gate or an AND gate. That&#39;s getting a bit too far into electrical engineering. Instead, we&#39;ll treat those as &#34;atoms&#34;, basic components from which everything else will be built.</p> <p>Instead, here is another exploration. There are no numbers this time. The squares are the outputs; you can&#39;t change them directly. In case you skipped the instructions above: Green is 1, red is 0. Click on circles to switch them. Squares are the output. The shapes I&#39;ve used are common in electrical engineering, but I&#39;ve also added the symbols <strong>&amp;</strong>, <strong>O</strong>, and <strong>X</strong> to make it more clear. (If you&#39;re still confused as to which gate is which—and I admit to being a little unclear on that—the best way to learn is to <em>try it yourself</em>!)</p>  <h3>Addition</h3> <p>With these four gates, we can make almost anything. Probably the easiest thing to start with is arithmetic, because numbers are so fundamental to computations. Of the four basic operations, addition is clearly the easiest of them, so let&#39;s start there.</p> <p>In fact, let&#39;s start with the simplest case of the simplest case: adding two individual bits. (In other words, we&#39;re adding two numbers that can be either 0 or 1.) Now, the result could be either 0, 1, or 2, which is three possiblilities, so we&#39;ll need more than one bit for the output. For these purposes, we&#39;ll have two output bits, one that means &#34;1&#34; and one that means &#34;2&#34;.</p> <p>Here&#39;s what we&#39;re going for. On the left, I&#39;ve made a simple adder to show what we&#39;re doing. On the right, I have a set of adjustable logic gates. You can click or tap the arrows to change the gates.</p> <p>See if you can get the rightmost output square to turn on when A + B = 1, and the leftmost one to turn on when A + B = 2. If you think you have it, click the &#34;TEST&#34; button to see if you&#39;re right! (Note that you have to make it work for EVERY possible input. I&#39;d highly recommend thinking about the different gates, rather than just trying all 9 possible gate configurations.)</p> <h5>Instructions</h5> <ol> <li>On the left, the circuit gives the correct answer but doesn&#39;t show the details.</li> <li>On the right are two gates. <strong>Use the arrow buttons to switch the gates between AND, OR, and XOR</strong>. (As you&#39;ll see, the inputs on each side are linked so both circuits always have the same inputs.)</li> <li>Your goal is to make the output on the right match that of the left <strong>for all possible inputs</strong> (not just the starting position!).</li> <li>When you think you have the answer, <strong>click the test button</strong>. It will turn yellow and try every combination of bits. If it later turns green, you solved it! Otherwise you&#39;ll see where your circuit went wrong.</li> </ol>  <p>Did you figure it out? If you did, good job! If not, let&#39;s see how we can discover it from scratch.</p> <p>With these kinds of problems, it helps to write down <em>exactly</em> what we want the wiring to do. We have two inputs, A and B.</p> <ul> <li>If both A and B are <strong>OFF</strong>, then both 1 and 2 are off.</li> <li>If only one of the two (A or B) is <strong>ON</strong>, then &#34;1&#34; should be <strong>ON</strong> but &#34;2&#34; should be off.</li> <li>If both A and B are <strong>ON</strong>, then &#34;1&#34; should turn off but &#34;2&#34; should turn <strong>ON</strong>.</li> </ul> <p>It should be fairly obvious by now that &#34;2&#34; needs to be an AND gate. I hope you&#39;ve also spotted that &#34;1&#34; should be an XOR gate, but if you guessed inclusive OR, it&#39;s okay -- mistakes are part of learning! (That also shows the value of writing everything out. It&#39;s much harder to forget about the double-1 case if you have to write it out. In fact, we also could have made a truth table; comparing it to the one for AND/OR/XOR would reveal the answer immediately.)</p> <h3>That was only half the work</h3> <p>What we just conceptualized was called a &#34;half adder&#34;. Why half? Because if you&#39;re trying to add two numbers, sooner or later you have to worry about carrying. The &#34;2&#34; output from above  would be our carry; it&#39;s a little like the tens digit in an addition like this:</p> <pre>addition:
 (1)
  58
+ 66
----
   4   (8 + 6 = 14, carry the 1)
 124</pre> <p>The lonely &#34;4&#34; above the answer represents the fact that you normally write the 4 first, <em>then</em> carry the 1, and add 1 + 5 + 6 = 12.</p> <p>So how can we handle carries? This is a bit complicated, so we&#39;ll definitely need a truth table. See if you can do it yourself!</p> <p>We&#39;ll technically have three inputs here, but one of them is the &#34;carry&#34; bit that represents the &#34;2&#34; output of the previous column. Also, there could be three ON (1) inputs. Instead of making a third output, we can just say that if all three are on, we&#39;ll turn the &#34;1&#34; <em>and</em> &#34;2&#34; inputs on. (Just like binary! 1 + 2 = 3.)</p> <table id="fill-in"> <thead> <tr> <th>Input A</th> <th>Input B</th> <th>Carry In</th> <th>Output 1</th> <th>Output 2</th> </tr> </thead> <tbody> <tr> <th>0</th><th>0</th><th>0</th> </tr> <tr> <th>1</th><th>0</th><th>0</th> </tr> <tr> <th>0</th><th>1</th><th>0</th> </tr> <tr> <th>1</th><th>1</th><th>0</th> </tr> <tr> <th>0</th><th>0</th><th>1</th> </tr> <tr> <th>1</th><th>0</th><th>1</th> </tr> <tr> <th>0</th><th>1</th><th>1</th> </tr> <tr> <th>1</th><th>1</th><th>1</th> </tr> </tbody> </table> <p>Did you get it? Scroll down for the answer. The right column has value 2 but I wrote 0s and 1s because that is more standard (there&#39;s no second voltage level or anything like that).</p> <table> <thead> <tr> <th>Input A</th> <th>Input B</th> <th>Carry In</th> <th>Output 1</th> <th>Output 2</th> </tr> </thead> <tbody> <tr> <th>0</th><th>0</th><th>0</th> <td>0</td> <td>0</td> </tr> <tr> <th>1</th><th>0</th><th>0</th> <td>1</td> <td>0</td> </tr> <tr> <th>0</th><th>1</th><th>0</th> <td>1</td> <td>0</td> </tr> <tr> <th>1</th><th>1</th><th>0</th> <td>0</td> <td>1</td> </tr> <tr> <th>0</th><th>0</th><th>1</th> <td>1</td> <td>0</td> </tr> <tr> <th>1</th><th>0</th><th>1</th> <td>0</td> <td>1</td> </tr> <tr> <th>0</th><th>1</th><th>1</th> <td>0</td> <td>1</td> </tr> <tr> <th>1</th><th>1</th><th>1</th> <td>1</td> <td>1</td> </tr> </tbody> </table>  <p>But how do we wire this? Well, we&#39;re trying to add A + B + C. We can think about splitting that up into (A + B) + C, that is, doing the first addition at the beginning and adding extra stuff on for the carry bit.</p> <p>I&#39;ll have you see if you can do it. I&#39;ll give you a hint by providing the general layout of the circuit as well as two of the five gates. See if you can fill in the rest!</p> <h5>Interactive Circuit</h5> <ul> <li>Just like before, your goal is to make the two circuits match.</li> <li>However, this time the circuit you are building is on the <strong>left</strong>.</li> <li>The two gates at the top (one AND, one XOR) cannot be changed. They are already correct!</li> <li>Whenever you see a dot (•) inside a wire, that means the signal is being sent to two different places. If there is no dot, then two different wires are crossing without affecting each other.</li>   <h3>Putting it all together</h3> <p>So once we have a full adder, all we need to do for multiple bits is to chain a whole bunch of them together!</p> <p>On the left side, I&#39;ve put a basic implementation of the hardware showing the individual gates that make a basic four-bit adder. On the right, I&#39;ve abstracted that away to a single component that does the same thing.</p> <p>Click on red and green <strong>circles</strong> to change the input bits. Red = 0, green = 1. The square bits are the outputs. The numbers show what your inputs and outputs are in decimal, but you <strong>cannot</strong> type numbers in. I did that on purpose. Click on the bits directly!</p> <p>(There are no adjustable gates this time. You can still click the bits, but the circuit is correct and complete.)</p>   <h3>What&#39;s Next?</h3> <p>Well... if you&#39;ve gotten this far, take a moment to feel good about yourself. You&#39;re learning!</p> <p>All right... Well, we&#39;ve just done addition. The next simplest operation is subtraction. When you&#39;re ready, let&#39;s move on to <a href="https://thelast19digitsofpi.github.io/hardware-explorations/dist/part2.html">part 2</a>!</p>  </ul></div></div>
  </body>
</html>
