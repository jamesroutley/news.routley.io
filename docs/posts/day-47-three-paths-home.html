<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamiepalatnik.com/day-47-three-paths-home/">Original</a>
    <h1>Day 47: Three Paths Home</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <div>
          
          
          <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>An introduction to a KVM-based single-process sandbox</p>
<!--more--><p><img src="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=1093&amp;height=933&amp;name=tinykvm%20image%201.png" width="1093" height="933" loading="lazy" alt="tinykvm image 1" srcset="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=547&amp;height=467&amp;name=tinykvm%20image%201.png 547w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=1093&amp;height=933&amp;name=tinykvm%20image%201.png 1093w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=1640&amp;height=1400&amp;name=tinykvm%20image%201.png 1640w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=2186&amp;height=1866&amp;name=tinykvm%20image%201.png 2186w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=2733&amp;height=2333&amp;name=tinykvm%20image%201.png 2733w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%201.png?width=3279&amp;height=2799&amp;name=tinykvm%20image%201.png 3279w" sizes="(max-width: 1093px) 100vw, 1093px"/></p>
<p><span><em>TinyKVM executes regular Linux programs with the same results as native execution.</em></span></p>
<p>TinyKVM can be used to sandbox regular Linux programs or programs with specialized APIs embedded into your servers.</p>
<h2>TinyKVM’s design</h2>
<p>In order to explain just what TinyKVM is, I’m just going to list explicit features that are currently implemented and working as intended:</p>
<p>TinyKVM runs static <em>Linux ELF programs</em>. It can also be extended with an API made by you to give it access to eg. an outer HTTP server or cache. I’ll also be adding dynamic executable support eventually. ⏳ It currently runs on AMD64 (x86_64), and I will port it to AArch64 (64-bit ARM) at some later point in time.</p>
<p>TinyKVM creates hugepages where possible for guest pages. It can also use hugepages on the host in addition. The result is often (if not always) higher performance than a vanilla native program. Just to hammer this a bit in: <a href="https://easyperf.net/blog/2022/09/01/Utilizing-Huge-Pages-For-Code" rel="noopener">https://easyperf.net/blog/2022/09/01/Utilizing-Huge-Pages-For-Code</a> found that just allocating 2MB pages for the execute segment gave a 5% compilation boost for the LLVM codebase.</p>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=1093&amp;height=933&amp;name=tinykvm%20image%202.png" width="1093" height="933" loading="lazy" alt="tinykvm image 2" srcset="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=547&amp;height=467&amp;name=tinykvm%20image%202.png 547w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=1093&amp;height=933&amp;name=tinykvm%20image%202.png 1093w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=1640&amp;height=1400&amp;name=tinykvm%20image%202.png 1640w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=2186&amp;height=1866&amp;name=tinykvm%20image%202.png 2186w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=2733&amp;height=2333&amp;name=tinykvm%20image%202.png 2733w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%202.png?width=3279&amp;height=2799&amp;name=tinykvm%20image%202.png 3279w" sizes="(max-width: 1093px) 100vw, 1093px"/></p>
<p><em><span>I quickly allocated some hugepages and ran TinyKVM w/STREAM, and yes it’s quite a bit faster.</span></em></p>
<p>TinyKVM has only 2us overhead when calling a function in the guest. This may seem like much compared to my <a href="https://libriscv.no/docs/performance/latency" rel="noopener">RISC-V emulators 3ns</a>, however we are entering another process, and we get to use all of our CPU features.</p>
<h2>System calls</h2>
<p>An API toward the host is created by defining and hooking up system calls in the emulator. In the guest they are implemented both by the SYSCALL/SYSRET and you can also use an OUT instruction directly from usermode, the latter being the lowest latency. This then causes a VM exit, and registers are inspected to find that a system call is being performed. All in all, the round-trip is a bit less than ~1 microsecond, which is quite different from libriscv’s 2ns. But, you can design a smaller API with larger inputs and outputs, instead of many smaller calls (which makes sense when its cheaper).</p>
<h2>Benchmarks</h2>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=600&amp;height=371&amp;name=tinykvm%20image%203.png" width="600" height="371" loading="lazy" alt="tinykvm image 3" srcset="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=300&amp;height=186&amp;name=tinykvm%20image%203.png 300w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=600&amp;height=371&amp;name=tinykvm%20image%203.png 600w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=900&amp;height=557&amp;name=tinykvm%20image%203.png 900w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=1200&amp;height=742&amp;name=tinykvm%20image%203.png 1200w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=1500&amp;height=928&amp;name=tinykvm%20image%203.png 1500w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%203.png?width=1800&amp;height=1113&amp;name=tinykvm%20image%203.png 1800w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p><em><span>The overhead of resetting the VM + calling into the VM guest.</span></em></p>
<p>For call overhead, we measure the cost of resetting the VM as tail latency, because it can be paid while (for example) a HTTP response is already underway. If you don’t need to reset, simply ignore the red. Reset time scales with working memory usage.</p>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=600&amp;height=371&amp;name=tinykvm%20image%204.png" width="600" height="371" loading="lazy" alt="tinykvm image 4" srcset="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=300&amp;height=186&amp;name=tinykvm%20image%204.png 300w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=600&amp;height=371&amp;name=tinykvm%20image%204.png 600w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=900&amp;height=557&amp;name=tinykvm%20image%204.png 900w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=1200&amp;height=742&amp;name=tinykvm%20image%204.png 1200w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=1500&amp;height=928&amp;name=tinykvm%20image%204.png 1500w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%204.png?width=1800&amp;height=1113&amp;name=tinykvm%20image%204.png 1800w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=600&amp;height=371&amp;name=tinykvm%20image%205.png" width="600" height="371" loading="lazy" alt="tinykvm image 5" srcset="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=300&amp;height=186&amp;name=tinykvm%20image%205.png 300w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=600&amp;height=371&amp;name=tinykvm%20image%205.png 600w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=900&amp;height=557&amp;name=tinykvm%20image%205.png 900w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=1200&amp;height=742&amp;name=tinykvm%20image%205.png 1200w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=1500&amp;height=928&amp;name=tinykvm%20image%205.png 1500w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%205.png?width=1800&amp;height=1113&amp;name=tinykvm%20image%205.png 1800w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p>Memory benchmarks are done to see if there’s anything obviously wrong, and there is not. One of my favorite benchmarks was encoding 1500 AVIF images per second in a HTTP benchmark (AVIF encoder as a service):</p>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=600&amp;height=371&amp;name=tinykvm%20image%206.png" width="600" height="371" loading="lazy" alt="tinykvm image 6" srcset="https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=300&amp;height=186&amp;name=tinykvm%20image%206.png 300w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=600&amp;height=371&amp;name=tinykvm%20image%206.png 600w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=900&amp;height=557&amp;name=tinykvm%20image%206.png 900w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=1200&amp;height=742&amp;name=tinykvm%20image%206.png 1200w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=1500&amp;height=928&amp;name=tinykvm%20image%206.png 1500w, https://info.varnish-software.com/hs-fs/hubfs/tinykvm%20image%206.png?width=1800&amp;height=1113&amp;name=tinykvm%20image%206.png 1800w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p><em><span>AVIFs can be transcoded from JPEGs quite fast with the right methods.</span></em></p>
<p>So we can see that 16x98.88 = 1582 image transcodings per second. Of course the transcoder settings and image size matters, but I am more interested in the scaling aspect. Does doubling concurrency increase our overall performance up to a point? Yes, it does.</p>
<p>Fun fact: Did you know that you can transcode JPEG to AVIF without going through (lossy?) RGB conversion? YUV planes work the same way in both formats!</p>
<h3>Fast sandboxing</h3>
<p>So, what exactly makes this the worlds fastest sandbox? Well, for one it doesn’t use any I/O, doesn’t use any drivers and no virtual devices so it shakes off a common problem with other KVM solutions: Virtualized I/O reduces performance somewhat.</p>
<h2>Drawbacks</h2>
<p>It’s not possible to reduce vCPU count after increasing it in the KVM API, and because of this I consider multi-processing something that can be better achieved by running more VMs concurrently and just using/abusing the automatic memory sharing. TinyKVM does have experimental multi-processing support but you can’t wind down after, so it’s not a great choice for long-running processes like Varnish.</p>
<h2>Future work</h2>
<ul>
<li>Intel TDX/AMD SEV support would be nice to have.</li>
<li>AArch64 port.</li>
<li>There is a KVM feature to lock down memory in a way where not even kernel mode in the guest can change it called KVM_MEM_READONLY which I hope can be a part of locking down the guest even more. A potential drawback is increased usage of memory mappings.</li>
<li>The user-facing API in TinyKVM needs work to become friendly.</li>
<li>Move much of the system call emulation that I’ve written for a Varnish integration into TinyKVM proper, which paves the way further for dynamic linker loading. ld.so uses mmap() with fd’s to map in files that it is loading. So, if you load ld.so into your own emulator, and then you add your intended program as the first argv argument, and its arguments after that, ld.so will load your program for you, provided you have that mmap() implementation. This is what <em>libriscv</em> does!</li>
</ul>
<h2>Conclusion</h2>
<p>TinyKVM perhaps surprisingly places itself among the smallest serious sandboxing solutions out there, and may also be the fastest. It takes security seriously and tries to avoid complex guest features and kernel mode in general. TinyKVM has a minimal attack surface and no ambition to grow further in complexity, outside of nicer user-facing APIs and ports to other architectures.</p>
<p>Have a look at the <a href="https://github.com/varnish/tinykvm" rel="noopener">code repository for TinyKVM</a>, if you’re interested. Documentation and user-facing API needs a lot of work still, but feel free to build the project and run some simple Linux programs with it. As long as they are static and don’t need file or network access, they might just run out-of-the box.</p>
<p>Not too long from now we will <a href="https://github.com/varnish/libvmod-tinykvm" rel="noopener">open-source a VMOD in Varnish</a> that lets you transform data safely using TinyKVM. It works on both open-source Varnish and Varnish Enterprise! If you&#39;d like to learn more, <a href="https://www.varnish-software.com/contact-us/" rel="noopener">reach out to us today</a>!</p>
<hr/>
<p>Blog originally posted <a href="https://fwsgonzo.medium.com/tinykvm-the-fastest-sandbox-564a1c5e9b42" rel="nofollow noopener">here</a>.</p></span></p>

          
        </div>
      </article>

      
    </div></div>
  </body>
</html>
