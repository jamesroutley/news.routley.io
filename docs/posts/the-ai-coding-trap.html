<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrisloy.dev/post/2025/09/28/the-ai-coding-trap">Original</a>
    <h1>The AI coding trap</h1>
    
    <div id="readability-page-1" class="page"><article><p>If you ever watch someone “coding”, you might see them spending far more time staring
into space than typing on their keyboard. No, they (probably) aren’t slacking off.
Software development is fundamentally a practice of problem-solving, and so, as with
solving a tricky crossword, most of the work is done in your head.</p>
<p>In the software development lifecycle, coding is the letters filled into the crossword,
only a small amount of effort compared to all the head scratching and scribbled notes.
The real work
usually happens alongside coding, as the developer learns the domain, narrows down
requirements, maps out relevant abstractions, considers side effects, tests features
incrementally, and finally squashes bugs that survived this rigorous process. It looks
something like this:</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-1.svg" alt="Thinking, then coding." title="Thinking, then coding."/></p>
<p>But with AI-driven coding, things play out very differently.</p>
<h2>“Code first, ask questions later”</h2>
<p>AI coding agents such as <a href="https://claude.com/product/claude-code">Claude Code</a> are
making it astonishingly fast to write code in isolation. But most software lives within
complex systems, and since LLMs can&#39;t yet hold the full context
of an application in memory at once, human review, testing, and integration needs will
remain. And that is a lot harder when the code has been written without the human thinking
about it. As a result, for complex software, much of the time will be spent on post hoc
understanding of what code the AI has written.</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-2.svg" alt="Coding, then trying to understand." title="Coding, then trying to understand."/></p>
<p>This is the root of the difference between marketing copy that boasts of the paradigm
shifting speed of <strong>writing code</strong> with AI (often framed as
“<a href="https://docs.coderabbit.ai/overview/introduction">10X</a>
<a href="https://zencoder.ai/product/coding-agent">faster</a>”), and the marginal productivity gains
in <strong>delivering working software</strong> seen in the wild (usually
<a href="https://www.microsoft.com/en/customers/story/22158-allpay-github-copilot">closer to 10%</a>).</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-3.svg" alt="alt_text" title="image_tooltip"/></p>
<p>An even more dispiriting upshot of this is that, as developers, we spend an ever greater
proportion of our time merely fixing up the output of these wondrous
<a href="https://chrisloy.dev/post/2024/12/24/llms-are-scrappy-innovators">babbling machines</a>. While the LLMs get to
blast through all the fun, easy work at lightning speed, we are then left with all the
thankless tasks: testing to ensure existing functionality isn’t broken, clearing out
duplicated code, writing documentation, handling deployment and infrastructure, etc.
Very little time is actually dedicated to the thing that developers actually love doing: coding.</p>
<p>Fortunately, help is at hand. While LLMs are shaking up how software development is
performed, this issue in itself is not actually new. In fact, it is merely a stark example
of an age-old problem, which I call:</p>
<h2>The tech lead’s dilemma</h2>
<p>As engineers progress in their careers, they will eventually
step into the role of <strong>tech lead</strong>. They might be <strong>managing</strong> a team,
or they could be a <strong>principal engineer</strong>, driving technical delivery without the
people management. In either case, they are responsible for the team’s technical
delivery. They are also usually the most experienced developer in the team: either in their career,
in the specialised domain of the team, or in both.</p>
<p>Software delivery is a team effort, but one in which experience can have a highly imbalancing
effect on individual contribution
<a href="https://chrisloy.dev/post/2023/11/10/software-engineering-mechanics">velocity</a>. As such, when the tech lead’s
primary job is to maximise delivery, they will often face an internal conflict between two
ways to deliver software:</p>
<ul>
<li><strong>Fair delegation</strong> across the team, maximising learning and ownership opportunities for
junior team members, but allowing delivery to be bottlenecked by the speed of the least productive
team members.</li>
<li><strong>Mollycoddling</strong> the team, by delegating only the easy or non-critical work to juniors,
and keeping the hardest work for themselves, as the person on the team most capable of
delivering at speed.</li>
</ul>
<p>Unfortunately, while we shall see that mollycoddling is extremely harmful to long-term team
health, it is also often a very effective way to accelerate delivery. The higher bandwidth of
the tech lead is often most efficiently deployed by eating up all the hardest work:</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-4.svg" alt="Senior engineers have higher bandwidth." title="Senior engineers have higher bandwidth."/></p>
<p>As such, I have seen this pattern repeated time and again over the course of my career. And,
of course, it comes at a cost. Siloing of experience in the tech lead makes the team brittle,
it makes support harder, and it places ever greater pressure on the tech lead as a single point
of failure. What follows next is predictable: burnout, departure, and ensuing crisis as the
team struggles to survive without the one person who really knows how everything works.</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-5.svg" alt="Mollycoddling leads to short term gains but eventual failure." title="Mollycoddling leads to short term gains but eventual failure."/></p>
<p>As is usually the case, the solution lies in a third way that avoids these two extremes
and balances delivery with team growth. We might frame it as something like:</p>
<blockquote>
<p><em>Implement team practices that allow engineers to deliver working code within a framework
that minimises rework, maximises effective collaboration, and promotes personal growth and
learning.</em></p>
</blockquote>
<p>When I was CTO of Datasine, we enshrined this attitude in a simple tech team motto:</p>
<blockquote>
<p><em><strong>Learn. Deliver. Have fun.</strong></em></p>
</blockquote>
<p>Good tech leads expose their engineers to work at the limit of their capabilities,
using processes and practices that minimise delivery risk while also enabling each team
member to grow their skills, knowledge, and domain expertise. This is, in fact, the essence
of good technical leadership.</p>
<p>There are many ways to accomplish it, from strict codified frameworks such as the
<a href="http://www.extremeprogramming.org/rules.html">Extreme Programming rules</a>, through
to looser sets of principles which we might broadly refer to as “best practices”:</p>
<ul>
<li>Code reviews</li>
<li>Incremental delivery</li>
<li><a href="https://chrisloy.dev/post/2025/01/24/modular-software-design">Modular design</a></li>
<li>Test-driven development</li>
<li>Pair programming</li>
<li>Quality documentation</li>
<li>Continuous integration</li>
</ul>
<p>So, for experienced engineers today, an urgent question is: how can we translate these practices
into a world of AI-driven coding?</p>
<h2>LLMs are lightning fast junior engineers</h2>
<p>In 2025, many engineers are finding themselves for the first time in a position familiar
to every tech lead: overseeing a brilliant but unpredictable junior engineer. Harnessing
and controlling such talent, in a way that benefits effective team collaboration, is one
of the primary challenges of engineering leadership. But AI coding agents need different
management to junior engineers, because the nature of their productivity and growth is
fundamentally different.</p>
<p>As software engineers gain experience, we tend to improve our productivity in multiple
ways at the same time: writing more robust code, using better abstractions, spending less
time writing and fixing bugs, understanding more complex architectures, covering edge
cases more effectively, spotting repeated patterns earlier, etc. Engineering is a rich
and complex discipline with many avenues for specialisation, but for simplicity we might
group these dimensions into two broad themes:</p>
<ul>
<li><strong>Quality</strong>: ability to deliver more complex, more performant, more maintainable code</li>
<li><strong>Velocity</strong>: ability to develop working, bug-free code in a shorter space of time</li>
</ul>
<p>Over time, good engineers will improve in both axes.</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-6.svg" alt="Engineers and LLMs improve in both velocity and quality." title="Engineers and LLMs improve in both velocity and quality."/></p>
<p>Early LLMs were fast to write code, but time spent fixing bugs and removing hallucinations
meant they were slow to complete bug-free code. Over time, smarter LLMs and better use of
context engineering and tools have meant that modern AI coding agents are much better at
“one shot” writing of code. The current generation of commercially available agents can be
incredibly fast at producing working code for problems that would challenge some mid-level
engineers, though they cannot yet match the expertise of senior engineers:</p>
<p>So we can think of the current generation of AI coding agents as junior engineers, albeit
with two fundamental differences:</p>
<ol>
<li>LLMs deliver code much, much faster than junior engineers, constrained neither by thinking
nor writing time;</li>
<li>LLMs have no true capacity to learn, and instead only improve through more effective
<a href="https://chrisloy.dev/post/2025/08/03/context-engineering">context engineering</a> or
the arrival of new foundation models.</li>
</ol>
<p>As with junior engineering talent, there are broadly two ways that you can deploy them, depending on
whether your focus is long-term or short-term:</p>
<ul>
<li><strong>AI-driven engineering</strong>: employing best practices, foregrounding human
understanding of the code, moving slowly to make development sustainable.</li>
<li><strong>Vibe coding</strong>: throwing caution to the wind and implementing at speed, sacrificing
understanding for delivery velocity, hitting an eventual wall of unsalvageable, messy code.</li>
</ul>
<p>As might be expected, the long-term trajectories of choosing between these two approaches
follow much the same pattern as choosing between parallel delegation and mollycoddling of a
junior team:</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-7.svg" alt="Vibe coding has the exact same failure state as mollycoddling." title="Vibe coding has the exact same failure state as mollycoddling."/></p>
<p>This is why the <a href="https://chrisloy.dev/post/2025/09/07/vibe-coding-art">vibe coding</a> approach
is great for tiny projects or throwaway prototypes: applications of sufficient simplicity
can be delivered without the need for any human thinking at all. By limiting the complexity
of our projects and leaning into the capabilities of the tools, we can deliver end-to-end
working software in no time at all.</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-8.svg" alt="Vibe coding is great as long as you don&#39;t need to think." title="Vibe coding is great as long as you don&#39;t need to think."/></p>
<p>But you <em>will</em> hit a wall of complexity that AI is incapable of scaling alone.</p>
<p>Building prototypes is now easier than ever. But if we want to effectively use LLMs to
accelerate delivery of real, complex, secure, working software, and to realise more than
marginal efficiency gains, we need to write a new playbook of engineering practices tailored
to maximise collaboration between engineering teams that include both humans and LLMs.</p>
<h2>How to avoid the AI coding trap</h2>
<p>AI coding agents are dazzlingly productive, but lack in-depth knowledge of your business,
codebase, or roadmap. Left unchecked, they will happily churn
out thousands of lines of code with no heed paid to design, consistency, or maintainability.
The job of the engineer, then, is to act as a tech lead to these hotshots: to provide the structure,
standards, and processes that convert raw speed into sustainable delivery.</p>
<p>We need a new playbook for how to deliver working software efficiently, and we can look to the
past to learn how to do that. By treating LLMs as <strong>lightning-fast junior engineers</strong>, we
can lean on best practices from the software development lifecycle to build systems that scale.</p>
<p><img src="https://chrisloy.dev/images/2025/ai-coding-9.svg" alt="AI can be used at every stage of the software development lifecycle." title="AI can be used at every stage of the software development lifecycle."/></p>
<p>Just as tech leads don&#39;t just write code but set practices for the team, engineers
now need to set practices for AI agents. That means bringing AI into every stage of
the lifecycle:</p>
<blockquote>
<p><strong>Specification</strong>: exploring, analysing, and refining feature specifications to cover edge cases and narrow focus.</p>
</blockquote>
<blockquote>
<p><strong>Documentation</strong>: generating and reviewing documentation up front to provide reusable guardrails and lasting evidence.</p>
</blockquote>
<blockquote>
<p><strong>Modular Design</strong>: scaffolding modular architectures to control context scope and maximise comprehension.</p>
</blockquote>
<blockquote>
<p><strong>Test-Driven Development</strong>: generating extensive test cases prior to implementation to guide implementation and prevent regression.</p>
</blockquote>
<blockquote>
<p><strong>Coding Standards</strong>: applying house styles and best practice when generating code, through context engineering.</p>
</blockquote>
<blockquote>
<p><strong>Monitoring &amp; Introspection</strong>: analysing logs and extracting insights faster than any human ever could.</p>
</blockquote>
<p>By understanding that delivering software is so much more than just writing code, we can
avoid the AI coding trap and instead hugely amplify our ability to deliver working, scalable software.</p></article></div>
  </body>
</html>
