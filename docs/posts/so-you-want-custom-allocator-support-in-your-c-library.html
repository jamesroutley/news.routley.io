<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2023/12/17/">Original</a>
    <h1>So you want custom allocator support in your C library</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  
  <time datetime="2023-12-17">
    December 17, 2023
  </time>
  <p>
    nullprogram.com/blog/2023/12/17/
  </p>

  <p>Users of mature C libraries conventionally get to choose how memory is
allocated — that is, when it <a href="https://nullprogram.com/blog/2018/06/10/">cannot be avoided entirely</a>. The C
standard never laid down a convention — <a href="https://nullprogram.com/blog/2023/02/11/">perhaps for the better</a> —
so each library re-invents an allocator interface. Not all are created
equal, and most repeat a few fundamental mistakes. Often the interface is
merely a token effort, to check off that it’s “supported” without actual
consideration to its use. This article describes the critical features of
a practical allocator interface, and demonstrates why they’re important.</p>

<p>Before diving into the details, here’s the checklist for library authors:</p>

<ol>
  <li>All allocation functions accept a user-defined context pointer.</li>
  <li>The “free” function accepts the original allocation size.</li>
  <li>The “realloc” function accepts both old and new size.</li>
</ol>

<h3 id="context-pointer">Context pointer</h3>

<p>The standard library allocator keeps its state in global variables. This
makes for a simple interface, but comes with significant performance and
complexity costs. These costs likely motivate custom allocator use in the
first place, in which case slavishly duplicating the standard interface is
essentially the worst possible option. Unfortunately this is typical:</p>

<div><div><pre><code><span>#define LIB_MALLOC  malloc
#define LIB_FREE    free
</span></code></pre></div></div>

<p>I could observe the library’s allocations, and I could swap in a library
functionality equivalent to the standard library allocator — jemalloc,
mimalloc, etc. — but that’s about it. Better than nothing, I suppose, but
only just so. Function pointer callbacks are slightly better:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>void</span> <span>*</span><span>(</span><span>*</span><span>malloc</span><span>)(</span><span>size_t</span><span>);</span>
    <span>void</span>  <span>(</span><span>*</span><span>free</span><span>)(</span><span>void</span> <span>*</span><span>);</span>
<span>}</span> <span>allocator</span><span>;</span>

<span>session</span> <span>*</span><span>session_new</span><span>(...,</span> <span>allocator</span><span>);</span>
</code></pre></div></div>

<p>At least I could use different allocators at different times, and there
are even <a href="https://nullprogram.com/blog/2017/01/08/">tricks to bind a context pointer</a> to the callback. It
also works when the library is dynamically linked.</p>

<p>Either case barely qualifies as custom allocator support, and they’re
useless when it matters most. Only a small ingredient is needed to make
these interfaces useful: a context pointer.</p>

<div><div><pre><code><span>// NOTE: Better, but still not great</span>
<span>typedef</span> <span>struct</span> <span>{</span>
    <span>void</span> <span>*</span><span>(</span><span>*</span><span>malloc</span><span>)(</span><span>size_t</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>);</span>
    <span>void</span>  <span>(</span><span>*</span><span>free</span><span>)(</span><span>void</span> <span>*</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>);</span>
    <span>void</span>   <span>*</span><span>ctx</span><span>;</span>
<span>}</span> <span>allocator</span><span>;</span>
</code></pre></div></div>

<p>Users can choose <em>from where</em> the library will allocate at at given time.
It liberates the allocator from global variables (or janky workarounds),
and multithreading woes. The default can still hook up to the standard
library through stubs that fit these interfaces.</p>

<div><div><pre><code><span>static</span> <span>void</span> <span>*</span><span>lib_malloc</span><span>(</span><span>size_t</span> <span>size</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>)</span>
<span>{</span>
    <span>(</span><span>void</span><span>)</span><span>ctx</span><span>;</span>
    <span>return</span> <span>malloc</span><span>(</span><span>size</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span> <span>*</span><span>lib_free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>)</span>
<span>{</span>
    <span>(</span><span>void</span><span>)</span><span>ctx</span><span>;</span>
    <span>free</span><span>(</span><span>ptr</span><span>);</span>
<span>}</span>

<span>static</span> <span>allocator</span> <span>lib_allocator</span> <span>=</span> <span>{</span><span>lib_malloc</span><span>,</span> <span>lib_free</span><span>,</span> <span>0</span><span>};</span>
</code></pre></div></div>

<p>Note that the context pointer came after the “standard” arguments. All
things being equal, “extra” arguments should go after standard ones. But
don’t sweat it! In the most common calling conventions this allows stub
implementations to be merely an unconditional jump. It’s <em>as though</em> the
stubs are a kind of subtype of the original functions.</p>

<div><div><pre><code><span>lib_malloc:</span>
        <span>jmp</span> <span>malloc</span>
<span>lib_free:</span>
        <span>jmp</span> <span>free</span>
</code></pre></div></div>

<p>Typically the decision is completely arbitrary, and so this minutia tips
the balance.</p>

<h4 id="context-pointer-example">Context pointer example</h4>

<p>So what’s the big deal? It means we can trivially plug in, say, a <a href="https://nullprogram.com/blog/2023/09/27/">tiny
arena allocator</a>. To demonstrate, consider this fictional string
set and partial JSON API, each of which supports a custom allocator. For
simplicity — I’m attempting to balance substance and brevity — they share
an allocator interface. (Note: Because <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf">subscripts and sizes should be
signed</a>, and we’re now breaking away from the standard library
allocator, I will use <code>ptrdiff_t</code> for the rest of the examples.)</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>void</span> <span>*</span><span>(</span><span>*</span><span>malloc</span><span>)(</span><span>ptrdiff_t</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>);</span>
    <span>void</span>  <span>(</span><span>*</span><span>free</span><span>)(</span><span>void</span> <span>*</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>);</span>
    <span>void</span>   <span>*</span><span>ctx</span><span>;</span>
<span>}</span> <span>allocator</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>set</span> <span>set</span><span>;</span>
<span>set</span>  <span>*</span><span>set_new</span><span>(</span><span>allocator</span> <span>*</span><span>);</span>
<span>set</span>  <span>*</span><span>set_free</span><span>(</span><span>set</span> <span>*</span><span>);</span>
<span>bool</span>  <span>set_add</span><span>(</span><span>set</span> <span>*</span><span>,</span> <span>char</span> <span>*</span><span>);</span>

<span>typdef</span> <span>struct</span> <span>json</span> <span>json</span><span>;</span>
<span>json</span>     <span>*</span><span>json_load</span><span>(</span><span>char</span> <span>*</span><span>buf</span><span>,</span> <span>ptrdiff_t</span> <span>len</span><span>,</span> <span>allocator</span> <span>*</span><span>);</span>
<span>json</span>     <span>*</span><span>json_free</span><span>(</span><span>json</span> <span>*</span><span>);</span>
<span>ptrdiff_t</span> <span>json_length</span><span>(</span><span>json</span> <span>*</span><span>);</span>
<span>json</span>     <span>*</span><span>json_subscript</span><span>(</span><span>json</span> <span>*</span><span>,</span> <span>ptrdiff_t</span> <span>i</span><span>);</span>
<span>json</span>     <span>*</span><span>json_getfield</span><span>(</span><span>json</span> <span>*</span><span>,</span> <span>char</span> <span>*</span><span>field</span><span>);</span>
<span>double</span>    <span>json_getnumber</span><span>(</span><span>json</span> <span>*</span><span>);</span>
<span>char</span>     <span>*</span><span>json_getstring</span><span>(</span><span>json</span> <span>*</span><span>);</span>
</code></pre></div></div>

<p><code>set</code> and <code>json</code> objects retain a copy of the <code>allocator</code> object for all
allocations made through that object. Given nothing, they default to the
standard library using the pass-through definitions above. Used together
with the standard library allocator:</p>

<div><div><pre><code><span>typedef</span> <span>{</span>
    <span>double</span> <span>sum</span><span>;</span>
    <span>bool</span>   <span>ok</span><span>;</span>
<span>}</span> <span>sum_result</span><span>;</span>

<span>sum_result</span> <span>sum_unique</span><span>(</span><span>char</span> <span>*</span><span>json</span><span>,</span> <span>ptrdiff_t</span> <span>len</span><span>)</span>
<span>{</span>
    <span>sum_result</span> <span>r</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>json</span> <span>*</span><span>namevals</span> <span>=</span> <span>json_load</span><span>(</span><span>json</span><span>,</span> <span>len</span><span>,</span> <span>0</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>namevals</span><span>)</span> <span>{</span>
        <span>return</span> <span>r</span><span>;</span>  <span>// parse error</span>
    <span>}</span>

    <span>ptrdiff_t</span> <span>arraylen</span> <span>=</span> <span>json_length</span><span>(</span><span>namevals</span><span>);</span>
    <span>if</span> <span>(</span><span>arraylen</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>json_free</span><span>(</span><span>namevals</span><span>);</span>
        <span>return</span> <span>r</span><span>;</span>  <span>// not an array</span>
    <span>}</span>

    <span>set</span> <span>*</span><span>seen</span> <span>=</span> <span>set_new</span><span>(</span><span>0</span><span>);</span>
    <span>for</span> <span>(</span><span>ptrdiff_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>arraylen</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>json</span> <span>*</span><span>element</span> <span>=</span> <span>json_subscript</span><span>(</span><span>namevals</span><span>,</span> <span>i</span><span>);</span>
        <span>char</span> <span>*</span><span>name</span>    <span>=</span> <span>json_getfield</span><span>(</span><span>element</span><span>,</span> <span>&#34;name&#34;</span><span>);</span>
        <span>char</span> <span>*</span><span>value</span>   <span>=</span> <span>json_getfield</span><span>(</span><span>element</span><span>,</span> <span>&#34;value&#34;</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>name</span> <span>||</span> <span>!</span><span>value</span><span>)</span> <span>{</span>
            <span>set_free</span><span>(</span><span>set</span><span>);</span>
            <span>json_free</span><span>(</span><span>namevals</span><span>);</span>
            <span>return</span> <span>r</span><span>;</span>  <span>// invalid element</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>set_add</span><span>(</span><span>set</span><span>,</span> <span>name</span><span>))</span> <span>{</span>
            <span>r</span><span>.</span><span>sum</span> <span>+=</span> <span>json_getnumber</span><span>(</span><span>value</span><span>);</span>
        <span>}</span>
    <span>}</span>

    <span>set_free</span><span>(</span><span>set</span><span>);</span>
    <span>json_free</span><span>(</span><span>namevals</span><span>);</span>
    <span>r</span><span>.</span><span>ok</span> <span>=</span> <span>1</span><span>;</span>
    <span>return</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Which given as JSON input:</p>

<div><div><pre><code><span>[</span><span>
    </span><span>{</span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;value&#34;</span><span>:</span><span>  </span><span>123</span><span>},</span><span>
    </span><span>{</span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;bar&#34;</span><span>,</span><span> </span><span>&#34;value&#34;</span><span>:</span><span>  </span><span>456</span><span>},</span><span>
    </span><span>{</span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>1000</span><span>}</span><span>
</span><span>]</span><span>
</span></code></pre></div></div>

<p>Would return <code>579.0</code>. Because it’s using standard library allocation, it
must carefully clean up before returning. There’s also no out-of-memory
handling because, in practice, programs typically do not get to observe
and respond to the standard allocator running out of memory.</p>

<p>We can improve and simplify it with an arena allocator:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>char</span>    <span>*</span><span>beg</span><span>;</span>
    <span>char</span>    <span>*</span><span>end</span><span>;</span>
    <span>jmp_buf</span> <span>*</span><span>oom</span><span>;</span>
<span>}</span> <span>arena</span><span>;</span>

<span>void</span> <span>*</span><span>arena_malloc</span><span>(</span><span>ptrdiff_t</span> <span>size</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>)</span>
<span>{</span>
    <span>arena</span> <span>*</span><span>a</span> <span>=</span> <span>ctx</span><span>;</span>
    <span>ptrdiff_t</span> <span>available</span> <span>=</span> <span>a</span><span>-&gt;</span><span>end</span> <span>-</span> <span>a</span><span>-&gt;</span><span>beg</span><span>;</span>
    <span>ptrdiff_t</span> <span>alignment</span> <span>=</span> <span>-</span><span>size</span> <span>&amp;</span> <span>15</span><span>;</span>
    <span>if</span> <span>(</span><span>size</span> <span>&gt;</span> <span>available</span><span>-</span><span>alignment</span><span>)</span> <span>{</span>
        <span>longjmp</span><span>(</span><span>*</span><span>a</span><span>-&gt;</span><span>oom</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>a</span><span>-&gt;</span><span>end</span> <span>-=</span> <span>size</span> <span>+</span> <span>alignment</span><span>;</span>
<span>}</span>

<span>void</span> <span>arena_free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>)</span>
<span>{</span>
    <span>// nothing to do (yet!)</span>
<span>}</span>
</code></pre></div></div>

<p>I’m allocating from the end rather than the beginning because it will make
a later change simpler. Applying that to the function:</p>

<div><div><pre><code><span>sum_result</span> <span>sum_unique</span><span>(</span><span>char</span> <span>*</span><span>json</span><span>,</span> <span>ptrdiff_t</span> <span>len</span><span>,</span> <span>arena</span> <span>scratch</span><span>)</span>
<span>{</span>
    <span>sum_result</span> <span>r</span> <span>=</span> <span>{</span><span>0</span><span>};</span>

    <span>allocator</span> <span>a</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>a</span><span>.</span><span>malloc</span> <span>=</span> <span>arena_malloc</span><span>;</span>
    <span>a</span><span>.</span><span>free</span> <span>=</span> <span>arena_free</span><span>;</span>
    <span>a</span><span>.</span><span>ctx</span> <span>=</span> <span>&amp;</span><span>scratch</span><span>;</span>

    <span>json</span> <span>*</span><span>namevals</span> <span>=</span> <span>json_load</span><span>(</span><span>json</span><span>,</span> <span>len</span><span>,</span> <span>&amp;</span><span>a</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>namevals</span><span>)</span> <span>{</span>
        <span>return</span> <span>r</span><span>;</span>  <span>// parse error</span>
    <span>}</span>

    <span>ptrdiff_t</span> <span>arraylen</span> <span>=</span> <span>json_length</span><span>(</span><span>namevals</span><span>);</span>
    <span>if</span> <span>(</span><span>arraylen</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>r</span><span>;</span>  <span>// not an array</span>
    <span>}</span>

    <span>set</span> <span>*</span><span>seen</span> <span>=</span> <span>set_new</span><span>(</span><span>&amp;</span><span>a</span><span>);</span>
    <span>for</span> <span>(</span><span>ptrdiff_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>arraylen</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>json</span> <span>*</span><span>element</span> <span>=</span> <span>json_subscript</span><span>(</span><span>namevals</span><span>,</span> <span>i</span><span>);</span>
        <span>char</span> <span>*</span><span>name</span>    <span>=</span> <span>json_getfield</span><span>(</span><span>element</span><span>,</span> <span>&#34;name&#34;</span><span>);</span>
        <span>char</span> <span>*</span><span>value</span>   <span>=</span> <span>json_getfield</span><span>(</span><span>element</span><span>,</span> <span>&#34;value&#34;</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>name</span> <span>||</span> <span>!</span><span>value</span><span>)</span> <span>{</span>
            <span>return</span> <span>r</span><span>;</span>  <span>// invalid element</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>set_add</span><span>(</span><span>set</span><span>,</span> <span>name</span><span>))</span> <span>{</span>
            <span>r</span><span>.</span><span>sum</span> <span>+=</span> <span>json_getnumber</span><span>(</span><span>value</span><span>);</span>
        <span>}</span>
    <span>}</span>
    <span>r</span><span>.</span><span>ok</span> <span>=</span> <span>1</span><span>;</span>
    <span>return</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Calls to <code>set_free</code> and <code>json_free</code> are no longer necessary because the
arena automatically frees these on any return, in O(1). I almost feel bad
the library authors bothered to write them! It also handles allocation
failure without introducing it to <code>sum_unique</code>. We may even deliberately
restrict the memory available to this function — perhaps because the input
is untrusted, and we want to quickly abort denial-of-service attacks — by
giving it a small arena, relying on out-of-memory to reject pathological
inputs.</p>

<p>There are so many possibilities unlocked by the context pointer.</p>

<h3 id="provide-the-original-allocation-size-when-freeing">Provide the original allocation size when freeing</h3>

<p>When an application frees an object it always has the original, requested
allocation size on hand. After all, it’s a necessary condition to use the
object correctly. In the simplest case it’s the size of the freed object’s
type: a static quantity. If it’s an array, then it’s a multiple of the
tracked capacity: a dynamic quantity. In any case the size is either known
statically or tracked dynamically by the application.</p>

<p>Yet <code>free()</code> does not accept a size, meaning that the allocator must track
the information redundantly! That’s a needless burden on custom
allocators, and with a bit of care a library can lift it.</p>

<p>This was noticed in C++, and WG21 added <a href="https://isocpp.org/files/papers/n3778.html">sized deallocation</a> in
C++14. It’s now the default on two of the three major implementations (and
probably not the two you’d guess). In other words, object size is so
readily available that it can mostly be automated away. Notable exception:
<code>operator new[]</code> and <code>operator delete[]</code> with trivial destructors. With
non-trivial destructors, <code>operator new[]</code> must track the array length for
its its own purposes <em>on top of libc bookkeeping</em>. In other words, array
allocations have their size stored in at least three different places!</p>

<p>That means the “free” interface should look like this:</p>

<div><div><pre><code><span>void</span> <span>*</span><span>lib_free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>ptrdiff_t</span> <span>len</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>);</span>
</code></pre></div></div>

<p>And calls inside the library might look like:</p>

<div><div><pre><code><span>lib_free</span><span>(</span><span>p</span><span>,</span> <span>sizeof</span><span>(</span><span>*</span><span>p</span><span>));</span>
<span>lib_free</span><span>(</span><span>a</span><span>,</span> <span>sizeof</span><span>(</span><span>*</span><span>a</span><span>)</span><span>*</span><span>len</span><span>);</span>
</code></pre></div></div>

<p>Now that <code>arena_free</code> has size information, it can free an allocation if
it was the most recent:</p>

<div><div><pre><code><span>void</span> <span>arena_free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>ptrdiff_t</span> <span>size</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>)</span>
<span>{</span>
    <span>arena</span> <span>*</span><span>a</span> <span>=</span> <span>ctx</span><span>;</span>
    <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>a</span><span>-&gt;</span><span>end</span><span>)</span> <span>{</span>
        <span>ptrdiff_t</span> <span>alignment</span> <span>+=</span> <span>-</span><span>size</span> <span>&amp;</span> <span>15</span><span>;</span>
        <span>a</span><span>-&gt;</span><span>end</span> <span>+=</span> <span>size</span> <span>+</span> <span>alignment</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>If the library allocates short-lived objects to compute some value, then
discards in reverse order, the memory can be reused. The arena doesn’t
have to do anything special. The library merely needs to share its
knowledge with the allocator.</p>

<p>Beyond arena allocation, an allocator could use the size to locate the
allocation’s size class and, say, push it onto a freelist of its size
class. <a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U">Size-class freelists compose well with arenas</a>, and an
implementation is short and simple when the caller of “free” communicates
object size.</p>

<p>Another idea: During testing, use a debug allocator that tracks object
size and validates the reported size against its own bookkeeping. This can
help catch mistakes sooner.</p>

<h3 id="provide-the-old-size-when-resizing-an-allocation">Provide the old size when resizing an allocation</h3>

<p>Resizing an allocation requires a lot from an allocator, and it should be
avoided if possible. At the very least it cannot be done <em>at all</em> without
knowing the original allocation size. An allocator can’t simply no-op it
like it can with “free.” With the standard library interface, allocators
have no choice but to redundantly track object sizes when “realloc” is
required.</p>

<p>So, just as with “free,” the allocator should be given the old object
size!</p>

<div><div><pre><code><span>void</span> <span>*</span><span>lib_realloc</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>ptrdiff_t</span> <span>old</span><span>,</span> <span>ptrdiff_t</span> <span>new</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>);</span>
</code></pre></div></div>

<p>At the very least, an allocator could implement “realloc” with “malloc”
and <code>memcpy</code>:</p>

<div><div><pre><code><span>void</span> <span>arena_realloc</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>ptrdiff_t</span> <span>old</span><span>,</span> <span>ptrdiff_t</span> <span>new</span><span>,</span> <span>void</span> <span>*</span><span>ctx</span><span>)</span>
<span>{</span>
    <span>void</span> <span>*</span><span>r</span> <span>=</span> <span>arena_malloc</span><span>(</span><span>new</span><span>,</span> <span>ctx</span><span>);</span>
    <span>return</span> <span>memcpy</span><span>(</span><span>r</span><span>,</span> <span>ptr</span><span>,</span> <span>old</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Of the three checklist items, this is the most neglected. Exercise for the
reader: The last-allocated object <em>can</em> be resized in place, instead using
<code>memmove</code>. If this is frequently expected, allocate from the front, adjust
<code>arena_free</code> as needed, and extend the allocation in place <a href="https://nullprogram.com/blog/2023/10/05/#addendum-extend-the-last-allocation">as discussed a
previous addendum</a>, without any copying.</p>

<h3 id="real-world-examples">Real world examples</h3>

<p>Let’s examine real world examples to see how well they fit the checklist.
First up is <a href="https://troydhanson.github.io/uthash/userguide.html#_hooks">uthash</a>, a popular, easy-to-use, intrusive hash table:</p>

<div><div><pre><code><span>#define uthash_malloc(sz) my_malloc(sz)
#define uthash_free(ptr, sz) my_free(ptr)
</span></code></pre></div></div>

<p>No “realloc” so it trivially checks (3). It optionally provides the old
size to “free” which checks (2). However it misses (1) which is the most
important, greatly limiting its usefulness.</p>

<p>Next is the venerable <a href="https://www.zlib.net/manual.html">zlib</a>. It has function pointers with these
prototypes on its <code>z_stream</code> object.</p>

<div><div><pre><code><span>void</span> <span>*</span><span>zlib_malloc</span><span>(</span><span>void</span> <span>*</span><span>ctx</span><span>,</span> <span>unsigned</span> <span>items</span><span>,</span> <span>unsigned</span> <span>size</span><span>);</span>
<span>void</span>  <span>zlib_free</span><span>(</span><span>void</span> <span>*</span><span>ctx</span><span>,</span> <span>void</span> <span>*</span><span>ptr</span><span>);</span>
</code></pre></div></div>

<p>The context pointer checks (1), and I can confirm from experience that
it’s genuinely useful with a custom allocator. No “realloc” so it passes
(3) automatically. It misses (2), but in practice this hardly matters: It
allocates everything up front, and frees at the very end, meaning a no-op
“free” is quite sufficient.</p>

<p>Finally there’s the <a href="https://www.lua.org/manual/5.4/manual.html#lua_Alloc">Lua programming language</a> with this economical,
single-function interface:</p>

<div><div><pre><code><span>void</span> <span>*</span><span>lua_Alloc</span><span>(</span><span>void</span> <span>*</span><span>ctx</span><span>,</span> <span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>size_t</span> <span>old</span><span>,</span> <span>size_t</span> <span>new</span><span>);</span>
</code></pre></div></div>

<p>It packs all three allocator functions into one function. It includes a
context pointer (1), a free size (2), and two realloc sizes (3). It’s a
simple allocator’s best friend!</p>



  
  <ol></ol>

  

  <nav>
  
    
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
