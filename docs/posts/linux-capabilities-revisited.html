<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dfir.ch/posts/linux_capabilities/">Original</a>
    <h1>Linux Capabilities Revisited</h1>
    
    <div id="readability-page-1" class="page"><div>
                <h2 id="introduction">Introduction</h2>
<p><strong>Notes to kernel developers</strong>: <em>The goal of capabilities is divide the power of superuser into pieces, such that if a program that has one or more capabilities is compromised, its power to do damage to the system would be less than the same program running with root privilege.</em> <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">Capabilities(7) — Linux manual page</a></p>
<p><code>Capabilities</code> are a fine-grained access control mechanism in Linux, allowing more granular permissions than the traditional superuser (<code>root</code>) model. Capabilities divide the privileges typically associated with the root user into distinct units that can be independently enabled or disabled for different processes. This allows for more secure and controlled privilege management.</p>
<p>For example, a process may need permission to bind to privileged ports but not require any other elevated permissions.</p>
<h2 id="understanding-capabilities">Understanding Capabilities</h2>
<p>To see how many capabilities our Linux host is aware of, we can query the file <code>cap_last_cap</code> inside the <code>/proc</code> directory:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># cat /proc/sys/kernel/cap_last_cap</span>
</span></span><span><span><span>40</span>
</span></span></code></pre></div><p>The <code>capsh --print</code> command displays the current capabilities and related settings of the shell or the process invoking the command. When executing this command on our Linux host, we see the full list of capabilities.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># capsh --print</span>
</span></span><span><span>Current: <span>=</span>ep
</span></span><span><span>Bounding <span>set</span> <span>=</span>cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
</span></span></code></pre></div><p>Each capability corresponds to a specific privileged action.</p>
<h2 id="backdooring-python">Backdooring Python</h2>
<p>The command <code>setcap</code> sets file capabilities on an executable. The <code>cap_setuid</code> capability allows a process to make arbitrary manipulations of user IDs (UIDs), including setting the UID to a value that would otherwise be restricted (i.e. <code>UID 0</code>, the root user). <code>setcap</code> takes a set of parameters, where</p>
<ul>
<li><code>e</code>: Effective means the capability is activated</li>
<li><code>p</code>: Permitted means the capability can be used/is allowed.</li>
</ul>
<p>Putting this together, we’re adding the <code>cap_setuid</code> capabilities to the Python binary:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># setcap cap_setuid+ep /usr/bin/python3.12</span>
</span></span></code></pre></div><p>One can find a list of supported capabilities here:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># cat /usr/include/linux/capability.h</span>
</span></span></code></pre></div><h2 id="testing">Testing</h2>
<p>For testing purposes, we created a new user (<code>malmoeb</code>) and switched to the context of this user (<code>useradd &amp;&amp; su</code>):</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># useradd -m malmoeb</span>
</span></span><span><span><span># su malmoeb</span>
</span></span><span><span>$ id
</span></span><span><span><span>uid</span><span>=</span>1000<span>(</span>malmoeb<span>)</span> <span>gid</span><span>=</span>1000<span>(</span>malmoeb<span>)</span> <span>groups</span><span>=</span>1000<span>(</span>malmoeb<span>)</span>
</span></span></code></pre></div><p>Using the following command line, we set the UID of the bash shell we are calling with Python to 0 (<code>UID 0 == root</code>), effectively spawning a root shell:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ /usr/bin/python3 -c <span>&#39;import os;os.setuid(0);os.system(&#34;/bin/bash&#34;)&#39;</span>
</span></span><span><span><span># id</span>
</span></span><span><span><span>uid</span><span>=</span>0<span>(</span>root<span>)</span> <span>gid</span><span>=</span>1000<span>(</span>malmoeb<span>)</span> <span>groups</span><span>=</span>1000<span>(</span>malmoeb<span>)</span>
</span></span></code></pre></div><p>The exciting thing about this technique is that we have not set a suid bit on a binary, or changed the Python binary. By setting the capabilities, we, as attackers, can build a powerful backdoor.</p>
<h2 id="hunting">Hunting</h2>
<p>Traditionally, system administrators and security professionals have focused on finding <code>SUID</code> (Set User ID) and <code>SGID</code> (Set Group ID) files, because these files can be used to escalate privileges under certain conditions. However, with the introduction of POSIX capabilities, it is now equally important to hunt for files with capabilities set, as demonstrated above.</p>
<p>Enumerating all binaries with capabilities set is possible with the command <code>getcap -r</code>:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># getcap -r / 2&gt;/dev/null</span>
</span></span><span><span>/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper cap_net_bind_service,cap_net_admin,cap_sys_nice<span>=</span>ep
</span></span><span><span>/usr/bin/mtr-packet <span>cap_net_raw</span><span>=</span>ep
</span></span><span><span>/usr/bin/ping <span>cap_net_raw</span><span>=</span>ep
</span></span><span><span>/usr/bin/python3.12 <span>cap_setuid</span><span>=</span>ep
</span></span></code></pre></div><p>Inside the /proc directory:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># cat /proc/1143966/status | grep Cap</span>
</span></span></code></pre></div><p>where:</p>
<ul>
<li><code>CapInh</code> = Inherited capabilities</li>
<li><code>CapPrm</code> = Permitted capabilities</li>
<li><code>CapEff</code> = Effective capabilities</li>
<li><code>CapBnd</code> = Bounding set</li>
<li><code>CapAmb</code> = Ambient capabilities set</li>
</ul>
<p>Utilising the command <code>capsh</code>, we decode the capabilities as follows:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># capsh --decode=0000000000000080</span>
</span></span><span><span><span>0x0000000000000080</span><span>=</span>cap_setuid
</span></span></code></pre></div><p>Or with the command <code>getpcaps</code>, passing the PID as an argument:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># getpcaps 1143966</span>
</span></span><span><span>Capabilities <span>for</span> <span>`</span>1143966<span>&#39;</span>: <span>=</span> cap_setuid+ep
</span></span></code></pre></div><p>Remove the capabilities from a binary with <code>setcap -r</code></p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># setcap -r /usr/bin/python3.12</span>
</span></span></code></pre></div><h2 id="linpeas">LinPeas</h2>
<p><a href="https://github.com/peass-ng/PEASS-ng/tree/master/linPEAS">LinPEAS</a>, the <em>Linux Privilege Escalation Awesome Script</em>, also performs some checks to find (interesting) capabilities. Following the commands taken directly from the relevant <a href="https://github.com/peass-ng/PEASS-ng/blob/516aafff276ce486866e30e9553146cf912f591d/linPEAS/builder/linpeas_parts/8_interesting_perms_files/4_Capabilities.sh">script</a>:</p>
<ul>
<li><strong>Current shell capabilities:</strong> <code>cat &#34;/proc/$$/status&#34;</code></li>
<li><strong>Parent process capabilities:</strong> <code>cat &#34;/proc/$PPID/status&#34;</code></li>
<li><strong>Files with capabilities:</strong> <code>getcap -r / 2&gt;/dev/null</code></li>
</ul>
<p>Besides checking for <code>suid</code> files, LinPEAS does an excellent job here for searching for (hidden) capabilities discussed so far.</p>
<h2 id="elastic-rule-process-capability-set-via-setcap-utility">Elastic rule: Process Capability Set via setcap Utility</h2>
<p>Elastic “<em>detects the use of the setcap utility to set capabilities on a process.</em>” See <a href="https://www.elastic.co/docs/reference/security/prebuilt-rules/rules/linux/persistence_process_capability_set_via_setcap">here</a> for the full description.</p>
<div><pre tabindex="0"><code data-lang="sql"><span><span><span>process</span><span> </span><span>where</span><span> </span><span>host</span><span>.</span><span>os</span><span>.</span><span>type</span><span> </span><span>==</span><span> </span><span>&#34;linux&#34;</span><span> </span><span>and</span><span> </span><span>event</span><span>.</span><span>type</span><span> </span><span>==</span><span> </span><span>&#34;start&#34;</span><span> </span><span>and</span><span> </span><span>event</span><span>.</span><span>action</span><span> </span><span>in</span><span> </span><span>(</span><span>&#34;exec&#34;</span><span>,</span><span> </span><span>&#34;exec_event&#34;</span><span>,</span><span> </span><span>&#34;start&#34;</span><span>)</span><span> </span><span>and</span><span>
</span></span></span><span><span><span></span><span>process</span><span>.</span><span>name</span><span> </span><span>==</span><span> </span><span>&#34;setcap&#34;</span><span> </span><span>and</span><span> </span><span>not</span><span> </span><span>(</span><span>
</span></span></span><span><span><span>  </span><span>process</span><span>.</span><span>parent</span><span>.</span><span>executable</span><span> </span><span>==</span><span> </span><span>null</span><span> </span><span>or</span><span>
</span></span></span><span><span><span>  </span><span>process</span><span>.</span><span>parent</span><span>.</span><span>executable</span><span> </span><span>:</span><span> </span><span>(</span><span>&#34;/var/lib/dpkg/*&#34;</span><span>,</span><span> </span><span>&#34;/var/lib/docker/*&#34;</span><span>,</span><span> </span><span>&#34;/tmp/newroot/*&#34;</span><span>,</span><span> </span><span>&#34;/var/tmp/newroot/*&#34;</span><span>)</span><span> </span><span>or</span><span>
</span></span></span><span><span><span>  </span><span>process</span><span>.</span><span>parent</span><span>.</span><span>name</span><span> </span><span>in</span><span> </span><span>(</span><span>&#34;jem&#34;</span><span>,</span><span> </span><span>&#34;vzctl&#34;</span><span>)</span><span>
</span></span></span><span><span><span></span><span>)</span><span>
</span></span></span></code></pre></div><h2 id="securitycapability">security.capability</h2>
<p>Extended permissions—such as <code>access control lists</code> (ACLs) set with <a href="https://dfir.ch/posts/today_i_learned_setfacl/">setfacl</a> and capability flags set with <code>setcap</code> are stored in the same location as traditional permission bits and setuid/setgid flags configured via chmod: the file’s inode.</p>
<p>The <code>ls</code> command does not display capability flags set by <code>setcap</code>. To view them, use <code>getcap</code>. To list all extended attributes, you can use <code>getfattr -d -m -</code>. The attribute <code>setcap</code> uses is <code>security.capability</code>, and it’s stored in a binary format that <code>getcap</code> conveniently decodes for you.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># getfattr -d -m - /usr/bin/python3.12 </span>
</span></span><span><span>getfattr: Removing leading <span>&#39;/&#39;</span> from absolute path names
</span></span><span><span>    <span># file: usr/bin/python3.12</span>
</span></span><span><span>security.capability<span>=</span><span>0sAQAAAoAAAAAAAAAAAAAAAAAAAAA</span><span>=</span>
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>While traditional SUID/SGID checks are still crucial, modern security practices must include hunting for files with specific capabilities set. Capabilities provide a more granular and potentially stealthy way to grant necessary privileges, and if not monitored, they can introduce significant security risks. Using tools like <code>getcap</code> to search the file system for these capabilities recursively is essential to ensure a comprehensive security audit and to mitigate potential exploitation vectors.</p>
<p>We have not touched upon <code>user capabilities</code>, which are stored in the <a href="https://manpages.ubuntu.com/manpages/focal/man5/capability.conf.5.html">/etc/security/capability.conf</a> configuration file, or the <code>service files</code>, where you can specify <code>AmbientCapabilities</code>.  The following section presents two good resources for an in-depth discussion of this topic.</p>
<h2 id="references">References</h2>
<p>Here are two recommended websites if you want to dig deeper into this topic:</p>
<ul>
<li><a href="https://juggernaut-sec.com/capabilities/">Capabilities – Linux Privilege Escalation</a></li>
<li><a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities">Linux Capabilities</a></li>
</ul>

            </div></div>
  </body>
</html>
