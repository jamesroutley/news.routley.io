<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ganssle.com/debouncing.htm">Original</a>
    <h1>How to Debounce a Contact (2014)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  <section id="mainContent"> 

  <!-- Main content starts here --> 
  <!-- InstanceBeginEditable name="EditRegion3" --> 

<!-- #EndLibraryItem -->
<p>This page gives scope captures of how a number of switches actually bounce, and provides C code that eliminate that bouncing.</p>
<p>This report is divided into two parts:</p>
<ul>
  <li>Part 1 (which you&#39;re reading) describes the problem of debouncing and gives emperical data.</li>
  <li><a href="https://www.ganssle.com/debouncing-pt2.htm">Part 2</a> shows, first, hardware solutions and then software debouncing code.</li>
</ul>

<p>The beer warms a bit as you pound the remote control. Again and again, temper fraying, you click the &#34;channel up&#34; key until the TV finally rewards your efforts. But it turns out channel 345 is playing Jeopardy so you again wave the remote in the general direction of the set and continue fiddling with the buttons. </p>
<p>Some remotes work astonishingly well, even when you bounce the beam off three walls before it impinges on the TV&#39;s IR detector. Others don&#39;t. One vendor told me reliability simply isn&#39;t important as users will subconsciously hit the button again and again till the channel changes.</p>
          <p>When a single remote press causes the tube to jump two channels, we developers know lousy debounce code is at fault. The FM radio on my sailboat has a tuning button that advances too far when I hit it hard. The usual suspect: bounce. </p>
          <p>When the contacts of any mechanical switch bang together they rebound a bit before settling, causing bounce. Debouncing, of course, is the process of removing the bounces, of converting the brutish realities of the analog world into pristine ones and zeros. Both hardware and software solutions exist, though by far the most common are those done in a snippet of code.</p>
          <p>Surf the net to sample various approaches to debouncing. Most are pretty lame. Few are based on experimental bounce parameters. A medley of anecdotal tales passed around the newsgroups substitute for empirical evidence.</p>
          <p>Ask most developers about the characteristics of a bounce and they&#39;ll toss out a guess at a max bounce time. But there&#39;s an awful lot going on during the bounce. How can we build an effective bounce filter, in hardware or software, unless we understand the entire event? During that time a long and complex string of binary bits is hitting our code. What are the characteristics of that data?</p>
          <p>We&#39;re writing functions that process an utterly mysterious and unknown input string. That&#39;s hardly the right way to build reliable code.</p>
          <p><i>Suggestion: Subscribe to my free <a href="https://www.ganssle.com/tem-subunsub.html">newsletter</a> which often covers debouncing and related subjects.</i> </p>
          
          <p>So I ran some experiments.</p>
          <p>I pulled some old switches out of my junk box. 20 bucks at the ever-annoying local Radio Shack yielded more (have you noticed that Radio Shack has fewer and fewer components? It&#39;s getting hard to buy a lousy NPN transistor there).  Baynesville Electronics (<a href="http://www.baynesvilleelectronics.com">http://www.baynesvilleelectronics.com</a>), Baltimore&#39;s best electronics store, proved a switch treasure trove. Eventually I had 18 very different kinds of switches.</p>
          <p>My desktop PC always has a little $49 MSP430 (TI&#39;s greatly underrated 16 bit microprocessor) development board attached, with IAR&#39;s toolchain installed. It&#39;s a matter of seconds to pop a little code into the board and run experiments. Initially I&#39;d planned to connect each switch to an MSP430 input and have firmware read and report bounce parameters. A bit of playing around with the mixed signal scope (MSO) showed this to be an unwise approach. </p>
          <table>
            <tbody><tr>
              <td></td>
              <td><p>I gave up on regular oscilloscopes. Now my Agilent MSO-X 3054A MSO is my go-to scope. An MSO is a mixed-signal oscilloscope; it combines a logic analyzer and a scope. Trigger from either an analog channel or a digital pattern to start the trace, and see how the digital and analog interact.</p></td>
            </tr>
          </tbody></table><p>Many of the switches exhibited quite wild and unexpected behavior. Bounces of under 100 nsec were common (more on this later). No reasonable micro could reliably capture these sorts of transitions, so I abandoned that plan and instead used the scope, connecting both analog and digital channels to the switch. This let me see what was going on in the analog domain, and how a computer would interpret the data. A 5 volt supply and 1k pull-up completed the test jig.</p>
          <p>If a sub-100 nsec transition won&#39;t be captured by a computer why worry about it? Unfortunately, even a very short signal will toggle the logic once in a while. Tie it to an interrupt and the likelihood increases. Those transitions, though very short, will occasionally pervert the debounce routine. For the sake of the experiment we need to see them.</p>
          <p>I tested the trigger switches from an old cheap game-playing joystick (the three yellow ones in the picture), the left mouse button from an ancient Compaq computer (on PCB in upper left corner), toggle switches, pushbuttons, and slide switches. Some were chassis mount, others were to be soldered directly onto circuit boards.</p>
          <p><img src="https://www.ganssle.com/images/debswitches.jpg" width="451" height="329" alt="Switches used to develop debounce algorithm"/><br/>
          </p>
          <p><em>Switches tested. The upper left is switch A, with B to its right, working to E (in red), and then F below A, etc.</em></p>
<!-- ***** ID_START ***** -->
 
 
 
<!-- ***** ID_END ***** -->
          <p>The results were interesting.</p>
          
          <p>            So how long do switches bounce for? The short answer: sometimes a lot, sometimes not at all.</p>
          <p>Only two switches exhibited bounces exceeding 6200 µsec. Switch E, what seemed like a nice red pushbutton, had a worst case bounce when it opened of 157 msec - almost a 1/6 of a second! Yuk. Yet it never exceeded a 20 µsec bounce when closed. Go figure.</p>
          <p>Another switch took 11.3 msec to completely close one time; other actuations were all under 10 msec.</p>
          <p>Toss out those two samples and the other 16 switches exhibited an average 1557 µsec of bouncing, with, as I said, a max of 6200 µsec. Not bad at all.</p>
          <p>Seven of the switches consistently bounced much longer when closed than when opened. I was amazed to find that for most of the switches many bounces on opening lasted for less than 1 µsec - that&#39;s right, less than a millionth of a second. Yet the very next experiment on the same switch could yield a reading in the hundreds of microseconds. </p>
          <p>Identical switches were not particularly identical. Two matching pairs were tested; each twin differed from its brother by a factor of two.</p>
          <p>Years ago a pal and I installed a system for the Secret Service that had thousands of very expensive switches on panels in a control room. We battled with a unique set of bounce challenges because the uniformed officers were too lazy to stand up and press a button. They tossed rulers at the panels from across the room. Different impacts created (and sometimes destroyed, but hey, it&#39;s only taxpayer money after all) quite an array of bouncing. So in these experiments I tried to actuate each device with a variety of techniques. Pushing hard or soft, fast or slow, releasing gently or with a snap, looking for different responses. F, a slide switch, was indeed very sensitive to the rate of actuation. Toggle switch G showed a 3 to 1 difference in bounce times depending on how fast I bonked its lever. A few others showed similar results but there was little discernable pattern.</p>
          <p> <img src="https://www.ganssle.com/images/debouncetimes.jpg" width="500" alt="Bounce times of different switches"/><br/>
          </p>
          <p>I was fascinated with the switches&#39; analog behavior. A few operated as expected, yielding a solid zero or 5 volts. But most gave much more complicated responses. </p>
          <p>The MSO responded to digital inputs assuming TTL signal levels. That means 0 to .8 volts is a zero, 0.8 to 2.0 is unknown, and above 2 a one. The instrument displayed both digital and analog signals to see how a logic device would interpret the real-world&#39;s grittiness. </p>
          <p>Switch A was typical. When opened the signal moved just a bit above ground and wandered in the hundreds of millivolts range for up to 8 msec. Then it suddenly snapped to a one. As the signal meandered up to near a volt the scope interpreted it as a one, but the analog&#39;s continued uneasy rambles took it in and out of &#34;one&#34; territory. The MSO showered the screen with hash as it tried to interpret the data. </p>
          <p>It was if the contacts didn&#39;t bounce so much as wiped, dragging across each other for a time, acting like a variable resistor.<br/>
          </p>
          <p> <img src="https://www.ganssle.com/images/debounceswitcha.jpg" width="500" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p>Looking into this more deeply I expanded the traces for switch C and, with the help of Ohm&#39;s Law, found the resistance when the device opened crawled pretty uniformly over 150 µsec from zero to 6 ohms, before suddenly hitting infinity. There was no bouncing per se; just an uneasy ramp up from 0 to 300 mV before it suddenly zapped to a solid +5.<br/>
          </p>
          <p>   <img src="https://www.ganssle.com/images/debounceswitchc.jpg" width="462" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p>Another artifact of this wiping action was erratic analog signals treading in the dreaded no-man&#39;s land of TTL uncertainty (0.8 to 2.0 volts), causing the MSO to dither, tossing out ones or zeroes almost randomly, just as your microprocessor would if connected to the same switch.</p>
          <p> <img src="https://www.ganssle.com/images/debounceswitchb.jpg" width="500" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p>The two from the el cheapo game joystick were nothing more than gold contacts plated onto a PCB; a rubber cover, when depressed, dropped some sort of conductive elastomer onto the board. Interestingly, the analog result was a slow ramp from zero to five volts, with no noise, wiping or other uncertainty. Not a trace of bounce. And yet.. . . the logic channel showed a msec or so of wild oscillations! What&#39;s going on?</p>
          <p>With TTL logic, signals in the range of 0.8 to 2.0 volts are illegal. Anything goes, and everything did. Tie this seemingly bounce-free input to your CPU and prepare to deal with tons of oscillation - virtual bounces.<br/>
          </p>
          <p> <img src="https://www.ganssle.com/images/debounceswitchk.jpg" width="500" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p>My assessment, then, is that there&#39;s much less whacking of contacts going on than we realize. A lot of the apparent logic hash is from analog signals treading in illegal logic regions. Regardless, the effect on our system is the same and the treatment identical. But the erratic nature of the logic warns us to avoid simple sampling algorithms, like assuming two successive reads of a one means a one.</p>
          
          <p>So we know how long the contacts bounce and that lots of digital zaniness - ultra short pulses in particular - can appear.</p>
          <p>But what happens during the bounce? Quite a lot, and every bounce of every switch was different. Many produced only high speed hash till a solid one or zero appeared. Others generated a serious pulse train of discernable logic levels like one might expect. I was especially interested in results that would give typical debounce routines heartburn. </p>
          <p>Consider switch E again, that one with the pretty face that hides a vicious 157 msec bouncing heart. One test showed the switch going to a solid one for 81 msec, after which it dropped to a perfect zero for 42 msec before finally assuming its correct high state. Think what that would do to pretty much any debounce code!</p>
          <p> <img src="https://www.ganssle.com/images/debounceswitche.jpg" width="500" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p>Switch G was pretty well behaved, except that a couple of times it gave a few microsecond one before falling to zero for over 2 msec. Then it assumed its correct final one. The initial narrow pulse might escape your polled I/O, but would surely fire off an interrupt, had you dared wire the system so. The poor ISR would be left puzzled as it contemplates 2 msec of nothingness. &#34;Me? Why did it invoke me? Ain&#39;t nuthin&#39; there!&#34;<br/>
          </p>
          <p> <img src="https://www.ganssle.com/images/debounceswitchg.jpg" width="500" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p>O is a very nice, high quality microswitch which never showed more than 1.18 msec of bouncing. But digging deeper I found it usually generated a pulse train guaranteed to play havoc with simple filter code. There&#39;s no high speed hash, just hard-to-eliminate solid ones and zeroes. One actuation yielded 7 clean zeroes levels ranging in time from 12 to 86 µsec, and 7 logic ones varying from 6 to 95 µsec. Easy to filter? Sure. But not by code that just looks for a couple of identical reads.<br/>
          </p>
          <p><img src="https://www.ganssle.com/images/debounceswitcho.jpg" width="465" height="270" alt="Scope trace of bouncing switch"/><br/>
          </p>
          <p><img src="https://www.ganssle.com/images/debounceswitchq.jpg" width="500" alt="Scope trace of bouncing switch"/></p>
          <p>What happens if we press the buttons really, really fast? Does that alter the bouncing in a significant way? It&#39;s awfully hard for these aging  fingers to do anything particularly quickly, so I set up a modified experiment, connecting my MSP430 board to a sizeable 3 amp four pole relay. Downloading code into the CPU&#39;s flash let me toggle the relay at different rates. </p>
<p>Bounce times ranged from 410 to 2920 µsec, quite similar to those of the switches, presumably validating the experiment. The relay had no noticeable analog effects, banging cleanly between 0 and 5 volts. </p>
          <p>The raucous clacking of contacts overwhelmed our usual classical fare for a few hours as the MSO accumulated bounce times in storage mode. When the relay opened it always had a max bounce time of 2.3 to 2.9 msec, at speeds from 2.5 to 30 Hz. More variation appeared on contact closure: at 2.5 Hz bounces never exceeded 410 µsec, which climbed to 1080 µsec at 30 Hz. Why? I have no idea. But it&#39;s clear there is some correlation between fast actuations and more bounce. These numbers suggest a tractable factor of two increase, though, not a scary order of magnitude or more.          </p>
          <p>In the bad old days we used a lot of leaf switches which typically bounced forever. Weeks, it seemed. Curious I disassembled a number of cheap consumer products expecting to find these sort of inexpensive devices. None found! Now that everything is mounted on a PCB vendors use board-mounted switches, which are pretty darn good little devices.</p>
          <p> <img src="https://www.ganssle.com/images/debouncepcb.jpg" width="469" height="367" alt="PCB switches"/><br/>
          </p>
          <p>I admit these experiments aren&#39;t terribly scientific. No doubt someone with a better education and more initials following his name could do a more reputable study for one of those journals no one reads. But as far as I know there&#39;s no data on the subject available anywhere, and we working engineers need some empirical information. </p>
          <p>Use a grain of salt when playing with these numbers. Civil engineers don&#39;t really know the exact strength of a concrete beam poured by indolent laborers, so they beef things up a bit. They add margin. Do the same here. Assume things are worse than shown.</p>
          <p><a href="https://www.ganssle.com/debouncing-pt2.htm">Go to Page Two of This report</a> which has hardware and software debounce solutions.<br/>
          </p>
          
          <!-- InstanceEndEditable --> </section>

  
  </div></div>
  </body>
</html>
