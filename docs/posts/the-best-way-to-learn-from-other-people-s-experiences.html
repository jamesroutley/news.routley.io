<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://commoncog.com/blog/how-to-learn-from-other-peoples-experiences/">Original</a>
    <h1>The Best Way to Learn From Other People&#39;s Experiences</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  
  <p><span>2022-01-23</span></p><p>This is a short post prompted by a question on <a href="https://reddit.com/r/rust/">/r/rust</a> from May 2019, asking about a way for a Rust program to modify itself.</p>
<p>Think of how much fun it would be to store a high score list directly inside the a executable.
When you make a copy (on floppy disk, to make things more realistic) and pass it to your friends, your high scores are persisted.</p>
<h2 id="errata">Errata</h2>
<ul>
<li>the variable should probably be marked as <code>#[repr(C)]</code>.</li>
<li>as <a href="https://www.reddit.com/r/rust/comments/saxzs8/on_selfmodifying_executables_in_rust/htwxint/">pointed out</a> by a reader, <code>unsafe { ptr::read_volatile(&amp;RUN_COUNT) }</code> is a better alternative to <code>static mut</code>.</li>
<li>you probably shouldn&#39;t do this except as a party trick.</li>
</ul>
<h2 id="diving-right-in">Diving right in</h2>
<p>As a proof of concept, we&#39;ll write a program that counts how many times it has been run.
This is hardly the only approach, but probably the simplest way is to store the counter in a separate section of the executable.</p>
<pre><code data-lang="rust"><span>#[</span><span>link_section </span><span>= &#34;</span><span>count</span><span>&#34;]
#[</span><span>used</span><span>]
</span><span>static mut </span><span>RUN_COUNT</span><span>: </span><span>u32 </span><span>= </span><span>0</span><span>;
</span></code></pre>
<p><code>#[link_section]</code> tells the linker to put the variable in a section called <code>count</code>.
<a href="https://rust-lang.github.io/rfcs/2386-used.html"><code>#[used]</code></a> means that the variable must be kept by the linker, even if could be optimized away.
Similarly, <code>mut</code> is required because otherwise the compiler will propagate the variable value to the code that reads it.</p>
<p>I&#39;m not sure if the combination above the best way to accomplish this, or if it&#39;s guaranteed to work.
It was the only working method I found back then, and it still seems to be the case today.</p>
<p>Since the code is so short, I&#39;ll just paste the rest of it here:</p>
<pre><code data-lang="rust"><span>use </span><span>memmap2::MmapOptions;
</span><span>use </span><span>object::{File, Object, ObjectSection};
</span><span>use </span><span>std::env;
</span><span>use </span><span>std::error::Error;
</span><span>use </span><span>std::fs::{</span><span>self</span><span>, OpenOptions};

</span><span>fn </span><span>get_section</span><span>(</span><span>file</span><span>: &amp;File, </span><span>name</span><span>: &amp;</span><span>str</span><span>) -&gt; Option&lt;(</span><span>u64</span><span>, </span><span>u64</span><span>)&gt; {
    </span><span>for</span><span> section in file.</span><span>sections</span><span>() {
        </span><span>match</span><span> section.</span><span>name</span><span>() {
            Ok(n) </span><span>if</span><span> n == name =&gt; {
                </span><span>return</span><span> section.</span><span>file_range</span><span>();
            }
            _ =&gt; {}
        }
    }
    None
}

</span><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    </span><span>let</span><span> run_count = </span><span>unsafe </span><span>{ </span><span>RUN_COUNT </span><span>};
    println!(&#34;</span><span>Previous run count: </span><span>{}</span><span>&#34;, run_count);
    </span><span>let</span><span> exe = env::current_exe()?;
    </span><span>let</span><span> tmp = exe.</span><span>with_extension</span><span>(&#34;</span><span>tmp</span><span>&#34;);
    fs::copy(&amp;exe, &amp;tmp)?;

    </span><span>let</span><span> file = OpenOptions::new().</span><span>read</span><span>(</span><span>true</span><span>).</span><span>write</span><span>(</span><span>true</span><span>).</span><span>open</span><span>(&amp;tmp)?;
    </span><span>let mut</span><span> buf = </span><span>unsafe </span><span>{ MmapOptions::new().</span><span>map_mut</span><span>(&amp;file) }?;
    </span><span>let</span><span> file = File::parse(&amp;*buf)?;

    </span><span>if let </span><span>Some(range) = </span><span>get_section</span><span>(&amp;file, &#34;</span><span>count</span><span>&#34;) {
        assert_eq!(range.</span><span>1</span><span>, </span><span>4</span><span>);
        </span><span>let</span><span> base = range.</span><span>0 </span><span>as </span><span>usize</span><span>;
        buf[base..(base + </span><span>4</span><span>)].</span><span>copy_from_slice</span><span>(&amp;(run_count + </span><span>1</span><span>).</span><span>to_ne_bytes</span><span>());

        </span><span>let</span><span> perms = fs::metadata(&amp;exe)?.</span><span>permissions</span><span>();
        fs::set_permissions(&amp;tmp, perms)?;
        fs::rename(&amp;tmp, &amp;exe)?;
    } </span><span>else </span><span>{
        fs::remove_file(&amp;tmp)?;
    }

    Ok(())
}
</span></code></pre>
<p>We look up the current executable, and map it into memory using <a href="https://docs.rs/memmap2/"><code>memmap2</code></a>.
Then we get a list of sections using the <a href="https://docs.rs/object/"><code>object</code></a> crate, search for one called <code>count</code> — beware of libraries using the same name! — then replace the variable value in the memory-mapped view of the file.</p>
<p>All this happens on a copy of our program.
Self-modifying programs were fine under MS-DOS, but modern operating systems won&#39;t let it fly.
Renaming or overwriting is fine, since the original file is still unchanged.</p>
<p>You can see a nice diagram showing the ELF (the executable format on my platform) structure <a href="https://github.com/corkami/pics/blob/28cb0226093ed57b348723bc473cea0162dad366/binary/elf101/elf101-64.svg">here</a>.
But we&#39;re not here to learn about executable formats.
We&#39;re here to clear out a tiny bit of backlog and see a working example, so does it work?</p>
<pre><code data-lang="bash"><span>$</span><span> cargo run</span><span> --release
   Compiling</span><span> self-modify v0.1.0 (/home/grayshade/Projects/self-modify)
    </span><span>Finished</span><span> release </span><span>[</span><span>optimized</span><span>]</span><span> target(s) </span><span>in</span><span> 0.30s
     </span><span>Running </span><span>`</span><span>target/release/self-modify</span><span>`
</span><span>Previous</span><span> run count: 0
</span><span>$</span><span> target/release/self-modify
</span><span>Previous</span><span> run count: 1
</span><span>$</span><span> target/release/self-modify
</span><span>Previous</span><span> run count: 2
</span><span>$</span><span> target/release/self-modify
</span><span>Previous</span><span> run count: 3
</span></code></pre>
<p>It does!</p>
<p>Note that I&#39;m on Linux.
The <code>object</code> crate should work with MacOS and Windows executables too, but on Windows the <code>fs::rename</code> call will probably fail.
There you can rename the current executable to some temporary name, but I don&#39;t want to deal with that stuff <a href="https://github.com/rust-analyzer/rust-analyzer/issues/6602">again</a>.</p>
<h2 id="bonus-section">Bonus <em>section</em></h2>
<p>I mentioned above that declaring our variable as <code>mut</code> is necessary because the compiler will optimize it otherwise.
How did I figure that out?</p>
<p>First, let&#39;s simplify the code and give the variable a more noticeable value:</p>
<pre><code data-lang="rust"><span>#[</span><span>link_section </span><span>= &#34;</span><span>count</span><span>&#34;]
#[</span><span>used</span><span>]
</span><span>static mut </span><span>RUN_COUNT</span><span>: </span><span>u32 </span><span>= </span><span>0x55aa55aa</span><span>;

</span><span>fn </span><span>main</span><span>() {
    </span><span>let</span><span> run_count = </span><span>unsafe </span><span>{ </span><span>RUN_COUNT </span><span>};
    println!(&#34;</span><span>Previous run count: </span><span>{}</span><span>&#34;, run_count);
}
</span></code></pre><pre><code data-lang="bash"><span>$</span><span> cargo build</span><span> --release
$</span><span> objdump</span><span> -d</span><span> target/release/self-modify
</span></code></pre><pre><code data-lang="asm"><span>[snip]
</span><span>0000000000011160 </span><span>&lt;_ZN11self_modify4main17hd56d204cd8f62812E&gt;:
   </span><span>11160</span><span>:       </span><span>48 83 </span><span>ec </span><span>48             </span><span>sub    </span><span>$</span><span>0x48</span><span>,</span><span>%</span><span>rsp
   </span><span>11164</span><span>:       8b </span><span>05 </span><span>ee 7e </span><span>03 00       </span><span>mov    </span><span>0x37eee</span><span>(%</span><span>rip</span><span>)</span><span>,</span><span>%</span><span>eax        </span><span># </span><span>49058 </span><span>&lt;__TMC_END__&gt;
   1116a:       </span><span>89 44 24 04             </span><span>mov    </span><span>%</span><span>eax</span><span>,</span><span>0x4</span><span>(%</span><span>rsp</span><span>)
   1116e:       </span><span>48 </span><span>8d </span><span>44 24 04          </span><span>lea    </span><span>0x4</span><span>(%</span><span>rsp</span><span>)</span><span>,</span><span>%</span><span>rax
   </span><span>11173</span><span>:       </span><span>48 89 44 24 08          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x8</span><span>(%</span><span>rsp</span><span>)
   </span><span>11178</span><span>:       </span><span>48 </span><span>8b </span><span>05 49 51 03 00    </span><span>mov    </span><span>0x35149</span><span>(%</span><span>rip</span><span>)</span><span>,</span><span>%</span><span>rax        </span><span># 462c8 &lt;_etext</span><span>+</span><span>0x423</span><span>&gt;
   1117f:       </span><span>48 89 44 24 10          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x10</span><span>(%</span><span>rsp</span><span>)
   </span><span>11184</span><span>:       </span><span>48 </span><span>8d </span><span>05 </span><span>e5 </span><span>57 03 00    </span><span>lea    </span><span>0x357e5</span><span>(%</span><span>rip</span><span>)</span><span>,</span><span>%</span><span>rax        </span><span># </span><span>46970 </span><span>&lt;_DYNAMIC</span><span>+</span><span>0x280</span><span>&gt;
   1118b:       </span><span>48 89 44 24 18          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x18</span><span>(%</span><span>rsp</span><span>)
   </span><span>11190</span><span>:       </span><span>48 </span><span>c7 </span><span>44 24 20 02 00    </span><span>movq   </span><span>$</span><span>0x2</span><span>,</span><span>0x20</span><span>(%</span><span>rsp</span><span>)
   </span><span>11197</span><span>:       </span><span>00 00
   11199</span><span>:       </span><span>48 </span><span>c7 </span><span>44 24 28 00 00    </span><span>movq   </span><span>$</span><span>0x0</span><span>,</span><span>0x28</span><span>(%</span><span>rsp</span><span>)
   111a0:       </span><span>00 00
   </span><span>111a2:       </span><span>48 </span><span>8d </span><span>44 24 08          </span><span>lea    </span><span>0x8</span><span>(%</span><span>rsp</span><span>)</span><span>,</span><span>%</span><span>rax
   </span><span>111a7:       </span><span>48 89 44 24 38          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x38</span><span>(%</span><span>rsp</span><span>)
   111ac:       </span><span>48 </span><span>c7 </span><span>44 24 40 01 00    </span><span>movq   </span><span>$</span><span>0x1</span><span>,</span><span>0x40</span><span>(%</span><span>rsp</span><span>)
   111b3:       </span><span>00 00
   </span><span>111b5:       </span><span>48 </span><span>8d 7c </span><span>24 18          </span><span>lea    </span><span>0x18</span><span>(%</span><span>rsp</span><span>)</span><span>,</span><span>%</span><span>rdi
   </span><span>111ba:       ff </span><span>15 48 </span><span>4f </span><span>03 00       </span><span>call   </span><span>*</span><span>0x34f48</span><span>(%</span><span>rip</span><span>)        # </span><span>46108 </span><span>&lt;_etext</span><span>+</span><span>0x263</span><span>&gt;
   111c0:       </span><span>48 83 </span><span>c4 </span><span>48             </span><span>add    </span><span>$</span><span>0x48</span><span>,</span><span>%</span><span>rsp
   </span><span>111c4:       c3                      </span><span>ret
        </span><span>...
</span><span>[snip]
</span></code></pre>
<p>Ookay, assembly is hard to read.
What happens without the <code>mut</code>?</p>
<pre><code data-lang="asm"><span>0000000000011160 </span><span>&lt;_ZN11self_modify4main17hd56d204cd8f62812E&gt;:
   </span><span>11160</span><span>:       </span><span>48 83 </span><span>ec </span><span>48             </span><span>sub    </span><span>$</span><span>0x48</span><span>,</span><span>%</span><span>rsp
   </span><span>11164</span><span>:       c7 </span><span>44 24 04 </span><span>aa </span><span>55 </span><span>aa    movl   </span><span>$</span><span>0x55aa55aa</span><span>,</span><span>0x4</span><span>(%</span><span>rsp</span><span>)
   1116b:       </span><span>55
   </span><span>1116c:       </span><span>48 </span><span>8d </span><span>44 24 04          </span><span>lea    </span><span>0x4</span><span>(%</span><span>rsp</span><span>)</span><span>,</span><span>%</span><span>rax
   </span><span>11171</span><span>:       </span><span>48 89 44 24 08          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x8</span><span>(%</span><span>rsp</span><span>)
   </span><span>11176</span><span>:       </span><span>48 </span><span>8b </span><span>05 </span><span>4b </span><span>51 03 00    </span><span>mov    </span><span>0x3514b</span><span>(%</span><span>rip</span><span>)</span><span>,</span><span>%</span><span>rax        </span><span># 462c8 &lt;_etext</span><span>+</span><span>0x423</span><span>&gt;
   1117d:       </span><span>48 89 44 24 10          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x10</span><span>(%</span><span>rsp</span><span>)
   </span><span>11182</span><span>:       </span><span>48 </span><span>8d </span><span>05 </span><span>e7 </span><span>57 03 00    </span><span>lea    </span><span>0x357e7</span><span>(%</span><span>rip</span><span>)</span><span>,</span><span>%</span><span>rax        </span><span># </span><span>46970 </span><span>&lt;_DYNAMIC</span><span>+</span><span>0x280</span><span>&gt;
   </span><span>11189</span><span>:       </span><span>48 89 44 24 18          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x18</span><span>(%</span><span>rsp</span><span>)
   1118e:       </span><span>48 </span><span>c7 </span><span>44 24 20 02 00    </span><span>movq   </span><span>$</span><span>0x2</span><span>,</span><span>0x20</span><span>(%</span><span>rsp</span><span>)
   </span><span>11195</span><span>:       </span><span>00 00
   11197</span><span>:       </span><span>48 </span><span>c7 </span><span>44 24 28 00 00    </span><span>movq   </span><span>$</span><span>0x0</span><span>,</span><span>0x28</span><span>(%</span><span>rsp</span><span>)
   1119e:       </span><span>00 00
   </span><span>111a0:       </span><span>48 </span><span>8d </span><span>44 24 08          </span><span>lea    </span><span>0x8</span><span>(%</span><span>rsp</span><span>)</span><span>,</span><span>%</span><span>rax
   </span><span>111a5:       </span><span>48 89 44 24 38          </span><span>mov    </span><span>%</span><span>rax</span><span>,</span><span>0x38</span><span>(%</span><span>rsp</span><span>)
   111aa:       </span><span>48 </span><span>c7 </span><span>44 24 40 01 00    </span><span>movq   </span><span>$</span><span>0x1</span><span>,</span><span>0x40</span><span>(%</span><span>rsp</span><span>)
   111b1:       </span><span>00 00
   </span><span>111b3:       </span><span>48 </span><span>8d 7c </span><span>24 18          </span><span>lea    </span><span>0x18</span><span>(%</span><span>rsp</span><span>)</span><span>,</span><span>%</span><span>rdi
   </span><span>111b8:       ff </span><span>15 </span><span>4a 4f </span><span>03 00       </span><span>call   </span><span>*</span><span>0x34f4a</span><span>(%</span><span>rip</span><span>)        # </span><span>46108 </span><span>&lt;_etext</span><span>+</span><span>0x263</span><span>&gt;
   111be:       </span><span>48 83 </span><span>c4 </span><span>48             </span><span>add    </span><span>$</span><span>0x48</span><span>,</span><span>%</span><span>rsp
   </span><span>111c2:       c3                      </span><span>ret
        </span><span>...
</span></code></pre>
<p>Did you spot the <code>movl   $0x55aa55aa,0x4(%rsp)</code> on the second line?
That&#39;s our value, inlined in the compiled code.</p>
<p>To be honest, we&#39;re getting a lot of extra code in there.
Instead, it&#39;s better to get rid of the <code>println!</code>, simplify the code as much as possible and paste it on godbolt.org.
Click <a href="https://godbolt.org/z/d5rbj7fMG">here</a> to see how that looks.</p>

</div>

        </div></div>
  </body>
</html>
