<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bugs.ruby-lang.org/issues/21311">Original</a>
    <h1>Ruby 3.5 Feature: Namespace on read</h1>
    
    <div id="readability-page-1" class="page"><div id="issue_description_wiki">
  <p>This replaces <a title="Feature: Namespace on read (Closed)" href="https://notebook.wesleyac.com/issues/19744">#19744</a></p>
<h2>Concept<a href="#Concept">¶</a></h2>
<p>This proposes a new feature to define virtual top-level namespaces in Ruby. Those namespaces can require/load libraries (either .rb or native extension) separately from other namespaces. Dependencies of required/loaded libraries are also required/loaded in the namespace.</p>
<p>This feature will be disabled by default at first, and will be enabled by an env variable <code>RUBY_NAMESPACE=1</code> as an experimental feature.</p>
<h3>&#34;on read&#34; approach<a href="#on-read-approach">¶</a></h3>
<p>The &#34;on write&#34; approach here is the design to define namespaces on the loaded side. For example, Java packages are defined in the .java files and it is required to separate namespaces from each other. It can be implemented very easily, but it requires all libraries to be updated with the package declaration. (In my opinion, it&#39;s almost impossible in the Ruby ecosystem.)</p>
<p>The &#34;on read&#34; approach is to create namespaces and then require/load applications and libraries in them. Programmers can control namespace separation at the &#34;read&#34; time. So, we can introduce the namespace separation incrementally.</p>
<h2>Motivation<a href="#Motivation">¶</a></h2>
<p>The &#34;namespace on read&#34; can solve the 2 problems below, and can make a path to solve another problem:</p>
<ul>
<li>Avoiding name conflicts between libraries
<ul>
<li>Applications can require two different libraries safely which use the same module name.</li>
</ul>
</li>
<li>Avoiding unexpected globally shared modules/objects
<ul>
<li>Applications can make an independent/unshared module instance.</li>
</ul>
</li>
<li>Multiple versions of gems can be required
<ul>
<li>Application developers will have fewer version conflicts between gem dependencies if rubygems/bundler will support the namespace on read. (Support from RubyGems/Bundler and/or other packaging systems will be needed)</li>
</ul>
</li>
</ul>
<p>For the motivation details, see [Feature <a title="Feature: Namespace on read (Closed)" href="https://notebook.wesleyac.com/issues/19744">#19744</a>].</p>
<h2>How we can use Namespace<a href="#How-we-can-use-Namespace">¶</a></h2>
<pre><code data-language="ruby"><span># app1.rb</span>
<span>PORT</span> <span>=</span> <span>2048</span>
<span>class</span> <span>App</span>
  <span>def</span> <span>self</span><span>.</span><span>port</span> <span>=</span> <span>::</span><span>PORT</span>
  <span>def</span> <span>val</span> <span>=</span> <span>PORT</span><span>.</span><span>to_s</span>
<span>end</span>

<span>p</span> <span>App</span><span>.</span><span>port</span> <span># 2048</span>

<span># app2.rb</span>
<span>class</span> <span>Number</span>
  <span>def</span> <span>double</span> <span>=</span> <span>self</span> <span>*</span> <span>2</span>
<span>end</span>

<span>PORT</span> <span>=</span> <span>2048</span><span>.</span><span>double</span>
<span>class</span> <span>App</span>
  <span>def</span> <span>self</span><span>.</span><span>port</span> <span>=</span> <span>::</span><span>PORT</span>
  <span>def</span> <span>val</span> <span>=</span> <span>PORT</span><span>.</span><span>double</span><span>.</span><span>to_s</span>
<span>end</span>

<span>p</span> <span>App</span><span>.</span><span>port</span> <span># 4096</span>

<span># main.rb - executed as `ruby main.rb`</span>
<span>ns1</span> <span>=</span> <span>Namespace</span><span>.</span><span>new</span>
<span>ns1</span><span>.</span><span>require</span><span>(</span><span>&#39;./app1&#39;</span><span>)</span> <span># 2048</span>
<span>ns2</span> <span>=</span> <span>Namespace</span><span>.</span><span>new</span>
<span>ns2</span><span>.</span><span>require</span><span>(</span><span>&#39;./app2&#39;</span><span>)</span> <span># 4096</span>

<span>PORT</span> <span>=</span> <span>8080</span>
<span>class</span> <span>App</span>
  <span>def</span> <span>self</span><span>.</span><span>port</span> <span>=</span> <span>::</span><span>PORT</span>
  <span>def</span> <span>val</span> <span>=</span> <span>PORT</span><span>.</span><span>to_s</span>
<span>end</span>

<span>p</span> <span>App</span><span>.</span><span>port</span> <span># 8080</span>
<span>p</span> <span>App</span><span>.</span><span>new</span><span>.</span><span>val</span> <span># &#34;8080&#34;</span>

<span>p</span> <span>ns1</span><span>::</span><span>App</span><span>.</span><span>port</span> <span># 2048</span>
<span>p</span> <span>ns1</span><span>::</span><span>App</span><span>.</span><span>new</span><span>.</span><span>val</span> <span># &#34;2048&#34;</span>

<span>p</span> <span>ns2</span><span>::</span><span>App</span><span>.</span><span>port</span> <span># 4096</span>
<span>p</span> <span>ns2</span><span>::</span><span>App</span><span>.</span><span>new</span><span>.</span><span>val</span> <span># &#34;8192&#34;</span>

<span>1</span><span>.</span><span>double</span> <span># NoMethodError</span>
</code></pre>
<h2>Namespace specification<a href="#Namespace-specification">¶</a></h2>
<h3>Types of namespaces<a href="#Types-of-namespaces">¶</a></h3>
<p>There are two namespace types, &#34;root&#34; and &#34;user&#34; namespace. &#34;Root&#34; namespace exists solely in a Ruby process, and &#34;user&#34; namespaces can be created as many as Ruby programmers want.</p>
<h3>Root namespace<a href="#Root-namespace">¶</a></h3>
<p>Root namespace is a unique namespace to be defined when a Ruby process starts. It only contains built-in classes/modules/constants, which are available without any <code>require</code> calls, including RubyGems itself (when <code>--disable-gems</code> is not specified).</p>
<p>At here, &#34;builtin&#34; classes/modules are classes/modules accessible when users&#39; script evaluation starts, without any require/load calls.</p>
<h3>User namespace<a href="#User-namespace">¶</a></h3>
<p>User namespace is a namespace to run users&#39; Ruby scripts. The &#34;main&#34; namespace is the namespace to run the user&#39;s <code>.rb</code> script specified by the <code>ruby</code> command-line argument. Other user namespaces (&#34;optional&#34; namespaces) can be created by <code>Namespace.new</code> call.</p>
<p>In user namespace (both main and optional namespaces), built-in class/module definitions are copied from the root namespace, and other new classes/modules are defined in the namespace, separately from other (root/user) namespaces.</p>
<p>In that namespace <code>ns</code>, <code>ns::App</code> is accessible as <code>App</code> (or <code>::App</code>). There is no way to access <code>App</code> in the main namespace from the code in the different namespace <code>ns</code>.</p>
<h3>Constants, class variables and global variables<a href="#Constants-class-variables-and-global-variables">¶</a></h3>
<p>Constants, Class variables of built-in classes and global variables are also separated by namespace. Values set to class/global variables in a namespace are invisible in other namespaces.</p>
<h3>Methods and procs<a href="#Methods-and-procs">¶</a></h3>
<p>Methods defined in a namespace run with the defined namespace, even when called from other namespaces.</p>
<h3>Dynamic link libraries<a href="#Dynamic-link-libraries">¶</a></h3>
<p>Dynamic link libraries (typically .so files) are also loaded in namespaces as well as .rb files.</p>
<h3>Open class (Changes on built-in classes)<a href="#Open-class-Changes-on-built-in-classes">¶</a></h3>
<p>In user namespaces, built-in class definitions can be modified. But those operations are processed as copy-on-write of class definition from the root namespace, and the changed definitions are visible only in the (user) namespace.</p>
<p>Definitions in the root namespace are not modifiable from other namespaces. Methods defined in the root namespace run only with root-namespace definitions.</p>
<h2>Enabling Namespace<a href="#Enabling-Namespace">¶</a></h2>
<p>Specify <code>RUBY_NAMESPACE=1</code> environment variable when starting Ruby processes. <code>1</code> is the only valid value here.</p>
<p>Namespace feature can be enabled only when Ruby processes start. Setting <code>RUBY_NAMESPACE=1</code> after starting Ruby scripts performs nothing.</p>
<h2>Pull-request<a href="#Pull-request">¶</a></h2>
<p><a href="https://github.com/ruby/ruby/pull/13226">https://github.com/ruby/ruby/pull/13226</a></p>
  </div></div>
  </body>
</html>
