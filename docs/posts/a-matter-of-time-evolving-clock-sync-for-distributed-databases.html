<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yugabyte.com/evolving-clock-sync-for-distributed-databases/">Original</a>
    <h1>A Matter of Time: Evolving Clock Sync for Distributed Databases</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Distributed clock synchronization is critical for many applications, including <a href="https://blog.yugabyte.com/what-is-distributed-sql/"><span>distributed SQL</span></a> databases. Clock synchronization needs to keep up with the other demands in our modern infrastructure, such as:</p>
<ul>
<li>Applications that have increasing performance requirements while distributing data across different geographic regions</li>
<li>Network infrastructure and computing power that is improving constantly</li>
</ul>
<p>A distributed SQL database is highly available and resilient to failures when deployed across a cluster of nodes. It can process queries and transactions in a distributed manner while ensuring <a href="https://blog.yugabyte.com/a-primer-on-acid-transactions/"><span>ACID compliance</span></a>. What does an atomic clock service have to do with a cloud-native, distributed SQL database? It turns out that time synchronization across nodes is critical to achieving distributed transactions. But getting multiple nodes to agree on time is a hard problem.</p>
<p>In this post, we’ll analyze the challenges and the different approaches to synchronizing time across nodes in a distributed database.</p>
<h2>1. Synchronizing wall clocks across nodes</h2>
<p>In a distributed cluster (or, more generally, a distributed system), the notion of time becomes ambiguous. Each node has its own notion of time that is not synchronized with the others. This is because nodes (like most modern timekeeping devices) rely on timers built using a quartz crystal oscillator to keep track of the passage of time.</p>
<p>These devices take advantage of quartz crystals vibrating from voltage at a precise frequency. The vibrations of the crystal act like the pendulum of a grandfather clock, ticking off how much time has passed. But the issue arises because these crystals run at different speeds, causing a <b>clock skew</b>. This means that the time across nodes gets out of sync.</p>
<h3>Network Time Protocol</h3>
<p>One mechanism commonly used to coarsely synchronize wall clocks across nodes is the Network Time Protocol (NTP). NTP is a networking protocol for clock synchronization between the nodes of a cluster which, under ideal conditions, can synchronize time across the participating nodes (of a cluster) to within a few milliseconds of each other.</p>
<p>However, in practice, it is rare to see NTP synchronize time across nodes consistently to within a few milliseconds. This is because deployments in the real world can often get into non-ideal conditions. These conditions include load on the node (NTP is not a kernel service, it runs in user space), asymmetric routes, network congestion, and failures, leading to much higher clock skews. From the <a href="http://www.ntp.org/ntpfaq/NTP-s-algo.htm#Q-ACCURATE-CLOCK"><span>ntp.org site on the accuracy of NTP</span></a>, the typical accuracy can vary from <b>5ms to over 100ms</b>. This makes it hard to simply use NTP to synchronize time in failure scenarios, especially given the purpose of a distributed SQL database is to work reliably even under failure scenarios.</p>
<h3>Analyzing an example banking application</h3>
<p>Let’s take an example of what could go wrong if time is not tightly synchronized across nodes. Say a banking application runs on a distributed, transactional database. This database then runs on a cluster of nodes where two of the nodes in the cluster have a 10s clock skew. Now assume that a particular user (with $50 in their checking account) first deposits $100, followed by withdrawing $70, which should succeed. The following scenario could arise if we do not synchronize time across nodes:</p>
<ul>
<li>The wall clock time on node #1 is 10s ahead of that on node #2.</li>
<li>To begin with, the user has $50 in their account.</li>
<li>The user connects to node #1 to deposit $100, and since the wall clock time on node #1 at this time is 100, the user’s account total becomes $150 at time = 100. Note that node #2 has a time of 90.</li>
<li>About 5s after making the deposit, the user connects to node #2 to withdraw $70, which should succeed. However, the wall clock time on node #2 at this time is 95, and the user made the deposit only at time 100. Thus, per node #2, the user balance is still $50, and the operation to withdraw $70 would fail.</li>
</ul>
<p>Below is a diagram depicting this scenario.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.40.18-PM.png" alt="What could go wrong if time is not tightly synchronized across nodes." width="712" height="499" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.40.18-PM.png 712w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.40.18-PM-300x210.png 300w" sizes="(max-width: 712px) 100vw, 712px"/></p>
<h2>2. Logical clocks</h2>
<p>The most well-known logical clock is <a href="https://en.wikipedia.org/wiki/Lamport_timestamp"><span>Lamport’s Clock</span></a>, originally proposed by Leslie Lamport. The Lamport timestamp algorithm provides a <a href="https://en.wikipedia.org/wiki/Partially_ordered_set"><span>partial ordering</span></a> of events by using the following rules:</p>
<ul>
<li>A process increments its counter before each local event (e.g., message sending event).</li>
<li>When a process sends a message, it includes its counter value with the message after executing step 1.</li>
<li>On receiving a message, the counter of the recipient updates, if necessary, to the greater of its current counter and the timestamp in the received message. The counter is then incremented by 1 before the message is considered received.</li>
</ul>
<p>The algorithm above works if we only want <i>causal ordering</i>. This means that if event A leads to the occurrence of event B, then the timestamp of A is less than B. However, if A and B are unrelated to each other, their timestamps don’t mean anything. Thus, this does not solve our scenario above of a user depositing and subsequently withdrawing money from their account, since those two events are independent of each other. We would run into the same issue pointed out above.</p>
<h3>The <i>timestamp oracle</i> – centralized logical clock</h3>
<p>In order to eliminate clock skew and ensure all nodes have the same notion of time, one option is to use a centralized service that is the timestamp authority. In this scheme, all nodes use an external service to generate any timestamp. The <i>Timestamp Oracle</i> (TO) issues the start and commit timestamps for each transaction. This is a single node that ensures the timestamps are monotonically increasing as time progresses. <a href="https://omid.incubator.apache.org/index.html"><span>Apache Omid (<i>Optimistically transaction Management In Datastores</i>)</span></a> uses such a mechanism, as do Google Percolator and TiDB.</p>
<p><em> The single responsibility of the Timestamp Oracle is to manage transaction timestamps. Transaction timestamps serve as a logical clock and preserve the time-related guarantees required for Snapshot Isolation.</em></p>
<p><em>The TO allocates and delivers transaction timestamps when required by the TSO. To achieve this task, it maintains a monotonically increasing counter. Transaction timestamps allocate when a transaction begins and right after a transaction willing to commit has passed the writeset validation. The start timestamp is also used as a transaction identifier. </em></p>
<p>Below is a diagram outlining how Apache Omid works.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.42.11-PM.png" alt="How Apache Omid works." width="584" height="517" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.42.11-PM.png 584w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.42.11-PM-300x266.png 300w" sizes="(max-width: 584px) 100vw, 584px"/></p>
<h3>Issues with this approach</h3>
<p><b>Violates horizontal scalability principle:</b> The timestamp oracle could become a bottleneck as the cluster scales. It is in the critical path for all transactions, and is effectively just a single node irrespective of the size of the cluster. Thus, in this architecture, it is not really possible to scale out the timestamp oracle. This is because we’d be introducing clock skew between the two different timestamp oracle instances—and would be back to square one. With horizontal scalability as a core design principle for a distributed SQL database, this approach is not acceptable.</p>
<p><b>Not highly available for geo-distributed deployments:</b> In geo-distributed deployments, there is still exactly one timestamp oracle, which partitions away from some of the nodes in the cluster. This could lead to the following scenario. Assume that the transaction oracle partitions from a set of nodes in a remote region, which could be a relatively common occurrence. Transactions between these nodes in the remote region would still require the timestamp oracle to issue timestamps, which partitions away. Thus, all these transactions would fail because they could not synchronize time amongst themselves, as shown in the diagram below.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.43.27-PM.png" alt="Transactions failing because they could not synchronize time amongst themselves." width="749" height="379" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.43.27-PM.png 749w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.43.27-PM-300x152.png 300w" sizes="(max-width: 749px) 100vw, 749px"/></p>
<h2>3. Distributed time sync using atomic clocks</h2>
<p><span><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">Google Spanner</a></span> uses the TrueTime service, which is highly available and built using GPS and atomic clocks. TrueTime can guarantee an upper bound on the clock skew between the nodes in the cluster to under 7ms. The implementation of the TrueTime service is as follows:</p>
<p><em>TrueTime is implemented by a set of time master machines per datacenter and a timeslave daemon per machine. The majority of masters have GPS receivers with dedicated antennas; these masters separate physically to reduce the effects of antenna failures, radio interference, and spoofing. The remaining masters (which we refer to as Armageddon masters) are equipped with atomic clocks.</em></p>
<h3>A brief note on atomic clocks</h3>
<p>Clock skew across nodes would be unacceptable for distributed SQL databases, which need extremely <b>stable<i> </i>clocks</b>. Stability refers to how consistently a clock measures a unit of time. For example, its measurement of the length of a second needs to be precise over days and weeks.</p>
<p><b>Atomic clocks</b> observe the ultra-stable oscillations of the atoms trapped within them. At the Naval Observatory, they rely on dozens of <a href="https://www.usno.navy.mil/USNO/time/master-clock/cesium-atomic-clocks"><span>cesium</span></a> and <a href="https://www.usno.navy.mil/USNO/time/master-clock/u.s.-naval-observatory-hydrogen-masers"><span>hydrogen maser</span></a> clocks. The array of atomic clocks used by the U.S. Naval Observatory, the <a href="https://www.usno.navy.mil/USNO/time/master-clock/precise-time-and-the-usno-master-clock"><span>Master Clock</span></a>, only deviates by 100 picoseconds (0.000 000 000 1 seconds) per day.</p>
<h3>How TrueTime simplifies transactions</h3>
<p>How does this service simplify our example scenario above? By knowing that the time on any two nodes can be no more than 7ms apart, it is possible to introduce an artificial delay of 7ms after accepting a transaction, and before committing it. This delay ensures that all other nodes in the cluster would have caught up to the issued timestamp being issued.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.45.47-PM.png" alt="How TrueTime simplifies transactions." width="682" height="702" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.45.47-PM.png 682w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.45.47-PM-291x300.png 291w" sizes="(max-width: 682px) 100vw, 682px"/></p>
<p>The figure above shows how this scheme works in the context of the example we used earlier. Note that the deposit transaction is accepted for a write at timestamp 100, but applied only at a later point in time (110 in the figure above). This ensures that no other node can serve a stale transaction, and the transaction doing the withdrawal  detects the conflict. In the example above, this is resolved by the withdrawal “waiting” for the conflicting transaction to commit before being processed (this mode of waiting is called <i>pessimistic concurrency control</i>).</p>
<h3>Issues with this approach</h3>
<p>The primary issue with this approach is that a TrueTime-like service, which depends on GPS and atomic clocks, is not a commodity service. This makes it infeasible to easily deploy and run the database on most public or private clouds.</p>
<h2>4. Distributed time sync with Hybrid Logical Clocks</h2>
<p><span><a href="https://cse.buffalo.edu/tech-reports/2014-04.pdf">Hybrid Logical Clocks (HLC)</a></span> can perform distributed time synchronization without requiring a GPS/atomic clock service like TrueTime. It does this by combining physical clocks and vector clocks to enable better distributed time synchronization between the nodes of a cluster:</p>
<p><em>HLC captures the causality relationship like logical clocks, and enables easy identification of consistent snapshots in distributed systems. Dually, HLC can be used in lieu of physical/NTP clocks since it maintains its logical clock to be always close to the NTP clock.</em></p>
<p>The HLC-timestamp is a 64-bit value represented as the tuple (physical component, logical component). The physical component is a 52-bit microsecond-precision timestamp that synchronizes using NTP. The logical component is a 12-bit vector clock that tracks causal dependencies, as shown in the below diagram.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.47.40-PM.png" alt="The HLC-timestamp is a 64-bit value represented as the tuple (physical component, logical component)." width="714" height="284" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.47.40-PM.png 714w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.47.40-PM-300x119.png 300w" sizes="(max-width: 714px) 100vw, 714px"/></p>
<p>HLCs generated on any node are strictly monotonic. This ensures that the time on each node only moves forward and never jumps back. A distributed SQL database uses the physical clock (CLOCK_REALTIME in Linux) of a node to initialize the physical time component of its HLC. Because the physical component of the HLC—which is the wall clock time on the node—is synchronized using NTP or chrony, it should be possible to bound the maximum skew across any two nodes of the cluster. In practice, we see a 100-250ms max skew using NTP, so a value of 500ms is a safe default for the max skew. In effect, this means no two nodes can have their physical component more than 500ms apart if they generate timestamps at the same time.</p>
<h3>HLCs for YugabyteDB</h3>
<p><span><a href="https://www.yugabyte.com/yugabytedb/">YugabyteDB</a></span> is the first—and only—100% open-source, hybrid, multi-cloud, distributed SQL database on the planet. Each node in a YugabyteDB cluster first computes its own HLC value. When any node in the cluster makes an RPC call to another node, the pair of nodes exchange HLC timestamps. The node with the lower HLC timestamp updates its HLC to the higher value.</p>
<p>Our choice for the time sync mechanism had to take into account some of the fundamental design principles for YugabyteDB, such as:</p>
<ul>
<li>Horizontal scalability</li>
<li>Support for multi-region transactional workloads requiring geographic distribution of data</li>
<li>The ability to deploy and run anywhere with no external dependencies</li>
</ul>
<p>This ruled out the centralized timestamp oracle option because it was a scalability bottleneck and unsuitable for geo-distributed deployments. The Google Spanner approach of performing distributed time synchronization across the nodes requires a service like TrueTime. But TrueTime is not readily available in most environments (public or private clouds).</p>
<h3>Issues with this approach</h3>
<p>The main downside is in certain scenarios where concurrent transactions try to perform conflicting updates. In these scenarios, the conflict resolution depends on the maximum clock skew in the cluster. This leads to a higher number of transaction conflicts or a higher latency of the transaction.</p>
<h2>Going beyond TrueTime and HLCs</h2>
<p>The problem of improving distributed time synchronization is far from done. There are some active, interesting projects underway that aim to improve distributed time synchronization. Some of them are listed below.</p>
<h3>HUYGENS (Apr 2018)</h3>
<p><span>In <a href="https://www.usenix.org/system/files/conference/nsdi18/nsdi18-geng.pdf"><span>Exploiting a Natural Network Effect for Scalable, Fine-grained Clock </span></a></span><span><a href="https://www.usenix.org/system/files/conference/nsdi18/nsdi18-geng.pdf">Synchronization</a></span> presented at the USENIX Symposium on NSDI ‘18, the authors state:</p>
<p><em>Nanosecond-level clock synchronization can be an enabler of a new spectrum of timing- and delay-critical applications in data centers.</em></p>
<p>To achieve this, they came up with HUYGENS, a software clock synchronization system that uses a <i>synchronization network</i> and leverages three key ideas:</p>
<ul>
<li>Coded probes identify and reject impure probe data. This is data captured by probes which suffer queuing delays, random jitter, and NIC timestamp noise.</li>
<li>HUYGENS processes the purified data with Support Vector Machines, a widely-used and powerful classifier, to accurately estimate one-way propagation times and achieve clock synchronization to within 100 nanoseconds.</li>
<li>Finally, HUYGENS exploits a natural network effect—the idea that a group of pair-wise synchronized clocks must be transitively synchronized—to detect and correct synchronization errors even further.</li>
</ul>
<p>And here’s the impressive result in practice:</p>
<p><em>We find the discrepancy between clock frequencies is typically 5-10µs/sec, but it can be as much as 30µs/sec. We show that HUYGENS achieves synchronization to within a few 10s of nanoseconds under varying loads, with a negligible overhead upon link bandwidth due to probes. Because HUYGENS is implemented in software running on standard hardware, it can be readily deployed in current data centers.</em></p>
<h3>Building an accurate time service at Facebook scale (Mar 2020)</h3>
<p>Not surprisingly, Facebook experienced the similar challenge of <a href="https://engineering.fb.com/2020/03/18/production-engineering/ntp-service/"><span>synchronizing time across machines at scale</span></a>:</p>
<p><em> As Facebook’s infrastructure has grown, time precision in our systems has become more and more important. We need to know the accurate time difference between two random servers in a data center so that datastore writes don’t mix up the order of transactions. We need to sync all the servers across many data centers with sub-millisecond precision. </em></p>
<p>Facebook did some careful measurements to compare ntpd and <a href="https://chrony.tuxfamily.org/"><span>chrony.</span></a> However, the result indicates that chrony is far more precise:</p>
<p><em> During testing, we found that chrony is significantly more accurate and scalable than the previously used service, ntpd, which made it an easy decision for us to replace ntpd in our infrastructure. </em></p>
<p>Chrony was just one component of a multi-layered precision time synchronization service, backed by atomic clocks and GPS systems on satellites. Below is the architecture diagram of the four-layered service.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.49.17-PM.png" alt="The architecture diagram of Facebook&#39;s four-layered service is shown below." width="713" height="390" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.49.17-PM.png 713w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.49.17-PM-300x164.png 300w" sizes="(max-width: 713px) 100vw, 713px"/></p>
<p>With this service, they were able to improve time precision <i>from tens of milliseconds to hundreds of microseconds</i>.</p>
<h3>Sundial (Apr 2020)</h3>
<p>There was a paper that recently appeared in OSDI 2020 called <a href="https://www.usenix.org/system/files/osdi20-li_yuliang.pdf"><span>Sundial: Fault-tolerant Clock Synchronization for Datacenters</span></a>. The authors present a fault-tolerant clock synchronization system for datacenters that achieves around 100ns (yes, that’s nanoseconds)  time-uncertainty bound under various types of failures. From the abstract:</p>
<p><em> Sundial provides fast failure detection based on frequent synchronization messages in hardware. Sundial enables fast failure recovery using a novel graph based algorithm to precompute a backup plan that is generic to failures. Through experiments in a &gt;500-machine testbed and large-scale simulations, we show that Sundial can achieve ~100ns time-uncertainty bound under different types of failures, which is more than two orders of magnitude lower than <i>the state-of-the-art solutions.</i> </em></p>
<p><span><a href="http://muratbuffalo.blogspot.com/2021/03/sundial-fault-tolerant-clock.html">Sundial is able to get epsilon less than 100 nanoseconds</a></span> using the following techniques to achieve better time synchronization:</p>
<ul>
<li>Performs timestamping and synchronization at L2 data link level in a point-to-point manner using the hardware NIC. Doing synchronization at the hardware level enables frequent synchronization to compensate for the uncontrollable clock drifts of quartz clocks. They send a synchronization signal every 500 microseconds to reduce clock drift of quartz clocks and to keep epsilon very small. Performing synchronization this frequently would not work over software.</li>
<li>Sundial uses a spanning tree as the multi-hop synchronization structure and synchronizes the nodes with respect to a single root. Sundial uses predetermined backup parents to default to, so it can recover fast from link and root failures.</li>
</ul>
<h2>Conclusion</h2>
<p>We discussed a few different approaches for distributed time synchronization in this post, as summarized in the below table.</p>
<p><img loading="lazy" src="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.51.07-PM.png" alt="A few different approaches for distributed time synchronization." width="705" height="285" srcset="https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.51.07-PM.png 705w, https://blog.yugabyte.com/wp-content/uploads/2022/02/Screen-Shot-2022-02-01-at-12.51.07-PM-300x121.png 300w" sizes="(max-width: 705px) 100vw, 705px"/></p>
<p>We picked HLC, which combines the best of logical clocks and physical clocks. This ensured that we were able to meet the fundamental design principles for YugabyteDB mentioned earlier.</p>
<p>When we began the YugabyteDB project in 2016, our premise was that clock synchronization in public clouds would keep getting better over time. This premise has already proven to be true with services such as <a href="https://aws.amazon.com/about-aws/whats-new/2017/11/introducing-the-amazon-time-sync-service/"><span>Amazon Time Sync Service</span></a>, which launched in 2017 followed by <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/linux/time-sync"><span>Time Sync for Azure</span></a>.</p>
<p>Lastly, it is very exciting to see the newer, novel approaches in this area outlined in a prior section. We often look into such works to see how we can continuously improve YugabyteDB and offer higher transactional guarantees with better performance.</p>
<p><i>Ensure continuous availability and limitless scale with Yugabyte Cloud, an effortless way to get started with YugabyteDB. </i><a href="https://cloud.yugabyte.com/signup"><span><i>Register now to spin up a free YugabyteDB cluster!</i></span></a></p>
 </div></div>
  </body>
</html>
