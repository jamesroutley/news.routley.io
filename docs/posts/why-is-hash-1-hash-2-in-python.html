<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://omairmajid.com/posts/2021-07-16-why-is-hash-in-python/">Original</a>
    <h1>Why is hash(-1) == hash(-2) in Python?</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>While <del>browsing Reddit the other day</del> <a href="https://xkcd.com/303/" target="_blank">waiting for my code to
compile</a>
, I ran across this question on
r/Python:</p>
<blockquote>
<p><a href="https://www.reddit.com/r/Python/comments/oks5km/is_hash_1hash2_an_easter_egg/" target="_blank">is hash(-1) == hash(-2) an easter egg?</a>
</p>
</blockquote>
<p>Wait, is that really true?</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>$</span> python
</span></span><span><span>Python <span>3.9.6</span> (default, Jun <span>29</span> <span>2021</span>, <span>00</span>:<span>00</span>:<span>00</span>)
</span></span><span><span>[GCC <span>11.1.1</span> <span>20210531</span> (Red Hat <span>11.1.1</span><span>-</span><span>3</span>)] on linux
</span></span><span><span>Type <span>&#34;help&#34;</span>, <span>&#34;copyright&#34;</span>, <span>&#34;credits&#34;</span> <span>or</span> <span>&#34;license&#34;</span> <span>for</span> more information<span>.</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> hash(<span>-</span><span>1</span>)
</span></span><span><span><span>-</span><span>2</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> hash(<span>-</span><span>2</span>)
</span></span><span><span><span>-</span><span>2</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> hash(<span>-</span><span>1</span>) <span>==</span> hash(<span>-</span><span>2</span>)
</span></span><span><span><span>True</span>
</span></span></code></pre></div><p>Yes, it is. How surprising!</p>
<p>Let’s check some other common hash values:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> hash(<span>1</span>)
</span></span><span><span><span>1</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> hash(<span>0</span>)
</span></span><span><span><span>0</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> hash(<span>3</span>)
</span></span><span><span><span>3</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> hash(<span>-</span><span>4</span>)
</span></span><span><span><span>-</span><span>4</span>
</span></span></code></pre></div><p>All small numbers seem to hash to themselves, except <code>-1</code>…</p>
<p>Now I was completely intrigued. I tried to find the answer myself. In
the rest of this post, I will walk you through how you can also find
this answer yourself.</p>
<p>How can we get started? What would have an authoritative answer? Let’s
use the source! The actual python implementation source code!</p>
<h2 id="lets-get-the-source-code">Let’s get the source code!</h2>
<p>I am hoping that, like myself when I began this exercise, you have no
idea where the source code of python is.</p>
<p>So how can we (assuming we have <em>never</em> looked at the source code of
python) get the source code to answer the original question?</p>
<p>Maybe we can use google? A search for “python implementation” brings
up a set of interesting results.</p>
<p>The first result for me,
<a href="https://wiki.python.org/moin/PythonImplementations" target="_blank">https://wiki.python.org/moin/PythonImplementations</a>
 calls out “the Cpython
reference implementation”.</p>
<p><a href="https://github.com/python" target="_blank">https://github.com/python</a>
 has “cpython” as the number 2 repo. That
looks legit. How can we be extra sure?</p>
<p>We can check python.org. Let’s go to source downloads. I eventually
ended up at <a href="https://www.python.org/ftp/python/3.9.6/Python-3.9.6.tgz" target="_blank">https://www.python.org/ftp/python/3.9.6/Python-3.9.6.tgz</a>
.
Extracting that, the <code>README.rst</code> also points to
<a href="https://github.com/python/cpython" target="_blank">https://github.com/python/cpython</a>
</p>
<p>Okay, that’s where we will start. Let’s get this code so we can later
search through it:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/python/cpython --depth <span>1</span>
</span></span></code></pre></div><p>The <code>--depth 1</code> argument makes <code>git</code> fetch a limited amount of
history. This makes the clone operation much faster. If we need the
complete history, we can get it later.</p>
<h2 id="lets-walk-through-it">Let’s walk through it</h2>
<p>We need to find a starting point as we begin to dig through the code.
Something easy to search for. Something like a simple string without
too many misleading matches.</p>
<p>Maybe we can use the documentation of the <code>hash</code> function? We can use
<code>help(hash)</code> to see the documentation text:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> hash
</span></span><span><span><span>&lt;</span>built<span>-</span><span>in</span> function hash<span>&gt;</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> help(hash)
</span></span><span><span>Help on built<span>-</span><span>in</span> function hash <span>in</span> module builtins:
</span></span><span><span>
</span></span><span><span>hash(obj, <span>/</span>)
</span></span><span><span>    Return the hash value <span>for</span> the given object<span>.</span>
</span></span><span><span>
</span></span><span><span>    Two objects that compare equal must also have the same hash value, but the
</span></span><span><span>    reverse <span>is</span> <span>not</span> necessarily true<span>.</span>
</span></span></code></pre></div><p>Now, we can use it to find the implementation of <code>hash()</code>:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ grep -r <span>&#39;Return the hash value&#39;</span>
</span></span><span><span>Python/clinic/bltinmodule.c.h:<span>&#34;Return the hash value for the given object.\n&#34;</span>
</span></span><span><span>Python/bltinmodule.c:Return the hash value <span>for</span> the given object.
</span></span><span><span>Doc/library/functions.rst:   Return the hash value of the object <span>(</span><span>if</span> it has one<span>)</span>.  Hash values are
</span></span><span><span>Lib/hmac.py:        <span>&#34;&#34;&#34;Return the hash value of this hashing object.
</span></span></span></code></pre></div><p>The <code>hmac</code> is probably related to the crypto HMAC implementation. So
we can probably ignore that. The <code>functions.rst</code> is a documentation
file. So, let’s ignore that too.</p>
<p><code>Python/bltinmodule.c</code> looks interesting. If we look through that, we
find this snippet of code:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/*
</span></span></span><span><span><span>...
</span></span></span><span><span><span>Return the hash value for the given object.
</span></span></span><span><span><span>
</span></span></span><span><span><span>Two objects that compare equal must also have the same hash value, but the
</span></span></span><span><span><span>reverse is not necessarily true.
</span></span></span><span><span><span>[clinic start generated code]*/</span>
</span></span><span><span>
</span></span><span><span><span>static</span> PyObject <span>*</span>
</span></span><span><span><span>builtin_hash</span>(PyObject <span>*</span>module, PyObject <span>*</span>obj)
</span></span><span><span><span>/*[clinic end generated code: output=237668e9d7688db7 input=58c48be822bf9c54]*/</span>
</span></span><span><span>{
</span></span><span><span>    Py_hash_t x;
</span></span><span><span>
</span></span><span><span>    x <span>=</span> PyObject_Hash(obj);
</span></span><span><span>    <span>if</span> (x <span>==</span> <span>-</span><span>1</span>)
</span></span><span><span>        <span>return</span> NULL;
</span></span><span><span>    <span>return</span> PyLong_FromSsize_t(x);
</span></span><span><span>}
</span></span></code></pre></div><p>A search for <code>PyLong</code> brings me
<a href="https://docs.python.org/3/c-api/long.html" target="_blank">here</a>
. Looks like
<code>PyLongObject</code> is the native representation of a python integer (this
will come in handy later too). After skimming the <code>PyLongObject</code> doc
and then re-reading this code, it looks like:</p>
<ol>
<li>We call <code>PyObject_Hash</code> to find the hash of an object</li>
<li>If the computed hash value is -1, that’s an error.
<ul>
<li>It looks like we use -1 to indicate an error, so no hash function
will ever compute -1 for a real object</li>
</ul>
</li>
<li>We convert <code>Py_Ssize_t</code> to <code>PyLongObject</code> (which the documentation
calls out as: “This subtype of PyObject represents a Python integer object).</li>
</ol>
<p>Aha! that answers why <code>hash(0)</code> is <code>0</code>, <code>hash(1)</code> is <code>1</code>, <code>hash(-2)</code>
is <code>-2</code>, but <code>hash(-1)</code> is not <code>-1</code>. It’s because <code>-1</code> is internally
used to indicate an error.</p>
<p>But why is <code>hash(-1)</code> <code>-2</code>? What sets it to that value?</p>
<p>Lets see if we can find out why.</p>
<p>We can start by looking for <code>PyObject_Hash</code>. Let’s search for it.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ag PyObject_Hash
</span></span><span><span>...
</span></span><span><span>Objects/rangeobject.c
</span></span><span><span>552:    result <span>=</span> PyObject_Hash<span>(</span>t<span>)</span>;
</span></span><span><span>
</span></span><span><span>Objects/object.c
</span></span><span><span>777:PyObject_HashNotImplemented<span>(</span>PyObject *v<span>)</span>
</span></span><span><span>785:PyObject_Hash<span>(</span>PyObject *v<span>)</span>
</span></span><span><span>802:    <span>return</span> PyObject_HashNotImplemented<span>(</span>v<span>)</span>;
</span></span><span><span>
</span></span><span><span>Objects/classobject.c
</span></span><span><span>307:    y <span>=</span> PyObject_Hash<span>(</span>a-&gt;im_func<span>)</span>;
</span></span><span><span>538:    y <span>=</span> PyObject_Hash<span>(</span>PyInstanceMethod_GET_FUNCTION<span>(</span>self<span>))</span>;
</span></span><span><span>...
</span></span></code></pre></div><p>There’s a lot of noise, but the only implementation appears to be in
<code>Objects/object.c</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>Py_hash_t
</span></span><span><span><span>PyObject_Hash</span>(PyObject <span>*</span>v)
</span></span><span><span>{
</span></span><span><span>    PyTypeObject <span>*</span>tp <span>=</span> Py_TYPE(v);
</span></span><span><span>    <span>if</span> (tp<span>-&gt;</span>tp_hash <span>!=</span> NULL)
</span></span><span><span>        <span>return</span> (<span>*</span>tp<span>-&gt;</span>tp_hash)(v);
</span></span><span><span>    <span>/* To keep to the general practice that inheriting
</span></span></span><span><span><span>     * solely from object in C code should work without
</span></span></span><span><span><span>     * an explicit call to PyType_Ready, we implicitly call
</span></span></span><span><span><span>     * PyType_Ready here and then check the tp_hash slot again
</span></span></span><span><span><span>     */</span>
</span></span><span><span>    <span>if</span> (tp<span>-&gt;</span>tp_dict <span>==</span> NULL) {
</span></span><span><span>        <span>if</span> (PyType_Ready(tp) <span>&lt;</span> <span>0</span>)
</span></span><span><span>            <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>        <span>if</span> (tp<span>-&gt;</span>tp_hash <span>!=</span> NULL)
</span></span><span><span>            <span>return</span> (<span>*</span>tp<span>-&gt;</span>tp_hash)(v);
</span></span><span><span>    }
</span></span><span><span>    <span>/* Otherwise, the object can&#39;t be hashed */</span>
</span></span><span><span>    <span>return</span> PyObject_HashNotImplemented(v);
</span></span><span><span>}
</span></span></code></pre></div><p>This is quite a confusing piece of code. Thankfully, the comment is
illuminating. After reading through it a few times, it seems like the
code - accounting for some lazy loading of the type (?) - finds the
type of the object (using <code>Py_TYPE</code>). Then looks for a function
<code>tp_hash</code> of that type and calls that function on v:
<code>(*tp-&gt;tp_hash)(v)</code></p>
<p>Where would we find the <code>tp_hash</code> of <code>-1</code>? Let’s do another search for
<code>tp_hash</code>:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ag tp_hash -l
</span></span><span><span>...
</span></span><span><span>Modules/_multiprocessing/semaphore.c
</span></span><span><span>Objects/sliceobject.c
</span></span><span><span>Objects/moduleobject.c
</span></span><span><span>Objects/exceptions.c
</span></span><span><span>Modules/_pickle.c
</span></span><span><span>Objects/frameobject.c
</span></span><span><span>Objects/setobject.c
</span></span><span><span>Objects/rangeobject.c
</span></span><span><span>Objects/longobject.c
</span></span><span><span>Objects/object.c
</span></span><span><span>Objects/methodobject.c
</span></span><span><span>Objects/classobject.c
</span></span><span><span>Objects/enumobject.c
</span></span><span><span>Objects/odictobject.c
</span></span><span><span>Objects/complexobject.c
</span></span><span><span>...
</span></span></code></pre></div><p>That’s a huge list. Recalling what the documentation said about
<code>PyLongObject</code> (“This … represents a Python integer object”), I
started by looking at <code>Objects/longobject.c</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>PyTypeObject PyLong_Type <span>=</span> {
</span></span><span><span>    PyVarObject_HEAD_INIT(<span>&amp;</span>PyType_Type, <span>0</span>)
</span></span><span><span>    <span>&#34;int&#34;</span>,                                      <span>/* tp_name */</span>
</span></span><span><span>    offsetof(PyLongObject, ob_digit),           <span>/* tp_basicsize */</span>
</span></span><span><span>    <span>sizeof</span>(digit),                              <span>/* tp_itemsize */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_dealloc */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_vectorcall_offset */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_getattr */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_setattr */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_as_async */</span>
</span></span><span><span>    long_to_decimal_string,                     <span>/* tp_repr */</span>
</span></span><span><span>    <span>&amp;</span>long_as_number,                            <span>/* tp_as_number */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_as_sequence */</span>
</span></span><span><span>    <span>0</span>,                                          <span>/* tp_as_mapping */</span>
</span></span><span><span>    (hashfunc)long_hash,                        <span>/* tp_hash */</span>
</span></span><span><span>    ...
</span></span></code></pre></div><p>So <code>tp_hash</code> is <code>long_hash</code> of objects of type <code>PyLongObject</code>. Let’s look at that.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> Py_hash_t
</span></span><span><span><span>long_hash</span>(PyLongObject <span>*</span>v)
</span></span><span><span>{
</span></span><span><span>    Py_uhash_t x;
</span></span><span><span>    Py_ssize_t i;
</span></span><span><span>    <span>int</span> sign;
</span></span><span><span>
</span></span><span><span>    ...
</span></span><span><span>
</span></span><span><span>    <span>if</span> (x <span>==</span> (Py_uhash_t)<span>-</span><span>1</span>)
</span></span><span><span>        x <span>=</span> (Py_uhash_t)<span>-</span><span>2</span>;
</span></span><span><span>    <span>return</span> (Py_hash_t)x;
</span></span><span><span>}
</span></span></code></pre></div><p>Note that I have removed a big chunk of the implementation details.
But the ending of this function matches exactly what we are expecting:
<code>-1</code> is reserved for an error signal, so the code converts that return
value explicitly to <code>-2</code>!</p>
<p>And that explains the entire reason why <code>hash(-1)</code> ends up being the
same as <code>hash(-2)</code>. Not an easter egg, just working around the
unavailability of <code>-1</code> as the possible result of a <code>hash()</code> method.</p>
<h2 id="is-this-the-rightcomplete-answer">Is this the right/complete answer?</h2>
<p>As I said earlier, I have never looked through the python code base at
all. I <em>think</em> I have an answer. But is it right? I might be
completely wrong.</p>
<p>Thankfully, <a href="https://www.reddit.com/r/Python/comments/oks5km/is_hash_1hash2_an_easter_egg/h5a7ylc/" target="_blank">/u/ExoticMandibles provided an answer on the Reddit post
itself</a>
:</p>
<blockquote>
<p>The reference implementation of Python is “CPython”, which is almost
certainly the Python you’re using. CPython is written in C, and
unlike Python, C doesn’t have exceptions. So, in C, when you design
a function, and you want your function to be able to indicate “there
was an error”, it has to return that error as its return value.</p>
<p>The hash() function in CPython can return an error, so it defines a
return code of -1 to mean “there was an error”. But this could be
confusing if the hash worked correctly, and the actual hash of an
object was -1. So the convention is: if hashing worked, and you got
a -1, return -2.</p>
<p>There’s special code in the hash function for ints (“long objects”)
in CPython that does exactly that:</p>
<p><a href="https://github.com/python/cpython/blob/main/Objects/longobject.c#L2967" target="_blank">https://github.com/python/cpython/blob/main/Objects/longobject.c#L2967</a>
</p>
</blockquote>
<p>This is exactly what I had guessed by reading the code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I started with a question that I thought might be difficult to answer.
But a few minutes of digging through code - and python’s clean
codebase makes looking through it much easier than some other
codebases I have seen - and the answer is quite easy to discover and
understand! Which shouldn’t be surprising if you have been around
computers. There’s no magic, just layers and layers of abstractions
and code.</p>
<p>If there’s a take away here, let it be this: <a href="https://wiki.c2.com/?UseTheSourceLuke" target="_blank">Use the
source!</a>
</p>

	</div></div>
  </body>
</html>
