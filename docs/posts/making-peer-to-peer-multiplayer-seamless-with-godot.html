<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rafa.ee/articles/godot-peer-to-peer-multiplayer/">Original</a>
    <h1>Making peer-to-peer multiplayer seamless with Godot</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  
    <small>
     <time datetime="2022-01-02T00:00:00+00:00">January 02, 2022</time>
    </small>
  

  <p>When we started developing our recently-released mini-strategy game <span><a href="https://pomme-grenade.itch.io/2planets">2 Planets</a></span>, we wanted to add networked multiplayer support.
Since the game is a side project and would be released for free, we didn’t want to spend much time and money on maintaining dedicated servers.
Instead, we chose a simple peer-to-peer networking setup where both players would connect to the other player’s machine directly.</p>

<p>Our initial implementation was very simple - players entered the IP of their match partner, we passed it to Godot and let the engine handle the rest. This had some problems:</p>
<ul>
<li>Entering IP addresses by hand is cumbersome and error-prone</li>
<li>No matchmaking support</li>
<li>Machines behind a <a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a>-enabled router are not accessible directly</li>
</ul>
<p>To solve these problems, we set up a small “rendezvous” server capable of <a href="https://en.wikipedia.org/wiki/Hole_punching_(networking)">NAT hole punching</a>.
When starting a game, players connect to the publicly available server, which sends them the IP address of their match partner and punches holes into router’s NATs if needed.
Both game clients then connect directly to each other, and the server’s job is done.
This process allowed us to connect players using small “Match codes” which were shorter and easier to type than IP addresses. We haven’t implemented matchmaking yet, but adding it to the current implementation would be a simple task.</p>
<video controls="">
    <source src="game_code_demo.mp4" type="video/mp4"/>
</video>
<small>Two players starting a game over the network in 2 Planets</small>
<p>I consider this approach ideal for small indie games.
Dedicated servers allow better cheat protection, and NAT hole punching doesn’t work all the time, but with this approach, the maintenance burden and complexity is considerably lower, both for the game’s code and the server’s operation.</p>
<p>If you’re looking for a way to have peer-to-peer multiplayer without setting up your own server, have a look at <a href="https://partner.steamgames.com/doc/features/multiplayer/networking">Steam’s Networking API</a> which also has a <a href="https://gramps.github.io/GodotSteam/functions-module.html#networking">Godot integration via GodotSteam</a>, or have a look at the <a href="http://dev.epicgames.com/docs/services/en-US/GameServices/P2P/index.html">Epic’s NAT P2P API</a>. Both provide NAT hole punching support with relay services as a fallback.</p>
<p>If, on the other hand, you want to stay independent of Steam and Epic or just like to do things yourself, continue reading! In the following you’ll find a short guide on setting up peer-to-peer multiplayer with NAT hole-punching in Godot for your own game, using your own server.</p>
<h2 id="setting-up-your-own">Setting up your own</h2>
<p>You’ll need the following:</p>
<ul>
<li>The excellent <a href="https://github.com/SLGamesCregg/HolePuncher">HolePuncher</a> Godot plugin and server by Cregg Hancock</li>
<li>A server or service allowing you to host a small python application (e.g. <a href="https://www.heroku.com/">Heroku</a> or <a href="https://vercel.com/">Vercel</a>)</li>
<li>Basic networking and server administration knowledge. Using a service like Heroku, you can get a python server up and running pretty easily, but you’ll still need some experience to configure everything correctly.</li>
<li>An understanding of <a href="https://docs.godotengine.org/en/stable/tutorials/networking/high_level_multiplayer.html">Godot’s multiplayer API</a> for connecting clients using the IP obtained from the rendezvous server and synchronizing the game state.</li>
</ul>
<p>First, deploy the <a href="https://github.com/SLGamesCregg/HolePuncher">HolePuncher</a> python server. Make sure it is accessible from your development machine. You don’t need a domain: if your server has a static IP, you can use that to let your clients initiate a connection.</p>
<p>Next, download and include the HolePuncher Godot plugin in your game. Copy the <code>addons</code> folder from the HolePuncher repository and place it at the root of your Godot project folder. Afterwards, go to <em>Project &gt; Project Settings &gt; Plugins</em> and enable the HolePuncher plugin.
You can now add and configure a <code>HolePunch</code> node to your menu scene.
We’ll do that in the following script:</p>
<pre data-lang="python"><code data-lang="python"><span>hole_puncher </span><span>= </span><span>preload</span><span>(</span><span>&#39;res://addons/Holepunch/holepunch_node.gd&#39;</span><span>)</span><span>.</span><span>new</span><span>()
</span><span># your rendezvous server IP or domain
</span><span>hole_puncher</span><span>.</span><span>rendevouz_address </span><span>= </span><span>&#34;1.1.1.1&#34;
</span><span># the port the HolePuncher python application is running on
</span><span>hole_puncher</span><span>.</span><span>rendevouz_port </span><span>= </span><span>&#34;3000&#34;
</span><span>add_child</span><span>(hole_puncher)
</span></code></pre>
<p>Refer to the <a href="https://github.com/SLGamesCregg/HolePuncher">HolePuncher documentation</a> to learn more about its configuration. </p>
<pre data-lang="python"><code data-lang="python"><span># Generate a unique ID for this machine
</span><span>var player_id </span><span>= </span><span>OS</span><span>.</span><span>get_unique_id</span><span>()
</span><span>hole_puncher</span><span>.</span><span>start_traversal</span><span>(game_code</span><span>, </span><span>is_host</span><span>, </span><span>player_id)
</span><span># Yield an array of [own_port, host_port, host_ip]
</span><span>var result </span><span>= yield</span><span>(hole_puncher</span><span>, </span><span>&#39;hole_punched&#39;</span><span>)
</span></code></pre>
<p>Run this code on both machines, with <code>is_host</code>
set to <code>true</code> on one machine, and to <code>false</code> on the other. </p>
<p>The <code>yield</code> call above turns your code into a <a href="https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/gdscript_basics.html#coroutines-with-yield">coroutine</a> which will continue running after all the network calls have succeeded, which can take a few seconds.
When the hole puncher is done, you can use the returned information to create a Godot network peer.
You might use it like this:</p>
<pre data-lang="python"><code data-lang="python"><span># Start a host
</span><span>var result </span><span>= yield</span><span>(hole_puncher</span><span>, </span><span>&#39;hole_punched&#39;</span><span>)
</span><span>var my_port </span><span>= </span><span>result[</span><span>0</span><span>]
</span><span>
</span><span>var peer </span><span>= </span><span>NetworkedMultiplayerENet</span><span>.</span><span>new</span><span>()
</span><span>peer</span><span>.</span><span>create_server</span><span>(my_port</span><span>, </span><span>1</span><span>)
</span><span>get_tree</span><span>()</span><span>.</span><span>set_network_peer</span><span>(peer)
</span></code></pre>
<pre data-lang="python"><code data-lang="python"><span># Connect a client to a host
</span><span>var result </span><span>= yield</span><span>(hole_puncher</span><span>, </span><span>&#39;hole_punched&#39;</span><span>)
</span><span>var host_ip </span><span>= </span><span>result[</span><span>2</span><span>]
</span><span>var host_port </span><span>= </span><span>result[</span><span>1</span><span>]
</span><span>var own_port </span><span>= </span><span>result[</span><span>0</span><span>]
</span><span>
</span><span>var peer </span><span>= </span><span>NetworkedMultiplayerENet</span><span>.</span><span>new</span><span>()
</span><span>peer</span><span>.</span><span>create_client</span><span>(host_ip</span><span>, </span><span>host_port</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>own_port)
</span><span>get_tree</span><span>()</span><span>.</span><span>set_network_peer</span><span>(peer)
</span></code></pre>
<p>After starting a host on one machine and connecting a client on another, you can start the game! Congratulations, you now have peer-to-peer multiplayer support from (almost) any network!</p>
<p>Of course, this example only works for two players and is heavily simplified, you’ll need to add at least a way for players to exchange game codes and handle errors that appear during connection attempts. If you’d like to see a more realistic example, have a look at the <a href="https://github.com/pomme-grenade/2planets/blob/master/menu/lobby_networking.gd">lobby code from <span>2 Planets</span></a>. If you’re interested in adding matchmaking, have a look at the source code of the HolePuncher server. It’s pretty compact.</p>
<p>I hope this guide was a good starting point for adding NAT hole punching to your game. NAT hole punching is a complex topic and you will probably have to look into other resources for a robust solution that fits your use-case, but getting started is surprisingly easy! If you have any questions or comments, feel free to reach out on <a href="https://twitter.com/rafaelepplee">twitter</a> or <a href="https://www.reddit.com/user/raffomania">reddit</a>.</p>

</article></div>
  </body>
</html>
