<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://imedadel.com/outcrop/">Original</a>
    <h1>I built a faster Notion in Rust</h1>
    
    <div id="readability-page-1" class="page"><div> <article> <picture> <source srcset="/_astro/outcrop-hero.D8hFMAtr_Z248aCF.webp" type="image/webp"/>  <img src="https://imedadel.com/_astro/outcrop-hero.D8hFMAtr_1EAWPy.png" alt="I built an actually faster Notion in Rust" loading="lazy" decoding="async" fetchpriority="auto" width="2540" height="1520"/> </picture>  <p><em>I’m building <a href="https://outcrop.app">Outcrop</a>. If your team’s looking for a Confluence alternative, sign up for <a href="https://outcrop.app">early access</a> or become an <a href="https://buy.stripe.com/dRmaEX8ax4183yzcdV3Je05">early sponsor</a>.</em></p>
<p>Eight months ago I left my job at Stripe to build a knowledge base. I had sat out the urge to do this for years by then. There have been many attempts at building a faster alternative, some of them mine. I don’t think any of them came close to getting it done.</p>
<p>What does it mean to build a better knowledge base? By the time I left my job, I had worked across many teams, built some knowledge systems, maintained some others, and read a whole lot of them. Stripe was the first company I worked at that had this figured out; they got themselves a team to build their own internal knowledge base, with search bridging the gap to other services.</p>
<p>As it turns out, all you need is speed and simplicity. Teams owned one or more spaces, and you didn’t have to remember where’s what, as you could find it with a quick search. Your team got assigned a task whenever a document went out of date.</p>
<p>The timing couldn’t be more right. Linear had already figured this out for product management. Many documentation tools gave up on building a good product and shifted their focus to competing with chat interfaces. Atlassian is sunsetting their Data Center offering, a once in a lifetime event that lets you swoop in and sign up their largest customers. Regulations over data residency have been tightening in Europe, and it helps to be an Irish company.</p>
<p>How do you build a simpler product? Counterintuitively, you start by building a much more complex one. It’s easy to wrap a database in a theme and call it a week, but you’d hit the same scaling issues as the next tool.</p>
<p>This is not where your favourite language comes in. I started by wrapping a database in a theme, in a week. I used Go and it’s a nice little language. But a couple of weeks in, I was writing more code for generating code than actual application code. There are many parts to a knowledge base, and no one has the time to write all the boilerplate. If you’re building a progressively complex system, you better have some automated way to know when services aren’t compatible anymore. By this point, I’ve decided that users should be able to collaborate in real time, and I wasn’t satisfied with search latency, and querying the database to check who can do what was getting tiresome. This is where your favourite language comes in.</p>
<pre tabindex="0" data-language="go"><code><span><span>const</span><span> (</span></span>
<span><span>	CreateSpaceMethod</span><span> =</span><span> &#34;POST&#34;</span></span>
<span><span>	CreateSpacePath</span><span>   =</span><span> &#34;/v1/spaces&#34;</span></span>
<span><span>)</span></span>
<span></span>
<span><span>type</span><span> CreateSpaceRequest</span><span> struct</span><span> {</span></span>
<span><span>	Name </span><span>string</span><span> `json:&#34;name&#34; binding:&#34;required&#34;`</span></span>
<span><span>}</span></span>
<span></span>
<span><span>type</span><span> CreateSpaceResponse</span><span> =</span><span> query</span><span>.</span><span>Space</span></span>
<span></span>
<span><span>func</span><span> (</span><span>r </span><span>*</span><span>Router</span><span>) </span><span>CreateSpace</span><span>(</span><span>c</span><span> *</span><span>gin</span><span>.</span><span>Context</span><span>, </span><span>req</span><span> CreateSpaceRequest</span><span>) (</span><span>int</span><span>, </span><span>CreateSpaceResponse</span><span>, </span><span>error</span><span>) {</span></span>
<span><span>	// [...]</span></span>
<span><span>}</span></span></code></pre>
<p>It didn’t take long to rewrite everything in Rust. Somehow I ended up with fewer lines of code as I replaced my handwritten bits for generating code with macro crates. What looked like a soup of text is now a more readable <code>utoipa</code> call. The ecosystem isn’t the largest out there, but it has some nifty crates that make your life so much easier.</p>
<pre tabindex="0" data-language="rust"><code><span><span>#[utoipa</span><span>::</span><span>path(get, path </span><span>=</span><span> &#34;/v1/spaces&#34;</span><span>, responses((status </span><span>=</span><span> OK</span><span>, body </span><span>=</span><span> Vec</span><span>&lt;model</span><span>::</span><span>Space</span><span>&gt;)))]</span></span>
<span><span>pub</span><span> async</span><span> fn</span><span> list_spaces</span><span>() </span><span>-&gt;</span><span> Result</span><span>&lt;(</span><span>StatusCode</span><span>, </span><span>Json</span><span>&lt;</span><span>Vec</span><span>&lt;model</span><span>::</span><span>Space</span><span>&gt;&gt;)&gt; {</span></span>
<span><span>    // [...]</span></span>
<span><span>}</span></span></code></pre>
<h3 id="a-tiny-zanzibar">A tiny Zanzibar</h3>
<p>With Rust in my toolbox, or rather, being my toolbox, there were so many bits I could now at least dream of building, and stay up for nights making a reality. A while ago, Google wrote about their Zanzibar authorisation system. I was getting fed up with querying the database on each call to make sure your man can actually access the page they’re requesting. There were already some open source implementations inspired by Google’s architecture, however, they felt a bit overwhelming. It’s straightforward to launch a new Docker container, but you’ve now taken on the burden of maintaining and debugging a service that might not be as documented or as supported as you might need.</p>
<p>The concepts behind Zanzibar are compelling; abstract your authorisation system away from your usual database queries and application code. I chose to build a tinier version of it. It’s not decentralised, it’s persisted to Postgres, but loaded in memory on startup. It doesn’t have a complicated configuration language; I already know my entities. The relation is defined in a <code>csv</code> file right next to the code.</p>
<pre tabindex="0" data-language="csv"><code><span><span>Scope,</span><span>  Role,</span><span>           Action,</span><span>                         Object</span></span>
<span><span>space,</span><span>  owner|admin,</span><span>    read|create|update|list|delete,</span><span> space</span></span>
<span><span>page,</span><span>   viewer,</span><span>         read|list,</span><span>                      page|comment</span></span></code></pre>
<p>Permissions are inheritable. Being a member of a team with access to a certain space immediately gives you access to that same space. Services can invoke the authorization system with a single macro call.</p>
<pre tabindex="0" data-language="rust"><code><span><span>grant!</span><span>(user_id, </span><span>Editor</span><span>, </span><span>Page</span><span>(page_id));</span></span>
<span><span>must!</span><span>(user_id, </span><span>Page</span><span>(page_id), </span><span>Update</span><span>);</span></span></code></pre>
<p>Without much optimisation, it takes nanoseconds to check if a user has access the right permissions to access a resource. It takes milliseconds to list every resource a user or a team have access to.</p>
<p><img alt="Benchmark results for authorisation checks" loading="lazy" decoding="async" fetchpriority="auto" width="450" height="300" src="https://imedadel.com/_astro/outcrop-enforce-bench.ChuzEEtm_ZFVXR0.svg"/></p>
<h3 id="a-more-elastic-search">A more elastic search</h3>
<p>A knowledge base is only as good as its search engine. I had been following the success of <code>tantivy</code> for a while. Its demos were convincing. There are easier ways to go about doing this, and your favourite tools all do it the same way; but they would’ve been too slow. Is your way truly any better than the other hundred if you’re making all the same choices as everyone else? My search engine was ready. Not long after, I added language detection, partially using <code>whatlang</code>, and multilingual tokenisation.</p>
<p>I didn’t expect much out of this, but I could now see the results coming in, with no latency I could notice, as I typed my queries. With authorisation also being within my control, I went a step further and integrated it with search. In the engine’s core, only the resources you can access are considered. They’re kept seamlessly in sync.</p>
<p>It might’ve taken longer than it should’ve to build these two integrated systems, but reading up other companies’ experiences, I think it saved me years of headaches.</p>
<h3 id="oxidising-prose">Oxidising prose</h3>
<p>I had hacked around with <code>prosemirror</code> before and it was the obvious choice this time. There are many collaboration plugins to use with it. It’s at this point that I started to think that my choice of Rust might finally come back to haunt me. The project itself comes with well-tested collaboration primitives, which I couldn’t use, because they were in JavaScript. I was aware of some alternatives, but they felt bloated and would get slower with larger documents and more users. It would’ve been foolish to rewrite such a massive project in Rust.</p>
<p>User edits are recorded as a list of steps, fed to <code>prosemirror</code> and compared against the original document for conflicts. An updated document with a new version hash is generated after, and persisted. To sidestep the issue, I applied the steps on the client-side, sent back the whole document, along with the steps, which I forwarded to the other connected users. This worked fine. With everything happening in real time, and given fast enough internet, no one would notice. But this meant that anyone could send anything and replace the whole document. It also introduced unnecessary latency and potential lag if you ever went through a patch of slow internet. With steps, and therefore, new documents, being generated for every few keys pressed, it wasn’t ideal. After building such great authorisation and search systems, this felt like a step down.</p>
<p>Is it foolish to rewrite <code>prosemirror</code> in Rust? It’s around this time that I realised someone had already done this work for Go. Ugh. I spent the rest of the week trying to set up <code>quickjs</code> or <code>v8</code> to process steps on the backend. They were fine, albeit buggy, but I couldn’t feel the added complexity’s worth. It’s time to do the thing. I spent the next week porting <code>prosemirror</code> to Rust along with all its tests and thousands of compatibility snapshots. I think I barely left the house that time.</p>
<pre tabindex="0" data-language="rust"><code><span><span>#[test]</span></span>
<span><span>fn</span><span> slice_can_cut_half_a_paragraph</span><span>() {</span></span>
<span><span>    let</span><span> original </span><span>=</span><span> doc!</span><span>(</span><span>p!</span><span>(</span><span>&#34;hello world&#34;</span><span>));</span></span>
<span><span>    let</span><span> expected </span><span>=</span><span> doc!</span><span>(</span><span>p!</span><span>(</span><span>&#34;hello&#34;</span><span>));</span></span>
<span><span>    let</span><span> result </span><span>=</span><span> original</span><span>.</span><span>slice</span><span>(</span><span>0</span><span>, </span><span>Some</span><span>(</span><span>6</span><span>), </span><span>None</span><span>)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>    assert_eq!</span><span>(result</span><span>.</span><span>content, </span><span>*</span><span>expected</span><span>.</span><span>content</span><span>());</span></span>
<span><span>    assert_eq!</span><span>(result</span><span>.</span><span>open_start, </span><span>0</span><span>);</span></span>
<span><span>    assert_eq!</span><span>(result</span><span>.</span><span>open_end, </span><span>1</span><span>);</span></span>
<span><span>}</span></span></code></pre>
<p>It’s hard to know how great the thing is until you do it. In this case, it now takes mere microseconds to apply document edits.</p>
<p><img alt="Benchmark results for prosemirror" loading="lazy" decoding="async" fetchpriority="auto" width="450" height="300" src="https://imedadel.com/_astro/outcrop-replace-simple.Ct_nqG7I_ZFVXR0.svg"/></p>
<p>I haven’t given it much thought at the time, but a while after I realised the potential applications for having done this. It’s much easier to extract text content from documents before feeding them to the search engine, it’s easier to extract links or mentions, and it’s easier to add tab completion. You can’t trust a large language model with editing a structured document, but if you check and resolve any conflicts within instants, it doesn’t matter if half its suggestions break the structure. Adding tab completion or structured suggestions isn’t my top priority at the moment, but it’s now at least possible.</p>
<h3 id="safe-sockets">Safe sockets</h3>
<p>That little crab is rather trusty. I think that matters the most when you’re tens of thousands of lines deep into your work. I’d rather be told when something’s broken, than be left to discover it a few months later, at two in the morning. Thanks to <code>utoipa</code>, again, real time messages are synced to the frontend, so TypeScript can carry on the trust.</p>
<pre tabindex="0" data-language="rust"><code><span><span>fn</span><span> create_docs</span><span>() </span><span>-&gt;</span><span> OpenApi</span><span> {</span></span>
<span><span>    OpenApiBuilder</span><span>::</span><span>new</span><span>()</span></span>
<span><span>        .</span><span>info</span><span>(</span><span>Info</span><span>::</span><span>new</span><span>(</span><span>&#34;live&#34;</span><span>, </span><span>&#34;1.0.0&#34;</span><span>))</span></span>
<span><span>        .</span><span>components</span><span>(</span><span>Some</span><span>(</span></span>
<span><span>            ComponentsBuilder</span><span>::</span><span>new</span><span>()</span></span>
<span><span>                .</span><span>schema_from</span><span>::</span><span>&lt;</span><span>Command</span><span>&gt;()</span></span>
<span><span>                .</span><span>schema_from</span><span>::</span><span>&lt;</span><span>CommandReply</span><span>&gt;()</span></span>
<span><span>                .</span><span>schema_from</span><span>::</span><span>&lt;</span><span>MsgContent</span><span>&gt;()</span></span>
<span><span>                .</span><span>build</span><span>(),</span></span>
<span><span>        ))</span></span>
<span><span>        .</span><span>build</span><span>()</span></span>
<span><span>}</span></span></code></pre>
<h3 id="beyond-prose">Beyond prose</h3>
<p>An editor is more than just text. It’s its own tiny app. It’s well known, by now, that <code>react</code> doesn’t mix well with <code>prosemirror</code>. You could hack your way around it, or you could once again choose to do something different. I happen to be quite fond of <code>solid</code>. Unfortunately, the ecosystem is still too small to build an entire user interface with it. But it’s solid enough to integrate with <code>prosemirror</code> and handle its rendering cycle. With indirection out of the way, there’s so much one can make. Nothing, but time, is holding me off from adding advanced diagrams, plots, macros, variables, canvases, and all the things no other editor has ever dared to dream of. A knowledge base could be about more than just prose; some threads, a few slides, a spreadsheet even.</p>
<p>Tools are about workflows. Linear had that figured out. And workflows are about structure. Documents should expire. They should be linted for dead links and mistakes. Your knowledge tools should sync with your task management ones. These are some low-hanging bits. We live at a time where we can push well past the boundaries of structure. A link might not be dead, but it could’ve lost any semantic relevance by this point. The recent code changes might’ve made your diagrams out-of-date. Language models won’t write your prose, but they can push workflows.</p>
<h3 id="whats-next">What’s next?</h3>
<p><img alt="Screenshot of Outcrop" loading="lazy" decoding="async" fetchpriority="auto" width="2540" height="1520" src="https://imedadel.com/_astro/outcrop-hero.D8hFMAtr_Z248aCF.webp"/></p>
<p>There’s a lot more work to be done. I made a <a href="https://outcrop.app">marketing page</a> with some demos you could check out. You could join the <a href="https://tally.so/r/nrXrz5">waitlist</a>. I’m aiming to launch within the next six months. Each seat will cost around €/$10. If you see yourself using this product, consider sponsoring Outcrop today for <a href="https://buy.stripe.com/3cI5kDfCZcxE0mn5Px3Je01">€/$100</a>; you’ll get €/$200 as credits on launch.</p>
<p>If you’ve got any questions, or ideas, you can reach me at <code>imed</code> under <code>outcrop.app</code>.</p>
<p>Thank you!</p> <p> <time datetime="2025-10-28T00:00:00.000Z"> 28 Oct 2025 </time> </p> </article> </div></div>
  </body>
</html>
