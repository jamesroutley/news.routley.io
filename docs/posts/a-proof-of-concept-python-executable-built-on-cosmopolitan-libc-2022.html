<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ahgamut.github.io/2021/07/13/ape-python/">Original</a>
    <h1>A proof-of-concept Python executable built on Cosmopolitan Libc (2022)</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><div><header><p><a href="https://ahgamut.github.io/"><b>Blog Needs a Name</b></a></p><ul><li><a href="https://ahgamut.github.io/">Home</a></li><li><a href="https://ahgamut.github.io/about">About</a></li></ul></header><hr/><h2>Python is Actually Portable</h2><p><strong>Update (2022-07-27)</strong> : This post describes a proof-of-concept Python
executable (2.7.18 and 3.6.14) built on <a href="https://github.com/jart/cosmopolitan">Cosmopolitan
Libc</a>, which allows it to run on six
different operating systems (Linux, Mac, Windows, NetBSD, FreeBSD, OpenBSD).
It’s been more than a year since I put this together, and now Python3.6 and its
test suite are part of the <a href="https://github.com/jart/cosmopolitan/pull/235">Cosmopolitan Libc
monorepo</a>. There’s been a LOT of
work done to improve <code>python.com</code> over vanilla Python3.6 – a custom
<a href="https://github.com/jart/cosmopolitan/pull/425"><code>sys.meta_path</code> entry</a> for
faster loading, <a href="https://justine.lol/sizetricks#dzd">size reductions</a> of the
<code>unicodedata</code>, a <code>cosmo</code> module for Cosmopolitan-specific goodies, a revamp of
Python’s build and testing system, a superb REPL experience, backports from
Python 3.7, and a lot more! So some of the details in this blog post are likely
out of date. Check out the history of APE Python
<a href="https://github.com/jart/cosmopolitan/issues/141">here</a>, build it via the
Cosmopolitan monorepo, or download <code>python.com</code> from
<a href="https://justine.lol/ftrace/python.com">here</a>. I’m also trying to port the newer
versions of Python and some well-known Python packages like numpy. Join the
discussion about Python and Cosmopolitan Libc in the
redbean Discord server: <a href="https://discord.gg/rGQja6kS">https://discord.gg/rGQja6kS</a></p><p>Back in February, I put together <a href="https://ahgamut.github.io/2021/02/27/ape-cosmo/">Lua 5.4</a> using <a href="https://github.com/jart/cosmopolitan">Cosmopolitan
Libc</a> as a quick proof-of-concept, and that led to Lua 5.4 being
<a href="https://github.com/jart/cosmopolitan/issues/61#issuecomment-792359199">vendored</a> as part of the Cosmopolitan repository on Github, along
with many other interesting developments. It’s pretty exciting to try and
compile well-known C projects using Cosmopolitan; the portability reward is
great motivation, and I get to observe the design, coding style, and build
system of high-quality codebases.</p><p>However, my initial plan with Cosmopolitan was not to compile Lua, it was to
compile Python. Since February, I’ve been trying to understand how Cosmopolitan
works, reading the repo code and submitting PRs occasionally, and finally I have
an actually portable version of Python 2.7.18 (and 3.6.14<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>) – you
can build it from the repository <a href="https://github.com/ahgamut/cpython/tree/cosmo_py27">here</a>. It’s not solid as Lua 5.4
because it currently passes only a third of the regression tests, but most of
the parts are there. For example, here’s a GIF showing a simple <a href="https://flask.palletsprojects.com/en/2.0.x/">Flask
webapp</a> running via the <code>python.com</code> APE.</p><p><img src="https://ahgamut.github.io/images/ape-python.gif" alt="webapp" loading="lazy" decoding="async" width="" height=""/></p><p>It’s quite slow, but it works(tested on Debian Linux and Windows
10<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>), and there’s a lot of room for improvement. This post
describes the kinds of changes I made to get Python to work.</p><h2 id="getting-python-to-compile">Getting Python to compile</h2><p>Python 2.7.18 is built via the <a href="https://en.wikipedia.org/wiki/Configure_script"><code>configure</code> idiom</a>: the tarball
provides a <code>configure</code> shell script which runs the necessary compatibility tests
for the host system/compiler. which then creates the Makefile for the actual
build, and fills <code>pyconfig.h</code> with the necessary <code>#define</code>s related to the
features available in the host system.</p><p>I added dummy headers like for Lua, and wrote a <code>superconfigure</code> script which
called <code>configure</code> with the flags for the Cosmopolitan
<a href="https://github.com/jart/cosmopolitan#getting-started">amalgamation</a>, like below:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>./configure --disable-shared <span>\
</span></span></span><span><span><span></span>    --without-threads --disable-ipv6 <span>\
</span></span></span><span><span><span></span>    <span>CFLAGS</span><span>=</span><span>&#34;</span><span>$COSMO_CFLAGS</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>    <span>LDFLAGS</span><span>=</span><span>&#34;</span><span>$COSMO_LDFLAGS</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>    <span>LIBS</span><span>=</span><span>&#34;cosmopolitan.a&#34;</span>
</span></span><span><span>make -j4
</span></span></code></pre></div><p>This started the build, but almost every source file had complaints about
functions being re-declared. For example, the Makefile assumed that <code>sinh</code> was
not available, and wrongly had <code>#define HAVE_SINH 0</code>, which caused it to use
Python’s backup implementation.</p><p>It turns out that the <code>CFLAGS</code> provided for the cosmopolitan amalgamation
clashed with <a href="https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Generic-Functions.html"><code>AC_CHECK_FUNC</code></a>, which is what <code>configure</code> scripts use
to check if the host provides a particular function. At the time, the simplest
fix was to edit the <code>AC_CHECK_FUNC</code> part of <code>configure</code> script to make it play
well, and it just worked<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p><p>After that, fixing the remaining errors was mostly straightforward: add a few
<code>#define</code>s or <code>#undef</code>s to avoid missing functions, ensure the Makefile
performed the linking correctly, find-and-replace for name
clashes<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>, and so on.</p><h2 id="running-the-base-interpreter">Running the base interpreter</h2><p>I tried running the <code>python.com</code> APE within the build directory, and it worked
without a hitch. But when I moved the executable somewhere, the interpreter
would start up and then exit with a failure <code>unable to import site</code>: Python
checks for <code>site.py</code> in <code>sys.path</code> at startup, which sets up the import context
for the rest of the standard library (stuff like which OS the APE is on for
<code>os.py</code>). Running <code>python.com -S</code> fixed the issue<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>, and later I
added a few relative folder paths to <code>sys.path</code> so that Python could search
there at startup.</p><p>One annoying issue I faced with the <code>python.com</code> REPL on Linux was I had to
press <code>Return</code> twice when I wanted to enter an empty line to the REPL. By
running <code>python.com -u</code> I found out this this was related to input buffering and
<a href="https://en.cppreference.com/w/c/io/setvbuf"><code>setvbuf</code></a>: the interpreter was following Cosmopolitan’s choice of
buffering IO, so I added a couple of lines to use unbuffered input by default.</p><p>When I tried <code>python.com -S</code> on Windows, the interpreter would start, but then
every line I entered at the REPL would cause a syntax error. I thought this was
also related to <code>setvbuf</code>, but this was because Windows <a href="https://github.com/jart/cosmopolitan/issues/141#issuecomment-812918670"><code>cmd.exe</code> sends
CRLF</a> on pressing <code>Return</code>, and the interpreter expects only LF, so the CR
was read as incorrect syntax. It was straightforward to change the parser logic.</p><h2 id="adding-standard-library-modules">Adding standard library modules</h2><p>When the Makefile finishes building <code>python</code>, it immediately tries to call a
<code>setup.py</code> to build C extensions for the standard library. This was pretty
stupid: <code>setup.py</code> tries to build and link a bunch of shared objects to the
interpreter even though I’ve specified a static build (<code>--disable-shared</code>). I
found out it was doing this after I saw a successful build on the screen,
followed a deluge of (<code>unable to link</code>/<code>no dlopen</code>/<code>Rdynamic specified but also static</code>) errors.</p><p>There is a nice way to compile C extensions into Python statically: via
<code>Modules/Setup</code>. This file follows a simple syntax to specify extensions and
their requirements, so that you can compile extensions before <code>setup.py</code> is
called.</p><div><pre tabindex="0"><code data-lang="sh"><span><span>*static*
</span></span><span><span>
</span></span><span><span><span># &lt;name of extension&gt; &lt;source files in Modules folder&gt; &lt;includes&gt; &lt;links&gt; -DSOME_FLAG</span>
</span></span><span><span>math mathmodule.c _math.c <span># -lm</span>
</span></span><span><span>array arraymodule.c
</span></span></code></pre></div><p>Calling <code>make</code> after changing <code>Modules/Setup</code> rebuilds the Makefile with the
necessary recipes for the specified extensions. You can read about
<a href="https://github.com/ahgamut/cpython/blob/cosmo_py27/Modules/Setup"><code>Modules/Setup</code> here</a>. One nasty aspect of this is if the syntax
in <code>Modules/Setup</code> is wrong, the Makefile will be wrong, so you can’t run <code>make</code>
even after you’ve fixed the error.</p><p>I was able to compile a lot of modules into APE using <code>Modules/Setup</code>: basic
modules like <code>cPickle</code>, <code>zlib</code> etc., modules that required external libraries
like <code>_sqlite</code>, <code>_bz2</code>, <code>readline</code>, <code>_ctypes</code><sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> etc., and even
<strong>external packages</strong> that depend on simple C extensions, like
<a href="https://github.com/python-greenlet/greenlet/"><code>greenlet</code></a>. It all boils down to writing the correct recipe in
<code>Modules/Setup</code>, ensuring the necessary static libraries are available, and
checking that the glue code around the imports works correctly<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>.</p><p>The final annoyance with the stdlib python files was that I had to copy the
folder containing them alongside <code>python.com</code>, but this got solved because
Cosmopolitan allows the APE to be used as a valid ZIP file. I just zipped up
<code>Lib/</code> into the APE, <em>added <code>python.com</code> itself as an entry in <code>sys.path</code></em>, and
Python’s own <a href="https://docs.python.org/2.7/library/zipimport.html"><code>zipimport</code> package</a> handled the rest.</p><h2 id="using-pip-and-external-packages">Using <code>pip</code> and external packages</h2><p>After compiling most of the standard library packages, I still couldn’t get
<code>ensurepip</code> to work, because it relied on threads, and the standard <code>threading</code>
module in Python would just raise an <code>ImportError</code> if it could not find the
<code>_thread</code> C extension. The fix was present within the stdlib: there is a module
called <code>_dummy_thread</code>, which spoofs <code>_thread</code> so that <code>threading</code> doesn’t
complain<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>. After this, I was able to run <code>ensurepip</code> to install
<code>pip</code> and <code>setuptools</code> in <code>Lib/site-packages</code>.</p><p>However, running <code>python.com -m pip install</code> doesn’t work because the Python APE
doe not currently have SSL support. I tried providing <code>http://pypi.org/simple</code>
as the index URL but <code>pip</code> was adamant in not letting me get my way.</p><p>I didn’t want to figure out how to add SSL support to the APE (I expect it
should be possible<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup>), so I just cheated and downloaded the
packages manually. The arrangement to add packages works like this:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>mkdir -p Lib/site-packages
</span></span><span><span>
</span></span><span><span><span># specify python version to pip if necessary</span>
</span></span><span><span>/usr/bin/python2 -m pip download flask -t .
</span></span><span><span>
</span></span><span><span><span># wheels are just ZIPs, use unzip if pip complains</span>
</span></span><span><span>./python.com -m pip install flask*.whl -t ./Lib/site-packages
</span></span><span><span>
</span></span><span><span>zip -qr ./python.com ./Lib/site-packages/
</span></span><span><span>rm -rf ./*.whl ./Lib/site-packages/
</span></span><span><span>
</span></span><span><span>./python.com -m flask --version
</span></span></code></pre></div><p>Of course, you would have recompile the APE if you wanted to add any C
extensions.</p><h2 id="closing-notes">Closing Notes</h2><p>It is really convenient to have the same application work on
Linux/Windows/MacOS, but the techniques I have seen/used all have tradeoffs:
either for the developer in terms of design, testing, and safety/consistency, or
for the user in terms on application size and performance.</p><p>Cosmopolitan Libc does come with some tradeoffs as well (static compilation, C
codebases, no multithreading (<strong>Update 2022-07-27:</strong>, no multithreading <em>yet</em>,
the pthreads API takes a while to fill)), but I think it is amazing that I can
send a <code>python.com</code> executable of a few megabytes as a zip file to someone, have
them run it without worrying about the OS, and provide them a simple webapp with
a backend that works even without an internet connection.</p><p>This successful <code>python.com</code> experiment unlocks many interesting directions:</p><ul><li><p>Is it possible to tune the performance of the <code>python.com</code> APE? I don’t expect
it to get anywhere close to <a href="https://redbean.dev/"><code>redbean</code></a>, but some speed
improvements would be nice because Python web frameworks are established and
easy to use.</p></li><li><p>Is there room for a custom build system to produce a single-file
size-optimized <code>python.com</code> APE webapp? We saw that it is possible to add C
extensions, and even regular packages into the executable via <code>zip</code>. If there
is a dependency resolver that accounts for stdlib imports, which then produces
a <code>Modules/Setup</code> or some similar build script to compile extensions and add
only the necessary libraries, that would be awesome<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>. (<strong>2022-07-27:</strong>
now the Cosmopolitan monorepo builds <code>python.com</code> via a
<a href="https://github.com/jart/cosmopolitan/blob/master/third_party/python/python.mk">Makefile</a>,
checks import dependencies at link-time, runs the Python test suite, and adds
all files to the APE internal ZIP store ready-to-use).</p></li><li><p>Regarding python packages with C extensions, the build process for adding them
to the APE is rather unwieldy (<strong>2022-07-27</strong> adding C extensions to the APE
is much more elegant now because of the Cosmopolitan monorepo, see
<a href="https://github.com/ahgamut/cosmopolitan/tree/import-mod-test">this</a>) because
of all the manual changes involved. Is there a way to automatically patch the
imports, or better yet, compile Python C extensions as shared libraries with
Cosmopolitan?</p></li><li><p>I’ve managed to compile Lua, QuickJS, and now Python2.7 and
<a href="https://github.com/ahgamut/cpython/tree/cosmo_py36">Python3.6</a>. Are there web-friendly languages that would benefit
more from a Cosmopolitan build? Maybe PHP, or Ruby, or even Go if the details
work out? Remains to be seen.</p></li></ul><hr/></div></div></div>
  </body>
</html>
