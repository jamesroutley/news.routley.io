<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lakesare.brick.do/lean-coq-isabel-and-their-proof-trees-yjnd2O2RgxwV">Original</a>
    <h1>Lean, Coq and other proof assistants: Visualising proofs as trees</h1>
    
    <div id="readability-page-1" class="page"><div><p><i>This week we (me &amp; Anton Kovsharov) published Paperproof, a Gentzen-tree-like proof interface for Lean 4. In this post I&#39;ll review proof visualisations from other proof assistants, as many as I can find.</i></p><hr/><p>In this review we&#39;re considering proof visualisation tools that were created with actual mathematicians in mind - tools that are supposed to make formalising mathematics (and parsing existing mathematical proofs) in proof assistants easier. </p><p>It just so happens, that such tools always visualise tactics proofs as a tree (really we&#39;d be thrilled if you can think of any other shape that helps us grok the structure of the proof). So, in this review, I&#39;ll focus on interfaces that at least remind us of sequent-calculus-style trees.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/Sequent_calculus_proof_tree_example.png" alt="File:Sequent calculus proof tree example.png - Wikimedia Commons"/><figcaption><strong>Sequent calculus tree</strong> (aka Gentzen tree)</figcaption></figure><p>There exists one other sort of tools which are frequently called proof visualisers - programs that simply display a tactic state before and after each tactic application. Examples of such tools are Coq&#39;s <strong>Alectryon</strong>, Lean&#39;s <strong>LeanInk</strong> and Coq&#39;s <strong>Coq-psv</strong>. These are great for rendering proof assistant documentation &amp; theorems in mathy blog posts, but they don&#39;t offer any additional value in writing proofs or parsing the structure of existing proofs, so we&#39;re not considering these tools here.</p><figure><img src="https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png" srcset="https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_150 150w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_300 300w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_450 450w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_600 600w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_750 750w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_900 900w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_1050 1050w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_1200 1200w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_1350 1350w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/b32157b666669a45a30e506df8b11fc22487fd90e33e0374.png/w_1438 1438w" sizes="100vw" width="1438"/><figcaption><strong>Alectryon</strong> rendering a Coq proof</figcaption></figure><p>We are also not considering proof interfaces that are designed for learning logic and can&#39;t be used by real mathematicians working on formalizing mathematics, such as <strong>ProofWeb</strong> or <strong>Incredible Proof Machine</strong>.</p><figure><img src="https://camo.githubusercontent.com/81d793a8c22d22ce756d3e011078299bf31b41dde6da9ef9033b9ae3ed3ffbe5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4e696d6974613331312f696e6372656469626c652d736f6c7574696f6e406d61737465722f736f6c7574696f6e732f322e392e312e737667" alt="GitHub - Nimita311/incredible-solution: Solutions to the Incredible Proof  Machine http://incredible.pm/"/><figcaption><strong>Incredible Proof Machine</strong></figcaption></figure><h2>Lean</h2><h3><a href="https://github.com/Paper-Proof/paperproof">Paperproof</a> (by Evgenia Karunus &amp; Anton Kovsharov)</h3><figure><img src="https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png" srcset="https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_200 200w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_400 400w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_600 600w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_800 800w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_1000 1000w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_1200 1200w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_1400 1400w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_1600 1600w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_1800 1800w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/ec0aa2fb4caf0f5de830df9fb26c10e16bc2127a5d182cdd.png/w_1988 1988w" sizes="100vw" width="1988"/><figcaption><strong>Paperproof</strong></figcaption></figure><p>So, our tool. <strong>Paperproof</strong> is available as a VSCode extension, and can only be used with Lean 4. </p><p>Hypotheses are displayed as <mark>green nodes</mark>, goals are displayed as <mark>red nodes</mark>, tactics are displayed as transparent nodes with dashed borders. If you drag these nodes around you will see arrows, however we&#39;re not displaying them to clean up the interface.</p><p>We start from our goal <code><mark>s ∩ t = t ∩ s</mark></code>, write tactic <code>ext x</code>, which turns our goal into <code><mark>x ∈ s ∩ t ↔ x ∈ t ∩ s</mark></code>.</p><blockquote><p>Aside: the fact that goals nodes form a tree is a consequence of how Lean and other proof assistants handle goals. Goal nodes form a tree because expressions in programming languages form a tree, and writing tactics is nothing other than gradually assigning some expressions to these nodes.</p></blockquote><h2>Coq</h2><h3><a href="http://askra.de/software/prooftree ">ProofTree</a> (by Hendrik Tews)</h3><figure><img src="http://askra.de/software/prooftree/nth_error_split.jpeg" alt="proof tree example"/><figcaption><strong>ProofTree</strong></figcaption></figure><p><strong>ProofTree</strong> is the oldest tool on the list, it was first released in 2011. <strong>ProofTree</strong> can only be used with Coq and in ProofGeneral (that&#39;s emacs editor for Coq).</p><p>ProofGeneral&#39;s <strong>ProofTree</strong> is similar to <strong>Paperproof</strong> conceptually (just revert it upside down to see it!), except <strong>ProofTree</strong> shows ⊢ instead of goal types, and doesn&#39;t display hypotheses at all.</p><p>Displaying hypotheses and variable scopes is hard work, however displaying goal types should be straightforward, wonder why he decided against that.</p><h3><a href="https://github.com/hide-kawabata/traf">Traf</a> (by Hideyuki Kawabata)</h3><figure><img src="https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png" srcset="https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_150 150w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_300 300w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_450 450w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_600 600w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_750 750w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_900 900w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_1050 1050w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_1200 1200w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_1350 1350w, https://71022.cdn.cke-cs.com/RructTCFEHceQFc13ldy/images/f7d5b3c7a17fedf159f04a14cef83fd6224c179b558bf9d5.png/w_1460 1460w" sizes="100vw" width="1460"/><figcaption><strong>Traf</strong></figcaption></figure><p>Here we get to something! <strong>Traf</strong> is <strong>ProofTree</strong>&#39;s posterity, and it was developed as an extension of <strong>ProofTree</strong>.  Like <strong>ProofTree</strong>, it&#39;s Coq-only tool that can only be used via ProofGeneral. It&#39;s pretty similar to <strong>Paperproof</strong>, and should be worth trying if you&#39;re in Coq.</p><p><strong>Traf</strong> offers a veridical recreation of Gentzen trees, as Hideyuki puts it:</p><blockquote><p>Traf is different from ordinary proof viewers and proof translators in that it is designed to guide interactive theorem proving by using a full-edged proof assistant through a standard tactic-based interface. In other words, Traf is a helper tool for enhancing both the writability and readability of proofs. The proof tree shown in Traf&#39;s window looks like a readable Gentzen-style natural deduction proof. </p></blockquote><p>One way in which <strong>Paperproof</strong> took a route different from <strong>Traf</strong>&#39;s is the displayal of hypotheses - <strong>Traf</strong> only displays the hypothesis once the goal is closed (and duplicates reused hypotheses, just like in Gentzen trees!), and <strong>Paperproof</strong> treats hypotheses as separate trees - it shows their history, shows what hypothesis originated from what hypothesis, and in what scopes they were available throughout the proof.</p><h3><a href="https://github.com/Ptival/PeaCoq">PeaCoq</a> (by Valentin Robert)</h3><figure><img src="https://goto.ucsd.edu/~vrobert/coq-en-stock/images/peacoq-diff-too-smart.png"/><figcaption><strong>PeaCoq</strong></figcaption></figure><p><strong>PeaCoq </strong>is available as a locally hosted web app, and only works with Coq.</p><p><strong>PeaCoq</strong> superficially looks like a proof tree, however what you see as a &#34;tactic state [aka goal] forking into 2 tactic states [aka goals]&#34; is not that. <strong>PeaCoq</strong> shows the current proof state on the left, suggests multiple tactics, and shows what the results would be on the right.</p><p>What <strong>PeaCoq</strong> is most similar to is Lean&#39;s default infoview diffs (where the changed subexpressions in hypotheses/goals are highlighted).</p><h2><strong>Isabelle, Metamath, Agda</strong></h2><p>Nothing? I <a href="https://chat.openai.com/share/488a9575-d49c-43ca-85a8-668f9ec32977">couldn&#39;t find</a> anything resembling proof visualisations for these proof assistants. Send some my way if you know of any.</p><h2>Conclusion</h2><p>I fully expected this post to go on for quite some time, I&#39;ve only dealt with a single proof assistant other than Lean after all!</p></div></div>
  </body>
</html>
