<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Mythra/typeish">Original</a>
    <h1>Type-ish â€“ A runtime type checker for bash, in bash</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Type-ish is a runtime type checker for bash functions, implemented entirely in
bash. This way you can accept arguments, and be sure they conform to whatever
sort of shape you want them too. <em><strong>It is also a very cursed idea taken way too far,
and I do not apologize for it.</strong></em></p>
<p dir="auto"><em><strong>NOTE: as of this moment type-ish has only been tested on bashv4 everything
should be compatible with bashv3 (what OSX ships), but I haven&#39;t actually
tested it out yet.</strong></em></p>
<p dir="auto">In essence type-ish allows you to runtime type your functions with
type-signatures like:</p>
<div data-snippet-clipboard-copy-content="#!/usr/bin/env bash

set -euo pipefail
source &#34;typeish.sh&#34;

sig {always_fails.returns { number }}
always_fails() {
  echo &#34;hi&#34; # This will always fail cause it doesn&#39;t return a number!
}

sig { add_numbers.params { a: number, b: number }.returns{ number }}
add_numbers() {
  printf &#39;%s&#39; &#34;$((a + b))&#34;
}

sig_update_functions # Actually process the functions that have signatures!
                     # This is separate so you can avoid runtime overhead
                     # if you don&#39;t want to pay for it all the time!
add_numbers &#34;a&#34; &#34;2&#34; || echo &#34;Failed to add the letter! didn&#39;t pass the type check!&#34;
add_numbers &#34;1&#34; &#34;2&#34; &amp;&amp; echo &#34; Successfully was able to add numbers!&#34;
always_fails"><pre><span><span>#!</span>/usr/bin/env bash</span>

<span>set</span> -euo pipefail
<span>source</span> <span><span>&#34;</span>typeish.sh<span>&#34;</span></span>

sig {always_fails.returns { number }}
<span>always_fails</span>() {
  <span>echo</span> <span><span>&#34;</span>hi<span>&#34;</span></span> <span><span>#</span> This will always fail cause it doesn&#39;t return a number!</span>
}

sig { add_numbers.params { a: number, b: number }.returns{ number }}
<span>add_numbers</span>() {
  <span>printf</span> <span><span>&#39;</span>%s<span>&#39;</span></span> <span><span>&#34;</span><span><span>$((</span>a <span>+</span> b<span>))</span></span><span>&#34;</span></span>
}

sig_update_functions <span><span>#</span> Actually process the functions that have signatures!</span>
                     <span><span>#</span> This is separate so you can avoid runtime overhead</span>
                     <span><span>#</span> if you don&#39;t want to pay for it all the time!</span>
add_numbers <span><span>&#34;</span>a<span>&#34;</span></span> <span><span>&#34;</span>2<span>&#34;</span></span> <span>||</span> <span>echo</span> <span><span>&#34;</span>Failed to add the letter! didn&#39;t pass the type check!<span>&#34;</span></span>
add_numbers <span><span>&#34;</span>1<span>&#34;</span></span> <span><span>&#34;</span>2<span>&#34;</span></span> <span>&amp;&amp;</span> <span>echo</span> <span><span>&#34;</span> Successfully was able to add numbers!<span>&#34;</span></span>
always_fails</pre></div>
<p dir="auto">This will print the following for you:</p>
<div data-snippet-clipboard-copy-content="[error @ typeish.sh:sig_validate_type_for / {TIMESTAMP}] Argument: `a` is NaN, but was asked to be number/boolean.
Failed to add the letter! didn&#39;t pass the type check!
3 Successfully was able to add numbers!
[error @ typeish.sh:sig_validate_type_for / {TIMESTAMP}] Argument: `hi` is NaN, but was asked to be number/boolean.
[error @ typeish.sh:always_fails / {TIMESTAMP}] return type was not correct! [hi] does not match [number]"><pre><code>[error @ typeish.sh:sig_validate_type_for / {TIMESTAMP}] Argument: `a` is NaN, but was asked to be number/boolean.
Failed to add the letter! didn&#39;t pass the type check!
3 Successfully was able to add numbers!
[error @ typeish.sh:sig_validate_type_for / {TIMESTAMP}] Argument: `hi` is NaN, but was asked to be number/boolean.
[error @ typeish.sh:always_fails / {TIMESTAMP}] return type was not correct! [hi] does not match [number]
</code></pre></div>
<p dir="auto">To use it&#39;s as simple as:</p>
<ol dir="auto">
<li>Load in <code>typeish.sh</code>.</li>
<li>Define a series of signatures for your functions.</li>
<li>Define your functions.</li>
<li>Call <code>sig_update_functions</code> to tell type-ish to update the list of functions to type-check.</li>
<li>Run your code as normal!</li>
</ol>
<p dir="auto">That&#39;s not all though! There are lots of cool things below -- like define&#39;ing
your own types, generics, type generation, and making type-checking optional
so you don&#39;t always have to pay the perf overhead!</p>
<h2 dir="auto"><a id="user-content-sigs" aria-hidden="true" href="#sigs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Sig&#39;s</h2>
<p dir="auto">Signatures are the core part of type-ish, they allow defining the actual
parameter names/types+return types of any arbitrary function. They follow
the general format of:</p>
<ul dir="auto">
<li><code>sig {function_name_i_apply_too.params { param_name: param_type, other_param: param_type_two }.returns { a_type }}</code></li>
</ul>
<p dir="auto">A couple things to note here:</p>
<ol dir="auto">
<li>The function name determines what function this applies too, nothing else
does. Yes this means signatures are completely disjoint from the actual
functions, so yes you can stick the signature definitions behind an if
branch -- this is useful if wanting to avoid the performance overhead of
typeish in certain situations.</li>
<li><code>params {}</code>, and <code>returns {}</code> are optional, if you do not define them they
are both expected to return + accept <code>void</code> which is short for nothing.
(note: since STDOUT is where you return values, if you have a void return
type this means you can&#39;t print anything to STDOUT, you should print to
STDERR).</li>
<li>Parameters map to their order (e.g. <code>param_name</code> will be equivalent to
<code>$1</code>), and you can reference it either by its name, or position.</li>
<li>All types have to be known at the time <code>sig {}</code> is written, the builtin
types are:
<ul dir="auto">
<li><code>void</code>: the absence of a value.</li>
<li><code>string</code>: in bash everything is a string, so this is basically an any
type.</li>
<li><code>number</code>: any type of number (including decimals! and including
signs <code>-</code>, or <code>+</code>)</li>
<li><code>boolean</code>: a shortcut for returning a number (as numbers are booleans).</li>
<li><code>array[ty]</code>: an array which can hold any type (yes the inner array values
are validated!)</li>
</ul>
</li>
<li>The &#34;sig&#34; line is actually a valid bash function! Calling it with a whole
bunch of string arguments! Meaning <em><strong>you can actually generate eval calls
to sig where you actually fully generate the signature pragmatically</strong></em>!
Yes this is probably a bad idea, but WHY NOT.</li>
</ol>
<h2 dir="auto"><a id="user-content-custom-types" aria-hidden="true" href="#custom-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Types</h2>
<p dir="auto">Type-ish allows defining custom types. Which in reality is just a way of doing
checked casting from one type to another. These types can also be generic,
and have multiple types in the generic (like if you want a map type)!</p>
<p dir="auto">First let&#39;s start out with the simple case, a very simple type:</p>
<div data-snippet-clipboard-copy-content="sig_custom_type { forced_start.from { string }.produces { ForcedStartTy } }
forced_start() {
  case &#34;$1&#34; in
    &#34;[&#34;*)
      return 0
      ;;
    *)
      log:error &#34;String: \`$1\` does not start with &#39;[&#39;, not valid.&#34;
      return 1
      ;;
  esac
}"><pre>sig_custom_type { forced_start.from { string }.produces { ForcedStartTy } }
<span>forced_start</span>() {
  <span>case</span> <span><span>&#34;</span><span>$1</span><span>&#34;</span></span> <span>in</span>
    <span><span>&#34;</span>[<span>&#34;</span></span><span>*</span>)
      <span>return</span> 0
      ;;
    <span>*</span>)
      log:error <span><span>&#34;</span>String: <span>\`</span><span>$1</span><span>\`</span> does not start with &#39;[&#39;, not valid.<span>&#34;</span></span>
      <span>return</span> 1
      ;;
  <span>esac</span>
}</pre></div>
<p dir="auto">In this case we define a conversion from <code>string</code> -&gt; <code>ForcedStartTy</code>, this is
how you introduce a new type. We tell type-ish to call <code>forced_start</code> every time
it needs to check if a string is a valid <code>ForcedStartTy</code> it will be passed a
single parameter which is the value to check, this will return an error if the
type is not a valid cast, otherwise it will return 0, signaling this is okay.</p>
<p dir="auto">Sig Custom Type otherwise has the very similar behavior to sig, it just uses
<code>from</code>, and <code>produces</code> rather than <code>params</code>, and <code>returns</code>.</p>
<p dir="auto">A couple notes:</p>
<ol dir="auto">
<li>It is only possible to have one conversion from Type A -&gt; Type B. You cannot
register multiple conversions for the same type (call it something else)!.</li>
<li>While it is possible to have many types all convert into another type, this
gets expensive very very fast (as we have to check each conversion in the
order it was registered)! In general try to see if you can just use a
different type name (maybe even borrow that old golang egyptian brackets
trick(!) -- <em>yes this is a terrible idea, but just as terrible as the rest
of this</em>).</li>
</ol>
<h3 dir="auto"><a id="user-content-generics" aria-hidden="true" href="#generics"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Generic&#39;s</h3>
<p dir="auto">It is possible to register generic types in <code>sig_custom_type</code>, by doing so you
inherit a lot of responsibility, but it&#39;s worth it for generics, <em>probably</em>.
A generic is identified by having it&#39;s produces block be in the form of:
<code>.produces { Map_generic }</code>, in this case you will have a type called <code>Map</code>
that can be used as a generic.</p>
<p dir="auto">In this case your first argument will the value to typecheck, and the second
will be a generic type if any is present.</p>
<p dir="auto">Notes:</p>
<ol dir="auto">
<li>Type-ish does not guarantee that a generic type has to have defined what
type it&#39;s holding. If you need type parameters/a specific amount of them
it is on you to validate it.</li>
<li>You cannot nest generics in generics.</li>
<li>If you need to accept multiple concrete types such as a map which has a key,
and a value you need to use the <code>-</code> character: <code>Map[number-string]</code>.
<em>yes i realize this is a bad choice, but I didn&#39;t really have a better
character because many others are reserved internally.</em></li>
<li>You take on the responsibility of calling the validation for the inner type
you are holding. If you do not, you can introduce a type error, and it&#39;ll
be bad.</li>
</ol>
<p dir="auto">As an example implementation take a definition of map (which is just an array
with a special identifier at the beginning, and methods to interact with the
array):</p>
<div data-snippet-clipboard-copy-content="sig { does_start_with_map_id.params { map: string }.returns { void } }
does_start_with_map_id() {
  # &lt;snipped&gt;
}
sig { split.params { to_split: string, split_by: string }.returns { array[string] } }
split() {
  # &lt;snipped&gt;
}
sig { keys_map.params { map: string }.returns { array[string] } }
keys_map() {
  # &lt;snipped&gt;
}
sig { values_map.params { map: string }.returns { array[string] } }
values_map() {
  # &lt;snipped&gt;
}

sig_custom_type { map_ty.from { string }.produces { Map_generic } }
map_ty() {
  # Check map starts with __MAP_ID
  if ! does_start_with_map_id &#34;$1&#34;; then
    log:error &#34;Type isn&#39;t actually a valid map!&#34;
    return 1
  fi
  if [ &#34;x${2+x}&#34; == &#34;x&#34; ]; then
    # No generic types on this map exit early.
    log:warn &#34;Map called with no generic types -- which were expected.&#34;
    return 0
  fi
  local -r generic_types=($(split &#34;$2&#34; &#34;-&#34;))
  
  # Validate keys!
  if [ &#34;x${generic_types[0]}&#34; != &#34;x&#34; ]; then
    log:trace &#34;Validating map key type against type: ${generic_types[0]}&#34;
    local keys=($(keys_map &#34;$1&#34;))
    local key=
    for key in &#34;${keys[@]}&#34;; do
      if ! sig_validate_type_for &#34;${generic_types[0]}&#34; &#34;${key}&#34;; then
        log:error &#34;Key of map: \`${key}\` was not valid for type: ${generic_types[0]}&#34;
        return 1
      fi
    done
  fi
  # Validate values!
  if [ &#34;x${generic_types[1]}&#34; != &#34;x&#34; ]; then
    log:trace &#34;Validating map value type against type: ${generic_types[1]}&#34;
    local values=($(values_map &#34;$1&#34;))
    local value=
    for value in &#34;${values[@]}&#34;; do
      if ! sig_validate_type_for &#34;${generic_types[1]}&#34; &#34;${value}&#34;; then
        log:error &#34;Value of map: \`${value}\` was not valid for type: ${generic_types[1]}&#34;
        return 1
      fi
    done
  fi

  # We all good!
  return 0
}"><pre>sig { does_start_with_map_id.params { map: string }.returns { void } }
<span>does_start_with_map_id</span>() {
  <span><span>#</span> &lt;snipped&gt;</span>
}
sig { split.params { to_split: string, split_by: string }.returns { array[string] } }
<span>split</span>() {
  <span><span>#</span> &lt;snipped&gt;</span>
}
sig { keys_map.params { map: string }.returns { array[string] } }
<span>keys_map</span>() {
  <span><span>#</span> &lt;snipped&gt;</span>
}
sig { values_map.params { map: string }.returns { array[string] } }
<span>values_map</span>() {
  <span><span>#</span> &lt;snipped&gt;</span>
}

sig_custom_type { map_ty.from { string }.produces { Map_generic } }
<span>map_ty</span>() {
  <span><span>#</span> Check map starts with __MAP_ID</span>
  <span>if</span> <span>!</span> does_start_with_map_id <span><span>&#34;</span><span>$1</span><span>&#34;</span></span><span>;</span> <span>then</span>
    log:error <span><span>&#34;</span>Type isn&#39;t actually a valid map!<span>&#34;</span></span>
    <span>return</span> 1
  <span>fi</span>
  <span>if</span> [ <span><span>&#34;</span>x<span>${2+x}</span><span>&#34;</span></span> <span>==</span> <span><span>&#34;</span>x<span>&#34;</span></span> ]<span>;</span> <span>then</span>
    <span><span>#</span> No generic types on this map exit early.</span>
    log:warn <span><span>&#34;</span>Map called with no generic types -- which were expected.<span>&#34;</span></span>
    <span>return</span> 0
  <span>fi</span>
  <span>local</span> -r generic_types=(<span><span>$(</span>split <span><span>&#34;</span><span>$2</span><span>&#34;</span></span> <span><span>&#34;</span>-<span>&#34;</span></span><span>)</span></span>)
  
  <span><span>#</span> Validate keys!</span>
  <span>if</span> [ <span><span>&#34;</span>x<span>${generic_types[0]}</span><span>&#34;</span></span> <span>!=</span> <span><span>&#34;</span>x<span>&#34;</span></span> ]<span>;</span> <span>then</span>
    log:trace <span><span>&#34;</span>Validating map key type against type: <span>${generic_types[0]}</span><span>&#34;</span></span>
    <span>local</span> keys=(<span><span>$(</span>keys_map <span><span>&#34;</span><span>$1</span><span>&#34;</span></span><span>)</span></span>)
    <span>local</span> key=
    <span>for</span> <span>key</span> <span>in</span> <span><span>&#34;</span><span>${keys[@]}</span><span>&#34;</span></span><span>;</span> <span>do</span>
      <span>if</span> <span>!</span> sig_validate_type_for <span><span>&#34;</span><span>${generic_types[0]}</span><span>&#34;</span></span> <span><span>&#34;</span><span>${key}</span><span>&#34;</span></span><span>;</span> <span>then</span>
        log:error <span><span>&#34;</span>Key of map: <span>\`</span><span>${key}</span><span>\`</span> was not valid for type: <span>${generic_types[0]}</span><span>&#34;</span></span>
        <span>return</span> 1
      <span>fi</span>
    <span>done</span>
  <span>fi</span>
  <span><span>#</span> Validate values!</span>
  <span>if</span> [ <span><span>&#34;</span>x<span>${generic_types[1]}</span><span>&#34;</span></span> <span>!=</span> <span><span>&#34;</span>x<span>&#34;</span></span> ]<span>;</span> <span>then</span>
    log:trace <span><span>&#34;</span>Validating map value type against type: <span>${generic_types[1]}</span><span>&#34;</span></span>
    <span>local</span> values=(<span><span>$(</span>values_map <span><span>&#34;</span><span>$1</span><span>&#34;</span></span><span>)</span></span>)
    <span>local</span> value=
    <span>for</span> <span>value</span> <span>in</span> <span><span>&#34;</span><span>${values[@]}</span><span>&#34;</span></span><span>;</span> <span>do</span>
      <span>if</span> <span>!</span> sig_validate_type_for <span><span>&#34;</span><span>${generic_types[1]}</span><span>&#34;</span></span> <span><span>&#34;</span><span>${value}</span><span>&#34;</span></span><span>;</span> <span>then</span>
        log:error <span><span>&#34;</span>Value of map: <span>\`</span><span>${value}</span><span>\`</span> was not valid for type: <span>${generic_types[1]}</span><span>&#34;</span></span>
        <span>return</span> 1
      <span>fi</span>
    <span>done</span>
  <span>fi</span>

  <span><span>#</span> We all good!</span>
  <span>return</span> 0
}</pre></div>
<p dir="auto">In this case the <code>log:${level}</code> functions, and <code>sig_validate_type_for</code> are
provided by type-ish. The rest the user wrote to validate a map.</p>
<h2 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">First off, type-ish has prettttty high overhead. There&#39;s just a lot we&#39;re
doing, and that comes at a huge price. In order to make this cost easier
to digest though we&#39;ve made it so all parts of type-ish are opt-in.</p>
<p dir="auto">First off the &#34;biggest hammer&#34; not paying the cost for sig parsing +
type-checking:</p>
<div data-snippet-clipboard-copy-content="#!/usr/bin/env bash

set -e

add_numbers() {
  local -r first_num=$1
  local -r second_num=$2
  printf &#39;%d&#39; &#34;$(( first_num + second_num ))&#34;
}

if [ &#34;x$ENABLE_TYPEISH&#34; != &#34;x&#34; ]; then
  source &#34;path/to/typeish.sh&#34;
  sig { add_numbers.params { num_one: number, num_two: number }.returns { number } }
  sig_update_functions
fi

add_numbers &#34;1&#34; &#34;2&#34;"><pre><span><span>#!</span>/usr/bin/env bash</span>

<span>set</span> -e

<span>add_numbers</span>() {
  <span>local</span> -r first_num=<span>$1</span>
  <span>local</span> -r second_num=<span>$2</span>
  <span>printf</span> <span><span>&#39;</span>%d<span>&#39;</span></span> <span><span>&#34;</span><span><span>$((</span> first_num <span>+</span> second_num <span>))</span></span><span>&#34;</span></span>
}

<span>if</span> [ <span><span>&#34;</span>x<span>$ENABLE_TYPEISH</span><span>&#34;</span></span> <span>!=</span> <span><span>&#34;</span>x<span>&#34;</span></span> ]<span>;</span> <span>then</span>
  <span>source</span> <span><span>&#34;</span>path/to/typeish.sh<span>&#34;</span></span>
  sig { add_numbers.params { num_one: number, num_two: number }.returns { number } }
  sig_update_functions
<span>fi</span>

add_numbers <span><span>&#34;</span>1<span>&#34;</span></span> <span><span>&#34;</span>2<span>&#34;</span></span></pre></div>
<p dir="auto">In this case type-ish will not be loaded, parsed, or impact loading in
anyway. Note the use of <code>$1</code>/<code>$2</code> instead of the names provided by type-ish,
this allows for compatibility when type-ish isn&#39;t loaded, and hasn&#39;t set
those variable names. <em>this can also be used as a way to feature detect, and
do something if type-ish is loaded vs not</em>.</p>
<p dir="auto">There is a second option which is to still parse <code>sig</code> lines so you can ensure
they&#39;re not typo&#39;d but not impact the actual function timings themselves (you
will only pay a small load cost to parse the signatures), this also is a bit
cleaner to write:</p>
<div data-snippet-clipboard-copy-content="#!/usr/bin/env bash

set -e

source &#34;path/to/typeish.sh&#34;

sig { add_numbers.params { num_one: number, num_two: number }.returns { number } }
add_numbers() {
  local -r first_num=$1
  local -r second_num=$2
  printf &#39;%d&#39; &#34;$(( first_num + second_num ))&#34;
}

if [ &#34;x$ENABLE_TYPEISH&#34; != &#34;x&#34; ]; then
  sig_update_functions
fi

add_numbers &#34;1&#34; &#34;2&#34;"><pre><span><span>#!</span>/usr/bin/env bash</span>

<span>set</span> -e

<span>source</span> <span><span>&#34;</span>path/to/typeish.sh<span>&#34;</span></span>

sig { add_numbers.params { num_one: number, num_two: number }.returns { number } }
<span>add_numbers</span>() {
  <span>local</span> -r first_num=<span>$1</span>
  <span>local</span> -r second_num=<span>$2</span>
  <span>printf</span> <span><span>&#39;</span>%d<span>&#39;</span></span> <span><span>&#34;</span><span><span>$((</span> first_num <span>+</span> second_num <span>))</span></span><span>&#34;</span></span>
}

<span>if</span> [ <span><span>&#34;</span>x<span>$ENABLE_TYPEISH</span><span>&#34;</span></span> <span>!=</span> <span><span>&#34;</span>x<span>&#34;</span></span> ]<span>;</span> <span>then</span>
  sig_update_functions
<span>fi</span>

add_numbers <span><span>&#34;</span>1<span>&#34;</span></span> <span><span>&#34;</span>2<span>&#34;</span></span></pre></div>
<p dir="auto">In this case we load type-ish, and let it parse the <code>sig</code> to validate it&#39;s
well formed, and also look nice. But we never call <code>sig_update_functions</code> so
type-ish unless asked too, which means we never actually start doing the
type-checking. As a result we still have to use positional arguments, since
type-ish may not be actually doing something on our function.</p>
<p dir="auto">Overall these two knobs should help you keep the performance of type-ish in
check.</p>
<h2 dir="auto"><a id="user-content-i-hate-this" aria-hidden="true" href="#i-hate-this"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>I Hate This</h2>
<p dir="auto">The feeling is mutual.</p>
<h2 dir="auto"><a id="user-content-why" aria-hidden="true" href="#why"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why?</h2>
<p dir="auto">:)</p>
</article>
          </div></div>
  </body>
</html>
