<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cs.utexas.edu/~bornholt/post/memory-models.html">Original</a>
    <h1>Memory Consistency Models: A Tutorial</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
        <h2>Memory Consistency Models: A Tutorial</h2>
<h3>17 February 2016</h3>


<blockquote><p>The cause of, and solution to, all your multicore performance problems.</p>
</blockquote>


<p>There are, of course, 
<a href="http://martinfowler.com/bliki/TwoHardThings.html">only two hard things in computer science</a>: 
cache invalidation, naming things, and off-by-one errors.
But there is another hard problem 
lurking amongst the tall weeds of computer science:
<em>seeing things in order</em>.
Whether it be <a href="https://en.wikipedia.org/wiki/Bubble_sort">sorting</a>,
<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">un-sorting</a>,
or <a href="https://twitter.com/mathiasverraes/status/632260618599403520">tweeting</a>,
seeing things in order is a challenge for the ages.</p>

<p>One common ordering challenge is
<em>memory consistency</em>,
which is the problem of defining how parallel threads
can observe their shared memory state.
There are many resources on memory consistency,
but most are either <a href="http://15418.courses.cs.cmu.edu/spring2015/lecture/consistency">slides</a>
(like <a href="http://courses.cs.washington.edu/courses/cse451/15au/notes/l17-mcm-slides.pdf">mine</a>!)
or <a href="http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016">dense tomes</a>.
My goal is to produce a primer,
and motivate why memory consistency is an issue for multicore systems.
For the details, you should certainly consult these other excellent sources.</p>

<h2 id="making-threads-agree">Making threads agree</h2>

<p>Consistency models deal with 
how multiple threads (or workers, or nodes, or replicas, etc.)
see the world.
Consider this simple program, 
running two threads,
and where <code>A</code> and <code>B</code> are initially both <code>0</code>:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb.png" alt="two threads running in parallel" width="45%"/></p>

<p>To understand what this program can output,
we should think about the order in which its events can happen.
Intuitively, there are two obvious orders in which this program could run:</p>

<ul>
  <li>(1) → (2) → (3) → (4): The first thread runs both its events before the second thread, and so the program prints <code>01</code>.</li>
  <li>(3) → (4) → (1) → (2): The second thread runs both its events before the first thread. The program still prints <code>01</code>.</li>
</ul>

<p>There are also some less obvious orders, where the instructions are interleaved with each other:</p>

<ul>
  <li>(1) → (3) → (2) → (4): The first instruction in each thread runs before the second instruction in either thread, printing <code>11</code>.</li>
  <li>(1) → (3) → (4) → (2): The first instruction from the first thread runs, then both instructions from the second thread, then the second instruction from the first thread. The program still prints <code>11</code>.</li>
  <li>and a few others that have the same effect.</li>
</ul>

<h3 id="things-that-shouldnt-happen">Things that shouldn’t happen</h3>

<p>Intuitively, it shouldn’t be possible for this program to print <code>00</code>. For line (2) to print <code>0</code>, we have to print <code>B</code> before line (3) writes a <code>1</code> to it. We can represent this graphically with an edge:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb1.png" alt="two threads running in parallel" width="45%"/></p>

<p>An edge from operation <code>x</code> to operation <code>y</code> says that <code>x</code> must <em>happen before</em> <code>y</code> to get the behavior we’re interested in. Similarly, for line (4) to print <code>0</code>, that print must happen before line (1) writes a <code>1</code> to <code>A</code>, so let’s add that to the graph:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb2.png" alt="two threads running in parallel" width="45%"/></p>

<p>And finally, of course, each thread’s events should happen in order—(1) before (2), and (3) before (4)—because that’s what we expect from an imperative program. So let’s add those edges too:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb3.png" alt="two threads running in parallel" width="45%"/></p>

<p>But now we have a problem. If we start at (1), and follow the edges—to (2), then (3), then (4), then… (1) again! Remember that the edges are saying which events must happen before other events. So if we start at (1), and end up back at (1) again, the graph is saying that (1) must <em>happen before itself</em>! Barring a very concerning advance in physics, this is unlikely to be possible.</p>

<p>Since this execution would require time-warping, we can conclude that this program can’t print <code>00</code>. Think of it as a <a href="https://en.wikipedia.org/wiki/Proof_by_contradiction">proof by contradiction</a>: suppose this program <em>could</em> print <code>00</code>. Then all the ordering rules we just showed must hold. But those rules lead to a contradiction (event (1) happening before itself). So the assumption is false.</p>

<h3 id="sequential-consistency-an-intuitive-model-of-parallelism">Sequential consistency: an intuitive model of parallelism</h3>

<p>Architects and programming language designers believe the rules we just explored to be <em>intuitive</em> to programmers. The idea is that multiple threads running in parallel are manipulating a single main memory, and so everything must happen in order. There’s no notion that two events can occur “at the same time”, because they are all accessing a single main memory.</p>

<p>Note that this rule says nothing about <em>what</em> order the events happen in—just that they happen in <em>some</em> order. The other part of this intuitive model is that events happen in <em>program order</em>: the events in a single thread happen in the order in which they were written. This is what programmers expect: all sorts of bad things would start happening if my programs were allowed to launch their missiles before checking that the key was turned.</p>

<p>Together, these two rules—a single main memory, and program order—define <em>sequential consistency</em>. <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/multi.pdf">Defining sequential consistency</a> is one of the many achievements that earned <a href="http://www.lamport.org/">Leslie Lamport</a> the <a href="http://amturing.acm.org/">Turing award</a> in 2013.<sup id="fnref:lamport" role="doc-noteref"><a href="#fn:lamport" rel="footnote">1</a></sup></p>

<p>Sequential consistency is our first example of a <em>memory consistency model</em>. A memory consistency model (which we often just call a “memory model”) defines the allowed orderings of multiple threads on a multiprocessor. For example, on the program above, sequential consistency <em>forbids</em> any ordering that results in printing <code>00</code>, but <em>allows</em> some orderings that print <code>01</code> and <code>11</code>.</p>

<p>A memory consistency model is a <em>contract</em> between the hardware and software. The hardware promises to only reorder operations in ways allowed by the model, and in return, the software acknowledges that all such reorderings are possible and that it needs to account for them.</p>

<h2 id="the-problem-with-sequential-consistency">The problem with sequential consistency</h2>

<p>One nice way to think about sequential consistency is as a switch. At each time step, the switch selects a thread to run, and runs its next event completely. This model preserves the rules of sequential consistency: events are accessing a single main memory, and so happen in order; and by always running the <em>next</em> event from a selected thread, each thread’s events happen in program order.</p>

<p>The problem with this model is that it’s <em>terribly, disastrously slow</em>. We can only run a single instruction at a time, so we’ve lost most of the benefit of having multiple threads run in parallel. Worse, we have to wait for each instruction to finish before we can start the next one—no more instructions can run until the current instruction’s effects become <em>visible</em> to every other thread.</p>

<h3 id="coherence">Coherence</h3>

<p>Sometimes, this requirement to wait makes sense. Consider the case where two threads both want to write to a variable <code>A</code> that another thread wants to read:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/coherence.png" alt="coherence" width="70%"/></p>

<p>If we give up on the idea of a single main memory, to allow (1) and (2) to run in parallel, it’s suddenly unclear which value of <code>A</code> event (3) should read. The single main memory guarantees that there will always be a “winner”: a single last write to each variable. Without this guarantee, after both (1) and (2) have happened, (3) could see either <code>1</code> or <code>2</code>, which is confusing.</p>

<p>We call this guarantee <em>coherence</em>, and it says that all writes <em>to the same location</em> are seen in the same order by every thread. It doesn’t prescribe the actual order (either (1) or (2) could happen first), but does require that everyone sees the same “winner”.</p>

<h2 id="relaxed-memory-models">Relaxed memory models</h2>

<p>Outside of coherence, a single main memory is often unnecessary. Consider this example again:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb.png" alt="two threads running in parallel" width="45%"/></p>

<p>There’s no reason why performing event (2) (a read from <code>B</code>) needs to wait until event (1) (a write to <code>A</code>) completes. They don’t interfere with each other at all, and so should be allowed to run in parallel. Event (1) is particularly slow because it’s a write. This means that with a single view of memory, we can’t run (2) until (1) has become visible to every other thread. On a modern CPU, that’s a very expensive operation due to the cache hierarchy:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb-cores.png" alt="two threads running in parallel" width="45%"/></p>

<p>The only shared memory between the two cores is all the way back at the L3 cache, which often takes upwards of 90 cycles to access.</p>

<h3 id="total-store-ordering-tso">Total store ordering (TSO)</h3>

<p>Rather than waiting for the write (1) to become visible, we could instead place it into a <em>store buffer</em>:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb-wb.png" alt="two threads running in parallel" width="45%"/></p>

<p>Then (2) could start immediately after putting (1) into the store buffer, rather than waiting for it to reach the L3 cache. Since the store buffer is on-core, it’s very fast to access. At some time in the future, the cache hierarchy will pull the write from the store buffer and propagate it through the caches so that it becomes visible to other threads. The store buffer allows us to hide the write latency that would usually be required to make write (1) visible to all the other threads.</p>

<p>Store buffering is nice because it preserves single-threaded behavior. For example, consider this simple single-threaded program:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb-local.png" alt="two threads running in parallel" width="45%"/></p>

<p>The read in (2) needs to see the value written by (1) for this program to preserve the expected single-threaded behavior. Write (1) has not yet gone to memory—it’s sitting in core 1’s store buffer—so if read (2) just looks to memory, it’s going to get an old value. But because it’s running on the same CPU, the read can instead just inspect the store buffer directly, see that it contains a write to the location it’s reading, and use that value instead. So even with a store buffer, this program correctly prints <code>1</code>.</p>

<p>A popular memory model that allows store buffering is called <em>total store ordering</em> (TSO). TSO mostly preserves the same guarantees as SC, except that it allows the use of store buffers. These buffers hide write latency, making execution <a href="https://courses.engr.illinois.edu/cs533/reading_list/2b.pdf">significantly faster</a>.</p>

<h4 id="the-catch">The catch</h4>

<p>A store buffer sounds like a great performance optimization, but there’s a catch: TSO allows behaviors that SC does not. In other words, programs running on TSO hardware can exhibit behavior that programmers would find surprising.</p>

<p>Let’s look at the same first example from above, but this time running on a machine with store buffers. First, we execute (1) and then (3), which both place their data into the store buffer rather than sending it back to main memory:</p>

<p><img src="https://www.cs.utexas.edu/~bornholt/img/post/ordering/wb-tso0.png" alt="two threads running in parallel" width="45%"/></p>

<p>Next we execute (2) on core 1, which is going to read the value of <code>B</code>. It first inspects its local store buffer, but there’s no value of <code>B</code> there, so it reads <code>B</code> from memory and gets the value <code>0</code>, which it prints. Finally, we execute (4) on core 2, which is going to read the value of <code>A</code>. There’s no value of <code>A</code> in core 2’s store buffer, so it reads from memory and gets the value <code>0</code>, which it prints. At some indeterminate point in the future, the cache hierarchy empties both store buffers and propagates the changes to memory.</p>

<p>Under TSO, then, this program can print <code>00</code>. This is a behavior that we showed above to be explicitly ruled out by SC! So store buffers cause behaviors that programmers don’t expect.</p>

<p>Is there any architecture willing to adopt an optimization that runs against programmer intuition? Yes! It turns out that practically <em>every</em> modern architecture includes a store buffer, and so has a memory model at least as weak as TSO.</p>

<p>In particular, the venerable x86 architecture specifies a memory model that is very close to TSO. Both Intel (the originator of x86) and AMD (the originator of x86-64) specify their memory model with example <em>litmus tests</em>, similar to the programs above, that describe the observable outcomes of small tests. Unfortunately, specifying the behavior of a complex system with a handful of examples leaves room for ambiguity. Researchers at Cambridge have poured significant effort into <a href="https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf">formalizing x86-TSO</a> to make clear the intended behaviors of x86’s TSO implementation (and in particular, where it differs from this notion of store buffering).</p>

<h3 id="getting-weaker">Getting weaker</h3>

<p>Even though x86 gives up on sequential consistency, it’s among the most well-behaved architectures in terms of the crazy behaviors it allows. Most other architectures implement even weaker memory models, meaning they allow even more unintuitive behaviors. There is an entire spectrum of such models—the <a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a> architecture allows programmer to <em>choose</em> between three different models at run time.</p>

<p>One such architecture worth calling out is <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>, which among other things, probably powers your smartphone. The ARM memory model is notoriously underspecified, but is essentially a form of <em>weak ordering</em>, which provides very few guarantees. Weak ordering allows almost any operation to be reordered, which enables a variety of hardware optimizations but is also a nightmare to program at the lowest levels.</p>

<h3 id="escaping-through-barriers">Escaping through barriers</h3>

<p>Luckily, all modern architectures include synchronization operations to bring their relaxed memory models under control when necessary. The most common such operation is a <em>barrier</em> (or <em>fence</em>). A barrier instruction forces all memory operations before it to complete before any memory operation after it can begin. That is, a barrier instruction effectively reinstates sequential consistency at a particular point in program execution.</p>

<p>Of course, this is exactly the behavior we were trying to avoid by introducing store buffers and other optimizations. Barriers are an escape hatch to be used sparingly: they can cost hundreds of cycles. They are also extremely subtle to use correctly, especially when combined with ambiguous memory model definitions. There are some more usable primitives, such as <a href="https://en.wikipedia.org/wiki/Compare-and-swap">atomic compare-and-swap</a>, but using low-level synchronization directly should really be avoided. A real synchronization library will spare you worlds of pain.</p>

<h2 id="languages-need-memory-models-too">Languages need memory models too</h2>

<p>It’s not only hardware that reorders memory operations—compilers do it all the time. Consider this program:</p>

<div><div><pre><code>X = 0
for i in range(100):
    X = 1
    print X
</code></pre></div></div>

<p>This program always prints a string of 100 <code>1</code>s. Of course, the write to <code>X</code> inside the loop is redundant, because no other code changes the value of <code>X</code>. A standard <a href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion">loop-invariant code motion</a> compiler pass will move the write outside the loop to avoid repeating it, and <a href="https://en.wikipedia.org/wiki/Dead_store">dead store elimination</a> will then remove <code>X = 0</code>, leaving:</p>

<div><div><pre><code>X = 1
for i in range(100):
    print X
</code></pre></div></div>

<p>These two programs are totally equivalent, in that they will both produce the same output.<sup id="fnref:compiler" role="doc-noteref"><a href="#fn:compiler" rel="footnote">2</a></sup></p>

<p>But now suppose there’s another thread running in parallel with our program, and it performs a single write to <code>X</code>:</p>



<p>With these two threads running in parallel, the first program’s behavior changes:
now, it can print strings like <code>11101111...</code>, so long as there’s only a single
zero (because it will reset <code>X=1</code> on the next iteration).
The second program’s behavior also changes:
it can now print strings like <code>11100000...</code>,
where once it starts printing zeroes it never goes back to ones.</p>

<p>But these two changes behaviors are not common to the two programs:
the first program can never print <code>11100000...</code>,
nor can the second program ever print <code>11101111...</code>.
This means that in the presence of parallelism,
the compiler optimization no longer produces an equivalent program!</p>

<p>What this example is suggesting is that there’s also an idea of memory consistency at the program level.
The compiler optimization here is effectively a reordering: it’s rearranging (and removing some) memory accesses in ways that may or may not be visible to programmers.
So to preserve intuitive behavior, programming languages need memory models of their own, to provide a contract to programmers about how their memory operations will be reordered.
This idea is becoming more common in the language design community. For example, the latest versions of <a href="https://cseweb.ucsd.edu/classes/fa13/cse160-a/Lectures/Lec07.pdf">C++</a> and <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java</a> have rigorously-defined memory models governing their operations.</p>

<h2 id="computers-are-broken">Computers are broken!</h2>

<p>All this reordering seems crazy insane, and there’s no way a human can keep it all straight.
On the other hand, if you reflect on your programming experience, memory consistency is probably not an issue you’ve run into often, if at all (unless you’re a low-level kernel hacker).
How do I reconcile these two extremes?</p>

<p>The trick is that every example I’ve mentioned here has involved a <em>data race</em>.
A data race is two accesses to the same memory location, of which at least one is a write operation,
and with no ordering induced by synchronization.
If there are no data races, then the reordering behaviors don’t matter,
because all unintuitive reorderings will be blocked by synchronization.
Note that this doesn’t mean race-free programs are <em>deterministic</em>: different threads can win the races on each execution.</p>

<p>In fact, languages such as C++ and Java offer a guarantee known as <em>sequential consistency for data-race-free programs</em> (or the buzzwordy version, “SC for DRF”).
This guarantee says that if your program has no data races, the compiler will insert all the necessary fences to preserve the appearance of sequential consistency.
If your program <em>does</em> have data races, however, all bets are off, and the compiler is free to do whatever it likes.
The intuition is that programs with data races are quite likely to be buggy, and there’s no need to provide strong guarantees for such buggy programs. If a program has deliberate data races, the programmer likely knows what they’re doing anyway, and so can be responsible for memory ordering issues themselves.</p>

<h2 id="use-a-synchronization-library">Use a synchronization library</h2>

<p>Now that you’ve seen all this mess, the most important lesson is that you should use a synchronization library. It will take care of ugly reordering issues for you. Operating systems are also pretty heavily optimized to have only the synchronization necessary on a particular platform. But now you know what’s going on under the hood when these libraries and kernels deal with subtle synchronization issues.</p>

<p>If, for some reason, you want to know more about the various abominable memory models computer architecture has inflicted on the world, the Morgan &amp; Claypool synthesis lectures on computer architecture have <a href="http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016">a nice entry</a> on memory consistency and coherence.</p>





    </div></div>
  </body>
</html>
