<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://renderingpixels.com/2022/07/getting-started-with-directx-raytracing/">Original</a>
    <h1>Getting Started with DirectX Raytracing</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>In <a href="https://renderingpixels.com/2022/01/ramblings-on-games-rendering-and-real-time-raytracing/" title="my previous post">my previous post</a> I talked about what raytracing is and what it does. This one is more of a tutorial/guide on getting started with DirectX Raytracing.</p><p>This post is based off the documentation I wrote during my internship last year at <a href="https://digitalartsandentertainment.be/page/133/Research">DAE Research</a>, slightly edited in places where some things were missing or needed some clarification. My aim for this is to be the one-stop place for anyone who’s starting with DirectX Raytracing. It is basically what I would’ve personally wanted to have when I was getting started.</p><p>It might not be <em>all</em> the source code that you’ll need, since I was working with <a href="https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/MiniEngine">Microsoft’s MiniEngine</a> during my internship, but it should still provide all the necessary details.
All the source code of my internship project is available on <a href="https://github.com/SeppahBaws/DirectX-Raytracing/tree/main/MiniEngine/RayBinning">GitHub</a>, if you’re curious. The main code is in the <code>RaytracingTest.cpp</code> file.</p><h2 id="dxr-enabled-device">DXR-enabled device<a href="#dxr-enabled-device" arialabel="Anchor">⌗</a></h2><p>The only additional step we have to do for MiniEngine DXR is to retrieve an <code>ID3D12Device5*</code> from the device. This is the earliest device version that supports ray-tracing. There currently are newer versions available, but this version should be all we need for this post.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>ComPtr<span>&lt;</span>ID3D12Device5<span>&gt;</span> pRTDevice;
</span></span><span><span>HRESULT hr <span>=</span> g_Device<span>-&gt;</span>QueryInterface(IID_PPV_ARGS(<span>&amp;</span>pRTDevice));
</span></span><span><span><span>// If not successful, we can assume DXR is not supported.
</span></span></span></code></pre></div><p>Because this project is rather limited in scope, the only functionality we are going to need from the <code>ID3D12Device5</code> are the <a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createstateobject"><code>CreateStateObject()</code></a> and the <a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-getraytracingaccelerationstructureprebuildinfo"><code>GetRaytracingAccelerationStructurePrebuildInfo()</code></a> functions. The full <a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12device5">Microsoft DirectX 12 documentation</a> shows what other functionality the <code>ID3D12Device5</code> interface provides.</p><p>A root signature defines what “root parameters” a shader has, what their type is, and in which register they are bound. In DirectX Raytracing we have two types of root signatures: global root signatures and local root signatures.</p><p>Creating a root signature with the <code>RootSignature</code> class in the MiniEngine is really simple:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// SamplerDesc wraps a D3D12_SAMPLER_DESC and provides default values
</span></span></span><span><span><span></span>SamplerDesc sampler;
</span></span><span><span>
</span></span><span><span>RootSignature exampleSignature{};
</span></span><span><span><span>// The Reset function takes in two parameters:
</span></span></span><span><span><span>// UINT NumRootParams : the amount of root parameters we want to pass.
</span></span></span><span><span><span>// UINT NumStaticSamplers : the amout of static samplers we want to pass.
</span></span></span><span><span><span></span>exampleSignature.Reset(<span>2</span>, <span>1</span>);
</span></span><span><span>exampleSignature.InitStaticSampler(<span>0</span>, sampler); <span>// Pass in the sampler on register 0
</span></span></span><span><span><span>// We initialize the first entry as a buffer SRV, bound to register 0.
</span></span></span><span><span><span></span>exampleSignature[<span>0</span>].InitAsBufferSRV(<span>0</span>);
</span></span><span><span><span>// The 2nd entry gets initialized as a descriptor range.
</span></span></span><span><span><span>// First we pass in the descriptor range type,
</span></span></span><span><span><span>// then the register at which the descriptor range starts,
</span></span></span><span><span><span>// and lastly the amount of descriptors that are in this range.
</span></span></span><span><span><span></span>exampleSignature[<span>1</span>].InitAsDescriptorRange(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, <span>1</span>, <span>3</span>);
</span></span><span><span><span>// When we added all the entries, we can create the root signature.
</span></span></span><span><span><span>// The string we pass in is the debug name that will show up in graphics debuggers
</span></span></span><span><span><span></span>exampleSignature.Finalize(<span>L</span><span>&#34;My Example Root Signature&#34;</span>);
</span></span></code></pre></div><h2 id="global-root-signature">Global Root Signature<a href="#global-root-signature" arialabel="Anchor">⌗</a></h2><p>A global root signature defines root parameters that are accessible across all DXR shaders in that pipeline. Every shader in the pipeline will have access to the root parameters defined in the global root signature.</p><p>Good candidates for parameters in the global root signature are: the raytracing output buffer, acceleration structure, mesh info…</p><h2 id="local-root-signature">Local Root Signature<a href="#local-root-signature" arialabel="Anchor">⌗</a></h2><p>Unlike a global root signature, a local root signature is only visible to one shader, specified upon creating the pipeline. Arguments are provided by the shader table.</p><p>Some logical use cases: bind an environment texture to the miss shader, bind the mesh texture to the hit shader…</p><h2 id="local-vs-global-root-signatures">Local vs global root signatures<a href="#local-vs-global-root-signatures" arialabel="Anchor">⌗</a></h2><p>In general, you want to use global root signatures for data that has to be available to all shaders, and local root signatures for data that is specific to one shader step. One important thing to note when using local and global root signatures together, is that the registers of the local root signature cannot overlap with those defined in the global root signature.</p><p>Local root signatures also have a larger limit on the amount of shader records they can hold.</p><p>Although DirectX Raytracing shaders are very similar to normal HLSL shaders, they do have some extra features to facilitate raytracing.</p><p>The most important thing to note is that raytracing is only supported in Shader Model 6.3 and above. In MiniEngine, shaders are built with Visual Studio, you just have to add them to the solution. In the file options, make sure to set the item type to “HLSL Compiler”
<img src="https://renderingpixels.com/images/getting-started-with-dxr/vs-shader-type.png" alt=""/></p><p>To compile a raytracing shader in Visual Studio, make sure to add it to the solution, remove the Entrypoint Name, set the Shader Type to “Library” and set the Shader Model to “Shader Model 6.3”. Higher Shader Model versions should also work, but that may depend on the compiler and Windows SDK version you use.
<img src="https://renderingpixels.com/images/getting-started-with-dxr/vs-shader-compile-options.png" alt=""/></p><p>A raytracing shader also needs to have an “attribute” on the shader function. An attribute looks as follows: <code>[shader(&#34;shadertype&#34;)]</code>, where you replace <code>shadertype</code> with the type of the shader (the exact attributes will be shown in each section below).</p><h2 id="ray-generation-shader">Ray generation shader<a href="#ray-generation-shader" arialabel="Anchor">⌗</a></h2><p>To declare a ray generation shader, assign the following attribute to your shader function: <code>[shader(&#34;raygeneration&#34;)]</code></p><p>A ray generation shader in its essence will look something like the following:</p><div><pre tabindex="0"><code data-lang="c"><span><span>[shader(<span>&#34;raygeneration&#34;</span>)]
</span></span><span><span><span>void</span> RayGen()
</span></span><span><span>{
</span></span><span><span>    <span>// Do some stuff...
</span></span></span><span><span><span></span>    RayDesc ray <span>=</span> { <span>/* ... */</span> };
</span></span><span><span>    MyPayload payload <span>=</span> { <span>/* ... */</span> };
</span></span><span><span>    TraceRay( <span>/* ... */</span>, ray, payload);
</span></span><span><span>}
</span></span></code></pre></div><p>The primary function of the ray generation shader is to call <code>TraceRay</code> to generate the rays that will be shot out, based on a <code>RayDesc</code> structure that is filled in and passed to the <code>TraceRay</code> function. The <code>RayDesc</code> structure is filled in as follows:</p><div><pre tabindex="0"><code data-lang="c"><span><span>RayDesc ray <span>=</span> {};
</span></span><span><span>ray.Origin <span>=</span> <span>/* ... */</span>;
</span></span><span><span>ray.TMin <span>=</span> <span>/* ... */</span>;
</span></span><span><span>ray.Direction <span>=</span> <span>/* ... */</span>;
</span></span><span><span>ray.TMax <span>=</span> <span>/* ... */</span>;
</span></span></code></pre></div><p>With this <code>RayDesc</code> structure now filled in, we can make a call to the <code>TraceRay</code> function:</p><div><pre tabindex="0"><code data-lang="c"><span><span>TraceRay(
</span></span><span><span>    <span>// Here we pass in the acceleration structure
</span></span></span><span><span><span></span>    AccelerationStructure,
</span></span><span><span>
</span></span><span><span>    <span>// Flags to specify the behavior when a ray hits a surface. A good default
</span></span></span><span><span><span></span>    <span>// is RAY_FLAG_CULL_BACK_FACING_TRIANGLES
</span></span></span><span><span><span></span>    RayFlags,
</span></span><span><span>
</span></span><span><span>    <span>// This mask can be used to mask out some geometries.
</span></span></span><span><span><span></span>    <span>// We pass in ~0 or 0xFF, indicating that no geometries will be masked out.
</span></span></span><span><span><span></span>    InstanceOcclusionMask,
</span></span><span><span>
</span></span><span><span>    <span>// Sometimes an object can have multiple hit groups attached to it.
</span></span></span><span><span><span></span>    <span>// (e.g. one for diffuse shading, and one for shadow rays)
</span></span></span><span><span><span></span>    <span>// so we can use this parameter to index to the correct hit group
</span></span></span><span><span><span></span>    <span>// Since we only have one hit group in this project, we can default it to 0
</span></span></span><span><span><span></span>    RayContributionToHitMask,
</span></span><span><span>
</span></span><span><span>    <span>// According to the documentation:
</span></span></span><span><span><span></span>    <span>// This specifies the stride to multiply by GeometryContributionToHitGroupIndex,
</span></span></span><span><span><span></span>    <span>// which is just the 0 based index the geometry was supplied by the app into the
</span></span></span><span><span><span></span>    <span>// bottom-level acceleration structure.
</span></span></span><span><span><span></span>    <span>// If you&#39;re not doing anything fancy with this, you can just set it to 1.
</span></span></span><span><span><span></span>    MultiplierForGeometryContributionToHitGroupIndex,
</span></span><span><span>
</span></span><span><span>    <span>// In case we are using multiple miss shaders, we can use this parameter to
</span></span></span><span><span><span></span>    <span>// index to the correct shader that we want to use. If you only have one
</span></span></span><span><span><span></span>    <span>// miss shader, you can just pass in 0.
</span></span></span><span><span><span></span>    MissShaderIndex,
</span></span><span><span>
</span></span><span><span>    <span>// Here we pass the RayDesc structure that we filled in the previous step
</span></span></span><span><span><span></span>    RayDesc,
</span></span><span><span>
</span></span><span><span>    <span>// The payload that we associate with this ray. This is used to communicate
</span></span></span><span><span><span></span>    <span>// information between the raygen and hit/miss shaders.
</span></span></span><span><span><span></span>    Payload
</span></span><span><span>);
</span></span></code></pre></div><p>Important to note: the <code>TraceRay</code> function can be called from the Ray Generation shader, Closest Hit shader and the Miss shader. This is especially useful if you want to e.g. render reflections, as you can just call another <code>TraceRay</code> in the Closest hit shader.</p><h3 id="ray-payload">Ray Payload<a href="#ray-payload" arialabel="Anchor">⌗</a></h3><p>The ray payload is a user-defined structure that gets passed along with the <code>TraceRay</code> function, and is then passed to the any hit, closest hit, and miss shaders as an inout parameter. Important to note is that the shaders using the payload must use the same structure as the one that was provided to the <code>TraceRay</code> function.</p><h3 id="traceray-vs-tracerayinline">TraceRay vs TraceRayInline<a href="#traceray-vs-tracerayinline" arialabel="Anchor">⌗</a></h3><p>Besides the <code>TraceRay</code> function, there is also the <code>TraceRayInline</code> function. The inline version offers the same functionality as the normal <code>TraceRay</code> function, except that it doesn’t make use of separate shaders for hit and miss etc. The shader that calls <code>TraceRayInline</code> has to control what the raytracer does. A more in-depth explanation can be found here: <a href="https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#inline-raytracing">DirectX Raytracing (DXR) Functional Spec</a>.</p><h2 id="miss-shader">Miss shader<a href="#miss-shader" arialabel="Anchor">⌗</a></h2><p>This shader is invoked when the ray does not hit anything at all. To identify a shader as a miss shader, use the <code>[shader(&#34;miss&#34;)]</code> attribute. A common use for this shader is to sample from an environment map.</p><p>An example:</p><div><pre tabindex="0"><code data-lang="c"><span><span>[shader(<span>&#34;miss&#34;</span>)]
</span></span><span><span><span>void</span> Miss(inout MyPayload payload)
</span></span><span><span>{
</span></span><span><span>    <span>// Possibly sample from environment map...
</span></span></span><span><span><span></span>    <span>// Calls to TraceRay and CallShader can also be done here if desired
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><h2 id="hit-shaders">Hit shaders<a href="#hit-shaders" arialabel="Anchor">⌗</a></h2><p>The hit shaders are executed when a ray intersects with a triangle in the acceleration structure. There are two different types of hit shaders:</p><h3 id="closest-hit">Closest Hit<a href="#closest-hit" arialabel="Anchor">⌗</a></h3><p>The Closest Hit shader can only get invoked once per ray, at the closest intersection with an object. Most of the shading work should be done in this shader. The attribute used for this shader is <code>[shader(&#34;closesthit&#34;)]</code>.</p><p>A closest hit shader may look like this:</p><div><pre tabindex="0"><code data-lang="c"><span><span>[shader(<span>&#34;closesthit&#34;</span>)]
</span></span><span><span><span>void</span> ClosestHit(inout MyPayload payload, in MyAttributes attr)
</span></span><span><span>{
</span></span><span><span>    <span>// Your logic here...
</span></span></span><span><span><span></span>    <span>// Possibly even additional calls to TraceRay with a reflected ray...
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><h3 id="any-hit">Any Hit<a href="#any-hit" arialabel="Anchor">⌗</a></h3><p>The Any Hit shader is called every time a ray intersects with a triangle. They are very useful to calculate transparency in objects, as they can tell the API to ignore the current hit and continue searching for other hits. Any Hit shaders are defined by the attribute <code>[shader(&#34;anyhit&#34;)]</code>.</p><p>To prevent heavy performance impacts, it is good practice to keep the Any Hit shaders as trivial as possible, because they can get called many times per <code>TraceRay()</code> call.</p><p>An example of an any hit shader:</p><div><pre tabindex="0"><code data-lang="c"><span><span>[shader(<span>&#34;anyhit&#34;</span>)]
</span></span><span><span><span>void</span> AnyHit(inout MyPayload payload, in MyAttributes attr)
</span></span><span><span>{
</span></span><span><span>    <span>// Typically some alpha-testing logic here...
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// Call to `AcceptHitAndEndSearch(...)` if we&#39;re ok with this current intersection.
</span></span></span><span><span><span></span>    <span>// Call `IgnoreHit(...)` if we want to discard this intersection and search for more.
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><h2 id="intersection-shader">Intersection shader<a href="#intersection-shader" arialabel="Anchor">⌗</a></h2><p>An intersection shader is used in case you want to implement custom intersection primitives. If you have procedural geometry in your acceleration structure, you can write a custom intersection shader to test each ray for collision against this procedural object. (e.g. you can pass a sphere as a point and a radius, and then write a custom intersection shader to define these collisions, instead of making a triangle mesh for the sphere)</p><p>An intersection shader uses the <code>[shader(&#34;intersection&#34;)]</code> attribute:</p><div><pre tabindex="0"><code data-lang="c"><span><span>[shader(<span>&#34;intersection&#34;</span>)]
</span></span><span><span><span>void</span> Intersection()
</span></span><span><span>{
</span></span><span><span>    <span>// Intersection checks
</span></span></span><span><span><span></span>    <span>// Call `ReportHit(...)` 
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>If you do not provide an intersection shader, DXR will use a default ray-triangle intersection shader. For most use cases, you shouldn’t have to write an intersection shader yourself.</p><h2 id="callable-shader">Callable shader<a href="#callable-shader" arialabel="Anchor">⌗</a></h2><p>Callable shaders are shaders that can be invoked from another shader, by using the <code>CallShader(...)</code> function. A callable shader can be used to group common behavior together, and reduce duplicated code across the shaders. For my simple example, I didn’t find a use case to use a callable shader.</p><p>In order to declare a shader as a callable shader, you have to use the <code>[shader(&#34;callable&#34;)]</code> attribute on the shader function.</p><div><pre tabindex="0"><code data-lang="c"><span><span>[shader(<span>&#34;callable&#34;</span>)]
</span></span><span><span><span>void</span> Callable(inout MyParams params)
</span></span><span><span>{
</span></span><span><span>    <span>// Do some shader magic.
</span></span></span><span><span><span></span>    <span>// Perhaps another call to CallShader
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>The acceleration structure is key to real-time raytracing. It is a Bounding Volume Hierarchy (BVH for short) which can be efficiently traversed to calculate ray-object intersections. In DXR this BVH exists of two levels: a Bottom-Level Acceleration Structure (BLAS) and a Top-Level Acceleration Structure (TLAS). The BLASes hold mesh data, along with a transform matrix. Each TLAS then holds an instance of a BLAS, along with a transform matrix.
<img src="https://renderingpixels.com/images/getting-started-with-dxr/nvidia-accel-overview.png" alt=""/>
Image credit: NVIDIA</p><h2 id="scratch-buffer">Scratch Buffer<a href="#scratch-buffer" arialabel="Anchor">⌗</a></h2><p>To create the acceleration structure in DXR, we need to allocate a scratch buffer that will be used to store temporary calculations while building the acceleration structure on the GPU. Before we can do that, we first need to query the minimum size that we’re gonna need:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Get the TLAS prebuild info, so that we know how much scratch buffer size we need.
</span></span></span><span><span><span></span>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO tlasPrebuildInfo;
</span></span><span><span>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC tlasDesc <span>=</span> {};
</span></span><span><span>
</span></span><span><span><span>// Here we specify how many BLASes we need, and other parameters.
</span></span></span><span><span><span></span>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS<span>&amp;</span> tlasInputs <span>=</span> tlasDesc.Inputs;
</span></span><span><span>tlasInputs.Type <span>=</span> D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
</span></span><span><span>tlasInputs.NumDescs <span>=</span> numBottomLevels;
</span></span><span><span>tlasInputs.Flags <span>=</span> D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE;
</span></span><span><span>tlasInputs.pGeometryDescs <span>=</span> <span>nullptr</span>;
</span></span><span><span>tlasInputs.DescsLayout <span>=</span> D3D12_ELEMENTS_LAYOUT_ARRAY;
</span></span><span><span><span>// Query how much we need.
</span></span></span><span><span><span></span>rtDevice<span>-&gt;</span>GetRaytracingAccelerationStructurePrebuildInfo(<span>&amp;</span>tlasInputs, <span>&amp;</span>tlasPrebuildInfo);
</span></span><span><span>
</span></span><span><span><span>// We&#39;ll update this when we create the BLASes.
</span></span></span><span><span><span></span>UINT64 scratchBufferSizeNeeded <span>=</span> tlasPrebuildInfo.ScratchDataSizeInBytes;
</span></span></code></pre></div><p>We’ll come back to creating the actual scratch buffer later, when we know how big our scratch buffer needs to be.</p><h2 id="bottom-level-acceleration-structure">Bottom-Level Acceleration Structure<a href="#bottom-level-acceleration-structure" arialabel="Anchor">⌗</a></h2><p>To create the BLASes, we need to first describe the geometry that it will take in.
In my case, I decided to have one BLAS for each model in my scene, and merge all the meshes in a model into the same BLAS, but your approach could be different.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>std<span>::</span>vector<span>&lt;</span>D3D12_RAYTRACING_GEOMETRY_DESC<span>&gt;</span> geometryDescs(numMeshes);
</span></span><span><span>
</span></span><span><span><span>// Set up the descriptor for the mesh
</span></span></span><span><span><span></span><span>for</span> (UINT i <span>=</span> <span>0</span>; i <span>&lt;</span> numMeshes; i<span>++</span>)
</span></span><span><span>{
</span></span><span><span>    Model<span>::</span>Mesh<span>&amp;</span> mesh <span>=</span> pModel<span>-&gt;</span>m_pMesh[i];
</span></span><span><span>
</span></span><span><span>    D3D12_RAYTRACING_GEOMETRY_DESC<span>&amp;</span> desc <span>=</span> geometryDescs[i];
</span></span><span><span>    desc.Type <span>=</span> D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES;
</span></span><span><span>    desc.Flags <span>=</span> D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE;
</span></span><span><span>
</span></span><span><span>    <span>// Specify some properties of the mesh data
</span></span></span><span><span><span></span>    D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC<span>&amp;</span> trianglesDesc <span>=</span> desc.Triangles;
</span></span><span><span>    trianglesDesc.VertexFormat <span>=</span> DXGI_FORMAT_R32G32B32_FLOAT;
</span></span><span><span>    trianglesDesc.VertexCount <span>=</span> mesh.vertexCount;
</span></span><span><span>    trianglesDesc.VertexBuffer.StartAddress <span>=</span> pModel<span>-&gt;</span>m_VertexBuffer.GetGpuVirtualAddress() <span>+</span> (mesh.vertexDataByteOffset <span>+</span> mesh.attrib[Model<span>::</span>attrib_position].offset);
</span></span><span><span>    trianglesDesc.VertexBuffer.StrideInBytes <span>=</span> mesh.vertexStride;
</span></span><span><span>    trianglesDesc.IndexBuffer <span>=</span> pModel<span>-&gt;</span>m_IndexBuffer.GetGpuVirtualAddress() <span>+</span> mesh.indexDataByteOffset;
</span></span><span><span>    trianglesDesc.IndexCount <span>=</span> mesh.indexCount;
</span></span><span><span>    trianglesDesc.IndexFormat <span>=</span> DXGI_FORMAT_R16_UINT;
</span></span><span><span>    trianglesDesc.Transform3x4 <span>=</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Now that we have the geometry descriptors, we can create the BLAS create structs:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Prepare the BLAS create structs
</span></span></span><span><span><span></span>std<span>::</span>vector<span>&lt;</span>UINT64<span>&gt;</span> blasSize(numBottomLevels);
</span></span><span><span>std<span>::</span>vector<span>&lt;</span>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC<span>&gt;</span> blasDescs(numBottomLevels);
</span></span><span><span><span>for</span> (UINT i <span>=</span> <span>0</span>; i <span>&lt;</span> numBottomLevels; i<span>++</span>)
</span></span><span><span>{
</span></span><span><span>    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC<span>&amp;</span> blasDesc <span>=</span> blasDescs[i];
</span></span><span><span>    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS<span>&amp;</span> blasInputs <span>=</span> blasDesc.Inputs;
</span></span><span><span>    blasInputs.Type <span>=</span> D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
</span></span><span><span>    blasInputs.NumDescs <span>=</span> numMeshes;
</span></span><span><span>    blasInputs.pGeometryDescs <span>=</span> <span>&amp;</span>geometryDescs[i];
</span></span><span><span>    blasInputs.Flags <span>=</span> buildFlags;
</span></span><span><span>    blasInputs.DescsLayout <span>=</span> D3D12_ELEMENTS_LAYOUT_ARRAY;
</span></span><span><span>
</span></span><span><span>    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO blasPrebuildInfo;
</span></span><span><span>    rtDevice<span>-&gt;</span>GetRaytracingAccelerationStructurePrebuildInfo(<span>&amp;</span>blasInputs, <span>&amp;</span>blasPrebuildInfo);
</span></span><span><span>
</span></span><span><span>    blasSize[i] <span>=</span> blasPrebuildInfo.ResultDataMaxSizeInBytes;
</span></span><span><span>    <span>// Here we&#39;ll make sure to increase the scratch buffer size, if we need it.
</span></span></span><span><span><span></span>    scratchBufferSizeNeeded <span>=</span> std<span>::</span>max(blasPrebuildInfo.ScratchDataSizeInBytes, scratchBufferSizeNeeded);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Now that we know the size, we can finally create the scratch buffer.
</span></span></span><span><span><span></span>scratchBuffer.Create(<span>L</span><span>&#34;Acceleration Structure Scratch Buffer&#34;</span>, <span>static_cast</span><span>&lt;</span>UINT<span>&gt;</span>(scratchBufferSizeNeeded), <span>1</span>);
</span></span></code></pre></div><p>With our scratch buffer created and our BLAS descriptors set up, we can create the BLASes:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>std<span>::</span>vector<span>&lt;</span>D3D12_RAYTRACING_INSTANCE_DESC<span>&gt;</span> instanceDescs(numBottomLevels);
</span></span><span><span>blases.resize(numBottomLevels);
</span></span><span><span><span>for</span> (UINT i <span>=</span> <span>0</span>; i <span>&lt;</span> blasDescs.size(); i<span>++</span>)
</span></span><span><span>{
</span></span><span><span>    <span>auto</span><span>&amp;</span> blas <span>=</span> blases[i];
</span></span><span><span>
</span></span><span><span>    <span>// Create the BLAS
</span></span></span><span><span><span></span>    <span>auto</span> bottomLevelDesc <span>=</span> CD3DX12_RESOURCE_DESC<span>::</span>Buffer(blasSize[i], D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
</span></span><span><span>    g_Device<span>-&gt;</span>CreateCommittedResource(
</span></span><span><span>        <span>&amp;</span>defaultHeapDesc,
</span></span><span><span>        D3D12_HEAP_FLAG_NONE,
</span></span><span><span>        <span>&amp;</span>bottomLevelDesc,
</span></span><span><span>        D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE,
</span></span><span><span>        <span>nullptr</span>,
</span></span><span><span>        IID_PPV_ARGS(<span>&amp;</span>blas));
</span></span><span><span>
</span></span><span><span>    blasDescs[i].DestAccelerationStructureData <span>=</span> blas<span>-&gt;</span>GetGPUVirtualAddress();
</span></span><span><span>    blasDescs[i].ScratchAccelerationStructureData <span>=</span> scratchBuffer.GetGpuVirtualAddress();
</span></span><span><span>
</span></span><span><span>    D3D12_RAYTRACING_INSTANCE_DESC<span>&amp;</span> instanceDesc <span>=</span> instanceDescs[i];
</span></span><span><span>    UINT descriptorIndex <span>=</span> descriptorHeap<span>-&gt;</span>AllocateBufferUav(<span>*</span>blas.Get());
</span></span><span><span>
</span></span><span><span>    <span>// Identity matrix
</span></span></span><span><span><span></span>    ZeroMemory(instanceDesc.Transform, <span>sizeof</span>(instanceDesc.Transform));
</span></span><span><span>    instanceDesc.Transform[<span>0</span>][<span>0</span>] <span>=</span> <span>1.0f</span>;
</span></span><span><span>    instanceDesc.Transform[<span>1</span>][<span>1</span>] <span>=</span> <span>1.0f</span>;
</span></span><span><span>    instanceDesc.Transform[<span>2</span>][<span>2</span>] <span>=</span> <span>1.0f</span>;
</span></span><span><span>
</span></span><span><span>    instanceDesc.AccelerationStructure <span>=</span> blases[i]<span>-&gt;</span>GetGPUVirtualAddress();
</span></span><span><span>    instanceDesc.Flags <span>=</span> <span>0</span>;
</span></span><span><span>    instanceDesc.InstanceID <span>=</span> <span>0</span>;
</span></span><span><span>    instanceDesc.InstanceMask <span>=</span> <span>1</span>;
</span></span><span><span>    instanceDesc.InstanceContributionToHitGroupIndex <span>=</span> i;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// We create a buffer to hold all of our BLAS instances.
</span></span></span><span><span><span></span>instanceDataBuffer.Create(<span>L</span><span>&#34;Instance Data Buffer&#34;</span>, numBottomLevels, <span>sizeof</span>(D3D12_RAYTRACING_INSTANCE_DESC), instanceDescs.data());
</span></span></code></pre></div><h2 id="top-level-acceleration-structure">Top-Level Acceleration Structure<a href="#top-level-acceleration-structure" arialabel="Anchor">⌗</a></h2><p>The top-level acceleration structure could be seen as an acceleration structure of acceleration structures. It holds instances of BLASes, each with their own transform matrix, so that it can correctly placed it in the world.</p><p>Now that we have our BLASes created, we can create the TLAS.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Specify where the instance data buffer is located.
</span></span></span><span><span><span></span>tlasInputs.InstanceDescs <span>=</span> instanceDataBuffer.GetGpuVirtualAddress();
</span></span><span><span>tlasInputs.DescsLayout <span>=</span> D3D12_ELEMENTS_LAYOUT_ARRAY;
</span></span><span><span>
</span></span><span><span><span>// With all the necessary buffers set up and structures filled in,
</span></span></span><span><span><span>// we can finally tell the GPU to build our acceleration structure
</span></span></span><span><span><span></span>
</span></span><span><span><span>// Create the BLASes
</span></span></span><span><span><span></span><span>for</span> (UINT i <span>=</span> <span>0</span>; i <span>&lt;</span> blasDescs.size(); i<span>++</span>)
</span></span><span><span>{
</span></span><span><span>    pRaytracingCommandList<span>-&gt;</span>BuildRaytracingAccelerationStructure(<span>&amp;</span>blasDescs[i], <span>0</span>, <span>nullptr</span>);
</span></span><span><span>}
</span></span><span><span><span>// Create the TLAS
</span></span></span><span><span><span></span>pRaytracingCommandList<span>-&gt;</span>BuildRaytracingAccelerationStructure(<span>&amp;</span>tlasDesc, <span>0</span>, <span>nullptr</span>);
</span></span></code></pre></div><p>The full source code of this example can be found <a href="https://github.com/SeppahBaws/DirectX-Raytracing/blob/main/MiniEngine/AdaptiveSampling/RaytracingHelpers/AccelerationStructureBuilder.cpp">here</a>. I mostly put everything into this post, but it might be more useful to see the full source code.</p><h2 id="acceleration-structure-refitting">Acceleration Structure Refitting<a href="#acceleration-structure-refitting" arialabel="Anchor">⌗</a></h2><p>If we want to animate our scenes now, we would need to completely rebuild the acceleration structure from scratch. As you can guess, this would cause a huge performance impact. Luckily we can avoid this by “refitting” the TLAS, which is much faster than a complete rebuild.</p><p>Since the TLAS simply stores BLASes along with a transformation matrix, we can simply update the transformation matrices for the BLASes that we want to animate, and refit the acceleration structure.</p><p>Since refitting was out of scope for my internship and this post, I kindly refer you to the <a href="https://developer.nvidia.com/rtx/raytracing/dxr/dx12-raytracing-tutorial/extra/dxr_tutorial_extra_refit">NVIDIA DXR tutorial on refitting</a>.</p><p>A descriptor heap is a collection of resource views. Its purpose is to group the majority of memory allocations for the resource views together. We can then create resource views for the shaders from this heap.</p><p>It is important to note that not all resource views can be created from the same descriptor heap: SRVs, UAVs and CBVs can be created from the same heap, but RTVs and Sampler views each need their own separate heap.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Create our descriptor heap:
</span></span></span><span><span><span></span>D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc <span>=</span> {};
</span></span><span><span>descriptorHeapDesc.NumDescriptors <span>=</span> <span>10</span>; <span>// How many you need
</span></span></span><span><span><span></span>descriptorHeapDesc.Type <span>=</span> D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
</span></span><span><span>descriptorHeapDesc.Flags <span>=</span> D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
</span></span><span><span>
</span></span><span><span>g_Device<span>-&gt;</span>CreateDescriptorHeap(<span>&amp;</span>descriptorHeapDesc, IID_PPV_ARGS(<span>&amp;</span>m_DescriptorHeap));
</span></span><span><span>
</span></span><span><span><span>// Get the handle so we can write to it on the CPU side
</span></span></span><span><span><span></span>D3D12_CPU_DESCRIPTOR_HANDLE descHandle <span>=</span> m_DescriptorHeap<span>-&gt;</span>GetCPUDescriptorHandleForHeapStart();
</span></span><span><span>
</span></span><span><span><span>// Now we can describe what our descriptor view should look like:
</span></span></span><span><span><span></span>
</span></span><span><span><span>// Add TLAS as SRV
</span></span></span><span><span><span></span>descHandle.ptr <span>+=</span> g_Device<span>-&gt;</span>GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
</span></span><span><span>
</span></span><span><span><span>// In this case we&#39;re creating our acceleration structure resource view:
</span></span></span><span><span><span></span>D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc;
</span></span><span><span>srvDesc.Format <span>=</span> DXGI_FORMAT_UNKNOWN;
</span></span><span><span>srvDesc.ViewDimension <span>=</span> D3D12_SRV_DIMENSION_RAYTRACING_ACCELERATION_STRUCTURE;
</span></span><span><span>srvDesc.Shader4ComponentMapping <span>=</span> D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
</span></span><span><span>srvDesc.RaytracingAccelerationStructure.Location <span>=</span> scene.m_InstanceDataBuffer<span>-&gt;</span>GetGPUVirtualAddress(); <span>// GPU address to the acceleration instance data buffer.
</span></span></span><span><span><span></span>g_Device<span>-&gt;</span>CreateShaderResourceView(<span>nullptr</span>, <span>&amp;</span>srvDesc, descHandle);
</span></span></code></pre></div><p>In a rasterized pipeline, we always know what part of the scene we’re rendering at any one point. However, we don’t have that luxury in raytracing, since two rays might get bounced around, hitting two totally different objects (e.g. one just a normal mesh, the other might hit a transparent object, etc…).</p><p>This is why we need a Shader Table: it holds all the shaders we might possibly need during raytracing. While raytracing, the API then indexes into the shader tables and uses the specified shader, depending on the current context (Did the ray hit anything? If yes, <em>what</em> did we hit? Was it a normal triangle? Was it something which requires a custom intersection shader? Which hit shader should I even run? etc…)</p><p>In the simple case of a hello-dxr, we only need 3 byte address buffers to store our shader tables:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>ByteAddressBuffer m_RayGenShaderTable;
</span></span><span><span>ByteAddressBuffer m_MissShaderTable;
</span></span><span><span>ByteAddressBuffer m_HitShaderTable;
</span></span></code></pre></div><p>We can now start creating our shader tables. We’ll need some extra helpers to get started first though:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>const</span> UINT shaderTableSize <span>=</span> D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES;
</span></span><span><span>
</span></span><span><span>ID3D12StateObjectProperties<span>*</span> stateObjectProperties <span>=</span> <span>nullptr</span>;
</span></span><span><span>ASSERT_SUCCEEDED(pPSO<span>-&gt;</span>QueryInterface(IID_PPV_ARGS(<span>&amp;</span>stateObjectProperties)));
</span></span></code></pre></div><p>We can now create the ray generation shader table - the miss shader table will be the exact same, except for a different shader identifier and a different ByteAddressBuffer:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>const</span> UINT alignment <span>=</span> <span>16</span>; <span>// We need to align it to 16 bytes.
</span></span></span><span><span><span>// A vector of bytes to hold our aligned table.
</span></span></span><span><span><span>// We add alignment - 1 to the initial size, so that we have room to pad our bytes.
</span></span></span><span><span><span></span>std<span>::</span>vector<span>&lt;</span>BYTE<span>&gt;</span> alignedShaderTableData(shaderTableSize <span>+</span> alignment <span>-</span> <span>1</span>);
</span></span><span><span>
</span></span><span><span><span>// Now we can get an aligned pointer into the bytes, where we will then write our shader table
</span></span></span><span><span><span></span>BYTE<span>*</span> pAlignedShaderTableData <span>=</span> alignedShaderTableData.data() <span>+</span> ((UINT64)alignedShaderTableData.data() <span>%</span> alignment);
</span></span><span><span>
</span></span><span><span><span>// For the ray generation table and miss table, we&#39;ll only need the shader identifier
</span></span></span><span><span><span>// The `rayGenExportName` parameter here is the export name of the shader. This has to be the same as the one that you passed into the PSO
</span></span></span><span><span><span></span><span>void</span><span>*</span> pRayGenShaderData <span>=</span> stateObjectProperties<span>-&gt;</span>GetShaderIdentifier(rayGenExportName);
</span></span><span><span>
</span></span><span><span><span>// Copy our shader data into the aligned portion of the vector.
</span></span></span><span><span><span></span>memcpy(pAlignedShaderTableData, pRayGenShaderData, shaderTableSize);
</span></span><span><span>
</span></span><span><span><span>// We can now create the ByteAddressBuffer with MiniEngine&#39;s helpers:
</span></span></span><span><span><span></span>m_RayGenShaderTable.Create(
</span></span><span><span>    <span>L</span><span>&#34;Ray Gen Shader Table&#34;</span>,       <span>// The name of the buffer
</span></span></span><span><span><span></span>    <span>1</span>,                             <span>// The amount of elements
</span></span></span><span><span><span></span>    shaderTableSize,               <span>// The size of each element
</span></span></span><span><span><span></span>    alignedShaderTableData.data()  <span>// The initial data
</span></span></span><span><span><span></span>);
</span></span></code></pre></div><p>Creating the hit shader table is a bit more complicated, and will vary depending on what data you need access to in the hit shader.
A simple pass where you output the mesh texture color might look something like this:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// The size of the shader identifier
</span></span></span><span><span><span></span><span>const</span> UINT shaderIdentifierSize <span>=</span> D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES;
</span></span><span><span><span>// The offset in the blob to the descriptor handle
</span></span></span><span><span><span></span><span>const</span> UINT offsetToDescriptorHandle <span>=</span> ALIGN(<span>sizeof</span>(D3D12_GPU_DESCRIPTOR_HANDLE), shaderIdentifierSize);
</span></span><span><span><span>// THe offset in the blob to the material constants
</span></span></span><span><span><span></span><span>const</span> UINT offsetToMaterialConstants <span>=</span> ALIGN(<span>sizeof</span>(UINT32), offsetToDescriptorHandle <span>+</span> <span>sizeof</span>(D3D12_GPU_DESCRIPTOR_HANDLE));
</span></span><span><span><span>// The size of one shader record
</span></span></span><span><span><span></span><span>const</span> UINT shaderRecordSizeInBytes <span>=</span> ALIGN(D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT, offsetToMaterialConstants <span>+</span> <span>sizeof</span>(MeshRootConstant));
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>// This is a temporary buffer where we will write the shader record table to.
</span></span></span><span><span><span>// We will have as many shader records as we have meshes.
</span></span></span><span><span><span>// In my case, a &#34;scene&#34; only consisted of a single model with one or more meshes.
</span></span></span><span><span><span></span>std<span>::</span>vector<span>&lt;</span>byte<span>&gt;</span> pHitShaderTable(shaderRecordSizeInBytes <span>*</span> model.m_Header.meshCount);
</span></span><span><span>
</span></span><span><span><span>// Get the shader identifier:
</span></span></span><span><span><span></span><span>void</span><span>*</span> pHitGroupIdentifierData <span>=</span> stateObjectProperties<span>-&gt;</span>GetShaderIdentifier(DEFAULT_HIT_GROUP_NAME);
</span></span><span><span>
</span></span><span><span><span>for</span> (UINT i <span>=</span> <span>0</span>; i <span>&lt;</span> model.m_Header.meshCount; i<span>++</span>)
</span></span><span><span>{
</span></span><span><span>    <span>// First entry in the record: the hit group for which this entry is
</span></span></span><span><span><span></span>    byte<span>*</span> pShaderRecord <span>=</span> i <span>*</span> shaderRecordSizeInBytes <span>+</span> pHitShaderTable.data();
</span></span><span><span>    memcpy(pShaderRecord, pHitGroupIdentifierData, shaderIdentifierSize);
</span></span><span><span>
</span></span><span><span>    <span>// Second entry: shader descriptors (textures etc)
</span></span></span><span><span><span></span>    UINT materialIndex <span>=</span> model.m_pMesh[i].materialIndex;
</span></span><span><span>    memcpy(pShaderRecord <span>+</span> offsetToDescriptorHandle,
</span></span><span><span>        <span>&amp;</span>scene.m_ModelDescriptors[materialIndex].ptr,
</span></span><span><span>        <span>sizeof</span>(scene.m_ModelDescriptors[materialIndex].ptr)
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// Third entry: mesh id (used to query mesh data like UVs in the shader)
</span></span></span><span><span><span></span>    MeshRootConstant meshConst;
</span></span><span><span>    meshConst.meshId <span>=</span> i;
</span></span><span><span>    memcpy(pShaderRecord <span>+</span> offsetToMaterialConstants,
</span></span><span><span>        <span>&amp;</span>meshConst,
</span></span><span><span>        <span>sizeof</span>(meshConst)
</span></span><span><span>    );
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Now we can create the ByteAddressBuffer with `pHitGroupIdentifierData`,
</span></span></span><span><span><span>// exactly the same way we did for the ray gen table and miss table
</span></span></span></code></pre></div><p>The raytracing pipeline groups all the objects together that are required to kick off the raytracing. These are: the shaders, hit groups, shader associations and the global root signature.
The DirectX 12 helpers library (available at: <a href="https://github.com/microsoft/DirectX-Headers/blob/main/include/directx/d3dx12.h">microsoft/DirectX-Headers</a>) is a very useful tool to quickly set this up, because it abstracts away a lot of boilerplate code.</p><p>To create a pipeline, we start off by creating the pipeline descriptor:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>CD3DX12_STATE_OBJECT_DESC raytracingPipeline{ D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE };
</span></span></code></pre></div><p>Then, we add our shaders to the pipeline: (repeat this for each shader)</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> shaderLib <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_DXIL_LIBRARY_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>D3D12_SHADER_BYTECODE shaderDxil <span>=</span> CD3DX12_SHADER_BYTECODE((<span>void</span><span>*</span>)g_pShader, ARRAYSIZE(g_pShader));
</span></span><span><span>shaderLib<span>-&gt;</span>SetDXILLibrary(<span>&amp;</span>shaderDxil);
</span></span><span><span>shaderLib<span>-&gt;</span>DefineExport(<span>L</span><span>&#34;ShaderMainFunction&#34;</span>);
</span></span></code></pre></div><p><code>g_pShader</code> is the bytecode array which is output by the shader compiler in Visual Studio, and <code>L&#34;ShaderMainFunction&#34;</code> is the name of the main function in your shader. This is the one with the shader identifier attribute.</p><p>After that, we add the hit group(s): (again, repeat for each group)</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> hitGroup <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_HIT_GROUP_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>hitGroup<span>-&gt;</span>SetClosestHitShaderImport(<span>L</span><span>&#34;...&#34;</span>); <span>// Closest hit shader main function name.
</span></span></span><span><span><span></span>hitGroup<span>-&gt;</span>SetHitGroupExport(<span>L</span><span>&#34;...&#34;</span>); <span>// Name to identify this hit group as.
</span></span></span><span><span><span></span>hitGroup<span>-&gt;</span>SetHitGroupType(D3D12_HIT_GROUP_TYPE_TRIANGLES); <span>// Can also be D3D12_HIT_GROUP_TYPE_PROCEDURAL_PRIMITIVE.
</span></span></span></code></pre></div><p>Next, we add the shader config:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> shaderConfig <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>UINT payloadSize <span>=</span> <span>1</span> <span>*</span> <span>sizeof</span>(<span>float</span>); <span>// float rayHitT
</span></span></span><span><span><span></span>UINT attributeSize <span>=</span> <span>2</span> <span>*</span> <span>sizeof</span>(<span>float</span>); <span>// float2 barycentrics
</span></span></span><span><span><span></span>shaderConfig<span>-&gt;</span>Config(payloadSize, attributeSize);
</span></span></code></pre></div><p>In this example, the ray payload only has 1 float for the distance, and we’re using the built-in attributes (<code>BuiltInTriangleIntersectionAttributes</code>) which only has a <code>float2 barycentrics</code> as data. (<a href="https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#intersection-attributes-structure">spec</a>)</p><p>Next, we add the local root signatures: (repeat for each shader)</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> shaderLocalRootSig <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>shaderLocalRootSig<span>-&gt;</span>SetRootSignature(m_ShaderLocalRootSig.GetSignature());
</span></span></code></pre></div><p><code>m_ShaderLocalRootSig</code> is of type <code>RootSignature</code> which is provided by the MiniEngine, and filled in later in the code</p><p>Then, we move on to adding the shader associations: (repeat for each shader)</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> shaderAssoc <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>shaderAssoc<span>-&gt;</span>SetSubobjectToAssociate(<span>*</span>shaderLocalRootSig); <span>// Root signature subobject from previous step.
</span></span></span><span><span><span></span>shaderAssoc<span>-&gt;</span>AddExport(<span>L</span><span>&#34;...&#34;</span>); <span>// Shader export name.
</span></span></span></code></pre></div><p>Next, we bind the global root signature:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> globalRootSig <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>globalRootSig<span>-&gt;</span>SetRootSignature(m_RTGlobalRootSig.GetSignature());
</span></span></code></pre></div><p>Similar as the local root signatures, the global root signature is of type <code>RootSignature</code>, which is provided by the MiniEngine, and initialized earlier in the code.</p><p>Finally, we bind the pipeline configuration:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> pipelineConfig <span>=</span> raytracingPipeline.CreateSubobject<span>&lt;</span>CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT<span>&gt;</span>();
</span></span><span><span>UINT maxRecursionDepth <span>=</span> <span>1</span>;
</span></span><span><span>pipelineConfig<span>-&gt;</span>Config(maxRecursionDepth);
</span></span></code></pre></div><p>The <code>maxRecursionDepth</code> defines how much recursion we can have (some effects like reflections need to trace secondary rays from a ray hit point). In my example I only used primary rays, so a maxRecursionDepth of 1 worked just fine.</p><p>Now that everything is bound to the pipeline descriptor, we can finally build the pipeline:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>HRESULT hr <span>=</span> m_pRTDevice<span>-&gt;</span>CreateStateObject(raytracingPipeline, IID_PPV_ARGS(<span>&amp;</span>m_RaytracingPSO));
</span></span><span><span><span>// Check hr for errors
</span></span></span></code></pre></div><p>This can fail, so make sure you check the HRESULT for errors!</p><p>Binding data to the global root signature is pretty easy; right before calling <code>DispatchRays()</code>, all you have to do is bind the root signature, and then bind all the global root signature parameters:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Bind the root signature.
</span></span></span><span><span><span></span>commandList<span>-&gt;</span>SetComputeRootSignature(m_GlobalRTRootSignature);
</span></span><span><span><span>// Bind the global root parameters
</span></span></span><span><span><span></span>commandList<span>-&gt;</span>SetComputeRootDescriptorTable(<span>0</span>, m_RTOutputUAV);
</span></span><span><span>commandList<span>-&gt;</span>SetComputeRootShaderResourceView(<span>1</span>, m_TLAS<span>-&gt;</span>GetGPUVirtualAddress());
</span></span><span><span><span>// etc...
</span></span></span></code></pre></div><p>Passing data to a local root signature is a bit more difficult, because you have to bind the data to a shader table, which can hold any arbitrary data. You are expected to set the memory directly, but it’s not too difficult with some pointer offset tricks.</p><p>My shader table looks like this:</p><table><thead><tr><th>Shader record name</th><th>Size</th></tr></thead><tbody><tr><td>hit group identifier</td><td>D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES (defined as 32)</td></tr><tr><td>material textures</td><td>sizeof(D3D12_GPU_DESCRIPTOR_HANDLE)</td></tr><tr><td>mesh id</td><td>sizeof(UINT32)</td></tr></tbody></table><p>Now that we know what our entries are and how big they are, we can calculate the offset of a shader record by just adding all the sizes of the previous shader records together.</p><p>Important to note is the first shader record: the <code>hit group identifier</code>. It is a mandatory field, and DXR expects us to set it, so that DXR knows to which hit group this shader stage belongs to.</p><p>To render everything correctly, we first have to make sure to bind our output buffer as our render target:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Transition the output buffer to a UAV
</span></span></span><span><span><span></span>gfxContext.TransitionResource(m_RaytracingOutput, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
</span></span><span><span>gfxContext.FlushResourceBarriers(); <span>// Wait until m_RaytracingOutput has finished transitioning
</span></span></span><span><span><span></span>gfxContext.SetRenderTarget(m_RaytracingOutput.GetRTV());
</span></span></code></pre></div><p>As you can see, we also need to transition the output buffer to be a UAV, so that we can properly access it and write to it from the shaders.</p><p>Next up we bind the descriptor heap:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>ID3D12DescriptorHeap<span>*</span> pDescriptorHeaps[] <span>=</span> { <span>&amp;</span>m_pRTDescHeap<span>-&gt;</span>GetDescriptorHeap() };
</span></span><span><span>rtCommandList<span>-&gt;</span>SetDescriptorHeaps(ARRAYSIZE(pDescriptorHeaps), pDescriptorHeaps);
</span></span></code></pre></div><p>After that, we bind the global root signature and its parameters</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>commandList<span>-&gt;</span>SetComputeRootSignature(m_RTGlobalRootSig.GetSignature());
</span></span><span><span><span>// Bind the root parameters by using the SetComputeRoot* functions
</span></span></span><span><span><span>// on the command list, e.g.:
</span></span></span><span><span><span></span>commandList<span>-&gt;</span>SetComputeRootDescriptorTable(<span>0</span>, m_RTOutputUAV);
</span></span><span><span>commandList<span>-&gt;</span>SetComputeRootShaderResourceView(<span>1</span>, m_TLAS<span>-&gt;</span>GetGPUVirtualAddress());
</span></span><span><span><span>// etc...
</span></span></span></code></pre></div><p>Then we can bind our raytracing pipeline:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>rtCommandList<span>-&gt;</span>SetPipelineState1(m_RaytracingPSO.Get());
</span></span></code></pre></div><p>Now that we have everything we need, we can finally tell DXR to kick off the raytracing. In order to do this, we have to fill in the <code>D3D12_DISPATCH_RAYS_DESC</code> struct, which will hold our shader tables and thread grid dimensions (similar to compute shaders).</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>D3D12_DISPATCH_RAYS_DESC dispatchRaysDesc <span>=</span> {};
</span></span><span><span>
</span></span><span><span><span>// Ray generation shader record
</span></span></span><span><span><span></span>dispatchRaysDesc.RayGenerationShaderRecord.StartAddress <span>=</span> m_RayGenShaderTable.GetGpuVirtualAddress();
</span></span><span><span>dispatchRaysDesc.RayGenerationShaderRecord.SizeInBytes <span>=</span> m_RayGenShaderTable.GetBufferSize();
</span></span><span><span>
</span></span><span><span><span>// Hit group table
</span></span></span><span><span><span></span>dispatchRaysDesc.HitGroupTable.StartAddress <span>=</span> m_HitShaderTable.GetGpuVirtualAddress();
</span></span><span><span>dispatchRaysDesc.HitGroupTable.SizeInBytes <span>=</span> m_HitShaderTable.GetBufferSize();
</span></span><span><span>dispatchRaysDesc.HitGroupTable.StrideInBytes <span>=</span> m_HitGroupStride;
</span></span><span><span>
</span></span><span><span><span>// Miss table
</span></span></span><span><span><span></span>dispatchRaysDesc.MissShaderTable.StartAddress <span>=</span> m_MissShaderTable.GetGpuVirtualAddress();
</span></span><span><span>dispatchRaysDesc.MissShaderTable.SizeInBytes <span>=</span> m_MissShaderTable.GetBufferSize();
</span></span><span><span>dispatchRaysDesc.MissShaderTable.StrideInBytes <span>=</span> dispatchRaysDesc.MissShaderTable.SizeInBytes; <span>// Only one entry
</span></span></span><span><span><span></span>
</span></span><span><span><span>// The dimensions to dispatch the rays over
</span></span></span><span><span><span></span>dispatchRaysDesc.Width <span>=</span> m_RaytracingOutput.GetWidth();
</span></span><span><span>dispatchRaysDesc.Height <span>=</span> m_RaytracingOutput.GetHeight();
</span></span><span><span>dispatchRaysDesc.Depth <span>=</span> <span>1</span>;
</span></span></code></pre></div><p>Once we have that filled in, we can finally call <code>DispatchRays</code>:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>rtCommandList<span>-&gt;</span>DispatchRays(<span>&amp;</span>dispatchRaysDesc);
</span></span></code></pre></div><p>When we’re done with raytracing, we can now use our raytracing output buffer however we like. In my example, I simply copied it to MiniEngine’s “backbuffer”:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Make sure the resources are in the correct state
</span></span></span><span><span><span></span>gfxContext.TransitionResource(m_RaytracingOutput, D3D12_RESOURCE_STATE_COPY_SOURCE);
</span></span><span><span>gfxContext.TransitionResource(g_SceneColorBuffer, D3D12_RESOURCE_STATE_COPY_DEST);
</span></span><span><span>
</span></span><span><span><span>// Wait for them to finish transitioning
</span></span></span><span><span><span></span>gfxContext.FlushResourceBarriers();
</span></span><span><span>
</span></span><span><span><span>// Issue the copy command
</span></span></span><span><span><span></span>gfxContext.CopyBuffer(g_SceneColorBuffer, m_RaytracingOutput);
</span></span><span><span>
</span></span><span><span><span>// Transition the back buffer back to a render target
</span></span></span><span><span><span></span>gfxContext.TransitionResource(g_SceneColorBuffer, D3D12_RESOURCE_STATE_RENDER_TARGET);
</span></span><span><span><span>// We transition m_RaytracingOutput at the beginning of the raytracing pass,
</span></span></span><span><span><span>// so no need to transition it here *again*.
</span></span></span></code></pre></div><p>And that’s it! If everything went well, you should now have your scene being raytraced.
In case you got stuck on something, I recommend going through the references linked below. They were the major ones I used when setting up DXR for the first time.
I also point you to <a href="https://github.com/SeppahBaws/DirectX-Raytracing">my own repository</a> where you can find all the source code I wrote during my internship. Everything in there should be working fine(tm).</p><p>If you haven’t yet, I also recommend giving <a href="https://renderingpixels.com/2022/01/ramblings-on-games-rendering-and-real-time-raytracing/">my previous post</a> a read, where I ramble about raytracing in games and stuff. If this post was a bit too much over your head, I think you’ll enjoy that one. :)</p><p>These are my most-used documentation pages and tutorials that I used while getting my feet wet with DXR.
I highly recommend going through these, because they contain a ton of information.</p><ul><li><a href="https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html">DirectX Raytracing (DXR) Functional Spec</a></li><li><a href="https://microsoft.github.io/DirectX-Specs/d3d/ResourceBinding.html#descriptor-heaps">DirectX-Specs</a></li><li><a href="https://developer.nvidia.com/rtx/raytracing/dxr/dx12-raytracing-tutorial-part-1#accelerationstructure">DX12 Raytracing tutorial - Part 1</a></li><li><a href="https://www.3dgep.com/learning-directx-12-1/#Create_a_Descriptor_Heap">Learning DirectX 12</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12device5">ID3D12Device5 - Win32 apps</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/root-signatures-overview">Root Signatures Overview - Win32 apps</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/direct3d-12-raytracing-hlsl-shaders">Direct3D 12 Raytracing HLSL Shaders - Win32 apps</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_build_raytracing_acceleration_structure_desc">D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC (d3d12.h) - Win32 apps</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_raytracing_geometry_desc">D3D12_RAYTRACING_GEOMETRY_DESC (d3d12.h) - Win32 apps</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/descriptor-heaps-overview">Descriptor Heaps Overview - Win32 apps</a></li></ul></div></div></div>
  </body>
</html>
