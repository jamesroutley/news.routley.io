<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://text.marvinborner.de/2024-03-25-02.html">Original</a>
    <h1>Lambda Screen: Fractals in Pure Lambda Calculus</h1>
    
    <div id="readability-page-1" class="page">

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#encoding" id="toc-encoding">Encoding</a>
<ul>
<li><a href="#example" id="toc-example">Example</a></li>
</ul></li>
<li><a href="#rendering" id="toc-rendering">Rendering</a></li>
<li><a href="#reduction" id="toc-reduction">Reduction</a></li>
<li><a href="#fractals" id="toc-fractals">Fractals</a>
<ul>
<li><a href="#sierpiński-triangle" id="toc-sierpiński-triangle">Sierpiński Triangle</a></li>
<li><a href="#t-square" id="toc-t-square">T-Square</a></li>
<li><a href="#sierpiński-carpet" id="toc-sierpiński-carpet">“Sierpiński
Carpet”</a></li>
<li><a href="#cantor-dust" id="toc-cantor-dust">Cantor Dust</a></li>
</ul></li>
<li><a href="#utilities" id="toc-utilities">Utilities</a></li>
</ul>
</nav>

<p>Pure lambda calculus has encodings for many different <a href="https://text.marvinborner.de/2023-04-07-01.html">data
structures</a> like lists, numbers, strings, and trees. Wrapped in <a href="https://tromp.github.io/cl/LC.pdf">monadic IO</a>, lambda calculus
provides a great interface for computation – as can be seen in
user-friendly syntactic variants like my programming language <a href="https://bruijn.marvinborner.de">bruijn</a>. Such simple languages,
however, typically don’t support <em>graphical</em> output (aside from
ASCII art).</p>
<p>I present the “Lambda Screen”, a way to use terms of pure lambda
calculus for generating images. I also show how recursive terms (induced
by fixed-point combinators) can lead to infinitely detailed <a href="https://en.wikipedia.org/wiki/Fractal">fractals</a>.</p>
<p>If you want to skip the details or want to figure out its inner
workings yourself, go to <a href="https://lambda-screen.marvinborner.de">my reference
implementation</a> (<a href="https://github.com/marvinborner/lambda-screen">source-code</a>)
and flip through the examples.</p>

<p>A <em>screen</em> is a term
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mtext> tl tr bl br</mtext><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\lambda x.(x\ \textrm{tl}\ \textrm{tr}\ \textrm{bl}\ \textrm{br}),</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span> </span><span><span>tl</span></span><span> </span><span><span>tr</span></span><span> </span><span><span>bl</span></span><span> </span><span><span>br</span></span><span>)</span><span>,</span></span></span></span></span>
where the terms <code>tl</code>, <code>tr</code>, <code>bl</code>, and
<code>br</code> represent the top-left, top-right, bottom-left, and
bottom-right quadrants of the image. Each of these terms can either be
another screen, or a <em>pixel</em>.</p>
<p>A <em>pixel</em> is either <em>on</em> (white) or <em>off</em>
(black). In its <em>on</em> state, a pixel is defined as the
<code>k</code> combinator
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>w</mtext><mo>=</mo><mi>λ</mi><mi>w</mi><mtext> </mtext><mi>b</mi><mi mathvariant="normal">.</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\textrm{w}=\lambda w\ b.w</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>w</span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>w</span><span> </span><span>b</span><span>.</span><span>w</span></span></span></span></span>
In its <em>off</em> state, it’s the <code>ki</code> combinator
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>b</mtext><mo>=</mo><mi>λ</mi><mi>w</mi><mtext> </mtext><mi>b</mi><mi mathvariant="normal">.</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">\textrm{b}=\lambda w\ b.b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>b</span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>w</span><span> </span><span>b</span><span>.</span><span>b</span></span></span></span></span>
This decision was made for simplicity and could be any other <a href="https://text.marvinborner.de/2023-04-07-01.html#states">state
encoding</a>, including ones of arbitrary size and color.</p>
<h2 id="example">Example</h2>
<p>Click the “Render” button to see the results.</p>
<ul>
<li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi mathvariant="normal">_</mi><mtext> </mtext><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mtext> b b b b</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda \_\ x.(x\ \textrm{b}\ \textrm{b}\ \textrm{b}\ \textrm{b})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>_</span><span> </span><span>x</span><span>.</span><span>(</span><span>x</span><span> </span><span><span>b</span></span><span> </span><span><span>b</span></span><span> </span><span><span>b</span></span><span> </span><span><span>b</span></span><span>)</span></span></span></span></li>
</ul>
<canvas height="600" width="600" data-term="[[((((0 [[0]]) [[0]]) [[0]]) [[0]])]]" data-id="1"></canvas>

<ul>
<li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi mathvariant="normal">_</mi><mtext> </mtext><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mtext> </mtext><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>y</mi><mtext> b w w b</mtext><mo stretchy="false">)</mo><mtext> w w b</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda \_\ x.(x\ \lambda y.(y\ \textrm{b}\ \textrm{w}\ \textrm{w}\ \textrm{b})\ \textrm{w}\ \textrm{w}\ \textrm{b})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>_</span><span> </span><span>x</span><span>.</span><span>(</span><span>x</span><span> </span><span>λ</span><span>y</span><span>.</span><span>(</span><span>y</span><span> </span><span><span>b</span></span><span> </span><span><span>w</span></span><span> </span><span><span>w</span></span><span> </span><span><span>b</span></span><span>)</span><span> </span><span><span>w</span></span><span> </span><span><span>w</span></span><span> </span><span><span>b</span></span><span>)</span></span></span></span></li>
</ul>
<canvas height="600" width="600" data-term="[[((((0 [((((0 [[0]]) [[1]]) [[1]]) [[0]])]) [[1]]) [[1]]) [[0]])]]" data-id="2"></canvas>


<p>For this project, I decided that the entire behavior of the screen is
defined by a single closed lambda term. Upon execution of the renderer,
this function gets applied to the default empty screen (four white
squares). This enables the use of point-free/Tacit programming
(e.g. using combinators), such that you don’t necessarily have to
construct screens/colors at all.</p>
<p>Through slightly modified beta-reduction, the screen gets updated
in-place while the term converges to its normal form. High rendering
depths or diverging behavior may stop the renderer before convergence is
reached.</p>
<p>Note that the renderer would also work with normal beta-reduction
until convergence. The additional steps were only made to add support
for in-place rendering of diverging terms.</p>

<p>The in-place reduction-rendering works as follows (written as
pseudo-Haskell using de Bruijn indices; actually implemented in
JavaScript).</p>
<p>Figure out if a term looks like a screen:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>isScreen (<span>Abs</span> (<span>App</span> (<span>App</span> (<span>App</span> (<span>App</span> (<span>Idx</span> <span>0</span>) _) _) _) _)) <span>=</span> <span>True</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>isScreen _                                             <span>=</span> <span>False</span></span></code></pre></div>
<p>Color the quadrants depending on pixel state (or grey if term is not
yet figured out):</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>quadrantColor (<span>Abs</span> (<span>Abs</span> (<span>Idx</span> <span>1</span>))) <span>=</span> <span>White</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>quadrantColor (<span>Abs</span> (<span>Abs</span> (<span>Idx</span> <span>0</span>))) <span>=</span> <span>Black</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>quadrantColor _                   <span>=</span> <span>Grey</span></span></code></pre></div>
<p>Reduce to normal form (or loop endlessly):</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>nf (<span>Abs</span> t)   <span>=</span> <span>Abs</span> <span>$</span> nf t</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>nf (<span>App</span> l r) <span>=</span> <span>case</span> nf l <span>of</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span>Abs</span> t <span>-&gt;</span> nf <span>$</span> subst t r</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  t     <span>-&gt;</span> <span>App</span> t (nf r)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>nf t         <span>=</span> t</span></code></pre></div>
<p>Reduce to weak-head normal form:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>whnf (<span>App</span> l r) <span>=</span> <span>case</span> whnf l <span>of</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span>Abs</span> t <span>-&gt;</span> whnf <span>$</span> subst t r</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  t     <span>-&gt;</span> <span>App</span> t r</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>whnf t         <span>=</span> t</span></code></pre></div>
<p>Reduce to screen normal form (either
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mtext> tl</mtext><mo stretchy="false">)</mo><mtext> tr</mtext><mo stretchy="false">)</mo><mtext> bl</mtext><mo stretchy="false">)</mo><mtext> br</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda x.((((x\ \textrm{tl})\ \textrm{tr})\ \textrm{bl})\ \textrm{br})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>((((</span><span>x</span><span> </span><span><span>tl</span></span><span>)</span><span> </span><span><span>tr</span></span><span>)</span><span> </span><span><span>bl</span></span><span>)</span><span> </span><span><span>br</span></span><span>)</span></span></span></span>,
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>w</mi><mtext> </mtext><mi>b</mi><mi mathvariant="normal">.</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\lambda w\ b.w</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>w</span><span> </span><span>b</span><span>.</span><span>w</span></span></span></span>,
or
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>w</mi><mtext> </mtext><mi>b</mi><mi mathvariant="normal">.</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">\lambda w\ b.b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>w</span><span> </span><span>b</span><span>.</span><span>b</span></span></span></span>):</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>snf t <span>=</span> <span>case</span> whnf t <span>of</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span>Abs</span> b <span>-&gt;</span> <span>case</span> <span>Abs</span> <span>$</span> whnf b <span>of</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    t<span>@</span>(<span>Abs</span> (<span>Abs</span> _)) <span>-&gt;</span> nf t <span>-- not a screen!</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    t <span>-&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>      <span>let</span> go t <span>|</span> isScreen t <span>=</span> t</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>          go (<span>App</span> l r)      <span>=</span> <span>case</span> whnf l <span>of</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            (<span>Abs</span> t) <span>-&gt;</span> go <span>$</span> subst t r</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            t       <span>-&gt;</span> go <span>$</span> <span>App</span> t (whnf r)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>          go (<span>Abs</span> t) <span>=</span> go <span>$</span> <span>Abs</span> <span>$</span> whnf t</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      <span>in</span>  go t</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  _ <span>-&gt;</span> <span>error</span> <span>&#34;not a screen/pixel&#34;</span></span></code></pre></div>
<p>Main reduction and rendering loop (assuming drawing functions that
use and return some <code>ctx</code>):</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>reduce ((t, ctx) <span>:</span> ts) <span>|</span> quadrantColor t <span>!=</span> <span>Grey</span> <span>=</span> reduce ts</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>reduce ((t, ctx) <span>:</span> ts) <span>=</span> <span>if</span> isScreen <span>$</span> snf t</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span>then</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span>let</span> (<span>App</span> (<span>App</span> (<span>App</span> (<span>App</span> _ tl) tr) bl) br) <span>=</span> t</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span>in</span>  reduce ts</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>          <span>++</span> [ (tl, drawTopLeft ctx (quadrantColor tl))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>             , (tr, drawTopRight ctx (quadrantColor tr))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>             , (bl, drawBottomLeft ctx (quadrantColor bl))</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>             , (br, drawBottomRight ctx (quadrantColor br))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>             ]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span>else</span> <span>do</span> <span>-- this is pseudo-Haskell after all</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    drawAt ctx (quadrantColor t)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    reduce ts</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span>-- and, finally:</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>main t <span>=</span> reduce [(t, <span>Ctx</span> (canvas, width, height))]</span></code></pre></div>
<p>See my <a href="https://github.com/marvinborner/lambda-screen/tree/main">reference
implementation</a> for more details.</p>

<h2 id="sierpiński-triangle">Sierpiński Triangle</h2>
<p>We can’t trivially draw the classic “standing-up” <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński
triangle</a>, since drawing the diagonals over square borders would get
quite complex.</p>
<p>Instead, we can draw a rotated variant using a simple rewrite
rule:</p>
<figure>
<img src="https://text.marvinborner.de/res/lambdaScreenTriangle.png" alt="Every black square stays black forever; each (sub-)quadrant gets recursively applied to this rewrite rule."/>
<figcaption aria-hidden="true">Every black square stays black forever;
each (sub-)quadrant gets recursively applied to this rewrite
rule.</figcaption>
</figure>
<p>Translated to lambda calculus, we get the following:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>triangle</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mtext> triangle b triangle triangle</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><msup><mtext>triangle</mtext><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mtext>y </mtext><mi>λ</mi><mi>t</mi><mtext> </mtext><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mtext> </mtext><mi>t</mi><mtext> b </mtext><mi>t</mi><mtext> </mtext><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{aligned} \textrm{triangle}&amp;=\lambda x.(x\ \textrm{triangle}\ \textrm{b}\ \textrm{triangle}\ \textrm{triangle})\\ \implies\textrm{triangle}&#39;&amp;=\lambda \_.(\textrm{y}\ \lambda t\ x.(x\ t\ \textrm{b}\ t\ t)) \end{aligned} </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>triangle</span></span></span></span><span><span></span><span><span></span><span>⟹</span><span></span><span></span><span><span><span>triangle</span></span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span> </span><span><span>triangle</span></span><span> </span><span><span>b</span></span><span> </span><span><span>triangle</span></span><span> </span><span><span>triangle</span></span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>_.</span><span>(</span><span><span>y</span></span><span> </span><span>λ</span><span>t</span><span> </span><span>x</span><span>.</span><span>(</span><span>x</span><span> </span><span>t</span><span> </span><span><span>b</span></span><span> </span><span>t</span><span> </span><span>t</span><span>))</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Or, <a href="https://codegolf.stackexchange.com/a/272442/119961">golfed in
binary lambda calculus</a> to 51 bits:</p>
<pre><code>000100011010000100000101010110110000010110110011010</code></pre>
</div>
  </body>
</html>
