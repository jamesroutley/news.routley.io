<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/modeling-crdts-in-alloy-introduction-and-the-importance-of-idempotence/">Original</a>
    <h1>modeling CRDTs in Alloy - introduction and the importance of idempotence</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, October 9, 2023</em></p><p>I&#39;ve been interested in <a href="https://www.inkandswitch.com/local-first/">local-first software</a> for a long time, and recently attended an event about it with a bunch of luminaries from various research groups. I learned a lot, and it rekindled my interest in syncable data structures.</p><p>I&#39;ve tried to sync data over the years with varying degrees of success. For example, I&#39;ve known about <a href="https://en.wikipedia.org/wiki/Operational_transformation">operational transformations (OT)</a> for a while (via <a href="https://quilljs.com/">Quill</a>, but I have never been able to get the syncing operations working to my satisfaction. Message ordering is crucially important in OT, and it&#39;s hard to get right. I get the impression that the engineers who worked on Google Wave (which also used OT) also struggled with this. One of them (Joseph Gentle) was quoted as saying &#34;Unfortunately, implementing OT sucks. There&#39;s a million algorithms with different tradeoffs, mostly trapped in academic papers. […] Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.&#34; (Worth noting that <a href="https://news.ycombinator.com/item?id=12311984">he later said it might not take as long today</a>, but still… pain!)</p><p>In contrast to OT, conflict-free replicated data types (CRDTs) seem really promising! <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Wikipedia has a good summary</a>, which I&#39;ll quote:</p><blockquote><p>In distributed computing, a conflict-free replicated data type (CRDT) is a data structure that is replicated across multiple computers in a network, with the following features:</p><ol><li>The application can update any replica independently, concurrently and without coordinating with other replicas.</li><li>An algorithm (itself part of the data type) automatically resolves any inconsistencies that might occur.</li><li>Although replicas may have different state at any particular point in time, they are guaranteed to eventually converge.</li></ol></blockquote><p>These properties appeal to me! If CRDTs can automatically and independently converge, no matter how far apart they drift, then you could store them wherever and however you like. Offline support should be simple, and adding live collaboration features should not mean spending years figuring out edge cases. Sign me up!</p><p>What are CRDTs made from, though? It looks like typically it&#39;s some internal stuff, a function to resolve the internal stuff to a <code>value</code>, and a function to <code>merge</code> two of the data structure together. The merge function is the number-one-most-important thing about this whole arrangement, and has to satisfy these three laws:</p><ul><li>commutative (so <code>merge(a, b)</code> must be the same as <code>merge(b, a)</code>)</li><li>associative (so <code>merge(merge(a, b), c)</code> must be the same as <code>merge(a, merge(b, c))</code>)</li><li>idempotent (so <code>merge(a, b)</code> must be the same as <code>merge(merge(a, b), b)</code>.)</li></ul><p>If all these are true, we can always merge two states, regardless of how many changes have been made since we last merged, and get the same result on both sides of the sync. Cool!</p><p>These seem like the kinds of things that <a href="https://bytes.zone/projects/learning-alloy/">Alloy</a> would be good at modeling, so let&#39;s try it! Over the next couple of posts, I&#39;m going to build a handful of data structures that follow these three rules and compose them into data structures we could build an application on top of.</p><p>Let&#39;s get a taste for this with <code>OR(bool, bool)</code>. First off, does it satisfy our three properties?</p><ul><li>commutative: <code>OR(True, False)</code> is the same as <code>OR(False, True)</code></li><li>associative: <code>OR(OR(True, False), True)</code> is the same as <code>OR(True, OR(False, True))</code></li><li>idempotent: calling <code>OR(x, True)</code> gives the same result as <code>OR(OR(x, True), True)</code>.</li></ul><p>So it looks like <code>OR</code> might be fine, but let&#39;s be sure. We can check this in Alloy by first defining a boolean:</p><pre data-lang="alloy"><code data-lang="alloy"><span>enum</span><span> Bool { True, False }
</span></code></pre><p>Then a merge function, which we check is correct:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fun </span><span>merge[</span><span>a, b: Bool</span><span>]</span><span>:</span><span> Bool {
</span><span>  </span><span>// OR
</span><span>  a </span><span>=</span><span> True </span><span>implies</span><span> a </span><span>else</span><span> b
</span><span>}
</span><span>
</span><span>check</span><span> MergeIsCorrect {
</span><span>  </span><span>// read as: given `a` and `b`, which are `Bool`, the
</span><span>  </span><span>// following condition must hold.
</span><span>  </span><span>all</span><span> a, b</span><span>:</span><span> Bool </span><span>|
</span><span>    (a </span><span>=</span><span> True </span><span>or</span><span> b </span><span>=</span><span> True) </span><span>implies </span><span>merge[</span><span>a, b</span><span>] </span><span>=</span><span> True
</span><span>}
</span></code></pre><p>And finally, our three properties:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> MergeIsCommutative {
</span><span>  </span><span>all</span><span> a, b</span><span>:</span><span> Bool </span><span>| </span><span>merge[</span><span>a, b</span><span>] </span><span>= </span><span>merge[</span><span>b, a</span><span>]
</span><span>}
</span><span>
</span><span>check</span><span> MergeIsAssociative {
</span><span>  </span><span>all</span><span> a, b, c</span><span>:</span><span> Bool </span><span>| </span><span>merge[</span><span>merge[a, b</span><span>]</span><span>, c] </span><span>= </span><span>merge[</span><span>a, merge[b, c</span><span>]</span><span>]
</span><span>}
</span><span>
</span><span>check</span><span> MergeIsIdempotent {
</span><span>  </span><span>all</span><span> a, b</span><span>:</span><span> Bool </span><span>| </span><span>merge[</span><span>a, b</span><span>] </span><span>= </span><span>merge[</span><span>merge[a, b</span><span>]</span><span>, b]
</span><span>}
</span></code></pre><p>Great! Alloy can&#39;t find any errors with <code>OR</code>. We expected that, so let&#39;s break it in interesting ways. What if the merge function was <code>XOR(bool, bool)</code> instead?</p><pre data-lang="alloy"><code data-lang="alloy"><span>fun </span><span>merge[</span><span>a, b: Bool</span><span>]</span><span>:</span><span> Bool {
</span><span>  a </span><span>=</span><span> b </span><span>implies</span><span> False </span><span>else</span><span> True
</span><span>}
</span></code></pre><p>Now Alloy finds that we&#39;ve broken idempotency: <code>merge[False, True]</code> is <code>True</code>, but <code>merge[merge[False, True], True]</code> is <code>False</code>. This would cause big problems if we used <code>XOR</code> as a merge function: the act of syncing could change our values! We can imagine this sequence of events:</p><ol><li>Node A sets the value to <code>True</code></li><li>Node B sets the value to <code>False</code></li><li>The nodes sync, both resolving to <code>True</code> (since <code>XOR(True, False)</code> is <code>True</code>)</li><li>The nodes sync again, both resolving to <code>False</code> (since <code>XOR(True, True)</code> is <code>False</code>)</li><li>Further syncs would stay at <code>False</code> until someone changed the value to <code>True</code>, at which point we&#39;d repeat from step 3.</li></ol><p>But in a fun twist of fate, we don&#39;t <em>have</em> to imagine this; we can ask Alloy to generate these traces for us. First we&#39;ll make a document that contains a changeable value:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Document {
</span><span>  var value</span><span>: one</span><span> Bool,
</span><span>}
</span></code></pre><p>Then we&#39;ll define a <code>not</code> for our boolean and a couple of operations (flipping an arbitrary value and syncing two documents):</p><pre data-lang="alloy"><code data-lang="alloy"><span>fun </span><span>bool_not[</span><span>b: Bool</span><span>]</span><span>:</span><span> Bool {
</span><span>  b </span><span>=</span><span> True </span><span>implies</span><span> False </span><span>else</span><span> True
</span><span>}
</span><span>
</span><span>// intent: when `flip` is true, the provided document will go
</span><span>// from True to False or False to True in the next time step. 
</span><span>// This serves as our proxy for someone clicking a button in
</span><span>// a UI or whatever.
</span><span>pred </span><span>flip[</span><span>d: Document</span><span>]</span><span> {
</span><span>  </span><span>// implementation: `value` is actually a set of tuples from
</span><span>  </span><span>// documents to booleans, and `value&#39;` is the same but in the
</span><span>  </span><span>// next time step. We set the entire value explicitly
</span><span>  </span><span>// (instead of just saying like `d&#39;.value = False`) because
</span><span>  </span><span>// otherwise Alloy could say &#34;and what if something changes
</span><span>  </span><span>// that you weren&#39;t expecting?&#34;
</span><span>  </span><span>//
</span><span>  </span><span>// Syntax: `-&gt;` creates a tuple, and `++` replaces all
</span><span>  </span><span>// existing tuples referencing `d` in the set.
</span><span>  value&#39; </span><span>=</span><span> value </span><span>++</span><span> d</span><span>-&gt;</span><span>bool_not[</span><span>d.value</span><span>]
</span><span>}
</span><span>
</span><span>// intent: merge two documents together in a way that all the
</span><span>// `merge` rules hold. Maybe imagine we have `d1` locally and
</span><span>// are getting `d2` over the network (but remember that order
</span><span>// should not matter!)
</span><span>pred </span><span>sync[</span><span>d1, d2: Document</span><span>]</span><span> {
</span><span>  </span><span>let</span><span> merged </span><span>= </span><span>merge[</span><span>d1.value, d2.value</span><span>]</span><span> {
</span><span>    value&#39; </span><span>=</span><span> value </span><span>++</span><span> (d1</span><span>-&gt;</span><span>merged </span><span>+</span><span> d2</span><span>-&gt;</span><span>merged)
</span><span>  }
</span><span>}
</span></code></pre><p>Now wire them up so these events can happen over time:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> init {
</span><span>  </span><span>// `Document` is a set of documents, and `-&gt;` will apply pairwise
</span><span>  </span><span>// for the sets in its arguments, so this means this says &#34;all
</span><span>  </span><span>// documents start at `False`&#34;
</span><span>  value </span><span>=</span><span> Document </span><span>-&gt;</span><span> False
</span><span>}
</span><span>
</span><span>fact</span><span> traces {
</span><span>  </span><span>// this says &#34;start with `init`, then pick one of these things to
</span><span>  </span><span>// happen at each time step.&#34; Putting it in a `fact` means that
</span><span>  </span><span>// any assertions we make from now on assume that we want these
</span><span>  </span><span>// instructions.
</span><span>  init
</span><span>  always {
</span><span>    (</span><span>one</span><span> d</span><span>:</span><span> Document </span><span>| </span><span>flip[</span><span>d</span><span>]</span><span>)
</span><span>    </span><span>or</span><span> (</span><span>some</span><span> d1, d2</span><span>:</span><span> Document </span><span>| </span><span>sync[</span><span>d1, d2</span><span>]</span><span>)
</span><span>  }
</span><span>}
</span></code></pre><p>We can now check that our sync is idempotent:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> SyncIsIdempotent {
</span><span>  </span><span>// at all times, if sync happens twice in a row (the `;` syntax) then
</span><span>  </span><span>// the next value (`value&#39;`) and the one after that (`value&#39;&#39;`) should
</span><span>  </span><span>// be the same.
</span><span>  always </span><span>all</span><span> d1, d2</span><span>:</span><span> Document </span><span>|
</span><span>    (</span><span>sync[</span><span>d1, d2</span><span>]</span><span>; </span><span>sync[</span><span>d1, d2</span><span>]</span><span>) </span><span>implies</span><span> value&#39; </span><span>=</span><span> value&#39;&#39;
</span><span>}
</span></code></pre><p>If we make <code>OR</code> our <code>merge</code> function, this works fine and Alloy can&#39;t find any counterexamples. If we use <code>XOR</code> for <code>merge</code>, though, Alloy finds the trace I mentioned could show up earlier. Here&#39;s what it shows us.</p><table><thead><tr><th>Step</th><th>Description</th><th>Image</th></tr></thead><tbody><tr><td>1.</td><td>We start off with all documents at <code>False</code>.</td><td><img src="https://www.nytimes.com/images/xor-trace-step-1-and-4.png" alt="an Alloy instance showing two documents both set to False"/></td></tr><tr><td>2.</td><td>One of the documents flips to <code>True</code>.</td><td><img src="https://www.nytimes.com/images/xor-trace-step-2.png" alt="the previous instance, but with one document now set to True"/></td></tr><tr><td>3.</td><td>The documents sync, converging to <code>True</code>.</td><td><img src="https://www.nytimes.com/images/xor-trace-step-3.png" alt="the previous instance, but with both documents now set to True"/></td></tr><tr><td>4.</td><td>The documents sync again, converging to <code>False</code> because <code>XOR(True, True)</code> (the previously synced state) is <code>False</code>.</td><td><img src="https://www.nytimes.com/images/xor-trace-step-1-and-4.png" alt="the previous instance, but with both documents now set to False"/></td></tr><tr><td>5.</td><td>Stay here forever or return to 2.</td><td></td></tr></tbody></table><p>In case you&#39;re encountering them for the first time, these diagrams are generated by Alloy—they&#39;re pretty fantastic for showing other people exactly what can happen in a system. (That&#39;s also why <code>Document 0</code> is <code>d1</code> and so on. The documents are defined separately, and the <code>d1</code> and <code>d2</code> labels come from our <code>check</code> so we can see what&#39;s doing what.)</p><p>Alloy can do more than this, too. If we modify our condition to have 3 distinct documents like this:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> SyncIsIdempotent {
</span><span>  always </span><span>all disj</span><span> d1, d2, d3</span><span>:</span><span> Document </span><span>|
</span><span>    (</span><span>sync[</span><span>d1, d2</span><span>]</span><span>; </span><span>sync[</span><span>d2, d3</span><span>]</span><span>) </span><span>implies</span><span> value&#39; </span><span>=</span><span> value&#39;&#39;
</span><span>}
</span></code></pre><p>Then Alloy shows the situation getting even sillier. You only need one of the nodes to be <code>False</code>, at which point it&#39;s possible that the documents as a whole could never converge again and just flap back and forth randomly forever. It all depends on which documents sync with which other documents. Turns out idempotency is pretty important!</p><p>That&#39;s it for today. Next time we&#39;ll go from booleans-of-dubious-usefulness to counters!</p><hr/><p>Big thanks to <a href="https://jakelazaroff.com/">Jake Lazaroff</a> for his help reviewing this post. If you&#39;re interested in this stuff, he also recently published <a href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/">an interactive intro to CRDTs</a> that you may enjoy!</p></article></div>
  </body>
</html>
