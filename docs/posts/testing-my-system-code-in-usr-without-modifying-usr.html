<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0pointer.net/blog/testing-my-system-code-in-usr-without-modifying-usr.html">Original</a>
    <h1>Testing my system code in /usr/ without modifying /usr/</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><a href="https://0pointer.net/blog/running-an-container-off-the-host-usr.html">I recently
blogged</a>
about how to run a volatile <code>systemd-nspawn</code> container from your
host&#39;s <code>/usr/</code> tree, for quickly testing stuff in your host
environment, sharing your home drectory, but all that without making a
single modification to your host, and on an isolated node.</p>
<p>The one-liner discussed in that blog story is great for testing during
system software development. Let&#39;s have a look at another <code>systemd</code>
tool that I regularly use to test things during <code>systemd</code> development,
in a relatively safe environment, but still taking full benefit of my
host&#39;s setup.</p>
<p>Since a while now, systemd has been shipping with a simple component
called
<a href="https://www.freedesktop.org/software/systemd/man/systemd-sysext.html"><code>systemd-sysext</code></a>. It&#39;s
primary usecase goes something like this: on one hand OS systems with
immutable <code>/usr/</code> hierarchies are fantastic for security, robustness,
updating and simplicity, but on the other hand not being able to
quickly add stuff to <code>/usr/</code> is just annoying.</p>
<p><code>systemd-sysext</code> is supposed to bridge this contradiction: when
invoked it will merge a bunch of &#34;system extension&#34; images into
<code>/usr/</code> (and <code>/opt/</code> as a matter of fact) through the use of read-only
<code>overlayfs</code>, making all files shipped in the image instantly and
<em>atomically</em> appear in <code>/usr/</code> during runtime — as if they always had
been there. Now, let&#39;s say you are building your locked down OS, with
an immutable <code>/usr/</code> tree, and it comes without ability to log into,
without debugging tools, without anything you want and need when
trying to debug and fix something in the system. With <code>systemd-sysext</code>
you could use a system extension image that contains all this, drop it
into the system, and activate it with <code>systemd-sysext</code> so that it
genuinely extends the host system.</p>
<p>(There are many other usecases for this tool, for example, you could
build systems that way that at their base use a generic image, but by
installing one or more system extensions get extended to with
additional more specific functionality, or drivers, or similar. The
tool is generic, use it for whatever you want, but for now let&#39;s not
get lost in listing all the possibilites.)</p>
<p>What&#39;s particularly nice about the tool is that it supports
automatically discovered <code>dm-verity</code> images, with signatures and
everything. So you can even do this in a fully authenticated,
measured, safe way. But I am digressing…</p>
<p>Now that we (hopefully) have a rough understanding what
<code>systemd-sysext</code> is and does, let&#39;s discuss how specficially we can
use this in the context of system software development, to safely use
and test bleeding edge development code — built freshly from your
project&#39;s build tree – in your host OS without having to risk that the
host OS is corrupted or becomes unbootable by stuff that didn&#39;t quite
yet work the way it was envisioned:</p>
<p>The images <code>systemd-sysext</code> merges into <code>/usr/</code> can be of two kinds:
disk images with a file system/verity/signature, or simple, plain
directory trees. To make these images available to the tool, they can
be placed or symlinked into <code>/usr/lib/extensions/</code>,
<code>/var/lib/extensions/</code>, <code>/run/extensions/</code> (and a bunch of
others). So if we now install our freshly built development software
into a subdirectory of those paths, then that&#39;s entirely sufficient to
make them valid system extension images in the sense of
<code>systemd-sysext</code>, and thus can be merged into <code>/usr/</code> to try them out.</p>
<p>To be more specific: when I develop <code>systemd</code> itself, here&#39;s what I do
regularly, to see how my new development version would behave on my
host system. As preparation I checked out the systemd development git
tree first of course, hacked around in it a bit, then built it with
meson/ninja. And now I want to test what I just built:</p>
<div><pre><span></span><code>sudo DESTDIR=/run/extensions/systemd-test meson install -C build --quiet --no-rebuild &amp;&amp;
        sudo systemd-sysext refresh --force
</code></pre></div>

<p>Explanation: first, we&#39;ll install my current build tree as a system
extension into <code>/run/extensions/systemd-test/</code>. And then we apply it
to the host via the <code>systemd-sysext refresh</code> command. This command
will search for all installed system extension images in the
aforementioned directories, then unmount (i.e. &#34;unmerge&#34;) any
previously merged dirs from <code>/usr/</code> and then freshly mount
(i.e. &#34;merge&#34;) the new set of system extensions on top of <code>/usr/</code>. And
just like that, I have installed my development tree of <code>systemd</code> into
the host OS, and all that without actually modifying/replacing even a
single file on the host at all. Nothing here actually hit the disk!</p>
<p>Note that all this works on any system really, it is not necessary
that the underlying OS even is designed with immutability in
mind. Just because the tool was developed with immutable systems in
mind it doesn&#39;t mean you couldn&#39;t use it on traditional systems where
<code>/usr/</code> is mutable as well. In fact, my development box actually runs
regular Fedora, i.e. is RPM-based and thus has a mutable <code>/usr/</code>
tree. As long as system extensions are applied the whole of <code>/usr/</code>
becomes read-only though.</p>
<p>Once I am done testing, when I want to revert to how things were without the image installed, it is sufficient to call:</p>
<div><pre><span></span><code>sudo systemd-sysext unmerge
</code></pre></div>

<p>And there you go, all files my development tree generated are gone
again, and the host system is as it was before (and <code>/usr/</code> mutable
again, in case one is on a traditional Linux distribution).</p>
<p>Also note that a reboot (regardless if a <em>clean</em> one or an <em>abnormal</em>
shutdown) will undo the whole thing automatically, since we installed
our build tree into <code>/run/</code> after all, i.e. a <code>tmpfs</code> instance that is
flushed on boot. And given that the <code>overlayfs</code> merge is a runtime
thing, too, the whole operation was executed without any
persistence. Isn&#39;t that great?</p>
<p>(You might wonder why I specified <code>--force</code> on the <code>systemd-sysext
refresh</code> line earlier. That&#39;s because <code>systemd-sysext</code> actually does
some minimal version compatibility checks when applying system
extension images. For that it will look at the host&#39;s
<code>/etc/os-release</code> file with
<code>/usr/lib/extension-release.d/extension-release.&lt;name&gt;</code>, and refuse
operaton if the image is not actually built for the host OS
version. Here we don&#39;t want to bother with dropping that file in
there, we <em>know</em> already that the extension image is compatible with
the host, as we just built it on it. <code>--force</code> allows us to skip the
version check.)</p>
<p>You might wonder: what about the combination of the idea from the
previous blog story (regarding running container&#39;s off the host
<code>/usr/</code> tree) with system extensions? Glad you asked. Right now we
have no support for this, but it&#39;s high on our TODO list (patches
welcome, of course!). i.e. a new switch for <code>systemd-nspawn</code> called
<code>--system-extension=</code> that would allow merging one or more such
extensions into the container tree booted would be stellar. With that,
with a single command I could run a container off my host OS but with
a development version of systemd dropped in, all without any
persistence. How awesome would that be?</p>
<p>(Oh, and in case you wonder, all of this only works with distributions
that have completed the <code>/usr/</code> merge. On legacy distributions that
didn&#39;t do that and still place parts of <code>/usr/</code> all over the hierarchy
the above won&#39;t work, since merging <code>/usr/</code> trees via <code>overlayfs</code> is
pretty pointess if the OS is not hermetic in <code>/usr/</code>.)</p>
<p>And that&#39;s all for now. Happy hacking!</p>
  </div></div>
  </body>
</html>
