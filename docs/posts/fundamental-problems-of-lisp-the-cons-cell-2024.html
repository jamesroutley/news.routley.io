<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://xahlee.info/comp/lisp_cons_problem.html">Original</a>
    <h1>Fundamental Problems of Lisp, the Cons Cell (2024)</h1>
    
    <div id="readability-page-1" class="page"><div>




<p>
(this essay is originally written around 2008)
</p>

<section>

<h2>The Cons Business</h2>

<p>
The other fundamental problem in the language is its cons cells as its list construction primitive.
</p>

<p>Lisp at core is based on functional programing on lists.
This is a powerful paradigm.
However, for historical reasons, lisp&#39;s list is based on the hardware concept of “cons” cell.
From a mathematical, functional, API point of view, what this means is that lisp&#39;s “list” is limited to a max of 2 elements.
If you want a longer list, you must nest it and interpret it in a special way.
(i.e.
effectively creating a mini-protocol, known as “proper list”.)
The cons fundamentally crippled the development of list processing.</p>

<p>Lisp being historically based the cons for about 4 decades. The cons and the associated {car cdr cadr caadr caddr caaar cdddr …} are fundamentally rooted in the lisp langs, is thus not something that can be easily mended. This is unfortunate. However, this situation could be improved.  By, for example:</p>

<ul>
<li>Create a standard that all list data structures must be proper lists. (this would also mean re-implement association lists to be based on proper lists)</li>
<li>Expose only higher-level list manipulation functions (i.e. interfaces to cons) in all new literature.</li>
<li>Even mark cons related constructs as obsolete.</li>
</ul>

<p>One of the myth that is quickly injected into budding lispers, is that cons is powerful. It is powerful in the sense assembly lang is powerful.</p>

<blockquote>

<p>Lisp&#39;s cons is perhaps the greatest fuck up in the history of computer languages.</p>

</blockquote>

<p>
Racket Lisp described the cons problem well:
</p>

<ul>
<li><a href="http://xahlee.info/comp/racket_lisp_doc_on_cons.html">Racket Doc on Lisp Cons Problem</a></li>
</ul>

<p>For some concrete examples of problems caused by the cons, see:</p>

<ul>
<li><a href="http://xahlee.info/comp/Guy_Steele_parallel_computing.html">Guy Steele Says: Don&#39;t Iterate, Recurse, and Get rid of lisp cons!</a></li>
<li><a href="http://xahlee.info/UnixResource_dir/writ/lisp_equal_copy_list.html">Why Lisp Not Have a Generic Copy-List Function?</a></li>
<li><a href="http://xahlee.info/emacs/emacs/lisp_list_problem.html">Lisp List Problem</a></li>
</ul>

</section>

<section>

<h2>Frequently Asked Questions</h2>

<h4>If you don&#39;t like cons, lisp has arrays and hashmaps, too.</h4>

<p>Suppose there&#39;s a lang called gisp.
In gisp, there&#39;s cons but also fons.
Fons is just like cons except it has 3 cells with 3 accessors: car, cbr, cdr.
Now, gisp is a old lang, the fons are deeply rooted in the lang.
Every some 100 lines of code you&#39;ll see a use of fons with its extra accessor cbr, or any one of the cbaar, cdabr, cbbar, cbbbar, etc.
You got annoyed by this.
You complain that fons is bad.
But then some gisp fanatics retorts: “If you don&#39;t like fons, gisp has cons, too!”.</p>

<p>You see, by “having something too”, does not solve the problem of pollution.</p>

<h4>I like the cons concept. Even in functional languages like Haskell it is popular, for example, when matching in the form of (x:xs), which is the same like car/cdr in Lisp.</h4>

<p>Languages that have a list data type implemented as linked list, with First, Rest accessors, do not expose it as API in the same way lisp does with explicit cons.</p>

<p>Lisp&#39;s cons forces programer to think of list in a low-level nested of 2-item construction, with explicit functions like “cddr”, “cadaar” etc, and even a special notation “(A .
B)”.</p>

<p>This hinders the development tree functions.
For example, one might write a function that extracts the leafs of a binary tree.
But due to cons, there is no single data structure to implement a binary tree.
You can have the whole structure made of cons, or cons only for ending branches, or whole structure made of “proper list”.
Consequently, what&#39;s considered a leaf depends on your implementation, and the code to traverse the tree also depends on how you used cons.</p>

<p>Worse, any proper list can have improper list as elements.
So, you can have a list of cons, or cons of lists, cons of cons, list of lists, or any mix.
The overall effect of the cons is that it prevents lisp to have a uniform high level treatment of lists, with the result that development of functions that work on tree are inconsistent and few.</p>

<p>
2009-07-21 Addendum : there was actually a lang with “fons” of 3 cells. {Haines, E.
C., The TREET List Processing Language.
M.S.
Thesis, MIT, Cambridge, Mass., August 1964.
Also SR-133, The MITRE Corporation, Bedford, Mass., April 1965.} Thanks to <a href="https://en.wikipedia.org/wiki/Richard_Fateman" data-accessed="" target="_blank" rel="noreferrer">Richard Fateman</a> for alerting me to this.</p>

</section>

<section>

<h2>Why Lisp&#39;s Cons Problem Never Got Fixed?</h2>

<p>Now, a little speculation.</p>

<p>We might wonder, why lisp has the cons problem and was never addressed in Common Lisp or Scheme Lisp?</p>

<h2>Historical Necessity</h2>

<p>I guess at the time, 1960s and 1970s, the very fact that you could have a concept like a list in a lang and manipulate it as a unit, is a very advanced concept.
The list, being built up by hardware cons, is just something that is necessary for implementation for practical considerations.
(think for a moment what computers are like in the 1960s.)</p>

<p>Having data as a single manipulable object (list) didn&#39;t really become popular until the 1990s.
(notably due to Perl) And today, it is THE most important feature of high-level languages.
(e.g. Perl Python Ruby PHP JavaScript)</p>

<h2>Deep Nesting is Rare</h2>

<p>The lisp&#39;s cons, as a underlying primitive that builds lists, even though a bit cumbersome, but works just fine when data structure used is simple.
Even today, with all the Perl, Python, PHP, JavaScript etc langs that deal with lists, vast majority of list usage is just simple flat list, sometimes 2 level of nesting (list of list, list of hash, hash of list).
3 levels of nesting is seldom used, unless it is 3D matrices used mostly in computer graphics or linear algebra applications.
Greater than 3 level is rarely seen.
Systematic manipulation and exploitation of nested list, such as mapping to leafs, to particular level, transposition by permutation on level, or list structure pattern matching in today&#39;s functional langs, etc is hardly ever to be seen.
(These are common idioms in so-called array languages.
For example, APL, MATLAB, <a href="http://xahlee.info/M/index.html">Mathematica</a>.)</p>

<p>So, in general, when you just deal with simple lists, the cumbersomeness of using {cons, car, cdr, caardr, …} for list doesn&#39;t really surface.
Further, the cons is fundamentally rooted in the language.
It&#39;s not something that can be easily changed except creating a new language.
When there is a specific need in a application, there is a haphazard collection of functions that deal with lists at a higher level.</p>

<p>Today, with list manipulation being mainstream, especially with the
<a href="http://xahlee.info/UnixResource_dir/writ/new_langs.html">Proliferation of Programing Languages</a>, and with
<a href="http://xahlee.info/js/js.html">JavaScript</a>
arose
<a href="http://xahlee.info/comp/json_format.html">JSON</a>
, the lisp&#39;s cons historical baggage becomes more apparent and painful.</p>

<p>Summary of Reasons:</p>

<ul>
<li>Lisp&#39;s list being cons as part of the language was necessary for practical implementation in 1960, 1970s.</li>
<li>List as a unit in programing languages did not became popular until 1990s.</li>
<li>By then, the cons as a lang element is deeply rooted in lisp and it is hard to change other then as a new lang.</li>
<li>Most use of lists in programing tasks are just flat lists. Nesting of more than 3 levels is rarely used for typical programing tasks. So, the problem of cons did not surface.</li>
</ul>

</section>

<section>

<h2>Clojure Fixed the Lisp Cons Problem</h2>

<blockquote>

<p><code>cons</code>, <code>first</code> and <code>rest</code> manipulate sequence abstractions, not concrete cons cells</p>

<p>from: ❰2014-11-04 <x-link>http://clojure.org/lisps</x-link> ❱</p>

</blockquote>

</section>

<section>

<h2>Emacs Lisp Manual on Cons</h2>

<figure>
<img src="http://xahlee.info/comp/i/elisp_manual_list_2024-07-02.png" alt="elisp manual list 2024-07-02" width="713" height="824"/>
<figcaption>
elisp manual list 2024-07-02
</figcaption>
</figure>

<figure>
<img src="http://xahlee.info/comp/i/elisp_manual_list_diagram_2024-07-02.png" alt="elisp manual list diagram 2024-07-02" width="716" height="723"/>
<figcaption>
elisp manual list diagram 2024-07-02
</figcaption>
</figure>

</section>

</div></div>
  </body>
</html>
