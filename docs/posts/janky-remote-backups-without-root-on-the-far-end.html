<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/10/21/sb/">Original</a>
    <h1>Janky remote backups without root on the far end</h1>
    
    
<p>
Sometimes I do dumb things to solve my own problems.  This is one of 
those times.  In this case, I wanted something that would give me access 
to a block device on a physically distant machine for backup purposes.  
I didn&#39;t want to do anything particularly fancy on the distant box, so 
rootly powers are out of the question.  I just need disk space, a bit of 
bandwidth, and some CPU time every now and then.
</p>
<p>
Here&#39;s how it works.  Perhaps you have heard of &#34;nbd&#34; if you&#39;re in the 
Linux world.  It lets you load a kernel module on the client machine 
and then it&#39;ll turn a network type connection into a block device.  That 
is in fact right in the name: &#34;nbd&#34; equals &#34;network block device&#34;.  
Nice, right?
</p>
<p>
I wanted this, but didn&#39;t want it making a &#34;bare&#34; connection to the far 
end.  By default, it&#39;s just a plain old TCP session to the other side.  
While you can rig it to use TLS, there are a bunch of problems with 
this.  It means you need to leave a daemon running on the far end, and 
again, if you aren&#39;t root out there, that can be troublesome.  It means 
the distant host ends up stuck with a listening port, and that&#39;s not 
always nice.  It also forces you to deal with getting the whole 
certificate thing hooked up.  Hope you&#39;re good at wrangling OpenSSL.
</p>
<p>
This seemed wholly unnecessary to me.  I already have ssh access to the 
machines in question, so that right there will give me a relatively 
solid transport.  I just needed to convince the nbd stuff to use it.
</p>
<p>
Now, let you stop you right here: if you&#39;re saying &#34;SOCKS proxy&#34; and/or 
&#34;port forwarding&#34;, you have missed the part where I&#39;d rather not have a 
persistent daemon on the far end that&#39;s listening on some port, *even 
if* it&#39;s &#34;merely bound to loopback&#34;.  That&#39;s still something running as 
me that presents an unnecessary orifice to unwelcome visitors.  No 
thank you.
</p>
<p>
There&#39;s another way the nbd client can work: it will totally connect to 
a stream-style Unix domain socket.  As long as whatever is on the other 
end of that socket speaks the right language, it doesn&#39;t matter where it 
is or what it is.  Thus, I needed to make a Unix domain socket reach 
over the network to the other end of a ssh connection.
</p>
<p>
Here&#39;s what happened: I wrote some grungy plumbing stuff (my specialty) 
that sets up a Unix domain socket on my local machine.  It does it in a 
directory where only I can access it, and it waits for a connection.  
Once it gets one, it forks, and the child fires up a ssh to the far end 
to invoke the nbd server (a trivial userspace thing I can leave in my 
personal bin directory).
</p>
<p>
Meanwhile, the parent process of the client sticks around and fires up a 
pair of threads to do a bucket-brigade thing.  It takes any data from 
the Unix domain socket connection it just received and flings it at the 
ssh connection.  The other one does the reverse.
</p>
<p>
This keeps going until one of the fds shows up as disconnected, at which 
point it shuts down everything and exits politely.
</p>
<p>
The other part of this is a currently a bit of *local* rootly scripting 
madness which points the NBD client at that socket, then does the 
crypto gunk to attach it, then fscks it, mounts it, and fires up rsync.  
Then after it&#39;s done, it undoes everything and declares victory.
</p>
<p>
It&#39;s not meant to be fast, and it&#39;s definitely not meant to be 
beautiful, but it does work.  My only footprint on the far end is a 
giant blob of a file that is entirely meaningless to anyone without a 
suitable key.  The data is only ever seen in a usable form here on the 
client machine which already has access to the original data by 
definition.  I didn&#39;t have to install anything special on the far end, I 
don&#39;t have to run any daemons, and I didn&#39;t need root out there.
</p>
<p>
It&#39;s the type of thing that you can stand up and just let it run every 
now and then, kind of like Time Machine on a Mac.  You hope you never 
need to use it, but it&#39;s there if you really get stuck somehow.
</p>
<p>
So, yeah, when my part of CA &#34;falls into the ocean&#34;, I will bob up to 
the surface, swim to shore, and then walk to where my offsites are and 
restore from backups.  You know, that whole thing.
</p>
<p>
Just basic 
<a href="https://xkcd.com/705/">sysadmin stuff</a>.  Nothing fancy.
</p>

  </body>
</html>
