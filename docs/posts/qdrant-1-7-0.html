<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qdrant.tech/articles/qdrant-1.7.x/">Original</a>
    <h1>Qdrant 1.7.0</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<section>
<article>
<div>
<picture>
<source srcset="https://qdrant.tech/articles_data/qdrant-1.7.x/preview/title.webp" type="image/webp"/>
<img alt="Qdrant 1.7.0 has just landed!" src="https://qdrant.tech/articles_data/qdrant-1.7.x/preview/title.jpg"/>
</picture>
</div><p>Please welcome the long-awaited <a href="https://github.com/qdrant/qdrant/releases/tag/v1.7.0">Qdrant 1.7.0 release</a>. Except for a handful of minor fixes and improvements, this release brings some cool brand-new features that we are excited to share!
The latest version of your favorite vector search engine finally supports <strong>sparse vectors</strong>. That’s the feature many of you requested, so why should we ignore it?
We also decided to continue our journey with <a href="https://qdrant.tech/articles/vector-similarity-beyond-search/">vector similarity beyond search</a>. The new Discovery API covers some utterly new use cases. We’re more than excited to see what you will build with it!
But there is more to it! Check out what’s new in <strong>Qdrant 1.7.0</strong>!</p><ol>
<li>Sparse vectors: do you want to use keyword-based search? Support for sparse vectors is finally here!</li><li>Discovery API: an entirely new way of using vectors for restricted search and exploration.</li><li>User-defined sharding: you can now decide which points should be stored on which shard.</li><li>Snapshot-based shard transfer: a new option for moving shards between nodes.</li></ol><p>Do you see something missing? Your feedback drives the development of Qdrant, so do not hesitate to <a href="https://qdrant.to/discord">join our Discord community</a> and help us build the best vector search engine out there!</p><h2 id="new-features"><a aria-label="Anchor" data-anchorjs-icon="" href="#new-features"></a>New features</h2><p>Qdrant 1.7.0 brings a bunch of new features. Let’s take a closer look at them!</p><h3 id="sparse-vectors"><a aria-label="Anchor" data-anchorjs-icon="" href="#sparse-vectors"></a>Sparse vectors</h3><p>Traditional keyword-based search mechanisms often rely on algorithms like TF-IDF, BM25, or comparable methods. While these techniques internally utilize vectors, they typically involve sparse vector representations. In these methods, the <strong>vectors are predominantly filled with zeros, containing a relatively small number of non-zero values</strong>.
Those sparse vectors are theoretically high dimensional, definitely way higher than the dense vectors used in semantic search. However, since the majority of dimensions are usually zeros, we store them differently and just keep the non-zero dimensions.</p><p>Until now, Qdrant has not been able to handle sparse vectors natively. Some were trying to convert them to dense vectors, but that was not the best solution or a suggested way. We even wrote a piece with <a href="https://qdrant.tech/articles/hybrid-search/">our thoughts on building a hybrid search</a>, and we encouraged you to use a different tool for keyword lookup.</p><p>Things have changed since then, as so many of you wanted a single tool for sparse and dense vectors. And responding to this <a href="https://github.com/qdrant/qdrant/issues/1678">popular</a> <a href="https://github.com/qdrant/qdrant/issues/1135">demand</a>, we’ve now introduced sparse vectors!</p><p>If you’re coming across the topic of sparse vectors for the first time, our <a href="https://qdrant.tech/documentation/overview/vector-search/">Brief History of Search</a> explains the difference between sparse and dense vectors.</p><p>Check out the <a href="https://qdrant.tech/documentation/concepts/indexing/#sparse-vector-index">sparse vectors index docs</a> for more details on what this new index means for Qdrant users. Stay tuned for a full article with code examples on how to use sparse vectors in Qdrant!</p><h3 id="discovery-api"><a aria-label="Anchor" data-anchorjs-icon="" href="#discovery-api"></a>Discovery API</h3><p>The recently launched <a href="https://qdrant.tech/documentation/concepts/explore/#discovery-api">Discovery API</a> extends the range of scenarios for leveraging vectors. While its interface mirrors the <a href="https://qdrant.tech/documentation/concepts/explore/#recommendation-api">Recommendation API</a>, it focuses on refining the search parameters for greater precision.
The concept of ‘context’ refers to a collection of positive-negative pairs that define zones within a space. Each pair effectively divides the space into positive or negative segments. This concept guides the search operation to prioritize points based on their inclusion within positive zones or their avoidance of negative zones. Essentially, the search algorithm favors points that fall within multiple positive zones or steer clear of negative ones.</p><p>The Discovery API can be used in two ways - either with or without the target point. The first case is called a <strong>discovery search</strong>, while the second is called a <strong>context search</strong>.</p><h4 id="discovery-search"><a aria-label="Anchor" data-anchorjs-icon="" href="#discovery-search"></a>Discovery search</h4><p><em>Discovery search</em> is an operation that uses a target point to find the most relevant points in the collection, while performing the search in the preferred areas only. That is basically a search operation with more control over the search space.</p><p><img src="https://qdrant.tech/articles_data/qdrant-1.7.x/discovery-search.png" alt="Discovery search visualization"/></p><p>Please refer to the <a href="https://qdrant.tech/documentation/concepts/explore/#discovery-search">Discovery API documentation on discovery search</a> for more details and the internal mechanics of the operation.</p><h4 id="context-search"><a aria-label="Anchor" data-anchorjs-icon="" href="#context-search"></a>Context search</h4><p>The mode of <em>context search</em> is similar to the discovery search, but it does not use a target point. Instead, the <code>context</code> is used to navigate the <a href="https://arxiv.org/abs/1603.09320">HNSW graph</a> towards preferred zones. It is expected that the results in that mode will be diverse, and not centered around one point.
<em>Context Search</em> could serve as a solution for individuals seeking a more exploratory approach to navigate the vector space.</p><p><img src="https://qdrant.tech/articles_data/qdrant-1.7.x/context-search.png" alt="Context search visualization"/></p><h3 id="user-defined-sharding"><a aria-label="Anchor" data-anchorjs-icon="" href="#user-defined-sharding"></a>User-defined sharding</h3><p>Qdrant’s collections are divided into shards. A single <strong>shard</strong> is a self-contained store of points, which can be moved between nodes. Up till now, the points were distributed among shards by using a consistent hashing algorithm, so that shards were managing non-intersecting subsets of points.
The latter one remains true, but now you can define your own sharding and decide which points should be stored on which shard. Sounds cool, right? But why would you need that? Well, there are multiple scenarios in which you may want to use custom sharding. For example, you may want to store some points on a dedicated node, or you may want to store points from the same user on the same shard and</p><p>While the existing behavior is still the default one, you can now define the shards when you create a collection. Then, you can assign each point to a shard by providing a <code>shard_key</code> in the <code>upsert</code> operation. What’s more, you can also search over the selected shards only, by providing the <code>shard_key</code> parameter in the search operation.</p><div><pre tabindex="0" id="Y3NzI"><code data-lang="http"><span><span><span>POST /collections/my_collection/points/search
</span></span></span><span><span><span>{
</span></span></span><span><span><span>    &#34;vector&#34;: [0.29, 0.81, 0.75, 0.11],
</span></span></span><span><span><span>    &#34;shard_key&#34;: [&#34;cats&#34;, &#34;dogs&#34;],
</span></span></span><span><span><span>    &#34;limit&#34;: 10,
</span></span></span><span><span><span>    &#34;with_payload&#34;: true,
</span></span></span><span><span><span>}
</span></span></span></code></pre></div><p>If you want to know more about the user-defined sharding, please refer to the <a href="https://qdrant.tech/documentation/guides/distributed_deployment/#sharding">sharding documentation</a>.</p><h3 id="snapshot-based-shard-transfer"><a aria-label="Anchor" data-anchorjs-icon="" href="#snapshot-based-shard-transfer"></a>Snapshot-based shard transfer</h3><p>That’s a really more in depth technical improvement for the distributed mode users, that we implemented a new options the shard transfer mechanism. The new approach is based on the snapshot of the shard, which is transferred to the target node.</p><p>Moving shards is required for dynamical scaling of the cluster. Your data can migrate between nodes, and the way you move it is crucial for the performance of the whole system. The good old <code>stream_records</code> method (still the default one) transmits all the records between the machines and indexes them on the target node.
In the case of moving the shard, it’s necessary to recreate the HNSW index each time. However, with the introduction of the new <code>snapshot</code> approach, the snapshot itself, inclusive of all data and potentially quantized content, is transferred to the target node. This comprehensive snapshot includes the entire index, enabling the target node to seamlessly load it and promptly begin handling requests without the need for index recreation.</p><p>There are multiple scenarios in which you may prefer one over the other. Please check out the docs of the <a href="https://qdrant.tech/documentation/guides/distributed_deployment/#shard-transfer-method">shard transfer method</a> for more details and head-to-head comparison. As for now, the old <code>stream_records</code> method is still the default one, but we may decide to change it in the future.</p><h2 id="minor-improvements"><a aria-label="Anchor" data-anchorjs-icon="" href="#minor-improvements"></a>Minor improvements</h2><p>Beyond introducing new features, Qdrant 1.7.0 enhances performance and addresses various minor issues. Here’s a rundown of the key improvements:</p><ol>
<li>
<p>Improvement of HNSW Index Building on High CPU Systems <a href="https://github.com/qdrant/qdrant/pull/2869">pull request</a></p></li><li>
<p>Improving <a href="https://github.com/qdrant/qdrant/pull/2931">Search Tail Latencies</a>: Improvement for high CPU systems with many parallel searches, directly impacting the user experience by reducing latency</p></li><li>
<p><a href="https://github.com/qdrant/qdrant/pull/2768">Adding Index for Geo Map Payloads</a>: Index for geo map payloads can significantly improve search performance, especially for applications involving geographical data</p></li><li>
<p>Stability of Consensus on Big High Load Clusters: Enhancing the stability of consensus in large, high-load environments is critical for ensuring the reliability and scalability of the system (<a href="https://github.com/qdrant/qdrant/pull/3013">https://github.com/qdrant/qdrant/pull/3013</a>, <a href="https://github.com/qdrant/qdrant/pull/3026">https://github.com/qdrant/qdrant/pull/3026</a>, <a href="https://github.com/qdrant/qdrant/pull/2942">https://github.com/qdrant/qdrant/pull/2942</a>, <a href="https://github.com/qdrant/qdrant/pull/3103">https://github.com/qdrant/qdrant/pull/3103</a>, <a href="https://github.com/qdrant/qdrant/pull/3054">https://github.com/qdrant/qdrant/pull/3054</a>)</p></li><li>
<p>Configurable Timeout for Searches <a href="https://github.com/qdrant/qdrant/pull/2748">PR#2748</a>, <a href="https://github.com/qdrant/qdrant/pull/2771">PR#2771</a>: Allowing users to configure the timeout for searches provides greater flexibility and can help optimize system performance under different operational conditions.</p></li></ol><h2 id="release-notes"><a aria-label="Anchor" data-anchorjs-icon="" href="#release-notes"></a>Release notes</h2><p><a href="https://github.com/qdrant/qdrant/releases/tag/v1.7.0">Our release notes</a> are a place to go if you are interested in more details. Please remember that Qdrant is an open source project, so feel free to <a href="https://github.com/qdrant/qdrant/issues">contribute</a>!</p></article></section></div></div></div>
  </body>
</html>
