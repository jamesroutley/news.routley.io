<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmlabs.dev/articles/docker-without-containers/">Original</a>
    <h1>WebAssembly: Docker Without Containers</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This is a companion article to a <a href="https://youtu.be/yo30oF1Gflo?t=7361">talk about Docker+WebAssembly</a> that we gave at &#34;Docker Community All Hands 7, Winter Edition&#34; on Dec 15th, 2022.</p>
<h2 id="introduction" tabindex="-1">Introduction</h2>
<p>Recently Docker announced support for <a href="https://docs.docker.com/desktop/wasm/">WebAssembly</a> in cooperation with <a href="https://wasmedge.org/">WasmEdge</a>.</p>
<p>This article will explain what is WebAssembly, why it is relevant to the Docker ecosystem and provide some hands-on examples to try on. We assume you are familiar with the Docker tooling. We will be using our work on the <a href="https://wasmlabs.dev/articles/php-wasm32-wasi-port/">WebAssembly port of PHP</a> to demonstrate how to build a PHP interpreter, package it as part of an OCI image and run it using Docker.</p>
<p>Note that this article focuses on getting some hands-on experience rather than discussing technical details. You can either reproduce the examples below or just read through them till the end as we will also provide the output.</p>
<h2 id="webassembly---what%3F-and-why%3F" tabindex="-1">WebAssembly - What? and Why?</h2>
<p>This is a very basic introduction. If you are already familiar with the technology you can skip to the <a href="#the-hands-on-examples">next section</a>.</p>
<h3 id="what-is-webassembly%3F" tabindex="-1">What is WebAssembly?</h3>
<p>WebAssembly (or Wasm) is an open standard that defines a binary instruction format, which allows the creation of portable binary executables from different source languages.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/Wasm-all-browsers.webp" alt="Wasm is in all browsers"/></p>
<p>These binaries can run in a variety of environments. It has its origins in the web and is supported by all major browsers.</p>
<h3 id="how-does-wasm-work-in-browsers%3F" tabindex="-1">How does Wasm work in browsers?</h3>
<p>Browser engines integrate a Wasm virtual machine, usually called a Wasm runtime, which can run the Wasm binary instructions. There are compiler toolchains (like Emscripten) that can compile source code to the Wasm target. This allows for legacy applications to be ported to a browser and directly communicate with the JS code that runs in client-side Web applications.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/Wasm-in-a-browser.webp" alt="Wasm in a browser"/></p>
<p>These technologies have allowed traditional desktop apps to run in a browser. And now they can run on any device on which you have a browser. Some notable examples are <a href="https://earth.google.com/">Google Earth</a> and the <a href="https://opencv.org/">Open CV</a> library for computer vision.</p>
<h3 id="how-does-wasm-work-on-servers%3F" tabindex="-1">How does Wasm work on servers?</h3>
<p>There are Wasm runtimes that can run outside of the browser, including traditional operating systems such as Linux, Windows and macOS. Because they cannot rely on a JavaScript engine being available they communicate with the outside world using different interfaces, such as WASI, the <a href="https://wasi.dev">WebAssembly System Interface</a>. These runtimes allow Wasm applications to interact with their host system in a similar (but not quite the same) way as POSIX. Projects like WASI SDK and wasi-libc help people compile existing POSIX-compliant applications to WebAssembly.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/Wasm-server-side.webp" alt="Wasm on the server"/></p>
<p>You only need to compile an application into a Wasm module once, and then you can run the exact same binary everywhere.</p>
<h3 id="what&#39;s-great-about-wasm%3F" tabindex="-1">What&#39;s great about Wasm?</h3>
<p>Some of the features that make Wasm great in browsers also make it attractive for server-side development:</p>
<p>üåê Open - it is a standard widely adopted in the industry. In contrast to the browser wars of the past, major companies are collaborating for the standardization of WASI and WebAssembly applications.</p>
<p>üöÄ Fast - it can offer native-like speed via the JIT/AOT capabilities of most runtimes. No cold starts, unlike booting a VM or starting a container.</p>
<p>üîí Secure - the Wasm runtime is sandboxed by default and allows for safe access to memory. The capabilities-based model ensures that a Wasm application can access only what it is explicitly allowed to. There is better supply chain security.</p>
<p>üíº Portable - across the several major runtimes there is support for most CPUs (x86, ARM, RISC-V) and most OS-es including Linux, Windows, macOS, Android, ESXi, and even non-Posix ones.</p>
<p>üîã Efficient - Wasm applications can be made to run with minimal memory footprint and CPU requirements.</p>
<p>üó£Ô∏è Polyglot - 40+ languages can be compiled to Wasm, with modern, constantly improving toolchains.</p>
<h3 id="the-next-step-in-server-platform-evolution%3F" tabindex="-1">The next step in server platform evolution?</h3>
<p>You may have seen this <a href="https://twitter.com/solomonstre/status/1111004913222324225">quote</a> from Solomon Hykes (one of the co-founders of Docker):</p>
<blockquote>
<p>If WASM+WASI existed in 2008, we wouldn&#39;t have needed to create Docker. That&#39;s how important it is. WebAssembly on the server is the future of computing.</p>
</blockquote>
<p>Indeed, WASM+WASI does seem to be the next step in the evolution of server-side software infrastructure.</p>
<ul>
<li>Back in the day, we had physical hardware to work on. We would meticulously install OS-es and applications on each box and maintain them all one by one.</li>
<li>Then with the adoption of VMs, pioneered by VMware, things became easier. People could copy, clone and move VMs across hardware boxes. But that still kept the need to install OS-es and applications in VMs.</li>
<li>Then came containers, popularized by Docker, which made it easier to run application configurations in a minimalistic wrapping context, without affecting any other applications on the host OS. However, that still kept the need to distribute applications bundled with their runtimes and necessary libraries. The security boundary was provided by the Linux kernel</li>
<li>We now have WebAssembly. Its technical features and portability make it possible to distribute the application, without requiring shipping OS-level dependencies and can run with strict security constraints.</li>
</ul>
<p>Given all this, it is common for developers to take a look at WebAssembly as the &#39;successor&#39; to containers and the next logical step in infrastructure deployment.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/Wasm-server-platform-evolution.webp" alt="Wasm is the next step in the server platform evolution"/></p>
<p>However, another way of looking at WebAssembly is as an alternative &#39;backend&#39; for Docker tooling. You can use the same command line tools and workflows, but instead of using Linux containers, it is implemented using WebAssembly-based container equivalents. The rest of the article explores this concept and this is what we referred to with the &#34;Docker without containers&#34; title.</p>
<h3 id="how-does-wasm-work-with-docker%3F" tabindex="-1">How does Wasm work with Docker?</h3>
<p>Docker Desktop now includes support for WebAssembly. It is implemented with a containerd shim that can run Wasm applications using a Wasm runtime called <a href="https://github.com/WasmEdge/Wasmedge">WasmEdge</a>. This means that instead of the typical Windows or Linux containers which would run a separate process from a binary in the container image, you can now run a Wasm application in the WasmEdge runtime, mimicking a container.</p>
<p>As a result, the container image does not need to contain OS or runtime context for the running application - a single Wasm binary suffices.</p>
<p>This is explained in detail in Docker&#39;s <a href="https://www.docker.com/blog/docker-wasm-technical-preview/">Wasm technical preview article</a>.</p>
<h3 id="what-is-wasmedge%3F" tabindex="-1">What is WasmEdge?</h3>
<p><a href="https://github.com/WasmEdge/Wasmedge">WasmEdge</a> is a High-Performance WebAssembly Runtime that:</p>
<ul>
<li>Is Open Source, part of the <a href="https://cncf.io">CNCF</a>.</li>
<li>Supports all major CPU architectures (x86, ARM, RISC-V).</li>
<li>Supports all major Operating Systems (Linux, Windows, macOS) as well as others such as seL4 RTOS, Android.</li>
<li>Is Optimized for cloud-native and Edge applications.</li>
<li>Is Extensible and supports standards and emerging technologies
<ul>
<li>AI Inference with Tensorflow, OpenVINO, PyTorch</li>
<li>Async networking with Tokio. Supports microservices, database clients, message queues, etc.</li>
<li>Integrates seamlessly with containers ecosystem, Docker and Kubernetes (as shown in this article!)
¬†¬†‚Äã</li>
</ul>
</li>
</ul>
<h3 id="what-about-interpreted-languages%3F" tabindex="-1">What about interpreted languages?</h3>
<p>So far we have only mentioned compiled languages such as C and Rust can target WebAssembly. For interpreted languages such as Python, Ruby and PHP, the approach is different: their interpreters are written in C and can be compiled to WebAssembly. Then this interpreted compiled to Wasm can be used to execute the source code files, typically ending in .py, .rb, .php and so on. Once compiled to Wasm, any platform with a Wasm runtime will be able to run those interpreted languages even if the actual interpreter was never compiled for that platform natively.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/Wasm-server-side-interpreted.webp" alt="Wasm on the server for interpreted languages"/></p>
<h2 id="the-hands-on-examples" tabindex="-1">The hands-on examples</h2>
<p>Let&#39;s get started! In the hands-on examples, we will use the PHP interpreter compiled to Wasm. We will:</p>
<ul>
<li>Build a <a href="#building-a-wasm-container">Wasm container</a>.</li>
<li>Compare <a href="#native-vs-wasm">Wasm and native</a> binaries.</li>
<li>Compare <a href="#traditional-vs-wasm-containers">traditional and Wasm</a> containers.</li>
<li>Showcase <a href="#wasm-portability">Wasm&#39;s portability</a></li>
</ul>
<h2 id="prerequisites" tabindex="-1">Prerequisites</h2>
<p>If you want to reproduce the examples locally you will need to prepare your environment with some or all of the following:</p>
<ul>
<li>WASI SDK - to build WebAssembly applications from legacy C code</li>
<li>PHP - to run a native PHP binary for the sake of comparison</li>
<li>WasmEdge runtime - to run WebAssembly applications</li>
<li>Docker Desktop + Wasm (at the time of this writing, available as stable beta in <a href="https://docs.docker.com/desktop/release-notes/#4150">version 4.15</a>) to be able to run Wasm containers</li>
</ul>
<p>We are also leveraging the <a href="https://github.com/vmware-labs/webassembly-language-runtimes">&#34;Wasm Language Runtimes&#34;</a> repository, which provides ways to build the PHP interpreter as a WebAssembly application.</p>
<p>You can start by checking out the demo branch like this:</p>
<pre><code><span>git clone --depth=1 -b php-wasmedge-demo \</span></code></pre>
<h2 id="building-a-wasm-container" tabindex="-1">Building a Wasm container</h2>
<p>As a first example, we will showcase how to build a C-based application like the PHP interpreter.</p>
<p>The build uses WASI-SDK set of tools. It includes a clang compiler that can build to the wasm32-wasi target as well as wasi-libc which implements the basic POSIX system call interfaces on top of WASI. With WASI SDK we can build a Wasm module out of PHP&#39;s codebase, written in C. After that, it takes a very simple Dockerfile based on scratch for us to make an OCI image that can be run with Docker+Wasm.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/DockerWasm-Building.webp" alt="From C code to Wasm container"/></p>
<h3 id="building-a-wasm-binary" tabindex="-1">Building a WASM binary</h3>
<p>Assuming you are in the <code>wlr-demo</code> folder which you checked out as part of the prerequisites section you could run the following to build a Wasm binary.</p>
<pre><code><span>export WASI_SDK_ROOT=/opt/wasi-sdk/</span></code></pre>
<p>PHP is built with <em>autoconf</em> and <em>make</em>. So if you take a look at the <code>scripts/wl-build.sh</code> script you will notice that we set up all relevant variables like <code>CC</code>, <code>LD</code>, <code>CXX</code>, etc. to use the compiler from WASI_SDK.</p>
<pre><code><span>export</span> <span>WASI_SYSROOT</span><span>=</span><span>&#34;<span>${WASI_SDK_ROOT}</span>/share/wasi-sysroot&#34;</span></code></pre>
<p>Then, digging further into <code>php/php-7.4.32/wl-build.sh</code> you can see that we use the <em>autoconf</em> build process as usual.</p>
<pre><code>./configure <span>--host</span><span>=</span>wasm32-wasi <span>host_alias</span><span>=</span>wasm32-musl-wasi <span>\</span></code></pre>
<p>WASI is a work in progress and many of the POSIX calls still can not be implemented on top of it. So to build PHP we had to apply several patches on top of the original codebase.</p>
<p>We saw above that the output binaries go to <code>build-output/php/php-7.4.32</code>. In the following examples we will use the <code>php-wasmedge</code> binary that is specifically built for WasmEdge as it offers server-side socket support, which is not yet part of WASI.</p>
<h3 id="optimizing-the-binary" tabindex="-1">Optimizing the binary</h3>
<p>Wasm is a virtual instruction set so the default behavior of any runtime would be to interpret those instructions on the fly. Of course, this could make things slow in some cases. So to get the best of both worlds with WasmEdge you can create an AOT (ahead-of-time) optimized binary that runs natively on the current machine but can still be interpreted on other ones.</p>
<p>To create that optimized binary run the following:</p>
<pre><code><span>wasmedgec --enable-all --optimize 3 \</span></code></pre>
<p>We will use this <code>build-output/php/php-7.4.32/bin/php-wasmedge-aot</code> binary in the following examples. To get to know more about the WasmEdge AOT optimized binaries take a look <a href="https://wasmlabs.dev/articles/docker-without-containers/build-output/php/php-7.4.32/bin/php-wasmedge-aot">here</a>.</p>
<h3 id="building-the-oci-image" tabindex="-1">Building the OCI image</h3>
<p>Now that we have a binary, we can wrap it up in an OCI image.</p>
<p>Let&#39;s take a look at <code>images/php/Dockerfile.cli</code>. All we need to do is just copy the Wasm binary and set it as <code>ENTRYPOINT</code>.</p>
<pre><code><span><span>FROM</span> scratch</span></code></pre>
<p>We could also add more content to the image, which will be accessible to the Wasm binary when it is run by Docker. For example in <code>images/php/Dockerfile.server</code> we also add some docroot content to be served by <code>php.wasm</code> when the container starts.</p>
<pre><code><span><span>FROM</span> scratch</span></code></pre>
<p>Based on the above files we can easily build our <code>php-wasm</code> images locally.</p>
<pre><code><span>docker build --build-arg PHP_BINARY=php-wasmedge-aot -t ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot -f images/php/Dockerfile.cli .</span></code></pre>
<h2 id="native-vs-wasm" tabindex="-1">Native vs Wasm</h2>
<p>Now let&#39;s compare a native PHP binary with a Wasm binary. Both locally and in a Docker container. We will use the same <code>index.php</code> file and compare the results we get when running it with:</p>
<ul>
<li><code>php</code>,</li>
<li><code>php-wasmedge-aot</code>,</li>
<li><code>php</code> in a traditional container,</li>
<li><code>php-wasmedge-aot</code> in a Wasm container.</li>
</ul>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/DockerWasm-Running%20index.php.webp" alt="Running index.php"/></p>
<p>We will use the same <code>images/php/docroot/index.php</code> file in all of the below examples so let&#39;s take a look. In a nutshell, this script will:</p>
<ul>
<li>use <code>phpversion</code> and <code>php_uname</code> to show the interpreter version and the platform on which it is running</li>
<li>print the names of all environment variables that the script can access</li>
<li>print a hello message with the current time and date</li>
<li>list the contents of the root folder <code>/</code></li>
</ul>
<pre><code><span><span><span>&lt;</span>html</span><span>&gt;</span></span></code></pre>
<h3 id="native-php-running-index.js" tabindex="-1">Native PHP running index.js</h3>
<p>When we use the native <code>php</code> binary we see
a Linux-based platform</p>
<ul>
<li>a list of 58 environment variables that the script can access if it needs to</li>
<li>a list of all the files and folders in `/``, which again the script can access if it needs to</li>
</ul>
<pre><code>$ php -f images/php/docroot/index.php</code></pre>
<h3 id="php-aot-wasm-running-index.js" tabindex="-1">php-aot-wasm running index.js</h3>
<p>When we use the <code>php-aot-wasm</code> with Wasmedge we see</p>
<ul>
<li>a wasi/wasm32 platform</li>
<li>no environment variables, because non have been explicitly exposed to the Wasm application</li>
<li>the Wasm application was not given explicit access to <code>/</code> so attempts to list its contents failed with an error</li>
</ul>
<p>Naturally, for the <code>php-wasmedge-aot</code> to have access to read the <code>index.php</code> file we had to explicitly state to WasmEdge that we want to pre-open <code>images/php/docroot</code> for access as <code>/docroot</code> in the context of the Wasm application.</p>
<p>This easily shows one of the greatest benefits of Wasm apart from portability. We get better security because nothing is accessible unless explicitly stated.</p>
<pre><code>$ wasmedge --dir /docroot:$(pwd)/images/php/docroot \</code></pre>
<h3 id="php-in-a-container-running-index.js" tabindex="-1">PHP in a container running index.js</h3>
<p>When we use the <code>php</code> from a traditional container we see</p>
<ul>
<li>a wasi/wasm32 platform</li>
<li>no environment variables, because non have been explicitly exposed to the Wasm application</li>
<li>the Wasm application was not given explicit access to <code>/</code> so attempts to list its contents failed with an error</li>
</ul>
<p>There is already a difference for the better compared to running this with <code>php</code> on the host machine. As the environment variables and contents of <code>/</code> are &#34;virtual&#34; and exist only within the container.</p>
<pre><code>docker run --rm \</code></pre>
<h3 id="php-aot-wasm-in-a-container-running-index.js" tabindex="-1">php-aot-wasm in a container running index.js</h3>
<p>When we use the <code>php-aot-wasm</code> with Wasmedge we see</p>
<ul>
<li>a wasi/wasm32 platform</li>
<li>just 2 infrastructural environment variables, pre-set with the WasmEdge shim that is running within containerd</li>
<li>a list of all the files and folders in <code>/</code> within the container, which is explicitly pre-opened for access by the Wasm application (part of the logic in the WasmEdge shim)</li>
</ul>
<p>Note: If you are more observant you will see that to run a container out of this image we have to:</p>
<ul>
<li>explicitly state the runtime via <code>--runtime=io.containerd.wasmedge.v1</code>pass command line arguments to <code>php.wasm</code> directly, without including the binary itself. Scroll back above and see that we could explicitly write the full command with the traditional PHP container, including the <code>php</code> binary (not that it is necessary).</li>
</ul>
<p>As a final note, even with Docker, Wasm has tightened the security around running index.php, as far less is exposed to it.</p>
<pre><code>docker run --rm \</code></pre>
<h2 id="traditional-vs-wasm-containers" tabindex="-1">Traditional vs wasm containers</h2>
<p>We managed to build and run a Wasm binary, and run it as a container, too. We saw the difference in output between a Wasm and a traditional container and the advanced &#34;sandboxing&#34; that Wasm brings in. Let&#39;s take a look at what other differences between the two types of containers we can easily see.</p>
<p>First, we will run two daemon containers and see how we can interpret some stats about them. Then we will examine the differences in the container images.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/DockerWasm-Comparing%20containers.webp" alt="Comparing containers"/></p>
<h3 id="container-stats" tabindex="-1">Container stats</h3>
<p>Let&#39;s run two daemon containers - one from the traditional <code>php</code> image, and another from the <code>php-wasm</code> image.</p>
<pre><code><span>docker run --rm -d \</span></code></pre>
<pre><code><span>docker run --rm -d \</span></code></pre>
<p>If we look at <code>docker stats</code>, however, we will only see stats for the traditional container. This might change with time as Docker+Wasm is a beta feature. So, if one really wants to see what&#39;s going on one could monitor the control groups instead. Each traditional container gets its own control group as in <code>docker/ee44...</code>. On the other hand, Wasm containers are included as part of the <code>podruntime/docker</code> control group and one can indirectly observe their CPU or Memory consumption.</p>
<pre><code><span><span>$</span> <span>systemd-cgtop <span>-kP</span> <span>--depth</span><span>=</span><span>10</span></span></span></code></pre>
<h3 id="image-size" tabindex="-1">Image size</h3>
<p>First, exploring the images, we see that Wasm container images are much smaller than the traditional ones. Even the <code>alpine</code> version of the <code>php</code> container is bigger than the Wasm one.</p>
<pre><code><span><span>$</span> <span><span>docker</span> images</span></span></code></pre>
<p>This is expected because with Wasm we only need to add the executable binary inside the container, while with traditional containers we still need some basic libs and files from the OS on which the binary will be running.</p>
<p>This difference in size can be quite beneficial for the speed of pulling an image for the first time as well as for the space that images take in a local repository.</p>
<h2 id="wasm-portability" tabindex="-1">Wasm portability</h2>
<p>One of the best things about Wasm is its portability. Docker has made traditional containers the way to go when one wants a portable application. However, on top of the big image size, traditional containers are also bound to the architecture of the platform on which they run. Many of us have been through the ups and downs of having to build versions of our software that support different architectures and packaging those in different images for each architecture.</p>
<p>WebAssembly brings true portability to the picture. You can build a binary once and run it everywhere. As a testament to that portability, we have prepared several examples of running WordPress via the PHP interpreter which we built for WebAssembly.</p>
<p>PHP would serve WordPress when it&#39;s run as a standalone Wasm application. Just as well it could run in a Docker+Wasm container. Also, it could run in any application that embeds a Wasm runtime. In our example, this is apache httpd, which via mod_wasm can use Wasm applications as content handlers. Lastly, PHP.wasm can just as well run in a browser.</p>
<p><img src="https://wasmlabs.dev/static/images/articles/docker-without-containers/DockerWasm-WASM%20is%20portable.webp" alt="Comparing containers"/></p>
<h3 id="serving-wordpress-via-wasmedge" tabindex="-1">Serving WordPress via WasmEdge</h3>
<p>We have prepared a compact WordPress+Sqlite example for this demonstration. Since it&#39;s a part of the <code>ghcr.io/vmware-labs/php-wasm:7.4.32-server-wordpress</code> container image, let&#39;s first download it locally.</p>
<p>This command will just create a temporary container (pulling the image), copy the WordPress files into <code>/tmp/wp/docroot</code> and then remove the container.</p>
<pre><code><span>container_id=$(docker create ghcr.io/vmware-labs/php-wasm:7.4.32-server-wordpress) &amp;&amp; \</span></code></pre>
<p>Now that we have WordPress let&#39;s serve it with:</p>
<pre><code><span>wasmedge --dir /docroot:/tmp/wp/docroot \</span></code></pre>
<p>You can go to <a href="">http://localhost:8085</a> and enjoy WordPress served by a PHP Wasm interpreter.</p>
<h3 id="serving-wordpress-via-docker%2Bwasm" tabindex="-1">Serving WordPress via Docker+Wasm</h3>
<p>Naturally, with Docker, things are much simpler.</p>
<pre><code><span>docker run --rm --runtime=io.containerd.wasmedge.v1 \</span></code></pre>
<p>You can go to <a href="">http://localhost:8086</a> and enjoy WordPress served by a PHP Wasm interpreter, which this time runs in a Docker container.</p>
<h3 id="serving-wordpress-via-mod_wasm-in-apache-httpd" tabindex="-1">Serving WordPress via mod_wasm in Apache HTTPD</h3>
<p>Apache HTTPD is one of the most widely used HTTP servers. And now with mod_wasm it can also run WebAssembly applications. To avoid installing and configuring it locally we have prepared a container where we have Apache HTTPD, mod_wasm and WordPress.</p>
<pre><code><span>docker run -p 8087:8080 projects.registry.vmware.com/wasmlabs/containers/php-mod-wasm:wordpress</span></code></pre>
<p>You can go to <a href="">http://localhost:8087</a> and enjoy WordPress served by a PHP Wasm interpreter, which is loaded by mod_wasm within Apache HTTPD.</p>
<h3 id="serving-wordpress-directly-in-a-browser" tabindex="-1">Serving WordPress directly in a browser</h3>
<p>Just go to [https://wordpress.wasmlabs.dev] for an example. You will see a frame in which the PHP Wasm interpreter is rendering WordPress on the spot.</p>
<h2 id="conclusion" tabindex="-1">Conclusion</h2>
<p>Thank you for reading this article. It was a lot to digest, but we hope it was useful to understand the capabilities of WebAssembly and how it can work with your existing codebases and tools, including Docker. Looking forward to see what <em>you</em> build with Wasm!</p>
</div></div>
  </body>
</html>
