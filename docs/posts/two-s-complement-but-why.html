<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://michaelprouty.com/blog/programming/2022/08/18/twos-complement-but-why.html">Original</a>
    <h1>Two’s Complement, But Why?</h1>
    
    <div id="readability-page-1" class="page"><section>
  <a href="http://michaelprouty.com/"><i></i>
</a>
  <p>18 August 2022</p>
  <a href="">
    
  </a>
  <p>There are plenty of
descriptions of <a href="https://en.wikipedia.org/wiki/Two%27s_complement">what</a> two’s
complement is and how to derive it. But I wanted to understand <em>why</em> it makes
sense as a convention for representing negative integers in binary. So here goes:</p>

<p>Let’s pretend we’re designing a binary encoding for signed
integers from scratch. I’ll use a 3-bit encoding for brevity, but
the same ideas apply to 16-bit, 32-bit, etc.</p>

<p>With 3 bits, you have 8 binary code points to map integers onto:</p>

<table>
  <tbody>
    <tr>
      <td>000</td>
      <td>001</td>
      <td>010</td>
      <td>011</td>
      <td>100</td>
      <td>101</td>
      <td>110</td>
      <td>111</td>
    </tr>
  </tbody>
</table>

<p>Since we’re representing both positive and negative integers, we’ll want to
reserve half of the code points for negative numbers.</p>

<h3 id="which-half">Which half?</h3>

<p>It’s convenient to continue using the familiar unsigned integer encodings
for the first four code points:</p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>000</td>
      <td>0</td>
    </tr>
    <tr>
      <td>001</td>
      <td>1</td>
    </tr>
    <tr>
      <td>010</td>
      <td>2</td>
    </tr>
    <tr>
      <td>011</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>That means we’ll map negative integers into the upper half of codepoints
<em>somehow</em> :</p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100</td>
      <td>?</td>
    </tr>
    <tr>
      <td>101</td>
      <td>?</td>
    </tr>
    <tr>
      <td>110</td>
      <td>?</td>
    </tr>
    <tr>
      <td>111</td>
      <td>?</td>
    </tr>
  </tbody>
</table>

<h3 id="but-how">But how?</h3>

<h4 id="111">111</h4>

<p>There’s a quirk in binary addition where:</p>



<p>This is because we run out of bits for the final carry:</p>



<p>Surprisingly, we can use this bizarreness to derive our encoding for 111.
Remember that we haven’t assigned an integer mapping to 111 yet. So if we translate this
operation to decimal we get:</p>

<table>
  <tbody>
    <tr>
      <td>111 + 001 = 000</td>
      <td>→</td>
      <td>? + 1 = 0</td>
    </tr>
  </tbody>
</table>

<p>If we solve for ?, we can see that -1 is the integer mapping for 111 that
<strong>makes 3-bit addition isomorphic to decimal addition</strong>.</p>

<table>
  <tbody>
    <tr>
      <td>111 + 001 = 000</td>
      <td>? + 1 = 0</td>
    </tr>
    <tr>
      <td>111 + 001 = 000</td>
      <td><span>-1</span> + 1 = 0</td>
    </tr>
  </tbody>
</table>

<p>We can derive mappings for the rest of the negative codepoints using the same idea:</p>

<h4 id="110">110</h4>

<table>
  <tbody>
    <tr>
      <td>110 + 010 = 000</td>
      <td>? + 2 = 0</td>
    </tr>
    <tr>
      <td>110 + 010 = 000</td>
      <td><span>-2</span> + 2 = 0</td>
    </tr>
  </tbody>
</table>

<h4 id="101">101</h4>

<table>
  <tbody>
    <tr>
      <td>101 + 011 = 000</td>
      <td>? + 3 = 0</td>
    </tr>
    <tr>
      <td>101 + 011 = 000</td>
      <td><span>-3</span> + 3 = 0</td>
    </tr>
  </tbody>
</table>

<h4 id="100">100</h4>

<table>
  <tbody>
    <tr>
      <td>100 + 011 = 111</td>
      <td>? + 3 = -1</td>
    </tr>
    <tr>
      <td>100 + 011 = 111</td>
      <td><span>-4</span> + 3 = -1</td>
    </tr>
  </tbody>
</table>

<p><strong><em>or…</em></strong></p>

<table>
  <tbody>
    <tr>
      <td>100 + 111 = 011</td>
      <td>? + (-1) = 3</td>
    </tr>
    <tr>
      <td>100 + 111 = 011</td>
      <td><span>4</span> + (-1) = 3</td>
    </tr>
  </tbody>
</table>

<h3 id="result-twos-complement">Result: Two’s Complement</h3>

<p>The resulting mapping for negative integers happens to be two’s complement of
the corresponding positive integer representation.</p>

<table>
  <thead>
    <tr>
      <th>decimal</th>
      <th>binary</th>
      <th>2C(binary)</th>
      <th>→ decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>000</td>
      <td>000</td>
      <td>-0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>001</td>
      <td>111</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>010</td>
      <td>110</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>011</td>
      <td>101</td>
      <td>-3</td>
    </tr>
    <tr>
      <td>4</td>
      <td>100</td>
      <td>100</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>

<p>Note that the pattern holds for zero the because -0 is 0.</p>

<h3 id="note-on-100">Note on 100</h3>

<p>100 could be mapped to either 4 or -4 since both mappings are isomorphic to
decimal addition (see above).</p>

<p>It’s nicer to go with -4 because then each code point with the most significant
bit set will corresponds to a negative number.</p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span>1</span>11</td>
      <td>-1</td>
    </tr>
    <tr>
      <td><span>1</span>10</td>
      <td>-2</td>
    </tr>
    <tr>
      <td><span>1</span>01</td>
      <td>-3</td>
    </tr>
    <tr>
      <td><span>1</span>00</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>

  
  

</section></div>
  </body>
</html>
