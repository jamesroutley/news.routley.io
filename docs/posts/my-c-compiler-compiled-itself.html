<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/keyvank/30cc">Original</a>
    <h1>Show HN: My C compiler compiled itself</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><code>30cc</code> (Pronounced as <em>CCC</em>, because in the Persian language, the number 30 is pronounced as C) is a toy C compiler written in C, which is strong enough to compile itself ü§ù This was my first attempt in writing a self-hosting software! What is a self-hosting software?</p>
<ul dir="auto">
<li>Imagine <code>30cc</code> gets strong enough to be able to compile itself.</li>
<li>I will first compile <code>30cc</code> with <code>gcc</code> to get the <code>30cc</code> compiler&#39;s binary.</li>
<li>I will then use the <code>gcc</code>-generated <code>30cc</code> binary file to compile the <code>30cc</code> again.</li>
<li>I now have a <code>30cc</code>-compiled version of <code>30cc</code>, which I can use for further developing the compiler!</li>
<li>I can forget about <code>gcc</code>, as if it never existed! Beautiful hah? <code>30cc</code> is now all alive by itself!</li>
</ul>
<p dir="auto"><code>30cc</code> emits x86-64 assembly as its output. The outputs are totally unoptimized, but that&#39;s fine, the project aims to be educational.</p>

<ul dir="auto">
<li>You&#39;ll first need to bootstrap the compiler by running <code>make</code>. This will compile the 30cc compiler and store its binary in <code>a.out</code>.</li>
<li>Then run <code>./build.py</code>. This will use the bootstrapped 30cc-compiler to compile 30cc itself. It then again uses the 30cc-compiled compiler to compile 30cc once again. The final compiler is then stored as <code>./30cc</code>.</li>
<li>In the end, you will have 3 binary files which should all behave the same:
<ol dir="auto">
<li><code>a.out</code> which is the bootstrapped gcc-compiled version of 30cc</li>
<li><code>30cc_gcc</code> which is the output of gcc-compiled 30cc compiler, compiling the 30cc compiler</li>
<li><code>30cc</code> which is the output of 30cc-compiled 30cc compiler, compiling the 30cc compiler</li>
</ol>
</li>
</ul>
<p dir="auto">Running independent source-files through <code>make</code>:</p>
<div data-snippet-clipboard-copy-content="make run program=./examples/inp.c arguments=something"><pre><code>make run program=./examples/inp.c arguments=something
</code></pre></div>


<p dir="auto">To run tests use</p>
<div data-snippet-clipboard-copy-content="python scripts/test.py update"><pre><code>python scripts/test.py update
</code></pre></div>
<p dir="auto">Then check the output of the tests.</p>
<p dir="auto">If you are on mac use <code>./scripts/test_mac.sh</code> to run the tests in docker.</p>
</article></div></div>
  </body>
</html>
