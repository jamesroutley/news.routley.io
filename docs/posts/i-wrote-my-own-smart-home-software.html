<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://renato.athaydes.com/posts/writing-your-own-smarthome-manager.html">Original</a>
    <h1>I wrote my own smart home software</h1>
    
    <div id="readability-page-1" class="page"><div><h2>How I wrote my own Smart Home software</h2>

<p>
... using Lua and the incredibly lightweight Mako Server
</p>
<p>Written on Sun, 04 Jun 2023 23:26:00 +0000</p><p><img src="https://renato.athaydes.com/images/mako/smarthome-banner.jpg" alt="SmartHome Image"/></p>

<p>I’ve wanted to automate my home for a long time… having a background in industrial automation and software development, it felt like I was in a great position to be an early adopter.</p>

<p>However, every time I looked into it, I quickly gave up because of two main problems:</p>

<ul>
<li>the sheer complexity of it all.</li>
<li>prices.</li>
</ul>

<p>The complexity seems to be intentional on the part of most vendors. They tend to not make it clear whether their products work with any <em>controller</em> (if you’re completely new to home automation, don’t worry, we’ll see soon what this means), which software can be used, which devices are compatible with what…</p>

<p>Prices of <em>smart devices</em> have always been ridiculously high, at least one order of magnitude higher than their <em>dumb</em> counterpart. That’s understandable when a technology is still in its early days. But home automation solutions have now been around for a long time!</p>

<p>It’s about time smart home devices became more accessible. Well, they may still not be cheap, but finally, prices have gone down enough that I’ve finally decided to take the plunge and get myself a few smart <em>things</em> to start playing with!</p>

<p>I got a few power plugs, a motion sensor, a little button that can be programmed to do <em>whatever</em>, and a smart home controller to connect to it all.</p>

<blockquote>
<p>A smart home controller is a hub that connects to all sensors (e.g. thermometers, power consumption meters etc.)
and lets you get information about them, as well as control devices which can be
controlled (e.g. turn on lights, change their colors, open/close the curtains, water the garden etc.).</p>
</blockquote>

<p>I chose to buy an <a href="https://about.ikea.com/en/newsroom/2022/05/25/ikea-launches-dirigera-the-matter-ready-hub-for-smart-products-and-a-new-ikea-home-smart-app">IKEA Dirigera</a>
to start with because at least where I am, IKEA smart things are the cheapest by far! But also because IKEA’s smart home products use <a href="https://en.wikipedia.org/wiki/Zigbee">Zigbee</a>,
which is a widely used protocol for home automation, so I could easily migrate to another hub (another name for the controller that manages the <em>things</em>) at some point,
if desired (which I did, as we’ll see).</p>

<p>I also got a <a href="https://www.tapo.com/en/product/smart-light-bulb/tapo-l920-10/">Wifi light strip</a> from IP-Link for good measure (it’s pretty awesome!).</p>

<p>After learning how to use the apps (from IKEA and IP-Link), including integrating them with my <a href="https://store.google.com/en/product/nest_hub_2nd_gen">Google Nest Hub</a>, I was a little bit underwhelmed.
Even though it’s really cool to be able to say “hey Google, turn on the lights in the main bedroom”, and it just works(!),
there’s very little automation you can actually do beyond what’s achievable with good old dumb electronics because of all the limitations of the apps.</p>

<p><strong>What I really wanted was to be able to program my home, like I can program my software, well beyond what some manufacturer’s app allows me to.</strong></p>

<p>Thus started my chase for the perfect smart home software setup!</p>

<h3>The usual smart home software people use</h3>

<p>At first, I tried a few smart home automation servers which are normally the “obvious” choices for this kind of stuff.</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/openhab.png" alt="OpenHab Logo"/>
    </figure>
<p><a href="https://www.openhab.org/">OpenHAB</a> is a Java-based server which uses <a href="https://www.openhab.org/docs/developer/osgi/osgi.html">OSGi</a> for its plugin system, meaning it can load/unload plugins at runtime to support
an enormous amount of <a href="https://www.openhab.org/addons/">add-ons</a> for seemingly every smart home product.</p>

<p>Even though OpenHAB looks great, it’s a complex system. Understanding its concepts and how to configure a nice dashboard, install <em>things</em>, add automations is very time consuming, I believe (if I remember correctly) I spent a few days on it and
only managed to get one <em>thing</em> connected, and didn’t really get to the point where I had a working dashboard at all.</p>

<p>I also looked at what is probably the most popular smart home hobbyist server, <a href="https://www.home-assistant.io/">HomeAssistant</a>. It looks pretty, has an easier setup than OpenHAB, has a neat
<a href="https://www.home-assistant.io/skyconnect/">USB Dongle</a> that makes things even easier… but what put me off with HomeAssistant were two things: first, it’s based on Python. I have a strong aversion to Python
due to its horrendous package management history (we use dozens of languages at work, guess which language is the only one that causes build issues all the time?). It’s a nice language, but for things like
home automation, having build/dependencies problems is the absolute last thing I need.</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/home-assistant.png" alt="HomeAssistant Logo"/>
    </figure>
<p>The biggest problem with HomeAssistant, however, is its really overengineered setup for running on mini computers like the <a href="https://www.raspberrypi.org/">Raspberry Pi</a>, which was my goal.</p>

<p>The recommended way to run it is with a fleet of Docker containers (and they even tell you to install <a href="https://www.home-assistant.io/installation/raspberrypi">their own Linux distro</a>
to make sure all the large amounts of software you’ll need is managed more easily).</p>

<p>Just imagine for a second, you’re automating your house to do little things like turn on a light at a certain time… perhaps open the curtains
in the morning as your alarm sets off in the morning. Is the best solution we can come up with a bunch of Docker containers running on a custom Linux distro?</p>

<p>As with OpenHAB, this all felt way more complex and heavy than I was hoping for. And I couldn’t even find a way to use them to actually write <strong>code</strong> to perform automations the way I wanted, rather than limited
visual programming tools which seem to be the standard way of doing things in this world (no, thanks!).</p>

<h3>Raspbee 2 and deCONZ REST API</h3>
<figure>
    <img src="https://renato.athaydes.com/images/mako/raspbee2.jpg" alt="Raspbee2"/>
    </figure>
<p>That’s when I finally found something that made sense to me: the <a href="https://phoscon.de/en/raspbee2">Raspbee 2</a> Zigbee Gateway, which is a tiny circuit board you plug directly on the Raspberry Pi’s GIO plug
(they also have a USB dongle version).</p>

<p>You then connect to it using either their <a href="https://phoscon.de/en/raspbee2/software">simple web-based app</a> (useful to set it up) or the <a href="https://dresden-elektronik.github.io/deconz-rest-doc/">deCONZ REST API</a> they expose.</p>

<p>This is exactly what I am looking for!</p>

<p>Having full access to my smart things via a REST API would, after all, allow me to write code in whatever programming language I’d like.</p>

<p>The next challenge was to decide what stack to use to create a little web application I and my family could use to interact with the smart things… I wanted something extremely light so I could run it even on
an older Raspberry Pi 2 that I had lying around with low power consumption… also the less complex, the better chances are it will still be working 10 years from now, which I think is very important for something
that’ll become part of the house.</p>

<p>By chance, I found a solution which I didn’t expect at all (I work with Java, but wanted to avoid it as I know it’s far too memory-heavy and slow on small devices): <a href="https://www.lua.org/">Lua</a>.</p>

<h3>Why Lua?</h3>
<figure>
    <img src="https://renato.athaydes.com/images/mako/lua.jpg" alt="Lua Language Logo"/>
    </figure>
<p>Lua was designed to be embedded in C programs. It’s probably the lighest practical language you’ll find.</p>

<blockquote>
<p><a href="http://justine.lol/">Justine</a>’s <a href="https://redbean.dev/">Redbean</a> web server, which is an <a href="https://justine.lol/ape.html">αcτµαlly pδrταblε εxεcµταblε</a> that embeds Lua and SQLite and runs on most Operating Systems
(the same file!), is a mere 2.2 MB download and runs using less than 1MB of RAM.</p>
</blockquote>

<p>For this reason, I considered using Lua and was delighted to find out that there was a really lightweight web server made exactly for things like this: the <a href="https://makoserver.net/">Mako Server</a>.</p>

<p>The Mako Server is based on the <a href="https://barracudaserver.com/">Barracuda Application Server</a>, which was designed to work on embedded devices. <a href="https://realtimelogic.com/products/barracuda-application-server/?t=r">It supports</a>
VxWorks, QNX, Zephyr, FreeRTOS+TCP and lots of other OSs, including of course the mainstream ones, Linux/Windows/MacOS!</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/MakoLogo2.svg" alt="Mako Server Logo"/>
    </figure>
<p>Mako has a <a href="https://makoserver.net/download/raspberry-pi/">special download for the Raspberry Pi</a> which comes with support for using GPIO from Lua. I built it from source on my Pi and it only took a few seconds.</p>

<p>What is the most amazing is the amount of stuff packed into this tiny server: a HTTP Client, JSON/<a href="https://ubjson.org/">UBJSON</a> parser, SMTP, MQTT, TLS,
<a href="https://www.sqlite.org/index.html">SQLite</a>, and obviously, Lua and <a href="https://realtimelogic.com/products/lua-server-pages/">LSP</a> (Lua Server Pages) which makes it easy to generate web content.</p>

<p>The result is a web server that uses less than 3MB of RAM (even including the built-in Mako, Barracuda and Lua’s complete Docs, and a code editor for changing things on the fly) while running and that I can code live.</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/raspbee2-and-dirigera.jpg" alt="Lua Language Logo"/>
        <figcaption>The IKEA Dirigera (at the bottom) next to its likely replacement, a Raspberry Pi + Raspbee2.</figcaption>
    </figure>
<p>In the rest of this blog post, I’ll show how to get started with the Mako Server, and how to use it to talk to the deCONZ API to automate any smart home setup.</p>

<h2>Getting started with Mako</h2>

<p>The Mako Server does not really need to be <em>installed</em> on a system… it consists of just a single binary executable file and its companion <code>mako.zip</code> file which contains some Lua libraries and other resources.</p>

<p>Go to the <a href="https://makoserver.net/download/overview/">Download Mako Server</a> page and choose your platform on the menu for instructions on how to get it.</p>

<p>As I am going to be using a Raspberry Pi to run Mako, I chose the <a href="https://makoserver.net/download/raspberry-pi/">Raspberry Pi</a> section, which explains that Mako needs to be built on the Pi itself.</p>

<p>A lot of software is very complicated to build, but Mako is one of the easiest pieces of software I’ve ever built! So, don’t let this scare you!</p>

<p>Here are the exact steps of what I did, so you don’t even need to go anywhere if you’re also using a Pi to run Mako!</p>

<p>First thing you need to do, is make sure you have some really basic utilities installed on your system (and I am assuming a Debian-based Linux distribution, like Ubuntu or Mint).</p>

<p>Open up a terminal and run the following commands:</p>
<pre tabindex="0"><code><span><span>sudo apt update
</span></span><span><span>sudo apt install git unzip gcc make
</span></span><span><span>
</span></span><span><span>mkdir mako
</span></span><span><span><span>cd</span> mako
</span></span><span><span>wget -O build.sh - https://raw.githubusercontent.com/RealTimeLogic/BAS/main/RaspberryPiBuild.sh
</span></span></code></pre>
<p>I am deviating a little bit from the official instructions because I think it’s important to understand what’s happening… above, all we’ve done was create a new directory to install mako on, then downloaded a bash script into <code>build.sh</code> that runs the build.</p>

<p>On your text editor, have a look at that file and make sure you’re happy with what it’s doing… it’s a very simple build file, so you should be able to understand exactly what’s going to do.</p>

<p>Now, just execute the file.</p>
<pre tabindex="0"><code><span><span>chmod +x ./build.sh
</span></span><span><span>./build.sh
</span></span></code></pre>
<p>It should take a couple of minutes.</p>

<p>At the end, it should ask you if you want to _install the Mako server in <code>/usr/local/bin</code>, which is optional to do. If you accept that, it just copies both the <code>mako</code> executable and its companion, <code>mako.zip</code>, into <code>bin</code>:</p>
<pre tabindex="0"><code><span><span>renato@renato-desktop:~/mako$ du -h /usr/local/bin/*
</span></span><span><span>2,9M	/usr/local/bin/mako
</span></span><span><span>492K	/usr/local/bin/mako.zip
</span></span><span><span>180K	/usr/local/bin/periphery.so
</span></span></code></pre>
<p>The <code>periphery.so</code> file seems to be a Raspberry Pi specific library for controlling the GPIO.</p>

<p>That gives us a fully functional web server, with lots of functionality as we’ll find out, in less than 3.5MB!</p>

<p>Finally, you can run <code>mako</code> (or <code>./mako</code> if you didn’t <em>install</em> it) to start the server!</p>

<p>When Mako starts up, it prints the ports it’s listening to, so now you just need to open a browser and go to <code>localhost:&lt;port&gt;</code> to see the initial page:</p>



<p>Before we start writing some code, download the <code>tutorials.zip</code> file from the <a href="https://makoserver.net/documentation/manual/">Download Mako Server Documentation and Tutorials</a> page, or just run the following command:</p>
<pre tabindex="0"><code><span><span>wget https://makoserver.net/download/tutorials.zip
</span></span><span><span>unzip tutorials.zip
</span></span></code></pre>
<p>Now, you should have several zip files in the local directory, including <code>badoc.zip</code> (the Barracuda Server Full Documentation) and <code>lspappmgr.zip</code> (an Application Server, as we’ll see) amongst others. Each zip file is a Mako application.</p>

<p>Stop the server if you left it running, then start it up with both the docs and the application server apps by entering the following command:</p>
<pre tabindex="0"><code><span><span>mako -ldocs::badoc.zip -l::lspappmgr.zip
</span></span></code></pre>
<p>The <code>-l</code> option specifies:</p>

<ul>
<li>the path where to deploy the application (leave empty for default <code>/</code>).</li>
<li>the priority (higher priority apps can handle requests first).</li>
<li>the application zip (or a directory with the app files).</li>
</ul>

<p>So, the command above starts the <code>badoc.zip</code> app on path <code>docs</code>, and <code>lspappmgr.zip</code> on the default path.</p>

<p>You can now open the docs at (supposing the server is on port 9357) <code>http://localhost:9357/docs/</code>, and the application manager at <code>http://localhost:9357/</code>!</p>

<p>The <a href="https://realtimelogic.com/ba/doc/">Barracuda Documentation</a> is pretty comprehensive (it even includes the Lua docs and the various Lua libraries included by default, like <code>json</code>, <code>http</code>, <code>crypto</code> and many others), if a bit confusing at first as it includes a lot of details that won’t make sense until you’ve learned a little bit more about it. Having it running locally on your own server is great!</p>

<p>But to get directly into the action, open the application manager… you should see the following:</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/app_mngr_initial_page.png" alt="LSP Application Manager"/>
        <figcaption><p>LSP Application Manager</p>
</figcaption>
    </figure>
<p>This web application allows us to create, change and deploy LSP (Lua Server Pages) applications, even from another machine! For example, you can keep running the Mako Server on the Pi, but use your main computer to develop your code!</p>

<p>Just find out your Pi’s IP address (on Ubuntu, use <code>ip -4 a</code>), then connect to it from any other machine on the same network.</p>

<p>Now, to create a new application, click on the <code>New Application</code> button, choose where to store it by clicking on the <code>Browse</code> button and use the file picker to create a new directory using the mouse right-click (<code>home</code> is the working directory, <code>disk</code> is your Pi’s root file system). You could just pick an existing directory as well, of course. Double-click on the chosen directory to select it.</p>

<blockquote>
<p>There’s a <a href="https://www.youtube.com/watch?v=XkVQYJ-z7JA">video tutorial</a> about using the LSP App Manager, running it on a <a href="https://en.wikipedia.org/wiki/ESP32">tiny ESP32</a> microcontroller with 320 KiB RAM, 448 KiB ROM!</p>
</blockquote>

<p>I created a directory called <code>smarthome</code>, clicked on <code>Submit</code>, left the default values in the <code>Configure</code> scren and then clicked on <code>Submit</code> again. Check the video linked in the text box above if you need help.</p>

<p>At this point, you should see this screen:</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/app_mngr_apps_running.png" alt="LSP App Manager with apps running"/>
        <figcaption><p>LSP App Manager with apps running</p>
</figcaption>
    </figure>
<p>Flip the <code>Running</code> switch to start up the app, then hit <code>Edit</code>!</p>

<p>This opens up a really simple IDE where you can start coding!</p>
<figure>
    <img src="https://renato.athaydes.com/images/mako/app_mngr_ide.png" alt="LSP App Manager IDE"/>
        <figcaption><p>LSP App Manager IDE</p>
</figcaption>
    </figure>
<p>Open <code>index.lsp</code> file, which creates the initial page for our application, in the <code>Editor</code> tab.</p>

<p>It looks like this:</p>
<pre tabindex="0"><code><span><span><span>&lt;</span>!DOCTYPE html<span>&gt;</span>
</span></span><span><span><span>&lt;</span>html<span>&gt;</span>
</span></span><span><span>  <span>&lt;</span>head<span>&gt;</span>
</span></span><span><span>     <span>&lt;</span>meta charset<span>=</span><span>&#34;</span><span>UTF-8</span><span>&#34;</span><span>/&gt;</span>
</span></span><span><span>    <span>&lt;</span>title<span>&gt;</span>MY LSP<span>&lt;/</span>title<span>&gt;</span>
</span></span><span><span>  <span>&lt;/</span>head<span>&gt;</span>
</span></span><span><span>  <span>&lt;</span>body<span>&gt;</span>
</span></span><span><span>     <span>&lt;</span>?lsp
</span></span><span><span>       response:write(<span>&#39;</span><span>&lt;p&gt;</span><span>&#39;</span>, <span>&#34;</span><span>こんにちは世界</span><span>&#34;</span>, <span>&#39;</span><span>&lt;/p&gt;</span><span>&#39;</span>)
</span></span><span><span>       print<span>&#34;</span><span>Hello World</span><span>&#34;</span>
</span></span><span><span>       trace<span>&#34;</span><span>Hello World</span><span>&#34;</span>
</span></span><span><span>     ?<span>&gt;</span>
</span></span><span><span>  <span>&lt;/</span>body<span>&gt;</span>
</span></span><span><span><span>&lt;/</span>html<span>&gt;</span>
</span></span></code></pre>
<p>You can click on the <code>Run</code> button to see what it generates.</p>

<p>Notice that the code between <code>&lt;?lsp</code> and <code>?&gt;</code> is Lua code. That’s the <em>dynamic part</em> of the application. This allows us to use data from a database, fetch information from web APIs and anything else we may want, as the code is running on the <strong>server</strong> and therefore is not as restricted as web clients are.</p>

<blockquote>
<p>The code above shows the <code>response:write</code> (which is used to send content to the HTTP client), <code>print</code> (which does the same thing, but also <em>processes</em> values as the standard Lua function does) and <code>trace</code> (which is used to log server-side).
You can find these functions in the documentation, either by opening the <code>badoc.zip</code> app that comes with the tutorials zip file, or <a href="https://realtimelogic.com/ba/doc/">online</a>.</p>
</blockquote>

<p>Outside of the <code>&lt;?lsp ... ?&gt;</code> tag, everything is just normal HTML… but you can include simple Lua expressions within HTML like this:</p>
<pre tabindex="0"><code><span><span><span>&lt;</span>h2<span>&gt;</span>System: <span>&lt;</span>?lsp<span>=</span> ba.exec(<span>&#39;</span><span>uname -a</span><span>&#39;</span>) ?<span>&gt;&lt;/</span>h2<span>&gt;</span>
</span></span></code></pre>
<p><code>ba</code> is the Barracuda Application namespace, which contains lots of useful functionality… you can find its docs in the <a href="https://realtimelogic.com/ba/doc/">Barracuda Docs</a>, under <code>Lua &gt; APIs &gt; ba</code>… take the opportunity to check the standard APIs, like <code>request</code>, <code>response</code>, <code>cookie</code>, <code>session</code>, <code>io</code>, <code>json</code>, authentication/authorization, and the many <code>Auxiliary APIs</code> as well (stuff like <code>crypto</code>, <code>mail</code>, <code>socket</code>, <code>thread</code> is there)!!</p>

<blockquote>
<p>If you like to use REPLs, you can download <a href="https://makoserver.net/download/overview/">xlua (at the end of this page)</a>, which is an enhanced Lua REPL including most Mako’s Lua APIs.</p>
</blockquote>

<h3>The <code>.preload</code> script and Lua modules</h3>

<p>You may have noticed that, in the default IDE app, there’s another file besides <code>index.lsp</code>, called <code>.preload</code>.
This is a Lua file that runs whenever the application starts up. It can be used to setup the application, read configuration and so on.</p>

<blockquote>
<p>Files or directories that start with a <code>.</code> are hidden, and hence cannot be accessed from outside the server. Anything else can! For example, navigate to <code>/smarthome/index.lsp</code> on your server and you should see the rendered LSP page (and because this page is named <code>index</code>, just going to <code>/smarthome/</code> should also show that).</p>
</blockquote>

<p>If you change the <code>.preload</code> file, you need to save it and then restart your application to re-run it, which you can do by pressing the <code>Restart</code> button.</p>

<p>One thing you probably want to do in <code>.preload</code> is call <a href="https://realtimelogic.com/ba/doc/?url=Mako.html#mako_createloader"><code>mako.createloader(io)</code></a>.
This allows the Lua code to <code>require</code> other Lua files from the application itself (in addition to the standard Lua search path).</p>

<p>To demonstrate that, create a new file in the application folder at <code>.lua/devices.lua</code> with the following contents:</p>
<pre tabindex="0"><code><span><span><span>-- use a module namespace</span>
</span></span><span><span><span>local</span> dv <span>=</span> {}
</span></span><span><span>
</span></span><span><span><span>function</span> <span>dv</span>.<span>isOn</span>(device)
</span></span><span><span>   <span>return</span> device.attributes.isOn <span>and</span> <span>true</span> <span>or</span> <span>false</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>return</span> dv
</span></span></code></pre>
<p>This function is just a basic example (based on the Dirigera API which I was trying to use early on), so don’t read too much into it.</p>

<p>Now, in <code>index.lsp</code>, do something like this (showing only the Lua code in most LSP snippets):</p>
<pre tabindex="0"><code><span><span><span>local</span> dv <span>=</span> require <span>&#39;</span><span>devices</span><span>&#39;</span>
</span></span><span><span>
</span></span><span><span><span>local</span> mockDevice <span>=</span> {
</span></span><span><span>    attributes <span>=</span> { isOn <span>=</span> <span>true</span> }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>print(<span>&#39;</span><span>Is device on?</span><span>&#39;</span>, dv.isOn(mockDevice))
</span></span></code></pre>
<p>You should see the <code>Is device on? true</code> output.</p>

<blockquote>
<p>Once <code>require</code>d, Lua does not normally reload a module.
To force Lua to do so when you make changes to the module,
add this line, where <code>&#34;device&#34;</code> is the name of the module to <em>unload</em>,
to the beginning of the <code>.preload</code> script,
then restart the application: <code>package.loaded[&#34;devices&#34;] = nil</code>.</p>
</blockquote>

<h3>Breaking up pages into separate files</h3>

<p>To make web pages easy to manage, it’s a good idea to break out some common parts, like headers and footers, into their own pages,
which can then be included in other pages as needed.</p>

<p>To do that is easy, thanks to <code>response:include</code>.</p>

<p>I’ve created a directory called <code>.fragments/</code> (starting with a <code>.</code> so it won’t be served directly by the server) containing the following files in it:</p>

<p><code>header.html</code>:</p>
<pre tabindex="0"><code><span><span><span>&lt;!DOCTYPE html&gt;</span>
</span></span><span><span>&lt;<span>html</span>&gt;
</span></span><span><span>&lt;<span>head</span>&gt;
</span></span><span><span>  &lt;<span>meta</span> <span>charset</span><span>=</span><span>&#34;UTF-8&#34;</span>/&gt;
</span></span><span><span>  &lt;<span>title</span>&gt;SmartHome&lt;/<span>title</span>&gt;
</span></span><span><span>  &lt;<span>link</span> <span>rel</span><span>=</span><span>&#34;stylesheet&#34;</span> <span>href</span><span>=</span><span>&#34;/smarthome/style.css&#34;</span>&gt;
</span></span><span><span>&lt;/<span>head</span>&gt;
</span></span><span><span>&lt;<span>body</span>&gt;
</span></span><span><span>&lt;<span>header</span> <span>class</span><span>=</span><span>&#39;top-header&#39;</span>&gt;
</span></span><span><span>    My SmartHome
</span></span><span><span>&lt;/<span>header</span>&gt;
</span></span><span><span>&lt;<span>main</span>&gt;
</span></span></code></pre>
<p><code>footer.html</code>:</p>
<pre tabindex="0"><code><span><span>&lt;/<span>main</span>&gt;
</span></span><span><span>&lt;/<span>body</span>&gt;
</span></span><span><span>&lt;/<span>html</span>&gt;
</span></span></code></pre>
<p>I also added the linked <code>style.css</code> file in the application root dir so the page looks half decent:</p>
<pre tabindex="0"><code><span><span><span>main</span> {
</span></span><span><span>  <span>margin</span>: <span>2</span><span>em</span>;
</span></span><span><span>  <span>font-family</span>: Verdana, <span>sans-serif</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>.<span>top-header</span> {
</span></span><span><span>  <span>font-size</span>: <span>3</span><span>em</span>;
</span></span><span><span>  <span>background</span>: <span>#0D6986</span>;
</span></span><span><span>  <span>color</span>: <span>white</span>;
</span></span><span><span>  <span>margin</span>: <span>0</span>;
</span></span><span><span>  <span>padding</span>: <span>1</span><span>em</span>;
</span></span><span><span>  <span>font-family</span>: <span>&#39;Brush Script MT&#39;</span>, <span>cursive</span>;
</span></span><span><span>  <span>font-style</span>: <span>italic</span>;
</span></span><span><span>}
</span></span></code></pre>
<p>Now, to build a full page (e.g. <code>index.lsp</code>) is simple, just include the header and the footer, and add some content in the middle:</p>
<pre tabindex="0"><code><span><span><span>&lt;</span>?lsp
</span></span><span><span>response:include <span>&#34;</span><span>/smarthome/.fragments/header.html</span><span>&#34;</span>
</span></span><span><span>response:write(<span>&#39;</span><span>&lt;h1&gt;My Page goes here!&lt;/h1&gt;</span><span>&#39;</span>)
</span></span><span><span>response:include <span>&#34;</span><span>/smarthome/.fragments/footer.html</span><span>&#34;</span>
</span></span><span><span>?<span>&gt;</span>
</span></span></code></pre>
<p>Which should look like this:</p>



<p>Adding another page that uses the same headers and footers now becomes trivial.</p>

<h3>Directory functions, routing</h3>

<p>To visit the page <code>hello.lsp</code> in our application, which was started at the <code>/smarthome/</code> path, you would just type <code>http://&lt;ip-address&gt;/smarthome/hello.lsp</code>. That works well, but sometimes it’s useful to handle a URI path using a handler function that decides what to do, instead of just mapping to exact pages, like in a file system.</p>

<p>For example, in a Smart Home web application, we’ll need to have some dynamic content so we may want to implement an API that allows Javascript code running on the client to update data without refreshing the page.</p>

<p>Directory functions allow us to do just that.</p>

<p>We can install a directory function in the <code>.preload</code> file, as shown below:</p>
<pre tabindex="0"><code><span><span><span>local</span> <span>function</span> <span>handleApiCall</span>(_ENV, path)
</span></span><span><span>   paths <span>=</span> string.gmatch(path, <span>&#34;</span><span>([%w_-]+)(/?)</span><span>&#34;</span>)
</span></span><span><span>   response:forward(<span>&#34;</span><span>/smarthome/.api.lsp</span><span>&#34;</span>)
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>local</span> apiDir <span>=</span> ba.create.dir(<span>&#34;</span><span>api</span><span>&#34;</span>)
</span></span><span><span>apiDir:setfunc(handleApiCall)
</span></span><span><span>dir:insert(apiDir, <span>true</span>)
</span></span></code></pre>
<p>This will send requests for any path like <code>/&lt;app-root&gt;/api/*</code> to the <code>.api.lsp</code> page.
This example makes the <code>paths</code> segments available to that page as a page-global variable.</p>

<p>The <code>.api.lsp</code> page can then do whatever it wants with that:</p>
<pre tabindex="0"><code><span><span><span>&lt;</span>?lsp
</span></span><span><span>response:setheader(<span>&#34;</span><span>Content-type</span><span>&#34;</span>, <span>&#34;</span><span>text/plain</span><span>&#34;</span>)
</span></span><span><span><span>for</span> p <span>in</span> paths <span>do</span>
</span></span><span><span>  print(<span>&#39;</span><span>path segment:</span><span>&#39;</span>, p)
</span></span><span><span><span>end</span>
</span></span><span><span>?<span>&gt;</span>
</span></span></code></pre>
<p>Sending a HTTP request to <code>http://192.168.1.77:9357/smarthome/api/foo/bar</code> should now result in the following response:</p>
<pre tabindex="0"><code><span><span>HTTP/1.1 200 OK
</span></span><span><span>Date: Thu, 23 Mar 2023 18:50:08 GMT
</span></span><span><span>Server: BarracudaServer.com (Posix)
</span></span><span><span>Content-type: text/plain
</span></span><span><span>Transfer-Encoding: chunked
</span></span><span><span>Keep-Alive: Keep-Alive
</span></span><span><span>
</span></span><span><span>path segment:	foo
</span></span><span><span>path segment:	bar
</span></span></code></pre>
<p>We could as easily return JSON content (notice that by using the <code>response:json</code> function we don’t even need to set the <code>content-type</code> header):</p>
<pre tabindex="0"><code><span><span><span>&lt;</span>?lsp
</span></span><span><span><span>local</span> data <span>=</span> {}
</span></span><span><span><span>for</span> p <span>in</span> paths <span>do</span>
</span></span><span><span>  table.insert(data, p)
</span></span><span><span><span>end</span>
</span></span><span><span>response:json({ data <span>=</span> data })
</span></span><span><span>?<span>&gt;</span>
</span></span></code></pre>
<p>Now, a HTTP request to <code>http://192.168.1.77:9357/smarthome/api/foo/bar</code> results in:</p>
<pre tabindex="0"><code><span><span>HTTP/1.1 200 OK
</span></span><span><span>Date: Thu, 23 Mar 2023 18:55:28 GMT
</span></span><span><span>Server: BarracudaServer.com (Posix)
</span></span><span><span>Content-Length: 22
</span></span><span><span>Content-Type: application/json
</span></span><span><span>Cache-Control: no-store, no-cache, must-revalidate, max-age=0
</span></span><span><span>Keep-Alive: Keep-Alive
</span></span><span><span>
</span></span><span><span>{&#34;data&#34;:[&#34;foo&#34;,&#34;bar&#34;]}
</span></span></code></pre>
<p>This means we’re able to both build HTML pages and generate typical JSON API responses from the server, making it easy to create a dynamic web application.</p>

<h3>Authentication</h3>

<p>I do not intend for my home automation server to be accessible on the Internet. That’s far too risky.</p>

<blockquote>
<p>It may be a good idea to configure a <a href="https://en.wikipedia.org/wiki/Virtual_private_network">VPN</a> or
similar solution to safely access a home network from the Internet.
That is much easier to do safely than to expose any web server directly to the Internet.</p>
</blockquote>

<p>However, letting anyone who happens to be able to connect to my Wifi to manage my houses devices also doesn’t sound ideal, so I think it’s prudent to
add a simple authentication mechanism to the server.</p>

<p>Luckily, Mako supports several authentication methods (see the <code>Authentication</code> section in the docs).</p>

<p>To activate authentication, however, you’ll also need to enable HTTPS.</p>

<p>You may have noticed that the Mako server automatically generated a TLS Certificate the first time it started up.</p>

<p>Here’s the message it printed:</p>
<pre tabindex="0"><code><span><span>renato@renato-desktop:~/mako$ mako
</span></span><span><span>
</span></span><span><span>Mako Server. Version 3.9
</span></span><span><span>BAS lib 5412. Build date: Mar <span>20</span> <span>2023</span>
</span></span><span><span>Copyright <span>(</span>c<span>)</span> Real Time Logic.
</span></span><span><span>
</span></span><span><span>EPOLL dispatcher; maxcon: <span>262144</span>
</span></span><span><span>Mounting /usr/local/bin/mako.zip
</span></span><span><span>Server listening on IPv6 port <span>9357</span>
</span></span><span><span>Server listening on IPv4 port <span>9357</span>
</span></span><span><span>Loading certificate MakoServer
</span></span><span><span>SharkSSL server listening on IPv6 port <span>9443</span>
</span></span><span><span>SharkSSL server listening on IPv4 port <span>9443</span>
</span></span></code></pre>
<p><code>SharkSSL</code> is the TLS library included in the Mako Server. As you can see, it generated a TLS certificate and started listening on port 9443 using a secure socket.</p>

<blockquote>
<p>Mako has support for generating TLS Certificates using <code>Let&#39;s Encrypt</code>, see the section <code>Mako Server &gt; mako.conf &gt; Let&#39;s Encrypt</code> in the Documentation
for more details.</p>
</blockquote>

<p>Opening <code>https://&lt;ip-address&gt;:9443/</code> on a browser should result in a warning page saying that the TLS certificate cannot be trusted. That’s ok, because the TLS certificate the server is using is not trusted by the browser yet.</p>

<p>There are ways to trust your self-signed TLS certificate in your devices, but doing that is out of scope for this blog post.</p>

<p>I ended up not completely finishing setting up either authentication or TLS for now because I kind of ran out of time. I got just far enough to know that I can add that later when I have more time.</p>

<p>The next step is to actually <em>talk</em> with the smart devices, so we can display and send them commands.</p>

<h3>HTTP Client</h3>

<p>I currently have three kinds of smart home devices: ZigBee devices connected through the IKEA Dirigera Hub, “independent” ZigBee devices, and a couple of Wifi light strips.</p>

<p>Unfortunately, talking to the Wifi devices requires going through their manufacturer’s APIs. Google Home/Apple SmartKit/Amazon Alexa are able to interact with them via their APIs but they do not make it easy for anyone else.</p>

<blockquote>
<p>TP-Link <a href="https://www.home-assistant.io/blog/2020/11/23/tplink-local-access/">seems to be actively hostile</a> to third-party integrations like Home Assistant.</p>
</blockquote>

<p>The IKEA ZigBee devices talk the standard ZigBee protocol, so it’s possible to enlist them to the Raspbee 2 hub, making the Dirigera Controller unnecessary. That’s what I ended up doing (though I still haven’t moved everything off the Dirigera yet, as by doing that I temporarily lose integration with the Google’s voice assistant, which is a must at home).</p>

<p>The deCONZ API is easy to use. The Lua HTTP Client even easier, as I’ll show below!</p>

<p>To make HTTP calls to the Raspbee 2 you need to obtain the API key first. The <a href="https://dresden-elektronik.github.io/deconz-rest-doc/getting_started/#acquire-an-api-key">deCONZ docs</a>
explain how to do that. Once you got it, the URLs for accessing the devices’ data looks like this:</p>
<pre tabindex="0"><code><span><span><span>local</span> conf <span>=</span> require <span>&#34;</span><span>loadconf</span><span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span>local</span> sensorsUrl <span>=</span> conf.sensorsServerUrl <span>..</span> <span>&#34;</span><span>/api/</span><span>&#34;</span> <span>..</span> conf.deconzKey <span>..</span> <span>&#34;</span><span>/sensors/</span><span>&#34;</span>
</span></span><span><span><span>local</span> lightsUrl <span>=</span> conf.sensorsServerUrl <span>..</span> <span>&#34;</span><span>/api/</span><span>&#34;</span> <span>..</span> conf.deconzKey <span>..</span> <span>&#34;</span><span>/lights/</span><span>&#34;</span>
</span></span><span><span><span>local</span> metadataUrl <span>=</span> conf.sensorsServerUrl <span>..</span> <span>&#34;</span><span>/api/</span><span>&#34;</span> <span>..</span> conf.deconzKey <span>..</span> <span>&#34;</span><span>/config</span><span>&#34;</span>
</span></span></code></pre>
<p>The <a href="https://realtimelogic.com/ba/doc/en/Mako.html#loadconf"><code>loadconf</code> module</a> is part of Mako and allows easy access to the <code>mako.conf</code> file, which I used to store the API key and the location of the deCONZ server.</p>

<p>Here’s what my basic HTTP requests look like:</p>
<pre tabindex="0"><code><span><span><span>local</span> <span>function</span> <span>readJsonResponse</span>(req)
</span></span><span><span>   <span>local</span> status <span>=</span> req:status()
</span></span><span><span>   <span>local</span> body <span>=</span> req:read <span>&#34;</span><span>*a</span><span>&#34;</span>
</span></span><span><span>   <span>if</span> status <span>==</span> <span>200</span> <span>then</span>
</span></span><span><span>      <span>if</span> string.match(req:header()[<span>&#39;</span><span>Content-Type</span><span>&#39;</span>] <span>or</span> <span>&#39;</span><span>&#39;</span>, <span>&#39;</span><span>application/json</span><span>&#39;</span>) <span>then</span>
</span></span><span><span>         <span>return</span> ba.json.decode(body), <span>nil</span>
</span></span><span><span>      <span>else</span>
</span></span><span><span>         <span>return</span> <span>nil</span>, string.format(<span>&#39;</span><span>not a JSON response: %s</span><span>&#39;</span>, body)
</span></span><span><span>      <span>end</span>
</span></span><span><span>   <span>end</span>
</span></span><span><span>   <span>return</span> <span>nil</span>, string.format(<span>&#39;</span><span>bad status (%d): %s</span><span>&#39;</span>, status, body)
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>local</span> <span>function</span> <span>getJsonData</span>(url)
</span></span><span><span>   <span>local</span> req <span>=</span> http.create()
</span></span><span><span>   <span>local</span> ok, err <span>=</span> req:request { url <span>=</span> url }
</span></span><span><span>   <span>local</span> data
</span></span><span><span>   <span>if</span> ok <span>then</span>
</span></span><span><span>      data, err <span>=</span> readJsonResponse(req)
</span></span><span><span>   <span>end</span>
</span></span><span><span>   req:close()
</span></span><span><span>   <span>return</span> data, err
</span></span><span><span><span>end</span>
</span></span></code></pre>
<h3>WebSockets</h3>

<p>It’s quite nice to be able to update the web application as events happen… For example, if you have motion sensors in the house, you probably expect to see when it detects
movement in real time.</p>

<p>The <a href="https://dresden-elektronik.github.io/deconz-rest-doc/endpoints/websocket/">deCONZ API exposes websockets</a> for that.</p>

<p>From Mako, it’s also very easy to connect to a websocket:</p>
<pre tabindex="0"><code><span><span><span>function</span> <span>deconz</span>.<span>connectWebSocket</span>(notifier)
</span></span><span><span>   <span>local</span> server <span>=</span> wsServer <span>..</span> <span>&#39;</span><span>:</span><span>&#39;</span> <span>..</span> tostring(findWsPort())
</span></span><span><span>   <span>local</span> req <span>=</span> http.create()
</span></span><span><span>   <span>local</span> ok, err <span>=</span> req:request { url <span>=</span> server }
</span></span><span><span>   <span>if</span> <span>not</span> ok <span>then</span> req:close(); error(err) <span>end</span>
</span></span><span><span>   <span>if</span> req:status() <span>~=</span> <span>101</span> <span>then</span>
</span></span><span><span>      trace(<span>&#34;</span><span>deCONZ server responded with unexpected status: </span><span>&#34;</span>, req:status())
</span></span><span><span>      req:close()
</span></span><span><span>      error(<span>&#34;</span><span>deCONZ server did not open websocket: </span><span>&#34;</span> <span>..</span> server)
</span></span><span><span>   <span>end</span>
</span></span><span><span>   <span>local</span> sock <span>=</span> ba.socket.http2sock(req)
</span></span><span><span>   sock:event(<span>function</span>(s)
</span></span><span><span>         <span>while</span> <span>true</span> <span>do</span>
</span></span><span><span>            <span>local</span> data <span>=</span> s:read()
</span></span><span><span>            <span>if</span> <span>not</span> data <span>then</span> <span>break</span> <span>end</span>
</span></span><span><span>            notifier(ba.json.decode(data))
</span></span><span><span>         <span>end</span>
</span></span><span><span>         trace <span>&#39;</span><span>deCONZ Websocket terminated</span><span>&#39;</span>
</span></span><span><span>   <span>end</span>)
</span></span><span><span><span>end</span>
</span></span></code></pre>
<p>On the JavaScript side in my frontend, I also had to connect to a websocket which kept the frontend up-to-date when the deCONZ websocket pushed events. It sounds complicated, but it’s pretty simple,
it’s just two websockets, one between the server and deCONZ, and another between the JS client and the server…</p>

<p>To handle a websocket from the JS client requires some odd code in the LSP page where you want the websocket to connect:</p>
<pre tabindex="0"><code><span><span><span>if</span> request:header <span>&#34;</span><span>Sec-WebSocket-Key</span><span>&#34;</span> <span>then</span>
</span></span><span><span>   <span>local</span> sock <span>=</span> ba.socket.req2sock(request)
</span></span><span><span>   <span>if</span> sock <span>then</span>
</span></span><span><span>      <span>local</span> listener <span>=</span> { listening <span>=</span> <span>true</span>, sock <span>=</span> sock }
</span></span><span><span>      table.insert(app.deconzListeners, createDeconzEventListener(listener))
</span></span><span><span>      sock:event(socketHandler(listener), <span>&#34;</span><span>s</span><span>&#34;</span>)
</span></span><span><span>      request:abort()
</span></span><span><span>   <span>end</span>
</span></span><span><span><span>end</span>
</span></span><span><span>response:senderror(<span>403</span>, <span>&#34;</span><span>Invalid request</span><span>&#34;</span>)
</span></span></code></pre>
<p>This upgrades a normal HTTP request to a websocket connection on the server… The event listener is just a function that handles events:</p>
<pre tabindex="0"><code><span><span><span>local</span> <span>function</span> <span>createDeconzEventListener</span>(listener)
</span></span><span><span>   <span>return</span> <span>function</span>(event)
</span></span><span><span>      <span>if</span> <span>not</span> listener.listening <span>then</span>
</span></span><span><span>         error <span>&#34;</span><span>stopped listening</span><span>&#34;</span>
</span></span><span><span>      <span>end</span>
</span></span><span><span>      <span>if</span> event.id <span>then</span>
</span></span><span><span>         <span>local</span> sock <span>=</span> listener.sock
</span></span><span><span>         <span>if</span> event.e <span>==</span> <span>&#39;</span><span>changed</span><span>&#39;</span> <span>and</span> event.r <span>and</span> event.state <span>then</span>
</span></span><span><span>            sock:write(ba.json.encode({
</span></span><span><span>                             id <span>=</span> event.id,
</span></span><span><span>                             r <span>=</span> event.r,
</span></span><span><span>                             type <span>=</span> <span>&#39;</span><span>changed</span><span>&#39;</span>,
</span></span><span><span>                             state <span>=</span> event.state
</span></span><span><span>                                     }), <span>true</span>)
</span></span><span><span>         <span>elseif</span> event.e <span>==</span> <span>&#39;</span><span>deleted</span><span>&#39;</span> <span>then</span>
</span></span><span><span>            sock:write(ba.json.encode({
</span></span><span><span>                             id <span>=</span> event.id,
</span></span><span><span>                             type <span>=</span> <span>&#39;</span><span>deleted</span><span>&#39;</span>
</span></span><span><span>                                     }), <span>true</span>)
</span></span><span><span>         <span>else</span>
</span></span><span><span>            <span>--trace(&#39;unknown event kind or missing data&#39;, ba.json.encode(event))</span>
</span></span><span><span>         <span>end</span>
</span></span><span><span>      <span>else</span>
</span></span><span><span>         trace(<span>&#39;</span><span>ignoring event</span><span>&#39;</span>, ba.json.encode(event))
</span></span><span><span>      <span>end</span>
</span></span><span><span>   <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre>
<p>With this, I now had a pretty dynamic web application in place with live data about my home!</p>

<h3>The final web app</h3>

<p>Finally, there’s enough pieces to put together a web application to be used as a frontend for the home automation system.</p>

<p>To implement the frontend, I opted to use vanilla JavaScript code, but you could use any web framework you’d fancy… the server just needs to serve the resources it expects,
and handle the requests made from the JS client using either LSP pages or virtual directory pages.</p>

<p>The <code>index.lsp</code> page I create pre-loads data so that the page doesn’t need to fetch any data after loading (it’ll only update when something happens, via websocket events).</p>

<p>My LSP home page does something like this to preload the data and connect to the websocket:</p>
<pre tabindex="0"><code><span><span><span>&lt;?lsp
</span></span></span><span><span><span>response:include &#34;/smarthome/.fragments/header.lsp&#34;
</span></span></span><span><span><span>
</span></span></span><span><span><span>-- some uninteresting code here
</span></span></span><span><span><span>
</span></span></span><span><span><span>local sensors = {}
</span></span></span><span><span><span>local lights, errorMessage = lightsData()
</span></span></span><span><span><span>if not errorMessage then
</span></span></span><span><span><span>   sensors, errorMessage = sensorsData()
</span></span></span><span><span><span>end
</span></span></span><span><span><span>
</span></span></span><span><span><span>?&gt;</span>
</span></span><span><span>
</span></span><span><span>&lt;<span>div</span> <span>id</span><span>=</span><span>&#39;error-message&#39;</span> <span>class</span><span>=</span><span>&#39;error&#39;</span>&gt;<span>&lt;?lsp= errorMessage or &#39;&#39; ?&gt;</span>&lt;/<span>div</span>&gt;
</span></span><span><span>&lt;<span>h2</span>&gt;Weather&lt;/<span>h2</span>&gt;
</span></span><span><span>&lt;<span>div</span> <span>id</span><span>=</span><span>&#39;weather&#39;</span>&gt;&lt;/<span>div</span>&gt;
</span></span><span><span>&lt;<span>h2</span>&gt;Lights&lt;/<span>h2</span>&gt;
</span></span><span><span>&lt;<span>div</span> <span>id</span><span>=</span><span>&#39;lights&#39;</span>&gt;&lt;/<span>div</span>&gt;
</span></span><span><span>&lt;<span>h2</span>&gt;Sensors&lt;/<span>h2</span>&gt;
</span></span><span><span>&lt;<span>div</span> <span>id</span><span>=</span><span>&#39;sensors&#39;</span>&gt;&lt;/<span>div</span>&gt;
</span></span><span><span>&lt;<span>script</span> <span>src</span><span>=</span><span>&#34;js/home.js&#34;</span>&gt;&lt;/<span>script</span>&gt;
</span></span><span><span>&lt;<span>script</span>&gt;
</span></span><span><span><span>const</span> lightsData <span>=</span> <span>&lt;</span><span>?</span>lsp<span>=</span> ba.json.encode(lights) <span>?</span><span>&gt;</span>;
</span></span><span><span><span>const</span> sensorsData <span>=</span> <span>&lt;</span><span>?</span>lsp<span>=</span> ba.json.encode(sensors) <span>?</span><span>&gt;</span>;
</span></span><span><span><span>const</span> weatherData <span>=</span> <span>&lt;</span><span>?</span>lsp<span>=</span> ba.json.encode(weather.latest()) <span>?</span><span>&gt;</span>;
</span></span><span><span>
</span></span><span><span><span>// start websocket connection
</span></span></span><span><span><span></span><span>const</span> protocol <span>=</span> <span>window</span>.location.protocol;
</span></span><span><span><span>const</span> host <span>=</span> <span>window</span>.location.host;
</span></span><span><span><span>const</span> port <span>=</span> <span>window</span>.location.port <span>?</span> <span>&#39;:&#39;</span> <span>+</span> <span>window</span>.location.port <span>:</span> <span>&#39;&#39;</span>;
</span></span><span><span>webSocket <span>=</span> <span>new</span> WebSocket((protocol <span>==</span> <span>&#39;http:&#39;</span> <span>?</span> <span>&#39;ws:&#39;</span> <span>:</span> <span>&#39;wss:&#39;</span>) <span>+</span>
</span></span><span><span>   <span>&#39;//&#39;</span> <span>+</span> host <span>+</span> port <span>+</span> <span>&#39;/smarthome/control-ws.lsp&#39;</span>);
</span></span><span><span>webSocket.onopen <span>=</span> (event) =&gt; Control(lightsData, sensorsData, weatherData, webSocket);
</span></span><span><span>&lt;/<span>script</span>&gt;
</span></span><span><span><span>&lt;?lsp
</span></span></span><span><span><span>response:include &#34;/smarthome/.fragments/footer.html&#34;
</span></span></span><span><span><span>?&gt;</span>
</span></span></code></pre>
<p>And this is what the home page looks like after a little bit of polishing:</p>

<p><img src="https://renato.athaydes.com/images/mako/smarthome.jpg" alt="Smart Home HomePage"/></p>

<p>Notice that I haven’t made the <code>Weather</code> section ready yet so it just shows some JSON data for now!</p>

<p>I did add some charts (based on the <a href="https://www.chartjs.org/">charts.js</a> library) which load data
from a SQLite database which is populated by running Lua timers in the background which collect information from
all sensors as well as weather data from the <a href="https://openweathermap.org/api">OpenWeather API</a>:</p>

<p><img src="https://renato.athaydes.com/images/mako/charts.jpg" alt="Smart Home Weather Charts Page"/></p>

<p>The code to persist data into SQLite is pretty simple:</p>
<pre tabindex="0"><code><span><span><span>local</span> db <span>=</span> {}
</span></span><span><span>
</span></span><span><span><span>local</span> sql <span>=</span> luasql.sqlite()
</span></span><span><span>
</span></span><span><span><span>function</span> <span>db</span>.<span>withConnection</span>(f)
</span></span><span><span>    <span>local</span> con <span>=</span> sql:connect(<span>&#39;</span><span>smarthome.db</span><span>&#39;</span>)
</span></span><span><span>    <span>local</span> ok, err <span>=</span> pcall(<span>function</span>() f(con) <span>end</span>)
</span></span><span><span>    <span>if</span> <span>not</span> ok <span>then</span> trace(<span>&#34;</span><span>problem running SQL operation</span><span>&#34;</span>, err) <span>end</span>
</span></span><span><span>    con:close()
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span>db.withConnection(<span>function</span>(con)
</span></span><span><span>
</span></span><span><span>  assert(con:execute <span>[[
</span></span></span><span><span><span>  CREATE TABLE IF NOT EXISTS Temperature (
</span></span></span><span><span><span>    time    INTEGER UNIQUE NOT NULL,
</span></span></span><span><span><span>    value   REAL    NOT NULL,
</span></span></span><span><span><span>    name    TEXT    NOT NULL,
</span></span></span><span><span><span>    UNIQUE(time, name)
</span></span></span><span><span><span>  )
</span></span></span><span><span><span>  ]]</span>)
</span></span><span><span>  
</span></span><span><span>  <span>-- ...</span>
</span></span><span><span><span>end</span>)
</span></span></code></pre>
<p>And so on for a few more tables to hold data for indoors humidity, pressure, local weather…</p>

<p>I was very happy with the results.</p>

<h2>Conclusion</h2>

<p>🎉 🏘️ 🎆</p>

<p>Adding a little automation to my home was not nearly easy as I had thought. I spent several months doing research
before even buying my first device. There’s just so much information, ways to do things, competing protocols,
countless vendors all trying to get you into their walled gardens to extract as much revenue from you as possible…</p>

<p>It’s a really challenging area. Despite all that, I did find a setup that I am happy with and hope that by describing
my journey here, others can benefit and find at least some useful ideas for what to do and not to do in their own
smart home setups.</p>

<p>There’s a lot of thing still missing… for example, I wanted to create a little DSL for writing small automation scripts that can control my <em>things</em> automatically, which shouldn’t be too hard now that all the requirements for that are in place.</p>

<p>Also, I haven’t moved all my <em>things</em> to the Raspbee controller… one reason being that I haven’t made it possible yet to control it using voice (doing that will probably require me to write my own <a href="https://developers.google.com/nest/device-access">integration with Google Nest</a>). Another reason is that the Wifi devices normally don’t offer an API I can talk to from my Mako Server, so those devices will probably never become fully integrated. However, even if the setup is not perfect, it’s pretty close to where I wanted it to be.</p>

<p>All the code I am using in my smart home (and most of the code shown in this blog post) can be found on GitHub at <a href="https://github.com/renatoathaydes/mako-smarthome">renatoathaydes/mako-smarthome</a>!</p>

<p>For anyone looking for a hobby that lets them use their programming skills while doing something pretty cool that
the family can actually appreciate, I highly recommend going down this rabbit hole! Have fun!</p>
</div></div>
  </body>
</html>
