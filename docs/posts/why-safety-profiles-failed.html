<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.circle-lang.org/draft-profiles.html">Original</a>
    <h1>Why Safety Profiles Failed</h1>
    
    <div id="readability-page-1" class="page"><div>

<div>


<blockquote>
<p><em>As for dangling pointers and for ownership, <strong>this model
detects all possible errors</strong>. This means that we can guarantee
that a program is free of uses of invalidated pointers.</em></p>
<p>– A brief introduction to C++’s model for type- and resource-
safety<span data-cites="type-and-resource-safety-2015">[<a href="https://www.stroustrup.com/resource-model.pdf" role="doc-biblioref">type-and-resource-safety-2015</a>]</span></p>
</blockquote>
<p>Safety Profiles were introduced in 2015 with the promise to detect
all lifetime safety defects in existing C++ code. It was a bold claim.
But after a decade of effort, Profiles failed to produce a
specification, reliable implementation or any tangible benefit for C++
safety. The cause of this failure involves a number of mistaken premises
at the core of its design:</p>
<ol type="1">
<li>“Zero annotation is required by default, because existing C++ source
code already contains sufficient information”<span data-cites="P3465R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf" role="doc-biblioref">P3465R0</a>]</span></li>
<li>“We should not require a <code>safe</code>
function annotation”<span data-cites="P3446R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf" role="doc-biblioref">P3446R0</a>]</span></li>
<li>“Do not add a feature that requires viral annotation”<span data-cites="P3466R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf" role="doc-biblioref">P3466R0</a>]</span></li>
<li>“Do not add a feature that requires heavy annotation”<span data-cites="P3466R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf" role="doc-biblioref">P3466R0</a>]</span></li>
</ol>
<p>The parameters of the problem make success impossible. This paper
examines the contradictions in these premises, explains why the design
didn’t improve safety in the past and why it won’t improve safety in the
future.</p>

<blockquote>
<p><em>Zero annotation is required by default, because existing C++
source code already contains sufficient information.</em></p>
<p>– Pursue <span data-cites="P1179R1">[<a href="https://wg21.link/p1179r1" role="doc-biblioref">P1179R1</a>]</span> as a Lifetime Safety TS<span data-cites="P3465R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf" role="doc-biblioref">P3465R0</a>]</span></p>
</blockquote>
<p>C++ source code <em>does not</em> have sufficient information for
achieving memory safety. A C++ function declaration lacks three things
that are critical for lifetime safety:</p>
<ol type="1">
<li><a href="#inferring-aliasing">Aliasing information</a>.</li>
<li><a href="#inferring-lifetimes">Lifetime information</a>.</li>
<li><a href="#inferring-safeness">Safeness information</a>.</li>
</ol>
<p>Functions involving parameter types with pointer or reference
semantics have <em>implicit</em> aliasing, lifetime and safeness
requirements. Safety Profiles cannot recover these properties from C++
code, because there are no language facilities to describe them. These
requirements are only specified in documentation, if they are specified
at all.</p>
<h2 data-number="2.1" id="inferring-aliasing"> Inferring aliasing<a href="#inferring-aliasing"></a></h2>
<p>A C++ compiler can infer nothing about aliasing from a function
declaration. A function parameter with a mutable reference <em>might
always</em> alias other parameters, it <em>might never</em> alias other
parameters, or <em>it might not care</em> about aliasing other
parameters.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>// i and j must always alias. They must refer to the same container.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>void</span> f1<span>(</span>std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;::</span>iterator i, std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;::</span>iterator j<span>)</span> <span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span>// If i and j point into different vectors, you have real problems.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>sort<span>(</span>i, j<span>)</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>// vec must not alias x.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>void</span> f2<span>(</span>std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;&amp;</span> vec, <span>int</span><span>&amp;</span> x<span>)</span> <span>{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span>// Resizing vec may invalidate x if x is a member of vec.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  vec<span>.</span>push_back<span>(</span><span>5</span><span>)</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span>// Potential use-after-free.</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  x <span>=</span> <span>6</span>;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span>// vec may or may not alias x. It doesn&#39;t matter.</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span>void</span> f3<span>(</span>std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;&amp;</span> vec, <span>const</span> <span>int</span><span>&amp;</span> x<span>)</span> <span>{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  vec<span>.</span>push_back<span>(</span>x<span>)</span>;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p><code>f1</code> and
<code>f2</code> have aliasing requirements. In
<code>f1</code>, both iterators must point into
the same container. In <code>f2</code>,
<code>x</code> must not come from the container
<code>vec</code>. These requirements are only
visible as documentation. The compiler cannot infer a function’s
aliasing requirements from its declaration or even from its definition.
If the safety profile enforces <em>no mutable aliasing</em>, then the
definitions of <code>f1</code> and
<code>f3</code> will fail to compile, breaking
your program.</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec1, vec2;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span>// *Incorrectly* permits call.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span>// UB, because the iterators point into different containers.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  f1<span>(</span>vec1<span>.</span>begin<span>()</span>, vec2<span>.</span>end<span>())</span>;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>// *Incorrectly* rejects call.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span>// This is the correct usage, but mutable aliasing prevents compilation.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  f1<span>(</span>vec1<span>.</span>begin<span>()</span>, vec1<span>.</span>end<span>())</span>;</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span>// *Correctly* rejects call.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  f2<span>(</span>vec1, vec1<span>[</span><span>2</span><span>])</span>;</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span>// *Incorrectly* rejects call.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  f3<span>(</span>vec1, vec1<span>[</span><span>2</span><span>])</span>;</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Profiles chose the wrong convention for several uses. It permits the
incorrect call to <code>f1</code> to compile, but
rejects a correct usage of <code>f1</code> on the
grounds of mutable aliasing. An unsound call to
<code>f2</code> is correctly rejected, but a
sound call to <code>f3</code> is also rejected.
Rejecting or permitting code (rightly or wrongly) is a matter of
coincidence, not intelligence.</p>
<p>Without language-level aliasing information, compile-time memory
safety is not possible. This requirement is the motivation for Rust’s
borrow type. A mutable borrow cannot alias other borrows. That’s
enforced by the borrow checker. Raw pointers have no aliasing
requirements, but are unsafe to dereference. In general, things that can
be checked by the compiler are checked, and things that can’t be checked
are unsafe to use.</p>
<p><a href="https://godbolt.org/z/WWera863E">(Compiler Explorer)</a></p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;vector&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;iostream&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>void</span> func<span>(</span>std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;&amp;</span> vec, <span>int</span><span>&amp;</span> x<span>)</span> <span>{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  vec<span>.</span>push_back<span>(</span><span>1</span><span>)</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  x <span>=</span> <span>2</span>;  <span>// A write-after-free when x is a member of vec!</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  vec<span>.</span>push_back<span>(</span><span>1</span><span>)</span>;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  func<span>(</span>vec, vec<span>[</span><span>0</span><span>])</span>;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>cout<span>&lt;&lt;</span> vec<span>[</span><span>0</span><span>]&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span>;</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>cout<span>&lt;&lt;</span> vec<span>[</span><span>1</span><span>]&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span>;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>

<p>The Safety Profiles partial reference implementation can’t prevent
aliasing-related undefined behavior because C++ doesn’t provide aliasing
information.</p>
<h2 data-number="2.2" id="inferring-lifetimes"> Inferring lifetimes<a href="#inferring-lifetimes"></a></h2>
<p>A C++ compiler can infer nothing about lifetimes from a function
declaration. A reference return type may be constrained by the lifetimes
of any number of reference parameters, by none of the reference
parameters, or by some other lifetime.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>// The returned reference is only constrained by the lifetime of the map</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>// parameter.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>// It is not constrained by the lifetime of the key parameter.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>int</span><span>&amp;</span> f4<span>(</span>std<span>::</span>map<span>&lt;</span><span>int</span>, <span>int</span><span>&gt;&amp;</span> map, <span>const</span> <span>int</span><span>&amp;</span> key<span>)</span> <span>{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> map<span>[</span>key<span>]</span>;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span>// The returned reference is constrained by the lifetime of both x and y</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span>// parameters.</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>int</span><span>&amp;</span> f5<span>(</span><span>const</span> <span>int</span><span>&amp;</span> x, <span>const</span> <span>int</span><span>&amp;</span> y<span>)</span> <span>{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span>return</span> std<span>::</span>min<span>(</span>x, y<span>)</span>;</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span>// The returned reference is not constrained by the lifetime of any</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span>// reference parameter.</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>int</span><span>&amp;</span> f6<span>(</span><span>const</span> <span>int</span><span>&amp;</span> key<span>)</span> <span>{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span>static</span> std<span>::</span>map<span>&lt;</span><span>int</span>, <span>int</span><span>&gt;</span> map;</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span>return</span> map<span>[</span>key<span>]</span>;</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>These three functions have different lifetime requirements, which are
indicated by comments. This information is available to developers but
not to the compiler. What’s the strategy to uphold these lifetime
requirements? Read the documentation, read the code, and <em>don’t make
mistakes</em>.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>map<span>&lt;</span><span>int</span>, <span>int</span><span>&gt;</span> map;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span>// r4 is constrained by lifetimes of map and 40.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span>int</span><span>&amp;</span> r4 <span>=</span> f4<span>(</span>map, <span>40</span><span>)</span>;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span>// *Incorrectly* rejects usage of r4. r4 is constrained to the lifetime</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span>// of the temporary 40, which expired at the end of the above statement.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span>int</span> x <span>=</span> r4;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span>// r5 is constrained by lifetimes of 50 and 51.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>int</span><span>&amp;</span> r5 <span>=</span> f5<span>(</span><span>50</span>, <span>51</span><span>)</span>;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span>// *Correctly* rejects usage of r5. The reference refers to one of the</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span>// two expired temporaries. This use would be a use-after-free.</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span>int</span> y <span>=</span> r5;</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  <span>// r6 is constrained by the lifetime of 60.</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>int</span><span>&amp;</span> r6 <span>=</span> f6<span>(</span><span>60</span><span>)</span>;</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>  <span>// *Incorrectly* rejects usage of r6.</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>  <span>// The return reference r6 should not be constrained by the lifetime of 60.</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  <span>int</span> z <span>=</span> r6;</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Profiles take a similarly conservative approach to lifetimes as they
do with aliasing. The lifetime of a returned reference is constrained by
the lifetimes of <em>all of its arguments</em>. This is fortuitous for a
function like
<code>std<span>::</span>min</code>,
which returns a reference to either of its function parameters. It’s bad
for a function like <code>std<span>::</span>map<span>&lt;</span>T<span>&gt;::</span><span>operator</span><span>[]</span></code>,
which takes a key argument by reference but returns a reference that’s
only constrained by the lifetime of
<code><span>this</span></code>.</p>
<p>Since the compiler has no information about function parameter
lifetimes, it can’t accurately flag out-of-contract function calls.
<code>f4</code> and
<code>f6</code> take references to temporary
objects but return references that should not be constrained to that
temporary. In both cases, the safety profile rejects a subsequent use of
the reference as a use-after-free, because it applies a too-conservative
convention.</p>
<p>The need for explicit lifetime information in function types is the
motivation for Rust’s lifetime arguments. A returned reference must be
annotated with a lifetime parameter that is constrained by a function
parameter on the same function, or it must be static. The alternative is
to be deluged with an impossible quantity of use-after-free false
positives.</p>
<p><a href="https://godbolt.org/z/4c84ofavY">(Compiler Explorer)</a></p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;map&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;utility&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>int</span><span>&amp;</span> f4<span>(</span>std<span>::</span>map<span>&lt;</span><span>int</span>, <span>int</span><span>&gt;&amp;</span> map, <span>const</span> <span>int</span><span>&amp;</span> key<span>)</span> <span>{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> map<span>[</span>key<span>]</span>;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>map<span>&lt;</span><span>int</span>, <span>int</span><span>&gt;</span> map;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>int</span><span>&amp;</span> ref <span>=</span> f4<span>(</span>map, <span>200</span><span>)</span>;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span>int</span> x <span>=</span> ref;</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>&lt;source&gt;:11:11: warning: dereferencing a dangling pointer [-Wlifetime]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  int x = ref;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>          ^~~</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>&lt;source&gt;:10:32: note: temporary was destroyed at the end of the full expression</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  const int&amp; ref = f4(map, 200);</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                               ^</span></code></pre></div>
<p>The Safety Profiles reference implementation can’t accurately deal
with lifetimes because C++ doesn’t provide lifetime information. The
tool doesn’t test for correctness, it only tests if your code conforms
to a pre-chosen convention.</p>
<h2 data-number="2.3" id="inferring-safeness"> Inferring safeness<a href="#inferring-safeness"></a></h2>
<blockquote>
<p><em>We should not require a <code>safe</code>
function annotation that has the semantics that a
<code>safe</code> function can only call other
<code>safe</code> functions.</em></p>
<p>– (Re)affirm design principles for future C++ evolution<span data-cites="P3446R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf" role="doc-biblioref">P3446R0</a>]</span></p>
</blockquote>
<p>Recall what “safe” actually means:</p>
<ul>
<li>A <em>safe function</em> has defined behavior for all valid
inputs.</li>
<li>An <em>unsafe function</em> has soundness preconditions. Calling an
unsafe function with out-of-contract inputs may result in undefined
behavior.</li>
</ul>
<p>A C++ compiler can infer nothing about safeness from a function
declaration. It can’t by tell by looking what constitutes an
out-of-contract call and what doesn’t. A <em>safe-specifier</em>
indicates the presence of soundness preconditions. An
<em>unsafe-block</em> permits the user to escape the safe context, prove
the preconditions, and call the unsafe function.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>class</span> vector <span>{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span>size_t</span> size<span>()</span> <span>const</span> <span>noexcept</span> safe <span>{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span>return</span> _len;</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  T<span>&amp;</span> <span>operator</span><span>[](</span><span>size_t</span> index<span>)</span> <span>noexcept</span> safe <span>{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span>// Can call size() because it&#39;s a safe function.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span>if</span><span>(</span>index <span>&gt;=</span> size<span>())</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      panic<span>(</span><span>&#34;Out-of-bounds vector::operator[]&#34;</span><span>)</span>;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    unsafe <span>{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      <span>// Pointer operations only allowed in unsafe context.</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      <span>// Safety proof:</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      <span>// The allocation has size() valid elements and index &lt; size().</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      <span>return</span> _data<span>[</span>index<span>]</span>;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span>private</span><span>:</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  T<span>*</span> _data;</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  <span>size_t</span> _len, _cap;</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span></code></pre></div>
<p>Let’s take a really simple case: <code>vector<span>::</span><span>operator</span><span>[]</span></code>.
Profiles have to reject pointer arithmetic, because there’s no static
analysis protection against indexing past the end of the allocation. How
is the compiler told to permit the raw pointer subscript in the
<em>return-statement</em> in <code>vector<span>::</span><span>operator</span><span>[]</span></code>?
In Rust and Safe C++, enter an <em>unsafe-block</em>.</p>
<p>This design distinguishes safe functions, which have no soundness
preconditions and can be called from other safe functions, and unsafe
functions, which require an <em>unsafe-block</em> escape to use, just
like pointer operations.</p>
<p>Separation of safe and unsafe functions is common in memory-safe
languages. Rust and C#<span data-cites="csharp">[<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe" role="doc-biblioref">csharp</a>]</span> include an
<code>unsafe</code> function specifier and an
<em>unsafe-block</em> construct. This is a human- and tooling-readable
tag for auditing potential origins of soundness defects. Aliasing and
lifetimes are transitive properties that must be recoverable from a
function declaration in order to be upheld. Safeness (the lack of
soundness preconditions) is another transitive property that must be
marked in a function declaration. The way to do that is with a
<em>safe-specifier</em>.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> RandomIt <span>&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span>void</span> sort<span>(</span> RandomIt first, RandomIt last <span>)</span>;</span></code></pre></div>
<p>Let’s consider another example: the
<code>std<span>::</span>sort</code>
API that takes two random-access iterators. This is an <em>unsafe</em>
function because it exhibits undefined behavior if called with the wrong
arguments. But there’s nothing in the type system to indicate that it
has soundness preconditions, so the compiler doesn’t know to reject
calls in safe contexts.</p>
<p>What are <code>sort</code>’s
preconditions?</p>
<ul>
<li>The <code>first</code> and
<code>last</code> iterators must point at
elements from the same container.</li>
<li><code>first</code> must not indicate an
element that appears after
<code>last</code>.</li>
<li><code>first</code> and
<code>last</code> may not be dangling
iterators.</li>
</ul>
<p>In the absence of a enforced safeness information, it’s up to the
user to follow the documentation and satisfy the requirements. Guidance
for calling unsafe functions is essentially “don’t write bugs.”</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>void</span> func<span>(</span>std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec1, std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec2<span>)</span> <span>{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span>// #1 - *Incorrectly* rejects correct call for mutable aliasing</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  sort<span>(</span>vec1<span>.</span>begin<span>()</span>, vec1<span>.</span>end<span>())</span>;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span>// #2 - *Incorrectly* permits out-of-contract call.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  sort<span>(</span>vec1<span>.</span>begin<span>()</span>, vec2<span>.</span>end<span>())</span>;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>In the Profiles model, the correct call to
<code>sort</code> #1 is rejected due to mutable
aliasing. That’s bad, but permitting the out-of-contract call #2 is
worse, because it’s a soundness bug. There’s no realistic static
analysis technology to verify that a call to
<code>sort</code> meets its preconditions. Even
the safety profile with the most conservative aliasing setting lets this
call through.</p>
<p>This is where <code>safe</code> and
<code>unsafe</code> specifiers play an important
role. From the caller’s perspective,
<code>sort</code> is unsafe because it has
preconditions that must be upheld without the compiler’s help. From the
callee’s perspective, <code>sort</code> is unsafe
because it’s written with <em>unsafe operations</em>. Pointer
differencing computes a pivot for the sort, and pointer differencing is
undefined when its operands point to different allocations.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>// No safe-specifier means unsafe.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>void</span> sort<span>(</span>vector<span>&lt;</span><span>int</span><span>&gt;::</span>iterator begin, vector<span>&lt;</span><span>int</span><span>&gt;::</span>iterator end<span>)</span>;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>// A safe-specifier means it can only call safe functions.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span>void</span> func<span>(</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec1, vector<span>&lt;</span><span>int</span><span>&gt;</span> vec2<span>)</span> safe <span>{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span>// Ill-formed: sort is an unsafe function.</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span>// Averts potential undefined behavior.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  sort<span>(</span>vec1<span>.</span>begin<span>()</span>, vec2<span>.</span>end<span>())</span>;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  unsafe <span>{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span>// Well-formed: call unsafe function from unsafe context.</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span>// Safety proof:</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span>// sort requires both iterators point into the same container.</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span>// Here, they both point into vec1.</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    sort<span>(</span>vec1<span>.</span>begin<span>()</span>, vec1<span>.</span>end<span>())</span>;</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The only way to enforce memory safety is to separate safe and unsafe
functions with a <em>safe-specifier</em>. In this example,
<code>func</code> is <em>safe</em> because it’s
defined for all valid inputs. It cannot call
<code>sort</code>, because that has soundness
preconditions: the two iterators must point into the same container. A
call to <code>sort</code> in a safe context
leaves the program ill-formed, because the compiler cannot guarantee
that the preconditions are satisfied. But by entering an
<em>unsafe-block</em>, the user can prove the preconditions and make the
unsafe call <em>without the compiler’s soundness guarantees</em>.</p>
<p><span data-cites="P3081R0">[<a href="https://isocpp.org/files/papers/P3081R0.pdf" role="doc-biblioref">P3081R0</a>]</span> does float a <code><span>[[</span><span>suppress</span><span>(</span><span>profile</span><span>)]]</span></code>
attribute to turn off certain Profiles checkes. It looks like the
equivalent of an <em>unsafe-block</em>. It may permit pointer operations
in a definition, but it doesn’t address the other side of the call:
without a <em>safe-specifier</em>, how does the Profiles design deal
with functions like <code>sort</code> that are
<em>inherently unsafe</em>? They must be separated from provably safe
functions. User intervention, wrapped up in <em>unsafe-blocks</em>, is
needed to satisfy their preconditions. Without this bump of impedance
the language cannot guarantee safety, as the property that a safe
functions contains no undefined behavior is not transitively upheld.</p>
<p><a href="https://godbolt.org/z/c7Ko3bnG8">(Compiler Explorer)</a></p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;memory&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;vector&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;algorithm&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> v1, v2;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  v1<span>.</span>push_back<span>(</span><span>1</span><span>)</span>;</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  v2<span>.</span>push_back<span>(</span><span>2</span><span>)</span>;</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span>// UB!</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>sort<span>(</span>v1<span>.</span>end<span>()</span>, v2<span>.</span>end<span>())</span>;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Program returned: 139</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>double free or corruption (out)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>Program terminated with signal: SIGSEGV</span></code></pre></div>
<p>The Safety Profiles reference implementation can’t deal with unsafe
functions, because C++ doesn’t know which functions are unsafe. This
out-of-contract call produces a heap double-free and then segfaults.</p>

<blockquote>
<p><em>Do not add a feature that requires viral annotation.</em></p>
<p>– (Re)affirm design principles for future C++ evolution<span data-cites="P3446R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf" role="doc-biblioref">P3446R0</a>]</span></p>
</blockquote>
<p>Rust’s safety model incorporates lifetime arguments on every
reference (or struct with reference semantics) that occurs in a function
type. The authors of Profiles disparagingly call these “viral
annotations.” Don’t be scared. C++ has always been full of viral
annotations: <strong>types are viral annotations</strong>.</p>
<p>Types establish type safety properties that are enforced by both the
caller and callee. These properties are <em>transitive</em>
(i.e. <em>viral</em>) because they’re enforced through any number of
function calls, creating a <em>network of reasoning</em> from the point
where an object is created to all of its uses.</p>
<p>Languages that treat types as viral annotations are
<em>statically-typed languages</em>. Languages that don’t are
<em>dynamically-typed languages</em>. These have well-known trade-offs.
Statically-typed languages exhibit higher performance and provide more
information to developers; programs in a statically-typed language may
be easier to reason about. Dynamically-typed languages are much simpler
and can be more productive.</p>
<p>Lifetime parameters, which provide crucial information to the
compiler to enable rigorous safety analysis, defines another axis of
<em>typing</em>. Rust has <em>static lifetimes</em>, which is a
high-performance, high-information approach to memory safety. Users can
reason about lifetimes and aliasing because those concepts are built
into the language. The compiler has sufficient information to rigorously
enforce lifetime safety with <em>borrow checking</em>.</p>
<p>Most other memory-safe languages use <em>dynamic lifetimes</em>, of
which <em>garbage collection</em> is an implementation. Instead of
enforcing lifetimes and exclusivity at compile time, the garbage
collector manages objects on the heap and extends their scope as long as
there are live references to them. This has the same basic trade-off as
<em>dynamic typing</em>: simplicity at the cost of performance.</p>
<table>
<tbody><tr><th>
</th>
<th>
Static lifetimes
</th>
<th>
Dynamic lifetimes
</th>
</tr><tr>
<th>
Static types
</th>
<td>
Rust
</td>
<td>
Java, Go
</td>
</tr>
<tr>
<th>
Dynamic types
</th>
<td>
-
</td>
<td>
Javascript, Python
</td>
</tr>
</tbody></table>
<p>The static types/static lifetimes quadrant is a new area of language
design, at least for languages widely used in production. The principles
may be unfamiliar. Lifetime annotations feel different than type
annotations because they establish relationships <em>between</em>
parameters and return types rather than on individual parameters and
objects. Instead of answering the question “What are the properties of
this entity?” they answer “How does this entity relate to other
entities?”.</p>
<p>Profiles fail because they reject, as a design principle, the
specific language improvements that provide necessary lifetime
information for compile-time safety.</p>

<blockquote>
<p><em>Annotations are distracting, add verbosity, and some can be wrong
(introducing the kind of errors they are assumed to help
eliminate).</em></p>
<p>– Profile invalidation - eliminating dangling pointers<span data-cites="P3446R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf" role="doc-biblioref">P3446R0</a>]</span></p>
</blockquote>
<p>This is not right. In a memory-safe language you can’t introduce
undefined behavior with mere coding mistakes. That’s the whole point of
memory safety. If you put the wrong lifetime annotation on a parameter,
your program becomes ill-formed, not undefined. A mistaken use of
lifetime parameters can be an ergonomics bug, or it can mask undefined
behavior when wrapping an unsafe function in a safe interface, but it
can’t cause undefined behavior.</p>
<p><a href="https://godbolt.org/z/MYW6x693P">(Compiler Explorer)</a></p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> f1<span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span>(x<span>:&amp;</span><span>&#39;a</span> <span>i32</span><span>,</span> y<span>:&amp;</span><span>&#39;b</span> <span>i32</span>) <span>-&gt;</span> <span>&amp;</span><span>&#39;b</span> <span>i32</span> <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> x<span>;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>error: lifetime may not live long enough</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a> --&gt; lifetime1.rs:5:10</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  |</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>4 | fn f1&lt;&#39;a, &#39;b&gt;(x:&amp;&#39;a i32, y:&amp;&#39;b i32) -&gt; &amp;&#39;b i32 {</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  |       --  -- lifetime `&#39;b` defined here</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  |       |</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  |       lifetime `&#39;a` defined here</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>5 |   return x;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  |          ^ function was supposed to return data with lifetime `&#39;b` but it is returning data with lifetime `&#39;a`</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  |</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  = help: consider adding the following bound: `&#39;a: &#39;b`</span></code></pre></div>
<p>Lifetime constraints are a contract between the caller and callee. If
either side violates the contract, the program is ill-formed. In the
code above, the lifetime constraints are violated by the callee. The
lifetime of the <code>x</code> parameter does not
outlive the lifetime of the returned reference. We used the wrong
annotation, but instead of leading to undefined behavior, the compiler
produces a detailed message that explains how the lifetime contract was
not met.</p>
<p><a href="https://godbolt.org/z/3YWvT7ce4">(Compiler Explorer)</a></p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> f2<span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span>(x<span>:&amp;</span><span>&#39;a</span> <span>i32</span><span>,</span> y<span>:&amp;</span><span>&#39;b</span> <span>i32</span>) <span>-&gt;</span> <span>&amp;</span><span>&#39;b</span> <span>i32</span> <span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>// Well-formed. The lifetime on y outlives the lifetime on</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>// the return reference.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span>return</span> y<span>;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span>fn</span> f3() <span>{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>let</span> x <span>=</span> <span>1</span><span>;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span>let</span> r<span>:&amp;</span><span>i32</span><span>;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span>{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span>let</span> y <span>=</span> <span>2</span><span>;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    r <span>=</span> f2(<span>&amp;</span>x<span>,</span> <span>&amp;</span>y)<span>;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span>// Ill-formed: r depends on y, which is out of scope.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span>let</span> z <span>=</span> <span>*</span>r<span>;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>error[E0597]: `y` does not live long enough</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  --&gt; lifetime2.rs:15:16</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   |</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>14 |     let y = 2;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>   |         - binding `y` declared here</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>15 |     r = f2(&amp;x, &amp;y);</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>   |                ^^ borrowed value does not live long enough</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>16 |   }</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>   |   - `y` dropped here while still borrowed</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>19 |   let z = *r;</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>   |           -- borrow later used here</span></code></pre></div>
<p>Let’s fix the implementation of the callee and test a broken version
of the caller. The returned reference depends on
<code>y</code>, but it’s used after
<code>y</code> goes out of scope. The compiler
rejects the program and tells us “<code>y</code>
does not live long enough.”</p>
<p>The use of lifetime annotations on parameters is the same as the use
of type annotations on parameters: it turns an intractable whole-program
analysis problem into an easy-to-enforce local-analysis problem.
Lifetime annotations, which exist to <em>guarantee</em> safety, do not
<em>jeopardize</em> safety.</p>

<blockquote>
<p><em>Do not add a feature that requires heavy annotation. “Heavy”
means something like “more than 1 annotation per 1,000 lines of
code.”</em></p>
<p>– (Re)affirm design principles for future C++ evolution<span data-cites="P3446R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf" role="doc-biblioref">P3446R0</a>]</span></p>
</blockquote>
<blockquote>
<p><em>We have an implemented approach that requires near-zero
annotation of existing source code.</em></p>
<p>– Pursue <span data-cites="P1179R1">[<a href="https://wg21.link/p1179r1" role="doc-biblioref">P1179R1</a>]</span> as a Lifetime TS<span data-cites="P3465R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf" role="doc-biblioref">P3465R0</a>]</span></p>
</blockquote>
<p>Central to Safety Profiles is the claim that annotations are
exceptional rather than the norm. For this to be true, the great bulk of
C++ would need to be written according to some preferred convention.
<span data-cites="P1179R1">[<a href="https://wg21.link/p1179r1" role="doc-biblioref">P1179R1</a>]</span> chooses “no mutable aliasing”
and constrains reference return types to all reference parameters. Let’s
consider a number of Standard Library functions and compare their
aliasing and exclusivity requirements to those conventions. Functions
that don’t adhere to these conventions must be annotated, and those
annotations must be virally propagated up the stack to all callers, as
aliasing and lifetime requirements are transitive. Only functions that
have no soundness preconditions can be considered safe.</p>
<p>Let’s start in <code><span>&lt;</span>algorithm<span>&gt;</span></code>
and work through alphabetically, indicating how functions deviate from
the Safety Profile’s aliasing and lifetime conventions:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>// Precondition: `first` and `last` must alias.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> UnaryPred <span>&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span>bool</span> all_of<span>(</span> InputIt first, InputIt last, UnaryPred p <span>)</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> UnaryPred <span>&gt;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span>bool</span> any_of<span>(</span> InputIt first, InputIt last, UnaryPred p <span>)</span>;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> UnaryPred <span>&gt;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span>bool</span> none_of<span>(</span> InputIt first, InputIt last, UnaryPred p <span>)</span>;</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `first` and `last` must alias.</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span>// Lifetime: The return type is not constrained by the lifetime of `value`</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> T <span>&gt;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>InputIt find<span>(</span> InputIt first, InputIt last, <span>const</span> T<span>&amp;</span> value <span>)</span>;</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> UnaryPred <span>&gt;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>InputIt find_if<span>(</span> InputIt first, InputIt last, UnaryPred p <span>)</span>;</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> UnaryPred <span>&gt;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>InputIt find_if_not<span>(</span> InputIt first, InputIt last, UnaryPred q <span>)</span>;</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `first` and `last` must alias.</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span>// Precondition 2: `s_first` and `s_last` must alias.</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span>// Lifetime: The return type is not constrained by the lifetime of `s_first`</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span>//   or `s_last`.</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt, <span>class</span> ForwardIt <span>&gt;</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>InputIt find_first_of<span>(</span> InputIt first, InputIt last,</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>  ForwardIt s_first, ForwardIt s_last <span>)</span>;</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `first` and `last` must alias.</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> ForwardIt <span>&gt;</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>ForwardIt adjacent_find<span>(</span> ForwardIt first, ForwardIt last <span>)</span>;</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `first1` and `last2` must alias.</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a><span>// Lifetime: The returned Input1 is constrained only by `first1` and `last1`</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a><span>// Lifetime: The returned Input2 is constrained only by `first2`.</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> InputIt1, <span>class</span> InputIt2 <span>&gt;</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>std<span>::</span>pair<span>&lt;</span>InputIt1, InputIt2<span>&gt;</span> mismatch<span>(</span> InputIt1 first1, InputIt1 last1,</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>  InputIt2 first2 <span>)</span>;</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `first` and `last` must alias.</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a><span>// Precondition 2: `s_first` and `s_last` must alias.</span></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a><span>// Lifetime: The returned ForwardIt1 is constrained only by `first` and `last`</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> ForwardIt1, <span>class</span> ForwardIt2 <span>&gt;</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>ForwardIt1 search<span>(</span> ForwardIt1 first, ForwardIt1 last, ForwardIt2 s_first, </span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>  ForwardIt2 s_last <span>)</span>;</span></code></pre></div>
<p>The functions in <code><span>&lt;</span>algorithms<span>&gt;</span></code>
mostly involve iterators which are inherently unsafe. Additionally, the
lifetime convention chosen by Profiles is frequently wrong: the lifetime
of a returned reference rarely is constrained by the lifetimes of all
its parameters. You’d need annotations in all of these cases.</p>
<p>Consider these conventions against the API for a container. Let’s
look at <code><span>&lt;</span>map<span>&gt;</span></code>:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>// Aliasing: the `key` parameter may alias `*this`.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span>// Lifetimes: the returned T&amp; is only constrained by `*this` and not by `key`.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>T<span>&amp;</span> map<span>&lt;</span>Key, T<span>&gt;::</span>at<span>(</span> <span>const</span> Key<span>&amp;</span> key <span>)</span>;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>T<span>&amp;</span> map<span>&lt;</span>Key, T<span>&gt;::</span><span>operator</span><span>[](</span> <span>const</span> Key<span>&amp;</span> key <span>)</span>;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span>// Aliasing: the `key` parameter may alias `*this`.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span>// Lifetimes: the returned iterator is only constrained by `*this` and not by</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span>//   `value`.</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>iterator map<span>&lt;</span>Key, T<span>&gt;::</span>find<span>(</span> <span>const</span> Key<span>&amp;</span> key <span>)</span>;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>iterator map<span>&lt;</span>Key, T<span>&gt;::</span>lower_bound<span>(</span> <span>const</span> Key<span>&amp;</span> key <span>)</span>;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>iterator map<span>&lt;</span>Key, T<span>&gt;::</span>upper_bound<span>(</span> <span>const</span> Key<span>&amp;</span> key <span>)</span>;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span>// Aliasing: the `value` parameter may alias `*this`.</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span>// Lifetimes: the returned iterator is only constrained by `*this` and not by</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span>//   `value`.</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>std<span>::</span>pair<span>&lt;</span>iterator, <span>bool</span><span>&gt;</span> map<span>&lt;</span>Key, T<span>&gt;::</span>insert<span>(</span> <span>const</span> value_type<span>&amp;</span> value <span>)</span>;</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `pos` must point into `*this`</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span>// Aliasing: the `value` parameter may alias `*this` or `pos`</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span>// Lifetimes: The returned iterator is only constrained by `*this` and not by</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span>//   `value`.</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>iterator map<span>&lt;</span>Key, T<span>&gt;::</span>insert<span>(</span> iterator pos, <span>const</span> value_type<span>&amp;</span> value <span>)</span>;</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span>// Aliasing: The `k` and `obj` parameters may alias `*this`.</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span>// Lifetimes: The returned iterator is only constrained by `*this` and not by </span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span>//   `k` or `value`.</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> M <span>&gt;</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>std<span>::</span>pair<span>&lt;</span>iterator, <span>bool</span><span>&gt;</span> map<span>&lt;</span>Key, T<span>&gt;::</span>insert_or_assign<span>(</span> <span>const</span> Key<span>&amp;</span> k, M<span>&amp;&amp;</span> obj <span>)</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span>// Unsafe!</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a><span>// Precondition 1: `hint` must point into `*this`</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span>// Aliasing: The `k` and `obj` parameters may alias `*this` and `hint`.</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a><span>// Lifetimes: The returned iterator is only constrained by `*this` and not by</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span>//   `k` or `value`.</span></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span> <span>class</span> M <span>&gt;</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>iterator insert_or_assign<span>(</span> const_iterator hint, <span>const</span> Key<span>&amp;</span> k, M<span>&amp;&amp;</span> obj <span>)</span>;</span></code></pre></div>
<p>This is only a few of the <code>map</code>
APIs which would either be unsafe or require annotations in the Profiles
model. The conservative aliasing rules gets most member functions wrong:
a reference returned from a member function is typically constrained
only by the <code><span>*</span><span>this</span></code>/<code>self</code>
parameter. That’s what Rust’s lifetime elision rules do. Regardless of
the convention chosen, expect annotations every time the function does
something different. With C++ code, it does something different <em>very
often</em>.</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;map&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>map<span>&lt;</span><span>int</span>, <span>int</span><span>&gt;</span> m;</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  m<span>[</span><span>1</span><span>]</span> <span>=</span> <span>2</span>;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span>// Temporary 1 expires. Profiles considers `value` a dangling reference.</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span>int</span><span>&amp;</span> value <span>=</span> m<span>[</span><span>1</span><span>]</span>;</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span>// Profiles should flag this apparent use-after-free.</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  value <span>=</span> <span>2</span>;</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Profile’s inability to deal accurately with lifetimes means that an
implementation would reject much valid code. In this example the
subscript to <code>map<span>::</span><span>operator</span><span>[]</span></code>
is a temporary. It goes out of scope at the end of the statement. Under
the Profile’s conservative lifetime convention, the returned reference
(stored in <code>value</code>) would be
considered a dangling reference and the subsequent use would make the
program ill-formed.</p>
<p>I do not believe that C++ code, with its countless unstated soundness
preconditions and inconsistent aliasing and lifetime requirements, can
be made memory safe with fewer than “1 annotation per 1,000 lines of
code.” In fact, legacy C++ code will have <em>many more</em> annotations
than equivalent Rust code. Rust often chooses object relocation to pass
parameters by value rather than pass them by reference. This reduces the
number of lifetime constraints that the system deals with. Additionally,
it has simpler, <em>safe versions</em> of facilities which are unsafe in
C++: the Rust iterator, for example, keeps both the data pointer and
length in the same struct to completely alleviate the aliasing concerns
that prevent safety analysis in C++.</p>
<h2 data-number="5.1" id="c-cannot-enforce-exclusivity"> C++ cannot enforce
exclusivity<a href="#c-cannot-enforce-exclusivity"></a></h2>
<p>The density of annotations required to vet existing code is not the
biggest problem facing Profiles. C++ overload resolution has created a
knot that cannot be untangled. Its standard conversion rules are one
reason why C++ is considered <em>inherently unsafe</em>.</p>
<p>For many accessor-style C++ APIs, there are two overloads:</p>
<ol type="1">
<li>A candidate that binds a <em>const</em> object and a returns a
<em>const</em> reference (or pointer or iterator).</li>
<li>A candidate that binds a <em>mutable</em> object and returns a
<em>mutable</em> reference (or pointer or iterator).</li>
</ol>
<p>If the mutable candidate <em>can</em> be chosen, <em>it is</em>
chosen, no matter what the result object is used for.</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>void</span> f1<span>(</span><span>const</span> <span>int</span><span>&amp;</span> x, <span>const</span> <span>int</span><span>&amp;</span> y<span>)</span>;</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span>void</span> f2<span>(</span>std<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec<span>)</span> <span>{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span>// The mutable overload of operator[] is called here.</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  f1<span>(</span>vec<span>[</span><span>0</span><span>]</span>, vec<span>[</span><span>1</span><span>])</span>;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This code will not pass an exclusivity test.
<code>vec</code> is a mutable object, so <code>vec<span>[</span><span>0</span><span>]</span></code>
calls the mutable version of <code><span>operator</span><span>[]</span></code>
and produces a mutable reference result object. <em>While that mutable
loan is in scope</em> (it remains in scope until
<code>f1</code> returns), <code>vec<span>[</span><span>1</span><span>]</span></code>
calls the mutable version of <code><span>operator</span><span>[]</span></code>
to produce its mutable reference result object. But you’re not allowed
more than one mutable reference to the same place. <em>This is an
exclusivity error!</em></p>
<p>Rust avoids this problem in two ways:</p>
<ul>
<li>In general there is no function overloading. As a convention, if
there are mutable and const versions of a function, the mutable one is
named with a <code>_mut</code> suffix.</li>
<li>There is syntax sugar which maps subscript operations to either
<code>index</code> or
<code>index_mut</code>. The latter is chosen in a
<em>mutable context</em>, which is the left-hand side of an
assignment.</li>
</ul>
<p>We can’t ditch function overloading and remain C++. But we can change
how overload resolution evaluates candidates. The standard conversion is
responsible for binding references to expressions. C++ chooses the wrong
(for safety purposes) subscript candidate because the standard
conversion is able to bind mutable references to lvalue expressions.</p>
<p><a href="https://godbolt.org/z/K3b8hP1W5">(Compiler Explorer)</a></p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>void</span> f3<span>(</span><span>const</span> <span>int</span><span>^</span> x, <span>const</span> <span>int</span><span>^</span> y<span>)</span> safe;</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> safe <span>{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  std2<span>::</span>vector<span>&lt;</span><span>int</span><span>&gt;</span> vec <span>{</span> <span>}</span>;</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span>// Okay.</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  f3<span>(</span>vec<span>[</span><span>0</span><span>]</span>, vec<span>[</span><span>1</span><span>])</span>;</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span>// Ill-formed: mutable borrow of vec between its mutable borrow and its use.</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  f3<span>(</span>mut vec<span>[</span><span>0</span><span>]</span>, mut vec<span>[</span><span>1</span><span>])</span>;</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  borrow checking: example.cpp:13:22</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    f3(mut vec[0], mut vec[1]); </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                       ^</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  mutable borrow of vec between its mutable borrow and its use</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  loan created at example.cpp:13:10</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    f3(mut vec[0], mut vec[1]); </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>           ^</span></code></pre></div>
<p>Safe C++ changes the standard conversion to work around this language
defect. In this extension, <em>standard conversions do not bind mutable
references</em>. <code>vec<span>[</span><span>0</span><span>]</span></code>
chooses the <em>const</em> candidate, which permits aliasing, and <code>mut vec<span>[</span><span>0</span><span>]</span></code>
chooses the <em>mutable</em> candidate, which does not. By opting in to
mutation, you get aliasing by default.</p>
<p><a href="https://godbolt.org/z/9G9oj68Yx">(Compiler Explorer)</a></p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> safe <span>{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span>int</span> x <span>=</span> <span>1</span>;</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span>int</span><span>^</span> ref <span>=</span> x;  <span>// Ill-formed! Can&#39;t bind mutable reference to lvalue.</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>error: example.cpp:5:14</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  int^ ref = x; </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>cannot implicitly bind borrow int^ to lvalue int</span></code></pre></div>
<p>The <code>mut</code> keyword<span data-cites="mutation">[<a href="https://safecpp.org/draft.html#explicit-mutation" role="doc-biblioref">mutation</a>]</span> puts the subexpression into
<em>the mutable context</em> and restores the restricted functionality.
In the mutable context, the compiler will bind mutable references to
expression:</p>
<p><a href="https://godbolt.org/z/xYcW3hYrf">(Compiler Explorer)</a></p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> safe <span>{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span>int</span> x <span>=</span> <span>1</span>;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span>int</span><span>^</span> ref <span>=</span> mut x;  <span>// Ok. Can bind mutable references in mutable context.</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Now, the const overload of a function is chosen unless the user
escapes with the <code>mut</code> keyword. This
addresses a language defect head-on.</p>
<p>What option does Profiles have? In its full generality, the mutable
binding default makes for an exceptionally thorny analysis problem. Does
Profiles replace calls to mutable candidates with calls to
similarly-named const candidates? That’s a presumption. Does it
retroactively classify mutable loans as shared loans depending on usage?
I’m not a soundness maverick. This is getting close to touching a live
wire.</p>
<p>Legacy C++ errs on the side of mutability, making it too
unconstrained to test for soundness. Old code is what it is.</p>

<blockquote>
<p><em>The development of new product lines for use in service of
critical infrastructure or NCFs (national critical functions) in a
memory-unsafe language (e.g., C or C++) … is dangerous and significantly
elevates risk to national security, national economic security, and
national public health and safety.</em></p>
<p>– CISA, Product Security Bad Practices<span data-cites="cisa">[<a href="https://www.cisa.gov/resources-tools/resources/product-security-bad-practices" role="doc-biblioref">cisa</a>]</span></p>
</blockquote>
<p><span data-cites="P3466R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf" role="doc-biblioref">P3466R0</a>]</span> insists that “we want to make
sure C++ evolution … hews to C++’s core principles.” But these are
<em>bad principles</em>. They make C++ extra vulnerable to memory safety
defects that are prevented in memory-safe languages. The US Government
implicates C++’s core principles as a danger to national security and
public health.</p>
<table>
<tbody><tr><th>
</th>
<th>
Static lifetimes
</th>
<th>
Dynamic lifetimes
</th>
</tr><tr>
<th>
Static types
</th>
<td>
Rust
</td>
<td>
Java, Go
</td>
</tr>
<tr>
<th>
Dynamic types
</th>
<td>
-
</td>
<td>
Javascript, Python
</td>
</tr>
</tbody></table>
<p>Reconsider this table. We want to evolve C++ to live in the static
types/static lifetimes quadrant. Since Rust is the only species in that
design family (at least among production languages), a new entry is
necessarily going to resemble Rust (at least in its memory safety
treatment) more than it does other languages. An earnest effort to
pursue <span data-cites="P1179R1">[<a href="https://wg21.link/p1179r1" role="doc-biblioref">P1179R1</a>]</span> as a Lifetime TS<span data-cites="P3465R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf" role="doc-biblioref">P3465R0</a>]</span> will compromise on C++’s
outdated and unworkable core principles and adopt mechanisms more like
Rust’s. In the compiler business this is called <em>carcinization</em>:
a tendency of non-crab organisms to evolve crab-like features.</p>
<ul>
<li>Standard C++ doesn’t have aliasing information. We need <strong>a
new reference type</strong> that upholds the “mutation XOR aliasing”
rule as a program-wide invariant.</li>
<li>Standard C++ doesn’t have lifetime information. We need
<strong>lifetime parameters</strong> to indicate constraint
relationships between function parameters and return references.</li>
<li>Safety is a transitive property. It has to be upheld with a
<em><strong>safe-specifier</strong></em> on functions to establish the
absence of soundness preconditions and an
<em><strong>unsafe-block</strong></em> to call unsafe operations.</li>
<li>Lifetime constraints are a transitive property. They must be upheld
by both caller and callee as <strong>viral annotations</strong>.</li>
<li>Lifetime constraints on functions do not follow any particular
convention. Constraints that deviate from a default (such as the
lifetime elision rules) require annotation, even <strong>heavy
annotations</strong> that may exceed 1 per 1,000 lines of code.</li>
<li>The standard conversion rules make exclusivity enforcement
impossible. We have to change the language default, establishing
<strong>no implicit mutation</strong> in order to support aliasing in
functions that take const references.</li>
</ul>

<blockquote>
<p><em>I think it is worth pursuing this compatible path first before,
or at least at the same time as, trying to graft another foreign
language’s semantics onto C++ which turns C++ into “something else”
and/or build an off-ramp from C++.</em></p>
<p>– Pursue <span data-cites="P1179R1">[<a href="https://wg21.link/p1179r1" role="doc-biblioref">P1179R1</a>]</span> as a Lifetime TS<span data-cites="P3465R0">[<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf" role="doc-biblioref">P3465R0</a>]</span></p>
</blockquote>
<p>Who does this provincialism serve? The latest Android security study
“prioritizes transitioning to memory-safe languages.”<span data-cites="android-security">[<a href="https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html?m=1" role="doc-biblioref">android-security</a>]</span> The off-ramp from C++
is an increasingly viable and attractive strategy for projects looking
to reduce CVE exposure. The off-ramp is happening and its benefits are
measurable. As the Android study observes, “once we turn off the tap of
new vulnerabilities, they decrease exponentially, making all of our code
safer.”</p>
<p>All focus should be on turning off the tap of new vulnerabilities.
Incorporating Rust’s safety model into C++ helps in two ways:</p>
<ol type="1">
<li>It provides an off-ramp from unsafe C++ to Safe C++ within a single
toolchain. Projects can follow best practices for Safe Coding<span data-cites="safe-coding">[<a href="https://storage.googleapis.com/gweb-research2023-media/pubtools/7665.pdf" role="doc-biblioref">safe-coding</a>]</span> without retraining the
whole engineering staff in a new programming language.</li>
<li>It can hasten the migration to Rust by improving C++/Rust interop.
By extending C++ with representations of all Rust constructs that can
appear in function declarations (such as Rust enums, borrows and
lifetimes, ZSTs, traits, etc) the number of common vocabulary types is
greatly increased. This allows interop tooling to map between C++ and
Rust declarations at a more expressive level than the current C-level
API.</li>
</ol>
<p>C++ can be made memory safe, but not by dismissing everything that
works, which is what the authors of Safety Profiles do. The language
must evolve to be more explicit in how it expresses aliasing, lifetime
and safeness properties. C++ can meet the security needs of its users,
both in a principal role, and, for those projects determined to take the
off-ramp, in an important supporting role.</p>

<div id="refs" data-entry-spacing="1" role="doc-bibliography">




<div id="ref-P1179R1" role="doc-biblioentry"><p>
[P1179R1] Herb Sutter. 2019-11-22. Lifetime safety: Preventing common
dangling. </p><a href="https://wg21.link/p1179r1"><p>https://wg21.link/p1179r1</p></a>
</div>
<div id="ref-P3081R0" role="doc-biblioentry"><p>
[P3081R0] Core safety Profiles&#34; Specification, adoptability, and impact.
</p><a href="https://isocpp.org/files/papers/P3081R0.pdf"><p>https://isocpp.org/files/papers/P3081R0.pdf</p></a>
</div>



<div id="ref-safe-coding" role="doc-biblioentry"><p>
[safe-coding] Secure by Design: Google’s Perspective on Memory Safety.
</p><a href="https://storage.googleapis.com/gweb-research2023-media/pubtools/7665.pdf"><p>https://storage.googleapis.com/gweb-research2023-media/pubtools/7665.pdf</p></a>
</div>
<div id="ref-type-and-resource-safety-2015" role="doc-biblioentry"><p>
[type-and-resource-safety-2015] A brief introduction to C++&#34;s model for
type- and resource- safety. </p><a href="https://www.stroustrup.com/resource-model.pdf"><p>https://www.stroustrup.com/resource-model.pdf</p></a>
</div>
</div>
</div>
</div></div>
  </body>
</html>
