<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://insearchofsecrets.com/2014/08/04/lisp-smalltalk-and-the-power-of-symmetry/">Original</a>
    <h1>Lisp, Smalltalk, and the power of symmetry (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>Like many hackers, my first real programming language love was <a href="http://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Lisp.</a> Paul Graham, who inspired my own explorations of the language, is a particular advocate and has written <a href="http://www.paulgraham.com/lisp.html">quite a bit</a> about Lisp and <a href="http://www.paulgraham.com/diff.html">what makes it different</a> from other programming languages. So what does make Lisp different? Why does Lisp continue to be one of the most powerful, flexible, and concise programming languages in existence, despite the fact that it was invented in 1958–making it the second-oldest high-level programming language in the world?<span id="more-536"></span></p>
<p>Paul Graham’s answer is <a href="http://www.paulgraham.com/avg.html">macros:</a></p>
<blockquote><p>Many languages have something called a macro. But Lisp macros are unique. […]</p>
<p>Lisp code is made out of Lisp data objects. And not in the trivial sense that the source files contain characters, and strings are one of the data types supported by the language. Lisp code, after it’s read by the parser, is made of data structures that you can traverse.</p>
<p>If you understand how compilers work, what’s really going on is not so much that Lisp has a strange syntax as that Lisp has no syntax. You write programs in the parse trees that get generated within the compiler when other languages are parsed. But these parse trees are fully accessible to your programs. You can write programs that manipulate them. In Lisp, these programs are called macros. They are programs that write programs.</p></blockquote>
<p>There’s an interesting implication hidden in PG’s argument here. What he’s saying is that macros make Lisp powerful because they allow you to write programs that themselves write programs. But that’s what macros <em>are,</em> not what enables them–Lisp’s macros aren’t the cause of its power, they’re a symptom of it. What makes Lisp powerful isn’t its macros, it’s the fact that <strong>Lisp runs in the same context it’s written in.</strong> It’s <a href="http://en.wikipedia.org/wiki/S-expression">s-expressions</a> all the way down. This leads to an interesting possibility: could there be other ways to achieve similar power? Are macros the only possible way to make programs that write programs, or might there be others?</p>
<p>When I studied computer languages in college, the second language we looked at after Lisp was <a href="http://en.wikipedia.org/wiki/Smalltalk">Smalltalk.</a> I had been so impressed with the power and flexibility of Lisp that the first question out of my mouth that day was “does Smalltalk have macros?” My professor, after thinking it over for a second, replied that “Smalltalk doesn’t need macros.” Huh? Smalltalk doesn’t need macros? Why not? What does it have instead? It took me three years to figure it out: Smalltalk doesn’t need macros because it has classes instead.</p>
<p>It may seem strange to compare object-oriented classes to Lisp macros. Aren’t classes and class structures notoriously <a href="http://en.wikipedia.org/wiki/Circle-ellipse_problem">rigid,</a> <a href="http://en.wikipedia.org/wiki/Fragile_base_class">brittle,</a> and prone to <a href="http://en.wikipedia.org/wiki/Spaghetti_code">spaghetti code?</a> Isn’t all that the opposite of a Lisp macro?</p>
<p>It’s true that the usual flavor of Object-Oriented Programming (“OOP,” as in “OOPs what was I thinking when I designed this class hierarchy”) has issues. Languages such as Java, C++, and even Python seem to think that “object-oriented” means mostly “classes and inheritance.” Which is sort of like saying that “driving” means mostly “buttons and pedals.” What most of these languages seem to miss is that Smalltalk’s class system, like Lisp’s macro system, is a <em>symptom</em> of the power already available in the language, not its cause. If it didn’t already have it, it wouldn’t really be that hard to add it in yourself.</p>
<p>Without Smalltalk’s underlying fundamentals, class inheritance becomes nothing more than a tool for code reuse. As such, it is neither the only nor necessarily the best such tool. The real power of Smalltalk’s <a href="http://www.smalltalk.org/articles/article_20100320_a3_Getting_The_Message.html">object system,</a> including its classes, is not inheritance–it’s <em>reflection.</em> Just as Lisp macros are powerful because they can operate on any Lisp code, <em>including themselves,</em> Smalltalk classes are powerful because <em>they themselves are objects.</em> Smalltalk, like Lisp, <strong>runs in the same context it’s written in.</strong> It’s <a href="http://onsmalltalk.com/domain-specific-languages-ruby-a-sign-post-on-the-road-to-smalltalk">objects all the way down.</a></p>
<p>Lisp is powerful because all Lisp programs are also Lisp data–everything that can be run can be written (and read) as an s-expression. Macros in Lisp are simply what happens when you apply this relationship inductively: they are code that manipulates data that is itself code.</p>
<p>Smalltalk is powerful because <em>all Smalltalk data are programs</em>–all information is embodied by running, living objects. Class programming in Smalltalk is simply data manipulating programs that are themselves data–it’s the inverse of the Lisp philosophy, but the end result is the same. It’s what enables the Smalltalk debugger to freeze, dissect, modify, and resume programs mid-execution. It’s what enables the browser to instantly find all objects that respond to a given message, or all superclasses <em>and subclasses</em> of a given object, or every running instance of a given class. It’s why the Smalltalk IDE isn’t just written in the language, it quite literally <em>is</em> the language.</p>
<p>Lisp, as PG mentions above, has effectively no syntax: because Lisp source code is expressed in the same form as running Lisp code, which is expressed in the same form as Lisp data, the three are interchangeable. Programs can write data which can be run as programs which can write data which can…</p>
<p>Smalltalk goes one further than Lisp: it’s not that Smalltalk’s source code has no syntax so much as Smalltalk <em>has no source code.</em> “Source code,” after all, just means “program that isn’t running,” and there is no such thing as a Smalltalk program <a href="http://en.wikipedia.org/wiki/Smalltalk#Image-based_persistence">that isn’t running!</a> Because there is absolutely nothing in Smalltalk except “data that runs”–which is what an object is, after all–then there is no distinction in Smalltalk between data and programs. Data (objects) can write programs (objects) which write data (objects) which write programs (objects) which…</p>
<p>So Lisp macros aren’t the only way that programs can write programs, after all. The only thing that seems to be required for a language to allow this is a pervasive symmetry between programs and data. If a language allows programs and data to be treated as the same thing, then that language becomes easily and infinitely extensible–a <a href="http://onsmalltalk.com/languages-of-the-gods">language of the gods.</a> S-expressions, it turns out, are not the only way to do this–you can do it with objects as well. I wonder if there are still more ways we haven’t yet tried?</p>
			
			
				</div></div>
  </body>
</html>
