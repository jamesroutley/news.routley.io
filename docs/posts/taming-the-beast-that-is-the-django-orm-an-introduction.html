<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.davidhang.com/blog/2024-09-01-taming-the-django-orm/">Original</a>
    <h1>Taming the beast that is the Django ORM – An introduction</h1>
    
    <div id="readability-page-1" class="page"><div>  <p><img src="https://www.davidhang.com/_astro/1.UiFfZ6wR_IHH0Y.webp" alt="man fighting dragon which represents the django orm" width="1024" height="1024" loading="lazy" decoding="async"/></p>
<p>The material this blog post was originally developed from was a bunch of slides
used for a skill share presentation I gave at my workplace <span>@</span> <a href="https://coreplan.io">coreplan.io</a>.</p>
<p>I have 3+ years of experience with Django, with it being the main framework that
underpins the backend of CorePlan’s main SaaS product. It is a mature, batteries
included framework that has been around for a while now. One particular powerful
yet dangerous feature of Django is the ORM. This is a Django specific ORM which
cannot be separated from the rest of the framework. The other major python ORM
is SQLAlchemy which can be used with other python web frameworks, but is an
independent tool.</p>
<p>Below are some of the things that I have learned about the Django ORM, how it
compares to raw SQL and gotchas that you should be aware of when using it.</p>
<hr/>
<h2 id="what-is-an-orm-object-relational-mapper">What is an ORM (Object Relational Mapper)?</h2>
<ul>
<li>Abstraction over SQL to interact with databases</li>
</ul>
<p>Code -&gt; SQL</p>
<pre tabindex="0" data-language="python"><code><span><span>Hole.objects.all()</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> *</span><span> FROM</span><span> drilling_hole;</span></span>
<span></span></code></pre>
<hr/>
<h2 id="why-use-an-orm---pros">Why use an ORM? - Pros</h2>
<ul>
<li>Abstraction over SQL, no need to write raw SQL (plus and minus)</li>
<li>Portability - Can change out database engines easily !?
<ul>
<li>Probably not true, often will rely on db specific features e.g. postgres jsonb, triggers, etc</li>
</ul>
</li>
<li>Direct mapping from db to models</li>
<li>Automatic schema generation
<ul>
<li>Migrations are automatically generated</li>
</ul>
</li>
<li>Security
<ul>
<li>abstracts away enough that sql injection is less likely</li>
</ul>
</li>
</ul>
<hr/>
<h2 id="why-use-an-orm---cons">Why use an ORM? - Cons</h2>
<ul>
<li>Abstraction over SQL…
<ul>
<li>Hides the underlying SQL</li>
<li>Can be difficult to debug</li>
<li>Lazy loading can cause N+1 queries without the developer realising</li>
<li>Harder to onboard new developers if they haven’t used Django before</li>
</ul>
</li>
<li>Performance
<ul>
<li>Generated sql be slower than crafted SQL</li>
</ul>
</li>
</ul>
<hr/>
<h2 id="fundamentals">Fundamentals</h2>
<ul>
<li>Models = Tables</li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span># drilling/models.py</span></span>
<span></span>
<span><span>from</span><span> django.db </span><span>import</span><span> models</span></span>
<span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>    name </span><span>=</span><span> models.TextField()</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="sql"><code><span><span>CREATE</span><span> TABLE</span><span> drilling_hole</span><span> (</span></span>
<span><span>    id </span><span>SERIAL</span><span> PRIMARY KEY</span><span>,</span></span>
<span><span>    name</span><span> VARCHAR</span><span>(</span><span>100</span><span>)</span></span>
<span><span>);</span></span>
<span></span></code></pre>
<hr/>
<h2 id="migrations">Migrations</h2>
<pre tabindex="0" data-language="bash"><code><span><span>python</span><span> manage.py</span><span> makemigrations</span><span> # generate migration files</span></span>
<span><span>python</span><span> manage.py</span><span> migrate</span><span> # apply migrations</span></span>
<span></span>
<span><span>python</span><span> manage.py</span><span> drilling</span><span> --empty</span><span> # generate empty file for data migration</span></span>
<span></span></code></pre>
<p><a href="https://docs.djangoproject.com/en/dev/topics/migrations/">https://docs.djangoproject.com/en/dev/topics/migrations/</a></p>
<hr/>

<h2 id="querying">Querying</h2>
<ul>
<li><code>ActiveRecord</code> pattern - ala Ruby on Rails style</li>
<li>QuerySets (<code>Hole.objects.all()</code>)
<ul>
<li>lazy</li>
<li>chainable</li>
<li>cached when iterated over multiple times <a href="https://docs.djangoproject.com/en/dev/topics/db/queries/#caching-and-querysets">!?</a>
<ul>
<li>I would not recommend relying on this because it hard to comprehend when it is cached and when it is not when you are reading code</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>holes_qs </span><span>=</span><span> Hole.objects.filter(</span><span>name</span><span>=</span><span>&#34;cheese&#34;</span><span>) </span><span># not evaluated yet</span></span>
<span><span>holes_qs </span><span>=</span><span> holes_qs.filter(</span><span>depth__gt</span><span>=</span><span>100</span><span>) </span><span># still not evaluated</span></span>
<span></span>
<span><span>list</span><span>(holes_qs) </span><span># evaluated</span></span>
<span><span>list</span><span>(holes_qs) </span><span># cached</span></span>
<span></span>
<span><span>holes_qs[</span><span>2</span><span>] </span><span># not cached</span></span>
<span><span>holes_qs.first() </span><span># not cached</span></span>
<span><span>holes_qs.get(</span><span>id</span><span>=</span><span>1</span><span>) </span><span># not cached</span></span>
<span></span></code></pre>
<hr/>
<h2 id="where">WHERE</h2>
<ul>
<li><code>WHERE</code> clause ≈ <code>filter()</code></li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>holes_qs </span><span>=</span><span> Hole.objects.filter(</span><span>name</span><span>=</span><span>&#34;cheese&#34;</span><span>)</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> *</span><span> </span></span>
<span><span>FROM</span><span> drilling_hole;</span></span>
<span><span>WHERE</span><span> drilling_hole</span><span>.</span><span>name</span><span> =</span><span> &#39;cheese&#39;</span><span>;</span></span>
<span></span></code></pre>
<hr/>
<h2 id="where-across-tables">WHERE across tables?</h2>
<ul>
<li>But how do you do a left/inner join? With the ORM it isn’t done declaratively, but implicitly</li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  pad </span><span>=</span><span> models.ForeignKey(Pad, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span></span>
<span><span>class</span><span> Pad</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>holes_qs </span><span>=</span><span> Hole.objects.filter(</span><span>pad__name</span><span>=</span><span>&#34;cheese board&#34;</span><span>)</span></span>
<span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> *</span><span> </span></span>
<span><span>FROM</span><span> drilling_hole;</span></span>
<span><span>INNER JOIN</span><span> drilling_pad </span><span>ON</span><span> drilling_hole</span><span>.</span><span>pad_id</span><span> =</span><span> drilling_pad</span><span>.</span><span>id</span></span>
<span><span>WHERE</span><span> drilling_pad</span><span>.</span><span>name</span><span> =</span><span> &#39;cheese board&#39;</span><span>;</span></span>
<span></span></code></pre>
<hr/>
<h2 id="where-other-conditionals">WHERE other conditionals</h2>
<ul>
<li><code>filter(name=&#34;cheese&#34;)</code> -&gt; <code>filter(name__exact=&#34;cheese&#34;)</code> -&gt; <code>WHERE name = &#39;cheese&#39;</code></li>
<li><code>filter(name__iexact=&#34;cheese&#34;)</code> -&gt; <code>WHERE name ILIKE &#39;cheese&#39;</code></li>
<li><code>filter(name__contains=&#34;cheese&#34;)</code> -&gt; <code>WHERE name LIKE &#39;%cheese%&#39;</code></li>
<li><code>filter(name__icontains=&#34;cheese&#34;)</code> -&gt; <code>WHERE name ILIKE &#39;%cheese%&#39;</code></li>
<li><code>filter(name__in=[&#34;cheese&#34;, &#34;board&#34;])</code> -&gt; <code>WHERE name IN (&#39;cheese&#39;, &#39;board&#39;)</code></li>
<li><code>filter(name__gt=100)</code> -&gt; <code>WHERE name &gt; 100</code> etc</li>
<li><code>filter(name__isnull=True)</code> -&gt; <code>WHERE name IS NULL</code>
<ul>
<li>At least for postgres shouldn’t <code>name = None</code>, <a href="https://www.postgresql.org/docs/current/functions-comparison.html">null != null</a></li>
</ul>
</li>
</ul>
<hr/>
<h2 id="as">AS</h2>
<ul>
<li><code>annotate</code> ≈ <code>AS</code></li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>holes_qs </span><span>=</span><span> Hole.objects.annotate(</span><span>this_thang</span><span>=</span><span>F(</span><span>&#34;pad__name&#34;</span><span>))</span></span>
<span><span>hole </span><span>=</span><span> holes_qs.first()</span></span>
<span><span>print</span><span>(hole.this_thang)</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> </span></span>
<span><span>  *</span><span> , </span></span>
<span><span>  drilling_pad</span><span>.</span><span>name</span><span> AS</span><span> this_thang</span></span>
<span><span>FROM</span><span> drilling_hole;</span></span>
<span><span>INNER JOIN</span><span> &#34;drilling_pad&#34;</span><span> ON</span><span> (</span><span>&#34;drilling_hole&#34;</span><span>.</span><span>&#34;pad_id&#34;</span><span> =</span><span> &#34;drilling_pad&#34;</span><span>.</span><span>&#34;id&#34;</span><span>)</span></span>
<span></span>
<span></span></code></pre>
<hr/>
<h2 id="subqueries">Subqueries</h2>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Project</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>class</span><span> Pad</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  pad </span><span>=</span><span> models.ForeignKey(Pad, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span><span>  project </span><span>=</span><span> models.ForeignKey(Project, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span></span>
<span><span># find pads that are on project_id=1</span></span>
<span><span>hole_subquery </span><span>=</span><span> Hole.objects.filter(</span><span>project_id</span><span>=</span><span>1</span><span>).values(</span><span>&#34;pk&#34;</span><span>)</span></span>
<span><span>pad_qs </span><span>=</span><span> Pad.objects.filter(</span><span>hole__in</span><span>=</span><span>Subquery(hole_subquery))</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> &#34;drilling_pad&#34;</span><span>.</span><span>&#34;id&#34;</span><span>,</span></span>
<span><span> &#34;drilling_pad&#34;</span><span>.</span><span>&#34;name&#34;</span></span>
<span><span>FROM</span><span> &#34;drilling_pad&#34;</span></span>
<span><span> INNER JOIN</span><span> &#34;drilling_hole&#34;</span><span> ON</span><span> (</span><span>&#34;drilling_pad&#34;</span><span>.</span><span>&#34;id&#34;</span><span> =</span><span> &#34;drilling_hole&#34;</span><span>.</span><span>&#34;pad_id&#34;</span><span>)</span></span>
<span><span>WHERE</span><span> &#34;drilling_hole&#34;</span><span>.</span><span>&#34;id&#34;</span><span> IN</span><span> (</span></span>
<span><span>  SELECT</span><span> U0.</span><span>&#34;id&#34;</span></span>
<span><span>  FROM</span><span> &#34;drilling_hole&#34;</span><span> U0</span></span>
<span><span>  WHERE</span><span> U0.</span><span>&#34;project_id&#34;</span><span> =</span><span> 1</span></span>
<span><span> )</span></span>
<span></span></code></pre>
<hr/>

<p>Correlated subqueries are where the inner query depends on outer query</p>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Pad</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  pad </span><span>=</span><span> models.ForeignKey(Pad, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span></span>
<span><span># include the hole id of any hole that has a foreign key to the pad</span></span>
<span><span>hole_subquery </span><span>=</span><span> Hole.objects.filter(</span><span>pad_id</span><span>=</span><span>OuterRef(</span><span>&#34;pk&#34;</span><span>)).values(</span><span>&#34;pk&#34;</span><span>)</span></span>
<span><span>pad_qs </span><span>=</span><span> Pad.objects.annotate(</span><span>hole_id</span><span>=</span><span>Subquery(hole_subquery))</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> &#34;drilling_pad&#34;</span><span>.</span><span>&#34;id&#34;</span><span>,</span></span>
<span><span> &#34;drilling_pad&#34;</span><span>.</span><span>&#34;name&#34;</span><span>,</span></span>
<span><span> (</span></span>
<span><span>  SELECT</span><span> U0.</span><span>&#34;id&#34;</span></span>
<span><span>  FROM</span><span> &#34;drilling_hole&#34;</span><span> U0</span></span>
<span><span>  WHERE</span><span> U0.</span><span>&#34;pad_id&#34;</span><span> =</span><span> (</span><span>&#34;drilling_pad&#34;</span><span>.</span><span>&#34;id&#34;</span><span>)</span></span>
<span><span> ) </span><span>AS</span><span> &#34;hole_id&#34;</span></span>
<span><span>FROM</span><span> &#34;drilling_pad&#34;</span></span>
<span></span></code></pre>
<hr/>
<h2 id="performance-improvements">Performance improvements</h2>
<ul>
<li>Reduce N+1
<ul>
<li>You typically want to reduce N+1 queries because they have communication
overhead</li>
<li><code>select_related</code></li>
<li><code>prefetch_related</code></li>
<li>You also might choose to use <code>annotate()</code> instead of <code>select_related</code>
because select related pulls all the data for the associated table when you
might only need one column. That associated might have a jsonb column which
contains a lot of unnecessary data that you don’t need.</li>
</ul>
</li>
</ul>
<hr/>

<pre tabindex="0" data-language="python"><code><span><span>holes </span><span>=</span><span> Hole.objects.all()</span></span>
<span><span>for</span><span> hole </span><span>in</span><span> holes:</span></span>
<span><span>  print</span><span>(hole.pad.name) </span><span># N+1 queries</span></span>
<span></span>
<span><span>holes </span><span>=</span><span> Hole.objects.select_related(</span><span>&#34;pad&#34;</span><span>)</span></span>
<span></span>
<span><span>for</span><span> hole </span><span>in</span><span> holes:</span></span>
<span><span>  print</span><span>(hole.pad.name) </span><span># no extra query</span></span>
<span></span>
<span></span></code></pre>
<hr/>

<p>You would use prefetch related when you are not pulling a direct foreign key
such a many-to-many relationship like below.</p>
<p><img src="https://www.davidhang.com/_astro/2.Cd5VA_n2_Z22TJnn.svg" alt="width:400px" width="340" height="465" loading="lazy" decoding="async"/></p>
<pre tabindex="0" data-language="python"><code><span></span>
<span><span>class</span><span> Faculty</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>class</span><span> Course</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  faculty </span><span>=</span><span> models.ForeignKey(Faculty, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span></span>
<span><span>class</span><span> Student</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  courses </span><span>=</span><span> models.ManyToManyField(Course, </span><span>through</span><span>=</span><span>&#34;Enrolment&#34;</span><span>)</span></span>
<span></span>
<span><span>class</span><span> Enrolment</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  course </span><span>=</span><span> models.ForeignKey(Course, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span><span>  student </span><span>=</span><span> models.ForeignKey(Student, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span><span>  grade </span><span>=</span><span> models.FloatField()</span></span>
<span></span>
<span><span>students </span><span>=</span><span> Student.objects.prefetch_related(</span><span>&#34;courses&#34;</span><span>)</span></span>
<span></span>
<span><span>for</span><span> student </span><span>in</span><span> students:</span></span>
<span><span>  for</span><span> course </span><span>in</span><span> student.courses.all():</span></span>
<span><span>    print</span><span>(course.name) </span><span># no extra query</span></span>
<span><span>    print</span><span>(course.faculty.name) </span><span># extra query</span></span>
<span></span>
<span><span>students </span><span>=</span><span> Student.objects.prefetch_related(</span></span>
<span><span>  Prefetch(</span></span>
<span><span>    &#34;courses&#34;</span><span>, </span></span>
<span><span>    queryset</span><span>=</span><span>Course.objects.select_related(</span><span>&#34;faculty&#34;</span><span>)</span></span>
<span><span>  )</span></span>
<span><span>)</span></span>
<span></span>
<span><span>for</span><span> student </span><span>in</span><span> students:</span></span>
<span><span>  for</span><span> course </span><span>in</span><span> student.courses.all():</span></span>
<span><span>    print</span><span>(course.name) </span><span># no extra query</span></span>
<span><span>    print</span><span>(course.faculty.name) </span><span># no extra query</span></span>
<span></span></code></pre>
<hr/>
<h2 id="to_attr">to_attr</h2>
<p><code>to_attr</code> can be used to make “filtered” relationships available on the instance.</p>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Enrolment</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  course </span><span>=</span><span> models.ForeignKey(Course, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span><span>  student </span><span>=</span><span> models.ForeignKey(Student, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span><span>  grade </span><span>=</span><span> models.FloatField()</span></span>
<span></span>
<span><span>students </span><span>=</span><span> Student.objects.prefetch_related(</span></span>
<span><span>  Prefetch(</span></span>
<span><span>    &#34;course&#34;</span><span>, </span></span>
<span><span>    queryset</span><span>=</span><span>Course.objects.filter(</span><span>grade__gt</span><span>=</span><span>80.0</span><span>).select_related(</span><span>&#34;faculty&#34;</span><span>), </span><span>to_attr</span><span>=</span><span>&#34;hd_courses&#34;</span></span>
<span><span>  )</span></span>
<span><span>)</span></span>
<span></span>
<span><span>for</span><span> student </span><span>in</span><span> students:</span></span>
<span><span>  for</span><span> course </span><span>in</span><span> student.hd_courses.all():</span></span>
<span><span>    ...</span></span>
<span></span></code></pre>
<hr/>
<h2 id="multiple-instances-when-filtering-across-many-to-many">Multiple instances when filtering across many-to-many</h2>
<p>One gotcha is selecting across a many-to-many relationship can return multiple of the same instances.</p>
<p><img src="https://www.davidhang.com/_astro/3.DMAdguVG_TLkyj.webp" alt="data model showing many to many relationship" width="530" height="810" loading="lazy" decoding="async"/></p>
<pre tabindex="0" data-language="python"><code><span><span>Student.objects.filter(</span><span>courses__faculty__name</span><span>=</span><span>&#34;Science&#34;</span><span>) </span><span># inner join returns duplicated rows</span></span>
<span><span>&lt;</span><span>QuerySet [</span><span>&lt;</span><span>Student: Student </span><span>object</span><span> (</span><span>1</span><span>)</span><span>&gt;</span><span>, </span><span>&lt;</span><span>Student: Student </span><span>object</span><span> (</span><span>1</span><span>)</span><span>&gt;</span><span>]</span><span>&gt;</span></span>
<span></span>
<span><span>Student.objects.filter(</span><span>courses__faculty__name</span><span>=</span><span>&#34;Science&#34;</span><span>).distinct()</span></span>
<span><span>&lt;</span><span>QuerySet [</span><span>&lt;</span><span>Student: Student </span><span>object</span><span> (</span><span>1</span><span>)</span><span>&gt;</span><span>]</span><span>&gt;</span></span>
<span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  &#34;testing_student&#34;</span><span>.</span><span>&#34;id&#34;</span><span>, </span></span>
<span><span>  &#34;testing_student&#34;</span><span>.</span><span>&#34;name&#34;</span><span> </span></span>
<span><span>FROM</span><span> </span></span>
<span><span>  &#34;testing_student&#34;</span><span> </span></span>
<span><span>INNER JOIN</span><span> </span></span>
<span><span>  &#34;testing_enrolment&#34;</span><span> </span></span>
<span><span>ON</span><span> </span></span>
<span><span>  (</span><span>&#34;testing_student&#34;</span><span>.</span><span>&#34;id&#34;</span><span> =</span><span> &#34;testing_enrolment&#34;</span><span>.</span><span>&#34;student_id&#34;</span><span>) </span></span>
<span><span>INNER JOIN</span><span> </span></span>
<span><span>  &#34;testing_course&#34;</span><span> </span></span>
<span><span>ON</span><span> </span></span>
<span><span>  (</span><span>&#34;testing_enrolment&#34;</span><span>.</span><span>&#34;course_id&#34;</span><span> =</span><span> &#34;testing_course&#34;</span><span>.</span><span>&#34;id&#34;</span><span>) </span></span>
<span><span>INNER JOIN</span><span> </span></span>
<span><span>  &#34;testing_faculty&#34;</span><span> </span></span>
<span><span>ON</span><span> </span></span>
<span><span>  (</span><span>&#34;testing_course&#34;</span><span>.</span><span>&#34;faculty_id&#34;</span><span> =</span><span> &#34;testing_faculty&#34;</span><span>.</span><span>&#34;id&#34;</span><span>)</span></span>
<span><span>WHERE</span><span> </span></span>
<span><span>  &#34;testing_faculty&#34;</span><span>.</span><span>&#34;name&#34;</span><span> =</span><span> &#39;Science&#39;</span></span>
<span></span></code></pre>
<hr/>
<h2 id="gotchas-and-other-funky-stuff">Gotchas and other Funky stuff</h2>
<ul>
<li>Model instances when retrieved will try to populate all columns, if column
removed in migration, and the worker still up exception occurs
<ul>
<li><code>get()</code> or <code>first()</code></li>
<li><code>for hole in Hole.objects.all()</code></li>
</ul>
</li>
<li>This can make migrations hard, as older workers will be requesting columns that might have been removed or renamed which will cause errors</li>
<li>There are ways to do down-timeless migrations but are bit <a href="https://hackernoon.com/deleting-a-column-from-a-django-model-on-production">funky and multi
step</a></li>
<li>Recommendation is to avoid deleting or renaming columns</li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  pad </span><span>=</span><span> models.ForeignKey(Pad, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span></span>
<span><span>class</span><span> Pad</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>holes_qs </span><span>=</span><span> Hole.objects.annotate(</span><span>this_thang</span><span>=</span><span>F(</span><span>&#34;pad__name&#34;</span><span>)).get()</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> </span></span>
<span><span>  drilling_hole</span><span>.</span><span>name</span><span>, </span><span>-- pulls all columns </span></span>
<span><span>  drilling_hole</span><span>.</span><span>pad_id</span><span>,</span></span>
<span><span>  drilling_pad</span><span>.</span><span>name</span><span> AS</span><span> this_thang</span></span>
<span><span>FROM</span><span> drilling_hole;</span></span>
<span><span>WHERE</span><span> drilling_pad</span><span>.</span><span>name</span><span> =</span><span> &#39;cheese board&#39;</span><span>;</span></span>
<span><span>LIMIT</span><span> 1</span><span>;</span></span>
<span></span></code></pre>
<hr/>
<h2 id="values">Values</h2>
<ul>
<li>So how do you to only retrieve certain columns?</li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span><span>  pad </span><span>=</span><span> models.ForeignKey(Pad, </span><span>on_delete</span><span>=</span><span>models.</span><span>CASCADE</span><span>)</span></span>
<span></span>
<span><span>holes_qs </span><span>=</span><span> Hole.objects.values(</span><span>&#34;name&#34;</span><span>)</span></span>
<span></span>
<span><span>for</span><span> hole </span><span>in</span><span> holes_qs:</span></span>
<span><span>  print</span><span>(</span><span>type</span><span>(hole)) </span><span># dict</span></span>
<span><span>  # not `Hole` object, hence no class functions, no lazy loading e.g. can&#39;t access `hole.pad.name`</span></span>
<span></span></code></pre>
<p>⬇️</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span><span> </span></span>
<span><span>  drilling_hole</span><span>.</span><span>name</span><span>, </span><span>-- only pulls name and maps it to a python dictionary object</span></span>
<span><span>FROM</span><span> drilling_hole;</span></span>
<span></span></code></pre>
<ul>
<li>Less data sent down the wire, but no lazy loading and no class functions as
the data is a python dictionary</li>
</ul>
<hr/>
<h2 id="other-options">Other options</h2>
<ul>
<li><code>only()</code> and <code>defer()</code></li>
<li>Will retrieve model instances, but won’t retrieve all fields</li>
<li>Values not declared when accessed on the model are lazy loaded</li>
<li>Would not recommend to be used regularly, very high chance of N+1</li>
</ul>
<pre tabindex="0" data-language="python"><code><span><span>holes_qs </span><span>=</span><span> Hole.objects.only(</span><span>&#34;pad_id&#34;</span><span>)</span></span>
<span></span>
<span><span>for</span><span> hole </span><span>in</span><span> holes_qs:</span></span>
<span><span>  print</span><span>(hole.pad_id) </span><span># no extra query</span></span>
<span><span>  print</span><span>(hole.name) </span><span># name will be lazy loaded, N+1 queries</span></span>
<span></span></code></pre>
<hr/>
<h3 id="how-do-you-know-what-sql-is-being-generated">How do you know what SQL is being generated?</h3>
<ul>
<li><code>print(queryset.query)</code></li>
<li><a href="https://github.com/jazzband/django-debug-toolbar">Django Debug Toolbar</a></li>
<li><a href="https://kolo.app/">Kolo</a></li>
</ul>
<hr/>
<h2 id="updating-rows">Updating rows</h2>
<p>There are three typical ways to update a row in the database.</p>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Hole</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>  name </span><span>=</span><span> models.TextField()</span></span>
<span></span>
<span><span>instance </span><span>=</span><span> Hole.objects.create(</span><span>name</span><span>=</span><span>&#34;cheese&#34;</span><span>)</span></span>
<span></span>
<span><span># save()</span></span>
<span><span>instance.name </span><span>=</span><span> &#34;board&#34;</span></span>
<span><span>instance.save()</span></span>
<span></span>
<span><span># update()</span></span>
<span><span>Model.objects.filter(</span><span>name</span><span>=</span><span>&#34;board&#34;</span><span>).update(</span><span>name</span><span>=</span><span>&#34;board2&#34;</span><span>)</span></span>
<span></span>
<span><span># bulk_update()</span></span>
<span><span>instance.name </span><span>=</span><span> &#34;board3&#34;</span></span>
<span><span>instances_to_update </span><span>=</span><span> [instance]</span></span>
<span><span>Model.objects.bulk_update(instances_to_update, [</span><span>&#34;name&#34;</span><span>])</span></span>
<span></span></code></pre>
<hr/>
<h2 id="problems-with-updates">Problems with updates</h2>
<ul>
<li><code>update()</code> and <code>bulk_update()</code> do not trigger <code>save()</code> method on the model</li>
<li>built in django signals (publish/subscribe pattern), there are post_save and pre_save signals which can be triggered when calling <code>save()</code>
<ul>
<li><code>update()</code> and <code>bulk_update()</code> do not trigger those signals…</li>
</ul>
</li>
<li><code>updated_at</code> column would not normally be updated when calling <code>update()</code> or
<code>bulk_update()</code> but if queryset is a descendant of <code>CoreplanQuerySet</code> then it will.</li>
</ul>
<hr/>

<ul>
<li>Pagination / order_by
<ul>
<li>Not a Django ORM thing, but a Django ORM hides the implementation detail,
which may lead to unexpected result</li>
<li>Page pagination is default in DRF list views and implemented with <code>LIMIT</code> and <code>OFFSET</code> in SQL</li>
</ul>
</li>
</ul>
<p><code>?page_size=10&amp;page=3</code></p>
<pre tabindex="0" data-language="plaintext"><code><span><span>SELECT * </span></span>
<span><span>FROM drilling_hole </span></span>
<span><span>LIMIT 10 </span></span>
<span><span>OFFSET 20;</span></span>
<span><span></span></span></code></pre>
<p>Anything wrong with this query?</p>
<ul>
<li>There is no deterministic guarantee that the same 10 rows will be returned each time.</li>
<li>A plain <code>SELECT</code> in postgres (may be different in different dbs) provides no
guarantee of order, unless <code>ORDER BY</code> is specified</li>
<li>It often appears to return in insertion/<code>id</code> order, but that is not guaranteed
in postgres</li>
<li>Model Meta <code>ordering</code> may set a default order, but sometimes tht is <a href="https://docs.djangoproject.com/en/dev/releases/2.2/#features-deprecated-in-2-2">ignored</a></li>
<li>For list views you should to provide a deterministic order_by</li>
<li><code>order_by(name)</code> is not enough if name is not unique
<ul>
<li><code>order_by(name, id)</code> is required, because id is unique</li>
</ul>
</li>
<li>This can been the the cause of some flaky tests issues where lists are
returned seemingly in insertion order and asserted to return in id order</li>
</ul>
<hr/>
<p>Thanks for reading! I hope this has been useful to you. There are definitely
more particularities and gotchas to be aware of when using the Django ORM and
Django in general but I think these are the most common ones.</p>  </div></div>
  </body>
</html>
