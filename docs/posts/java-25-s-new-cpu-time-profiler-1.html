<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mostlynerdless.de/blog/2025/06/11/java-25s-new-cpu-time-profiler-1/">Original</a>
    <h1>Java 25&#39;s new CPU-Time Profiler (1)</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>More than three years in the making, with a concerted effort starting last year, my CPU-time profiler <a href="https://github.com/openjdk/jdk/pull/25302">landed</a> in Java with OpenJDK 25. It’s an experimental new profiler/method sampler that helps you find performance issues in your code, having distinct advantages over the current sampler. This is what this week’s and next week’s blog posts are all about. This week, I will cover why we need a new profiler and what information it provides; next week, I’ll cover the technical internals that go beyond what’s written in the JEP. I will quote the <a href="https://openjdk.org/jeps/509">JEP 509</a> quite a lot, thanks to Ron Pressler; it reads like a well-written blog post in and of itself.</p>


<div>
<figure><img decoding="async" width="2000" height="1441" src="https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-2000x1441.png" alt="" srcset="https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-2000x1441.png 2000w, https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-300x216.png 300w, https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-768x553.png 768w, https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-1536x1107.png 1536w, https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-2048x1476.png 2048w, https://mostlynerdless.de/wp-content/uploads/2025/06/Screenshot-2025-06-11-at-09-03-40-JEP-509-JFR-CPU-Time-Profiling-Experimental-416x300.png 416w" sizes="(max-width: 2000px) 100vw, 2000px"/></figure></div>


<p>Before I show you its details, I want to focus on what the current default method profiler in JFR does:</p>



<h2>Current JFR Profiling Strategy</h2>



<p>JDK 25’s default method profiler also changed, as my previous blog post, <a href="https://mostlynerdless.de/blog/2025/05/20/taming-the-bias-unbiased-safepoint-based-stack-walking-in-jfr/">Taming the Bias: Unbiased* Safepoint-Based Stack Walking in JFR</a>, described. However, the profiling strategy remained the same.</p>



<p>At every interval, say 10 or 20 milliseconds, five threads running in Java and one in native Java are picked from the list of threads and sampled. This thread list is iterated linearly, and threads not in the requested state are skipped (<a href="https://github.com/openjdk/jdk/blob/9586817cea3f1cad8a49d43e9106e25dafa04765/src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp#L228">source</a>).</p>



<h2>Problems?</h2>



<p>This strategy has problems, as also covered in <a href="https://fosdem.org/2025/schedule/event/fosdem-2025-4848-advancing-java-profiling-achieving-precision-and-stability-with-jfr-ebpf-and-user-context/">a talk by Jaroslav Bachorik and me at this year’s FOSDEM</a>:</p>



<figure><div>

</div></figure>



<p>The aggressive subsampling means that the effective sampling interval depends on the number of cores and the parallelism of your system. Say we have a large machine on which 32 threads can run in parallel. Then JFR on samples at most 19%, turning a sampling rate of 10ms into 53ms. This is an inherent property of wall-clock sampling, as the sampler considers threads on the system. This number can be arbitrarily large, so sub-sampling is necessary.</p>



<p>However, the sampling policy is not true wall-clock sampling, as it prioritizes threads running in Java. Consider a setting where 10 threads run in native and 5 in Java. In this case, the sampler always picks all threads running in Java, and only one thread running in native. This might be confusing and may lead users to the wrong conclusions.</p>



<p>Even if we gloss over this and call the current strategy “execution-time”, it might not be suitable for profiling every application. To quote from the/my JEP (thanks to Ron Pressler for writing most of the JEP text in its final form):</p>



<blockquote>
<p>Execution time does not necessarily reflect CPU time. A method that sorts an array, e.g., spends all of its time on the CPU. Its execution time corresponds to the number of CPU cycles it consumes. In contrast, a method that reads from a network socket might spend most of its time idly waiting for bytes to arrive over the wire. Of the time it consumes, only a small portion is spent on the CPU. An execution-time profile will not distinguish between these cases.</p>



<p>Even a program that does a lot of I/O can be constrained by the CPU. A computation-heavy method might consume little execution time compared the program’s I/O operations, thus having little effect on latency — but it might consume most of the program’s CPU cycles, thus affecting throughput. Identifying and optimizing such methods will reduce CPU consumption and improve the program’s throughput — but in order to do so, we need to profile CPU time rather than execution time.</p>
<cite><a href="https://openjdk.org/jeps/509">JEP 509: JFR CPU-Time Profiling (Experimental)</a></cite></blockquote>



<h2>Execution-time Example</h2>



<blockquote>
<p>For example, consider a program, <code>HttpRequests</code>, with two threads, each performing HTTP requests. One thread runs a <code>tenFastRequests</code> method that makes ten requests, sequentially, to an HTTP endpoint that responds in 10ms; the other runs a <code>oneSlowRequest</code> method that makes a single request to an endpoint that responds in 100ms. The average latency of both methods should be about the same, and so the total time spent executing them should be about the same.</p>



<p>We can record a stream of execution-time profiling events like so:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ java -XX:StartFlightRecording=filename=profile.jfr,settings=profile.jfc HttpRequests client</pre>
<cite><a href="https://openjdk.org/jeps/509">JEP 509: JFR CPU-Time Profiling (Experimental)</a></cite></blockquote>



<p>You can find the program on <a href="https://gist.github.com/parttimenerd/d66364f2086089761eb2fec7eda026d7">GitHub</a>. Be aware that it requires the server instance to run alongside, start it via</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">java HttpRequests server</pre>



<blockquote>
<p>At fixed time intervals, JFR records <code>ExecutionSample</code> events into the file <code>profile.jfr</code>. Each event captures the stack trace of a thread running Java code, thus recording all of the methods currently running on that thread. (The file <code>profile.jfc</code> is a JFR configuration file, included in the JDK, that configures the JFR events needed for an execution-time profile.)</p>



<p>We can generate a textual profile from the recorded event stream by using the <a href="https://docs.oracle.com/en/java/javase/24/docs/specs/man/jfr.html"><code>jfr</code></a> tool included in the JDK:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ jfr view native-methods profile.jfr

                      Waiting or Executing Native Methods

Method                                                          Samples Percent
--------------------------------------------------------------- ------- -------
sun.nio.ch.SocketDispatcher.read0(FileDescriptor, long, int)        102  98.08%
...</pre>



<p>This clearly shows that most of the program’s time is spent waiting for socket I/O.</p>



<p>We can generate a graphical profile, in the form of a <a href="https://www.brendangregg.com/flamegraphs.html">flame graph</a>, by using the <a href="https://www.oracle.com/java/technologies/jdk-mission-control.html">JDK Mission Control tool</a> (JMC):</p>



<blockquote>
<figure><img decoding="async" src="https://bugs.openjdk.org/secure/attachment/110756/profile.png" alt="Execution time flame graph"/></figure>
</blockquote>



<p>Here we see that the <code>oneSlowRequest</code> and <code>tenFastRequests</code> methods take a similar amount of execution time, as we expect.</p>



<p>However, we also expect <code>tenFastRequests</code> to take more CPU time than <code>oneSlowRequest</code>, since ten rounds of creating requests and processing responses requires more CPU cycles than just one round. If these methods were run concurrently on many threads then the program could become CPU-bound, yet an execution-time profile would still show most of the program’s time being spent waiting for socket I/O. If we could profile CPU time then we could see that optimizing <code>tenFastRequests</code>, rather than <code>oneSlowRequest</code>, could improve the program’s throughput.</p>
<cite><a href="https://openjdk.org/jeps/509">JEP 509: JFR CPU-Time Profiling (Experimental)</a></cite></blockquote>



<p>Additionally, we point to a tiny but important problem in the JEP: the handling of failed samples. Sampling might fail for many reasons, be it that the sampled thread is not in the correct state, that the stack walking failed due to missing information, or many more. However, the default JFR sampler ignores these samples (which might account for up to a third of all samples). This doesn’t make interpreting the “execution-time” profiles any easier.</p>



<h2>CPU-time profiling</h2>



<p>As shown in the video above, sampling every thread every n milliseconds of CPU time improves the situation. Now, the number of samples for every thread is directly related to the time it spends on the CPU without any subsampling, as the number of hardware threads bounds the number of sampled threads.</p>



<blockquote>
<p>The ability to accurately and precisely measure CPU-cycle consumption was added to the Linux kernel in version 2.6.12 via a timer that emits signals at fixed intervals of CPU time rather than fixed intervals of elapsed real time. Most profilers on Linux use this mechanism to produce CPU-time profiles.</p>



<p>Some popular third-party Java tools, including <a href="https://github.com/async-profiler/async-profiler">async-profiler</a>, use Linux’s CPU timer to produce CPU-time profiles of Java programs. However, to do so, such tools interact with the Java runtime through unsupported internal interfaces. This is inherently unsafe and can lead to process crashes.</p>



<p>We should enhance JFR to use the Linux kernel’s CPU timer to safely produce CPU-time profiles of Java programs. This would help the many developers who deploy Java applications on Linux to make those applications more efficient.</p>
<cite><a href="https://openjdk.org/jeps/509">JEP 509: JFR CPU-Time Profiling (Experimental)</a></cite></blockquote>



<p>Please be aware that I don’t discourage using async-profiler. It’s a potent tool and is used by many people. But it is inherently hampered by not being embedded into the JDK. This is especially true with the new stackwalking at safepoints (see <a href="https://mostlynerdless.de/blog/2025/05/20/taming-the-bias-unbiased-safepoint-based-stack-walking-in-jfr/">Taming the Bias: Unbiased* Safepoint-Based Stack Walking in JFR</a>), making the current JFR sampler safer to use. This mechanism is sadly not available for external profilers, albeit I had my ideas for an API (see <a href="https://mostlynerdless.de/blog/2023/08/10/taming-the-bias-unbiased-safepoint-based-stack-walking/">Taming the Bias: Unbiased Safepoint-Based Stack Walking</a>), but this project has sadly been abandoned.</p>



<p>Let’s continue with the example from before.</p>



<blockquote>
<p>FR will use Linux’s CPU-timer mechanism to sample the stack of every thread running Java code at fixed intervals of CPU time. Each such sample is recorded in a new type of event, <code>jdk.CPUTimeSample</code>. This event is not enabled by default.</p>



<p>This event is similar to the existing <code>jdk.ExecutionSample</code> event for execution-time sampling. Enabling CPU-time events does not affect execution-time events in any way, so the two can be collected simultaneously.</p>



<p>We can enable the new event in a recording started at launch like so:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true,filename=profile.jfr ...</pre>



<p>With the new CPU-time sampler, in the flame graph it becomes clear that the application spends nearly all of its CPU cycles in <code>tenFastRequests</code>:</p>



<blockquote>
<figure><img decoding="async" src="https://bugs.openjdk.org/secure/attachment/110757/cpu_profile.png" alt="CPU time flame graph"/></figure>
</blockquote>



<p>A textual profile of the hot CPU methods, i.e., those that consume many CPU cycles in their own bodies rather than in calls to other methods, can be obtained like so:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ jfr view cpu-time-hot-methods profile.jfr</pre>



<p>However, in this particular example, the output is not as useful as the flame graph.</p>
<cite><a href="https://openjdk.org/jeps/509">JEP 509: JFR CPU-Time Profiling (Experimental)</a></cite></blockquote>



<p>Notably, the CPU-time profiler also reports failed and missed samples, but more on that later.</p>



<h2>Problems of the new Profiler</h2>



<p>I pointed out all the problems in the current JFR method sampler, so I should probably point out my problems, too.</p>



<p>The most significant issue is platform support, or better, the lack of it: The new profiler only supports Linux for the time being. While this is probably not a problem for production profiling, as most systems use Linux anyway, it’s a problem for profiling on developer machines. Most development happens on Windows and Mac OS machines. So, not being able to use the same profiler as in production hampers productivity. But this is a problem for other profilers too. Async-profiler, for example, only supports wall-clock profiling on Mac OS and doesn’t support Windows at all. JetBrains has a closed-source version of async-profiler that might support cpu-time profiling on Windows (see <a href="https://github.com/async-profiler/async-profiler/issues/188">GitHub issue</a>). Still, I could not confirm as I don’t have a Windows machine and found no specific information online.</p>



<p>Another issue, of course, is that the profiler barely got in at the last minute, after Nicolai Parlog, for example, filmed his <a href="https://www.youtube.com/watch?v=T5q72vcSjyk" data-rel="lightbox-video-0">Java 25 update video</a>.</p>



<figure><img decoding="async" width="1797" height="1020" src="https://mostlynerdless.de/wp-content/uploads/2025/06/image.png" alt="" srcset="https://mostlynerdless.de/wp-content/uploads/2025/06/image.png 1797w, https://mostlynerdless.de/wp-content/uploads/2025/06/image-300x170.png 300w, https://mostlynerdless.de/wp-content/uploads/2025/06/image-768x436.png 768w, https://mostlynerdless.de/wp-content/uploads/2025/06/image-1536x872.png 1536w, https://mostlynerdless.de/wp-content/uploads/2025/06/image-500x284.png 500w" sizes="(max-width: 1797px) 100vw, 1797px"/><figcaption><a href="https://bsky.app/profile/nipafx.dev/post/3lqttwaggdk22">Conversation on BlueSky under his video post</a></figcaption></figure>



<h2>Why did it get into JDK 25?</h2>



<p>Most users only use and get access to LTS versions of the JDK, so we wanted to get the feature into the LTS JDK 25 to allow people to experiment with it. To quote Markus Grönlund:</p>



<blockquote>
<p>I am approving this PR for the following reasons:</p>



<ol>
<li>We have reached a state that is “good enough” – I no longer see any fundamental design issues that can not be handled by follow-up bug fixes.</li>



<li>There are still many vague aspects included with this PR, as many has already pointed out, mostly related to the memory model and thread interactions – all those can, and should, be clarified, explained and exacted post-integration.</li>



<li>The feature as a whole is experimental and turned off by default.</li>



<li>Today is the penultimate day before JDK 25 cutoff. To give the feature a fair chance for making JDK25, it needs approval now.</li>
</ol>



<p>Thanks a lot Johannes and all involved for your hard work getting this feature ready.</p>



<p>Many thanks</p>
<cite><a href="https://github.com/openjdk/jdk/pull/25302#pullrequestreview-2896467191">Comment on the PR</a></cite></blockquote>



<h2>Open Issues</h2>



<p>So, use the profiler with care. None of the currently known issues should break the JVM. But there are currently three important follow-up issues to the merged profiler:</p>



<ul>
<li><a href="https://bugs.openjdk.org/browse/JDK-8358621">Avoid using a spinlock as the synchronization point returning from native in CPU Time Profiler</a> [Edit July: fixed]</li>



<li><a href="https://bugs.openjdk.org/browse/JDK-8358616">Clarify the requirements and exact the memory ordering in CPU Time Profiler</a>: I used acquire-release semantics for most atomic variables, which is not wrong, just not necessarily optimal from a performance perspective.</li>



<li><a href="https://bugs.openjdk.org/browse/JDK-8358619">Fix interval recomputation in CPU Time Profiler</a> [Edit July: fixed]</li>
</ul>



<p>I have already started work on the last issue and will be looking into the other two soon. Please test the profiler yourself and report all the issues you find.</p>



<h2>The new CPUTimeSample Event</h2>



<p>Where the old profiler had two events <code>jdk.ExecutionSample</code> and <code>jdk.NativeMethodSample</code>The new profiler has only one for simplicity, as it doesn’t treat threads in native and Java differently. As stated before, this event is called <code>jdk.CPUTimeSample</code>.</p>



<p>The event has five different fields:</p>



<ul>
<li><code>stackTrace</code> (nullable): Recorded stack trace</li>



<li><code>eventThread</code>: Sampled thread</li>



<li><code>failed</code> (boolean): Did the sampler fail to walk the stack trace? Implies that <code>stackTrace</code> is <code>null</code></li>



<li><code>samplingPeriod</code>: The actual sampling period, directly computed in the signal handler. More on that next week.</li>



<li><code>biased</code> (boolean): Is this sample safepoint biased (the stacktrace related to the frame at safepoint and not the actual frame when the sampling request has been created, see <a href="https://mostlynerdless.de/blog/2025/05/20/taming-the-bias-unbiased-safepoint-based-stack-walking-in-jfr/">Taming the Bias: Unbiased* Safepoint-Based Stack Walking in JFR</a> for more)</li>
</ul>



<p>You can find the event on the <a href="https://sapmachine.io/jfrevents/25.html#cputimesample">JFR Events Collection</a> page too.</p>



<p>Internally, the profiler uses bounded queues, which might overflow; this can result in lost events. The number of these events is regularly recorded in the form of the <code>jdk.CPUTimeSampleLoss</code> event. The event has two fields:</p>



<ul>
<li><code>lostSamples</code>: Number of samples that have been lost since the last <code>jdk.CPUTimeSampleLoss</code> event</li>



<li><code>eventThread</code>: Thread for which the samples are lost</li>
</ul>



<p>Both events allow a pretty good view of the program’s execution, including a relatively exact view of the CPU time used.</p>



<h2>Configuration of the CPU-time Profiler</h2>



<p>The emission of two events of the current sampler is controlled via the <code>period</code> property. It allows the user to configure the sampling interval. The problem now with the CPU-time profiler is that it might produce too many events depending on the number of hardware threads. This is why the <code>jdk.CPUTimeSample</code> event is controlled via the <code>throttle</code> setting. This setting can be either a sampling interval or an upper bound for the number of emitted events.</p>



<p>When setting an interval directly like “10ms” (as in the <code>default.jfc</code>), then we sample every thread every 10ms of CPU-time. This can at most result in 100 * #[hardware threads] events per second. On a 10 hardware thread machine, this results in at most (when every thread is CPU-bound) 1000 events per second or 12800 on a 128 hardware thread machine.</p>



<p>Setting, on the other hand, <code>throttle</code> to a rate like “500/s” (as in the <code>profile.jfc</code>), limits the number of events per second to a fixed rate. This is implemented by choosing the proper sampling interval in relation to the number of hardware threads. For a rate of “500/s” and a ten hardware thread machine, this would be 20ms. On a 128 hardware thread machine, this would be 0.256.</p>



<p>I have to mention that the issue <a href="https://bugs.openjdk.org/browse/JDK-8358619"><em>Fix interval recomputation in CPU Time Profiler</em></a> is related to the recomputation when the number of hardware threads changes mid-profiling.</p>



<h2>New JFR Views</h2>



<p>In addition to the two new events, there are two new views that you can use via <code>jfr view VIEW_NAME profile.jfr</code>:</p>



<p><code>cpu-time-hot-methods</code> shows you a list of the 25 most executed methods. These are methods that are on top of the stack the most (running the <a href="https://gist.github.com/parttimenerd/d66364f2086089761eb2fec7eda026d7">example</a> with a 1ms throttle):</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">                       Java Methods that Execute the Most from CPU Time Sampler (Experimental)

Method                                                                                                Samples Percent
----------------------------------------------------------------------------------------------------- ------- -------
jdk.jfr.internal.JVM.emitEvent(long, long, long)                                                           35  72.92%
jdk.jfr.internal.event.EventWriter.putStringValue(String)                                                   1   2.08%
jdk.internal.loader.NativeLibraries.load(NativeLibraries$NativeLibraryImpl, String, boolean, boolean)       1   2.08%
jdk.internal.logger.LazyLoggers$LazyLoggerAccessor.platform()                                               1   2.08%
jdk.internal.jimage.ImageStringsReader.unmaskedHashCode(String, int)                                        1   2.08%
sun.net.www.ParseUtil.quote(String, long, long)                                                             1   2.08%
java.net.HttpURLConnection.getResponseCode()                                                                1   2.08%
java.io.BufferedInputStream.read(byte[], int, int)                                                          1   2.08%
java.util.HashMap.hash(Object)                                                                              1   2.08%
sun.nio.ch.NioSocketImpl$1.read(byte[], int, int)                                                           1   2.08%
java.util.Properties.load0(Properties$LineReader)                                                           1   2.08%
java.lang.StringLatin1.regionMatchesCI(byte[], int, byte[], int, int)                                       1   2.08%
java.util.stream.AbstractPipeline.exactOutputSizeIfKnown(Spliterator)                                       1   2.08%
sun.nio.fs.UnixChannelFactory$Flags.toFlags(Set)                                                            1   2.08%</pre>



<p>The second view is <code>cpu-time-statistics</code> which gives you the number of successful samples, failed samples, biased Samples, total samples, and lost samples:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">CPU Time Sample Statistics
--------------------------
Successful Samples: 48
Failed Samples: 0
Biased Samples: 0
Total Samples: 48
Lost Samples: 14</pre>



<p>All of the lost samples are caused by the sampled Java thread running VM internal code. This view is really helpful when checking whether the profiling contains the whole picture. </p>



<h2>Conclusion</h2>



<p>Getting this new profiler in JDK 25 was a real push, but I think it was worth it. OpenJDK now has a built-in CPU-time profiler that records missed samples. The implementation builds upon JFR’s new cooperative sampling approach, which also got into JDK 25 just days before. CPU-time profiling has many advantages, especially when you’re interested in the code that is actually wasting your CPU.</p>



<p>This is the first of a two-part series on the new profiler. You can expect a deep dive into the implementation of the profiler next week.</p>



<p><em>This blog post is part of my work in the <a href="https://sapmachine.io/">SapMachine</a> team at <a href="https://sap.com">SAP</a>, making profiling easier for everyone.</em></p>



<p>P.S.: I submitted to a few conferences the talk <em>From Idea to JEP: An OpenJDK Developer’s Journey to Improve Profiling</em> with the following description: <em>Have you ever wondered how profiling, like JFR, works in OpenJDK and how we can improve it? In this talk, I’ll take you on my three-year journey to improve profiling, especially method sampling, with OpenJDK: from the initial ideas and problems of existing approaches to my different draft implementations and JEP versions, with all the setbacks and friends I made along the way. It’s a story of blood, sweat, and C++.</em></p>

                
                    <!--begin code -->

                    
                    <div data-post_id="1710" data-instance_id="1" data-additional_class="pp-multiple-authors-layout-boxed.multiple-authors-target-the-content" data-original_class="pp-multiple-authors-boxes-wrapper pp-multiple-authors-wrapper box-post-id-1710 box-instance-id-1">
                                                                                    
                                                                            <p><span>
                                                                                                                        <ul>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                    <li>
                                                                                                                                                                                    <div>
                                                                    <p><img alt="Johannes Bechberger" src="https://secure.gravatar.com/avatar/c52eaa3c0c73ed834ae0e48b927edd38573408d48f4c35c898d34f71d958e0c9?s=80&amp;d=blank&amp;r=g" srcset="https://secure.gravatar.com/avatar/c52eaa3c0c73ed834ae0e48b927edd38573408d48f4c35c898d34f71d958e0c9?s=160&amp;d=blank&amp;r=g 2x" height="80" width="80"/>                                                                                                                                                                                                            </p>
                                                                                                                                    </div>
                                                            
                                                            <div>
                                                                                                                                                                                                                                                                        <p>
                                                                                                                                                    Johannes Bechberger is a JVM developer working on profilers and their underlying technology in the SapMachine team at SAP. This includes improvements to async-profiler and its ecosystem, a website to view the different JFR event types, and improvements to the FirefoxProfiler, making it usable in the Java world. He started at SAP in 2022 after two years of research studies at the KIT in the field of Java security analyses. His work today is comprised of many open-source contributions and his blog, where he writes regularly on in-depth profiling and debugging topics, and of working on his JEP Candidate 435 to add a new profiling API to the OpenJDK.                                                                                                                                                </p>
                                                                                                                                
                                                                                                                                    <p><span>
                                                                        <a href="https://mostlynerdless.de/blog/author/parttimenerd/" title="View all posts">
                                                                            <span>View all posts</span>
                                                                        </a>
                                                                    </span>
                                                                                                                                <a aria-label="Email" href="mailto:me@mostlynerdless.de" target="_self"><span></span> </a><a aria-label="Website" href="https://mostlynerdless.de/" target="_self"><span></span> </a>
                                                                                                                            </p></div>
                                                                                                                                                                                                                        </li>
                                                                                                                                                                                                                                    </ul>
                                                                            </span>
                                                                                                                        </p>
                        </div>
                    <!--end code -->
                    
                
                            
        <div id="tnp-subscription-posts"><p>New posts like these come out at least every two weeks, to get notified about new posts, follow me on <a href="https://bsky.app/profile/mostlynerdless.de">BlueSky</a>, <a href="https://twitter.com/parttimen3rd">Twitter</a>, <a href="https://mastodon.social/@parttimenerd">Mastodon</a>, or <a href="https://www.linkedin.com/in/johannes-bechberger/">LinkedIn</a>, or join the newsletter:</p>
</div>			</div></div>
  </body>
</html>
