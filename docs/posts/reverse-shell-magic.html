<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jackcarrick.net/blog/reverse-shell-magic">Original</a>
    <h1>Reverse shell magic</h1>
    
    <div id="readability-page-1" class="page"><div face="Arial">
<table><tbody><tr><td></td><td>


<table><tbody><tr><td>
<img src="https://jackcarrick.net/blog/images/curves1.png"/></td><td>
</td></tr></tbody></table>

<br/><a href="https://jackcarrick.net/blog/espanol.html">Pseudo 3d en español aqui! Gracias a Luis Peña!</a>

<br/>(C) 2013 Louis Gorenfeld, updated May 3, 2013<br/>
<br/><b>NEW:</b> Important details on the segmented road system and some additional links
<br/><b>NEW:</b> An (optional) explanation of finding field-of-view for the 3d projection formula
<br/><b>NEW:</b> An analysis of S.T.U.N. Runner
<br/><b>NEW:</b> General writing improvements

<p>Previous update:<br/>
<br/>An explanation of 3d projection mathematics (under Road Basics) and analysis of Activision&#39;s Enduro (under Case Studies)!
<br/>Thanks to everyone for all the e-mail!  Keep it coming :)
Sorry, I can&#39;t answer questions about when I&#39;ll post source code, but I&#39;m 
always happy to answer anything else about these engines!
<br/>Official material on the Road Rash graphics engine and more detailed explanation of curves and a generalized curve equation
<br/>
<br/>Is this information inaccurate?  Am I way off?  Don&#39;t hesitate to write me at louis.gorenfeld at gmail dot com!
</p><hr noshade=""/>
<h2>Table of Contents</h2>
<a href="#intro">
Introduction<br/>
</a>
<a href="#basics">
Road Basics<br/>
</a>
<a href="#curves">
Curves and Steering<br/>
</a>
<a href="#sprites">
Sprites and Data<br/>
</a>
<a href="#hills">
Hills<br/>
</a>
<a href="#wrapup">Taking Raster Roads Farther<br/></a>
<a href="#proj3d">True 3d-Projected Segments<br/></a>
<a href="#enhancements">
Enhancements<br/>
</a>
<a href="#related">
Related Effects<br/>
</a>
<a href="#hw">
Case Studies<br/>
</a>
<a href="#stuff">
Code Stuff<br/>
</a>
<a href="#glossary">
Glossary<br/>
</a>
<a href="#gallery">
The Gallery
</a>
<hr noshade=""/>

<a name="intro">

<h2>Introduction</h2>

</a><p><a name="intro"><u><b>Why Pseudo 3d?</b></u><br/>
</a>
Now that every system can produce graphics consisting of a zillion polygons on the fly, why would you want to do a road the old way?  Aren&#39;t polygons the exact same thing, only better?  Well, no.  It&#39;s true that polygons lead to less distortion, but it is the warping in these old engines that give the surreal, exhillerating sense of speed found in many pre-polygon games.  Think of the view as being controlled by a camera.  As you take a curve in a game which uses one of these engines, it seems to look around the curve.  Then, as the road straightens, the view straightens.  As you go over a blind curve, the camera would seem to peer down over the ridge.  And, since these games do not use a traditional track format with perfect spatial relationships, it is possible to effortlessly create tracks large enough that the player can go at ridiculous speeds-- without worrying about an object appearing on the track faster than the player can possibly react since the physical reality of the game can easily be tailored to the gameplay style.
</p><p>But they have plenty of drawbacks as well.  The depth of physics found in more simulation-like games tends to be lost, and so these engines aren&#39;t suited to every purpose.  They are, however, easy to implement, run quickly, and are generally a lot of fun to play with!
</p><p>It is worth noting that not every older racing game used these techniques.  In fact, the method outlined here is only one possible way to do a pseudo 3d road.  Some used projected and scaled sprites, others seem to involve varying degrees of real projection for the road.  How you blend real mathematics with trickery is up to you.  
I hope you have as much fun exploring this special effect as I did.

</p><p><u><b>How Much Math Do I Need?</b></u><br/>
If you...
<br/>
...have Trigonometry knowledge, that&#39;s the most math you&#39;ll need for the entire tutorial<br/>
...have just Algebra and Geometry, skip the field-of-view explanation<br/>
...want to avoid as much math as possible, read: The Simplest Road, Curves and Steering, Sprites and Data, and Hills<br/>
</p><p>This is a very flexible technique, and you can actually get by with just addition! With more advanced math, it can look better, but
with just arithmetic, you can get up to the level of detail seen in games like Pole Position or the first OutRun.

</p><p><u><b>How Much Programming Knowledge Do I Need?</b></u><br/>
It helps a lot to understand raster graphics: Know what a scanline is, and that each line is made of a row of pixels. 
The programming examples are written in pseudocode, so you don&#39;t need experience in any specific language to understand them.
</p><p>
Ready? Let&#39;s begin!

</p><p><u><b>Raster Effects - Some Background</b></u><br/>
A pseudo 3d road is just a variation of a more general class of effects called raster effects.  
One of the best-known examples of a raster effect is in Street Fighter II:  
As the fighters move left and right, the ground scrolls in perspective.  This actually isn&#39;t 3d.  Instead, the ground
graphic is stored as an extremely wide-angle perspective shot.  When the view scrolls, the lines of the screen which are supposed to be farther away scroll more slowly than the lines which
are closer.  That is, each line of the screen scrolls independently of each other.  
Shown below is both the end result and the ground graphic as it is stored in memory.
</p><center>
<img src="https://jackcarrick.net/blog/images/sf2.png"/>
<br/>
<img src="https://jackcarrick.net/blog/images/sf2ground_rom.png"/>
</center>


<br/><br/>
<a name="basics">
<u>
<h2>Road Basics</h2></u>
</a>
<p><u><b>Introduction to Raster Roads</b></u><br/>
We are used to thinking of 3d effects in terms of polygons whose vertices are
suspended in 3d space.  Older systems, however, were not powerful enough to
make a large number of 3d calculations.  Many older effects, in general,
fall into the category of raster effects.  These are special effects which
are done by changing some variable per line.  Most commonly, this means changing
the color or palette per line, or scrolling per line.  This is well-suited to
old graphics hardware which had acceleration for scrolling and used an indexed
color mode.
</p><p>
The pseudo raster road effect actually works similarly to the Street Fighter
II perspective effect in that it warps a static image to create the illusion
of 3d.  Here&#39;s how they do it:
</p><p>
Most raster roads start off with an image of a flat road.  This is essentially
a graphic of two parallel lines on the ground retreating into the distance.
As they get farther into the distance, the lines appear to the viewer to
be closer 
together.  This is a basic rule of perspective.  
Now, in order to give the illusion 
of motion, most arcade racing games have stripes on the road.
Moving these stripes on the road forwards is
generally either achieved by color cycling or by changing the palette every line.
Curves and steering are done by scrolling each line independently of one
another, just like in Street Fighter II.  
</p><p>
We will get into curves and steering
in the next chapter.  For now, let&#39;s put that aside and concentrate on 
making the road appear to scroll forwards.  

</p><p><u><b>The Simplest Road</b></u><br/>
Take the image of a road described above:  Two parallel lines demarcating the left and right edges of the road
retreat into the distance.  As they move into the distance, they appear to the viewer to be closer together.
Below is what this might look like:<br/>
<img src="https://jackcarrick.net/blog/images/nolines.png"/>
</p><p>
What is missing from this picture are road markings to give a good impression of distance.  Games use alternating light and dark strips, among other road markings, for this effect.  
To help accomplish this, let&#39;s define a &#34;texture position&#34; variable.  This variable starts at zero at the bottom of the screen and increases
each line going up the screen.  When this is below a certain amount, the road is drawn in one shade.  When it is above that amount, it is drawn in the other shade.  The position variable then wraps back to zero when it exceeds the maximum amount, causing a repeating pattern.  
</p><p>It is not enough to change this by a set amount each line though, because then you&#39;ll just see several strips of different colors which are not getting smaller as the road goes into the distance.  That means you need another variable which will change by a set amount, add it to another variable each line, and then add the last one to the texture position change.
</p><p>Here&#39;s an example which shows, from the bottom of the screen, what the Z value will be for each line as it 
recedes into the distance.  After the variables, I print what is added to get the values for the next line.  I&#39;ve named the values DDZ (delta delta Z), DZ
(delta Z), and Z.  DDZ remains constant, DZ changes in a linear fashion, and Z&#39;s value curves.  You can think of Z as
representing the Z position, DZ as holding the velocity of the position, and DDZ as being the acceleration of
the position (the change in acceleration).
Note that the value I chose, four, is arbitrary and was just convinient for this example.
</p><p>
<code>
<font size="-1">
DDZ = 4   DZ = 0   Z = 0  : dz += 4, z += 4<br/>
DDZ = 4   DZ = 4   Z = 4  : dz += 4, z += 8<br/>
DDZ = 4   DZ = 8   Z = 12 : dz += 4, z += 12<br/>
DDZ = 4   DZ = 12  Z = 24 : dz += 4, z += 16<br/>
DDZ = 4   DZ = 16  Z = 40 : etc...<br/>
</font>
</code>
</p><p>
Noice that DZ is modified first, and then that is used to modify Z.  To sum it up, say you are moving through the texture at speed 4.  That means that after line one, you are reading the texture at position 4.  The next line will be 12.  After that, 24.  So, this way it reads through the texture faster and faster.  This is why I like to refer to these variables as the texture position (where in the texture we are reading), the texture speed (how quickly we read through the texture), and the texture acceleration (how quickly the texture speed increases).
</p><p>A similar method will also be used to draw curves and hills without too much number crunching.  Now, 
to make the road appear to move, just change where the texture position starts at the bottom of the screen for each frame.
</p><p>Now, you may notice a shortcoming with this trick:  the zooming rate is inaccurate.  
This causes a distortion that I will refer to as the &#34;oatmeal effect&#34;.  It is a warping effect present in early pseudo games such as OutRun in which objects, including the stripes on the road,
appear to slow down as they move outwards from the center of the screen.
</p><p>This method for finding the Z value has another disadvantage: It&#39;s not easily predictable what the value is in the very distance, especially
when hills are involved. We will learn a more advanced method which I will call the Z-map. This is a table that calculates what the Z distance is
for every scanline of the screen. But first, we need a little more math...

</p><p><u><b>A Mathematical Detour: 3d Perspective Projection</b></u><br/>
There are ways to get rid of the oatmeal effect.  However, some traditional 3d mathematics are needed to make them possible.  What we need is a way of translating
3d coordinates so that they fit onto a 2d surface. 
</p><p><img src="https://jackcarrick.net/blog/images/project.png"/>
</p><p>In the picture above, an eyeball (lower left) is looking through the screen (the blue vertical line) at an object in our 3d world (&#34;y_world&#34;).  The eyeball is
a distance &#34;dist&#34; from the screen, and a distance &#34;z_world&#34; from the object.  Now, one thing you might have noticed if you&#39;ve spent some time with geometry or
trigonometry is that there are not one but two triangles in the picture.  The first triangle is the largest one, from the eyeball over to the ground on the right side
and up to the object we&#39;re looking at.  The second triangle I&#39;ve colored yellow.  This is from the eyeball to where on the screen we&#39;ll see our object, down to the
ground, and back.  
</p><p>These two triangles&#39; hypoteneuses (the line from the eye to the object) are at the same angle even though one is longer than the other.  They are essentially 
the same triangle, but the smaller one is just scaled down.  What this implies is that the ratio of the horizontal and vertical sides must be the same!  In math terms:
</p><p><code>y_screen/dist = y_world/z_world</code>
</p><p>What we need to do now is juggle the equation to get y_screen.  This gives us:
</p><p><code>y_screen = (y_world*dist)/z_world</code>
</p><p>In summary, to find the y coordinate of an object on the screen, we take the y world coordinate, multiply that by the distance we are to the screen, and then divide
it by the distance it is in the world.  Of course, if we just do that, the center of our view is going to be the upper-left corner of the screen!  Just plug in y_world=0 to
see this.  What we can do to center it is add half of our screen resolution to the result to put it right in the middle.  The equation can also be simplified a little bit
by pretending that our noses are right up to the screen.  In this case, dist=1.  The final equation then is:
</p><p><code>y_screen = (y_world/z_world) + (y_resolution/2)</code>
</p><p>There is a relationship between the ratios and the viewing angle, as well as scaling the image so that it is resolution-neutral, but we won&#39;t really need any of that to fix our road problem.  
If you are curious, try looking at the diagram from the top view:  the angle to the edge of the screen is the field of view and the same relationships hold!

</p><p><u><b>More Math: Adding Field-of-View to 3d Projection</b></u><br/>
Now, this is <b>largely unnecessary</b> for most road engine cases. But, it&#39;s useful for making projection parameters
resolution-independent, or for objects that need to rotate or for integration with true 3d effects.
</p><p>Let&#39;s go back to the original projection formula. The &#34;dist&#34; from the explanation above will now be called &#34;scaling&#34;:
</p><p><code>y_screen = (y_world*scaling)/z_world + (y_resolution/2)</code>
</p><p>The idea is that we need to scale all the points on the screen by some value which lets points within a certain
field-of-view (FOV) remain visible. You&#39;ll need a constant for the x FOV and a constant for the y FOV.
</p><p>As an example, let&#39;s assume we&#39;re working in 640x480 resolution and we want a FOV of 60 degrees. We&#39;ve seen a diagram of
3d projection from the side view. For this, let&#39;s look at this
top view of the projection space instead:<br/>
<img src="https://jackcarrick.net/blog/images/TopView.png"/><br/>
One way to think about the problem is that if an object is at the right edge of our FOV, it needs to appear on the screen
at x=640 (since we&#39;re at 640x480). Looking at the chart, our FOV can be split into two right triangles where the angle
of each is fov_angle/2 (a/2). And since our FOV is a cone, an object is on the right edge of its FOV if its x=R*sin(a/2) and
z=R*cos(a/2), where R is any radius value we want. We might as well make R=1. And we need the object to appear at
x_screen=640.
That gives us this (starting from the basic projection formula):
</p><p><code>
	x_screen=640   fov_angle=60   y_world=sin(60/2)    z_world=(60/2)    x_resolution/2=320    scaling=?<br/>
	<br/>
x_screen = (y_world*scaling)/z_world + (x_resolution/2)<br/>
640 = (sin(30)*scaling/cos(30)) + 320<br/>
320 = tan(30)*scaling<br/>
320/tan(30) = scaling<br/>
<br/>In generic terms: scaling = (x_resolution/2) / tan(fov_angle/2)
</code>
</p><p>
We&#39;ve replaced a/2 by 30 (half of 60 degrees), recognized that sin/cos = tan, and voila! We should be able to test this
by placing an object at the right edge of the field-of-view, plugging these values into the original projection equation,
and ensuring that the X value winds up as 640. For example, an (x, z) point at (20, 34.64) will wind up at X=640 because 20 is
40*sin(30) and 34.64 is 40*cos(30).
</p><p>
Note that you&#39;ll have different FOV values for horizontal (x) and vertical (y) for a standard or widescreen monitor that&#39;s in
horizontal orientation.

</p><p><u><b>A More Accurate Road - Using a Z Map</b></u><br/>
What we want to do to fix our perspective problem is to precompute a list of distances for each line of the screen.  In short, the problem is how to describe a flat plane in 3d. 
To understand how this works, first think of the 2d equivalent: a line!  To describe a horizontal line in 2d, you would say that for every (x, y) coordinate the y is the same. 
If we extend this into 3d, it becomes a plane: for every x and z distance, the y is the same!  When it comes to a flat horizontal surface, it doesn&#39;t matter how far from the camera it is, the
y is always the same.  Likewise, it doesn&#39;t matter how much to the left or right the point is, the y will still be the same.

Back to figuring out the distance of each line of the screen:  let&#39;s call this a Z Map.  Calculating the Z Map is just a matter of rearranging the 3d 
projection formula to find a Z value for each screen Y!
</p><p>
First, take the equation from the last section:
</p><p>
<code>
Y_screen = (Y_world / Z) + (y_resolution / 2)
</code>
</p><p>
Now, since we&#39;re given Y_screen (each line), juggle the equation so that we&#39;re finding the Z:
</p><p>
<code>Z = Y_world / (Y_screen - (height_screen / 2))</code>
</p><p>
Y_world is basically the difference between the ground and the camera height, which is going to be negative.  This is the same for each line because, as described in the introductory paragraph,
we&#39;re interested in a flat road for the time-being.  
In addition to looking much more accurate and avoiding the &#34;oatmeal effect&#34;, it has the advantage that it is easy to compute what the maximum draw distance is.  
</p><p>The road is mapped onto the screen by reading through this buffer:  For each distance, you must figure out what part of the road texture belongs there by noting how many units each stripe or pixel of the texture take up.  
</p><p> 
Though we now know the distance of each row of the screen, it may also be useful to cache either the width of the road or scale factor for each line.  The scaling factor would just be the
inverse of the distance, adjusted so that the value is 1 on the line which the player&#39;s car graphic spends the most time.  This can then be used to scale sprites which are on a given line, or to
find what the width of the road is.  
<br/><br/>
<a name="curves">
<u>
</u></a></p><h2><a name="curves"><u>Curves and Steering</u></a></h2><a name="curves">
</a>

<p><u><b>Making it Curve</b></u><br/>
To curve a road, you just need to change the position of the center-line in a curve shape.  There are a couple ways to do this.  
One way is to do it the way the Z positions were done in &#34;The Simplest Road&#34;: with three variables.  That is, starting at the bottom of the screen, the amount that the center of the road shifts left or right per line steadily increases.  Like with the texture reads, we can refer to these variables as the center line (curve) position, the curve velocity, and the curve acceleration.
</p><p>There are some problems with this method though.  One is that S-curves are not very convinient.  Another limitation that going into a turn looks the same as coming out of a turn: The road bends, and simply unbends. <br/>
</p><p>To improve the situation, we&#39;ll introduce the idea of road segments.  A road segment is a partition which is invisible to the player.
Think of it as an invisible horizontal divide which sets the curve of the road above that line.  At any given time, one of these segment dividers is at the bottom of the screen and another is travelling down at a steady rate towards the bottom of the screen.  Let&#39;s call the one at the bottom the base segment, because it sets the initial curve of the road.  Here&#39;s how it works:
</p><p>
When we start drawing the road, the first thing we do is look at the base point and set the parameters for drawing accordingly. 
As a turn approaches, the segment line for that would start in the distance and come towards the player kind of like any other road object, except it needs to drift down the screen at a steady rate. That is, for a specific speed that the player is traveling, the segment divider travels down the
screen at so many lines per frame. Or, if you&#39;re using a Z-Map, so many z-map entries per frame. If the segment were to &#39;accelerate&#39; at the player
the way 3d objects on the track do, the road would swing too wildly.
</p><p>
Let&#39;s see how this works. Suppose the segment line for a left curve is halfway down the road and the base segment is just a straight road.  As the road is drawn, it doesn&#39;t even start curving until it hits the &#34;left curve&#34; segment.  Then the curve of the road begins to change at the rate specified by that point.  As the moving segment hits the bottom of the screen, it becomes the new base segment and what was previously the base segment goes to the top of the road.

</p><p>Shown below are two roads:  One is a straightaway followed by a left turn, and one is a left turn followed by a straightaway.  In both these cases, the segment position is halfway down the
Z Map (or, halfway down the screen).  In other words, the road begins to curve or straighten halfway down the road, and the camera is entering the turn in the first picture and leaving the turn in the second.

</p><p><img src="https://jackcarrick.net/blog/images/straight-then-left.png"/> <img src="https://jackcarrick.net/blog/images/left-then-straight.png"/> 

</p><p>And this is the same technique and same segment position applied to an S-curve:<br/>
<img src="https://jackcarrick.net/blog/images/left-then-right.png"/>

</p><p>The best way to keep track of the segment position is in terms of where on the Z Map it is.  That is, instead of tying the 
segment position to a screen y position, tie it to a position in the Z Map.  This way, it will still start at the road&#39;s
horizon, but will more gracefully be able to handle hills.  Note that on a flat road that the two methods of tracking
the segment position are equivalent.

<!-- One possibility is that Final Lap does its complex track visuals by using more than two segments. -->
</p><p>Let&#39;s illustrate this with some code:
</p><p><code>
<font size="-1">
current_x = 160  // Half of a 320 width screen<br/>
dx = 0 // Curve amount, constant per segment<br/>
ddx = 0 // Curve amount, changes per line<br/><br/>
for each line of the screen from the bottom to the top:<br/>
  if line of screen&#39;s Z Map position is below segment.position:<br/>
    dx = bottom_segment.dx<br/>
  else if line of screen&#39;s Z Map position is above segment.position:<br/>
    dx = segment.dx<br/>
  end if<br/>
  ddx += dx<br/>
  current_x += ddx<br/>
  this_line.x = current_x<br/>
end for<br/>
<br/>// Move segments<br/>
segment_y += constant * speed // Constant makes sure the segment doesn&#39;t move too fast<br/>
if segment.position &lt; 0 // 0 is nearest<br/>
  bottom_segment = segment<br/>
  segment.position = zmap.length - 1 // Send segment position to farthest distance<br/>
  segment.dx = GetNextDxFromTrack() // Fetch next curve amount from track data<br/>
end if<br/>
</font>
</code>

</p><p>One big advantage of doing the curves this way is that if you have a curve followed by a straightaway, you can see the straightaway as you come
out of the curve.  Likewise, if you have a curve followed by a curve in the opposite direction (or even a steeper curve the same direction), you can
see that next piece of track coming around the bend before you hit it.

</p><p>To complete the illusion, you need to have a horizon graphic.  As the curve approaches, the horizon doesn&#39;t change (or scrolls only slightly).  Then when the curve is completely drawn, it is assumed that the car is going around it, and the horizon scrolls quickly in the opposite direction that the curve is pointing.  As the curve straightens out again, the background continues to scroll until the curve is complete.  If you are using segments, you can just scroll the horizon according to the settings on the base segment.

</p><p><u><b>General Curve Formula</b></u><br/>
There is one interesting observation we can make about the curve technique detailed in the section &#34;The Simplest
Road&#34;.  This observation is more mathematical than the above-material, and can be safely skipped as long as your
graphics engine either does not have to be resolution-independent or is using the &#34;3d projected segments&#34; technique
discussed in the chapter on hills.
</p><p>Looking at the curve example using &#34;Z&#34; from the section &#34;The Simplest Road&#34;, we can see that the z-position (or x-position) at a given line is the sum of an increasing series of numbers (e.g. 1 + 2 + 3 + 4).  This is
what&#39;s called an arithmetic series, or an arithmetic progression.  Instead of 1 + 2 + 3 + 4, a sharper curve can be produced by adding 2 + 4 + 6 + 8, or 2*1 + 2*2 + 2*3 + 2*4.  The &#34;2&#34; in this case is the 
variable segment.dx from above.  It can also be factored out to get 2(1 + 2 + 3 + 4)!  Now all that has to be done is to find a formula to describe 1 + 2 + ... + N, where N is the number of lines making up the curve.
It turns out that the sum of an arithmetic series is equal to N(N+1)/2.  So, the formula can be written as s = A * [ N(N+1)/2 ] where A is the sharpness of the curve and s is the sum.  This can be further modified
to add a starting point, for instance, the center of the road at the bottom of the screen.  If we call this &#39;x&#39;, we now have s = x + A * [ N(N+1)/2 ].
</p><p>We now have a formula to describe our curve.  The question that we want to ask it is, &#34;given a starting point x and N lines of the curve, what should A be to make the curve reach x-position &#39;s&#39; by the end?&#34;  Juggling
the equation to solve for A gets us A = 2(s - x)/[n(n+1)].  This means that the sharpness of a given curve may be 
stored in terms of the endpoint&#39;s X position, making the graphics engine resolution-independent.

</p><p><u><b>Perspective-style Steering</b></u><br/>
It&#39;s much less interesting looking to have a game in which when you
steer, it only moves the car sprite.  So, instead of moving the player&#39;s car sprite, you keep it in the center of the screen and move the road-- more importantly, you move the position of the center-line at the front (bottom) of the screen.  Now, you want to assume that the player is going to be looking at the road always, so make the road end at the center of the screen.  You&#39;ll need an angle-of-road variable for this.  So, calculate the difference between the center of the screen and the position of the front of the road, and divide by
the height of the road&#39;s graphic.  That will give you the amount to
move the center of the road each line.

<br/><br/>
<a name="sprites">
<u>
</u></a></p><h2><a name="sprites"><u>Sprites and Data</u></a></h2><a name="sprites">
</a>

<p><u><b>Placing Objects and Scaling</b></u><br/>
Sprites should be drawn back-to-front.  This is sometimes referred to as the Painter&#39;s Algorithm.  To do this, you&#39;ll have to note in advance where on the screen each object should be drawn, and then draw them in a different step.
The way I do this is as follows:  As I go through the Z Map while drawing the road, I like to also note at that time which line of the screen each sprite
will be associated with.  If you&#39;ve kept your sprites sorted by Z, this is trivial:  Each time a new Z Map value is read,
check to see whether the next sprite&#39;s Z position is closer to the camera than the current Z Map value, or whether it&#39;s
equal.  If so, note that sprite&#39;s screen Y position as belonging to the current line.  Then check the next sprite the
same way.  Keep doing this until you take a sprite off the list which has a farther Z position than the current one.
</p><p>The X position of the object should be kept track of relative to the center of the road.  The easiest way then to position
the sprite horizontally is just to multiply it by the scaling factor for the current line (inverse of Z) and add that to the road&#39;s center.

</p><p><b><u>Storing Track Data</u></b><br/>
When I did my first road demo, I stored the level information as a list of events which would happen at specified distances.  The distances are, of course, in terms of texture position units.  The events would consist of commands to begin and stop curves.  Now, as far as I can tell, the speed at which the road starts and stops curving is arbitrary.  The only rule seems to be that it must correlate to the speed of the player vehicle.
</p><p>If, however, you are using a segmented system, you can just use a list of commands.  The distance that each command takes is equivalent to how
quickly the invisible segment line drifts down the screen.  This also frees you up to create a track format which works on a tile map, for representing
somewhat realistic track geography.  That is, each tile could be one segment.  A sharp turn could turn the track 90 degrees, while a more mild turn
would come out at 45 degrees.

</p><p><b><u>Texturing the Road</u></b><br/>
Now, you probably would like a real graphical texture on your road
instead of the alternating lines and such that you have at the moment.
There are a couple ways to do this.  A cheap and easy way to do it is this:  You have a couple of textures for the road (for the alternating line effect).
When each horizontal line of the road is drawn, you stretch the texture to fit the width of that line.  Or, if you can&#39;t stretch, pick a line out of one of two complete road
bitmaps (ala Outrunners).
</p><p>
If you want the road to look more accurate, make the Z for each line correspond to a row number on a texture graphic.  Voila!  One textured road!
</p><p>However, if you only want strips of alternating color, the answer is even simpler-- especially when using fixed point.  For each Z, make one of the bits
represent the shade of the road (dark or light). Then, just draw the appropriate road pattern or colors for that bit.
<br/><br/>
<a name="hills">
<u>
</u></a></p><h2><a name="hills"><u>Hills</u></a></h2><a name="hills">
</a>

<p>
<u><b>Varieties of Hills</b></u><br/>
It seems there are a near-infinite number of ways to produce hill effects.  Hill effects have a wide range of geometric accuracy, with some of the
less accurate techniques being more convincing than others.  Here we will examine two possible methods.

</p><p>
<u><b>Faked Hills</b></u>
<br/>After much experimentation, I&#39;ve come up with a flexible method for faking hills which uses little in the way of
calculations.  Additionally, it accurately tracks objects which are beneath the horizon.  It is a scaling
and warping effect which vertically stretches and compresses the road.   It uses the same addition trick
used to draw the curves to generate the curvature of the hill.
</p><p>
Here&#39;s how it&#39;s done:  First of all, the drawing loop would start at the beginning of the Z Map (nearest) and stop when it gets to the end
(farthest).  If we are to decrement the drawing position each line by 1, the road will be drawn flat.  However, if we decrement
the drawing position each line by 2, doubling lines as we go, the road will be drawn twice as high.  Finally, by varying the
amount we decrement the drawing position each line, we can draw a hill which starts flat and curves upwards.  If the next drawing
position is more than one line from the current drawing position, the current Z Map line is repeated until we get there,
producing a scaling effect. 
</p><p>Downhills are similar:  If the drawing position is incremented instead of decremented, it will move beneath the last line
drawn.  Of course, lines which are below the horizon will not be visible on-screen-- only lines which are 1 or more pixels
above the last line should be drawn.  However, we&#39;ll still want to keep track of objects which are beneath the horizon.  To
do this, note the screen Y position of each sprite as the Z Map is traversed. 
It may help to make the Z Map larger
than needed for a flat road.  This way, as the buffer stretches, it won&#39;t become too pixellated.

</p><p>Now, we have to move the horizon to convince the player.  I like to 
use a Lotus-style background in which the horizon doesn&#39;t just consist 
of just a skyline, but also a distant ground graphic.  When the hill curves
upwards (elongating the view), the horizon should move downwards slightly relative to
the top of the road.  When the hill curves downwards as the camera crests
the hill (shortening the view), the horizon should move upwards.
</p><p>
This is what the effect looks like for a downhill and an uphill-- minus the horizon graphic of course:</p><p>
<img src="https://jackcarrick.net/blog/images/downhill1.png"/>
<img src="https://jackcarrick.net/blog/images/uphill1.png"/>
</p><p>
<b>Pros</b>
</p><ul>
<li>Inexpensive in terms of calculations: No multiplies or divides necessary
</li><li>Objects on the back side of the hill are tracked
</li><li>The view&#39;s angle appears to follow the player over hills
</li></ul>
<b>Cons</b>
<ul>
<li>Accurate 3d geometry is impossible
</li><li>Tweaking is required to create a convincing effect
</li></ul>

<br/><br/>
<h2><a name="wrapup"><u>Wrap-up: Taking Raster Roads Farther</u></a></h2>
These accumulation-style curve formulas can be used verbatim if you don&#39;t need crazy curves or huge, rolling hills. Many games which use these
kinds of tricks scroll the road so fast that even a slight curve can be convincing.
<p>However, you may want to exaggerate
the effect in order to get a more dramatic road. One thing that can be done with any of these curve formulas
is to use high ddx or ddy values, but not allow dx or dy to exceed a sane value. And a user on YouTube, Foppygames,
has discovered another trick for getting more severe curves out of these accumulation formulas: multiply the dx or dy value by the 
z value for each line! This makes the curve more severe in the distance than it is in the foreground, and it creates 
a <a href="http://www.youtube.com/watch?v=mL5yJ5K13po">pretty convincing effect</a>.
</p><p>And, the experimentation doesn&#39;t stop there. In fact, the best thing about these engines is that there&#39;s no &#34;right&#34; way of doing it. Anything
that creates curves and warpage which is pleasing to the eye is allowed! In my earliest road engines, I used a sinewave lookup table to bend the
road.
</p><p>You can also use multiplication: To shift the road right, you might multiply the x position by, for example, 1.01 each line.
To move it left the same amount, you&#39;d multiply it by 0.99, or 1/1.01 (reciprocal of 1.01). However, armed with the knowledge
that many old processors did not have multiplication or were slow at it, I settled upon using
the accumulation technique because it only uses addition. It seemed the most likley &#34;authentic&#34; way of curving the road.
</p><p>
Some games, like OutRun, even use a simple spline system-- at least judging by the great reverse-engineered open-source C++ port,
<a href="http://reassembler.blogspot.com/p/cannonball-open-source-outrun-engine.html">Cannonball</a>.
</p><p>So, play around and experiment, and see what technique you like best!
</p><p>...or, read on for a description of a clever trick that mixes 3d polygons, is nearly as fast, is even more convincing, 
and can be displayed with the same oldschool raster hardware. Intrigued?




<br/><br/>
</p><h2><a name="proj3d"><u>True 3d-Projected Segments</u></a></h2>
<p>
<b><u>3d-Projected Segments vs. Raster Roads</u></b><br/>
As nice as raster roads are, they can be made even more impressive by involving a simple form of polygon rendering. This form of rendering
can actually be pulled off using the same limited raster hardware. However, it involves more calculations.
</p><p>
This trick is known to have been used in games such as <b>Road Rash</b> and <b>Test Drive II: The Duel</b>. Here&#39;s what it is: The track is
made of polygonal segments. However, rather than moving in full 3d space, it still only moves towards the camera. For curves, the road still
just skews left and right in almost an identical way to the raster road: There is no actual rotation when going around
curves as there would be in a full polygonal engine.
</p><p>Here&#39;s a rundown:
</p><ul>
<li>Since we are still faking curves and road angles, that means expensive rotation calculations still won&#39;t be needed
</li><li>The road is essentially a strip of quads: each section of the road is attached to the next section.  This means
we can calculate whether part of the road is visible or not based solely on its screen Y position relative to its previous neighbor.
</li><li>The relationship of these quads to one another will never change.  That is, the angle never actually changes, so
the quads are always and automatically sorted by Z.
</li></ul>

<p>
<b><u>The Basic 3d Road</u></b><br/>
First, break the road into polygonal quads. Each of these will be called a segment. Just like a segment in a purely raster
road, each segment here still has a curve amount (ddx), and either a hill amount (ddy) or a y-position that determines how high
up it is. Of course, these can also have other attributes as well such as terrain changes.
</p><p>
Pictured below is a segmented road made of very few polygons so we can easily see the boundaries between the segments and how
it affects the curvature of the road:<br/>
<img src="https://jackcarrick.net/blog/images/SegmentedRoad.png"/>
</p><p>
When rendering, first find the screen y location of each 3d segment by using the screen_y = world_y/z formula.  Or, if division
is too slow,
you could find the height off the ground of a given segment by multiplying the segment&#39;s height by the scaling factor for that
line. That could then be subtracted that from a reverse z-map (this map would be: for every z position of a flat road, what is the 
y?) to find
the final position on screen.
</p><p>
Then, you would
linearly interpolate the road widths and texture (if desired) between these heights.  Deciding which 3d segments to draw and which not to can be
determined easily:  From the front of the screen back, a 3d segment whose screen_y is projected as lower than the last-drawn 3d segment would not be shown (however, its sprites may still be visible because they stick up-- keep that in mind).
</p><p>
<u><b>Scrolling the Road</b></u><br/>
Now, we also need to learn how to scroll these segments. Move the entire mess of polygons which make up the road towards the camera. As the frontmost segment&#39;s polygon passes through the camera, move the entire road back to its starting point so that it loops. 
This is akin to how a scolling 2d tilefield can be made by scrolling up to one tile-worth, and when that is hit all the tiles are
shifted over and new tilemap data is pulled in. In this, we scroll up to one segment-worth, and when that is hit, we move the road
back and pull in new road data.
</p></td></tr></tbody></table>

</div></div>
  </body>
</html>
