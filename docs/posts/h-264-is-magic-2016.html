<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sidbala.com/h-264-is-magic/">Original</a>
    <h1>H.264 is Magic (2016)</h1>
    
    <div id="readability-page-1" class="page"><section>
            <!--kg-card-begin: markdown--><p>H.264 is a video compression codec standard. It is ubiquitous - internet video, Blu-ray, phones, security cameras, drones, everything. Everything uses H.264 now.</p>
<p>H.264 is a remarkable piece of technology. It is the result of 30+ years of work with one single goal: To reduce the bandwidth required for transmission of full-motion video.</p>
<p>Technically, it is very interesting. This post will give insight into some of the details at a high level - I hope to not bore you too much with the intricacies. Also note that many of the concepts explained here apply to video compression in general, and not just H.264.</p>
<blockquote>
<p>Why even compress anything?</p>
</blockquote>
<p>A simple uncompressed video file will contain an array of 2D buffers containing pixel data for each frame. So it&#39;s a 3D (2 spatial dimensions and 1 temporal) array of bytes. Each pixel takes 3 bytes to store - one byte each for the three primary colors (red, green and blue).</p>
<p>1080p @ 60 Hz = 1920x1080x60x3 =&gt; ~<strong>370 MB/sec</strong> of raw data.</p>
<p>This is next to impossible to deal with. A 50GB Blu-ray disk will only hold ~2 mins. You can&#39;t move it anywhere fast. Even SSDs have trouble dumping this straight from RAM to Disk[^1].</p>
<p>So yeah. We need compression.</p>
<blockquote>
<p>Why <em>H.264</em> compression?</p>
</blockquote>
<p>Yes, I will answer this. But first let me show you something. Here is the Apple Homepage:</p>
<p><img src="https://sidbala.com/content/images/2016/11/HomePage.png" alt="" loading="lazy"/></p>
<p>I captured the screen of this home page and produced two files:</p>
<ul>
<li><a href="https://sidbala.com/content/images/2016/11/outputFrame.png">PNG screenshot of the Apple homepage</a> <strong>1015KB</strong></li>
<li><a href="https://s3-us-west-2.amazonaws.com/sidbala-blog/VideoH264.mp4">5 Second 60fps H.264 video of the same Apple homepage</a> <strong>175KB</strong></li>
</ul>
<blockquote>
<p>Eh. What? Those file sizes look switched.</p>
</blockquote>
<p>No, they&#39;re right. The H.264 video, 300 frames long is 175KB. A single frame of that video in PNG is 1015KB.</p>
<p>It looks like we&#39;re storing 300 times the amount of data in the video. But the file size is a fifth. So H.264 would seem to be 1500x as efficient as PNG.</p>
<blockquote>
<p>How is this even possible? All right, what&#39;s the trick?</p>
</blockquote>
<p>There are very many tricks! H.264 uses all the tricks you can think of (and tons you can&#39;t think of). Let&#39;s go through the important ones.</p>
<h6 id="sheddingweight">Shedding weight</h6>
<p>Imagine you&#39;re building a car for street racing. You need to go faster. What is the first thing you do? You shed some weight. Your car weighs 3000 lbs. You throw away stuff you don&#39;t need. Those back seats? pfft. Chuck those. That subwoofer? Gone. No music for you. Air Conditioning? Yeah, ditch it. Transmission? Ye..no. Wait! We&#39;re gonna need that.</p>
<p>You remove everything except the things that matter.</p>
<p>This concept of throwing away bits you don&#39;t need to save space is called <strong>lossy</strong> compression. H.264 is a lossy codec - it throws away less important bits and only keeps the important bits.</p>
<p>PNG is a <strong>lossless</strong> codec. It means that nothing is thrown away. Bit for bit, the original source image can be recovered from a PNG encoded image.</p>
<blockquote>
<p>Important bits? How does the algorithm know what bits in my frame are important?</p>
</blockquote>
<p>There are few obvious ways to trim out images. Maybe the top right quadrant is useless all the time. So maybe we can zero out those pixels and discard that quadrant. We would use only 3/4th of the space we need. ~2200 lbs now. Or maybe we can crop out a thick border around the edges of the frame, the important stuff is in the middle anyway. Yes, you could do these. But H.264 doesn&#39;t do this.</p>
<blockquote>
<p>What does H.264 actually do?</p>
</blockquote>
<p>H.264, like other lossy image algorithms, discards detail information. Here is a close-up of the original compared with the image post-discard.</p>
<p><img src="https://sidbala.com/content/images/2016/11/CompressedImage-1.jpg" alt="" loading="lazy"/></p>
<p>See how the compressed one does not show the holes in the speaker grills in the MacBook Pro? If you don&#39;t zoom in, you would even notice the difference. The image on the right weighs in at <strong>7%</strong> the size of the original - and we haven&#39;t even compressed the image in the traditional sense. Imagine your car weighed just 200 lbs!</p>
<blockquote>
<p>7% wow! How do you discard detail information like that?</p>
</blockquote>
<p>For this we need a quick math lesson.</p>
<h6 id="informationentropy">Information Entropy</h6>
<p>Now we&#39;re getting to the juicy bits! Ha puns! If you took an information theory class, you might remember information entropy. Information entropy is the number of bits required to represent some information. Note that it is not simply the size of some dataset. It is minimum number of bits that must be used to represent all the information contained in a dataset.</p>
<p>For example, if your dataset is the result of a single coin toss, you need 1 bit of entropy. If you have record two coin tosses, you&#39;ll need 2 bits. Makes sense?</p>
<p>Suppose you have some strange coin - you&#39;ve tossed it 10 times, and every time it lands on heads. How would you describe this information to someone? You wouldn&#39;t say HHHHHHHHH. You would just say &#34;10 tosses, all heads&#34; - bam! You&#39;ve just compressed some data! Easy. I saved you hours of mindfuck lectures. This is obviously an oversimplification, but you&#39;ve transformed some data into another shorter representation of the same information. You&#39;ve reduced data <strong>redundancy</strong>. The information entropy in this dataset has not changed - you&#39;ve just converted between representations. This type of encoder is called an <strong>entropy encoder</strong> - it&#39;s a general-purpose lossless encoder that works for any type of data.</p>
<h6 id="frequencydomain">Frequency Domain</h6>
<p>Now that you understand information entropy, let&#39;s move on to transformations of data. You can represent data in some fundamental units. If you use binary, you have 0 and 1. If you use hex, you have 16 characters. You can easily transform between the two systems. They are essentially equivalent. So far so good? Ok!</p>
<p>Now, some imagination! Imagine you can transform any dataset that varies over space(or time) - something like the brightness value of an image, into a different coordinate space. So instead of x-y coordinates, let&#39;s say we have frequency coordinates. freqX and freqY are the axes now. This is called a <strong>frequency domain</strong> representation. There is another mindfuck mathematical theorem[^2] that states that you can do this for any data and you can achieve a perfect lossless transformation as long as freqX and freqY are high enough.</p>
<blockquote>
<p>Okay, but what the freq are freqX and freqY?</p>
</blockquote>
<p>freqX and freqY are some other set of basis units. Just like when we switch from binary to hex, we have a different fundamental unit, we&#39;re switching from the familiar X-Y to freqX and freqY. Hex &#39;A&#39; looks different from binary &#39;1010&#39;. Both mean the same thing, but <strong>look</strong> different. So here is what our image looks like in the frequency domain:</p>
<p><img src="https://sidbala.com/content/images/2016/11/BasicFFT-2.png" alt="" loading="lazy"/></p>
<p>The fine grill on that MacBook pro has a high information content in the higher frequency components of that image. Finely varying content = high frequency components. Any sort of gradual variation in the color and brightness - such as gradients are low frequency components of that image. Anything in between falls in between. So fine details = high freq. Gentle gradients = low freq. Makes sense?</p>
<p>In the frequency domain representation, the low frequency components are near the center of that image. The higher frequency components are towards of the edges of the image.</p>
<blockquote>
<p>Okay. Kinda makes sense. But why do all this?</p>
</blockquote>
<p>Because now, you can take that frequency domain image and then mask out the edges - discard information which will contain the information with high frequency components. Now if you convert back to your regular x-y coordinates, you&#39;ll find that the resulting image looks similar to the original but has lost some of the fine details. But now, the image only occupies a fraction of the space. By controlling how big your mask is, you can now tune precisely how detailed you want your output images to be.</p>
<p>Here is the close-up of the laptop in the home page again. Except now, there is a circular border mask that&#39;s been applied.</p>
<p><img src="https://sidbala.com/content/images/2016/11/QuantizationHorizontalWithMasks-1.jpg" alt="" loading="lazy"/></p>
<p>The numbers represent the information entropy of that image as a fraction of the original. Even at 2%, you won&#39;t notice the difference unless you&#39;re at this zoom level. 2%! - your car now weighs 60 lbs!</p>
<p>So that&#39;s how you shed weight. This process in lossy compression is called <strong>quantization</strong>[^3].</p>
<blockquote>
<p>Okay. Impressive, I guess. What else you got?</p>
</blockquote>
<h6 id="chromasubsampling">Chroma Subsampling.</h6>
<p>The human/eye brain system is not very good at resolving finer details in color. It can detect minor variations in brightness very easily but not color. So there must be some way to discard color information to shed even more weight.</p>
<p>In a TV signal, R+G+B color data gets transformed to Y+Cb+Cr. The Y is the luminance (essentially black and white brightness) and the Cb and Cr are the chrominance (color) components. RGB and YCbCr are equivalent in terms of information entropy.</p>
<blockquote>
<p>Why unnecessarily complicate? RGB not good enough for you?</p>
</blockquote>
<p>Back before we had color TV, we only had the Y signal. And when color TVs just started coming along, engineers had to figure out a way to transmit RGB color along with Y. Instead of using two separate data streams, they wisely decided to encode the color information into Cb and Cr and transmit that along with the Y information. That way, BW TVs would only look at the Y component. Color TVs will, in addition, look at the chrominance components and convert to RGB internally.</p>
<p>But check out the trick: the Y component gets encoded at full resolution. The C components only at a quarter resolution. Since the eye/brain is terrible at detecting color variations, you can get away with this. By doing this, you reduce total bandwidth by one half, with very little visual difference. Half! Your car now weighs 30 lbs!</p>
<p>This process of discarding some of the color information is called <strong>Chroma Subsampling</strong>[^4]. While not specific to H.264 and has been around for decades itself, it is used almost universally.</p>
<p>Those are the big weight shedders for lossy compression. Our frames are now tiny - since we discarded most of the detail information and half of the color information.</p>
<blockquote>
<p>Wait. That&#39;s it? Can we do something more?</p>
</blockquote>
<p>Yes. Weight shedding is only the first step. So far we&#39;re only looking at the spatial domains within a single frame. Now it&#39;s time to explore temporal compression - where we look at a group of frames across time.</p>
<h6 id="motioncompensation">Motion compensation</h6>
<p>H.264 is a motion compensation compression standard.</p>
<blockquote>
<p>Motion compensation? What now?</p>
</blockquote>
<p>Imagine you&#39;re watching a tennis match. The camera is fixed at a certain angle. The only thing moving is the ball back and forth. How would you encode this information? You do what you always do, right? You have a 3D array of pixels, two dimensions in space and one in time. Right?</p>
<p>Nah. Why would you? Most of the image is the same anyway. The court, the net, the crowds, all are static. The only real action is the ball moving. What if you could just have one static image of everything in the background, and then one moving image of just the ball? Wouldn&#39;t that save a lot of space? You see where I am going with this? Get it? See where I am going? Motion estimation?</p>
<p>Lame jokes aside, this is exactly what H.264 does. H.264 splits up the image into macro-blocks - typically 16x16 pixel blocks that it will use for motion estimation. It encodes one static image - typically called an <strong>I-frame</strong>(Intra frame). This is a full frame - containing all the bits it required to construct that frame. And then subsequent frames are either <strong>P-frames</strong>(predicted) or <strong>B-frames</strong>(bi-directionally predicted). P-frames are frames that will encode a motion vector for each of the macro-blocks from the previous frame. So a P-frame has to be constructed by the decoder based on previous frames. It starts with the last I-frame in the video stream and then walks through every subsequent frame - adding up the motion vector deltas as it goes along until it arrives at the current frame.</p>
<p>B-frames are even more interesting, where the prediction happens bi-directionally, both from past frames and from future frames. So you can imagine now why that Apple home page video is so well compressed. Because it&#39;s really just three I-frames in which the macro blocks are being panned around.</p>
<p>Let&#39;s say you&#39;ve been playing a video on YouTube. You missed the last few seconds of dialog, so you scrub back a few seconds. Have you noticed that it doesn&#39;t instantly start playing from that timecode you just selected. It pauses for a few moments and then plays. It&#39;s already buffered those frames from the network, since you just played it, so why that pause?</p>
<blockquote>
<p>Yeah that annoys the shit out of me. Why does it do that?</p>
</blockquote>
<p>Because you&#39;ve asked the decoder to jump to some arbitrary frame, the decoder has to redo all the calculations - starting from the nearest I-frames and adding up the motion vector deltas to the frame you&#39;re on - and this is computationally expensive, and hence the brief pause. Hopefully you&#39;ll be less annoyed now, knowing it&#39;s actually doing hard work and not just sitting around just to annoy you.</p>
<p>Since you&#39;re only encoding motion vectors deltas, this technique is extremely space-efficient for any video with motion, at the cost of some computation.</p>
<p>Now we&#39;ve covered both spatial and temporal compression! So far we have a shitton of space saved in Quantization. Chroma subsampling further halved the space required. On top of that, we have motion compensation that stores only 3 actual frames for the ~300 that we had in that video.</p>
<blockquote>
<p>Looks pretty good to me. Now what?</p>
</blockquote>
<p>Now we wrap up and seal the deal. We use a traditional lossless entropy encoder. Because why not? Let&#39;s just slap that on there for good measure.</p>
<h6 id="entropycoder">Entropy Coder</h6>
<p>The I-frames, after the lossy steps, contain redundant information. The motion vectors for each of the macro blocks in the P and B-frames - there are entire groups of them with the same values - since several macro blocks move by the same amount when the image pans in our test video.</p>
<p>An entropy encoder will take care of this redundancy. And since it is a general purpose lossless encoder, we don&#39;t have to worry about what tradeoffs it&#39;s making. We can recover all the data that goes in.</p>
<p>And, we&#39;re done! At the core of it, this is how video compression codecs like H.264 work. These are its tricks.</p>
<blockquote>
<p>Ok great! But I am curious to know how much our car weighs now.</p>
</blockquote>
<p>The original video was captured at an odd resolution of 1232x1154. If we apply the math here, we get:</p>
<p>5 secs @ 60 fps = 1232x1154x60x3x5 =&gt; <strong>1.2 GB</strong></p>
<p>If we apply the same ratio to our 3000 lb car, we get <strong>0.4 lbs</strong> as the final weight. 6.5 ounces!</p>
<p><strong>Yeah. It&#39;s magic!</strong></p>
<p>Obviously, I am massively oversimplifying several decades of intense research in this field. If you want to know more, the <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC">Wikipedia Page</a> is pretty descriptive.</p>
<p>Have comments? Did I get something wrong? Not a fan of the lame jokes? Offended by the swearing? Use <a href="https://news.ycombinator.com/item?id=12871403"><strong>HackerNews</strong></a> or <a href="https://www.reddit.com/r/programming/comments/5b31gt/h264_is_magic/"><strong>Reddit</strong></a> for voicing your opinion!</p>
<p>Or hit me up on <a href="https://twitter.com/SidBaIa"><strong>Twitter</strong></a> or <a href="https://www.linkedin.com/in/sidbalasubramanian"><strong>LinkedIn</strong></a> if you want to chat.</p>
<p>[^1]<a href="http://www.anandtech.com/show/8747/samsung-ssd-850-evo-review/8">SSD Benchmarks</a></p>
<p>[^2]<a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Nyquist-Shannon Sampling Theorem</a></p>
<p>[^3][Quantization](<a href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)">https://en.wikipedia.org/wiki/Quantization_(signal_processing)</a></p>
<p>[^4]<a href="https://en.wikipedia.org/wiki/Chroma_subsampling">Chroma Subsampling</a></p>
<!--kg-card-end: markdown-->
        </section></div>
  </body>
</html>
