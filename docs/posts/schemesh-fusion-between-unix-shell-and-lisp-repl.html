<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/cosmos72/schemesh">Original</a>
    <h1>Schemesh: Fusion between Unix shell and Lisp REPL</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<div dir="auto"><h2 tabindex="-1" dir="auto">Fusion between a Unix shell and a Lisp REPL</h2><a id="user-content-fusion-between-a-unix-shell-and-a-lisp-repl" aria-label="Permalink: Fusion between a Unix shell and a Lisp REPL" href="#fusion-between-a-unix-shell-and-a-lisp-repl"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Schemesh is an interactive shell scriptable in Lisp.</p>
<p dir="auto">It is primarily intended as a user-friendly Unix login shell, replacing bash, zsh, pdksh etc.</p>
<p dir="auto">As such, it supports interactive line editing, autocompletion, history and the familiar Unix shell syntax:
it can start commands, including redirections, pipelines, job concatenation with <code>;</code> <code>&amp;&amp;</code> <code>||</code>,
groups surrounded by <code>{ }</code>, subshells surrounded by <code>[ ]</code>, and manage foreground/background jobs.</p>
<p dir="auto">For more complex tasks, it seamlessly integrates a full Lisp REPL backed by Chez Scheme.</p>
<p dir="auto">Schemesh can be used as:</p>
<ul dir="auto">
<li>
<p dir="auto">a replacement for traditional interactive Unix shell, as for example bash/zsh/pdksh etc.</p>
</li>
<li>
<p dir="auto">a Unix shell scriptable in Chez Scheme.</p>
</li>
<li>
<p dir="auto">a Scheme REPL with additional syntax and functions to start, redirect and manage Unix processes.</p>
</li>
<li>
<p dir="auto">a Scheme library for starting, redirecting and managing Unix processes.</p>
</li>
</ul>
<p dir="auto">For scripting and serious programming, schemesh completely replaces the slow, clumsy and error-prone
scripting language of a traditional shell (yes, the author has opinions) with a full-featured Lisp REPL,
backed by the fast and open-source Chez Scheme compiler that generates highly optimized native code.</p>

<p dir="auto">As a traditional Unix shell: type a command and press Enter.</p>
<p dir="auto">If the parentheses/braces/brackets/quotes are balanced,</p>
<p dir="auto">If the parentheses/braces/brackets/quotes are <em>not</em> balanced,</p>
<p dir="auto">Switching between shell syntax and Lisp syntax is extremely simple, and can be done basically everywhere:</p>
<ul dir="auto">
<li>
<p dir="auto">open parenthesis <code>(</code> temporarily switches to Lisp syntax until the corresponding <code>)</code>.</p>
</li>
<li>
<p dir="auto">open brace i.e. <code>{</code> temporarily switches to shell syntax until the corresponding <code>}</code>.</p>
</li>
<li>
<p dir="auto">open bracket i.e. <code>[</code> starts a new sub-form in current syntax until the corresponding <code>]</code>.</p>
</li>
<li>
<p dir="auto">the directives <code>#!scheme</code> <code>#!chezscheme</code> and <code>#!r6rs</code> temporarily switch to Scheme syntax
(with the appropriate flavor) until the end of current <code>( )</code>, <code>[ ]</code> or <code>{ }</code>.</p>
</li>
<li>
<p dir="auto">the directive <code>#!shell</code> temporarily switches to shell syntax until the end of current <code>( )</code>, <code>[ ]</code> or <code>{ }</code>.</p>
</li>
<li>
<p dir="auto">shell syntax creates first-class Lisp <code>sh-job</code> objects, which can be started/stopped/managed from both syntaxes.</p>
</li>
<li>
<p dir="auto"><code>sh-job</code> objects are discoverable and pretty-printable:</p>
</li>
</ul>
<p dir="auto">The most common mechanisms to start/stop/manage jobs from shell syntax are:</p>
<ul dir="auto">
<li>CTRL+C      interrupt the current foreground job</li>
<li>CTRL+Z      suspend the current foreground job</li>
<li><code>bg job-id</code> resume a job in background</li>
<li><code>fg job-id</code> resume a job in foreground</li>
</ul>
<p dir="auto">The analogous job control mechanisms from Scheme syntax are:</p>
<ul dir="auto">
<li>CTRL+C      as above</li>
<li>CTRL+Z      as above</li>
<li><code>(sh-start job-object)</code> start a job in background, return immediately</li>
<li><code>(sh-run/i job-object)</code> start a job in foreground, wait until job finishes or is suspended</li>
<li><code>(sh-run   job-object)</code> start a job in foreground, wait until job finishes</li>
<li><code>(sh-bg    job-or-id)</code> resume a job in background, return immediately</li>
<li><code>(sh-fg    job-or-id)</code> resume a job in foreground, wait until job finishes or is suspended</li>
<li><code>(sh-wait  job-or-id)</code> resume a job in foreground, wait until job finishes</li>
</ul>
<p dir="auto">Some more advanced Scheme functions:</p>
<ul dir="auto">
<li><code>(sh-run/string job-object)</code> start a job in foreground, wait until job finishes, return its output as a Scheme string</li>
<li><code>(sh-start/fd-stdout job-object)</code> start a job in background, return a file descriptor fixnum for reading its standard output - for example with <code>(open-fd-input-port fd)</code></li>
</ul>

<p dir="auto">You can mix shell command execution with Lisp control structures, loops and functions as for example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(if (some_expression arg1 (sub_expression2))
  (sh-run/i {then_run_this_command foo bar $VAR})
  (sh-run/i {else_run_this_command foo bar $VAR}))"><pre>(<span>if</span> (some_expression arg1 (sub_expression2))
  (sh-run/i {then_run_this_command foo bar $VAR})
  (sh-run/i {else_run_this_command foo bar $VAR}))</pre></div>
<p dir="auto">instead of typical shell syntax, which is error prone as it&#39;s based on string expansion and splitting,
and geared toward command execution, as for example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Note: this is POSIX shell syntax for `if-then-else`. It will NOT work in schemesh.
if some_command &#34;$arg1&#34; &#34;$(sub_command)&#34;
then
  then_run_this_command foo bar $VAR
else
  else_run_this_command foo bar $VAR
fi"><pre><span><span>#</span> Note: this is POSIX shell syntax for `if-then-else`. It will NOT work in schemesh.</span>
<span>if</span> some_command <span><span>&#34;</span><span>$arg1</span><span>&#34;</span></span> <span><span>&#34;</span><span><span>$(</span>sub_command<span>)</span></span><span>&#34;</span></span>
<span>then</span>
  then_run_this_command foo bar <span>$VAR</span>
<span>else</span>
  else_run_this_command foo bar <span>$VAR</span>
<span>fi</span></pre></div>
<p dir="auto">more examples mixing shell and Lisp syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="find (lisp-function-returning-some-string) -type f | grep ^lib | wc -l &amp;
fg 1"><pre>find (lisp-function-returning-some-string) -type f <span>|</span> grep ^lib <span>|</span> wc -l <span>&amp;</span>
<span>fg</span> 1</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="(define job {ls -l &gt; ls.out || echo &#34;ls failed&#34;})
(sh-start job)
(sh-fg job)"><pre>(define job {ls -l <span>&gt;</span> ls.out || echo <span><span>&#34;</span>ls failed<span>&#34;</span></span>})
(sh-start job)
(sh-fg job)</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="(define txt (sh-run/string {git log}))
(display txt)"><pre>(define txt (sh-run/string {git log}))
(display txt)</pre></div>
<p dir="auto">a slighty more complex example - uses several additional functions and macros provided by schemesh</p>
<div dir="auto" data-snippet-clipboard-copy-content="(import (schemesh all))

(for ((f (in-list (sh-run/string-split-after-nuls {find -type f -print0}))))
  (file-rename f (string-replace f &#34;.old&#34; &#34;.bak&#34;)))"><pre>(<span>import</span> (schemesh all))

(for ((f (in-list (sh-run/string-split-after-nuls {find -type f -print0}))))
  (file-rename f (string-replace f <span><span>&#34;</span>.old<span>&#34;</span></span> <span><span>&#34;</span>.bak<span>&#34;</span></span>)))</pre></div>

<ul>
<li> REPL with multi-line editing and parentheses highlighting</li>
<li> dual syntax parsing, allows mixing Scheme and shell expressions</li>
<li> shortcuts to execute commands by pressing a single key: KP- KP+</li>
<li> history searchable with PageUp and PageDown keys</li>
<li> cut-and-paste</li>
<li> context-sensitive autocompletion - some improvements pending</li>
<li> UTF-8b for losslessly converting byte sequences that are not valid UTF-8</li>
<li> shell commands, including <code>;</code> <code>&amp;</code> <code>!</code> <code>&amp;&amp;</code> <code>||</code> <code>{</code> <code>}</code> <code>[</code> <code>]</code></li>
<li> shell job control</li>
<li> shell aliases</li>
<li> shell builtins</li>
<li> shell environment variables</li>
<li> shell pipelines <code>|</code> <code>|&amp;</code></li>
<li> shell redirections <code>&lt;</code> <code>&gt;</code> <code>&lt;&gt;</code> <code>&gt;&gt;</code> <code>&lt;&amp;</code> <code>&gt;&amp;</code> <code>$()</code> <code>``</code></li>
<li> shell wildcard expansion</li>
<li> each job has its own current directory and environment variables,
initially inherited from parent job</li>
<li> customizable prompt, set by environment variable <code>$SCHEMESH_PS1</code></li>
<li> if the directory <code>$HOME/.cache/schemesh/</code> exists,</li>
<li> if the file <code>$HOME/.config/schemesh/repl_init.ss</code> exists,</li>
<li> if the file <code>$HOME/.config/schemesh/repl_quit.ss</code> exists,</li>
</ul>

<p dir="auto">On Debian Linux, execute the following commands:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo apt update
sudo apt install build-essential chezscheme-dev liblz4-dev libncurses-dev git uuid-dev zlib1g-dev
git clone https://github.com/cosmos72/schemesh
cd schemesh
make -j
sudo make install"><pre>sudo apt update
sudo apt install build-essential chezscheme-dev liblz4-dev libncurses-dev git uuid-dev zlib1g-dev
git clone https://github.com/cosmos72/schemesh
<span>cd</span> schemesh
make -j
sudo make install</pre></div>
<p dir="auto">On Fedora Linux:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo dnf install gcc gcc-c++ make chez-scheme-devel lz4-devel ncurses-devel git libuuid-devel zlib-devel
git clone https://github.com/cosmos72/schemesh
cd schemesh
make -j
sudo make install"><pre>sudo dnf install gcc gcc-c++ make chez-scheme-devel lz4-devel ncurses-devel git libuuid-devel zlib-devel
git clone https://github.com/cosmos72/schemesh
<span>cd</span> schemesh
make -j
sudo make install</pre></div>
<p dir="auto">For other systems, the instructions above can (hopefully) be adapted as needed.</p>
<p dir="auto">If all went well, you can execute <code>schemesh</code></p>
<p dir="auto">In case your environment variable <code>$PATH</code> does not contain <code>/usr/local/bin</code>,
the command <code>schemesh</code> will not suffice - you will need to run <code>/usr/local/bin/schemesh</code></p>
<p dir="auto">Troubleshooting:</p>
<p dir="auto">if <code>make -j</code> fails, a possible error is that it fails to autodetect Chez Scheme installation directory.
In such case you can manually specify it, as for example <code>make -j CHEZ_SCHEME_DIR=&#34;/usr/local/lib/csv10.0.0/ta6le&#34;</code></p>

<p dir="auto">See <a href="https://github.com/cosmos72/schemesh/blob/main/doc/recent_changes.md">doc/recent_changes.md</a></p>

<ul dir="auto">
<li>autocomplete shell paths and scheme strings: unescape stems before searching for completions, escape completions</li>
<li>autocomplete shell paths and scheme strings: when autocompleting inside single or double quotes, the stem starts at the quotes.</li>
<li>autocomplete shell paths starting with ~</li>
<li>maybe add missing shell builtins &#34;kill&#34;</li>
<li>implement function <code>(string-&gt;sh-patterns)</code></li>
</ul>
</article></div></div>
  </body>
</html>
