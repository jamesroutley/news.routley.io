<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ryleealanza.org/posts/hither/">Original</a>
    <h1>Hither, a little forth written in Zig</h1>
    
    <div id="readability-page-1" class="page"><div id="outline-text-headline-2"><p>You can find the code for <code>hither</code> on <a href="https://github.com/ryleelyman/hither">GitHub</a>.
To run it yourself, you’ll need a copy of <a href="https://ziglang.org">Zig</a> version 0.12.
I believe that in its current state, as of today (May 21, 2024)
<code>hither</code> will also run on the development version of Zig 0.13,
but I make no promises.</p><p>Anyway, now that you’re all squared away,
you can build and run <code>hither</code> from the repository root by executing <code>zig build run</code>.</p><p>(By the way, if you’re reading this and want to give <code>hither</code> a try
but the above isn’t sufficient instructions for you to fill in the blanks,
shoot me an email!
I’d be tickled pink to walk you through it.)</p><p>Anyway, the Zig compiler will do its thing for a bit and then hit you with</p><p>so now you’re looking at the <code>hither</code> REPL!
you can type some stuff and hit enter, and the REPL will think about it and tell you what it computed.
for example:</p><p>(By the way, apologies if you’re a command line super Amadeus, in which case
the REPL interaction might feel a bit constrained, since familiar keyboard interaction patterns
from interacting with your shell simply won’t work and will dump strange escape codes instead.
I might find the motivation to clean this up, but I also might not.)</p><p>Anyway, from this we can learn a few things.
First of all, like <a href="https://en.wikipedia.org/wiki/FORTH">Forth</a>, hither uses what is sometimes called “reverse Polish notation”,
a funky way of operating I first learned by playing with my dad’s fancy calculator in the 90s.
Basically rather than “infix” notation, which we’re used to for addition like <code>2 + 2</code>,
we put the <em>arguments</em> to the operation <em>before</em> the operand.
This has the advantage of making parsing essentially trivial:
by the time our parser hits the <code>+</code>, everything is all set up for it to just perform the addition.
Programming languages that operate in this way, by sort of building up longer and longer streams of operations,
are sometimes called <a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">concatenative</a>.</p><p>So <code>2 2 +</code> operates like this: hither has a little “stack”,
a “first in, first out” data structure common to many programming languages.
the <code>hither</code> interpreter takes in a line of text,
parses it into little chunks I’ll call “words”,
and then pushes each word onto the stack.
Here we have three words, <code>2</code>, <code>2</code> and <code>+</code>.
When <code>2</code> is pushed onto the stack, nothing happens—it’s just the number 2.
But when <code>+</code> is pushed, it pops two words from the stack,
checks that they’re numbers, and then pushes their sum onto the stack.
Since that’s the end of the line,
the <code>hither</code> interpreter checks that there isn’t anything hanging out waiting to be finished on the stack
(secretly it does this by checking the state of a <em>return</em> stack that it also manages).
If everything looks good,
the interpreter prints out the contents of the stack,
so <code>4</code> in this case,
and then writes <code>ok</code> to tell you that the previous operation completed successfully.</p><div id="outline-container-headline-3"><h3 id="headline-3">Strings and variables</h3><div id="outline-text-headline-3"><p>From a user’s perspective, <code>hither</code> supports four basic data types:
<em>integers</em> which we’ve seen,
floating point <em>numbers,</em> like <code>1.5</code>,
<em>strings</em> which you enter surrounded by quotation marks as in <code>&#34;this is a string&#34;</code>,
and <em>words</em> which are whitespace-delimited symbols which don’t parse as strings, integers or numbers:
<code>+</code> is a word, but so is something like <code>this_is_4-word</code>.
There are several words predefined for you.
At the time of this writing, they are:
<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>dupe</code>, <code>swap</code>, <code>height</code>, <code>top</code>, <code>drop</code>,
<code>and</code>, <code>or</code>, <code>not</code>, <code>print</code>, <code>++</code>, <code>:=</code>, <code>@</code>, <code>while</code>, <code>_</code>, <code>&#39;</code>, <code>{</code>, <code>}</code>, <code>if</code>, <code>else</code>, <code>then</code>,
<code>exit</code>, <code>dump</code>, <code>inspect</code> and <code>abort</code>.
I’ll explain some of them, but leave the rest to you to play around with—or to ask me directly!
To define a new word, you can use <code>:=</code> in combination with either a string or the <code>&#39;</code> operator,
as in</p><div><div><pre tabindex="0"><code data-lang="text"><span><span>&gt; 1 &#39; x :=
</span></span><span><span>ok
</span></span><span><span>&gt; x
</span></span><span><span>1
</span></span><span><span>ok
</span></span><span><span>&gt; 2 &#34;x&#34; :=
</span></span><span><span>ok
</span></span><span><span>&gt; x
</span></span><span><span>2
</span></span><span><span>ok</span></span></code></pre></div></div><p>These are completely identical. Unfortunately, directly writing <code>1 x :=</code> won’t work:
the reason is that the interpreter doesn’t <em>know</em> that the <code>:=</code> operator is coming,
so it attempts to interpret <code>x</code> as a word.
If <code>x</code> has been defined already, this succeeds, but puts the <em>value</em> of <code>x</code> onto the stack,
which doesn’t make sense to assign with <code>:=</code>.
If <code>x</code> hasn’t been defined, then we get an error.
That’s why we need to use the <code>&#39;</code> operator—it effectively tells the interpreter
to push the next token onto the stack <em>without</em>
calling it or even attempting to resolve whether it’s been defined.</p></div></div><div id="outline-container-headline-4"><h3 id="headline-4">Lambdas</h3><div id="outline-text-headline-4"><p>To define a word that actually executes some code,
we can use the <code>{</code> and <code>}</code> pair.
These start and end a <em>lambda,</em> programmer jargon for an “anonymous function”.
You should think of the curly braces as sort putting what ever comes between them “in quotes”.
Just as doing that in English is different from saying those words directly,
so too in <code>hither</code> does this “quotation” put a different spin on things.
Rather than executing directly,
the <code>hither</code> interpreter collects everything inside and packages it up:</p><div><div><pre tabindex="0"><code data-lang="text"><span><span>&gt; { 1 2 + }
</span></span><span><span>slice: address: 0xfff80, length: 3, type: definition
</span></span><span><span>ok</span></span></code></pre></div></div><p>(On your machine, the actual address you see printed might differ, but the length and type should be the same.)
What this is telling us is that there <em>is</em> something on the stack,
but that thing is a <em>definition,</em> rather than anything else we’ve seen previously.
There are effectively two things you can do with definitions:
call them now or assign them to words to call later.
To call a definition now, you use <code>@</code>:</p><p>To assign a definition to a word, you use the same syntax we did for variables:</p><div><div><pre tabindex="0"><code data-lang="text"><span><span>&gt; { 1 2 + } &#39; three :=
</span></span><span><span>ok
</span></span><span><span>&gt; three
</span></span><span><span>3
</span></span><span><span>ok</span></span></code></pre></div></div></div></div></div></div>
  </body>
</html>
