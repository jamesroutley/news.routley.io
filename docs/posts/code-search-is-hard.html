<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.val.town/blog/search-notes/">Original</a>
    <h1>Code search is hard</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-bvzihdzo=""> <article itemscope="" itemtype="https://schema.org/Article" data-astro-cid-bvzihdzo=""> <div data-astro-cid-bvzihdzo=""> <div data-astro-cid-bvzihdzo="">  <p><img src="https://blog.val.town/_astro/tom.Cx99M2g4_Z1L13eJ.webp" srcset="/_astro/tom.Cx99M2g4_Z2jf3OO.webp 1x, /_astro/tom.Cx99M2g4_Z2f6MW8.webp 2x, /_astro/tom.Cx99M2g4_Z2aXx4r.webp 3x" alt="Tom MacWright" }="true" data-astro-cid-bvzihdzo="" width="20" height="20" loading="lazy" decoding="async"/> 
on
<time datetime="2024-04-10T00:00:00.000Z"> Apr 10, 2024 </time> </p> </div> <p>Val Town’s search functionality isn’t very good. Right now it’s built on the Postgres <a href="https://www.postgresql.org/docs/current/functions-matching.html">ILIKE</a> functionality, which just performs a substring search: if your search term is in the code, it appears in search results. There’s virtually no ranking involved, and queries with multiple words are pretty poorly supported.
Better search is <a href="https://github.com/val-town/val-town-product/discussions/69">one of our most-requested features</a>.</p>
<p>I’m working on improving this, but we haven’t found a solution that fits our needs yet.
Here are some notes from our research. So far what we’ve learned is that:</p>
<ul>
<li>Mainstream search solutions are designed for natural language, not code.</li>
<li>Big companies with code search needs have spent a lot of time and money
building their own custom solutions.</li>
<li>We have a lot of data already, and need a solution that scales well.</li>
<li>The infrastructure and complexity tradeoffs involved in using a separate
search service instead of a database extension are important.</li>
</ul>
<h3 id="code-search-versus-natural-language-search">Code search versus natural language search</h3>
<p>A common issue with off-the shelf search solutions is that they’re designed to work with English and other natural languages. For example, here are some of the algorithms you get by default with a usual FTS setup:</p>
<ul>
<li><strong>Stop words removal</strong>: words like “the” and “it” are removed from text before it is indexed, because they’re so common that they cause more problems for performance than they’re worth.</li>
<li><strong>Stemming</strong>: this mostly <a href="https://en.wikipedia.org/wiki/Grammatical_conjugation">reverses conjugation</a>, turning a word like “running” into “run” before it is added to the index, and doing the same for search queries, so that you can search for “runs” and get a search result for a document with the term “running.”</li>
<li><strong>Lemmatization</strong>: some search indexes are even fancy enough to substitute synonyms for more common words, so that you can search for “excellent” and get results for documents including “great.”</li>
</ul>
<p>All together, this means that the vector derived from a document that you’re storing in the index does not look like the document at all:</p>
<div><figure><pre tabindex="0"><code><div><p><span>select</span><span> </span><span>*</span><span> </span><span>from</span><span> to_tsvector(</span><span>&#39;english&#39;</span><span>, </span><span>&#39;I am writing this example sentence&#39;</span><span>);</span></p></div><div><p><span>--- &#39;exampl&#39;:5 &#39;sentenc&#39;:6 &#39;write&#39;:3</span></p></div></code></pre></figure></div>
<p>The problem with all of these rules is that they wreak havoc on code. <code>the</code> is not a stop-word in TypeScript: it’s a valid variable name that you might want to search for. Word boundaries aren’t the same, and stemming function names doesn’t make much sense.</p>
<div><figure><pre tabindex="0"><code><div><p><span>select</span><span> </span><span>*</span><span> </span><span>from</span><span> to_tsvector(</span><span>&#39;english&#39;</span><span>,</span></p></div><div><p><span>  </span><span>&#39;function stringifyNumber(a: number): string { return a.toString() }&#39;</span><span>);</span></p></div><div><p><span>-- &#39;a.tostring&#39;:7 &#39;function&#39;:1 &#39;number&#39;:4 &#39;return&#39;:6 &#39;string&#39;:5 &#39;stringifynumb&#39;:2</span></p></div></code></pre></figure></div>
<p>This is a pretty bad index: it has words that should be stop words, like <code>function</code>, and won’t split <code>a.toString()</code> into two tokens because <code>.</code> is not a default word boundary.</p>
<h3 id="full-text-search">Full Text Search</h3>
<p>Postgres has a <a href="https://www.postgresql.org/docs/current/textsearch.html">Full Text Search</a> extension which is supported by our hosting provider, <a href="https://docs.render.com/postgresql-extensions">Render</a>. I’ve used FTS in previous projects, and for certain scales, it works great. You can try and <a href="https://www.amazingcto.com/postgres-for-everything/">use Postgres for everything</a>, and frankly, so far we have: we’ve been using the heck out of Postgres. It’s a fantastic piece of technology with great documentation that is well-supported by our hosting provider.</p>
<p>If we can use Postgres for something, we will: keeping infrastructure as simple as possible is essential with a small team.</p>
<p>However, the previous projects I’ve used FTS for have run into performance problems and struggled to scale - <a href="https://observablehq.com/">Observable</a> ended up
moving to Elasticsearch. We have a ton of vals, and are testing the limits of a single-node Postgres cluster. It’s hard to find any accounts of code-search using FTS, though people might be quietly succeeding with it. I wanted to avoid this as a first option but keep it in my back pocket.</p>
<h3 id="pg_trgrm">pg_trgrm</h3>
<p>The solution that we’ve soft-launched as the v2 search algorithm is based on <a href="https://www.postgresql.org/docs/current/pgtrgm.html"><code>pg_trgrm</code></a>, which implements <a href="https://en.wikipedia.org/wiki/Trigram_search">trigram search</a> in Postgres. Code search <em>does</em> seem to succeed with trigrams: <a href="https://swtch.com/~rsc/regexp/regexp4.html">Russ Cox’s famous (to me?) piece from 2012 tells the story of how Google Code Search</a> used trigram indexes and a special regex implementation to succeed, technically. GitHub’s <a href="https://github.blog/2023-02-06-the-technology-behind-githubs-new-code-search/">new search system</a> uses trigram search too, in addition to a lot of technology that I’m jealous of. <a href="https://github.com/sourcegraph/zoekt">Sourcegraph</a> has a trigram-based search tool that they’ve inherited from Google, too.</p>
<p>Our work with the Postgres <code>pg_trgrm</code> approach has been heavily informed by <a href="https://devlog.hexops.com/2021/postgres-regex-search-over-10000-github-repositories/">Stephen Gutekanst’s blog post series about indexing repositories locally</a> in Postgres. We’ve created a <a href="https://www.postgresql.org/docs/current/gin.html">GIN</a> index with <code>gin_trgm_ops</code> on a column containing search text.</p>
<p>The conclusion so far is that this is a great solution for regex search, but we’re not doing regex search: most searches are more freeform. We’re using <a href="https://www.postgresql.org/docs/current/pgtrgm.html#PGTRGM-FUNCS-OPS">word_similarity</a> for search ranking, and it has been very hard to coax the algorithm into giving us anything like a reasonable ranking.</p>
<h3 id="the-universe-of-options">The universe of options</h3>
<table><thead><tr><th>Option</th><th>Architecture</th><th>Language</th><th>Stars</th></tr></thead><tbody><tr><td><a href="https://www.meilisearch.com/">Meilisearch</a></td><td>Standalone</td><td>Rust</td><td>41k</td></tr><tr><td><a href="https://typesense.org/">Typesense</a></td><td>Standalone</td><td>C++</td><td>17k</td></tr><tr><td><a href="https://github.com/sourcegraph/zoekt">Zoekt</a></td><td>Standalone</td><td>Go</td><td>406</td></tr><tr><td><a href="https://www.paradedb.com/">ParadeDB</a></td><td>Postgres extension</td><td>Rust</td><td>3.2k</td></tr><tr><td><a href="https://github.com/valeriansaliou/sonic">Sonic</a></td><td>Standalone</td><td>Rust</td><td>19.4k</td></tr></tbody></table>
<p>There are code-specific tools that exist, but most of them are closed-source: GitHub’s search is excellent, but is obviously the work of a dedicated team with a real time budget.</p>
<ul>
<li>Sourcegraph’s maintained fork of <a href="https://github.com/google/zoekt">Zoekt</a> is pretty cool, but is pretty fearfully niche and would be a big, new infrastructure commitment.</li>
<li><a href="https://github.com/elastic/elasticsearch">Elasticsearch</a> might be the eventual,
unavoidable solution to this problem. It doesn’t have code-specific handling, but can be
customized in nearly infinite ways. We’re not excited to start learning about Java memory
tuning and to introduce the first persistent disk storage to our application, as well as
an additional source of truth for our data. Possibly we could use Elasticsearch
<a href="https://www.elastic.co/cloud">Cloud</a> to avoid the maintenance overhead.</li>
<li><a href="https://github.com/meilisearch/meilisearch">Meilisearch</a> seems like a promising ES alternative with the shininess of ✨Rust✨, but they <a href="https://blog.meilisearch.com/meilisearch-vs-elasticsearch/">seem to emphasize latency over scalability</a>, and we’re not sure if the infrastructure commitment would be any lower.</li>
<li><a href="https://www.paradedb.com/">ParadeDB</a> promises to be like Elasticsearch but “just Postgres,” which is very appealing, but we <a href="https://docs.render.com/postgresql-extensions">can’t use their extension in Render yet</a>.</li>
</ul>
<hr/>
<p>In short, we’re still working on it. Searching code instead of English makes the difficulty level a bit higher. For a small team, with an incentive to keep infrastructure simple, development environments easy to set up, and data in the same place, we’re trying to be careful not to commit to something that requires constant upkeep. There’s a reason why most mid and large-sized companies have a search “team,” not just a search service.</p> <a href="https://github.com/val-town/val-town-blog/edit/main/src/content/blog/search-notes.md" data-astro-cid-npoeh54f=""><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" data-astro-cid-npoeh54f=""><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" data-astro-cid-npoeh54f=""></path></svg>
Edit this page
</a> </div> </article> </div></div>
  </body>
</html>
