<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nesbitt.io/2025/12/26/how-uv-got-so-fast.html">Original</a>
    <h1>How uv got so fast</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>uv installs packages faster than pip by an order of magnitude. The usual explanation is “it’s written in Rust.” That’s true, but it doesn’t explain much. Plenty of tools are written in Rust without being notably fast. The interesting question is what design decisions made the difference.</p>

<p>Charlie Marsh’s <a href="https://www.janestreet.com/tech-talks/uv-an-extremely-fast-python-package-manager/">Jane Street talk</a> and a <a href="https://xebia.com/blog/uv-the-engineering-secrets-behind-pythons-speed-king/">Xebia engineering deep-dive</a> do an excellent job at covering the technical details. Let’s dig into the design decisions that led to it: standards that enable fast paths, things uv drops that pip supports, and optimizations that don’t require Rust at all.</p>

<h2 id="the-standards-that-made-uv-possible">The standards that made uv possible</h2>

<p>pip’s slowness isn’t a failure of implementation. For years, Python packaging required executing code to find out what a package needed.</p>

<p>The problem was <a href="https://setuptools.pypa.io/">setup.py</a>. You couldn’t know a package’s dependencies without running its setup script. But you couldn’t run its setup script without installing its build dependencies. <a href="https://peps.python.org/pep-0518/">PEP 518</a> in 2016 called this out explicitly: “You can’t execute a setup.py file without knowing its dependencies, but currently there is no standard way to know what those dependencies are in an automated fashion without executing the setup.py file.”</p>

<p>This chicken-and-egg problem forced pip to download packages, execute untrusted code, fail, install missing build tools, and try again. Every install was potentially a cascade of subprocess spawns and arbitrary code execution. Installing a source distribution was essentially <code>curl | bash</code> with extra steps.</p>

<p>The fix came in stages:</p>

<ul>
  <li><a href="https://peps.python.org/pep-0518/">PEP 518</a> (2016) created pyproject.toml, giving packages a place to declare build dependencies without code execution. The TOML format was borrowed from Rust’s Cargo, which makes a Rust tool returning to fix Python packaging feel less like coincidence.</li>
  <li><a href="https://peps.python.org/pep-0517/">PEP 517</a> (2017) separated build frontends from backends, so pip didn’t need to understand setuptools internals.</li>
  <li><a href="https://peps.python.org/pep-0621/">PEP 621</a> (2020) standardized the <code>[project]</code> table, so dependencies could be read by parsing TOML rather than running Python.</li>
  <li><a href="https://peps.python.org/pep-0658/">PEP 658</a> (2022) put package metadata directly in the Simple Repository API, so resolvers could fetch dependency information without downloading wheels at all.</li>
</ul>

<p>PEP 658 went live on PyPI in May 2023. uv launched in February 2024. The timing isn’t coincidental. uv could be fast because the ecosystem finally had the infrastructure to support it. A tool like uv couldn’t have shipped in 2020. The standards weren’t there yet.</p>

<p>Other ecosystems figured this out earlier. Cargo has had static metadata from the start. npm’s package.json is declarative. Python’s packaging standards finally bring it to parity.</p>

<h2 id="what-uv-drops">What uv drops</h2>

<p>Speed comes from elimination. Every code path you don’t have is a code path you don’t wait for.</p>

<p>uv’s <a href="https://docs.astral.sh/uv/pip/compatibility/">compatibility documentation</a> is a list of things it doesn’t do:</p>

<p><strong>No .egg support.</strong> Eggs were the pre-wheel binary format. pip still handles them; uv doesn’t even try. The format has been obsolete for over a decade.</p>

<p><strong>No pip.conf.</strong> uv ignores pip’s configuration files entirely. No parsing, no environment variable lookups, no inheritance from system-wide and per-user locations.</p>

<p><strong>No bytecode compilation by default.</strong> pip compiles .py files to .pyc during installation. uv skips this step, shaving time off every install. You can opt in if you want it.</p>

<p><strong>Virtual environments required.</strong> pip lets you install into system Python by default. uv inverts this, refusing to touch system Python without explicit flags. This removes a whole category of permission checks and safety code.</p>

<p><strong>Stricter spec enforcement.</strong> pip accepts malformed packages that technically violate packaging specs. uv rejects them. Less tolerance means less fallback logic.</p>

<p><strong>Ignoring requires-python upper bounds.</strong> When a package says it requires <code>python&lt;4.0</code>, uv ignores the upper bound and only checks the lower. This reduces resolver backtracking dramatically since upper bounds are almost always wrong. Packages declare <code>python&lt;4.0</code> because they haven’t tested on Python 4, not because they’ll actually break. The constraint is defensive, not predictive.</p>

<p><strong>First-index wins by default.</strong> When multiple package indexes are configured, pip checks all of them. uv picks from the first index that has the package, stopping there. This prevents dependency confusion attacks and avoids extra network requests.</p>

<p>Each of these is a code path pip has to execute and uv doesn’t.</p>

<h2 id="optimizations-that-dont-need-rust">Optimizations that don’t need Rust</h2>

<p>Some of uv’s speed comes from Rust. But not as much as you’d think. Several key optimizations could be implemented in pip today:</p>

<p><strong>HTTP range requests for metadata.</strong> <a href="https://packaging.python.org/en/latest/specifications/binary-distribution-format/">Wheel files</a> are zip archives, and zip archives put their file listing at the end. uv tries PEP 658 metadata first, falls back to HTTP range requests for the zip central directory, then full wheel download, then building from source. Each step is slower and riskier. The design makes the fast path cover 99% of cases. This is HTTP protocol work, not Rust.</p>

<p><strong>Parallel downloads.</strong> pip downloads packages one at a time. uv downloads many at once. This is concurrency, not language magic.</p>

<p><strong>Global cache with hardlinks.</strong> pip copies packages into each virtual environment. uv keeps one copy globally and uses <a href="https://en.wikipedia.org/wiki/Hard_link">hardlinks</a> (or copy-on-write on filesystems that support it). Installing the same package into ten venvs takes the same disk space as one. This is filesystem ops, not language-dependent.</p>

<p><strong>Python-free resolution.</strong> pip needs Python running to do anything, and invokes build backends as subprocesses to get metadata from legacy packages. uv parses TOML and wheel metadata natively, only spawning Python when it hits a setup.py-only package that has no other option.</p>

<p><strong>PubGrub resolver.</strong> uv uses the <a href="https://github.com/dart-lang/pub/blob/master/doc/solver.md">PubGrub algorithm</a>, originally from Dart’s pub package manager. pip uses a backtracking resolver. PubGrub is faster at finding solutions and better at explaining failures. It’s an algorithm choice, not a language choice.</p>

<h2 id="where-rust-actually-matters">Where Rust actually matters</h2>

<p>Some optimizations do require Rust:</p>

<p><strong>Zero-copy deserialization.</strong> uv uses <a href="https://rkyv.org/">rkyv</a> to deserialize cached data without copying it. The data format is the in-memory format. This is a Rust-specific technique.</p>

<p><strong>Lock-free concurrent data structures.</strong> Rust’s ownership model makes concurrent access safe without locks. Python’s GIL makes this difficult.</p>

<p><strong>No interpreter startup.</strong> Every time pip spawns a subprocess, it pays Python’s startup cost. uv is a single static binary with no runtime to initialize.</p>

<p><strong>Compact version representation.</strong> uv packs versions into u64 integers where possible, making comparison and hashing fast. Over 90% of versions fit in one u64. This is micro-optimization that compounds across millions of comparisons.</p>

<p>These are real advantages. But they’re smaller than the architectural wins from dropping legacy support and exploiting modern standards.</p>

<h2 id="the-actual-lesson">The actual lesson</h2>

<p>uv is fast because of what it doesn’t do, not because of what language it’s written in. The standards work of PEP 518, 517, 621, and 658 made fast package management possible. Dropping eggs, pip.conf, and permissive parsing made it achievable. Rust makes it a bit faster still.</p>

<p>pip could implement parallel downloads, global caching, and metadata-only resolution tomorrow. It doesn’t, largely because backwards compatibility with fifteen years of edge cases takes precedence. But it means pip will always be slower than a tool that starts fresh with modern assumptions.</p>

<p>The takeaway for other package managers: the things that make uv fast are static metadata, no code execution to discover dependencies, and the ability to resolve everything upfront before downloading. Cargo and npm have operated this way for years. If your ecosystem requires running arbitrary code to find out what a package needs, you’ve already lost.</p>

  </div>

  
</article>

      </div></div>
  </body>
</html>
