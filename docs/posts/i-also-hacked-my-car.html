<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://goncalomb.com/blog/2024/01/30/f57cf19b-how-i-also-hacked-my-car">Original</a>
    <h1>I also hacked my car</h1>
    
    <div id="readability-page-1" class="page"><article><p><abbr title="2024-01-30T22:14:07+00:00: created
">2024-01-30T22:14:07+00:00</abbr> • goncalomb • hacking,car,dacia,rpi</p><p>This blog post is kind of inspired by another that I saw <a rel="noopener" href="https://news.ycombinator.com/item?id=32447650">on HN some time ago</a>, <a rel="noopener" href="https://programmingwithstyle.com/posts/howihackedmycar/">&#34;How I Hacked my Car&#34;</a>. After praising the infotainment system of the car, a Hyundai IONIQ, the author ends up hacking it and running custom software on the head unit.</p>
<p>Well, my much cheaper 2023 Dacia Sandero also has a decent infotainment system with navigation and wireless Android Auto.</p>
<p>Even before I got the car, I searched around to see if the system was hackable. I was not surprised to find that a simple USB drive with an <code>autorun.sh</code> script gets run as root. A classic. Various forums around the web use this method to change skins and side-load navigation maps. I was not interested in that, my goal was also to run some custom software.</p>
<p>Well, there is more to the story, otherwise, I would just that <code>autorun.sh</code> &#34;feature&#34;.</p>
<h3>The Infotainment System</h3>
<p>The system is a MediaNav Evolution from Renault (which Dacia is a subsidiary of), built by LG (FCC ID: <a rel="noopener" href="https://electric.garden/lg-usa-bej/radio-car-lan5900wr">BEJLAN5900WR</a>). It&#39;s a Linux box.</p>
<p>Over the years there have been various iterations of this system, the <a rel="noopener" href="https://menaco.co/medianav-linux-multimedia">older devices</a> used <a rel="noopener" href="https://en.wikipedia.org/wiki/Windows_Embedded_Compact">WinCE</a>.</p>
<p>The navigation part of the software is by a company called <a rel="noopener" href="https://nng.com/">NNG</a> (<a rel="noopener" href="https://nng.com/products/nng-igo">iGO</a>?). Apparently, they provide navigation software for <a rel="noopener" href="https://www.naviextras.com/shop/portal/deviceSelect">many other devices</a>.</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/avn-0.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/avn-0.jpg" alt="MediaNav Evolution (unofficially called MediaNav 4)" title="MediaNav Evolution (unofficially called MediaNav 4)"/></a><figcaption>MediaNav Evolution (unofficially called MediaNav 4)</figcaption></figure>
<h3>The autorun.sh</h3>
<p>Just by looking around on various forums, I knew of 3 special files that when placed on a USB drive would trigger some debug functions:</p>
<ul>
<li>
<code>autorun_bavn/autorun.sh</code>: a script that gets run as root</li>
<li>
<code>logfiles_bavn</code>: a directory that gathers various system logs and files</li>
<li>
<code>usb_logging</code>: a directory where the system continually dumps <a rel="noopener" href="https://github.com/COVESA/dlt-daemon">dlt files</a> (proprietary log system)</li>
</ul>
<p>One good thing about the log files is that they contain the Wi-Fi password for the AP. This password can be reset on the UI, but it&#39;s never visible. Knowing the password allows other devices to connect to it (e.g. PC). <em>When using wireless Android Auto it connects automatically, I think it bootstraps using Bluetooth.</em></p>
<p>I was most interested in the <code>autorun.sh</code>... But it was not working, I couldn&#39;t get the script to run.</p>
<h3>The Firmware</h3>
<p>At this point, I decided to start inspecting the firmware to see what was wrong, and if there was another way in. My device came with version 6.0.9.9.</p>
<p>I wanted a recent update file, but the <a rel="noopener" href="https://dacia.welcome.naviextras.com/">official website</a> doesn&#39;t provide a direct download.</p>
<p>It requires installing a desktop application, &#34;Toolbox&#34;, which I ended up doing. The application can be used to buy map updates or download firmware/OS updates for free.</p>
<p>The procedure starts with collecting some information about the system/car to a USB drive. After connecting it to a PC, the &#34;Toolbox&#34; software detects a new update and puts the new update file on the drive.</p>
<p>I didn&#39;t update it, I just wanted the file, it was version 6.0.10.2:</p>
<pre><code>&gt;: file upgrade.lgu
upgrade.lgu: POSIX tar archive (GNU)
</code></pre>
<p>I also had an older update file, version 6.0.9.7, that I found in some random forum.</p>
<blockquote>
<p>Sometimes even <code>grep</code> can be a great analysis tool. Just by running <code>grep -RF autorun.sh</code> on the contents of both the new and old firmware, I could see that the new one had no matches.</p>
</blockquote>
<p>Time to load Ghidra and see what&#39;s going on...</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/ghidra-autorun.png"><img src="https://goncalomb.com/blog/files/f57cf19b/ghidra-autorun.png" alt="Version 6.0.9.7 has the autorun.sh feature, but it is not present on version 6.0.10.2" title="Version 6.0.9.7 has the autorun.sh feature, but it is not present on version 6.0.10.2"/></a><figcaption>Version 6.0.9.7 has the autorun.sh feature, but it is not present on version 6.0.10.2</figcaption></figure>
<p>Comparing the 2 files it was evident that they had removed the <code>autorun.sh</code> backdoor. Even though I didn&#39;t have the specific firmware for my installed version (6.0.9.9), it was clear that mine didn&#39;t have it and that&#39;s why I could never get it to work.</p>
<p>This <code>miscmanager</code> file is also responsible for the other USB debug features, these are all still there.</p>
<p>The core OS appears to be from <a rel="noopener" href="https://en.wikipedia.org/wiki/COVESA">GENIVI/COVESA</a> (GitHub: <a rel="noopener" href="https://github.com/GENIVI">GENIVI</a>/<a rel="noopener" href="https://github.com/COVESA">COVESA</a>). I&#39;m not familiar with these systems at all. <em>They have a fair bit of open-source stuff that will probably explore in the future.</em></p>
<p>I decompiled other binaries to try to look for some other interesting stuff. Found a lot of D-Bus stuff, that will be useful for getting vehicle information when I can run my own software. But my goal was to get root access first.</p>
<p>One way would be to craft a new update file with a backdoor, which would require reverse engineering the whole upgrade procedure, and as expected the update files do have some signature hashes that presumably need to match.</p>
<p>Getting root access directly would be the preferred way.</p>
<h3>The Android Update App</h3>
<p>Something I noticed on the official website was that they were promoting a <a rel="noopener" href="https://dacia.welcome.naviextras.com/pbmu_en.html">new way to update the maps</a>, using an Android phone app.</p>
<blockquote>
<p>Could this be my way in?</p>
</blockquote>
<p>The <a rel="noopener" href="https://play.google.com/store/apps/details?id=com.nng.pbmu.dacia">description on Google Play</a> promises to &#34;Eliminate the <a rel="noopener" href="https://en.wikipedia.org/wiki/Sneakernet">Sneaker Network</a>&#34;, an expression that I had never heard, in reference to not requiring a USB drive.</p>
<p>Of course I didn&#39;t install it, there is no point in that. I just searched the id <code>com.nng.pbmu.dacia</code> on Google to find one of the many sites that offer the <code>.apk</code> file for download.</p>
<p>I&#39;m not an Android developer, I just know that deep inside there is some bytecode that traces its root back to Java, and I <em>know</em> Java. I don&#39;t care about Dalvik, ART, Zygote, or whatever. Just give me those Java classes.</p>
<p>Over the years I&#39;ve decompiled a few Android apps, my preferred way is just to unpack the <code>.apk</code> as a <code>.zip</code> (that&#39;s all it is), get the <code>.dex</code> bytecode files, run them through <a rel="noopener" href="https://github.com/pxb1988/dex2jar">dex2jar</a> to get some <code>.jar</code> files and open them with good old <a rel="noopener" href="https://java-decompiler.github.io/">JD-GUI</a>. <em>Recently I&#39;ve discovered <a rel="noopener" href="https://github.com/skylot/jadx">jadx</a> which provides a better experience for decompiling apps.</em></p>
<p>To my surprise the app was quite complex, it appears to include some sort of native bindings, and most of the functionality is implemented in some kind of proprietary <code>.xs</code> scripts (similar to JavaScript). These are found on the app&#39;s resources.</p>

<p>It appears that the <code>liblib_nng_sdk.so</code> library is responsible for running these scripts, but I didn&#39;t explore it further. My goal was just to focus on what kind of protocol was used to update the maps on the device.</p>
<p>And I found it in the file <code>nftp.xs</code>.</p>
<h3>NFTP!? Is it standard FTP?</h3>
<p>No, it&#39;s not standard FTP or any other known protocol that I could find. It&#39;s a new binary protocol for transferring files, implemented on these <code>.xs</code> scripts.</p>
<p>The app then uses <a rel="noopener" href="https://source.android.com/docs/core/interaction/accessories/protocol">Android Open Accessory (AOA)</a> as the transport layer for the protocol. AOA was totally new to me, but after some reading, it was clear that it is just a way of establishing a standard for an accessory to talk USB with an Android device.</p>
<blockquote>
<p>The names are confusing, the &#34;accessory&#34; is actually the USB host (in this case, the head unit) and the Android device is the USB peripheral.</p>
</blockquote>
<h3>The Other Side</h3>
<p>The new update file that I had was version 6.0.10.2, which, according to the website, was the version required for the new update app to work. That naturally means that there is some specific service/code on that file to handle the update on the head unit side.</p>
<p>After some digging, I found it. It&#39;s another set of <code>.xs</code> scripts, these run on a native interpreter. There is also a native binary, <code>aoa2sock</code>, that bridges the gap between USB (AOA) and the <code>.xs</code> scripts by providing a pipe for the transfer protocol.</p>
<p>It&#39;s clear that this phone update feature is an afterthought, the binaries/scripts are not part of the standard upgrade filesystem, they are installed separately from a <code>.ipk</code> package file (<code>yellowtool.ipk</code>) when the system is updated. The internal name they use is YellowTool / YellowBox. And this is the only part of the entire system that is coded with these <code>.xs</code> scripts, everything else is just native binaries.</p>

<p>Being plain text scripts, it was relatively easy to understand what the protocol does and what kind of access it provides, even though the coding style is atrocious.</p>
<h3>Constructing The Backdoor</h3>
<p>At this point, just by reading the code, I was pretty sure that it was possible to write arbitrary files under the <code>/navi</code> directory, and that would give me full access if I carefully modified some files.</p>
<p>I just needed to create a fake Android update app and connect using AOA. Well, as I said before, I&#39;m not an Android developer, so I went with the next best thing, the Linux Kernel.</p>
<p>As it turns out I&#39;m also not a kernel developer... But I knew that it has something called gadget mode, where a device running Linux can act as a USB peripheral (instead of a host).</p>
<blockquote>
<p>Could I make a Raspberry Pi act as an Android device in AOA mode?</p>
</blockquote>
<p>Gadget mode can be <a rel="noopener" href="https://docs.kernel.org/usb/gadget_configfs.html">configured from userspace using configfs</a> (just by writing specific <code>/sys/kernel/config/</code> files), this way does not require writing any kernel code, but it&#39;s limited to specific &#34;functions&#34; already implemented in the kernel (e.g. serial port, mass storage, ethernet adapter etc).</p>
<p>Not unsurprisingly, that&#39;s how the guys at Google implemented AOA, they <a rel="noopener" href="https://android.googlesource.com/kernel/common/+/refs/tags/android14-6.1-2023-12_r2/drivers/usb/gadget/function/f_accessory.c">added a new &#34;accessory&#34; function</a> to the kernel. They even tried to <a rel="noopener" href="https://patchwork.kernel.org/project/linux-usb/list/?series=363135&amp;state=%2A&amp;archive=both">push it upstream</a>, but it went nowhere, currently, <a rel="noopener" href="https://github.com/torvalds/linux/tree/v6.6/drivers/usb/gadget/function">it&#39;s not part of the Linux Kernel</a>. I don&#39;t think it will ever be, it&#39;s probably too specific, and it&#39;s kind of a weird protocol.</p>
<p>After reading more about AOA, it was clear that it involved a kind of handshake where the accessory asks the Android device for AOA, and after that, the device just acts like a serial port (a &#34;raw&#34; data pipe), and it&#39;s up to the developer to do the rest (this is a simplification, and there are other modes, <a rel="noopener" href="https://source.android.com/docs/core/interaction/accessories/aoa">read more</a>).</p>
<p>So maybe I could use the <a rel="noopener" href="https://docs.kernel.org/usb/gadget-testing.html#serial-function">serial gadget function</a> to fake an Android device already in accessory mode, without implementing the handshake.</p>
<p>I also found the talk where they first announced AOA, back in 2011. It&#39;s a nice talk if you are into USB stuff:</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/s7szcpXf2rE?rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
<h3>The Testing Setup</h3>
<p>The system is something like this:</p>
<ul>
<li>Android side:
<ul>
<li>Update App / &#34;nftp&#34; (<code>.xs</code> scripts) &lt;=&gt; AOA &lt;=&gt; USB</li>
</ul>
</li>
<li>Head unit side:
<ul>
<li>USB (host) &lt;=&gt; <code>aoa2sock</code> &lt;=&gt; &#34;nftp&#34; (<code>.xs</code> scripts) &lt;=&gt; [reads/writes system files]</li>
</ul>
</li>
</ul>
<p>For testing, I used 2 Raspberry Pies.</p>
<p>Because the head unit is ARM-based as is the Raspberry Pi, I was able to run the <code>aoa2sock</code> binary and <code>.xs</code> interpreter from the firmware, this simulated the head unit and acted like a USB host.</p>
<p>The other RPi was the USB peripheral (using the On-The-Go, OTG port), which when configured correctly using the gadget mode, acted like an Android device in AOA mode.</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/rpis.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/rpis.jpg" alt="The smaller Raspberry Pi Zero 2 W can be powered from the OTG port and will act as the Android device" title="The smaller Raspberry Pi Zero 2 W can be powered from the OTG port and will act as the Android device"/></a><figcaption>The smaller Raspberry Pi Zero 2 W can be powered from the OTG port and will act as the Android device</figcaption></figure>
<p>After messing about with multiple gadget configurations, I was seeing some promising debug messages from <code>aoa2sock</code>, that&#39;s the binary extracted from the firmware that creates a pipe between the USB AOA and the weird &#34;nftp&#34; protocol (<code>.xs</code> scripts), on the head unit side.</p>
<p>But it was not working...</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/aoa-fail.png"><img src="https://goncalomb.com/blog/files/f57cf19b/aoa-fail.png" alt="&amp;quot;No AOA endpoint was found&amp;quot;: My fake head unit was not recognizing my fake Android device" title="&amp;quot;No AOA endpoint was found&amp;quot;: My fake head unit was not recognizing my fake Android device"/></a><figcaption>&#34;No AOA endpoint was found&#34;: My fake head unit was not recognizing my fake Android device</figcaption></figure>
<pre><code>&gt;: file aoa2sock
aoa2sock: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 2.6.32, BuildID[sha1]=XXXXXXXX, with debug_info, not stripped
</code></pre>
<p>After inspecting the <code>aoa2sock</code> binary in Ghidra (thanks for the debug info) and reading the kernel code, I finally found the issue. The kernel serial port gadget uses a different USB subclass from the one used by AOA, and it can&#39;t be changed from userspace.</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/kernel-compare.png"><img src="https://goncalomb.com/blog/files/f57cf19b/kernel-compare.png" alt="Is this a bug? I think AOA is correct in using USB_SUBCLASS_VENDOR_SPEC for a generic interface" title="Is this a bug? I think AOA is correct in using USB_SUBCLASS_VENDOR_SPEC for a generic interface"/></a><figcaption>Is this a bug? I think AOA is correct in using USB_SUBCLASS_VENDOR_SPEC for a generic interface</figcaption></figure>
<h3>OK... Let&#39;s patch the kernel</h3>
<p>I ended up having to download the kernel source and patch the <code>f_serial.c</code> gadget function to change the USB subclass. After compiling the kernel module and loading it using <code>modprobe</code>, it finally worked and the <code>aoa2sock</code> binary recognized the device.</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/aoa-success.png"><img src="https://goncalomb.com/blog/files/f57cf19b/aoa-success.png" alt="My fake Android device was finally connected to my fake head unit" title="My fake Android device was finally connected to my fake head unit"/></a><figcaption>My fake Android device was finally connected to my fake head unit</figcaption></figure>
<blockquote>
<p>Can I call myself a kernel developer now?</p>
</blockquote>
<p>All that was left to do was to somehow recreate that &#34;nftp&#34; protocol. I didn&#39;t really want to use the proprietary <code>.xs</code> files implementation, so I wrote my own in Python.</p>
<p>At this point, I had all the pieces and the Raspberry Pi now replaced the Android app:</p>
<ul>
<li>Raspberry Pi side:
<ul>
<li>Python Script (&#34;nftp&#34; implementation) &lt;=&gt; USB Gadget Mode (emulates AOA)</li>
</ul>
</li>
<li>Head unit side (same as before):
<ul>
<li>USB (host) &lt;=&gt; <code>aoa2sock</code> &lt;=&gt; &#34;nftp&#34; (<code>.xs</code> scripts) &lt;=&gt; [reads/writes system files]</li>
</ul>
</li>
</ul>
<p>Creating the backdoor involved issuing &#34;nftp&#34; commands to edit a specific file under the <code>/navi</code> directory and inject a call to a bash script, this bash script (also uploaded using &#34;nftp&#34;) contains the payload that runs as root.</p>
<h3>H4cking Time</h3>
<p>After much testing with my dual RPi setup, I was confident that it was going to work...</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/avn-1-rpi.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/avn-1-rpi.jpg" alt="Raspberry Pi Zero 2 W (OTG port) connected to the infotainment head unit" title="Raspberry Pi Zero 2 W (OTG port) connected to the infotainment head unit"/></a><figcaption>Raspberry Pi Zero 2 W (OTG port) connected to the infotainment head unit</figcaption></figure>
<p>Setting up for an update...</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/avn-5-update.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/avn-5-update.jpg" alt="Ready to &amp;quot;Update with Phone&amp;quot;, that option is only available after version 6.0.10.2" title="Ready to &amp;quot;Update with Phone&amp;quot;, that option is only available after version 6.0.10.2"/></a><figcaption>Ready to &#34;Update with Phone&#34;, that option is only available after version 6.0.10.2</figcaption></figure>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/avn-6-update.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/avn-6-update.jpg" alt="Waiting for a phone" title="Waiting for a phone"/></a><figcaption>Waiting for a phone</figcaption></figure>
<p>Time to put the RPi in gadget mode (I was connected to it using SSH)...</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/avn-7-update.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/avn-7-update.jpg" alt="Sorry, it&#39;s not a phone and we are not sending any maps" title="Sorry, it&#39;s not a phone and we are not sending any maps"/></a><figcaption>Sorry, it&#39;s not a phone and we are not sending any maps</figcaption></figure>
<p>Sending and running the payload...</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/avn-8-pwned.jpg"><img src="https://goncalomb.com/blog/files/f57cf19b/avn-8-pwned.jpg" alt="Got it!" title="Got it!"/></a><figcaption>Got it!</figcaption></figure>
<p>Success! I had root access.</p>
<blockquote>
<p>That payload is just call to a specific D-Bus method that I found while analyzing the firmware, it shows a popup with custom text and title. The text is the output of the <code>id</code> command.</p>
</blockquote>
<p>Finally, after replacing the payload with something more useful, a simple <code>socat</code> bind shell and connecting back to it using Wi-Fi, I had full access.</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/socat-shell.png"><img src="https://goncalomb.com/blog/files/f57cf19b/socat-shell.png" alt="Give me that root shell" title="Give me that root shell"/></a><figcaption>Give me that root shell</figcaption></figure>
<p>If you didn&#39;t follow it all the way, here&#39;s a summary:</p>
<p>I used a Raspberry Pi in USB gadget mode to simulate an Android device connected to the head unit. The head unit thinks it&#39;s accepting a navigation maps update from the &#34;phone&#34;, but because the update protocol allows for arbitrary file changes, I can issue commands to modify a specific file and inject a call to a bash script that gets run as root.</p>
<h3>Code Please</h3>
<p>Everything is <a rel="noopener" href="https://github.com/goncalomb/mn4-tools/tree/master/mn4-pwned">on GitHub with more detailed instructions</a> (it contains no proprietary code).</p>
<p>The key pieces are <a rel="noopener" href="https://github.com/goncalomb/mn4-tools/blob/master/mn4-pwned/scripts/ctrl-proto.py">my implementation of the &#34;nftp&#34; protocol</a> and <a rel="noopener" href="https://github.com/goncalomb/mn4-tools/blob/master/mn4-pwned/scripts/ctrl-gadget.sh">the gadget configuration</a>.</p>
<h3>What&#39;s Next?</h3>
<p>This is just the beginning, now it&#39;s time to really explore the system.</p>
<p>First, I&#39;ll probably end up restoring the <code>autorun.sh</code> functionality, with a custom service, because I think that&#39;s the easiest way to load software. That way I can keep all the new stuff on the drive and make as few changes to the system as possible.</p>
<p>One of the main things I would like to do is record car parameters, stuff like speed, fuel, location etc. It remains to be seen if I can easily access that information through D-Bus, or if I need to go deeper. I&#39;m not interested in adding anything that requires my attention while driving.</p>
<p>But that&#39;s for another time...</p>
<h3>Some Extras (Could I have used SSH?)</h3>
<p>Two ports are open by default on the head unit, an SSH server, and some Apple service, probably related to CarPlay (<code>Server: AirTunes/320.17.6</code>), I didn&#39;t really explore that.</p>
<p>But I tried cracking the <code>/etc/shadow</code> root password from the update file using <a rel="noopener" href="https://github.com/hashcat/hashcat">hashcat</a> / <a rel="noopener" href="https://github.com/openwall/john">john</a> with some <a rel="noopener" href="https://github.com/NotSoSecure/password_cracking_rules">rules</a> and password <a rel="noopener" href="https://github.com/danielmiessler/SecLists/tree/master/Passwords/Leaked-Databases">lists</a>. I&#39;m not an expert doing this at all, I don&#39;t even know if I was doing it right, and was not successful.</p>
<p>Not that it matters now, I could just change the root password or add a new user.</p>
<figure><a href="https://goncalomb.com/blog/files/f57cf19b/nmap-services.png"><img src="https://goncalomb.com/blog/files/f57cf19b/nmap-services.png" alt="SSH on port 22 / AirTunes/320.17.6 on port 7000" title="SSH on port 22 / AirTunes/320.17.6 on port 7000"/></a><figcaption>SSH on port 22 / AirTunes/320.17.6 on port 7000</figcaption></figure>
</article></div>
  </body>
</html>
