<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/i-formally-modeled-dreidel-for-no-good-reason/">Original</a>
    <h1>Formally modeled Dreidel for no good reason</h1>
    
    <div id="readability-page-1" class="page"><div>
            
    
    
    <div>
        <article>
            <date>
                
                    Dec. 12, 2023, 2:14 p.m.
                </date>
            
            
                <h2>
                    I can mathematically prove the game&#39;s not fun.
                </h2>
            

            

            
                
                    <h3>New blog post</h3>
<p><a href="https://www.hillelwayne.com/post/strangeloop-23/" target="_blank">Notes on Every Strangeloop 2023 Talk I Attended</a>. Would have been out earlier but I was busy and sick. Patreon is <a href="https://www.patreon.com/posts/notes-on-notes-i-94141348" target="_blank">here</a>.</p>
<hr/>
<h2>I formally modeled Dreidel for no good reason</h2>
<p>It&#39;s the sixth night of <a href="https://en.wikipedia.org/wiki/Hanukkah" target="_blank">Channukah</a> and I&#39;m thinking about dreidels:</p>
<p><img alt="A dreidel" src="https://assets.buttondown.email/images/b665a8db-c930-4215-80b1-d8b89661b34f.png?w=960&amp;fit=max"/> </p>
<p>On Channukah we use dreidels to play the game dreidel:</p>
<ol>
<li>Every player starts with N pieces (usually chocolate coins). This is usually 10-15 pieces per player.</li>
<li>At the beginning of the game, and whenever the pot is empty, every play antes one coin into the pot.</li>
<li>
<p>Turns consist of spinning the dreidel. Outcomes are:</p>
<ul>
<li>נ (Nun): nothing happens.</li>
<li>ה (Hey): player takes half the pot, rounded up.</li>
<li>ג (Gimmel): player takes the whole pot, everybody antes.</li>
<li>ש (Shin): player adds one of their coins to the pot.</li>
</ul>
</li>
<li>
<p>If a player ever has zero coins, they are eliminated. Play continues until only one player remains, or (much more likely) everybody gets bored.</p>
</li>
</ol>
<p>Traditionally this game is played by kids, as it&#39;s an excellent way to convince them that gambling is boring as all hell. In 2015 <a href="https://www.slate.com/articles/life/holidays/2014/12/rules_of_dreidel_the_hannukah_game_is_way_too_slow_let_s_speed_it_up.html" target="_blank">Ben Blatt simulated the game</a> and found that for P=4 and N=10, the average game will take 860 spins to finish. </p>
<p>But this was based on a mere 50,000 simulated games! We can do better than a mere simulation. We can mathematically model the game and get <em>exact</em> numbers. So we&#39;re busting out <a href="https://www.prismmodelchecker.org/" target="_blank">PRISM</a>.</p>
<h3>Modeling Dreidel in PRISM</h3>
<p>PRISM is a probabilistic model checker. You create a model of a probabilistic system, like queueing workers or a gambling game, and PRISM can give you exact probabilities of various events happening. I&#39;ve written two blog posts on PRISM:</p>
<ul>
<li><a href="https://www.hillelwayne.com/post/prism/" target="_blank">Probabilistic Modeling with PRISM</a></li>
<li><a href="https://www.hillelwayne.com/post/queueing-prism/" target="_blank">Two workers are quadratically better than one</a></li>
</ul>
<p>If you read those blog posts, you&#39;ll quickly learn that I <em>really do not like PRISM</em>. The problem is that it is <em>incredibly</em> limited language. It doesn&#39;t have strings, or arrays, or <em>functions</em>. This makes generalizing or abstracting things virtually impossible, and you&#39;re going to be hardcoding a lot of stuff. Despite all that, I keep finding excuses to use PRISM anyway. I&#39;ve got an enormous number of small PRISM tricks I will never share with anyone because nobody else will ever use PRISM. Maybe there&#39;s a grad student who needs them, I dunno.</p>
<p>I&#39;m not going to go through the entire model, you can see it <a href="https://gist.github.com/hwayne/f8724f0c83393c576b1e20ee4b76966d" target="_blank">here</a>. Just some highlights:</p>
<div><pre><span></span><code>formula Players = 4; //Players
formula maxval = M*Players;
formula done = (p1=0) | (p2=0) | (p3=0) | (p4=0);
</code></pre></div>

<p>Since I can&#39;t abstract over anything, I can&#39;t make a general model that works for P players, so instead I hardcode in 4 players. Also, properly modeling &#34;playing until one player is left&#34; would have been a <em>nightmare</em>, so instead I&#39;m just modeling until <em>one</em> player is eliminated.</p>
<div><pre><span></span><code>    [spin] ((pot != 0) &amp; !done &amp; (turn = 1)) -&gt;
      0.25: (p1&#39; = p1-1) &amp; (pot&#39; = min(pot+1, maxval)) &amp; (turn&#39; = 2) //shin
    + 0.25: (turn&#39; = 2) //nun
    + 0.25: (p1&#39; = min(p1+halfpot,maxval)) &amp; (pot&#39; = pot-halfpot) &amp; (turn&#39; = 2) // hay
    + 0.25: (p1&#39; = min(p1+pot,maxval)) &amp; (pot&#39; = 0) &amp; (turn&#39; = 2); //gimmel
</code></pre></div>

<p>This is the core of a PRISM spec: a set of conditions for this to happen, a set of weighted outcomes, and the updates for each outcome. Though it&#39;s mathematically impossible for a shin to make the pot have more than <code>maxval</code> coins, whatever model checking algorithm PRISM uses couldn&#39;t tell that, so I had to manually cap it with <code>(pot&#39; = min(pot+1, maxval))</code>. I spent a lot of time on this spec coddling the model checker. </p>
<p>Also notice that I had to hardcode that this is all for <em>player one</em> (<code>p1</code>). This means that I have to write this action three more times:</p>
<div><pre><span></span><code>    [spin] ((pot != 0) &amp; !done &amp; (turn = 2)) -&gt;
      0.25: (p2&#39; = p2-1) &amp; (pot&#39; = min(pot+1, maxval)) &amp; (turn&#39; = 3)
    + 0.25: (turn&#39; = 3)
    // etc etc etc
</code></pre></div>

<p>All of the actions are guarded on <code>pot!=0</code>. When it&#39;s empty, we instead have an ante action:</p>
<div><pre><span></span><code>    [ante] (pot = 0) &amp; !done -&gt; (pot&#39;=pot+4) &amp; (p1&#39; = p1-1) &amp; (p2&#39; = p2-1) &amp; (p3&#39; = p3-1) &amp; (p4&#39; = p4-1);
</code></pre></div>

<p>Since this means not all actions will be spins, I added a <a href="https://www.prismmodelchecker.org/manual/ThePRISMLanguage/CostsAndRewards" target="_blank">reward</a> to track just the spins: </p>
<div><pre><span></span><code>rewards &#34;num_spins&#34;
    [spin] true : 1;
endrewards
</code></pre></div>

<h3>Querying the system</h3>
<p>So why bother with all this when the Python would be like ten lines? The reason is that once you&#39;ve gone through all the work of modeling something in PRISM, you get a powerful querying system to learn properties of the model. First, let&#39;s just find the expected value (weighted average) for the number of spins to knock out one player:</p>
<div><pre><span></span><code>$ ./prism dreidel.prism -const M=10 -pf &#39;R=? [C]&#39;    

Value in the initial state: 63.71149441710945
Time for model checking: 174.563 seconds.
</code></pre></div>

<p>So if we have four players, and each player starts with 10 coins, it&#39;ll take on average 64 spins to knock a single player out. I stopwatched a dreidel and it takes about 8 seconds for a spin, so you&#39;re looking at about nine minutes of watching a top spin before <em>someone</em> gets to leave the table.</p>
<p>Of course that&#39;s only the <em>likeliest</em> outcome. I can also get the cumulative probability like this: </p>
<div><pre><span></span><code>const C0;
P=? [F&lt;=C0 done]
</code></pre></div>

<p>That returns the probability that within C0 steps of starting, <code>done</code> is <strong>F</strong>inally true. Note this is total model checking steps and includes antes too. While I can run this from the command line, it&#39;s nicer to see in the GUI.</p>
<p><img alt="A graph of the gui showing that 90% of the time, you&#39;ll knock out one player within 150 steps" src="https://assets.buttondown.email/images/07a3fc81-e86d-4a4a-bec8-f1f1768f218c.png?w=960&amp;fit=max"/> </p>
<p>Those are still pretty easy to find from a regular simulation, so let&#39;s try a more complex property. What&#39;s the probability that the game ends because a player rolled a Shin, as opposed to an ante?</p>
<div><pre><span></span><code>prism dreidel.prism 
  -pf &#34;P=? [F (pot != 0 &amp; !done &amp; (X done))]&#34; 
  -const M=6:4:10 
  -exportresults stdout

M       Result
6       0.2944666679018678
10      0.2930102532933088
</code></pre></div>

<p>(Don&#39;t forget to check the probability it ends because of an ante!)</p>
<p>What&#39;s the probability that the first player will have 75% of all pieces in the game, and still lose?</p>
<div><pre><span></span><code>-pf &#34;P=? [F (p1=maxval-M &amp; (F p1=0))]&#34;
-const M=5:5:15 
-exportresults stdout
M       Result
6       1.1876357695852015E-10
10      1.0185162507865054E-8
15      4.902270837317093E-8
</code></pre></div>

<p>It&#39;s extraordinarily unlikely but becomes less extraordinarily likely when you start with more coins. And again we&#39;re just modeling until one player runs out of coins, so the odds are slightly (slightly) higher than this. </p>
<p>Finally, the chance the pot maxes out at <code>C0</code> coins:</p>
<div><pre><span></span><code>-pf &#39;P=? [(F pot=C0) &amp; (G pot &lt;= C0)]&#39;
-const M=10,C0=0:1:20
</code></pre></div>

<p><img alt="A graph showing the maximum pot size probability peaks at 6 coins and almost never goes above 9" src="https://assets.buttondown.email/images/a5caff3a-99bd-42b7-b997-50d1cde5e129.png?w=960&amp;fit=max"/> </p>
<h3>Was this worth it?</h3>
<p>Ugh no I hate PRISM</p>
<p>But also I think I figured out a different approach to modeling this that would better handle adding players <em>and</em> running until just one player is left. Maybe that&#39;ll be a blog post for next Channukah!</p>
<hr/>
<h3>End of Year Administrative Stuff</h3>
<p>Next week will be the last newsletter of the year. Quick updates on this year&#39;s projects:</p>
<ul>
<li><em>Logic for Programmers</em>: Haven&#39;t made any progress on it for a while, but a friend has kindly offered to help edit and keep me to a schedule, so I&#39;m more optimistic for the next year.</li>
</ul>
<ul>
<li><em>Why programming languages doesn&#39;t have graph types</em>: Done with interviews, writing an outline!</li>
</ul>
<p>I want to write a new formal methods talk for next year, which would focus on the general history and idea of formal specification instead of just pitching TLA+ as a product. If you know any conference people who&#39;d be interested, put me in touch!</p>
                
            

            
                <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.email/hillelwayne" target="_blank">here</a>. Updates are 6x a month. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
            

            

            <div>
                <p>
                    Don&#39;t miss what&#39;s next. Subscribe to Computer Things:
                </p>
                 








            </div>
        </article>
    </div>

    

    

        </div></div>
  </body>
</html>
