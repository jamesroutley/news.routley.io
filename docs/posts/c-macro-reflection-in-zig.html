<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jstrieb.github.io/posts/c-reflection-zig/">Original</a>
    <h1>C Macro Reflection in Zig</h1>
    
    <div id="readability-page-1" class="page">




<p>By <a href="https://jstrieb.github.io">Jacob Strieb</a>.</p>
<p>Published on <a href="https://elijer.github.io/posts/c-reflection-zig/">July 30, 2024</a>.</p>
<hr/>

<p><a href="https://ziglang.org/learn/overview/">Zig</a> is a nascent programming language with an emphasis on low-level and systems programming that is positioned to be a C replacement.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> Despite being under active development (and having some rough edges as a result), Zig is extremely powerful, and is already used by a few substantial projects such as <a href="https://github.com/oven-sh/bun">Bun</a> and <a href="https://github.com/tigerbeetle/tigerbeetle">TigerBeetle</a>.</p>
<p>Zig has many interesting features, but its outstanding interoperability (“interop”) with C is especially impressive. It is easy to call an external library, as in this example from <a href="https://ziglang.org/learn/samples/">the Zig website</a>:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>const</span> win <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>)<span>.</span>os<span>.</span>windows;</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span>extern</span> <span>&#34;user32&#34;</span> <span>fn</span> MessageBoxA(</span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span>?</span>win<span>.</span>HWND<span>,</span> </span>
<span id="cb1-5"><a href="#cb1-5"></a>  [<span>*:</span><span>0</span>]<span>const</span> <span>u8</span><span>,</span> </span>
<span id="cb1-6"><a href="#cb1-6"></a>  [<span>*:</span><span>0</span>]<span>const</span> <span>u8</span><span>,</span> </span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span>u32</span><span>,</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>) <span>callconv</span>(win<span>.</span>WINAPI) <span>i32</span>;</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {</span>
<span id="cb1-11"><a href="#cb1-11"></a>    _ <span>=</span> MessageBoxA(<span>null</span><span>,</span> <span>&#34;world!&#34;</span><span>,</span> <span>&#34;Hello&#34;</span><span>,</span> <span>0</span>);</span>
<span id="cb1-12"><a href="#cb1-12"></a>}</span></code></pre></div>
<p>Calling external functions from C libraries is convenient, but lots of languages can do that. What is more impressive is that, in Zig, it is trivial to import C header files and use them as if they were regular Zig imports. We can rewrite the above to use the Windows header files, instead of manually forward-declaring <code>extern</code> functions:<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a><span>const</span> win32 <span>=</span> <span>@cImport</span>({</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span>@cInclude</span>(<span>&#34;windows.h&#34;</span>);</span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span>@cInclude</span>(<span>&#34;winuser.h&#34;</span>);</span>
<span id="cb2-4"><a href="#cb2-4"></a>});</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {</span>
<span id="cb2-7"><a href="#cb2-7"></a>    _ <span>=</span> win32<span>.</span>MessageBoxA(<span>null</span><span>,</span> <span>&#34;world!&#34;</span><span>,</span> <span>&#34;Hello&#34;</span><span>,</span> <span>0</span>);</span>
<span id="cb2-8"><a href="#cb2-8"></a>}</span></code></pre></div>
<p>The following command will compile both of the code examples above for Windows from any host operating system:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1"></a><span># Using Zig 0.13.0</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span>zig</span> build-exe -lc -target x86_64-windows-gnu main.zig</span></code></pre></div>
<p>I continue to be astounded and delighted that that this code can both be written and cross-compiled so easily on any system.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>

<p>I have done my fair share of C programming, but until recently, I had never written a Win32 application,<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> nor had I ever written a program in Zig.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>A typical Windows application has a <code>main</code> (or <code>wWinMain</code>) function and a “window procedure” (<code>WindowProc</code>) function. The main function initializes the application, and runs the loop in which messages are dispatched to the window procedure. The window procedure receives and handles the messages, typically taking a different action for each message type. To quote <a href="https://learn.microsoft.com/en-us/windows/win32/learnwin32/window-messages">the Microsoft website</a>:</p>
<blockquote>
<p>Windows uses a message-passing model. The operating system communicates with your application window by passing messages to it. A message is simply a numeric code that designates a particular event. For example, if the user presses the left mouse button, the window receives a message that has the following message code.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a><span>#define WM_LBUTTONDOWN 0x0201</span></span></code></pre></div>
<p>Some messages have data associated with them. For example, the <code>WM_LBUTTONDOWN</code> message includes the x-coordinate and y-coordinate of the mouse cursor.</p>
</blockquote>
<p>In practice, the window procedure becomes an enormous <code>switch</code> statement that matches the message code (<code>uMsg</code> in the example below) against macros defined in <code>winuser.h</code>. A minimal Zig example of a Win32 application with the standard structure (abridged from <a href="https://learn.microsoft.com/en-us/windows/win32/learnwin32/your-first-windows-program">the Microsoft Win32 tutorial sequence</a>) is as follows:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a><span>const</span> std <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);</span>
<span id="cb5-2"><a href="#cb5-2"></a><span>const</span> windows <span>=</span> std<span>.</span>os<span>.</span>windows;</span>
<span id="cb5-3"><a href="#cb5-3"></a><span>const</span> win32 <span>=</span> <span>@cImport</span>({</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span>@cInclude</span>(<span>&#34;windows.h&#34;</span>);</span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span>@cInclude</span>(<span>&#34;winuser.h&#34;</span>);</span>
<span id="cb5-6"><a href="#cb5-6"></a>});</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span>var</span> stdout<span>:</span> std<span>.</span>fs<span>.</span>File<span>.</span>Writer <span>=</span> <span>undefined</span>;</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span>pub</span> <span>export</span> <span>fn</span> WindowProc(hwnd<span>:</span> win32<span>.</span>HWND<span>,</span> uMsg<span>:</span> <span>c_uint</span><span>,</span> wParam<span>:</span> win32<span>.</span>WPARAM<span>,</span> lParam<span>:</span> win32<span>.</span>LPARAM) <span>callconv</span>(windows<span>.</span>WINAPI) win32<span>.</span>LRESULT {</span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span>// Handle each type of window message we care about</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>    _ <span>=</span> <span>switch</span> (uMsg) {</span>
<span id="cb5-13"><a href="#cb5-13"></a>        win32<span>.</span>WM_CLOSE <span>=&gt;</span> win32<span>.</span>DestroyWindow(hwnd)<span>,</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>        win32<span>.</span>WM_DESTROY <span>=&gt;</span> win32<span>.</span>PostQuitMessage(<span>0</span>),</span>
<span id="cb5-15"><a href="#cb5-15"></a>        <span>else</span> <span>=&gt;</span> {</span>
<span id="cb5-16"><a href="#cb5-16"></a>            stdout<span>.</span>print(<span>&#34;Unknown window message: 0x{x:0&gt;4}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span>{uMsg}) <span>catch</span> <span>undefined</span>;</span>
<span id="cb5-17"><a href="#cb5-17"></a>        }<span>,</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    };</span>
<span id="cb5-19"><a href="#cb5-19"></a>    <span>return</span> win32<span>.</span>DefWindowProcA(hwnd<span>,</span> uMsg<span>,</span> wParam<span>,</span> lParam);</span>
<span id="cb5-20"><a href="#cb5-20"></a>}</span>
<span id="cb5-21"><a href="#cb5-21"></a></span>
<span id="cb5-22"><a href="#cb5-22"></a><span>pub</span> <span>export</span> <span>fn</span> main(hInstance<span>:</span> win32<span>.</span>HINSTANCE) <span>c_int</span> {</span>
<span id="cb5-23"><a href="#cb5-23"></a>    stdout <span>=</span> std<span>.</span>io<span>.</span>getStdOut()<span>.</span>writer();</span>
<span id="cb5-24"><a href="#cb5-24"></a></span>
<span id="cb5-25"><a href="#cb5-25"></a>    <span>// Windows boilerplate to set up and draw a window</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>    <span>var</span> class <span>=</span> std<span>.</span>mem<span>.</span>zeroes(win32<span>.</span>WNDCLASSEXA);</span>
<span id="cb5-27"><a href="#cb5-27"></a>    class<span>.</span>cbSize <span>=</span> <span>@sizeOf</span>(win32<span>.</span>WNDCLASSEXA);</span>
<span id="cb5-28"><a href="#cb5-28"></a>    class<span>.</span>style <span>=</span> win32<span>.</span>CS_VREDRAW <span>|</span> win32<span>.</span>CS_HREDRAW;</span>
<span id="cb5-29"><a href="#cb5-29"></a>    class<span>.</span>hInstance <span>=</span> hInstance;</span>
<span id="cb5-30"><a href="#cb5-30"></a>    class<span>.</span>lpszClassName <span>=</span> <span>&#34;Class&#34;</span>;</span>
<span id="cb5-31"><a href="#cb5-31"></a>    class<span>.</span>lpfnWndProc <span>=</span> WindowProc; <span>// Handle messages with this function</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>    _ <span>=</span> win32<span>.</span>RegisterClassExA(<span>&amp;</span>class);</span>
<span id="cb5-33"><a href="#cb5-33"></a></span>
<span id="cb5-34"><a href="#cb5-34"></a>    <span>const</span> hwnd <span>=</span> win32<span>.</span>CreateWindowExA(win32<span>.</span>WS_EX_CLIENTEDGE<span>,</span> <span>&#34;Class&#34;</span><span>,</span> <span>&#34;Window&#34;</span><span>,</span> win32<span>.</span>WS_OVERLAPPEDWINDOW<span>,</span> win32<span>.</span>CW_USEDEFAULT<span>,</span> win32<span>.</span>CW_USEDEFAULT<span>,</span> win32<span>.</span>CW_USEDEFAULT<span>,</span> win32<span>.</span>CW_USEDEFAULT<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> hInstance<span>,</span> <span>null</span>);</span>
<span id="cb5-35"><a href="#cb5-35"></a>    _ <span>=</span> win32<span>.</span>ShowWindow(hwnd<span>,</span> win32<span>.</span>SW_NORMAL);</span>
<span id="cb5-36"><a href="#cb5-36"></a>    _ <span>=</span> win32<span>.</span>UpdateWindow(hwnd);</span>
<span id="cb5-37"><a href="#cb5-37"></a></span>
<span id="cb5-38"><a href="#cb5-38"></a>    <span>// Dispatch messages to WindowProc</span></span>
<span id="cb5-39"><a href="#cb5-39"></a>    <span>var</span> message<span>:</span> win32<span>.</span>MSG <span>=</span> std<span>.</span>mem<span>.</span>zeroes(win32<span>.</span>MSG);</span>
<span id="cb5-40"><a href="#cb5-40"></a>    <span>while</span> (win32<span>.</span>GetMessageA(<span>&amp;</span>message<span>,</span> <span>null</span><span>,</span> <span>0</span>, <span>0</span>) <span>&gt;</span> <span>0</span>) {</span>
<span id="cb5-41"><a href="#cb5-41"></a>        _ <span>=</span> win32<span>.</span>TranslateMessage(<span>&amp;</span>message);</span>
<span id="cb5-42"><a href="#cb5-42"></a>        _ <span>=</span> win32<span>.</span>DispatchMessageA(<span>&amp;</span>message);</span>
<span id="cb5-43"><a href="#cb5-43"></a>    }</span>
<span id="cb5-44"><a href="#cb5-44"></a></span>
<span id="cb5-45"><a href="#cb5-45"></a>    <span>return</span> <span>0</span>;</span>
<span id="cb5-46"><a href="#cb5-46"></a>}</span></code></pre></div>
<p>The output of the code above looks like the following when it is run:</p>
<pre><code>Unknown window message: 0x0024
Unknown window message: 0x0081
Unknown window message: 0x0083
Unknown window message: 0x0001
...
Unknown window message: 0x0008
Unknown window message: 0x0281
Unknown window message: 0x0282
Unknown window message: 0x0082</code></pre>

<p>When extending the Windows code above to handle new message types, it is troublesome to determine which C macro corresponds to each message the window procedure receives. The numeric value of each message code is printed to the standard output, but mapping the numeric values back to C macro names involves either searching through documentation, or manually walking the header <code>#include</code> tree to find the right macro declaration.</p>
<p>The underlying cause of difficulty in mapping macro values back to macro names is that C does not have <a href="https://en.wikipedia.org/wiki/Reflective_programming">reflection</a> for preprocessor macros – there is no way to get a list of all defined macros, let alone all macros with a specific value, from within C code. The preprocessor runs before the code is actually compiled, so the compiler itself is unaware of macros.<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a> The separation between the preprocessor and the compiler enables the user to <a href="https://github.com/DosX-dev/obfus.h">make advanced changes to the code at compile time</a>, but in practice, that separation means compiled code cannot introspect macros.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>Though it may not be obvious from the code above, in Zig, references to macro and non-macro declarations from imported C header files are made in the same way. For example, <code>win32.TranslateMessage</code> is a function declared in the header file, and <code>win32.WM_CLOSE</code> is a macro declared using <code>#define</code>. Both are used in Zig by doing <code>imported_name.declared_value</code>. The Zig <code>@import</code> function returns a <code>struct</code>, so regular declarations and macros, alike, are represented as fields in the struct generated from importing the C header files.</p>
<p>It is significant that declarations are represented in imports as struct fields because, unlike C, Zig <em>does</em> have reflection. In particular, the <a href="https://ziglang.org/documentation/0.13.0/#typeInfo"><code>@typeInfo</code></a> function lists the fields and declarations of structs passed to it. This means that, though we cannot introspect C macros within C, we can introspect C macros within Zig. Consequently, we can create a mapping of macro values to macro names:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1"></a><span>const</span> window_messages <span>=</span> get_window_messages();</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span>// The WM_* macros have values less than 65536, so an array of that size can</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span>// represent all of them</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span>fn</span> get_window_messages() [<span>65536</span>][:<span>0</span>]<span>const</span> <span>u8</span> {</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span>var</span> result<span>:</span> [<span>65536</span>][:<span>0</span>]<span>const</span> <span>u8</span> <span>=</span> <span>undefined</span>;</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span>@setEvalBranchQuota</span>(<span>1000000</span>);</span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span>// Loop over all struct fields and match against the expected prefix</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span>for</span> (<span>@typeInfo</span>(win32)<span>.</span>Struct<span>.</span>decls) <span>|</span>field<span>|</span> {</span>
<span id="cb7-10"><a href="#cb7-10"></a>        <span>if</span> (field<span>.</span>name<span>.</span>len <span>&gt;=</span> <span>3</span> <span>and</span> std<span>.</span>mem<span>.</span>eql(<span>u8</span><span>,</span> field<span>.</span>name[<span>0</span><span>..</span><span>3</span>], &#34;<span>WM_</span><span>&#34;)) {</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>            <span>const</span> value <span>=</span> <span>@field</span>(win32<span>,</span> field<span>.</span>name);</span>
<span id="cb7-12"><a href="#cb7-12"></a>            result[value] <span>=</span> field<span>.</span>name;</span>
<span id="cb7-13"><a href="#cb7-13"></a>        }</span>
<span id="cb7-14"><a href="#cb7-14"></a>    }</span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span>// We return by value here, not by reference, so this is safe to do</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>    <span>return</span> result;</span>
<span id="cb7-17"><a href="#cb7-17"></a>}</span></code></pre></div>
<p>Using the global constant <code>window_messages</code>, we can change our <code>WindowProc</code> function to print more helpful information about the messages it is receiving:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1"></a><span>pub</span> <span>export</span> <span>fn</span> WindowProc(hwnd<span>:</span> win32<span>.</span>HWND<span>,</span> uMsg<span>:</span> <span>c_uint</span><span>,</span> wParam<span>:</span> win32<span>.</span>WPARAM<span>,</span> lParam<span>:</span> win32<span>.</span>LPARAM) <span>callconv</span>(windows<span>.</span>WINAPI) win32<span>.</span>LRESULT {</span>
<span id="cb8-2"><a href="#cb8-2"></a>    _ <span>=</span> <span>switch</span> (uMsg) {</span>
<span id="cb8-3"><a href="#cb8-3"></a>        win32<span>.</span>WM_CLOSE <span>=&gt;</span> win32<span>.</span>DestroyWindow(hwnd)<span>,</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>        win32<span>.</span>WM_DESTROY <span>=&gt;</span> win32<span>.</span>PostQuitMessage(<span>0</span>),</span>
<span id="cb8-5"><a href="#cb8-5"></a>        <span>else</span> <span>=&gt;</span> {</span>
<span id="cb8-6"><a href="#cb8-6"></a>            <span>// New: print the macro for the current window message</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>            stdout<span>.</span>print(</span>
<span id="cb8-8"><a href="#cb8-8"></a>                <span>&#34;{s}: 0x{x:0&gt;4}</span><span>\n</span><span>&#34;</span><span>,</span> </span>
<span id="cb8-9"><a href="#cb8-9"></a>                <span>.</span>{ window_messages[uMsg]<span>,</span> uMsg }<span>,</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>            ) <span>catch</span> <span>undefined</span>;</span>
<span id="cb8-11"><a href="#cb8-11"></a>        }<span>,</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>    };</span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span>return</span> win32<span>.</span>DefWindowProcA(hwnd<span>,</span> uMsg<span>,</span> wParam<span>,</span> lParam);</span>
<span id="cb8-14"><a href="#cb8-14"></a>}</span></code></pre></div>
<p>Now, the output of the program looks much nicer when run:</p>
<pre><code>...
WM_NCHITTEST: 0x0084
WM_SETCURSOR: 0x0020
WM_MOUSEMOVE: 0x0200
WM_SYSKEYDOWN: 0x0104
WM_CHAR: 0x0102
WM_KEYUP: 0x0101
WM_SYSKEYUP: 0x0105
WM_WINDOWPOSCHANGING: 0x0046
WM_WINDOWPOSCHANGED: 0x0047
WM_NCACTIVATE: 0x0086
WM_ACTIVATE: 0x0006
WM_ACTIVATEAPP: 0x001c
WM_KILLFOCUS: 0x0008
WM_IME_SETCONTEXT: 0x0281
WM_NCDESTROY: 0x0082</code></pre>

<p>Though this example is small, it illustrates that Zig can do what C does, but can do so more ergonomically by employing modern programming language constructs. One of Zig’s unique superpowers is that it bundles a C compiler toolchain – that is what enables it to transcend C <abbr title="Foreign Function Interface">FFI</abbr> and seamlessly include declarations from C header files, among other capabilities.</p>
<p>Incorporating C interoperability so deeply into the language highlights Zig’s prudent acknowledgment that C has been around for a long time, and is here to stay for a while longer. Integrating with C in this way means that Zig developers have had access to thousands of existing, battle-tested software libraries since the language’s first release. It also gives developers responsible for existing C or C++ codebases a path to transition them to Zig. Availability of high-quality libraries and transition paths for existing code are both critical obstacles to language adoption that Zig has cleverly bypassed by electing to subsume C in the course of replacing it.</p>
<p>Zig’s philosophy of pragmatism is apparent as soon as you begin learning the language. Within a few hours of getting started, I was able to come up with this C macro reflection trick, and also able to be generally productive. That is, to me, clear evidence of Zig’s intuitive, consistent design.<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>Zig’s straightforward cross-compilation and C integration are what drew me to the language, but its philosophy and design are what will keep me here to stay.</p>

<p>Thanks to <a href="https://github.com/lsnow99">Logan Snow</a> and <a href="https://www.linkedin.com/in/amyjl/">Amy Liu</a> for reviewing a draft of this post.</p>
<p>Shout out to <a href="https://andrewkelley.me/">Andrew Kelley</a> and the other Zig contributors.</p>




</div>
  </body>
</html>
