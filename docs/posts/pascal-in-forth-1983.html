<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://tangentstorm.github.io/winfield-pascal-83.html">Original</a>
    <h1>Pascal in Forth (1983)</h1>
    
    <div id="readability-page-1" class="page"><div id="text-1-6">
<p>
The total program splits very conveniently into two parts; the arithmetic expression compiler, and the statement compiler, so I shall describe the former here and the later in the <i>second part of this article</i>. Although I am at risk of re-inventing some wheels here (see the <i>second reference</i>!) it does turn out that the expression compiler is useful in its own right as an infix arithmetic compiler/interpreter, as I will show later.
</p>

<p>
First, however, we must establish the basic routines for parsing the input stream and identifying Pascal reserved words. Given the design constraints outlined earlier, we can see that a Pascal program will contain five basic word types:
</p>

<ul>
<li>Pascal reserved words
</li>
<li>Numbers
</li>
<li>References to Forth variables
</li>
<li>References to Forth constants
</li>
<li>Other words to be treated as Forth functions or procedures.
</li>
</ul>

<p>
What we require is a basic routine to &#39;fetch the next thing from the input stream&#39; and classify it as one of these five basic types.
</p>

<p>
Since the final three types (variable, constant, or function) will all be words in the dictionary when the Pascal program is compiled, it is clear that a dictionary search wil lbe needed somewhere in this routine. Why not, therefore, create a special vocabulary containing the Pascal reseverd words and let the Forth dictionary search word <code>FIND</code> do all the work for us?
</p>

<p>
When <code>FIND</code> is executed it will fetch the next word from the input stream (delimited by <code>space</code>), and search the <code>CONTEXT</code> vocabulary for a matching word. If successful it returns the (unique) address of the dictionary entry for that word, or the value zero if not. (This is the Code Field Address or CFA). All that we need to do in our basic parsing routine (which I call <code>next</code>), is to arrange that the Pascal reserved word vocabulary is <code>CONTEXT</code> when <code>FIND</code> is executed. This will ensure that it is searched before the rest of the Forth dictionary, avoiding any conflict between similar Pascal and Forth words. We can then use the CFA to classify the word into one of the five types above.
</p>

<p>
All of this happens in <i>blocks 2001-2006</i>, listed at the end of this article. The pascal reserved words are a set of empty definitions in the vocabulary <code>pascal-words</code>, in block 2001. The classification of reserved words is achieved by attempting to match the CFA returned by <code>FIND</code> with one of the entries in a special table containing the reserved words CFAs (<code>cfa-table</code>, <a href="#sec-1-7-4">1.7.4</a>), thena  value from 1 to 40 is returned, corresponding to the position of the reserved word in <code>cfa-table</code>. If no match is found then <code>next</code> (blocks <i>2005</i> and <i>2006</i>) compares the CFA with <code>vcode</code> and <code>ccode</code>, the CFAs for variable and constant, respectively. No further matching is necessary, since if all of these tests fail the word must have been either a number, or a Forth function or procedure call, and a value of zero returned by <code>FIND</code> will, of course, indicate a number (or a syntax error!)
</p>

<p>
The final result of <code>next</code> is returned in the variable <code>type</code>; values 1-40 indicate Pascal reserved words, -2 constants, -1 variables, 0 numbers, or any other value for references to Forth words (defined by colon definitions). Thus, after loading blocks 2001-2006 into a Forth system, we may test these by typing:
</p>

<div>

<pre>next +      type ? 1  ok     (Pascal &#39;+&#39;)
next begin  type ? 20 ok     (and &#39;begin&#39;)
next 27     type ? 0  ok     (a number)
VARIABLE fred
1 CONSTANT true
next fred   type ? -1 ok     (a variable)
next true   type ? -2 ok     (a constant)
next .R     type L 12524 ok  (the CFA of .R)
</pre>
</div>

<p>
Although it may come as a surprise, the development of the word <code>next</code> was one of the most difficult problems of this entire application. Everything else falls into place with remarkable ease!
</p>
</div></div>
  </body>
</html>
