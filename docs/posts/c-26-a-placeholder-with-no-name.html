<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sandordargo.com/blog/2025/01/08/cpp26-unnamed-placeholders">Original</a>
    <h1>C&#43;&#43;26: A Placeholder with No Name</h1>
    
    <div id="readability-page-1" class="page"><div><p>Let’s continue exploring C++26. In this post, we are going to discuss a core language feature proposed by Corentin Jabot and Micheal Park in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf">P2169R4</a>. With the new standard we get a cool unnamed placeholder.</p><h2 id="motivations">Motivations</h2><p>By convention, when we have a variable whose value we don’t want to use or care about, we often name it <code>_</code>. The problem is that with higher warning levels (<code>-Wunused-variable</code>), our compilation might fail because <code>_</code> is unused.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>int</span> <span>foo</span><span>()</span> <span>{</span>
<span>return</span> <span>42</span><span>;</span>
<span>}</span>

<span>auto</span> <span>_</span> <span>=</span> <span>foo</span><span>();</span>
<span>/*
error: unused variable &#39;_&#39; [-Werror,-Wunused-variable]
*/</span>
</pre></td></tr></tbody></table></code></p></div><p>To avoid this problem, we must mark it <code>[[maybe_unused]]</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>int</span> <span>foo</span><span>()</span> <span>{</span>
<span>return</span> <span>42</span><span>;</span>
<span>}</span>

<span>[[</span><span>maybe_unused</span><span>]]</span> <span>auto</span> <span>_</span> <span>=</span> <span>foo</span><span>();</span> <span>// OK now</span>
</pre></td></tr></tbody></table></code></p></div><p>But what if we want to ignore several of them?</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>int</span> <span>foo</span><span>()</span> <span>{</span> <span>return</span> <span>42</span><span>;</span> <span>}</span>
<span>char</span> <span>bar</span><span>()</span> <span>{</span> <span>return</span> <span>&#39;c&#39;</span><span>;</span> <span>}</span>

<span>[[</span><span>maybe_unused</span><span>]]</span> <span>auto</span> <span>_</span> <span>=</span> <span>foo</span><span>();</span>
<span>[[</span><span>maybe_unused</span><span>]]</span> <span>auto</span> <span>_</span> <span>=</span> <span>bar</span><span>();</span>
</pre></td></tr></tbody></table></code></p></div><p>In this case, even <code>[[maybe_unused]]</code> doesn’t help because <code>_</code> is just a normal variable and is introduced twice. We can use <code>std::ignore</code>!</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>#include</span> <span>&lt;utility&gt;</span><span>
</span><span>int</span> <span>foo</span><span>()</span> <span>{</span> <span>return</span> <span>42</span><span>;</span> <span>}</span>
<span>char</span> <span>bar</span><span>()</span> <span>{</span> <span>return</span> <span>&#39;c&#39;</span><span>;</span> <span>}</span>

<span>std</span><span>::</span><span>ignore</span> <span>=</span> <span>foo</span><span>();</span>
<span>std</span><span>::</span><span>ignore</span> <span>=</span> <span>bar</span><span>();</span>
</pre></td></tr></tbody></table></code></p></div><p>But even this solution won’t work all the time. We cannot use it with structured bindings, which are probably the most often used place where <code>_</code> is used as variable names. And if you want to use <code>_</code> with various structured bindings in the same (nested) scope, you have to look for other solutions.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>int</span><span>,</span> <span>std</span><span>::</span><span>tuple</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>,</span> <span>std</span><span>::</span><span>string</span><span>,</span> <span>std</span><span>::</span><span>string</span><span>&gt;&gt;</span> <span>m</span><span>{</span>
        <span>{</span><span>1</span><span>,</span> <span>{</span><span>&#34;one&#34;</span><span>,</span> <span>&#34;I&#34;</span><span>,</span> <span>&#34;foo&#34;</span><span>}},</span> <span>{</span><span>2</span><span>,</span> <span>{</span><span>&#34;two&#34;</span><span>,</span> <span>&#34;II&#34;</span><span>,</span> <span>&#34;bar&#34;</span><span>}},</span> <span>{</span><span>3</span><span>,</span> <span>{</span><span>&#34;three&#34;</span><span>,</span> <span>&#34;III&#34;</span><span>,</span> <span>&#34;baz&#34;</span><span>}}};</span>

<span>for</span><span>(</span><span>const</span> <span>auto</span><span>&amp;</span> <span>[</span><span>_</span><span>,</span> <span>v</span><span>]</span><span>:</span> <span>m</span><span>)</span> <span>{</span>
    <span>const</span> <span>auto</span><span>&amp;</span> <span>[</span><span>e</span><span>,</span> <span>r</span><span>,</span> <span>_</span><span>]</span> <span>=</span> <span>v</span><span>;</span> <span>// ERROR:  error: redefinition of &#39;_&#39;!</span>
    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>e</span> <span>&lt;&lt;</span> <span>&#34; in Roman format &#34;</span> <span>&lt;&lt;</span> <span>r</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>The above piece of code will not compile, because we try to redefine <code>_</code>! In some cases, we can easily remove one of the ignored variables with the help of ranges!</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>#include</span> <span>&lt;ranges&gt;</span><span>
</span>
<span>std</span><span>::</span><span>map</span><span>&lt;</span><span>int</span><span>,</span> <span>std</span><span>::</span><span>tuple</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>,</span> <span>std</span><span>::</span><span>string</span><span>,</span> <span>std</span><span>::</span><span>string</span><span>&gt;&gt;</span> <span>m</span><span>{</span>
        <span>{</span><span>1</span><span>,</span> <span>{</span><span>&#34;one&#34;</span><span>,</span> <span>&#34;I&#34;</span><span>,</span> <span>&#34;foo&#34;</span><span>}},</span> <span>{</span><span>2</span><span>,</span> <span>{</span><span>&#34;two&#34;</span><span>,</span> <span>&#34;II&#34;</span><span>,</span> <span>&#34;bar&#34;</span><span>}},</span> <span>{</span><span>3</span><span>,</span> <span>{</span><span>&#34;three&#34;</span><span>,</span> <span>&#34;III&#34;</span><span>,</span> <span>&#34;baz&#34;</span><span>}}};</span>

<span>for</span><span>(</span><span>const</span> <span>auto</span><span>&amp;</span> <span>v</span><span>:</span> <span>m</span> <span>|</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>values</span><span>)</span> <span>{</span>
    <span>const</span> <span>auto</span><span>&amp;</span> <span>[</span><span>e</span><span>,</span> <span>r</span><span>,</span> <span>_</span><span>]</span> <span>=</span> <span>v</span><span>;</span>
    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>e</span> <span>&lt;&lt;</span> <span>&#34; in Roman format &#34;</span> <span>&lt;&lt;</span> <span>r</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>But this won’t be possible all the time.</p><p>In addition, there are some variables such as locks and <code>scope_guard</code>s that are only used for their side effects. We don’t want to store them in (not-so-)nicely named variables.</p><h2 id="the-new-solution">The new solution</h2><p>The solution that is brought to us with the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf">P2169R4</a> is simple. We can use <code>_</code> as a placeholder in the same scope as many times as we want.</p><p>This solution is also similar to other languages’ features or conventions and it’s not unfamiliar at all from existing C++ practices. It already carries the meaning of <em>“I don’t want to use this variable”</em>.</p><p>In more - but not too - technical terms, if we introduce <code>_</code> as a variable, a non-static class member, a lambda capture or in a structured binding, it will implicitly get the <code>[[maybe_unused]]</code> attribute. In addition, we can also redeclare it as many times as we want it.</p><p>On the other hand, if we try to use <code>_</code> in any expression, the program is ill-formed!</p><p>The new placeholder has certain <em>limits</em>, it cannot be used in template parameter lists or in requires clauses. For more details on the <em>why</em>s, refer to the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf">accepted proposal</a></p><p>The authors also investigated the effects on existing code. The library that might come into most of our minds is <em>GMock</em>, where <code>_</code> is used to match any input passed to a function. There is little risk that this new feature will cause problems to <em>GMock</em> users as long as <code>using namespace testing;</code> appears before any declaration of <code>_</code>.</p><p>This change has been already implemented in GCC 14 and Clang 18.</p><h2 id="conclusion">Conclusion</h2><p>C++26 is going to bring us an unnamed placeholder, <code>_</code>, that can be redeclared as many times in the same scope as you need it. It is implicitely bears the <code>[[maybe_unused]]</code> attribute to avoid getting warnings on unused variables.</p><p>You can already try this feature with a fresh version of GCC and Clang.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,</li><li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></li></ul><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a></p></div></div>
  </body>
</html>
