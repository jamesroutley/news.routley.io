<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prdeving.wordpress.com/2023/10/13/mmo-architecture-client-connections-sockets-threads-and-connection-oriented-servers/">Original</a>
    <h1>MMO Architecture: clients, sockets, threads and connection-oriented servers</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<pre>More on MMO Architecture:</pre>



<hr/>



<p>In the MMO-type online gaming landscape, we are often faced with the challenge of managing a <strong>high demand for connections</strong>. Unlike regular applications, these systems must maintain a smooth and enjoyable gaming experience even amidst the digital chaos of having thousands of players interacting in <strong>real time.</strong></p>



<p>The first step in this orgy of fun is the client connecting to the system.</p>



<p>Add to this that, no matter how boring and static our game is, those <strong>sockets will tend to be used</strong>, which means more and <strong>more traffic</strong>, and with it more and more load. And of course, we will have to implement some kind of <strong>authentication, authorization</strong> and be able to discern to which world or area the notification we receive from the client should be directed.</p>



<p>it is not complicated to realize that on occasions as extreme as the ridiculous space fights of 10,000 players in Eve online, the saturation of open connections can bring down even the most solid system.</p>



<p>Even more so if the design is not correct.</p>



<h2>Connections and threads.</h2>



<p>First of all, how do we manage these connections? You only need to look at an online tutorial on threading of any half-serious language to find the demon itself, <strong>one thread per connection</strong>.</p>



<figure><img data-attachment-id="3113" data-permalink="https://prdeving.wordpress.com/2023/10/13/mmo-architecture-client-connections-sockets-threads-and-connection-oriented-servers/image-3/" data-orig-file="https://prdeving.files.wordpress.com/2023/10/image.png" data-orig-size="771,487" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://prdeving.files.wordpress.com/2023/10/image.png?w=300" data-large-file="https://prdeving.files.wordpress.com/2023/10/image.png?w=771" src="https://prdeving.files.wordpress.com/2023/10/image.png?w=771" alt="" srcset="https://prdeving.files.wordpress.com/2023/10/image.png 771w, https://prdeving.files.wordpress.com/2023/10/image.png?w=150 150w, https://prdeving.files.wordpress.com/2023/10/image.png?w=300 300w, https://prdeving.files.wordpress.com/2023/10/image.png?w=768 768w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></figure>



<p>Well, if you want to have to sell your liver to maintain your infrastructure and have your server explode every Friday afternoon, then this is the perfect choice for you.</p>



<p>In general, we will use these threads to manage the connections, but not the executions derived from the messages that appear in them.</p>



<h2>Thread pooling for message digesting</h2>



<p>The concept of digesting events or messages is quite graphic, in fact.</p>



<figure><img data-attachment-id="3114" data-permalink="https://prdeving.wordpress.com/2023/10/13/mmo-architecture-client-connections-sockets-threads-and-connection-oriented-servers/image-1-2/" data-orig-file="https://prdeving.files.wordpress.com/2023/10/image-1.png" data-orig-size="958,571" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-1" data-image-description="" data-image-caption="" data-medium-file="https://prdeving.files.wordpress.com/2023/10/image-1.png?w=300" data-large-file="https://prdeving.files.wordpress.com/2023/10/image-1.png?w=840" src="https://prdeving.files.wordpress.com/2023/10/image-1.png?w=958" alt="" srcset="https://prdeving.files.wordpress.com/2023/10/image-1.png 958w, https://prdeving.files.wordpress.com/2023/10/image-1.png?w=150 150w, https://prdeving.files.wordpress.com/2023/10/image-1.png?w=300 300w, https://prdeving.files.wordpress.com/2023/10/image-1.png?w=768 768w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></figure>



<p>To solve this situation, an ideal tool is a<strong> thread pool</strong>, a simple yet effective mechanism which handles<strong> multiple tasks</strong> without the overhead of initializing and destroying threads for each individual task.</p>



<p>A thread pool is initialized with a specific number of threads, messages are submitted to a shared queue, which, in our case is implemented as a FIFO queue to maintain the order of processing.</p>



<p>The threads in the thread pool continuously <strong>monitor the queue</strong> for new tasks and when a task is available, a thread from the pool will <strong>dequeue the task and execute it.</strong> Upon completion of a task, the <strong>thread returns to the pool</strong> and stands ready to process the next available task in the queue.</p>



<p>These threads are <strong>created in advance</strong>, which alleviates the overhead of creating and destroying threads that would otherwise occur per task, and may even exceed the fixed limits of our machine by producing denials of service to the system’s clients.</p>



<p>This way, threads are <strong>reused across many tasks</strong>, leading to <strong>better performance</strong> and <strong>lower system resource usage</strong> as compared to creating a new thread for each task.</p>



<p>Utilizing a thread pool for digesting messages from a FIFO queue is <strong>highly efficient</strong> especially in scenarios where the rate of message arrival is high and the processing of each message is relatively short-lived, thus perfect for this little MMO situation we have here. The pool can significantly<strong> reduce the latency associated with the processing of these messages</strong>, ensuring that each message is handled in a timely fashion.</p>



<p>By leveraging a thread pool, the system can process <strong>multiple messages concurrently</strong>, maximizing the utilization of system resources and improving the overall throughput of the message processing system.</p>



<p>But threading is just a small slice of the story. </p>



<p>Even if we can afford 40 threads running in parallel and we can easily manage 200 clients per thread, reserving half of them for a pool, we would be talking about <strong>4000 concurrent clients</strong> per server, still far from the 10k nerds and their virtual lasers we were talking about before.</p>



<p>How do we scale this?</p>



<h2>Frontend servers to decouple game from connections</h2>



<p>In a way, the question is already answered, but let’s go into a little more detail.</p>



<p>How would the flow look like at the definition point we are at? Simple, a client connects to the server and sends a message “hey server, I jumped!”.</p>



<blockquote>
<p>we have <strong>game servers</strong> […] take care of the game </p>
</blockquote>



<p>This is where the proxy or frontend servers come into play.</p>



<blockquote>
<p>The <strong>connection and the message goes to the frontend server</strong></p>
</blockquote>



<p>The <strong>connection and the message goes to the frontend server</strong>, it does its pooling magic, validates the session, sees which game world the character belongs to and sends the action directly to the game server.</p>



<figure><img data-attachment-id="3116" data-permalink="https://prdeving.wordpress.com/2023/10/13/mmo-architecture-client-connections-sockets-threads-and-connection-oriented-servers/image-2-2/" data-orig-file="https://prdeving.files.wordpress.com/2023/10/image-2.png" data-orig-size="1023,553" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://prdeving.files.wordpress.com/2023/10/image-2.png?w=300" data-large-file="https://prdeving.files.wordpress.com/2023/10/image-2.png?w=840" src="https://prdeving.files.wordpress.com/2023/10/image-2.png?w=1023" alt="" srcset="https://prdeving.files.wordpress.com/2023/10/image-2.png 1023w, https://prdeving.files.wordpress.com/2023/10/image-2.png?w=150 150w, https://prdeving.files.wordpress.com/2023/10/image-2.png?w=300 300w, https://prdeving.files.wordpress.com/2023/10/image-2.png?w=768 768w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></figure>



<p>Voila, all the load related to sessions, client connections, retries, lags due to lost packets etc is isolated on frontend servers.</p>



<p>Meanwhile, our game worlds are only concerned with, well, <strong>the game.</strong></p>



<hr/>



<p>In distributed systems as complex as an MMO, we face unique operational challenges. Real-time interaction among thousands of players, each of them generating a torrent of messages and actions, tests the robustness and efficiency of our designs.</p>



<p>Efficient<strong> use of resources</strong> through techniques that allow us to control and distribute system load, such as thread pooling, is critical to efficiently digest messages and <strong>avoid overloading at times of high concurrency</strong>, enabling rapid response to player demands. In addition, the layered server architecture, with <strong>frontend servers handling connections</strong> and <strong>game servers focused on game </strong>logic, provides a clear <strong>separation of responsibilities</strong>, facilitating <strong>scalability and system maintenance.</strong></p>

			
				</div></div>
  </body>
</html>
