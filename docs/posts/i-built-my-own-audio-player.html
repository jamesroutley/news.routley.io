<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nexo.sh/posts/why-i-built-a-native-mp3-player-in-swiftui/">Original</a>
    <h1>I Built My Own Audio Player</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><blockquote><p>In 2025, playing your own <strong>music on an iPhone is surprisingly hard</strong>, unless you pay Apple or navigate a maze of limitations. So I built my own player from scratch, with <strong>full text search</strong>, <strong>iCloud support</strong>, and a <strong>local-first experience</strong>. <a href="https://github.com/nexo-tech/music-app">GitHub link</a></p></blockquote><h2 id="why-i-built-my-own-audio-player">Why I Built My Own Audio Player</h2><p><img src="https://www.scd31.com/posts/frame_source.webp" alt="An image of a music app I’ve built"/></p><p>Like many people, I’ve picked up too many subscriptions, some through Apple (iCloud, Apple Music), others got lost in random platforms (like Netflix, which I forgot I was still paying for). I actually used Apple Music regularly (and previously Spotify), but the streaming turned out to be more convenience than necessity. With a curated local library, I didn’t lose much, just the lock-in.</p><p>Initially I thought, I’d just keep using iCloud Music Library for cross-device music synchronization, but once I cancelled the Apple Music subscription, the sync stopped working. Turns out this feature is <strong>behind a paywall</strong>. You can technically get it back via <a href="https://support.apple.com/en-us/108935"><em>iTunes Match</em> ($24.99/year)</a>. Match just stores 256-kbps AAC copies online; your original files stay put unless you choose to replace them. On a modern Mac, you do all this in the Music app. Without either subscription, cloud sync is gone, and you’re back to cable/Wi-Fi syncing.</p><p>Frustrated with the lack of options, I went the <strong>builder route</strong>. If I bought a computing device (iPhone in this case), what stops me from just building exactly what I need with code to use it? In this article, I want to share my full journey of frustrations towards creating a basic music player functionality: loading audio files, organizing and playing them back, but mostly, I wanted to remind myself, <em>this is still a general-purpose computer, I should be able to make it do what I want</em>.</p><h2 id="what-apple-and-others-offer-today">What Apple (and Others) Offer Today</h2><p>Before writing my own app, I explored the official and third-party options for offline music playback.</p><h3 id="apples-built-in-apps">Apple’s Built-in Apps</h3><p>Apple technically lets you play music directly from iCloud via the Files app, but its functionality is not designed for music listening. It <strong>lacks essential features</strong> such as playlist management, metadata sorting, or playback queues. While it supports music playback, it’s very limited and overall <a href="https://discussions.apple.com/thread/252762868"><strong>not a good user experience</strong></a>.</p><h3 id="third-party-apps">Third-Party Apps</h3><p>I went to the app store to look for cool apps that solve my problem, while there are many of them, many rely on <strong>subscription-based pricing</strong>, a questionable model for an app that simply plays files users already own. There’s one app that I liked, <a href="https://apps.apple.com/us/app/doppler-mp3-flac-player/id1468459747">Doppler</a>. I’ve played with it during a trial, but the UX is built around managing albums. The search wasn’t that good, and the import functionality from iCloud was slow and hard to use on a large number of nested folders. The upside was, it had a single payment pricing model.</p><h2 id="going-builder-mode-my-technical-journey">Going Builder Mode: My Technical Journey</h2><p>With that said, I decided to create my own ideal music player that solves my pain points:</p><ul><li>Flexible full-text search across iCloud folders, so I can select and import a folder with music or specific files quickly.</li><li>Functionality in managing music at least on par with the official Music App: queue, playlist management, and sorting by albums, etc.</li><li>Familiar and friendly interface.</li></ul><h3 id="trying-react-native-first">Trying React Native First</h3><p>Initially, I avoided Swift because of my previous experience with it. A few years back, I liked the syntax (felt closer to TypeScript) and appreciated the Rust-like memory safety, but without native <code>async</code>/<code>await</code> at that time, writing concurrent code compared to Go or JS/TS felt clunky and boilerplate-heavy. That experience left me frustrated, so when I revisited this project, I initially reached for something more familiar.</p><p>That said, I went with React Native or Expo, hoping to reuse my web development experience and plug in a player UI from existing templates. Building the playback UI was straightforward; there are numerous open-source examples and tutorial videos on building good-looking music players that fit my needs. I picked an existing <a href="https://github.com/CodeWithGionatha-Labs/music-player">template project by Gionatha Sturba</a>, because it looked to have every feature I need for my app.</p><p><img src="https://www.scd31.com/posts/rn-screenshot.webp" alt="Attempting to build an app with React Native/Expo"/></p><p>Accessing the file system and syncing cloud files hit major roadblocks: libraries like <a href="https://docs.expo.dev/versions/latest/sdk/filesystem/"><code>expo-filesystem</code></a> supported basic file picking, but recursive traversal over deeply nested iCloud directories <strong>often failed or even caused app crashes</strong>. This made it clear that a <strong>JavaScript-based approach introduced more complexity</strong> than just working with Apple’s native APIs, even if it meant a steeper learning curve.</p><p>iOS sandboxing prevents apps from reading files without explicit user permission, which meant React Native couldn’t access external folders reliably. Switching to Swift gave me more control over iCloud file access and sandboxed permissions.</p><h3 id="switching-to-swiftui">Switching to SwiftUI</h3><p>I went with <strong>SwiftUI</strong> instead of UIKit or storyboards because I wanted a <strong>clean and declarative UI</strong> layer that would stay out of the way while I focused on domain logic and data synchronization. With modern features like async/await and integration with <strong>Swift Actors</strong>, I found it easier to manage data flow and concurrency. SwiftUI also definitely made it easier to structure the app into isolated ViewModel components, which in turn helped me get better results from LLMs like OpenAI o1 and DeepSeek. LLMs could produce pure UI code or data binding code without introducing messy interdependencies.</p><h2 id="app-architecture-and-data-model">App Architecture and Data Model</h2><p>Let’s go over the architecture of the app I’ve created: I used SQLite for persistent data storage and approached the app architecture as a simple server application. I avoided CoreData because I needed tight control over schema, raw queries, and especially full-text search. SQLite’s built-in FTS5 support let me add fast fuzzy search without pulling in heavy external search engines or building my own indexing layer.</p><h3 id="three-main-screens">Three Main Screens</h3><p><strong>The app consists of 3 screen/modes:</strong></p><ol><li><strong>Library import.</strong> This is where you add your iCloud library folder. The app scans every folder for audio files and inserts every path into a SQLite database. This way, you can have full flexibility in searching, adding folders, and subfolders. Apple’s native file picker is very clunky; you cannot select multiple directories that you searched by keyword and then also a bunch of files in one go. It simply is not designed to do that.</li><li><strong>Library management.</strong> This is where you can manage the added songs and organize playlists. For the most part, I’ve reflected the way Apple did that in their Music app, and it was good enough for my needs.</li><li><strong>Player and playback.</strong> This part of the application manages queue management (repeat, shuffle), etc., and play, stop, and next song functionality.</li></ol><p>A simple user flow diagram is shown here:</p><figure><img src="https://www.scd31.com/posts/why-i-built-a-native-mp3-player-in-swiftui/user-flow-diagram.svg" alt="User flow diagram" width="600"/></figure><p><strong>User flow in practice:</strong> When the app launches with an empty library, it lands on the Sync tab, showing a big “Add iCloud Source” button. Pick a folder there, and the Sync screen displays a progress bar while it walks the tree. As soon as indexing finishes, it switches you to the Library tab, whose first screen lists <strong>Playlists / Artists / Albums / Songs</strong>. Dive into any list, tap a track, and a Mini-Player pops up along the bottom; tap that mini-bar to open the full-screen Player with shuffle, repeat, queue reorder, and volume. Swipe or tap the close icon, and you’re straight back to the Library while playback continues. Any time you need more music, jump back to Sync, hit the “+” in the nav bar, select another folder, and the import service merges new songs in the background, no restart required.</p><h3 id="backend-like-logic-layer">Backend-Like Logic Layer</h3><p>Having a web/cloud background and shipped a lot of server code while working in startups, I went with a <strong>backend-like architecture</strong> for the mobile app. The whole domain/logic layer was separated from the <strong>View and View-Model layer</strong> because I had to nail the <strong>cloud syncing, metadata parsing</strong> aspect of the app and having clean data access to a SQLite DB. <em>Here’s an approximate layered architecture diagram that I used here</em>:</p><figure><img src="https://www.scd31.com/posts/why-i-built-a-native-mp3-player-in-swiftui/layers.svg" alt="Layered architecture diagram" width="600"/></figure><p><strong>How the layers talk:</strong> SQLite sits at the bottom, storing raw song rows and FTS indexes. Then repositories wrap the database and expose async APIs. On top of those live my <strong>domain actors</strong>, Swift actors that own all business rules (import, search, queue logic) so state mutations stay <strong>thread-safe</strong>. ViewModels subscribe to the actors, transform the data into UI-ready structs, and SwiftUI views simply render whatever they get. Nothing crosses layers directly, keeping iCloud sync, playback, and UI <strong>nicely decoupled</strong>.</p><h2 id="implementing-full-text-search-with-sqlite">Implementing Full Text Search with SQLite</h2><p>Like I previously mentioned, it’s fortunate that you can import an SQLite version with FTS capabilities: starting around iOS 11, it’s available out of the box <strong>without extra setup</strong>. This made it easy to integrate fuzzy search into my music library <strong>without any third-party dependencies</strong>. Additionally, I used the SQLite.swift library for regular queries (which works as a sort of query builder with compile-time safety); however, for FTS queries, I had to resort to regular SQL statements.</p><p>SQLite’s <a href="https://sqlite.org/fts5.html">FTS5</a> extension ended up being one of the most valuable pieces of the architecture. It let me query across file names and metadata like artist, album, and title without extra indexing infrastructure.</p><h3 id="setting-up-the-fts-tables">Setting Up the FTS Tables</h3><table><thead><tr><th>Domain</th><th>Swift actor / repo</th><th>FTS5 table</th><th>Columns that get indexed</th></tr></thead><tbody><tr><td>Library songs</td><td><code>SQLiteSongRepository</code></td><td><code>songs_fts</code></td><td><code>artist</code>, <code>title</code>, <code>album</code>, <code>albumArtist</code></td></tr><tr><td>Source-browser paths</td><td><code>SQLiteSourcePathSearchRepository</code></td><td><code>source_paths_fts</code></td><td><code>fullPath</code>, <code>fileName</code></td></tr></tbody></table><p>I used two FTS5 tables: one for indexed songs (artist/title/album) and one for file paths during folder import. Both tables live next to the primary rows in plain‐old B-tree tables (<code>songs</code>, <code>source_paths</code>). FTS is <strong>read-only for the UI</strong>; all writes happen inside the repositories so nothing slips through the cracks.</p><h4 id="creating-the-search-index">Creating the search index</h4><p>SQLite’s built-in FTS5 makes quick searches easy. Here’s a simple table definition I used:</p><figure role="figure" aria-label="swift code snippet"><div><p>swift</p><div><p>Copied to clipboard</p></div></div><div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span></code></pre></td><td><pre tabindex="0"><code data-lang="swift"><span><span><span>try</span> <span>db</span><span>.</span><span>execute</span><span>(</span><span>&#34;&#34;&#34;
</span></span></span><span><span><span>CREATE VIRTUAL TABLE IF NOT EXISTS songs_fts USING fts5(
</span></span></span><span><span><span>  songId UNINDEXED,
</span></span></span><span><span><span>  artist, title, album, albumArtist,
</span></span></span><span><span><span>  tokenize=&#39;unicode61&#39;
</span></span></span><span><span><span>);
</span></span></span><span><span><span>&#34;&#34;&#34;</span><span>)</span></span></span></code></pre></td></tr></tbody></table></div></div></div></figure><p>I used <code>unicode61</code> tokenizer to ensure that a wide variety of characters are handled. Non-searchable keys are flagged with <code>UNINDEXED</code>, so they don’t bloat the term dictionary.</p><h4 id="updating-data-reliably">Updating data reliably</h4><p>To keep things simple and safe, I wrapped updates and inserts in transactions. This ensures the search index never gets out of sync, even if the app crashes or gets interrupted.</p><figure role="figure" aria-label="swift code snippet"><div><p>swift</p><div><p>Copied to clipboard</p></div></div><div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td><td><pre tabindex="0"><code data-lang="swift"><span><span><span>func</span> <span>upsertSong</span><span>(</span><span>_</span> <span>song</span><span>:</span> <span>Song</span><span>)</span> <span>async</span> <span>throws</span> <span>{</span>
</span></span><span><span>    <span>db</span><span>.</span><span>transaction</span> <span>{</span>
</span></span><span><span>        <span>// insert or update main song data</span>
</span></span><span><span>        <span>// insert or update search index data</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span></span></span></code></pre></td></tr></tbody></table></div></div></div></figure><h3 id="querying-with-fuzzy-search">Querying with Fuzzy Search</h3><p>For user-friendly search, I add wildcard support automatically. If you type “lumine,” it searches for “lumine*” internally, giving instant results even with partial queries.</p><p>I also leverage SQLite’s built-in smart ranking (<code>bm25</code>) to return more relevant results without extra complexity:</p><figure role="figure" aria-label="sql code snippet"><div><p>sql</p><div><p>Copied to clipboard</p></div></div><div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td><td><pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span><span>s</span><span>.</span><span>*</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> </span><span>songs</span><span> </span><span>s</span><span> </span><span>JOIN</span><span> </span><span>songs_fts</span><span> </span><span>fts</span><span> </span><span>ON</span><span> </span><span>s</span><span>.</span><span>id</span><span> </span><span>=</span><span> </span><span>fts</span><span>.</span><span>songId</span><span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span><span>songs_fts</span><span> </span><span>MATCH</span><span> </span><span>?</span><span>
</span></span></span><span><span><span></span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>bm25</span><span>(</span><span>songs_fts</span><span>)</span><span>
</span></span></span><span><span><span></span><span>LIMIT</span><span> </span><span>?</span><span> </span><span>OFFSET</span><span> </span><span>?</span><span>;</span></span></span></code></pre></td></tr></tbody></table></div></div></div></figure><p>Overall, using raw SQLite gave me the flexibility I needed: predictable schema, local-first access, and powerful full-text search, without introducing any network dependencies or external services. This approach was ideal for an app designed to be private and offline-first.</p><h2 id="working-with-ios-files-and-bookmarks">Working with iOS Files and Bookmarks</h2><p>On iOS, apps can store persistent bookmarks to file locations, but <strong>security-scoped bookmarks</strong>, which grant extended access to files outside the app’s sandbox, are only available on <strong>macOS</strong>. iOS apps can use regular bookmarks to remember file paths and request access again through the document picker, but that access isn’t guaranteed to persist silently. See <a href="https://developer.apple.com/documentation/foundation/nsurl#Bookmarks-and-Security-Scope">Apple’s bookmark documentation</a>.</p><p>To mitigate this, I implemented a fallback mechanism that copies files into the <strong>app’s own sandboxed container</strong>. This avoids the fragile lifecycle of security-scoped bookmarks that can silently break if iOS resets the permissions. By copying files proactively in the background, while the bookmark is valid, there’s no risk in accessing invalid audio-file references.</p><p>This approach also improves indexing speed. I can scan the folder structure once (while access is active), import only relevant audio files, and safely traverse deeply nested directories. But reliably playing back individual audio files from external locations, especially after device restarts, <em>remains an unsolved problem to me</em>. This highlights how <strong>under-supported</strong> this use case is, even for native apps, and how complex it still is to <strong>handle file access reliably on iOS</strong>.</p><h2 id="building-the-playback-and-ui">Building the Playback and UI</h2><h3 id="metadata-parsing">Metadata Parsing</h3><p>To parse metadata from audio files, I used Apple’s <strong>AVFoundation framework</strong>, specifically the <strong>AVURLAsset</strong> class, which allows inspection of media file metadata, such as title, album artist, etc. While metadata parsing is handled by the native SDK, certain fields like track numbers you have to manually look up from ID3 tags. I relied on <a href="https://github.com/TastemakerDesign/Warper/blob/2af8c07ad8422f4dc3a539177d3a76ee8502e632/plugins/flutter_media_metadata/ios/Classes/Id3MetadataRetriever.swift">GitHub search</a> to find examples, since the official documentation lacked coverage for edge cases.</p><h3 id="audio-playback-with-avfoundation">Audio Playback with AVFoundation</h3><p>After the library is indexed, implementing an audio player feels pretty simple: you just have to initialize an instance of <code>AVAudioPlayer</code> and let the audio play. Additionally, for quality-of-life features: playing music from the control center, I had to implement the <code>AVAudioPlayerDelegate</code> protocol and also hooked into Apple’s <code>MPRemoteCommandCenter</code>, which lets developers respond to system-level playback controls.</p><h2 id="reflections-apple-developer-lock-in-and-the-future">Reflections: Apple, Developer Lock-In, and the Future</h2><p>Here’s what stood out during development:</p><h3 id="the-bad">The Bad</h3><p><strong>Xcode’s limitations remain frustrating.</strong> Real-time SwiftUI previews are definitely a step forward, but the overall development experience still isn’t on par with what Flutter offered five years ago: tight VSCode integration, real-time simulator reloads, and familiar debugging tools.</p><p><strong>Lack of editor flexibility.</strong> Setting up Language Server Protocol (LSP) support for Swift in Neovim or VSCode requires extra tooling like <a href="https://github.com/SolaWing/xcode-build-server"><code>xcode-build-server</code></a>, and still doesn’t fully match the developer experience of web-first ecosystems.</p><p><strong>Some corners of Apple’s SDK still live in Objective-C land.</strong> Spotlight file search, for instance, is only exposed through <code>NSMetadataQuery</code>, which uses Key-Value Observing (KVO) and string keys, no Swift-friendly wrapper yet. Documentation is often sparse, which steepens the learning curve.</p><p><strong>SwiftUI’s declarative UI is great, but debugging iCloud interactions still requires manual mocks.</strong> SwiftUI previews can’t emulate full app behaviors involving iCloud entitlements, so you have to mock cloud interactions manually, a minor annoyance but notable.</p><h3 id="the-good">The Good</h3><p><strong>Async/await.</strong> Finally, I can write I/O-bound concurrent code like an imperative one with no annoying callbacks. That’s a big win, and I greatly appreciate how easy it is to write even sync code into Actors and call it like you do in JavaScript ecosystems.</p><p><strong>Plethora of native libs.</strong> Yes, you’re not limited by open source bindings like in React Native/Flutter ecosystems. Here you have much more freedom in developing something “more serious” than your company/product website replacement (because of poor mobile-first experience). Many Apple’s APIs are available with examples, which made it easy to get started.</p><p><strong>SwiftUI</strong> itself. Yes, the React-style approach to building UIs gives more productivity and space for explorations. It’s just great that Apple adopted it.</p><h3 id="summary-building-should-be-easier">Summary: Building Should Be Easier</h3><p>After 1.5 weeks of hacking around, I was able to get the piece of software which exactly satisfies my needs: a <strong>local/offline music player</strong> that can import audio files from cloud storage.</p><p>But developers quickly realize they can’t easily deploy apps to their own devices these days and forget about it: apps only run for <a href="https://developer.apple.com/support/compare-memberships"><strong>7 days without a dev certificate</strong></a>, and after that, you have to rebuild it, unless you paid $99 to Apple to enroll in the development program.</p><p>Even after the <strong>DMA Act in the EU</strong>, sideloading still isn’t fully open. EU users can now install apps from third-party marketplaces directly from a developer’s site, but only if that developer still enrolled in Apple’s $99/year program and agrees to Apple’s Alternative Terms. For personal/hobbyist use, this still doesn’t remove the 7-day dev build limitation.</p><p>This makes ultimately no sense. An innovative technology company actively puts roadblocks into democratized application development. Even Progressive Web Applications (PWAs) <a href="https://brainhub.eu/library/pwa-on-ios">face notable limitations on iOS</a>: even after Apple’s 16-18.x updates, iOS PWAs still run inside Safari’s sandbox. They get WebGL2 and web-push, but they don’t get Web Bluetooth/USB/NFC, Background Sync, or more than ~50MB of guaranteed storage. WebGL runs through Metal shim, so real-world frame-rates often trail native Metal apps; this is good enough for UI, but not for AAA 3D games.</p><p>Nowadays, AI has reduced the complexity of modern software development by allowing anyone to tackle unknown technologies by providing all the necessary knowledge in an accessible way. You can clearly see how web development got more interest from non-technical people who have a way to build their ideas without specializing in a plethora of technologies. But when it comes to mobile apps, you just have to play by the artificial rules. <em>Even if you built it yourself, for yourself, Apple still gets the final say</em> before you can run it for more than a week. The same company that once empowered independent developers now imposes <strong>tight restrictions that hinder personal app development</strong> and distribution. AI has made it easier than ever to build new tools, unless you’re building for iOS, where the gate is still locked.</p><ul><li><a href="https://support.apple.com/en-us/HT204146">iTunes Match – Apple Support</a></li><li><a href="https://developer.apple.com/documentation/foundation/nsurl#1664002">Security-Scoped Bookmarks – Apple Docs</a></li><li><a href="https://sqlite.org/fts5.html">FTS5 – SQLite Documentation</a></li><li><a href="https://apps.apple.com/us/app/doppler-music-player/id1500875779">Doppler Music Player – App Store</a></li><li><a href="https://docs.expo.dev/versions/latest/sdk/filesystem/">Expo FileSystem Documentation</a></li><li><a href="https://developer.apple.com/programs/">Apple Developer Program Info (7-day builds)</a></li><li><a href="https://discussions.apple.com/thread/252762868?sortBy=rank">Apple Community: Files App &amp; MP3 Playback</a></li></ul></div></div>
  </body>
</html>
