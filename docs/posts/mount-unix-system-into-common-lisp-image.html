<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/PuellaeMagicae/unix-in-lisp">Original</a>
    <h1>Show HN: Mount Unix system into Common Lisp image</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Unix in Lisp is currently a usable Lisp (not POSIX!) shell for Unix. The distinctive feature of Unix in Lisp is that rather than creating a sub-language for Unix operations, Unix concepts are directly/shallowly embedded into Lisp (Unix commands become Lisp macros, Unix file become Lisp variables, Unix streams become lazy Lisp sequences, etc).</p>
<p dir="auto">The fact that Unix in Lisp <i>is</i> Lisp, rather than an interpreter written in Lisp, makes it possible to leverage existing tools for Lisp. One instance is the Unix in SLIME listener, which inherits completion, interactive debugger and multiple listeners etc from SLIME itself. Another instance is that existing CL library such as sequence helper functions from <code>serapeum</code> works out of the box on Unix in Lisp process streams.</p>

<ul dir="auto">
  <li><a href="#quick-start">Quick Start</a>
    <ul dir="auto">
      <li><a href="#examples">Examples</a></li>
    </ul>
  </li>
  <li><a href="#documentation">Documentation</a>
    <ul dir="auto">
      <li><a href="#file-system-mapping">File System Mapping</a></li>
      <li><a href="#command-and-process-mapping">Command and Process Mapping</a>
        <ul dir="auto">
          <li><a href="#simple-commands">Simple commands</a></li>
          <li><a href="#pipeline">Pipeline</a></li>
          <li><a href="#interactive-use">Interactive Use</a></li>
        </ul>
      </li>
      <li><a href="#environment">Environment</a></li>
      <li><a href="#scripting-blazingly-fast-start-up">Scripting (blazingly fast start up)</a></li>
      <li><a href="#unix-in-slime">Unix in SLIME</a>
        <ul dir="auto">
          <li><a href="#performance-fast">Performance: fast!</a></li>
          <li><a href="#completion">Completion</a></li>
        </ul>
      </li>
      <li><a href="#package-system-structure">Package system structure</a></li>
    </ul>
  </li>
</ul>

<p dir="auto">Currently, only SBCL is supported. Clone this repository into your <code>~/quicklisp/local-projects/</code>. Unix in Lisp is currently at <i>alpha</i> stage and will receive frequent changes. It’s recommended to use Ultralisp to install dependencies, to make sure various bug fixes to the upstream are available which Unix in Lisp relies on. If you haven’t done so, <code>(ql-dist:install-dist &#34;http://dist.ultralisp.org/&#34; :prompt nil)</code>. Before first-time use, run <code>(ql:update-dist &#34;ultralisp&#34;)</code> and <code>(ql:quickload &#34;unix-in-lisp&#34;)</code> to install all dependencies. It’s also advised to <code>(ql:update-dist &#34;ultralisp&#34;)</code> and <code>git pull</code> this repo regularly to get updates and bug fixes.</p>
<p dir="auto">It’s recommended to load <code>unix-in-slime.el</code> for better SLIME integration. To load it, evaluate <code>(require &#39;unix-in-slime &#34;~/quicklisp/local-projects/unix-in-lisp/unix-in-slime&#34;)</code> in emacs. You may want to add this line to your <code>init.el</code>. Then <code>M-x unix-in-sime</code> to start a listener, and have fun!</p>
<p dir="auto"><code>unix-in-slime</code> installs hacks to the host Lisp environment by calling <code>(unix-in-lisp:install)</code> on startup. To undo hacks done to the host environment and unmount Unix FS packages, run <code>(unix-in-lisp:uninstall)</code>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">(Some print-outs are omitted)</p>
<p dir="auto">Counting number of files</p>
<pre>/Users/kchan&gt; (cd quicklisp/local-projects/unix-in-lisp)
/Users/kchan/quicklisp/local-projects/unix-in-lisp&gt; (pipe (wc -l) (ls))
       9
</pre>
<p dir="auto">But why not the Lisp way as well!</p>
<pre>/Users/kchan/quicklisp/local-projects/unix-in-lisp&gt; (length (package-exports ./))
9
</pre>
<p dir="auto">For more examples, see <a href="https://github.com/PuellaeMagicae/unix-in-lisp/blob/master/TUTORIAL.org">TUTORIAL.org</a></p>

<h2 tabindex="-1" dir="auto"><a id="user-content-file-system-mapping" aria-hidden="true" href="#file-system-mapping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File System Mapping</h2>
<p dir="auto">Directories are mapped as <i>Unix FS packages</i>. A Unix FS packages is any Common Lisp package whose package name designate an absolute path name (usually when it starts with a slash).</p>
<p dir="auto">The exported symbols of a Unix FS package should one-to-one correspond to files in the mapped directory. Exceptions to this one-to-one correspondence:</p>
<ul dir="auto">
  <li>Because of the limit of file system change tracking, the package structure in the Common Lisp image may diverge from the Unix FS state.
    <ul dir="auto">
      <li>Currently, the state of a Unix FS package is synchronized when calling <code>mount-directory</code>. By default, <code>remount-current-directory</code> is added to <code>*post-command-hook*</code>, which does the obvious thing.</li>
    </ul>
  </li>
</ul>
<p dir="auto">Each of these exported symbols has a global symbol macro binding, so that they can be read/write like Lisp variables. Access to the symbol gives the list of lines of the underlying file, and setting it with a list designator of lines cause them to be written to the file.</p>
<pre>unix-user /Users/kchan/&gt; .bashrc
(&#34;export CC=\&#34;clang\&#34;&#34; &#34;export PS1=&#39;$(hostname):$(pwd) $(whoami)\\$ &#39;&#34; ...)
</pre>
<p dir="auto">Note that there are no corresponding symbol for a non-existent file. To write or create a file that you are not sure whether it already exists, it’s recommended to use <code>defile</code> macro, which will ensure the file exists and creates the corresponding symbol.</p>
<pre>unix-user /Users/kchan/&gt; (defile iota.txt (iota 10))
/Users/kchan/iota.txt
unix-user /Users/kchan/&gt; iota.txt
(&#34;0&#34; &#34;1&#34; &#34;2&#34; &#34;3&#34; &#34;4&#34; &#34;5&#34; &#34;6&#34; &#34;7&#34; &#34;8&#34; &#34;9&#34;)
</pre>
<p dir="auto">In the above example, if <code>iota.txt</code> does not exist and I use <code>setq</code> instead of <code>defile</code>, an internal symbol named <code>IOTA.TXT</code> will be created in <code>UNIX-USER</code> package instead and I will write to its value cell, rather than <code>/Users/kchan/iota.txt</code> on the file system.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-command-and-process-mapping" aria-hidden="true" href="#command-and-process-mapping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Command and Process Mapping</h2>
<p dir="auto">Unix in Lisp manages jobs in the unit of <i>Effective processes</i>. Theses include regular Unix processes represented by <code>simple-process</code>, and <code>pipeline</code>’s which are consisted of any number of UNIX processes and Lisp function stages.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-simple-commands" aria-hidden="true" href="#simple-commands"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simple commands</h3>
<p dir="auto">When Unix in Lisp maps a directory, files are checked for execution permission and executable ones are mapped as Common Lisp macros.  These macros <i>implicitly quasiquotes</i> their arguments. The arguments are converted to strings using <code>literal-to-string</code>, then passed to the corresponding executable.</p>
<p dir="auto">Examples of using macros mapped from Unix commands</p>
<pre>/Users/kchan/some-documents&gt; (cat ,@(ls))
;; This cats together all files under current directory.
</pre>
<p dir="auto">You can also set up redirections (and maybe other process creation settings in the future) via supplying keyword arguments. These arguments <i>are not</i> implicitly quasiquoted and <i>are</i> evaluated.</p>
<pre>/Users/kchan/some-documents&gt; (ls :output *terminal-io*)
;; This outputs to *terminal-io*, which usually goes into *inferior-lisp* buffer.
</pre>
<pre>/Users/kchan/some-documents&gt; (ls :error :output)
;; This redirect stderr of ls command to its stdout, like 2&gt;&amp;1 in posix shell
</pre>
<p dir="auto">Like you have discovered in <code>(cat ,@(ls))</code>, effective processes can be used like Lisp sequences – they designate the sequence of their output lines.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-pipeline" aria-hidden="true" href="#pipeline"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Pipeline</h3>
<p dir="auto">Pipelines are created via the <code>pipe</code> macro:</p>
<pre>/Users/kchan/quicklisp/local-projects/unix-in-lisp&gt; (pipe (wc -l) (ls))
       9
</pre>
<p dir="auto">Under the hood, except the first stage, each stage of the pipeline is passed <code>:input &lt;result-of-previous-pipeline-stage&gt;</code> as an additional argument. Alternatively, if there are arguments <code>_</code>, they are substituted with the result of the previous stage. You can mix Lisp functions and values with Unix commands. Using Lisp value as the first input stage is easy enough:</p>
<pre>/Users/kchan&gt; (pipe (iota 10) (wc))
      10      10      20
</pre>
<p dir="auto">The <code>_</code> extension make it easy to add Lisp functions to the mix:</p>
<pre>/Users/kchan&gt; (pipe (ls) (filter (lambda (s) (&gt; (length s) 10)) _) (wc -l))
      47
</pre>
<p dir="auto">The above counts the number of file with filename longer than 10 under my home directory.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-interactive-use" aria-hidden="true" href="#interactive-use"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interactive Use</h3>
<p dir="auto">Inside a <code>unix-in-slime</code> listener, if the primary value of evaluation is an effective process and it has avaliable input/output streams, <code>unix-in-slime</code> automatically “connect” it to the listener, i.e. I/O of the listener is redirected to the process, similar to <i>foreground processes</i> in POSIX shell:</p>
<pre>/Users/kchan&gt; (python3 -i)
Python 3.8.9 (default, Apr 13 2022, 08:48:07)
[Clang 13.1.6 (clang-1316.0.21.2.5)] on darwin
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; print(&#34;Hello world!&#34;)
Hello world!
&gt;&gt;&gt; ; No values
/Users/kchan&gt;
</pre>
<p dir="auto"><b>Attention:</b> use <code>C-u RET</code> to signal EOF in <code>unix-in-slime</code>, similar to <code>Ctrl+D</code> in POSIX shells. You can interrupt evaluation via <code>C-c C-c</code> like usual, after which you will be provided a few restarts:</p>
<ol dir="auto">
  <li><code>BACKGROUND</code> puts the job in background (accessible via <code>unix-in-lisp:*jobs*</code>)</li>
  <li><code>ABORT</code> terminates the current job (via <code>SIGTERM</code> for Unix processes)</li>
</ol>
<p dir="auto"><b>Attention:</b> You have to use <code>-i</code> flag to start Python REPL, because Unix in Lisp currently talk to all processes using pipe rather than pseudo tty. Without <code>-i</code>, Python will start itself into non-interactive mode. Other REPLs may need respective flags.</p>
<p dir="auto">When using Unix in Lisp outside <code>unix-in-slime</code>, use <code>(unix-in-lisp:repl-connect &lt;process&gt;)</code> to achieve the same thing.</p>
<p dir="auto"><code>unix-in-lisp:*jobs*</code> keeps a list of running effective processes:</p>
<pre>unix-in-lisp&gt; *jobs*
(#&lt;simple-process python3 (running) {1005BFFCF3}&gt;)
</pre>
<p dir="auto">Note that because <code>unix-in-slime</code> listener connects a job automatically if it is the primary value of evaluation, you can use e.g.</p>
<pre>unix-in-lisp&gt; (nth 0 *jobs*)
</pre>
<p dir="auto">to resume from a background job.</p>
<p dir="auto"><code>unix-in-lisp:repl-connect</code> connects a process exclusively in at most one listener. If a process is already connected in other listener, it will do nothing and the effective process object will be printed like normal. In fact, many Unix in Lisp operations (including <code>repl-connect</code> and <code>pipe</code>) takes exclusive access of input/output stream of processes (by setting the respective slots to <code>nil</code> during their course of operation).</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-environment" aria-hidden="true" href="#environment"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Environment</h2>
<p dir="auto">Unix environment variables are mapped to special (dynamic-scope) Lisp variables.</p>
<pre>/Users/kchan&gt; $logname
&#34;kchan&#34;
</pre>
<p dir="auto">You can set them or dynamically bind them</p>
<pre>/Users/kchan&gt; (setf $test &#34;42&#34;)
&#34;42&#34;
/Users/kchan&gt; (pipe &#39;(&#34;echo $TEST&#34;) (bash))
42
nil
/Users/kchan&gt; (let (($test &#34;override&#34;)) (pipe &#39;(&#34;echo $TEST&#34;) (bash)))
override
nil
</pre>
<p dir="auto">The above works with the help of a reader macro defined on <code>$</code>, which registers the following symbol as an environment variable. If you want to use Unix in Lisp environment variables without our readtable, you need to use function <code>unix-in-lisp:ensure-env-var</code> to register the symbol first. Consult its docstring for more information.</p>
<p dir="auto">Unix in Lisp keeps its own idea of a Unix environment, and pass to subprocesses created by it (e.g. via the macros it created from Unix commands). Other Lisp facilities (e.g. <code>uiop:run-program</code>) does not know this, and usually inherit the “real” Unix environment of the Lisp process instead. To remedy this, Unix in Lisp provides function <code>unix-in-lisp:synchronize-env-to-unix</code> which copies the environment Unix in Lisp manages to the “real” Unix environment of the Lisp process. This is by default run in <code>*post-command-hook*</code>, and you may want to call them before using other Lisp facilities that spawns Unix subprocesses.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-scripting-blazingly-fast-start-up" aria-hidden="true" href="#scripting-blazingly-fast-start-up"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Scripting (blazingly fast start up)</h2>
<p dir="auto">The recommended way to write scripts is to create executable files (say <code>do-stuff.sh</code>) with contents like</p>
<pre>#!/usr/env/bin sbcl --script
(asdf:require-system &#34;&lt;dependency&gt;&#34;)
(asdf:require-system &#34;unix-in-lisp&#34;)
(unix-in-lisp:setup)
&lt;do-stuff&gt;
</pre>
<p dir="auto">The benefit of the above approach is that it is blazingly fast when started from within Unix in Lisp (via e.g. <code>(do-stuff.sh)</code>), because Unix in Lisp has a <i>Fast loading command</i> mechanism, which can execute the script within Unix in Lisp image without starting subprocess if it detects a Lisp shebang. The essence of writing fast startup script is:</p>
<ol dir="auto">
  <li>Use <code>#!/usr/env/bin sbcl --script</code> shebang. Currently it has to be an exact match.</li>
  <li>Use <code>asdf:require-system</code>. This avoids scanning the ASDF registry directory tree for modification, which wastes significant time!</li>
</ol>
<p dir="auto">On my machine, a hello world using the above approach run in 0.5ms, while Python 3 uses 30ms!</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-unix-in-slime" aria-hidden="true" href="#unix-in-slime"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unix in SLIME</h2>
<p dir="auto">The above documentations have been assuming you are using the <code>unix-in-slime</code> listener. Here we document some additional aspects of <code>unix-in-slime</code>.</p>
<p dir="auto">Unix in Lisp assumes a dedicated swank server for <code>unix-in-slime</code> listeners (and potentially other front-ends in the future). <code>M-x unix-in-slime</code> will start one on <code>unix-in-slime-default-port</code> (4010 by default) if none already exists in the Unix in Lisp image. The server handles multiple connections, so you can safely start multiple <code>unix-in-slime</code> listeners simultaneously, like how you must have lived with multiple terminal windows.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-performance-fast" aria-hidden="true" href="#performance-fast"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance: fast!</h3>
<p dir="auto">A quite unintended achievement is that <code>unix-in-slime</code> is a very fast shell for Emacs. In fact, a simple <code>(pipe &#34;time for i in {0..99999}; do echo line $i; done&#34; (sh))</code> benchmark takes 0.83s in <code>unix-in-slime</code>, and takes 2.93s in <code>vterm</code>. <code>unix-in-slime</code> is more than 3 times faster than one of the fastest Emacs terminal emulator (partly written in C)! Of course, this is not a head-to-head comparison because <code>vterm</code> is a terminal emulator while <code>unix-in-slime</code> is a shell, but I did frequent experience fast command outputs choking Emacs and it’s good to know <code>unix-in-slime</code> is pretty good at handle these. I think the reason is that SLIME’s swank server does some very Emacs-specific tuning, e.g. limiting network packet rate because it knows Emacs choke on a flood of them, which also benefits us when we use it as a shell.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-completion" aria-hidden="true" href="#completion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Completion</h3>
<p dir="auto">If you have configured completion for SLIME, completion works out of the box for <code>unix-in-slime</code>. Note that we automagically get “filename completion”, because they are mapped as symbols, and we have symbol completion at home! Currently there’s one quirk: filenames are always completed to their fully resolved path (with <code>.. . ~</code> components resolved), because that’s what corresponds to symbols. I’d say it’s either a bug or a feature depending on who you ask, I’m leaving it like that for now.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-package-system-structure" aria-hidden="true" href="#package-system-structure"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Package system structure</h2>
<p dir="auto">Unix in Lisp defines and populates a number of packages during <code>unix-in-lisp:install</code>. First, <code>unix-in-lisp:path</code> is created according to <code>$PATH</code> environment variable. Then, <code>unix-in-lisp.common</code> is ensured to re-export <code>unix-in-lisp.path</code>, and also export symbols corresponding to environment variables. Packages that wish to make use of Unix in Lisp functionalities should use <code>unix-in-lisp.common</code>, and potentially shadowing import some of its symbols. Any other usage of packages created by Unix in Lisp is less safe, including using or importing symbols from the Unix FS packages, particularly because invoking <code>unix-in-lisp:uninstall</code> deletes them.</p>
<p dir="auto">The Unix in SLIME listener by default starts in <code>unix-user</code> package, which uses <code>unix-in-lisp.common</code> and other utility packages. This causes all listeners to share the same package by default, but you can also create new packages and switch listeners to it. Note that we <i>do not</i> support current directory by <i>using</i> its corresponding Unix FS package. Instead, a reader hook (to <code>sb-impl::%intern</code>) is installed that replace symbols denoting relative path with a new “effective” uninterned symbol that merges bindings from the original symbol and the mounted symbols according to the relative path under current directory (<code>*default-pathname-defaults*</code>). Similar to Unix, our redirection never shadows existing global function bindings, to avoid unintentionally execute files under current directory.</p>
</article>
          </div></div>
  </body>
</html>
