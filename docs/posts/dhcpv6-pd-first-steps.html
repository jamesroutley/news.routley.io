<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sha256.net/dhcpv6-pd-first-steps.html">Original</a>
    <h1>DHCPv6-PD â€“ First Steps</h1>
    
    <div id="readability-page-1" class="page"><div id="text-org968f450">
<p>
At this point I was somewhat stuck and I had a look at how dhcpcd
deals with this. While I was already using dhcpcd in my network, I had
not yet setup the more advanced use case with a <code>/60</code> and multiple
<code>/64</code>. I was pretty sure that dhcpcd can handle this, but I did not
yet know how.
</p>

<p>
Disclaimer: What follows are my notes on how I got it to work. It is
likely that I am doing things wrong and misunderstand some
parts. Unfortunately I no longer have access to GitHub<sup><a id="fnr.7" href="#fn.7" role="doc-backlink">7</a></sup>, so I
cannot open an issue with the project to ask for help with this. I am
very sorry.
</p>

<p>
Here is the relevant part from the <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpcd.conf&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+14.0-RELEASE+and+Ports&amp;arch=default&amp;format=html">dhcpcd.conf man page:</a>
</p>
<pre id="org179ee15">ia_pd [iaid [/ prefix / prefix_len] [interface [/ sla_id [/ prefix_len
        [/ suffix]]]]]
        Request a  DHCPv6 Delegated Prefix for iaid.  This option must
        be used in an interface block.  Unless a sla_id of  0  is  as-
        signed with the same resultant prefix length as the delegation,
        a  reject  route  is installed for the Delegated Prefix to stop
        unallocated addresses being resolved upstream.  If no interface
        is given then we will assign a prefix to every other  interface
        with a sla_id equivalent to the interface index assigned by the
        OS.   Otherwise addresses are only assigned for each interface
        and sla_id.  To avoid delegating to any interface, use - as the
        invalid interface name. Each  assigned address  will  have  a
        suffix, defaulting  to 1.  If the suffix is 0 then a SLAAC ad-
        dress is assigned.  You cannot assign a prefix to the  request-
        ing  interface  unless  the DHCPv6 server supports the RFC 6603
        Prefix Exclude Option.  dhcpcd has to be running  for  all  the
        interfaces  it is delegating to.  A default prefix_len of 64 is
        assumed, unless the maximum sla_id does not fit.  In this  case
        prefix_len  is  increased to the highest multiple of 8 that can
        accommodate the sla_id. sla_id is an  integer  which  must  be
        unique  inside  the  iaid and is added to the prefix which must
        fit inside prefix_len less the length of the delegated  prefix.
        You  can  specify  multiple interface / sla_id / prefix_len per
        ia_pd, space separated. IPv6RS should be  disabled  globally
        when requesting a Prefix Delegation.
</pre>
<p>
I kinda do not know what all of this means.
</p>

<p>
After much experimentation I ended up with this working-ish
configuration:
</p>
<pre id="org13abc38">ia_pd 2/::/59 vether0/0/60 vether1/1/64
</pre>
<p>
which put this in <code>daemon.log</code>:
</p>
<pre id="orgb355e17">vio1: delegated prefix 2001:db8:3::/56
vether0: adding address 2001:db8:3::1/60
vether1: adding address 2001:db8:3:1::1/64
</pre>

<p>
A closer look shows that the two prefixes overlap though:
</p>
<div>
<pre><span>&gt;&gt;&gt;</span> <span>import</span> ipaddress
<span>&gt;&gt;&gt;</span> a <span>=</span> ipaddress.ip_network(<span>&#39;2001:db8:3::/60&#39;</span>)
<span>&gt;&gt;&gt;</span> b <span>=</span> ipaddress.ip_network(<span>&#39;2001:db8:3:1::/64&#39;</span>)
<span>&gt;&gt;&gt;</span> a.overlaps(b)
<span>True</span>
</pre>
</div>

<p>
This configuration produces non-overlapping prefix assignments:
</p>
<pre id="orgc44eef6">ia_pd 2/::/59 vether0/0/60 vether1/16/64
</pre>

<pre id="org25ce261">vio1: delegated prefix 2001:db8:3::/56
vether0: adding address 2001:db8:3::1/60
vether1: adding address 2001:db8:3:10::1/64
</pre>

<p>
Taking this apart, token by token:
</p>
<dl>
<dt><code>ia_pd</code></dt><dd>This is just the keyword to request a prefix delegation.</dd>
<dt><code>2/::/59</code></dt><dd>2 is a unique request ID needed by the DHCPv6
protocol. <code>::</code> is the unspecified prefix and 59 is the requested
prefix length. Since the DHCPv6 server does not have an address pool
for <code>/59</code> it hands out a prefix for the next larger prefix for which
it does have a pool, <code>/56</code> in this case.</dd>
<dt><code>vether0/0/60</code></dt><dd>This assigns the 1st (index 0) <code>/60</code> prefix to
<code>vether0</code>.</dd>
<dt><code>vether1/16/64</code></dt><dd>This assigns the 17th<sup><a id="fnr.8" href="#fn.8" role="doc-backlink">8</a></sup> (index 16) <code>/64</code> prefix to <code>vether1</code>.</dd>
</dl>

<p>
What I misunderstood when I used <code>vether1/1/64</code> was that <code>sla_id</code>
(the 1 in the middle) does not mean use the next free <code>/64</code> but use
the 2nd <code>/64</code> in the delegated prefix.
</p>

<p>
I find this confusing because the way I think about subnetting is that
the different prefixes do not stand alone. <code>2001:db8:3:10::/64</code> is not
the 17th <code>/64</code> prefix in <code>2001:db8:3::/56</code> but the first <code>/64</code> in the
2nd <code>/60</code>. It&#39;s a hierarchy.
</p>
</div></div>
  </body>
</html>
