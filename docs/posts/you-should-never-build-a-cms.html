<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sanity.io/blog/you-should-never-build-a-cms">Original</a>
    <h1>“You should never build a CMS”</h1>
    
    <div id="readability-page-1" class="page"><div><p>We&#39;re just going to call it: up until recently, <a rel="noopener noreferrer" href="https://cursor.com" target="_blank">cursor.com</a> was powered by Sanity as its CMS.</p><p>Then Lee Robinson sat down and spent 344 agent requests and around $260 to migrate the content and setup to <!--$--><a data-state="closed" href="https://www.sanity.io/glossary/markdown">markdown</a><!--/$--> files, GitHub, Vercel, and a vibe-coded media management interface.</p><p>He did <a rel="noopener noreferrer" href="https://leerob.com/agents" target="_blank">a great write-up of the process on his blog</a>. He was classy and didn&#39;t name us.</p><p>Of course, when a high-profile customer moves off your product and <a rel="noopener noreferrer" href="https://x.com/leerob/status/1867513884382597485" target="_blank">the story resonates with builders you respect</a>, you pay attention.</p><p>The weird twist here is that we sort of agree with Lee’s take. He has a lot of great points. The conversation around complexity and abstractions that a <span>headless CMS</span> brings reflects real frustration. The way things have been done for the past decade deserved criticism.</p><p>But Lee&#39;s post doesn&#39;t tell the full story. We see what people are trying to solve when it comes to content every day. We live and breathe this CMS stuff. So let us add some context.</p><p>The headless CMS industry built complexity that didn&#39;t deliver proportional value for many. This is true.</p><p>Preview workflows are clunky. Draft modes, toolbar toggles, account requirements just to see what your content looks like before it goes live. Having to add data attributes everywhere to connect front ends with backend fields feels unnecessary.  Real friction for something that feels it should be simple.</p><p>Auth fragmentation is annoying. CMS login. GitHub login. Hosting provider login. Three systems to get a preview working.</p><p>Their CDN costs was largely caused by hosting a video from our file storage. It’s not an ideal way to host videos in front of Cursor’s massive audience. We should have made it more obvious that there are better and cheaper ways, like using the Mux plugin.</p><p>332K lines of code was removed in exchange for 43K new ones. That sounds a great win. We love getting rid of code too. </p><p>And here&#39;s the one that actually matters: AI agents couldn&#39;t easily reach content behind authenticated APIs. When your coding agent can grep your codebase but can&#39;t query your CMS, that&#39;s a real problem. Lee felt this friction and responded to it. (We did too, and <a rel="noopener noreferrer" href="https://mcp.sanity.io" target="_blank">the new very capable MCP server is out</a>).</p><p>These complaints are valid. We&#39;re not going to pretend otherwise. </p><p>Here&#39;s the thing though. Read his post carefully and look at what he ended up with:</p><ul><li>An asset management GUI (built with &#34;3-4 prompts,&#34; which, to be fair, is impressive)</li><li>User management via GitHub permissions</li><li><!--$--><a data-state="closed" href="https://www.sanity.io/glossary/version-control">Version control</a><!--/$--> via git</li><li>Localization tooling</li><li>A <!--$--><a data-state="closed" href="https://www.sanity.io/glossary/content-model">content model</a><!--/$--> (markdown frontmatter with specific fields)</li></ul><p>These are CMS features. Distributed across npm scripts, GitHub&#39;s permission system, and Vercel&#39;s infrastructure.</p><p>The features exist because the problems are real. You can delete the CMS, but you can&#39;t delete the need to manage assets, control who can publish what, track changes, and structure your content for reusability and distribution at scale.</p><p>Give it six months. The bespoke tooling will grow. The edge cases will multiply. Someone will need to schedule a post. Someone will need to preview on mobile. Someone will want to revert a change from three weeks ago and git reflog won&#39;t cut it. The &#34;simple&#34; system will accrete complexity because content management <em>is</em> complex.</p><p>Even with agents. Who were mostly trained within the constraints of these patterns.</p><p>Lee&#39;s model is clean: one markdown file equals one page. Simple. Grep-able.</p><p>This works until it doesn&#39;t.</p><h3 id="5xtauv"><a title="Copy link to heading" href="https://www.sanity.io/blog/you-should-never-build-a-cms#5xtauv"><span aria-hidden="true"><svg data-sanity-icon="link" width="1em" height="1em" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12.5L12.5 14C13.281 14.781 14.719 14.781 15.5 14L18.5 11C19.281 10.219 19.281 8.78105 18.5 8L18 7.5C17.2189 6.71895 15.781 6.71895 15 7.5L13 9.5M12 15.5L10 17.5C9.21895 18.281 7.78105 18.281 7 17.5L6.5 17C5.71895 16.219 5.71896 14.781 6.5 14L9.50001 11C10.2811 10.219 11.719 10.2189 12.5 11L14 12.5" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"></path></svg><svg data-sanity-icon="checkmark" width="1em" height="1em" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.5 11.5L10.5 16.5L19.5 7.60001" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"></path></svg></span>The content === page trap</a></h3><p>What happens when your pricing lives in three places? The pricing page, the comparison table, the footer CTA. In markdown-land, you update three files. Or you build a templating system that pulls from a canonical source. At which point you&#39;ve invented content references. At which point you&#39;re building a CMS.</p><p>What happens when legal needs to update the compliance language that appears on 47 pages? You grep for the old string and replace it. Except the string has slight variations. Except someone reworded it slightly on the enterprise page. Except now you need to verify each change because regex can&#39;t understand intent. Now you are building a CMS.</p><p>What happens when you want to know &#34;where is this product mentioned?&#34; You can grep for the product name. You can&#39;t grep for &#34;content that references this product entity&#34; because markdown doesn&#39;t have entities. It has strings. </p><p>Suddenly you’re parsing thousands of files on every build to check for broken links (that you can’t query). And yes, you are building a CMS.</p><p>Structured content breaks the content = page assumption on purpose. A product is a document. A landing page document references that product and both are rendered together on the website. And in an app. And the support article for that product. When the product information changes, that changes is reflected in all these places. When you need to find every mention, you query the references, not the strings.</p><p>Engineers understand this. It&#39;s normalization. It&#39;s the same reason you don&#39;t store <code>customer_name</code> as a string in every order row. You store a <code>customer_id</code> and join.</p><p><strong>Markdown files are the content equivalent of denormalized strings everywhere. It works for small datasets. It becomes a maintenance nightmare at scale.</strong></p><h3 id="5xtavo"><a title="Copy link to heading" href="https://www.sanity.io/blog/you-should-never-build-a-cms#5xtavo"><span aria-hidden="true"><svg data-sanity-icon="link" width="1em" height="1em" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12.5L12.5 14C13.281 14.781 14.719 14.781 15.5 14L18.5 11C19.281 10.219 19.281 8.78105 18.5 8L18 7.5C17.2189 6.71895 15.781 6.71895 15 7.5L13 9.5M12 15.5L10 17.5C9.21895 18.281 7.78105 18.281 7 17.5L6.5 17C5.71895 16.219 5.71896 14.781 6.5 14L9.50001 11C10.2811 10.219 11.719 10.2189 12.5 11L14 12.5" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"></path></svg><svg data-sanity-icon="checkmark" width="1em" height="1em" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.5 11.5L10.5 16.5L19.5 7.60001" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"></path></svg></span>Git is not a content collaboration tool</a></h3><p>Git is a version control system built for code. Code has specific properties that make git work well:</p><ul><li>Merge conflicts are mechanical. Two people edited the same function. The resolution is structural.</li><li>Line-based diffing makes sense. Code is organized in lines that map to logical units.</li><li>Branching maps to features. You branch to build something, then merge when it&#39;s done.</li><li>Async is fine. You don&#39;t need to see someone else&#39;s changes until they push.</li></ul><p>Content has different properties:</p><ul><li>Merge conflicts are semantic. Two people edited the same paragraph with different intentions. The &#34;correct&#34; merge requires understanding what both people <em>meant</em>.</li><li>Line-based diffing is arbitrary. A paragraph rewrite shows as one changed line that actually changes everything. If you have block content (like Notion) this breaks apart even more.</li><li>Branching doesn&#39;t map to content workflows. &#34;I&#39;m working on the Q3 campaign&#34; isn&#39;t a branch. It&#39;s 30 pieces of content across 12 pages with 4 people contributing.</li><li>Real-time matters. When your content team is distributed, &#34;I&#39;m editing this doc&#34; needs to be visible <em>now</em>, not after a commit and push. Even more so with AI automation and agents in the mix.</li></ul><p>None of this is git&#39;s fault. Git solved the problem it was built for brilliantly. Content collaboration isn&#39;t that problem.</p><p>We know this because every team that scales content on git builds the same workarounds:</p><ul><li>Lock files or Slack conversations to prevent simultaneous editing</li><li>&#34;I&#39;m working on X, don&#39;t touch it&#34; announcements</li><li>Elaborate PR review processes that become bottlenecks</li><li>Content freezes before launches because merge complexity is too high</li></ul><p>Sound familiar? These are the problems CMSes were built to solve. Real-time collaboration. Conflict-free editing. Workflow states that aren&#39;t git branches.</p><p>Lee&#39;s core argument: AI agents can now grep the codebase, so content should live in the codebase.</p><p>This sounds reasonable until you think about what grep actually does. It&#39;s string matching. Pattern finding. It&#39;s great for &#34;find all files containing X.&#34;</p><p>It&#39;s not great for:</p><ul><li>&#34;All blog posts mentioning feature Y published after September&#34;</li><li>&#34;Products with price &gt; $100 that are in stock&#34;</li><li>&#34;Content tagged &#39;enterprise&#39; that hasn&#39;t been translated to German yet&#34;</li><li>&#34;The three most recent case studies in the finance category&#34;</li></ul><p>Here&#39;s what that last one looks like in GROQ:</p><p>Try writing that as a grep command against markdown files. You can&#39;t. You&#39;d need to parse frontmatter, understand your date format, resolve the category references, handle the sorting, limit the results. At which point you&#39;ve built a query engine.</p><p>Structured content with a real <!--$--><a data-state="closed" href="https://www.sanity.io/glossary/query-language">query language</a><!--/$--> is what agents actually need to reason about content. Markdown files are <em>less</em> queryable than a proper content API, not more.</p><p>The irony here is thick. Lee&#39;s argument for moving to code is that agents can work with code. But agents are better at working with structured data and APIs than they are at parsing arbitrary file formats and grepping for strings. That&#39;s not a limitation of current AI. That&#39;s just how information retrieval works.</p><p>Here&#39;s what we think Lee got backwards: the solution to &#34;my agent can&#39;t access my CMS&#34; isn&#39;t &#34;delete the CMS.&#34; It&#39;s &#34;give your agent access to the CMS.&#34;</p><p>It was also bad timing. Our MCP server wasn&#39;t good enough when Lee tried it.</p><p>But we fixed it. <a rel="noopener noreferrer" href="https://mcp.sanity.io" target="_blank">Our new MCP server is out now</a>.</p><p>Your coding agent can now create new content projects, query your content, create documents, update schemas, and manage releases. All through the same interface you&#39;re already using to build everything else. You never have to see any CMS UI unless you want to.</p><p>Schema, queryable content. From prompts. In about 10 minutes from start to deployed. You can ask it to generate images of those cars too.</p><figure data-type="muxVideo2"><p><img sizes="100vw" alt="" decoding="async" loading="lazy" src="https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0" srcset="https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0&amp;width=200 200w, https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0&amp;width=400 400w, https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0&amp;width=600 600w, https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0&amp;width=800 800w, https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0&amp;width=1200 1200w, https://image.mux.com/fOG02RAwwy00Z4eqtBlOYIQGSvZ4GWUEKC/thumbnail.webp?time=0&amp;width=1600 1600w"/></p></figure><p>You can also use it for content inquires like this:</p><p>The agent queries your actual schema and returns actionable results. Not string matches. Actual documents with their field states.</p><p>The agent checks your existing schema, generates compatible additions, and can deploy them. No tab-switching to documentation. No copy-pasting boilerplate.</p><p>This is what &#34;agents working with content&#34; actually looks like. Not grep. A query language. Not editing markdown. Operating on structured data through proper APIs. Not string matching. Semantic understanding of your content model.</p><p>Here’s something we should acknowledge: LLMs are good at markdown. They were trained on massive amounts of it. The format is token-efficient compared to JSON and XML. When you ask an agent to write or edit prose, markdown is a reasonable output format. </p><p>This is real. It’s part of why Lee’s migration worked.</p><p>But there is a difference between “good format for LLM I/O” and “good format for content infrastructure.”</p><p>LLMs are also good at SQL (they even now GROQ fairly well when you remind them). That doesn’t mean you should store your database as .sql files in git and have agents grep them. The query language and the storage layer are different concerns.</p><p><a rel="noopener noreferrer" href="https://www.smashingmagazine.com/2022/02/thoughts-on-markdown/" target="_blank">I wrote about this three years ago in Smashing Magazine</a>, before LLMs changed everything. The arguments still hold: you can’t query markdown, structured content is more tinker-able, and hosting content in a database doesn’t mean you own it less. </p><p>What’s changed is that we now have agents that can work with both formats. The question is which architecture sets them up to do more.</p><p>Let&#39;s be fair about scope. Cursor’s setup works for cursor.com right now because:</p><ul><li>Their entire team writes code. &#34;Designers are developers&#34; at Cursor.</li><li>Content has one destination: the website.</li><li>They ship infrequently enough that git workflows are fine.</li><li>They don&#39;t need approval chains, compliance audits, or role-based permissions beyond what GitHub provides.</li><li>Localization is &#34;AI at build time.&#34;</li></ul><p>If your company looks like this, maybe markdown in git is fine. Genuinely.</p><p>But most companies don&#39;t look like this.</p><p>This is what we are seeing every day:</p><ul><li>Content needs to flow to apps, email systems, AI agents, personalization engines. Not just one website.</li><li>You need structured data, not just prose. Product specs. Pricing tables. Configuration. Things that need to be queryable and validated.</li><li>You have governance requirements. &#34;Who changed this and when&#34; needs actual audit trails, not git blame.</li><li>You need real-time collaboration. Multiple people and agents working on the same content simultaneously. Git merge conflicts on prose are miserable for humans and wasteful for agents.</li><li><!--$--><a data-state="closed" href="https://www.sanity.io/glossary/content-operations">Content operations</a><!--/$--> need to scale independently of engineering. Not because your team can’t learn git, but because content velocity shouldn’t be bottlenecked by PR review cycles.</li></ul><p>Cursor is ~50 developers shipping one product website. That context matters.</p><p>The debate shouldn&#39;t be &#34;CMS vs. no CMS.&#34;</p><p>There are definitely parts of the traditional CMS we should nuke into the sun with fire:</p><ul><li>WYSIWYG editors that produce garbage HTML soup</li><li>Page builders that store content as layout blobs (you can&#39;t query &#34;all hero sections&#34; if hero sections are just JSON fragments in a page blob)</li><li><!--$--><a data-state="closed" href="https://www.sanity.io/glossary/webhook">Webhook</a><!--/$--> hell for basic content updates</li><li>&#34;Content modeling&#34; that&#39;s really just &#34;pick from these 15 field types and good luck&#34;</li><li>Revision history that tells you something changed but not what or why</li></ul><p>We can leave these things behind without resorting to git and markdown.</p><p>Rather, the question should be: <strong>is your content infrastructure built for AI to be both author and consumer?</strong></p><p>That means:</p><ul><li><strong>Structured, not flat files.</strong> AI that can reason about typed fields and relationships, not arbitrary strings.</li><li><strong>Queryable, not grep-able.</strong> Real query languages that understand your schema, not regex pattern matching.</li><li><strong>Real-time, not batch.</strong> Content changes shouldn&#39;t require a <!--$--><a data-state="closed" href="https://www.sanity.io/glossary/deployment">deployment</a><!--/$--> to be visible.</li><li><strong>Presentation-agnostic.</strong> No hex colors in your content model. No assumptions about where content renders. Separation of concerns.</li></ul><p>Lee&#39;s frustration was valid: &#34;I don&#39;t want to click through UIs just to update content.&#34;</p><p>The answer is content infrastructure that works the way modern development does. Agents that understand your schema. Queries that express intent. APIs that don&#39;t require you to build a query engine out of grep and find.</p><p>Lee&#39;s post went viral because it resonated. Developers have real frustrations with content management tools that were built for a different era.</p><p>We know. We literally built Sanity because we were angry at the CMS industry (a.k.a “spite-driven development”)</p><p>The answer isn&#39;t to retreat to 2002 and plain text files for agents to parse. It&#39;s to build what actually solves the problem: content infrastructure that AI can read, write, and reason about.</p><p>You shouldn&#39;t build a CMS from scratch with grep and markdown files. You probably shouldn&#39;t have to click through forms to update content either. Both of these can be true.</p><p>The tools exist to have it both ways. Structured content that agents can actually query. Editorial interfaces that don&#39;t require git. Real-time collaboration that doesn&#39;t involve merge conflicts on prose.</p><p>That&#39;s what we&#39;re building. Lee&#39;s post is a good reminder of what happens when we don&#39;t get it right.</p></div></div>
  </body>
</html>
