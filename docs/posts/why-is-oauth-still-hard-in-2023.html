<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nango.dev/blog/why-is-oauth-still-hard">Original</a>
    <h1>Why is OAuth still hard in 2023?</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>OAuth is a standard protocol. Right? And there are client libraries for OAuth 2.0 <a href="https://oauth.net/code/nodejs/">available</a> <a href="https://oauth.net/code/php/">in</a> <a href="https://oauth.net/code/java/">basically</a> <a href="https://oauth.net/code/python/">every</a> <a href="https://oauth.net/code/go/">programming</a> <a href="https://oauth.net/code/rust/">language</a> <a href="https://oauth.net/code/dotnet/">you</a> <a href="https://oauth.net/code/kotlin/">can</a> <a href="https://oauth.net/code/swift/">imagine</a>.</p><p>You might conclude that, armed with a client library, you would be able to implement OAuth for any API in about 10 minutes. Or at least in an hour.</p><p>If you manage, please email us — we’d like to treat you to a delicious dinner and hear how you did it.</p><h4>OAuth in practice</h4><p>We implemented OAuth for the 50 most popular APIs, such as Google (Gmail, Calendar, Sheets etc.), HubSpot, Shopify, Salesforce, Stripe, Jira, Slack, Microsoft (Azure, Outlook, OneDrive), LinkedIn, Facebook and <a href="https://docs.nango.dev/providers">other OAuth APIs.</a>‍</p><p>Our conclusion: The real-world OAuth experience is comparable to JavaScript browser APIs in 2008. There’s a general consensus on how things should be done, but in reality every API has its own interpretation of the standard, implementation quirks, and nonstandard behaviors and extensions. The result: footguns behind every corner.</p><p>If it weren’t so annoying, it would be quite funny. Let’s dive in!</p><h3>Problem 1: The OAuth standard is just too big and complex</h3><blockquote>“This API also uses OAuth 2.0, and we already did that a few weeks ago. I should be done by tomorrow.”</blockquote><p>OAuth is a very big standard. The <a href="https://oauth.net/2/">OAuth 2.0’s official site</a> currently lists 17 different RFCs (documents defining a standard) that together define how OAuth 2 works. They cover everything from the OAuth framework and Bearer tokens to threat models and private key JWTs.</p><p>“But,” I hear you say, “surely not all of these RFCs are relevant for a simple third-party-access token authorization with an API?”</p><ul role="list"><li>OAuth standard: OAuth 2.0 is the default now, but OAuth 1.0a is still used by some (and 2.1 is around the corner). Once you know which one your API uses, move on to:</li><li>Grant type: Do you need `authorization_code`, `client_credentials`, or `device_code`? What do they do, and when should you use each of them? When in doubt, try `authorization_code`.</li><li>Side note: Refresh tokens are also a grant type, but kind of a special one. How they work is standardized, but how you ask for them in the first place is not. More on that later.</li><li>Now that you’re ready for your requests, let’s look at the many (72, to be precise) <a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml">official OAuth parameters</a> with a defined meaning and behavior. Common examples are `prompt`, `scope`, `audience`, `resource`, `assertion`, and `login_hint`. However, in our experience, most API providers seem to be as oblivious to this list as you probably were until now, so don&#39;t worry too much about it.</li></ul><p>If you think this still feels too complicated and like a lot to learn, we tend to agree with you.</p><p>Most teams building public APIs seem to agree as well. Instead of implementing a full OAuth 2.0 subset, they just implement the parts of OAuth they think they need for their API’s use case. This leads to pretty long pages in docs outlining how OAuth works for this particular API. But we have a hard time blaming them; they have only the best intentions in mind for their DX. And if they truly tried to implement the full standard, you’d need to read a small book!</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/63cb480c27e7bc98c7ec69cf/63f730a22a503d3c49cb51f2_Untitled.png" alt=""/></p><figcaption>The Salesforce authorization_code OAuth flow. What&#39;s not to like about a clear visual for this simple 10-step process?</figcaption></figure><p>‍</p><p>The trouble is that everybody has a slightly different idea of which subset of OAuth is relevant for them, so you end up with lots of different (sub-) implementations.</p><p>‍</p><h3>Problem 2: Everybody’s OAuth is different in subtle ways</h3><p>As every API implements a different subset of OAuth, you quickly get into a situation where you are forced to read their long pages of OAuth docs in detail:</p><div><ul>
	<li>Which parameters do they require in the authorize call?
  		<ul>
      	<li>For Jira, the `audience` parameter is key (and must be set to a specific fixed value). Google prefers to handle this through different scopes but really cares about the `prompt` parameter. Meanwhile, somebody at Microsoft discovered the `response_mode` parameter and demands that you always set it to `query`.</li>
        <li>The Notion API takes a radical approach and does away with the ubiquitous `scope` parameter. In fact, you won’t even find the word “scope” in their API docs. Notion calls them “capabilities,” and you set them when you register the app. It took us 30 confused minutes to understand what was going on. Why did they reinvent this wheel?</li>
        <li>It gets worse with `offline_access`: Most APIs these days expire access tokens after a short while. To get a refresh token, you need to request “offline_access,” which needs to be done through a parameter, a scope, or something you set when you register your OAuth app. Ask your API or OAuth doctor for details.</li>
      </ul>
  </li>
  <li>What do they want to see in the token request call?
  		<ul>
      	<li>Some APIs, like Fitbit, insist on getting data in the headers. Most really want it in the body, encoded as `x-www-url-form-encoded`, except for a few, such as Notion, which prefer to get it as JSON.</li>
        <li>Some want you to authenticate this request with Basic auth. Many don’t bother with that. But beware, they may change their mind tomorrow.</li>
      </ul>
  </li>
  <li>Where should I redirect my users to authorize?
  		<ul>
      	<li>Shopify and Zendesk have a model in which every user gets a subdomain like {subdomain}.myshopify.com. And yes, that includes the OAuth authorization page, so you’d better build dynamic URLs into your model and frontend code.</li>
        <li>Zoho Books has different data centers for their customers in different locations. Hopefully, they remember where their data resides: To authorize your app, your U.S. customers should go to https://accounts.zoho.com, Europeans can visit https://accounts.zoho.eu, and Indians are welcome at https://accounts.zoho.in. The list goes on.</li>
      </ul>
  </li>
  <li>But at least I can pick my callback URL, no?
  		<ul>
      	<li>If you enter `http://localhost:3003/callback` as a callback for the Slack API, they kindly remind you to “Please use https for security.” Yes, also for localhost. Luckily <a href="https://www.nango.dev/blog/oauth-redirects-on-localhost-with-https">there are solutions for OAuth redirects on localhost</a>.</li>
      </ul>
  </li>
</ul></div><p>We could go on for a long time, but we think you probably get the point by now.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/63cb480c27e7bc98c7ec69cf/63f7310639759c5c1a13a423_Untitled.png" alt=""/></p><figcaption>OAuth is too complex; let’s make a simpler version of OAuth that has everything we need! ©XKCD</figcaption></figure><h3><strong>Problem 3: Many APIs add nonstandard extensions to OAuth</strong></h3><p>Even though the OAuth standard is vast, many APIs still seem to find gaps in it for features they need. A common issue we see is that you need some data in addition to the `access_token` to work with the API. Wouldn’t it be neat if this additional data could be returned to you together with the access_token in the OAuth flow?</p><p>We actually think this is a good idea — orr at least it’s better than forcing users to do quirky additional API requests afterward to fetch this information (looking at you, Jira). But it does mean more nonstandard behavior that you specifically need to implement for every API.</p><p>Here’s a small list of nonstandard extensions we have seen:</p><ul role="list"><li>Quickbooks employs a `realmID`, which you need to pass in with every API request. The only time they tell you this `realmID` is as an additional parameter in the OAuth callback. Better store it somewhere safe!</li><li>Braintree does the same with a `companyID`</li><li>Salesforce uses a different API base URL for each customer; they call this the `instance_url`. Thankfully, they return the `instance_url` of the user together with the access token in the token response, but you do need to parse it out from there and store it.</li><li>Unfortunately, Salesforce also does even more annoying things: Access tokens expire after a preset period of time, which can be customized by the user. Fine so far, but for some reason they don’t tell you in the token response when the access token you just received will expire (everybody else does this). Instead, you need to query an additional token details endpoint to get the (current) expiration date of the token. Why, Salesforce, why?</li><li>Slack has two different types of scopes: scopes you hold as a Slack bot and scopes that allow you to take action on behalf of the user who authorized your app. Smart, but instead of just adding different scopes for each, they implemented a separate `user_scopes` parameter that you need to pass in the authorization call. You’d better be aware of this, and good luck finding support for this in your OAuth library.</li></ul><p>For the sake of brevity and simplicity, we’re skipping the many not-really-standard OAuth flows we have encountered.</p><h3><strong>Problem 4: “invalid_request” — debugging OAuth flows is hard</strong></h3><p>Debugging distributed systems is always hard. It’s harder when the service you’re working with uses broad, generic error messages.</p><p>OAuth2 has <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-5.2">standardized error messages</a>, but they’re about as useful in telling you what’s going on as the example in the title above (which, by the way, is one of the recommended error messages from the OAuth standard).</p><p>You could argue that OAuth is a standard and that there are docs for every API, so what is there to debug?</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/63cb480c27e7bc98c7ec69cf/63f73156e6f799d425272378_Untitled.png" alt=""/></p><figcaption>How did Randall observe me while I was debugging OAuth flows? ©XKCD</figcaption></figure><p>Some flows also break for, what seem to be, random reasons: LinkedIn OAuth, for instance, breaks if you pass in PKCE parameters. The error you get? “client error - invalid OAuth request.” That is … telling? It took us an hour to understand that passing in (optional, usually disregarded) PKCE parameters is what breaks the flow.</p><p>Another common mistake is sending scopes that don’t match the ones you preregistered with the app. (Preregister scopes? Yes, a lot of APIs these days demand that.) This often results in a generic error message about there being an issue with scopes. Duh.</p><h3><strong>Problem 5: Cumbersome approvals to build on top of APIs</strong></h3><p>The truth is, if you build toward some other system by using their API, you’re probably in the weaker position. Your customers are asking for the integration because they’re already using the other system. Now you need to make them happy.</p><p>To be fair, many APIs are liberal and provide easy self-service signup flows for developers to register their apps and start using OAuth. But some of the most popular APIs out there require reviews before your app becomes public and can be used by any of their users. Again, to be fair, most review processes are sane and can be completed in a few days. They’re probably a net gain in terms of security and quality for end users.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/63cb480c27e7bc98c7ec69cf/63f7318d0ef63f72db1dacd6_Untitled.png" alt=""/></p></figure><p>But some notorious examples can take months to complete, and some even require you to enter into revenue-share agreements:</p><ul role="list"><li>Google requires a “security review” if you want to access scopes with more sensitive user data, such as email contents. We have heard these reviews can take days or weeks to pass and require a nontrivial amount of work on your side.</li><li>Looking to integrate with Rippling? Get ready for their 30-plus questions and security preproduction screening. We hear access takes months (if you are approved).</li><li>HubSpot, Notion, Atlassian, Shopify, and pretty much everybody else who has an integrations marketplace or app store requires a review to get listed there. Some reviews are mild, and some ask you for demo logins, video walkthroughs, blog posts (yes!), and more. However, listing on the marketplace or store is often optional.</li><li>Ramp, Brex, Twitter, and a good number of others don’t have a self-service signup flow for developers and require that you fill in forms for manual access. Many are quick to process requests, but we’re still waiting to hear back from some after weeks.</li><li>Xero is a particularly drastic example of a monetized API: If you want to exceed a limit of 25 connected accounts, you have to <a href="https://developer.xero.com/documentation/xero-app-store/app-partner-guides/app-partner-steps/">become a Xero partner</a> and list your app in their app store. They will then take (as of the time of this writing) a 15% revenue cut from every lead generated from that store.</li></ul><h3><strong>Problem 6: OAuth security is hard and a moving target</strong></h3><p>As attacks have been uncovered, and the available web technologies have evolved, the OAuth standard has changed as well. If you’re looking to implement the current security best practices, the OAuth working group has a <a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics">rather lengthy guide</a> for you. And if you’re working with an API that is still using OAuth 1.0a today, you realize that backwards compatibility is a never-ending struggle.</p><p>Luckily, security is getting better with every iteration, but it often comes at the cost of more work for developers. The upcoming OAuth 2.1 standard will make some current best practices mandatory and includes mandatory PKCE (today only a handful of APIs require this) and additional restrictions for refresh tokens.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/63cb480c27e7bc98c7ec69cf/63f731abb76b0c74fb6f74ee_Untitled.png" alt=""/></p><figcaption>At least OAuth already implements a two-factor auth model. ©XKCD</figcaption></figure><p>The biggest change has probably been ushered in with expiring access tokens and the rise of refresh tokens. On the surface, the process seems simple: Whenever an access token expires, refresh it with the refresh token and store the new access token and refresh token.</p><p>In reality, when we implemented this we had to consider:</p><ul role="list"><li>Race conditions: How can we make sure no other requests run while we refresh the current access token?</li><li>Some APIs also expire the refresh token if you don’t use it for a certain number of days (or if the user has revoked the access). Expect some refreshes to fail.</li><li>Some APIs issue you a new refresh token with every refresh request …</li><li>… but some also silently assume that you will keep the old refresh token and keep on using it.</li><li>Some APIs will tell you the access token expiration time in absolute values. Others only in relative “seconds from now.” And some, like Salesforce, don’t divulge this kind of information easily.</li></ul><h3><strong>Last but not least: Some things we haven’t talked about yet</strong></h3><p>Sadly, we have only just scratched the surface of your OAuth implementation. Now that your OAuth flow runs and you get access tokens, it’s time to think about:</p><ul role="list"><li>How to securely store these access tokens and refresh tokens. They are like passwords to your users’ accounts. But hashing is not an option; you need secure, reversible encryption.</li><li>Checking that the granted scopes match the requested scopes (some APIs allow users to change the scopes they grant in the authorize flow).</li><li>Avoiding race conditions when refreshing tokens.</li><li>Detecting access tokens revoked by the user on the provider side.</li><li>Letting users know that access tokens have expired, so they can re-authorize your app if needed.</li><li>How to revoke access tokens you no longer need (or that the user has requested you delete under GDPR).</li><li>Changes in available OAuth scopes, provider bugs, missing documentation, and so on.</li></ul><h3>A better way?</h3><p>If you’ve read this far, you might be thinking, “There must be a better way!”</p><p>We think there is, which is why we’re building <a href="https://www.nango.dev/">Nango</a>: An <a href="https://github.com/NangoHQ/nango">open-source</a>, self-contained service that comes with prebuilt OAuth flows, secure token storage, and automatic token refreshes <a href="https://docs.nango.dev/providers">for more than 90 OAuth APIs</a>.</p><p>If you give it a try, we’d love to hear your feedback. And if you want to share your worst OAuth horror story with us, we’d love to hear about it in our <a href="https://nango.dev/slack">Slack community</a>.</p><p>Thanks for reading and happy authorizing!</p></div></div></div>
  </body>
</html>
