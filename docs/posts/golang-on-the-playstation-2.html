<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgsilva.com/blog/ps2-go-part-1/">Original</a>
    <h1>Golang on the Playstation 2</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      <figure>
        <img src="https://rgsilva.com/blog/ps2-go-part-1/cover.jpg"/>
      </figure>
      <p>I always wanted to do some weird stuff with consoles. I‚Äôm not sure why, but making devices do unexpected things is always an interesting topic for me. And the same applies to the <a href="https://en.wikipedia.org/wiki/PlayStation_2">PlayStation 2</a>, the 2000 console released by Sony.</p>
<p>Also, Sony, don‚Äôt sue me for this lol</p>
<p>Let‚Äôs get straight into it: I want to run code into consoles (more on <em>why</em> this in a future post). Normally this is done in low(er) level languages, but nowadays we have better and easier to work with languages such as <a href="https://go.dev/">Go</a>. So I was wondering.. why not?</p>
<p>Looking online, however, yielded no easy way of doing this, so I decided to tackle this problem myself.</p>
<blockquote>
<p>Please note that I‚Äôm writing this after a lot of the research here has been done and tested already. This means that a lot of the experimentation here is from memory and from retracing my steps, so there might be inconsistencies here and there.</p>
</blockquote>
<blockquote>
<p>Also note that this is all running inside an emulator. I do own a PS2 that I can test this, but I‚Äôm too lazy to set it up. Plus I want fully functional demos before doing so.</p>
</blockquote>
<blockquote>
<p>Final note: the code will be released at a later point and I‚Äôll update the post accordingly.</p>
</blockquote>
<h2 id="the-challenge">The challenge</h2>
<p>By default, <a href="https://go.dev/wiki/MinimumRequirements">Go only supports a handful of platforms</a>, and unfortunately that does not include the PS2. In fact, Go seems to require an OS behind the scenes, thing that we don‚Äôt even have over there (not considering PS2 Linux). To solve that, however, we have <a href="https://tinygo.org/">TinyGo</a>, a Go compiler for small devices, like microcontrollers and embedded systems. The basic way it works is that it gets the Go code, turns into LLVM IR, and then that into the binary code for whatever target we‚Äôre trying to code for.</p>
<p>The PS2 main CPU is called <a href="https://en.wikipedia.org/wiki/Emotion_Engine">Emotion Engine</a>, which is based on a MIPS R5900. It implements the instructions for MIPS-III and MIPS-IV, plus some custom stuff. It also is missing a few other things (more on that later). Go can actually build code for MIPS already, which should save me some time, but not a lot, as I need to get TinyGo to work on it. TinyGo relies on LLVM 19, which does support MIPS-III, but not the R5900 CPU directly.</p>
<p>These are all technical issues. There‚Äôs a much more pressing one: I don‚Äôt know how the PS2 works.</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-10.png"/><figcaption>
      Well, that should be fun.
    </figcaption>
</figure>
<h2 id="the-ps2dev-sdk-and-its-quirks">The ps2dev SDK and its quirks</h2>
<p>If you look it up online for a way of developing code for the PS2, you‚Äôll probably cross paths with <a href="https://github.com/ps2dev/ps2dev">ps2dev</a>. This is a full-blown SDK that lets you generate binaries for it in a pretty neat way. The coolest thing about it is that it already provides a bunch of libraries for graphical operations, debugging, I/O, etc - even a stdlib is provided! Because of that, I thought: hey, maybe I want to link to their code - this would allow an easier and faster implementation of anything for the PS2 in Go. Think of it as an ‚ÄúOS‚Äù API (technically it‚Äôs not?), which we could call whenever we want to do things we don‚Äôt want to reimplement (or that aren‚Äôt even worth trying sometimes).</p>
<p>That said, this introduces a few problems. The first one is that the ps2dev libraries are compiled to the MIPS-III N32 standard. This means that, whatever code we produce, needs to target the same thing. Same hard-float, same N32 ABI, etc. This is a bit annoying, but manageable. The reason why it needs to match is because we‚Äôll be linking our code to their pre-built libraries, and linkers are not really fond of dealing with different targets.</p>
<blockquote>
<p>For the sake of clarification: MIPS-III N32 means that this is targeting a MIPS CPU that is implementing the MIPS-III instruction set. This is a 64bit CPU, but due to the N32, this is running 32bit code with some 64bit instructions to handle 64bit integers. This is very confusing, but you can check <a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models">this</a> to read more about it.</p>
</blockquote>
<p>Because of this, you‚Äôll see my attempts to target <code>mipsel</code> with a <code>mips3</code> CPU in the next steps, even though it should, technically speaking, be a <code>mips64el</code>, as this is a 64bit CPU. N32 should force things to run in 32bit mode, even though though our target should support 64bit code. However, Clang/LLVM and TinyGo get kinda messy on this and it gets very confusing and complicated. Also, building for <code>mips64el</code> caused TinyGo to failed some verification steps when generating code with the LLVM, as well as clang to refuse to properly build it as the code is kinda broken. Since I <em>really</em> wanted to move forward, I gave up and opted for generating <code>mipsel</code> code with the N32 ABI, which will force clang to change it to a MIPS64 internally, but still generate valid code. Like I said, it‚Äôs very weird. Please bear with me, this is all new to me too! :D</p>
<p>Further reiteration on this topic might be necessary to get this just right, but I‚Äôm not diving into this hell right now. Future-wise we can try dropping ps2dev and doing things directly in Go, but some assembly is required - literally and metaphorically.</p>
<h2 id="getting-tinygo-to-generate-some-code">Getting TinyGo to generate some code</h2>
<p>For TinyGo to know about a certain target, it requires a file defining it - we‚Äôll call it <code>ps2.json</code>. It defines a bunch of very interesting things that we don‚Äôt really care at the moment, but here are the most important ones:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>	<span>&#34;llvm-target&#34;</span>: <span>&#34;mipsel-unknown-unknown&#34;</span>,
</span></span><span><span>	<span>&#34;cpu&#34;</span>: <span>&#34;mips3&#34;</span>,
</span></span><span><span>	<span>&#34;features&#34;</span>: <span>&#34;-noabicalls&#34;</span>,
</span></span><span><span>	<span>&#34;build-tags&#34;</span>: [<span>&#34;ps2&#34;</span>, <span>&#34;baremetal&#34;</span>, <span>&#34;mipsel&#34;</span>],
</span></span><span><span>	<span>&#34;goos&#34;</span>: <span>&#34;linux&#34;</span>,
</span></span><span><span>	<span>&#34;goarch&#34;</span>: <span>&#34;mipsle&#34;</span>,
</span></span><span><span>	<span>&#34;linker&#34;</span>: <span>&#34;ld.lld&#34;</span>,
</span></span><span><span>	<span>&#34;rtlib&#34;</span>: <span>&#34;compiler-rt&#34;</span>,
</span></span><span><span>	<span>&#34;libc&#34;</span>: <span>&#34;&#34;</span>,
</span></span><span><span>	<span>&#34;cflags&#34;</span>: [
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;ldflags&#34;</span>: [
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;linkerscript&#34;</span>: <span>&#34;&#34;</span>,
</span></span><span><span>	<span>&#34;extra-files&#34;</span>: [
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;gdb&#34;</span>: []
</span></span><span><span>}
</span></span></code></pre></div><p>This file is the culmination of many, maaany days testing different configurations. It is only <strong>partially functional</strong>. It cannot generate object files yet (more below), hence the reason why I‚Äôm not bothering to fill in flags for compiling and linking code. There are some relevant things I need to explain, though, so here we go:</p>
<ol>
<li>Target is <code>mipsel-unknown-unknown</code>. This is our LLVM target. I‚Äôm sticking with <code>mipsel</code> here for the reasons I explained previously.</li>
<li>The features have <code>-noabicalls</code>. It is required as otherwise shit hits the fan and nothing works (the LLVM IR that gets generated gets broken).</li>
<li>I‚Äôve set it to not use any <code>libc</code>. This is because ps2dev already provides one, and I don‚Äôt want to mess with that (trust me). Plus, since we‚Äôll be linking to their code, we might as well use their version of it.</li>
</ol>
<p>This is the <em>basic</em> target file we need so that TinyGo at least <em>knows</em> what a PS2 is. But that‚Äôs not all - we need to define a bunch of functions which are target-specific.</p>
<h3 id="baremetal-definitions">Baremetal definitions</h3>
<p>Our target needs a baremetal configuration - <code>baremetal_ps2.go</code>. Usually the <a href="https://github.com/tinygo-org/tinygo/blob/release/src/runtime/baremetal.go">default baremetal file</a> is enough, but in our case I‚Äôve opted to create a custom one so that I can redefine some things.</p>
<blockquote>
<p>Note from the future: this can be improved by adjusting the linker file so it finds the correct externs. I might end up doing that and come back here later on.</p>
</blockquote>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>runtime</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;unsafe&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>//go:extern _heap_start
</span></span></span><span><span><span></span><span>var</span> <span>heapStartSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _heap_end
</span></span></span><span><span><span></span><span>var</span> <span>heapEndSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _fdata
</span></span></span><span><span><span></span><span>var</span> <span>globalsStartSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _edata
</span></span></span><span><span><span></span><span>var</span> <span>globalsEndSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _stack_top
</span></span></span><span><span><span></span><span>var</span> <span>stackTopSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>var</span> (
</span></span><span><span>	<span>heapStart</span>    = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>heapStartSymbol</span>))
</span></span><span><span>	<span>heapEnd</span>      = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>heapEndSymbol</span>))
</span></span><span><span>	<span>globalsStart</span> = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>globalsStartSymbol</span>))
</span></span><span><span>	<span>globalsEnd</span>   = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>globalsEndSymbol</span>))
</span></span><span><span>	<span>stackTop</span>     = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>stackTopSymbol</span>))
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>growHeap</span>() <span>bool</span> {
</span></span><span><span>	<span>// On baremetal, there is no way the heap can be grown.
</span></span></span><span><span><span></span>	<span>return</span> <span>false</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>//export runtime_putchar
</span></span></span><span><span><span></span><span>func</span> <span>runtime_putchar</span>(<span>c</span> <span>byte</span>) {
</span></span><span><span>	<span>putchar</span>(<span>c</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>//go:linkname syscall_Exit syscall.Exit
</span></span></span><span><span><span></span><span>func</span> <span>syscall_Exit</span>(<span>code</span> <span>int</span>) {
</span></span><span><span>  	<span>// TODO
</span></span></span><span><span><span></span>	<span>exit</span>(<span>code</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>const</span> <span>baremetal</span> = <span>true</span>
</span></span><span><span>
</span></span><span><span><span>var</span> <span>timeOffset</span> <span>int64</span>
</span></span><span><span>
</span></span><span><span><span>//go:linkname now time.now
</span></span></span><span><span><span></span><span>func</span> <span>now</span>() (<span>sec</span> <span>int64</span>, <span>nsec</span> <span>int32</span>, <span>mono</span> <span>int64</span>) {
</span></span><span><span>	<span>mono</span> = <span>nanotime</span>()
</span></span><span><span>	<span>sec</span> = (<span>mono</span> <span>+</span> <span>timeOffset</span>) <span>/</span> (<span>1000</span> <span>*</span> <span>1000</span> <span>*</span> <span>1000</span>)
</span></span><span><span>	<span>nsec</span> = int32((<span>mono</span> <span>+</span> <span>timeOffset</span>) <span>-</span> <span>sec</span><span>*</span>(<span>1000</span><span>*</span><span>1000</span><span>*</span><span>1000</span>))
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>AdjustTimeOffset</span>(<span>offset</span> <span>int64</span>) {
</span></span><span><span>	<span>timeOffset</span> <span>+=</span> <span>offset</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>var</span> <span>errno</span> <span>int32</span>
</span></span><span><span>
</span></span><span><span><span>//export __errno_location
</span></span></span><span><span><span></span><span>func</span> <span>libc_errno_location</span>() <span>*</span><span>int32</span> {
</span></span><span><span>	<span>return</span> <span>&amp;</span><span>errno</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Do we need to understand how most of this works? No, we don‚Äôt. Not only that, most of this is copy-paste from the normal <code>baremetal.go</code> implementation. We can adjust later if necessary, no worries. Like I said, we mostly need this to <em>build</em>, so that we can figure out what is wrong and fix it accordingly.</p>
<blockquote>
<p>Note: for this to work, you still need to disable the building of the original <code>baremetal.go</code> for our target, so we need to change its build flag to <code>//go:build baremetal &amp;&amp; !ps2</code>.</p>
</blockquote>
<h3 id="runtime">Runtime</h3>
<p>Our target needs a runtime definitions file - <code>runtime_ps2.go</code>. This is the place where a bunch of target-specific functions get defined, including how <code>putchar</code>, <code>exit</code> and even <code>main</code> (later) gets implemented. Pretty cool part of the code if I‚Äôd say so.</p>
<p>A very basic implementation would look like this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>runtime</span>
</span></span><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>extern void _exit(int status);
</span></span></span><span><span><span>extern void* malloc(unsigned int size);
</span></span></span><span><span><span>extern void free(void *ptr);
</span></span></span><span><span><span>extern void scr_printf(const char *format, ...);
</span></span></span><span><span><span>*/</span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>import</span> <span>&#34;unsafe&#34;</span>
</span></span><span><span>
</span></span><span><span><span>// timeUnit in nanoseconds
</span></span></span><span><span><span></span><span>type</span> <span>timeUnit</span> <span>int64</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>initUART</span>() {
</span></span><span><span>  <span>// Unsupported.
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>putchar</span>(<span>c</span> <span>byte</span>) {
</span></span><span><span>	<span>// This is a very hacky way of doing this. It assumes the debug screen is already active, and prints
</span></span></span><span><span><span></span>	<span>// a whole string for a single char every single time. Very slow, but works. We can improve it later.
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>x</span> <span>:=</span> <span>C</span>.<span>CString</span>(string(<span>c</span>))
</span></span><span><span>	<span>C</span>.<span>scr_printf</span>(<span>x</span>)
</span></span><span><span>	<span>C</span>.<span>free</span>(<span>unsafe</span>.<span>Pointer</span>(<span>x</span>))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>getchar</span>() <span>byte</span> {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>buffered</span>() <span>int</span> {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>sleepWDT</span>(<span>period</span> <span>uint8</span>) {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>exit</span>(<span>code</span> <span>int</span>) {
</span></span><span><span>  	<span>// This just delegates it to the ps2dev _exit(int) function.
</span></span></span><span><span><span></span>	<span>C</span>.<span>_exit</span>(<span>C</span>.int(<span>code</span>))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>abort</span>() {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ticksToNanoseconds</span>(<span>ticks</span> <span>timeUnit</span>) <span>int64</span> {
</span></span><span><span>  	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> int64(<span>ticks</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>nanosecondsToTicks</span>(<span>ns</span> <span>int64</span>) <span>timeUnit</span> {
</span></span><span><span>  	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>timeUnit</span>(<span>ns</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>sleepTicks</span>(<span>d</span> <span>timeUnit</span>) {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ticks</span>() (<span>ticksReturn</span> <span>timeUnit</span>) {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span></code></pre></div><p>A lot of it is not implemented, and this is intentional - I won‚Äôt be using those things at the moment, so I don‚Äôt care about them. We can later implement them accordingly, and get them to work as expected. Some of them might be even doable through ps2dev‚Äôs C functions, for example.</p>
<h3 id="interrupts">Interrupts</h3>
<p>Another basic file we need is the interrupts defintions - <code>interrupt_ps2.go</code>. I know that ps2dev has implementations for those calls, but I‚Äôve opted to not call them yet. At this moment, we don‚Äôt need interrupts, so let‚Äôs just implement dummy functions for that:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>interrupt</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>State</span> <span>uintptr</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Disable</span>() (<span>state</span> <span>State</span>) {
</span></span><span><span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Restore</span>(<span>state</span> <span>State</span>) {}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>In</span>() <span>bool</span> {
</span></span><span><span>	<span>return</span> <span>false</span>
</span></span><span><span>}
</span></span></code></pre></div><p>With that, we <em>should</em> be able to build some Go code. So let‚Äôs give it a try.</p>
<h2 id="calling-go-functions-from-c">Calling Go functions from C</h2>
<p>Let‚Äôs start with a simple example: get our C code to return a number and a string. Nothing major. We‚Äôll split this into 2 parts: the loader (in C) and our Go code. It will work like this:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-2.png"/><figcaption>
      It works!
    </figcaption>
</figure>
<p>Here‚Äôs our Go code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//export aGoString
</span></span></span><span><span><span></span><span>func</span> <span>aGoString</span>() <span>*</span><span>C</span>.<span>char</span> {
</span></span><span><span>	<span>return</span> <span>C</span>.<span>CString</span>(<span>&#34;The answer for everything is&#34;</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>//export aGoNumber
</span></span></span><span><span><span></span><span>func</span> <span>aGoNumber</span>() <span>C</span>.<span>int</span> {
</span></span><span><span>	<span>return</span> <span>C</span>.int(<span>42</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>And our loader, which contains our <code>main</code> function:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>// Our go functions, exported before.
</span></span></span><span><span><span></span><span>extern</span> <span>char</span><span>*</span> <span>aGoString</span>();
</span></span><span><span><span>extern</span> <span>int</span> <span>aGoNumber</span>();
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>  <span>// Initialize our debug screen.
</span></span></span><span><span><span></span>  <span>sceSifInitRpc</span>(<span>0</span>);
</span></span><span><span>  <span>init_scr</span>();
</span></span><span><span>
</span></span><span><span>  <span>// Print stuff we get from Go functions.
</span></span></span><span><span><span></span>  <span>scr_printf</span>(<span>&#34;%s: %d</span><span>\n</span><span>&#34;</span>, <span>aGoString</span>(), <span>aGoNumber</span>());
</span></span><span><span>
</span></span><span><span>  <span>// Infinite loop so we keep the program running.
</span></span></span><span><span><span></span>  <span>while</span> (<span>1</span>) {}
</span></span><span><span>
</span></span><span><span>  <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Very simple code, right? Let‚Äôs build it.</p>
<p>Well, no, wait. There‚Äôs a problem. TinyGo, by default, wants you to generate the final ELF (<code>.elf</code>) or the object file (<code>.o</code>) with it. However, the ELF requires adding a linkfile and some other extra bits of code to it, which we‚Äôre far from. For now, we just want to get some functions in a way that we can link - so we should be able to just use the object file.</p>
<p>However, attempting to do so generates an incorrect file:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o test.o
</span></span><span><span>$ file test.o
</span></span><span><span>test.o: ELF 32-bit LSB relocatable, MIPS, MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, with debug_info, not stripped
</span></span></code></pre></div><figcaption>
  Note the missing `N32` in the string
</figcaption>
<p>I thought: oh, ok, we‚Äôre just missing the proper <code>cflags</code> and <code>ldflags</code> here, right? So let‚Äôs try adding it:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>	<span>// (...)
</span></span></span><span><span><span></span>	<span>&#34;cflags&#34;</span>: [
</span></span><span><span>		<span>&#34;-mabi=n32&#34;</span>
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;ldflags&#34;</span>: [
</span></span><span><span>		<span>&#34;-mabi=n32&#34;</span>
</span></span><span><span>	],
</span></span><span><span>	<span>// (...)
</span></span></span></code></pre></div><figcaption>
  These might not be the right flags, but according to some docs it seems like it is.
</figcaption>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o test.o
</span></span><span><span>$ file test.o                                        
</span></span><span><span>test.o: ELF 32-bit LSB relocatable, MIPS, MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, with debug_info, not stripped
</span></span></code></pre></div><p>Oh. Ok then.</p>
<p>Since TinyGo is, for some reason, not playing nice here, I‚Äôve opted for breaking this into steps that I can more easily control. TinyGo internally will generating some LLVM IR from your Go code, and then build it. Let‚Äôs stop at the LLVM IR level then:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o build/go.ll
</span></span></code></pre></div><p>This will generate a valid LLVM IR file! üéâ Now we can just manually build it into the object file with the format we want:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ clang -fno-pic -c --target<span>=</span>mips64el -mcpu<span>=</span>mips3 -fno-inline-functions -mabi<span>=</span>n32 -mhard-float -mxgot -mlittle-endian -o build/go.o build/go.ll
</span></span></code></pre></div><p>The flags here are important. Our target is a MIPS64 (only TinyGo is not happy with it), Little Endian, with the MIPS-III instruction set, using the N32 ABI. It uses hardware floating numbers, and the <code>-fno-pic</code> and <code>-mxgot</code> is to deal with a global offset table size limit issue when linking. With all that, here‚Äôs what we get:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ file build/go.o
</span></span><span><span>build/go.o: ELF 32-bit LSB relocatable, MIPS, N32 MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, with debug_info, not stripped
</span></span></code></pre></div><figcaption>
  Finally!
</figcaption>
<p>From here, we can link with our C code. For that, I‚Äôve opted to use the ps2dev linking command (extracted from the Makefile and some testing), with our Go code added into it:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>mips64r5900el-ps2-elf-gcc <span>\
</span></span></span><span><span><span></span>	-Tlinkfile <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ee/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ports/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/gsKit/lib/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34bt/ee/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34usb/ee/ <span>\
</span></span></span><span><span><span></span>	-Wl,-zmax-page-size<span>=</span><span>128</span> <span>\
</span></span></span><span><span><span></span>	-lpatches <span>\
</span></span></span><span><span><span></span>	-lfileXio <span>\
</span></span></span><span><span><span></span>	-lpad <span>\
</span></span></span><span><span><span></span>	-ldebug <span>\
</span></span></span><span><span><span></span>	-lmath3d <span>\
</span></span></span><span><span><span></span>	-ljpeg <span>\
</span></span></span><span><span><span></span>	-lfreetype <span>\
</span></span></span><span><span><span></span>	-lgskit_toolkit <span>\
</span></span></span><span><span><span></span>	-lgskit <span>\
</span></span></span><span><span><span></span>	-ldmakit <span>\
</span></span></span><span><span><span></span>	-lpng <span>\
</span></span></span><span><span><span></span>	-lz <span>\
</span></span></span><span><span><span></span>	-lmc <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lelf-loader <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lc <span>\
</span></span></span><span><span><span></span>	-mhard-float <span>\
</span></span></span><span><span><span></span>	-msingle-float <span>\
</span></span></span><span><span><span></span>	-o build/main.elf <span>\
</span></span></span><span><span><span></span>	build/loader.o <span>\
</span></span></span><span><span><span></span>	build/asm_mipsx.o <span>\
</span></span></span><span><span><span></span>	build/go.o
</span></span></code></pre></div><figcaption>
  Loader is our C code, and Go is our.. well, Go code.
</figcaption>
<blockquote>
<p>Note: the <code>asm_mipsx.o</code> is some assembly code provided by TinyGo that I just copied into the project and built with clang. You can find it <a href="https://github.com/tinygo-org/tinygo/blob/release/src/runtime/asm_mipsx.S">here</a>.</p>
</blockquote>
<p>And, with that, we build our new application!</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ file build/main.elf
</span></span><span><span>build/main.elf: ELF 32-bit LSB executable, MIPS, N32 MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, statically linked, with debug_info, not stripped
</span></span></code></pre></div><p>And running it yields success:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-3.png"/><figcaption>
      It works! This is PCSX2 v2.3.223 btw.
    </figcaption>
</figure>
<h2 id="switching-to-gos-main">Switching to Go‚Äôs main</h2>
<p>Right now the <code>main</code> function that is being called is not in Go, but in C - that is what we‚Äôve been calling <em>loader</em> so far. However, Go applications can start by themselves without a C-based loader - and it would be great if our <del>games</del> PS2 applications would so!</p>
<h3 id="runtime-changes">Runtime changes</h3>
<p>The first step to allowing Go applications to run without our loader is to have the <code>main</code> function exposed by Go. We can do that in our <code>runtime_ps2.go</code>:</p>
<pre tabindex="0"><code>//export main
func main() {
	preinit()
	run()
	preexit()
	exit(0)
}

const (
	memSize = uint(24 * 1024 * 1024)
)

var (
	goMemoryAddr uintptr
)

func preinit() {
	// NOTE: no need to clear .bss and other memory areas as crt0 is already doing that in __start.

	// Since we&#39;re loading into whatever ps2dev kernel thingy that exists, it&#39;s safer for us to do
	// a proper malloc before proceeding. This guarantees that the heap location is ours. We will
	// need to free it later on though.

	goMemoryAddr = uintptr(unsafe.Pointer(C.malloc(C.uint(memSize))))
	heapStart = goMemoryAddr
	heapEnd = goMemoryAddr + uintptr(memSize)
}

func preexit() {
	C.free(unsafe.Pointer(heapStart))
}
</code></pre><p>There are some important things to note here:</p>
<ol>
<li>The heap start and end could be defined by the linker file. And, ironically, they are. However, the <code>crt0</code> provided by ps2dev will clear those variables for some reason, making it kinda broken.
<ol>
<li>We could just assume that anything above a certain memory address is ours, <em>buuuut</em> ps2dev may want to play with more memory and I don‚Äôt want to deal with this right now.</li>
<li>We‚Äôll allocate the memory using ps2dev‚Äôs <code>malloc</code> as per stated in the code. This will guarantee that this memory area is ours - if the libraries need more, they should still have some memory left, as the PS2 should have 32MB and we‚Äôre allocating 24MB only.</li>
<li>Technically speaking we could make the heap grow per demand - but that‚Äôs a problem for future me.</li>
</ol>
</li>
<li>We‚Äôll intentionally unallocate the memory after usage. Not really required, but <em>just in case</em>.</li>
<li>The <code>run</code> function is responsible for calling our <code>main</code> function inside our <code>main</code> package. This is not something we need to deal with - TinyGo‚Äôs code does that for us, we just need to call it.</li>
</ol>
<p>It works basically like this:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-4.png"/><figcaption>
      Exitpoint is even a word?!
    </figcaption>
</figure>
<p>This is technically a mixed approach: it‚Äôs both baremetal - because it runs without a proper OS - but it‚Äôs also not - because it allocates memory, enters and exits application.</p>
<p>Fun fact: once the code exits, it shows the memory card selection screen!</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-5.png"/>
</figure>
<h3 id="our-go-code">Our Go code</h3>
<p>Let‚Äôs code something in Go then. First step is to have something to call, so let‚Äôs create a package called <code>debug</code> with the debug screen functions:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>debug</span>
</span></span><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>extern void free(void *ptr);
</span></span></span><span><span><span>extern void sceSifInitRpc(int mode);
</span></span></span><span><span><span>extern void init_scr(void);
</span></span></span><span><span><span>extern void scr_printf(const char *format, ...);
</span></span></span><span><span><span>*/</span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;unsafe&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Init</span>() {
</span></span><span><span>	<span>C</span>.<span>sceSifInitRpc</span>(<span>0</span>)
</span></span><span><span>	<span>C</span>.<span>init_scr</span>()
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Printf</span>(<span>format</span> <span>string</span>, <span>args</span> <span>...</span><span>interface</span>{}) {
</span></span><span><span>	<span>formatted</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>format</span>, <span>args</span><span>...</span>)
</span></span><span><span>
</span></span><span><span>	<span>str</span> <span>:=</span> <span>C</span>.<span>CString</span>(<span>formatted</span>)
</span></span><span><span>	<span>C</span>.<span>scr_printf</span>(<span>str</span>)
</span></span><span><span>	<span>C</span>.<span>free</span>(<span>unsafe</span>.<span>Pointer</span>(<span>str</span>))
</span></span><span><span>}
</span></span></code></pre></div><blockquote>
<p>Yes, there is an <code>extern</code> for the <code>free</code> function which could be replaced by stdlib. I‚Äôve avoided that at the moment as that requires adding some C flags for include paths and that made it messy. Here‚Äôs how it looks like with it:</p>
<pre tabindex="0"><code>/*
#cgo CFLAGS: -I/Users/ricardo/dev/ps2dev/ee/mips64r5900el-ps2-elf/include -I/Users/ricardo/dev/ps2dev/ee/lib/gcc/mips64r5900el-ps2-elf/14.2.0/include/ -I/Users/ricardo/dev/ps2dev/gsKit/include -I/Users/ricardo/dev/ps2dev/ps2sdk/common/include -I/Users/ricardo/dev/ps2dev/ps2sdk/ports/include/freetype2 -I/Users/ricardo/dev/ps2dev/ps2sdk/ports/include/zlib
#include &lt;stdlib.h&gt;

extern void sceSifInitRpc(int mode);
extern void init_scr(void);
extern void scr_printf(const char *format, ...);
*/
</code></pre><p>This can be improved by moving those flags externally to the build process but that‚Äôs a problem for future me once this gets released.</p>
</blockquote>
<p>Overall, this is nothing too crazy - it‚Äôs just the normal debug functions exposed by ps2dev (declared <a href="https://ps2dev.github.io/ps2sdk/ee_2debug_2include_2debug_8h.html">here</a> and implemented <a href="https://github.com/ps2dev/ps2sdk/blob/master/ee/debug/src/scr_printf.c">here</a>). And then we just call it:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;ps2go/debug&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>debug</span>.<span>Init</span>()
</span></span><span><span>
</span></span><span><span>	<span>debug</span>.<span>Printf</span>(<span>&#34;Hello world from Go!\n&#34;</span>)
</span></span><span><span>	<span>debug</span>.<span>Printf</span>(<span>`
</span></span></span><span><span><span>   ____                                _                           
</span></span></span><span><span><span>  / ___| ___    _ __ _   _ _ __  _ __ (_)_ __   __ _    ___  _ __  
</span></span></span><span><span><span> | |  _ / _ \  | &#39;__| | | | &#39;_ \| &#39;_ \| | &#39;_ \ / _&#39; |  / _ \| &#39;_ \ 
</span></span></span><span><span><span> | |_| | (_) | | |  | |_| | | | | | | | | | | | (_| | | (_) | | | |
</span></span></span><span><span><span>  \____|\___/  |_|   \__,_|_| |_|_| |_|_|_| |_|\__, |  \___/|_| |_|
</span></span></span><span><span><span>    ____  _             ____  _        _   _   |___/       ____    
</span></span></span><span><span><span>   |  _ \| | __ _ _   _/ ___|| |_ __ _| |_(_) ___  _ __   |___ \   
</span></span></span><span><span><span>   | |_) | |/ _&#39; | | | \___ \| __/ _&#39; | __| |/ _ \| &#39;_ \    __) |  
</span></span></span><span><span><span>   |  __/| | (_| | |_| |___) | || (_| | |_| | (_) | | | |  / __/   
</span></span></span><span><span><span>   |_|   |_|\__,_|\__, |____/ \__\__,_|\__|_|\___/|_| |_| |_____|  
</span></span></span><span><span><span>                  |___/                                            
</span></span></span><span><span><span>`</span>)
</span></span><span><span>	<span>for</span> {
</span></span><span><span>		<span>// Infinite loop to not exit!
</span></span></span><span><span><span></span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Fancy, no? Let‚Äôs build the code and see what happens:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o build/go.ll
</span></span><span><span>$ clang -fno-pic -c --target<span>=</span>mips64el -mcpu<span>=</span>mips3 -fno-inline-functions -mabi<span>=</span>n32 -mhard-float -mxgot -mlittle-endian -o build/go.o build/go.ll
</span></span><span><span>$ mips64r5900el-ps2-elf-gcc <span>\
</span></span></span><span><span><span></span>	-Tlinkfile <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ee/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ports/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/gsKit/lib/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34bt/ee/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34usb/ee/ <span>\
</span></span></span><span><span><span></span>	-Wl,-zmax-page-size<span>=</span><span>128</span> <span>\
</span></span></span><span><span><span></span>	-lpatches <span>\
</span></span></span><span><span><span></span>	-lfileXio <span>\
</span></span></span><span><span><span></span>	-lpad <span>\
</span></span></span><span><span><span></span>	-ldebug <span>\
</span></span></span><span><span><span></span>	-lmath3d <span>\
</span></span></span><span><span><span></span>	-ljpeg <span>\
</span></span></span><span><span><span></span>	-lfreetype <span>\
</span></span></span><span><span><span></span>	-lgskit_toolkit <span>\
</span></span></span><span><span><span></span>	-lgskit <span>\
</span></span></span><span><span><span></span>	-ldmakit <span>\
</span></span></span><span><span><span></span>	-lpng <span>\
</span></span></span><span><span><span></span>	-lz <span>\
</span></span></span><span><span><span></span>	-lmc <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lelf-loader <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lc <span>\
</span></span></span><span><span><span></span>	-mhard-float <span>\
</span></span></span><span><span><span></span>	-msingle-float <span>\
</span></span></span><span><span><span></span>	-o build/main.elf <span>\
</span></span></span><span><span><span></span>	build/asm_mipsx.o <span>\
</span></span></span><span><span><span></span>	build/go.o
</span></span></code></pre></div><figcaption>
  Easy, no?
</figcaption>
<p>That builds the ELF file. Now let‚Äôs load it in the emulator and see what happens!</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-6.png"/><figcaption>
      Yeeeeeeeeey!
    </figcaption>
</figure>
<p>Success! üéâ</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-9.png"/><figcaption>
      Gotta love memes
    </figcaption>
</figure>
<h2 id="the-ddivu-problem">The DDIVU problem</h2>
<p>While testing some basic functionality, I‚Äôve noticed that <code>fmt.Sprintf</code> didn‚Äôt work properly. Look at this very simple basic code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>debug</span>.<span>Init</span>()
</span></span><span><span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>-</span><span>32</span>; <span>i</span> <span>&lt;=</span> <span>32</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>debug</span>.<span>Printf</span>(<span>&#34;%02d, &#34;</span>, <span>i</span>)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>for</span> {
</span></span><span><span>		<span>// Infinite loop to not exit!
</span></span></span><span><span><span></span>	}
</span></span><span><span>}
</span></span></code></pre></div><figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-7.png"/><figcaption>
      Errr this is awkward
    </figcaption>
</figure>
<p>Ok, this is not normal. The numbers between <code>-9</code> and <code>+9</code> are correct, while everything else is wrong. This specific problem took me <em>days</em> to figure out what the hell was going on. I eventually narrowed it down to <a href="https://cs.opensource.google/go/go/+/master:src/fmt/format.go;l=243-249?q=fmtinteger&amp;ss=go%2Fgo">this</a> part of the <code>fmtInteger</code> implementation, used by <code>Sprintf</code> inside the <code>fmt</code> package:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> (<span>f</span> <span>*</span><span>fmt</span>) <span>fmtInteger</span>(<span>u</span> <span>uint64</span>, <span>base</span> <span>int</span>, <span>isSigned</span> <span>bool</span>, <span>verb</span> <span>rune</span>, <span>digits</span> <span>string</span>) {
</span></span><span><span>	<span>// (... bunch of code here ...)
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>switch</span> <span>base</span> {
</span></span><span><span>	<span>case</span> <span>10</span>:
</span></span><span><span>		<span>for</span> <span>u</span> <span>&gt;=</span> <span>10</span> {
</span></span><span><span>			<span>i</span><span>--</span>
</span></span><span><span>			<span>next</span> <span>:=</span> <span>u</span> <span>/</span> <span>10</span>
</span></span><span><span>			<span>buf</span>[<span>i</span>] = byte(<span>&#39;0&#39;</span> <span>+</span> <span>u</span> <span>-</span> <span>next</span><span>*</span><span>10</span>)
</span></span><span><span>			<span>u</span> = <span>next</span>
</span></span><span><span>		}
</span></span><span><span>
</span></span><span><span>	<span>// (... bunch of code here ...)
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>Look at how TinyGo is generating the LLVM IR code for that:</p>
<pre tabindex="0"><code>!875 = !DIFile(filename: &#34;format.go&#34;, directory: &#34;/usr/local/go/src/fmt&#34;)
!15696 = !DILocalVariable(name: &#34;next&#34;, scope: !15679, file: !875, line: 243, type: !373)

; (...)

lookup.next:                                      ; preds = %for.body
  %31 = udiv i64 %27, 10, !dbg !15759
    #dbg_value(i64 %31, !15696, !DIExpression(), !15757)
  %.neg = mul i64 %31, 246, !dbg !15760
  %32 = add i64 %27, 48, !dbg !15761
  %33 = add i64 %32, %.neg, !dbg !15762
  %34 = trunc i64 %33 to i8, !dbg !15763
  %35 = getelementptr inbounds i8, ptr %.pn75, i32 %30, !dbg !15758
  store i8 %34, ptr %35, align 1, !dbg !15758
    #dbg_value(i64 %31, !15696, !DIExpression(), !15764)
    #dbg_value(i64 %31, !15684, !DIExpression(), !15765)
  br label %for.loop, !dbg !15700
</code></pre><figcaption>
  Hopefully this is the right section of the code lol
</figcaption>
<p>Which all seems just fine. Looking deeper into it, there‚Äôs this specific thing: <code>udiv i64 %27, 10</code> - this is a unsigned division of a 64bit integer by 10. Keep that 64bit part in mind.</p>
<p>This generates the following MIPS assembly code:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>.LBB139_23:                             <span># %lookup.next
</span></span></span><span><span><span></span>                                        <span>#   in Loop: Header=BB139_19 Depth=1
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:i &lt;- [DW_OP_plus_uconst 176] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:u &lt;- [DW_OP_plus_uconst 184] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:negative &lt;- [DW_OP_plus_uconst 332] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:digits &lt;- [DW_OP_LLVM_fragment 32 32] 17
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:base &lt;- [DW_OP_plus_uconst 316] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:verb &lt;- [DW_OP_plus_uconst 312] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:digits &lt;- [DW_OP_plus_uconst 308, DW_OP_LLVM_fragment 0 32] [$sp+0]
</span></span></span><span><span><span></span>	<span>.loc</span>	<span>129</span> <span>0</span> <span>7</span> <span>is_stmt</span> <span>0</span>               <span># format.go:0:7
</span></span></span><span><span><span></span>	<span>lw</span>	<span>$1</span>, <span>176</span>(<span>$sp</span>)                    <span># 4-byte Folded Reload
</span></span></span><span><span><span></span>	<span>lw</span>	<span>$4</span>, <span>272</span>(<span>$sp</span>)                    <span># 4-byte Folded Reload
</span></span></span><span><span><span></span>	<span>ld</span>	<span>$3</span>, <span>184</span>(<span>$sp</span>)                    <span># 8-byte Folded Reload
</span></span></span><span><span><span></span>	<span>daddiu</span>	<span>$2</span>, <span>$zero</span>, <span>10</span>
</span></span><span><span>	<span>.loc</span>	<span>129</span> <span>243</span> <span>14</span> <span>is_stmt</span> <span>1</span>            <span># format.go:243:14
</span></span></span><span><span><span></span>	<span>ddivu</span>	<span>$zero</span>, <span>$3</span>, <span>$2</span>
</span></span><span><span>	<span>teq</span>	<span>$2</span>, <span>$zero</span>, <span>7</span>
</span></span><span><span>	<span>mflo</span>	<span>$2</span>
</span></span></code></pre></div><p>Let‚Äôs ignore most of this and focus on one specific thing: <code>ddivu $zero, $3, $2</code>. Looks correct, right?</p>
<p>Well‚Ä¶ let‚Äôs look into how PCSX2 loads this:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-8.png"/><figcaption>
      ??????
    </figcaption>
</figure>
<p>Yep. PCSX2 doesn‚Äôt see the <code>DDIVU</code> instruction. Or, more specifically, <em>the PlayStation</em>  doesn‚Äôt see it.</p>



<p>The <code>DDIVU</code> (doubleword divide unsigned) is a instruction defined in MIPS-III (<a href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf">source</a>) responsible for doing the division of 2 unsigned 64bit integers.</p>
<p>However, that doesn‚Äôt work in the PS2, as we saw before. You see, the <code>DDIVU</code> instruction is not defined (<a href="https://psi-rockin.github.io/ps2tek/">source</a>) in the PS2 MIPS instruction set - only <code>DIVU</code> is. This introduces a major problem, as now all <code>int64</code> (with <code>DDIV</code>) and <code>uint64</code> (with <code>DDIVU</code>) divisions won‚Äôt execute - or will execute incorrectly if it ends up matching some other instruction. We need to avoid that, and either split this division inside the Go compiler in a way that would not do the 64bit version of it, or modify the LLVM so that it won‚Äôt use this instruction, even on a <code>mips3</code> CPU. Or maybe we can implement a custom CPU inside the LLVM - the <code>r5900</code>, like ps2dev‚Äôs GCC.</p>
<h3 id="finding-a-way-out">Finding a way out</h3>
<p>My first thought was ‚Äúoh, let‚Äôs adapt this in the LLVM‚Äù. But, and I‚Äôm not gonna lie to you, changing that code is <em>hell</em>. It‚Äôs very complex and requires a ton of changes and most of the time it even requires full rebuild of the LLVM project. I‚Äôm just too lazy for that. So I‚Äôve opted for the terrible approach of doing this inside TinyGo‚Äôs compiler.</p>
<p>The first step is to <em>have</em> a 64bit division code. According to my good friend ChatGPT (<em>who has never been wrong before /s</em>), whenever 64bit division is not available (like in the R5900), GCC uses an auxiliary function called <code>__udivdi3</code>:</p>
<pre tabindex="0"><code>uint64_t __udivdi3(uint64_t a, uint64_t b);
</code></pre><p>So my thought was: oh, I can just map the uint64 division to this then. The first step is to add this as something that is available on our <code>runtime_ps2.go</code> (because I‚Äôm too lazy to do the full proper call):</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>runtime</span>
</span></span><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>extern long __divdi3(long a, long b);
</span></span></span><span><span><span>extern unsigned long __udivdi3 (unsigned long a, unsigned long b);
</span></span></span><span><span><span>extern long __moddi3(long a, long b);
</span></span></span><span><span><span>extern unsigned long __umoddi3(unsigned long a, unsigned long b);
</span></span></span><span><span><span>*/</span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>int64div</span>(<span>a</span>, <span>b</span> <span>int64</span>) <span>int64</span> {
</span></span><span><span>	<span>return</span> int64(<span>C</span>.<span>__divdi3</span>(<span>C</span>.<span>long</span>(<span>a</span>), <span>C</span>.<span>long</span>(<span>b</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>uint64div</span>(<span>a</span>, <span>b</span> <span>uint64</span>) <span>uint64</span> {
</span></span><span><span>	<span>return</span> uint64(<span>C</span>.<span>__udivdi3</span>(<span>C</span>.<span>ulong</span>(<span>a</span>), <span>C</span>.<span>ulong</span>(<span>b</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>int64mod</span>(<span>a</span>, <span>b</span> <span>int64</span>) <span>int64</span> {
</span></span><span><span>	<span>return</span> int64(<span>C</span>.<span>__moddi3</span>(<span>C</span>.<span>long</span>(<span>a</span>), <span>C</span>.<span>long</span>(<span>b</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>uint64mod</span>(<span>a</span>, <span>b</span> <span>uint64</span>) <span>uint64</span> {
</span></span><span><span>	<span>return</span> uint64(<span>C</span>.<span>__umoddi3</span>(<span>C</span>.<span>ulong</span>(<span>a</span>), <span>C</span>.<span>ulong</span>(<span>b</span>)))
</span></span><span><span>}
</span></span></code></pre></div><p>Then, we need to modify TinyGo‚Äôs compiler to use it. That is simpler than it sounds - <a href="https://github.com/tinygo-org/tinygo/blob/3e60eeb368f25f237a512e7553fd6d70f36dc74c/compiler/compiler.go#L2514-L2566">it‚Äôs all handled here</a>.</p>
<p>Let‚Äôs start with the unsigned operations:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateUDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateURem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>will then become:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;uint64div&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateUDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;uint64mod&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateURem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Then we just rebuild the TinyGo‚Äôs compiler with a <code>make</code>, and rebuild our application. Let‚Äôs retest our previous code:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-11.png"/><figcaption>
      Fuck yeah!
    </figcaption>
</figure>
<p>And for our <code>int64</code> operations as well please. From the following code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateSDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateSRem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>we adapt it into this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;int64div&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateSDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;int64mod&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateSRem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Finally, we can test our changes by doing this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>debug</span>.<span>Printf</span>(<span>&#34;\n\n&#34;</span>)
</span></span><span><span><span>for</span> <span>i</span> <span>:=</span> int64(<span>-</span><span>8</span>); <span>i</span> <span>&lt;=</span> <span>8</span>; <span>i</span><span>++</span> {
</span></span><span><span>	<span>debug</span>.<span>Printf</span>(<span>&#34;%02d | div02 = %02d | mod04 = %02d\n&#34;</span>, <span>i</span>, <span>i</span><span>/</span><span>2</span>, <span>i</span><span>%</span><span>4</span>)
</span></span><span><span>}
</span></span></code></pre></div><figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-12.png"/>
</figure>
<p>And with that, we‚Äôre done for the 64bit integer problem! Yey!</p>
<blockquote>
<p>Yes, I know, there might be other instructions that are not implemented. Not looking into this now for sure. Also, yes, I didn‚Äôt get big-ass numbers, but also I don‚Äôt need them now.</p>
</blockquote>
<blockquote>
<p>Spoiler: not doing this on the LLVM level will bite our asses in the future.</p>
</blockquote>
<h2 id="what-now">What now?</h2>
<p>Well, now we need to keep pushing forward! But I need to stop this post at some point so that people can catch up with this project, and also so I can publish these findings. But there‚Äôs a lot still to get done:</p>
<ul>
<li>Target-specific things, such as syscalls, inline assembly and interrupt support</li>
<li>Floating points as they are non-functional at the moment</li>
<li>New LLVM MIPS CPU - yes, we‚Äôll probably need that, plus this way we can avoid hacking code inside TinyGo‚Äôs compiler</li>
<li>Everything else we want!</li>
</ul>
<p>You may be wondering, ‚Äúwhat can I do with it <em>now</em>‚Äù? Well, you can do whatever you want, actually. You can call ps2dev‚Äôs libraries and play with them, and if something fails, you can just call C code from Go. But your code will be running from the Go side of things first, which is pretty neat in my opinion - even if a bit limited for now.</p>
<p>I‚Äôm already working on the next part of this project though, so stay tuned! See you around!</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-13.png"/><figcaption>
      üëã
    </figcaption>
</figure>
<ul>
  
   <li>
     <a href="https://rgsilva.com/tags/coding/">Coding</a>
   </li>
  
   <li>
     <a href="https://rgsilva.com/tags/embedded/">Embedded</a>
   </li>
  
   <li>
     <a href="https://rgsilva.com/tags/go/">Go</a>
   </li>
  
</ul>

    </div></div>
  </body>
</html>
