<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgsilva.com/blog/ps2-go-part-1/">Original</a>
    <h1>Golang on the Playstation 2</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      <figure>
        <img src="https://rgsilva.com/blog/ps2-go-part-1/cover.jpg"/>
      </figure>
      <p>I always wanted to do some weird stuff with consoles. I’m not sure why, but making devices do unexpected things is always an interesting topic for me. And the same applies to the <a href="https://en.wikipedia.org/wiki/PlayStation_2">PlayStation 2</a>, the 2000 console released by Sony.</p>
<p>Also, Sony, don’t sue me for this lol</p>
<p>Let’s get straight into it: I want to run code into consoles (more on <em>why</em> this in a future post). Normally this is done in low(er) level languages, but nowadays we have better and easier to work with languages such as <a href="https://go.dev/">Go</a>. So I was wondering.. why not?</p>
<p>Looking online, however, yielded no easy way of doing this, so I decided to tackle this problem myself.</p>
<blockquote>
<p>Please note that I’m writing this after a lot of the research here has been done and tested already. This means that a lot of the experimentation here is from memory and from retracing my steps, so there might be inconsistencies here and there.</p>
</blockquote>
<blockquote>
<p>Also note that this is all running inside an emulator. I do own a PS2 that I can test this, but I’m too lazy to set it up. Plus I want fully functional demos before doing so.</p>
</blockquote>
<blockquote>
<p>Final note: the code will be released at a later point and I’ll update the post accordingly.</p>
</blockquote>
<h2 id="the-challenge">The challenge</h2>
<p>By default, <a href="https://go.dev/wiki/MinimumRequirements">Go only supports a handful of platforms</a>, and unfortunately that does not include the PS2. In fact, Go seems to require an OS behind the scenes, thing that we don’t even have over there (not considering PS2 Linux). To solve that, however, we have <a href="https://tinygo.org/">TinyGo</a>, a Go compiler for small devices, like microcontrollers and embedded systems. The basic way it works is that it gets the Go code, turns into LLVM IR, and then that into the binary code for whatever target we’re trying to code for.</p>
<p>The PS2 main CPU is called <a href="https://en.wikipedia.org/wiki/Emotion_Engine">Emotion Engine</a>, which is based on a MIPS R5900. It implements the instructions for MIPS-III and MIPS-IV, plus some custom stuff. It also is missing a few other things (more on that later). Go can actually build code for MIPS already, which should save me some time, but not a lot, as I need to get TinyGo to work on it. TinyGo relies on LLVM 19, which does support MIPS-III, but not the R5900 CPU directly.</p>
<p>These are all technical issues. There’s a much more pressing one: I don’t know how the PS2 works.</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-10.png"/><figcaption>
      Well, that should be fun.
    </figcaption>
</figure>
<h2 id="the-ps2dev-sdk-and-its-quirks">The ps2dev SDK and its quirks</h2>
<p>If you look it up online for a way of developing code for the PS2, you’ll probably cross paths with <a href="https://github.com/ps2dev/ps2dev">ps2dev</a>. This is a full-blown SDK that lets you generate binaries for it in a pretty neat way. The coolest thing about it is that it already provides a bunch of libraries for graphical operations, debugging, I/O, etc - even a stdlib is provided! Because of that, I thought: hey, maybe I want to link to their code - this would allow an easier and faster implementation of anything for the PS2 in Go. Think of it as an “OS” API (technically it’s not?), which we could call whenever we want to do things we don’t want to reimplement (or that aren’t even worth trying sometimes).</p>
<p>That said, this introduces a few problems. The first one is that the ps2dev libraries are compiled to the MIPS-III N32 standard. This means that, whatever code we produce, needs to target the same thing. Same hard-float, same N32 ABI, etc. This is a bit annoying, but manageable. The reason why it needs to match is because we’ll be linking our code to their pre-built libraries, and linkers are not really fond of dealing with different targets.</p>
<blockquote>
<p>For the sake of clarification: MIPS-III N32 means that this is targeting a MIPS CPU that is implementing the MIPS-III instruction set. This is a 64bit CPU, but due to the N32, this is running 32bit code with some 64bit instructions to handle 64bit integers. This is very confusing, but you can check <a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models">this</a> to read more about it.</p>
</blockquote>
<p>Because of this, you’ll see my attempts to target <code>mipsel</code> with a <code>mips3</code> CPU in the next steps, even though it should, technically speaking, be a <code>mips64el</code>, as this is a 64bit CPU. N32 should force things to run in 32bit mode, even though though our target should support 64bit code. However, Clang/LLVM and TinyGo get kinda messy on this and it gets very confusing and complicated. Also, building for <code>mips64el</code> caused TinyGo to failed some verification steps when generating code with the LLVM, as well as clang to refuse to properly build it as the code is kinda broken. Since I <em>really</em> wanted to move forward, I gave up and opted for generating <code>mipsel</code> code with the N32 ABI, which will force clang to change it to a MIPS64 internally, but still generate valid code. Like I said, it’s very weird. Please bear with me, this is all new to me too! :D</p>
<p>Further reiteration on this topic might be necessary to get this just right, but I’m not diving into this hell right now. Future-wise we can try dropping ps2dev and doing things directly in Go, but some assembly is required - literally and metaphorically.</p>
<h2 id="getting-tinygo-to-generate-some-code">Getting TinyGo to generate some code</h2>
<p>For TinyGo to know about a certain target, it requires a file defining it - we’ll call it <code>ps2.json</code>. It defines a bunch of very interesting things that we don’t really care at the moment, but here are the most important ones:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>	<span>&#34;llvm-target&#34;</span>: <span>&#34;mipsel-unknown-unknown&#34;</span>,
</span></span><span><span>	<span>&#34;cpu&#34;</span>: <span>&#34;mips3&#34;</span>,
</span></span><span><span>	<span>&#34;features&#34;</span>: <span>&#34;-noabicalls&#34;</span>,
</span></span><span><span>	<span>&#34;build-tags&#34;</span>: [<span>&#34;ps2&#34;</span>, <span>&#34;baremetal&#34;</span>, <span>&#34;mipsel&#34;</span>],
</span></span><span><span>	<span>&#34;goos&#34;</span>: <span>&#34;linux&#34;</span>,
</span></span><span><span>	<span>&#34;goarch&#34;</span>: <span>&#34;mipsle&#34;</span>,
</span></span><span><span>	<span>&#34;linker&#34;</span>: <span>&#34;ld.lld&#34;</span>,
</span></span><span><span>	<span>&#34;rtlib&#34;</span>: <span>&#34;compiler-rt&#34;</span>,
</span></span><span><span>	<span>&#34;libc&#34;</span>: <span>&#34;&#34;</span>,
</span></span><span><span>	<span>&#34;cflags&#34;</span>: [
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;ldflags&#34;</span>: [
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;linkerscript&#34;</span>: <span>&#34;&#34;</span>,
</span></span><span><span>	<span>&#34;extra-files&#34;</span>: [
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;gdb&#34;</span>: []
</span></span><span><span>}
</span></span></code></pre></div><p>This file is the culmination of many, maaany days testing different configurations. It is only <strong>partially functional</strong>. It cannot generate object files yet (more below), hence the reason why I’m not bothering to fill in flags for compiling and linking code. There are some relevant things I need to explain, though, so here we go:</p>
<ol>
<li>Target is <code>mipsel-unknown-unknown</code>. This is our LLVM target. I’m sticking with <code>mipsel</code> here for the reasons I explained previously.</li>
<li>The features have <code>-noabicalls</code>. It is required as otherwise shit hits the fan and nothing works (the LLVM IR that gets generated gets broken).</li>
<li>I’ve set it to not use any <code>libc</code>. This is because ps2dev already provides one, and I don’t want to mess with that (trust me). Plus, since we’ll be linking to their code, we might as well use their version of it.</li>
</ol>
<p>This is the <em>basic</em> target file we need so that TinyGo at least <em>knows</em> what a PS2 is. But that’s not all - we need to define a bunch of functions which are target-specific.</p>
<h3 id="baremetal-definitions">Baremetal definitions</h3>
<p>Our target needs a baremetal configuration - <code>baremetal_ps2.go</code>. Usually the <a href="https://github.com/tinygo-org/tinygo/blob/release/src/runtime/baremetal.go">default baremetal file</a> is enough, but in our case I’ve opted to create a custom one so that I can redefine some things.</p>
<blockquote>
<p>Note from the future: this can be improved by adjusting the linker file so it finds the correct externs. I might end up doing that and come back here later on.</p>
</blockquote>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>runtime</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;unsafe&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>//go:extern _heap_start
</span></span></span><span><span><span></span><span>var</span> <span>heapStartSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _heap_end
</span></span></span><span><span><span></span><span>var</span> <span>heapEndSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _fdata
</span></span></span><span><span><span></span><span>var</span> <span>globalsStartSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _edata
</span></span></span><span><span><span></span><span>var</span> <span>globalsEndSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>//go:extern _stack_top
</span></span></span><span><span><span></span><span>var</span> <span>stackTopSymbol</span> [<span>0</span>]<span>byte</span>
</span></span><span><span>
</span></span><span><span><span>var</span> (
</span></span><span><span>	<span>heapStart</span>    = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>heapStartSymbol</span>))
</span></span><span><span>	<span>heapEnd</span>      = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>heapEndSymbol</span>))
</span></span><span><span>	<span>globalsStart</span> = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>globalsStartSymbol</span>))
</span></span><span><span>	<span>globalsEnd</span>   = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>globalsEndSymbol</span>))
</span></span><span><span>	<span>stackTop</span>     = uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>stackTopSymbol</span>))
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>growHeap</span>() <span>bool</span> {
</span></span><span><span>	<span>// On baremetal, there is no way the heap can be grown.
</span></span></span><span><span><span></span>	<span>return</span> <span>false</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>//export runtime_putchar
</span></span></span><span><span><span></span><span>func</span> <span>runtime_putchar</span>(<span>c</span> <span>byte</span>) {
</span></span><span><span>	<span>putchar</span>(<span>c</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>//go:linkname syscall_Exit syscall.Exit
</span></span></span><span><span><span></span><span>func</span> <span>syscall_Exit</span>(<span>code</span> <span>int</span>) {
</span></span><span><span>  	<span>// TODO
</span></span></span><span><span><span></span>	<span>exit</span>(<span>code</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>const</span> <span>baremetal</span> = <span>true</span>
</span></span><span><span>
</span></span><span><span><span>var</span> <span>timeOffset</span> <span>int64</span>
</span></span><span><span>
</span></span><span><span><span>//go:linkname now time.now
</span></span></span><span><span><span></span><span>func</span> <span>now</span>() (<span>sec</span> <span>int64</span>, <span>nsec</span> <span>int32</span>, <span>mono</span> <span>int64</span>) {
</span></span><span><span>	<span>mono</span> = <span>nanotime</span>()
</span></span><span><span>	<span>sec</span> = (<span>mono</span> <span>+</span> <span>timeOffset</span>) <span>/</span> (<span>1000</span> <span>*</span> <span>1000</span> <span>*</span> <span>1000</span>)
</span></span><span><span>	<span>nsec</span> = int32((<span>mono</span> <span>+</span> <span>timeOffset</span>) <span>-</span> <span>sec</span><span>*</span>(<span>1000</span><span>*</span><span>1000</span><span>*</span><span>1000</span>))
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>AdjustTimeOffset</span>(<span>offset</span> <span>int64</span>) {
</span></span><span><span>	<span>timeOffset</span> <span>+=</span> <span>offset</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>var</span> <span>errno</span> <span>int32</span>
</span></span><span><span>
</span></span><span><span><span>//export __errno_location
</span></span></span><span><span><span></span><span>func</span> <span>libc_errno_location</span>() <span>*</span><span>int32</span> {
</span></span><span><span>	<span>return</span> <span>&amp;</span><span>errno</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Do we need to understand how most of this works? No, we don’t. Not only that, most of this is copy-paste from the normal <code>baremetal.go</code> implementation. We can adjust later if necessary, no worries. Like I said, we mostly need this to <em>build</em>, so that we can figure out what is wrong and fix it accordingly.</p>
<blockquote>
<p>Note: for this to work, you still need to disable the building of the original <code>baremetal.go</code> for our target, so we need to change its build flag to <code>//go:build baremetal &amp;&amp; !ps2</code>.</p>
</blockquote>
<h3 id="runtime">Runtime</h3>
<p>Our target needs a runtime definitions file - <code>runtime_ps2.go</code>. This is the place where a bunch of target-specific functions get defined, including how <code>putchar</code>, <code>exit</code> and even <code>main</code> (later) gets implemented. Pretty cool part of the code if I’d say so.</p>
<p>A very basic implementation would look like this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>runtime</span>
</span></span><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>extern void _exit(int status);
</span></span></span><span><span><span>extern void* malloc(unsigned int size);
</span></span></span><span><span><span>extern void free(void *ptr);
</span></span></span><span><span><span>extern void scr_printf(const char *format, ...);
</span></span></span><span><span><span>*/</span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>import</span> <span>&#34;unsafe&#34;</span>
</span></span><span><span>
</span></span><span><span><span>// timeUnit in nanoseconds
</span></span></span><span><span><span></span><span>type</span> <span>timeUnit</span> <span>int64</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>initUART</span>() {
</span></span><span><span>  <span>// Unsupported.
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>putchar</span>(<span>c</span> <span>byte</span>) {
</span></span><span><span>	<span>// This is a very hacky way of doing this. It assumes the debug screen is already active, and prints
</span></span></span><span><span><span></span>	<span>// a whole string for a single char every single time. Very slow, but works. We can improve it later.
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>x</span> <span>:=</span> <span>C</span>.<span>CString</span>(string(<span>c</span>))
</span></span><span><span>	<span>C</span>.<span>scr_printf</span>(<span>x</span>)
</span></span><span><span>	<span>C</span>.<span>free</span>(<span>unsafe</span>.<span>Pointer</span>(<span>x</span>))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>getchar</span>() <span>byte</span> {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>buffered</span>() <span>int</span> {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>sleepWDT</span>(<span>period</span> <span>uint8</span>) {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>exit</span>(<span>code</span> <span>int</span>) {
</span></span><span><span>  	<span>// This just delegates it to the ps2dev _exit(int) function.
</span></span></span><span><span><span></span>	<span>C</span>.<span>_exit</span>(<span>C</span>.int(<span>code</span>))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>abort</span>() {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ticksToNanoseconds</span>(<span>ticks</span> <span>timeUnit</span>) <span>int64</span> {
</span></span><span><span>  	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> int64(<span>ticks</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>nanosecondsToTicks</span>(<span>ns</span> <span>int64</span>) <span>timeUnit</span> {
</span></span><span><span>  	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>timeUnit</span>(<span>ns</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>sleepTicks</span>(<span>d</span> <span>timeUnit</span>) {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ticks</span>() (<span>ticksReturn</span> <span>timeUnit</span>) {
</span></span><span><span>	<span>// TODO
</span></span></span><span><span><span></span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span></code></pre></div><p>A lot of it is not implemented, and this is intentional - I won’t be using those things at the moment, so I don’t care about them. We can later implement them accordingly, and get them to work as expected. Some of them might be even doable through ps2dev’s C functions, for example.</p>
<h3 id="interrupts">Interrupts</h3>
<p>Another basic file we need is the interrupts defintions - <code>interrupt_ps2.go</code>. I know that ps2dev has implementations for those calls, but I’ve opted to not call them yet. At this moment, we don’t need interrupts, so let’s just implement dummy functions for that:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>interrupt</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>State</span> <span>uintptr</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Disable</span>() (<span>state</span> <span>State</span>) {
</span></span><span><span>	<span>return</span> <span>0</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Restore</span>(<span>state</span> <span>State</span>) {}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>In</span>() <span>bool</span> {
</span></span><span><span>	<span>return</span> <span>false</span>
</span></span><span><span>}
</span></span></code></pre></div><p>With that, we <em>should</em> be able to build some Go code. So let’s give it a try.</p>
<h2 id="calling-go-functions-from-c">Calling Go functions from C</h2>
<p>Let’s start with a simple example: get our C code to return a number and a string. Nothing major. We’ll split this into 2 parts: the loader (in C) and our Go code. It will work like this:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-2.png"/><figcaption>
      It works!
    </figcaption>
</figure>
<p>Here’s our Go code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//export aGoString
</span></span></span><span><span><span></span><span>func</span> <span>aGoString</span>() <span>*</span><span>C</span>.<span>char</span> {
</span></span><span><span>	<span>return</span> <span>C</span>.<span>CString</span>(<span>&#34;The answer for everything is&#34;</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>//export aGoNumber
</span></span></span><span><span><span></span><span>func</span> <span>aGoNumber</span>() <span>C</span>.<span>int</span> {
</span></span><span><span>	<span>return</span> <span>C</span>.int(<span>42</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>And our loader, which contains our <code>main</code> function:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>// Our go functions, exported before.
</span></span></span><span><span><span></span><span>extern</span> <span>char</span><span>*</span> <span>aGoString</span>();
</span></span><span><span><span>extern</span> <span>int</span> <span>aGoNumber</span>();
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>  <span>// Initialize our debug screen.
</span></span></span><span><span><span></span>  <span>sceSifInitRpc</span>(<span>0</span>);
</span></span><span><span>  <span>init_scr</span>();
</span></span><span><span>
</span></span><span><span>  <span>// Print stuff we get from Go functions.
</span></span></span><span><span><span></span>  <span>scr_printf</span>(<span>&#34;%s: %d</span><span>\n</span><span>&#34;</span>, <span>aGoString</span>(), <span>aGoNumber</span>());
</span></span><span><span>
</span></span><span><span>  <span>// Infinite loop so we keep the program running.
</span></span></span><span><span><span></span>  <span>while</span> (<span>1</span>) {}
</span></span><span><span>
</span></span><span><span>  <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Very simple code, right? Let’s build it.</p>
<p>Well, no, wait. There’s a problem. TinyGo, by default, wants you to generate the final ELF (<code>.elf</code>) or the object file (<code>.o</code>) with it. However, the ELF requires adding a linkfile and some other extra bits of code to it, which we’re far from. For now, we just want to get some functions in a way that we can link - so we should be able to just use the object file.</p>
<p>However, attempting to do so generates an incorrect file:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o test.o
</span></span><span><span>$ file test.o
</span></span><span><span>test.o: ELF 32-bit LSB relocatable, MIPS, MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, with debug_info, not stripped
</span></span></code></pre></div><figcaption>
  Note the missing `N32` in the string
</figcaption>
<p>I thought: oh, ok, we’re just missing the proper <code>cflags</code> and <code>ldflags</code> here, right? So let’s try adding it:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>	<span>// (...)
</span></span></span><span><span><span></span>	<span>&#34;cflags&#34;</span>: [
</span></span><span><span>		<span>&#34;-mabi=n32&#34;</span>
</span></span><span><span>	],
</span></span><span><span>	<span>&#34;ldflags&#34;</span>: [
</span></span><span><span>		<span>&#34;-mabi=n32&#34;</span>
</span></span><span><span>	],
</span></span><span><span>	<span>// (...)
</span></span></span></code></pre></div><figcaption>
  These might not be the right flags, but according to some docs it seems like it is.
</figcaption>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o test.o
</span></span><span><span>$ file test.o                                        
</span></span><span><span>test.o: ELF 32-bit LSB relocatable, MIPS, MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, with debug_info, not stripped
</span></span></code></pre></div><p>Oh. Ok then.</p>
<p>Since TinyGo is, for some reason, not playing nice here, I’ve opted for breaking this into steps that I can more easily control. TinyGo internally will generating some LLVM IR from your Go code, and then build it. Let’s stop at the LLVM IR level then:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o build/go.ll
</span></span></code></pre></div><p>This will generate a valid LLVM IR file! 🎉 Now we can just manually build it into the object file with the format we want:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ clang -fno-pic -c --target<span>=</span>mips64el -mcpu<span>=</span>mips3 -fno-inline-functions -mabi<span>=</span>n32 -mhard-float -mxgot -mlittle-endian -o build/go.o build/go.ll
</span></span></code></pre></div><p>The flags here are important. Our target is a MIPS64 (only TinyGo is not happy with it), Little Endian, with the MIPS-III instruction set, using the N32 ABI. It uses hardware floating numbers, and the <code>-fno-pic</code> and <code>-mxgot</code> is to deal with a global offset table size limit issue when linking. With all that, here’s what we get:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ file build/go.o
</span></span><span><span>build/go.o: ELF 32-bit LSB relocatable, MIPS, N32 MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, with debug_info, not stripped
</span></span></code></pre></div><figcaption>
  Finally!
</figcaption>
<p>From here, we can link with our C code. For that, I’ve opted to use the ps2dev linking command (extracted from the Makefile and some testing), with our Go code added into it:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>mips64r5900el-ps2-elf-gcc <span>\
</span></span></span><span><span><span></span>	-Tlinkfile <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ee/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ports/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/gsKit/lib/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34bt/ee/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34usb/ee/ <span>\
</span></span></span><span><span><span></span>	-Wl,-zmax-page-size<span>=</span><span>128</span> <span>\
</span></span></span><span><span><span></span>	-lpatches <span>\
</span></span></span><span><span><span></span>	-lfileXio <span>\
</span></span></span><span><span><span></span>	-lpad <span>\
</span></span></span><span><span><span></span>	-ldebug <span>\
</span></span></span><span><span><span></span>	-lmath3d <span>\
</span></span></span><span><span><span></span>	-ljpeg <span>\
</span></span></span><span><span><span></span>	-lfreetype <span>\
</span></span></span><span><span><span></span>	-lgskit_toolkit <span>\
</span></span></span><span><span><span></span>	-lgskit <span>\
</span></span></span><span><span><span></span>	-ldmakit <span>\
</span></span></span><span><span><span></span>	-lpng <span>\
</span></span></span><span><span><span></span>	-lz <span>\
</span></span></span><span><span><span></span>	-lmc <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lelf-loader <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lc <span>\
</span></span></span><span><span><span></span>	-mhard-float <span>\
</span></span></span><span><span><span></span>	-msingle-float <span>\
</span></span></span><span><span><span></span>	-o build/main.elf <span>\
</span></span></span><span><span><span></span>	build/loader.o <span>\
</span></span></span><span><span><span></span>	build/asm_mipsx.o <span>\
</span></span></span><span><span><span></span>	build/go.o
</span></span></code></pre></div><figcaption>
  Loader is our C code, and Go is our.. well, Go code.
</figcaption>
<blockquote>
<p>Note: the <code>asm_mipsx.o</code> is some assembly code provided by TinyGo that I just copied into the project and built with clang. You can find it <a href="https://github.com/tinygo-org/tinygo/blob/release/src/runtime/asm_mipsx.S">here</a>.</p>
</blockquote>
<p>And, with that, we build our new application!</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ file build/main.elf
</span></span><span><span>build/main.elf: ELF 32-bit LSB executable, MIPS, N32 MIPS-III version <span>1</span> <span>(</span>SYSV<span>)</span>, statically linked, with debug_info, not stripped
</span></span></code></pre></div><p>And running it yields success:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-3.png"/><figcaption>
      It works! This is PCSX2 v2.3.223 btw.
    </figcaption>
</figure>
<h2 id="switching-to-gos-main">Switching to Go’s main</h2>
<p>Right now the <code>main</code> function that is being called is not in Go, but in C - that is what we’ve been calling <em>loader</em> so far. However, Go applications can start by themselves without a C-based loader - and it would be great if our <del>games</del> PS2 applications would so!</p>
<h3 id="runtime-changes">Runtime changes</h3>
<p>The first step to allowing Go applications to run without our loader is to have the <code>main</code> function exposed by Go. We can do that in our <code>runtime_ps2.go</code>:</p>
<pre tabindex="0"><code>//export main
func main() {
	preinit()
	run()
	preexit()
	exit(0)
}

const (
	memSize = uint(24 * 1024 * 1024)
)

var (
	goMemoryAddr uintptr
)

func preinit() {
	// NOTE: no need to clear .bss and other memory areas as crt0 is already doing that in __start.

	// Since we&#39;re loading into whatever ps2dev kernel thingy that exists, it&#39;s safer for us to do
	// a proper malloc before proceeding. This guarantees that the heap location is ours. We will
	// need to free it later on though.

	goMemoryAddr = uintptr(unsafe.Pointer(C.malloc(C.uint(memSize))))
	heapStart = goMemoryAddr
	heapEnd = goMemoryAddr + uintptr(memSize)
}

func preexit() {
	C.free(unsafe.Pointer(heapStart))
}
</code></pre><p>There are some important things to note here:</p>
<ol>
<li>The heap start and end could be defined by the linker file. And, ironically, they are. However, the <code>crt0</code> provided by ps2dev will clear those variables for some reason, making it kinda broken.
<ol>
<li>We could just assume that anything above a certain memory address is ours, <em>buuuut</em> ps2dev may want to play with more memory and I don’t want to deal with this right now.</li>
<li>We’ll allocate the memory using ps2dev’s <code>malloc</code> as per stated in the code. This will guarantee that this memory area is ours - if the libraries need more, they should still have some memory left, as the PS2 should have 32MB and we’re allocating 24MB only.</li>
<li>Technically speaking we could make the heap grow per demand - but that’s a problem for future me.</li>
</ol>
</li>
<li>We’ll intentionally unallocate the memory after usage. Not really required, but <em>just in case</em>.</li>
<li>The <code>run</code> function is responsible for calling our <code>main</code> function inside our <code>main</code> package. This is not something we need to deal with - TinyGo’s code does that for us, we just need to call it.</li>
</ol>
<p>It works basically like this:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-4.png"/><figcaption>
      Exitpoint is even a word?!
    </figcaption>
</figure>
<p>This is technically a mixed approach: it’s both baremetal - because it runs without a proper OS - but it’s also not - because it allocates memory, enters and exits application.</p>
<p>Fun fact: once the code exits, it shows the memory card selection screen!</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-5.png"/>
</figure>
<h3 id="our-go-code">Our Go code</h3>
<p>Let’s code something in Go then. First step is to have something to call, so let’s create a package called <code>debug</code> with the debug screen functions:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>debug</span>
</span></span><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>extern void free(void *ptr);
</span></span></span><span><span><span>extern void sceSifInitRpc(int mode);
</span></span></span><span><span><span>extern void init_scr(void);
</span></span></span><span><span><span>extern void scr_printf(const char *format, ...);
</span></span></span><span><span><span>*/</span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;unsafe&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Init</span>() {
</span></span><span><span>	<span>C</span>.<span>sceSifInitRpc</span>(<span>0</span>)
</span></span><span><span>	<span>C</span>.<span>init_scr</span>()
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>Printf</span>(<span>format</span> <span>string</span>, <span>args</span> <span>...</span><span>interface</span>{}) {
</span></span><span><span>	<span>formatted</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>format</span>, <span>args</span><span>...</span>)
</span></span><span><span>
</span></span><span><span>	<span>str</span> <span>:=</span> <span>C</span>.<span>CString</span>(<span>formatted</span>)
</span></span><span><span>	<span>C</span>.<span>scr_printf</span>(<span>str</span>)
</span></span><span><span>	<span>C</span>.<span>free</span>(<span>unsafe</span>.<span>Pointer</span>(<span>str</span>))
</span></span><span><span>}
</span></span></code></pre></div><blockquote>
<p>Yes, there is an <code>extern</code> for the <code>free</code> function which could be replaced by stdlib. I’ve avoided that at the moment as that requires adding some C flags for include paths and that made it messy. Here’s how it looks like with it:</p>
<pre tabindex="0"><code>/*
#cgo CFLAGS: -I/Users/ricardo/dev/ps2dev/ee/mips64r5900el-ps2-elf/include -I/Users/ricardo/dev/ps2dev/ee/lib/gcc/mips64r5900el-ps2-elf/14.2.0/include/ -I/Users/ricardo/dev/ps2dev/gsKit/include -I/Users/ricardo/dev/ps2dev/ps2sdk/common/include -I/Users/ricardo/dev/ps2dev/ps2sdk/ports/include/freetype2 -I/Users/ricardo/dev/ps2dev/ps2sdk/ports/include/zlib
#include &lt;stdlib.h&gt;

extern void sceSifInitRpc(int mode);
extern void init_scr(void);
extern void scr_printf(const char *format, ...);
*/
</code></pre><p>This can be improved by moving those flags externally to the build process but that’s a problem for future me once this gets released.</p>
</blockquote>
<p>Overall, this is nothing too crazy - it’s just the normal debug functions exposed by ps2dev (declared <a href="https://ps2dev.github.io/ps2sdk/ee_2debug_2include_2debug_8h.html">here</a> and implemented <a href="https://github.com/ps2dev/ps2sdk/blob/master/ee/debug/src/scr_printf.c">here</a>). And then we just call it:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;ps2go/debug&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>debug</span>.<span>Init</span>()
</span></span><span><span>
</span></span><span><span>	<span>debug</span>.<span>Printf</span>(<span>&#34;Hello world from Go!\n&#34;</span>)
</span></span><span><span>	<span>debug</span>.<span>Printf</span>(<span>`
</span></span></span><span><span><span>   ____                                _                           
</span></span></span><span><span><span>  / ___| ___    _ __ _   _ _ __  _ __ (_)_ __   __ _    ___  _ __  
</span></span></span><span><span><span> | |  _ / _ \  | &#39;__| | | | &#39;_ \| &#39;_ \| | &#39;_ \ / _&#39; |  / _ \| &#39;_ \ 
</span></span></span><span><span><span> | |_| | (_) | | |  | |_| | | | | | | | | | | | (_| | | (_) | | | |
</span></span></span><span><span><span>  \____|\___/  |_|   \__,_|_| |_|_| |_|_|_| |_|\__, |  \___/|_| |_|
</span></span></span><span><span><span>    ____  _             ____  _        _   _   |___/       ____    
</span></span></span><span><span><span>   |  _ \| | __ _ _   _/ ___|| |_ __ _| |_(_) ___  _ __   |___ \   
</span></span></span><span><span><span>   | |_) | |/ _&#39; | | | \___ \| __/ _&#39; | __| |/ _ \| &#39;_ \    __) |  
</span></span></span><span><span><span>   |  __/| | (_| | |_| |___) | || (_| | |_| | (_) | | | |  / __/   
</span></span></span><span><span><span>   |_|   |_|\__,_|\__, |____/ \__\__,_|\__|_|\___/|_| |_| |_____|  
</span></span></span><span><span><span>                  |___/                                            
</span></span></span><span><span><span>`</span>)
</span></span><span><span>	<span>for</span> {
</span></span><span><span>		<span>// Infinite loop to not exit!
</span></span></span><span><span><span></span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Fancy, no? Let’s build the code and see what happens:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ tinygo build -target ps2 -o build/go.ll
</span></span><span><span>$ clang -fno-pic -c --target<span>=</span>mips64el -mcpu<span>=</span>mips3 -fno-inline-functions -mabi<span>=</span>n32 -mhard-float -mxgot -mlittle-endian -o build/go.o build/go.ll
</span></span><span><span>$ mips64r5900el-ps2-elf-gcc <span>\
</span></span></span><span><span><span></span>	-Tlinkfile <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ee/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/ps2sdk/ports/lib <span>\
</span></span></span><span><span><span></span>	-L/usr/local/ps2dev/gsKit/lib/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34bt/ee/ <span>\
</span></span></span><span><span><span></span>	-Lmodules/ds34usb/ee/ <span>\
</span></span></span><span><span><span></span>	-Wl,-zmax-page-size<span>=</span><span>128</span> <span>\
</span></span></span><span><span><span></span>	-lpatches <span>\
</span></span></span><span><span><span></span>	-lfileXio <span>\
</span></span></span><span><span><span></span>	-lpad <span>\
</span></span></span><span><span><span></span>	-ldebug <span>\
</span></span></span><span><span><span></span>	-lmath3d <span>\
</span></span></span><span><span><span></span>	-ljpeg <span>\
</span></span></span><span><span><span></span>	-lfreetype <span>\
</span></span></span><span><span><span></span>	-lgskit_toolkit <span>\
</span></span></span><span><span><span></span>	-lgskit <span>\
</span></span></span><span><span><span></span>	-ldmakit <span>\
</span></span></span><span><span><span></span>	-lpng <span>\
</span></span></span><span><span><span></span>	-lz <span>\
</span></span></span><span><span><span></span>	-lmc <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lelf-loader <span>\
</span></span></span><span><span><span></span>	-laudsrv <span>\
</span></span></span><span><span><span></span>	-lc <span>\
</span></span></span><span><span><span></span>	-mhard-float <span>\
</span></span></span><span><span><span></span>	-msingle-float <span>\
</span></span></span><span><span><span></span>	-o build/main.elf <span>\
</span></span></span><span><span><span></span>	build/asm_mipsx.o <span>\
</span></span></span><span><span><span></span>	build/go.o
</span></span></code></pre></div><figcaption>
  Easy, no?
</figcaption>
<p>That builds the ELF file. Now let’s load it in the emulator and see what happens!</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-6.png"/><figcaption>
      Yeeeeeeeeey!
    </figcaption>
</figure>
<p>Success! 🎉</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-9.png"/><figcaption>
      Gotta love memes
    </figcaption>
</figure>
<h2 id="the-ddivu-problem">The DDIVU problem</h2>
<p>While testing some basic functionality, I’ve noticed that <code>fmt.Sprintf</code> didn’t work properly. Look at this very simple basic code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>debug</span>.<span>Init</span>()
</span></span><span><span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>-</span><span>32</span>; <span>i</span> <span>&lt;=</span> <span>32</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>debug</span>.<span>Printf</span>(<span>&#34;%02d, &#34;</span>, <span>i</span>)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>for</span> {
</span></span><span><span>		<span>// Infinite loop to not exit!
</span></span></span><span><span><span></span>	}
</span></span><span><span>}
</span></span></code></pre></div><figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-7.png"/><figcaption>
      Errr this is awkward
    </figcaption>
</figure>
<p>Ok, this is not normal. The numbers between <code>-9</code> and <code>+9</code> are correct, while everything else is wrong. This specific problem took me <em>days</em> to figure out what the hell was going on. I eventually narrowed it down to <a href="https://cs.opensource.google/go/go/+/master:src/fmt/format.go;l=243-249?q=fmtinteger&amp;ss=go%2Fgo">this</a> part of the <code>fmtInteger</code> implementation, used by <code>Sprintf</code> inside the <code>fmt</code> package:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> (<span>f</span> <span>*</span><span>fmt</span>) <span>fmtInteger</span>(<span>u</span> <span>uint64</span>, <span>base</span> <span>int</span>, <span>isSigned</span> <span>bool</span>, <span>verb</span> <span>rune</span>, <span>digits</span> <span>string</span>) {
</span></span><span><span>	<span>// (... bunch of code here ...)
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>switch</span> <span>base</span> {
</span></span><span><span>	<span>case</span> <span>10</span>:
</span></span><span><span>		<span>for</span> <span>u</span> <span>&gt;=</span> <span>10</span> {
</span></span><span><span>			<span>i</span><span>--</span>
</span></span><span><span>			<span>next</span> <span>:=</span> <span>u</span> <span>/</span> <span>10</span>
</span></span><span><span>			<span>buf</span>[<span>i</span>] = byte(<span>&#39;0&#39;</span> <span>+</span> <span>u</span> <span>-</span> <span>next</span><span>*</span><span>10</span>)
</span></span><span><span>			<span>u</span> = <span>next</span>
</span></span><span><span>		}
</span></span><span><span>
</span></span><span><span>	<span>// (... bunch of code here ...)
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>Look at how TinyGo is generating the LLVM IR code for that:</p>
<pre tabindex="0"><code>!875 = !DIFile(filename: &#34;format.go&#34;, directory: &#34;/usr/local/go/src/fmt&#34;)
!15696 = !DILocalVariable(name: &#34;next&#34;, scope: !15679, file: !875, line: 243, type: !373)

; (...)

lookup.next:                                      ; preds = %for.body
  %31 = udiv i64 %27, 10, !dbg !15759
    #dbg_value(i64 %31, !15696, !DIExpression(), !15757)
  %.neg = mul i64 %31, 246, !dbg !15760
  %32 = add i64 %27, 48, !dbg !15761
  %33 = add i64 %32, %.neg, !dbg !15762
  %34 = trunc i64 %33 to i8, !dbg !15763
  %35 = getelementptr inbounds i8, ptr %.pn75, i32 %30, !dbg !15758
  store i8 %34, ptr %35, align 1, !dbg !15758
    #dbg_value(i64 %31, !15696, !DIExpression(), !15764)
    #dbg_value(i64 %31, !15684, !DIExpression(), !15765)
  br label %for.loop, !dbg !15700
</code></pre><figcaption>
  Hopefully this is the right section of the code lol
</figcaption>
<p>Which all seems just fine. Looking deeper into it, there’s this specific thing: <code>udiv i64 %27, 10</code> - this is a unsigned division of a 64bit integer by 10. Keep that 64bit part in mind.</p>
<p>This generates the following MIPS assembly code:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>.LBB139_23:                             <span># %lookup.next
</span></span></span><span><span><span></span>                                        <span>#   in Loop: Header=BB139_19 Depth=1
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:i &lt;- [DW_OP_plus_uconst 176] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:u &lt;- [DW_OP_plus_uconst 184] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:negative &lt;- [DW_OP_plus_uconst 332] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:digits &lt;- [DW_OP_LLVM_fragment 32 32] 17
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:base &lt;- [DW_OP_plus_uconst 316] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:verb &lt;- [DW_OP_plus_uconst 312] [$sp+0]
</span></span></span><span><span><span></span>	<span>#DEBUG_VALUE: (*fmt.fmt).fmtInteger:digits &lt;- [DW_OP_plus_uconst 308, DW_OP_LLVM_fragment 0 32] [$sp+0]
</span></span></span><span><span><span></span>	<span>.loc</span>	<span>129</span> <span>0</span> <span>7</span> <span>is_stmt</span> <span>0</span>               <span># format.go:0:7
</span></span></span><span><span><span></span>	<span>lw</span>	<span>$1</span>, <span>176</span>(<span>$sp</span>)                    <span># 4-byte Folded Reload
</span></span></span><span><span><span></span>	<span>lw</span>	<span>$4</span>, <span>272</span>(<span>$sp</span>)                    <span># 4-byte Folded Reload
</span></span></span><span><span><span></span>	<span>ld</span>	<span>$3</span>, <span>184</span>(<span>$sp</span>)                    <span># 8-byte Folded Reload
</span></span></span><span><span><span></span>	<span>daddiu</span>	<span>$2</span>, <span>$zero</span>, <span>10</span>
</span></span><span><span>	<span>.loc</span>	<span>129</span> <span>243</span> <span>14</span> <span>is_stmt</span> <span>1</span>            <span># format.go:243:14
</span></span></span><span><span><span></span>	<span>ddivu</span>	<span>$zero</span>, <span>$3</span>, <span>$2</span>
</span></span><span><span>	<span>teq</span>	<span>$2</span>, <span>$zero</span>, <span>7</span>
</span></span><span><span>	<span>mflo</span>	<span>$2</span>
</span></span></code></pre></div><p>Let’s ignore most of this and focus on one specific thing: <code>ddivu $zero, $3, $2</code>. Looks correct, right?</p>
<p>Well… let’s look into how PCSX2 loads this:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-8.png"/><figcaption>
      ??????
    </figcaption>
</figure>
<p>Yep. PCSX2 doesn’t see the <code>DDIVU</code> instruction. Or, more specifically, <em>the PlayStation</em>  doesn’t see it.</p>



<p>The <code>DDIVU</code> (doubleword divide unsigned) is a instruction defined in MIPS-III (<a href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf">source</a>) responsible for doing the division of 2 unsigned 64bit integers.</p>
<p>However, that doesn’t work in the PS2, as we saw before. You see, the <code>DDIVU</code> instruction is not defined (<a href="https://psi-rockin.github.io/ps2tek/">source</a>) in the PS2 MIPS instruction set - only <code>DIVU</code> is. This introduces a major problem, as now all <code>int64</code> (with <code>DDIV</code>) and <code>uint64</code> (with <code>DDIVU</code>) divisions won’t execute - or will execute incorrectly if it ends up matching some other instruction. We need to avoid that, and either split this division inside the Go compiler in a way that would not do the 64bit version of it, or modify the LLVM so that it won’t use this instruction, even on a <code>mips3</code> CPU. Or maybe we can implement a custom CPU inside the LLVM - the <code>r5900</code>, like ps2dev’s GCC.</p>
<h3 id="finding-a-way-out">Finding a way out</h3>
<p>My first thought was “oh, let’s adapt this in the LLVM”. But, and I’m not gonna lie to you, changing that code is <em>hell</em>. It’s very complex and requires a ton of changes and most of the time it even requires full rebuild of the LLVM project. I’m just too lazy for that. So I’ve opted for the terrible approach of doing this inside TinyGo’s compiler.</p>
<p>The first step is to <em>have</em> a 64bit division code. According to my good friend ChatGPT (<em>who has never been wrong before /s</em>), whenever 64bit division is not available (like in the R5900), GCC uses an auxiliary function called <code>__udivdi3</code>:</p>
<pre tabindex="0"><code>uint64_t __udivdi3(uint64_t a, uint64_t b);
</code></pre><p>So my thought was: oh, I can just map the uint64 division to this then. The first step is to add this as something that is available on our <code>runtime_ps2.go</code> (because I’m too lazy to do the full proper call):</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build ps2
</span></span></span><span><span><span></span>
</span></span><span><span><span>package</span> <span>runtime</span>
</span></span><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>extern long __divdi3(long a, long b);
</span></span></span><span><span><span>extern unsigned long __udivdi3 (unsigned long a, unsigned long b);
</span></span></span><span><span><span>extern long __moddi3(long a, long b);
</span></span></span><span><span><span>extern unsigned long __umoddi3(unsigned long a, unsigned long b);
</span></span></span><span><span><span>*/</span>
</span></span><span><span><span>import</span> <span>&#34;C&#34;</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>int64div</span>(<span>a</span>, <span>b</span> <span>int64</span>) <span>int64</span> {
</span></span><span><span>	<span>return</span> int64(<span>C</span>.<span>__divdi3</span>(<span>C</span>.<span>long</span>(<span>a</span>), <span>C</span>.<span>long</span>(<span>b</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>uint64div</span>(<span>a</span>, <span>b</span> <span>uint64</span>) <span>uint64</span> {
</span></span><span><span>	<span>return</span> uint64(<span>C</span>.<span>__udivdi3</span>(<span>C</span>.<span>ulong</span>(<span>a</span>), <span>C</span>.<span>ulong</span>(<span>b</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>int64mod</span>(<span>a</span>, <span>b</span> <span>int64</span>) <span>int64</span> {
</span></span><span><span>	<span>return</span> int64(<span>C</span>.<span>__moddi3</span>(<span>C</span>.<span>long</span>(<span>a</span>), <span>C</span>.<span>long</span>(<span>b</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>uint64mod</span>(<span>a</span>, <span>b</span> <span>uint64</span>) <span>uint64</span> {
</span></span><span><span>	<span>return</span> uint64(<span>C</span>.<span>__umoddi3</span>(<span>C</span>.<span>ulong</span>(<span>a</span>), <span>C</span>.<span>ulong</span>(<span>b</span>)))
</span></span><span><span>}
</span></span></code></pre></div><p>Then, we need to modify TinyGo’s compiler to use it. That is simpler than it sounds - <a href="https://github.com/tinygo-org/tinygo/blob/3e60eeb368f25f237a512e7553fd6d70f36dc74c/compiler/compiler.go#L2514-L2566">it’s all handled here</a>.</p>
<p>Let’s start with the unsigned operations:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateUDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateURem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>will then become:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;uint64div&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateUDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;uint64mod&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateURem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Then we just rebuild the TinyGo’s compiler with a <code>make</code>, and rebuild our application. Let’s retest our previous code:</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-11.png"/><figcaption>
      Fuck yeah!
    </figcaption>
</figure>
<p>And for our <code>int64</code> operations as well please. From the following code:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateSDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>return</span> <span>b</span>.<span>CreateSRem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>we adapt it into this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>op</span> <span>==</span> <span>token</span>.<span>QUO</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;int64div&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateSDiv</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>} <span>else</span> {
</span></span><span><span>	<span>if</span> (<span>x</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>x</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) <span>||</span>
</span></span><span><span>		(<span>y</span>.<span>Type</span>().<span>TypeKind</span>() <span>==</span> <span>llvm</span>.<span>IntegerTypeKind</span> <span>&amp;&amp;</span> <span>y</span>.<span>Type</span>().<span>IntTypeWidth</span>() <span>==</span> <span>64</span>) {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>createRuntimeCall</span>(<span>&#34;int64mod&#34;</span>, []<span>llvm</span>.<span>Value</span>{<span>x</span>, <span>y</span>}, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>return</span> <span>b</span>.<span>CreateSRem</span>(<span>x</span>, <span>y</span>, <span>&#34;&#34;</span>), <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Finally, we can test our changes by doing this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>debug</span>.<span>Printf</span>(<span>&#34;\n\n&#34;</span>)
</span></span><span><span><span>for</span> <span>i</span> <span>:=</span> int64(<span>-</span><span>8</span>); <span>i</span> <span>&lt;=</span> <span>8</span>; <span>i</span><span>++</span> {
</span></span><span><span>	<span>debug</span>.<span>Printf</span>(<span>&#34;%02d | div02 = %02d | mod04 = %02d\n&#34;</span>, <span>i</span>, <span>i</span><span>/</span><span>2</span>, <span>i</span><span>%</span><span>4</span>)
</span></span><span><span>}
</span></span></code></pre></div><figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-12.png"/>
</figure>
<p>And with that, we’re done for the 64bit integer problem! Yey!</p>
<blockquote>
<p>Yes, I know, there might be other instructions that are not implemented. Not looking into this now for sure. Also, yes, I didn’t get big-ass numbers, but also I don’t need them now.</p>
</blockquote>
<blockquote>
<p>Spoiler: not doing this on the LLVM level will bite our asses in the future.</p>
</blockquote>
<h2 id="what-now">What now?</h2>
<p>Well, now we need to keep pushing forward! But I need to stop this post at some point so that people can catch up with this project, and also so I can publish these findings. But there’s a lot still to get done:</p>
<ul>
<li>Target-specific things, such as syscalls, inline assembly and interrupt support</li>
<li>Floating points as they are non-functional at the moment</li>
<li>New LLVM MIPS CPU - yes, we’ll probably need that, plus this way we can avoid hacking code inside TinyGo’s compiler</li>
<li>Everything else we want!</li>
</ul>
<p>You may be wondering, “what can I do with it <em>now</em>”? Well, you can do whatever you want, actually. You can call ps2dev’s libraries and play with them, and if something fails, you can just call C code from Go. But your code will be running from the Go side of things first, which is pretty neat in my opinion - even if a bit limited for now.</p>
<p>I’m already working on the next part of this project though, so stay tuned! See you around!</p>
<figure><img src="https://rgsilva.com/blog/ps2-go-part-1/image-13.png"/><figcaption>
      👋
    </figcaption>
</figure>
<ul>
  
   <li>
     <a href="https://rgsilva.com/tags/coding/">Coding</a>
   </li>
  
   <li>
     <a href="https://rgsilva.com/tags/embedded/">Embedded</a>
   </li>
  
   <li>
     <a href="https://rgsilva.com/tags/go/">Go</a>
   </li>
  
</ul>

    </div></div>
  </body>
</html>
