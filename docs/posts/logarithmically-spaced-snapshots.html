<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://madebyevan.com/algos/log-spaced-snapshots/">Original</a>
    <h1>Logarithmically-Spaced Snapshots</h1>
    
    <div id="readability-page-1" class="page"><section>
        

  

  
  <p>
    When making a series of updates to something, you may wish to also retain a series of snapshots in between
    updates. For example, you may want to track version history for edits to a document. With limited storage space
    available, you cannot have a snapshot between every update. You would prefer to have a higher density of recent
    snapshots and a lower density of long-ago snapshots because it&#39;s typically more important to have higher
    granularity for more recent snapshots.
  </p>
  <p>
    This algorithm is a simple way to keep a set of snapshots logarithmically-spaced back in history. It only ever keeps
    around roughly <code>2 log<sub>2</sub>(n)</code> snapshots for <code>n</code> updates, doesn&#39;t require any complex
    bookkeeping, and runs in <code>O(1)</code> time per update step.
  </p>
  <p>
    <b><i>The algorithm:</i></b> After each step, add a new snapshot number <code>n</code> and delete the existing
    snapshot number <code>n - (firstZeroBit(n) &lt;&lt; d)</code> where <code>firstZeroBit(x)</code> returns the value
    of the least significant zero bit of <code>x</code>. The value <code>d</code> is a customizable shift that
    determines the density of snapshots. It can be set to any positive integer but has been set to 2 for the
    visualization below. Here is a possible implementation of <code>firstZeroBit</code>:
  </p>
  <pre><span>function</span> firstZeroBit(x) {
  <span>let</span> bit = 1
  <span>while</span> (bit &amp;&amp; (x &amp; bit) !== <span>0</span>)
    bit &lt;&lt;= <span>1</span>
  <span>return</span> bit
}</pre>
  <p>Here&#39;s a second possible (although less understandable) implementation of <code>firstZeroBit</code> that uses bit
    tricks and is equivalent to the first:</p>
  <pre><span>function</span> firstZeroBit(x) {
  <span>return</span> (x + 1) &amp; ~x
}</pre>
  <p>
    The visualization below has one row for each step. Each successive row gains an additional column on the end to
    represent a new snapshot with the latest edits of the document. A given step has a snapshot when there is a solid
    square present for that step, and no longer has a snapshot when there is only a dot present for that step. The
    red-outlined squares represent snapshot deletes. At most one snapshot is deleted at each step. The number for each
    row is the number of snapshots retained (i.e. the number of remaining snapshots in that row), which is logarithmic
    in the number of steps.
  </p>
  <p>
    Density:
    
    <code id="densityText">d = 2</code>
  </p>

  </section></div>
  </body>
</html>
