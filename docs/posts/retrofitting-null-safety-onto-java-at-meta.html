<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2022/11/22/developer-tools/meta-java-nullsafe/">Original</a>
    <h1>Retrofitting null-safety onto Java at Meta</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>We developed a new static analysis tool called Nullsafe that is used at Meta to detect NullPointerException (NPE) errors in Java code.</span></li>
<li aria-level="1"><span>Interoperability with legacy code and gradual deployment model were key to Nullsafe’s wide adoption and allowed us to recover some null-safety properties in the context of an otherwise null-unsafe language in a multimillion-line codebase.</span></li>
<li aria-level="1"><span>Nullsafe has helped significantly reduce the overall number of NPE errors and improved developers’ productivity. This shows the value of static analysis in solving real-world problems at scale.</span></li>
</ul>
<p><span>Null dereferencing is a common type of programming error in Java. On Android, </span><span>NullPointerException</span><span> (NPE) errors are the </span><a href="https://developer.android.com/games/optimize/crash#prevent-crashes-null-pointer" target="_blank" rel="noopener"><span>largest cause of app crashes on Google Play</span></a><span>. Since Java doesn’t provide tools to express and check nullness invariants, developers have to rely on testing and dynamic analysis to improve reliability of their code. These techniques are essential but have their own limitations in terms of time-to-signal and coverage.</span></p>
<p><span>In 2019, we started a project called </span><span>0NPE</span><span> with the goal of addressing this challenge within our apps and significantly improving null-safety of Java code through static analysis.</span></p>
<p><span>Over the course of two years, we developed Nullsafe, a static analyzer for detecting NPE errors in Java, integrated it into the core developer workflow, and ran a large-scale code transformation to make many million lines of Java code Nullsafe-compliant.</span></p>
<figure id="attachment_19860" aria-describedby="caption-attachment-19860"><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png?w=1024" alt="nullsafe" width="1024" height="552" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png 1484w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png?resize=916,494 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png?resize=768,414 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png?resize=1024,552 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png?resize=96,52 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-1-revised.png?resize=192,104 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19860">Figure 1: Percent null-safe code over time (approx.).</figcaption></figure>
<p><span>Taking <a href="https://engineering.fb.com/2022/11/04/web/instagram-video-processing-encoding-reduction/" target="_blank" rel="noopener">Instagram</a>, one of Meta’s largest Android apps, as an example, we observed a 27 percent reduction in production NPE crashes during the 18 months of code transformation. Moreover, NPEs are no longer a leading cause of crashes in both alpha and beta channels, which is a direct reflection of improved developer experience and development velocity.</span></p>
<h2><span>The problem of </span><span>null</span><span>s</span></h2>
<p><span>Null pointers are notorious for causing bugs in programs. Even in a tiny snippet of code like the one below, things can go wrong in a number of ways:</span></p>
<p><i><span>Listing 1</span></i><span>: </span><i><span>buggy </span></i><span>getParentName</span><i><span> method</span></i></p>
<pre><code>Path getParentName(Path path) {
  return path.getParent().getFileName();
}
</code></pre>
<ol>
<li aria-level="1"><span><span>getParent</span><span>()</span></span><span> may produce </span><span>null</span><span> and cause a </span><span>NullPointerException </span><b>locally</b><span> in </span><span>getParentName(…)</span><span>.</span></li>
<li aria-level="1"><span><span>getFileName</span><span>()</span></span><span> may return </span><span>null</span><span> which may propagate further and cause a crash in some other place.</span></li>
</ol>
<p><span>The former is relatively easy to spot and debug, but the latter may prove challenging — especially as the codebase grows and evolves. </span></p>
<p><span>Figuring out nullness of values and spotting potential problems is easy in toy examples like the one above, but it becomes extremely hard at the scale of millions of lines of code. Then adding thousands of code changes a day makes it impossible to manually ensure that no single change leads to a </span><span>NullPointerException</span><span> in some other component. As a result, users suffer from crashes and application developers need to spend an inordinate amount of mental energy tracking nullness of values.</span></p>
<blockquote><p><span>The problem, however, is not the </span><span>null</span><span> value itself but rather the lack of explicit nullness information in APIs and lack of tooling to validate that the code properly handles nullness.</span></p></blockquote>
<h3><span>Java and nullness</span></h3>
<p><span>In response to these challenges Java 8 introduced </span><span>java.util.Optional&lt;T&gt;</span><span> class. But its performance impact and legacy API compatibility issues meant that </span><span>Optional</span><span> could not be used as a general-purpose substitute for nullable references.</span></p>
<p><span>At the same time, annotations have been used with success as a language extension point. In particular, adding annotations such as </span><span>@Nullable</span><span> and </span><span>@NotNull</span><span> to regular nullable reference types is a viable way to extend Java’s types with explicit nullness while avoiding the downsides of </span><span>Optional</span><span>. However, this approach requires an external checker.</span></p>
<p><span>An annotated version of the code from </span><i><span>Listing 1 </span></i><span>might look like this:</span></p>
<p><i><span>Listing 2</span></i><span>: </span><i><span>correct and annotated </span></i><span>getParentName</span><i><span> method</span></i></p>
<pre><code>// (2)                          (1)
@Nullable Path getParentName(Path path) {
  Path parent = path.getParent(); // (3)
  return parent != null ? parent.getFileName() : null;
            // (4)
}
</code></pre>
<p><span>Compared to a null-safe but not annotated version, this code adds a single annotation on the return type. There are several things worth noting here:</span></p>
<ol>
<li aria-level="1"><b>Unannotated types are considered not-nullable</b><span>. This convention greatly reduces the annotation burden but is applied only to first-party code.</span></li>
<li aria-level="1"><b>Return type is marked </b><span><b>@Nullable</b></span><span> because the method can return </span><span>null</span><span>.</span></li>
<li aria-level="1"><b>Local</b><span> variable </span><span>parent</span><span> is not annotated, as its </span><b>nullness must be inferred</b><span> by the static analysis checker. This further reduces the annotation burden.</span></li>
<li aria-level="1"><span>Checking a value for </span><span>null </span><b>refines its type</b><span> to be not-nullable in the corresponding branch. This is called </span><i><span>flow-sensitive typing, </span></i><span>and it allows writing code idiomatically and handling nullness only where it’s really necessary.</span></li>
</ol>
<blockquote><p><span>Code annotated for nullness can be statically checked for null-safety. The analyzer can protect the codebase from regressions and allow developers to move faster with confidence.</span></p></blockquote>
<h3><span>Kotlin and nullness</span></h3>
<p><span><a href="https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/" target="_blank" rel="noopener">Kotlin</a> is a modern programming language designed to interoperate with Java. In Kotlin, nullness is explicit in the types, and the compiler checks that the code is handling nullness correctly, giving developers instant feedback. </span></p>
<p><span>We recognize these advantages and, in fact, </span><a href="https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/" target="_blank" rel="noopener"><span>use Kotlin heavily at Meta</span></a><span>. But we also recognize the fact that there is a lot of business-critical Java code that cannot — and sometimes should not — be moved to Kotlin overnight. </span></p>
<blockquote><p><span>The two languages – Java and Kotlin – have to coexist, which means there is still a need for a null-safety solution for Java.</span></p></blockquote>
<h2><span>Static analysis for nullness checking at scale</span></h2>
<p><span>Meta’s success building other static analysis tools such as <a href="https://fbinfer.com/" target="_blank" rel="noopener">Infer</a>, </span><a href="https://docs.hhvm.com/hack/" target="_blank" rel="noopener"><span>Hack</span></a><span>, and </span><a href="https://flow.org/" target="_blank" rel="noopener"><span>Flow </span></a><span>and applying them to real-world code-bases made us confident that we could build a nullness checker for Java that is: </span></p>
<ol>
<li aria-level="1"><b>Ergonomic:</b><span> understands the flow of control in the code, doesn’t require developers to bend over backward to make their code compliant, and adds minimal annotation burden. </span></li>
<li aria-level="1"><b>Scalable:</b><span> able to scale from hundreds of lines of code to millions.</span></li>
<li aria-level="1"><b>Compatible with Kotlin:</b><span> for seamless interoperability.</span></li>
</ol>
<blockquote><p><span>In retrospect, implementing the static analysis checker itself was probably the easy part. The real effort went into integrating this checker with the development infrastructure, working with the developer communities, and then making millions of lines of production Java code null-safe.</span></p></blockquote>
<p><span>We implemented the first version of our nullness checker for Java as a </span><a href="https://fbinfer.com/docs/checker-eradicate" target="_blank" rel="noopener"><span>part of Infer</span></a><span>, and it served as a great foundation. Later on, we moved to a compiler-based infrastructure. Having a tighter integration with the compiler allowed us to improve the accuracy of the analysis and streamline the integration with development tools. </span></p>
<p><span>This second version of the analyzer is called Nullsafe, and we will be covering it below.</span></p>
<h3><span>Null-checking under the hood</span></h3>
<p><span>Java compiler API was introduced via </span><a href="https://jcp.org/en/jsr/detail?id=199" target="_blank" rel="noopener"><span>JSR-199</span></a><span>. This API gives access to the compiler’s internal representation of a compiled program and allows custom functionality to be added at different stages of the compilation process. We use this API to extend Java’s type-checking with an extra pass that runs Nullsafe analysis and then collects and reports nullness errors.</span></p>
<p><span>Two main data structures used in the analysis are the abstract syntax tree (AST) and control flow graph (CFG). See Listing 3 and Figures 2 and 3 for examples.</span></p>
<ul>
<li aria-level="1"><span>The AST represents the syntactic structure of the source code without superfluous details like punctuation. We get a program’s AST via the compiler API, together with the type and annotation information.</span></li>
<li aria-level="1"><span>The CFG is a flowchart of a piece of code: blocks of instructions connected with arrows representing a change in control flow. We’re using the </span><a href="https://github.com/typetools/checker-framework/tree/master/dataflow" target="_blank" rel="noopener"><span>Dataflow</span></a><span> library to build a CFG for a given AST.</span></li>
</ul>
<p><span>The analysis itself is split into two phases:</span></p>
<ol>
<li aria-level="1"><span>The </span><b>type inference</b><span> phase is responsible for figuring out nullness of various pieces of code, answering questions such as:</span>
<ul>
<li aria-level="2"><i><span>Can this method invocation return </span></i><span>null</span><i><span> at program point X</span></i><span>?</span></li>
<li aria-level="2"><i><span>Can this variable be </span></i><span>null</span><i><span> at program point Y</span></i><span>?</span></li>
</ul>
</li>
<li aria-level="1"><span>The </span><b>type checking</b><span> phase is responsible for validating that the code doesn’t do anything unsafe, such as dereferencing a nullable value or passing a nullable argument where it’s not expected.</span></li>
</ol>
<p><i><span>Listing 3</span></i><span>: </span><i><span>example </span></i><span>getOrDefault</span><i><span> method</span></i></p>
<pre><code>String getOrDefault(@Nullable String str, String defaultValue) {
  if (str == null) { return defaultValue; }
  return str;
}</code></pre>
<figure id="attachment_19818" aria-describedby="caption-attachment-19818"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp?w=1024" alt="Nullsafe" width="1024" height="455" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp 1496w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp?resize=916,407 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp?resize=768,341 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp?resize=1024,455 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp?resize=96,43 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-2-cropped.webp?resize=192,85 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19818">Figure 2: CFG for code from Listing 3.</figcaption></figure>
<figure id="attachment_19734" aria-describedby="caption-attachment-19734"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png?w=1024" alt="nullsafe" width="1024" height="739" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png 1141w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png?resize=916,661 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png?resize=768,554 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png?resize=1024,739 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png?resize=96,69 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-3.png?resize=192,138 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19734">Figure 3: AST for code from Listing 3</figcaption></figure>
<h4><span>Type-inference phase </span></h4>
<p><span>Nullsafe does type inference based on the code’s CFG. The result of the inference is a mapping from expressions to nullness-extended types at different program points.</span></p>
<p><em><span>state = expression x </span><span>program point → </span><span>nullness – extended type</span></em></p>
<p><span>The inference engine traverses the CFG and </span><i><span>executes</span></i><span> every instruction according to the analysis’ rules. For a program from </span><i><span>Listing 3</span></i><span> this would look like this:</span></p>
<ol>
<li aria-level="1"><span>We start with a mapping at </span><span>&lt;entry&gt;</span><span> point: </span>
<ul>
<li aria-level="2"><span><span>{str <em>→ </em></span><span> @Nullable String, defaultValue <em>→ </em></span><span>String}</span></span><span>.</span></li>
</ul>
</li>
<li aria-level="1"><span>When we execute the comparison </span><span>str</span><span> == </span><span>null</span><span>, the control flow splits and we produce two mappings:</span>
<ul>
<li aria-level="2"><span>THEN: </span><span>{<span>str <em>→ </em></span></span><span> @Nullable String, defaultValue <span><span><em>→ </em></span></span></span><span><span> String</span>}</span><span>.</span></li>
<li aria-level="2"><span>ELSE: </span><span>{</span><span><span>str <em>→ </em></span><span> String</span><span>, defaultValue <em>→ </em></span></span><span><span> String</span>}</span><span>.</span></li>
</ul>
</li>
<li aria-level="1"><span>When the control flow joins, the inference engine needs to produce a mapping that over-approximates the state in both branches. If we have </span><span>@Nullable String</span><span> in one branch and </span><span>String</span><span> in another, the over-approximated type would be </span><span>@Nullable String</span><span>.</span></li>
</ol>
<figure id="attachment_19735" aria-describedby="caption-attachment-19735"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png?w=1024" alt="Nullsafe" width="1024" height="491" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png 1026w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png?resize=916,439 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png?resize=768,368 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png?resize=1024,491 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png?resize=96,46 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-figure-4.png?resize=192,92 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19735">Figure 4: CFG with the analysis results</figcaption></figure>
<p><span>The main benefit of using a CFG for inference is that it allows us to make the analysis flow-sensitive, which is crucial for an analysis like this to be useful in practice.</span></p>
<p><span>The example above demonstrates a very common case where nullness of a value is refined according to the control flow. To accommodate real-world coding patterns, Nullsafe has support for more advanced features, ranging from contracts and complex invariants where we use SAT solving to interprocedural object initialization analysis. Discussion of these features, however, is outside the scope of this post.</span></p>
<h4><span>Type-checking phase</span></h4>
<p><span>Nullsafe does type checking based on the program’s AST. By traversing the AST, we can compare the information specified in the source code with the results from the inference step.</span></p>
<p><span>In our example from Listing 3, when we visit the </span><span>return str</span><span> node we fetch the inferred type of </span><span>str</span><span> expression, which happens to be </span><span>String</span><span>, and check whether this type is compatible with the return type of the method, which is declared as </span><span>String</span><span>.</span></p>
<figure id="attachment_19816" aria-describedby="caption-attachment-19816"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?w=1024" alt="nullsafe" width="1024" height="488" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp 2176w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=916,436 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=768,366 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=1024,488 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=1536,731 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=2048,975 2048w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=96,46 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-5-cropped.webp?resize=192,91 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19816">Figure 5: Checking types during AST traversal.</figcaption></figure>
<p><span>When we see an AST node corresponding to an object dereference, we check that the inferred type of the receiver excludes </span><span>null</span><span>. Implicit unboxing is treated in a similar way. For method call nodes, we check that the inferred types of the arguments are compatible with method’s declared types. And so on.</span></p>
<p><span>Overall, the type-checking phase is much more straightforward than the type-inference phase. One nontrivial aspect here is error rendering, where we need to augment a type error with a context, such as a type trace, code origin, and potential quick fix.</span></p>
<h4><span>Challenges in supporting generics</span></h4>
<p><span>Examples of the nullness analysis given above covered only the so-called root nullness, or nullness of a value itself. Generics add a whole new dimension of expressivity to the language and, similarly, nullness analysis can be extended to support generic and parameterized classes to further improve the expressivity and precision of APIs.</span></p>
<blockquote><p><span>Supporting generics is obviously a good thing. But extra expressivity comes as a cost. In particular, type inference gets a lot more complicated.</span></p></blockquote>
<p><span>Consider a parameterized class </span><span>Map&lt;K, List&lt;Pair&lt;V1, V2&gt;&gt;&gt;</span><span>. In the case of </span><b>non-generic </b><span>nullness checker, there is only the root nullness to infer:</span></p>
<pre><code>// NON-GENERIC CASE
   ␣ Map&lt;K, List&lt;Pair&lt;V1, V2&gt;&gt;
// ^
// \--- Only the root nullness needs to be inferred

</code></pre>
<p><span>The </span><b>generic </b><span>case requires a lot more gaps to fill on top of an already complex flow-sensitive analysis:</span></p>
<pre><code>// GENERIC CASE
   ␣ Map&lt;␣ K, ␣ List&lt;␣ Pair&lt;␣ V1, ␣ V2&gt;&gt;
// ^     ^    ^      ^      ^      ^
// \-----|----|------|------|------|--- All these need to be inferred
</code></pre>
<p><span>This is not all. Generic types that the analysis infers must closely follow </span><i><span>the shape</span></i><span> of the types that Java itself inferred to avoid bogus errors. For example, consider the following snippet of code:</span></p>
<pre><code>interface Animal {}
class Cat implements Animal {}
class Dog implements Animal {}

void targetType(@Nullable Cat catMaybe) {
  List&lt;@Nullable Animal&gt; animalsMaybe = List.of(catMaybe);
}
</code></pre>
<p><span>List.&lt;T&gt;of(T…)</span><span> is a generic method and in isolation the type of </span><span>List.of(catMaybe)</span><span> could be inferred as </span><span>List&lt;@Nullable Cat&gt;</span><span>. This would be problematic because generics in Java are invariant, which means that </span><span>List&lt;Animal&gt;</span><span> is not compatible with </span><span>List&lt;Cat&gt;</span><span> and the assignment would produce an error.</span></p>
<p><span>The reason this code type checks is that the Java compiler knows the type of the target of the assignment and uses this information to tune how the type inference engine works in the context of the assignment (or a method argument for the matter). This feature is called </span><i><span>target typing</span></i><span>, and although it improves the ergonomics of working with generics, it doesn’t play nicely with the kind of forward CFG-based analysis we described before, and it required extra care to handle.</span></p>
<p><span>In addition to the above, the Java compiler itself has bugs (e.g., </span><a href="https://bugs.openjdk.org/browse/JDK-8225377" target="_blank" rel="noopener"><span>this</span></a><span>) that require various workarounds in Nullsafe and in other static analysis tools that work with type annotations.</span></p>
<p><span>Despite these challenges, we see </span><b>significant value in supporting generics</b><span>. In particular:</span></p>
<ul>
<li aria-level="1"><b>Improved ergonomics</b><span>. Without support for generics, developers cannot define and use certain APIs in a null-aware way: from collections and functional interfaces to streams. They are forced to circumvent the nullness checker, which harms reliability and reinforces a bad habit. We have found many places in the codebase where lack of null-safe generics led to </span><b>brittle code and bugs</b><span>.</span></li>
<li aria-level="1"><b>Safer Kotlin interoperability</b><span>. Meta is a heavy user of Kotlin, and a nullness analysis that supports generics closes the gap between the two languages and significantly </span><b>improves the safety of the interop</b><span> and the development experience in a heterogeneous codebase.</span></li>
</ul>
<h3><span>Dealing with legacy and third-party code</span></h3>
<p><span>Conceptually, the static analysis performed by Nullsafe adds a new set of semantic rules to Java in an attempt to retrofit null-safety onto an otherwise null-unsafe language. The ideal scenario is that all code follows these rules, in which case diagnostics raised by the analyzer are relevant and actionable. The reality is that there’s a lot of null-safe code that knows nothing about the new rules, and there’s even more null-unsafe code. Running the analysis on such legacy code or even newer code that calls into legacy components would produce too much noise, which would add friction and undermine the value of the analyzer.</span></p>
<p><span>To deal with this problem in Nullsafe, we separate code into three tiers:</span></p>
<ul>
<li aria-level="1"><b>Tier 1: Nullsafe compliant code.</b><span> This includes first-party code marked as </span><span>@Nullsafe</span><span> and checked to have no errors. This also includes known good annotated third-party code or third-party code for which we have added nullness models.</span></li>
<li aria-level="1"><b>Tier 2: First-party code not compliant with Nullsafe.</b><span> This is internal code written without explicit nullness tracking in mind. This code is checked optimistically by Nullsafe.</span></li>
<li aria-level="1"><b>Tier 3: Unvetted third-party code.</b><span> This is third-party code that Nullsafe knows nothing about. When using such code, the uses are checked pessimistically and developers are urged to add proper nullness models.</span></li>
</ul>
<p><span>The important aspect of this tiered system is that when Nullsafe type-checks Tier </span><i><span>X</span></i><span> code that calls into Tier </span><i><span>Y</span></i><span> code, it uses Tier </span><i><span>Y</span></i><span>’s rules. In particular:</span></p>
<ol type="A">
<li aria-level="1"><span>Calls from Tier 1 to Tier 2 are checked optimistically,</span></li>
<li aria-level="1"><span>Calls from Tier 1 to Tier 3 are checked pessimistically,</span></li>
<li aria-level="1"><span>Calls from Tier 2 to Tier 1 are checked according to Tier 1 component’s nullness.</span></li>
</ol>
<p><span>Two things are worth noting here:</span></p>
<ol>
<li aria-level="1"><span>According to point A, Tier 1 code can have unsafe dependencies or safe dependencies used unsafely. This unsoundness is the price we had to pay to streamline and gradualize the rollout and adoption of Nullsafe in the codebase. We tried other approaches, but extra friction rendered them extremely hard to scale. The good news is that as more Tier 2 code is migrated to Tier 1 code, this point becomes less of a concern.</span></li>
<li aria-level="1"><span>Pessimistic treatment of third-party code (point B) adds extra friction to the nullness checker adoption. But in our experience, the cost was not prohibitive, while the improvement in the safety of Tier 1 and Tier 3 code interoperability was real.</span></li>
</ol>
<figure id="attachment_19812" aria-describedby="caption-attachment-19812"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?w=1024" alt="Nullsafe" width="1024" height="768" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp 2304w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=916,687 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=768,576 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=1024,768 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=1536,1152 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=2048,1536 2048w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=96,72 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-6-update.webp?resize=192,144 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19812">Figure 6: Three tiers of null-safety rules.</figcaption></figure>
<h3><span>Deployment, automation, and adoption</span></h3>
<p><span>A nullness checker alone is not enough to make a real impact. The effect of the checker is proportional to the amount of code compliant with this checker. Thus a migration strategy, developer adoption, and protection from regressions become primary concerns.</span></p>
<p><span>We found three main points to be essential to our initiative’s success:</span></p>
<ol>
<li aria-level="1"><b>Quick fixes</b><span> are incredibly helpful. The codebase is full of trivial null-safety violations. Teaching a static analysis to not only check for errors but also to come up with quick fixes can cover a lot of ground and give developers the space to work on meaningful fixes.</span></li>
<li aria-level="1"><b>Developer adoption</b><span> is key. This means that the checker and related tooling should integrate well with the main development tools: build tools, IDEs, CLIs, and CI. But more important, there should be a working feedback loop between application and static analysis developers. </span></li>
<li aria-level="1"><b>Data and metrics</b><span> are important to keep the momentum. Knowing where you are, the progress you’ve made, and the next best thing to fix really helps facilitate the migration.</span></li>
</ol>
<h2><span>Longer-term reliability impact</span></h2>
<p><span>As one example, looking at 18 months of reliability data for the Instagram Android app:</span></p>
<ul>
<li aria-level="1"><span>The portion of the app’s code compliant with Nullsafe grew from 3 percent to 90 percent.</span></li>
<li aria-level="1"><span>There was a significant decrease in the relative volume of </span><span>NullPointerException</span><span> (NPE) errors across all release channels (see Figure 7). Particularly, in production, the volume of NPEs was reduced by 27 percent.</span></li>
</ul>
<p><span>This data is validated against other types of crashes and shows a real improvement in reliability and null-safety of the app. </span></p>
<p><span>At the same time, individual product teams also reported significant reduction in the volume of NPE crashes after addressing nullness errors reported by Nullsafe. </span></p>
<p><span>The drop in production NPEs varied from team to team, with </span><b>improvements ranging</b> <b>from 35 percent to 80 percent</b><span>.</span></p>
<p><span>One particularly interesting aspect of the results is the </span><b>drastic drop in NPEs in the alpha-channel</b><span>. This directly reflects the improvement in the developer productivity that comes from using and relying on a nullness checker.</span></p>
<p><span>Our north star goal, and an ideal scenario, would be to completely eliminate NPEs. However, real-world reliability is complex, and there are more factors playing a role:</span></p>
<ul>
<li aria-level="1"><span>There is still null-unsafe code that is, in fact, responsible for a large percentage of top NPE crashes. But now we are in a position where targeted null-safety improvements can make a significant and lasting impact.</span></li>
</ul>
<ul>
<li aria-level="1"><span>The volume of crashes is not the best metric to measure reliability improvement because one bug that slips into production can become very hot and single-handedly skew the results. A better metric might be the number of new unique crashes per release, where we see </span><i><span>n</span></i><span>-fold improvement.</span></li>
<li aria-level="1"><span>Not all NPE crashes are caused by bugs in the app’s code alone. A mismatch between the client and the server is another major source of production issues that need to be addressed via other means.</span></li>
<li aria-level="1"><span>The static analysis itself has limitations and unsound assumptions that let certain bugs slip into production.</span></li>
</ul>
<p><span>It is important to note that this is the </span><b>aggregate effect of hundreds of engineers using Nullsafe</b><span> to improve the safety of their code as well as the effect of</span><b> other reliability initiatives</b><span>, so we can’t attribute the improvement solely to the use of Nullsafe. However, based on reports and our own observations over the course of the last few years, we’re confident that Nullsafe played a significant role in driving down NPE-related crashes.</span></p>
<figure id="attachment_19813" aria-describedby="caption-attachment-19813"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?w=1024" alt="" width="1024" height="633" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp 1800w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?resize=916,566 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?resize=768,475 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?resize=1024,633 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?resize=1536,950 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?resize=96,59 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Nullsafe-image-7-update.webp?resize=192,119 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19813">Figure 7: Percent NPE crashes by release channel.</figcaption></figure>
<h2><span>Beyond Meta</span></h2>
<p><span>The problems outlined above are hardly specific to Meta. Unexpected </span><span>null</span><span>-dereferences have caused </span><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" target="_blank" rel="noopener"><span>countless problems in different companies</span></a><span>. Languages like C# evolved into having </span><a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references" target="_blank" rel="noopener"><span>explicit nullness</span></a><span> in their type system, while others, like Kotlin, had it from the very beginning. </span></p>
<p><span>When it comes to Java, there were multiple attempts to add nullness, starting with </span><a href="https://stackoverflow.com/questions/2289694/what-is-the-status-of-jsr-305" target="_blank" rel="noopener"><span>JSR-305</span></a><span>, but none was widely successful. Currently, there are many great static analysis tools for Java that can check nullness, including CheckerFramework, SpotBugs, ErrorProne, and NullAway, to name a few. In particular, Uber walked </span><a href="https://arxiv.org/abs/1907.02127" target="_blank" rel="noopener"><span>the same path</span></a><span> by making their Android codebase null-safe using NullAway checker. But in the end, all the checkers perform nullness analysis in different and subtly incompatible ways. The lack of standard annotations with precise semantics has constrained the use of static analysis for Java throughout the industry.</span></p>
<p><span>This problem is exactly what the </span><a href="https://jspecify.dev/" target="_blank" rel="noopener"><span>JSpecify workgroup</span></a><span> aims to address. The JSpecify started in 2019 and is a collaboration between individuals representing companies such as Google, JetBrains, Uber, Oracle, and others. Meta has also been part of JSpecify since late 2019.</span></p>
<p><span>Although the </span><a href="https://jspecify.dev/docs/spec" target="_blank" rel="noopener"><span>standard for nullness</span></a><span> is not yet finalized, there has been a lot of progress on the specification itself and on the tooling, with more exciting announcements following soon. Participation in JSpecify has also influenced how we at Meta think about nullness for Java and about our own codebase evolution.</span></p>

		
	</div></div>
  </body>
</html>
