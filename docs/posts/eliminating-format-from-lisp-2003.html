<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cs-www.cs.yale.edu/homes/dvm/format-stinks.html">Original</a>
    <h1>Eliminating Format from Lisp (2003)</h1>
    
    <div id="readability-page-1" class="page">
<h2>Eliminating <tt>FORMAT</tt> from Lisp
</h2>

<p>Drew McDermott</p>

<p>February 14, 2003\\
Revised August 16, 2004
</p>


<p>The <tt>FORMAT</tt> statement started with Fortran, in the
mid-50&#39;s.  To print an integer and a real, interspersed with
explanatory tags, one would write:
</p><pre>     PRINT 101, I, X
101  FORMAT (2HI=, I5, 6W, 2HX=, F6.2)
</pre>
Here <tt>2HI=</tt> is a specification of a <em>Hollerith string</em>;
&#34;<tt>2H</tt>&#34; means the string has two characters (&#34;I&#34; and &#34;=&#34;).  
<tt>I5</tt> and <tt>F6.2</tt> tell how to print the integer and real:
the former has a field width of 5 characters, the latter of 6, with
two to the right of the decimal point.


<p>The C language took over the same idea, embodied in the
<tt>printf</tt> function from the C standard I/O library.
Instead of a separate <tt>FORMAT</tt> statement, the information about
how to print the data was incorporated into a string argument to
<tt>printf</tt>.  So the example above became:
</p><pre>    printf(&#34;I=%5d      X=%6.2f\n&#34;, i, x);
</pre>
This is an improvement.  (Even IBM eventually got rid of Hollerith
strings.)


<p>Early versions of Lisp had builtin I/O procedures such as
<tt>print</tt>, <tt>terpri</tt>, etc., but they were awkward for any
purpose much more complex than printing a single S-expression.  At
some point someone had the bright idea of importing <tt>format</tt>
into Lisp.  The example above became
</p><pre>   (format t &#34;I=~5d      X=~6,2F~%&#34; i x)
</pre>
which differs only in minor details from the C version.


<p>In my opinion, this was a silly mistake.  Lisp is a syntactically
extensible language, meaning that it is quite easy, using macros, to
create arbitrary language extensions, so long as they obey two basic
rules: (1) A new statement must look like <tt>(<i>op</i> ...)</tt>,
where &#34;...&#34; has balanced parentheses; (2) the lexical conventions
inside the new statement must be Lisp&#39;s (e.g., more characters
(including <tt>&#39;*&#39;</tt>, <tt>&#39;+&#39;</tt>, and such) 
are ordinary symbol constituents, in contrast to their role in other
languages, so adjacent symbols must be separated by whitespace; 
double quote starts a
string; single quote, sharpsign, and a few other characters have
special meanings).
If you&#39;re used to Lisp, these rules are barely noticeable, so that
Lisp hackers come to think of it as having the most flexible syntax
in the world.
</p>

<p>The <tt>format</tt> statement takes a completely different
approach.  <tt>format</tt> is implemented as a function, whose second
argument is a string containing instructions on how to print the
remaining arguments.  This &#34;format control string&#34; is essentially a
little program written in a special &#34;format control language.&#34;  This
language doesn&#39;t obey any of Lisp&#39;s syntax rules.  Over time, the
format control language has evolved to the point where it contains
conditionals, iteration, and even &#34;goto&#34;s.  It even has its own
compiler, the <tt>formatter</tt> function.
</p>

<p>If this language were particularly suited to I/O, it might be worth
putting up with.  But it is unbearably clumsy from the word go.  Why
should one have to write <tt>(format t &#34;x = ~s, y = ~s, z = ~s~%&#34; x y
z)</tt>, and then match up the occurrences of <tt>&#34;~s&#34;</tt> with the
variables to see where <tt>x</tt>, <tt>y</tt>, and <tt>z</tt> are
printed?  Why not write this instead:
</p><pre>    (out &#34;x = &#34; x 
         &#34;, y = &#34; y 
         &#34;, z = &#34; z :%)
</pre>
Now it is obvious at what points in the output the three results
are to be printed.  My alternative format uses the <tt>out</tt> macro,
described in greater detail in <a href="http://cs-www.cs.yale.edu/homes/dvm/papers/ytdoc.pdf">the YTools
manual</a>.  I will describe more features of
<tt>out</tt> as I go along.  The arguments to <tt>out</tt>, for now,
are strings that are <tt>princ</tt>&#39;ed and expressions that are
evaluated and printed.


<p>As soon as control structures enter the picture, it becomes even
more obvious how much better one can do than <tt>format</tt>.  Suppose
we have a structure <tt>f1</tt> of type <tt>Foo</tt>, and we want the
print-function for this type to print its
<tt>label</tt> and each element of its <tt>contents</tt>.
Furthermore, if its status is marked <tt>:abnormal</tt>, we want to
print a question mark after the label.  At this point the Lisp
community had to choose between
abandoning <tt>format</tt> and adding conditionals to it.
Unfortunately, they chose to do the latter.
Here is what I would like to write:
</p><pre>   (out &#34;#&lt;Foo &#34; (Foo-label f1) 
        (:q ((eq (Foo-status f1) &#39;:abnormal)
             &#34;?&#34;))
        (:e (dolist (x (Foo-contents f1))
               (:o &#34; &#34; x)))
	&#34;&gt;&#34;)
</pre>
 We use the <a href="http://cl-cookbook.sourceforge.net/macros.html">&#34;guide symbols&#34;</a> 
<tt>:q</tt>, <tt>:e</tt>, and <tt>:o</tt> to signal that we are
writing expressions whose meanings are specific to the <tt>out</tt>
macro, not general-purpose Lisp expressions.  These constructs allow
us to mix evaluated Lisp forms, such as <tt>(Foo-contents f1)</tt>,
with forms in &#34;<tt>out</tt> mode,&#34; such as <tt>&#34;?&#34;</tt>.
<tt>(:q <it>--clauses--</it>)</tt> is like <tt>cond</tt>, except that
after the test in a clause, the remaining expressions are in
<tt>out</tt> mode.  So if <tt>f1</tt> has abnormal status, a question
mark is printed. The <tt>:e</tt> construct is more general:<tt>(:e
<it>--exps--</it>)</tt> causes the <it>exps</it> to be evaluated and
the results discarded, except that any subexpression of the form
<tt>(:o <it>--outstuff--</it>)</tt> returns us to <tt>out</tt> mode.


<p>The net result for printing <tt>f1</tt> is that if <tt>f1</tt> has
label &#34;tree&#34;, is not flagged as abnormal, 
and has a contents list <tt>(eenie meenie minie moe)</tt>, it would be
printed as
</p><pre>   #&lt;Foo tree eeenie meenie minie moe&gt;
</pre>


Here is a larger example, from <a href="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html"> 
Steele&#39;s &#34;Common Lisp: The Language&#34;
(edition 2)</a>.  He calls this the &#34;hairiest format control string I have
ever seen,&#34; although I believe I have seen worse.  We have a datatype
called a &#34;xapping&#34;:

<pre>(defstruct 
  (xapping (:print-function print-xapping) 
           (:constructor xap 
             (domain range &amp;optional 
              (default &#39;:unknown defaultp) 
              (infinite (and defaultp :constant)) 
              (exceptions &#39;())))) 
  domain 
  range 
  default 
  (infinite nil :type (member nil :constant :universal) 
  exceptions)
</pre>

<p>where the print-function is defined thus:
</p>

<pre>(defun print-xapping (xapping stream depth)
   (declare (ignore depth))
   (format stream
	   ;; Are you ready for this one?
	   &#34;~:[{~;[~]~:{~S~:[-&gt;~S~;~*~]~:^ ~}~:[~; ~]~
            ~{~S-&gt;~^ ~}~:[~; ~]~[~*~;-&gt;~S~;-&gt;~*~]~:[}~;]~]&#34;
	   ;; Is that clear?
	   (xectorp xapping)
	   (do ((vp (xectorp xapping))
		(sp (finite-part-is-xetp xapping))
		(d (xapping-domain xapping) (cdr d))
		(r (xapping-range xapping) (cdr r))
		(z &#39;() (cons (list (if vp (car r) (car d)) (or vp sp) (car r)) z)))
	       ((null d) (reverse z)))
	   (and (xapping-domain xapping)
		(or (xapping-exceptions xapping)
		    (xapping-infinite xapping)))
	   (xapping-exceptions xapping)
	   (and (xapping-exceptions xapping) (xapping-infinite xapping))
	   (ecase (xapping-infinite xapping)
	     ((nil) 0)
	     (:constant 1)
	     (:universal 2))
	   (xapping-default xapping)
	   (xectorp xapping))) 
</pre>

I quote Steele&#39;s exegesis of the format control:

<blockquote>
Here is a blow-by-blow description of the parts of this format string:
<table>

<colgroup><col width="25%"/><col/>
</colgroup><tbody><tr><td>~:[{~;[~] </td><td>Print ``[&#39;&#39; for a xector, and ``{&#39;&#39; otherwise.  </td></tr>

<tr><td>~:{~S~:[-&gt;~S~;~*~]~:^ ~} </td><td>Given a list of lists, print the pairs. Each sublist has three elements: the index (or the value if we&#39;re printing a xector); a flag that is true for either a xector or xet (in which case no arrow is printed); and the value. Note the use of ~:{ to iterate, and the use of ~:^ to avoid printing a separating space after the final pair (or at all, if there are no pairs).  </td></tr>

<tr><td>~:[~; ~] </td><td>If there were pairs and there are exceptions or an infinite part, print a separating space.  </td></tr>

<tr><td>~ </td><td>Do nothing. This merely allows the format control string to be broken across two lines. </td></tr>

<tr><td>~{~S-&gt;~^ ~} </td><td>Given a list of exception indices, print them. Note the use of ~{ to iterate, and the use of ~^ to avoid printing a separating space after the final exception (or at all, if there are no exceptions).  </td></tr>

<tr><td>~:[~; ~] </td><td>If there were exceptions and there is an infinite part, print a separating space. </td></tr>

<tr><td> ~[~*~;-&gt;~S~;-&gt;~*~] </td><td>Use ~[ to choose one of three cases for printing the infinite part. </td></tr>

<tr><td> ~:[}~;]~] </td><td>Print ``]&#39;&#39; for a xector, and ``}&#39;&#39; otherwise.  </td></tr>
</tbody></table>
</blockquote>

<p>Folks, you don&#39;t have to put up with this nonsense.  Here is the
civilized way to write the print-function.  
</p>

<pre>(defun print-xapping (xapping stream depth)
   (declare (ignore depth))
   (out (:to stream)
      ;; Print ``[&#39;&#39; for a xector, and ``{&#39;&#39; otherwise. 
      (:q ((xectorp xapping) &#34;[&#34;)
	  (t &#34;{&#34;))

      ;; Print the pairs implied by the xapping.
      ;; Whether the element to the left of the arrow comes from
      ;; the list &#39;d&#39; or the list &#39;r&#39; depends on whether the
      ;; xapping is a xector.  An arrow is printed only if
      ;; xapping is not a xector or a xet.  The element to the
      ;; right of the arrow always comes from &#39;r&#39;.
      ;; Each pair is followed by a space, except the last.
      (:e (do ((vp (xectorp xapping))
	       (sp (finite-part-is-xetp xapping))
	       (d (xapping-domain xapping) (cdr d))
	       (r (xapping-range xapping) (cdr r)))
	      ((null d))
	     (:o (if vp (car r) (car d))
		 (:q ((not (or vp sp)) &#34;-&gt;&#34;))
		 (car r)
		 (:q ((not (null (cdr d))) &#34; &#34;)))))

      ;; If there were pairs and there are exceptions or an infinite part,
      ;; print a separating space. 
      (:q ((and (xapping-domain xapping)
		(or (xapping-exceptions xapping)
		    (xapping-infinite xapping)))
	   &#34; &#34;))

      ;; Given a list of exception indices, print them.
      (:e (do ((el (xapping-exceptions xapping) (cdr el)))
	      ((null el))
	     (:o (car el)
		 (:q ((not (null (cdr el))) &#34; &#34;)))))

      ;; If there were exceptions and there is an infinite part,
      ;; print a separating space.
      (:q ((and (xapping-exceptions xapping) (xapping-infinite xapping))
	   &#34; &#34;))

      ;; The infinite part is omitted if nil, printed as &#34;-&gt;k&#34; if it&#39;s a
      ;; constant k, and printed as &#34;-&gt;&#34; if it&#39;s &#34;universal&#34;
     (:e (ecase (xapping-infinite xapping)
	    ((nil))
	    (:constant (:o &#34;-&gt;&#34; (xapping-default xapping)))
	    (:universal (:o &#34;-&gt;&#34;))))

     ;; Print ``]&#39;&#39; for a xector, and ``}&#39;&#39; otherwise. 
     (:q ((xectorp xapping) &#34;]&#34;)
	 (t &#34;}&#34;))))
</pre>

<p>
Note that Steele&#39;s
comments now have a place to go. Of course, now the comments can be
about <em>content</em>, not the grubby details of the control string.
Furthermore, we no longer have to squeeze the output data into a form
intelligible to <tt>format</tt>, because we can use any Lisp control
structure we like.  This especially applies to the code for printing
the arrow-separated pairs and the &#34;infinite part&#34; of the xapping.
</p>

<p>Irritatingly, format control strings are used in more than one Lisp
construct.  The macros <tt>error</tt>, <tt>cerror</tt>, and
<tt>break</tt> use them to control printout.  So to eliminate all uses
of format control strings we must provide new versions of these macros.
</p>

<p><em>Acknowledgements:</em>
The <tt>out</tt> macro I&#39;ve given examples of is a descendant of
the <tt>MSG</tt> macro described in 
</p><blockquote>
Eugene Charniak, Christopher Riesbeck, Drew McDermott and 
James Meehan 1987 {\it
Artificial Intelligence Programming, {\rm (2nd edition)}}.
 Lawrence Erlbaum Associates,
</blockquote>
and incorporated into <a href="ftp://ftp.cs.yale.edu/pub/mcdermott/software/nisp.tar.gz">
Nisp</a>,
although I believe it was originally created at UC Irvine by Meehan
and colleagues in the early 1980s.












</div>
  </body>
</html>
