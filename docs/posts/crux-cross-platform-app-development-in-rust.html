<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://redbadger.github.io/crux/">Original</a>
    <h1>Crux: Cross-platform app development in Rust</h1>
    
    <div id="readability-page-1" class="page">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents">
            
            
        </nav>

        <!-- Track and set sidebar scroll position -->
        

        <div id="page-wrapper">

            <div class="page">
                                
                

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        
<p>Crux is an <strong>experimental</strong> approach to building cross-platform applications
with better testability, higher code and behavior reuse, better safety,
security, and more joy from better tools.</p>
<p>It splits the application into two distinct parts, a Core built in Rust, which
drives as much of the business logic as possible, and a Shell, built in the
platform native language (Swift, Kotlin, TypeScript), which provides all
interfaces with the external world, including the human user, and acts as a
platform on which the core runs.</p>
<p><img src="https://redbadger.github.io/crux/crux.png" alt="Crux"/></p>
<p>The interface between the two is a native FFI (Foreign Function Interface) with
cross-language type checking and message passing semantics, where simple data
structures are passed across the boundary.</p>
<div id="admonition-get-to-know-crux">

<div>
<p>To get playing with Crux quickly, follow the <a href="https://redbadger.github.io/crux/getting_started/core.html">Getting Started</a> steps. If you prefer to read more about how apps are built in Crux first, read the <a href="https://redbadger.github.io/crux/guide/hello_world.html">Development Guide</a>. And if you&#39;d like to know what possessed us to try this in the first place, read about our <a href="https://redbadger.github.io/crux/motivation.html">Motivation</a>.</p>
<p>There are two places to find API documentation: the latest published version on docs.rs, and we also have the very latest master docs if you too like to live dangerously.</p>
<ul>
<li><strong>crux_core</strong> - the main Crux crate: <a href="https://docs.rs/crux_core/latest/crux_core/">latest release</a> | <a href="https://redbadger.github.io/crux/master_api_docs/crux_core/">latest master</a></li>
<li><strong>crux_http</strong> - HTTP client capability: <a href="https://docs.rs/crux_http/latest/crux_http/">latest release</a> | <a href="https://redbadger.github.io/crux/master_api_docs/crux_http/">latest master</a></li>
</ul>
<p>Crux is open source on <a href="https://github.com/redbadger/crux">Github</a>. A good way to learn Crux is to explore the code, play with the <a href="https://github.com/redbadger/crux/tree/master/examples">examples</a>, and raise issues or pull requests. We&#39;d love you to get involved.</p>
<p>You can also join the friendly conversation on our <a href="https://crux-community.zulipchat.com">Zulip channel</a>.</p>
</div>
</div>
<h2 id="design-overview"><a href="#design-overview">Design overview</a></h2>
<p><img src="https://redbadger.github.io/crux/architecture.svg" alt="Logical architecture"/></p>
<p>The architecture is event-driven, based on
<a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>. The Core
holds the majority of state, which is updated in response to events happening in
the Shell. The interface between the Core and the Shell is messaged based.</p>
<p>The user interface layer is built natively, with modern declarative UI
frameworks such as Swift UI, Jetpack Compose and React/Vue or a WASM based
framework on the web. The UI layer is as thin as it can be, and all other
application logic is performed by the shared Core. The one restriction is that
the Core is sideâ€“effect free. This is both a technical requirement (to be able
to target WebAssembly), and an intentional design goal, to separate logic from
effects and make them both easier to test in isolation.</p>
<p>The core requests side-effects from the Shell through common
<a href="https://redbadger.github.io/crux/guide/capabilities.html">capabilities</a>. The basic concept is that instead of
<em>doing</em> the asynchronous work, the core <em>describes</em> the intent for the work with
data, and passes this to the Shell to be performed. The Shell performs the work,
and returns the outcomes back to the Core. This approach is inspired by
<a href="https://elm-lang.org/">Elm</a>, and similar to how other purely functional
languages deal with effects and I/O (e.g. the IO monad in Haskell). It is also
similar to how iterators work in Rust.</p>
<p>The Core exports types for the messages it can understand. The Shell can call
the Core and pass one of the messages. In return, it receives a set of
side-effect requests to perform. When the work is completed, the Shell sends the
result back into the Core, which responds with further requests if necessary.</p>
<p>Updating the user interface is considered one of the side-effects the Core can
request. The entire interface is strongly typed and breaking changes in the core
will result in build failures in the Shell.</p>
<h2 id="goals"><a href="#goals">Goals</a></h2>
<p>We set out to prove this architecture to find a better way of building apps
across platforms. You can read more <a href="https://redbadger.github.io/crux/motivation.html">about our motivation</a>. The
overall goals of Crux are to:</p>
<ul>
<li>Build the majority of the application code once, in Rust</li>
<li>Encapsulate the <em>behavior</em> of the app in the Core for reuse</li>
<li>Follow the Ports and Adapters pattern, also known as
<a href="https://alistair.cockburn.us/hexagonal-architecture/">Hexagonal Architecture</a>
to facilitate pushing side-effects to the edge, making behavior easy to test</li>
<li>Separate the behavior from the look and feel and interaction design</li>
<li>Use the native UI tool kits to create user experience that is the best fit for
a given platform</li>
</ul>

                    </main>

                    <nav aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next" href="https://redbadger.github.io/crux/motivation.html" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i></i>
                            </a>

                        
                    </nav>
                </div>
            </div>

            <nav aria-label="Page navigation">

                    <a rel="next" href="https://redbadger.github.io/crux/motivation.html" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i></i>
                    </a>
            </nav>

        </div>




        


        
        
        

        
        
        

        <!-- Custom JS scripts -->


    </div>
    

</div>
  </body>
</html>
