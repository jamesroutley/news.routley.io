<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://redpenguin101.github.io/html/posts/2025_01_21_voronoi.html">Original</a>
    <h1>Generating Voronoi Diagrams Using Fortune&#39;s Algorithm (With Odin)</h1>
    
    <div id="readability-page-1" class="page">

<h2 id="health-warning">Health warning</h2>
<p>This article is about using Fortune’s Algorithm to generate Voronoi
Diagrams in O(nlogn) time. If I’d known how hard it would be I wouldn’t
have started it. If you are intending to implement it with the intent to
actually use it, rather than as an exercise, I would recommend not using
Fortune’s. Unless you are doing a <em>lot</em> of large diagrams - like
multiple large diagrams every second - I’d suggest looking at an O(n^2)
implementation, which I’ve heard is much easier. Or even better, using a
library. While it was very frustrating at times, it is a cool looking
algorithm when you get it working.</p>
<h2 id="what-is-a-voronoi-diagram">What is a Voronoi diagram?</h2>
<p>A Voronoi diagram is method of partitioning a plane into regions. It
is often used to procedurally generate maps.</p>
<p><img src="https://macwright.com/2025/images/voronoi/voronoi.jpeg"/></p>
<p>You pick a bunch of points on a plane called ‘sites’, and the region,
or ‘cell’, corresponding to that site is the area enclosing every point
which is closer to that site than to any other site.</p>
<p>Put another way, the edge of each cell is where it is equidistant to
two sites (top drawing). The ‘corners’ of the cells, where edges meet,
are called ‘Voronoi Vertices’. These are the points which are
equidistant from three sites (bottom drawing).</p>
<p><img src="https://macwright.com/2025/images/voronoi/edge_and_vertex.png"/></p>
<p>There are a few methods for generating the diagrams. A popular one is
Fortune’s Algorithm, and that’s the one I’ll describe here.</p>
<h2 id="fortunes-algorithm">Fortune’s Algorithm</h2>
<p>Seen visually, this method creates a line which ‘sweeps’ from the
left edge of the plane to the right, pixel by pixel - called the
<strong>sweep-line</strong>. When the line encounters a site it creates
what looks like a ‘bubble’ around it (actually, a parabolic arc). The
bubble grows as the sweep line gets further away. The magic happens when
two arcs from two different sites collide: the point of collision
becomes the edge of the cells, it being equidistant between the two
points. And when two of those <em>edges</em> collide, it creates a
corner in the diagram. The ‘frontier’ of all the active bubbles is
called the <strong>beachline</strong>, I guess because it sort of looks
like a coast?</p>
<p><img src="https://macwright.com/2025/images/voronoi/animated.gif"/></p>
<p>In reality you don’t actually go pixel by pixel. Interesting things
happen at certain points which can be calculated - irritatingly called
<strong>events</strong> - and we just look at those. There’s a lot to
unpack here, and we need to do some groundwork before really getting
into it.</p>
<h2 id="glossary-of-terms">Glossary of Terms</h2>
<p>There are a few terms that are core to understanding the process.
I’ll define them briefly here, but most of them won’t make sense until
you understand how they relate to the algorithm. they’re just here for
reference so you can come back to them later.</p>
<p>A <strong>site</strong>, sometimes called a seed, is a 2d point. The
sites are what determine the shape of the resulting Voronoi diagram,
because the edges of the cells are equidistant from two sites.</p>
<p>The <strong>sweep line</strong> is the vertical line that sweeps
across the region. As the sweep line passes each event in the event
queue, that event is processed.</p>
<p>The <strong>beach line</strong> is a line comprised of a series of
arcs. When an event is processed, the beach line is affected by either
adding or removing arcs. Each arc corresponds to a site, though each
site can have multiple, or no, arcs on the beachline at any given point
in time.</p>
<p>An <strong>intersection</strong> is a point where two arcs on the
beachline meet eachother. These intersections are also equidistant
between the sites to which the arcs relate.</p>
<p>The <strong>event queue</strong> is where the site and circle events
are stored, ordered by ascending x-coordinate. The algorithm progresses
by popping the next event off the queue, and processing it, until there
are none left. This is a conceptually a priority queue, though isn’t
implemented as one here.</p>
<p>A <strong>site event</strong> is one of the two types of event on the
event queue, and the simpler one. It is defined by the coordinates of a
corresponding site. Processing a site event results in a new arc being
added to the beach line. Since the sites are known when you begin the
algorithm, they are added to the queue before the algorithm starts
processing events.</p>
<p>A <strong>circle event</strong> is the other type of event on the
queue. It is defined by the three arcs which sit on the perimeter of the
circle. Apart from the center and radius of the circle, another
important attribute of the circle is the <strong>circle point</strong>,
which is the right-most point of the circle. It’s the x-coordinate of
this circle point which determines where it sits in the event queue.
Circle points are not known ahead of time, but are generated as arcs are
added to or removed from the beach line. Processing a circle event
results in an arc being removed from the beach line, and a Voronoi
Vertex and two half edges being created.</p>
<p>A <strong>Voronoi Vertex</strong> is a point equidistant between 3
sites, where three equiedges meet. They are the corners of the cells of
the Voronoi diagram. They are also the center of the circles of circle
events.</p>
<p>An <strong>equiedge</strong> is an line which is equidistant between
two sites in the Voronoi diagram.</p>
<p>An <strong>incomplete edge</strong> is a line which has a fixed point
on one side, but the other side is defined as the intersection of two
parabola focus points. Since the parabola intersections change with the
sweep line, this end of the edge is not fixed. Incomplete edges become
‘complete’ when the two incomplete edges meet eachother (at a circle
event), and in doing so generate Voronoi Vertices and half edges.</p>
<p>A <strong>half edge</strong> is a part of the Voronoi data structure.
It has a origin point (a Voronoi Vertex) and a ‘twin’ half edge. Half
edges are generated from the ‘completion’ of an incomplete edge.</p>
<h2 id="a-parabolic-tangent">A Parabolic Tangent</h2>
<p>The concept and properties of a parabola are really important to this
algorithm. So we need to be able to represent
parabola.<sup><a href="#fn1" id="note1" title="Footnote 1">1</a></sup>
Parabola are usually defined using an equation <code>y=ax^2+bx+c</code>
or some slight variation on that. We use a different, but equivalent
formulation called the ‘locus definition’. You can define a parabola
using two things: A 2d coordinate called the <strong>focus
point</strong>, and a line called the
<strong>directrix</strong><sup><a href="#fn2" id="note2" title="Footnote 2">2</a></sup>.
The parabola consists of all points which are equally distant from the
focus point and the directrix. If we restrict ourselves to a vertical
directrix, then the directrix becomes a single number representing the
x-coordinate of the line.</p>
<p><img src="https://macwright.com/2025/images/voronoi/parabola.png"/></p>


<p>This how you can calculate the points of the parabola. Derivation is
not going to be covered here, and it’s not actually important for the
algorithm. But it’s useful for drawing
it<sup><a href="#fn3" id="note3" title="Footnote 3">3</a></sup>.</p>

<div id="cb1"><pre><code><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a><span>def</span> parabola_x(focus:Vector2, y: <span>int</span>, d: <span>int</span>):</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a>  x <span>=</span> y <span>-</span> focus.y</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a>  x <span>*=</span> x</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a>  x <span>/=</span> focus.x <span>-</span> d</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a>  x <span>+=</span> focus.x <span>+</span> d</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a>  x <span>*=</span> <span>0.5</span></span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a>  <span>return</span> x</span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9" tabindex="-1"></a><span>def</span> draw_parabola(f:V2, d:<span>int</span>, y0<span>:=</span><span>0</span>, yn<span>:=</span>HEIGHT, color<span>:=</span>BLACK)</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10" tabindex="-1"></a>  <span>for</span> y <span>in</span> y0..<span>&lt;</span>yn:</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11" tabindex="-1"></a>    DrawPixel(parabola_x(f, y, d), y, color)</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13" tabindex="-1"></a>focus_point <span>=</span> [<span>200</span>,<span>300</span>]</span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14" tabindex="-1"></a>directrix <span>=</span> <span>300</span></span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15" tabindex="-1"></a><span># The focus point</span></span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16" tabindex="-1"></a>draw_circle(focus_point, <span>5</span>, RED)</span>
<span id="cb1-17"><a aria-hidden="true" href="#cb1-17" tabindex="-1"></a><span># The directrix/sweep line</span></span>
<span id="cb1-18"><a aria-hidden="true" href="#cb1-18" tabindex="-1"></a>draw_line([directrix, <span>0</span>], [directrix, H]  <span>5</span>, BLUE)</span>
<span id="cb1-19"><a aria-hidden="true" href="#cb1-19" tabindex="-1"></a>draw_parabola(focus_point, directrix)</span></code></pre></div>
<p><img src="https://macwright.com/2025/images/voronoi/parabola2.png"/></p>
<p>Let’s tie all this back to the problem: Remember the goal here is to
find the equiedge between two sites - the line that has all points that
are the same distance from both sites. The benefit of defining a
parabola like this is that, if we set the focus points to be our sites
and the directrix to be our sweep line, then:</p>
<ul>
<li>every point on the parabola is distance p from the sweep line</li>
<li>every point on the parabola is <em>also</em> distance p from the
site.</li>
<li>if you have two parabola from different sites, and use the same
sweep line, the point of intersection of the parabola is equidistant
from both sites.</li>
</ul>
<p>So by finding the interections between two parabola you find the
‘boundary’ edge which is equidistance from both
sites<sup><a href="#fn4" id="note4" title="Footnote 4">4</a></sup>.</p>

<p><img src="https://macwright.com/2025/images/voronoi/parabola_intersect1.png"/></p>
<div id="cb2"><pre><code><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a><span># Coordinates of two sites</span></span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a>site1 <span>=</span> [<span>200</span>, <span>300</span>]</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3" tabindex="-1"></a>site2 <span>=</span> [<span>400</span>, <span>700</span>]</span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5" tabindex="-1"></a><span># X coord of sweeplines at progressive points</span></span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6" tabindex="-1"></a>sweep_lines <span>=</span> [<span>450</span>, <span>500</span>, <span>600</span>, <span>700</span>, <span>800</span>, <span>900</span>]</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7" tabindex="-1"></a><span># Intersection fn takes 2 sites and a sweep line, returns</span></span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8" tabindex="-1"></a><span># intersections.</span></span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9" tabindex="-1"></a>start, _ <span>=</span> intersection(site1, site2, sweep_lines[<span>0</span>])</span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10" tabindex="-1"></a>end, _ <span>=</span> intersection(site1, site2, sweep_lines[<span>len</span>(sweep_lines)<span>-</span><span>1</span>])</span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11" tabindex="-1"></a></span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12" tabindex="-1"></a>draw_circle(site1, <span>5</span>, RED)</span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13" tabindex="-1"></a>draw_circle(site2, <span>5</span>, RED)</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14" tabindex="-1"></a></span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15" tabindex="-1"></a><span>for</span> s <span>in</span> sweep_lines:</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16" tabindex="-1"></a>  draw_parabola(site1, s, color<span>=</span>GREEN)</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17" tabindex="-1"></a>  draw_parabola(site2, s, color<span>=</span>BLUE)</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18" tabindex="-1"></a></span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19" tabindex="-1"></a>draw_line(start, end, <span>5</span>, ORANGE)</span></code></pre></div>
<p><img src="https://macwright.com/2025/images/voronoi/parabola_intersect2.png"/></p>
<p>This is math magic, I love it.</p>
<h2 id="back-to-the-beachline">Back to the Beachline</h2>
<p>The beachline is like the ‘frontier’ of all the arcs at a given point
in the sweep line. The first takeaway from this is that, since the sweep
line is going to be the same for all arcs, we can represent an arc just
by its focus point (i.e. the site). And since the focus points are our
sites, every ‘arc’ on the beachline is just the 2d coordinate of one of
our sites. The second takeaway is that we can represent the frontier
line as a simple sequence of
points<sup><a href="#fn5" id="note5" title="Footnote 5">5</a></sup>.
So in the following, the beachline is arc 1 and arc 2. Or,
<code>[arc1,arc2]</code></p>

<p><img src="https://macwright.com/2025/images/voronoi/beachline1.png"/></p>
<p>And here it’s <code>[arc1, arc2, arc3]</code></p>
<p><img src="https://macwright.com/2025/images/voronoi/beachline2.png"/></p>
<p>There are a few nuances though. Look at this one, where there are
three arcs: 1, 2, and 3. A full description of the frontier needs to
reflect that 2 separate parts of arc1 are on the frontier, with the
middle bit being covered by 3.</p>
<p><img src="https://macwright.com/2025/images/voronoi/beachline3.png"/></p>
<p>It’s actually easy to handle this: just put it in the beachline
twice: <code>[arc1, arc3, arc1, arc2]</code></p>
<p>A final scenario I’ll mention, because it turns out to be important,
is that it’s totally possible to have a beachline where the same three
arcs appear together but in a <em>different order</em>. Like you might
have the sequence <code>[i,j,k]</code>, and then later
<code>[k,j,i]</code>. Triples of arcs on the beachline are important for
reasons that will become clear. Each <em>ordered triple</em> will be
unique in the beachline. So you can’t have <code>[i,j,k]</code>
twice.</p>
<p><img src="https://macwright.com/2025/images/voronoi/beachline4.png"/></p>
<p>For each pair of arcs in the beachline we calculate the intersection,
and by drawing the arcs between the intersection, we sketch the
beachline.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a aria-hidden="true" href="#cb3-1" tabindex="-1"></a><span>def</span> draw_beachline(beachline:[V2], d:<span>int</span>)</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2" tabindex="-1"></a>  y <span>=</span> <span>0</span></span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3" tabindex="-1"></a>  <span>for</span> i <span>in</span> <span>0.</span>.<span>&lt;</span><span>len</span>(beachline)<span>-</span><span>1</span></span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4" tabindex="-1"></a>    p1, _ <span>=</span> intersection(beachline[i], beachline[i<span>+</span><span>1</span>], d)</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5" tabindex="-1"></a>    draw_parabola(beachline[i], d, y, p1.y)</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6" tabindex="-1"></a>    y <span>=</span> p1.y</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7" tabindex="-1"></a>  draw_parabola(beachline[<span>len</span>(beachline)<span>-</span><span>1</span>], d, y, H)</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8" tabindex="-1"></a></span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9" tabindex="-1"></a>site1 <span>=</span> [<span>200</span>, <span>300</span>]</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10" tabindex="-1"></a>site2 <span>=</span> [<span>400</span>, <span>700</span>]</span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11" tabindex="-1"></a>site3 <span>=</span> [<span>450</span>, H<span>/</span><span>3</span>]</span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12" tabindex="-1"></a></span>
<span id="cb3-13"><a aria-hidden="true" href="#cb3-13" tabindex="-1"></a>sweep <span>=</span> <span>500</span></span>
<span id="cb3-14"><a aria-hidden="true" href="#cb3-14" tabindex="-1"></a>beach_line <span>=</span> [site1, site3, site1, site2]</span>
<span id="cb3-15"><a aria-hidden="true" href="#cb3-15" tabindex="-1"></a></span>
<span id="cb3-16"><a aria-hidden="true" href="#cb3-16" tabindex="-1"></a>draw_circle(site1, <span>5</span>, RED)</span>
<span id="cb3-17"><a aria-hidden="true" href="#cb3-17" tabindex="-1"></a>draw_circle(site2, <span>5</span>, RED)</span>
<span id="cb3-18"><a aria-hidden="true" href="#cb3-18" tabindex="-1"></a>draw_circle(site3, <span>5</span>, RED)</span>
<span id="cb3-19"><a aria-hidden="true" href="#cb3-19" tabindex="-1"></a>draw_line([sweep, <span>0</span>], [sweep, H],  <span>5</span>, BLUE)</span>
<span id="cb3-20"><a aria-hidden="true" href="#cb3-20" tabindex="-1"></a>draw_beachline(beach_line, sweep)</span></code></pre></div>
<p><img src="https://macwright.com/2025/images/voronoi/beachline.png"/></p>
<h2 id="new-arcs-are-created-when-the-sweep-line-hits-a-new-site">New
arcs are created when the sweep line hits a new site</h2>
<p>So that’s the beachline: just a sequence of points, where each point
represents both a site and an arc. Next we should talk about how things
get added to and removed from the beachline. I mentioned at the
beginning that interesting stuff happens at some special points on the
sweep line. The first of these is when the sweep line hits a new site.
This creates a new arc, and inserts it into the sequence, ‘splitting’
the old arc in two. Inserts where? You need to find the arc which, if
you draw a line left from the new site, you hit. That’s the arc that
gets split. It’s easier to see it in a picture.</p>
<p><img src="https://macwright.com/2025/images/voronoi/site_add1.png"/></p>
<div id="cb4"><pre><code><span id="cb4-1"><a aria-hidden="true" href="#cb4-1" tabindex="-1"></a><span>def</span> add_site(beachline:[V2], site:V2):</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2" tabindex="-1"></a>  <span>if</span> <span>len</span>(beachline) <span>==</span> <span>0</span>:</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3" tabindex="-1"></a>    append(beachline, site)</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4" tabindex="-1"></a>    <span>return</span></span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6" tabindex="-1"></a>  sweep <span>=</span> site.x</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7" tabindex="-1"></a>  insert_after <span>=</span> <span>0</span></span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8" tabindex="-1"></a>  <span>for</span> i <span>in</span> <span>0.</span>.<span>&lt;</span><span>len</span>(beachline)<span>-</span><span>1</span>:</span>
<span id="cb4-9"><a aria-hidden="true" href="#cb4-9" tabindex="-1"></a>    b, _ <span>:=</span> intersection(beachline[i], beachline[i<span>+</span><span>1</span>], sweep)</span>
<span id="cb4-10"><a aria-hidden="true" href="#cb4-10" tabindex="-1"></a>    <span>if</span> b.y <span>&gt;</span> site.y:</span>
<span id="cb4-11"><a aria-hidden="true" href="#cb4-11" tabindex="-1"></a>      insert_after <span>=</span> i</span>
<span id="cb4-12"><a aria-hidden="true" href="#cb4-12" tabindex="-1"></a>      <span>break</span></span>
<span id="cb4-13"><a aria-hidden="true" href="#cb4-13" tabindex="-1"></a>  inject_at(beachline, insert_after<span>+</span><span>1</span>, site)</span>
<span id="cb4-14"><a aria-hidden="true" href="#cb4-14" tabindex="-1"></a>  inject_at(beachline, insert_after<span>+</span><span>2</span>, beachline[insert_after])</span>
<span id="cb4-15"><a aria-hidden="true" href="#cb4-15" tabindex="-1"></a></span>
<span id="cb4-16"><a aria-hidden="true" href="#cb4-16" tabindex="-1"></a>site1 <span>=</span> [<span>200</span>, <span>300</span>]</span>
<span id="cb4-17"><a aria-hidden="true" href="#cb4-17" tabindex="-1"></a>site2 <span>=</span> [<span>400</span>, <span>700</span>]</span>
<span id="cb4-18"><a aria-hidden="true" href="#cb4-18" tabindex="-1"></a>site3 <span>=</span> [<span>450</span>, <span>280</span>]</span>
<span id="cb4-19"><a aria-hidden="true" href="#cb4-19" tabindex="-1"></a></span>
<span id="cb4-20"><a aria-hidden="true" href="#cb4-20" tabindex="-1"></a>beach_line : []</span>
<span id="cb4-21"><a aria-hidden="true" href="#cb4-21" tabindex="-1"></a>add_site(beach_line, site1)</span>
<span id="cb4-22"><a aria-hidden="true" href="#cb4-22" tabindex="-1"></a>add_site(beach_line, site2)</span>
<span id="cb4-23"><a aria-hidden="true" href="#cb4-23" tabindex="-1"></a>add_site(beach_line, site3)</span>
<span id="cb4-24"><a aria-hidden="true" href="#cb4-24" tabindex="-1"></a></span>
<span id="cb4-25"><a aria-hidden="true" href="#cb4-25" tabindex="-1"></a><span>print</span>(beach_line)</span>
<span id="cb4-26"><a aria-hidden="true" href="#cb4-26" tabindex="-1"></a><span>## =&gt;</span></span>
<span id="cb4-27"><a aria-hidden="true" href="#cb4-27" tabindex="-1"></a>[[<span>200</span>, <span>300</span>], [<span>450</span>, <span>280</span>], [<span>200</span>, <span>300</span>], [<span>400</span>, <span>700</span>], [<span>200</span>, <span>300</span>]]</span>
<span id="cb4-28"><a aria-hidden="true" href="#cb4-28" tabindex="-1"></a><span>#  site1       site3        site1       site2       site1</span></span></code></pre></div>
<p>As you can see from this, we add sites to the beach line from left to
right by the x-coordinate. Since we know the sites from the beginning,
we can put them in a queue and ‘pop’ them off off one at a time. That’s
why in the literature they’re called <strong>site events</strong>,
though I don’t like that much.</p>
<p>Here’s what the beachline looks like after processing these three
sites events in order:</p>
<p><img src="https://macwright.com/2025/images/voronoi/site_add2.png"/></p>
<p><img src="https://macwright.com/2025/images/voronoi/site_add3.png"/></p>
<p><img src="https://macwright.com/2025/images/voronoi/site_add4.png"/></p>
<h2 id="intersecting-edges-and-circumcircles">Intersecting edges and
Circumcircles</h2>
<p>After we’ve processed the sites and draw the the beachline we see
something like
this<sup><a href="#fn6" id="note6" title="Footnote 6">6</a></sup>.</p>

<p><img src="https://macwright.com/2025/images/voronoi/intersect1.png"/></p>
<p>All good. If we carry on though, and draw the beachline with the
sweep line a bit further on, we run into a problem.</p>
<p><img src="https://macwright.com/2025/images/voronoi/intersect2.png"/></p>
<p>We went too far! If I dial that line back a bit, you can see what is
happening - or about to happen - more clearly:</p>
<p><img src="https://macwright.com/2025/images/voronoi/intersect3.png"/></p>
<p>Depending on how you look at it, 3 things are happening:</p>
<ol type="1">
<li>The orange lines are intersecting</li>
<li>The middle arc is being squeezed out of existance</li>
<li>The intersection points of two pairs of arcs on the beachline are
colliding</li>
</ol>
<p>So when we get to that point we need to remove the middle arc from
the beachline. This ‘arc squeezing’ point is the second type of point we
need to deal with, but its a bit more complicated than the sites. So
lets look at what’s happening in more detail.</p>
<p>Way back at the start I said the edges of the Voronoi were where two
points were equidistant, and the ‘corners’ of the cells where the edges
meet are the points which are equidistant from 3 or more sites. If you
eyeball it in the above picture, you can see that it looks like the
where the lines intersect is about in the middle of the three
points.</p>
<p>We can be a bit more precise than that. What we’re saying
mathematically is that, if we draw a circle where the 3 sites all sit on
the radius, the center of the circle will be equidistant from all 3
points, and by the above definition will be where the edges of the
Voronoi intersect. A circle which puts a set of given points on its
circumference is called a <em>circumcircle</em> (and it’s center is a
circumcenter)<sup><a href="#fn7" id="note7" title="Footnote 7">7</a></sup>.
If we plug the numbers in and draw the circle we get this:</p>

<p><img src="https://macwright.com/2025/images/voronoi/circle1.png"/></p>
<p>Which is spot on. And this is the really important point, because
this is where we finally <em>have a Voronoi Vertex</em>, which is the
whole point of this exercise. When we reach the Voronoi Vertex, defined
by the three arcs on the beachline <code>[..,i,j,k,..]</code>, the
center arc <em>j</em> gets <em>removed</em> from the beachline, so the
beachline looks like <code>[..,i,k,..]</code>. So now we have a new
boundary between arcs <em>i</em> and <em>k</em>, where none existed
before. You can see how this looks in the diagram: there’s a new
equiedge coming out of the Voronoi Vertex we created, which is between
sites <em>i</em> and <em>k</em></p>
<p><img src="https://macwright.com/2025/images/voronoi/intersect4.png"/></p>
<p>But we’re not out of the woods yet. We know we we need to process
each site (i.e. add a new arc) in order from left to right. And that
when we find an intersection, we need to process that intersection
(remove the arc from the beachline, record a Voronoi vertex.) But when
in the sequence of points can we do that? You might think, as soon as we
know those 3 points, we can calculate the circle and therefore the
intersection. But that won’t work. To see why, consider the following
scenario. The first picture is the same scenario we saw before, and you
might think you can go ahead and assume that the edges will converge.
But wait! There is <em>another site</em>, and the sweep line hits it
before the edges converge, breaking up the arc before it reaches the
intersection point.</p>
<p><img src="https://macwright.com/2025/images/voronoi/false_alarm.png"/></p>
<p>The important thing is that the new site is <em>inside the
circle</em>. And that is the answer to the question: You process the
edge intersection when the sweepline leaves the circle without having
encountered any sites inside the circle. The point where the sweepline
leaves the circle is the right-most point of the circle - called the
<strong>circle point</strong>.</p>
<p><img src="https://macwright.com/2025/images/voronoi/circle2.png"/></p>
<p>Until now we’ve been sequentially processing <em>site events</em>.
Now we need to add this second type of event, called a <strong>circle
event</strong> for obvious reasons. Every time we change the beachline,
we need to check for new circle events, and check existing circle events
to see if they are still valid. This is probably the hardest concept in
the algorithm to grok, so I’m going to spend some time on it, before
talking about what happens when our sweepline passes a circle point.</p>
<p>Say you have a beachline containing the three arcs
<code>[..,i,j,k,..]</code>. Because arcs are references to sites
(remember, an ‘arc’ in our datamodel is just a 2d point, with each 2d
point being a site.) <em>i,j</em> and <em>k</em> in addition to being
arcs are also sites. The significance of them being next to eachother in
the beachline is that the equiedges between i and j, and j and k,
<em>could</em> intercept at the center of the circumcircle they
describe, becoming a Voronoi Vertex. This is what a circle event really
is: A reference to a triple of arcs on the beachline (not <em>every</em>
triple on the beachline, but we’ll park that for now).</p>
<p>If there is a change to the beachline affecting that triple before
those lines intersect, then there is no intersection. When I say
‘change’, I mean either a new arc added to the beachline by a site
parameter or one has been removed. In the case of an addition, the
beachline becomes <code>[..,i,j,L,j,k,..]</code>. The triple
<em>i,j,k</em> has gone - and so has any circle event associated with
it. And there are two new triples <em>i,j,L</em> and <em>L,j,k</em>. So
we need to check both of those to see if they create generate circle
events. That’s what happened in the following picture: the arc which is
being ‘squeezed’ is actually being split by the arc created by the new
site before the squeeze happens.</p>
<p><img src="https://macwright.com/2025/images/voronoi/split1.png"/></p>
<p><img src="https://macwright.com/2025/images/voronoi/split2.png"/></p>
<h2 id="incomplete-edges">Incomplete edges</h2>
<p>A couple of sections ago I started adding those orange lines to the
diagram to indicate the equiedges, but I didn’t talk about what they
were exactly. They ultimately become the (half) edges of the Voronoi.
But they start out as <strong>incomplete edges</strong>. These are edges
where one end is a fixed point, but the other is the intersection of two
arcs. That intersection isn’t a fixed point, but changes depending on
where the sweep line is. Hence why it’s incomplete: because one of the
ends isn’t fixed yet.</p>
<p>We create two new incomplete edges whenever we put a new arc on the
beachline. The fixed point of both is the coordinate where the new arc
intersected the old one. And the arc-intersection are the two
intersections between the new arc and the one that it splits. If the new
arc is <em>j</em> and the old one is <em>i</em>, the arc-intersections
are <code>[i,j]</code> and <code>[j,i]</code>.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a aria-hidden="true" href="#cb5-1" tabindex="-1"></a><span>## From the process_site_event function</span></span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2" tabindex="-1"></a>new_arc <span>=</span> <span># the new site event we&#39;re processing</span></span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3" tabindex="-1"></a>old_arc <span>=</span> <span># the old arc which is being split</span></span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5" tabindex="-1"></a>fix <span>=</span> [calc_x(old_arc, new_arc.y, new_arc.x), new_arc.y]</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6" tabindex="-1"></a>incomplete_edges[PointPair{old_arc, new_arc}] <span>=</span> fix</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7" tabindex="-1"></a>incomplete_edges[PointPair{new_arc, old_arc}] <span>=</span> fix</span></code></pre></div>
<p>In these pictures, I’ve put one of the incomplete edges in orange,
and the other in blue, to make it clear there are two. You can see how
the ‘center’ stays in the same place, but the other side changes with
the sweep line.</p>
<p><img src="https://macwright.com/2025/images/voronoi/incomplete_edge1.png"/></p>
<p><img src="https://macwright.com/2025/images/voronoi/incomplete_edge2.png"/></p>
<p>When two incomplete edges collide (during a circle event), the point
of collision becomes a Voronoi Vertex, and the incomplete edges turn
into half edges. Also a new incomplete edge is created where the fixed
point is the Voronoi Vertex.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a aria-hidden="true" href="#cb6-1" tabindex="-1"></a><span>## From the process_circle_event function</span></span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2" tabindex="-1"></a>mid_arc <span>=</span> <span># the arc that is getting squeezed</span></span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3" tabindex="-1"></a>up_arc  <span>=</span> <span># the arc that above it in the beachline</span></span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4" tabindex="-1"></a>down_arc  <span>=</span> <span># the arc that below it in the beachline</span></span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5" tabindex="-1"></a>add_vertex(vd, center_of_circle)</span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6" tabindex="-1"></a></span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7" tabindex="-1"></a>fix1 <span>=</span> incomplete_edges[PointPair{up_arc, mid_arc}]</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8" tabindex="-1"></a>add_half_edge(vd, center, fix1)</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9" tabindex="-1"></a></span>
<span id="cb6-10"><a aria-hidden="true" href="#cb6-10" tabindex="-1"></a>fix2 <span>=</span> incomplete_edges[PointPair{mid_arc, down_arc}]</span>
<span id="cb6-11"><a aria-hidden="true" href="#cb6-11" tabindex="-1"></a>add_half_edge(vd, center, fix2)</span>
<span id="cb6-12"><a aria-hidden="true" href="#cb6-12" tabindex="-1"></a></span>
<span id="cb6-13"><a aria-hidden="true" href="#cb6-13" tabindex="-1"></a><span># The new incomplete represents the new intersection</span></span>
<span id="cb6-14"><a aria-hidden="true" href="#cb6-14" tabindex="-1"></a>ft.incomplete_edges[PointPair{up_arc, down_arc}] <span>=</span> center</span></code></pre></div>
<p>In these pictures, you can see the incomplete edges ‘completing’ into
half edges (colored black), and the new incomplete edges coming out of
the intersection point.</p>
<p><img src="https://macwright.com/2025/images/voronoi/incomplete_edge3.png"/></p>
<p><img src="https://macwright.com/2025/images/voronoi/incomplete_edge4.png"/></p>
<h2 id="only-counterclockwise-circles-create-circle-events">Only
counterclockwise circles create circle events</h2>
<p>Look at this example. We’ve just processed the site k, and we have a
beachline <code>[i,j,k,j,i]</code>. We have the new potential circle
events <code>ijk</code> and <code>kji</code>. One of them is a circle
event. One of them is <em>not</em> a circle event. Scanning it visually,
it’s pretty obvious: The arcs at the top half of the picture,
<code>ijk</code>, will never have the middle arc squeezed, because the
lines are diverging. The arcs at the bottom half of the picture,
<code>kji</code>, clearly are going to converge, at the center of the
circle. So <code>kji</code> does create a circle event, but
<code>ijk</code> will not.</p>
<p><img src="https://macwright.com/2025/images/voronoi/ccw1.png"/></p>
<p>While it’s easy to see this visually, determining it programatically
is less intuitive. The trick is to realise that, when you read off the
points of the circle as <code>ijk</code>, they are going
<em>clockwise</em> around the circle. And if you read them as
<code>kji</code>, they are going counterclockwise. And this is test you
need to apply. You can do this by finding the determinant of the
points<sup><a href="#fn8" id="note8" title="Footnote 8">8</a></sup>.
A negative determinant means a counterclockwise orientation (and so a
circle event). A positive one means a clockwise one (and so no circle
event). A determinant of zero means the points are in a straight line
(no circle!)</p>

<h2 id="summary">Summary</h2>
<p>OK, so we have everything we need to do the algorithm now. To
summarize the whole thing:</p>
<ul>
<li>Given a set of sites put all the site point in a queue, as ‘site’
events, ordered by the x-value.</li>
<li>While the queue is not empty, pop the next event off the queue.</li>
<li>If the popped event is a site-type, do the following:
<ul>
<li>Go through all circle events that are ahead of it in the queue, and
determine if this site is inside the circle. If so, remove that circle
event from the queue.</li>
<li>Find the arc directly across from the site. Let that be <em>j</em>
in the beachline <code>[..,i,j,k,..]</code></li>
<li>insert the arc defined by that point (<em>L</em>) into the beachline
‘splitting’ j, so it becomes <code>[..,i,j,L,j,k,..]</code>.</li>
<li>add two imcomplete edges, both with the fixed point at the point the
new arc intersected the beachline, and the arc-intersections of the
split arc vs. new arc, and new arc vs. split arc.</li>
<li>Check the new triples <em>i,j,L</em> and <em>L,j,k</em> to see if
they form new circle events, and if so insert them in the event
queue.</li>
</ul></li>
<li>If the popped event is a circle-type do the following
<ul>
<li>Find the center of the circle, and add it as a vertex to the Voronoi
diagram.</li>
<li>Find the arc that is being squeezed out of existance, let it be
<em>j</em> in <code>[..,h,i,j,k,l,..]</code></li>
<li>Go through all circle events that are ahead of it, and check if the
removed arc invalidates the event.</li>
<li>remove it from the beachline, leaving
<code>[..,h,i,k,l,..]</code>.</li>
<li>Check the new triples <em>h,i,k</em> and <em>i,k,l</em> to see if
they form new circle events, and if so insert them in the event
queue.</li>
</ul></li>
<li>When the queue is empty, go through all remaining incomplete edges,
and if they are within the bounds of the diagram, extend them to the
diagram side, creating Voronoi Vertices at the point the hit the
side</li>
</ul>
<h2 id="implementing-fortunes-algorithm">Implementing Fortune’s
Algorithm</h2>
<h3 id="datastructure">Datastructure</h3>
<p>A bit of housekeeping: a <code>V2</code> is a <code>[2]int</code>. A
<code>PointPair</code> is a pair of <code>V2</code>s, i.e. a
<code>[2][2]int</code>.</p>
<p>An Event is a struct of <code>{site:bool, a,b,c:V2}</code>. The
boolean indicates what type of event it is: a site (true) or circle
(false). The three <code>V2</code>s have different semantics depending
on the event. If it’s a site, then <code>a</code> is just the
coordinates of the site, and the other two are unused. If it’s a circle,
then the three V2’s are the arcs in the beachline that generated the
event. Or put another way, the three sites that site on the perimeter of
the the circle.</p>
<p>For the algorithm itself, we need to store the following things:</p>
<ul>
<li>The <code>queue</code> is an array of Events. Technically it’s
better to have this as a priority queue, but it’s not really important
to the implementation of the algorithm.</li>
<li>The <code>beachline</code> is an array of <code>V2</code>s. Again,
for efficiency you this implement this as a binary tree.</li>
<li><code>incomplete_edges</code> is a dictionary/map of
<code>PointPair-&gt;V2</code></li>
</ul>
<h3 id="the-algorithm">The algorithm</h3>
<p>This is the code, written in the wonderful C alternative <a href="https://odin-lang.org">Odin</a>. The comments should hopefully
explain what is being done and why where it’s not clear from the
code<sup><a href="#fn9" id="note9" title="Footnote 9">9</a></sup>.</p>

<div id="cb7"><pre><code><span id="cb7-1"><a aria-hidden="true" href="#cb7-1" tabindex="-1"></a><span>package</span> voronoi</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2" tabindex="-1"></a><span>import</span> <span>&#34;core:math&#34;</span></span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3" tabindex="-1"></a><span>import</span> <span>&#34;core:log&#34;</span></span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4" tabindex="-1"></a></span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5" tabindex="-1"></a><span>/* Events can be site or circle events. site events are defined by a</span></span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6" tabindex="-1"></a><span>   single point, stored in a circle event are defined as the three</span></span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7" tabindex="-1"></a><span>   site points which define them. They are stored in a,b and c</span></span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8" tabindex="-1"></a><span>   respectively */</span></span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10" tabindex="-1"></a>Event <span>::</span> <span>struct</span> <span>{</span>site<span>:</span><span>bool</span><span>,</span> a<span>,</span>b<span>,</span>c<span>:</span>V2<span>}</span></span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11" tabindex="-1"></a></span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12" tabindex="-1"></a><span>event_x_coord </span><span>::</span><span> </span><span>proc</span><span>(</span>e<span>:</span>Event<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13" tabindex="-1"></a>    <span>if</span> e<span>.</span>site <span>do</span> <span>return</span> e<span>.</span>a<span>.</span>x</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14" tabindex="-1"></a>    <span>else</span> <span>{</span></span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15" tabindex="-1"></a>        _<span>,</span>_<span>,</span>cp <span>:=</span> <span>circle_point</span><span>(</span>e<span>.</span>a<span>,</span>e<span>.</span>b<span>,</span>e<span>.</span>c<span>)</span></span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16" tabindex="-1"></a>        <span>return</span> cp<span>.</span>x</span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-18"><a aria-hidden="true" href="#cb7-18" tabindex="-1"></a><span>}</span></span>
<span id="cb7-19"><a aria-hidden="true" href="#cb7-19" tabindex="-1"></a></span>
<span id="cb7-20"><a aria-hidden="true" href="#cb7-20" tabindex="-1"></a><span>event_y_coord </span><span>::</span><span> </span><span>proc</span><span>(</span>e<span>:</span>Event<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-21"><a aria-hidden="true" href="#cb7-21" tabindex="-1"></a>    <span>if</span> e<span>.</span>site <span>do</span> <span>return</span> e<span>.</span>a<span>.</span>y</span>
<span id="cb7-22"><a aria-hidden="true" href="#cb7-22" tabindex="-1"></a>    <span>else</span> <span>{</span></span>
<span id="cb7-23"><a aria-hidden="true" href="#cb7-23" tabindex="-1"></a>        _<span>,</span>_<span>,</span>cp <span>:=</span> <span>circle_point</span><span>(</span>e<span>.</span>a<span>,</span>e<span>.</span>b<span>,</span>e<span>.</span>c<span>)</span></span>
<span id="cb7-24"><a aria-hidden="true" href="#cb7-24" tabindex="-1"></a>        <span>return</span> cp<span>.</span>y</span>
<span id="cb7-25"><a aria-hidden="true" href="#cb7-25" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-26"><a aria-hidden="true" href="#cb7-26" tabindex="-1"></a><span>}</span></span>
<span id="cb7-27"><a aria-hidden="true" href="#cb7-27" tabindex="-1"></a></span>
<span id="cb7-28"><a aria-hidden="true" href="#cb7-28" tabindex="-1"></a>PointPair <span>::</span> <span>[</span><span>2</span><span>]</span>V2</span>
<span id="cb7-29"><a aria-hidden="true" href="#cb7-29" tabindex="-1"></a></span>
<span id="cb7-30"><a aria-hidden="true" href="#cb7-30" tabindex="-1"></a><span>/* An &#34;Incomplete Edge&#34; is an edge between a point (which doesn&#39;t</span></span>
<span id="cb7-31"><a aria-hidden="true" href="#cb7-31" tabindex="-1"></a><span>   change) and the intersection of two parabola defined by two focus</span></span>
<span id="cb7-32"><a aria-hidden="true" href="#cb7-32" tabindex="-1"></a><span>   points (which does change, with the directrix). These will</span></span>
<span id="cb7-33"><a aria-hidden="true" href="#cb7-33" tabindex="-1"></a><span>   ultimately become the half-edges of the DCEL, when two such</span></span>
<span id="cb7-34"><a aria-hidden="true" href="#cb7-34" tabindex="-1"></a><span>   intersections meet.</span></span>
<span id="cb7-35"><a aria-hidden="true" href="#cb7-35" tabindex="-1"></a></span>
<span id="cb7-36"><a aria-hidden="true" href="#cb7-36" tabindex="-1"></a><span>   The meaning of the fixed point - which I&#39;ll call the reference - is</span></span>
<span id="cb7-37"><a aria-hidden="true" href="#cb7-37" tabindex="-1"></a><span>   different depending on what created it. The pair of incomplete</span></span>
<span id="cb7-38"><a aria-hidden="true" href="#cb7-38" tabindex="-1"></a><span>   edges created by a site event start at the point at which the site</span></span>
<span id="cb7-39"><a aria-hidden="true" href="#cb7-39" tabindex="-1"></a><span>   arc intersected the beachline. So it&#39;s sort of like the midpoint of</span></span>
<span id="cb7-40"><a aria-hidden="true" href="#cb7-40" tabindex="-1"></a><span>   the edge (though not literally in the middle). If it&#39;s created by a</span></span>
<span id="cb7-41"><a aria-hidden="true" href="#cb7-41" tabindex="-1"></a><span>   circle event, the fixed point is the vertex in the VD which was</span></span>
<span id="cb7-42"><a aria-hidden="true" href="#cb7-42" tabindex="-1"></a><span>   created by that circle event. */</span></span>
<span id="cb7-43"><a aria-hidden="true" href="#cb7-43" tabindex="-1"></a></span>
<span id="cb7-44"><a aria-hidden="true" href="#cb7-44" tabindex="-1"></a>Fortune <span>::</span> <span>struct</span> <span>{</span></span>
<span id="cb7-45"><a aria-hidden="true" href="#cb7-45" tabindex="-1"></a>    beachline<span>:[</span><span>dynamic</span><span>]</span>V2<span>,</span></span>
<span id="cb7-46"><a aria-hidden="true" href="#cb7-46" tabindex="-1"></a>    queue<span>:[</span><span>dynamic</span><span>]</span>Event<span>,</span></span>
<span id="cb7-47"><a aria-hidden="true" href="#cb7-47" tabindex="-1"></a>    incomplete_edges<span>:</span><span>map</span><span>[</span>PointPair<span>]</span>V2<span>,</span></span>
<span id="cb7-48"><a aria-hidden="true" href="#cb7-48" tabindex="-1"></a>    vd<span>:</span>DCEL<span>,</span></span>
<span id="cb7-49"><a aria-hidden="true" href="#cb7-49" tabindex="-1"></a><span>}</span></span>
<span id="cb7-50"><a aria-hidden="true" href="#cb7-50" tabindex="-1"></a></span>
<span id="cb7-51"><a aria-hidden="true" href="#cb7-51" tabindex="-1"></a><span>add_site_event </span><span>::</span><span> </span><span>proc</span><span>(</span>q<span>:^[</span><span>dynamic</span><span>]</span>Event<span>,</span> v<span>:</span>V2<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-52"><a aria-hidden="true" href="#cb7-52" tabindex="-1"></a>    <span>return</span> <span>add_event_ordered</span><span>(</span>q<span>,</span> Event<span>{</span><span>true</span><span>,</span> v<span>,</span> <span>{},{}})</span></span>
<span id="cb7-53"><a aria-hidden="true" href="#cb7-53" tabindex="-1"></a><span>}</span></span>
<span id="cb7-54"><a aria-hidden="true" href="#cb7-54" tabindex="-1"></a></span>
<span id="cb7-55"><a aria-hidden="true" href="#cb7-55" tabindex="-1"></a><span>add_circle_event </span><span>::</span><span> </span><span>proc</span><span>(</span>q<span>:^[</span><span>dynamic</span><span>]</span>Event<span>,</span> a<span>,</span>b<span>,</span>c<span>:</span>V2<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-56"><a aria-hidden="true" href="#cb7-56" tabindex="-1"></a>    <span>return</span> <span>add_event_ordered</span><span>(</span>q<span>,</span> Event<span>{</span><span>false</span><span>,</span> a<span>,</span>b<span>,</span>c<span>})</span></span>
<span id="cb7-57"><a aria-hidden="true" href="#cb7-57" tabindex="-1"></a><span>}</span></span>
<span id="cb7-58"><a aria-hidden="true" href="#cb7-58" tabindex="-1"></a></span>
<span id="cb7-59"><a aria-hidden="true" href="#cb7-59" tabindex="-1"></a><span>add_event_ordered </span><span>::</span><span> </span><span>proc</span><span>(</span>queue<span>:^[</span><span>dynamic</span><span>]</span>Event<span>,</span> ev<span>:</span>Event<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-60"><a aria-hidden="true" href="#cb7-60" tabindex="-1"></a>    <span>// inserts an event into the queue by it&#39;s x value</span></span>
<span id="cb7-61"><a aria-hidden="true" href="#cb7-61" tabindex="-1"></a>    <span>if</span> <span>len</span><span>(</span>queue<span>)</span> <span>==</span> <span>0</span> <span>{</span></span>
<span id="cb7-62"><a aria-hidden="true" href="#cb7-62" tabindex="-1"></a>        <span>append</span><span>(</span>queue<span>,</span> ev<span>)</span></span>
<span id="cb7-63"><a aria-hidden="true" href="#cb7-63" tabindex="-1"></a>        <span>return</span> <span>0</span></span>
<span id="cb7-64"><a aria-hidden="true" href="#cb7-64" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-65"><a aria-hidden="true" href="#cb7-65" tabindex="-1"></a></span>
<span id="cb7-66"><a aria-hidden="true" href="#cb7-66" tabindex="-1"></a>    <span>this_x </span><span>:=</span> <span>event_x_coord</span><span>(</span>ev<span>)</span></span>
<span id="cb7-67"><a aria-hidden="true" href="#cb7-67" tabindex="-1"></a></span>
<span id="cb7-68"><a aria-hidden="true" href="#cb7-68" tabindex="-1"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..&lt;</span><span>len</span><span>(</span>queue<span>)</span> <span>{</span></span>
<span id="cb7-69"><a aria-hidden="true" href="#cb7-69" tabindex="-1"></a>        <span>other </span><span>:=</span> queue<span>[</span>i<span>]</span></span>
<span id="cb7-70"><a aria-hidden="true" href="#cb7-70" tabindex="-1"></a>        <span>other_x </span><span>:=</span> <span>event_x_coord</span><span>(</span>other<span>)</span></span>
<span id="cb7-71"><a aria-hidden="true" href="#cb7-71" tabindex="-1"></a>        <span>if</span> this_x <span>==</span> other_x <span>{</span></span>
<span id="cb7-72"><a aria-hidden="true" href="#cb7-72" tabindex="-1"></a>            <span>this_y </span><span>:=</span> <span>event_y_coord</span><span>(</span>ev<span>)</span></span>
<span id="cb7-73"><a aria-hidden="true" href="#cb7-73" tabindex="-1"></a>            <span>other_y </span><span>:=</span> <span>event_y_coord</span><span>(</span>other<span>)</span></span>
<span id="cb7-74"><a aria-hidden="true" href="#cb7-74" tabindex="-1"></a>            <span>if</span> this_y <span>==</span> other_y <span>{</span></span>
<span id="cb7-75"><a aria-hidden="true" href="#cb7-75" tabindex="-1"></a>                <span>// We just ignore this duplicated event</span></span>
<span id="cb7-76"><a aria-hidden="true" href="#cb7-76" tabindex="-1"></a>                <span>return</span> i</span>
<span id="cb7-77"><a aria-hidden="true" href="#cb7-77" tabindex="-1"></a>            <span>}</span> <span>else</span> <span>if</span> this_y <span>&lt;</span> other_y <span>{</span></span>
<span id="cb7-78"><a aria-hidden="true" href="#cb7-78" tabindex="-1"></a>                <span>inject_at</span><span>(</span>queue<span>,</span> i<span>,</span> ev<span>)</span></span>
<span id="cb7-79"><a aria-hidden="true" href="#cb7-79" tabindex="-1"></a>                <span>return</span> i</span>
<span id="cb7-80"><a aria-hidden="true" href="#cb7-80" tabindex="-1"></a>            <span>}</span></span>
<span id="cb7-81"><a aria-hidden="true" href="#cb7-81" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-82"><a aria-hidden="true" href="#cb7-82" tabindex="-1"></a>        <span>else</span> <span>if</span> this_x <span>&lt;</span> other_x <span>{</span></span>
<span id="cb7-83"><a aria-hidden="true" href="#cb7-83" tabindex="-1"></a>            <span>inject_at</span><span>(</span>queue<span>,</span> i<span>,</span> ev<span>)</span></span>
<span id="cb7-84"><a aria-hidden="true" href="#cb7-84" tabindex="-1"></a>            <span>return</span> i</span>
<span id="cb7-85"><a aria-hidden="true" href="#cb7-85" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-86"><a aria-hidden="true" href="#cb7-86" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-87"><a aria-hidden="true" href="#cb7-87" tabindex="-1"></a>    <span>append</span><span>(</span>queue<span>,</span> ev<span>)</span></span>
<span id="cb7-88"><a aria-hidden="true" href="#cb7-88" tabindex="-1"></a>    <span>return</span> <span>len</span><span>(</span>queue<span>)-</span><span>1</span></span>
<span id="cb7-89"><a aria-hidden="true" href="#cb7-89" tabindex="-1"></a><span>}</span></span>
<span id="cb7-90"><a aria-hidden="true" href="#cb7-90" tabindex="-1"></a></span>
<span id="cb7-91"><a aria-hidden="true" href="#cb7-91" tabindex="-1"></a><span>initialise_fortune </span><span>::</span><span> </span><span>proc</span><span>(</span>f<span>:^</span>Fortune<span>,</span> sites<span>:[]</span>V2<span>)</span> <span>{</span></span>
<span id="cb7-92"><a aria-hidden="true" href="#cb7-92" tabindex="-1"></a>    <span>clear</span><span>(&amp;</span>f<span>.</span>beachline<span>)</span></span>
<span id="cb7-93"><a aria-hidden="true" href="#cb7-93" tabindex="-1"></a>    <span>clear</span><span>(&amp;</span>f<span>.</span>queue<span>)</span></span>
<span id="cb7-94"><a aria-hidden="true" href="#cb7-94" tabindex="-1"></a>    <span>clear</span><span>(&amp;</span>f<span>.</span>incomplete_edges<span>)</span></span>
<span id="cb7-95"><a aria-hidden="true" href="#cb7-95" tabindex="-1"></a>    <span>clear_vd</span><span>(&amp;</span>f<span>.</span>vd<span>)</span></span>
<span id="cb7-96"><a aria-hidden="true" href="#cb7-96" tabindex="-1"></a>    <span>for</span> site <span>in</span> sites <span>do</span> <span>add_site_event</span><span>(&amp;</span>f<span>.</span>queue<span>,</span> site<span>)</span></span>
<span id="cb7-97"><a aria-hidden="true" href="#cb7-97" tabindex="-1"></a><span>}</span></span>
<span id="cb7-98"><a aria-hidden="true" href="#cb7-98" tabindex="-1"></a></span>
<span id="cb7-99"><a aria-hidden="true" href="#cb7-99" tabindex="-1"></a><span>process_site_event </span><span>::</span><span> </span><span>proc</span><span>(</span>ft<span>:^</span>Fortune<span>,</span> e<span>:</span>Event<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-100"><a aria-hidden="true" href="#cb7-100" tabindex="-1"></a>    <span>site </span><span>:=</span> e<span>.</span>a</span>
<span id="cb7-101"><a aria-hidden="true" href="#cb7-101" tabindex="-1"></a>    <span>/* We need to check if this site is within the radius of any</span></span>
<span id="cb7-102"><a aria-hidden="true" href="#cb7-102" tabindex="-1"></a><span>    upcoming circle events, because this will cause them to be</span></span>
<span id="cb7-103"><a aria-hidden="true" href="#cb7-103" tabindex="-1"></a><span>    cancelled (a &#39;false alarm&#39;). */</span></span>
<span id="cb7-104"><a aria-hidden="true" href="#cb7-104" tabindex="-1"></a></span>
<span id="cb7-105"><a aria-hidden="true" href="#cb7-105" tabindex="-1"></a>    <span>i</span><span>:=</span><span>0</span></span>
<span id="cb7-106"><a aria-hidden="true" href="#cb7-106" tabindex="-1"></a>    <span>for</span> i <span>&lt;</span> <span>len</span><span>(</span>ft<span>.</span>queue<span>)</span> <span>{</span></span>
<span id="cb7-107"><a aria-hidden="true" href="#cb7-107" tabindex="-1"></a>        <span>cev </span><span>:=</span> ft<span>.</span>queue<span>[</span>i<span>]</span></span>
<span id="cb7-108"><a aria-hidden="true" href="#cb7-108" tabindex="-1"></a>        <span>if</span> <span>!</span>cev<span>.</span>site <span>{</span></span>
<span id="cb7-109"><a aria-hidden="true" href="#cb7-109" tabindex="-1"></a>            ctr<span>,</span> r<span>,</span> cp <span>:=</span> <span>circle_point</span><span>(</span>cev<span>.</span>a<span>,</span> cev<span>.</span>b<span>,</span> cev<span>.</span>c<span>)</span></span>
<span id="cb7-110"><a aria-hidden="true" href="#cb7-110" tabindex="-1"></a>            <span>/* Adding 1 makes it a bit more conservative */</span></span>
<span id="cb7-111"><a aria-hidden="true" href="#cb7-111" tabindex="-1"></a>            <span>test </span><span>:=</span> <span>f32</span><span>(</span>r<span>)+</span><span>1.1</span></span>
<span id="cb7-112"><a aria-hidden="true" href="#cb7-112" tabindex="-1"></a>            <span>ed </span><span>:=</span> <span>euclid_distance</span><span>(</span>ctr<span>,</span> site<span>)</span></span>
<span id="cb7-113"><a aria-hidden="true" href="#cb7-113" tabindex="-1"></a>            <span>if</span> ed <span>&lt;</span> test <span>{</span></span>
<span id="cb7-114"><a aria-hidden="true" href="#cb7-114" tabindex="-1"></a>                <span>ordered_remove</span><span>(&amp;</span>ft<span>.</span>queue<span>,</span> i<span>)</span></span>
<span id="cb7-115"><a aria-hidden="true" href="#cb7-115" tabindex="-1"></a>                i <span>-=</span> <span>1</span></span>
<span id="cb7-116"><a aria-hidden="true" href="#cb7-116" tabindex="-1"></a>            <span>}</span></span>
<span id="cb7-117"><a aria-hidden="true" href="#cb7-117" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-118"><a aria-hidden="true" href="#cb7-118" tabindex="-1"></a>        i <span>+=</span> <span>1</span></span>
<span id="cb7-119"><a aria-hidden="true" href="#cb7-119" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-120"><a aria-hidden="true" href="#cb7-120" tabindex="-1"></a></span>
<span id="cb7-121"><a aria-hidden="true" href="#cb7-121" tabindex="-1"></a>    <span>/* Trivial case of an empty beachline - just add it  */</span></span>
<span id="cb7-122"><a aria-hidden="true" href="#cb7-122" tabindex="-1"></a></span>
<span id="cb7-123"><a aria-hidden="true" href="#cb7-123" tabindex="-1"></a>    <span>if</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)</span> <span>==</span> <span>0</span> <span>{</span></span>
<span id="cb7-124"><a aria-hidden="true" href="#cb7-124" tabindex="-1"></a>        <span>append</span><span>(&amp;</span>ft<span>.</span>beachline<span>,</span> site<span>)</span></span>
<span id="cb7-125"><a aria-hidden="true" href="#cb7-125" tabindex="-1"></a>        <span>return</span> <span>0</span></span>
<span id="cb7-126"><a aria-hidden="true" href="#cb7-126" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-127"><a aria-hidden="true" href="#cb7-127" tabindex="-1"></a></span>
<span id="cb7-128"><a aria-hidden="true" href="#cb7-128" tabindex="-1"></a>    <span>/* Walk the beachline from top to bottom, for each arc checking</span></span>
<span id="cb7-129"><a aria-hidden="true" href="#cb7-129" tabindex="-1"></a><span>    the y coordinate of the intersection with the following arc to see</span></span>
<span id="cb7-130"><a aria-hidden="true" href="#cb7-130" tabindex="-1"></a><span>    if it&#39;s greater than our site y. The first arc that meets this</span></span>
<span id="cb7-131"><a aria-hidden="true" href="#cb7-131" tabindex="-1"></a><span>    condition is the one which our new site will split. I set</span></span>
<span id="cb7-132"><a aria-hidden="true" href="#cb7-132" tabindex="-1"></a><span>    insert_after as len-1, so it&#39;ll insert at the end if there is</span></span>
<span id="cb7-133"><a aria-hidden="true" href="#cb7-133" tabindex="-1"></a><span>    none.*/</span></span>
<span id="cb7-134"><a aria-hidden="true" href="#cb7-134" tabindex="-1"></a></span>
<span id="cb7-135"><a aria-hidden="true" href="#cb7-135" tabindex="-1"></a>    <span>d </span><span>:=</span> site<span>.</span>x</span>
<span id="cb7-136"><a aria-hidden="true" href="#cb7-136" tabindex="-1"></a>    <span>insert_after </span><span>:=</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>1</span></span>
<span id="cb7-137"><a aria-hidden="true" href="#cb7-137" tabindex="-1"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..&lt;</span><span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>1</span> <span>{</span></span>
<span id="cb7-138"><a aria-hidden="true" href="#cb7-138" tabindex="-1"></a>        b<span>,</span> _<span>,</span> _ <span>:=</span> <span>intersection</span><span>(</span>ft<span>.</span>beachline<span>[</span>i<span>],</span> ft<span>.</span>beachline<span>[</span>i<span>+</span><span>1</span><span>],</span> d<span>)</span></span>
<span id="cb7-139"><a aria-hidden="true" href="#cb7-139" tabindex="-1"></a>        <span>if</span> b<span>.</span>y <span>&gt;</span> site<span>.</span>y <span>{</span></span>
<span id="cb7-140"><a aria-hidden="true" href="#cb7-140" tabindex="-1"></a>            insert_after <span>=</span> i</span>
<span id="cb7-141"><a aria-hidden="true" href="#cb7-141" tabindex="-1"></a>            <span>break</span></span>
<span id="cb7-142"><a aria-hidden="true" href="#cb7-142" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-143"><a aria-hidden="true" href="#cb7-143" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-144"><a aria-hidden="true" href="#cb7-144" tabindex="-1"></a></span>
<span id="cb7-145"><a aria-hidden="true" href="#cb7-145" tabindex="-1"></a>    <span>/* The site is inserted into the beachline, and a copy of the arc</span></span>
<span id="cb7-146"><a aria-hidden="true" href="#cb7-146" tabindex="-1"></a><span>    is inserted after that. This has the effect of &#39;splitting&#39; the</span></span>
<span id="cb7-147"><a aria-hidden="true" href="#cb7-147" tabindex="-1"></a><span>    arc, so if the beachline is abCde, where C is intersected arc,</span></span>
<span id="cb7-148"><a aria-hidden="true" href="#cb7-148" tabindex="-1"></a><span>    after this operation it will be acCSCde, where S is the new site</span></span>
<span id="cb7-149"><a aria-hidden="true" href="#cb7-149" tabindex="-1"></a><span>    we&#39;re adding. This creates two new intersections: Between CS and</span></span>
<span id="cb7-150"><a aria-hidden="true" href="#cb7-150" tabindex="-1"></a><span>    SC */</span></span>
<span id="cb7-151"><a aria-hidden="true" href="#cb7-151" tabindex="-1"></a></span>
<span id="cb7-152"><a aria-hidden="true" href="#cb7-152" tabindex="-1"></a>    <span>arc </span><span>:=</span> ft<span>.</span>beachline<span>[</span>insert_after<span>]</span></span>
<span id="cb7-153"><a aria-hidden="true" href="#cb7-153" tabindex="-1"></a>    <span>inject_at</span><span>(&amp;</span>ft<span>.</span>beachline<span>,</span> insert_after<span>+</span><span>1</span><span>,</span> site<span>)</span></span>
<span id="cb7-154"><a aria-hidden="true" href="#cb7-154" tabindex="-1"></a></span>
<span id="cb7-155"><a aria-hidden="true" href="#cb7-155" tabindex="-1"></a>    <span>/* We have to handle the special case where the arc and site have</span></span>
<span id="cb7-156"><a aria-hidden="true" href="#cb7-156" tabindex="-1"></a><span>    the same x coordindate, and therefore have only one intersection*/</span></span>
<span id="cb7-157"><a aria-hidden="true" href="#cb7-157" tabindex="-1"></a></span>
<span id="cb7-158"><a aria-hidden="true" href="#cb7-158" tabindex="-1"></a>    <span>same_x </span><span>:=</span> arc<span>.</span>x <span>==</span> site<span>.</span>x</span>
<span id="cb7-159"><a aria-hidden="true" href="#cb7-159" tabindex="-1"></a></span>
<span id="cb7-160"><a aria-hidden="true" href="#cb7-160" tabindex="-1"></a>    <span>if</span> <span>!</span>same_x <span>do</span> <span>inject_at</span><span>(&amp;</span>ft<span>.</span>beachline<span>,</span> insert_after<span>+</span><span>2</span><span>,</span> arc<span>)</span></span>
<span id="cb7-161"><a aria-hidden="true" href="#cb7-161" tabindex="-1"></a></span>
<span id="cb7-162"><a aria-hidden="true" href="#cb7-162" tabindex="-1"></a>    <span>/* Calculate the point at which a horizontal line from the new</span></span>
<span id="cb7-163"><a aria-hidden="true" href="#cb7-163" tabindex="-1"></a><span>    site intersects the arc. This becomes the reference point for two</span></span>
<span id="cb7-164"><a aria-hidden="true" href="#cb7-164" tabindex="-1"></a><span>    incomplete edges, one for each of the new intersections we</span></span>
<span id="cb7-165"><a aria-hidden="true" href="#cb7-165" tabindex="-1"></a><span>    created. by inserting the new arc into the beachline.*/</span></span>
<span id="cb7-166"><a aria-hidden="true" href="#cb7-166" tabindex="-1"></a></span>
<span id="cb7-167"><a aria-hidden="true" href="#cb7-167" tabindex="-1"></a>    <span>ref </span><span>:=</span> V2<span>{</span><span>calc_x</span><span>(</span>arc<span>,</span> site<span>.</span>y<span>,</span> site<span>.</span>x<span>),</span> site<span>.</span>y<span>}</span></span>
<span id="cb7-168"><a aria-hidden="true" href="#cb7-168" tabindex="-1"></a></span>
<span id="cb7-169"><a aria-hidden="true" href="#cb7-169" tabindex="-1"></a>    <span>/* Once more, we need to handle the special case of equal xs. We</span></span>
<span id="cb7-170"><a aria-hidden="true" href="#cb7-170" tabindex="-1"></a><span>    create the reference point off-map so it will be properly cleaned up*/</span></span>
<span id="cb7-171"><a aria-hidden="true" href="#cb7-171" tabindex="-1"></a></span>
<span id="cb7-172"><a aria-hidden="true" href="#cb7-172" tabindex="-1"></a>    <span>if</span> same_x <span>do</span> ref <span>=</span> <span>{-</span><span>1</span><span>,</span><span> </span><span>(</span>site<span>.</span>y<span>+</span>arc<span>.</span>y<span>)/</span><span>2</span><span>}</span></span>
<span id="cb7-173"><a aria-hidden="true" href="#cb7-173" tabindex="-1"></a></span>
<span id="cb7-174"><a aria-hidden="true" href="#cb7-174" tabindex="-1"></a>    <span>if</span> <span>!</span>same_x <span>{</span></span>
<span id="cb7-175"><a aria-hidden="true" href="#cb7-175" tabindex="-1"></a>        ft<span>.</span>incomplete_edges<span>[</span>PointPair<span>{</span>site<span>,</span> arc<span>}]</span> <span>=</span> ref</span>
<span id="cb7-176"><a aria-hidden="true" href="#cb7-176" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-177"><a aria-hidden="true" href="#cb7-177" tabindex="-1"></a>    ft<span>.</span>incomplete_edges<span>[</span>PointPair<span>{</span>arc<span>,</span> site<span>}]</span> <span>=</span> ref</span>
<span id="cb7-178"><a aria-hidden="true" href="#cb7-178" tabindex="-1"></a></span>
<span id="cb7-179"><a aria-hidden="true" href="#cb7-179" tabindex="-1"></a>    <span>/* Check the new arc against the two arcs above it and below it in</span></span>
<span id="cb7-180"><a aria-hidden="true" href="#cb7-180" tabindex="-1"></a><span>    the beachline to see if there are any new circle events we need to</span></span>
<span id="cb7-181"><a aria-hidden="true" href="#cb7-181" tabindex="-1"></a><span>    add to the queue */</span></span>
<span id="cb7-182"><a aria-hidden="true" href="#cb7-182" tabindex="-1"></a></span>
<span id="cb7-183"><a aria-hidden="true" href="#cb7-183" tabindex="-1"></a>    <span>new_arc_idx </span><span>:=</span> insert_after<span>+</span><span>1</span></span>
<span id="cb7-184"><a aria-hidden="true" href="#cb7-184" tabindex="-1"></a>    <span>if</span> new_arc_idx <span>&gt;=</span><span>2</span> <span>do</span> <span>new_circle_event</span><span>(</span>ft<span>,</span> new_arc_idx<span>-</span><span>2</span><span>)</span></span>
<span id="cb7-185"><a aria-hidden="true" href="#cb7-185" tabindex="-1"></a>    <span>if</span> new_arc_idx <span>&lt;=</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>3</span> <span>do</span> <span>new_circle_event</span><span>(</span>ft<span>,</span> new_arc_idx<span>)</span></span>
<span id="cb7-186"><a aria-hidden="true" href="#cb7-186" tabindex="-1"></a></span>
<span id="cb7-187"><a aria-hidden="true" href="#cb7-187" tabindex="-1"></a></span>
<span id="cb7-188"><a aria-hidden="true" href="#cb7-188" tabindex="-1"></a>    <span>return</span> new_arc_idx</span>
<span id="cb7-189"><a aria-hidden="true" href="#cb7-189" tabindex="-1"></a><span>}</span></span>
<span id="cb7-190"><a aria-hidden="true" href="#cb7-190" tabindex="-1"></a></span>
<span id="cb7-191"><a aria-hidden="true" href="#cb7-191" tabindex="-1"></a><span>circle_point </span><span>::</span><span> </span><span>proc</span><span>(</span>a<span>,</span>b<span>,</span>c<span>:</span>V2<span>)</span> <span>-&gt;</span><span> </span><span>(</span>center<span>:</span>V2<span>,</span> radius<span>:</span><span>int</span><span>,</span> circle_point<span>:</span>V2<span>)</span> <span>{</span></span>
<span id="cb7-192"><a aria-hidden="true" href="#cb7-192" tabindex="-1"></a>    <span>/* Given three points, calculate the circumcircle which passes</span></span>
<span id="cb7-193"><a aria-hidden="true" href="#cb7-193" tabindex="-1"></a><span>    through all three points. It returns the center and radius of the</span></span>
<span id="cb7-194"><a aria-hidden="true" href="#cb7-194" tabindex="-1"></a><span>    circle, as well as the circle-point, that being the right-most</span></span>
<span id="cb7-195"><a aria-hidden="true" href="#cb7-195" tabindex="-1"></a><span>    point of the circle.</span></span>
<span id="cb7-196"><a aria-hidden="true" href="#cb7-196" tabindex="-1"></a></span>
<span id="cb7-197"><a aria-hidden="true" href="#cb7-197" tabindex="-1"></a><span>    https://en.wikipedia.org/wiki/Circumcircle</span></span>
<span id="cb7-198"><a aria-hidden="true" href="#cb7-198" tabindex="-1"></a><span>    */</span></span>
<span id="cb7-199"><a aria-hidden="true" href="#cb7-199" tabindex="-1"></a></span>
<span id="cb7-200"><a aria-hidden="true" href="#cb7-200" tabindex="-1"></a>    <span>/* normalize on a */</span></span>
<span id="cb7-201"><a aria-hidden="true" href="#cb7-201" tabindex="-1"></a>    <span>b </span><span>:=</span> b<span>-</span>a</span>
<span id="cb7-202"><a aria-hidden="true" href="#cb7-202" tabindex="-1"></a>    <span>c </span><span>:=</span> c<span>-</span>a</span>
<span id="cb7-203"><a aria-hidden="true" href="#cb7-203" tabindex="-1"></a>    <span>D </span><span>:=</span> <span>f32</span><span>(</span><span>2</span><span>*(</span>b<span>.</span>x<span>*</span>c<span>.</span>y<span>-</span>b<span>.</span>y<span>*</span>c<span>.</span>x<span>))</span></span>
<span id="cb7-204"><a aria-hidden="true" href="#cb7-204" tabindex="-1"></a></span>
<span id="cb7-205"><a aria-hidden="true" href="#cb7-205" tabindex="-1"></a>    u<span>:</span>V2f</span>
<span id="cb7-206"><a aria-hidden="true" href="#cb7-206" tabindex="-1"></a>    u<span>.</span>x <span>=</span> <span>f32</span><span>(</span>c<span>.</span>y<span>*(</span>b<span>.</span>x<span>*</span>b<span>.</span>x<span>+</span>b<span>.</span>y<span>*</span>b<span>.</span>y<span>)-</span>b<span>.</span>y<span>*(</span>c<span>.</span>x<span>*</span>c<span>.</span>x<span>+</span>c<span>.</span>y<span>*</span>c<span>.</span>y<span>))</span></span>
<span id="cb7-207"><a aria-hidden="true" href="#cb7-207" tabindex="-1"></a>    u<span>.</span>x <span>/=</span> D</span>
<span id="cb7-208"><a aria-hidden="true" href="#cb7-208" tabindex="-1"></a>    u<span>.</span>y <span>=</span> <span>f32</span><span>(</span>b<span>.</span>x<span>*(</span>c<span>.</span>x<span>*</span>c<span>.</span>x<span>+</span>c<span>.</span>y<span>*</span>c<span>.</span>y<span>)-</span>c<span>.</span>x<span>*(</span>b<span>.</span>x<span>*</span>b<span>.</span>x<span>+</span>b<span>.</span>y<span>*</span>b<span>.</span>y<span>))</span></span>
<span id="cb7-209"><a aria-hidden="true" href="#cb7-209" tabindex="-1"></a>    u<span>.</span>y <span>/=</span> D</span>
<span id="cb7-210"><a aria-hidden="true" href="#cb7-210" tabindex="-1"></a></span>
<span id="cb7-211"><a aria-hidden="true" href="#cb7-211" tabindex="-1"></a>    <span>r </span><span>:=</span> math<span>.</span><span>sqrt</span><span>(</span>u<span>.</span>x<span>*</span>u<span>.</span>x <span>+</span> u<span>.</span>y<span>*</span>u<span>.</span>y<span>)</span></span>
<span id="cb7-212"><a aria-hidden="true" href="#cb7-212" tabindex="-1"></a>    <span>ui </span><span>:=</span> <span>V2f_to_i</span><span>(</span>u<span>)+</span>a</span>
<span id="cb7-213"><a aria-hidden="true" href="#cb7-213" tabindex="-1"></a>    <span>return</span> ui<span>,</span> <span>int</span><span>(</span>r<span>),</span> ui<span>+</span>V2<span>{</span><span>int</span><span>(</span>r<span>),</span> <span>0</span><span>}</span></span>
<span id="cb7-214"><a aria-hidden="true" href="#cb7-214" tabindex="-1"></a><span>}</span></span>
<span id="cb7-215"><a aria-hidden="true" href="#cb7-215" tabindex="-1"></a></span>
<span id="cb7-216"><a aria-hidden="true" href="#cb7-216" tabindex="-1"></a><span>new_circle_event </span><span>::</span><span> </span><span>proc</span><span>(</span>ft<span>:^</span>Fortune<span>,</span> start_at<span>:</span><span>int</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-217"><a aria-hidden="true" href="#cb7-217" tabindex="-1"></a>    <span>assert</span><span>(</span>start_at <span>&gt;=</span> <span>0</span><span>)</span></span>
<span id="cb7-218"><a aria-hidden="true" href="#cb7-218" tabindex="-1"></a>    <span>assert</span><span>(</span><span>len</span><span>(</span>ft<span>.</span>beachline<span>)</span> <span>&gt;</span> start_at<span>+</span><span>2</span><span>)</span></span>
<span id="cb7-219"><a aria-hidden="true" href="#cb7-219" tabindex="-1"></a></span>
<span id="cb7-220"><a aria-hidden="true" href="#cb7-220" tabindex="-1"></a>    <span>/* A circle event is created if three sites in a beachline sit on</span></span>
<span id="cb7-221"><a aria-hidden="true" href="#cb7-221" tabindex="-1"></a><span>    counterclockwise circle, which is what taking the determinant</span></span>
<span id="cb7-222"><a aria-hidden="true" href="#cb7-222" tabindex="-1"></a><span>    checks. Basically, if the points i,j,k are counterclockwise, the</span></span>
<span id="cb7-223"><a aria-hidden="true" href="#cb7-223" tabindex="-1"></a><span>    lines defined by equipoints of i,j and j,k will converge, and if</span></span>
<span id="cb7-224"><a aria-hidden="true" href="#cb7-224" tabindex="-1"></a><span>    they are clockwise (or they sit on a straight line, with a</span></span>
<span id="cb7-225"><a aria-hidden="true" href="#cb7-225" tabindex="-1"></a><span>    determinant of zero), they won&#39;t.</span></span>
<span id="cb7-226"><a aria-hidden="true" href="#cb7-226" tabindex="-1"></a></span>
<span id="cb7-227"><a aria-hidden="true" href="#cb7-227" tabindex="-1"></a><span>    It&#39;s important to check this, because consider the beachline</span></span>
<span id="cb7-228"><a aria-hidden="true" href="#cb7-228" tabindex="-1"></a><span>    ijkji. Both ijk and kji will form a circle, but only one will be</span></span>
<span id="cb7-229"><a aria-hidden="true" href="#cb7-229" tabindex="-1"></a><span>    valid.*/</span></span>
<span id="cb7-230"><a aria-hidden="true" href="#cb7-230" tabindex="-1"></a></span>
<span id="cb7-231"><a aria-hidden="true" href="#cb7-231" tabindex="-1"></a>    <span>h</span><span>:=</span>ft<span>.</span>beachline<span>[</span>start_at<span>]</span></span>
<span id="cb7-232"><a aria-hidden="true" href="#cb7-232" tabindex="-1"></a>    <span>j</span><span>:=</span>ft<span>.</span>beachline<span>[</span>start_at<span>+</span><span>1</span><span>]</span></span>
<span id="cb7-233"><a aria-hidden="true" href="#cb7-233" tabindex="-1"></a>    <span>k</span><span>:=</span>ft<span>.</span>beachline<span>[</span>start_at<span>+</span><span>2</span><span>]</span></span>
<span id="cb7-234"><a aria-hidden="true" href="#cb7-234" tabindex="-1"></a>    <span>det </span><span>:=</span><span> </span><span>(</span>j<span>.</span>x<span>-</span>h<span>.</span>x<span>)*(</span>k<span>.</span>y<span>-</span>h<span>.</span>y<span>)-(</span>j<span>.</span>y<span>-</span>h<span>.</span>y<span>)*(</span>k<span>.</span>x<span>-</span>h<span>.</span>x<span>)</span></span>
<span id="cb7-235"><a aria-hidden="true" href="#cb7-235" tabindex="-1"></a>    <span>if</span> det <span>&lt;</span> <span>0</span> <span>{</span></span>
<span id="cb7-236"><a aria-hidden="true" href="#cb7-236" tabindex="-1"></a>        <span>return</span> <span>add_circle_event</span><span>(&amp;</span>ft<span>.</span>queue<span>,</span> h<span>,</span>j<span>,</span>k<span>)</span></span>
<span id="cb7-237"><a aria-hidden="true" href="#cb7-237" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-238"><a aria-hidden="true" href="#cb7-238" tabindex="-1"></a>    <span>return</span> <span>-</span><span>1</span></span>
<span id="cb7-239"><a aria-hidden="true" href="#cb7-239" tabindex="-1"></a><span>}</span></span>
<span id="cb7-240"><a aria-hidden="true" href="#cb7-240" tabindex="-1"></a></span>
<span id="cb7-241"><a aria-hidden="true" href="#cb7-241" tabindex="-1"></a><span>process_circle_event </span><span>::</span><span> </span><span>proc</span><span>(</span>ft<span>:^</span>Fortune<span>,</span> e<span>:</span>Event<span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span></span>
<span id="cb7-242"><a aria-hidden="true" href="#cb7-242" tabindex="-1"></a>    <span>assert</span><span>(!</span>e<span>.</span>site<span>)</span></span>
<span id="cb7-243"><a aria-hidden="true" href="#cb7-243" tabindex="-1"></a>    center<span>,</span> r<span>,</span> cp <span>:=</span> <span>circle_point</span><span>(</span>e<span>.</span>a<span>,</span> e<span>.</span>b<span>,</span> e<span>.</span>c<span>)</span></span>
<span id="cb7-244"><a aria-hidden="true" href="#cb7-244" tabindex="-1"></a></span>
<span id="cb7-245"><a aria-hidden="true" href="#cb7-245" tabindex="-1"></a>    <span>/* As with the site event, we iterate through the beachline to</span></span>
<span id="cb7-246"><a aria-hidden="true" href="#cb7-246" tabindex="-1"></a><span>    find the appropriate arc to select for removal. In this case, the</span></span>
<span id="cb7-247"><a aria-hidden="true" href="#cb7-247" tabindex="-1"></a><span>    arc to remove is the middle one of the three points which describe</span></span>
<span id="cb7-248"><a aria-hidden="true" href="#cb7-248" tabindex="-1"></a><span>    the circle event. So we can just iterate through the beachline</span></span>
<span id="cb7-249"><a aria-hidden="true" href="#cb7-249" tabindex="-1"></a><span>    checking for that sequence.*/</span></span>
<span id="cb7-250"><a aria-hidden="true" href="#cb7-250" tabindex="-1"></a></span>
<span id="cb7-251"><a aria-hidden="true" href="#cb7-251" tabindex="-1"></a>    <span>rmv </span><span>:=</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>1</span></span>
<span id="cb7-252"><a aria-hidden="true" href="#cb7-252" tabindex="-1"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..&lt;</span><span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>2</span> <span>{</span></span>
<span id="cb7-253"><a aria-hidden="true" href="#cb7-253" tabindex="-1"></a>        <span>h </span><span>:=</span> ft<span>.</span>beachline<span>[</span>i<span>]</span></span>
<span id="cb7-254"><a aria-hidden="true" href="#cb7-254" tabindex="-1"></a>        <span>j </span><span>:=</span> ft<span>.</span>beachline<span>[</span>i<span>+</span><span>1</span><span>]</span></span>
<span id="cb7-255"><a aria-hidden="true" href="#cb7-255" tabindex="-1"></a>        <span>k </span><span>:=</span> ft<span>.</span>beachline<span>[</span>i<span>+</span><span>2</span><span>]</span></span>
<span id="cb7-256"><a aria-hidden="true" href="#cb7-256" tabindex="-1"></a></span>
<span id="cb7-257"><a aria-hidden="true" href="#cb7-257" tabindex="-1"></a>        <span>if</span> h <span>==</span> e<span>.</span>a <span>&amp;&amp;</span> j <span>==</span> e<span>.</span>b <span>&amp;&amp;</span> k <span>==</span> e<span>.</span>c <span>{</span></span>
<span id="cb7-258"><a aria-hidden="true" href="#cb7-258" tabindex="-1"></a>            rmv <span>=</span> i<span>+</span><span>1</span></span>
<span id="cb7-259"><a aria-hidden="true" href="#cb7-259" tabindex="-1"></a>            <span>break</span></span>
<span id="cb7-260"><a aria-hidden="true" href="#cb7-260" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-261"><a aria-hidden="true" href="#cb7-261" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-262"><a aria-hidden="true" href="#cb7-262" tabindex="-1"></a></span>
<span id="cb7-263"><a aria-hidden="true" href="#cb7-263" tabindex="-1"></a>    <span>if</span> rmv <span>&lt;</span> <span>1</span> <span>||</span> rmv <span>&gt;=</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>1</span> <span>{</span></span>
<span id="cb7-264"><a aria-hidden="true" href="#cb7-264" tabindex="-1"></a>        <span>return</span> rmv</span>
<span id="cb7-265"><a aria-hidden="true" href="#cb7-265" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-266"><a aria-hidden="true" href="#cb7-266" tabindex="-1"></a></span>
<span id="cb7-267"><a aria-hidden="true" href="#cb7-267" tabindex="-1"></a>    <span>mid_arc  </span><span>:=</span> ft<span>.</span>beachline<span>[</span>rmv<span>]</span></span>
<span id="cb7-268"><a aria-hidden="true" href="#cb7-268" tabindex="-1"></a>    <span>up_arc   </span><span>:=</span> ft<span>.</span>beachline<span>[</span>rmv<span>-</span><span>1</span><span>]</span></span>
<span id="cb7-269"><a aria-hidden="true" href="#cb7-269" tabindex="-1"></a>    <span>down_arc </span><span>:=</span> ft<span>.</span>beachline<span>[</span>rmv<span>+</span><span>1</span><span>]</span></span>
<span id="cb7-270"><a aria-hidden="true" href="#cb7-270" tabindex="-1"></a></span>
<span id="cb7-271"><a aria-hidden="true" href="#cb7-271" tabindex="-1"></a>    <span>/* When two arcs (the up and down arcs) squeeze a third arc (the</span></span>
<span id="cb7-272"><a aria-hidden="true" href="#cb7-272" tabindex="-1"></a><span>    middle arc), the point at which they meet becomes a vertex in the</span></span>
<span id="cb7-273"><a aria-hidden="true" href="#cb7-273" tabindex="-1"></a><span>    VD.</span></span>
<span id="cb7-274"><a aria-hidden="true" href="#cb7-274" tabindex="-1"></a></span>
<span id="cb7-275"><a aria-hidden="true" href="#cb7-275" tabindex="-1"></a><span>    It also causes the incomplete edge which we are tracking between</span></span>
<span id="cb7-276"><a aria-hidden="true" href="#cb7-276" tabindex="-1"></a><span>    up and mid, and mid and center, to crystalize into the half edges.</span></span>
<span id="cb7-277"><a aria-hidden="true" href="#cb7-277" tabindex="-1"></a><span>    */</span></span>
<span id="cb7-278"><a aria-hidden="true" href="#cb7-278" tabindex="-1"></a></span>
<span id="cb7-279"><a aria-hidden="true" href="#cb7-279" tabindex="-1"></a>    <span>add_vertex</span><span>(&amp;</span>ft<span>.</span>vd<span>,</span> center<span>)</span></span>
<span id="cb7-280"><a aria-hidden="true" href="#cb7-280" tabindex="-1"></a></span>
<span id="cb7-281"><a aria-hidden="true" href="#cb7-281" tabindex="-1"></a>    <span>ref1 </span><span>:=</span> ft<span>.</span>incomplete_edges<span>[</span>PointPair<span>{</span>up_arc<span>,</span> mid_arc<span>}]</span></span>
<span id="cb7-282"><a aria-hidden="true" href="#cb7-282" tabindex="-1"></a>    <span>delete_key</span><span>(&amp;</span>ft<span>.</span>incomplete_edges<span>,</span> PointPair<span>{</span>up_arc<span>,</span> mid_arc<span>})</span></span>
<span id="cb7-283"><a aria-hidden="true" href="#cb7-283" tabindex="-1"></a>    <span>add_half_edge</span><span>(&amp;</span>ft<span>.</span>vd<span>,</span> center<span>,</span> ref1<span>)</span></span>
<span id="cb7-284"><a aria-hidden="true" href="#cb7-284" tabindex="-1"></a>    <span>delete_key</span><span>(&amp;</span>ft<span>.</span>incomplete_edges<span>,</span> PointPair<span>{</span>up_arc<span>,</span> mid_arc<span>})</span></span>
<span id="cb7-285"><a aria-hidden="true" href="#cb7-285" tabindex="-1"></a></span>
<span id="cb7-286"><a aria-hidden="true" href="#cb7-286" tabindex="-1"></a>    <span>ref2 </span><span>:=</span> ft<span>.</span>incomplete_edges<span>[</span>PointPair<span>{</span>mid_arc<span>,</span> down_arc<span>}]</span></span>
<span id="cb7-287"><a aria-hidden="true" href="#cb7-287" tabindex="-1"></a>    <span>add_half_edge</span><span>(&amp;</span>ft<span>.</span>vd<span>,</span> center<span>,</span> ref2<span>)</span></span>
<span id="cb7-288"><a aria-hidden="true" href="#cb7-288" tabindex="-1"></a>    <span>delete_key</span><span>(&amp;</span>ft<span>.</span>incomplete_edges<span>,</span> PointPair<span>{</span>mid_arc<span>,</span> down_arc<span>})</span></span>
<span id="cb7-289"><a aria-hidden="true" href="#cb7-289" tabindex="-1"></a></span>
<span id="cb7-290"><a aria-hidden="true" href="#cb7-290" tabindex="-1"></a>    <span>/* A new incomplete edge is created between the up and down arcs,</span></span>
<span id="cb7-291"><a aria-hidden="true" href="#cb7-291" tabindex="-1"></a><span>    with the reference point being the center of the circle (i.e.</span></span>
<span id="cb7-292"><a aria-hidden="true" href="#cb7-292" tabindex="-1"></a><span>    where the three arcs intersected)</span></span>
<span id="cb7-293"><a aria-hidden="true" href="#cb7-293" tabindex="-1"></a></span>
<span id="cb7-294"><a aria-hidden="true" href="#cb7-294" tabindex="-1"></a><span>    We need to handle the special case that the site IS the circle</span></span>
<span id="cb7-295"><a aria-hidden="true" href="#cb7-295" tabindex="-1"></a><span>    point. This indicates that point the site hits the beachline is at</span></span>
<span id="cb7-296"><a aria-hidden="true" href="#cb7-296" tabindex="-1"></a><span>    the exact meeting point of two arcs */</span></span>
<span id="cb7-297"><a aria-hidden="true" href="#cb7-297" tabindex="-1"></a></span>
<span id="cb7-298"><a aria-hidden="true" href="#cb7-298" tabindex="-1"></a>    <span>ref3 </span><span>:=</span> center</span>
<span id="cb7-299"><a aria-hidden="true" href="#cb7-299" tabindex="-1"></a>    <span>midpoint </span><span>:=</span><span> </span><span>(</span>up_arc<span>+</span>down_arc<span>)/</span><span>2</span></span>
<span id="cb7-300"><a aria-hidden="true" href="#cb7-300" tabindex="-1"></a>    <span>if</span> center <span>==</span> ref1 <span>||</span> center <span>==</span> ref2 <span>{</span></span>
<span id="cb7-301"><a aria-hidden="true" href="#cb7-301" tabindex="-1"></a>        ref3 <span>=</span> midpoint</span>
<span id="cb7-302"><a aria-hidden="true" href="#cb7-302" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-303"><a aria-hidden="true" href="#cb7-303" tabindex="-1"></a>    <span>if</span> midpoint <span>==</span> ref1 <span>||</span> midpoint <span>==</span> ref2 <span>{</span></span>
<span id="cb7-304"><a aria-hidden="true" href="#cb7-304" tabindex="-1"></a>        <span>// Very unlucky</span></span>
<span id="cb7-305"><a aria-hidden="true" href="#cb7-305" tabindex="-1"></a>        ref3 <span>+=</span> <span>{</span><span>1</span><span>,</span><span>1</span><span>}</span></span>
<span id="cb7-306"><a aria-hidden="true" href="#cb7-306" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-307"><a aria-hidden="true" href="#cb7-307" tabindex="-1"></a>    <span>add_half_edge</span><span>(&amp;</span>ft<span>.</span>vd<span>,</span> center<span>,</span> ref3<span>)</span></span>
<span id="cb7-308"><a aria-hidden="true" href="#cb7-308" tabindex="-1"></a>    ft<span>.</span>incomplete_edges<span>[</span>PointPair<span>{</span>up_arc<span>,</span> down_arc<span>}]</span> <span>=</span> ref3</span>
<span id="cb7-309"><a aria-hidden="true" href="#cb7-309" tabindex="-1"></a></span>
<span id="cb7-310"><a aria-hidden="true" href="#cb7-310" tabindex="-1"></a>    <span>/* we remove the arc from the beachline */</span></span>
<span id="cb7-311"><a aria-hidden="true" href="#cb7-311" tabindex="-1"></a></span>
<span id="cb7-312"><a aria-hidden="true" href="#cb7-312" tabindex="-1"></a>    <span>/* Collapsing the arc can invalidate future events which have that</span></span>
<span id="cb7-313"><a aria-hidden="true" href="#cb7-313" tabindex="-1"></a><span>    arc as part of it. Here we check every future event to see if it&#39;s</span></span>
<span id="cb7-314"><a aria-hidden="true" href="#cb7-314" tabindex="-1"></a><span>    now invalid. This is very inefficient, there should be faster way</span></span>
<span id="cb7-315"><a aria-hidden="true" href="#cb7-315" tabindex="-1"></a><span>    to do this */</span></span>
<span id="cb7-316"><a aria-hidden="true" href="#cb7-316" tabindex="-1"></a>    <span>// </span><span>TODO</span><span> Find a more efficient way to do this</span></span>
<span id="cb7-317"><a aria-hidden="true" href="#cb7-317" tabindex="-1"></a></span>
<span id="cb7-318"><a aria-hidden="true" href="#cb7-318" tabindex="-1"></a>    <span>i </span><span>:=</span> <span>0</span></span>
<span id="cb7-319"><a aria-hidden="true" href="#cb7-319" tabindex="-1"></a>    <span>r0 </span><span>:=</span> ft<span>.</span>beachline<span>[</span>rmv<span>-</span><span>1</span><span>]</span></span>
<span id="cb7-320"><a aria-hidden="true" href="#cb7-320" tabindex="-1"></a>    <span>r1 </span><span>:=</span> ft<span>.</span>beachline<span>[</span>rmv<span>]</span></span>
<span id="cb7-321"><a aria-hidden="true" href="#cb7-321" tabindex="-1"></a>    <span>r2 </span><span>:=</span> ft<span>.</span>beachline<span>[</span>rmv<span>+</span><span>1</span><span>]</span></span>
<span id="cb7-322"><a aria-hidden="true" href="#cb7-322" tabindex="-1"></a>    <span>for</span> i <span>&lt;</span> <span>len</span><span>(</span>ft<span>.</span>queue<span>)</span> <span>{</span></span>
<span id="cb7-323"><a aria-hidden="true" href="#cb7-323" tabindex="-1"></a>        <span>ev </span><span>:=</span> ft<span>.</span>queue<span>[</span>i<span>]</span></span>
<span id="cb7-324"><a aria-hidden="true" href="#cb7-324" tabindex="-1"></a>        <span>if</span> <span>!</span>ev<span>.</span>site <span>{</span></span>
<span id="cb7-325"><a aria-hidden="true" href="#cb7-325" tabindex="-1"></a>            <span>if</span> ev<span>.</span>b <span>==</span> r0 <span>&amp;&amp;</span> ev<span>.</span>c <span>==</span> r1 <span>||</span> ev<span>.</span>a <span>==</span> r1 <span>&amp;&amp;</span> ev<span>.</span>b <span>==</span> r2 <span>{</span></span>
<span id="cb7-326"><a aria-hidden="true" href="#cb7-326" tabindex="-1"></a>                <span>ordered_remove</span><span>(&amp;</span>ft<span>.</span>queue<span>,</span> i<span>)</span></span>
<span id="cb7-327"><a aria-hidden="true" href="#cb7-327" tabindex="-1"></a>                i <span>-=</span> <span>1</span></span>
<span id="cb7-328"><a aria-hidden="true" href="#cb7-328" tabindex="-1"></a>            <span>}</span></span>
<span id="cb7-329"><a aria-hidden="true" href="#cb7-329" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-330"><a aria-hidden="true" href="#cb7-330" tabindex="-1"></a>        i <span>+=</span> <span>1</span></span>
<span id="cb7-331"><a aria-hidden="true" href="#cb7-331" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-332"><a aria-hidden="true" href="#cb7-332" tabindex="-1"></a></span>
<span id="cb7-333"><a aria-hidden="true" href="#cb7-333" tabindex="-1"></a>    <span>ordered_remove</span><span>(&amp;</span>ft<span>.</span>beachline<span>,</span> rmv<span>)</span></span>
<span id="cb7-334"><a aria-hidden="true" href="#cb7-334" tabindex="-1"></a></span>
<span id="cb7-335"><a aria-hidden="true" href="#cb7-335" tabindex="-1"></a>    <span>/* Collapsing the arc has possibly created a new circle event. If</span></span>
<span id="cb7-336"><a aria-hidden="true" href="#cb7-336" tabindex="-1"></a><span>    the beachline as abCde before, and we removed C, we need to check</span></span>
<span id="cb7-337"><a aria-hidden="true" href="#cb7-337" tabindex="-1"></a><span>    abd, and bde for new circle events. Since we removed C, the</span></span>
<span id="cb7-338"><a aria-hidden="true" href="#cb7-338" tabindex="-1"></a><span>    &#39;to_remove&#39; index (i) is now pointed at d, so that means checking</span></span>
<span id="cb7-339"><a aria-hidden="true" href="#cb7-339" tabindex="-1"></a><span>    i-2, i-1, i for the up direction, and i-1, i, i+1 in the down</span></span>
<span id="cb7-340"><a aria-hidden="true" href="#cb7-340" tabindex="-1"></a><span>    direction. */</span></span>
<span id="cb7-341"><a aria-hidden="true" href="#cb7-341" tabindex="-1"></a></span>
<span id="cb7-342"><a aria-hidden="true" href="#cb7-342" tabindex="-1"></a>    <span>if</span> rmv <span>&gt;=</span><span>2</span> <span>do</span> <span>new_circle_event</span><span>(</span>ft<span>,</span> rmv<span>-</span><span>2</span><span>)</span></span>
<span id="cb7-343"><a aria-hidden="true" href="#cb7-343" tabindex="-1"></a>    <span>if</span> rmv <span>&gt;=</span> <span>1</span> <span>&amp;&amp;</span> rmv <span>&lt;=</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)-</span><span>2</span> <span>do</span> <span>new_circle_event</span><span>(</span>ft<span>,</span> rmv<span>-</span><span>1</span><span>)</span></span>
<span id="cb7-344"><a aria-hidden="true" href="#cb7-344" tabindex="-1"></a></span>
<span id="cb7-345"><a aria-hidden="true" href="#cb7-345" tabindex="-1"></a>    <span>return</span> rmv</span>
<span id="cb7-346"><a aria-hidden="true" href="#cb7-346" tabindex="-1"></a><span>}</span></span>
<span id="cb7-347"><a aria-hidden="true" href="#cb7-347" tabindex="-1"></a></span>
<span id="cb7-348"><a aria-hidden="true" href="#cb7-348" tabindex="-1"></a><span>clean_beachline_edges </span><span>::</span><span> </span><span>proc</span><span>(</span>ft<span>:^</span>Fortune<span>,</span> d<span>:</span><span>int</span><span>)</span> <span>{</span></span>
<span id="cb7-349"><a aria-hidden="true" href="#cb7-349" tabindex="-1"></a>    <span>/* As the sweepline advances, the arcs on each end of the can</span></span>
<span id="cb7-350"><a aria-hidden="true" href="#cb7-350" tabindex="-1"></a><span>    become overtaken by those further toward the middle. If the bottom</span></span>
<span id="cb7-351"><a aria-hidden="true" href="#cb7-351" tabindex="-1"></a><span>    of the beachline ends with arcs ijk, if the midpoint of jk is no</span></span>
<span id="cb7-352"><a aria-hidden="true" href="#cb7-352" tabindex="-1"></a><span>    longer in bounds of the digram, it&#39;s pruned off.*/</span></span>
<span id="cb7-353"><a aria-hidden="true" href="#cb7-353" tabindex="-1"></a></span>
<span id="cb7-354"><a aria-hidden="true" href="#cb7-354" tabindex="-1"></a>    <span>l </span><span>:=</span> <span>len</span><span>(</span>ft<span>.</span>beachline<span>)</span></span>
<span id="cb7-355"><a aria-hidden="true" href="#cb7-355" tabindex="-1"></a>    <span>/* A beachline of length 0 or 1 has nothing to prune */</span></span>
<span id="cb7-356"><a aria-hidden="true" href="#cb7-356" tabindex="-1"></a>    <span>if</span> l <span>&lt;</span> <span>2</span> <span>do</span> <span>return</span></span>
<span id="cb7-357"><a aria-hidden="true" href="#cb7-357" tabindex="-1"></a></span>
<span id="cb7-358"><a aria-hidden="true" href="#cb7-358" tabindex="-1"></a>    mp <span>:</span> V2</span>
<span id="cb7-359"><a aria-hidden="true" href="#cb7-359" tabindex="-1"></a>    mp <span>=</span><span> </span><span>(</span>ft<span>.</span>beachline<span>[</span><span>0</span><span>]+</span>ft<span>.</span>beachline<span>[</span><span>1</span><span>])/</span><span>2</span></span>
<span id="cb7-360"><a aria-hidden="true" href="#cb7-360" tabindex="-1"></a>    b<span>,</span> _<span>,</span> sols <span>:=</span> <span>intersection</span><span>(</span>ft<span>.</span>beachline<span>[</span><span>0</span><span>],</span> ft<span>.</span>beachline<span>[</span><span>1</span><span>],</span> d<span>)</span></span>
<span id="cb7-361"><a aria-hidden="true" href="#cb7-361" tabindex="-1"></a>    <span>if</span> b<span>.</span>y <span>&lt;</span> <span>0</span> <span>{</span></span>
<span id="cb7-362"><a aria-hidden="true" href="#cb7-362" tabindex="-1"></a>        _<span>,</span>vv<span>,</span>_ <span>:=</span> <span>line_rectangle_intersection</span><span>(</span>mp<span>,</span> b<span>)</span></span>
<span id="cb7-363"><a aria-hidden="true" href="#cb7-363" tabindex="-1"></a>        <span>ordered_remove</span><span>(&amp;</span>ft<span>.</span>beachline<span>,</span> <span>0</span><span>)</span></span>
<span id="cb7-364"><a aria-hidden="true" href="#cb7-364" tabindex="-1"></a>        l <span>-=</span> <span>1</span></span>
<span id="cb7-365"><a aria-hidden="true" href="#cb7-365" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-366"><a aria-hidden="true" href="#cb7-366" tabindex="-1"></a></span>
<span id="cb7-367"><a aria-hidden="true" href="#cb7-367" tabindex="-1"></a>    <span>if</span> l <span>&lt;</span> <span>2</span> <span>do</span> <span>return</span></span>
<span id="cb7-368"><a aria-hidden="true" href="#cb7-368" tabindex="-1"></a>    mp <span>=</span><span> </span><span>(</span>ft<span>.</span>beachline<span>[</span>l<span>-</span><span>1</span><span>]+</span>ft<span>.</span>beachline<span>[</span>l<span>-</span><span>2</span><span>])/</span><span>2</span></span>
<span id="cb7-369"><a aria-hidden="true" href="#cb7-369" tabindex="-1"></a>    _<span>,</span> b<span>,</span> sols <span>=</span> <span>intersection</span><span>(</span>ft<span>.</span>beachline<span>[</span>l<span>-</span><span>1</span><span>],</span> ft<span>.</span>beachline<span>[</span>l<span>-</span><span>2</span><span>],</span> d<span>)</span></span>
<span id="cb7-370"><a aria-hidden="true" href="#cb7-370" tabindex="-1"></a>    <span>if</span> sols <span>==</span> <span>2</span> <span>&amp;&amp;</span> b<span>.</span>y <span>&gt;</span> H <span>{</span></span>
<span id="cb7-371"><a aria-hidden="true" href="#cb7-371" tabindex="-1"></a>        _<span>,</span>vv<span>,</span>_ <span>:=</span> <span>line_rectangle_intersection</span><span>(</span>mp<span>,</span> b<span>)</span></span>
<span id="cb7-372"><a aria-hidden="true" href="#cb7-372" tabindex="-1"></a>        <span>ordered_remove</span><span>(&amp;</span>ft<span>.</span>beachline<span>,</span> l<span>-</span><span>1</span><span>)</span></span>
<span id="cb7-373"><a aria-hidden="true" href="#cb7-373" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-374"><a aria-hidden="true" href="#cb7-374" tabindex="-1"></a><span>}</span></span>
<span id="cb7-375"><a aria-hidden="true" href="#cb7-375" tabindex="-1"></a></span>
<span id="cb7-376"><a aria-hidden="true" href="#cb7-376" tabindex="-1"></a><span>calc_vd </span><span>::</span><span> </span><span>proc</span><span>(</span>sites<span>:[]</span>V2<span>,</span> ft<span>:^</span>Fortune<span>,</span> max_x<span>:=</span>W<span>)</span> <span>{</span></span>
<span id="cb7-377"><a aria-hidden="true" href="#cb7-377" tabindex="-1"></a>    <span>initialise_fortune</span><span>(</span>ft<span>,</span> sites<span>)</span></span>
<span id="cb7-378"><a aria-hidden="true" href="#cb7-378" tabindex="-1"></a></span>
<span id="cb7-379"><a aria-hidden="true" href="#cb7-379" tabindex="-1"></a>    <span>/* While there are events in the queue, process them. */</span></span>
<span id="cb7-380"><a aria-hidden="true" href="#cb7-380" tabindex="-1"></a></span>
<span id="cb7-381"><a aria-hidden="true" href="#cb7-381" tabindex="-1"></a>    <span>final_x </span><span>:=</span> <span>0</span></span>
<span id="cb7-382"><a aria-hidden="true" href="#cb7-382" tabindex="-1"></a>    <span>for</span> <span>len</span><span>(</span>ft<span>.</span>queue<span>)</span> <span>&gt;</span> <span>0</span> <span>{</span></span>
<span id="cb7-383"><a aria-hidden="true" href="#cb7-383" tabindex="-1"></a>        <span>ev </span><span>:=</span> ft<span>.</span>queue<span>[</span><span>0</span><span>]</span></span>
<span id="cb7-384"><a aria-hidden="true" href="#cb7-384" tabindex="-1"></a>        final_x <span>=</span> <span>event_x_coord</span><span>(</span>ev<span>)</span></span>
<span id="cb7-385"><a aria-hidden="true" href="#cb7-385" tabindex="-1"></a>        <span>if</span> max_x <span>!=</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> <span>event_x_coord</span><span>(</span>ev<span>)</span> <span>&gt;</span> max_x <span>do</span> <span>return</span></span>
<span id="cb7-386"><a aria-hidden="true" href="#cb7-386" tabindex="-1"></a>        <span>ordered_remove</span><span>(&amp;</span>ft<span>.</span>queue<span>,</span> <span>0</span><span>)</span></span>
<span id="cb7-387"><a aria-hidden="true" href="#cb7-387" tabindex="-1"></a>        <span>clean_beachline_edges</span><span>(</span>ft<span>,</span> <span>event_x_coord</span><span>(</span>ev<span>))</span></span>
<span id="cb7-388"><a aria-hidden="true" href="#cb7-388" tabindex="-1"></a>        <span>if</span> ev<span>.</span>site <span>do</span> <span>process_site_event</span><span>(</span>ft<span>,</span> ev<span>)</span></span>
<span id="cb7-389"><a aria-hidden="true" href="#cb7-389" tabindex="-1"></a>        <span>else</span> <span>do</span> <span>process_circle_event</span><span>(</span>ft<span>,</span> ev<span>)</span></span>
<span id="cb7-390"><a aria-hidden="true" href="#cb7-390" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-391"><a aria-hidden="true" href="#cb7-391" tabindex="-1"></a></span>
<span id="cb7-392"><a aria-hidden="true" href="#cb7-392" tabindex="-1"></a>    <span>clear</span><span>(&amp;</span>ft<span>.</span>beachline<span>)</span></span>
<span id="cb7-393"><a aria-hidden="true" href="#cb7-393" tabindex="-1"></a></span>
<span id="cb7-394"><a aria-hidden="true" href="#cb7-394" tabindex="-1"></a>    <span>/* For any incomplete edges that remain, calculate where they</span></span>
<span id="cb7-395"><a aria-hidden="true" href="#cb7-395" tabindex="-1"></a><span>    intersect the diagram side and create edges at those points. */</span></span>
<span id="cb7-396"><a aria-hidden="true" href="#cb7-396" tabindex="-1"></a></span>
<span id="cb7-397"><a aria-hidden="true" href="#cb7-397" tabindex="-1"></a>    <span>for</span> is<span>,</span> ref <span>in</span> ft<span>.</span>incomplete_edges <span>{</span></span>
<span id="cb7-398"><a aria-hidden="true" href="#cb7-398" tabindex="-1"></a>        <span>if</span> <span>inbounds</span><span>(</span>ref<span>)</span> <span>{</span></span>
<span id="cb7-399"><a aria-hidden="true" href="#cb7-399" tabindex="-1"></a>            p <span>,</span> _<span>,</span>_ <span>:=</span> <span>intersection</span><span>(</span>is<span>.</span>x<span>,</span> is<span>.</span>y<span>,</span> <span>max</span><span>(</span>W<span>*</span><span>2</span><span>,</span> final_x<span>*</span><span>2</span><span>))</span></span>
<span id="cb7-400"><a aria-hidden="true" href="#cb7-400" tabindex="-1"></a>            _<span>,</span>le<span>,</span>_ <span>:=</span> <span>line_rectangle_intersection</span><span>(</span>ref<span>,</span>p<span>)</span></span>
<span id="cb7-401"><a aria-hidden="true" href="#cb7-401" tabindex="-1"></a>            <span>add_half_edge</span><span>(&amp;</span>ft<span>.</span>vd<span>,</span> le<span>,</span> ref<span>)</span></span>
<span id="cb7-402"><a aria-hidden="true" href="#cb7-402" tabindex="-1"></a>            <span>add_vertex</span><span>(&amp;</span>ft<span>.</span>vd<span>,</span> le<span>)</span></span>
<span id="cb7-403"><a aria-hidden="true" href="#cb7-403" tabindex="-1"></a>        <span>}</span></span>
<span id="cb7-404"><a aria-hidden="true" href="#cb7-404" tabindex="-1"></a>        <span>delete_key</span><span>(&amp;</span>ft<span>.</span>incomplete_edges<span>,</span> is<span>)</span></span>
<span id="cb7-405"><a aria-hidden="true" href="#cb7-405" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-406"><a aria-hidden="true" href="#cb7-406" tabindex="-1"></a></span>
<span id="cb7-407"><a aria-hidden="true" href="#cb7-407" tabindex="-1"></a>    <span>complete_vd</span><span>(&amp;</span>ft<span>.</span>vd<span>)</span></span>
<span id="cb7-408"><a aria-hidden="true" href="#cb7-408" tabindex="-1"></a><span>}</span></span></code></pre></div>
<h2 id="thing-i-havent-talked-about">Thing I haven’t talked about</h2>
<p>One of the difficulties implementing this algorithm is that there’s
lots of fiddly edge cases to consider. I’m not going to go into all the
ones I found, because they are quite tedious. And there are probably
many that I missed.</p>
<p>Another topic I haven’t covered is the datastructure for a Voronoi:
The Doubly Connected Edge List or <strong>DCEL</strong>. There’s a bit
at the end about them, but they are neither very interesting nor core to
the algorithm.</p>
<p>There is one procedure I didn’t talk about in the algorithm called
‘cleaning the beachline’, which just looks at two ends of the beachline
and prunes off any uneccessary arcs.</p>
<p>Finally, that last step - what to do after the queue is empty - I
haven’t gone into detail about. It involves a bit of simple math to go
through all the incomplete edges, untwinned half edges, and vertices and
just tidy them up a bit. Again, not very interesting.</p>
<h2 id="sources">Sources</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Voronoi_diagram">https://en.wikipedia.org/wiki/Voronoi_diagram</a></li>
<li><a href="https://mathworld.wolfram.com/VoronoiDiagram.html">https://mathworld.wolfram.com/VoronoiDiagram.html</a></li>
<li><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fortune&#39;s_algorithm">https://en.wikipedia.org/wiki/Fortune&#39;s_algorithm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lloyd&#39;s_algorithm">https://en.wikipedia.org/wiki/Lloyd&#39;s_algorithm</a></li>
<li><a href="https://www.cs.tufts.edu/comp/163/demos/fortune/">https://www.cs.tufts.edu/comp/163/demos/fortune/</a></li>
<li><a href="https://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect10-dcel.pdf">https://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect10-dcel.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Doubly_connected_edge_list">https://en.wikipedia.org/wiki/Doubly_connected_edge_list</a></li>
<li><a href="https://pvigier.github.io/2018/11/18/fortune-algorithm-details.html">https://pvigier.github.io/2018/11/18/fortune-algorithm-details.html</a></li>
<li><a href="https://jacquesheunis.com/post/fortunes-algorithm/">https://jacquesheunis.com/post/fortunes-algorithm/</a></li>
<li><a href="https://jacquesheunis.com/post/fortunes-algorithm-implementation/">https://jacquesheunis.com/post/fortunes-algorithm-implementation/</a></li>
<li><a href="http://amsi.org.au/ESA_Senior_Years/SeniorTopic2/2a/2a_2content_10.html">http://amsi.org.au/ESA_Senior_Years/SeniorTopic2/2a/2a_2content_10.html</a></li>
</ul>
<h2 id="data-structure-for-describing-voronoi-diagrams">Data structure
for describing Voronoi Diagrams</h2>
<p>Voronois are usually stored in a doubly-connected-edge-list (DCEL).
This data structure describes a ‘web’ of vertices and edges between
those vertices (called a cell-complex, which is what a Voronoi
technically is) in a way that’s easy to manipulate and transform.</p>
<p>DCEL is a primarily edge-based representation, but it also stores the
vertex and face information. Edges in a cell-complex are undirected, but
in a DCEL each edge is stored as two directed ‘half edges’, one in each
direction. In the case of the Voronoi diagram, the stored vertices are
<em>not</em> the sites, but the Voronoi vertices. The structure is like
this:</p>
<pre><code>DCEL:
 Edge[]:
    twin, next, previous:^Edge, 
    origin:^Vertex 
    left:^Face
 Vertex[]: 
    ID:int, 
    Coord:V2, 
    incident:^Edge
 Face[]:
    incident:^Edge</code></pre>
<p>The ‘twin’ of the edge going from vertex A to B is the vertex going
from B to A. If we store the origin of the edge, we can get to the
destination by <code>E.twin.origin</code>. And similarly, we store the
left face, but to get to the right face we do <code>E.twin.left</code>.
The edge pointer on the vertex can be to any edge which has this vertex
as its origin.</p>
<p><img src="https://macwright.com/2025/images/voronoi/DCEL.png"/></p>


</div>
  </body>
</html>
