<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ericpfahl.com/from-pattern-matching-to-unification/">Original</a>
    <h1>Unification in Elixir</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        <div>
        <section>

            <ul>
                <li>
                    <a href="https://www.ericpfahl.com/author/eric/" aria-label="Read more of Eric Pfahl">
                        <img src="https://www.ericpfahl.com/content/images/size/w100/2023/01/angry_human-1.png" alt="Eric Pfahl"/>
                    </a>
                </li>
            </ul>

            <div>
                
                <p><time datetime="2023-02-25">Feb 25, 2023</time>
                        <span><span>•</span> 13 min read</span>
                </p>
            </div>

        </section>
        </div>


    </header>

    <section>
        <p>Pattern matching is a pervasive and powerful tool in Elixir. This isn&#39;t too surprising if you know a little about the history of Elixir&#39;s parent language, <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)?ref=ericpfahl.com">Erlang</a>. Erlang was originally inspired by and written in <a href="https://en.wikipedia.org/wiki/Prolog?ref=ericpfahl.com">Prolog</a>, a logic programming language where pattern matching has first-class support.</p><p>In Elixir, you might see an expression like this:</p><pre><code>[x, [2, y]] = [1, [2, 3]]</code></pre><p>When this expression is evaluated, the variables <code>x</code> and <code>y</code> on the left are assigned to values 1 and 3, respectively. The symbol <code>=</code>, called the <em>match</em> operator, attempts to associate variables with values that allow the two sides be equal. When a unique match is possible, variables are assigned and made available to the runtime. When a match isn&#39;t possible, Elixir raises a <code>MatchError</code>:</p><pre><code>[x, [2, y]] = [1, 2]

** (MatchError) no match of right hand side value: [1, 2]</code></pre><p>Elixir allows <em>one-sided</em> pattern matching, where variables can appear only on the left side of the match operator. There are probably very good practical reasons for this choice, but there is no logical reason why variables couldn&#39;t appear on both sides.</p><p>To help you get a better appreciation for how pattern matching works, and to tease the potential of more general logic programming, I&#39;ll walk through the implementation of two-sided pattern matching, also known as <em><a href="https://en.wikipedia.org/wiki/Unification_(computer_science)?ref=ericpfahl.com">unification</a>.</em> Unification is an algorithm for solving symbolic equations. Described below are the ingredients and steps to make unification seem relatively intuitive and to allow you play with it yourself.</p><h2 id="what-is-unification">What is unification?</h2><p>Like Elixir&#39;s pattern matching, unification is an assertion of equality, followed by variable assignment when the assertion is true. Unification operates on a pair of <em>terms</em>. These terms may be variables or atomic values (numbers, strings, atoms) or a list of terms. Successful unification produces a mapping from variables to values (other terms), so that the original assertion is satisfied. This mapping is a <em>substitution</em>.</p><p>Unlike Elixir&#39;s pattern matching, the substitution that results from successful unification may contain variables with only partially known values. This allowance for uncertainty is a powerful feature. New information may come along that further refines existing variables, adds new variables to the substitution, or refutes the substitution and causes unification to fail. </p><p>Here are some notional examples of successful unification, along with the resulting substitutions:</p><pre><code>#1

unify(1, 1)

identity; empty substitution

---

#2

unify(x, x)

identity; empty substitution

---

#3

unify(x, 1)

x =&gt; 1

---

#4

unify(x, [1, y])

x =&gt; [1, y]

---

#5

unify([x, [2, y]], [1, [2, [x, 4]]])

x =&gt; 1
y =&gt; [x, 4]</code></pre><p>This interface is slightly different than the implementation shown below, but the spirit is the same. The first two example are identity relations: true statements that don&#39;t provide any new information. Partial knowledge is shown in the 4th example: <code>x</code> is assigned to a list, but <code>y</code> is unknown. In example 5, the substitution says that variable <code>y</code> is assigned to a list that contains variable <code>x</code>. But since <code>x</code> is assigned to 1, the value of <code>y</code> is actually <code>[1, 4]</code>. This kind of indirection in substitutions is common. You&#39;ll see below how to simplify variable assignments in cases like this.</p><p>These pairs of terms fail to unify:</p><pre><code>#1

unify(&#34;one&#34;, &#34;two&#34;)

---

#2

unify([x, 2], :a)

---

#3

unify([x, x], [1, 2])</code></pre><p>Two different atomic values aren&#39;t equal, and a list can never be equal to an atomic value. The 3rd case says that a list of two identical elements can&#39;t be equal to a list with two different elements.  </p><p>If all of this still seems a bit murky, don&#39;t panic. The ideas are pretty straightforward, and once you see the code and put it to use, I think things will fall into place. Next, I&#39;ll define more precisely what is meant by <em>term, <em>variable</em></em>, and <em>substitution</em>.</p><h2 id="what-is-a-term">What is a term?</h2><p>A <em>term</em> is a collective label for the kinds of values that can be unified. To distinguish from the broader class of <a href="https://hexdocs.pm/elixir/typespecs.html?ref=ericpfahl.com#basic-types">Elixir terms</a>, I&#39;ll use the type <code>uterm</code> when discussing unification. A <code>uterm</code> can be either an atomic value, a variable, or a list of <code>uterm</code> values. For this discussion, a list will be the only collection type in the definition of <code>uterm</code>.</p><p>As an Elixir typespec, a <code>uterm</code> can be defined as</p><pre><code>@type atomic :: number | atom | binary

@type uterm :: atomic | variable | [uterm]</code></pre><p>(The <em>variable</em> type will be defined shortly.) Notice that the definition of <code>uterm</code> is recursive. If <code>x</code>, <code>y</code>, and <code>z</code> are variables, then examples of valid terms include <code>1</code>, <code>x</code>, <code>&#34;term&#34;</code>, <code>[1, 2]</code>, <code>[x, :a, 1, &#34;one&#34;]</code>, and <code>[[x, y], [[1, [2, z]]]</code>.</p><h2 id="what-is-a-variable">What is a variable?</h2><p>A variable is placeholder for a value. That value can be any term, including another variable or a list that contains variables. Variables with different names, like <code>x</code> and <code>y</code>, may hold different values. If variable <code>x</code> appears more than once in the terms being unified, every instance of <code>x</code> must have the <em>same</em> value. And once the value of a variable is set, it can&#39;t have any other value. The term <code>[x, y]</code> might successfully unify with both <code>[1, 2]</code> and <code>[1, 1]</code>. The term <code>[x, [1, x]]</code> would successfully unify with <code>[:a, [1, :a]]</code>, but not with <code>[3, [1, 2]]</code>.</p><p>There are a number of ways to define a variable in code. Whatever the approach, it must be possible to uniquely identify different variables, and a variable must be distinct from a number, binary, atom, or list. Since we&#39;re working in Elixir, an idiomatic way to represent a variable is as a struct, like so</p><pre><code>defmodule Var do
  alias Var

  @type t :: %Var{id: any}
  defstruct [:id]

  @spec new(any) :: Var.t()
  def new(id), do: %Var{id: id}
end</code></pre><p>This defines a type <code>Var.t</code> and a constructor <code>Var.new</code> to be used outside the module. The <code>variable</code> type in <code>uterm</code> can alias the struct type:</p><pre><code>@type variable :: Var.t()</code></pre><p>This struct representation makes it convenient to use Elixir pattern matching when working with variables.</p><p>When constructing a variable, there doesn&#39;t need to be any relationship between the identifier and the Elixir variable name. It&#39;s valid to type <code>x = Var.new(1)</code>. Just be careful to use different identifiers for different variables. As a convention, I&#39;ll define variables with an atom identifier that corresponds to the Elixir variable name, as in <code>x = Var.new(:x)</code> and <code>y = Var.new(:y)</code>.</p><h2 id="what-is-a-substitution">What is a substitution?</h2><p>As already stated, a substitution is a mapping from variables to values, where a value can be any term. Unsurprisingly, an Elixir <code>Map</code> is an excellent choice to represent a substitution. This type definition serves as handy documentation:</p><pre><code>@type substitution :: %{} | %{variable =&gt; uterm}</code></pre><p>Because the substitution is represented as an ordinary map, standard functions like <code>Map.fetch</code> and <code>Map.put</code> can be used to query and update a substitution.</p><p>A substitution will often have indirect relationships, where one variable is associated with other variables, and those variables depend on other variables, and so on. To resolve the value of a term, it may be necessary to hop among associated variables–to <em>walk</em> the web of relationships. Two kinds of walks will be used later, one shallow and one complete. The shallow version, which, according to convention, I just call <code>walk</code>, is used in the implementation of unification. The complete walk, which I call <code>simplify</code>, is used to present the final result of unification in the simplest form possible.</p><p>A walk of a term is performed against the current substitution. In <code>walk</code>, the term is first looked up as a key in the substitution. If the key is present, the walk is applied recursively to its associated value. If, at some point in the recursion, the key is absent, the walk returns the term. Here&#39;s an implementation of the shallow walk:</p><pre><code>@spec walk(substitution, uterm) :: uterm
def walk(sub, term) do
  case Map.fetch(sub, term) do
    {:ok, t} -&gt; walk(sub, t)
    :error -&gt; term
  end
end</code></pre><p>For the substitution <code>%{x =&gt; y, y =&gt; 1}</code>, a shallow walk on <code>x</code> first finds the term <code>y</code>, then the term 1, and then returns 1. If <code>x</code> is walked on <code>%{x =&gt; y,  y =&gt; [1, z]}</code>, the walk stops when the list term <code>[1, z]</code> is reached, because a list can&#39;t be a key in the substitution; only variables can be keys.</p><p>The function <code>simplify</code> starts with a shallow walk, but then descends into list terms and recursively applies <code>simplify</code> to their contents. Here&#39;s the code:</p><pre><code>@spec simplify(substitution, uterm) :: uterm
def simplify(sub, term) do
  case walk(sub, term) do
    [h | t] -&gt; [simplify(sub, h)| simplify(sub, t)]
    term -&gt; term
  end
end</code></pre><p>If the the shallow walk ends at a list, a new list is formed by applying <code>simplify</code> to the head and tail. Otherwise, the result of <code>walk</code> is returned. When <code>x</code> is simplified in <code>%{x =&gt; y, y =&gt; [1, z], z =&gt; 2}</code>, the result is <code>[1, 2]</code>. </p><h2 id="putting-it-all-together">Putting it all together</h2><p>At this point, all the data structures and basic operations have been discussed. Now I&#39;ll step through the implementation of the unification algorithm.</p><p>The public function for unification is</p><pre><code>@spec unify(substitution, uterm, uterm) :: {:ok, substitution} | :error
def unify(sub, term1, term2) do
  ...
end</code></pre><p>When <code>unify</code> succeeds, it returns an <code>:ok</code> tuple with an updated substitution; otherwise, <code>:error</code> is returned.</p><p>When <code>unify</code> is first called, it will often be given an empty substitution, which is the same as saying that there&#39;s no prior knowledge about the variables. The assertion that the two terms are equivalent constrains the relationships between variables present in the terms. Information about these constraints is captured as an updated substitution. The substitution acts like a working memory as unification proceeds through a series of relatively simple steps.</p><h3 id="step-1-walk">Step 1: Walk</h3><p>If one or both terms are variables, the values of those variables are needed before equivalence can be tested. Variable values are obtained by a shallow walk with the given substitution. These walked values are passed as arguments to <code>do_unify</code>, a private function that does the heavy lifting:</p><pre><code>def unify(sub, term1, term2) do
  do_unify(sub, walk(sub, term1), walk(sub, term2))
end</code></pre><p>With a shallow walk as the first step, unification is able to navigate variable relationships incrementally, testing for equivalence and new information at each stage of the descent. Remember that <code>walk</code> returns the first value that isn&#39;t a key in the substitution. This could be a variable for which there is not yet a value, a list, or an atomic value. Each of these possibilities is dealt with, in turn, using multiple clauses of <code>do_unify</code>.</p><h3 id="step-2-equivalence">Step 2: Equivalence</h3><p>First, test for the equivalence of the two walked terms. If the two terms passed to <code>do_unify</code> have equivalent values, then stop and return <code>{:ok, sub}</code>:</p><pre><code>defp do_unify(sub, term1, term2) when term1 == term2 do
  {:ok, sub}
end</code></pre><p>When the terms are lists, unification succeeds if the lists are equivalent. This is true even if the lists contain variables. Note that <code>[x, 2] == [x, 2]</code> is true for all values of <code>x</code>.</p><h3 id="steps-3-and-4-variable">Steps 3 and 4: Variable</h3><p>If the first term in <code>do_unify</code> is a variable (a <code>Var</code> struct), update the substitution by associating the variable with the second term. If the first term isn&#39;t a variable, perform the same test on the second term:</p><pre><code>defp do_unify(sub, %Var{} = var, term) do
  extend(sub, var, term)
end

defp do_unify(sub, term, %Var{} = var) do
  extend(sub, var, term)
end</code></pre><p>where <code>extend</code> is:</p><pre><code>@spec extend(substitution, variable, uterm) :: {:ok, substitution}
defp extend(sub, var, term) do
  {:ok, Map.put(sub, var, term)}
end</code></pre><p>This is the step where new knowledge is recorded in the substitution.</p><p>When <code>unify(%{}, x, 1)</code> is called, there&#39;s an assertion that <code>x == 1</code>. Since this assertion doesn&#39;t conflict with the initially empty substitution, the substitution is updated to <code>%{x =&gt; 1}</code>. The same result is obtained from <code>unify(%{}, 1, x)</code> because of the symmetry enforced by the pair of <code>do_unify</code> clauses that test for a <code>Var</code> struct.</p><h3 id="step-5-list">Step 5: List</h3><p>If both terms are non-empty lists, first unify the heads of the two lists. If the heads successfully unify, return the unification of the tails. It looks like this:</p><pre><code>defp do_unify(sub, [h1 | t1], [h2 | t2]) do
  with {:ok, sub} &lt;- unify(sub, h1, h2) do
    unify(sub, t1, t2)
  end
end</code></pre><p>This is the recursive step in the unification algorithm. Notice that the <code>with</code> block returns <code>:error</code> if the heads don&#39;t successfully unify.</p><h3 id="step-6-remainder">Step 6: Remainder</h3><p>If the walked terms passed to <code>do_unify</code> don&#39;t satisfy any of the previous patterns, then the two terms can&#39;t be unified. In this case, just return <code>:error</code>:</p><pre><code>defp do_unify(_sub, _term1, _term2) do
  :error
end</code></pre><p>This clause will be reached when the terms are different atomic values, like 1 and <code>:one</code>, when one term is a constant and the other is a list, or when both terms are empty lists.</p><p>That&#39;s it! This completes implementation of unification. The full code listing can be found here:</p><p><a href="https://gist.github.com/epfahl/06ac14323555ecc6b45f0887278926f0?ref=ericpfahl.com">Unification algorithm in Elixir.</a></p><h2 id="presenting-results">Presenting results</h2><p>Suppose you&#39;re given the substitution <code>%{x =&gt; y, y =&gt; [1, z], z =&gt; 2}</code> and asked to reduce the variables to their simplest possible forms. That means walking the relationships in the substitution as far as possible. This is the job of <code>simplify</code> that was introduced earlier. Here&#39;s a usage example:</p><pre><code>x = Var.new(:x)
y = Var.new(:y)
z = Var.new(:z)

sub = %{x =&gt; y, y =&gt; [1, z], z =&gt; 2}

simplify(sub, [x, y, z])</code></pre><p>This application of <code>simplify</code> returns <code>[[1, 2], [1, 2], 2]</code>. Notice that a new term, <code>[x, y, z]</code>, was created to collect the simplified values.</p><h2 id="examples">Examples</h2><p>This can all seem a bit dry and technical without meaningful examples. Here are two simple examples that hint at more general possibilities.</p><h3 id="yes-and">Yes, and</h3><p>Here are three lists, each with variables:</p><pre><code>[x, y, z] = for i &lt;- [:x, :y, :z], do: Var.new(i)

l1 = [1, y, z]
l2 = [x, 2, z]
l3 = [x, y, 3]</code></pre><p>I assert that all of these lists are equivalent; that is, each list holds the same set of values. Find values for <code>x</code>, <code>y</code>, and <code>z</code> that satisfy the assertion. It&#39;s easy to see that the answer is <code>[x, y, z] = [1, 2, 3]</code>.  Let&#39;s use unification to prove this.</p><p>First, unify <code>l1</code> and <code>l2</code> on an empty substitution to find</p><pre><code>{:ok, s12} = unify(%{}, l1, l2)</code></pre><p>The updated substitution, <code>s12 = %{x =&gt; 1, y =&gt; 2}</code>, holds information about <code>x</code> and <code>y</code>, but not <code>z</code>. Feed this substitution into the unification of  <code>l2</code> and <code>l3</code>:</p><pre><code>{:ok, s23} = unify(s12, l2, l3)</code></pre><p>This yields the substitution <code>s23 = %{x =&gt; 1, y =&gt; 2, z =&gt; 3}</code>. All the variables now have atomic values. Unification of <code>l1</code> and <code>l3</code> using the previous substitution will work just fine, but it doesn&#39;t add any new information.</p><p>All of these steps can be captured in one block of code that looks like a pipeline, where the substitution from the previous step is fed to <code>unify</code> in the next step:</p><pre><code>with {:ok, s12} &lt;- unify(%{}, l1, l2),
     {:ok, s23} &lt;- unify(s12, l2, l3),
     {:ok, s13} &lt;- unify(s23, l1, l3) do
  simplify(s13, [x, y, z])
end</code></pre><p>This returns the expected result <code>[1, 2, 3]</code>.</p><p>The pipeline above encodes that idea that <code>l1 = l2</code> <strong>and</strong>  <code>l2 = l3</code> <strong>and</strong> <code>l1 = l3</code>; it&#39;s asserting that the equalities are <em>jointly</em> true. This is an example of logical <em><a href="https://en.wikipedia.org/wiki/Logical_conjunction?ref=ericpfahl.com">conjunction</a></em>. Successful conjunction produces a single substitution that jointly satisfies the assertions. Failure of any one of the assertions causes the whole conjunction to fail. It&#39;s all or nothing.</p><h3 id="choices-choices">Choices, choices</h3><p>Each variable in a substitution has a single value. And a single substitution captures one set of variable assignments. But what if there are choices for variable values? What if <code>x</code> can be 0 or 1, or <code>:up</code> or <code>:down</code>? If a substitution is able to hold only one value per variable, then a collection of substitutions can encode multiple choices.</p><p>Logical conjunction asserts that statements are <em>jointly</em> true. In a logical <a href="https://en.wikipedia.org/wiki/Logical_disjunction?ref=ericpfahl.com"><em>disjunction</em></a>, the statements may be <em>separately</em> true. Like we saw in the example of the three-way list merge, conjunction involves chaining assertions together to create a single substitution that represents joint truth. Disjunction, on the other hand, creates multiple branches of truth, a collection of substitutions, each of which captures a different choice. It&#39;s time for an example.</p><p>Imagine a person that can move only one step to the left or one step to the right, but we don&#39;t know what choice the person will make beforehand (this might represent a <a href="https://en.wikipedia.org/wiki/Random_walk?ref=ericpfahl.com">random walk</a>). What can we say about the person&#39;s possible locations after a number of steps?</p><figure><img src="https://www.ericpfahl.com/content/images/2023/02/image-3.png" alt="" loading="lazy" width="2000" height="565" srcset="https://www.ericpfahl.com/content/images/size/w600/2023/02/image-3.png 600w, https://www.ericpfahl.com/content/images/size/w1000/2023/02/image-3.png 1000w, https://www.ericpfahl.com/content/images/size/w1600/2023/02/image-3.png 1600w, https://www.ericpfahl.com/content/images/size/w2400/2023/02/image-3.png 2400w" sizes="(min-width: 720px) 720px"/></figure><p>For the first step, the direction <code>d1</code> will be either <code>:left</code> or <code>:right</code>. This can be expressed as two unifications, both starting with an empty substitution:</p><pre><code>d1 = Var.new(:d1)

{:ok, sl} = unify(%{}, d1, :left)
{:ok, sr} = unify(%{}, d1, :right)

[sl, sr] = [%{d1 =&gt; :left}, %{d1 =&gt; :right}]</code></pre><p>The list of substitutions exhibits the two choices for <code>d1</code>. Another way to write this, for reasons you&#39;ll see very soon, is</p><pre><code>d1 = Var.new(:d1)

[sl, sr] =
  [%{}]
  |&gt; Enum.flat_map(fn sub -&gt;
    {:ok, sl} = unify(sub, d1, :left)
    {:ok, sr} = unify(sub, d1, :right)
    [sl, sr]
  end)</code></pre><p>Convince yourself that this returns the same result (see the docs for <code><a href="https://hexdocs.pm/elixir/1.14/Enum.html?ref=ericpfahl.com#flat_map/2">Enum.flat_map</a></code>).</p><p>What&#39;s the situation after two steps? The choices are the same (<code>:left</code> or <code>:right</code>), but each choice for the second step is compounded with the choice from the first step. The first step is either <code>:left</code> <strong>or</strong> <code>:right</code>, <strong>and</strong> the second step is either <code>:left</code> <strong>or</strong> <code>:right</code>. This is a conjunction of two disjunctions. The result from the first step is chained with the result from the second step. Here&#39;s what that looks like in code:</p><pre><code>d2 = Var.new(:d2)

[sl, sr]
  |&gt; Enum.flat_map(fn sub -&gt;
    {:ok, sl} = unify(sub, d2, :left)
    {:ok, sr} = unify(sub, d2, :right)
    [sl, sr]
  end)</code></pre><p>The result from the first step is piped to <code>flat_map</code>. This has the same structure as the code from the first step. The two-step result is</p><pre><code>[
  %{d1 =&gt; :left, d2 =&gt; :left},
  %{d1 =&gt; :left, d2 =&gt; :right},
  %{d1 =&gt; :right, d2 =&gt; :left},
  %{d1 =&gt; :right, d2 =&gt; :right}
]
</code></pre><p>There are four substitutions, each displaying a pair of binary choices.</p><p>A third step will produce eight substitutions. Can you see how to pipe the previous result into a similar <code>flat_map</code> expression that contains a variable <code>d3</code>? The pattern can certainly be leveraged to create a more ergonomic way to generate the substitutions for any number of steps. That&#39;s left to you as an exercise!</p><h2 id="wrapping-up-and-looking-ahead">Wrapping up and looking ahead</h2><p>You now have in your toolbox a working <a href="https://gist.github.com/epfahl/06ac14323555ecc6b45f0887278926f0?ref=ericpfahl.com">Elixir implementation of unification</a>. My hope is that you also <em>understand</em> how unification works, perhaps well enough to read about other implementations or to write your own version in a different language. If your understanding is still a little hazy, have some fun experimenting with the code. Create your own examples. Tweak the algorithm and see what happens. Add some helper functions to streamline tedious steps.</p><p>Even on its own, unification, like Elixir&#39;s pattern matching, is a powerful tool. But things get so much more interesting when new operations are layered on top of unification. The examples above hint at how conjunction and disjunction might be implemented more generally. With only equality (via unification), conjunction, and disjunction, it&#39;s possible to create a very capable logic programming language. To read more about this, take a look at some of the sources that inspired this post:</p><p><a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf?ref=ericpfahl.com" rel="nofollow">microKanren: A Minimal Functional Core for Relational Programming</a></p><p><a href="https://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf?ref=ericpfahl.com" rel="nofollow">Relational Programming in miniKanren: Techniques, Applications, and Implementations</a></p><p><a href="https://mitpress.mit.edu/9780262535519/the-reasoned-schemer/?ref=ericpfahl.com" rel="nofollow">The Reasoned Schemer</a></p><p>All of these references use a Lisp dialect as the host language. For an Elixir-flavored miniKanren, see <a href="https://github.com/epfahl/logos?ref=ericpfahl.com">Logos</a>, a library I wrote that is still very much a work-in-progress.</p><p>In a follow-up post, I&#39;ll go into some of the core operations defined in microKanren and how they can be leveraged to build more powerful logical abstractions.</p><p>Have fun and logic on!</p>
    </section>


</article>
</div></div>
  </body>
</html>
