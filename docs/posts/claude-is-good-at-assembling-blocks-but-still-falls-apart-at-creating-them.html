<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.approachwithalacrity.com/claude-ne/">Original</a>
    <h1>Claude is good at assembling blocks, but still falls apart at creating them</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Opus 4.5 is out and people cannot stop raving about it. AGI is nigh! It&#39;s a step-change in capabilities!</p><p>Don&#39;t get me wrong. It&#39;s very impressive. But after trying it out in a real codebase for a few weeks, I think that view is overly simplistic. Claude is now incredibly good at assembling well-designed blocks â€“ but it still falls apart when it has to create them.</p><p>To demonstrate, I&#39;ll run through three real examples: a Sentry debugging loop where Claude ran on its own for 90 minutes and solved the problem; an AWS migration it one-shotted in three hours; and a React refactor where it proposed a hack that would have made our codebase worse. </p><p>The same pattern explains all three. And in doing so, it also demonstrates what senior engineers actually do â€“ and why we&#39;ll be safe from AGI for a long time.</p><figure><blockquote><p lang="qme" dir="ltr">ðŸŽ¯</p>â€” Ryan Nystrom (@ryannystrom) <a href="https://twitter.com/ryannystrom/status/2010096311379603909?ref_src=twsrc%5Etfw&amp;ref=approachwithalacrity.com">January 10, 2026</a></blockquote>
<figcaption><p><span>The tl;dr.</span></p></figcaption></figure><h2 id="the-good">The Good</h2><h3 id="running-a-playwright-and-sentry-debugging-loop">Running a Playwright-and-Sentry debugging loop</h3><p>The most impressive thing Claude Code has done for me is debug, on its own.</p><p>I was trying to attach Sentry to our system. Sentry is a wonderful service that creates nice traces of when parts of your code run. This makes it easy to figure out why itâ€™s running slower than you expect. </p><figure><img src="https://www.approachwithalacrity.com/content/images/2026/01/Screenshot-2026-01-07-at-7.24.24---PM-1.png" alt="" loading="lazy" width="2000" height="2286" srcset="https://www.approachwithalacrity.com/content/images/size/w600/2026/01/Screenshot-2026-01-07-at-7.24.24---PM-1.png 600w, https://www.approachwithalacrity.com/content/images/size/w1000/2026/01/Screenshot-2026-01-07-at-7.24.24---PM-1.png 1000w, https://www.approachwithalacrity.com/content/images/size/w1600/2026/01/Screenshot-2026-01-07-at-7.24.24---PM-1.png 1600w, https://www.approachwithalacrity.com/content/images/2026/01/Screenshot-2026-01-07-at-7.24.24---PM-1.png 2238w" sizes="(min-width: 720px) 720px"/><figcaption><span>An example sentry trace, showing that we need to optimize our database lookups...</span></figcaption></figure><p>It&#39;s usually very easy to set up, but on this day it wasn&#39;t working. And there were no good debug logs, so the only way to figure out what was going on was to guess-and-check. I had to send a test message on our frontend, then look into the Sentry logs to see if we successfully set it up, then randomly try another approach based on the docs. It was frustrating and tedious.</p><p>So I had Claude write a little testing script with Playwright that logged into our website and sent a chat. Then I had it connect to Sentry by MCP, and look for the exact codepath I was trying to debug. Finally, I gave it the Sentry docs and told it to keep plugging away until it figured it out.</p><p>It took about an hour and a half, but Claude finally got it. This was pretty cool! The core loop of performance engineering is straightforward: make a code change, test, check tracing logs, repeat. With this tooling, Claude could do that work for us.</p><p>(The problem, if you&#39;re interested, was that Sentry automatically sets up transactions for FastAPI endpoints <em>but not for ones that return StreamingResponses</em>. The solution was to write that in manually.)</p><h3 id="migrating-from-modal-to-aws-ecs-in-an-evening">Migrating from Modal to AWS ECS in an evening</h3><p>Iâ€™ve used <a href="https://modal.com/?ref=approachwithalacrity.com" rel="noreferrer">Modal</a> happily for a year. It has the <em>best</em> UI for spinning up containers in the cloud on-demand. But last week we hit its limits, so I had to migrate us onto AWS.</p><p>I wanted to set up an autoscaling, containerized workflow on Amazon&#39;s Elastic Container Service, since I knew this was the â€˜rightâ€™ thing to do. Iâ€™ve set up plenty of Linux servers by hand, so I knew what to do. But I&#39;ve never before touched Kubernetes or ECS. The pain of learning AWSâ€™s terminology always put me off.</p><p>This time, I asked Claude to do it. I gave it Terraform and access to the <code>aws</code> command line tool. It one-shotted creating Dockerfiles for our code. Then it pushed them to AWSâ€™s container registry, and set up the correct permissions using the cli, and set up the necessary AWS ECS configs in Terraform. </p><p>And it all worked on the first try! Amazing!</p><figure><img src="https://www.approachwithalacrity.com/content/images/2026/01/Screenshot-2026-01-11-at-10.28.07---PM.png" alt="" loading="lazy" width="1082" height="548" srcset="https://www.approachwithalacrity.com/content/images/size/w600/2026/01/Screenshot-2026-01-11-at-10.28.07---PM.png 600w, https://www.approachwithalacrity.com/content/images/size/w1000/2026/01/Screenshot-2026-01-11-at-10.28.07---PM.png 1000w, https://www.approachwithalacrity.com/content/images/2026/01/Screenshot-2026-01-11-at-10.28.07---PM.png 1082w" sizes="(min-width: 720px) 720px"/><figcaption><span>Here are some terraform configs. Exciting stuff. Imagine writing this by hand!</span></figcaption></figure><p>This is a straightforward task, but it would have taken me a day or two. I would have made a dozen mistakes and would have had to read through pages of AWS documentation. Claude crushed it, and got it all working in three hours late at night.</p><h3 id="conclusion">Conclusion</h3><p>Both these use-cases are really impressive! They required a lot of detail and care. They each probably saved me a day and a half of low-value, tedious work. And Claude&#39;s ability to track its own state and keep going was great! I can see why folks cannot shut up about Opus 4.5. </p><h2 id="the-bad">The Bad</h2><h3 id="what-makes-a-good-engineer">What makes a good engineer?</h3><p>I once knew a distinguished engineer named sweeks. Sweeks was legendary for his good code. People whispered about how he had single-handedly invented many of my employer&#39;s paradigms for programming in OCaml.</p><p>Sweeks wasnâ€™t a god. He wrote normal, bug-prone code, like you and me. He was good at coding because he was a gardener. Every time he walked into his codebase, he picked up his shears and manicured a bit of stray code. Over time, he rewrote every line of code over and over, tightening it down to only the perfectly-abstracted essentials.</p><p>Sweeks is an inspiration. So whenever I make a change in our codebase, I ask if itâ€™s the most elegant solution. If not, I rewrite the code until it is. Putting in a hacky fix might take five minutes; repairing all the code around a change might take me thirty. But unless Iâ€™m in a rush, I always do the latter.</p><p>I bring this up because it&#39;s a microcosm of what a senior engineer does. A senior engineer sees the non-obvious improvements and executes them quickly. A senior engineer identifies large step changes that are costly, but pay off in multiples down the road, and fights to get them through.</p><p>Opus is not a senior engineer.</p><h3 id="claude-tries-to-write-react-and-fails">Claude tries to write React, and fails</h3><p>I was recently working on some gnarly React code. (In fact, it was gnarly because I vibe-coded it over Christmas and pushed it without properly cleaning it up.)</p><p>We had two components that both needed access to the same data: Component A had a â€˜keyâ€™, and Component B had an â€˜idâ€™. And we had these data structures:</p><p><code>keyIdPairs: [(key, id)] // a list of tuples</code></p><p>Our problem, at its core, was that Component A needed to look up <code>data</code> on-demand as well. What to do? </p><p>Claude, our idiot savant, proposed a linear lookup:</p><p><code>// Scan the list to find the matching id</code></p><p>But in context, this was obviously insane. I knew that <code>key</code> and <code>id</code> came from the same upstream source. So the correct solution was to have the upstream source also pass <code>id</code> to the code that had <code>key</code>, to let it do a fast lookup.*</p><p>If you give Claude the pure data problem, it comes up with the right solution. But in our actual codebase, it lost the plot. It couldn&#39;t see the actual data problem amid all the badly-written React code. If Iâ€™d let it run wild, it would have made our frontend codebase worse.</p><h2 id="claude-needs-good-legos">Claude needs good legos</h2><p>Nowadays, I think of Claude as a very smart child â€” one that loves to put together legos. Good infrastructure and abstractions are the lego blocks you give it. The bigger and better they are, the more you can do.</p><p>When I gave it Sentry, I could put it in a loop and watch it go. When I gave it Terraform and told it to go wild on the AWS CLI, it succeeded because Terraform is an excellent abstraction over cloud compute resources.</p><p>But when you donâ€™t have good abstractions â€” like in our gnarly React code â€” Claude gets lost, and it canâ€™t rescue itself.</p><p><a href="https://grantslatton.com/?ref=approachwithalacrity.com" rel="noreferrer">Grant Slatton</a> put it very well:</p><figure><blockquote><p lang="en" dir="ltr">obviously this is a very rough analogy, it&#39;s just a handwave sketch at a concept</p>â€” Grant Slatton (@GrantSlatton) <a href="https://twitter.com/GrantSlatton/status/2005009356463767914?ref_src=twsrc%5Etfw&amp;ref=approachwithalacrity.com">December 27, 2025</a></blockquote>
</figure><p>Since Claude canâ€™t <em>create</em> the good abstractions. Claude&#39;s powers are limited by how good the blocks you give it are. Have no illusions; Claude cannot reproduce Sentry and Terraform and Playwright. These are incredibly complex and well-designed pieces of code. And since Claude canâ€™t create good abstractions on its own, thereâ€™s a limit to how much anyone can do with Claude alone. Even though everyone on X thinks you can vibe-code all software, I think the opposite is true: the value of good abstractions and well-designed infrastructure has never been higher.</p><p>If I had to boil down my criticism of Claude to one sentence, itâ€™s this: Claude doesnâ€™t have a soul. It doesn&#39;t want anything. It certainly doesnâ€™t yearn to create beautiful things. So it doesnâ€™t produce good solutions. It doesn&#39;t write elegant abstractions where there were none; it doesn&#39;t manicure the code garden.</p><p>And this is all fine! It&#39;s still a fantastic tool. But until it has a soul, we should all calm down a little. It&#39;s nowhere near replacing all engineers. If anything, it makes us all much more important.</p><p><em>Edited Jan 12: I rewrote the React section to explain more clearly what Claude did wrong. Thanks to </em><a href="https://x.com/konstiwohlwend/status/2010799158261936281?ref=approachwithalacrity.com" rel="noreferrer"><em>Konsti</em></a><em> for pointing this out!</em></p>
    </div></div>
  </body>
</html>
