<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dashbit.co/blog/data-evolution-with-set-theoretic-types">Original</a>
    <h1>Data evolution with set-theoretic types</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
<ul>
  <li>
    <i></i> José Valim
  </li>
  <li>
    <i></i> January 14th, 2025
  </li>
  <li>
    <i></i><a href="https://dashbit.co/blog/tags/elixir">elixir</a>, <a href="https://dashbit.co/blog/tags/types">types</a>, <a href="https://dashbit.co/blog/tags/structs">structs</a>
  </li>
</ul>
<p>
Recently I have been working on projects that integrate Elixir with native code in C and Rust. One of the Rust libraries defines the following struct (with fields removed for simplicity):</p>
<pre><code>struct Schema {
  name: CString,
  format: CString,
  metadata: Option&lt;Vec&lt;u8&gt;&gt;,
  dictionary: Option&lt;*mut Schema&gt;
}</code></pre>
<p>
It turns out the structure above does not follow the C specification, which says the name may be <em>null</em>. Unfortunately, the C library I used was producing data with the name set to <code>null</code>, making it impossible to interoperate with the Rust one.</p>
<p>
I was the unlucky one to find this out. Even though the library is well used within the Rust ecosystem, by several projects throughout the years, nobody ran into this before. The ideal solution is to change the type of the struct field, perhaps by wrapping the name into an <code>Option</code> type:</p>
<pre><code>struct Schema {
  name: Option&lt;CString&gt;,
  format: CString,
  metadata: Option&lt;Vec&lt;u8&gt;&gt;,
  dictionary: Option&lt;*mut Schema&gt;
}</code></pre>
<p>
However, doing so would effectively break ALL existing users of the library. Who am I to propose such a breaking change to a library, based on a scenario that apparently no one else ran into after a few years? Such change would effectively split the library’ ecosystem in two.</p>
<p>
Alternatively, we could convert <code>null</code>s into empty strings, keeping the current type definition and compatibility, but still not following the spec. This was the option taken for this particular case.</p>
<p>
Honestly, this is a tough spot where none of the options are optimal. This article aims to explore how set-theoretic types could help address the issue that many statically typed languages do not allow libraries to evolve their public data definitions in a backwards-compatible manner. The proposed solution aims to be automatically verified by the compiler and type safe.</p>
<blockquote>
  <p>
There is on-going research to bring <a href="https://elixir-lang.org/blog/2023/06/22/type-system-updates-research-dev/">a set-theoretic type system to the Elixir programming language</a>. While this blog post is related to both Elixir and set-theoretic types, it is not an official proposal to the language. I am publishing it on the Dashbit blog to open up the discussion and collect feedback.  </p>
</blockquote>
<h2>
Breaking changes: libraries vs applications</h2>
<p>
While changing the name from <code>CString</code> to  <code>Option&lt;CString&gt;</code> would be acceptable within our own applications, since we control all consumers of the code, when it happens in a library, it causes a downstream flow of changes. For this article, let’s assume the library is called “data_schema”.</p>
<p>
If “data_schema” changes a user facing type, such as the <code>Schema</code> type above, in a backwards incompatible manner, its authors have to release a new major version. A new major version can be a fork on the road. Libraries that depend on “data_schema”‘s new version won’t accept the old ones. Old libraries that depend on “data_schema” have to be updated and potentially forced to also release a new major version, cascading the problem. If any package along the way is unmaintained, it can stall and complicate further downstream updates.</p>
<p>
On the other hand, we, as developers, deal with the fact our data definitions are evolving all the time. If you talk to a seasoned web application developer, they will tell you: “you should never rename a database column”. Instead, you must add a new column, copy the data, and remove the old column.</p>
<p>
Similarly, the Erlang VM is used for building distributed systems, which may also require old and new nodes to interact with each other. It also performs hot code upgrades, allowing you to change the code that is running in production without bringing the system down. This requires our codebase to deal with both old and new versions of data.</p>
<p>
Despite plenty of examples and uses of data versioning, our type systems often provide little support for us to do the same: once you change a data definition, it assumes all old versions of the data ceases to exist and all code must be immediately rewritten, with nothing between.</p>
<h2>
Replicating the problem in Elixir</h2>
<p>
Let’s port the problem to Elixir. The Elixir team has not yet defined how structs will be declared under set-theoretic types but we can explore some ideas which are valid Elixir syntax today.</p>
<p>
Imagine that we define typed structs in Elixir as follows (let’s call this v1):</p>
<pre><code><span>defmodule</span><span> </span><span>Schema</span><span> </span><span data-group-id="0844621479-1">do</span><span>
  </span><span>defstruct</span><span> </span><span data-group-id="0844621479-2">do</span><span>
    </span><span>name</span><span> </span><span>::</span><span> </span><span>string</span><span data-group-id="0844621479-3">(</span><span data-group-id="0844621479-3">)</span><span>
  </span><span data-group-id="0844621479-2">end</span><span>
</span><span data-group-id="0844621479-1">end</span></code></pre>
<p>
In Elixir, we can now instantiate a new struct as <code>%Schema{name: &#34;mycolumn&#34;}</code>.</p>
<p>
And let’s say there is a convenience function for upcasing the schema name. It is quite silly but enough to explore the problem space:</p>
<pre><code><span>defmodule</span><span> </span><span>SchemaHelpers</span><span> </span><span data-group-id="2733222880-1">do</span><span>
  </span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="2733222880-2">(</span><span data-group-id="2733222880-2">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="2733222880-3">(</span><span data-group-id="2733222880-3">)</span><span>
  </span><span>def</span><span> </span><span>upcase_name</span><span data-group-id="2733222880-4">(</span><span data-group-id="2733222880-5">%{</span><span>name</span><span>:</span><span> </span><span>name</span><span data-group-id="2733222880-5">}</span><span> </span><span>=</span><span> </span><span>schema</span><span data-group-id="2733222880-4">)</span><span> </span><span data-group-id="2733222880-6">do</span><span>
    </span><span data-group-id="2733222880-7">%{</span><span>schema</span><span> </span><span>|</span><span> </span><span>name</span><span>:</span><span> </span><span>String</span><span>.</span><span>upcase</span><span data-group-id="2733222880-8">(</span><span>name</span><span data-group-id="2733222880-8">)</span><span data-group-id="2733222880-7">}</span><span>
  </span><span data-group-id="2733222880-6">end</span><span>
</span><span data-group-id="2733222880-1">end</span></code></pre>
<p>
Calling it with <code>%Schema{name: &#34;mycolumn&#34;}</code> returns <code>%Schema{name: &#34;MYCOLUMN&#34;}</code>.</p>
<p>
Now what happens when we change the <code>Schema</code> definition to support <code>nil</code>s? Let’s call this v2:</p>
<pre><code><span>defmodule</span><span> </span><span>Schema</span><span> </span><span data-group-id="0887570023-1">do</span><span>
  </span><span>defstruct</span><span> </span><span data-group-id="0887570023-2">do</span><span>
    </span><span>name</span><span> </span><span>::</span><span> </span><span>string</span><span data-group-id="0887570023-3">(</span><span data-group-id="0887570023-3">)</span><span> </span><span>or</span><span> </span><span>nil</span><span>
  </span><span data-group-id="0887570023-2">end</span><span>
</span><span data-group-id="0887570023-1">end</span></code></pre>
<p>
With the change above, you should now expect <code>SchemaHelpers.upcase_name/1</code> to report a typing violation. The <code>name</code> can now be <code>nil</code> but the <code>String.upcase/1</code> function will fail if given a <code>nil</code> value.</p>
<p>
That looks correct… or does it?</p>
<p>
In our v1 of <code>Schema</code>, we allowed <code>name</code> to only be a <code>string()</code>. In a statically typed language, we are effectively proving that all uses of <code>Schema</code> has a <code>string()</code> name. When we allow the name to also be <code>nil</code> in v2, that should not introduce bugs in our software <em>yet</em> because, by definition, there is no instance of <code>Schema</code> where the name is <code>nil</code>!</p>
<p>
In other words, all existing code remains correct, but most type systems would immediately flag them as wrong, on the possibility they <em>may</em> receive a <code>nil</code> value. There must be a better way and that’s what we study in this article.</p>
<p>
In particular, we want to provide a mechanism where both old and new version of <code>Schema</code> can coexist <strong>while preserving type safety</strong>. Luckily, Elixir’s type system allows us to explore this through structural subtyping. So let’s take a deeper look.</p>
<h2>
Data instantiation with structural subtyping</h2>
<p>
In simple words, structural subtyping assigns types based on the <code>Schema</code> value, not on the <code>Schema</code> definition.</p>
<p>
In nominal type systems, where types are represented by their name, the following Elixir code would commonly have type <code>Schema</code>:</p>
<pre><code><span data-group-id="0655650009-1">%</span><span data-group-id="0655650009-1">Schema</span><span data-group-id="0655650009-1">{</span><span>name</span><span>:</span><span> </span><span>&#34;mycolumn&#34;</span><span data-group-id="0655650009-1">}</span></code></pre>
<p>
If you want to know exactly what the field <code>name</code> represents, you would consult the <code>Schema</code> definition, and learn it is <code>string()</code> if you are using v1. If you are using v2, it is <code>string() or nil</code>, even if the field <code>name</code> is always given a string when the schema is instantiated.</p>
<p>
However, with structural subtyping, the definition above gets the type <code>Schema.t(name: string())</code>, which is valid as long as it is a subtype of the field types specified in the <code>Schema</code> definition. Changing the <code>Schema</code> definition to a broader type won’t change the instantiated data nor cause type incompatibilities. Consequently, at this moment, there is no <code>Schema</code> instance where the name is <code>nil</code>.</p>
<h2>
Type checking with revisions</h2>
<p>
As seen above, structural subtyping allows us to preserve the types of our schema fields when we instantiate them, even if the <code>Schema</code> definition changes. But what about function signatures?</p>
<p>
The <code>upcase_name</code> function is a perfect example:</p>
<pre><code><span>defmodule</span><span> </span><span>SchemaHelpers</span><span> </span><span data-group-id="2114827580-1">do</span><span>
  </span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="2114827580-2">(</span><span data-group-id="2114827580-2">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="2114827580-3">(</span><span data-group-id="2114827580-3">)</span><span>
  </span><span>def</span><span> </span><span>upcase_name</span><span data-group-id="2114827580-4">(</span><span data-group-id="2114827580-5">%{</span><span>name</span><span>:</span><span> </span><span>name</span><span data-group-id="2114827580-5">}</span><span> </span><span>=</span><span> </span><span>schema</span><span data-group-id="2114827580-4">)</span><span> </span><span data-group-id="2114827580-6">do</span><span>
    </span><span data-group-id="2114827580-7">%{</span><span>schema</span><span> </span><span>|</span><span> </span><span>name</span><span>:</span><span> </span><span>String</span><span>.</span><span>upcase</span><span data-group-id="2114827580-8">(</span><span>name</span><span data-group-id="2114827580-8">)</span><span data-group-id="2114827580-7">}</span><span>
  </span><span data-group-id="2114827580-6">end</span><span>
</span><span data-group-id="2114827580-1">end</span></code></pre>
<p>
If the type for the <code>name</code> suddenly changes to <code>string() or nil</code>, our function will report a typing violation because it is incapable of handling <code>nil</code> values. Now, let’s fix the function above to also handle <code>nil</code>s:</p>
<pre><code><span>defmodule</span><span> </span><span>SchemaHelpers</span><span> </span><span data-group-id="1956412918-1">do</span><span>
  </span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="1956412918-2">(</span><span data-group-id="1956412918-2">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="1956412918-3">(</span><span data-group-id="1956412918-3">)</span><span>
  </span><span>def</span><span> </span><span>upcase_name</span><span data-group-id="1956412918-4">(</span><span data-group-id="1956412918-5">%{</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="1956412918-5">}</span><span> </span><span>=</span><span> </span><span>schema</span><span data-group-id="1956412918-4">)</span><span> </span><span data-group-id="1956412918-6">do</span><span>
    </span><span>schema</span><span>
  </span><span data-group-id="1956412918-6">end</span><span>

  </span><span>def</span><span> </span><span>upcase_name</span><span data-group-id="1956412918-7">(</span><span data-group-id="1956412918-8">%{</span><span>name</span><span>:</span><span> </span><span>name</span><span data-group-id="1956412918-8">}</span><span> </span><span>=</span><span> </span><span>schema</span><span data-group-id="1956412918-7">)</span><span> </span><span data-group-id="1956412918-9">do</span><span>
    </span><span data-group-id="1956412918-10">%{</span><span>schema</span><span> </span><span>|</span><span> </span><span>name</span><span>:</span><span> </span><span>String</span><span>.</span><span>upcase</span><span data-group-id="1956412918-11">(</span><span>name</span><span data-group-id="1956412918-11">)</span><span data-group-id="1956412918-10">}</span><span>
  </span><span data-group-id="1956412918-9">end</span><span>
</span><span data-group-id="1956412918-1">end</span></code></pre>
<p>
Our code has been fixed but it has a downside. If I give it a struct <code>%Schema{name: &#34;mycolumn&#34;}</code>, which has type <code>Schema.t(name: string())</code>, the function signature says that it will return a new <code>Schema.t()</code>, which is equivalent to type <code>Schema.t(name: string() or nil)</code>. In other words, even though we can instantiate structs as <code>v1</code>, as soon as we do any operation on them, their types will get “upgraded” to <code>v2</code>, which has type <code>string() or nil</code>. This will lead to further typing violations, which can lead to breaking changes on codebases using our library.</p>
<p>
Instead, it would be ideal if the <code>upcase_name</code> function could preserve the version of the schema. If a <code>schema</code> of type v1 is given, it returns a schema of type v1. If a schema of type v2 is given, it returns a schema of type v2. In fact, if you look at the implementation of the function, it already guarantees this! But the function signature does not encode this property.</p>
<p>
This article proposes to address this problem by introducing an explicit versioning mechanism - let’s call them <em>revisions</em> - to our structs. So in this case, the updated <code>Schema</code> struct would look like this:</p>
<pre><code><span>defmodule</span><span> </span><span>Schema</span><span> </span><span data-group-id="7590491705-1">do</span><span>
  </span><span>defstruct</span><span> </span><span data-group-id="7590491705-2">do</span><span>
    </span><span>name</span><span> </span><span>::</span><span> </span><span>string</span><span data-group-id="7590491705-3">(</span><span data-group-id="7590491705-3">)</span><span>

    </span><span>revision</span><span> </span><span>2</span><span> </span><span data-group-id="7590491705-4">do</span><span>
      </span><span>name</span><span> </span><span>::</span><span> </span><span>string</span><span data-group-id="7590491705-5">(</span><span data-group-id="7590491705-5">)</span><span> </span><span>or</span><span> </span><span>nil</span><span>
    </span><span data-group-id="7590491705-4">end</span><span>
  </span><span data-group-id="7590491705-2">end</span><span>
</span><span data-group-id="7590491705-1">end</span></code></pre>
<p>
Fields declared without a revision are considered to belong to revision 1. Furthermore, from now on, we will say that <code>Schema.t()</code> always returns the field types of the latest revision, but remember you can specify a field type explicitly, such as <code>Schema.t(name: string())</code>.</p>
<p>
As long as revision 2 (r2) is a supertype of revision 1 (r1), which is something the type system can enforce, we want to generally assert that all code written with r2 will work for both r1 and r2. While code written for r1, only works with r1.</p>
<p>
The next challenge is to prove that <code>upcase_name</code> returns <code>r1</code> if given <code>r1</code>, and returns <code>r2</code> if given <code>r2</code>. Intuitively, we want that:</p>
<ul>
  <li>
    <p>
if given a schema that has type <code>r1</code>, i.e. the <code>name</code> field is a <code>string()</code>, it returns a schema with a <code>string()</code> name    </p>
  </li>
  <li>
    <p>
if given a schema type that is <code>r2</code> but not <code>r1</code>, then the <code>name</code> field can only be <code>nil</code>, and it can return a schema with names of either <code>string()</code> or <code>nil</code> (after all, we don’t care if r2 downgrades to r1, only the opposite)    </p>
  </li>
</ul>
<p>
Luckily, thanks to intersection types, we can precisely encode the logic above into a function signature:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="7986873765-1">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="7986873765-2">(</span><span data-group-id="7986873765-2">)</span><span data-group-id="7986873765-1">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="7986873765-3">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="7986873765-4">(</span><span data-group-id="7986873765-4">)</span><span data-group-id="7986873765-3">)</span><span>
</span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="7986873765-5">(</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="7986873765-5">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="7986873765-6">(</span><span data-group-id="7986873765-6">)</span></code></pre>
<p>
The definition above says: if the struct matches <code>r1</code>, it will return <code>r1</code>. Otherwise, if it receives a struct containing the additional parts of <code>r2</code>, which is the <code>nil</code> possibility in the <code>name</code> field, it will return <code>r2</code>. This will allow us to enforce what we call the <strong>revision preservation property</strong>.</p>
<p>
The most important part is that, you won’t have to write the signature above. Since we explicitly tagged the revisions, the Elixir compiler can automatically rewrite <code>$ Schema.t() -&gt; Schema.t()</code> into a function signature that enforces the revision preservation property! Long story short: we can support both old and new versions of <code>Schema</code> and all of the work will be done by the compiler and the type system to guarantee correctness, enabling library authors to provide a safer and better experience to developers.</p>
<p>
Let’s see a couple more examples before we dive deeper into how it works.</p>
<h2>
Multi-field revisions</h2>
<p>
Let’s complicate our example a bit further. Imagine this was our struct definition.</p>
<pre><code><span>defmodule</span><span> </span><span>Schema</span><span> </span><span data-group-id="7214872008-1">do</span><span>
  </span><span>defstruct</span><span> </span><span data-group-id="7214872008-2">do</span><span>
    </span><span>name</span><span> </span><span>::</span><span> </span><span>string</span><span data-group-id="7214872008-3">(</span><span data-group-id="7214872008-3">)</span><span>
    </span><span>age</span><span> </span><span>::</span><span> </span><span>integer</span><span data-group-id="7214872008-4">(</span><span data-group-id="7214872008-4">)</span><span>

    </span><span>revision</span><span> </span><span>2</span><span> </span><span data-group-id="7214872008-5">do</span><span>
      </span><span>name</span><span> </span><span>::</span><span> </span><span>string</span><span data-group-id="7214872008-6">(</span><span data-group-id="7214872008-6">)</span><span> </span><span>or</span><span> </span><span>nil</span><span>
      </span><span>age</span><span> </span><span>::</span><span> </span><span>integer</span><span data-group-id="7214872008-7">(</span><span data-group-id="7214872008-7">)</span><span> </span><span>or</span><span> </span><span>nil</span><span>
    </span><span data-group-id="7214872008-5">end</span><span>
  </span><span data-group-id="7214872008-2">end</span><span>
</span><span data-group-id="7214872008-1">end</span></code></pre>
<p>
Given the <code>$ Schema.t() -&gt; Schema.t()</code> signature used <code>upcase_name/1</code>, what is the underlying signature the compiler should automatically generate to validate our revision presevation property?</p>
<p>
Here it goes:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6090030867-1">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="6090030867-2">(</span><span data-group-id="6090030867-2">)</span><span>,</span><span> </span><span>age</span><span>:</span><span> </span><span>integer</span><span data-group-id="6090030867-3">(</span><span data-group-id="6090030867-3">)</span><span data-group-id="6090030867-1">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6090030867-4">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="6090030867-5">(</span><span data-group-id="6090030867-5">)</span><span>,</span><span> </span><span>age</span><span>:</span><span> </span><span>integer</span><span data-group-id="6090030867-6">(</span><span data-group-id="6090030867-6">)</span><span data-group-id="6090030867-4">)</span><span>
</span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6090030867-7">(</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="6090030867-7">)</span><span> </span><span>or</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6090030867-8">(</span><span>age</span><span>:</span><span> </span><span>nil</span><span data-group-id="6090030867-8">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6090030867-9">(</span><span data-group-id="6090030867-9">)</span></code></pre>
<p>
It is quite similar to the one before, except it now encompasses more fields. If we receive <code>r1</code>, where name is a string and age is an integer, we will return <code>r1</code>. Otherwise any field encoded by <code>r2</code> and not in <code>r1</code>, returns <code>r2</code>.</p>
<p>
Note we wrote <code>Schema.t(name: nil) or Schema.t(age: nil)</code> and not <code>Schema.t(name: nil, age: nil)</code>. The latter requires both fields as <code>nil</code>, while we want any struct that has <em>any</em> of the fields as <code>nil</code> would belong to r2. Hence <code>Schema.t(name: nil) or Schema.t(age: nil)</code>.</p>
<p>
Therefore, to prove the <strong>revision preservation property</strong>, the number of possibilities we need to validate per revision will grow by the amount of revisioned fields. Each field changed in a new revision adds one new “union” for us to prove, which may have an impact type checking times.</p>
<p>
Regardless if performance of multiple revisioned fields will be a concern or not, we propose to give users explicit control over which revisions they want to allow in their applications. It is unlikely - or shall we say, not advisable to - for a given application to depend on several revisions over a long period of time. They are meant to be transitory.</p>
<p>
So let’s see some examples of how one might control the revisions used in their application.</p>
<h2>
Explicit revision control</h2>
<p>
As the author of <code>data_schema</code> library, you want to prove that your library is compatible for all revisions you provide, therefore, you could set the configuration in your <code>mix.exs</code> to:</p>
<pre><code><span>revisions</span><span>:</span><span> </span><span data-group-id="8206566564-1">%{</span><span>
  </span><span>Schema</span><span> </span><span>=&gt;</span><span> </span><span data-group-id="8206566564-2">[</span><span>1</span><span>,</span><span> </span><span>2</span><span data-group-id="8206566564-2">]</span><span>
</span><span data-group-id="8206566564-1">}</span></code></pre>
<p>
This will guarantee to the author of the <code>Schema</code> struct that users can safely upgrade their codebases through the revision preservation property, as the compiler and type system will assume <code>r1</code> and <code>r2</code> should coexist.</p>
<p>
On the other hand, applications that use <code>data_schema</code>, may simply start by supporting only r1 on upgrades:</p>
<pre><code><span>revisions</span><span>:</span><span> </span><span data-group-id="3391353899-1">%{</span><span>
  </span><span>Schema</span><span> </span><span>=&gt;</span><span> </span><span data-group-id="3391353899-2">[</span><span>1</span><span data-group-id="3391353899-2">]</span><span>
</span><span data-group-id="3391353899-1">}</span></code></pre>
<p>
Given <code>data_schema</code> was proven to work with both revisions, we can restrict our revision to a subset. Then, once application developers are ready to migrate to r2, they either bump the revision or remove the configuration altogether. Ideally, application developers do not need to work without multiple revisions at once. The mechanism is there mostly to empower library authors, but multiple revisions may be handy on large updates.</p>
<h2>
Transitive dependencies</h2>
<p>
Let’s complicate our scenario a bit further. The biggest issue with doing breaking changes to a library is breaking all of the other libraries that depend on it, causing a rift in the ecosystem.</p>
<p>
So imagine that we introduce a new dependency, called “depends_on_data_schema”, such that:</p>
<pre><code>my_app -&gt; depends_on_data_schema -&gt; data_schema</code></pre>
<p>
When you configure the revision of <code>Schema</code>, it applies to all libraries, so we know this state is valid:</p>
<pre><code>my_app -&gt; depends_on_data_schema -&gt; data_schema
  r1                r1                  r1</code></pre>
<p>
As well as:</p>
<pre><code>my_app -&gt; depends_on_data_schema -&gt; data_schema
  r2                r2                  r2</code></pre>
<p>
However, it is worth pointing out that we could allow a combination of revisions, as long as revisions are not removed as you descend the dependency tree. In particular, we could compile the project like this:</p>
<pre><code>my_app -&gt; depends_on_data_schema -&gt; data_schema
  r1                r1                 r1-r2</code></pre>
<p>
Or like this:</p>
<pre><code>my_app -&gt; depends_on_data_schema -&gt; data_schema
  r1              r1-r2                r1-r2</code></pre>
<p>
But not like this:</p>
<pre><code>my_app -&gt; depends_on_data_schema -&gt; data_schema
  r2                r1                 r1-r2</code></pre>
<p>
This would enable us to upgrade dependencies piecemeal. In fact, <code>my_app</code> could even talk to two different libraries, which do not depend on each other, one depending on r1 and another depending on r2, and the type checker can still validate their boundaries are respected.</p>
<p>
We could even downcast from r2 to r1. For example, we could mimic the choice done by the Rust library, downcast <code>r2</code> to a <code>r1</code> by setting the field to an empty string:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="1851148254-1">(</span><span data-group-id="1851148254-1">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="1851148254-2">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="1851148254-3">(</span><span data-group-id="1851148254-3">)</span><span data-group-id="1851148254-2">)</span><span>
</span><span>def</span><span> </span><span>from_r2_to_r1</span><span data-group-id="1851148254-4">(</span><span data-group-id="1851148254-5">%{</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="1851148254-5">}</span><span data-group-id="1851148254-4">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span data-group-id="1851148254-6">%{</span><span>schema</span><span> </span><span>|</span><span> </span><span>name</span><span>:</span><span> </span><span>&#34;&#34;</span><span data-group-id="1851148254-6">}</span><span>
</span><span>def</span><span> </span><span>from_r2_to_r1</span><span data-group-id="1851148254-7">(</span><span data-group-id="1851148254-8">%{</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="1851148254-8">}</span><span> </span><span>=</span><span> </span><span>schema</span><span data-group-id="1851148254-7">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>schema</span></code></pre>
<p>
Alternatively, if you’d rather downcast r2 to r1 while assuming that <code>name</code> can never be nil, failing at runtime otherwise (equivalent to an <code>unwrap</code>), you might write:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6139283513-1">(</span><span data-group-id="6139283513-1">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6139283513-2">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="6139283513-3">(</span><span data-group-id="6139283513-3">)</span><span data-group-id="6139283513-2">)</span><span>
</span><span>def</span><span> </span><span>from_r2_to_r1</span><span data-group-id="6139283513-4">(</span><span data-group-id="6139283513-5">%{</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="6139283513-5">}</span><span data-group-id="6139283513-4">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>raise</span><span> </span><span>&#34;not allowed&#34;</span><span>
</span><span>def</span><span> </span><span>from_r2_to_r1</span><span data-group-id="6139283513-6">(</span><span data-group-id="6139283513-7">%{</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="6139283513-7">}</span><span> </span><span>=</span><span> </span><span>schema</span><span data-group-id="6139283513-6">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>schema</span></code></pre>
<p>
The signature says we will preserve all fields of the given schema, except that <code>name</code> is overridden to always have type <code>string()</code>.</p>
<p>
Would downcasting actually be useful in practice? That is yet to be seen.</p>
<h2>
A pinch of formalization</h2>
<p>
We have learned so far that, by revisioning our schema evolution and guaranteeing that each revision is a supertype, the compiler and type system will work together to guarantee that our code works across several revisions. How does that work behind the scenes?</p>
<blockquote>
  <p>
This section is for those who are type curious and it is not required reading. Actually, most of this blog post is probably not required for those who’d want to simply <em>use</em> this feature in the future.  </p>
</blockquote>
<p>
When the compiler sees <code>Schema.t()</code> inside a type signature, it will add a new intersection (i.e. a new arrow) for each revision that we have. Each new clause will have:</p>
<ul>
  <li>
the domain set to the current revision excepted by the domain of the previous revisions  </li>
  <li>
the codomain set to the current revision unioned by the codomain of the previous revisions  </li>
</ul>
<p>
Simply put, if a schema has three versions r1, r2, r3, the type signatures will be:</p>
<pre><code><span>$</span><span> </span><span>domain_r1</span><span> </span><span>-&gt;</span><span> </span><span>codomain_r1</span><span>
</span><span>$</span><span> </span><span>domain_r2</span><span> </span><span>and</span><span> </span><span>not</span><span> </span><span>domain_r1</span><span> </span><span>-&gt;</span><span> </span><span>codomain_r1</span><span> </span><span>or</span><span> </span><span>codomain_r2</span><span>
</span><span>$</span><span> </span><span>domain_r3</span><span> </span><span>and</span><span> </span><span>not</span><span> </span><span>domain_r2</span><span> </span><span>and</span><span> </span><span>not</span><span> </span><span>domain_r1</span><span> </span><span>-&gt;</span><span> </span><span>codomain_r1</span><span> </span><span>or</span><span> </span><span>codomain_r2</span><span> </span><span>or</span><span> </span><span>codomain_r3</span></code></pre>
<p>
Where <code>domain_r1</code> is the domain of the type signature with all instances of <code>Schema.t</code> replaced by r1 and so forth.</p>
<p>
While this may sound complicated at first, they all boil down to standard set operations. Let’s see some examples.</p>
<p>
Take our <code>Schema</code> with <code>r1 = Schema.t(name: string())</code> and <code>r2 = Schema.t(name: string() or nil)</code>. The function signature <code>$ Schema.t() -&gt; Schema.t()</code> will become:</p>
<pre><code><span># domain_r1 -&gt; codomain_r1</span><span>
</span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="0357738258-1">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="0357738258-2">(</span><span data-group-id="0357738258-2">)</span><span data-group-id="0357738258-1">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="0357738258-3">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="0357738258-4">(</span><span data-group-id="0357738258-4">)</span><span data-group-id="0357738258-3">)</span><span>

</span><span># domain_r2 and not domain_r1 -&gt; codomain_r1 or codomain_r2</span><span>
</span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="0357738258-5">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="0357738258-6">(</span><span data-group-id="0357738258-6">)</span><span> </span><span>or</span><span> </span><span>nil</span><span data-group-id="0357738258-5">)</span><span> </span><span>and</span><span> </span><span>not</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="0357738258-7">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="0357738258-8">(</span><span data-group-id="0357738258-8">)</span><span data-group-id="0357738258-7">)</span><span> </span><span>-&gt;</span><span>
    </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="0357738258-9">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="0357738258-10">(</span><span data-group-id="0357738258-10">)</span><span> </span><span>or</span><span> </span><span>nil</span><span data-group-id="0357738258-9">)</span><span> </span><span>or</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="0357738258-11">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="0357738258-12">(</span><span data-group-id="0357738258-12">)</span><span data-group-id="0357738258-11">)</span></code></pre>
<p>
That’s quite verbose but luckily that’s not what users will see in practice. Since <code>r2</code> is a supertype of <code>r1</code>, the type system will simplify many of these operations.</p>
<p>
The first arrow is already in its simplest form. In the second one, <code>Schema.t(name: string() or nil) and not Schema.t(name: string())</code> is equivalent to <code>Schema.t(name: nil)</code> (all schemas with names <code>string() or nil</code> except the ones with names <code>string()</code> results in only schemas with <code>nil</code> names). Furthermore, <code>Schema.t(name: string() or nil) or Schema.t(name: string())</code> is the same as <code>Schema.t(name: string() or nil)</code>. After applying these simplications and eliding fields with their default types, we end-up with what we originally wrote:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6312192430-1">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="6312192430-2">(</span><span data-group-id="6312192430-2">)</span><span data-group-id="6312192430-1">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6312192430-3">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="6312192430-4">(</span><span data-group-id="6312192430-4">)</span><span data-group-id="6312192430-3">)</span><span>
</span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6312192430-5">(</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="6312192430-5">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="6312192430-6">(</span><span data-group-id="6312192430-6">)</span></code></pre>
<h4>
What about contravariance?</h4>
<p>
One question people may ask this point is: what about contravariance? What if we have a high-order function that receives a schema and returns a function that receives another schema and returns yet another schema?</p>
<p>
It would have this type signature:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="4251335511-1">(</span><span data-group-id="4251335511-1">)</span><span> </span><span>-&gt;</span><span> </span><span data-group-id="4251335511-2">(</span><span>Schema</span><span>.</span><span>t</span><span data-group-id="4251335511-3">(</span><span data-group-id="4251335511-3">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="4251335511-4">(</span><span data-group-id="4251335511-4">)</span><span data-group-id="4251335511-2">)</span></code></pre>
<p>
By applying the domain and codomain rules above, we will have the following two arrows, where <code>r1</code> and <code>r2</code> represents their respective schema versions:</p>
<pre><code><span>$</span><span> </span><span>r1</span><span> </span><span>-&gt;</span><span> </span><span data-group-id="3403679938-1">(</span><span>r1</span><span> </span><span>-&gt;</span><span> </span><span>r1</span><span data-group-id="3403679938-1">)</span><span>
</span><span>$</span><span> </span><span>r2</span><span> </span><span>and</span><span> </span><span>not</span><span> </span><span>r1</span><span> </span><span>-&gt;</span><span> </span><span data-group-id="3403679938-2">(</span><span>r2</span><span> </span><span>-&gt;</span><span> </span><span>r2</span><span data-group-id="3403679938-2">)</span><span> </span><span>or</span><span> </span><span data-group-id="3403679938-3">(</span><span>r1</span><span> </span><span>-&gt;</span><span> </span><span>r1</span><span data-group-id="3403679938-3">)</span></code></pre>
<p>
The first arrow is, as always, already in its simplified form. What about the second?</p>
<p>
Once again we found <code>r2 and not r1</code>, which we know to be <code>Schema.t(name: nil)</code>. That simplifies the domain of the second arrow. What about its codomain?</p>
<p>
When we have a union of arrows, because Elixir does not allow checking the types a function expects at runtime, the only valid application of <code>(a -&gt; a) or (b -&gt; b)</code> is an argument that satifies both <code>a</code> and <code>b</code>, therefore, we need to compute the intersection between their domain (aka inputs) and then return the union of the codomain (aka outputs). In this case, we have <code>(r2 -&gt; r2) or (r1 -&gt; r1)</code>, so the intersection of the inputs will be the smallest type, <code>r1</code>, and the union will be biggest one, <code>r2</code>, which leaves us with <code>(r1 -&gt; r2)</code>. This is a less precise type than the original one, but one that mirrors Elixir semantics.</p>
<p>
By replacing <code>r1 and r2</code> by their respective schemas, the final signature would be:</p>
<pre><code><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="3554448306-1">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="3554448306-2">(</span><span data-group-id="3554448306-2">)</span><span data-group-id="3554448306-1">)</span><span> </span><span>-&gt;</span><span>
    </span><span data-group-id="3554448306-3">(</span><span>Schema</span><span>.</span><span>t</span><span data-group-id="3554448306-4">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="3554448306-5">(</span><span data-group-id="3554448306-5">)</span><span data-group-id="3554448306-4">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="3554448306-6">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="3554448306-7">(</span><span data-group-id="3554448306-7">)</span><span data-group-id="3554448306-6">)</span><span data-group-id="3554448306-3">)</span><span>

</span><span>$</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="3554448306-8">(</span><span>name</span><span>:</span><span> </span><span>nil</span><span data-group-id="3554448306-8">)</span><span> </span><span>-&gt;</span><span>
    </span><span data-group-id="3554448306-9">(</span><span>Schema</span><span>.</span><span>t</span><span data-group-id="3554448306-10">(</span><span>name</span><span>:</span><span> </span><span>string</span><span data-group-id="3554448306-11">(</span><span data-group-id="3554448306-11">)</span><span data-group-id="3554448306-10">)</span><span> </span><span>-&gt;</span><span> </span><span>Schema</span><span>.</span><span>t</span><span data-group-id="3554448306-12">(</span><span data-group-id="3554448306-12">)</span><span data-group-id="3554448306-9">)</span></code></pre>
<p>
There is something deeply elegant about the definition the type system produced here because it gives us the safest definition possible: the returned function only accepts schemas in r1 (i.e. it is strict on its input) and returns the broadest schema possible (i.e. it is broad on its output). These definitions were derived automatically and they are the semantics that your code will be typechecked against to guarantee the revision preservation property.</p>
<h2>
Data evolution</h2>
<p>
There is one last topic to discuss: which changes are possible to our struct definitions when using revisions?</p>
<p>
Since we require new revisions to be a supertype of previous ones, the operations we can perform are:</p>
<ul>
  <li>
    <p>
Making a field wider than before (a supertype).    </p>
  </li>
  <li>
    <p>
Adding a new field with a default value.    </p>
  </li>
  <li>
    <p>
Marking a field as deprecated (as it may be removed in a future breaking version). Deprecated fields are marked as optional, allowing new code to avoid instatiating them altogether, while retaining compatibility with old one.    </p>
  </li>
</ul>
<blockquote>
  <p>
While adding a new field makes a revision a subtype of the previous one, if the field has a default value, we can consider that previous revisions actually had the field with an optional type. Therefore, the revision that effectively adds the field is equivalent to making it a required one, which is a supertype.  </p>
</blockquote>
<p>
And the compiler can actually guarantee revisions follow these rules. Any other change (removing fields, changing it to a subtype or a disjoint type, etc) will be a breaking change. Although this looks limiting, all Elixir libraries (and of other programming languages) that desire to remain backwards compatible are already under such constraints today. Revisions should effectively improve the status quo by <strong>making data evolution progressive and type safe</strong>. This is important for the Elixir ecosystem, where the language and major frameworks, such as Phoenix, have remained backwards compatible for more than a decade.</p>
<h2>
Summing up</h2>
<p>
I hope this article introduces the problem of data versioning present in many languages and outlines one possible solution. Overall, there are challenges ahead, including formalizing and prooving the safety of the ideas outlined above, as well as asking ourselves how much of what was outlined here is practical.</p>
<p>
The goal of data versioning is to provide more mechanisms for <strong>library authors</strong> to evolve their schemas without imposing breaking changes often. Application developers will have limited use of this feature, as they would rather update their existing codebases and their types right away. Although this may find use cases around durable data and distributed systems.</p>
<p>
From the theoretical point of view, the only capabilities necessary to make this work is structural subtyping, with unions, intersections, and negations, all available out of the box in Elixir’s set-theoretic type system. The struct versioning itself, aka revisions, can be fully tackled by the compiler, which makes the implementation quite more accessible. The job of the type system is simply to provide a foundation to make this possible!</p>
<p>
A massive thank you to Giuseppe Castagna, Guillaume Duboc, and Xuejing Huang for suggestions and the initial formalization of the solution. I am also grateful to Richard Feldman, Leandro Ostera, and Louis Pilfold for feedback on drafts. All opinions and innacuracies are my own.</p>

  </article>
</div></div>
  </body>
</html>
