<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/phoenix-files/elixir-and-rust-is-a-good-mix/">Original</a>
    <h1>Elixir and Rust is a good mix</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/jason.webp" alt="Jason Stiebs" srcset=""/> <dl> <dt>Name</dt> <dd> Jason Stiebs </dd> <dt>Social Media</dt> <dd> <a href="https://twitter.com/peregrine" target="_blank" rel="noopener noreferrer"> <span aria-hidden="true">@peregrine</span> <span>View Twitter Profile</span> </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/phoenix-files/2023-04-11/elixir-rust-cover.webp" alt="An purple droplet representing Elixir and a red crab, Ferris, representing Rust."/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p> This post is about using Rust with Elixir and how easily it can be done! If you want to deploy your Phoenix LiveView app right now, then check out how to <a href="https://fly.io/docs/elixir/">get started</a>. You could be up and running in minutes.</p><h2 id="problem"><a href="#problem" aria-label="Anchor"></a>Problem</h2><p>We need to perform a CPU intensive or system level programming task and there are just no good solutions in <a href="https://hex.pm">hex.pm</a>, in this example let&#39;s pretend there <a href="https://fly.io/phoenix-files/resizing-images-using-elixir/">are no good ways to do image</a> processing with Elixir.</p> <p>As is often the case, there IS a high quality <a href="https://www.rust-lang.org/">Rust</a> library called <a href="https://github.com/image-rs/image">image</a> that claims to be just the solution! But shoot, our entire application is written in Elixir already, and we really don&#39;t know how to use <a href="https://www.rust-lang.org/">Rust</a> that well.</p> <p>How can Elixir turn to Rust code for high-performance operations?</p> <h2 id="solution"><a href="#solution" aria-label="Anchor"></a>Solution</h2><p>Enter <a href="https://github.com/rusterlium/rustler">rustler</a>, this library is designed to make using Rust and its package ecosystem trivial. Let&#39;s dive in!</p> <p>Following the getting started guide, first add <a href="https://hex.pm/packages/rustler">rustler</a> to our <code>mix.exs</code> file:</p> <p>Once we run <code>mix deps.get</code> use the built-in mix task to generate our empty rust project:</p> <div><pre><code>This is the name of the Elixir module the NIF module will be registered to.
Module name &gt; MyApp.RustImage
This is the name used for the generated Rust crate. The default is most likely fine.
Library name (myapp_rustimage) &gt; rust_image
* creating native/rust_image/.cargo/config.toml
* creating native/rust_image/README.md
* creating native/rust_image/Cargo.toml
* creating native/rust_image/src/lib.rs
* creating native/rust_image/.gitignore
Ready to go! See /Users/me/projects/my_app/native/rust_image/README.md for further instructions.
</code></pre></div><p>You should go open up that <code>README.md</code>, but I&#39;ll save you the hassle, we need to make an Elixir module in <code>lib/my_app/rust_image.ex</code> that has the following contents:</p> <div><pre><code><span>defmodule</span> <span>MyApp</span><span>.</span><span>RustImage</span> <span>do</span>
  <span>use</span> <span>Rustler</span><span>,</span> <span>otp_app:</span> <span>:my_app</span><span>,</span> <span>crate:</span> <span>&#34;rust_image&#34;</span>

  <span># When your NIF is loaded, it will override this function.</span>
  <span>def</span> <span>add</span><span>(</span><span>_a</span><span>,</span> <span>_b</span><span>),</span> <span>do</span><span>:</span> <span>:erlang</span><span>.</span><span>nif_error</span><span>(</span><span>:nif_not_loaded</span><span>)</span>
<span>end</span>
</code></pre></div><p>And from then on out we&#39;re ready to do some Rust. The default generator gives us an <code>add/2</code> function implemented in <code>native/rust_image/src/lib.rs</code> let&#39;s take a look</p> <div><pre><code><span>#[rustler::nif]</span>
<span>fn</span> <span>add</span><span>(</span><span>a</span><span>:</span> <span>i64</span><span>,</span> <span>b</span><span>:</span> <span>i64</span><span>)</span> <span>-&gt;</span> <span>i64</span> <span>{</span>
    <span>a</span> <span>+</span> <span>b</span>
<span>}</span>

<span>rustler</span><span>::</span><span>init!</span><span>(</span><span>&#34;Elixir.MyApp.RustImage&#34;</span><span>,</span> <span>[</span><span>add</span><span>]);</span>
</code></pre></div><div> <h4 id="what-is-a-nif"><a href="#what-is-a-nif" aria-label="Anchor"></a>What Is a NIF?</h4><p>Native Implemented Functions are the BEAM&#39;s method of allowing processes to directly call native functions. They normally have a <em>ton</em> of boilerplate and you need to be serious about cleaning up your memory, handling errors and being safe. Luckily that&#39;s Rust&#39;s entire thing! For example here is the <a href="https://www.erlang.org/doc/tutorial/nif.html">Erlang NIF tutorial</a>. We didn&#39;t need to do any of that!</p> </div><p>Our hyper optimized code will add two integers of size i64 and return the result. Note the Rustler specific parts here:</p> <ul> <li><code>#[rustler::nif]</code> is a macro that tells Rustler to expose this function as a NIF. </li><li><code>rustler::init!(&#34;Elixir.MyApp.RustImage&#34;, [add]);</code> This initializes the Erlang NIF runtime so that the beam can put the <code>add/2</code> function on the <code>Elixir.MyApp.RustImage</code> module and replace the stub we left. </li></ul> <p>This is <em>amazing</em>. To see if this works, lets fire up <code>iex -S mix</code></p> <div><pre><code>iex(1)&gt; MyApp.RustImage.add(100, 20)
120
</code></pre></div><p>If everything worked the first time, you should have seen cargo building the app in release mode and succeeding before opening the iex term. If you didn&#39;t already have Rust installed it would have shown an error, you can install Rust the <a href="https://rustup.rs/">usual way</a>.</p> <p>Rustler is even smart and will recompile automatically, leave iex open and change our <code>lib.rs</code></p> <div><pre><code><span>#[rustler::nif]</span>
<span>fn</span> <span>add</span><span>(</span><span>a</span><span>:</span> <span>i64</span><span>,</span> <span>b</span><span>:</span> <span>i64</span><span>)</span> <span>-&gt;</span> <span>i64</span> <span>{</span>
    <span>a</span> <span>+</span> <span>b</span> <span>+</span> <span>1</span>
<span>}</span>
</code></pre></div><p>Save and then open that running iex session again:</p> <div><pre><code><span>iex</span><span>(</span><span>2</span><span>)</span><span>&gt;</span> <span>r</span><span>(</span><span>MyApp</span><span>.</span><span>RustImage</span><span>)</span>
<span>...</span> <span>truncated</span> <span>output</span> <span>of</span> <span>cargo</span> <span>doing</span> <span>it</span><span>&#39;s thing an maybe some beam warnings
{:reloaded, [MyApp.RustImage]}
iex(3)&gt; MyApp.RustImage.add(1,1)
3
</span></code></pre></div><p>Incredible! We get the same workflow and nice bits of working with Elixir, with minimal fussing about with Rust.</p> <h3 id="images"><a href="#images" aria-label="Anchor"></a>Images</h3><p>First add our image dependency to our <code>Cargo.toml</code> file:</p> <div><pre><code><span>[dependencies]</span>
<span>rustler</span> <span>=</span> <span>&#34;0.27.0&#34;</span>
<span>image</span> <span>=</span> <span>&#34;0.24.6&#34;</span>
</code></pre></div><p>Then alter our <code>lib.rs</code> to create a function that accepts an <code>input</code> path, an <code>output</code> path and <code>quality</code> and changes any image to a JPEG with our set quality.</p> <div><pre><code><span>use</span> <span>image</span><span>::</span><span>io</span><span>::</span><span>Reader</span> <span>as</span> <span>ImageReader</span><span>;</span>
<span>use</span> <span>image</span><span>::</span><span>codecs</span><span>::</span><span>jpeg</span><span>::</span><span>JpegEncoder</span><span>;</span>
<span>use</span> <span>std</span><span>::</span><span>fs</span><span>::</span><span>File</span><span>;</span>

<span>#[rustler::nif]</span>
<span>fn</span> <span>jpg</span><span>(</span><span>input</span><span>:</span> <span>String</span><span>,</span> <span>output</span><span>:</span> <span>String</span><span>,</span> <span>quality</span><span>:</span> <span>i64</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>img</span> <span>=</span> <span>ImageReader</span><span>::</span><span>open</span><span>(</span><span>&amp;</span><span>input</span><span>)</span><span>.unwrap</span><span>()</span><span>.decode</span><span>()</span><span>.unwrap</span><span>();</span>
    <span>let</span> <span>out_file</span> <span>=</span> <span>std</span><span>::</span><span>fs</span><span>::</span><span>File</span><span>::</span><span>create</span><span>(</span><span>&amp;</span><span>output</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>let</span> <span>mut</span> <span>jpg</span> <span>=</span> <span>JpegEncoder</span><span>::</span><span>new_with_quality</span><span>(</span><span>&amp;</span><span>out_file</span><span>,</span> <span>quality</span> <span>as</span> <span>u8</span><span>);</span>

    <span>jpg</span><span>.encode_image</span><span>(</span><span>&amp;</span><span>img</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>Ok</span><span>(</span><span>output</span><span>.to_string</span><span>())</span>
<span>}</span>

<span>// add code...</span>

<span>rustler</span><span>::</span><span>init!</span><span>(</span><span>&#34;Elixir.MyApp.RustImage&#34;</span><span>,</span> <span>[</span><span>add</span><span>,</span> <span>jpg</span><span>]);</span>
</code></pre></div><p>We also want to update our RustImage module to include a stub for <code>jpg/3</code>, but that&#39;s left as an exercise to the reader.</p> <p>Now let&#39;s try it out! <code>iex -S mix</code></p> <div><pre><code>iex(1)&gt; MyApp.RustImage.jpg(&#34;input.png&#34;, &#34;output.jpeg&#34;, 75)
{:ok, &#34;output.jpeg&#34;}
</code></pre></div><p>And boom! We&#39;ve converted a PNG to a JPEG with 75% quality.</p> <h2 id="being-a-good-beam-citizen"><a href="#being-a-good-beam-citizen" aria-label="Anchor"></a>Being a Good BEAM Citizen</h2><p>There is one more thing we should consider here, and that&#39;s CPU load. While this function likely runs near instantly on our laptop, when deployed it might take longer on shared CPU/RAM.</p> <p>And because the BEAM runs our code directly, and it will lock an the runtime until it has completed running. What we mean by directly is that when using a NIF the beam will treat it like any other code, with the major caveat that it can&#39;t prempt the Rust code automatically.</p> <p>On the BEAM this is a big issue since the entire runtime expects to be able to switch contexts between millions of processes at any time.</p> <p>Luckily the Rustler and BEAM teams have thought of this and given us a solution. Simply change that macro on top of <code>jpeg</code> to this</p> <div><pre><code><span>-- #[rustler::nif]
</span><span>++ #[rustler::nif(schedule = &#34;DirtyCpu&#34;)]
</span></code></pre></div><p>This tells the Rustler and BEAM to automagically schedule this in a way that won&#39;t block the entire world while it works. Again <em>amazing</em>, this is called a <a href="https://www.erlang.org/doc/man/erl_nif.html">DirtyNif</a> and is way more difficult to work with when you are manually using this via C.</p> <h2 id="deployment"><a href="#deployment" aria-label="Anchor"></a>Deployment</h2><p>Deploying this to Fly.io with Docker isn&#39;t as automagic, we need to make some small changes so that our Docker environment can build Rust. First, update the Dockerfile by adding a build step right before our Elixir build step:</p> <div><pre><code><span>#... ARG stuff..</span>
<span>FROM</span><span> </span><span>rust:1.68.0</span><span> </span><span>as</span><span> </span><span>rust</span>
<span># install build dependencies</span>
<span>RUN </span>apt-get update <span>-y</span> <span>&amp;&amp;</span> apt-get <span>install</span> <span>-y</span> build-essential git <span>\
</span>    <span>&amp;&amp;</span> apt-get clean <span>&amp;&amp;</span> <span>rm</span> <span>-f</span> /var/lib/apt/lists/<span>*</span>_<span>*</span>

<span>workdir</span><span> /app</span>
<span>COPY</span><span> native/rust_images ./</span>
<span>RUN </span>cargo rustc <span>--release</span> 

<span>#..Elixir builder.....</span>
<span># compile assets</span>
<span>RUN </span>mix assets.deploy

<span>#NEW STUFF</span>
<span>COPY</span><span> --from=rust /app/target/release/librust_images.so priv/native/librust_images.so</span>
<span>#/NEW</span>
<span># Compile the release</span>
<span>RUN </span>mix compile
</code></pre></div><p>Then update our <code>config/prod.exs</code> adding the following line:</p> <div><pre><code><span>config</span> <span>:my_app</span><span>,</span> <span>MyApp</span><span>.</span><span>RustImage</span><span>,</span>
  <span>crate:</span> <span>:rust_image</span><span>,</span>
  <span>skip_compilation?:</span> <span>true</span><span>,</span>
  <span>load_from:</span> <span>{</span><span>:my_app</span><span>,</span> <span>&#34;priv/native/librust_image&#34;</span><span>}</span>
</code></pre></div><p>What we did here is build the library in its own Docker builder context, so it runs in parallel with the rest of our Docker steps and can be cache&#39;d easily. Then we told Rustler to skip compiling and to load it directly from our where we put it.</p> <p>And we&#39;re all set, simply <code>fly deploy</code> and you&#39;re off!</p> <h2 id="discussion"><a href="#discussion" aria-label="Anchor"></a>Discussion</h2><p>We have only really scratched the surface about what is possible using the power of NIFs and Rust together. From <a href="https://github.com/elixir-nx/explorer">loading massive datasets to do science</a> to connecting via <a href="https://github.com/livinginthepast/specter">WebRTC</a>, the Rust community has built out an impressive suite of packages and tools that are also now available to us. And Rustler makes it possible!</p> <figure> <figcaption> <p> Fly.io is a great way to run your Phoenix LiveView app close to your users. It&#39;s really easy to get started. You can be running in minutes.</p><p><a href="https://fly.io/docs/elixir/"> Deploy a Phoenix app today!  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/static/images/cta-rabbit.webp" srcset="/static/images/cta-rabbit@2x.webp 2x" alt=""/></p></figure>  </section> <dl> <dt> Next post  ↑ </dt> <dd> <a href="https://fly.io/phoenix-files/phoenix-liveview-zipped-uploads/"> Phoenix LiveView Zipped Uploads </a> </dd> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/phoenix-files/can-phoenix-safely-use-the-zip-module/"> Can Phoenix Safely use the Zip Module? </a> </dd> </dl> </article></div>
  </body>
</html>
