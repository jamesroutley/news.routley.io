<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.redblobgames.com/grids/hexagons/">Original</a>
    <h1>Hexagonal Grids (2013)</h1>
    
    <div id="readability-page-1" class="page"><div><!-- Adapting the layout to wide vs narrow:

     Make a div.float-container to surround areas that should be wider.
     a. Any children inside this will be in the left column.
     b. Except if it's .float-right then it will be in the right column.
     
     For example layout A {diagram} B, the narrow version will be

         AAAAAAA
         diagram
         diagram
         BBBBBBB

     and the wide version will be

         AAAAAAA  diagram
         BBBBBBB  diagram
                  
  --><address>Mar 2013, updated in Mar 2015, Apr 2018, Feb 2019, May 2020, Oct 2021</address><section><br/></section><section><h2 id="basics"><span><a href="#basics">Geometry</a></span><a href="#basics">#</a></h2><template id="diagram-sizes"></template><h3 id="spacing"><span>Spacing</span><a aria-hidden="true" href="#spacing">#</a></h3><template id="diagram-spacing"></template><h3 id="angles"><span>Angles</span><a aria-hidden="true" href="#angles">#</a></h3><template id="diagram-angles"></template></section><section><h2 id="coordinates"><span><a href="#coordinates">Coordinate Systems</a></span><a href="#coordinates">#</a></h2><p>Now let&#39;s assemble hexagons into a grid. With square grids, there&#39;s one obvious way to do it. With hexagons, there are multiple approaches. I like cube coordinates for algorithms and axial or doubled for storage.</p><h3 id="coordinates-offset"><span>Offset coordinates</span><a aria-hidden="true" href="#coordinates-offset">#</a></h3><p>The most common approach is to offset every other column or row. Columns are named <code>col</code> (<code>q</code>). Rows are named <code>row</code> (<code>r</code>). You can either offset the odd or the even column/rows, so the horizontal and vertical hexagons each have two variants.</p><h3 id="coordinates-cube"><span>Cube coordinates</span><a aria-hidden="true" href="#coordinates-cube">#</a></h3><div><div><p>Another way to look at hexagonal grids is to see that there are <em>three</em> primary axes, unlike the <em>two</em> we have for square grids. There&#39;s an elegant symmetry with these.</p><p>Let&#39;s take a cube grid and <strong>slice</strong> out a diagonal plane at <code><span>x</span> + <span>y</span> + <span>z</span> = 0</code>. This is a <em>weird</em> idea but it helps us with hex grid algorithms:</p><ol><li>3d cartesian coordinates follow standard vector operations: we can add/subtract coordinates, multiply/divide by a scalar, etc. We can reuse these operations with hexagonal grids. Offset coordinates do not support these operations.</li><li>3d cartesian coordinates have existing algorithms like distances, rotation, reflection, line drawing, conversion to/from screen coordinates, etc. We can adapt these algorithms to work on hexagonal grids.</li></ol></div><template id="diagram-cube-to-hex"></template></div><template id="diagram-grid-cube"></template><div><div><h3 id="coordinates-axial"><span>Axial coordinates</span><a aria-hidden="true" href="#coordinates-axial">#</a></h3><p>The axial coordinate system, sometimes called “trapezoidal” or “oblique” or “skewed”, is <strong>the same as the cube system</strong> except we don&#39;t store the <span>s</span> coordinate. Since we have a constraint <code><span>q</span> + <span>r</span> + <span>s</span> = 0</code>, we can calculate <code><span>s</span> = -<span>q</span>-<span>r</span></code> when we need it.</p></div><template id="diagram-grid-axial"></template><p>The axial/cube system allows us to add, subtract, multiply, and divide with hex coordinates. The offset coordinate systems do not allow this, and that&#39;s part of what makes algorithms simpler with axial/cube coordinates.</p></div><h3 id="coordinates-doubled"><span>Doubled coordinates</span><a aria-hidden="true" href="#coordinates-doubled">#</a></h3><div><p>Although I recommend axial/cube coordinates, if you are sticking to offset coordinates, consider the doubled variant. It makes many of the algorithms easier to implement. Instead of alternation, the doubled coordinates <em>double</em> either the horizontal or vertical step size. It has a constraint <code>(<span>col</span> + <span>row</span>) % 2 == 0</code>. In the horizontal (pointy top hex) layout it increases the column by 2 each hex; in the vertical (flat top hex) layout it increases the row by 2 each hex. This allows the in-between values for the hexes that are halfway in between:</p><p>I haven&#39;t found much information about this system — tri-bit.com called it <a href="http://web.archive.org/web/20090205120106/http://sc.tri-bit.com/Hex_Grids">interlaced</a><sup>[4]</sup>, rot.js calls it <a href="http://ondras.github.io/rot.js/manual/#hex/indexing">double width</a><sup>[5]</sup>, and <a href="https://www.researchgate.net/publication/235779843_Storage_and_addressing_scheme_for_practical_hexagonal_image_processing?_sg=flKEA6rk1KmOpC4LBjQJN_-NBuiR1KJtJt-XeYRXnd0z_MNUrB2gjb2FKV3iBoKg988P2xHCpQ">this paper</a><sup>[6]</sup> calls it rectangular. Other possible names: brick or checkerboard. I&#39;m not sure what to call it. Tamás Kenéz sent me the core algorithms (neighbors, distances, etc.). If you have any references, please send them to me.</p></div><h3 id="coordinates-other"><span>Others</span><a aria-hidden="true" href="#coordinates-other">#</a></h3><p>In <a href="https://www.redblobgames.com/grids/hexagons-v2/">previous versions of this document</a>, I used <span>x</span> <span>z</span> <span>y</span> for hexagonal coordinates and <em>also</em> for cartesian coordinates, and then I also used <span>q</span> <span>r</span> <span>s</span> for hexagonal coordinates. To avoid confusion in this document, I&#39;ll use the names <span>q</span> <span>r</span> <span>s</span> for hexagonal coordinates (with the constraint <code><span>q</span> + <span>r</span> + <span>s</span> = 0</code>), and I&#39;ll use the names x y z for cartesian coordinates.</p><p>There are <em>many</em> different valid cube hex coordinate systems. Some of them have constraints other than <code><span>q</span> + <span>r</span> + <span>s</span> = 0</code>. I&#39;ve shown only one of the many systems. There are also <em>many</em> different valid axial hex coordinate systems, found by using reflections and rotations. Some have the 120° axis separation as shown here and some have a 60° axis separation.</p><p>There are also cube systems that use <code>q-r, r-s, s-q</code>. One of the interesting properties of that system is that it reveals <a href="https://www.redblobgames.com/grids/hexagons/directions.html">hexagonal directions</a>.</p><p>There are spiral coordinate systems I haven&#39;t explored. See <a href="https://gamedev.stackexchange.com/questions/71785/converting-between-spiral-honeycomb-mosaic-and-axial-hex-coordinates">this question</a><sup>[7]</sup> or <a href="https://tex.stackexchange.com/questions/275490/is-there-an-easy-way-to-number-a-hexagonal-spiral">this question</a><sup>[8]</sup> on stackoverflow, or this <a href="https://opus.lib.uts.edu.au/bitstream/2100/280/11/02Whole.pdf">paper about machine vision</a><sup>[9]</sup>, or this <a href="https://web.archive.org/web/20120303114550/http://www.pyxisinnovation.com/pyxwiki/index.php?title=Generalized_Balanced_Ternary">diagram about &#34;generalized balanced ternary&#34; coordinates</a><sup>[10]</sup>, or this <a href="https://www.sciencedirect.com/science/article/pii/0166218X9200186P">math paper</a><sup>[11]</sup>, or this <a href="https://old.reddit.com/r/gamedev/comments/19wmvn/a_data_structure_for_a_game_board_with_hexagonal/c8s9qbe">discussion on reddit</a><sup>[12]</sup>. They seem potentially useful for fixed sized hexagonal shaped maps.</p><h3 id="coordinates-comparison"><span>Recommendations</span><a aria-hidden="true" href="#coordinates-comparison">#</a></h3><p>What do I recommend?</p><table><thead><tr><th></th><th>Offset</th><th>Doubled</th><th>Axial</th><th>Cube</th></tr></thead><tbody><tr><th>Pointy rotation</th><td>evenr, oddr</td><td>doublewidth</td><td rowspan="2">axial</td><td rowspan="2">cube</td></tr><tr><th>Flat rotation</th><td>evenq, oddq</td><td>doubleheight</td></tr><tr><th>Other rotations</th><td colspan="2">no</td><td colspan="2">yes</td></tr><tr><th>Vector operations (add, subtract, scale)</th><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><th>Array storage</th><td>rectangular</td><td>no<sup>*</sup></td><td>rhombus<sup>*</sup></td><td>no<sup>*</sup></td></tr><tr><th>Hash storage</th><td colspan="2">any shape</td><td colspan="2">any shape</td></tr><tr><th>Hexagonal symmetry</th><td>no</td><td>no</td><td>no</td><td>yes</td></tr><tr><th>Easy algorithms</th><td>few</td><td>some</td><td>most</td><td>most</td></tr></tbody></table><p><sup>*</sup> rectangular maps require an adapter, shown in the <a href="#map-storage">map storage section</a></p><p>My recommendation: if you are only going to use non-rotated rectangular maps, consider the doubled or offset system that matches your map orientation. For maps with rotation, or non-rectangularly shaped maps, use axial/cube. Either choose to store the <code>s</code> coordinate (cube), or calculate it when needed as <code>-<span>q</span>-<span>r</span></code> (axial).</p></section><section><h2 id="conversions"><span><a href="#conversions">Coordinate conversion</a></span><a href="#conversions">#</a></h2><p>It is likely that you will use axial or offset coordinates in your project, but many algorithms are simpler to express in axial/cube coordinates. Therefore you need to be able to convert back and forth.</p><h3 id="conversions-axial"><span>Axial coordinates</span><a aria-hidden="true" href="#conversions-axial">#</a></h3><template id="diagram-conversions-axial"></template><h3 id="conversions-offset"><span>Offset coordinates</span><a aria-hidden="true" href="#conversions-offset">#</a></h3><template id="diagram-conversions-offset"></template><h3 id="conversions-doubled"><span>Doubled coordinates</span><a aria-hidden="true" href="#conversions-doubled">#</a></h3><pre>function doubleheight_to_axial(hex):
    var q = hex.col
    var r = (hex.row - hex.col) / 2
    return Hex(q, r)

function axial_to_doubleheight(hex):
    var col = hex.q
    var row = 2 * hex.r + hex.q
    return DoubledCoord(col, row)

function doublewidth_to_axial(hex):
    var q = (hex.col - hex.row) / 2
    var r = hex.row
    return Hex(q, r)

function axial_to_doublewidth(hex):
    var col = 2 * hex.q + hex.r
    var row = hex.r
    return DoubledCoord(col, row)</pre><p>If you need Cube coordinates, use <code>Cube(q, r, -q-r)</code> instead of <code>Hex(q, r)</code>.</p></section><section><h2 id="neighbors"><span><a href="#neighbors">Neighbors</a></span><a href="#neighbors">#</a></h2><p>Given a hex, which 6 hexes are neighboring it? As you might expect, the answer is simplest with cube coordinates, still pretty simple with axial coordinates, and slightly trickier with offset coordinates. We might also want to calculate the 6 “diagonal” hexes.</p><h3 id="neighbors-cube"><span>Cube coordinates</span><a aria-hidden="true" href="#neighbors-cube">#</a></h3><template id="diagram-neighbors-cube"></template><h3 id="neighbors-axial"><span>Axial coordinates</span><a aria-hidden="true" href="#neighbors-axial">#</a></h3><template id="diagram-neighbors-axial"></template><h3 id="neighbors-offset"><span>Offset coordinates</span><a aria-hidden="true" href="#neighbors-offset">#</a></h3><p>As with cube and axial coordinates, we&#39;ll build a table of the numbers we need to add to <code>col</code> and <code>row</code>. However <strong>offset coordinates can&#39;t be safely subtracted and added</strong>. For example, moving southeast from (0, 0) takes us to (0, +1), so we might put (0, +1) into the table for moving southeast. But moving southeast from (0, +1) takes us to (+1, +2), so we would need to put (+1, +1) into that table. <em>The amount we need to add depends on where in the grid we are</em>.</p><p>Since the movement vector is different for odd and even columns/rows, we will need two separate lists of neighbors. <strong>Pick a grid type</strong> to see the corresponding code.</p><template id="diagram-neighbors-offset"></template><p>Using the above lookup tables is the easiest way to to calculate neighbors. It&#39;s also possible to <a href="https://www.redblobgames.com/grids/hexagons/derive-hex-neighbor-formula.html">derive these numbers</a>, for those of you who are curious.</p><h3 id="neighbors-doubled"><span>Doubled coordinates</span><a aria-hidden="true" href="#neighbors-doubled">#</a></h3><p>Unlike offset coordinates, the neighbors for doubled coordinates do <em>not</em> depend on which column/row we&#39;re on. They&#39;re the same everywhere, like axial/cube coordinates. Also unlike offset coordinates, we can safely subtract and add doubled coordinates, which makes them easier to work with than offset coordinates.</p><template id="diagram-neighbors-doubled"></template><h3 id="neighbors-diagonal"><span>Diagonals</span><a aria-hidden="true" href="#neighbors-diagonal">#</a></h3><template id="diagram-neighbors-diagonal"></template></section><section><h2 id="distances"><span><a href="#distances">Distances</a></span><a href="#distances">#</a></h2><h3 id="distances-cube"><span>Cube coordinates</span><a aria-hidden="true" href="#distances-cube">#</a></h3><div><div><p>Since cube hexagonal coordinates are based on 3d cube coordinates, we can <em>adapt</em> the distance calculation to work on hexagonal grids. Each hexagon corresponds to a cube in 3d space. Adjacent hexagons are distance 1 apart in the hex grid but distance 2 apart in the cube grid. For every 2 steps in the cube grid, we need only 1 step in the hex grid. In the 3d cube grid, Manhattan distances are <code>abs(dx) + abs(dy) + abs(dz)</code>. The distance on a hex grid is half that:</p><pre>function cube_subtract(a, b):
    return Cube(a.q - b.q, a.r - b.r, a.s - b.s)

function cube_distance(a, b):
    var vec = cube_subtract(a, b)
    return (abs(vec.q) + abs(vec.r) + abs(vec.s)) / 2
    // or: (abs(a.q - b.q) + abs(a.r - b.r) + abs(a.s - b.s)) / 2</pre><p>An equivalent way to write this is by noting that one of the three coordinates must be the sum of the other two, then picking that one as the distance. You may prefer the “divide by two” form above, or the “max” form here, but they give the same result:</p><pre>function cube_subtract(a, b):
    return Cube(a.q - b.q, a.r - b.r, a.s - b.s)

function cube_distance(a, b):
    var vec = cube_subtract(a, b)
    return max(abs(vec.q), abs(vec.r), abs(vec.s))
    // or: max(abs(a.q - b.q), abs(a.r - b.r), abs(a.s - b.s))</pre><p>The maximum of the three coordinates is the distance. You can also use the max of <code>abs(vec.q-vec.r), abs(vec.r-vec.s),
          abs(vec.s-vec.q)</code> to figure out which of the 6 “wedges” a hex is in; see <a href="https://www.redblobgames.com/grids/hexagons/directions.html">diagrams here</a>.</p></div><template id="diagram-distances"></template><p>Xiangguo Li&#39;s paper <a href="https://www.researchgate.net/publication/235779843_Storage_and_addressing_scheme_for_practical_hexagonal_image_processing?_sg=flKEA6rk1KmOpC4LBjQJN_-NBuiR1KJtJt-XeYRXnd0z_MNUrB2gjb2FKV3iBoKg988P2xHCpQ"><em>Storage and addressing scheme for practical hexagonal image processing.</em></a><sup>[15]</sup> (<a href="https://doi.org/10.1117/1.JEI.22.1.010502">DOI</a><sup>[16]</sup>) gives a formula for Euclidean distance, which can be adapted to axial coordinates: <code>sqrt(dq² + dr² + dq*dr)</code>.</p></div><h3 id="distances-axial"><span>Axial coordinates</span><a aria-hidden="true" href="#distances-axial">#</a></h3><p>In the axial system, the third coordinate is implicit. We can always <a href="#conversions">convert</a> axial to cube to calculate distance:</p><pre>function axial_distance(a, b):
    var ac = axial_to_cube(a)
    var bc = axial_to_cube(b)
    return cube_distance(ac, bc)</pre><p>Once we inline those functions it ends up as:</p><pre>function axial_distance(a, b):
    return (abs(a.q - b.q) 
          + abs(a.q + a.r - b.q - b.r)
          + abs(a.r - b.r)) / 2</pre><p>which can also be written:</p><pre>function axial_subtract(a, b):
    return Hex(a.q - b.q, a.r - b.r)

function axial_distance(a, b):
    var vec = axial_subtract(a, b)
    return (abs(vec.q)
          + abs(vec.q + vec.r)
          + abs(vec.r)) / 2</pre><p>There are lots of different ways to write hex distance in axial coordinates. No matter which way you write it, <em>axial hex distance is derived from the Mahattan distance on cubes</em>. For example, the <a href="https://web.archive.org/web/20210302023226/http://3dmdesign.com/development/hexmap-coordinates-the-easy-way">“difference of differences”</a><sup>[17]</sup> formula results from writing <code>a.q + a.r - b.q - b.r</code> as <code>a.q - b.q + a.r - b.r</code>, and using “max” form instead of the “divide by two” form of <code>cube_distance</code>. They&#39;re all equivalent once you see the connection to cube coordinates.</p><h3 id="distances-offset"><span>Offset coordinates</span><a aria-hidden="true" href="#distances-offset">#</a></h3><p>As with axial coordinates, we&#39;ll <a href="#conversions">convert</a> offset coordinates to axial/cube coordinates, then use axial/cube distance.</p><pre>function offset_distance(a, b):
    var ac = offset_to_axial(a)
    var bc = offset_to_axial(b)
    return axial_distance(ac, bc)</pre><p>We&#39;ll use the same pattern for many of the algorithms: convert offset to axial/cube, run the axial/cube version of the algorithm, and convert any axial/cube results back to offset coordinates. There are also more direct formulas for distances; see <a href="http://ondras.github.io/rot.js/manual/#hex/indexing">the rot.js manual</a><sup>[18]</sup> for a formula in the &#34;Odd shift&#34; section.</p><h3 id="distances-doubled"><span>Doubled coordinates</span><a aria-hidden="true" href="#distances-doubled">#</a></h3><p>Although converting doubled coordinates to axial/cube coordinates works, there&#39;s also a direct formula for distances, from the <a href="http://ondras.github.io/rot.js/manual/#hex/indexing">rot.js manual</a><sup>[19]</sup>:</p><pre>function doublewidth_distance(a, b):
    var dcol = abs(a.col - b.col)
    var drow = abs(a.row - b.row)
    return drow + max(0, (dcol-drow)/2)

function doubleheight_distance(a, b):
    var dcol = abs(a.col - b.col)
    var drow = abs(a.row - b.row)
    return dcol + max(0, (drow−dcol)/2)</pre></section><section><h2 id="line-drawing"><span><a href="#line-drawing">Line drawing</a></span><a href="#line-drawing">#</a></h2><template id="diagram-line-drawing"></template></section><section><h2 id="range"><span><a href="#range">Movement Range</a></span><a href="#range">#</a></h2><h3 id="range-coordinate"><span>Coordinate range</span><a aria-hidden="true" href="#range-coordinate">#</a></h3><div><div><p>Given a hex <code>center</code> and a range N, which hexes are within N steps from it?</p><p>We can work backwards from the <a href="#distances">hex distance</a> formula, <code>distance = max(abs(q), abs(r), abs(s))</code>. To find all hexes within N steps, we need <code>max(abs(q), abs(r), abs(s)) ≤ N</code>. This means we need <em>all</em> three to be true: <code>abs(q) ≤ N</code> and <code>abs(r) ≤ N</code> and <code>abs(s) ≤ N</code>. Removing absolute value, we get <code>-N ≤ q ≤ +N</code> and <code>-N ≤ r ≤ +N</code> and <code>-N ≤ s ≤ +N</code>. In code it&#39;s a nested loop:</p><pre>var results = []
for each -N ≤ q ≤ +N:
    for each -N ≤ r ≤ +N:
        for each -N ≤ s ≤ +N:
            if q + r + s == 0:
                results.append(cube_add(center, Cube(q, r, s)))</pre><p>This loop will work but it&#39;s somewhat inefficient. Of all the values of <code>s</code> we loop over, only one of them actually satisfies the <code>q + r + s = 0</code> constraint on cubes. Instead, let&#39;s directly calculate the value of <code>s</code> that satisfies the constraint:</p><pre>var results = []
for each -N ≤ q ≤ +N:
    for each max(-N, -q-N) ≤ r ≤ min(+N, -q+N):
        var s = -q-r
        results.append(cube_add(center, Cube(q, r, s)))</pre><p>This loop iterates over exactly the needed coordinates. In the diagram, each range is a pair of lines. Each line is an inequality (a <a href="http://devmag.org.za/2013/08/31/geometry-with-hex-coordinates/">half-plane</a><sup>[25]</sup>). We pick all the hexes that satisfy all six inequalities. This loop also works nicely with axial coordinates:</p><pre>var results = []
for each -N ≤ q ≤ +N:
    for each max(-N, -q-N) ≤ r ≤ min(+N, -q+N):
        results.append(axial_add(center, Hex(q, r)))</pre></div><template id="diagram-range-coordinate"></template></div><h3 id="range-intersection"><span>Intersecting ranges</span><a aria-hidden="true" href="#range-intersection">#</a></h3><div><div><p>If you need to find hexes that are in more than one range, you can intersect the ranges before generating a list of hexes.</p><p>You can either think of this problem algebraically or geometrically. Algebraically, each hexagonally-shaped region is expressed as inequality constraints of the form <code>-N ≤ dq ≤ +N</code>, and we&#39;re going to solve for the intersection of those constraints. Geometrically, each region is a cube in 3D space, and we&#39;re going to intersect two cubes in 3D space to form a <a href="https://en.wikipedia.org/wiki/Cuboid">cuboid</a><sup>[26]</sup> in 3D space, then project back to the q + r + s = 0 plane to get hexes. I&#39;m going to solve it algebraically:</p><p>First, we rewrite constraint <code>-N ≤ dq ≤ +N</code> into a more general form, <code>q<sub>min</sub> ≤ q ≤
          q<sub>max</sub></code>, and set <code>q<sub>min</sub> = center.q
          - N</code> and <code>q<sub>max</sub> = center.q + N</code>. We&#39;ll do the same for <code>r</code> and <code>s</code>, and end up with this generalization of the code from the previous section:</p><pre>var results = []
for each q<sub>min</sub> ≤ q ≤ q<sub>max</sub>:
    for each max(r<sub>min</sub>, -q-s<sub>max</sub>) ≤ r ≤ min(r<sub>max</sub>, -q-s<sub>min</sub>):
        results.append(Hex(q, r))</pre><p>The intersection of two ranges <code>a ≤ q ≤ b</code> and <code>c ≤ q ≤ d</code> is <code>max(a, c) ≤ q ≤ min(b,
          d)</code>. Since a hex region is expressed as ranges over q, r, s, we can separately intersect each of the q, r, s ranges then use the nested loop to generate a list of hexes in the intersection. For one hex region we set <code>q<sub>min</sub> = H.q - N</code> and <code>q<sub>max</sub> = H.q + N</code> and likewise for <code>r</code> and <code>s</code>. For intersecting two hex regions we set <code>q<sub>min</sub> = max(H<sub>1</sub>.q -
          N, H<sub>2</sub>.q - N)</code> and <code>q<sub>max</sub> =
          min(H<sub>1</sub>.q + N, H<sub>2</sub>.q + N)</code>, and likewise for <code>r</code> and <code>s</code>. The same pattern works for intersecting three or more regions, and can generalize to <a href="http://devmag.org.za/2013/08/31/geometry-with-hex-coordinates/">other shapes</a><sup>[27]</sup> (triangles, trapezoids, rhombuses, non-regular hexagons).</p></div><template id="diagram-range-intersection"></template></div><h3 id="range-obstacles"><span>Obstacles</span><a aria-hidden="true" href="#range-obstacles">#</a></h3><div><div><p>If there are obstacles, the simplest thing to do is a distance-limited flood fill (<a href="https://www.redblobgames.com/pathfinding/tower-defense/">breadth first search</a>). In the code, <code>fringes[k]</code> is an array of all hexes that can be reached in <code>k</code> steps. Each time through the main loop, we expand level <code>k-1</code> into level <code>k</code>. This works equally well with any of the hex coordinate systems (cube, axial, offset, doubled).</p><pre>function hex_reachable(start, movement):
    var visited = set() # set of hexes
    add start to visited
    var fringes = [] # array of arrays of hexes
    fringes.append([start])

    for each 1 &lt; k ≤ movement:
        fringes.append([])
        for each hex in fringes[k-1]:
            for each 0 ≤ dir &lt; 6:
                var neighbor = hex_neighbor(hex, dir)
                if neighbor not in visited and not blocked:
                    add neighbor to visited
                    fringes[k].append(neighbor)

    return visited</pre></div><template id="diagram-movement-range"></template></div></section><section><h2 id="rotation"><span><a href="#rotation">Rotation</a></span><a href="#rotation">#</a></h2><div><div><p>Given a hex vector (difference between one hex and another), we might want to rotate it to point to a different hex. This is simple with cube coordinates if we stick with rotations of 1/6th of a circle.</p><p>A rotation 60° right (clockwise ↻) shoves each coordinate one slot to the left ←:</p><pre>      [ q,  r,  s]
to        [-r, -s, -q]
to           [  s,  q,  r]</pre><p>A rotation 60° left (counter-clockwise ↺) shoves each coordinate one slot to the right →:</p><pre>          [ q,  r,  s]
to    [-s, -q, -r]
to [r,  s,  q]</pre></div><template id="diagram-rotation"></template><div><p>As you play with diagram, notice that each 60° rotation <em>flips</em> the signs and also physically “rotates” the coordinates. Take a look at the axis legend on the bottom left to see how this works. After a 120° rotation the signs are flipped back to where they were. A 180° rotation flips the signs but the coordinates have rotated back to where they originally were.</p><p>Here&#39;s the full recipe for rotating a position <code>hex</code> around a center position <code>center</code> to result in a new position <code>rotated</code>:</p><ol><li><a href="#conversions">Convert</a> positions <code>hex</code> and <code>center</code> to cube coordinates.</li><li>Calculate a <em>vector</em> by subtracting the center: <code>vec = cube_subtract(hex, center) = Cube(hex.q - center.q, hex.r - center.r, hex.s - center.s)</code>.</li><li>Rotate the vector <code>vec</code> as described above, and call the resulting vector <code>rotated_vec</code>.</li><li>Convert the vector back to a position by adding the center: <code>rotated = cube_add(rotated_vec, center) = Cube(rotated_vec.q + center.q, rotated_vec.r + center.r, rotated_vec.s + center.s)</code>.</li><li><a href="#conversions">Convert</a> the cube position <code>rotated</code> back to to your preferred coordinate system.</li></ol><p>It&#39;s several conversion steps but each step is short. You can shortcut some of these steps by defining rotation directly on axial coordinates, but hex vectors don&#39;t work for offset coordinates and I don&#39;t know a shortcut for offset coordinates. Also see <a href="https://gamedev.stackexchange.com/questions/15237/how-do-i-rotate-a-structure-of-hexagonal-tiles-on-a-hexagonal-grid/">this stackexchange discussion</a><sup>[28]</sup> for other ways to calculate rotation.</p></div></div></section><section><h2 id="reflection"><span><a href="#reflection">Reflection</a></span><a href="#reflection">#</a></h2><div><p>Given a hex, we might want to reflect it across one of the axes. With cube coordinates, we <em>swap</em> the coordinates that <em>aren&#39;t</em> the axis we&#39;re reflecting over. The axis we&#39;re reflecting over stays the same.</p><template id="diagram-reflection"></template><pre>function reflectQ(h) { return Cube(h.q, h.<b>s</b>, h.<b>r</b>); }
function reflectR(h) { return Cube(h.<b>s</b>, h.r, h.<b>q</b>); }
function reflectS(h) { return Cube(h.<b>r</b>, h.<b>q</b>, h.s); }</pre><p>To reach the other two reflections, <em>negate</em> the coordinates of the original and the first reflection. These are shown as white arrows in the diagram.</p><p>To reflect over a line that&#39;s not at 0, pick a reference point on that line. Subtract the reference point, perform the reflection, then add the reference point back.</p></div></section><section><h2 id="rings"><span><a href="#rings">Rings</a></span><a href="#rings">#</a></h2><div><div><h3 id="rings-single"><span>Single ring</span><a aria-hidden="true" href="#rings-single">#</a></h3><p>To find out whether a given hex is on a ring of a given <code>radius</code>, calculate the distance from that hex to the center and see if it&#39;s <code>radius</code>. To get a list of all such hexes, take <code>radius</code> steps away from the center, then follow the rotated vectors in a path around the ring.</p><pre>function cube_scale(hex, factor):
    return Cube(hex.q * factor, hex.r * factor, hex.s * factor)

function cube_ring(center, radius):
    var results = []
    # this code doesn&#39;t work for radius == 0; can you see why?
    var hex = cube_add(center,
                        cube_scale(cube_direction(4), radius))
    for each 0 ≤ i &lt; 6:
        for each 0 ≤ j &lt; radius:
            results.append(hex)
            hex = cube_neighbor(hex, i)
    return results</pre><p>In this code, <code>hex</code> starts out on the ring, shown by the large arrow from the center to the corner in the diagram. I chose corner 4 to start with because it lines up the way my direction numbers work but you may need a different starting corner. At each step of the inner loop, <code>hex</code> moves one hex along the ring. After a circumference of <code>6 * radius</code> steps it ends up back where it started.</p></div><template id="diagram-rings"></template><p>The scale, add, and neighbor operations also work on axial and doubled coordinates, so the same algorithm can be used. For offset coordinates, convert to one of the other formats, generate the ring, and convert back.</p></div><div><div><h3 id="rings-spiral"><span>Spiral rings</span><a aria-hidden="true" href="#rings-spiral">#</a></h3><p>Traversing the <code>N</code> rings one by one in a spiral pattern, we can fill in the interior:</p><pre>function cube_spiral(center, radius):
    var results = list(center)
    for each 1 ≤ k ≤ N:
        results = list_append(results, cube_ring(center, k))
    return results</pre></div><template id="diagram-spiral"></template><p id="calculation-spiral">Spirals also give us a way to <em>count</em> how many hexagon tiles are in the larger hexagon. The center is 1 hex. The circumference of the k-th ring is <code>6 * k</code> hexes. The sum for N rings is <code>1 + 6 * sum(1 to N)</code>. Using <a href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF">this formula</a><sup>[29]</sup>, that simplifies to <code>1 + 3 * N * (N+1)</code>. For <label> rings</label>, there will be <output><code>{{count}}</code></output> hexes.</p><p>Visiting the hexes this way can also be used to calculate <a href="#range">movement range</a>.</p></div></section><section><h2 id="field-of-view"><span><a href="#field-of-view">Field of view</a></span><a href="#field-of-view">#</a></h2><div><div><p>Given a location and a distance, what is visible from that location, not blocked by obstacles? The simplest way to do this is to draw a line to every hex that&#39;s in range. If the line doesn&#39;t hit any walls, then you can see the hex. Mouse over a hex to see the line being drawn to that hex, and which walls it hits.</p><p>This algorithm can be slow for large areas but it&#39;s so easy to implement that it&#39;s what I recommend starting with.</p></div><template id="diagram-field-of-view"></template><!--
           <p>
           Another algorithm would be to move outwards from the center
           hex. Keep a set of ranges of angles that are in shadow. If you
           encounter a hex that's within one of the ranges, then it's not
           visible. If you encounter a hex that's an obstacle, you generate
           a new angle range and union it with the existing set. I think <a
           href="https://en.wikipedia.org/wiki/Interval_tree">interval
           trees</a> might be useful for this. <s> sketch is: for each
           hex in the spiral ring traversal { calculate min/max angle of
           the hex; if range is entirely contained within shadow range set,
           skip; otherwise if it's an obstacle, add range to shadow range
           set; otherwise hex is visible } but dealing with the angle
           ranges crossing 0 deg will be an added complication </s>
           </p>
      --><p>There are many different ways to define what&#39;s &#34;visible&#34;. Do you want to be able to see the center of the other hex from the center of the starting hex? Do you want to see any part of the other hex from the center of the starting point? Maybe any part of the other hex from any part of the starting point? Are there obstacles that occupy less than a complete hex? Field of view turns out to be trickier and more varied than it might seem at first. Start with the simplest algorithm, but expect that it may not compute exactly the answer you want for your project. <span id="field-of-view-illogical-results">There are even situations where the simple algorithm produces results that are illogical.</span></p><p><a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html">Clark Verbrugge&#39;s guide</a><sup>[30]</sup> describes a “start at center and move outwards” algorithm to calculate field of view. Also see the <a href="https://github.com/jbochi/duelo">Duelo</a><sup>[31]</sup> project, which has an <a href="https://s3.amazonaws.com/jbochi/layout.html">an online demo of directional field of view</a><sup>[32]</sup> and code on Github. Also see <a href="https://www.redblobgames.com/articles/visibility/">my article on 2d visibility calculation</a> for an algorithm that works on polygons, including hexagons. For grids, the roguelike community has a nice set of algorithms for square grids (see <a href="http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html">Roguelike Vision Algorithms</a><sup>[33]</sup> and <a href="http://www.roguebasin.com/index.php/Pre-Computed_Visibility_Tries">Pre-Computed Visibility Tries</a><sup>[34]</sup> and <a href="http://www.roguebasin.com/index.php/Field_of_Vision">Field of Vision</a><sup>[35]</sup>); some of them might be adapted for hex grids.</p></div></section><section><h2 id="hex-to-pixel"><span><a href="#hex-to-pixel">Hex to pixel</a></span><a href="#hex-to-pixel">#</a></h2><p>For hex to pixel, it&#39;s useful to review the <a href="#basics">size and spacing diagram</a> at the top of the page.</p><h3 id="hex-to-pixel-axial"><span>Axial coordinates</span><a aria-hidden="true" href="#hex-to-pixel-axial">#</a></h3><template id="diagram-hex-to-pixel-axial"></template><h3 id="hex-to-pixel-offset"><span>Offset coordinates</span><a aria-hidden="true" href="#hex-to-pixel-offset">#</a></h3><template id="code-hex-to-pixel-offset"></template><h3 id="hex-to-pixel-doubled"><span>Doubled coordinates</span><a aria-hidden="true" href="#hex-to-pixel-doubled">#</a></h3><p>Doubled makes many algorithms simpler than offset.</p><pre>function doublewidth_to_pixel(hex):
    var x = size * sqrt(3)/2 * hex.col
    var y = size * 3/2 * hex.row
    return Point(x, y)

function doubleheight_to_pixel(hex):
    var x = size * 3/2 * hex.col
    var y = size * sqrt(3)/2 * hex.row
    return Point(x, y)</pre></section><section><h2 id="pixel-to-hex"><span><a href="#pixel-to-hex">Pixel to Hex</a></span><a href="#pixel-to-hex">#</a></h2><template id="diagram-pixel-to-hex"></template></section><section><h2 id="rounding"><span><a href="#rounding">Rounding to nearest hex</a></span><a href="#rounding">#</a></h2><p>Sometimes we&#39;ll end up with a <em>floating-point</em> cube coordinate, and we&#39;ll want to know which hex it should be in. This comes up in <a href="#line-drawing">line drawing</a> and <a href="#pixel-to-hex">pixel to hex</a>. Converting a floating point value to an integer value is called <em>rounding</em> so I call this algorithm <code>cube_round</code>.</p><p>Just as with integer cube coordinates, <code>frac.q + frac.r + frac.s = 0</code> with fractional (floating point) cube coordinates. We can round each component to the nearest integer, <code>q = round(frac.q); r = round(frac.r); s = round(frac.s)</code>. However, after rounding we do <em>not</em> have a guarantee that <code>q + r + s = 0</code>. We do have a way to correct the problem: <em>reset</em> the component with the largest change back to what the constraint <code>q + r + s = 0</code> requires. For example, if the r-change <code>abs(r-frac.r)</code> is larger than <code>abs(q-frac.q)</code> and <code>abs(s-frac.s)</code>, then we reset <code>r = -q-s</code>. This guarantees that <code>q + r + s = 0</code>. Here&#39;s the algorithm:</p><pre>function cube_round(frac):
    var q = round(frac.q)
    var r = round(frac.r)
    var s = round(frac.s)

    var q_diff = abs(q - frac.q)
    var r_diff = abs(r - frac.r)
    var s_diff = abs(s - frac.s)

    if q_diff &gt; r_diff and q_diff &gt; s_diff:
        q = -r-s
    else if r_diff &gt; s_diff:
        r = -q-s
    else:
        s = -q-r

    return Cube(q, r, s)</pre><p>For non-cube coordinates, the simplest thing to do is to <a href="#conversions">convert to cube coordinates</a>, use the rounding algorithm, then convert back:</p><pre>function axial_round(hex):
    return cube_to_axial(cube_round(axial_to_cube(hex)))</pre><p>The same would work if you have <code>oddr</code>, <code>evenr</code>, <code>oddq</code>, or <code>evenq</code> instead of <code>axial</code>. Jacob Rus has a <a href="https://observablehq.com/@jrus/hexround">direct implementation of axial_round</a><sup>[38]</sup> without converting to cube first.</p><p>Implementation note: <code>cube_round</code> and <code>axial_round</code> take <em>float</em> coordinates instead of <em>int</em> coordinates. If you&#39;ve written a Cube and Hex class, they&#39;ll work fine in dynamically typed languages where you can pass in floats instead of ints, and they&#39;ll also work fine in statically typed languages with a unified number type. However, in most statically typed languages, you&#39;ll need a separate class/struct type for float coordinates, and <code>cube_round</code> will have type <code>FloatCube → Cube</code>. If you also need <code>axial_round</code>, it will be <code>FloatHex → Hex</code>, using helper function <code>floatcube_to_floathex</code> instead of <code>cube_to_hex</code>. In languages with parameterized types (C++, Haskell, etc.) you might define <code>Cube&lt;T&gt;</code> where <code>T</code> is either <code>int</code> or <code>float</code>. Alternatively, you could write <code>cube_round</code> to take three floats as inputs instead of defining a new type just for this function.</p><!--
    <p>
      This algorithm is based on <a
      href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">Charles
      Fu's article</a>. His code contains the additional optimization
      that if <code>rx + ry + rz = 0</code> there's no need to
      look at the error values and reset the largest component.
    </p>
    --><p>Patrick Surry has a <a href="https://blocks.roadtolarissa.com/patricksurry/0603b407fa0a0071b59366219c67abca">visualization showing why the rounding algorithm works</a><sup>[39]</sup>.</p></section><section><h2 id="map-storage"><span><a href="#map-storage">Map storage in axial coordinates</a></span><a href="#map-storage">#</a></h2><p>One of the common complaints about the axial coordinate system is that it leads to wasted space when using a rectangular map; that&#39;s one reason to favor an offset coordinate system. However all the hex coordinate systems lead to wasted space when using a triangular or hexagonal map. We can use the same strategies for storing all of them.</p><template id="diagram-map-storage"></template><p>Notice in the diagram that the wasted space is on the left and right sides of each row (except for rhombus maps) This gives us three strategies for storing the map:</p><ol><li>Use a <strong>2D Array</strong>. Use nulls or some other sentinel at the unused spaces. Store <code>Hex(<span>q</span>, <span>r</span>)</code> at <code>array[<span>r</span>][<span>q</span>]</code>. At most there&#39;s a factor of two for these common shapes; it may not be worth using a more complicated solution.</li><li>Use a <strong>hash table</strong> instead of dense array. This allows arbitrarily shaped maps, including ones with holes. Store <code>Hex(<span>q</span>, <span>r</span>)</code> in <code>hash_table(hash(<span>q</span>,<span>r</span>))</code>.</li><li>Use an <strong>array of arrays</strong> by sliding row to the left, and shrinking the rows to the minimum size. For pointy-top hexes, store <code>Hex(<span>q</span>, <span>r</span>)</code> in <code>array[<span>r</span> - first_row][<span>q</span> - first_column(r)]</code>. Some examples for the map shapes above: <ul><li><strong>Rectangle</strong>. Store <code>Hex(<span>q</span>, <span>r</span>)</code> at <code>array[<span>r</span>][<span>q</span> + floor(r/2)]</code>. Each row has the same length. This is equivalent to odd-r offset.</li><li><strong>Hexagon</strong>. Store <code>Hex(<span>q</span>, <span>r</span>)</code> at <code>array[<span>r</span>][<span>q</span> - max(0, N-r)]</code>. Row <span>r</span> size is <code>2*N+1 - abs(N-r)</code>.</li><li><strong>Rhombus</strong>. Conveniently, <code>first_row</code> and <code>first_column(r)</code> are both 0. Store <code>Hex(<span>q</span>, <span>r</span>)</code> at <code>array[<span>r</span>][<span>q</span>]</code>. All rows are the same length.</li><li><strong>Down-triangle</strong>. Store <code>Hex(<span>q</span>, <span>r</span>)</code> at <code>array[<span>r</span>][<span>q</span>]</code>. Row <span>r</span> has size <code>N+1-r</code>.</li><li><strong>Up-triangle</strong>. Store <code>Hex(<span>q</span>, <span>r</span>)</code> at <code>array[<span>r</span>][<span>q</span> - N+1+r]</code>. Row <span>r</span> has size <code>1+r</code>.</li></ul> For flat-top hexes, swap the roles of the rows and columns, and use <code>array[<span>q</span> - first_column][<span>r</span> - first_row(q)]</code>.</li></ol><p>Encapsulate access into the getter/setter in a map class so that the rest of the game doesn&#39;t need to know about the map storage. Your maps may not look exactly like these, so you will have to adapt one of these approaches.</p></section><section><h2 id="wraparound"><span><a href="#wraparound">Wraparound maps</a></span><a href="#wraparound">#</a></h2><div><div><p>In some games you want the map to “wrap” around the edges. In a square map, you can either wrap around the x-axis only (roughly corresponding to a sphere) or both x- and y-axes (roughly corresponding to a torus). Wraparound depends on the map shape, not the tile shape. To wrap around a rectangular map is easy with offset coordinates. I&#39;ll show how to wrap around a hexagon-shaped map with cube coordinates.</p><p>Corresponding to the center of the map, there are six “mirror” centers. When you go off the map, you subtract the mirror center closest to you until you are back on the main map. In the diagram, try exiting the center map, and watch one of the mirrors enter the map on the opposite side.</p><p>The simplest implementation is to precompute the answers. Make a lookup table storing, for each hex just off the map, the corresponding cube on the other side. For each of the six mirror centers <code>M</code>, and each of the locations on the map <code>L</code>, store <code>mirror_table[cube_add(M, L)] = L</code>. Then any time you calculate a hex that&#39;s in the mirror table, replace it by the unmirrored version. See <a href="https://gamedev.stackexchange.com/a/137603/2472">stackoverflow</a><sup>[40]</sup> for another approach.</p><p>For a hexagonal shaped map with radius <code>N</code>, the mirror centers will be <code>Cube(2*N+1, -N, -N-1)</code> and its <a href="#rotation">six rotations</a>.</p></div><template id="diagram-wraparound"></template><p>Related: Sander Evers has a <a href="https://observablehq.com/@sanderevers/hexagon-tiling-of-an-hexagonal-grid">nice explanation of how to combine small hexagons into a grid of large hexagons</a><sup>[41]</sup> and also a <a href="https://observablehq.com/@sanderevers/hexmod-representation">coordinate system to represent small hexagons within a larger one</a><sup>[42]</sup>.</p></div></section><section><h2 id="pathfinding"><span><a href="#pathfinding">Pathfinding</a></span><a href="#pathfinding">#</a></h2><div><p>If you&#39;re using graph-based pathfinding such as A* or Dijkstra&#39;s algorithm or Floyd-Warshall, pathfinding on hex grids isn&#39;t different from pathfinding on square grids. The explanations and code from <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">my pathfinding tutorial</a><sup>[43]</sup> will work equally well on hexagonal grids.</p><template id="diagram-pathfinding"></template><p><span>Mouse over</span><span>Touch</span> a hex in the diagram to see the path to it. <span>Click or drag to toggle walls.</span></p><ol><li><strong>Neighbors</strong>. The sample code I provide in the pathfinding tutorial calls <code>graph.neighbors</code> to get the neighbors of a location. Use the function in the <a href="#neighbors">neighbors</a> section for this. Filter out the neighbors that are impassable.</li><li><strong>Heuristic</strong>. The sample code for A* uses a <code>heuristic</code> function that gives a distance between two locations. Use the <a href="#distances">distance formula</a>, scaled to match the movement costs. For example if your movement cost is 5 per hex, then multiply the distance by 5.</li></ol></div></section><section><h2 id="references"><span><a href="#references">More</a></span><a href="#references">#</a></h2><p>I have an <a href="https://www.redblobgames.com/grids/hexagons/implementation.html"><b>guide to implementing your own hex grid library</b></a>, including sample code in C++, Java, C#, Javascript, Haxe, and Python.</p><ul><li>The best early guide I saw to the axial coordinate system was <a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html">Clark Verbrugge&#39;s guide</a><sup>[44]</sup>, written in 1996.</li><li>The first time I saw the cube coordinate system was from <a href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">Charles Fu&#39;s posting to rec.games.programmer</a><sup>[45]</sup> in 1994.</li><li><a href="http://devmag.org.za/2013/08/31/geometry-with-hex-coordinates/">DevMag has a nice visual overview of hex math</a><sup>[46]</sup> including how to represent areas such as half-planes, triangles, and quadrangles. There&#39;s a <a href="http://www.gamelogic.co.za/downloads/HexMath2.pdf">PDF article</a><sup>[47]</sup> that goes into more detail. <strong>Highly recommended</strong>! The <a href="http://gamelogic.co.za/grids/documentation-contents/quick-start-tutorial/gamelogics-hex-grids-for-unity-and-amit-patels-guide-for-hex-grids/">GameLogic Grids</a><sup>[48]</sup> library implements these and many other grid types in Unity.</li><li>In my <a href="https://www.redblobgames.com/grids/parts/">Guide to Grids</a>, I cover axial coordinate systems to address square, triangle, and hexagon sides and corners, and algorithms for the relationships among tiles, sides, and corners. I also show how square and hex grids are related.</li><li><a href="http://playtechs.blogspot.com/2007/04/hex-grids.html">James McNeill has a nice visual explanation of grid transformations</a><sup>[49]</sup>.</li><li><a href="http://web.archive.org/web/20090205120106/http://sc.tri-bit.com/Hex_Grids">Overview of hex coordinate types</a><sup>[50]</sup>: staggered (offset), interlaced, 3d (cube), and trapezoidal (axial).</li><li><a href="http://ondras.github.io/rot.js/manual/#hex/indexing">The Rot.js library</a><sup>[51]</sup> has a list of hex coordinate systems: non-orthogonal (axial), odd shift (offset), double width (interlaced), cube.</li><li><a href="https://stackoverflow.com/questions/2049196/generating-triangular-hexagonal-coordinates-xyz">Range for cube coordinates</a><sup>[52]</sup>: given a distance, which hexagons are that distance from the given one?</li><!-- - keekerdc prohibited wayback machine, *and* wiped his blog; emailed him 2022-08-27 --><li><a href="https://archive.ph/20141214082648/http://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/">Distances on hex grids</a><sup>[53]</sup> using cube coordinates, and reasons to use cube coordinates instead of offset.</li><!-- domain squatter took over and also wiped wayback machine 
      <li><a href="http ://www.br-gs.com/tutorial/hexagon-grid.html">This
      guide</a> explains the basics of measuring and drawing hexagons,
      using an offset grid.</li>
      --><li><a href="https://stackoverflow.com/questions/2459402/hexagonal-grid-coordinates-to-pixel-coordinates">Convert cube hex coordinates to pixel coordinates</a><sup>[54]</sup>.</li><li><a href="https://gamedev.stackexchange.com/questions/51264/get-ring-of-tiles-in-hexagon-grid">This thread</a><sup>[55]</sup> explains how to generate rings.</li><li>The <a href="http://www.battleanalysis.com/battlefield.html">HexPart</a><sup>[56]</sup> system uses both hexes and rectangles to make some of the algorithms easier to work with.</li><li>Are there <a href="https://gamedev.stackexchange.com/questions/49718/vertical-vs-horizontal-hex-grids-pros-and-cons">pros and cons of “pointy top” and “flat top” hexagons</a><sup>[57]</sup>?</li><li><a href="https://web.archive.org/web/20121113035227/http://arges-systems.com/blog/2011/01/10/hex-grid-line-of-sight-revisited/">Line of sight in a hex grid</a><sup>[58]</sup> with offset coordinates, splitting hexes into triangles</li><li>Hexnet explains how the <a href="https://hexnet.org/content/permutohedron">correspondence between hexagons and cubes</a><sup>[59]</sup> goes much deeper than what I described on this page, generalizing to higher dimensions.</li><li>I used the PDF hex grids from <a href="https://incompetech.com/graphpaper/hexagonal/">this page</a><sup>[60]</sup> while working out some of the algorithms.</li><li><a href="https://link.springer.com/book/10.1007/1-84628-203-9">Hexagonal Image Processing</a><sup>[61]</sup> (<a href="https://doi.org/10.1007/1-84628-203-9">DOI</a><sup>[62]</sup>) is an entire book that uses a hierarchical hexagonal coordinate system.</li><li><a href="http://hexgridutilities.codeplex.com/documentation">Hex-Grid Utilities</a><sup>[63]</sup> is a C# library for hex grid math, with neighbors, grids, range finding, path finding, field of view. Open source, MIT license.</li><li>This is the oldest reference I can find for axial grids: Luczak, E. and Rosenfeld, A., <em>Distance on a Hexagonal Grid</em>. IEEE Transactions on Computers (1976) (<a href="https://doi.org/10.1109/TC.1976.1674642">DOI</a><sup>[64]</sup>) It calls the axial system <em>oblique coordinates</em> and the offset systems <em>pseudohexagonal grids</em>.</li><li>Snyder, Qi, Sander&#39;s paper <em>Coordinate system for hexagonal pixels</em> (<a href="https://doi.org/10.1117/12.348629">DOI</a><sup>[65]</sup>) describes gradients, diffusion, and map storage for axial coordinates. Mersereau&#39;s paper <em>The processing of hexagonally sampled two-dimensional signals</em> (<a href="https://doi.org/10.1109/PROC.1979.11356">DOI</a><sup>[66]</sup>) describes signal processing on axial coordinates.</li><li>There&#39;s a paper that calls cube coordinates <em>*R3 coordinates</em>: Her, Innchyn, <em>Geometric Transformations on the Hexagonal Grid</em>, IEEE Transactions on Image Processing (1995) (<a href="https://doi.org/10.1109/83.413166">DOI</a><sup>[67]</sup>) It covers coordinates, correspondence to cube coordinates, rounding, reflections, scaling, shearing, and rotation. A paper from the same author (<a href="https://doi.org/10.1115/1.2919210">DOI</a><sup>[68]</sup>) covers distances.</li><li>The <a href="https://old.reddit.com/r/gamedev/comments/1dz1tr/">Reddit discussion</a><sup>[69]</sup> and <a href="https://news.ycombinator.com/item?id=5809724">Hacker News discussion</a><sup>[70]</sup> and <a href="https://www.metafilter.com/128649/Hexagonal-Grids">MetaFilter discussion</a><sup>[71]</sup> have more comments and links.</li></ul><p>The code that powers this page is partially procedurally generated! The core algorithms are in <a href="https://www.redblobgames.com/grids/hexagons/codegen/output/lib.js">lib.js</a>, generated from <a href="https://www.redblobgames.com/grids/hexagons/implementation.html">my guide to implementation</a>. There are a few more algorithms in <a href="https://www.redblobgames.com/grids/hexagons/hex-algorithms.js">hex-algorithms.js</a>. The interactive diagrams are in <a href="https://www.redblobgames.com/grids/hexagons/diagrams.js">diagrams.js</a> and <a href="https://www.redblobgames.com/grids/hexagons/index.js">index.js</a>, using Vue.js to inject into the templates in <a href="https://www.redblobgames.com/grids/hexagons/index.bxml">index.bxml</a> (xhtml I feed into a preprocessor).</p><p>There are more things I want to do for this guide. I&#39;m <a href="https://www.notion.so/redblobgames/f8bc2f44fba94607afa9c06711d23245?v=0766432cb1534ce582ce35b33cbbef7e&amp;p=7d2d4d624bc5483dafbe615d75ab3902">keeping a list on Notion</a><sup>[72]</sup>. Do you have suggestions for things to change or add? Comment below.</p></section></div></div>
  </body>
</html>
