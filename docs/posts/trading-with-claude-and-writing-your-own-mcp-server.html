<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dangelov.com/blog/trading-with-claude/">Original</a>
    <h1>Trading with Claude, and writing your own MCP server</h1>
    
    <div id="readability-page-1" class="page"><section><header><a href="https://dangelov.com/"><abbr title="Pronounced &#39;dee-no&#39;">Dino</abbr> Angelov</a></header><summary><time>May 4, 2025</time> <span>• 12 minute read</span></summary><p>Ever wanted to check on your portfolio and trade some stocks directly with Claude? Well you’re in luck.</p><p><img src="https://dangelov.com/blog/trading-with-claude/img/trade-executed.png" alt="Claude executing a trade via SnapTrade"/></p><h2 id="claude-and-mcp">Claude and MCP</h2><p>In November 2024, <a href="https://www.anthropic.com/news/model-context-protocol">Anthropic open-sourced MCP</a> (Model-Context Protocol) to standardize the way AI assistants interact with other tools. This standardization allows AI assistants to seamlessly integrate with various tools and platforms, enhancing their capabilities and usability. Since then, it’s been growing in popularity and adoption, slowly becoming a key component in the development of AI-powered tools and applications.</p><p>While the original version had some support for remote MCP servers, it was somewhat complicated to implement and did not see widespread adoption. So, as a natural evolution to the original MCP, they released the <a href="https://modelcontextprotocol.io/specification/2025-03-26/changelog">2025-03-26 version</a> with support for OAuth 2.1 authorization and replaced the HTTP+SSE transport with “Streamable HTTP” transport.</p><p>Perhaps most importantly, all of this only worked in Claude Desktop - till now. A few days ago, they <a href="https://www.anthropic.com/news/integrations">added “Integrations” to Claude</a>, allowing everyone to use MCP tools directly from the web chat interface.</p><p>Unfortunately, they labeled it as beta and only made it available on their more expensive Max, Team, and Enterprise plans, launching with a limited number of partners.</p><p>So for now, we will stick to exploring the possibilities of MCP with Claude Desktop.</p><h2 id="what-is-an-mcp-server-anyway">What is an MCP server anyway?</h2><p>An MCP server is just a server, which can be hosted remotely or a local binary (or a local command) that exposes a list of functions, resources and other information to an LLM.</p><p>It exposes this via a standardized mechanism (see above), and then LLMs such as Claude can choose when to call it and ask to use a tool (much like a function call).</p><h2 id="snaptrade">SnapTrade</h2><p>Which brings me to my next point: I work at <a href="https://snaptrade.com/">SnapTrade</a> (and a mandatory disclaimer: I’m writing this in a personal capacity, not as an employee of SnapTrade) - which allows anyone with some technical knowledge to integrate with a vast array of financial platforms and brokerages using a <a href="https://docs.snaptrade.com/">simple, unified API</a>.</p><p>So what better way to explore MCP than to build a financial trading bot using SnapTrade’s API and MCP?</p><h2 id="building-the-mcp-server">Building the MCP server</h2><p>When I first looked into doing this, I thought why not use Claude to write the server? The same company (Anthropic) owns both Claude and drove the development of MCP. Surely they’ve made it really easy to use Claude to write the server. Right? Turns out, I had <strong>much</strong> better luck using <a href="https://gemini.google.com/">Gemini</a> than Claude. I was able to feed Gemini all of the prompts and docs that <a href="https://modelcontextprotocol.io/tutorials/building-mcp-with-llms">MCP’s own “Building with LLMs” documentation</a> suggested and it wrote a working version on the first try, while Claude struggled with context limits and a number of other issues.</p><p>The generated code was still more than what I wanted to maintain, and as <a href="https://raz.sh/blog/2025-05-02_a_critical_look_at_mcp">others have noted</a> it can be quite frustrating to implement it from scratch.</p><p>Even so, none of that turned out to really be necessary. I was able to iterate and work on the core product much faster by using the <a href="https://github.com/mark3labs/mcp-go">go-mcp</a> framework for Go.</p><h3 id="requirements">Requirements</h3><ul><li><a href="https://golang.org/">Go</a> - I quite enjoy working with Go, it’s a great language and it makes it really easy to build single binaries that are incredibly easy to point to from Claude Desktop.</li><li><a href="https://github.com/mark3labs/mcp-go">go-mcp</a> - I evaluated a couple of alternatives, but go-mcp was the most straightforward and easy to use.</li><li><a href="https://pkg.go.dev/github.com/passiv/snaptrade-sdks/sdks/go">SnapTrade Go SDK</a> - the SnapTrade Go SDK.</li><li><a href="https://github.com/fbiville/markdown-table-formatter">markdown-table-formatter</a> - A tool for formatting Markdown tables. Useful when presenting some structured data such as positions, orders, and other financial data.</li><li><a href="https://github.com/urfave/cli">cli</a> - A simple command-line interface library for Go. Only used to make it easy to build a helper companion CLI app to iterate faster during development, not necessary nor used in the MCP server itself.</li><li><a href="https://dashboard.snaptrade.com/signup">a SnapTrade client ID and secret</a> - Sign up through this link to get a free test key which gives you a limited number of connections for free, plus access to paper trading.</li></ul><h3 id="directory-structure">Directory structure</h3><p>Sometimes I find it helpful to see a general overview of the directory structure before I begin working on a project. Here’s roughly what we will be building. We have <code>bin</code> holding our built binary, <code>cmd</code> holding the “commands” (cli apps) we want to build (just 1 for now), and <code>internal</code> holding a number of packages that are internal to our server.</p><p>The most important subdirectory is <code>tools</code>, which holds code for each of the tools we want to make available to Claude via our MCP server.</p><pre><code>.
├── bin
│   ├── cli
│   ├── .env
│   └── .env.example
├── cmd
│   ├── cli
│   │   └── main.go
│   └── manage
│       └── main.go
├── .gitignore
├── go.mod
├── go.sum
├── internal
│   ├── snaptradeclient
│   │   └── snaptrade.go
│   └── tools
│       ├── connect
│       │   └── connect.go
│       ├── help
│       │   └── help.go
│       ├── orders
│       │   └── orders.go
│       ├── portfolio
│       │   └── portfolio.go
│       └── trades
│           └── trades.go
└── Makefile
</code></pre><h3 id="help-i-want-to-trade-with-claude-and-snaptrade">Help! I want to trade with Claude (and SnapTrade)</h3><p>Let’s start with our first tool. This will define the pattern or structure we will reuse for each of our tools. This file should live under <code>internal/tools/help/help.go</code>.</p><div><pre><code data-lang="go"><span>package</span> help

<span>import</span> (
	<span>&#34;context&#34;</span>

	<span>&#34;github.com/mark3labs/mcp-go/mcp&#34;</span>
	<span>&#34;github.com/mark3labs/mcp-go/server&#34;</span>
	<span>&#34;snaptrade.com/mcp-server/internal/snaptradeclient&#34;</span>
)

<span>// This just defines a new tool using the MCP framework. It&#39;s important to have
</span><span>// clear and helpful tool name and descriptions, as that&#39;s what Claude uses
</span><span>// to determine when and whether to run your tool.
</span><span></span><span>var</span> Tool = mcp.<span>NewTool</span>(<span>&#34;get_started_with_brokerage_connection&#34;</span>,
	mcp.<span>WithDescription</span>(<span>&#34;Provides information on how to connect your brokerage account and lists the supported brokerages.&#34;</span>),
)

<span>// Each tool has a handler that returns a function matching the `go-mcp`
</span><span>// tool handler function signature. We use this to make it easy to pass
</span><span>// an instance of `snaptradeclient.SnapTradeClient` which holds all the
</span><span>// code interacting with SnapTrade via the SnapTrade Go SDK
</span><span></span><span>func</span> <span>Handler</span>(cl *snaptradeclient.SnapTradeClient) server.ToolHandlerFunc {
	<span>return</span> <span>func</span>(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, <span>error</span>) {
		<span>// Note: This specific handler doesn&#39;t currently *use* the client,
</span><span></span>		<span>// but we adapt the signature for consistency and future use.
</span><span></span>		<span>return</span> mcp.<span>NewToolResultText</span>(<span>&#34;To get started with investing and portfolio management, please let us know which brokerage you have an account with. We can help you connect your account to any of the following brokerages: Trading212, Vanguard, Schwab, Alpaca, Alpaca Paper, Tradier, Robinhood, Fidelity, ETrade.&#34;</span>), <span>nil</span>
	}
}
</code></pre></div><p>Easy right? There isn’t much more to it. When you ask for information about brokerages or to check your portfolio value, Claude will now helpfully reply with the information we’ve gathered here. You can see what <code>snaptradeclient.SnapTradeClient</code> is and what it does <a href="https://github.com/dangelov/mcp-snaptrade/blob/main/internal/snaptradeclient/snaptrade.go">here on GitHub</a>, I’ve tried to leave plenty of comments to help you navigate the codebase.</p><p><img src="https://dangelov.com/blog/trading-with-claude/img/help.png" alt="Claude providing a helpful message on how to connect"/></p><h3 id="connect">Connect</h3><p>Naturally, next up is actually connecting to the brokerage of your choice. We again expose a tool to Claude via <code>go-mcp</code> along with a list of accepted strings as a sort of an enum. We’ll then reply with a link to SnapTrade’s connection portal, which allows you to easily and securely connect to the brokerage of your choice. I recommend Alpaca Paper for this demo due to its great paper trading capabilities and easy OAuth connection flow.</p><div><pre><code data-lang="go"><span>package</span> connect

<span>import</span> (
	<span>&#34;context&#34;</span>
	<span>&#34;fmt&#34;</span>

	<span>&#34;github.com/mark3labs/mcp-go/mcp&#34;</span>
	<span>&#34;github.com/mark3labs/mcp-go/server&#34;</span>

	<span>&#34;snaptrade.com/mcp-server/internal/snaptradeclient&#34;</span>
)

<span>var</span> Tool = mcp.<span>NewTool</span>(<span>&#34;connect_brokerage&#34;</span>,
	mcp.<span>WithDescription</span>(<span>&#34;Connect your brokerage account to see your portfolio and trades for that account.&#34;</span>),
	mcp.<span>WithString</span>(<span>&#34;brokerage&#34;</span>,
		mcp.<span>Required</span>(),
		mcp.<span>Description</span>(<span>&#34;The brokerage to connect to&#34;</span>),
		mcp.<span>Enum</span>(<span>&#34;Trading212&#34;</span>, <span>&#34;Vanguard&#34;</span>, <span>&#34;Schwab&#34;</span>, <span>&#34;Alpaca&#34;</span>, <span>&#34;Alpaca Paper&#34;</span>, <span>&#34;Tradier&#34;</span>, <span>&#34;Robinhood&#34;</span>, <span>&#34;Fidelity&#34;</span>, <span>&#34;ETrade&#34;</span>),
	),
)

<span>func</span> <span>Handler</span>(cl *snaptradeclient.SnapTradeClient) server.ToolHandlerFunc {
	<span>return</span> <span>func</span>(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, <span>error</span>) {
		brokerage, ok := request.Params.Arguments[<span>&#34;brokerage&#34;</span>].(<span>string</span>)
		<span>if</span> !ok {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Invalid brokerage&#34;</span>), <span>nil</span>
		}

        <span>// The SnapTrade API takes these slugs to pre-select the brokerage to connect to, so we need to map the user&#39;s choice to the correct slug.
</span><span></span>		nameToSlug := <span>map</span>[<span>string</span>]<span>string</span>{
			<span>&#34;Trading212&#34;</span>:   <span>&#34;TRADING212&#34;</span>,
			<span>&#34;Vanguard&#34;</span>:     <span>&#34;VANGUARD&#34;</span>,
			<span>&#34;Schwab&#34;</span>:       <span>&#34;SCHWAB&#34;</span>,
			<span>&#34;Alpaca&#34;</span>:       <span>&#34;ALPACA&#34;</span>,
			<span>&#34;Alpaca Paper&#34;</span>: <span>&#34;ALPACA-PAPER&#34;</span>,
			<span>&#34;Tradier&#34;</span>:      <span>&#34;TRADIER&#34;</span>,
			<span>&#34;Robinhood&#34;</span>:    <span>&#34;ROBINHOOD&#34;</span>,
			<span>&#34;Fidelity&#34;</span>:     <span>&#34;FIDELITY&#34;</span>,
			<span>&#34;ETrade&#34;</span>:       <span>&#34;ETRADE&#34;</span>,
		}
		slug, ok := nameToSlug[brokerage]
		<span>if</span> !ok {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Invalid brokerage&#34;</span>), <span>nil</span>
		}

        <span>// This calls our custom SnapTrade client and grabs a URL to present to
</span><span></span>        <span>// the user. They will then need to click it to connect.
</span><span></span>		redirectURI, err := cl.<span>LoginUserAndGetRedirectURI</span>(slug)
		<span>if</span> err != <span>nil</span> {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Failed to generate connection link for SnapTrade&#34;</span>), <span>nil</span>
		}

		<span>return</span> mcp.<span>NewToolResultText</span>(fmt.<span>Sprintf</span>(<span>&#34;To connect to %s, you must present this link to the user. Please note that it expires, so even if you&#39;ve shown it before, you need to show this new one:\n %s&#34;</span>, brokerage, redirectURI)), <span>nil</span>
	}
}
</code></pre></div><p><img src="https://dangelov.com/blog/trading-with-claude/img/connect.png" alt="Claude providing the link to connect"/></p><p>This is where user action is required and you will need to click the link and follow the instructions in order to connect your Alpaca Paper account. Once you’ve connected, go back to Claude to continue the conversation.</p><h3 id="checking-your-portfolio">Checking your portfolio</h3><p>This code might look a bit more complicated on first glance, but in reality:</p><ul><li>We’re pulling all of the accounts you’ve connected</li><li>Grouping them by institution</li><li>Providing a table with a list of positions held</li></ul><div><pre><code data-lang="go"><span>package</span> portfolio

<span>import</span> (
	<span>&#34;context&#34;</span>
	<span>&#34;fmt&#34;</span>

	<span>&#34;github.com/fbiville/markdown-table-formatter/pkg/markdown&#34;</span>
	<span>&#34;github.com/mark3labs/mcp-go/mcp&#34;</span>
	<span>&#34;github.com/mark3labs/mcp-go/server&#34;</span>
	st <span>&#34;github.com/passiv/snaptrade-sdks/sdks/go&#34;</span>

	<span>&#34;snaptrade.com/mcp-server/internal/snaptradeclient&#34;</span>
)

<span>var</span> Tool = mcp.<span>NewTool</span>(<span>&#34;portfolio&#34;</span>,
	mcp.<span>WithDescription</span>(<span>&#34;Check your portfolio and brokerage accounts for their positions and values.&#34;</span>)
)

<span>func</span> <span>Handler</span>(cl *snaptradeclient.SnapTradeClient) server.ToolHandlerFunc {
	<span>return</span> <span>func</span>(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, <span>error</span>) {
		<span>// Use the client method
</span><span></span>		response, err := cl.<span>ListUserAccounts</span>()
		<span>if</span> err != <span>nil</span> {
			fmt.<span>Println</span>(<span>&#34;Error retrieving accounts:&#34;</span>, err)
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Error retrieving accounts&#34;</span>), <span>nil</span>
		}
		<span>if</span> <span>len</span>(response) == <span>0</span> {
			fmt.<span>Println</span>(<span>&#34;No brokerage accounts connected&#34;</span>)
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;No brokerage accounts connected&#34;</span>), <span>nil</span>
		}

		reply := <span>&#34;Your connected brokerage accounts are:\n&#34;</span>

		<span>// Group the accounts by institution
</span><span></span>		accounts := <span>make</span>(<span>map</span>[<span>string</span>][]st.Account)
		<span>for</span> _, account := <span>range</span> response {
			institution := account.<span>GetInstitutionName</span>()
			<span>if</span> _, ok := accounts[institution]; !ok {
				accounts[institution] = []st.Account{}
			}
			accounts[institution] = <span>append</span>(accounts[institution], account)
		}

		<span>// Find all accounts
</span><span></span>		<span>for</span> institution, accountsList := <span>range</span> accounts {
			reply += fmt.<span>Sprintf</span>(<span>&#34;%s:\n&#34;</span>, institution)
			<span>for</span> _, account := <span>range</span> accountsList {
				marketValueDescription := <span>&#34;&#34;</span>
				<span>if</span> account.Balance.<span>GetTotal</span>().Amount != <span>nil</span> &amp;&amp; account.Balance.<span>GetTotal</span>().Currency != <span>nil</span> {
					marketValue := *account.Balance.<span>GetTotal</span>().Amount
					marketValueCurrency := *account.Balance.<span>GetTotal</span>().Currency
					marketValueDescription = fmt.<span>Sprintf</span>(<span>&#34;(value including cash: %.2f %s)&#34;</span>, marketValue, marketValueCurrency)
				}
				reply += fmt.<span>Sprintf</span>(<span>&#34;%s %s\n\nPlease show this markdown formatted table of all the positions under this account\n\n&#34;</span>, *account.Name.<span>Get</span>(), marketValueDescription)

				<span>// Now get all the positions for this account using the client method
</span><span></span>				positions, err := cl.<span>GetUserAccountPositions</span>(account.Id)
				<span>if</span> err != <span>nil</span> {
					fmt.<span>Println</span>(<span>&#34;Error retrieving positions for account&#34;</span>, account.Name, <span>&#34;:&#34;</span>, err)
					<span>continue</span> <span>// Or add an error message to the reply
</span><span></span>				}
				<span>if</span> <span>len</span>(positions) == <span>0</span> {
					reply += fmt.<span>Sprintf</span>(<span>&#34;  - No positions found for account %s\n&#34;</span>, *account.Name.<span>Get</span>())
					<span>continue</span>
				} <span>else</span> {
					tableData := <span>make</span>([][]<span>string</span>, <span>len</span>(positions))
					<span>for</span> i, position := <span>range</span> positions {
						tableData[i] = []<span>string</span>{
							position.Symbol.Symbol.Symbol,
							fmt.<span>Sprintf</span>(<span>&#34;%.4f&#34;</span>, *position.Units.<span>Get</span>()),
							fmt.<span>Sprintf</span>(<span>&#34;%.2f %s&#34;</span>, *position.Price.<span>Get</span>()**position.Units.<span>Get</span>(), *position.Symbol.Symbol.Currency.Code),
						}
					}

					basicTable, err := markdown.<span>NewTableFormatterBuilder</span>().
						<span>Build</span>(<span>&#34;Instrument&#34;</span>, <span>&#34;Units&#34;</span>, <span>&#34;Value&#34;</span>).
						<span>Format</span>(tableData)
					<span>if</span> err != <span>nil</span> {
						fmt.<span>Println</span>(<span>&#34;Error creating table:&#34;</span>, err)
						<span>continue</span> <span>// Or add an error message to the reply
</span><span></span>					}
					<span>// Add the table to the reply
</span><span></span>					reply += fmt.<span>Sprintf</span>(<span>&#34;%s\n&#34;</span>, basicTable)
				}
			}
		}

		fmt.<span>Println</span>(reply)
		<span>return</span> mcp.<span>NewToolResultText</span>(reply), <span>nil</span>
	}
}
</code></pre></div><p><img src="https://dangelov.com/blog/trading-with-claude/img/portfolio.png" alt="result of call to portfolio"/></p><h3 id="making-a-trade">Making a trade</h3><p>Now we get to the part that’s most exciting. I intentionally kept the list trading options and configuration simple in the MCP server, but you could easily extend it by looking at the relevant docs for <a href="https://docs.snaptrade.com/reference/Trading/Trading_placeForceOrder">placing a trade on SnapTrade</a>.</p><p>Apart from doing some basic validation, we shoot over all the data we got directly to SnapTrade via the SDK and let it take care of it.</p><div><pre><code data-lang="go"><span>package</span> trades

<span>import</span> (
	<span>&#34;context&#34;</span>
	<span>&#34;fmt&#34;</span>

	<span>&#34;github.com/mark3labs/mcp-go/mcp&#34;</span>
	<span>&#34;github.com/mark3labs/mcp-go/server&#34;</span>

	<span>&#34;snaptrade.com/mcp-server/internal/snaptradeclient&#34;</span> <span>// Use snaptradeclient instead of snaptrade
</span><span></span>)

<span>var</span> Tool = mcp.<span>NewTool</span>(<span>&#34;place_order&#34;</span>,
	mcp.<span>WithDescription</span>(<span>&#34;Place an order with your brokerage account&#34;</span>),
	mcp.<span>WithString</span>(<span>&#34;brokerage&#34;</span>,
		mcp.<span>Required</span>(),
		mcp.<span>Description</span>(<span>&#34;The brokerage to place an order with&#34;</span>),
		mcp.<span>Enum</span>(<span>&#34;Trading212&#34;</span>, <span>&#34;Vanguard&#34;</span>, <span>&#34;Schwab&#34;</span>, <span>&#34;Alpaca&#34;</span>, <span>&#34;Alpaca Paper&#34;</span>, <span>&#34;Tradier&#34;</span>, <span>&#34;Robinhood&#34;</span>, <span>&#34;Fidelity&#34;</span>, <span>&#34;ETrade&#34;</span>),
	),
	mcp.<span>WithString</span>(<span>&#34;action&#34;</span>,
		mcp.<span>Required</span>(),
		mcp.<span>Description</span>(<span>&#34;The action to perform (BUY/SELL)&#34;</span>),
		mcp.<span>Enum</span>(<span>&#34;BUY&#34;</span>, <span>&#34;SELL&#34;</span>),
	),
	mcp.<span>WithString</span>(<span>&#34;ticker&#34;</span>,
		mcp.<span>Required</span>(),
		mcp.<span>Description</span>(<span>&#34;The ticker symbol of the stock&#34;</span>),
	),
	mcp.<span>WithNumber</span>(<span>&#34;quantity&#34;</span>,
		mcp.<span>Required</span>(),
		mcp.<span>Description</span>(<span>&#34;The quantity of shares to buy/sell&#34;</span>),
	),
)

<span>func</span> <span>Handler</span>(cl *snaptradeclient.SnapTradeClient) server.ToolHandlerFunc {
	<span>return</span> <span>func</span>(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, <span>error</span>) {
		brokerage, ok := request.Params.Arguments[<span>&#34;brokerage&#34;</span>].(<span>string</span>)
		<span>if</span> !ok {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Invalid brokerage&#34;</span>), <span>nil</span>
		}
		action, ok := request.Params.Arguments[<span>&#34;action&#34;</span>].(<span>string</span>)
		<span>if</span> !ok {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Invalid action&#34;</span>), <span>nil</span>
		}
		ticker, ok := request.Params.Arguments[<span>&#34;ticker&#34;</span>].(<span>string</span>)
		<span>if</span> !ok {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Invalid ticker&#34;</span>), <span>nil</span>
		}
		quantity, ok := request.Params.Arguments[<span>&#34;quantity&#34;</span>].(<span>float64</span>)
		<span>if</span> !ok {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Invalid quantity&#34;</span>), <span>nil</span>
		}
		quantityFloat := <span>float32</span>(quantity)

		<span>// Use the client method
</span><span></span>		response, err := cl.<span>ListUserAccounts</span>()
		<span>if</span> err != <span>nil</span> {
			fmt.<span>Println</span>(<span>&#34;Error retrieving accounts:&#34;</span>, err)
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;Error retrieving accounts&#34;</span>), <span>nil</span> <span>// Return error to MCP
</span><span></span>		}
		<span>if</span> <span>len</span>(response) == <span>0</span> {
			<span>return</span> mcp.<span>NewToolResultError</span>(<span>&#34;No brokerage accounts connected&#34;</span>), <span>nil</span>
		}

		accountId := <span>&#34;&#34;</span>
		<span>for</span> _, account := <span>range</span> response {
			<span>if</span> account.<span>GetInstitutionName</span>() == brokerage {
				accountId = account.Id
				<span>break</span> <span>// Found the account
</span><span></span>			}
		}
		<span>if</span> accountId == <span>&#34;&#34;</span> {
			<span>return</span> mcp.<span>NewToolResultError</span>(fmt.<span>Sprintf</span>(<span>&#34;No matching account found for brokerage: %s&#34;</span>, brokerage)), <span>nil</span>
		}

		<span>// Use the client method
</span><span></span>		orderRecord, err := cl.<span>PlaceForceOrder</span>(accountId, action, ticker, quantityFloat)
		<span>if</span> err != <span>nil</span> {
			fmt.<span>Println</span>(<span>&#34;Error placing order:&#34;</span>, err)
			<span>return</span> mcp.<span>NewToolResultError</span>(fmt.<span>Sprintf</span>(<span>&#34;Error placing order: %s&#34;</span>, err.<span>Error</span>())), <span>nil</span> <span>// Return error to MCP
</span><span></span>		}

		<span>return</span> mcp.<span>NewToolResultText</span>(fmt.<span>Sprintf</span>(<span>&#34;Order placed successfully: %s. You can monitor the status of your order by asking me to show your recent orders.&#34;</span>, *orderRecord.BrokerageOrderId)), <span>nil</span>
	}
}
</code></pre></div><p>As shown at the beginning of this blog post, here’s what that might look like.</p><p><img src="https://dangelov.com/blog/trading-with-claude/img/trade-executed.png" alt="Claude executing a trade via SnapTrade"/></p><h2 id="caveats-and-downsides">Caveats and downsides</h2><p><strong>Be careful</strong> when placing trades or performing any sort of high-impact actions through an LLM like Claude. While this worked well on most attempts, there was a couple of times during testing where it failed to place a trade, and then it kept trying to place ever-higher quantity trades - eg: instead of 1 share, it tried to buy 2, then 3 - on it’s own. So you could potentially end up placing orders that you didn’t intend to.</p><p>Similarly, due to the unpredictable nature of LLMs, I couldn’t get a 100% hit rate when trying to get the connect a brokerage link to show - it kept saying it already showed it instead of just displaying the new one. So there’s definitely some bugs and kinks to work out if you do decide to connect an LLM to a tool like this.</p><h3 id="what-next">What next?</h3><p>The sample MCP server also has a tool to check recent orders, but I won’t bore you with the code in this very blog post - you can head over to the <a href="https://github.com/dangelov/mcp-snaptrade/">snaptrade-mcp GitHub repo</a> and check it all out for yourself.</p><p>MCP is a powerful tool that can be used to build a wide range of applications. It is still in its early stages, but it has the potential to revolutionize the way we build applications and offer serviecs - as long as we’re aware of it’s limitations.</p></section></div>
  </body>
</html>
