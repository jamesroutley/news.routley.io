<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/formal-land/coq-of-rust">Original</a>
    <h1>Coq-of-rust: Formal verification tool for Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<blockquote>
<p dir="auto">Formal verification tool for Rust: check 100% of execution cases of your programs 🦀 to make applications with no bugs! <g-emoji alias="airplane">✈️</g-emoji> 🚀 ⚕️ 🏦</p>
</blockquote>
<p dir="auto">Even if Rust&#39;s type system prevents many mistakes, including memory errors, the code is still not immune to vulnerabilities, such as unexpected panics or wrongly implemented business rules.</p>
<p dir="auto">The way to go further is to <strong>mathematically</strong> prove that it is bug-free: this is named &#34;formal verification&#34; and what <code>coq-of-rust</code> proposes! This is the only way to ensure your code contains no bugs or vulnerabilities, even against state-level actors 🧚.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>We propose formal verification as a service, including designing the specification and the proofs.</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto"><em>The development of <code>coq-of-rust</code> was mainly funded by the <a href="https://alephzero.org/" rel="nofollow">Aleph Zero Foundation</a>. We thank them for their support!</em></p>

<ul dir="auto">
<li><a href="#example">Example</a></li>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#installation-and-user-guide">Installation and User Guide</a></li>
<li><a href="#language-features">Features</a></li>
<li><a href="#contact">Contact</a></li>
<li><a href="#alternative-projects">Alternative Projects</a></li>
<li><a href="#contributing">Contributing</a></li>
</ul>

<p dir="auto">At the heart of <code>coq-of-rust</code> is the translation of Rust programs to the <a href="https://coq.inria.fr/" rel="nofollow">proof system Coq 🐓</a>. Once some Rust code is translated to Coq, it can then be verified using standard proof techniques.</p>
<p dir="auto">Here is an example of a Rust function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="fn add_one(x: u32) -&gt; u32 {
    x + 1
}"><pre><span>fn</span> <span>add_one</span><span>(</span><span>x</span><span>:</span> <span>u32</span><span>)</span> -&gt; <span>u32</span> <span>{</span>
    x + <span>1</span>
<span>}</span></pre></div>
<p dir="auto">Running <code>coq-of-rust</code>, it translates in Coq to:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Definition add_one (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ x ] =&gt;
    ltac:(M.monadic
      (let x := M.alloc (| x |) in
      BinOp.Panic.add (| M.read (| x |), Value.Integer Integer.U32 1 |)))
  | _, _ =&gt; M.impossible
  end."><pre><span>Definition</span> add_one (τ : list Ty.t) (α : list Value.t) : M :=
  <span>match</span> τ, α <span>with</span>
  | [], [ x ] =&gt;
    ltac:(M.monadic
      (<span>let</span> x := M.alloc (| x |) <span>in</span>
      BinOp.Panic.add (| M.read (| x |), Value.Integer Integer.U32 1 |)))
  | _, _ =&gt; M.impossible
  <span>end</span>.</pre></div>
<p dir="auto">Functions such as <code>BinOp.Panic.add</code> are part of the standard library for Rust in Coq that we provide. We can then express and verify specifications on the code in Coq.</p>

<p dir="auto">Here is the typical workflow of usage for <code>coq-of-rust</code>:</p>
<section data-identity="31d1446f-e656-4cb7-9965-d506ce892924" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div data-json="{&#34;data&#34;:&#34;graph TB\n    R[Rust code 🦀] -- coq-of-rust --&amp;gt; T[Translated code 🐓]\n    T -- name resolutions --&amp;gt; L[Linked code 🐓]\n    L -- refinement --&amp;gt; S[Simulations 🐓]\n    S --&amp;gt; P\n    SP[Specifications 🐓] --&amp;gt; P[Proofs 🐓]\n    P -.-&amp;gt; X[100% reliable code! 🦄]\n&#34;}" data-plain="graph TB
    R[Rust code 🦀] -- coq-of-rust --&gt; T[Translated code 🐓]
    T -- name resolutions --&gt; L[Linked code 🐓]
    L -- refinement --&gt; S[Simulations 🐓]
    S --&gt; P
    SP[Specifications 🐓] --&gt; P[Proofs 🐓]
    P -.-&gt; X[100% reliable code! 🦄]
" dir="auto">
    <div dir="auto">
      <pre lang="mermaid" aria-label="Raw mermaid code">graph TB
    R[Rust code 🦀] -- coq-of-rust --&gt; T[Translated code 🐓]
    T -- name resolutions --&gt; L[Linked code 🐓]
    L -- refinement --&gt; S[Simulations 🐓]
    S --&gt; P
    SP[Specifications 🐓] --&gt; P[Proofs 🐓]
    P -.-&gt; X[100% reliable code! 🦄]
</pre>
    </div>
  </div>
  <span role="presentation">
    <span data-view-component="true">
  <svg style="box-sizing: content-box; color: var(--color-icon-primary);" width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" data-view-component="true">
    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-opacity="0.25" stroke-width="2" vector-effect="non-scaling-stroke" fill="none"></circle>
    <path d="M15 8a7.002 7.002 0 00-7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"></path>
</svg>    <span>Loading</span>
</span>
  </span>
</section>

<p dir="auto">We start by generating an automatic translation of the Rust we verify to Coq code with <code>coq-of-rust</code>. The translation is originally verbose. We go through two semi-automated refinement steps, links and simulations, that gradually make the code more amenable to formal verification.</p>
<p dir="auto">Finally, we write the <strong>specifications</strong> and <strong>prove</strong> that our Rust program fulfills them <strong>with any possible user input 🔥</strong>.</p>
<p dir="auto">Examples of typical specifications are:</p>
<ul dir="auto">
<li>The code cannot panic.</li>
<li>This clever data structure is equivalent to its naive version, except for the execution time.</li>
<li>This new release, which introduces new endpoints and does a lot of refactoring, is fully backward-compatible with the previous version.</li>
<li>Data invariants are properly preserved.</li>
<li>The storage system is sound, as what goes in goes out (this generally amounts to state that the serialization/deserialization functions are inverse).</li>
<li>The implementation behaves as a special case of what the whitepaper describes once formally expressed.</li>
</ul>
<p dir="auto"><strong>With that in hand, you can virtually reduce your bugs and vulnerabilities to zero 🦸!</strong></p>

<p dir="auto">Formal verification allows the prevention of all bugs in critical software.</p>
<p dir="auto">The type system of Rust already offers strong guarantees to avoid bugs that exist in C or Python. We still need to write tests to verify the business rules or the absence of <code>panic</code>. Testing is incomplete as it cannot cover all execution cases.</p>
<p dir="auto">With formal verification, we cover all cases (code 100% bug-free!). We replace the tests with mathematical reasoning on code. You can view it as an extension of the type system but without restrictions on the expressivity.</p>
<p dir="auto">The tool <code>coq-of-rust</code> translates Rust programs to the battle-tested formal verification system Coq to make Rust programs 100% safe 🚀.</p>

<ul dir="auto">
<li>Rust</li>
<li>Coq (see <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/coq-of-rust.opam">coq-of-rust.opam</a>)</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Installation and User Guide</h2><a id="user-content-installation-and-user-guide" aria-label="Permalink: Installation and User Guide" href="#installation-and-user-guide"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <a href="https://github.com/formal-land/coq-of-rust/blob/main/docs/BUILD.md">build tutorial</a> provides detailed instructions on building and installing <code>coq-of-rust</code>, while the <a href="https://github.com/formal-land/coq-of-rust/blob/main/docs/GUIDE.md">user tutorial</a> provides an introduction to the <code>coq-of-rust</code> command line interface and the list of supported options.</p>

<p dir="auto">The translation works at the level of the <a href="https://rustc-dev-guide.rust-lang.org/thir.html" rel="nofollow">THIR</a> intermediate representation of Rust.</p>
<p dir="auto">We support 99% of the Rust examples from the <a href="https://doc.rust-lang.org/rust-by-example/" rel="nofollow">Rust Book by Examples</a>. This includes:</p>
<ul dir="auto">
<li>basic control structures (like <code>if</code> and <code>match</code>)</li>
<li>loops (<code>while</code> and <code>for</code>)</li>
<li>references and mutability (<code>&amp;</code> and <code>&amp;mut</code>)</li>
<li>closures</li>
<li>panics</li>
<li>user types (with <code>struct</code> and <code>enum</code>)</li>
<li>the definition of traits</li>
<li>the implementation keyword <code>impl</code> for traits or user types</li>
</ul>

<p dir="auto">For formal verification services on your Rust code base, contact us at <a href="mailto:contact@formal.land">contact@formal.land</a>. Formal verification can apply to smart contracts, database engines, or any critical Rust project. This provides the highest confidence level in the absence of bugs compared to other techniques, such as manual reviews or testing.</p>

<p dir="auto">Here are other projects working on formal verification for Rust:</p>
<ul dir="auto">
<li><a href="https://github.com/AeneasVerif/aeneas">Aeneas</a>: Translation from MIR to purely functional Coq/F* code. Automatically put the code in a functional form. See their paper <a href="https://dl.acm.org/doi/abs/10.1145/3547647" rel="nofollow">Aeneas: Rust verification by functional translation</a>.</li>
<li><a href="https://github.com/hacspec/hacspec-v2">Hacspec v2</a>: Translation from THIR to Coq/F* code</li>
<li><a href="https://github.com/xldenis/creusot">Creusot</a>: Translation from MIR to Why3 (and then SMT solvers)</li>
<li><a href="https://github.com/verus-lang/verus">Verus</a>: Automatic verification for Rust with annotations</li>
<li><a href="https://github.com/model-checking/kani">Kani</a>: Model-checking with <a href="https://github.com/diffblue/cbmc">CBMC</a></li>
</ul>

<p dir="auto">This is all open-source software.</p>
<p dir="auto">Open some pull requests or issues to contribute to this project. All contributions are welcome! This project is open-source under license AGPL for the Rust code (the translator) and MIT for the Coq libraries. There is a bit of code taken from the <a href="https://github.com/xldenis/creusot">Creusot</a> project to make the Cargo command <code>coq-of-rust</code> and run the translation in the same context as Cargo.</p>
</article></div></div>
  </body>
</html>
