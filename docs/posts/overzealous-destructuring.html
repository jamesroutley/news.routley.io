<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.aleksandrhovhannisyan.com/blog/overzealous-destructuring/">Original</a>
    <h1>Overzealous Destructuring</h1>
    
    <div id="readability-page-1" class="page"><div id="page-content">
  
<article>
  
  <div>
    <p>Back when I first learned about destructuring in ES6 JavaScript—and its close siblings, the rest and spread syntax—I did what many other developers do when they learn a new trick: I used it everywhere, trying to cram this newfound square peg into every round hole I stumbled upon. Somehow, I had come to equate destructuring with clean code, and anything that required more typing was unequivocally worse and had to be refactored to destructure All The Things. This was the way:</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span><span>{</span>
  <span>prop</span><span>:</span> <span>{</span>
    <span>nestedProperty</span><span>:</span> <span>{</span>
      <span>wow</span><span>:</span> <span>{</span> <span>this</span><span>:</span> isKindaHardToRead <span>}</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span><span>}</span><span>;</span>
</code></pre>
<p>Nowadays, I’m not quite so fond of destructuring. It certainly has its uses, but it can also cause problems if not used carefully. I’ve found that destructuring is most effective when the unpacked variables are in close proximity to their usage or when the alternative is harder to read. In the next few sections, we’ll explore some of the problems with what I’ll call <em>overzealous destructuring</em>.</p>

<h2 id="table-of-contents">Table of Contents</h2>
<nav id="toc"><ol><li><a href="#destructuring-makes-it-harder-to-identify-a-variables-scope">Destructuring Makes It Harder to Identify a Variable’s Scope</a><ol><li><a href="#destructuring-may-introduce-naming-clashes">Destructuring May Introduce Naming Clashes</a></li></ol></li><li><a href="#destructuring-deeply-nested-properties-harms-readability">Destructuring Deeply Nested Properties Harms Readability</a></li><li><a href="#destructuring-potentially-nullish-values-is-dangerous">Destructuring Potentially Nullish Values Is Dangerous</a></li><li><a href="#destructuring-makes-it-harder-to-debug-object-arguments">Destructuring Makes It Harder to Debug Object Arguments</a></li><li><a href="#destructuring-makes-it-harder-to-rename-symbols-in-typescript">Destructuring Makes it Harder to Rename Symbols in TypeScript</a></li><li><a href="#when-its-okay-to-destructure">When It’s Okay to Destructure</a><ol><li><a href="#1-named-imports-in-commonjs">1. Named Imports in CommonJS</a></li><li><a href="#2-arrays">2. Arrays</a></li><li><a href="#3-small-functions">3. Small Functions</a></li></ol></li><li><a href="#everything-in-moderation">Everything in Moderation</a></li><li><a href="#attributions">Attributions</a></li></ol></nav>
<h2 id="destructuring-makes-it-harder-to-identify-a-variables-scope"><a href="#destructuring-makes-it-harder-to-identify-a-variables-scope">Destructuring Makes It Harder to Identify a Variable’s Scope</a></h2>
<p>Programming languages like C++ have a construct known as a <strong>namespace</strong>—a region of code that encapsulates identifiers, preventing them from leaking into the global scope. You can access a namespace’s identifiers with the reserved namespace operator, like this: <code>Namespace1::variable</code>. Namespacing is really important in big projects because it helps you identify where a particular symbol is coming from. But more importantly, it helps you avoid naming clashes in case two different namespaces happen to use the same name for their variables: <code>Namespace1::variable</code> versus <code>Namespace2::variable</code>.</p>
<p>In C++, there’s also a bad programming practice that is basically analogous to destructuring arguments in JavaScript functions: declaring which namespaces you intend to use at the very top of your file. You’d declare <code>using namespace Namespace1</code>, and this would save you quite a bit of typing because you would no longer have to prefix all your variable usages with their corresponding namespace. Instead, you could use them directly, as if they were declared outside the namespace.</p>

<p>Similarly, destructuring can be very tempting in JavaScript because it helps you save some typing, and anything that makes our lives easier must be good. When you destructure arguments in JavaScript, you don’t have to repeat yourself like you do here:</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>;</span>
</code></pre>
<p>Instead, you can can do this:</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span><span>{</span> arg1<span>,</span> arg2<span>,</span> arg3 <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>;</span>
</code></pre>
<p>We’ve all heard that DRY code is good, but this is entirely dependent on context. Sometimes, those few extra keystrokes are worth it, and repeating yourself isn’t so bad after all.</p>
<p>The first problem with destructuring is that it strips object properties of their namespace, making it harder to tell, at a glance, where a particular variable is coming from. Was it declared globally in the module? Imported from another module? Passed in as a function argument? Declared as a local variable in the function’s scope?</p>
<p>Compare this:</p>
<pre><code><span>import</span> <span>{</span> a<span>,</span> b <span>}</span> <span>from</span> <span>&#39;module&#39;</span><span>;</span>

<span>const</span> g <span>=</span> <span>&#39;global variable&#39;</span><span>;</span>

<span>const</span> <span>function</span> <span>=</span> <span>(</span><span><span>{</span> c<span>,</span> d<span>,</span> e <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> l <span>=</span> <span>&#39;local-variable&#39;</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>c<span>,</span> d<span>,</span> e<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>To this:</p>
<pre><code><span>import</span> <span>{</span> a<span>,</span> b <span>}</span> <span>from</span> <span>&#39;module&#39;</span><span>;</span>

<span>const</span> g <span>=</span> <span>&#39;global variable&#39;</span><span>;</span>

<span>const</span> <span>function</span> <span>=</span> <span>(</span><span>args</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> l <span>=</span> <span>&#39;local-variable&#39;</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>args<span>.</span>c<span>,</span> args<span>.</span>d<span>,</span> args<span>.</span>e<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>

<p>Especially in large functions and modules, this sort of namespacing can make your code much easier to follow. You may not think this is a big deal if you’re the one writing the code, but you have to remember that other developers may one day have to read your code, too. Don’t use clever tricks that sacrifice readability for speed.</p>
<h3 id="destructuring-may-introduce-naming-clashes"><a href="#destructuring-may-introduce-naming-clashes">Destructuring May Introduce Naming Clashes</a></h3>
<p>I mentioned that namespaces can help you avoid <strong>naming clashes</strong> in other programming languages, and the same actually goes for function arguments in JavaScript. When you destructure function arguments, you make it harder to reuse the same variable names for final and intermediate values elsewhere in the function.</p>
<p>For example, if you’re creating a React component, you might want to derive some state from props. This pattern is common in modals, where users are allowed to discard their changes but the initial state needs to be populated from some persisted data that comes in via props:</p>
<pre><code><span>const</span> <span>Modal</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>value<span>,</span> setValue<span>]</span> <span>=</span> <span>useState</span><span>(</span>props<span>.</span>value<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>If we destructure the prop, we’ll need to rename either that prop or the state variable (or both) to avoid naming clashes:</p>
<pre><code>
<span>const</span> <span>Modal</span> <span>=</span> <span>(</span><span><span>{</span> initialValue <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>value<span>,</span> setvalue<span>]</span> <span>=</span> <span>useState</span><span>(</span>initialValue<span>)</span><span>;</span>
<span>}</span><span>;</span>


<span>const</span> <span>Modal</span> <span>=</span> <span>(</span><span><span>{</span> <span>value</span><span>:</span> initialValue <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>value<span>,</span> setvalue<span>]</span> <span>=</span> <span>useState</span><span>(</span>initialValue<span>)</span><span>;</span>
<span>}</span><span>;</span>


<span>const</span> <span>Modal</span> <span>=</span> <span>(</span><span><span>{</span> value <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>tempValue<span>,</span> setTempValue<span>]</span> <span>=</span> <span>useState</span><span>(</span>props<span>.</span>value<span>)</span><span>;</span>
<span>}</span><span>;</span>


<span>const</span> <span>Modal</span> <span>=</span> <span>(</span><span><span>{</span> initialValue <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>tempValue<span>,</span> setTempValue<span>]</span> <span>=</span> <span>useState</span><span>(</span>props<span>.</span>initialValue<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>Admittedly, this particular example isn’t so bad. But there are other situations where these sorts of compromises can hurt the readability of your code, forcing you to rename multiple variables until you no longer recognize what values are coming from which sources, or until the variable names are unnecessarily verbose compared to when they were namespaced. <code>varProp</code> is no more readable than <code>props.var</code>.</p>
<h2 id="destructuring-deeply-nested-properties-harms-readability"><a href="#destructuring-deeply-nested-properties-harms-readability">Destructuring Deeply Nested Properties Harms Readability</a></h2>
<p>Just because you can do something doesn’t mean that you should. In JavaScript, you can destructure not only the direct properties of an object but also any deeply nested properties, like this:</p>
<pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span><span>{</span>
  <span>a</span><span>:</span> <span>{</span>
    <span>deeply</span><span>:</span> <span>{</span>
      <span>nested</span><span>:</span> <span>{</span> variable <span>}</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>variable<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>This saves you a few keystrokes at the expense of making your function signature much more noisy and difficult to parse. Compare that to the following code, which, despite requiring more effort to type out per usage, is easier to read:</p>
<pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>props<span>.</span>a<span>.</span>deeply<span>.</span>nested<span>.</span>variable<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<h2 id="destructuring-potentially-nullish-values-is-dangerous"><a href="#destructuring-potentially-nullish-values-is-dangerous">Destructuring Potentially Nullish Values Is Dangerous</a></h2>
<p>We saw in the previous section that destructuring deeply nested properties makes your code harder to read. But that’s not the only problem. A more insidious problem is that destructuring nullish or undefined objects is dangerous and will throw an uncaught runtime error:</p>
<pre><code>Uncaught TypeError: Cannot read properties of null
</code></pre>
<p>This can become a rather nasty source of bugs in your code base if you’re not careful, especially if you’re frequently destructuring object properties.</p>
<p>One of the nice things about accessing object properties the old-fashioned way is that we can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" target="_blank" rel="noreferrer noopener">optional chaining operator</a> (<code>?.</code>) to safeguard against potentially <a href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish" target="_blank" rel="noreferrer noopener">nullish values</a> while preserving the readability of our code:</p>
<pre><code><span>const</span> value <span>=</span> object<span>?.</span>with<span>?.</span>nested<span>?.</span>properties<span>;</span>
</code></pre>
<p>In the above expression, <code>value</code> will evaluate to the value of <code>properties</code> if the object and all of its intermediate properties are non-nullish. But if the object or any of its properties is nullish, the entire expression will return <code>undefined</code> without throwing any errors. This allows us to safely access deeply nested object properties without checking each property individually. The above code is equivalent to doing this:</p>
<pre><code><span>const</span> value <span>=</span>
  object <span>&amp;&amp;</span> object<span>.</span>with <span>&amp;&amp;</span> object<span>.</span>with<span>.</span>nested
    <span>?</span> object<span>.</span>with<span>.</span>nested<span>.</span>properties
    <span>:</span> <span>undefined</span><span>;</span>
</code></pre>
<p>On the other hand, if we destructure those properties, we run into several problems. First, we have no (good) way of safeguarding against nullish values other than using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" target="_blank" rel="noreferrer noopener">nullish coalescing operator</a> (<code>??</code>):</p>
<pre><code><span>const</span> fallback <span>=</span> <span>{</span> <span>with</span><span>:</span> <span>{</span> <span>nested</span><span>:</span> <span>{</span><span>}</span> <span>}</span> <span>}</span><span>;</span>
<span>const</span> object <span>=</span> <span>undefined</span><span>;</span>
<span>const</span> <span>{</span>
  <span>with</span><span>:</span> <span>{</span>
    <span>nested</span><span>:</span> <span>{</span> properties <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span> <span>=</span> object <span>??</span> fallback<span>;</span>
</code></pre>
<p>This says: Attempt to destructure the deeply nested <code>properties</code> property from the object. If the object is nullish, fall back to an object containing all properties except the one that we want. This means that <code>properties</code> is the value if it exists or <code>undefined</code> (because the fallback <code>nested</code> object has no properties, so <code>fallback.with.nested.properties</code> is <code>undefined</code>).</p>
<p>Except… what if the object <em>is</em> defined but one of its intermediate properties isn’t?</p>
<pre><code><span>const</span> fallback <span>=</span> <span>{</span> <span>with</span><span>:</span> <span>{</span> <span>nested</span><span>:</span> <span>{</span><span>}</span> <span>}</span> <span>}</span><span>;</span>
<span>const</span> object <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>const</span> <span>{</span>
  <span>with</span><span>:</span> <span>{</span>
    <span>nested</span><span>:</span> <span>{</span> properties <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span> <span>=</span> object <span>??</span> fallback<span>;</span>
</code></pre>
<p>Because <code>object.with</code> is <code>undefined</code>, attempting to access <code>object.with.nested</code> will throw the same type error:</p>
<pre><code>Uncaught TypeError: Cannot read properties of undefined (reading &#39;nested&#39;)
</code></pre>
<p>The version with destructuring is <em>significantly</em> more complex and error prone than the original, and it sacrifices the readability of our code for absolutely no gain. It’s riddled with traps that can catch you off guard if you’re not careful, and its syntax is far more verbose than it needs to be.</p>
<p>The code is also not the same as the original! In the original example, we named the final variable <code>value</code>. If we want to rename the deeply nested property while destructuring it, we’ll need to do so during assignment. This only exacerbates the readability problem:</p>
<pre><code><span>const</span> fallback <span>=</span> <span>{</span> <span>with</span><span>:</span> <span>{</span> <span>nested</span><span>:</span> <span>{</span><span>}</span> <span>}</span> <span>}</span><span>;</span>
<span>const</span> <span>{</span>
  <span>with</span><span>:</span> <span>{</span>
    <span>nested</span><span>:</span> <span>{</span> <span>properties</span><span>:</span> value <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span> <span>=</span> object <span>??</span> fallback<span>;</span>
</code></pre>
<p>After all of this, you might think that TypeScript would help you avoid this problem entirely by warning you whenever you drill deep into a chain of potentially nullish properties. And it will. But it’s important to remember that TypeScript does not provide any assurances about a variable’s <em>runtime</em> type, especially if the data is coming from an external source (like an API). In those cases, you often need to use type assertions or guards anyway to assert the returned type because TypeScript can’t infer the type of dynamically fetched data. So destructuring the data is more dangerous than defensive coding (like using the optional chaining operator or good-old <code>if</code> statements).</p>
<h2 id="destructuring-makes-it-harder-to-debug-object-arguments"><a href="#destructuring-makes-it-harder-to-debug-object-arguments">Destructuring Makes It Harder to Debug Object Arguments</a></h2>
<p>Occasionally, when debugging functions, I find it helpful to stick a <code>debugger</code> statement on the first line or log out the arguments manually to verify that the function is receiving the correct data:</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>props<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>But when you destructure function arguments in the signature, you make it impossible to see the whole object unless you log each piece exhaustively.</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span><span>{</span> arg1<span>,</span> arg2<span>,</span> arg3<span>,</span> <span>...</span>others <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>arg1<span>,</span> arg2<span>,</span> arg3<span>,</span> others<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>If you’re going to do this, at least destructure the arguments in the body of the function:</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>props</span><span>`</span></span><span>,</span> props<span>)</span><span>;</span>

  
  <span>const</span> <span>{</span> arg1<span>,</span> arg2<span>,</span> arg3<span>,</span> <span>...</span>others <span>}</span> <span>=</span> props<span>;</span>
<span>}</span>
</code></pre>
<p>That way, you still see the full context but can destructure the arguments if the component is small enough.</p>
<p>However, keep in mind all the other problems mentioned so far about destructuring. In my experience, the amount of typing saved from destructuring is not worth the cost.</p>
<h2 id="destructuring-makes-it-harder-to-rename-symbols-in-typescript"><a href="#destructuring-makes-it-harder-to-rename-symbols-in-typescript">Destructuring Makes it Harder to Rename Symbols in TypeScript</a></h2>
<p>In TypeScript projects, if you rename a prop that’s being destructured somewhere in your code, VS Code won’t rename the destructured variable; instead, it will use the old name as an alias. <a href="https://github.com/microsoft/TypeScript/issues/29238" target="_blank" rel="noreferrer noopener">This was a known issue for a long time</a> until VS Code eventually introduced some editor-level settings to get around it.</p>
<p>Suppose you had this code originally:</p>
<pre><code><span>type</span> <span>Props</span> <span>=</span> <span>{</span>
  oldName<span>?</span><span>:</span> <span>string</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> <span>function</span> <span>=</span> <span>(</span><span>{</span> oldName <span>}</span><span>:</span> Props<span>)</span> <span>=&gt;</span> <span>{</span><span>}</span><span>;</span>
</code></pre>
<p>If you now decide to rename <code>oldName</code>, VS Code will alias <code>newName</code> to <code>oldName</code>:</p>
<pre><code><span>type</span> <span>Props</span> <span>=</span> <span>{</span>
  newName<span>?</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>

<span>const</span> <span>function</span> <span>=</span> <span>(</span><span>{</span> newName<span>:</span> oldName <span>}</span><span>:</span> Props<span>)</span> <span>=&gt;</span> <span>{</span><span>}</span><span>;</span>
</code></pre>
<p>You don’t run into this issue with properly namespaced props because there’s no aliasing to be done:</p>
<pre><code><span>type</span> <span>Props</span> <span>=</span> <span>{</span>
  newName<span>?</span><span>:</span> <span>string</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> <span>function</span> <span>=</span> <span>(</span>props<span>:</span> Props<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>props<span>.</span>newName<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>Again, there’s a known workaround for this issue, but it’s still something to keep in mind.</p>
<h2 id="when-its-okay-to-destructure"><a href="#when-its-okay-to-destructure">When It’s Okay to Destructure</a></h2>
<p>Developers are sometimes overzealous in adopting new features and syntaxes, and this can cause problems if we’re not careful. On the flip side, developers also tend to be passionate about avoiding bad practices (like misusing divs in HTML)—to the point that we sometimes avoid using a certain syntax or language feature entirely out of fear of misusing it, even if it’s not inherently bad all the time.</p>
<p>While this article looked at some of the pitfalls of overusing destructuring in JavaScript—particularly in function signatures—this doesn’t necessarily mean that destructuring is bad and should be avoided. There are certainly legitimate use cases for it; these are briefly covered in the following sections.</p>
<h3 id="1-named-imports-in-commonjs"><a href="#1-named-imports-in-commonjs">1. Named Imports in CommonJS</a></h3>
<p>If you’ve worked with CommonJS modules, you’re probably familiar with this old syntax for importing a named export from a module:</p>
<pre><code>
module<span>.</span>exports <span>=</span> <span>{</span>
  <span>a</span><span>:</span> <span>1</span><span>,</span>
  <span>b</span><span>:</span> <span>2</span><span>,</span>
<span>}</span><span>;</span>


<span>const</span> <span>{</span> a<span>,</span> b <span>}</span> <span>=</span> <span>require</span><span>(</span><span>&#39;module-1&#39;</span><span>)</span><span>;</span>
</code></pre>
<p>This uses object destructuring to extract the properties from the exported module’s <code>exports</code> object (which is what <code>require</code> returns). There’s absolutely nothing wrong with doing this, assuming you don’t also try to import something from a different module that uses the same name (in which case you’ll need to alias one or more imports).</p>
<h3 id="2-arrays"><a href="#2-arrays">2. Arrays</a></h3>
<p>Destructuring arrays can be useful, especially if the alternative is more verbose.</p>
<p>For example, we can use destructuring and rest syntax to isolate the first element of an array while collecting the remaining elements in a separate array:</p>
<pre><code>
<span>const</span> <span>[</span>first<span>,</span> <span>...</span>rest<span>]</span> <span>=</span> <span>[</span><span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span><span>;</span>
</code></pre>
<p>We can also use a clever trick with array destructuring to swap two values:</p>
<pre><code><span>let</span> a <span>=</span> <span>1</span><span>;</span>
<span>let</span> b <span>=</span> <span>2</span><span>;</span>
<span>[</span>b<span>,</span> a<span>]</span> <span>=</span> <span>[</span>a<span>,</span> b<span>]</span><span>;</span>
</code></pre>
<p>If you’ve worked with React hooks, you should also be familiar with array destructuring when using built-in hooks such as <code>useState</code>:</p>
<pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>state<span>,</span> setState<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>This is more expressive and readable than doing this:</p>
<pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> stateDescriptor <span>=</span> <span>useState</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> state <span>=</span> stateDescriptor<span>[</span><span>0</span><span>]</span><span>;</span>
  <span>const</span> setState <span>=</span> stateDescriptor<span>[</span><span>1</span><span>]</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<h3 id="3-small-functions"><a href="#3-small-functions">3. Small Functions</a></h3>
<p>Destructuring all of your function arguments isn’t a great idea, especially if the function has some combination of arguments and locally or globally declared variables. But if the function is compact, accepts a handful of arguments, and returns some result, there’s no harm in destructuring those arguments. As mentioned earlier, if you do this, you should at least keep the original object around so it’s easier to debug:</p>
<pre><code><span>const</span> <span>function</span> <span>=</span> <span>(</span><span>args</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>{</span> arg1<span>,</span> arg2<span>,</span> <span>...</span>otherArgs <span>}</span> <span>=</span> args<span>;</span>
  <span>return</span> someResult<span>;</span>
<span>}</span>
</code></pre>
<h2 id="everything-in-moderation"><a href="#everything-in-moderation">Everything in Moderation</a></h2>
<p>Destructuring is like salt: Use it judiciously, and it can bring out the flavor in a dish. But overuse it, and you may ruin your meal. Like many practices in programming, destructuring isn’t inherently evil—it certainly has many clever uses that can make our code easier to follow. But as we saw, <em>overdoing</em> it can make our code harder to read and debug.</p>
<h2 id="attributions"><a href="#attributions">Attributions</a></h2>
<p>Social media preview: Photo by <a href="https://unsplash.com/@jiaweizhao?utm_source=https://www.aleksandrhovhannisyan.com&amp;utm_medium=referral" target="_blank" rel="noreferrer noopener">Jiawei Zhao</a> (<a href="https://unsplash.com/photos/W-ypTC6R7_k?utm_source=https://www.aleksandrhovhannisyan.com&amp;utm_medium=referral" target="_blank" rel="noreferrer noopener">Unsplash</a>).</p>
</div>
</article>


</div></div>
  </body>
</html>
