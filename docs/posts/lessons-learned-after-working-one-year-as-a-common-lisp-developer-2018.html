<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cdagostino.io/posts/2018-03-28-one-year-common-lisp-developer-part-1-the-good.html">Original</a>
    <h1>Lessons learned after working one year as a Common Lisp Developer (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p><em>I intented this to be a small post with some lessons learned after working one year as a CL dev, however it turned out quite long (two parts!). As always: All opinions are my own. This post is not endorsed by anybody.</em></p>
<p><em>This post includes some Lisp code that works for AllegroCL, so all the “lessons” noted here are after a year of writing CL using Franz’s AllegroCL compiler, which is a very much batteries-included Common Lisp implementation. So my experience will differ from someone who has professional experience with, say, SBCL or LispWorks.</em></p>
<h2 id="intro">Intro</h2>
<p>If it wasn’t clear already, my favorite language is Haskell. If I could, I’d work professionally as a Haskell dev always, but that’s not possible, as Haskell jobs are hard to come by, because honestly there aren’t that many places where Haskell fits.</p>
<h2 id="landing-a-cl-job">Landing a CL job</h2>
<p>As I’ve mentioned previously, I took up a job writing CL full time. I was fortunate enough to be of interest to <a href="https://www.ravenpack.com">the company</a>, even having CL experience limited to just tinkering at home with it and various other Lisps. I didn’t even know Emacs, which of course wasn’t required, but if you’re writing CL professionally in anything other than Emacs, please send me a message because I’m interested in your setup – I couldn’t make anything work smoothly aside from Emacs+Slime/Sly/Whathaveyou.</p>
<h3 id="book-recommendation">Book recommendation</h3>
<p>Once I had accepted a job offer, I had to prepare and learn CL <strong>really fast</strong>. I was told I shouldn’t hurry, but I felt like I had to anyway. I didn’t want to be the guy asking ridiculous stuff on my first day<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Of course, a lot of things just come with experience, but I found a book that allowed me to hit the ground running.</p>
<p>The book is called <strong>Practical Common Lisp, by Peter Seibel</strong>, and it can be found in its online version here:</p>
<p><b>“Practical Common Lisp” by Peter Seibel</b></p>
<p>I have bookmarked many links from it, and I also have the hardcover version. It is a timeless book. You don’t have to get the hard cover version, of course, as it’s freely online and it’s an amazing reference to bookmark for when you’re writing some <code>format</code> expression and you forgot how the hell to print floats with 3 decimal spaces.</p>
<h2 id="lessons">Lessons</h2>
<p>So many things that I consider to be “good” of Lisp can spill into the “bad” very easily, and viceversa. I think that might be a characteristic of almost everything: Doing too much of something Good can (and most likely will) be Bad.</p>
<h3 id="the-good-cl-is-fancy-and-fast">The Good: CL is fancy and <em>fast</em></h3>
<p>Some people (even - now former - coworkers) would constantly mention the fact that parentheses were “ugly”. In my opinion, that’s absolutely false.</p>
<p>Parentheses are one of the very few syntax tokens of the language. In a language like Haskell you have some reserved “tokens” of the language, which you cannot modify, and you cannot have any identifier name clash with a reserved token.</p>
<p>So for example, in Haskell I can’t call an identifier <code>let</code> or <code>module</code> because it’s expecting those to be reserved words of the language<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Much in the same way that in Java you can’t call a variable <code>class</code>, so everyone just writes <code>klass</code> when they’re doing some obviously misguided things with Reflection.</p>
<p>Lisp can also be <em>fast</em>. Like crazy fast. I’ll write about that below.</p>
<h5 id="one-structure-for-everything">One structure for everything</h5>
<p>As a lot of people know, <strong>LISP</strong> stands for <strong>LIS</strong>t <strong>P</strong>rocessing. The languate itself <strong>is a darn list</strong>, and indeed, in the beginning, <em>everything</em> was a List. However, that’s no longer true: there’s arrays, structs, classes (and a pretty well-developed class hierarchy), a sensible condition system, etc.</p>
<p>Regarding the condition system in CL, it’s not <em>just</em> sensible, it’s unmatched. Feel free to convince yourself here:</p>
<p><b>“Condition Handling in the Lisp Language Family” by Kent M. Pitman</b></p>
<h5 id="almost-everything-is-a-macro">Almost everything is a macro</h5>
<p>You know what was a fun experience? Seeing just how many things in Lisp are a macro.</p>
<p>You’d think <a href="http://clhs.lisp.se/Body/m_defun.htm"><code>defun</code></a> (to define a function) would be some sort of built-in language feature that adds some AST to some internal function mapping mechanism, right? Well, yes it <em>does do that</em>, but it’s not built-in!</p>

<p>I really don’t know what that macroexpansion is <em>really</em> doing, but I know the end result of it, which is that it adds a function.</p>
<p>How about <a href="http://clhs.lisp.se/Body/m_case_.htm"><code>case</code></a>? Surely, <code>case</code> is a built-in mechanism, right? Not so fast:</p>

<p>So <code>case</code> is built on top of <a href="http://clhs.lisp.se/Body/m_cond.htm"><code>cond</code></a>! So then, <code>cond</code> <strong>must</strong> be a built-in… right? You can see where this is going:</p>

<p>So <code>cond</code> is not only a macro, but a recursive macro, built on top of <code>if</code> and itself until some base case.</p>
<p>Now <a href="http://clhs.lisp.se/Body/s_if.htm"><code>if</code> <strong>is</strong> a special operator</a>, but to me it was eye-opening just how many forms are just macros on top of macros.</p>
<h5 id="you-can-talk-with-the-compiler-lot-i.e.-the-programmable-programming-language">You can talk with the compiler lot (i.e. “the programmable programming language”)</h5>
<h6 id="execute-code-in-different-stages-of-the-compiler">Execute code in different stages of the compiler</h6>
<p>There are so many great things you can do in CL.</p>
<p>Do you want to declare a function that will <em>only</em> be available at compile time? Or what about performing some action, like instructing the compiler to optimize the file being compiled for maximum speed?</p>
<p>Fine: Just use <code>eval-when</code>! The <a href="http://clhs.lisp.se/Body/s_eval_w.htm"><code>eval-when</code> <em>special operator</em></a> will allow you to load and execute pieces of code during the different stages of the compiler, and this can be immensely powerful.</p>
<p>Can this get tricky? Of course it can, just ask <a href="https://twitter.com/fare">Fare</a>:</p>

<h6 id="only-compile-expressions-when-certain-features-are-available">Only compile expressions when certain “features” are available</h6>
<p>Despite the hardship, <code>eval-when</code> is <strong>extensively</strong> used to push keywords into a variable called <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/v_featur.htm"><code>*features*</code></a>, which will allow you to, at a later stage of the compiling process, decide what you want to compile and what not to.</p>
<p>For example, you can load your lisp and try to start up <code>swank</code> but only if the library is loaded. You could make use of this to start an alternative server if not. In that situation, you could do:</p>

<p>Is this the best thing ever? Certainly not. Can it be dangerous? Certainly, yes. Is it awesome nonetheless? Yes (IMO).</p>
<h6 id="create-your-own-reader-macros">Create your own reader macros</h6>
<ul>
<li>Are you writing some long multiline strings in your code, and are annoyed by delimiters like double quotes that you have to keep escaping?</li>
<li>Would you prefer to write timestamps in ANSI format?</li>
<li>Would you prefer to type JSON structures in shorthand format, but just get them in a CL structure?</li>
</ul>
<p><strong>Say no more:</strong></p>
<p>Consider the following snippet, where we declare some utility functions, and create a <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node192.html"><strong>readtable</strong></a> with specific dispatch characters.</p>

<p>We start out by setting the <a href="http://clhs.lisp.se/Body/v_rdtabl.htm"><code>*readtable*</code> variable</a> to our newly created readtable in our REPL and just type away:</p>

<p>This, to me, is an incredible feature to have. And, when you combine it with the power of macros and Metaobject Programming, really highlights why CL is truly a programmable programming language.</p>
<p>Still not convinced? In his <code>xooglers</code> recount, <a href="http://www.flownet.com/ron/">Ron Garret</a> talks about how we would adapt one particular product to support multiple languages. His example is basically replacing the default string reader with one that will replace all strings with their responding translation if one exists. The example below is for AllegroCL, but it’s totally adapted from his CCL example<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>:</p>

<p>I suggest reading his <code>xooglers</code> stuff<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>:</p>
<p><b>“Xooglers Rises From the Ashes” by Ron Garret</b></p>
<h6 id="tell-the-compiler-that-certain-functions-or-files-are-fine-to-optimize">Tell the compiler that certain functions or files are fine to optimize</h6>
<p>And it will optimize the sh*t out of them.</p>
<p>As Lisp is a dynamic language, it does what you would expect a dynamic language to do, like checking that you compare a string against a string, or that you add two numbers, and many other things that it does without any type information. If it finds a runtime error, it will spit out an easy-to-read <strong>stack trace</strong> where you can debug what went wrong. This is what most languages do<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>, so it’s no surprise.</p>
<p>But, what if you have a function that you <em>really</em> need to be fast, because it’s running in a tight loop, and you <em>Really Know What You Are Doing (tm)</em>, so you don’t want the compiler getting in the way. You just wanna go <strong>fast</strong>. Well, check this one out:</p>

<p>So in our REPL we typed up and compiled two functions: <code>search-tree</code> and <code>search-tree*</code>, and the only difference between them is that one has an <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm"><code>optimize</code></a> in the middle there.</p>
<p>Reading the <code>optimize</code> declaration, we can see that the second function <code>search-tree*</code> will compile for <em>speed</em> and no debug. The rest is the same: a depth-first search on a tree (a nested list).</p>
<p>So we can see the results below:</p>

<p>In total, <code>search-tree*</code> is nearly <strong>twice</strong> as fast, with hardly any code changes. I haven’t seen any other programming language where this is possible, and it’s extremely helpful.</p>
<p>See, what we did here with the <code>optimize</code> declaration is tell the compiler <strong>not to keep a stack trace</strong><a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>, which is something it does by default to help when debugging. This makes the execution much, much faster, because now the function is tail-recursive, whereas before it was keeping a stack, which is something that can hinder performance greatly.</p>
<p>Want to do the same, but for an entire file? Just type this at the top of your Lisp file:</p>
<pre><code>(eval-when (:compile-toplevel)
   (declaim (optimize (speed 3)
                      (space 0)
                      (debug 0))))</code></pre>
<p>But, <strong>beware</strong>.</p>
<h5 id="parentheses-are-a-solved-problem">Parentheses are a solved problem</h5>
<p>If you’re writing CL and you’re not using <code>parinfer</code>, then seriously: <strong>what in the hell are you doing?</strong></p>
<p>Parentheses are a solved problem. There’s no need to manually align them, and no need to manually check that they’re balanced.</p>
<p>Do yourself a favor and install <a href="https://shaunlebron.github.io/parinfer/"><strong>Parinfer</strong></a>. You don’t even have to use Emacs, and it supports all Lisps. So there’s no excuse. Install it. <a href="https://cdagostino.io/images/didyoudoit.jpg">Do it.</a></p>
<h6 id="interactive-development-is-wonderful">Interactive development is wonderful</h6>
<p>As I’m typing in Emacs with a fully loaded Lisp and gigabytes of data loaded in RAM, about 90% of the time I can simply hover over a function and type <code>C-c C-c</code>, and after a minor flash and a message in the minibuffer saying that the “compilation [is] complete”, I can run my tests again and suddenly they’re passing! I fixed the problem in my editor, which convenienty hosted a REPL where I could issue the test command.</p>
<p>Interactive development is not a side-effect of CL, but a feature and important to its condition system (which includes the notion “restarts”), and any lisper worth their salt will write code that adapts to live reloading.</p>
<p>Having accesss to a REPL is so important to the CL community and its background, that one of the most quoted stories related to that is mentioned in the book I linked to above, but here’s a Google Talk regarding that:</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/_gZK0tW8EhQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="">
</iframe>
<p>Mr Garret in this talk is very biased and spills lots of his own opinions, but what you can keep from the video is that they debugged a satellite from very far away using Lisp (at min 42:00). Nice stuff.</p>
<h6 id="theres-more">There’s more!</h6>
<p>There’s so much more to say, but I better stop here for “the good”. I could continue, but I would also recommend that you read more on things like the type system and the fantastic <code>disassemble</code> function from here:</p>
<p><b>“Performance and Types in Lisp” by Bob Krzaczek</b></p>
<h2 id="listening-to">Listening to</h2>

<p><em>One of the best albums of 2017 <strong>easy</strong>. My favorite story is about the cyborg Han-Tyumi, whose only wish is to vomit and die.</em></p>
<h2 id="amendments">Amendments</h2>
<p>Amendments to this page can be found <a href="https://github.com/carlosdagos/blog/commits/master/posts/2018-03-28-one-year-common-lisp-developer-part-1-the-good.md">here</a>.</p>


            </div></div>
  </body>
</html>
