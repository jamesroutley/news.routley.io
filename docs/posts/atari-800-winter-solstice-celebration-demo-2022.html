<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://8bitworkshop.com/docs/posts/2022/happy-holidays-2022.html">Original</a>
    <h1>Atari 800 Winter Solstice Celebration Demo 2022</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
              
              <div>
                 <div id="atari-800-winter-solstice-celebration-demo-2022">

<p>Every December, I try to make a little wintery demo to exercise one of 8bitworkshop’s platforms. This year, I chose the Atari 800 to test out the new native TypeScript emulator in 8bitworkshop.
<a href="https://8bitworkshop.com/projects/?n=atari8-800/happy2022">You can see the demo emulated here.</a></p>
<p>I revisted my <a href="https://8bitworkshop.com/projects/?n=astrocade/happy2020">Bally Astrocade “Happy 2020” Demo</a>, which simulates falling snow. It uses pixel-level collision to simulate each falling particle, which creates neat little piles of snow and particles that ripple off the sides of obstacles.</p>
<p><img alt="" src="https://8bitworkshop.com/docs/_images/village3.png"/></p>
<div id="background">
<h2>Background<a href="#background" title="Permalink to this headline">¶</a></h2>
<p>Atari ANTIC Mode $F uses the GTIA chip to add additional modes beyond what the original CTIA chip provides.
I used GTIA Mode 10, which is 80 x 192 pixels with nine different colors.</p>
<p>I changed the snow-falling algorithm so that the snow piles up only when it collides with existing snow.
This scheme reserves one of the palette entries for snow, so we can detect snow vs. background.</p>
<p>First I used <a href="https://diffusionbee.com/">DiffusionBee</a>, a stable diffusion AI art app, to make some nice little villages.
This one turned out the best:</p>
<p><img alt="" src="https://8bitworkshop.com/docs/_images/village1.png"/></p>
<p>I painted a white streak on the roofs of buildings and the ground, ensuring that snow would collide there.
I then ran it through <a href="https://8bitworkshop.com/dithertron/">Dithertron</a> to convert it to Atari Mode 10.</p>
</div>
<div id="particle-simulation">
<h2>Particle Simulation<a href="#particle-simulation" title="Permalink to this headline">¶</a></h2>
<p>In the original demo, the falling particles follow these rules every frame:</p>
<ul>
<li><p>Move the particle down 1 pixel. If there is an empty pixel there, we’re done for now.</p></li>
<li><p>Otherwise, if there is an empty pixel to the left or right, move it left or right.</p></li>
<li><p>Otherwise, set the background pixel to snow color, and recycle the particle to the top of the screen where it will fall somewhere else.</p></li>
</ul>
<p>In the new demo, we modify them thusly:</p>
<ul>
<li><p>Instead of “empty pixel” we only collide when we find a “snow pixel”. This means particles will pass over the background image until they hit snow. Using XOR ensures we won’t damage the background.</p></li>
<li><p>When a particle should move left or right, there will be a small probability that they will instead stop.
Over time this will create piles on top of steep roofs, whereas the old algorithm would never pile up any snow on an incline steeper than 45 degrees.</p></li>
</ul>
</div>
<div id="music">
<h2>Music<a href="#music" title="Permalink to this headline">¶</a></h2>
<p>I adapted the Atari vector game music routine from <a href="https://8bitworkshop.com/#books">Making 8-Bit Arcade Games in C</a>.
This sets up the POKEY in 16-bit mode to gain higher frequency accuracy, so you can hit notes without the weird tuning problems like on the Atari 2600.</p>
<p>The arcade games have two POKEYs, and a stock Atari 800 only has one, so we only get two voices with this scheme.</p>
<p>To play at a steady tempo, we need to call the <code><span>music_update</span></code> routine at a steady rate.
The CC65 library sets up a VBI (vertical blank interrupt) that runs at 60 Hz, so we can use that.</p>
<p>The problem with CC65 and interrupts is that CC65 code uses registers and stack in RAM, which can get clobbered if the interrupt fires at the wrong time.
CC65 provides a special <code><span>set_irq()</span></code> function which hooks C routines into the interrupt chain, but preserves global registers and uses a second stack for the interrupt.</p>
<div><div><pre><span></span><span>// set interrupt routine with stack at $7000-$70FF</span>
<span>set_irq</span><span>(</span><span>music_update</span><span>,</span><span> </span><span>(</span><span>void</span><span>*</span><span>)</span><span>0x7000</span><span>,</span><span> </span><span>0x100</span><span>);</span><span></span>
</pre></div>
</div>
</div>
<div id="cc65-config-file">
<h2>CC65 Config File<a href="#cc65-config-file" title="Permalink to this headline">¶</a></h2>
<p>For this demo we’re going to output a 32 KB cartridge ROM, which takes up addresses <code><span>$8000-$BFFF</span></code>.
This requires us to hook in a custom .cfg file, like this (in the main .c file):</p>
<div><div><pre><span></span><span>//#resource &#34;atari-tgi.cfg&#34;</span>
<span>#define CFGFILE atari-tgi.cfg</span>
</pre></div>
</div>
<p>Making the cartridge 32 KB is easy, there’s just one variable to change:</p>
<div><div><pre><span></span><span>__CARTSIZE__</span><span>:</span><span> </span><span>type</span><span> </span><span>=</span><span> </span><span>weak</span><span>,</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>$4000</span><span>;</span><span></span>
</pre></div>
</div>
</div>
<div id="tgi-graphics">
<h2>TGI Graphics<a href="#tgi-graphics" title="Permalink to this headline">¶</a></h2>
<p>We are using the TGI library for setting up the Atari graphics mode.
TGI requires us to reserve enough memory for the frame buffer(s), which is done with this config variable:</p>
<div><div><pre><span></span><span>__RESERVED_MEMORY__</span><span>:</span><span> </span><span>type</span><span> </span><span>=</span><span> </span><span>export</span><span>,</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>$1e00</span><span>;</span><span></span>
</pre></div>
</div>
<p>Here’s how to initialize TGI for Mode 10 graphics:</p>
<div><div><pre><span></span><span>const</span><span> </span><span>byte</span><span> </span><span>PALETTE</span><span>[</span><span>9</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>  </span><span>0xf0</span><span>,</span><span> </span><span>0x42</span><span>,</span><span> </span><span>0x84</span><span>,</span><span> </span><span>0x46</span><span>,</span><span></span>
<span>  </span><span>0xa6</span><span>,</span><span> </span><span>0x3a</span><span>,</span><span> </span><span>0xaa</span><span>,</span><span> </span><span>0x1e</span><span>,</span><span> </span><span>0x0e</span><span>,</span><span></span>
<span>};</span><span></span>

<span>    </span><span>tgi_install</span><span> </span><span>(</span><span>atr10_tgi</span><span>);</span><span> </span>
<span>    </span><span>tgi_init</span><span> </span><span>();</span><span></span>
<span>    </span><span>tgi_clear</span><span>();</span><span></span>
<span>    </span><span>tgi_setpalette</span><span>(</span><span>PALETTE</span><span>);</span><span></span>
</pre></div>
</div>
<p>We don’t use TGI for the particle-drawing routines, because they’re too slow and don’t support XOR.
Instead, we write our own:</p>
<div><div><pre><span></span><span>byte</span><span>*</span><span> </span><span>fb</span><span>;</span><span> </span><span>// frame buffer address</span>

<span>void</span><span> </span><span>drawflake</span><span>(</span><span>word</span><span> </span><span>pos</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>if</span><span> </span><span>(</span><span>pos</span><span> </span><span>&amp;</span><span> </span><span>1</span><span>)</span><span></span>
<span>    </span><span>fb</span><span>[</span><span>pos</span><span>&gt;&gt;</span><span>1</span><span>]</span><span> </span><span>^=</span><span> </span><span>0x08</span><span>;</span><span></span>
<span>  </span><span>else</span><span></span>
<span>    </span><span>fb</span><span>[</span><span>pos</span><span>&gt;&gt;</span><span>1</span><span>]</span><span> </span><span>^=</span><span> </span><span>0x80</span><span>;</span><span></span>
<span>}</span><span></span>
</pre></div>
</div>
<p>The <code><span>fb</span></code> variable holds the address of the graphics frame buffer.
The SAVMSC BIOS register (0x58/0x59) contains the start of screen memory, so after we initialize TGI we read SAVMSC and set the <code><span>fb</span></code> variable:</p>
<div><div><pre><span></span><span>  </span><span>fb</span><span> </span><span>=</span><span> </span><span>(</span><span>char</span><span>*</span><span>)</span><span> </span><span>PEEKW</span><span>(</span><span>0x58</span><span>);</span><span></span>
</pre></div>
</div>
<p>For the background image,
I downloaded the BIN file from Dithertron and converted it to a C array with a binary-to-text converter – the same one linked to on 8bitworkshop’s Tools menu.
Then you can just <code><span>memcpy()</span></code> it to the frame buffer:</p>
<div><div><pre><span></span><span>  </span><span>memcpy</span><span>(</span><span>fb</span><span>,</span><span> </span><span>BITMAP</span><span>,</span><span> </span><span>40</span><span>*</span><span>192</span><span>);</span><span></span>
</pre></div>
</div>
</div>
<div id="try-it-in-8bitworkshop">
<h2>Try it in 8bitworkshop<a href="#try-it-in-8bitworkshop" title="Permalink to this headline">¶</a></h2>
<p>The source code to the demo is <a href="https://github.com/sehugg/holiday2022">available on GitHub</a>, so if you’re interested in Atari programming, check it out!</p>
</div>
</div>



              </div>
              
              
              
              
          </div></div>
  </body>
</html>
