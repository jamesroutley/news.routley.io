<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nextjs.org/blog/layouts-rfc">Original</a>
    <h1>Next.js Layouts RFC: Nested routes and layouts, designed for Server Components</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This RFC outlines the biggest update to Next.js since it was introduced in 2016:<!-- --></p><ul><li><strong>Nested Layouts:</strong> Build complex applications with nested routes.<!-- --></li><li><strong>Designed for Server Components:</strong> Optimized for subtree navigation.<!-- --></li><li><strong>Improved Data Fetching:</strong> Fetch in layouts while avoiding waterfalls.<!-- --></li><li><strong>Using React 18 Features:</strong> Streaming, Transitions, and Suspense.<!-- --></li><li><strong>Client and Server Routing:</strong> Server-centric routing with <!-- --><em>SPA-like</em> behavior.<!-- --></li><li><strong>100% incrementally adoptable</strong>: No breaking changes so you can adopt gradually.<!-- --></li><li><strong>Advanced Routing Conventions</strong>: Offscreen stashing, instant transitions, and more.<!-- --></li></ul><p>The new Next.js router will be built on top of the <!-- --><a href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener noreferrer" target="_blank">recently released React 18<!-- --></a> features. We plan to introduce defaults and conventions to allow you to easily adopt these new features and take advantage of the benefits they unlock.<!-- --></p><h2 data-components-heading="true"><span id="timeline"></span><a href="#timeline">Timeline</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>This RFC will be divided into two parts:<!-- --></p><ul><li><strong>Part 1 (This Post):</strong> Overview of the new routing system and how it integrates with React Server Components and Data Fetching.<!-- --></li><li><strong>Part 2 (Next Post):</strong> Advanced routing examples and conventions, and how Next.js will use Suspense behind the scenes for streaming and selective hydration.<!-- --></li></ul><h2 data-components-heading="true"><span id="motivation"></span><a href="#motivation">Motivation</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>We&#39;ve been gathering community feedback from GitHub, Discord, Reddit, and our developer survey about the current limitations of routing in Next.js. We&#39;ve found that:<!-- --></p><ul><li>The developer experience of creating layouts can be improved. It should be easy to create layouts that can be nested, shared across routes, and have their state preserved on navigation.<!-- --></li><li>Many Next.js applications are dashboards or consoles, which would benefit from more advanced routing solutions.<!-- --></li></ul><p>While the current routing system has worked well since the beginning of Next.js, we want to make it easier for developers to build more performant and feature-rich web applications.<!-- --></p><p>As framework maintainers, we also want to build a routing system that is backwards compatible and aligns with the future of React.<!-- --></p><blockquote><p><strong>Note:</strong> Some routing conventions were inspired by the Relay-based router at Meta, where some features of Server Components were originally developed, as well as client-side routers like React Router and Ember.js. The <!-- --><code>layout.js<!-- --></code> file convention was inspired by the work done in SvelteKit. We&#39;d also like to thank <!-- --><a href="https://twitter.com/cassidoo" rel="noopener noreferrer" target="_blank">Cassidy<!-- --></a> for opening <!-- --><a href="https://github.com/vercel/next.js/discussions/26389" rel="noopener noreferrer" target="_blank">an earlier RFC on layouts<!-- --></a>.<!-- --></p></blockquote><h2 data-components-heading="true"><span id="terminology"></span><a href="#terminology">Terminology</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>This RFC introduces new routing conventions and syntax. The terminology is based on React and standard web platform terms. Throughout the RFC, you&#39;ll see these terms linked back to their definitions below.<!-- --></p><ul><li><strong>Tree:</strong> A convention for visualizing a hierarchical structure. For example, a component
tree with parent and children components, a folder structure, etc.<!-- --></li><li><strong>Subtree</strong> Part of the tree, starting at the root (first) and ending at the leaf (last).<!-- --></li></ul><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271798%27%20height=%27615%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><ul><li><strong>URL Path:</strong> Part of the URL that comes after the domain.<!-- --></li><li><strong>URL Segment:</strong> Part of the URL path delimited by slashes.<!-- --></li></ul><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271798%27%20height=%27407%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><h2 data-components-heading="true"><span id="how-routing-currently-works"></span><a href="#how-routing-currently-works">How Routing Currently Works</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>Today, Next.js uses the file system to map individual folders and files in the <!-- --><a href="https://nextjs.org/docs/basic-features/pages" rel="noopener noreferrer" target="_blank">Pages<!-- --></a> directory to routes accessible through URLs. Each <!-- --><strong>Page</strong> file exports a React Component and has an associated <!-- --><strong>Route</strong> based on its file name. For example:<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271798%27%20height=%27605%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>Next.js also supports <!-- --><a href="https://nextjs.org/docs/routing/dynamic-routes" rel="noopener noreferrer" target="_blank">Dynamic Routes<!-- --></a> (including catch all variations) with the <!-- --><code>[param].js<!-- --></code>, <!-- --><code>[...param].js<!-- --></code> and <!-- --><code>[[...param]].js<!-- --></code> conventions.<!-- --></p><ul><li><strong>Layouts:</strong> Next.js offers support for simple <!-- --><a href="https://nextjs.org/docs/basic-features/layouts" rel="noopener noreferrer" target="_blank">component-based<!-- --></a> layouts, per-page layouts using a component <!-- --><a href="https://nextjs.org/docs/basic-features/layouts#per-page-layouts" rel="noopener noreferrer" target="_blank">property pattern<!-- --></a>, and a single global layout using a <!-- --><a href="https://nextjs.org/docs/basic-features/layouts#single-shared-layout-with-custom-app" rel="noopener noreferrer" target="_blank">custom app<!-- --></a>.<!-- --></li><li><strong>Data Fetching:</strong> Next.js provides data fetching methods (<!-- --><a href="https://nextjs.org/docs/basic-features/data-fetching/get-static-props" rel="noopener noreferrer" target="_blank"><code>getStaticProps<!-- --></code></a>, <!-- --><a href="https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props" rel="noopener noreferrer" target="_blank"><code>getServerSideProps<!-- --></code></a>) which can be used at the page (route) level. These methods are used to determine if a page should be Statically Generated (<!-- --><a href="https://nextjs.org/docs/basic-features/data-fetching/get-static-props" rel="noopener noreferrer" target="_blank"><code>getStaticProps<!-- --></code></a>) or Server-Side Rendered (<!-- --><a href="https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props" rel="noopener noreferrer" target="_blank"><code>getServerSideProps<!-- --></code></a>). In addition, you can use <!-- --><a href="https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration" rel="noopener noreferrer" target="_blank">Incremental Static Regeneration (ISR)<!-- --></a> to create or update static pages after a site is built.<!-- --></li><li><strong>Rendering:</strong> Next.js provides three rendering options: <!-- --><a href="https://nextjs.org/learn/foundations/how-nextjs-works/rendering" rel="noopener noreferrer" target="_blank">Static Generation<!-- --></a>, <!-- --><a href="https://nextjs.org/learn/foundations/how-nextjs-works/rendering" rel="noopener noreferrer" target="_blank">Server-Side Rendering<!-- --></a>, and <!-- --><a href="https://nextjs.org/learn/foundations/how-nextjs-works/rendering" rel="noopener noreferrer" target="_blank">Client-Side Rendering<!-- --></a>. By default, pages are statically generated unless they have a blocking data fetching requirement (<!-- --><code>getServerSideProps<!-- --></code>).<!-- --></li></ul><h2 data-components-heading="true"><span id="introducing-the-app-folder"></span><a href="#introducing-the-app-folder">Introducing the App Folder</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>To ensure these new improvements can be incrementally adopted and avoid breaking changes, we are proposing a new directory called <!-- --><code>app<!-- --></code>.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271534%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>The <!-- --><code>app<!-- --></code> directory will work alongside the <!-- --><code>pages<!-- --></code> directory. For backwards compatibility, the behavior of the <!-- --><code>pages<!-- --></code> directory will remain the same and continue to be supported. You can incrementally move parts of your application to the new <!-- --><code>app<!-- --></code> directory to take advantage of the new features.<!-- --></p><h2 data-components-heading="true"><span id="defining-routes"></span><a href="#defining-routes">Defining Routes</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>You can use the <!-- --><strong>folder</strong> hierarchy inside <!-- --><code>app<!-- --></code> to define routes. A <!-- --><strong>route</strong> is a single path of nested folders, following the hierarchy from the <!-- --><strong>root</strong> <!-- --><strong>folder</strong> down to the final <!-- --><strong>leaf folder.</strong></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271280%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>For example, you can add a new <!-- --><code>/dashboard/settings<!-- --></code> route by nesting two new folders in the <!-- --><code>app<!-- --></code> directory.<!-- --></p><blockquote><p><strong>Note:</strong></p><ul><li>With this system, you&#39;ll use folders to define routes, and files to define UI (with new file conventions such as <!-- --><code>layout.js<!-- --></code>, <!-- --><code>page.js<!-- --></code>, and in the second part of the RFC <!-- --><code>loading.js<!-- --></code>).<!-- --></li><li>This allows you to colocate your own project files (UI components, test files, stories, etc) inside the <!-- --><code>app<!-- --></code> directory. This is currently not possible in <!-- --><code>pages<!-- --></code>.<!-- --></li></ul></blockquote><h3 data-components-heading="true"><span id="route-segments"></span><a href="#route-segments">Route Segments</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>Each folder in the <!-- --><a href="#terminology">subtree<!-- --></a> represents a <!-- --><strong>route segment</strong>. Each route segment is mapped to a corresponding <!-- --><strong>segment</strong> in a <!-- --><strong><a href="#terminology">URL path<!-- --></a></strong>.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271512%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>For example, the <!-- --><code>/dashboard/settings<!-- --></code> route is composed of 3 segments:<!-- --></p><ul><li>The <!-- --><code>/<!-- --></code> root segment<!-- --></li><li>The <!-- --><code>dashboard<!-- --></code> segment<!-- --></li><li>The <!-- --><code>settings<!-- --></code> segment<!-- --></li></ul><blockquote><p><strong>Note</strong>: The name route segment was chosen to match the existing terminology around <!-- --><a href="#terminology">URL paths<!-- --></a>.<!-- --></p></blockquote><h2 data-components-heading="true"><span id="layouts--creating-ui"></span><a href="#layouts--creating-ui">Layouts &amp; Creating UI</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p><strong>New file convention:</strong> <!-- --><code>layout.js<!-- --></code></p><p>So far, we have used folders to define the routes of our application. But empty folders do not do anything by themselves. Let&#39;s discuss how you can define the UI that will render for these routes using new file conventions.<!-- --></p><p>A <!-- --><strong>layout</strong> is UI that is shared between route segments in a <!-- --><a href="#terminology">subtree<!-- --></a>. Layouts do not affect <!-- --><a href="#terminology">URL paths<!-- --></a> and do not re-render (React state is preserved) when a user navigates between segments that share the same layout.<!-- --></p><p>A layout can be defined by default exporting a React component from a <!-- --><code>layout.js<!-- --></code> file. The component should accept a <!-- --><code>children<!-- --></code> prop which will be populated with the segments the layout is wrapping.<!-- --></p><p>There are 2 types of layouts:<!-- --></p><ul><li><strong>Root layout:</strong> Applies to all routes<!-- --></li><li><strong>Regular layout:</strong> Applies to specific route segments<!-- --></li></ul><p>You can nest two or more layouts together to form <!-- --><strong>nested layouts</strong>.<!-- --></p><h3 data-components-heading="true"><span id="root-layout"></span><a href="#root-layout">Root layout</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>You can create a root layout that will apply to all routes of your application by adding a <!-- --><code>layout.js<!-- --></code> file inside the <!-- --><code>app<!-- --></code> folder.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271210%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><blockquote><p><strong>Note:</strong></p><ul><li>The root layout replaces the need for a <!-- --><a href="https://nextjs.org/docs/advanced-features/custom-app" rel="noopener noreferrer" target="_blank">custom App (<!-- --><code>_app.js<!-- --></code>)<!-- --></a> and <!-- --><a href="https://nextjs.org/docs/advanced-features/custom-document" rel="noopener noreferrer" target="_blank">custom Document (<!-- --><code>_document.js<!-- --></code>)<!-- --></a> since it applies to all routes.<!-- --></li><li>You&#39;ll be able to use the root layout to customize the initial document shell (e.g. <!-- --><code>&lt;html&gt;<!-- --></code> and <!-- --><code>&lt;body&gt;<!-- --></code> tags).<!-- --></li><li>You&#39;ll be able to use data fetching methods inside the root layout (and other layouts).<!-- --></li></ul></blockquote><h3 data-components-heading="true"><span id="regular-layouts"></span><a href="#regular-layouts">Regular layouts</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>You can also create a layout that only applies to a part of your application by adding a <!-- --><code>layout.js<!-- --></code> file inside a specific folder.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271696%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>For example, you can create a <!-- --><code>layout.js<!-- --></code> file inside the <!-- --><code>dashboard<!-- --></code> folder which will only apply to the route segments inside <!-- --><code>dashboard<!-- --></code>.<!-- --></p><h3 data-components-heading="true"><span id="nesting-layouts"></span><a href="#nesting-layouts">Nesting layouts</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>Layouts are <!-- --><strong>nested</strong> by default.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271696%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>For example, if we were to combine the two layouts above. The root layout (<!-- --><code>app/layout.js<!-- --></code>) would be applied to the <!-- --><code>dashboard<!-- --></code> layout, which would also apply to all route segments inside <!-- --><code>dashboard/*<!-- --></code>.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271668%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><h2 data-components-heading="true"><span id="pages"></span><a href="#pages">Pages</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p><strong>New file convention:</strong> <!-- --><code>page.js<!-- --></code></p><p>A page is UI that is unique to a route segment and required for a route to be valid. You can create a page by adding a <!-- --><code>page.js<!-- --></code> file inside a folder.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271696%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>For example, to create pages for the <!-- --><code>/dashboard/*<!-- --></code> routes, you can add a <!-- --><code>page.js<!-- --></code> file inside each folder. When a user visits <!-- --><code>/dashboard/settings<!-- --></code>, Next.js will render the <!-- --><code>page.js<!-- --></code> file for the <!-- --><code>settings<!-- --></code> folder wrapped in any layouts that exist further up the <!-- --><a href="#terminology">subtree<!-- --></a>.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271668%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>You can create a <!-- --><code>page.js<!-- --></code> file directly inside the dashboard folder to match the <!-- --><code>/dashboard<!-- --></code> route. The dashboard layout will also apply to this page:<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271858%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>This route is composed of 2 segments:<!-- --></p><ul><li>The <!-- --><code>/<!-- --></code> root segment<!-- --></li><li>The <!-- --><code>dashboard<!-- --></code> segment<!-- --></li></ul><blockquote><p><strong>Note:</strong></p><ul><li>For a route to be valid, it needs to have a page in its leaf segment. If it doesn&#39;t, the route will 404.<!-- --></li><li>A <!-- --><code>page.js<!-- --></code> file should default export a React component.<!-- --></li><li>The name needs to be <!-- --><code>page.(js|jsx|ts|tsx)<!-- --></code> exactly. If you do not export a Page component, Next.js will throw an error.<!-- --></li></ul></blockquote><h2 data-components-heading="true"><span id="layout-and-page-behavior"></span><a href="#layout-and-page-behavior">Layout and Page Behavior</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p><strong>Recap:</strong></p><ul><li>Page components are the default export of <!-- --><code>page.js<!-- --></code>.<!-- --></li><li>Layout components are the default export of <!-- --><code>layout.js<!-- --></code>.<!-- --></li><li>Layout components <!-- --><strong>must</strong> accept a <!-- --><code>children<!-- --></code> prop.<!-- --></li></ul><p>When a layout component is rendered, the <!-- --><code>children<!-- --></code> prop will be populated with a child layout component (if it exists further down the <!-- --><a href="#terminology">subtree<!-- --></a>) or a page component.<!-- --></p><p>It may be easier to visualize it as a layout <!-- --><a href="#terminology">tree<!-- --></a> where the parent layout will pick the nearest child layout until it reaches a page.<!-- --></p><p><strong>Basic Example:</strong></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271372%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><pre><pre><code>
<!-- -->
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>RootLayout</span></span><span>(</span><span><span>{</span> children <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span>html<!-- --></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>body<!-- --></span><span>&gt;</span></span><span>
        </span><span><span><span>&lt;</span><span>Header</span></span> <!-- --><span>/&gt;</span></span><span>
        </span><span>{</span>children<!-- --><span>}</span><span>
        </span><span><span><span>&lt;</span><span>Footer</span></span> <!-- --><span>/&gt;</span></span><span>
      </span><span><span><span>&lt;/</span>body<!-- --></span><span>&gt;</span></span><span>
    </span><span><span><span>&lt;/</span>html<!-- --></span><span>&gt;</span></span>
  <!-- --><span>)</span>
<!-- --><span>}</span>

<!-- -->
<!-- -->
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>DashboardLayout</span></span><span>(</span><span><span>{</span> children <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span><span>DashboardSidebar</span></span> <!-- --><span>/&gt;</span></span><span>
      </span><span>{</span>children<!-- --><span>}</span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span>
<!-- --><span>}</span>

<!-- -->
<!-- -->
<!-- -->
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>AnalyticsPage</span></span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span>main<!-- --></span><span>&gt;</span></span><span>...</span><span><span><span>&lt;/</span>main<!-- --></span><span>&gt;</span></span>
  <!-- --><span>)</span>
<!-- --><span>}</span>
<!-- --></code></pre></pre><p>The above combination of layouts and pages would render the following component hierarchy:<!-- --></p><pre><pre><code><span><span><span>&lt;</span><span>RootLayout</span></span><span>&gt;</span></span><span>
  </span><span><span><span>&lt;</span><span>Header</span></span> <!-- --><span>/&gt;</span></span><span>
  </span><span><span><span>&lt;</span><span>DashboardLayout</span></span><span>&gt;</span></span><span>
    </span><span><span><span>&lt;</span><span>DahboardSidebar</span></span> <!-- --><span>/&gt;</span></span><span>
    </span><span><span><span>&lt;</span><span>AnalyticsPage</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>main<!-- --></span><span>&gt;</span></span><span>...</span><span><span><span>&lt;/</span>main<!-- --></span><span>&gt;</span></span><span>
    </span><span><span><span>&lt;/</span><span>AnalyticsPage</span></span><span>&gt;</span></span><span>
  </span><span><span><span>&lt;/</span><span>DashboardLayout</span></span><span>&gt;</span></span><span>
  </span><span><span><span>&lt;</span><span>Footer</span></span> <!-- --><span>/&gt;</span></span><span>
</span><span><span><span>&lt;/</span><span>RootLayout</span></span><span>&gt;</span></span>
<!-- --></code></pre></pre><h2 data-components-heading="true"><span id="react-server-components"></span><a href="#react-server-components">React Server Components</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><blockquote><p><strong>Note:</strong> If you&#39;re not familiar with React Server Components, we recommend reading the <!-- --><a href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md" rel="noopener noreferrer" target="_blank">React Server Component RFC<!-- --></a> before reading this section.<!-- --></p></blockquote><p>With this RFC, you can start using React features and incrementally adopt React Server Components into your Next.js application.<!-- --></p><p>The internals of the new routing system leverage recently released React features such as Streaming, Suspense, and Transitions. These are the building blocks for React Server Components.<!-- --></p><h3 data-components-heading="true"><span id="server-components-are-the-new-default"></span><a href="#server-components-are-the-new-default">Server Components are the new default</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>One of the biggest changes between the <!-- --><code>pages<!-- --></code> and <!-- --><code>app<!-- --></code> directories is that, by default, <!-- --><strong>files inside <!-- --><code>app<!-- --></code> will be rendered on the server as React Server Components.<!-- --></strong></p><p>This will allow you to automatically adopt React Server Components when incrementally migrating your application from <!-- --><code>pages<!-- --></code> to <!-- --><code>app<!-- --></code>.<!-- --></p><h3 data-components-heading="true"><span id="rendering-environments-and-component-types"></span><a href="#rendering-environments-and-component-types">Rendering Environments and Component Types</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><blockquote><p><strong>Note:</strong> React introduces new component (module) types: Server, Client, and Shared Components. To learn more about these new types, we recommend reading the <!-- --><a href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md#capabilities--constraints-of-server-and-client-components" rel="noopener noreferrer" target="_blank">Capabilities &amp; Constraints of Server and Client Components<!-- --></a> and <!-- --><a href="https://github.com/reactjs/rfcs/blob/235f27c12aa893efd2378ec3c4a9b0b221641861/text/0000-server-module-conventions.md#js-serverjs-clientjs" rel="noopener noreferrer" target="_blank">Server Module Conventions RFC<!-- --></a>.<!-- --></p></blockquote><p>You&#39;ll have granular control of what components will be in the client-side JavaScript bundle using the new React conventions. There is an <!-- --><a href="https://github.com/reactjs/rfcs/pull/189#issuecomment-1116482278" rel="noopener noreferrer" target="_blank">ongoing discussion<!-- --></a> on what exactly the convention will be for defining Client Components and Server Components. We will follow the resolution of this discussion.<!-- --></p><p>For now, it&#39;s worth noting that <!-- --><code>app<!-- --></code> allows components (layouts and pages) in a route to be rendered on the server, on the client, or both.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271230%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>This is different from the <!-- --><code>pages<!-- --></code> directory in Next.js, where by default, pages are statically generated unless they have data fetching requirements. In <!-- --><code>pages<!-- --></code>, you have the flexibility to decide when (build time or runtime) and where (server-side, client-side, or a combination) a page is rendered by using Next.js data fetching methods (<!-- --><code>getStaticProps<!-- --></code>, <!-- --><code>getServerSideProps<!-- --></code>) or fetching the data from the client-side<!-- --></p><p>However, in the <!-- --><code>app<!-- --></code> folder, <!-- --><strong>the rendering environment is decoupled from the data fetching method and set at the component level</strong>. You will still need to respect the <!-- --><a href="https://github.com/reactjs/rfcs/blob/235f27c12aa893efd2378ec3c4a9b0b221641861/text/0000-server-module-conventions.md#js-serverjs-clientjs" rel="noopener noreferrer" target="_blank">constraints of Client and Server components<!-- --></a> (e.g. you will not be able to use the <!-- --><code>getServerSideProps<!-- --></code> method inside a page or layout that is a client component).<!-- --></p><h3 data-components-heading="true"><span id="interleaving-client-and-server-components-using-the-children-prop"></span><a href="#interleaving-client-and-server-components-using-the-children-prop">Interleaving Client and Server Components using the <!-- --><code>children<!-- --></code> prop<!-- --></a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>In React, there&#39;s a restriction around importing Server Components inside Client Components because Server Components might have server-only code that should only run on the server (e.g. database or filesystem utilities).<!-- --></p><p>For example, this pattern would not work:<!-- --></p><pre><pre><code><span>import</span> <!-- --><span>ServerComponent</span> <!-- --><span>from</span> <!-- --><span>&#39;./ServerComponent.js&#39;</span><span>;</span>

<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>ClientComponent</span></span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span><span>ServerComponent</span></span> <!-- --><span>/&gt;</span></span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>
<!-- --></code></pre></pre><p>However, a Server Component can be passed as a child of a Client Component if both are <!-- --><strong>wrapped</strong> in another Server Component. For example, you can pass the <!-- --><code>ServerComponent<!-- --></code> to the <!-- --><code>ClientComponent<!-- --></code> as a child in another Server Component.<!-- --></p><pre><pre><code>
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>ClientComponent</span></span><span>(</span><span><span>{</span> children <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>h1<!-- --></span><span>&gt;</span></span><span>Client Component</span><span><span><span>&lt;/</span>h1<!-- --></span><span>&gt;</span></span><span>
      </span><span>{</span>children<!-- --><span>}</span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>

<!-- -->
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>ServerComponent</span></span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>h1<!-- --></span><span>&gt;</span></span><span>Server Component</span><span><span><span>&lt;/</span>h1<!-- --></span><span>&gt;</span></span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>

<!-- -->
<!-- -->
<!-- -->
<!-- --><span>import</span> <!-- --><span>ClientComponent</span> <!-- --><span>from</span> <!-- --><span>&#34;./ClientComponent.js&#34;</span><span>;</span>
<!-- --><span>import</span> <!-- --><span>ServerComponent</span> <!-- --><span>from</span> <!-- --><span>&#34;./ServerComponent.js&#34;</span><span>;</span>

<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>ServerComponentPage</span></span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span><span>ClientComponent</span></span><span>&gt;</span></span><span>
        </span><span><span><span>&lt;</span><span>ServerComponent</span></span> <!-- --><span>/&gt;</span></span><span>
      </span><span><span><span>&lt;/</span><span>ClientComponent</span></span><span>&gt;</span></span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>
<!-- --></code></pre></pre><p>With this pattern, React will know it needs to render <!-- --><code>ServerComponent<!-- --></code> on the server before sending the result (which doesn&#39;t contain any server-only code) to the client. From the Client Component&#39;s perspective, its child will be already rendered.<!-- --></p><p>The new router leverages this to allow rendering layouts as client components while the nested layout or page might be a server component.<!-- --></p><p>For example, you can have a Server Component page and a Client Component layout wrapping it:<!-- --></p><pre><pre><code>
<!-- -->
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>ClientLayout</span></span><span>(</span><span><span>{</span> children <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- -->
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>h1<!-- --></span><span>&gt;</span></span><span>Layout</span><span><span><span>&lt;/</span>h1<!-- --></span><span>&gt;</span></span><span>
      </span><span>{</span>children<!-- --><span>}</span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>

<!-- -->
<!-- -->
<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>ServerPage</span></span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>h1<!-- --></span><span>&gt;</span></span><span>Page</span><span><span><span>&lt;/</span>h1<!-- --></span><span>&gt;</span></span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>
<!-- --></code></pre></pre><blockquote><p><strong>Note:</strong> This style of composition is an important pattern for rendering Server Components inside Client Components. It sets the precedence of one pattern to learn, and is one of the reasons why we&#39;ve decided to use the <!-- --><code>children<!-- --></code> prop.<!-- --></p></blockquote><h2 data-components-heading="true"><span id="data-fetching"></span><a href="#data-fetching">Data fetching</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>It&#39;s possible to use Next.js data fetching methods inside <!-- --><code>layout.js<!-- --></code> files. Since layouts can be nested, this also means it is possible to fetch data in multiple segments of a route. This is different from the <!-- --><code>pages<!-- --></code> directory, where data fetching methods were limited to the page-level.<!-- --></p><h3 data-components-heading="true"><span id="data-fetching-in-layouts"></span><a href="#data-fetching-in-layouts">Data fetching in Layouts</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>You can fetch data in a <!-- --><code>layout.js<!-- --></code> file by using the Next.js data fetching methods <!-- --><code>getStaticProps<!-- --></code> or <!-- --><code>getServerSideProps<!-- --></code>.<!-- --></p><p>For example, a blog layout could use <!-- --><code>getStaticProps<!-- --></code> to fetch categories from a CMS, which can be used to populate a sidebar component:<!-- --></p><pre><pre><code>
<!-- --><span>export</span> <!-- --><span>async</span> <!-- --><span>function</span> <!-- --><span>getStaticProps</span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>const</span> categories <!-- --><span>=</span> <!-- --><span>await</span> <!-- --><span>getCategoriesFromCMS</span><span>(</span><span>)</span><span>;</span>

  <!-- --><span>return</span> <!-- --><span>{</span>
    props<!-- --><span>:</span> <!-- --><span>{</span> categories <!-- --><span>}</span><span>,</span>
  <!-- --><span>}</span><span>;</span>
<!-- --><span>}</span>

<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>BlogLayout</span></span><span>(</span><span><span>{</span> categories<!-- --><span>,</span> children <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span>(</span>
    <!-- --><span><span><span>&lt;</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span><span>BlogSidebar</span></span> <!-- --><span>categories</span><span><span>=</span><span>{</span>categories<!-- --><span>}</span></span> <!-- --><span>/&gt;</span></span><span>
      </span><span>{</span>children<!-- --><span>}</span><span>
    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
  <!-- --><span>)</span><span>;</span>
<!-- --><span>}</span>
<!-- --></code></pre></pre><h3 data-components-heading="true"><span id="multiple-data-fetching-methods-in-a-route"></span><a href="#multiple-data-fetching-methods-in-a-route">Multiple data fetching methods in a route</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>You can also fetch data in multiple segments of a route. For example, a <!-- --><code>layout<!-- --></code> that fetches data can also wrap a <!-- --><code>page<!-- --></code> that fetches its own data.<!-- --></p><p>Using the blog example above, a single post page can use <!-- --><code>getStaticProps<!-- --></code> and <!-- --><code>getStaticPaths<!-- --></code> to fetch post data from a CMS:<!-- --></p><pre><pre><code>
<!-- --><span>export</span> <!-- --><span>async</span> <!-- --><span>function</span> <!-- --><span>getStaticPaths</span><span>(</span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>const</span> posts <!-- --><span>=</span> <!-- --><span>await</span> <!-- --><span>getPostSlugsFromCMS</span><span>(</span><span>)</span><span>;</span>

  <!-- --><span>return</span> <!-- --><span>{</span>
    paths<!-- --><span>:</span> posts<!-- --><span>.</span><span>map</span><span>(</span><span>(</span><span>post</span><span>)</span> <!-- --><span>=&gt;</span> <!-- --><span>(</span><span>{</span>
      params<!-- --><span>:</span> <!-- --><span>{</span> slug<!-- --><span>:</span> post<!-- --><span>.</span><span>slug</span> <!-- --><span>}</span><span>,</span>
    <!-- --><span>}</span><span>)</span><span>)</span><span>,</span>
  <!-- --><span>}</span><span>;</span>
<!-- --><span>}</span>

<!-- --><span>export</span> <!-- --><span>async</span> <!-- --><span>function</span> <!-- --><span>getStaticProps</span><span>(</span><span><span>{</span> params <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>const</span> post <!-- --><span>=</span> <!-- --><span>await</span> <!-- --><span>getPostFromCMS</span><span>(</span>params<!-- --><span>.</span><span>slug</span><span>)</span><span>;</span>

  <!-- --><span>return</span> <!-- --><span>{</span>
    props<!-- --><span>:</span> <!-- --><span>{</span> post <!-- --><span>}</span><span>,</span>
  <!-- --><span>}</span><span>;</span>
<!-- --><span>}</span>

<!-- --><span>export</span> <!-- --><span>default</span> <!-- --><span>function</span> <!-- --><span><span>BlogPostPage</span></span><span>(</span><span><span>{</span> post <!-- --><span>}</span></span><span>)</span> <!-- --><span>{</span>
  <!-- --><span>return</span> <!-- --><span><span><span>&lt;</span><span>Post</span></span> <!-- --><span>post</span><span><span>=</span><span>{</span>post<!-- --><span>}</span></span> <!-- --><span>/&gt;</span></span><span>;</span>
<!-- --><span>}</span>
<!-- --></code></pre></pre><p>Since both <!-- --><code>app/blog/layout.js<!-- --></code> and <!-- --><code>app/blog/[slug]/page.js<!-- --></code> use <!-- --><code>getStaticProps<!-- --></code>, Next.js will statically generate the whole <!-- --><code>/blog/[slug]<!-- --></code> route as <!-- --><strong>React Server Components</strong> at build time. React Server Components result in less client-side JavaScript and faster hydration.<!-- --></p><p>Statically generated routes improve this further, as the client navigation reuses the cache (server components data) and doesn&#39;t recompute work, leading to less CPU time because you&#39;re rendering a snapshot of the Server Components.<!-- --></p><h2 data-components-heading="true"><span id="behavior-and-priority"></span><a href="#behavior-and-priority">Behavior and priority</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>Next.js Data Fetching Methods (<!-- --><code>getServerSideProps<!-- --></code> and <!-- --><code>getStaticProps<!-- --></code>) can only be used in Server Components in the <!-- --><code>app<!-- --></code> folder. Different data fetching methods in segments across a single route affect each other.<!-- --></p><p>Using <!-- --><code>getServerSideProps<!-- --></code> in one segment will affect <!-- --><code>getStaticProps<!-- --></code> in other segments. Since a request already has to go to a server for the <!-- --><code>getServerSideProps<!-- --></code> segment, the server will also render any <!-- --><code>getStaticProps<!-- --></code> segments. It will reuse the props fetched at build time so the data will still be static, the <!-- --><strong>rendering</strong> happens on-demand on every request with the props generated during <!-- --><code>next build<!-- --></code>.<!-- --></p><p>Using <!-- --><code>getStaticProps<!-- --></code> with <!-- --><strong>revalidate</strong> <!-- --><strong>(ISR)</strong> in one segment will affect <!-- --><code>getStaticProps<!-- --></code> with <!-- --><code>revalidate<!-- --></code> in other segments. If there are two revalidate periods in one route, the shorter revalidation will take precedence.<!-- --></p><blockquote><p><strong>Note:</strong> In the future, this may be optimized to allow for full data fetching granularity in a route.<!-- --></p></blockquote><h2 data-components-heading="true"><span id="data-fetching-and-rendering-with-react-server-components"></span><a href="#data-fetching-and-rendering-with-react-server-components">Data fetching and rendering with React Server Components</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>The combination of Server-Side Routing, React Server Components, Suspense and Streaming have a few implications for data fetching and rendering in Next.js:<!-- --></p><h3 data-components-heading="true"><span id="parallel-fetching-and-rendering"></span><a href="#parallel-fetching-and-rendering">Parallel fetching and rendering</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>Next.js will eagerly initiate data fetches in parallel to minimize waterfalls. In combination with Suspense, React can also start rendering Server Components immediately, before the requests have completed, and can slot in the result as the requests resolve.<!-- --></p><p>For example, if data fetching was <!-- --><strong>sequential</strong>, each nested segment in the route couldn&#39;t start fetching data until the previous segment was completed. If rendering was dependent on data fetching, each segment could only render <!-- --><strong>after</strong> data fetching was complete.<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271386%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><p>With <!-- --><strong>parallel</strong> fetching, however, each segment can eagerly start data fetching at the same time. With Suspense, rendering <!-- --><em>also</em> starts immediately, even if the data is not completely loaded. If the data is read before it&#39;s available, Suspense will be triggered.<!-- --></p><h3 data-components-heading="true"><span id="partial-fetching-and-rendering"></span><a href="#partial-fetching-and-rendering">Partial fetching and rendering</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h3><p>When navigating between sibling route segments, Next.js will only fetch and render from that segment down. It will not need to re-fetch or re-render anything above. This means in a page that shares a layout, the layout will be preserved when a user navigates between sibling pages, and Next.js will only fetch and render from that segment down.<!-- --></p><p>This is especially useful for React Server Components, as otherwise each navigation would cause the full page to re-render on the server instead of rendering only the changed part of the page on the server. This reduces the amount of data transfered and execution time, leading to improved performance.<!-- --></p><p>For example, if the user navigates between the <!-- --><code>/analytics<!-- --></code> and the <!-- --><code>/settings<!-- --></code> pages, React will re-render the page segments but preserve the layouts:<!-- --></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%273596%27%20height=%271880%27/%3e"/></span><img alt="" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></figure><blockquote><p><strong>Note:</strong> It will be possible to force a re-fetch of data higher up the <!-- --><a href="#terminology">tree<!-- --></a>. We are still discussing the details of how this will look and will update the RFC.<!-- --></p></blockquote><h2 data-components-heading="true"><span id="conclusion"></span><a href="#conclusion">Conclusion</a><span><span><svg height="16" viewBox="0 0 16 16" width="16"><g fill="#000000" stroke="#000000" stroke-width="1"><path d="M8.995,7.005 L8.995,7.005c1.374,1.374,1.374,3.601,0,4.975l-1.99,1.99c-1.374,1.374-3.601,1.374-4.975,0l0,0c-1.374-1.374-1.374-3.601,0-4.975 l1.748-1.698" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path><path d="M7.005,8.995 L7.005,8.995c-1.374-1.374-1.374-3.601,0-4.975l1.99-1.99c1.374-1.374,3.601-1.374,4.975,0l0,0c1.374,1.374,1.374,3.601,0,4.975 l-1.748,1.698" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10"></path></g></svg></span></span></h2><p>We&#39;re excited about the future of layouts, routing, and data fetching in Next.js. In the next part of the RFC, we&#39;ll discuss:<!-- --></p><ul><li><strong>Instant Loading States:</strong> With server-side routing, rendering and data fetching happens on the server before navigation completes. This makes it important to show loading UI so the application doesn&#39;t feel unresponsive. We propose framework level support for instant loading states - inline and global loading indicators and skeletons.<!-- --></li><li><strong>Offscreen Stashing with Instant Back/Forward:</strong> React is planning to add a new <!-- --><code>&lt;Offscreen /&gt;<!-- --></code> component that stores a React tree and its state without rendering it to the screen. Leveraging this component, it should be possible to stash routes that have been visited and pre-render routes before they are visited. Navigation backwards and forwards to these routes should be instant and restore any previously stored state.<!-- --></li><li><strong>Parallel Routes:</strong> If you have two or more tab bars on a page, it should be possible to have two or more parallel nested layouts that can be navigated independently, conceptually similar to an <!-- --><code>&lt;iframe /&gt;<!-- --></code>.<!-- --></li><li><strong>Intercepting Routes:</strong> Sometimes it&#39;s useful to be able to intercept a route from within another page. The URL would normally lead to a different part of the UI but not when it&#39;s visited within this context. For example, a tweet that can be expanded and presented inline or a modal photo viewer instead of a standalone gallery.<!-- --></li><li><strong>Streaming and selective hydration:</strong> We will share more details about how a server centric routing, React Server Components, Suspense and streaming combine to enable new routing paradigms and help performance by reducing what is sent to the client and breaking down work into smaller chunks.<!-- --></li></ul><p>Leave comments and <!-- --><a href="https://github.com/vercel/next.js/discussions/37136" rel="noopener noreferrer" target="_blank">join the conversation on GitHub Discussions<!-- --></a>.<!-- --></p></div></div></div>
  </body>
</html>
