<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2022/01/ibm360model50.html">Original</a>
    <h1>Simulating the IBM 360/50 mainframe from its microcode</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1556663171519058512" itemprop="description articleBody">


<p>The IBM System/360 was a groundbreaking family of mainframe computers announced on April 7, 1964.
System/360 was an extremely risky &#34;bet-the-company&#34; project for IBM, costing over $5 billion, but 
the System/360 ended up as a huge success,
setting the direction of the computer industry for decades.
The S/360 architecture was so successful that it is still supported by IBM&#39;s latest mainframes, almost 60 years later.
I&#39;m developing a microcode-level simulator<span id="fnref:simulator"><a href="#fn:simulator">1</a></span>
for the IBM System/360 Model 50
(<a href="http://righto.com/360">link to the simulator</a>);
this blog post provides background to understand the Model 50 and the simulator.</p>
<p><a href="https://righto.com/360"><img alt="Screenshot of the simulator running in a browser." height="387" src="https://static.righto.com/images/ibm-360-50/screenshot-w450.jpg" title="Screenshot of the simulator running in a browser." width="450"/></a></p><p>Screenshot of the simulator running in a browser.</p>
<p>The radical decision behind System/360 was to use a single architecture for the
entire product line of computers.<span id="fnref:variants"><a href="#fn:variants">3</a></span>
The name symbolized “360 degrees to cover the entire circle of possible uses.”
Using a common architecture seems obvious now (e.g. x86),
but prior to the System/360, IBM (like other computer manufacturers) produced multiple computers with entirely incompatible architectures.</p>
<p>Internally, the different System/360 models had completely different implementations to support a wide range of cost and performance levels:
the fastest model was over 1000 times as powerful as the slowest.
Low-end models used simple hardware and an 8-bit datapath while advanced models used wide datapaths, fast semiconductor registers, out-of-order instruction execution, and caches.<span id="fnref:architectures"><a href="#fn:architectures">2</a></span>
Despite these internal differences, the models all looked the same to the programmer.</p>


<h2>Architecture of System/360<span id="fnref:princops"><a href="#fn:princops">4</a></span></h2>
<p>You might expect a computer architecture from the 1960s to be simple, but System/360 is remarkably complex, partly because it merged six computer families into
one architecture. <!-- Computer Architecture: Concepts and Evolution, p693. -->
It is a 32-bit architecture that supports many datatypes.
As well as 32-bit integers and half words,
it supports decimal arithmetic on numbers up to 31 digits long.
Floating-point arithmetic supports short (32 bit), long (64 bit), or extended (128 bit) values.
The processor also supports character strings up to 256 bytes long.
<!--
The System/360 architecture supports 16 32-bit general registers and four 64-bit floating-point registers.
--></p>
<p>The System/360 instruction set has about 100 different instructions and several addressing modes.
Some of these instructions are straightforward arithmetic, logic, or control operations.
Other instructions are more complex, such as the &#34;character move&#34; that copies up to 256 characters in memory,
or the floating-point instructions.</p>
<p>One of the most complex instructions is &#34;edit&#34;,
which formats a sequence of decimal digits for printing, for example inserting commas, a minus sign, or decimal point; removing leading zeroes, or
filling leading spaces with characters.
The number 1234567 could be &#34;edited&#34; into the string &#34;$***12,345.67&#34; for printing on a check.
Keep in mind that this is a <em>single</em> instruction, not a library function like <code>printf</code>.</p>
<!--
System/360 instructions are two, four, or six bytes long and fall into six classes.
RR (register-register), RS (register-storage), RX (register to indexed-storage), SI (storage and immediate operand), and SS (storage-storage).
I'll give some examples of instructions so you can get an idea of what the processor does.
A typical RR (register-register) operation is multiplication.
The instruction below multiplies the values in registers 2 and 3.
While this may seem straightforward, this instruction requires many internal steps because multiplication is implemented through repeated binary addition.
<pre>M 2, 3</pre>

A typical register-to-register floating-point operation is addition.
The instruction below adds the 64-bit floating-point registers 4 and 6.
This is considerably more complex than an integer addition since
the numbers must be shifted so the decimal points line up before adding, and then the correct exponent must be calculated.
<pre>ADR 4, 6</pre>

The RX subtraction instruction below generates a memory address by adding the displacement constant 23 to the contents of general registers 4 and 5.
The value in this memory location is subtracted from register 1.
<pre>S 1, 23(4, 5)</pre>

The variable-length SS (storage-to-storage) instructions add more complications. For example, the character move instruction below copies 200 bytes between
two memory addresses, both with displacements.
<pre>MVC 123(200,4), 456(5)</pre>

-->

<!-- http://www.bitsavers.org/pdf/ibm/360/training/C20-1646-1_A_Programmers_Introduction_To_IBM_System360_Assembler_Language_May66.pdf -->

<!--
The need to support both scientific and business applications made the System/360 architecture surprisingly complex for a 1964 system.
Scientific applications required extensive floating-point instructions.
Business applications used special datatypes such as 
zoned decimal (representing a decimal number on a punch card) and packed decimal (efficiently storing two decimal digits per byte).
-->

<p><a href="https://static.righto.com/images/ibm-360-50/IBM_system_360-50_console_-_MfK_Bern.jpg"><img alt="IBM System/360 Model 50 control panel. The dataflow diagram in the upper right illustrates the system&#39;s internal design. Photo by Sandstein, CC BY-SA 3.0." height="476" src="https://static.righto.com/images/ibm-360-50/IBM_system_360-50_console_-_MfK_Bern-w400.jpg" title="IBM System/360 Model 50 control panel. The dataflow diagram in the upper right illustrates the system&#39;s internal design. Photo by Sandstein, CC BY-SA 3.0." width="400"/></a></p><p>IBM System/360 Model 50 control panel. The dataflow diagram in the upper right illustrates the system&#39;s internal design. Photo by <a href="https://commons.wikimedia.org/wiki/File:IBM_system_360-50_console_-_MfK_Bern.jpg">Sandstein</a>, <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">CC BY-SA 3.0</a>.</p>
<p>The System/360 architecture also included I/O, defining IBM&#39;s &#34;channel&#34; architecture.
A channel is a programmable I/O subsystem with its own instruction set.
On larger systems, the channel was an independent unit connected to the computer. But smaller systems such as the Model 50 used the same microcode engine to run
CPU programs and channel programs.</p>
<p>The point is that System/360 has a large and complex instruction set. A single instruction could result in hundreds of memory accesses and processing steps.
The dense instruction set helped programmers to cram programs into the extremely limited core memory of the 1960s.
However, the complex instruction set was a problem for the computer designer, who had to implement the complex circuitry to carry out these instructions.
The solution was microcode.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/model-50-ibm.jpg"><img alt="The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM." height="396" src="https://static.righto.com/images/ibm-360-50/model-50-ibm-w500.jpg" title="The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM." width="500"/></a></p><p>The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM.</p>
<h2>Microcode</h2>
<p>One of the hardest parts of computer design is creating the control logic that tells each part of the processor how to carry out each instruction.
In 1951, Maurice Wilkes came up with the idea of microcode: instead of building the control circuitry from complex logic gates, the control logic could be replaced with code (i.
e.
microcode) stored in a special memory called a control store.
To execute an instruction, the computer internally executes several simpler microinstructions, specified by the microcode.
Microcode turns the processor&#39;s control logic into a programming task instead of a logic design task.<span id="fnref:control"><a href="#fn:control">5</a></span></p>
<p>Microcode played a key role in the success of the System/360, helping IBM produce a line of computers with the same instruction set architecture but widely different implementations.
It also allowed a processor to support different instruction sets;
System/360 machines could be backward compatible with customers&#39; older machines<span id="fnref:compatibility"><a href="#fn:compatibility">6</a></span>
so customers could keep their existing software.
For these reasons, the System/360 computers used microcode unless there was a compelling reason not to.<span id="fnref:non-microcode"><a href="#fn:non-microcode">7</a></span></p>
<p>Another advantage of microcode is that it provides an easy way to fix design flaws and bugs in the field. Instead of modifying the hardware, a service engineer could
replace the microcode with a new version. The photo below shows a copper sheet with microcode etched into it for the Model 50.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/ibm_bcros_full.jpg"><img alt="A replaceable BCROS sheet, holding 17,600 bits. Photo courtesy of Glenn&#39;s Computer Museum." height="395" src="https://static.righto.com/images/ibm-360-50/ibm_bcros_full-w500.jpg" title="A replaceable BCROS sheet, holding 17,600 bits. Photo courtesy of Glenn&#39;s Computer Museum." width="500"/></a></p>
<p>Microcode can be implemented in a variety of ways.
Many computers use &#34;vertical microcode&#34;, where a microcode instruction is similar to a machine instruction, just less complicated.
The System/360 designs, on the other hand, used &#34;horizontal microcode&#34;, with complex, wide instructions of up to 100 bits, depending on the model.
These microinstructions were more like a collection of fields, each controlling low-level signals.
This improved performance since multiple parts of the processor could be controlled in parallel. </p>
<h2>Hardware of the Model 50<span id="fnref:refs"><a href="#fn:refs">8</a></span></h2>
<p>The Model 50 was roughly in the middle of the System/360 lineup, providing a powerful mainframe that could be used by a medium-sized business or university department.
The Model 50
<a href="https://books.google.com/books?id=pFzxLUAnSS8C&amp;lpg=PA88&amp;dq=ibm%20360%20rental%20price%20%22model%2030%22%20-computerworld&amp;pg=PA88#v=onepage&amp;q=ibm%20360%20&amp;f=false">typically</a>
<a href="https://books.google.com/books?id=xLTiBQAAQBAJ&amp;lpg=PA213&amp;dq=ibm%20360%20rental%20price%20%22model%2050%22%20-computerworld&amp;pg=PA213#v=onepage&amp;q=%20%22model%2040%22%20&amp;f=false">rented</a> for about $18,000 - $32,000 per month (equivalent to $120,000-$200,000 a month in current dollars).</p>
<!--
It could be expanded with 8 more megabytes externally;
each IBM 2361 "Large Capacity Storage" unit held 2 megabytes of core memory and weighed a ton.
-->

<p><a href="https://static.righto.com/images/ibm-360-50/ibm-360-50.png"><img alt="IBM S/360 Model 50. The console was attached to the main frame, about 5 feet deep. The storage frame and power frame are the black cabinets at the back. Photo from Pinterest." height="343" src="https://static.righto.com/images/ibm-360-50/ibm-360-50-w500.png" title="IBM S/360 Model 50. The console was attached to the main frame, about 5 feet deep. The storage frame and power frame are the black cabinets at the back. Photo from Pinterest." width="500"/></a></p><p>IBM S/360 Model 50. The console was attached to the main frame, about 5 feet deep. The storage frame and power frame are the black cabinets at the back. Photo from <a href="https://www.pinterest.com/pin/123145371033491049/">Pinterest</a>.</p>
<p>The Model 50 occupied three large cabinets, each 5 feet long, about 2 feet wide, 6 feet tall, and weighing nearly a ton each.<span id="fnref:dimensions"><a href="#fn:dimensions">9</a></span>
The main frame, behind the console, contained the CPU, I/O channel circuitry, and the microcode storage.
Behind this, the power cabinet contained the computer&#39;s power supplies.
To the left, the cabinet at the back contained the main storage: one or two core memory modules, each with 128 kilobytes of memory.
(I wrote in detail about the <a href="https://www.righto.com/2019/04/a-look-at-ibm-s360-core-memory-in-1960s.html">Model 50&#39;s core memory</a> earlier.)
The computer&#39;s cables ran under a raised floor to the I/O devices, which typically included tape drives, a card reader, printers, disk drives, I/O controllers, and so forth.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/ibm-360-50-frames.png"><img alt="This diagram shows the three frames that made up the basic S/360 Model 50. Source: Model 50 Maintenance Manual page 138." height="326" src="https://static.righto.com/images/ibm-360-50/ibm-360-50-frames-w500.png" title="This diagram shows the three frames that made up the basic S/360 Model 50. Source: Model 50 Maintenance Manual page 138." width="500"/></a></p><p>This diagram shows the three frames that made up the basic S/360 Model 50. Source: <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/SY22-2832-4_360-50Maint.pdf">Model 50 Maintenance Manual</a> page 138.</p>
<p>The System/360 processors weren&#39;t implemented with integrated circuits, but with SLT (Solid Logic Technology) modules, hybrid modules that contain a few transistors, diodes,
and resistors.
A typical module implemented a logic gate, so it takes many circuit boards full of modules to construct the processor.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/logic-board.jpg"><img alt="A logic board using SLT modules. Each square metal can is a module." height="331" src="https://static.righto.com/images/ibm-360-50/logic-board-w300.jpg" title="A logic board using SLT modules. Each square metal can is a module." width="300"/></a></p><p>A logic board using SLT modules. Each square metal can is a module.</p>
<p>Like most computers of the 1960s, the Model 50 used magnetic core memory, with a tiny ferrite ring to store each bit.
The photo below shows a core plane that stores 32768 bits (along with 512 bits for I/O).
A stack of 18 planes formed a 64-kilobyte memory module, with two parity bits.<span id="fnref:core"><a href="#fn:core">10</a></span></p>
<p><a href="https://static.righto.com/images/ibm-360-50/core-plane-50.jpg"><img alt="A Model 50 core plane is arranged as a grid of cores. The Y lines run horizontally. X and sense/inhibit lines run vertically. The sense/inhibit lines form loops at the top and bottom. Each of the four vertical pairs of blocks has separate sense/inhibit lines. Each core plane was about 10¾ × 6¾ × ⅛ inches." height="260" src="https://static.righto.com/images/ibm-360-50/core-plane-50-w500.jpg" title="A Model 50 core plane is arranged as a grid of cores. The Y lines run horizontally. X and sense/inhibit lines run vertically. The sense/inhibit lines form loops at the top and bottom. Each of the four vertical pairs of blocks has separate sense/inhibit lines. Each core plane was about 10¾ × 6¾ × ⅛ inches." width="500"/></a></p><p>A Model 50 core plane is arranged as a grid of cores. The Y lines run horizontally. X and sense/inhibit lines run vertically. The sense/inhibit lines form loops at the top and bottom. Each of the four vertical pairs of blocks has separate sense/inhibit lines. Each core plane was about 10¾ × 6¾ × ⅛ inches.</p>
<h2>The Model 50&#39;s internal architecture</h2>


<blockquote cite="http://www.bitsavers.org/pdf/ibm/360/fe/2040/SY22-2840-2_Model_40_Comprehensive_Introduction_Apr70.pdf">
<p>
To the programmer, all processors within System/360 look the same; internal circuitry, however,
may be entirely different.
</p></blockquote>

<p>It&#39;s important to keep in mind that the internal architecture of the Model 50 is very different from the architecture that the programmer sees.<span id="fnref:programmer"><a href="#fn:programmer">11</a></span>
In particular, the processor&#39;s internal registers are invisible to the programmer.
The programmer instead sees 16 general-purpose registers and 4 floating-point registers, but to the processor these are part of the 64-word local store, a small high-speed core memory.</p>
<p>The diagram below shows the complex data flow through the computer.<span id="fnref:dataflow"><a href="#fn:dataflow">12</a></span>
The black boxes are internal registers; the processor has a surprisingly large number of registers, used for a variety of purposes.
The internal components are connected by buses.
Most of the internal communication is over the 32-bit buses, shown in black. The 8-bit &#34;mover&#34; bus is shown in gray.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/diagram.jpg"><img alt="This diagram shows the data flow through the IBM 360/50 and appears in the upper-right corner of the console. I drew this version since I couldn&#39;t find a clear photo of it." height="434" src="https://static.righto.com/images/ibm-360-50/diagram-w900.jpg" title="This diagram shows the data flow through the IBM 360/50 and appears in the upper-right corner of the console. I drew this version since I couldn&#39;t find a clear photo of it." width="900"/></a></p><p>This diagram shows the data flow through the IBM 360/50 and appears in the upper-right corner of the console. I drew this version since I couldn&#39;t find a clear photo of it.</p>
<p>The heart of the computer is the 32-bit adder, which performs addition.
For subtraction, the argument is complemented by the True/Complement circuit (TC).
The adder has an associated shifter to perform bit-shifts; this is especially important for multiplication, division, and floating-point calculations.
Operating in parallel with the adder is the &#34;mover&#34;, which operates on bytes. It can extract a byte from a 32-bit word, as well as manipulating 4-bit pieces of the byte.
The mover also performs Boolean operations (AND, OR, XOR).
(Unlike most processors, the Model 50 separates arithmetic and logical operations, instead of having an ALU perform both.)</p>
<p>The computer&#39;s main core-memory storage is on the left. To access memory, an address is put in the Storage Address Register (SAR). Data is then read or written through the Storage
Data Register (SDR). To the left of main storage, is the Instruction Address Register (the Program Counter or PC in modern terms).
At the top is the Local Store, 64 words of high-speed core memory that holds the programmer&#39;s registers as well as some internal storage.
The local store is accessed through the Local Store Address Register (LSAR).</p>
<p>At the right are the I/O channels: the low-speed Multiplexor Channel and the high-speed Selector Channel.
You can think of these as DMA (direct memory access) paths for I/O.
The multiplexor channel communicates over an 8-bit bus through the mover, while the selector channel communicates over a 32-bit bus.
Although the channels are conceptually separate from the processor, the channels use the same buses, circuitry, and microcode engine as the processor.
This limits I/O performance compared to more advanced System/360 models that have independent circuitry for the channels.</p>
<h2>An example of the microcode</h2>
<p>As you can see, the processor has many registers and functional units. The microcode needs to control these components to carry out program instructions.
The microcode architecture is very complex and takes over 100 pages to explain thoroughly,<span id="fnref:microcode-ref"><a href="#fn:microcode-ref">15</a></span>
so I&#39;m only able to scratch the surface here.
Each microinstruction is 90 bits long and performs multiple tasks.
In the documentation, IBM used an 11-line block to represent each microinstruction, showing all the activities that are taking place in parallel.</p>
<p>A sample microinstruction is shown below, part of the microcode that implements an add instruction.
At this point, earlier microinstructions have fetched and decoded the instruction and put the arguments into the R and L registers.
This microinstruction performs the actual 32-bit addition, but there&#39;s a lot more happening than just the addition.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/microcode-diagram.jpg"><img alt="One microinstruction, part of the integer addition code. This microinstruction is at micro-address 0220." height="354" src="https://static.righto.com/images/ibm-360-50/microcode-diagram-w500.jpg" title="One microinstruction, part of the integer addition code. This microinstruction is at micro-address 0220." width="500"/></a></p><p>One microinstruction, part of the integer addition code. This microinstruction is at micro-address 0220.</p>
<p>Starting with the line &#34;R+L→R&#34; (red), this indicates that the ALU is taking inputs from registers R and L, and the result is going into the R register.
In other words, the two arguments are added.
The result R is stored into the desired programmer-visible register in local storage (blue).
The processor registers FN and J select the address in local storage.
Meanwhile, the <code>SETCRALG</code> line sets the Condition code register based on the sign (i.e. &#34;algebraic&#34; value) of the result, indicating if the result is positive,
negative, or zero.</p>
<p>The line &#34;BC⩝C&#34; indicates that signed overflow is detected and used as the carry flag<span id="fnref:carry"><a href="#fn:carry">14</a></span>
while CAR (yellow) indicates the microcode branches on this carry (overflow) value.
Thus, the microcode will take one path if the addition was valid and a second error path if overflow occurred.
<!--
In System/360 overflpw interrupts are enabled by bit 36 of the Processor Status Word.
This microinstruction prepares for the next microinstruction to test this bit.
-->
A microinstruction can &#34;emit&#34; an arbitrary 4-bit value (green) which can be used in a variety of ways.
In this case, the binary value 1000 is emitted, fed into the W register, and then the M register, for use by the next microinstruction.
As you can see, the CPU performs many activities in parallel for one microinstruction, which increases the computer&#39;s performance.</p>
<p>All the activities of a microinstruction are
encoded into a 90-bit word consisting of 28 fields.<span id="fnref:bitstream"><a href="#fn:bitstream">13</a></span>
The microinstruction discussed above (micro-address 0220) is highlighted in the documentation below.
A single microinstruction is very complex, which is why it takes an 11-line block of text to represent it.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/bitstream.jpg"><img alt="Part of the microcode listing. The previously-discussed microinstruction is highlighted. Note that the micro-address 0220 matches the address in the upper-left corner of the microinstruction diagram." height="101" src="https://static.righto.com/images/ibm-360-50/bitstream-w800.jpg" title="Part of the microcode listing. The previously-discussed microinstruction is highlighted. Note that the micro-address 0220 matches the address in the upper-left corner of the microinstruction diagram." width="800"/></a></p><p>Part of the <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol20_Sep72.pdf">microcode listing</a>. The previously-discussed microinstruction is highlighted. Note that the micro-address 0220 matches the address in the upper-left corner of the microinstruction diagram.</p>
<p>The processor documentation contains hundreds of pages of microcode;<span id="fnref:listing"><a href="#fn:listing">16</a></span> one page of the floating-point multiply code is below.
Each box is one microinstruction, and the lines between them indicate the complex control paths.
I&#39;m not going to explain this microcode,<span id="fnref:explanation"><a href="#fn:explanation">17</a></span> but I wanted to show its complexity.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/fp-microcode.jpg"><img alt="Part of the floating-point multiply microcode. (Click for a larger view.) From ALD vol 18." height="452" src="https://static.righto.com/images/ibm-360-50/fp-microcode-w700.jpg" title="Part of the floating-point multiply microcode. (Click for a larger view.) From ALD vol 18." width="700"/></a></p><p>Part of the floating-point multiply microcode. (Click for a larger view.) From <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol18_Sep72.pdf">ALD vol 18</a>.</p>
<h2>The console</h2>
<p>The discussion above has shown the complex internal architecture of the Model 50. The numerous lights and controls on the console<span id="fnref:console"><a href="#fn:console">19</a></span> provide a view into this internal state.
There were three main uses for the console.
The first use was basic &#34;operator control&#34; tasks such as turning the system on, booting it, or powering it off, using the controls in the lower section of the console.
These controls were consistent across the S/360 line and were usually the only controls the operator needed.
The three hexadecimal dials in the lower right selected the I/O unit that held the boot software.
Once the system had booted, the operator generally typed commands into the system rather than using the console.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/ibm-360-50-marc.jpg"><img alt="Control panel of the IBM System/360 Model 50. This panel has marginal check controls for auxiliary storage in the upper right, replacing the dataflow diagram." height="613" src="https://static.righto.com/images/ibm-360-50/ibm-360-50-marc-w450.jpg" title="Control panel of the IBM System/360 Model 50. This panel has marginal check controls for auxiliary storage in the upper right, replacing the dataflow diagram." width="450"/></a></p><p>Control panel of the IBM System/360 Model 50. This panel has marginal check controls for auxiliary storage in the upper right, replacing the dataflow diagram.</p>
<p>The second console function was &#34;operator intervention&#34;: program debugging tasks such as examining and modifying memory or registers
and setting breakpoints.
The lights and toggle switches in the lower half of the console were used for operator intervention.
The operator could enter a 24-bit address using the row of 24 toggle switches, and enter a 32-bit data value
using the row of 32 toggle switches above.
The lights allowed the contents of memory to be examined.
With other switches, the operator could set a breakpoint, single-step through a program, and perform other
debugging operations.</p>
<p>The third console function was system maintenance and repair performed by an IBM customer engineer.
The customer engineering displays took up the top half of the console and provided detailed access to the computer&#39;s complex internal state.
To save space, the Model 50 had four roller knobs on the right side, with 8 positions for each knob.
Each knob position selected a different function for the row of 36 lights (32 bits plus parity).
The legends above the lights rotate with the knobs, showing the meaning of each light.
For example, one position would display the L register, while another position would display the current
microinstruction.
In the photo below, the upper roller and lights are displaying part of the microcode currently being executed (ROS = Read Only Store).
The roller below shows some of the internal registers and counters.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/rollers.jpg"><img alt="Closeup of two rollers and the associated lights." height="215" src="https://static.righto.com/images/ibm-360-50/rollers-w500.jpg" title="Closeup of two rollers and the associated lights." width="500"/></a></p><p>Closeup of two rollers and the associated lights.</p>
<p>Finally, the voltmeter and voltage control knobs in the upper left of the console were used by an IBM customer engineer for &#34;marginal checking&#34;. By raising and lowering the voltage levels, borderline components could be detected and replaced before they caused problems.</p>
<h2>The simulator</h2>
<p>The simulator is at <a href="http://righto.com/360">righto.com/360</a> and the code is on <a href="https://github.com/shirriff/ibm-system-360-50-simulator">Github</a>.
I implemented the simulator in JavaScript so it can run in a browser. It runs a sample program by executing the Model 50&#39;s microcode, simulating each microinstruction
and the hardware.
Each microinstruction is displayed graphically, along with the current instruction, the registers, the local storage, and core memory.
It displays the console lights accurately based on the internal state, on a zoomable virtual console.
Each row of lights can display 8 different elements, which you can change by clicking on a roller.
You can step also through the microcode, one microinstruction at a time.</p>
<p>This simulator is still under development so don&#39;t expect it to work perfectly. I also haven&#39;t implemented the toggle switches, so you can&#39;t enter a program from
the console yet.
I also need to implement the I/O system, which has its own registers and a different microcode format.</p>
<p>To build the simulator, I extracted the binary microcode from the <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol20_Sep72.pdf">listings</a> using a custom OCR tool.
I implemented the hundreds of micro-operations, which were tricky to get correct.
While most micro-operations are simple operations such as moving a register to the bus, some microinstructions are much more complex, especially for floating-point
operations.<span id="fnref:edfp"><a href="#fn:edfp">20</a></span>
Another complication is that a microinstruction performs many tasks in parallel and it was hard to determine the exact order in which to perform them.
<!--
(For example, if a register is loaded, added, and compared in the same microinstruction, does the addition use the old value or the new value?)
--></p>
<p>My eventual goal with the simulator is to move it into the physical world. Specifically, I plan to drive the lights on CuriousMarc&#39;s <a href="https://www.youtube.com/watch?v=WS-WtjwAAO0">Model 50 control panel</a> to make the panel
operate accurately. We also plan to hook up his IBM tape drives and card reader so we can have all the pieces
of a Model 50 mainframe working together, except for the processor itself.
I plan to port the simulator to C so I can run it in a microcontroller to drive the physical console.
An FPGA implementation is another possibility; this would provide the maximum speed, but would be harder to implement.
I announce my latest blog posts on Twitter, so follow me <a href="https://twitter.com/kenshirriff">@kenshirriff</a> for updates and future articles. I also have an <a href="https://www.righto.com/feeds/posts/default">RSS feed</a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
