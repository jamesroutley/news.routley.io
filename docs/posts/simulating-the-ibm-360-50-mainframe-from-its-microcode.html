<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2022/01/ibm360model50.html">Original</a>
    <h1>Simulating the IBM 360/50 mainframe from its microcode</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1556663171519058512" itemprop="description articleBody">


<p>The IBM System/360 was a groundbreaking family of mainframe computers announced on April 7, 1964.
System/360 was an extremely risky &#34;bet-the-company&#34; project for IBM, costing over $5 billion, but 
the System/360 ended up as a huge success,
setting the direction of the computer industry for decades.
The S/360 architecture was so successful that it is still supported by IBM&#39;s latest mainframes, almost 60 years later.
I&#39;m developing a microcode-level simulator<span id="fnref:simulator"><a href="#fn:simulator">1</a></span>
for the IBM System/360 Model 50
(<a href="http://righto.com/360">link to the simulator</a>);
this blog post provides background to understand the Model 50 and the simulator.</p>
<p><a href="https://righto.com/360"><img alt="Screenshot of the simulator running in a browser." height="387" src="https://static.righto.com/images/ibm-360-50/screenshot-w450.jpg" title="Screenshot of the simulator running in a browser." width="450"/></a></p><p>Screenshot of the simulator running in a browser.</p>
<p>The radical decision behind System/360 was to use a single architecture for the
entire product line of computers.<span id="fnref:variants"><a href="#fn:variants">3</a></span>
The name symbolized “360 degrees to cover the entire circle of possible uses.”
Using a common architecture seems obvious now (e.g. x86),
but prior to the System/360, IBM (like other computer manufacturers) produced multiple computers with entirely incompatible architectures.</p>
<p>Internally, the different System/360 models had completely different implementations to support a wide range of cost and performance levels:
the fastest model was over 1000 times as powerful as the slowest.
Low-end models used simple hardware and an 8-bit datapath while advanced models used wide datapaths, fast semiconductor registers, out-of-order instruction execution, and caches.<span id="fnref:architectures"><a href="#fn:architectures">2</a></span>
Despite these internal differences, the models all looked the same to the programmer.</p>


<h2>Architecture of System/360<span id="fnref:princops"><a href="#fn:princops">4</a></span></h2>
<p>You might expect a computer architecture from the 1960s to be simple, but System/360 is remarkably complex, partly because it merged six computer families into
one architecture. <!-- Computer Architecture: Concepts and Evolution, p693. -->
It is a 32-bit architecture that supports many datatypes.
As well as 32-bit integers and half words,
it supports decimal arithmetic on numbers up to 31 digits long.
Floating-point arithmetic supports short (32 bit), long (64 bit), or extended (128 bit) values.
The processor also supports character strings up to 256 bytes long.
<!--
The System/360 architecture supports 16 32-bit general registers and four 64-bit floating-point registers.
--></p>
<p>The System/360 instruction set has about 100 different instructions and several addressing modes.
Some of these instructions are straightforward arithmetic, logic, or control operations.
Other instructions are more complex, such as the &#34;character move&#34; that copies up to 256 characters in memory,
or the floating-point instructions.</p>
<p>One of the most complex instructions is &#34;edit&#34;,
which formats a sequence of decimal digits for printing, for example inserting commas, a minus sign, or decimal point; removing leading zeroes, or
filling leading spaces with characters.
The number 1234567 could be &#34;edited&#34; into the string &#34;$***12,345.67&#34; for printing on a check.
Keep in mind that this is a <em>single</em> instruction, not a library function like <code>printf</code>.</p>
<!--
System/360 instructions are two, four, or six bytes long and fall into six classes.
RR (register-register), RS (register-storage), RX (register to indexed-storage), SI (storage and immediate operand), and SS (storage-storage).
I'll give some examples of instructions so you can get an idea of what the processor does.
A typical RR (register-register) operation is multiplication.
The instruction below multiplies the values in registers 2 and 3.
While this may seem straightforward, this instruction requires many internal steps because multiplication is implemented through repeated binary addition.
<pre>M 2, 3</pre>

A typical register-to-register floating-point operation is addition.
The instruction below adds the 64-bit floating-point registers 4 and 6.
This is considerably more complex than an integer addition since
the numbers must be shifted so the decimal points line up before adding, and then the correct exponent must be calculated.
<pre>ADR 4, 6</pre>

The RX subtraction instruction below generates a memory address by adding the displacement constant 23 to the contents of general registers 4 and 5.
The value in this memory location is subtracted from register 1.
<pre>S 1, 23(4, 5)</pre>

The variable-length SS (storage-to-storage) instructions add more complications. For example, the character move instruction below copies 200 bytes between
two memory addresses, both with displacements.
<pre>MVC 123(200,4), 456(5)</pre>

-->

<!-- http://www.bitsavers.org/pdf/ibm/360/training/C20-1646-1_A_Programmers_Introduction_To_IBM_System360_Assembler_Language_May66.pdf -->

<!--
The need to support both scientific and business applications made the System/360 architecture surprisingly complex for a 1964 system.
Scientific applications required extensive floating-point instructions.
Business applications used special datatypes such as 
zoned decimal (representing a decimal number on a punch card) and packed decimal (efficiently storing two decimal digits per byte).
-->

<p><a href="https://static.righto.com/images/ibm-360-50/IBM_system_360-50_console_-_MfK_Bern.jpg"><img alt="IBM System/360 Model 50 control panel. The dataflow diagram in the upper right illustrates the system&#39;s internal design. Photo by Sandstein, CC BY-SA 3.0." height="476" src="https://static.righto.com/images/ibm-360-50/IBM_system_360-50_console_-_MfK_Bern-w400.jpg" title="IBM System/360 Model 50 control panel. The dataflow diagram in the upper right illustrates the system&#39;s internal design. Photo by Sandstein, CC BY-SA 3.0." width="400"/></a></p><p>IBM System/360 Model 50 control panel. The dataflow diagram in the upper right illustrates the system&#39;s internal design. Photo by <a href="https://commons.wikimedia.org/wiki/File:IBM_system_360-50_console_-_MfK_Bern.jpg">Sandstein</a>, <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">CC BY-SA 3.0</a>.</p>
<p>The System/360 architecture also included I/O, defining IBM&#39;s &#34;channel&#34; architecture.
A channel is a programmable I/O subsystem with its own instruction set.
On larger systems, the channel was an independent unit connected to the computer. But smaller systems such as the Model 50 used the same microcode engine to run
CPU programs and channel programs.</p>
<p>The point is that System/360 has a large and complex instruction set. A single instruction could result in hundreds of memory accesses and processing steps.
The dense instruction set helped programmers to cram programs into the extremely limited core memory of the 1960s.
However, the complex instruction set was a problem for the computer designer, who had to implement the complex circuitry to carry out these instructions.
The solution was microcode.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/model-50-ibm.jpg"><img alt="The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM." height="396" src="https://static.righto.com/images/ibm-360-50/model-50-ibm-w500.jpg" title="The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM." width="500"/></a></p><p>The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM.</p>
<h2>Microcode</h2>
<p>One of the hardest parts of computer design is creating the control logic that tells each part of the processor how to carry out each instruction.
In 1951, Maurice Wilkes came up with the idea of microcode: instead of building the control circuitry from complex logic gates, the control logic could be replaced with code (i.
e.
microcode) stored in a special memory called a control store.
To execute an instruction, the computer internally executes several simpler microinstructions, specified by the microcode.
Microcode turns the processor&#39;s control logic into a programming task instead of a logic design task.<span id="fnref:control"><a href="#fn:control">5</a></span></p>
<p>Microcode played a key role in the success of the System/360, helping IBM produce a line of computers with the same instruction set architecture but widely different implementations.
It also allowed a processor to support different instruction sets;
System/360 machines could be backward compatible with customers&#39; older machines<span id="fnref:compatibility"><a href="#fn:compatibility">6</a></span>
so customers could keep their existing software.
For these reasons, the System/360 computers used microcode unless there was a compelling reason not to.<span id="fnref:non-microcode"><a href="#fn:non-microcode">7</a></span></p>
<p>Another advantage of microcode is that it provides an easy way to fix design flaws and bugs in the field. Instead of modifying the hardware, a service engineer could
replace the microcode with a new version. The photo below shows a copper sheet with microcode etched into it for the Model 50.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/ibm_bcros_full.jpg"><img alt="A replaceable BCROS sheet, holding 17,600 bits. Photo courtesy of Glenn&#39;s Computer Museum." height="395" src="https://static.righto.com/images/ibm-360-50/ibm_bcros_full-w500.jpg" title="A replaceable BCROS sheet, holding 17,600 bits. Photo courtesy of Glenn&#39;s Computer Museum." width="500"/></a></p><div><p>A replaceable BCROS sheet, holding 17,600 bits. Photo courtesy of <a href="http://www.glennsmuseum.com/ibm/ibm.html">Glenn&#39;s Computer Museum</a>.</p></div>
<p>Microcode can be implemented in a variety of ways.
Many computers use &#34;vertical microcode&#34;, where a microcode instruction is similar to a machine instruction, just less complicated.
The System/360 designs, on the other hand, used &#34;horizontal microcode&#34;, with complex, wide instructions of up to 100 bits, depending on the model.
These microinstructions were more like a collection of fields, each controlling low-level signals.
This improved performance since multiple parts of the processor could be controlled in parallel. </p>
<h2>Hardware of the Model 50<span id="fnref:refs"><a href="#fn:refs">8</a></span></h2>
<p>The Model 50 was roughly in the middle of the System/360 lineup, providing a powerful mainframe that could be used by a medium-sized business or university department.
The Model 50
<a href="https://books.google.com/books?id=pFzxLUAnSS8C&amp;lpg=PA88&amp;dq=ibm%20360%20rental%20price%20%22model%2030%22%20-computerworld&amp;pg=PA88#v=onepage&amp;q=ibm%20360%20&amp;f=false">typically</a>
<a href="https://books.google.com/books?id=xLTiBQAAQBAJ&amp;lpg=PA213&amp;dq=ibm%20360%20rental%20price%20%22model%2050%22%20-computerworld&amp;pg=PA213#v=onepage&amp;q=%20%22model%2040%22%20&amp;f=false">rented</a> for about $18,000 - $32,000 per month (equivalent to $120,000-$200,000 a month in current dollars).</p>
<!--
It could be expanded with 8 more megabytes externally;
each IBM 2361 "Large Capacity Storage" unit held 2 megabytes of core memory and weighed a ton.
-->

<p><a href="https://static.righto.com/images/ibm-360-50/ibm-360-50.png"><img alt="IBM S/360 Model 50. The console was attached to the main frame, about 5 feet deep. The storage frame and power frame are the black cabinets at the back. Photo from Pinterest." height="343" src="https://static.righto.com/images/ibm-360-50/ibm-360-50-w500.png" title="IBM S/360 Model 50. The console was attached to the main frame, about 5 feet deep. The storage frame and power frame are the black cabinets at the back. Photo from Pinterest." width="500"/></a></p><p>IBM S/360 Model 50. The console was attached to the main frame, about 5 feet deep. The storage frame and power frame are the black cabinets at the back. Photo from <a href="https://www.pinterest.com/pin/123145371033491049/">Pinterest</a>.</p>
<p>The Model 50 occupied three large cabinets, each 5 feet long, about 2 feet wide, 6 feet tall, and weighing nearly a ton each.<span id="fnref:dimensions"><a href="#fn:dimensions">9</a></span>
The main frame, behind the console, contained the CPU, I/O channel circuitry, and the microcode storage.
Behind this, the power cabinet contained the computer&#39;s power supplies.
To the left, the cabinet at the back contained the main storage: one or two core memory modules, each with 128 kilobytes of memory.
(I wrote in detail about the <a href="https://www.righto.com/2019/04/a-look-at-ibm-s360-core-memory-in-1960s.html">Model 50&#39;s core memory</a> earlier.)
The computer&#39;s cables ran under a raised floor to the I/O devices, which typically included tape drives, a card reader, printers, disk drives, I/O controllers, and so forth.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/ibm-360-50-frames.png"><img alt="This diagram shows the three frames that made up the basic S/360 Model 50. Source: Model 50 Maintenance Manual page 138." height="326" src="https://static.righto.com/images/ibm-360-50/ibm-360-50-frames-w500.png" title="This diagram shows the three frames that made up the basic S/360 Model 50. Source: Model 50 Maintenance Manual page 138." width="500"/></a></p><p>This diagram shows the three frames that made up the basic S/360 Model 50. Source: <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/SY22-2832-4_360-50Maint.pdf">Model 50 Maintenance Manual</a> page 138.</p>
<p>The System/360 processors weren&#39;t implemented with integrated circuits, but with SLT (Solid Logic Technology) modules, hybrid modules that contain a few transistors, diodes,
and resistors.
A typical module implemented a logic gate, so it takes many circuit boards full of modules to construct the processor.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/logic-board.jpg"><img alt="A logic board using SLT modules. Each square metal can is a module." height="331" src="https://static.righto.com/images/ibm-360-50/logic-board-w300.jpg" title="A logic board using SLT modules. Each square metal can is a module." width="300"/></a></p><p>A logic board using SLT modules. Each square metal can is a module.</p>
<p>Like most computers of the 1960s, the Model 50 used magnetic core memory, with a tiny ferrite ring to store each bit.
The photo below shows a core plane that stores 32768 bits (along with 512 bits for I/O).
A stack of 18 planes formed a 64-kilobyte memory module, with two parity bits.<span id="fnref:core"><a href="#fn:core">10</a></span></p>
<p><a href="https://static.righto.com/images/ibm-360-50/core-plane-50.jpg"><img alt="A Model 50 core plane is arranged as a grid of cores. The Y lines run horizontally. X and sense/inhibit lines run vertically. The sense/inhibit lines form loops at the top and bottom. Each of the four vertical pairs of blocks has separate sense/inhibit lines. Each core plane was about 10¾ × 6¾ × ⅛ inches." height="260" src="https://static.righto.com/images/ibm-360-50/core-plane-50-w500.jpg" title="A Model 50 core plane is arranged as a grid of cores. The Y lines run horizontally. X and sense/inhibit lines run vertically. The sense/inhibit lines form loops at the top and bottom. Each of the four vertical pairs of blocks has separate sense/inhibit lines. Each core plane was about 10¾ × 6¾ × ⅛ inches." width="500"/></a></p><p>A Model 50 core plane is arranged as a grid of cores. The Y lines run horizontally. X and sense/inhibit lines run vertically. The sense/inhibit lines form loops at the top and bottom. Each of the four vertical pairs of blocks has separate sense/inhibit lines. Each core plane was about 10¾ × 6¾ × ⅛ inches.</p>
<h2>The Model 50&#39;s internal architecture</h2>


<blockquote cite="http://www.bitsavers.org/pdf/ibm/360/fe/2040/SY22-2840-2_Model_40_Comprehensive_Introduction_Apr70.pdf">
<p>
To the programmer, all processors within System/360 look the same; internal circuitry, however,
may be entirely different.
</p></blockquote>

<p>It&#39;s important to keep in mind that the internal architecture of the Model 50 is very different from the architecture that the programmer sees.<span id="fnref:programmer"><a href="#fn:programmer">11</a></span>
In particular, the processor&#39;s internal registers are invisible to the programmer.
The programmer instead sees 16 general-purpose registers and 4 floating-point registers, but to the processor these are part of the 64-word local store, a small high-speed core memory.</p>
<p>The diagram below shows the complex data flow through the computer.<span id="fnref:dataflow"><a href="#fn:dataflow">12</a></span>
The black boxes are internal registers; the processor has a surprisingly large number of registers, used for a variety of purposes.
The internal components are connected by buses.
Most of the internal communication is over the 32-bit buses, shown in black. The 8-bit &#34;mover&#34; bus is shown in gray.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/diagram.jpg"><img alt="This diagram shows the data flow through the IBM 360/50 and appears in the upper-right corner of the console. I drew this version since I couldn&#39;t find a clear photo of it." height="434" src="https://static.righto.com/images/ibm-360-50/diagram-w900.jpg" title="This diagram shows the data flow through the IBM 360/50 and appears in the upper-right corner of the console. I drew this version since I couldn&#39;t find a clear photo of it." width="900"/></a></p><p>This diagram shows the data flow through the IBM 360/50 and appears in the upper-right corner of the console. I drew this version since I couldn&#39;t find a clear photo of it.</p>
<p>The heart of the computer is the 32-bit adder, which performs addition.
For subtraction, the argument is complemented by the True/Complement circuit (TC).
The adder has an associated shifter to perform bit-shifts; this is especially important for multiplication, division, and floating-point calculations.
Operating in parallel with the adder is the &#34;mover&#34;, which operates on bytes. It can extract a byte from a 32-bit word, as well as manipulating 4-bit pieces of the byte.
The mover also performs Boolean operations (AND, OR, XOR).
(Unlike most processors, the Model 50 separates arithmetic and logical operations, instead of having an ALU perform both.)</p>
<p>The computer&#39;s main core-memory storage is on the left. To access memory, an address is put in the Storage Address Register (SAR). Data is then read or written through the Storage
Data Register (SDR). To the left of main storage, is the Instruction Address Register (the Program Counter or PC in modern terms).
At the top is the Local Store, 64 words of high-speed core memory that holds the programmer&#39;s registers as well as some internal storage.
The local store is accessed through the Local Store Address Register (LSAR).</p>
<p>At the right are the I/O channels: the low-speed Multiplexor Channel and the high-speed Selector Channel.
You can think of these as DMA (direct memory access) paths for I/O.
The multiplexor channel communicates over an 8-bit bus through the mover, while the selector channel communicates over a 32-bit bus.
Although the channels are conceptually separate from the processor, the channels use the same buses, circuitry, and microcode engine as the processor.
This limits I/O performance compared to more advanced System/360 models that have independent circuitry for the channels.</p>
<h2>An example of the microcode</h2>
<p>As you can see, the processor has many registers and functional units. The microcode needs to control these components to carry out program instructions.
The microcode architecture is very complex and takes over 100 pages to explain thoroughly,<span id="fnref:microcode-ref"><a href="#fn:microcode-ref">15</a></span>
so I&#39;m only able to scratch the surface here.
Each microinstruction is 90 bits long and performs multiple tasks.
In the documentation, IBM used an 11-line block to represent each microinstruction, showing all the activities that are taking place in parallel.</p>
<p>A sample microinstruction is shown below, part of the microcode that implements an add instruction.
At this point, earlier microinstructions have fetched and decoded the instruction and put the arguments into the R and L registers.
This microinstruction performs the actual 32-bit addition, but there&#39;s a lot more happening than just the addition.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/microcode-diagram.jpg"><img alt="One microinstruction, part of the integer addition code. This microinstruction is at micro-address 0220." height="354" src="https://static.righto.com/images/ibm-360-50/microcode-diagram-w500.jpg" title="One microinstruction, part of the integer addition code. This microinstruction is at micro-address 0220." width="500"/></a></p><p>One microinstruction, part of the integer addition code. This microinstruction is at micro-address 0220.</p>
<p>Starting with the line &#34;R+L→R&#34; (red), this indicates that the ALU is taking inputs from registers R and L, and the result is going into the R register.
In other words, the two arguments are added.
The result R is stored into the desired programmer-visible register in local storage (blue).
The processor registers FN and J select the address in local storage.
Meanwhile, the <code>SETCRALG</code> line sets the Condition code register based on the sign (i.e. &#34;algebraic&#34; value) of the result, indicating if the result is positive,
negative, or zero.</p>
<p>The line &#34;BC⩝C&#34; indicates that signed overflow is detected and used as the carry flag<span id="fnref:carry"><a href="#fn:carry">14</a></span>
while CAR (yellow) indicates the microcode branches on this carry (overflow) value.
Thus, the microcode will take one path if the addition was valid and a second error path if overflow occurred.
<!--
In System/360 overflpw interrupts are enabled by bit 36 of the Processor Status Word.
This microinstruction prepares for the next microinstruction to test this bit.
-->
A microinstruction can &#34;emit&#34; an arbitrary 4-bit value (green) which can be used in a variety of ways.
In this case, the binary value 1000 is emitted, fed into the W register, and then the M register, for use by the next microinstruction.
As you can see, the CPU performs many activities in parallel for one microinstruction, which increases the computer&#39;s performance.</p>
<p>All the activities of a microinstruction are
encoded into a 90-bit word consisting of 28 fields.<span id="fnref:bitstream"><a href="#fn:bitstream">13</a></span>
The microinstruction discussed above (micro-address 0220) is highlighted in the documentation below.
A single microinstruction is very complex, which is why it takes an 11-line block of text to represent it.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/bitstream.jpg"><img alt="Part of the microcode listing. The previously-discussed microinstruction is highlighted. Note that the micro-address 0220 matches the address in the upper-left corner of the microinstruction diagram." height="101" src="https://static.righto.com/images/ibm-360-50/bitstream-w800.jpg" title="Part of the microcode listing. The previously-discussed microinstruction is highlighted. Note that the micro-address 0220 matches the address in the upper-left corner of the microinstruction diagram." width="800"/></a></p><p>Part of the <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol20_Sep72.pdf">microcode listing</a>. The previously-discussed microinstruction is highlighted. Note that the micro-address 0220 matches the address in the upper-left corner of the microinstruction diagram.</p>
<p>The processor documentation contains hundreds of pages of microcode;<span id="fnref:listing"><a href="#fn:listing">16</a></span> one page of the floating-point multiply code is below.
Each box is one microinstruction, and the lines between them indicate the complex control paths.
I&#39;m not going to explain this microcode,<span id="fnref:explanation"><a href="#fn:explanation">17</a></span> but I wanted to show its complexity.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/fp-microcode.jpg"><img alt="Part of the floating-point multiply microcode. (Click for a larger view.) From ALD vol 18." height="452" src="https://static.righto.com/images/ibm-360-50/fp-microcode-w700.jpg" title="Part of the floating-point multiply microcode. (Click for a larger view.) From ALD vol 18." width="700"/></a></p><p>Part of the floating-point multiply microcode. (Click for a larger view.) From <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol18_Sep72.pdf">ALD vol 18</a>.</p>
<h2>The console</h2>
<p>The discussion above has shown the complex internal architecture of the Model 50. The numerous lights and controls on the console<span id="fnref:console"><a href="#fn:console">19</a></span> provide a view into this internal state.
There were three main uses for the console.
The first use was basic &#34;operator control&#34; tasks such as turning the system on, booting it, or powering it off, using the controls in the lower section of the console.
These controls were consistent across the S/360 line and were usually the only controls the operator needed.
The three hexadecimal dials in the lower right selected the I/O unit that held the boot software.
Once the system had booted, the operator generally typed commands into the system rather than using the console.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/ibm-360-50-marc.jpg"><img alt="Control panel of the IBM System/360 Model 50. This panel has marginal check controls for auxiliary storage in the upper right, replacing the dataflow diagram." height="613" src="https://static.righto.com/images/ibm-360-50/ibm-360-50-marc-w450.jpg" title="Control panel of the IBM System/360 Model 50. This panel has marginal check controls for auxiliary storage in the upper right, replacing the dataflow diagram." width="450"/></a></p><p>Control panel of the IBM System/360 Model 50. This panel has marginal check controls for auxiliary storage in the upper right, replacing the dataflow diagram.</p>
<p>The second console function was &#34;operator intervention&#34;: program debugging tasks such as examining and modifying memory or registers
and setting breakpoints.
The lights and toggle switches in the lower half of the console were used for operator intervention.
The operator could enter a 24-bit address using the row of 24 toggle switches, and enter a 32-bit data value
using the row of 32 toggle switches above.
The lights allowed the contents of memory to be examined.
With other switches, the operator could set a breakpoint, single-step through a program, and perform other
debugging operations.</p>
<p>The third console function was system maintenance and repair performed by an IBM customer engineer.
The customer engineering displays took up the top half of the console and provided detailed access to the computer&#39;s complex internal state.
To save space, the Model 50 had four roller knobs on the right side, with 8 positions for each knob.
Each knob position selected a different function for the row of 36 lights (32 bits plus parity).
The legends above the lights rotate with the knobs, showing the meaning of each light.
For example, one position would display the L register, while another position would display the current
microinstruction.
In the photo below, the upper roller and lights are displaying part of the microcode currently being executed (ROS = Read Only Store).
The roller below shows some of the internal registers and counters.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/rollers.jpg"><img alt="Closeup of two rollers and the associated lights." height="215" src="https://static.righto.com/images/ibm-360-50/rollers-w500.jpg" title="Closeup of two rollers and the associated lights." width="500"/></a></p><p>Closeup of two rollers and the associated lights.</p>
<p>Finally, the voltmeter and voltage control knobs in the upper left of the console were used by an IBM customer engineer for &#34;marginal checking&#34;. By raising and lowering the voltage levels, borderline components could be detected and replaced before they caused problems.</p>
<h2>The simulator</h2>
<p>The simulator is at <a href="http://righto.com/360">righto.com/360</a> and the code is on <a href="https://github.com/shirriff/ibm-system-360-50-simulator">Github</a>.
I implemented the simulator in JavaScript so it can run in a browser. It runs a sample program by executing the Model 50&#39;s microcode, simulating each microinstruction
and the hardware.
Each microinstruction is displayed graphically, along with the current instruction, the registers, the local storage, and core memory.
It displays the console lights accurately based on the internal state, on a zoomable virtual console.
Each row of lights can display 8 different elements, which you can change by clicking on a roller.
You can step also through the microcode, one microinstruction at a time.</p>
<p>This simulator is still under development so don&#39;t expect it to work perfectly. I also haven&#39;t implemented the toggle switches, so you can&#39;t enter a program from
the console yet.
I also need to implement the I/O system, which has its own registers and a different microcode format.</p>
<p>To build the simulator, I extracted the binary microcode from the <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol20_Sep72.pdf">listings</a> using a custom OCR tool.
I implemented the hundreds of micro-operations, which were tricky to get correct.
While most micro-operations are simple operations such as moving a register to the bus, some microinstructions are much more complex, especially for floating-point
operations.<span id="fnref:edfp"><a href="#fn:edfp">20</a></span>
Another complication is that a microinstruction performs many tasks in parallel and it was hard to determine the exact order in which to perform them.
<!--
(For example, if a register is loaded, added, and compared in the same microinstruction, does the addition use the old value or the new value?)
--></p>
<p>My eventual goal with the simulator is to move it into the physical world. Specifically, I plan to drive the lights on CuriousMarc&#39;s <a href="https://www.youtube.com/watch?v=WS-WtjwAAO0">Model 50 control panel</a> to make the panel
operate accurately. We also plan to hook up his IBM tape drives and card reader so we can have all the pieces
of a Model 50 mainframe working together, except for the processor itself.
I plan to port the simulator to C so I can run it in a microcontroller to drive the physical console.
An FPGA implementation is another possibility; this would provide the maximum speed, but would be harder to implement.
I announce my latest blog posts on Twitter, so follow me <a href="https://twitter.com/kenshirriff">@kenshirriff</a> for updates and future articles. I also have an <a href="https://www.righto.com/feeds/posts/default">RSS feed</a>. Thanks to 
Richard Cornwell for discussion and data.</p>
<h2>Notes and references</h2>
<div>
<ol>
<li id="fn:simulator">
<p>My simulator is not particularly useful unless you really care about the microcode in the Model 50.
If you want to run software on a simulated System/360, you probably want to use the <a href="http://www.hercules-390.eu/">Hercules system</a>. <a href="#fnref:simulator" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:architectures">
<p>I&#39;ll briefly summarize some of the different implementations used in System/360 computers.
</p><p>The low-end Model 30 uses an 8-bit bus and ALU, so 32-bit operations take four steps. It uses 60-bit microcode.
</p><p>The Model 40 also has an 8-bit bus and ALU, but it has 16-bit registers and a 16-bit bus to memory, improving
the performance. It has 60-bit microcode.
</p><p>The Model 50 (discussed in this blog post) has 32-bit registers, memory bus, and adder. It also has the 8-bit
mover that can operate in parallel with the adder.
</p><p>The Model 65 has a 64-bit bus, and multiple adders (60 and 8-bit) that allow a floating-point fraction and
exponent to be processed in parallel. It also has an 8-byte instruction buffer and external channels.
It uses 100-bit microcode.
</p><p>The Model 75 has a 64-bit main adder, 8-bit exponent adder, 8-bit decimal adder, and a 24-bit addressing adder.
It overlaps instruction fetching and execution, with 16 bytes of instruction prefetching and 8 bytes of
data prefetching.
</p><p>The high-end Model 91 has an advanced superscalar architecture with out-of-order execution, instruction pipelining, and multiple arithmetic execution units.
Higher models support memory interleaving for faster access: 2-way on the Model 65 up to 16-way on the Model 195.
</p><p>The models 44, 75, 91 and above used hardwired control instead of microcode to squeeze out more performance.
</p><p>
As you can see, the System/360 line has a wide variety of implementations. At the low end, the hardware
is kept to a minimum to reduce costs, while at the high end, more hardware boosts performance, with wider
datapaths and multiple functional units providing parallelism. <a href="#fnref:architectures" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:variants">
<p>The System/360 line didn&#39;t completely meet the goal of a compatible architecture.
IBM split out the business and
scientific markets on the low-end machines by marketing subsets of the instruction set.
The basic instructions were provided in the &#34;standard&#34; instruction set.
On top of this, decimal instructions (for business) were in the &#34;commercial&#34; instruction set and floating-point was in the
&#34;scientific&#34; instruction set. The &#34;universal&#34; instruction set provided all these instructions plus storage
protection (i.e. memory protection between programs).
Additionally, cost-cutting on the low-end Model 20 made it incompatible with the S/360 architecture, and the Model 44 was somewhat incompatible to improve performance on scientific applications. <a href="#fnref:variants" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:princops">
<p>IBM defined the System/360 architecture in great detail in a document called the <a href="http://bitsavers.trailing-edge.com/pdf/ibm/360/princOps/A22-6821-0_360PrincOps.pdf">IBM System/360 Principles of Operation</a>.
It describes not only the instruction set, but also the datatypes, input/output model, the interrupt model, and even the basic structure of the system control panel.
To learn more about System/360, see <a href="http://www.bitsavers.org/pdf/ibm/360/training/C20-1646-1_A_Programmers_Introduction_To_IBM_System360_Assembler_Language_May66.pdf">A Programmer&#39;s Introduction to the IBM System/360 Architecture, Instructions, and Assembler Language</a>.
A bunch of assembly examples are at <a href="https://rosettacode.org/wiki/Category:360_Assembly">rosettacode</a>. <a href="#fnref:princops" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:control">
<p>The primary benefit of microcode for IBM was economic.
As described in <a href="https://doi.org/10.1147/sj.64.0222">Microprogram Control for System/360</a>, the cost of a non-microcoded processor is roughly linear in the
size of the instruction set.
However, a microcoded system has a roughly fixed cost, with a small overhead for additional instructions.
Thus, as instruction sets get more complex (as in System/360), there is a crossover point where microcode is more efficient.
This is especially the case for smaller systems where the base cost is lower.
The lower marginal cost also makes emulating other systems more feasible.
The IBM System/360 was one of the first commercial computers to make extensive use of microcode. <a href="#fnref:control" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn:compatibility">
<p>Various System/360 machines supported compatibility features with earlier IBM computers including the 1401, 1440, 1620, 7070, 7074, 7080, 709, 7090, 7094.
Generally, a smaller System/360 machine could replace a smaller IBM computer such as the 1401, while a larger mainframe such as the 7090 needed to be replaced by
a larger System/360 computer such as the Model 65.
<!-- http://www.bitsavers.org/pdf/ibm/360/systemSummary/GA22-6810-12_360sysSumJan74.pdf --> <a href="#fnref:compatibility" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
<li id="fn:non-microcode">
<p>A few System/360 models did not use microcode.
The Model 44 was designed as a high-performance computer for scientific applications, so it used hardwired control.
The Model 85 was partially microcoded, while the Models 75 and 91 were completely hardwired. <a href="#fnref:non-microcode" title="Jump back to footnote 7 in the text">↩</a></p>
</li>
<li id="fn:refs">
<p>The book <a href="https://amzn.to/2E7ZxqP">IBM&#39;s 360 and Early 370 Systems</a> describes the history of the S/360 in great detail.
IBM lists <a href="https://www.ibm.com/ibm/history/exhibits/mainframe/mainframe_FS360.html">data</a> on each model, including dates, data flow width, cycle time, storage, and microcode size. Another list with model details is <a href="https://www.ece.ucdavis.edu/~vojin/CLASSES/EEC272/S2005/Papers/Padegs-IBM360-sep81.pdf">here</a>.
The article <a href="http://www.ece.ucdavis.edu/~vojin/CLASSES/EEC272/S2005/Papers/Padegs-IBM360-sep81.pdf">System/360 and Beyond</a> has lots of info.
A list of 360 models and brief descriptions is <a href="http://www.beagle-ears.com/lars/engineer/comphist/model360.htm">here</a>.
For information on the Model 50 specifically, see the <a href="http://www.bitsavers.org/pdf/ibm/360/funcChar/A22-6898-1_360-50_funcChar_1967.pdf">Functional Characteristics</a> manual,
<a href="http://bitsavers.org/pdf/ibm/360/fe/2050/">Field Engineering</a> manuals,
<a href="https://en.wikipedia.org/wiki/IBM_System/360_Model_50">Wikipedia</a>,
photos <a href="http://infolab.stanford.edu/pub/voy/museum/pictures/display/3-1.htm">here</a> and
<a href="https://commons.wikimedia.org/wiki/File:ERMETH_input.jpg">here</a>,
<a href="https://www.youtube.com/watch?v=WS-WtjwAAO0">CuriousMarc video</a>. <a href="#fnref:refs" title="Jump back to footnote 8 in the text">↩</a></p>
</li>
<li id="fn:dimensions">
<p>For detailed dimensions of the System/360 components, see the <a href="http://www.bitsavers.org/pdf/ibm/360/fe/GC22-6820-12_System_360_Installation_Manual_Physical_Planning.pdf">Physical Planning Manual</a>
For more memory, another 1500-pound frame could be added to the Model 50, boosting it from 256 kilobytes of memory to 512 kilobytes.
Up to four Large Capacity Storage units (IBM 2361) could be added, each providing two more megabytes. <a href="#fnref:dimensions" title="Jump back to footnote 9 in the text">↩</a></p>
</li>
<li id="fn:core">
<p>I wrote in detail about the Model 50&#39;s core memory system <a href="https://www.righto.com/2019/04/a-look-at-ibm-s360-core-memory-in-1960s.html">here</a>. <a href="#fnref:core" title="Jump back to footnote 10 in the text">↩</a></p>
</li>
<li id="fn:programmer">
<p>The quote is from System/360 Model 40 <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2040/SY22-2840-2_Model_40_Comprehensive_Introduction_Apr70.pdf">comprehensive introduction</a>. <a href="#fnref:programmer" title="Jump back to footnote 11 in the text">↩</a></p>
</li>
<li id="fn:dataflow">
<p>The Model 50 <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/Z22-2833-R_2050_Processing_Unit_Field_Engineering_Diagram_Manual_Jul66.pdf">Field Engineering Diagram Manual</a> contains the detailed data flow diagram below.
This diagram corresponds to the diagram discussed earlier, but provides much more detail.
In particular, it shows the exact bit widths of the various data paths and registers.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/data-flow.png"><img alt="The detailed data flow diagram. Click for a larger version." height="620" src="https://static.righto.com/images/ibm-360-50/data-flow-w800.png" title="The detailed data flow diagram. Click for a larger version." width="800"/></a></p><p>The detailed data flow diagram. Click for a larger version.</p>
<p><!-- --> <a href="#fnref:dataflow" title="Jump back to footnote 12 in the text">↩</a></p>
</li>
<li id="fn:bitstream">

<p>The table below shows how a microinstruction is encoded into a 90-bit word.</p>
<table>
<tbody><tr><th>Bits</th><th>Name</th><th>Meaning</th></tr>
  <tr><td>0</td><td>P</td><td>Parity</td></tr>
  <tr><td>1-3</td><td>LU</td><td>Mover input left side</td></tr>
  <tr><td>4-5</td><td>MV</td><td>Mover input right side</td></tr>
  <tr><td>6-11</td><td>ZP</td><td>ROAR address (Read Only storage Address Register)</td></tr>
  <tr><td>12-15</td><td>ZF</td><td>ROAR branch control</td></tr>
  <tr><td>16-18</td><td>ZN</td><td>Address control field</td></tr>
  <tr><td>19-23</td><td>TR</td><td>Adder control</td></tr>
  <tr><td>24</td><td></td><td>Unused</td></tr>
  <tr><td>25-27</td><td>WS</td><td>Local store address control</td></tr>
  <tr><td>28-30</td><td>SF</td><td>Local store functions</td></tr>
  <tr><td>31</td><td>P</td><td>Parity</td></tr>
  <tr><td>32-34</td><td>IV</td><td>Invalid digit test</td></tr>
  <tr><td>35-39</td><td>AL</td><td>Adder latch gating</td></tr>
  <tr><td>40-43</td><td>WM</td><td>Mover destination</td></tr>
  <tr><td>44-45</td><td>UP</td><td>Byte counter function</td></tr>
  <tr><td>46</td><td>MD</td><td>MD counter control</td></tr>
  <tr><td>47</td><td>LB</td><td>L byte counter control</td></tr>
  <tr><td>48</td><td>MB</td><td>M byte counter control</td></tr>
  <tr><td>49-51</td><td>DG</td><td>Length counter</td></tr>
  <tr><td>52-53</td><td>UL</td><td>Mover function left digit</td></tr>
  <tr><td>54-55</td><td>UR</td><td>Mover function right digit</td></tr>
  <tr><td>56</td><td>P</td><td>Parity</td></tr>
  <tr><td>57-60</td><td>CE</td><td>Emit field</td></tr>
  <tr><td>61-63</td><td>LX</td><td>Left adder input</td></tr>
  <tr><td>64</td><td>TC</td><td>True or complement control</td></tr>
  <tr><td>65-67</td><td>RY</td><td>Right adder input</td></tr>
  <tr><td>68-71</td><td>AD</td><td>Adder function control</td></tr>
  <tr><td>72-77</td><td>AB</td><td>A branch control</td></tr>
  <tr><td>78-82</td><td>BB</td><td>B branch control</td></tr>
  <tr><td>83</td><td></td><td>Unused</td></tr>
  <tr><td>84-89</td><td>SS</td><td>Stat setting control</td></tr>
</tbody></table>
<p>For channel instructions, the microcode format is slightly different since some of the fields need to control the channel circuitry.
However, most of the fields are the same as for the CPU. The table below shows the microcode format for the channel;
the highlighted entries are different from the CPU microcode.</p>
<table>
<tbody><tr><th>Bits</th><th>Name</th><th>Meaning</th></tr>
  <tr><td>0</td><td>P</td><td>Parity</td></tr>
  <tr><td>1-3</td><td>LU</td><td>Mover input left side</td></tr>
  <tr><td>4-5</td><td>MV</td><td>Mover input right side</td></tr>
  <tr><td>6-11</td><td>ZP</td><td>ROAR address</td></tr>
  <tr><td>12-15</td><td>ZF</td><td>ROAR branch control</td></tr>
  <tr><td>16-18</td><td>ZN</td><td>Address control field</td></tr>
  <tr><td>19-23</td><td>TR</td><td>Adder control</td></tr>
  <tr><td>24</td><td></td><td>Unused</td></tr>
  <tr><td>25</td><td>CS</td><td>Local storage address selector</td></tr>
  <tr><td>26-27</td><td>SA</td><td>Local storage address</td></tr>
  <tr><td>28-30</td><td>SF</td><td>Local storage function</td></tr>
  <tr><td>31</td><td>P</td><td>Parity</td></tr>
  <tr><td>32-34</td><td>CT</td><td>Timing signals to channel</td></tr>
  <tr><td>35-39</td><td>AL</td><td>Adder latch gating</td></tr>
  <tr><td>40-42</td><td>WL</td><td>Mover destination</td></tr>
  <tr><td>43-46</td><td>HC</td><td>Multiplexor channel stat setting</td></tr>
  <tr><td>47-48</td><td>CG</td><td>Control signals to channel</td></tr>
  <tr><td>49-51</td><td>MG</td><td>Multiplexor channel gate control</td></tr>
  <tr><td>52-53</td><td>UL</td><td>Mover function left digit</td></tr>
  <tr><td>54-55</td><td>UR</td><td>Mover function right digit</td></tr>
  <tr><td>56</td><td>P</td><td>Parity</td></tr>
  <tr><td>57-60</td><td>CE</td><td>Emit field</td></tr>
  <tr><td>61-63</td><td>LX</td><td>Left adder input</td></tr>
  <tr><td>64</td><td>TC</td><td>True or complement control</td></tr>
  <tr><td>65-67</td><td>RY</td><td>Right adder input</td></tr>
  <tr><td>68-70</td><td>CL</td><td>Selector channel adder latch tests</td></tr>
  <tr><td>71</td><td></td><td>Unused</td></tr>
  <tr><td>72-77</td><td>AB</td><td>A branch control</td></tr>
  <tr><td>78-82</td><td>BB</td><td>B branch control</td></tr>
  <tr><td>83</td><td></td><td>Unused</td></tr>
  <tr><td>84-89</td><td>SS</td><td>Stat setting control</td></tr>
</tbody></table> <a href="#fnref:bitstream" title="Jump back to footnote 13 in the text">↩</a>
</li>
<li id="fn:carry">
<p>When adding twos-complement signed numbers,
an overflow occurs if the carry out of the most significant bit is different from the carry out of the second-most-significant bit.
(I explain this in detail <a href="https://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">here</a>.)
IBM numbers the bits in a word &#34;backward&#34; with bit 0 the most significant.
Thus, an overflow occurs if the carry from bit 0 XOR&#39;d with the carry from bit 1 is nonzero.
IBM uses ⩝ to indicate an exclusive or. 
Thus, CARRY(0) ⩝ CARRY(1) indicates an overflow, represented as BC⩝C in the microcode. <a href="#fnref:carry" title="Jump back to footnote 14 in the text">↩</a></p>
</li>
<li id="fn:microcode-ref">
<p>For a description of how the Model 50 microcode works, see the book &#34;Microprogramming: Principles and Practices&#34;, S. Husson (1970), pages 295 to 411.
Bitsavers has a lot of <a href="http://www.bitsavers.org/pdf/ibm/360/fe/2050/">Model 50 documents</a>, but not everything.
If you have additional documentation, such as the IBM Automated Logic Diagrams, please let me know. <a href="#fnref:microcode-ref" title="Jump back to footnote 15 in the text">↩</a></p>
</li>
<li id="fn:listing">
<p>The Model 50&#39;s microcode listing is available in three volumes on <a href="http://bitsavers.org/pdf/ibm/360/fe/2050/2050_Vol20_Sep72.pdf">bitsavers</a>.
The binary microcode listings are difficult to read with OCR because pages were printed on different printers; some use serif fonts and others use sans-serif fonts.
I made my own OCR program designed to process binary, which was able to read the listings for the most part.
The presence of parity in the microcode helped catch errors. <a href="#fnref:listing" title="Jump back to footnote 16 in the text">↩</a></p>
</li>
<li id="fn:explanation">
<p>Ok, I&#39;ll give a brief explanation of that page of microcode, which is part of the implementation of floating-point multiplication.
The implementation is designed with tradeoffs between speed, code length, and temporary memory usage.
The idea is to multiply the multiplicand by the multiplier, kind of like long multiplication on paper, where you multiply a digit at a time and add the partial sums.
This code processes a hex digit of the multiplier at a time, with a separate case for each digit.
The multiplicand is multiplied by the digit and this is added to the running total, shifting as appropriate.
To make this fast, multiples of the multiplicand are pre-computed. However, pre-computing 16 multiples (one for each hex digit value) would take too much temporary (local) storage.
So the only pre-computed multiples are 1, 2, and 6, and these are combined for other digits.
To multiply by the digit 7, for instance, the multiples for 1 and 6 are added. To multiply by the digit 4, the multiple for 6 is added and the multiple for 2 is subtracted.
<!--
(Keep in mind that a "long" value is two words, so two steps are required for each addition or subtraction, one for the low order (LO) word and one for the high order (HO) word.)
--></p>
<p>But what about multiplying by 9 through 15? The trick is to &#34;borrow&#34; 16 from the next-higher digit.
For instance, to multiply by the digit 11, you borrow 16, subtract the multiple for 6, and add the multiple for 1.
Then the value one less is used for the next digit to account for the borrow.
Thus, all 16 possibilities can be handled by adding or subtracting at most two of the pre-computed values.
With borrowing, the code needs to handle 32 cases; the included page implements 22 of these cases.
This implementation makes multiplication rapid, but the microcode is complex with many paths.
(There is also a bunch more code to handle the floating-point exponent, normalizing values, overflow, underflow, and so forth.) <a href="#fnref:explanation" title="Jump back to footnote 17 in the text">↩</a></p>
</li>
<li id="fn:ros">
<p>Different System/360 models used a variety of methods to store microcode.<span id="fnref:ros"><a href="#fn:ros">18</a></span>
An important feature of IBM&#39;s microcode storage was that the microcode could be replaced in the field.
The low-end Model 25 held microcode in a 16-kilobyte section of core memory called Control Storage.
The Model 30 used CCROS (Card Capacitor Read-only Store), storing the microcode on special metalized punch
cards that were read capacitively.
Transformer Read-Only Storage (TROS, below) was used by the System/360 Model 20 and Model 40.
I wrote an article about <a href="https://www.righto.com/2019/11/tros-how-ibm-mainframes-stored.html">microcode storage</a> if you want more information.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/tros.jpg"><img alt="A TROS module from an IBM System/360 Model 20." height="208" src="https://static.righto.com/images/ibm-360-50/tros-w500.jpg" title="A TROS module from an IBM System/360 Model 20." width="500"/></a></p><p>A TROS module from an IBM System/360 Model 20.</p>
<!-- -->

<p>The Model 50 (as well as 65 and 67) stored microcode in BCROS (Balanced Capacitor Read-Only Storage), using
copper-clad epoxy glass laminate boards, each
20″×8½″.
Each sheet plane held 176 words of 100 bits, and the Model 50 used 16 sheets to store 2816 words.
(Only 90 of the 100 bits in each word were used.)
The data in BCROS was etched into the copper wiring (below).
<!-- abbas 1968 -->
Each bit is represented by two squares: one connected to the upper wire and one connected to the lower wire (or vice versa), forming the balanced capacitors.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/bcros-detail.jpg"><img alt="Closeup of a BCROS sheet from a System/360 Model 50." height="294" src="https://static.righto.com/images/ibm-360-50/bcros-detail-w300.jpg" title="Closeup of a BCROS sheet from a System/360 Model 50." width="300"/></a></p><p>Closeup of a BCROS sheet from a System/360 Model 50.</p>
<p><!-- --> <a href="#fnref:ros" title="Jump back to footnote 18 in the text">↩</a></p>
</li>
<li id="fn:console">
<p>The features of the system control panel were carefully defined in the <a href="http://bitsavers.trailing-edge.com/pdf/ibm/360/princOps/A22-6821-0_360PrincOps.pdf">System/360 Principles of Operation</a> pages 117-121,
providing a consistent operator experience across the S/360 line.
(The customer engineering part of the panel, on the other hand, was not specified and wildly different across
the product line.)
Diagrams of S/360 consoles are at <a href="http://www.quadibloc.com/comp/pan04.htm">quadibloc</a>.
For more details on the consoles, see my article on <a href="https://www.righto.com/2019/04/iconic-consoles-of-ibm-system360.html">System/360 consoles</a>. <a href="#fnref:console" title="Jump back to footnote 19 in the text">↩</a></p>
</li>
<li id="fn:edfp">
<p>The micro-operation that caused me the most difficulty is ED*FP, which computes the difference between two exponents for floating-point, but also computes
four floating-point flags including the sign depending on the type of operation.
Not only is this operation complex, but I think there is a typo in the description.</p>
<p><a href="https://static.righto.com/images/ibm-360-50/edfp.png"><img alt="A description of the ED*FP micro-operation." height="273" src="https://static.righto.com/images/ibm-360-50/edfp-w400.png" title="A description of the ED*FP micro-operation." width="400"/></a></p><p>A description of the ED*FP micro-operation.</p>
<!-- -->

<p>Another complex micro-operation is <code>MLJK</code>, which performs multiple actions as part of instruction decoding:</p>
<p>Gate adder latch to L reg and M reg. Gate latch bits 12-15 to J reg. Gate latch bits 16-19 to MD counter. Turn off refetch stat.
</p>
</li>
</ol>
</div>

</div></div>
  </body>
</html>
