<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prefix.dev/blog/introducing_rip">Original</a>
    <h1>Rip – Rust crate to resolve and install Python packages</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction"><a href="#introduction">Introduction<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>It&#39;s no secret anymore that we&#39;ve been working on a shiny new thing: a pip/PyPI package resolver and installer in Rust.
We are doing this to build a strong bridge between the two worlds: conda and PyPI.
Many real-world “environments” mix PyPI and conda-forge packages.
<a href="https://github.com/prefix-dev/rip" rel="nofollow"><code>rip</code></a> is a low-level library that we are integrating into <a href="https://github.com/prefix-dev/pixi" rel="nofollow"><code>pixi</code></a>.</p>
<p>Conda also has the ability to mix PyPI and conda packages but does so in a pretty limited fashion, it just invokes <code>pip</code> after installing packages with <code>conda</code>.
We are planning to more tightly integrate PyPI support into <a href="https://github.com/prefix-dev/pixi" rel="nofollow"><code>pixi</code></a>, which includes adding the PyPI packages to the lockfiles.
Our goal is a blissful experience for <a href="https://github.com/prefix-dev/pixi" rel="nofollow"><code>pixi</code></a> users.</p>
<p>We took all the experience we have gotten from implementing the low-level <a href="https://github.com/mamba-org/rattler" rel="nofollow"><code>rattler</code></a> crates as well as the Rust SAT solver <a href="https://github.com/mamba-org/resolvo" rel="nofollow"><code>resolvo</code></a> and applied that to a new problem - PyPI packages.</p>
<p>There are a few key differences between Python packages and conda packages:</p>
<ul>
<li><strong>Metadata fetching:</strong> With conda you get all the metadata upfront, from a central &#34;index&#34; that describes all the available package versions and dependencies.
This file is called &#34;repodata&#34; and encoded as <code>JSON</code>.</li>
<li><strong>Wheel files metadata:</strong> the package metadata on PyPI is encoded inside the wheel files (or not existent for source distributions, sdists).
To get to the metadata, the wheel files need to be downloaded or for sdists, they need to be built to a wheel first.
This is a little better for new uploads since <a href="https://peps.python.org/pep-0658/" rel="nofollow">PEP 658</a> where the metadata is also stored alongside the wheel file and can be downloaded individually.
The python package metadata inside the wheel files is also a completely different format (conda uses JSON while Python packages use a custom format).</li>
<li><strong>Dependency specs:</strong> Conda and PyPI use similar dependency range specifier syntax, but the details are quite different.
PyPI supports dev and prerelease versions that conda does not yet have.</li>
</ul>
<h2 id="step-1-making-the-solver-generic"><a href="#step-1-making-the-solver-generic">Step 1: Making the solver generic<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>When we started out with our own SAT solver we made it work for conda packages - because that is what we know best and where we initially wanted to make use of the solver.
But we soon had the vision to also handle other package formats.
PyPI is a clear first choice given the history of the conda project and the existing ecosystem of “environment.yml” files that mix <code>conda</code> and <code>pip</code>.</p>
<p>That is why step 1 was to make the solver standalone and generic – we removed every trace of conda from it, and renamed it <a href="https://github.com/mamba-org/resolvo" rel="nofollow"><code>resolvo</code></a>.
It now lives in its own Github repository and crate.
It is quite straightforward to implement support for new package formats now.</p>
<p>One just needs to implement the following trait.
An ordering between packages (highest version number / most preferable package first!), and a dependency matcher (given a string to find all packages that match the version specifier string).</p>
<div data-rehype-pretty-code-fragment=""><pre><code data-language="rust" data-theme="default"><span data-line=""><span>pub</span><span> </span><span>trait</span><span> </span><span>DependencyProvider</span><span>&lt;VS</span><span>:</span><span> </span><span>VersionSet</span><span>, </span><span>N</span><span>:</span><span> </span><span>PackageName</span><span> </span><span>=</span><span> </span><span>String</span><span>&gt;</span><span>:</span><span> </span><span>Sized</span><span> {</span></span>
<span data-line=""><span>    // The only required methodes</span></span>
<span data-line=""><span>    </span><span>fn</span><span> </span><span>pool</span><span>(</span><span>&amp;</span><span>self) </span><span>-&gt;</span><span> </span><span>&amp;</span><span>Pool</span><span>&lt;</span><span>VS</span><span>, </span><span>N</span><span>&gt;;</span></span>
<span data-line=""><span>    </span><span>fn</span><span> </span><span>sort_candidates</span><span>(</span></span>
<span data-line=""><span>        </span><span>&amp;</span><span>self,</span></span>
<span data-line=""><span>        solver</span><span>:</span><span> </span><span>&amp;</span><span>SolverCache</span><span>&lt;</span><span>VS</span><span>, </span><span>N</span><span>, Self&gt;,</span></span>
<span data-line=""><span>        solvables</span><span>:</span><span> </span><span>&amp;mut</span><span> [</span><span>SolvableId</span><span>]</span></span>
<span data-line=""><span>    );</span></span>
<span data-line=""><span>    </span><span>fn</span><span> </span><span>get_candidates</span><span>(</span><span>&amp;</span><span>self, name</span><span>:</span><span> </span><span>NameId</span><span>) </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>Candidates</span><span>&gt;;</span></span>
<span data-line=""><span>    </span><span>fn</span><span> </span><span>get_dependencies</span><span>(</span><span>&amp;</span><span>self, solvable</span><span>:</span><span> </span><span>SolvableId</span><span>) </span><span>-&gt;</span><span> </span><span>Dependencies</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>You can find an example package ecosystem implementation in the tests of <a href="https://github.com/mamba-org/resolvo/blob/main/tests/solver.rs" rel="nofollow"><code>resolvo</code></a>.</p>
<h2 id="step-2-make-the-solver-lazy"><a href="#step-2-make-the-solver-lazy">Step 2: Make the solver lazy<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>As described earlier, the metadata of Python packages is hidden inside the wheel files.
This makes it impractical to obtain all available metadata right away as one would need to download many packages (and individual packages can be quite large!).
pip works around this by being “lazy” - only retrieve the files that are necessary and expand the tree of packages when needed.
After some head scratching and watching some <a href="https://www.youtube.com/watch?v=d76e4hV1iJY" rel="nofollow">lectures about CDCL</a> Bas &amp; Tim found a way to make the solver lazy while keeping it fast in the non-lazy case – but that’s a topic for a future blog post.</p>
<h2 id="step-3-reading-the-metadata"><a href="#step-3-reading-the-metadata">Step 3: Reading the metadata<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Finally we were lucky in that we could reuse quite a bit of existing software: from the <a href="https://github.com/njsmith/posy" rel="nofollow">Posy project</a>, another Rust-based pip install &amp; resolve project,
as well as <a href="https://github.com/konstin" rel="nofollow">Konstin</a>’s awesome work on the <a href="https://docs.rs/pep440_rs/latest/pep440_rs/" rel="nofollow">pep440_rs</a> and <a href="https://docs.rs/pep508_rs/latest/pep508_rs/" rel="nofollow">pep508_rs</a> crates.
The pep440_rs crate already implements the version matching for Python version strings and thus made it quite straightforward to plug the PyPI ecosystem into resolvo.
We also added a high-performance wheel cache and the ability to actually unpack and install the wheel files.</p>
<p>We’ve built <a href="https://github.com/prefix-dev/rip" rel="nofollow"><code>rip</code></a> in a similar fashion as <a href="https://github.com/mamba-org/rattler" rel="nofollow"><code>rattler</code></a> - as  low level libraries that we want to use in pixi!
We’ve already begun the integration and are excited at all the other real-world use cases that this integration will unlock!</p>
<p>Combining this work results in a fast, typesafe PyPI package solver.
Here is an example of <code>rip</code> solving the requirements for <code>flask</code>.</p>
<p><img src="https://user-images.githubusercontent.com/4995967/271225240-5b0356b6-8e06-47bb-9424-94b3fdd9da09.gif" alt="flask-install"/></p></div></div>
  </body>
</html>
