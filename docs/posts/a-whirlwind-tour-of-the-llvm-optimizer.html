<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf">Original</a>
    <h1>A whirlwind tour of the LLVM optimizer</h1>
    
    <div id="readability-page-1" class="page"><div id="__next" data-reactroot=""><div><div><div data-testid="fullscreen-wrapper"><div data-testid="player" id="new-player" data-slideshow-id="257768007"><div><p><img src="https://image.slidesharecdn.com/awhirlwindtourofthellvmoptimizer-230510155843-c30751d5/85/a-whirlwind-tour-of-the-llvm-optimizer-1-320.jpg?cb=1683735187" alt="thumb"/><span>Top clipped slide</span></p></div></div></div></div></div><div><h3><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792" height="24" width="24" fill="currentColor"><path d="M1596 380q28 28 48 76t20 88v1152q0 40-28 68t-68 28h-1344q-40 0-68-28t-28-68v-1600q0-40 28-68t68-28h896q40 0 88 20t76 48zm-444-244v376h376q-10-29-22-41l-313-313q-12-12-41-22zm384 1528v-1024h-416q-40 0-68-28t-28-68v-416h-768v1536h1280z"></path></svg>A whirlwind tour of the LLVM optimizer</h3><ol><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#1">A whirlwind tour </a><span> of the
LLVM optimizer
Nikita Popov @ EuroLLVM 2023
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#2">Agenda
● High-level overview </a><span> of the middle-end optimization pipeline
● Brief description of important optimization passes
○ Get basic idea about pass responsibilities
○ Learn about key restrictions/constraints
2
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#3">About Me
● Software </a><span> Engineer on Platform Tools team at Red Hat
○ Packaging of LLVM for Fedora, CentOS and RHEL
○ Upstream work on LLVM and Clang
3
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#4">About Me
● Software </a><span> Engineer on Platform Tools team at Red Hat
○ Packaging of LLVM for Fedora, CentOS and RHEL
○ Upstream work on LLVM and Clang
● I work on:
○ The LLVM middle-end
○ LLVM / Rust integration
○ Compilation time improvements (LLVM Compile-Time Tracker)
4
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#5">...ends
5
Frontend Middle-end Backend
Clang
Rust
Swift
Julia
...
X86
AArch64
ARM
RISCV
...
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#6">Default (non-LTO) pipeline
6
Module </a><span> 1 Module 1&#39;
Optimize
Module 2 Module 2&#39;
Module 3 Module 3&#39;
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#7">Full LTO pipeline
7
Module </a><span> 1 Module 1&#39;
Pre-link
optimize
Module 2 Module 2&#39;
Module 3 Module 3&#39;
Module M Module M&#39;
Post-link
optimize
Merge
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#8">Thin LTO pipeline
8
Module </a><span> 1 Module 1&#39;
Pre-link
optimize
Module 2 Module 2&#39;
Module 3 Module 3&#39;
Module 2&#39;&#39; Module 2&#39;&#39;&#39;
Post-link
optimize
Cross
import
Module 1&#39;&#39;
Module 3&#39;&#39; Module 3&#39;&#39;&#39;
Module 1&#39;&#39;&#39;
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#9">Default pipeline
9
Module
Simplification
Module
Optimization
Backend
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#10">Default pipeline
10
Module
Simplification
Module
Optimization
Backend
More
canonical
Less
canonical
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#11">Default pipeline
11
Module
Simplification
Module
Optimization
Backend
More
canonical
Less
canonical
Inlining
Mem2Reg
LICM (Loop </a><span> Invariant Code Motion)
...
Make further opts
easier
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#12">Default pipeline
12
Module
Simplification
Module
Optimization
Backend
More
canonical
Less
canonical
Vectorization
Runtime unrolling
...
Make </a><span> further opts
harder
Inlining
Mem2Reg
LICM
...
Make further opts
easier
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#13">Default pipeline
13
Module
Simplification
Module
Optimization
Backend
More
canonical
Less
canonical
Vectorization
Runtime unrolling
...
Make </a><span> further opts
harder
Inlining
Mem2Reg
LICM
...
Make further opts
easier
Target-specific
optimization
Lowering to
machine code
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#14">ThinLTO pipeline
14
Module 1
Simplification
Module </a><span> 1&#39;
Simplification
Module 1&#39;
Optimization
Module 2
Simplification
Module 2&#39;
Simplification
Module 2&#39;
Optimization
Cross
import
Post-link
Pre-link
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#15">ThinLTO pipeline
15
Module 1
Simplification
Module </a><span> 1&#39;
Simplification
Module 1&#39;
Optimization
Module 2
Simplification
Module 2&#39;
Simplification
Module 2&#39;
Optimization
Cross
import
Post-link
Pre-link
Second round of inlining
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#16">ThinLTO pipeline
16
Module 1
Simplification
Module </a><span> 1&#39;
Simplification
Module 1&#39;
Optimization
Module 2
Simplification
Module 2&#39;
Simplification
Module 2&#39;
Optimization
Cross
import
Post-link
Pre-link
Second round of inlining
Don&#39;t run decanonicalizing
transforms pre-link
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#17">Module Simplification
17
Early
Cleanup
Inlining
Function Simplification
Late
Cleanup
CGSCC </a><span> Pipeline
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#18">CGSCC Pipeline
18
g
h
i
f
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#19">CGSCC Pipeline
19
g
h
i
simplify
f
simplify
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#20">CGSCC Pipeline
20
g,h
i
f
simplify
try inline
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#21">CGSCC Pipeline
21
g,h
i
f
simplify
try inline
simplify
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#22">CGSCC Pipeline
22
g,h
i
f
simplify
try inline
simplify
try </a><span> inline
simplify
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#23">CGSCC Pipeline
23
g,h
i
f
simplify
try inline
simplify
try </a><span> inline
simplify
Inlining sees already simplified functions!
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#24">Call-Graph Strongly Connected </a><span> Components
24
g h i
f
SCC 1
SCC 2
SCC 3
No well-defined order within SCC
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#25">Running pipelines
● opt </a><span> -passes=&#39;default&lt;O3&gt;&#39; == opt -O3
● opt -passes=&#39;thinlto-pre-link&lt;O3&gt;&#39;
● opt -passes=&#39;thinlto&lt;O3&gt;&#39;
● opt -passes=&#39;lto-pre-link&lt;O3&gt;&#39;
● opt -passes=&#39;lto&lt;O3&gt;&#39;
25
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#26">opt -passes=&#39;default&lt;O3&gt;&#39; -print-pipeline-passes
annotation2metadata,forceattrs,inferattrs,coro-early,function&lt;eager-inv&gt;(lower-expect,simplifycfg&lt;bonus-inst-threshold=1;no-forw
ard-switch-cond;no-switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-sink-common-insts&gt;,sroa&lt;modify-c
fg&gt;,early-cse&lt;&gt;,callsite-splitting),openmp-opt,ipsccp,called-value-propagation,globalopt,function&lt;eager-inv&gt;(mem2reg,instcombine
&lt;max-iterations=1000;no-use-loop-info&gt;,simplifycfg&lt;bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-
to-lookup;keep-loops;no-hoist-common-insts;no-sink-common-insts&gt;),require&lt;globals-aa&gt;,function(invalidate&lt;aa&gt;),require&lt;profile-s
ummary&gt;,cgscc(devirt&lt;4&gt;(inline&lt;only-mandatory&gt;,inline,function-attrs&lt;skip-non-recursive&gt;,argpromotion,openmp-opt-cgscc,function&lt;
eager-inv;no-rerun&gt;(sroa&lt;modify-cfg&gt;,early-cse&lt;memssa&gt;,speculative-execution,jump-threading,correlated-propagation,simplifycfg&lt;b
onus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-sink-c
ommon-insts&gt;,instcombine&lt;max-iterations=1000;no-use-loop-info&gt;,aggressive-instcombine,constraint-elimination,libcalls-shrinkwrap
,tailcallelim,simplifycfg&lt;bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-h
oist-common-insts;no-sink-common-insts&gt;,reassociate,loop-mssa(loop-instsimplify,loop-simplifycfg,licm&lt;no-allowspeculation&gt;,loop-
rotate,licm&lt;allowspeculation&gt;,simple-loop-unswitch&lt;nontrivial;trivial&gt;),simplifycfg&lt;bonus-inst-threshold=1;no-forward-switch-con
d;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-sink-common-insts&gt;,instcombine&lt;max-iterations=100
0;no-use-loop-info&gt;,loop(loop-idiom,indvars,loop-deletion,loop-unroll-full),sroa&lt;modify-cfg&gt;,vector-combine,mldst-motion&lt;no-spli
t-footer-bb&gt;,gvn&lt;&gt;,sccp,bdce,instcombine&lt;max-iterations=1000;no-use-loop-info&gt;,jump-threading,correlated-propagation,adce,memcpy
opt,dse,move-auto-init,loop-mssa(licm&lt;allowspeculation&gt;),coro-elide,simplifycfg&lt;bonus-inst-threshold=1;no-forward-switch-cond;sw
itch-range-to-icmp;no-switch-to-lookup;keep-loops;hoist-common-insts;sink-common-insts&gt;,instcombine&lt;max-iterations=1000;no-use-l
oop-info&gt;),function-attrs,function(require&lt;should-not-run-function-passes&gt;),coro-split)),deadargelim,coro-cleanup,globalopt,glob
aldce,elim-avail-extern,rpo-function-attrs,recompute-globalsaa,function&lt;eager-inv&gt;(float2int,lower-constant-intrinsics,chr,loop(
loop-rotate,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize&lt;no-interleave-forced-only;no-vectorize-forced-only
;&gt;,loop-load-elim,instcombine&lt;max-iterations=1000;no-use-loop-info&gt;,simplifycfg&lt;bonus-inst-threshold=1;forward-switch-cond;switc
h-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;sink-common-insts&gt;,slp-vectorizer,vector-combine,instcombine&lt;m
ax-iterations=1000;no-use-loop-info&gt;,loop-unroll&lt;O3&gt;,transform-warning,sroa&lt;preserve-cfg&gt;,instcombine&lt;max-iterations=1000;no-use
-loop-info&gt;,loop-mssa(licm&lt;allowspeculation&gt;),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simpl
ifycfg&lt;bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;n
o-sink-common-insts&gt;),globaldce,constmerge,cg-profile,rel-lookup-table-converter,function(annotation-remarks),verify,print
26
Defined </a><span> in PassBuilderPipelines.cpp
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#27">godbolt.org – LLVM </a><span> Opt Pipeline
27
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#28">godbolt.org – LLVM </a><span> Opt Pipeline
28
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#29">godbolt.org – LLVM </a><span> Opt Pipeline
29
Or run opt -print-after-all
locally
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#30">30
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#31">SSA Construction
31
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#32">Mem2Reg
int test(int x, </a><span> int y) {
return x + y;
}
32
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#33">Mem2Reg
define i32 @test(i32 </a><span> %x, i32 %y) {
entry:
%x.addr = alloca i32
%y.addr = alloca i32
store i32 %x, ptr %x.addr
store i32 %y, ptr %y.addr
%0 = load i32, ptr %x.addr
%1 = load i32, ptr %y.addr
%add = add nsw i32 %0, %1
ret i32 %add
}
33
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#34">Mem2Reg
define i32 @test(i32 </a><span> %x, i32 %y) {
entry:
%add = add nsw i32 %x, %y
ret i32 %add
}
34
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#35">SROA: Scalar Replacement </a><span> of Aggregates
● Break up allocas into smaller allocas based on access pattern
○ %vec = alloca { ptr, i64, i64 }
○ -&gt; %vec.ptr = alloca ptr
○ -&gt; %vec.size = alloca i64
○ -&gt; %vec.capacity = alloca i64
35
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#36">SROA: Scalar Replacement </a><span> of Aggregates
● Break up allocas into smaller allocas based on access pattern
○ %vec = alloca { ptr, i64, i64 }
○ -&gt; %vec.ptr = alloca ptr
○ -&gt; %vec.size = alloca i64
○ -&gt; %vec.capacity = alloca i64
● Then run Mem2Reg to convert alloca/load/store to SSA values
36
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#37">SROA: Scalar Replacement </a><span> of Aggregates
● Break up allocas into smaller allocas based on access pattern
○ %vec = alloca { ptr, i64, i64 }
○ -&gt; %vec.ptr = alloca ptr
○ -&gt; %vec.size = alloca i64
○ -&gt; %vec.capacity = alloca i64
● Then run Mem2Reg to convert alloca/load/store to SSA values
● Knows many tricks for overlapping accesses
○ For example inserting/extracting bits of a larger integer
37
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#38">Control-Flow Optimization
38
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#39">SimplifyCFG
● The kitchen </a><span> sink of control-flow transforms
○ If it fits nowhere else, put it here!
39
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#40">SimplifyCFG: Hoist
if (cond) </a><span> {
foo();
a();
} else {
foo();
b();
}
40
foo();
if (cond) {
a();
} else {
b();
}
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#41">SimplifyCFG: Speculate
if (cond) </a><span> {
x = foo();
} else {
x = 0;
}
41
tmp = foo();
x = cond ? tmp : 0;
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#42">SimplifyCFG: Switch to </a><span> lookup table
switch (x) {
case 0:
return 10;
case 1:
return 42;
case 2:
return 123;
case 3:
return 7;
default:
return 13;
}
42
int table[] = {10, 42, 123, 7};
if (x &lt; 4) {
return table[x];
} else {
return 13;
}
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#43">SimplifyCFG
● The kitchen </a><span> sink of control-flow transforms
○ If it fits nowhere else, put it here!
● Invoked with many different options at different pipeline positions
○ Some transforms only run late in the pipeline
43
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#44">SimplifyCFG
● The kitchen </a><span> sink of control-flow transforms
○ If it fits nowhere else, put it here!
● Invoked with many different options at different pipeline positions
○ Some transforms only run late in the pipeline
● Can use target-dependent cost model (via TargetTransformInfo)
44
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#45">Instruction Combining
(Peephole Optimization)
45
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#46">InstCombine
● The kitchen </a><span> sink of non-CFG transforms
○ If it fits nowhere else, put it here!
46
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#47">InstCombine: Analysis helpers
47
InstCombine </a><span> InstSimplify ConstantFolding
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#48">InstCombine: Analysis helpers
● </a><span> ConstantFolding
○ Folds instructions with constant operands to constants
○ 1 + 2 =&gt; 3
48
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#49">InstCombine: Analysis helpers
● </a><span> ConstantFolding
○ Folds instructions with constant operands to constants
○ 1 + 2 =&gt; 3
● InstSimplify
○ Folds instructions to existing values or constants
○ x + 0 =&gt; x
○ x - x =&gt; 0
49
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#50">InstCombine: Analysis helpers
● </a><span> ConstantFolding
○ Folds instructions with constant operands to constants
○ 1 + 2 =&gt; 3
● InstSimplify
○ Folds instructions to existing values or constants
○ x + 0 =&gt; x
○ x - x =&gt; 0
● InstCombine
○ Tries constant folding and instruction simplification first
○ Performs folds that create or modify instructions
○ x * 4 =&gt; x &lt;&lt; 2
50
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#51">InstCombine
● The kitchen </a><span> sink of non-CFG transforms
○ If it fits nowhere else, put it here!
○ Use InstSimplify / ConstantFolding for transforms that don&#39;t create/modify instructions.
51
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#52">InstCombine
● The kitchen </a><span> sink of non-CFG transforms
○ If it fits nowhere else, put it here!
○ Use InstSimplify / ConstantFolding for transforms that don&#39;t create/modify instructions.
● Also used to paper over phase ordering issues
○ InstCombine re-implements weak versions of transforms from other passes
○ For example: Basic store-to-load forwarding (usually done by EarlyCSE/GVN)
52
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#53">…Combine
● InstCombine
○ Canonicalization </a><span> pass: Cannot be target-dependent
○ Backend implements reverse/undo transform if necessary
53
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#54">…Combine
● InstCombine
○ Canonicalization </a><span> pass: Cannot be target-dependent
○ Backend implements reverse/undo transform if necessary
● AggressiveInstCombine
○ For expensive transforms, only runs once in pipeline
○ Target-dependence discouraged but sometimes allowed
54
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#55">…Combine
● InstCombine
○ Canonicalization </a><span> pass: Cannot be target-dependent
○ Backend implements reverse/undo transform if necessary
● AggressiveInstCombine
○ For expensive transforms, only runs once in pipeline
○ Target-dependence discouraged but sometimes allowed
● VectorCombine
○ For target-dependent, cost-model driven vector transforms
55
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#56">CVP: CorrelatedValuePropagation
● Optimizations </a><span> based on value range information (from LazyValueInfo)
● Important for bounds check elimination
○ icmp ult i32 %x, 10 =&gt; i1 true if %x in [0, 10)
56
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#57">CVP: CorrelatedValuePropagation
● Optimizations </a><span> based on value range information (from LazyValueInfo)
● Important for bounds check elimination
○ icmp ult i32 %x, 10 =&gt; i1 true if %x in [0, 10)
● Other range based optimizations
○ sdiv i32 %x, %y =&gt; udiv i32 %x, %y if %x, %y non-negative
57
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#58">Same transform, different </a><span> analysis
58
● Some folds (e.g. sdiv -&gt; udiv) are implemented in multiple passes
○ Folds are driven by different analyses, which are good at different things
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#59">Same transform, different </a><span> analysis
59
InstCombine
ValueTracking
(KnownBits)
CorrelatedValue
Propagation
LazyValueInfo
IndVarSimplify
ScalarEvolution
IPSCCP
ValueLattice +
PredicateInfo
● Some folds (e.g. sdiv -&gt; udiv) are implemented in multiple passes
○ Folds are driven by different analyses, which are good at different things
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#60">Redundancy Elimination
60
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#61">EarlyCSE: Common Subexpression </a><span> Elimination
61
add1 = x + y;
// ...
add2 = x + y;
use(add1);
use(add2);
add1 = x + y;
// ...
use(add1);
use(add1);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#62">EarlyCSE: Common Subexpression </a><span> Elimination
● Basic CSE based on scoped hash table
● Load CSE and store-to-load forwarding using MemorySSA
62
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#63">EarlyCSE: Store to </a><span> load forwarding
63
*p = v1;
// p not written here
v2 = *p;
use(v1);
use(v2);
*p = v1;
use(v1);
use(v1);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#64">GVN: Global Value </a><span> Numbering
● More general (and much more expensive!) than EarlyCSE
● Uses MemoryDependenceAnalysis
● Non-local load CSE
● Partial redundancy elimination (PRE)
64
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#65">GVN: Non-local load </a><span> CSE
65
if (...) {
v1 = *p;
} else {
*p = v2;
}
v3 = *p;
use(v3);
if (...) {
v1 = *p;
} else {
*p = v2;
}
v3 = phi(v1, v2);
use(v3);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#66">GVN: Load PRE
66
if </a><span> (...) {
} else {
*p = v1;
}
v2 = *p;
use(v2);
if (...) {
v2_pre = *p;
} else {
*p = v1;
}
v2 = phi(v2_pre, v1);
use(v2);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#67">Memory Optimizations
67
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#68">MemCpyOpt
● Optimize memcpy </a><span> and memset using MemorySSA
68
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#69">MemCpyOpt: Memcpy forwarding
69
memcpy(y, </a><span> x, 16);
// y not written here
memcpy(z, y, 16);
memcpy(y, x, 16);
// y not written here
memcpy(z, x, 16);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#70">MemCpyOpt: Call Slot </a><span> Optimization
70
Ty tmp;
foo(tmp);
memcpy(dst, tmp, sizeof(Ty));
foo(dst);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#71">DSE: Dead Store </a><span> Elimination
● Remove dead stores using MemorySSA
71
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#72">DSE: Dead Store </a><span> Elimination
72
*p = v1;
// p not read here
*p = v2;
// p not read here
*p = v2;
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#73">DSE: Dead before </a><span> return
73
%p = alloca i32
; ...
store i32 %v, ptr %p
; %p not read here
ret void
%p = alloca i32
; ...
; %p not read here
ret void
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#74">Loop Optimization
74
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#75">Loop pass manager
● </a><span> Visit child loops first, then parent loops
● Constructs LoopSimplify and LCSSA (Loop-Closed SSA) form before running
75
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#76">76
Preheader
Exit
Loop
LICM: Hoist
x = </a><span> foo();
use(x);
y = bar();
use(y);
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#77">77
Preheader
Exit
Loop
LICM: Hoist
use(x);
y = </a><span> bar();
use(y);
x = foo();
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#78">78
Preheader
Exit
Loop
LICM: Sink
use(x);
y = </a><span> bar();
use(y);
x = foo();
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#79">79
Preheader
Exit
Loop
LICM: Sink
use(x);
y = </a><span> bar();
use(y);
x = foo();
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#80">80
Preheader
Exit
Loop
LICM: Promote
v = </a><span> *p;
vn = v + 1;
*p = vn;
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#81">81
Preheader
Exit
Loop
LICM: Promote
v = </a><span> phi(v0, vn);
vn = v + 1;
*p = vn;
v0 = *p;
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#82">LICM: Loop Invariant </a><span> Code Motion
● Transforms:
○ Hoist instructions into preheader
○ Sink instructions into exits
○ Promote scalars
● Uses MemorySSA
● Canonicalization pass: Cannot be target or PGO dependent
○ May be undone by LoopSink or MachineSink
82
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#83">IndVarSimplify
● Uses ScalarEvolution </a><span> analysis
● Simplify induction variables (IVs) and their uses
● Simplify loop exit conditions
83
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#84">IndVarSimplify: Loop exit </a><span> value replacement
unsigned test(unsigned n) {
unsigned sum = 0;
for (unsigned i = 0; i &lt;= n; i++) {
sum += i;
}
return sum;
}
84
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#85">IndVarSimplify: Loop exit </a><span> value replacement
unsigned test(unsigned n) {
unsigned sum = 0;
for (unsigned i = 0; i &lt;= n; i++) {
sum += i;
}
return sum;
}
unsigned test(unsigned n) {
for (unsigned i = 0; i &lt;= n; i++) {}
return (n * (n - 1))/2 + n;
}
85
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#86">IndVarSimplify: Loop exit </a><span> value replacement
unsigned test(unsigned n) {
unsigned sum = 0;
for (unsigned i = 0; i &lt;= n; i++) {
sum += i;
}
return sum;
}
unsigned test(unsigned n) {
for (unsigned i = 0; i &lt;= n; i++) {}
return (n * (n - 1))/2 + n;
}
86
Later removed by LoopDeletion
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#87">LoopUnroll: Full unrolling
87
Iteration </a><span> #1
Iteration #2
Iteration #3
Iteration #4
Iteration #1-4
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#88">LoopUnroll: Loop peeling
88
Iteration </a><span> #1-N
Iteration #1
Iteration #2-N
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#89">LoopUnroll: Partial unrolling
89
Iteration </a><span> #(4i+1)
Iteration #(4i+2)
Iteration #(4i+3)
Iteration #(4i+4)
Iteration #1-400
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#90">LoopUnroll: Runtime unrolling
90
Iteration </a><span> #(4i+1)
Iteration #(4i+2)
Iteration #(4i+3)
Iteration #(4i+4)
Iteration #1-N
Tail iterations
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#91">LoopUnroll
● Simplification:
○ Full </a><span> unrolling (requires known constant trip count)
○ Loop peeling
● Optimization:
○ Partial unrolling (requires known constant trip count/multiple)
○ Runtime unrolling
91
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#92">Vectorization
92
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#93">LoopVectorize
● VPlan to </a><span> model vectorization without IR changes
● LoopAccessAnalysis to ensure memory dependences are safe
● May require inserting runtime checks and LoopVersioning
93
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#94">SLPVectorize
● SLP = </a><span> Superword-Level Parallelism
● Vectorizes straight-line code
94
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#95">Inter-Procedural Optimization (IPO)
95
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#96">FunctionAttrs
● Infer attributes </a><span> on function, arguments and return values
○ nounwind, readonly, nonnull, etc.
96
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#97">FunctionAttrs
● Infer attributes </a><span> on function, arguments and return values
○ nounwind, readonly, nonnull, etc.
● General approach:
○ Optimistically all functions in the SCC are nounwind
○ Check whether there are any non-nounwind instructions
○ If not, mark all functions in the SCC nounwind
97
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#98">FunctionAttrs
● Infer attributes </a><span> on function, arguments and return values
○ nounwind, readonly, nonnull, etc.
● General approach:
○ Optimistically all functions in the SCC are nounwind
○ Check whether there are any non-nounwind instructions
○ If not, mark all functions in the SCC nounwind
● New &#34;Attributor&#34; implements much stronger version of this, but not enabled by
default (too slow)
98
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#99">IPSCCP: Inter-Procedural Sparse </a><span> Conditional Constant Propagation
● Propagates constants and constant ranges across functions
● Uses PredicateInfo to take branch conditions into account
99
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#100">IPSCCP: Inter-Procedural Sparse </a><span> Conditional Constant Propagation
● Propagates constants and constant ranges across functions
● Uses PredicateInfo to take branch conditions into account
● Runs very early, before most simplification (which may lose information)
100
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#101">IPSCCP: Inter-Procedural Sparse </a><span> Conditional Constant Propagation
● Propagates constants and constant ranges across functions
● Uses PredicateInfo to take branch conditions into account
● Runs very early, before most simplification (which may lose information)
● Also does function specialization (since recently)
101
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#102">Thank You!
Questions?
102
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#103">The End
● Blog: </a><span> https://www.npopov.com/
● Reach me at:
○ npopov@redhat.com
○ https://twitter.com/nikita_ppv
103
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#104">Bonus Slides
104
  </a></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#105">JumpThreading
105
if (x &gt; </a><span> 10) {
greater10();
}
always();
if (x &gt; 0) {
greater0();
}
if (x &gt; 10) {
greater10();
always();
greater0();
} else {
always();
}
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#106">JumpThreading
● Optimizes conditional </a><span> branches where one condition implies another
● Uses LazyValueInfo analysis, which provides value range information
106
 </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#107">107
Header
Latch
Preheader
Exit 1
Exit 2
Loop
Backedge
Loop
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#108">108
Header
Latch
Preheader
Exit 1
Exit 2
Loop
Backedge
LoopSimplify
Form
 </a><span> </span></li><li><a href="https://www.slideshare.net/nikita_ppv/a-whirlwind-tour-of-the-llvm-optimizerpdf#109">SimpleLoopUnswitch
while (...) {
if </a><span> (c) {
foo();
} else {
bar();
}
}
109
if (c) {
while (...) {
foo();
}
} else {
while (...) {
bar();
}
}
 </span></li></ol></div></div></div>
  </body>
</html>
