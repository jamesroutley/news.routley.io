<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.hartleybrody.com/thoughts-on-flyio/">Original</a>
    <h1>My thoughts about Fly.io (so far) and other newish technology I&#39;m getting into</h1>
    
    <div id="readability-page-1" class="page"><section>
                

<p>It’s been 5 years since I launched my <a href="https://github.com/hartleybrody/flask-boilerplate">flask boilerplate project</a> in 2017, and that has been my go-to web stack ever since. I’ve built dozens of web apps with it – both for clients as well as personal projects.</p>
<p>Being an independent consultant, I’m not surrounded by a team of people bringing in different ideas or ways of doing things, so I have to occasionally remember to poke my head up and see what’s going on around me.</p>
<p>I spent some time last year (finally) getting familiar with Docker, and wrote my own “Docker Crash Course” as I learned.</p>
<h3>Elixir &amp; Phoenix</h3>
<p>This year, my goal is to get used to a totally new language and web stack. One that’s fast, productive and requires writing as little javascript as possible:</p>
<ul>
<li><a href="https://elixir-lang.org/getting-started/introduction.html">elixir</a> - a functional language that shares the Erlang VM</li>
<li><a href="https://www.phoenixframework.org/">phoenix</a> - the most productive “batteries included” framework for Elixir</li>
<li><a href="https://htmx.org/docs/#introduction">HTMX</a> - for dynamically updating page content with server-rendered HTML</li>
<li><a href="https://alpinejs.dev/">alpine.js</a> - for managing js state – if you really, really must</li>
</ul>
<p>I was originally put onto HTMX and Alpine by <a href="https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/htmx-alpine/">this article</a> that was <a href="https://news.ycombinator.com/item?id=29319034">posted to HN last November</a>. From the discussion on that article, I found a comment that mentioned <a href="https://www.youtube.com/watch?v=8xJzHq8ru0M">this demo from Chris McCord</a> on Phoenix LiveView.</p>
<blockquote>
<p>Have a look at how Phoenix(Elixir) does it with LiveView. You simply write everything as a server rendered view and the framework pulls things apart and sends just what changed over a web socket. Its mind blowing how fast it is (can be. Latency is real)</p>
<p>I have no doubt that this style of front-end management is going to be a game changer in the next few years. Of course full-on SPA frameworks will still have their place. But if you aren’t writing the next Google Maps clone, maybe you don’t need all that. <em>It’s made me love web dev again after hating the complexity explosion of recent years.</em> (emphasis added)</p>
<p>https://m.youtube.com/watch?v=8xJzHq8ru0M</p>
</blockquote>
<p>I finally got around to watching the talk the other day and was definitely blown away with how elegant that framework makes it to keep a reactive UI using server-managed state. I’m also going through <a href="https://elixir-lang.org/getting-started/introduction.html">the Elixir introduction</a> and <a href="https://elixirschool.com/en/lessons/basics/documentation/">Elixir School</a> to learn the basics of the Erlang-based language.</p>
<h3>Fly.io</h3>
<p>The other thing that I’m seeing coming up a lot on HN is <a href="https://fly.io/">fly.io</a>, which says</p>
<blockquote>
<p>Deploy App Servers Close to Your Users</p>
<p>Run your full stack apps (and databases!) all over the world. No ops required.</p>
</blockquote>
<p>The product <a href="https://news.ycombinator.com/item?id=22616857">launched on HN in March 2020</a> and was summarized by a commenter as</p>
<blockquote>
<p>fly.io is really a way to run Docker images on servers in different cities and a global router to connect users to the nearest available instance. We convert your Docker image into a root filesystem, boot tiny VMs using an Amazon project called Firecracker, and then proxy connections to it. As your app gets more traffic, we add VMs in the most popular locations.</p>
</blockquote>
<p>It seems like it’s got a lot of buzz, especially since they’re <a href="https://news.ycombinator.com/item?id=31318708">riding the wave of support for sqlite in web apps</a> with products like <a href="https://litestream.io/">litestream</a> that back up your sqlite file to s3.</p>
<p>I spent a few hours reading the docs and eventually found <a href="https://fly.io/docs/reference/architecture/">this very helpful piece buried near the bottom of their nav</a>. I especially got excited when I saw this piece entitled <a href="https://christine.website/blog/fly.io-heroku-replacement">“Fly.io: the Reclaimer of Heroku’s Magic”</a> make the <a href="https://news.ycombinator.com/item?id=31390506">top of HN</a>.</p>
<p>I’ve been using heroku for years and while some might complain that it has stagnated and mostly stayed the same since the salesforce acquistion, I think that’s been an asset. It feels like exactly what I need, and nothing I don’t – an easy way to run a web app that offers a decent add-on marketplace, and enforces <a href="https://12factor.net/">12factor.net</a> best practices.</p>
<p>I nodded along with <a href="https://news.ycombinator.com/item?id=31391163">this HN comment</a> on the article claiming Fly was reclaiming Heroku’s magic:</p>
<blockquote>
<p>After all the chatter this week, I’ve come to the conclusion that Heroku froze at the perfect time for my 4 person company. All of these so called “features” are exactly what we don’t want or need.</p>
<p>…</p>
<p>I’m really glad Heroku froze when it did. Markets always demand growth at all costs, and I find it incredibly refreshing that Heroku ended up staying in its lane. IMO it was and remains the best PaaS for indie devs and small teams.</p>
</blockquote>
<p>But I’m also aware of the bias against shiny new things. I know that it’s dangerous to assume that we figured out all of the answers in 2014 and there’s no need to learn anything new ever again. I do want to jump into some new tech that makes intuitive sense to me at a high level.</p>
<p>But despite how much I want to learn the fly.io platform – it has been a bit tricky for me wrap my head around a good use-case for this type of distributed hosting service.</p>
<p>For one, is the cost. If you want a $5/mo server in 4 places, that’s $20/month, which makes sense. But also, I don’t know when I’d want to pay 4x the hosting costs just to “reduce latency” for most applications. I’d rather spend that on a bigger database or cache server for likely a much bigger performance boost.</p>
<p>They also promote the idea of having a local read replica of your database running alongside each instance of your app, but this complicates the picture for writes (which must still be centralized) and eventual consistency. It seems like this would add a whole new class of bugs, like “I just submitted a form to change a setting and when the page reloaded, it still showed my previous value in the form” – since the write hadn’t propagated to the local read replica yet.</p>
<p>Some commenters seem to think <a href="https://www.cockroachlabs.com/compare/cockroachdb-vs-postgresql/">CockroachDB</a> will help solve this problem. It’s certainly interesting that it’s <a href="https://www.cockroachlabs.com/docs/stable/postgresql-compatibility.html">wire compatible with postgres</a>, but I just don’t like the complexity of the mental model that all of these distributed services create.</p>
<p>It seems like it’s a service that’s really geared for apps that can live in a truly distributed way to be “close to the user” and not worry too much about consistent state. From their HN launch thread <a href="https://news.ycombinator.com/item?id=22621827">the founder mentions these use cases</a></p>
<ul>
<li>image, video, audio processing near consumers</li>
<li>game or video chat servers running near the centroid of  people in a session</li>
<li>server side rendering of single page js apps</li>
<li>route users to regional data centers for compliance</li>
<li>graphql stitching / caching (we do this!)</li>
<li>pass through cache for s3, or just minio as a global s3 (we do this!)</li>
<li>buildkite / GitHub Action agents (we do this!)</li>
<li>tensorflow prediction / DDoS &amp; bot detection</li>
<li>load balance between spot instances on AWS/GCP</li>
<li>TLS termination for custom domains</li>
<li>authentication proxy / api gateway (we do this!)</li>
<li>IoT stream processing near devices</li>
</ul>
<p>but these all seem like fairly specialized workloads, and not something for the average web app.</p>
<p>I do want to be open to doing things a new way and weening myself off of the stack I’ve practically memorized over the past 5 years. I know it will be slower initially, but if I’m going to continue benefiting from standing on the shoulders of giants, it’s good to hop up onto the taller ones that stand up every few years.</p>


              </section></div>
  </body>
</html>
