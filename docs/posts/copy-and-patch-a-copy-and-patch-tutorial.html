<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://transactional.blog/copy-and-patch/tutorial">Original</a>
    <h1>Copy-and-Patch: A Copy-and-Patch Tutorial</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <hr/>
    
    
    
    
<div id="preamble">
  <p><a href="https://arxiv.org/abs/2011.13127">Copy-and-patch Compilation</a> is a fascinating way of constructing a baseline JIT<a id="_sideref_1"></a><sup>[1]</sup>.  It permits incredibly fast runtime compilation of code fragments in a very easy to maintain fashion, requires barely any actual understanding of assembly code, and produces native code of sufficient quality to be within the same range as traditional, hand-written baseline JITs.
<span><a id="_sidedef_1"></a>[1]: Baseline JIT, as in a JIT whose goal is primarily to generate code quickly and gain performance by removing interpretation overhead than generating well optimized code itself.  Baseline JITs can be paired with optimizing JITs, like V8’s Liftoff baseline JIT for WASM allowing tiering up into V8’s Crankshaft optimizing JIT.</span></p>
<p>Copy-and-patch works by writing <em>stencils</em>, minimal C functions that implement the desired individual operations such that they compile to concatenate native code fragments. At JIT compile time, one can copy the pre-compiled fragment for each operation back-to-back, patching them change embedded constants or addresses as needed..</p>
<p>As an adventure into understanding how copy-and-patch works, our goal will be to create the function</p>
<div>
<div>
<pre><code data-lang="c"><span>int</span> <span>add_a_b</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>a</span> <span>+</span> <span>b</span>
<span>}</span></code></pre>
</div>
</div>
<p>But specialized at runtime to compute <code>1 + 2</code>. We’ll be doing this by first breaking it down into some bytecode-sized operations:</p>
<div>
<ol>
<li>
<p>const_int_reg1: <code>a = 1;</code></p>
</li>
<li>
<p>const_int_reg2: <code>b = 2;</code></p>
</li>
<li>
<p>add_int1_int2: <code>c = a + b;</code></p>
</li>
<li>
<p>return_int1: <code>return c;</code></p>
</li>
</ol>
</div>
<p>And to define our copy-and-patch JIT, we’ll take each of these and:</p>
<div>
<ol>
<li>
<p>Implement the operation in C with relocation holes to be later patched to form our stencil.</p>
</li>
<li>
<p>Compile the stencil into native code.</p>
</li>
<li>
<p>Copy-paste the native code back into a C file with functions to emit it to a buffer and patch any relocations.</p>
</li>
</ol>
</div>
<p>Then we can write our little JIT compilation engine to concatenate our stencils and execute the generated function. Let’s get started!</p>
</div>
<h2 id="_stencils">
Stencils
</h2> 
<p>Our first step is to define our stencils:</p>
<div>
<p>stencils.c</p>
<div>
<pre><code data-lang="c"><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span>
<span>#define STENCIL_FUNCTION __attribute__((preserve_none))
</span>
<span>extern</span> <span>char</span> <span>cnp_value_hole</span><span>[</span><span>65536</span><span>];</span>
<span>extern</span> <span>void</span> <span>cnp_func_hole</span><span>(</span><span>void</span><span>)</span> <span>STENCIL_FUNCTION</span><span>;</span>

<span>#define STENCIL_HOLE(type) \
  (type)((uintptr_t)&amp;cnp_value_hole)
#define DECLARE_STENCIL_OUTPUT(...) \
  typedef void(*stencil_output_fn)(__VA_ARGS__) STENCIL_FUNCTION; \
  stencil_output_fn stencil_output = (stencil_output_fn)&amp;cnp_func_hole;
</span>
<span>STENCIL_FUNCTION</span> <span>void</span> <span>load_int_reg1</span><span>()</span> <span>{</span>
  <span>int</span> <span>a</span> <span>=</span> <span>STENCIL_HOLE</span><span>(</span><span>int</span><span>);</span>
  <span>DECLARE_STENCIL_OUTPUT</span><span>(</span><span>int</span><span>);</span>
  <span>stencil_output</span><span>(</span><span>a</span><span>);</span>
<span>}</span>

<span>STENCIL_FUNCTION</span> <span>void</span> <span>load_int_reg2</span><span>(</span><span>int</span> <span>a</span><span>)</span> <span>{</span>
  <span>int</span> <span>b</span> <span>=</span> <span>STENCIL_HOLE</span><span>(</span><span>int</span><span>);</span>
  <span>DECLARE_STENCIL_OUTPUT</span><span>(</span><span>int</span><span>,</span> <span>int</span><span>);</span>
  <span>stencil_output</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>);</span>
<span>}</span>

<span>STENCIL_FUNCTION</span> <span>void</span> <span>add_int1_int2</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>)</span> <span>{</span>
  <span>int</span> <span>c</span> <span>=</span> <span>a</span> <span>+</span> <span>b</span><span>;</span>
  <span>DECLARE_STENCIL_OUTPUT</span><span>(</span><span>int</span><span>);</span>
  <span>stencil_output</span><span>(</span><span>c</span><span>);</span>
<span>}</span>

<span>STENCIL_FUNCTION</span> <span>int</span> <span>return_int1</span><span>(</span><span>int</span> <span>a</span><span>)</span> <span>{</span>
  <span>return</span> <span>a</span><span>;</span>
<span>}</span></code></pre>
</div>
</div>
<p>We compile this with <code>clang -O3 -mcmodel=medium -c stencils.c</code>, and examine the generated code via <code>objdump -d -Mintel,x86-64 --disassemble --reloc stencils.o</code>.  This yields:</p>
<div>
<div>
<pre><code data-lang="nasm"><span>0000000000000000</span> <span>&lt;</span><span>load_int_reg1</span><span>&gt;</span><span>:</span>
   <span>0</span><span>:</span>	<span>41</span> <span>bc</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>    	<span>mov</span>    <span>r12d</span><span>,</span><span>0x0</span>
			<span>2</span><span>:</span> <span>R_X86_64_32</span>	<span>cnp_value_hole</span>
   <span>6</span><span>:</span>	<span>e9</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>       	<span>jmp</span>    <span>b</span> <span>&lt;</span><span>load_int_reg1</span><span>+</span><span>0xb</span><span>&gt;</span>
			<span>7</span><span>:</span> <span>R_X86_64_PLT32</span>	<span>cnp_func_hole</span><span>-</span><span>0x4</span>
   <span>b:</span>	<span>0</span><span>f</span> <span>1</span><span>f</span> <span>44</span> <span>00</span> <span>00</span>       	<span>nop</span>    <span>DWORD</span> <span>PTR</span> <span>[</span><span>rax</span><span>+</span><span>rax</span><span>*</span><span>1</span><span>+</span><span>0x0</span><span>]</span>

<span>0000000000000010</span> <span>&lt;</span><span>load_int_reg2</span><span>&gt;</span><span>:</span>
  <span>10</span><span>:</span>	<span>41</span> <span>bd</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>    	<span>mov</span>    <span>r13d</span><span>,</span><span>0x0</span>
			<span>12</span><span>:</span> <span>R_X86_64_32</span>	<span>cnp_value_hole</span>
  <span>16</span><span>:</span>	<span>e9</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>       	<span>jmp</span>    <span>1b</span> <span>&lt;</span><span>load_int_reg2</span><span>+</span><span>0xb</span><span>&gt;</span>
			<span>17</span><span>:</span> <span>R_X86_64_PLT32</span>	<span>cnp_func_hole</span><span>-</span><span>0x4</span>
  <span>1</span><span>b:</span>	<span>0</span><span>f</span> <span>1</span><span>f</span> <span>44</span> <span>00</span> <span>00</span>       	<span>nop</span>    <span>DWORD</span> <span>PTR</span> <span>[</span><span>rax</span><span>+</span><span>rax</span><span>*</span><span>1</span><span>+</span><span>0x0</span><span>]</span>

<span>0000000000000020</span> <span>&lt;</span><span>add_int1_int2</span><span>&gt;</span><span>:</span>
  <span>20</span><span>:</span>	<span>45</span> <span>01</span> <span>ec</span>             	<span>add</span>    <span>r12d</span><span>,</span><span>r13d</span>
  <span>23</span><span>:</span>	<span>e9</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>       	<span>jmp</span>    <span>28</span> <span>&lt;</span><span>add_int1_int2</span><span>+</span><span>0x8</span><span>&gt;</span>
			<span>24</span><span>:</span> <span>R_X86_64_PLT32</span>	<span>cnp_func_hole</span><span>-</span><span>0x4</span>
  <span>28</span><span>:</span>	<span>0</span><span>f</span> <span>1</span><span>f</span> <span>84</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> 	<span>nop</span>    <span>DWORD</span> <span>PTR</span> <span>[</span><span>rax</span><span>+</span><span>rax</span><span>*</span><span>1</span><span>+</span><span>0x0</span><span>]</span>
  <span>2</span><span>f:</span>	<span>00</span>

<span>0000000000000030</span> <span>&lt;</span><span>return_int1</span><span>&gt;</span><span>:</span>
  <span>30</span><span>:</span>	<span>44</span> <span>89</span> <span>e0</span>             	<span>mov</span>    <span>eax</span><span>,</span><span>r12d</span>
  <span>33</span><span>:</span>	<span>c3</span>                   	<span>ret</span></code></pre>
</div>
</div>
<p>(The NOP’s aren’t actually a part of the function, they’re just padding added so that each function starts with 16 byte alignment.)</p>
<p>For each of these stencils, we fill in a template to form our stencil generation library to use during JITing.</p>
<div>
<div>
<pre><code data-lang="c"><span>uint8_t</span> <span>cnp_stencil_</span><span>&lt;</span><span>OP</span><span>&gt;</span><span>_code</span><span>[]</span> <span>=</span> <span>{</span>
  <span>// Copy the bytes from the top of the function until the jmp.</span>
<span>};</span>

<span>uint8_t</span><span>*</span> <span>cnp_copy_</span><span>&lt;</span><span>OP</span><span>&gt;</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>stencil_size</span> <span>=</span> <span>sizeof</span><span>(</span><span>cnp_stencil_</span><span>&lt;</span><span>OP</span><span>&gt;</span><span>_code</span><span>);</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span><span>,</span> <span>cnp_stencil_</span><span>&lt;</span><span>OP</span><span>&gt;</span><span>_code</span><span>,</span> <span>stencil_size</span><span>);</span>
  <span>return</span> <span>stencil_start</span> <span>+</span> <span>stencil_size</span><span>;</span>
<span>}</span>

<span>// If any relocations exist for the stencil, fill in the values.</span>
<span>// If not, just skip writing this function.</span>
<span>void</span> <span>cnp_patch_</span><span>&lt;</span><span>OP</span><span>&gt;</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>,</span> <span>/* ... */</span> <span>)</span> <span>{</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span> <span>+</span> <span>/*relocation_offset*/</span><span>,</span> <span>&amp;</span><span>value</span><span>,</span> <span>/* relocation_size */</span><span>);</span>
<span>}</span></code></pre>
</div>
</div>
<p>So let’s get started!</p>
<div>
<p>cnp_stencils.c</p>
<div>
<pre><code data-lang="c"><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span>
<span>uint8_t</span> <span>cnp_stencil_load_int_reg1_code</span><span>[]</span> <span>=</span> <span>{</span>
   <span>0x41</span><span>,</span> <span>0xbc</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>// mov r12d,0x0</span>
<span>};</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_load_int_reg1</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>stencil_size</span> <span>=</span> <span>sizeof</span><span>(</span><span>cnp_stencil_load_int_reg1_code</span><span>);</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span><span>,</span> <span>cnp_stencil_load_int_reg1_code</span><span>,</span> <span>stencil_size</span><span>);</span>
  <span>return</span> <span>stencil_start</span> <span>+</span> <span>stencil_size</span><span>;</span>
<span>}</span>
<span>void</span> <span>cnp_patch_load_int_reg1</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>,</span> <span>int</span> <span>value</span><span>)</span> <span>{</span>
  <span>// 2: R_X86_64_32 cnp_value_hole  -&gt;  0x02 offset</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span> <span>+</span> <span>0x2</span><span>,</span> <span>&amp;</span><span>value</span><span>,</span> <span>sizeof</span><span>(</span><span>value</span><span>));</span>
<span>}</span>

<span>uint8_t</span> <span>cnp_stencil_load_int_reg2_code</span><span>[]</span> <span>=</span> <span>{</span>
   <span>0x41</span><span>,</span> <span>0xbd</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>// mov r13d,0x0</span>
<span>};</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_load_int_reg2</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>stencil_size</span> <span>=</span> <span>sizeof</span><span>(</span><span>cnp_stencil_load_int_reg2_code</span><span>);</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span><span>,</span> <span>cnp_stencil_load_int_reg2_code</span><span>,</span> <span>stencil_size</span><span>);</span>
  <span>return</span> <span>stencil_start</span> <span>+</span> <span>stencil_size</span><span>;</span>
<span>}</span>
<span>void</span> <span>cnp_patch_load_int_reg2</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>,</span> <span>int</span> <span>value</span><span>)</span> <span>{</span>
  <span>// 12: R_X86_64_32 cnp_value_hole  -&gt;  0x12 - 0x10 base = 0x2</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span> <span>+</span> <span>0x2</span><span>,</span> <span>&amp;</span><span>value</span><span>,</span> <span>sizeof</span><span>(</span><span>value</span><span>));</span>
<span>}</span>

<span>uint8_t</span> <span>cnp_stencil_add_int1_int2_code</span><span>[]</span> <span>=</span> <span>{</span>
  <span>0x45</span><span>,</span> <span>0x01</span><span>,</span> <span>0xec</span><span>,</span> <span>// add r12d,r13d</span>
<span>};</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_add_int1_int2</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>stencil_size</span> <span>=</span> <span>sizeof</span><span>(</span><span>cnp_stencil_add_int1_int2_code</span><span>);</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span><span>,</span> <span>cnp_stencil_add_int1_int2_code</span><span>,</span> <span>stencil_size</span><span>);</span>
  <span>return</span> <span>stencil_start</span> <span>+</span> <span>stencil_size</span><span>;</span>
<span>}</span>
<span>// No patching needed</span>

<span>uint8_t</span> <span>cnp_stencil_return_int1_code</span><span>[]</span> <span>=</span> <span>{</span>
  <span>0x44</span><span>,</span> <span>0x89</span><span>,</span> <span>0xe0</span><span>,</span> <span>// mov eax,r12d</span>
  <span>0xc3</span><span>,</span>             <span>// ret</span>
<span>};</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_return_int1</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>stencil_size</span> <span>=</span> <span>sizeof</span><span>(</span><span>cnp_stencil_return_int1_code</span><span>);</span>
  <span>memcpy</span><span>(</span><span>stencil_start</span><span>,</span> <span>cnp_stencil_return_int1_code</span><span>,</span> <span>stencil_size</span><span>);</span>
  <span>return</span> <span>stencil_start</span> <span>+</span> <span>stencil_size</span><span>;</span>
<span>}</span>
<span>// No patching needed</span></code></pre>
</div>
</div>
<p>In a fully automated setup, all of this work will happen as part of the build system. The stencil compilation and transforming them into a library of copy functions and patch functions happens as part running <code>make</code>.</p>
<h2 id="_your_first_jit">
Your First JIT
</h2> 
<p>With our stencil library in place, we can use our code generation functions to build our runtime specialized adder:</p>
<div>
<p>cnp_jit.c</p>
<div>
<pre><code data-lang="c"><span>#include</span> <span>&lt;assert.h&gt;</span><span>
#include</span> <span>&lt;stdint.h&gt;</span><span>
#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;stdlib.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
#include</span> <span>&lt;sys/mman.h&gt;</span><span>
</span>
<span>//#include &#34;cnp_stencils.h&#34;</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_load_int_reg1</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>);</span>
<span>void</span> <span>cnp_patch_load_int_reg1</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>,</span> <span>int</span> <span>value</span><span>);</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_load_int_reg2</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>);</span>
<span>void</span> <span>cnp_patch_load_int_reg2</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>,</span> <span>int</span> <span>value</span><span>);</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_add_int1_int2</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>);</span>
<span>uint8_t</span><span>*</span> <span>cnp_copy_return_int1</span><span>(</span><span>uint8_t</span><span>*</span> <span>stencil_start</span><span>);</span>

<span>typedef</span> <span>int</span><span>(</span><span>*</span><span>jit_func</span><span>)()</span> <span>__attribute__</span><span>((</span><span>preserve_none</span><span>));</span>

<span>jit_func</span> <span>create_add_1_2</span><span>()</span> <span>{</span>
  <span>// Most systems mark memory as non-executable by default</span>
  <span>// and mprotect() to set memory as executable needs</span>
  <span>// to be run against mmap-allocated memory.  We start</span>
  <span>// by allocating it as read/write, and then switch it</span>
  <span>// to write/execute once we&#39;re done writing the code.</span>
  <span>uint8_t</span><span>*</span> <span>codedata</span> <span>=</span> <span>mmap</span><span>(</span><span>NULL</span><span>,</span> <span>256</span><span>,</span> <span>PROT_READ</span> <span>|</span> <span>PROT_WRITE</span><span>,</span>
      <span>MAP_PRIVATE</span> <span>|</span> <span>MAP_ANONYMOUS</span> <span>|</span> <span>MAP_POPULATE</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>);</span>
  <span>assert</span> <span>(</span><span>codedata</span> <span>!=</span> <span>MAP_FAILED</span><span>);</span>
  <span>jit_func</span> <span>ret</span> <span>=</span> <span>(</span><span>jit_func</span><span>)</span><span>codedata</span><span>;</span>

  <span>// Concatenate our program together, while saving the</span>
  <span>// locations that need to be patched.</span>
  <span>uint8_t</span><span>*</span> <span>load_int_reg1_location</span> <span>=</span> <span>codedata</span><span>;</span>
  <span>codedata</span> <span>=</span> <span>cnp_copy_load_int_reg1</span><span>(</span><span>codedata</span><span>);</span>
  <span>uint8_t</span><span>*</span> <span>load_int_reg2_location</span> <span>=</span> <span>codedata</span><span>;</span>
  <span>codedata</span> <span>=</span> <span>cnp_copy_load_int_reg2</span><span>(</span><span>codedata</span><span>);</span>
  <span>codedata</span> <span>=</span> <span>cnp_copy_add_int1_int2</span><span>(</span><span>codedata</span><span>);</span>
  <span>codedata</span> <span>=</span> <span>cnp_copy_return_int1</span><span>(</span><span>codedata</span><span>);</span>

  <span>// Overwrite the zero value placeholders with our intended</span>
  <span>// specialized values: 1 and 2.</span>
  <span>cnp_patch_load_int_reg1</span><span>(</span><span>load_int_reg1_location</span><span>,</span> <span>1</span><span>);</span>
  <span>cnp_patch_load_int_reg2</span><span>(</span><span>load_int_reg2_location</span><span>,</span> <span>2</span><span>);</span>

  <span>// Now that we&#39;re done writing, remove write access and</span>
  <span>// allow execution from this page instead.</span>
  <span>int</span> <span>rc</span> <span>=</span> <span>mprotect</span><span>(</span><span>ret</span><span>,</span> <span>256</span><span>,</span> <span>PROT_READ</span> <span>|</span> <span>PROT_EXEC</span><span>);</span>
  <span>if</span> <span>(</span><span>rc</span><span>)</span> <span>{</span>
    <span>perror</span><span>(</span><span>&#34;mprotect&#34;</span><span>);</span>
  <span>}</span>
  <span>return</span> <span>ret</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>jit_func</span> <span>add_1_2</span> <span>=</span> <span>create_add_1_2</span><span>();</span>
  <span>int</span> <span>result</span> <span>=</span> <span>add_1_2</span><span>();</span>
  <span>printf</span><span>(</span><span>&#34;JIT&#39;d 1 + 2 = %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>result</span><span>);</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre>
</div>
</div>
<p>And now we can compile and run that!</p>
<div>
<div>
<pre>$ clang cnp_jit.c cnp_stencils.c -o cnp_jit
$ ./cnp_jit
JIT&#39;d 1 + 2 = 3</pre>
</div>
</div>
<p>We’ve successfully built runtime code generation, while letting clang do the hard work of actually writing the assembly code, and our JIT compiler is just a bunch of memcpy calls!</p>
<h2 id="_try_it_yourself">
Try It Yourself
</h2> 
<p>Here’s a header to offer some macros to make declaring relocation holes easier:</p>
<div>
<p>cnp_stencils.h</p>
<div>
<pre><code data-lang="c"><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span>
<span>#define STENCIL_FUNCTION __attribute__((preserve_none))
</span>
<span>extern</span> <span>void</span> <span>cnp_stencil_output</span><span>(</span><span>void</span><span>)</span> <span>STENCIL_FUNCTION</span><span>;</span>

<span>#define STENCIL_HOLE32(ordinal, type) \
  (type)((uintptr_t)&amp;cnp_small_value_hole_##ordinal)
#define STENCIL_HOLE64(ordinal, type) \
  (type)((uintptr_t)&amp;cnp_large_value_hole_##ordinal)
#define STENCIL_FN_NEAR(ordinal, type) \
  (type)&amp;cnp_near_func_hole_##ordinal
#define STENCIL_FN_FAR(ordinal, type) \
  ({ uint64_t _cnp_addr_as_int = (uint64_t)((uintptr_t)&amp;cnp_far_func_hole_##ordinal); \
  asm volatile(&#34;&#34; : &#34;+r&#34; (_cnp_addr_as_int) : : &#34;memory&#34;); \
  (type)_cnp_addr_as_int; })
#define DECLARE_STENCIL_OUTPUT(...) \
  typedef void(*stencil_output_fn)(__VA_ARGS__) STENCIL_FUNCTION; \
  stencil_output_fn stencil_output = (stencil_output_fn)&amp;cnp_stencil_output;
</span>
<span>#define DECLARE_EXTERN_HOLES(ordinal) \
extern char cnp_large_value_hole_##ordinal[100000]; \
extern char cnp_small_value_hole_##ordinal[8]; \
extern void cnp_near_func_hole_##ordinal(void) STENCIL_FUNCTION; \
extern char cnp_far_func_hole_##ordinal[100000];</span></code></pre>
</div>
</div>
<p>(If you’re interested in the details of why these macros are the way they are, see the next post in the series!)</p>
<p>Then you can declare as complex of a stencil as you need:</p>
<div>
<p>complex_stencil.h</p>
<div>
<pre><code data-lang="c"><span>#include</span> <span>&#34;cnp_stencils.h&#34;</span><span>
</span>
<span>// Declare up to the maximum number of holes you need of one type</span>
<span>// in a function:</span>
<span>DECLARE_EXTERN_HOLES</span><span>(</span><span>1</span><span>);</span>
<span>DECLARE_EXTERN_HOLES</span><span>(</span><span>2</span><span>);</span>

<span>STENCIL_FUNCTION</span>
<span>void</span> <span>fused_multiply_add_sqrt_ifnotzero</span><span>()</span> <span>{</span>
  <span>uint32_t</span> <span>a</span> <span>=</span> <span>STENCIL_HOLE32</span><span>(</span><span>1</span><span>,</span> <span>uint32_t</span><span>);</span>
  <span>uint32_t</span> <span>b</span> <span>=</span> <span>STENCIL_HOLE32</span><span>(</span><span>2</span><span>,</span> <span>int32_t</span><span>);</span>
  <span>uint64_t</span> <span>c</span> <span>=</span> <span>STENCIL_HOLE64</span><span>(</span><span>1</span><span>,</span> <span>uint64_t</span><span>);</span>

  <span>uint64_t</span> <span>fma</span> <span>=</span> <span>a</span> <span>*</span> <span>b</span> <span>+</span> <span>c</span><span>;</span>

  <span>if</span> <span>(</span><span>fma</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>void</span> <span>(</span><span>*</span><span>div_trap</span><span>)(</span><span>void</span><span>)</span> <span>=</span> <span>STENCIL_FN_NEAR</span><span>(</span><span>1</span><span>,</span> <span>void</span><span>(</span><span>*</span><span>)(</span><span>void</span><span>));</span>
    <span>div_trap</span><span>();</span>
  <span>}</span>

  <span>uint64_t</span> <span>(</span><span>*</span><span>sqrt</span><span>)(</span><span>uint64_t</span><span>)</span> <span>=</span> <span>STENCIL_FN_FAR</span><span>(</span><span>1</span><span>,</span> <span>uint64_t</span><span>(</span><span>*</span><span>)(</span><span>uint64_t</span><span>));</span>
  <span>uint64_t</span> <span>result</span> <span>=</span> <span>sqrt</span><span>(</span><span>c</span><span>);</span>

  <span>DECLARE_STENCIL_OUTPUT</span><span>(</span><span>uint64_t</span><span>);</span>
  <span>stencil_output</span><span>(</span><span>result</span><span>);</span>
<span>}</span></code></pre>
</div>
</div>
<p>Which just for completeness sake, compiles into:</p>
<div>
<div>
<pre>0000000000000000 &lt;fused_multiply_add_sqrt_ifnotzero&gt;:
   0:	50                   	push   rax
   1:	b8 00 00 00 00       	mov    eax,0x0
			2: R_X86_64_32	cnp_small_value_hole_2
   6:	b9 00 00 00 00       	mov    ecx,0x0
			7: R_X86_64_32	cnp_small_value_hole_1
   b:	0f af c8             	imul   ecx,eax
   e:	48 b8 00 00 00 00 00 	movabs rax,0x0
  15:	00 00 00
			10: R_X86_64_64	cnp_large_value_hole_1
  18:	48 01 c8             	add    rax,rcx
  1b:	75 05                	jne    22 &lt;fused_multiply_add_sqrt_ifnotzero+0x22&gt;
  1d:	e8 00 00 00 00       	call   22 &lt;fused_multiply_add_sqrt_ifnotzero+0x22&gt;
			1e: R_X86_64_PLT32	cnp_near_func_hole_1-0x4
  22:	48 b8 00 00 00 00 00 	movabs rax,0x0
  29:	00 00 00
			24: R_X86_64_64	cnp_far_func_hole_1
  2c:	48 bf 00 00 00 00 00 	movabs rdi,0x0
  33:	00 00 00
			2e: R_X86_64_64	cnp_large_value_hole_1
  36:	ff d0                	call   rax
  38:	49 89 c4             	mov    r12,rax
  3b:	58                   	pop    rax
  3c:	e9 00 00 00 00       	jmp    41 &lt;fused_multiply_add_sqrt_ifnotzero+0x41&gt;
			3d: R_X86_64_PLT32	cnp_stencil_output-0x4</pre>
</div>
</div>
    <!-- TODO: consider https://utteranc.es/ for in-page comments. -->
      <hr/>
      
    </div></div>
  </body>
</html>
