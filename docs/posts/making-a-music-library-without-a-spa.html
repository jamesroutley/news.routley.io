<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://begin.com/blog/posts/2023-09-28-introducing-enhance-music">Original</a>
    <h1>Making a music library without a SPA</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    <section slot="doc"><p>Today, the Enhance team is excited to introduce our latest demo app: <a href="https://enhance-music.com" rel="noopener noreferrer" target="_blank">Enhance Music</a> — a music library and audio player app built with HTML and CSS, and progressively enhanced with a couple pinches of JavaScript. Despite being built as a traditional multipage website, Enhance Music features an audio player that persists across page loads, and some gorgeous interactive UI built entirely with web standards.</p>
<p>As with <a href="https://begin.com/blog/posts/2023-07-26-introducing-enhance-movie" rel="noopener noreferrer" target="_blank">our previous demo app, Enhance Movies</a>, Enhance Music is designed to highlight the sort of developer and user experiences that can be achieved by focusing on building for the web platform itself, with a bit of help from Enhance.</p>
<p>In this article, I’ll give you an in depth look at how Enhance Music works under the hood, with the hopes of giving you a few additions to your web development tool belt. Feel free to <a href="https://github.com/enhance-dev/enhance-music" rel="noopener noreferrer" target="_blank">take a look at the codebase</a> as you follow along!</p>
<h2 id="a-fully-functional-music-library%2C-without-the-struggle-stack">A fully functional music library, without the struggle stack</h2>
<p>Highly interactive interfaces (such as one for a music player) are often cited as reasons for employing a host of JavaScript libraries. We’re often told that the complexity of managing interactivity inherently requires third party frameworks and abstractions of markup, styling, and web platform APIs. I can recall this being at least occasionally true many years ago — it used to be that building even basic interfaces such as <a href="https://en.wikipedia.org/wiki/Accordion_(GUI)" rel="noopener noreferrer" target="_blank">accordions</a> or <a href="https://en.wikipedia.org/wiki/Tab_(interface)" rel="noopener noreferrer" target="_blank">tabbed navigations</a> on the web could prove to be tough without at least calling in the likes of jQuery to tame cross browser quirks. I can also recall the many years I spent building interfaces in React, when I’d immediately jump over to NPM as soon as I needed to build something more trivial than putting static text on a page. (Forms? Better check NPM. Dialogs? There’s a package for that. Animations? Spoiled for choice!)</p>
<p>But is this still the case in 2023? Do we need to transpile proprietary dialects of JavaScript to describe our UI? Do we need fully featured state machines or reducer functions to keep track of permutations of those interfaces and their data? Do we need a Single Page App (SPA) architecture to deliver richly interactive and stateful experiences?</p>
<p>We’ve found that the answer to all these questions is a hard ‘nope.’</p>
<p>Depending on your experience — and given the ubiquity of SPAs today — this answer may be surprising. But multipage sites aren’t the relic many might think they are. When asked to explain his preference for multipage architectures recently, <a href="https://adactio.com/journal/20442" rel="noopener noreferrer" target="_blank">Jeremy Keith wrote on his blog</a>:</p>
<blockquote>
<p>For most use cases, a website (or multi-page app if you prefer) is going to provide the most robust experience for the most number of users. […]</p>
<p>There are some cases where you’d want a state to persist across pages. Let’s say you’re playing a song, or a podcast episode. Ideally you’d want that player to continue seamlessly playing even as the user navigates around the site. In that situation, a single-page app would be a suitable architecture.</p>
<p>But that architecture comes at a cost.</p>
</blockquote>
<p>I agree with Jeremy. I think there may still be some situations in which building an SPA is a suitable choice (though amusingly given Jeremy’s example of an audio player, we’d wrapped up Enhance Music just a day or two before).</p>
<p>However, I also think <a href="https://begin.com/blog/posts/2023-02-21-why-does-everyone-suddenly-hate-single-page-apps" rel="noopener noreferrer" target="_blank">the number of situations in which an SPA architecture can be recommended is dwindling</a>, chiefly due to how good the web platform has become (and how much better it’s getting every day). And because so much of the rest of the ‘struggle stack’ (transpilers, unique dialects, etc.) was built to get around gaps in the web platform that no longer exist, the use cases for these tools is dwindling in tandem.</p>
<p>This is good news: not only can we avoid piling up transient knowledge about a seemingly endless stream of dependencies, we can also eject from the routine stress of those dependencies changing or breaking under our feet and throwing wrenches into our workflows — all while delivering more robust and performant websites to end users.</p>
<p>By delivering a rich (and resilient) interactive experience built solely with web standards and a multipage architecture, Enhance Music demonstrates this premise very well. So, without further ado, let’s start walking through how we built it.</p>
<h2 id="no-component-is-an-island">No component is an island</h2>
<p>The inspiration for Enhance Music came from Maxi Ferreira’s recently updated <a href="https://astro-records.pages.dev/" rel="noopener noreferrer" target="_blank">Astro Records demo app</a>. What’s cool about this application is that it’s actually built on a multipage architecture, with a user experience that feels very much like an SPA. Although you can navigate through multiple pages (a library page, individual album pages), if you start playing a track, that audio player UI will stay with you as you move between those pages.</p>
<p>This is accomplished using <a href="https://docs.astro.build/en/concepts/islands/" rel="noopener noreferrer" target="_blank">Astro Islands</a>, which allows components rendered with client side JavaScript to persist between otherwise static page loads. The result is a traditional multipage website that gets upgraded to a more seamless experience in the browser. In combination with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API" rel="noopener noreferrer" target="_blank">View Transitions API</a>, this produces a very slick result.</p>
<p>There is a catch here, though: because Astro Islands (and other client side routing solutions, such as <a href="https://turbo.hotwired.dev/" rel="noopener noreferrer" target="_blank">Turbo Drive</a>) rely on JavaScript to function, these persistent interfaces can only be rendered <em>if</em> the application’s JavaScript downloads and executes successfully for the user. Unfortunately, that can be a big ‘if’. <a href="https://www.kryogenix.org/code/browser/everyonehasjs.html" rel="noopener noreferrer" target="_blank">Not everyone has JavaScript</a> — at least <a href="https://scribe.rip/@jason.godesky/when-javascript-fails-52eef47e90db" rel="noopener noreferrer" target="_blank">not all the time</a>.</p>
<p>This got us thinking: could we create a better experience for those users for whom JavaScript is unavailable? How could we use a multipage architecture while allowing some piece of our UI to persist between page loads without relying on JavaScript?</p>
<p>Sometimes the old ways are the best ways, and in this case, we found our answer in an older HTML element: the Inline Frame element, better known as <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" rel="noopener noreferrer" target="_blank">the iframe</a>.</p>
<p><img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/oldercode-bf3bbdcbf5.gif" alt="Clip from Star Wars: Return of the Jedi — ‘It’s an older code, sir, but it checks out.’"/></p>
<p>Web developers typically associate iframes with third party integrations — think of embedding a YouTube video, Google Maps content, etc. But iframes can also be used to embed your own content within a parent page. Additionally, using the <code>target</code> attribute, links can target specific iframes within the parent document by name. Thus, if you were to embed two iframes within a document — say, one iframe for a music library, and another for an audio player — you could create a navigable music library in one iframe and a persistent audio player in another.</p>
<p>And that’s exactly what we did.</p>
<h2 id="structuring-the-foundations">Structuring the foundations</h2>
<p><blog-image alt="The Enhance Music app shown in both a mobile phone display and a desktop web browser" src="/_public/blog/post-assets/cole-enhance-music/layout-acf9ce3c5a.webp">
    <enhance-image src="/_public/blog/post-assets/cole-enhance-music/layout-acf9ce3c5a.webp" alt="The Enhance Music app shown in both a mobile phone display and a desktop web browser" loading="eager" variant1="(min-width: 64em) 2000" variant2="(min-width: 48em) 1280" defaultwidth="1080">
    <picture>
      <source media="(min-width: 64em)" srcset="/transform/width_2000/_public/blog/post-assets/cole-enhance-music/layout-acf9ce3c5a.webp"/><source media="(min-width: 48em)" srcset="/transform/width_1280/_public/blog/post-assets/cole-enhance-music/layout-acf9ce3c5a.webp"/>
      <source srcset="/transform/width_1080/_public/blog/post-assets/cole-enhance-music/layout-acf9ce3c5a.webp"/>
      <img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/layout-acf9ce3c5a.webp" alt="The Enhance Music app shown in both a mobile phone display and a desktop web browser" loading="eager"/>
    </picture>
  </enhance-image>
  </blog-image></p>
<p>Looking at our website’s <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/pages/index.mjs#L9-L21" rel="noopener noreferrer" target="_blank">index page</a>, you can see the content is straightforward: one title bar custom element, and our two iframes. When a user first accesses this page, the first iframe will contain our music library page, while the second (reserved for the audio player) will simply be blank, since no track has been selected yet. Wrapping this content is <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/layout-grid.mjs" rel="noopener noreferrer" target="_blank">our layout grid custom element</a>, which creates a grid layout for the three aforementioned elements. You can see that the first row of the grid will be sized automatically based on the content (that’s where our title bar custom element goes), while the second row (for our library iframe) will take up whatever remaining vertical space is available in the viewport. The last row, which will hold our audio player iframe, is sized using the <code>grid-auto-rows</code> property, as we’ll be doing some progressive enhancement later on to display that iframe dynamically.</p>
<p>Our library page is pretty straightforward — it renders an instance of our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/music-library.mjs" rel="noopener noreferrer" target="_blank"><code>music-library</code> component</a>, which contains <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-grid.mjs" rel="noopener noreferrer" target="_blank">a layout element for our grid of albums</a> and an instance of our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-item.mjs" rel="noopener noreferrer" target="_blank"><code>album-item</code> element</a> for each album in the library. Finally, each instance of this component links to a dedicated page for its album, which is rendered primarily with the <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs" rel="noopener noreferrer" target="_blank"><code>album-data</code> element</a>.</p>
<p>The <code>album-data</code> element involves a bit more orchestration of styling, logic, content, and interactivity, so let’s step through it briefly.</p>
<p><a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L72-L102" rel="noopener noreferrer" target="_blank">The markup for this element</a> is where we structure the content pertaining to each album. We start by reusing our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-cover.mjs" rel="noopener noreferrer" target="_blank"><code>album-cover</code> element</a> to show the album’s cover, and then we render a <code>header</code> element to contain all the top level information about the album, like its title, artist, record label, the year it was published, a link to a Bandcamp page (if one exists), and finally, a button to start playing the album. Finally, we render the album’s tracklisting using an ordered list, where each track gets its track number, title, and length dumped into a link.</p>
<p><a href="https://github.com/enhance-dev/enhance-music/blob/5e50e7db0c9b1cc2268a539dacbcda9928fd014a/app/elements/album-data.mjs#L90" rel="noopener noreferrer" target="_blank">The way this track link is set up</a> is important. Note that this link points to a <a href="https://enhance.dev/docs/learn/concepts/routing/dynamic-routes" rel="noopener noreferrer" target="_blank">dynamic route</a> for the track itself, and that the link’s <code>target</code> attribute is set to <code>player</code>. That <code>target</code> attribute allows us to tell the browser to render that track’s page in our audio player iframe, since <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/pages/index.mjs#L16-L18" rel="noopener noreferrer" target="_blank">we named that iframe <code>player</code> in our index page</a>.</p>
<p>Thus, when a user selects a track for playback, that track will be rendered in the audio player’s iframe, leaving the user free to continue to navigate within the library’s iframe without affecting the audio player’s state. This gives us an audio player that follows us around the library — with zero JavaScript required.</p>
<p><blog-image alt="Diagram showing navigation between two library pages in an iframe, and an independent, persistent audio player in a second iframe, which is updated via links from the library iframe" src="/_public/blog/post-assets/cole-enhance-music/iframes-a3a89bbe89.webp">
    <enhance-image src="/_public/blog/post-assets/cole-enhance-music/iframes-a3a89bbe89.webp" alt="Diagram showing navigation between two library pages in an iframe, and an independent, persistent audio player in a second iframe, which is updated via links from the library iframe" loading="eager" variant1="(min-width: 64em) 2000" variant2="(min-width: 48em) 1280" defaultwidth="1080">
    <picture>
      <source media="(min-width: 64em)" srcset="/transform/width_2000/_public/blog/post-assets/cole-enhance-music/iframes-a3a89bbe89.webp"/><source media="(min-width: 48em)" srcset="/transform/width_1280/_public/blog/post-assets/cole-enhance-music/iframes-a3a89bbe89.webp"/>
      <source srcset="/transform/width_1080/_public/blog/post-assets/cole-enhance-music/iframes-a3a89bbe89.webp"/>
      <img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/iframes-a3a89bbe89.webp" alt="Diagram showing navigation between two library pages in an iframe, and an independent, persistent audio player in a second iframe, which is updated via links from the library iframe" loading="eager"/>
    </picture>
  </enhance-image>
  </blog-image></p>
<p>However, this doesn’t mean we can’t use JavaScript to upgrade the user experience when it’s available. This brings us to our first use case for <a href="https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement" rel="noopener noreferrer" target="_blank">progressive enhancement</a>.</p>
<h2 id="enhancing-the-tracklisting">Enhancing the tracklisting</h2>
<p>Any decent music library will provide some visual indication of which track in a tracklist is currently playing, and with just a little JavaScript, we can make that happen.</p>
<p><blog-image alt="Two tracks in a tracklist, with the second track indicated as active via a play icon to the left of the track title" src="/_public/blog/post-assets/cole-enhance-music/tracklist-6a5586493e.webp">
    <enhance-image src="/_public/blog/post-assets/cole-enhance-music/tracklist-6a5586493e.webp" alt="Two tracks in a tracklist, with the second track indicated as active via a play icon to the left of the track title" loading="eager" variant1="(min-width: 64em) 2000" variant2="(min-width: 48em) 1280" defaultwidth="1080">
    <picture>
      <source media="(min-width: 64em)" srcset="/transform/width_2000/_public/blog/post-assets/cole-enhance-music/tracklist-6a5586493e.webp"/><source media="(min-width: 48em)" srcset="/transform/width_1280/_public/blog/post-assets/cole-enhance-music/tracklist-6a5586493e.webp"/>
      <source srcset="/transform/width_1080/_public/blog/post-assets/cole-enhance-music/tracklist-6a5586493e.webp"/>
      <img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/tracklist-6a5586493e.webp" alt="Two tracks in a tracklist, with the second track indicated as active via a play icon to the left of the track title" loading="eager"/>
    </picture>
  </enhance-image>
  </blog-image></p>
<p>To indicate which track is currently playing to both sighted users and those using a screenreader, we rely on <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current" rel="noopener noreferrer" target="_blank">the <code>aria-current</code> attribute</a>. This attribute is perfect for our use case, as it’s meant to indicate which item within a list of items is currently active.</p>
<p>To begin, note that within each link in our tracklist, <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L91-L92" rel="noopener noreferrer" target="_blank">we render both a track index and a playback icon in span elements</a>. If you refer to our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L26-L33" rel="noopener noreferrer" target="_blank">styles for the <code>index</code> and <code>playing</code> classes</a>, you’ll note that the playback icon will only be rendered within a parent that matches the <code>[aria-current=&#39;true&#39;]</code> selector — in which case, the track index (via the <code>index</code> class) will <em>not</em> be rendered. This means that all we need to do with JavaScript is to add the <code>aria-current=&#39;true&#39;</code> attribute to the track that’s been selected by the user.</p>
<p>We accomplish this by registering <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L124-L131" rel="noopener noreferrer" target="_blank">an event handler</a> on each track’s <code>click</code> event, getting the track number from <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L89" rel="noopener noreferrer" target="_blank">the track’s data attributes</a>, and running <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L112-L114" rel="noopener noreferrer" target="_blank">the <code>setCurrent</code> function</a> with that track number to apply the <code>aria-current</code> attribute to the correct track element. We also run this function <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-data.mjs#L116-L117" rel="noopener noreferrer" target="_blank">on the initial page render</a>, in case a track in the album we’re viewing is already playing when the album’s page is loaded.</p>
<p>With this code in place, users with JavaScript available will now see a playback icon appear in place of a track’s index when that track is played. Users without JavaScript will miss out on this, but given that this is a non essential feature, that’s alright — that’s why it’s called ‘progressive enhancement’ and not ‘progressive bare minimum’.</p>
<p>That covers navigating between our library and its albums and choosing a track to play — but how do we manage actually playing those tracks? Let’s dive into our audio player implementation.</p>
<h2 id="audio-players-for-(almost)-everyone">Audio players for (almost) everyone</h2>
<p><blog-image alt="Image showing system audio players in Chrome, Firefox, and Safari. Safari’s audio player appears to be broken." src="/_public/blog/post-assets/cole-enhance-music/system-audio-d9ac6b1c02.webp">
    <enhance-image src="/_public/blog/post-assets/cole-enhance-music/system-audio-d9ac6b1c02.webp" alt="Image showing system audio players in Chrome, Firefox, and Safari. Safari’s audio player appears to be broken." loading="eager" variant1="(min-width: 64em) 2000" variant2="(min-width: 48em) 1280" defaultwidth="1080">
    <picture>
      <source media="(min-width: 64em)" srcset="/transform/width_2000/_public/blog/post-assets/cole-enhance-music/system-audio-d9ac6b1c02.webp"/><source media="(min-width: 48em)" srcset="/transform/width_1280/_public/blog/post-assets/cole-enhance-music/system-audio-d9ac6b1c02.webp"/>
      <source srcset="/transform/width_1080/_public/blog/post-assets/cole-enhance-music/system-audio-d9ac6b1c02.webp"/>
      <img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/system-audio-d9ac6b1c02.webp" alt="Image showing system audio players in Chrome, Firefox, and Safari. Safari’s audio player appears to be broken." loading="eager"/>
    </picture>
  </enhance-image>
  </blog-image></p>
<p>As mentioned, each track in our album tracklist renders a link within a list item. That link, in turn, gets targeted to our audio player iframe when clicked. The route that we point to with each audio link gets handled by <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/api/player/%24id.mjs" rel="noopener noreferrer" target="_blank">a dynamic API route (<code>/player/$id.mjs</code>)</a>, which is responsible for returning the relevant track data based on the dynamic portion of our route. This data then gets passed to <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs" rel="noopener noreferrer" target="_blank">the audio player element</a> via the <code>state</code> attribute (which you can <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L4-L5" rel="noopener noreferrer" target="_blank">see in action here</a>). Finally, our audio player element can use that data to render our audio player.</p>
<p>As with the rest of our app, we want to provide users with a fully functional experience when JavaScript is unavailable — and for that reason, we default to serving our users the selected track via <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio" rel="noopener noreferrer" target="_blank">the <code>audio</code> element</a>. This will allow every user who downloads our HTML to play the audio back using a system audio player with full playback controls. The interface may look a little different between different browsers and operating systems, and it may not exactly match the look of the rest of our app, but that’s okay — it does a great job of playing back the audio the user requested! (Except in Safari — see that footnote if you’re morbidly curious.)</p>
<p>With our ‘zero JavaScript’ happy paths now covered, we can have a little more fun when JavaScript is available in the browser.</p>
<h2 id="enhancing-the-audio-player">Enhancing the audio player</h2>
<p><blog-image alt="Custom audio player interface" src="/_public/blog/post-assets/cole-enhance-music/custom-audio-d9922af410.webp">
    <enhance-image src="/_public/blog/post-assets/cole-enhance-music/custom-audio-d9922af410.webp" alt="Custom audio player interface" loading="eager" variant1="(min-width: 64em) 2000" variant2="(min-width: 48em) 1280" defaultwidth="1080">
    <picture>
      <source media="(min-width: 64em)" srcset="/transform/width_2000/_public/blog/post-assets/cole-enhance-music/custom-audio-d9922af410.webp"/><source media="(min-width: 48em)" srcset="/transform/width_1280/_public/blog/post-assets/cole-enhance-music/custom-audio-d9922af410.webp"/>
      <source srcset="/transform/width_1080/_public/blog/post-assets/cole-enhance-music/custom-audio-d9922af410.webp"/>
      <img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/custom-audio-d9922af410.webp" alt="Custom audio player interface" loading="eager"/>
    </picture>
  </enhance-image>
  </blog-image></p>
<p>Building a custom audio player isn’t the easiest task, but it can produce great results, as we’ll find out shortly. The key is to use semantically appropriate elements wherever possible  (and ARIA attributes when necessary), and getting to know <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement" rel="noopener noreferrer" target="_blank">the <code>HTMLMediaElement</code> interface</a> as intimately as possible.</p>
<p>Let’s start with <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L69-L110" rel="noopener noreferrer" target="_blank">the markup for our custom audio player</a>. The entire component is wrapped in <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure" rel="noopener noreferrer" target="_blank">a <code>figure</code> element</a> to indicate that the content inside it is self contained. Next, we add <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L88-L97" rel="noopener noreferrer" target="_blank">a button to toggle the playback</a> of our audio track (note the ARIA attributes used to semantically relate this button to our audio element). Finally, we render <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L98-L109" rel="noopener noreferrer" target="_blank">some markup for the track’s metadata and album art</a>, and — especially important — <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L105" rel="noopener noreferrer" target="_blank">a range input</a> to indicate and modify the track’s playback position. Since this input controls audio playback, we use an appropriate ARIA attribute here, too.</p>
<p>Now that we’ve got our required markup, it’s time to dive into interactivity with Web Components and the HTMLMediaElement interface. <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L115-L250" rel="noopener noreferrer" target="_blank">The script tag which contains this functionality</a> is a little gnarly, but we’ll walk through the most important points (and for the moment, we’ll bypass the portions of this script concerned with our waveform UI).</p>
<p>First, take note of <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L146-L152" rel="noopener noreferrer" target="_blank">AudioPlayer class’s instance properties</a>; we’ll be using these to refer to and modify certain aspects of our audio player. Next, note that we’re <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L156-L162" rel="noopener noreferrer" target="_blank">creating a new instance of our audio element programmatically</a>. We do this instead of declaring an audio element with HTML because we need to attach event listeners to this element, and by the time this JavaScript executes on the client, some of those events may already have been fired by the browser before we can attach those listeners. (Yes, you read that right: we actually need to account for the fact that JavaScript is slower than HTML to get this right.)</p>
<p>Next, we add <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L164-L172" rel="noopener noreferrer" target="_blank">an absolute ton of event listeners</a> to our playback button, audio element, and our timeline (AKA our range input). This will allow us to use these events to trigger the expected behavior from our audio player. We’ll get to the specifics of these momentarily.</p>
<p>At last, we get to <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L174-L177" rel="noopener noreferrer" target="_blank">render some content</a>! Once all our setup is complete, we use a few DOM methods to hide the system audio player, insert our programmatically created audio element, and reveal our custom audio markup, which was previously hidden from view. In combination with <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L16-L62" rel="noopener noreferrer" target="_blank">our custom element styles</a> (which are handily <a href="https://enhance.dev/docs/learn/concepts/styling/enhance-styles/element-styles" rel="noopener noreferrer" target="_blank">scoped to our custom element by Enhance</a>), we now have a custom audio player ready to be interacted with.</p>
<p>Let’s go over each of these interactions in a little more detail.</p>
<h3 id="playing-and-pausing">Playing and pausing</h3>
<p>This one’s pretty straightforward. Our playback button fires <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L201-L203" rel="noopener noreferrer" target="_blank">the <code>onPlayPause</code> function</a> when clicked. This function plays or pauses the audio track, depending on whether it’s currently paused or not.</p>
<p>Then, because we registered <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L167-L168" rel="noopener noreferrer" target="_blank">event listeners for the <code>play</code> and <code>pause</code> events</a> on the audio element itself, our playback button’s <code>aria-pressed</code> attribute will be updated accordingly by the <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L205-L211" rel="noopener noreferrer" target="_blank"><code>onPlay</code> and <code>onPause</code> functions</a>. These attributes inform the user of the button’s current state, and cause <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L45-L51" rel="noopener noreferrer" target="_blank">the proper icon within the button to be displayed</a>.</p>
<h3 id="updating-the-current-time-display">Updating the current time display</h3>
<p>Every time the audio track’s <code>currentTime</code> property updates (usually a few times per second, depending on the client), our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L213-L221" rel="noopener noreferrer" target="_blank"><code>onTimeUpdate</code> function</a> is fired. This function is responsible for updating both the value of our timeline element (the range input) and the inner text of our custom audio player’s current time stamp.</p>
<p><blog-image alt="Custom audio player interface, shown in standby mode and while a track is playing" src="/_public/blog/post-assets/cole-enhance-music/play-pause-a7045df9f7.webp">
    <enhance-image src="/_public/blog/post-assets/cole-enhance-music/play-pause-a7045df9f7.webp" alt="Custom audio player interface, shown in standby mode and while a track is playing" loading="eager" variant1="(min-width: 64em) 2000" variant2="(min-width: 48em) 1280" defaultwidth="1080">
    <picture>
      <source media="(min-width: 64em)" srcset="/transform/width_2000/_public/blog/post-assets/cole-enhance-music/play-pause-a7045df9f7.webp"/><source media="(min-width: 48em)" srcset="/transform/width_1280/_public/blog/post-assets/cole-enhance-music/play-pause-a7045df9f7.webp"/>
      <source srcset="/transform/width_1080/_public/blog/post-assets/cole-enhance-music/play-pause-a7045df9f7.webp"/>
      <img src="https://begin.com/_public/blog/post-assets/cole-enhance-music/play-pause-a7045df9f7.webp" alt="Custom audio player interface, shown in standby mode and while a track is playing" loading="eager"/>
    </picture>
  </enhance-image>
  </blog-image></p>
<h3 id="adjusting-the-playback-position">Adjusting the playback position</h3>
<p>Here’s where things get a little more nuanced.</p>
<p>Along with indicating the audio track’s current playback position, we also want our timeline element to be interactive, allowing users to seek to a specific playback position within the audio track. This is why we used the HTML range input element for our timeline: it’s both illustrative (as we saw in the previous section) and modifiable.</p>
<p>When users interact with HTML range inputs, developers can be notified of changes to its value at two different stages: first, <a href="(https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)"><code>input.oninput</code></a>, which occurs <em>while</em> the input is being modified (i.e., the user is actively dragging or otherwise manipulating the input); and second, <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event" rel="noopener noreferrer" target="_blank"><code>input.onchange</code></a>, which occurs when the user finally commits a particular value (i.e., when the user disengages the range input). This is important to know, as we need to handle each event differently.</p>
<p>To begin, let’s examine our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L223-L233" rel="noopener noreferrer" target="_blank"><code>onTimelineInput</code> function</a>, which fires every time the input is manipulated. Because we’re keeping our timeline’s value in sync with the audio track’s <code>currentTime</code> property, we first need to remove the event listener responsible for doing so — otherwise, the user’s interaction would be cut short by the audio track continuing to update the input’s value in the background. By <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L225-L227" rel="noopener noreferrer" target="_blank">removing that event listener</a>, we can give the user full control of the input’s value (and position).</p>
<p>Next, as the user continues to update the timeline’s value, we use that value (provided by the <code>event.target.value</code> property) to <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L229-L232" rel="noopener noreferrer" target="_blank">set the UI’s current time stamp</a>, in order to indicate this position in time to the user.</p>
<p>Eventually, the user will commit a value to the range input — this is where our <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L235-L243" rel="noopener noreferrer" target="_blank"><code>onTimelineChange</code> function</a> takes over. In this function, we first <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L237-L239" rel="noopener noreferrer" target="_blank">assign the chosen value</a> to both our timeline input and the audio track’s <code>currentTime</code> property. Then, in order for the timeline to resume staying in sync with the audio track’s playback position, we <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L241-L242" rel="noopener noreferrer" target="_blank">reregister our event listener and callback</a>.</p>
<p>Whew! It’s a bit of a whirlwind, but with this code in place, we now have a fully interactive custom audio player!</p>

<p>At this point in developing Enhance Music, we were pretty happy with our results. We had a navigable music library with a persistent audio player, and a bunch of great progressive enhancements to make things look and feel smooth via JavaScript (when available).</p>
<p>But then we got a little greedy and decided to add another bell and whistle or two.</p>
<h2 id="final-enhancements">Final enhancements</h2>
<p>As I mentioned earlier, there are a lot of presumptions out there about what can and cannot be accomplished in terms of UI without resorting to pulling in JavaScript libraries like React. This especially extends to creating rich, dynamic visual effects and data visualizations. We wanted to take this opportunity to demonstrate that web standards are fully up to this task — and that using them to do so can actually be pretty straightforward!</p>
<p>A common visualization we see on a lot of audio player interfaces is a representation of the current audio track’s <a href="https://www.google.com/search?sca_esv=568226998&amp;q=waveform&amp;tbm=isch&amp;source=lnms&amp;sa=X&amp;ved=2ahUKEwja4r2_lsaBAxXfjokEHRbEDDwQ0pQJegQIDRAB&amp;biw=1783&amp;bih=1136&amp;dpr=2" rel="noopener noreferrer" target="_blank">waveform</a>. We thought it would be awesome to do something like this with Enhance Music to provide a little more information about the current track’s content and dynamics, as well as to satisfy our cravings for a little razzle dazzle.</p>
<p>I mentioned avoiding the propensity to resort to NPM as a first response earlier, but that doesn’t mean we should ignore the value of NPM entirely. At this point, not wanting to invest the time required to learn how to derive a waveform graphic from an audio file from scratch, we finally headed over to NPM to see what sort of libraries might be available to help us out with this. That’s where we found <a href="https://wavesurfer-js.org/" rel="noopener noreferrer" target="_blank">Wavesurfer.js</a>, an open source JavaScript library for generating and customizing waveforms, with support for HTML5 Audio and Web Audio. With an easy to follow interface and a mere 43kb addition to our site’s payload, this was a perfect solution for our needs.</p>

<p>Waveform.js uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener noreferrer" target="_blank">the Canvas API</a> to generate its graphics, so after a bit of poking around through various docs on MDN to learn about canvas gradients, I was able to come up with <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L119-L137" rel="noopener noreferrer" target="_blank">a couple of custom gradients</a> to use as the fill for our custom waveform. Applying that gradient to our Wavesurfer instance and adding <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L181-L191" rel="noopener noreferrer" target="_blank">further customizations</a> was a piece of cake. So, too, was <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/audio-player.mjs#L220" rel="noopener noreferrer" target="_blank">syncing the Wavesurfer instance up with our audio track’s progress</a>, which provided us with even more flair for our custom audio player. With this in place (and using a little CSS filtering on our audio player), we arrived at a gorgeous visualization of our audio track, layered beneath our custom audio player.</p>
<p>We decided to add one more piece of progressive enhancement to Enhance Music at this point: hiding the audio player iframe when a track hasn’t been loaded. The empty audio player iframe taking up room on our layout when there was no content to show wasn’t ideal, but it took <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/browser/player-visibility.mjs" rel="noopener noreferrer" target="_blank">just a sprinkling of JavaScript</a> to hide the iframe once our script loads, and to then listen for <code>load</code> events on it to show the iframe once an audio track has been selected. No sweat!</p>
<p>Our final investigation for Enhance Music’s UI focused on <a href="https://daverupert.com/2023/05/getting-started-view-transitions/" rel="noopener noreferrer" target="_blank">view transitions</a>. This worked well when testing our library view in isolation (and you can <a href="https://enhance-music.com/library" rel="noopener noreferrer" target="_blank">see it in action here, using Chrome Canary</a>), but upon verifying this in the app itself, we realized that view transitions are not yet supported in iframes. Given that this spec is still so early in its rollout, that’s pretty understandable; we even got <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1481881" rel="noopener noreferrer" target="_blank">a bug filed in Chromium</a> to track this. Once the spec rolls out though, <a href="https://github.com/enhance-dev/enhance-music/blob/main/app/elements/album-cover.mjs#L25" rel="noopener noreferrer" target="_blank">this simple addition to our album cover element</a> should have view transitions working smoothly, which should help to make navigation through the library even more seamless.</p>

<h2 id="a-fully-functional-music-library%2C-backed-by-great-performance">A fully functional music library, backed by great performance</h2>
<p>Not only is Enhance Music a great example of a fully functional interactive app built entirely with web standards, it also performs exceptionally well: as in, ‘<a href="https://pagespeed.web.dev/analysis/https-enhance-music-com/ji19jdzrkn?form_factor=mobile" rel="noopener noreferrer" target="_blank">all 100s on PageSpeed Insights</a>’.</p>
<p>But honestly, getting the performance to this point mostly just happened on its own. We formatted our album covers as <code>.webp</code> images and sized them appropriately, and we kept bundle sizes in mind when looking for waveform libraries on NPM, but otherwise, the strategy here could be summed up as: ‘Use the platform.’</p>
<p>By relying on HTML, CSS, and the smallest amount of JavaScript necessary, achieving great performance becomes almost a matter of course. This isn’t to say that no thinking had to be done at all — after all, Enhance is built from the ground up with performance in mind, and we did spend a bit of time researching appropriate ARIA attributes for our custom audio player — but rather that by working with the grain of the platform instead of ejecting into JS frameworks, transpilers, and other overheads, one learns to build performantly (and accessibly) from the start, rather than trying to make performance and accessibility happen in the ‘polishing’ stage (which seldom works anyway). This is as true for authoring simple static sites as it is for rich interactive web apps — and I think Enhance Music demonstrates this quite well!</p>
<h2 id="summing-up%3A-on-the-longevity-of-web-standards">Summing up: on the longevity of web standards</h2>
<p>Working on Enhance Music over these past weeks reminded me of the last time I worked on a web project involving an audio player. I was building a module for a pretty intense React application — a series of learning activities for English students, which required a custom audio player to play back pieces of dialogue or other spoken materials. While both that audio player and the audio player for Enhance Music were built on top of the HTMLMediaElement interface, the former was necessarily interlaced with React specific implementation details — details that involved time, problem solving, and results that I will never be able to transfer to another project or component. Even if I were to build that audio player in React again today, I’m confident that at least some of the React specific details would have to change to be compliant with the current version of React. The audio player for Enhance Music, meanwhile — being built solely with web standards — has given me knowledge and tools that I will be able to bring with me as long as the web platform itself exists. That’s pretty powerful.</p>
<p>This isn’t meant to disparage React, or any other JavaScript view framework. For me, this instead highlights the incredible benefits of learning and building with web standards: your code — and more importantly, the knowledge you acquire while writing it — remains portable forever. HTML, CSS, and JavaScript are fully backwards and forwards compatible, and modern web browsers are too. The knowledge I’ve picked up building Enhance Music will remain useful and applicable for as long as I’m writing code for the web, which will allow me to focus on critical problem solving in the future, rather than relearning problem solving strategies I’ve already internalized. In today’s fast paced web ecosystem, that’s a huge advantage — and, frankly, a relief.</p>
<p>Not only does this knowledge remain useful, but the results speak for themselves: Enhance Music delivers exceptional performance, a beautiful multimodal interface, and is even ready for future web features like view transitions in iframes (presuming the spec doesn’t change — which, to be fair, it could… but that’s okay).</p>
<p>I hope this deep dive through Enhance Music has been as enjoyable to read as it was to create the project itself, and I hope it’s given you some ideas for your next project! Please feel free to <a href="https://github.com/enhance-dev/enhance-music/" rel="noopener noreferrer" target="_blank">explore the source code</a> and borrow whatever pieces of it might be useful to you.</p>
<p>And if you’re excited about what can be done with Enhance, be sure to <a href="https://enhance.dev" rel="noopener noreferrer" target="_blank">check out the Enhance website and docs</a>, or <a href="https://enhance.dev/discord" rel="noopener noreferrer" target="_blank">join us on Discord</a> to ask questions or share your ideas.</p>
<p>See you next time!</p>


</section>

    
  </div></div>
  </body>
</html>
