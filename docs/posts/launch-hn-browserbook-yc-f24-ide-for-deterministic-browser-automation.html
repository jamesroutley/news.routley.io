<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=46232434">Original</a>
    <h1>Launch HN: BrowserBook (YC F24) – IDE for deterministic browser automation</h1>
    
    <div id="readability-page-1" class="page"><div><td colspan="2"></td><td><div><p>Hey HN!  We’re Chris, Jorrie, and Evan of BrowserBook, an IDE for writing and debugging Playwright-based web automations. You can download it as a Mac app here: <a href="https://browserbook.com">https://browserbook.com</a>, and there’s a demo video at <a href="https://www.youtube.com/watch?v=ODGJBCNqGUI" rel="nofollow">https://www.youtube.com/watch?v=ODGJBCNqGUI</a>.</p><p>Why we built this: When we were going through YC, we were a company that automated back-office healthcare workflows.  Since the interoperability ecosystem in healthcare is so fragmented, we started using browser agents to automate EMRs, practice management software, and payment portals directly through the web. When we did, we ran into a ton of problems:</p><p>Speed: High latency on LLM calls vs. a scripting approach</p><p>Cost: We burned through tokens with all the context we needed to make the automations reasonably accurate</p><p>Reliability: Even with detailed instructions, context, and tools, agents tended to drift on multi-step tasks in unpredictable ways</p><p>Debuggability: When drift did occur, we were essentially playing whack-a-mole in our prompt and re-running the whole automation to debug issues (see above: speed and cost issues made this quite painful)</p><p>More and more we were just giving our agent scripts to execute. Eventually, we came to the conclusion that scripting is a better approach for web automation for these sort of use cases. But scripting was also too painful, so we set out to solve those problems with BrowserBook.</p><p>Under the hood, it runs a standalone TypeScript REPL wired directly into an inline browser instance, with built-in tooling to make script development quick and easy.  This includes:</p><p>- A fully interactive browser window directly in the IDE so you can run your code without context switching</p><p>- A Jupyter-notebook-style environment - the idea here is you can write portions of your automation in individual cells and run them individually (and quickly reset manually in the browser), instead of having to rerun the whole thing every time</p><p>- An AI coding assistant which uses the DOM context of the current page to write automation logic, which helps avoid digging around for selectors</p><p>- Helper functions for taking screenshots, data extraction, and managed authentication for auth-required workflows.</p><p>Once you’ve created your automation, you can run it directly in the application or in our hosted environment via API, so you can use it in external apps or agentic workflows.</p><p>At its core, BrowserBook is an Electron app, so we can run a Chrome instance directly in the app without the need for cloud-hosted browsers. For API runs, we use hosted browser infra via Kernel (which is a fantastic product, btw), relying on their bot anti-detection capabilities (stealth mode, proxies, etc.).</p><p>Scripted automation can be unpopular because scripts are inherently brittle; unlike “traditional” software development, your code is deployed in an environment you don’t control - someone else’s website. With BrowserBook, we’re trying to “embrace the suck”, and acknowledge this “offensive programming” environment.</p><p>We’ve designed from the ground up to assume scripts will break, and aim to provide the tools that make building and maintaining them easier. In the future, our plan is to leverage AI where it has shown its strength already - writing code - to minimize downtime and quickly repair broken scripts as the deployed environment changes.</p><p>Browser agents promised to solve this by handing the reins to an LLM which can handle inconsistency and ambiguity. While we think there are some applications where browser agents can be genuinely helpful, tasks that need to be done reliably and repeatedly are not one of them.</p><p>We’d love for you to try it out!  You can download BrowserBook from our website here: <a href="https://browserbook.com">https://browserbook.com</a> (only available for Mac so far, sorry!) And of course, we’d appreciate any feedback and comments you have!</p></div></td></div></div>
  </body>
</html>
