<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scala-js.org/doc/sjs-for-js/es6-to-scala-part1.html">Original</a>
    <h1>From ES6 to Scala: Basics</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>This is a short introduction to the Scala language for those familiar with JavaScript ES6. We are comparing
to ES6 instead of earlier versions of JavaScript because ES6 contains many nice features and syntax changes that bring
it closer to Scala.</p>

<p>The best way to experiment with Scala is to use a Scala <a href="https://lihaoyi.github.io/Ammonite/">REPL</a>, or the worksheet
functionality in the <a href="https://github.com/scala-ide/scala-worksheet/wiki/Getting-Started">Scala
IDE</a> or <a href="https://confluence.jetbrains.com/display/IntelliJIDEA/Working+with+Scala+Worksheet">IntelliJ
IDEA</a>.</p>

<p>For more reading check out <a href="http://scala-exercises.47deg.com/index.html">Scala Exercises</a>, <a href="https://twitter.github.io/scala_school/">Scala
School</a> and official <a href="https://docs.scala-lang.org/tutorials/">Scala Tutorials</a>.</p>

<h2 id="the-scala-language">The Scala language</h2>

<p>Scala is a modern multi-paradigm programming language designed to express common programming patterns in a concise,
elegant, and type-safe way. It smoothly integrates features of <em>object-oriented</em> and <em>functional languages</em>. Scala is a
pure object-oriented language in the sense that every value is an object. It is also a functional language in the sense
that every function is a value and that immutability is favored over mutability.</p>

<p>This combination of paradigms is not alien to JavaScript developers.
JavaScript is also object-oriented, although primitive values are not considered as objects.
It is at least partially functional as well, since functions are values and can be passed
around to other functions (such as <code>Array.prototype.map</code>).
However, although it is possible to write with an immutable mindset in JavaScript,
the language does not <em>encourage</em> immutability.</p>

<p>The biggest difference to JavaScript is that Scala is <em>statically typed</em>. This means that it is equipped with an
expressive type system that enforces statically that abstractions are used in a safe and coherent manner, meaning the
compiler will catch many typical programming errors. If you have used other statically typed languages like Java or C#
before you may have noticed that type definitions are all over the place. This is not true with Scala where the compiler
can <em>infer</em> most of the types automatically.</p>

<h2 id="variables">Variables</h2>

<p>Let’s start with something simple, variables. Both Scala and ES6 support mutable and immutable variables.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>// mutable variable</span>
<span>let</span> <span>x</span> <span>=</span> <span>5</span><span>;</span>
<span>// immutable variable</span>
<span>const</span> <span>y</span> <span>=</span> <span>&#34;Constant&#34;</span><span>;</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>// mutable variable
</span><span>var</span> <span>x</span> <span>=</span> <span>5</span>
<span>// immutable variable
</span><span>val</span> <span>y</span> <span>=</span> <span>&#34;Constant&#34;</span></code></pre></figure>
</div>
</div>

<p>Note that the Scala compiler automatically infers the types for <code>x</code> and <code>y</code> from the values that are assigned. In Scala
both mutable and immutable variables must always be initialized when declared.</p>

<h2 id="primitive-types">Primitive types</h2>

<p>Scala defines several primitive types, of which most have corresponding types in JavaScript as well. 
The following table presents the most commonly used ones (there are also <code>Byte</code>, <code>Short</code> and <code>Float</code>).</p>

<table>
  <thead>
    <tr><th>Scala type</th><th>JavaScript type</th><th>Notes</th></tr>
  </thead>
  <tbody>
    <tr><td>String</td><td>string</td><td></td></tr>
    <tr><td>Boolean</td><td>boolean</td><td></td></tr>
    <tr><td>Int</td><td>number</td><td>integer, range (-2147483648, 2147483647)</td></tr>
    <tr><td>Double</td><td>number</td><td>64-bit floating point, fully equivalent to JS number</td></tr>
    <tr><td>Long</td><td><i>N/A</i></td><td>64-bit integer</td></tr>
    <tr><td>Char</td><td><i>N/A</i></td><td>UTF-16 code unit</td></tr>
    <tr><td>Unit</td><td>undefined</td><td></td></tr>
    <tr><td>Null</td><td>null</td><td></td></tr>
  </tbody>
</table>

<p>In JavaScript all numbers are represented as 64-bit floating point internally, which may give surprising results when
making some calculations. In Scala calculations are always performed using the types of operands, so dividing an <code>Int</code>
with another <code>Int</code>, the result is rounded to an <code>Int</code>.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>x</span> <span>=</span> <span>5</span> <span>/</span> <span>3</span><span>;</span> <span>// == 1.6666666666666667</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>val</span> <span>x</span> <span>=</span> <span>5</span> <span>/</span> <span>3</span> <span>// == 1
</span><span>val</span> <span>y</span> <span>=</span> <span>5.0</span> <span>/</span> <span>3</span> <span>// == 1.6666666666666667
</span><span>val</span> <span>z</span> <span>=</span> <span>5</span> <span>/</span> <span>3.0</span> <span>//</span> <span>==</span> <span>1.6666666666666667</span></code></pre></figure>
</div>
</div>

<p>Because in JavaScript every number is a <code>number</code> there is no need to do type conversions. In Scala, however, it is an
error if you try to assign a higher precision value to a lower precision variable. You must explicitly convert it using
an appropriate function.</p>

<div>
<div><figure><pre><code data-lang="scala"><span>val</span> <span>x</span><span>:</span> <span>Double</span> <span>=</span> <span>3</span> <span>// Ok!
</span><span>val</span> <span>y</span><span>:</span> <span>Int</span> <span>=</span> <span>3.5</span> <span>// Compile error
</span><span>val</span> <span>z</span><span>:</span> <span>Int</span> <span>=</span> <span>3.5</span><span>.</span><span>toInt</span> <span>// Ok!
</span><span>val</span> <span>a</span><span>:</span> <span>Int</span> <span>=</span> <span>x</span> <span>// Compile error
</span><span>val</span> <span>b</span><span>:</span> <span>Int</span> <span>=</span> <span>x</span><span>.</span><span>toInt</span> <span>//</span> <span>Ok</span><span>!</span></code></pre></figure>
</div>
</div>

<h2 id="functions">Functions</h2>

<p>Defining functions is quite similar in both languages.
You just replace the <code>function</code> keyword with <code>def</code>, and add types for the
parameters and the result type.
Speaking of which, this is about the only place you will explicitly write types
in Scala. The types of local values inside functions are usually inferred by the
compiler.
Actually, even the result type will usually be inferred too, but it is good
practice to explicitly define it, to help catch potential type errors.</p>

<p>Note that there is no need for a <code>return</code> keyword: the last expression in the
function is automatically used as the return value.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>function</span> <span>mult</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
  <span>return</span> <span>x</span> <span>*</span> <span>y</span><span>;</span>
<span>}</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>def</span> <span>mult</span><span>(</span><span>x</span><span>:</span> <span>Double</span><span>,</span> <span>y</span><span>:</span> <span>Double</span><span>)</span><span>:</span> <span>Double</span> <span>=</span> <span>x</span> <span>*</span> <span>y</span></code></pre></figure>
</div>
</div>

<h4 id="anonymous-functions">Anonymous functions</h4>

<p>In functional programming you quite often need to provide a function as a parameter, but you don’t need it elsewhere so
it can be anonymous. Both languages support the nice “fat arrow” notation for defining anonymous functions conveniently.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>f</span> <span>=</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>y</span><span>;</span>

<span>const</span> <span>p</span> <span>=</span> <span>[</span><span>&#34;Fox&#34;</span><span>,</span> <span>&#34;jumped&#34;</span><span>,</span> <span>&#34;over&#34;</span><span>,</span> <span>&#34;me&#34;</span><span>];</span>
<span>const</span> <span>l</span> <span>=</span> <span>p</span><span>.</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>length</span><span>)</span>
  <span>.</span><span>reduce</span><span>((</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>,</span> <span>0</span><span>);</span> <span>// == 15</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>val</span> <span>f</span> <span>=</span> <span>(</span><span>x</span><span>:</span> <span>Double</span><span>,</span> <span>y</span><span>:</span> <span>Double</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>y</span>

<span>val</span> <span>p</span> <span>=</span> <span>Array</span><span>(</span><span>&#34;Fox&#34;</span><span>,</span> <span>&#34;jumped&#34;</span><span>,</span> <span>&#34;over&#34;</span><span>,</span> <span>&#34;me&#34;</span><span>)</span>
<span>val</span> <span>l</span> <span>=</span> <span>p</span><span>.</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>length</span><span>)</span>
  <span>.</span><span>foldLeft</span><span>(</span><span>0</span><span>)((</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>)</span> <span>//</span> <span>==</span> <span>15</span></code></pre></figure>
</div>
</div>

<h4 id="default-named-and-rest-parameters">Default, named and rest parameters</h4>

<p>You can also define default values for parameters if they are not supplied when the function is called. For variable
number of parameters, you can access those as a <code>Seq</code> (see the
<a href="https://www.scala-js.org/doc/sjs-for-js/es6-to-scala-part2.html">collections part of this tour</a> for more info).
Named parameters work just as you would expect in Scala, whereas
in ES6 you need to supply them with the object notation.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>// default value</span>
<span>function</span> <span>mult</span><span>(</span><span>x</span><span>,</span> <span>y</span> <span>=</span> <span>42.0</span><span>)</span> <span>{</span>
  <span>return</span> <span>x</span> <span>*</span> <span>y</span><span>;</span>
<span>}</span>

<span>// variable number of parameters</span>
<span>function</span> <span>sum</span><span>(...</span><span>args</span><span>)</span> <span>{</span>
  <span>return</span> <span>args</span><span>.</span><span>reduce</span><span>((</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>,</span> <span>0</span><span>);</span>
<span>}</span>

<span>const</span> <span>s</span> <span>=</span> <span>sum</span><span>(</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>);</span> <span>// == 15</span>

<span>// named parameters</span>
<span>function</span> <span>vec</span><span>({</span><span>x</span> <span>=</span> <span>0</span><span>,</span> <span>y</span> <span>=</span> <span>0</span><span>,</span> <span>z</span> <span>=</span> <span>0</span><span>})</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Vec</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>);</span>
<span>}</span>

<span>const</span> <span>v</span> <span>=</span> <span>vec</span><span>({</span><span>x</span><span>:</span> <span>8</span><span>,</span> <span>z</span><span>:</span> <span>42</span><span>});</span> <span>// Vec(8, 0, 42)</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>// default value
</span><span>def</span> <span>mult</span><span>(</span><span>x</span><span>:</span> <span>Double</span><span>,</span> <span>y</span><span>:</span> <span>Double</span> <span>=</span> <span>42.0</span><span>)</span><span>:</span> <span>Double</span> <span>=</span>
  <span>x</span> <span>*</span> <span>y</span>


<span>// variable number of parameters
</span><span>def</span> <span>sum</span><span>(</span><span>args</span><span>:</span> <span>Double*</span><span>)</span><span>:</span> <span>Double</span> <span>=</span>
  <span>args</span><span>.</span><span>foldLeft</span><span>(</span><span>0.0</span><span>)((</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>)</span>


<span>val</span> <span>s</span> <span>=</span> <span>sum</span><span>(</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>)</span> <span>// == 15
</span>
<span>// named parameters (works directly)
</span><span>def</span> <span>vec</span><span>(</span><span>x</span><span>:</span> <span>Int</span> <span>=</span> <span>0</span><span>,</span> <span>y</span><span>:</span> <span>Int</span> <span>=</span> <span>0</span><span>,</span> <span>z</span><span>:</span> <span>Int</span> <span>=</span> <span>0</span><span>)</span><span>:</span> <span>Vec</span> <span>=</span>
  <span>new</span> <span>Vec</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>)</span>


<span>val</span> <span>v</span> <span>=</span> <span>vec</span><span>(</span><span>8</span><span>,</span> <span>z</span> <span>=</span> <span>42</span><span>)</span> <span>//</span> <span>Vec</span><span>(</span><span>8</span><span>,</span> <span>0</span><span>,</span> <span>42</span><span>)</span></code></pre></figure>
</div>
</div>

<p>Again, the Scala compiler can infer all the required types in the code above, including the parameters for the anonymous
function given to the <code>foldLeft</code> function.</p>

<h2 id="if-while-for-match-control-structures"><code>if</code>, <code>while</code>, <code>for</code>, <code>match</code> control structures</h2>

<p>As you would expect, Scala has the regular <code>if-else</code> and <code>while</code> control structures found in most programming
languages. The big difference to JavaScript is that <code>if</code> statements are actually expressions returning a value. In
JavaScript you have the special <code>a ? b : c</code> construct to achieve the same result.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>res</span> <span>=</span> <span>(</span><span>name</span> <span>===</span> <span>&#34;&#34;</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>;</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>val</span> <span>res</span> <span>=</span> <span>if</span> <span>(</span><span>name</span> <span>==</span> <span>&#34;&#34;</span><span>)</span> <span>0</span> <span>else</span> <span>1</span></code></pre></figure>
</div>
</div>

<p>The <code>for</code> construct in Scala is quite different from the for-loop in JavaScript and also much more powerful. You can use
it to iterate over numerical ranges or collections in both languages:</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>let</span> <span>x</span> <span>=</span> <span>0</span><span>;</span>
<span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>100</span><span>;</span> <span>i</span><span>++</span><span>)</span>
  <span>x</span> <span>+=</span> <span>i</span> <span>*</span> <span>i</span><span>;</span>

<span>const</span> <span>p</span> <span>=</span> <span>[</span><span>&#34;Fox&#34;</span><span>,</span> <span>&#34;jumped&#34;</span><span>,</span> <span>&#34;over&#34;</span><span>,</span> <span>&#34;me&#34;</span><span>];</span>
<span>for</span> <span>(</span><span>let</span> <span>s</span> <span>of</span> <span>p</span><span>)</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>`Word </span><span>${</span><span>s</span><span>}</span><span>`</span><span>);</span>
<span>}</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>var</span> <span>x</span> <span>=</span> <span>0</span>
<span>for</span> <span>(</span><span>i</span> <span>&lt;-</span> <span>0</span> <span>until</span> <span>100</span><span>)</span>
  <span>x</span> <span>+=</span> <span>i</span> <span>*</span> <span>i</span>

<span>val</span> <span>p</span> <span>=</span> <span>Array</span><span>(</span><span>&#34;Fox&#34;</span><span>,</span> <span>&#34;jumped&#34;</span><span>,</span> <span>&#34;over&#34;</span><span>,</span> <span>&#34;me&#34;</span><span>)</span>
<span>for</span> <span>(</span><span>s</span> <span>&lt;-</span> <span>p</span><span>)</span> <span>{</span>
  <span>println</span><span>(</span><span>s</span><span>&#34;Word $s&#34;</span><span>)</span>
<span>}</span></code></pre></figure>
</div>
</div>

<p>In case you have nested for-loops, you can easily combine them into one <em>for-comprehension</em> in Scala. Inside the <code>for</code>
you can even filter using <code>if</code> expressions. In Scala a <em>for-comprehension</em> is just syntactic sugar for a series of
<code>flatMap</code>, <code>map</code> and <code>withFilter</code> calls making it <em>very</em> handy when dealing with Scala collections.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>function</span> <span>findPairs</span><span>(</span><span>n</span><span>,</span> <span>sum</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> <span>j</span> <span>=</span> <span>i</span><span>;</span> <span>j</span> <span>&lt;</span> <span>n</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>i</span> <span>+</span> <span>j</span> <span>==</span> <span>sum</span><span>)</span>
        <span>console</span><span>.</span><span>log</span><span>(</span><span>`Found pair </span><span>${</span><span>i</span><span>}</span><span>, </span><span>${</span><span>j</span><span>}</span><span>`</span><span>);</span>
    <span>}</span>
  <span>}</span>
<span>};</span>
<span>findPairs</span><span>(</span><span>20</span><span>,</span> <span>31</span><span>);</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>def</span> <span>findPairs</span><span>(</span><span>n</span><span>:</span> <span>Int</span><span>,</span> <span>sum</span><span>:</span> <span>Int</span><span>)</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
  <span>for</span> <span>{</span>
    <span>i</span> <span>&lt;-</span> <span>0</span> <span>until</span> <span>n</span>
    <span>j</span> <span>&lt;-</span> <span>i</span> <span>until</span> <span>n</span> <span>if</span> <span>i</span> <span>+</span> <span>j</span> <span>==</span> <span>sum</span>
  <span>}</span> <span>println</span><span>(</span><span>s</span><span>&#34;Found pair $i, $j&#34;</span><span>)</span>
<span>}</span>
<span>findPairs</span><span>(</span><span>20</span><span>,</span> <span>31</span><span>)</span></code></pre></figure>
</div>
</div>

<p>The code above also serves as an example for <em>string interpolation</em> (in Scala) and <em>template strings</em> (in ES6). Both
make it easier to construct strings using variables or function calls. In Scala you don’t need to enclose the variable
in <code>{}</code> if it’s just a simple variable name. For more complex cases you’ll need to use the <code>s&#34;Length = ${data.length}&#34;</code>
syntax.</p>

<p>Finally the <code>match</code> construct provides <em>pattern matching</em> capabilities in Scala. Pattern matching is a complex topic
covered in more detail in the advanced section of this article, so here we just focus on the simple use cases like
replacing JavaScript <code>switch</code>/<code>case</code> with it.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>animal</span> <span>=</span> <span>&#34;Dog&#34;</span><span>;</span>
<span>let</span> <span>description</span><span>;</span>
<span>switch</span><span>(</span><span>animal</span><span>)</span> <span>{</span>
  <span>case</span> <span>&#34;Cat&#34;</span><span>:</span>
  <span>case</span> <span>&#34;Lion&#34;</span><span>:</span>
  <span>case</span> <span>&#34;Tiger&#34;</span><span>:</span>
    <span>description</span> <span>=</span> <span>&#34;It&#39;s feline!&#34;</span><span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> <span>&#34;Dog&#34;</span><span>:</span>
  <span>case</span> <span>&#34;Wolf&#34;</span><span>:</span>
    <span>description</span> <span>=</span> <span>&#34;It&#39;s canine!&#34;</span><span>;</span>
    <span>break</span><span>;</span>
  <span>default</span><span>:</span>
    <span>description</span> <span>=</span> <span>&#34;It&#39;s something else&#34;</span><span>;</span>
<span>}</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>description</span><span>);</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>val</span> <span>animal</span> <span>=</span> <span>&#34;Dog&#34;</span>
<span>val</span> <span>description</span> <span>=</span> <span>animal</span> <span>match</span> <span>{</span>
  <span>case</span> <span>&#34;Cat&#34;</span> <span>|</span> <span>&#34;Lion&#34;</span> <span>|</span> <span>&#34;Tiger&#34;</span> <span>=&gt;</span>
    <span>&#34;It&#39;s feline!&#34;</span>
  <span>case</span> <span>&#34;Dog&#34;</span> <span>|</span> <span>&#34;Wolf&#34;</span> <span>=&gt;</span>
    <span>&#34;It&#39;s canine!&#34;</span>
  <span>case</span> <span>_</span> <span>=&gt;</span>
    <span>&#34;It&#39;s something else&#34;</span>
<span>}</span>
<span>println</span><span>(</span><span>description</span><span>)</span></code></pre></figure>
</div>
</div>

<p>In Scala you can use the <code>|</code>-operator to match multiple choices and there is no need (nor support) for <code>break</code>, as cases
never fall through like they do in JavaScript. For the default case, use the ubiquitous <code>_</code> syntax (it has many many
more uses in Scala!) As with <code>if</code>, a <code>match</code> is an expression returning a value that you can directly assign to a
variable.</p>

<h2 id="classes">Classes</h2>

<p>Being an object-oriented language, Scala naturally supports classes with inheritance. In addition to basic classes Scala
also has:</p>

<ul>
  <li><code>case class</code>es for conveniently storing data</li>
  <li><code>object</code>s for singletons</li>
  <li><code>trait</code>s for defining interfaces and mixins</li>
</ul>

<p>Let us look at a simple class hierarchy in both languages.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>class</span> <span>Shape</span> <span>{</span>
  <span>constructor</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>x</span> <span>=</span> <span>x</span><span>;</span>
    <span>this</span><span>.</span><span>y</span> <span>=</span> <span>y</span><span>;</span>
  <span>}</span>

  <span>move</span><span>(</span><span>dx</span><span>,</span> <span>dy</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>x</span> <span>+=</span> <span>dx</span><span>;</span>
    <span>this</span><span>.</span><span>y</span> <span>+=</span> <span>dy</span><span>;</span>
  <span>}</span>

  <span>draw</span><span>()</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>`Shape at </span><span>${</span><span>this</span><span>.</span><span>x</span><span>}</span><span>, </span><span>${</span><span>this</span><span>.</span><span>y</span><span>}</span><span>`</span><span>);</span>
  <span>}</span>
<span>};</span>

<span>class</span> <span>Circle</span> <span>extends</span> <span>Shape</span> <span>{</span>
  <span>constructor</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>r</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>);</span>
    <span>this</span><span>.</span><span>r</span> <span>=</span> <span>r</span><span>;</span>
  <span>}</span>

  <span>draw</span><span>()</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>`Circle at </span><span>${</span><span>this</span><span>.</span><span>x</span><span>}</span><span>, </span><span>${</span><span>this</span><span>.</span><span>y</span><span>}</span><span> with radius </span><span>${</span><span>this</span><span>.</span><span>r</span><span>}</span><span>`</span><span>);</span>
  <span>}</span>
<span>}</span>

<span>const</span> <span>c</span> <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>5</span><span>,</span> <span>5</span><span>,</span> <span>42</span><span>);</span>
<span>const</span> <span>r</span> <span>=</span> <span>c</span><span>.</span><span>r</span><span>;</span> <span>// == 42</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>// use var to make coordinates mutable
</span><span>abstract</span> <span>class</span> <span>Shape</span><span>(</span><span>var</span> <span>x</span><span>:</span> <span>Int</span><span>,</span> <span>var</span> <span>y</span><span>:</span> <span>Int</span><span>)</span> <span>{</span>
  <span>def</span> <span>move</span><span>(</span><span>dx</span><span>:</span> <span>Int</span><span>,</span> <span>dy</span><span>:</span> <span>Int</span><span>)</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>x</span> <span>+=</span> <span>dx</span>
    <span>y</span> <span>+=</span> <span>dy</span>
  <span>}</span>

  <span>def</span> <span>draw</span><span>()</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>println</span><span>(</span><span>s</span><span>&#34;Shape at $x, $y&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// r is immutable but accessible outside the class
</span><span>class</span> <span>Circle</span><span>(</span><span>x</span><span>:</span> <span>Int</span><span>,</span> <span>y</span><span>:</span> <span>Int</span><span>,</span> <span>val</span> <span>r</span><span>:</span> <span>Int</span><span>)</span>
    <span>extends</span> <span>Shape</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
  <span>override</span> <span>def</span> <span>draw</span><span>()</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>println</span><span>(</span><span>s</span><span>&#34;Circle at $x, $y with radius $r&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>val</span> <span>c</span> <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>5</span><span>,</span> <span>5</span><span>,</span> <span>42</span><span>)</span>
<span>val</span> <span>r</span> <span>=</span> <span>c</span><span>.</span><span>r</span> <span>//</span> <span>==</span> <span>42</span></code></pre></figure>
</div>
</div>

<p>Note that <code>this</code> is typically omitted in Scala, since the compiler can tell that
<code>x</code>, <code>y</code> and <code>r</code> are properties of the enclosing class (and not local variables).</p>

<h4 id="case-classes">Case classes</h4>

<p>Case classes are a particular kind of class in Scala which have a lot of
compiler-generated goodies. They are particularly suited for immutable data
containers whose instances are equal if and only if their fields are pairwise
equal. They also automatically receive a sensible <code>toString()</code> representation,
and they can be instantiated without the <code>new</code> keyword.</p>

<p>JavaScript doesn’t quite have a similar construct, but whenever you would use
the regular object notation, consider using a case class instead.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>person</span> <span>=</span> <span>{</span><span>first</span><span>:</span> <span>&#34;James&#34;</span><span>,</span> <span>last</span><span>:</span> <span>&#34;Bond&#34;</span><span>};</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>case</span> <span>class</span> <span>Person</span><span>(</span><span>first</span><span>:</span> <span>String</span><span>,</span> <span>last</span><span>:</span> <span>String</span><span>)</span>

<span>val</span> <span>person</span> <span>=</span> <span>Person</span><span>(</span><span>&#34;James&#34;</span><span>,</span> <span>&#34;Bond&#34;</span><span>)</span></code></pre></figure>
</div>
</div>

<p>Case classes enforce type safety and prevent constructing invalid objects with missing fields.</p>

<p>The Scala compiler automatically generates a proper <code>equals</code> method for case classes, making comparing them trivial. In ES6
you would typically go for a library like <a href="https://lodash.com/docs#isEqual">lodash</a> to avoid writing the complex
comparison code yourself.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>o1</span> <span>=</span> <span>{</span><span>a</span><span>:</span> <span>1</span><span>,</span> <span>x</span><span>:</span> <span>&#34;test&#34;</span><span>};</span>
<span>const</span> <span>o2</span> <span>=</span> <span>{</span><span>a</span><span>:</span> <span>1</span><span>,</span> <span>x</span><span>:</span> <span>&#34;test&#34;</span><span>};</span>

<span>if</span> <span>(</span><span>o1</span> <span>!=</span> <span>o2</span><span>)</span> <span>{</span>
  <span>// this doesn&#39;t work as expected</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;They are not equal!&#34;</span><span>);</span>
<span>}</span>

<span>if</span> <span>(</span><span>_</span><span>.</span><span>isEqual</span><span>(</span><span>o1</span><span>,</span> <span>o2</span><span>))</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;They are equal!&#34;</span><span>);</span>
<span>}</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>case</span> <span>class</span> <span>AX</span><span>(</span><span>a</span><span>:</span> <span>Int</span><span>,</span> <span>x</span><span>:</span> <span>String</span><span>)</span>

<span>val</span> <span>o1</span> <span>=</span> <span>AX</span><span>(</span><span>1</span><span>,</span> <span>&#34;test&#34;</span><span>)</span>
<span>val</span> <span>o2</span> <span>=</span> <span>AX</span><span>(</span><span>1</span><span>,</span> <span>&#34;test&#34;</span><span>)</span>
<span>if</span> <span>(</span><span>o1</span> <span>==</span> <span>o2</span><span>)</span> <span>{</span>
  <span>println</span><span>(</span><span>&#34;They are equal!&#34;</span><span>)</span>
<span>}</span></code></pre></figure>
</div>
</div>

<p>Fields in case classes are public and immutable by default (unless you define them with <code>var</code> modifier) so you cannot make changes
to instances. Instead of modifying the instance you make a copy and modify one or more fields during the copy. Scala
provides a suitable <code>copy</code> function for each case class automatically. In ES6 you can use <code>Object.assign</code> to achieve the
same result.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>o1</span> <span>=</span> <span>{</span><span>a</span><span>:</span> <span>1</span><span>,</span> <span>x</span><span>:</span> <span>&#34;test&#34;</span><span>};</span>

<span>// start with empty object to prevent</span>
<span>// modification of o1</span>
<span>const</span> <span>o2</span> <span>=</span> <span>Object</span><span>.</span><span>assign</span><span>({},</span> <span>o1</span><span>,</span> <span>{</span><span>a</span><span>:</span> <span>42</span><span>});</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>case</span> <span>class</span> <span>AX</span><span>(</span><span>a</span><span>:</span> <span>Int</span><span>,</span> <span>x</span><span>:</span> <span>String</span><span>)</span>

<span>val</span> <span>o1</span> <span>=</span> <span>AX</span><span>(</span><span>1</span><span>,</span> <span>&#34;test&#34;</span><span>)</span>
<span>val</span> <span>o2</span> <span>=</span> <span>o1</span><span>.</span><span>copy</span><span>(</span><span>a</span> <span>=</span> <span>42</span><span>)</span></code></pre></figure>
</div>
</div>

<p>Finally case classes can be used nicely in <em>pattern matching</em>, which is covered in the advanced section.</p>

<h4 id="objects">Objects</h4>

<p>An <code>object</code> is a special class with only a single instance: a singleton. JavaScript also has a singleton design pattern
(or actually several) even though the language itself does not have direct support for the concept. Singletons are
useful for putting stuff in a shared namespace without polluting the global scope.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>RandomGen</span> <span>=</span> <span>{</span>
  <span>_privateMethod</span><span>()</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;I am private&#34;</span><span>);</span>
  <span>},</span>

  <span>_rnd</span><span>()</span> <span>{</span>
    <span>return</span> <span>Math</span><span>.</span><span>random</span><span>()</span>
  <span>},</span>

  <span>publicMethod</span><span>()</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;The public can see me!&#34;</span><span>);</span>
    <span>this</span><span>.</span><span>_privateMethod</span><span>();</span>
  <span>},</span>

  <span>name</span><span>:</span> <span>&#34;RandomGen&#34;</span><span>,</span>

  <span>getRandomNumber</span><span>()</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>_rnd</span><span>()</span>
  <span>}</span>
<span>}</span>

<span>const</span> <span>r</span> <span>=</span> <span>RandomGen</span><span>.</span><span>getRandomNumber</span><span>();</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>import</span> <span>scala.util.Random</span>

<span>object</span> <span>RandomGen</span> <span>{</span>
  <span>private</span> <span>def</span> <span>privateMethod</span><span>()</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>println</span><span>(</span><span>&#34;I am private&#34;</span><span>)</span>
  <span>}</span>

  <span>private</span> <span>val</span> <span>rnd</span> <span>=</span> <span>new</span> <span>Random</span><span>()</span>

  <span>def</span> <span>publicMethod</span><span>()</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>println</span><span>(</span><span>&#34;The public can see me!&#34;</span><span>)</span>
    <span>privateMethod</span><span>()</span>
  <span>}</span>

  <span>val</span> <span>name</span> <span>=</span> <span>&#34;RandomGen&#34;</span>

  <span>def</span> <span>getRandomNumber</span><span>:</span> <span>Double</span> <span>=</span> <span>rnd</span><span>.</span><span>nextDouble</span><span>()</span>
<span>}</span>

<span>val</span> <span>r</span> <span>=</span> <span>RandomGen</span><span>.</span><span>getRandomNumber</span></code></pre></figure>
</div>
</div>

<p>As you can see, defining singleton objects in Scala is quite trivial thanks to the native support in the language.</p>

<p>Another common use for <code>object</code>s in Scala is using them as <em>companion objects</em> for classes to store static variables
and methods shared by all instances of the class.</p>

<h4 id="traits">Traits</h4>

<p>Scala <code>trait</code>s are similar to the mixin design pattern in JavaScript by allowing developer to define behaviors for class
composition. Because of Scala’s strict type system, traits are commonly used to describe common <em>interfaces</em> for a group
of implementation classes. JavaScript itself has no need for interfaces, but some extensions like TypeScript support
them for the same purpose as Scala.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>class</span> <span>Circle</span> <span>extends</span> <span>Shape</span> <span>{</span>
  <span>constructor</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>r</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>);</span>
    <span>this</span><span>.</span><span>r</span> <span>=</span> <span>r</span><span>;</span>
  <span>}</span>

  <span>draw</span><span>()</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>`Circle at </span><span>${</span><span>this</span><span>.</span><span>x</span><span>}</span><span>, </span><span>${</span><span>this</span><span>.</span><span>y</span><span>}</span><span> with radius </span><span>${</span><span>this</span><span>.</span><span>r</span><span>}</span><span>`</span><span>);</span>
  <span>}</span>
<span>}</span>

<span>const</span> <span>Clickable</span> <span>=</span> <span>{</span>
  <span>onClick</span><span>()</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;Clicked!&#34;</span><span>);</span>
  <span>}</span>
<span>};</span>

<span>class</span> <span>ClickableCircle</span> <span>extends</span> <span>Circle</span> <span>{}</span>
<span>Object</span><span>.</span><span>assign</span><span>(</span><span>ClickableCircle</span><span>.</span><span>prototype</span><span>,</span> <span>Clickable</span><span>);</span>

<span>const</span> <span>cc</span> <span>=</span> <span>new</span> <span>ClickableCircle</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>42</span><span>);</span>
<span>cc</span><span>.</span><span>onClick</span><span>();</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>class</span> <span>Circle</span><span>(</span><span>x</span><span>:</span> <span>Int</span><span>,</span> <span>y</span><span>:</span> <span>Int</span><span>,</span> <span>val</span> <span>r</span><span>:</span> <span>Int</span><span>)</span>
    <span>extends</span> <span>Shape</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
  <span>override</span> <span>def</span> <span>draw</span><span>()</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>println</span><span>(</span><span>s</span><span>&#34;Circle at $x, $y with radius $r&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>trait</span> <span>Clickable</span> <span>{</span>
  <span>def</span> <span>onClick</span><span>()</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
    <span>println</span><span>(</span><span>&#34;Clicked!&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>ClickableCircle</span><span>(</span><span>x</span><span>:</span> <span>Int</span><span>,</span> <span>y</span><span>:</span> <span>Int</span><span>,</span> <span>r</span><span>:</span> <span>Int</span><span>)</span>
    <span>extends</span> <span>Circle</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>r</span><span>)</span> <span>with</span> <span>Clickable</span>

<span>val</span> <span>cc</span> <span>=</span> <span>new</span> <span>ClickableCircle</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>42</span><span>)</span>
<span>cc</span><span>.</span><span>onClick</span><span>()</span></code></pre></figure>
</div>
</div>

<p>Note that there are many ways for defining mixins in JavaScript, using <code>Object.assign</code> is just one of them supported by
ES6.</p>

<h2 id="option-the-type-safe-undefined"><code>Option</code>, the type safe <code>undefined</code></h2>

<p>The notorious <code>undefined</code> type in JavaScript can be a blessing or a curse. On the other hand it makes life easy by
allowing you to drop function parameters or leave variables undefined. But then it also masks many errors and makes
you write extra code to check for <code>undefined</code>. Quite often <code>undefined</code> is used to make a distinction between an
existing value (of any type) and a missing value.</p>

<p>Scala doesn’t have <code>undefined</code> (it does have <code>null</code> but its use is discouraged), but instead it has an
<a target="scaladoc" href="https://www.scala-lang.org/api/current/#scala.Option"><code>Option</code></a> trait for representing optional values. In Scala.js the <code>undefined</code> type exists to support
interoperability with JS libraries, but even there it is recommended to use <code>Option</code> whenever possible.</p>

<p><code>Option[A]</code> is a container for an optional value of type <code>A</code>
(note that <code>Option[A]</code> is Scala’s notation for <em>type parameters</em>, which most
programming languages, including TypeScript, write as <code>Option&lt;A&gt;</code>).
If the value of type <code>A</code> is present, the <code>Option[A]</code> is an instance of <code>Some[A]</code>,
containing the present value of type <code>A</code>. If the value is absent, the <code>Option[A]</code>
is the object <code>None</code>.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>function</span> <span>log</span><span>(</span><span>msg</span><span>,</span> <span>context</span><span>)</span> <span>{</span>
  <span>let</span> <span>s</span><span>;</span>
  <span>if</span> <span>(</span><span>context</span> <span>!==</span> <span>undefined</span><span>)</span>
    <span>s</span> <span>=</span> <span>`[</span><span>${</span><span>context</span><span>}</span><span>] </span><span>${</span><span>msg</span><span>}</span><span>`</span><span>;</span>
  <span>else</span>
    <span>s</span> <span>=</span> <span>msg</span><span>;</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>s</span><span>);</span>
<span>};</span>

<span>// produces: First message</span>
<span>log</span><span>(</span><span>&#34;First message&#34;</span><span>);</span>
<span>// produces: [debug] Second message</span>
<span>log</span><span>(</span><span>&#34;Second message&#34;</span><span>,</span> <span>&#34;debug&#34;</span><span>);</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>def</span> <span>log</span><span>(</span><span>msg</span><span>:</span> <span>String</span><span>,</span>
    <span>context</span><span>:</span> <span>Option</span><span>[</span><span>String</span><span>]</span> <span>=</span> <span>None</span><span>)</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
  <span>val</span> <span>s</span> <span>=</span> <span>context</span> <span>match</span> <span>{</span>
    <span>case</span> <span>Some</span><span>(</span><span>c</span><span>)</span> <span>=&gt;</span> <span>s</span><span>&#34;[$c] $msg&#34;</span>
    <span>case</span> <span>None</span> <span>=&gt;</span> <span>msg</span>
  <span>}</span>
  <span>println</span><span>(</span><span>s</span><span>)</span>
<span>}</span>

<span>log</span><span>(</span><span>&#34;First message&#34;</span><span>)</span>
<span>log</span><span>(</span><span>&#34;Second message&#34;</span><span>,</span> <span>Some</span><span>(</span><span>&#34;debug&#34;</span><span>))</span></code></pre></figure>
</div>
</div>

<p>Pattern matching works nicely with <code>Option</code>, but there are more powerful ways to use it. Let’s rewrite the previous
function another way giving us the same result.</p>

<div>
<div><figure><pre><code data-lang="scala"><span>def</span> <span>log</span><span>(</span><span>msg</span><span>:</span> <span>String</span><span>,</span> <span>context</span><span>:</span> <span>Option</span><span>[</span><span>String</span><span>]</span> <span>=</span> <span>None</span><span>)</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
  <span>val</span> <span>s</span> <span>=</span> <span>context</span><span>.</span><span>map</span><span>(</span><span>c</span> <span>=&gt;</span> <span>s</span><span>&#34;[$c] $msg&#34;</span><span>).</span><span>getOrElse</span><span>(</span><span>msg</span><span>)</span>
  <span>println</span><span>(</span><span>s</span><span>)</span>
<span>}</span></code></pre></figure>
</div>
</div>

<p>Whoa, quite a reduction in code size! Next let’s see how we can process a sequence of option values.</p>

<div>
<div><figure><pre><code data-lang="javascript"><span>const</span> <span>data</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>undefined</span><span>,</span> <span>5</span><span>,</span> <span>undefined</span><span>,</span> <span>7</span><span>];</span>
<span>const</span> <span>res</span> <span>=</span> <span>data</span><span>.</span><span>filter</span><span>((</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>!==</span> <span>undefined</span><span>);</span></code></pre></figure>
</div>

<div><figure><pre><code data-lang="scala"><span>val</span> <span>data</span> <span>=</span> <span>Array</span><span>(</span><span>Some</span><span>(</span><span>1</span><span>),</span> <span>Some</span><span>(</span><span>2</span><span>),</span> <span>Some</span><span>(</span><span>3</span><span>),</span>
  <span>None</span><span>,</span> <span>Some</span><span>(</span><span>5</span><span>),</span> <span>None</span><span>,</span> <span>Some</span><span>(</span><span>7</span><span>))</span>
<span>val</span> <span>res</span> <span>=</span> <span>data</span><span>.</span><span>filter</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>isDefined</span><span>)</span></code></pre></figure>
</div>
</div>

<p><code>Option</code> provides many <em>collection like</em> methods like <code>map</code>, <code>filter</code> and <code>flatMap</code>, which are discussed in the <a href="https://www.scala-js.org/doc/sjs-for-js/es6-to-scala-part2.html">next
chapter</a>.</p>

            
        </div></div>
  </body>
</html>
