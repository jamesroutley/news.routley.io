<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.anvilsecure.com/blog/compromising-garmins-sport-watches-a-deep-dive-into-garminos-and-its-monkeyc-virtual-machine.html">Original</a>
    <h1>Compromising Garmin Sport Watches: A Deep Dive into GarminOS and Its MonkeyC VM</h1>
    
    <div id="readability-page-1" class="page"><div id="pg-3940-0"><div id="pgc-3940-0-0"><div id="panel-3940-0-0-0" data-index="0"><div>
<div>
	<p><em>By Tao Sauvage</em></p>
<p><strong>TL;DR</strong>: I reversed the firmware of my Garmin Forerunner 245 Music back in 2022 and found a dozen or so vulnerabilities in their support for Connect IQ applications. They can be exploited to bypass permissions and compromise the watch. I have published various scripts and proof-of-concept apps to a <a href="https://github.com/anvilsecure/garmin-ciq-app-research" target="_blank" rel="noopener">GitHub repository</a>. Coordinating disclosure with Garmin, some of the vulnerabilities have been around since 2015 and affect over a hundred models, including fitness watches, outdoor handhelds, and GPS for bikes.</p>
<h3>Why Garmin’s Sport Watches?</h3>
<p>Garmin is a key player in the global market for fitness devices. In 2020, it was 2nd, behind Apple, in the global smartwatch market according to <a href="https://www.counterpointresearch.com/global-smartwatch-market-revenue-h1-2020/" target="_blank" rel="noopener">Counterpoint Research</a>. In terms of the security of their devices, I did not find much information online. I was therefore interested to dig further since this uncharted territory could affect a substantial number of end-users, myself included.</p>
<p>In early 2022, the only information I could find online was the following interesting blog post from Atredis: <a href="https://www.atredis.com/blog/2020/11/4/garmin-forerunner-235-dion-blazakis">&#34;A Watch, A Virtual Machine, and Broken Abstractions&#34; by Dionysus Blazakis</a> (2020). It provided an insight into how the Garmin Forerunner 235 worked and how their applications, named Connect IQ (CIQ) applications, were implemented. Blazakis’ blog post kickstarted my whole journey and I am building on top of their research.</p>
<h3>Vulnerabilities</h3>
<p>As a teaser, below is the list of vulnerabilities that I found during my project and disclosed to Garmin:</p>
<div>
<table>
<tbody>
<tr>
<td><span>Anvil ID</span></td>
<td><span>CVE ID</span></td>
<td>

</td>
<td><span>Summary</span></td>
</tr>
<tr>
<td>GRMN-01</td>
<td>
<p><em>No CVE requested</em></p>
</td>
<td>1.0.0</td>
<td>
<p>TVM does not ensure that <code>toString</code> returns a <code>String</code> object</p>
</td>
</tr>
<tr>
<td>GRMN-02</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23301" target="_blank" rel="noopener">CVE-2023-23301</a></td>
<td>1.0.0</td>
<td>
<p>Out-of-bound read when loading string resources</p>
</td>
</tr>
<tr>
<td>GRMN-03</td>
<td>
<p><em>No CVE requested</em></p>
</td>
<td>1.0.0</td>
<td>
<p>Inconsistent size when loading string resources</p>
</td>
</tr>
<tr>
<td>GRMN-04</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23298" target="_blank" rel="noopener">CVE-2023-23298</a></td>
<td>2.3.0</td>
<td>
<p>Integer overflows in <code>BufferedBitmap</code> initialization</p>
</td>
</tr>
<tr>
<td>GRMN-05</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23304" target="_blank" rel="noopener">CVE-2023-23304</a></td>
<td>2.3.0</td>
<td dir="ltr">
<p><code>SensorHistory</code> permission bypass</p>
</td>
</tr>
<tr>
<td>GRMN-06</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23305" target="_blank" rel="noopener">CVE-2023-23305</a></td>
<td>1.0.0</td>
<td>
<p>Buffer overflows when loading font resources</p>
</td>
</tr>
<tr>
<td>GRMN-07</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23302" target="_blank" rel="noopener">CVE-2023-23302</a></td>
<td>1.2.0</td>
<td>
<p>Buffer overflows in <code>Toybox.GenericChannel.setDeviceConfig</code>
</p>
</td>
</tr>
<tr>
<td>GRMN-08</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23303" target="_blank" rel="noopener">CVE-2023-23303</a></td>
<td>3.2.0</td>
<td>
<p>Buffer overflows in <code>Toybox.Ant.GenericChannel.enableEncryption</code>
</p>
</td>
</tr>
<tr>
<td>GRMN-09</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23306" target="_blank" rel="noopener">CVE-2023-23306</a></td>
<td>2.2.0</td>
<td>
<p>Relative out-of-bound write in <code>Toybox.Ant.BurstPayload</code>
</p>
</td>
</tr>
<tr>
<td>GRMN-10</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23300" target="_blank" rel="noopener">CVE-2023-23300</a></td>
<td>3.0.0</td>
<td>
<p>Buffer overflows in <code>Toybox.Cryptography.Cipher.initialize</code>
</p>
</td>
</tr>
<tr>
<td>GRMN-11</td>
<td>
<p><em>Same as GRMN-09</em></p>
</td>
<td>2.2.0</td>
<td>
<p>Type confusion in <code>Toybox.Ant.BurstPayload</code>
</p>
</td>
</tr>
<tr>
<td>GRMN-12</td>
<td>
<p><em>No CVE requested</em></p>
</td>
<td>1.0.0</td>
<td>
<p>Native functions do not check the number of arguments</p>
</td>
</tr>
<tr>
<td dir="ltr">GRMN-13</td>
<td dir="ltr"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23299" target="_blank" rel="noopener">CVE-2023-23299</a></td>
<td dir="ltr">1.0.0</td>
<td dir="ltr">
<p>Permission bypass via field definition manipulation</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>We coordinated disclosure with Garmin through 2022 and 2023 (see the <a href="https://www.anvilsecure.com/#responsible-disclosure-timeline"><em>Responsible Disclosure Timeline</em></a> section). They clarified that several of the vulnerabilities were there since version 1.0.0, published in January 2015.</p>
<p>They also clarified that the vulnerabilities affected over a hundred devices, based on the list of <a href="https://developer.garmin.com/connect-iq/compatible-devices/" target="_blank" rel="noopener">Connect IQ Compatible Devices</a> and fixed in CIQ API version 3.1.x as specified by Garmin.</p>
<h3>Pre-Research</h3>
<p>The CIQ applications are executed inside a virtual machine (named TVM in the firmware, which I read as &#34;The Virtual Machine&#34;) implemented in their Garmin Operating System (aptly named GarminOS). TVM is mainly used for stability but it also adds a security layer:</p>
<ul>
<li>If the application takes too long to execute, the VM aborts it.</li>
<li>The VM takes care of allocating and freeing memory, to prevent memory leaks.</li>
<li>The VM stops applications from accessing sensitive APIs if they do not have the correct permissions (e.g. accessing GPS location).</li>
</ul>
<p>Atredis&#39; blog post focused on the security of TVM&#39;s operation codes (opcodes) that are implemented natively. It highlighted several critical issues that can be exploited with malicious assembly code to break the virtualization layer and gain native code execution on the watch, allowing full control.</p>
<p>The attack scenario is for a user to install a malicious CIQ application (manually or from <a href="https://apps.garmin.com/en-US/" target="_blank" rel="noopener">the Connect IQ Store</a>). We can make the parallel with Android applications, where a user installs a malicious APK on their mobile device, either from the Play Store or by side-loading it.</p>
<p>I recommend giving Atredis&#39; blog post a read if you&#39;re interested. Although they only list the Forerunner 235 model in their advisory, I strongly suspect that the vulnerabilities they found affected a much wider range of devices.</p>
<p>In my journey, I was interested in analyzing three additional aspects of Garmin applications that could represent potential attack vectors:</p>
<ul>
<li>How does GarminOS load CIQ apps?</li>
<li>What are the native functions briefly mentioned in Atredis&#39; blog post?</li>
<li>How are app permissions implemented?</li>
</ul>
<h3>GarminOS and TVM</h3>
<p>GarminOS is a fully custom OS developed in-house by Garmin, which, to say the least, is not common nowadays. It implements threading and memory management but does not have a concept of user-mode vs. kernel mode, nor does it support multiple processes for instance. It is mostly written in C, with the UI framework starting to move to C++ over the past couple of years (based on <a href="https://cppcast.com/brad-larson-cpp-watch/" target="_blank" rel="noopener">this podcast</a> linked in <a href="https://forums.garmin.com/developer/connect-iq/f/discussion/260863/question-regarding-the-operating-system-of-the-garmins-smartwatches/1250915#1250915" target="_blank" rel="noopener">this random Garmin forum message</a> I found through shear luck).</p>
<p>Public documentation of their OS is limited but we know that their watches use ARM Cortex M series processors, which can help with reverse-engineering later. Here, we will be analyzing and testing the <a href="https://www.garmin.com/en-US/p/646690" target="_blank" rel="noopener">Garmin Forerunner 245 Music model</a>.</p>
<p>Interestingly, Garmin developed their own programing language named <a href="https://developer.garmin.com/connect-iq/monkey-c/" target="_blank" rel="noopener">MonkeyC</a>, which is used to write applications that can run on the watch. They provide an <a href="https://developer.garmin.com/connect-iq/sdk/" target="_blank" rel="noopener">SDK</a> and <a href="https://developer.garmin.com/connect-iq/api-docs/" target="_blank" rel="noopener">API documentation</a> that developers can rely on to develop CIQ applications.</p>
<p>The MonkeyC language is a mix between Java and JavaScript, among others. It compiles into byte code that is interpreted by Garmin&#39;s TVM.</p>
<p>Here is an example of a simple MonkeyC program that outputs &#34;Hello Monkey C!&#34; to the log file of the app:</p>
<pre data-enlighter-language="java" data-enlighter-theme="dracula">import Toybox.Application as App;
import Toybox.System;

class MyProjectApp extends App.AppBase {
    function onStart(state) {
        System.println(&#34;Hello Monkey C!&#34;);
    }
}
</pre>
<h3>Firmware Analysis</h3>
<p>I initially tried analyzing the firmware update that is temporarily stored on the watch when it prompts you to update. However, I quickly realized that this was an incremental build and did not contain the whole firmware.</p>
<p>Fortunately, Garmin provides <a href="https://www8.garmin.com/support/download_details.jsp?id=14937" target="_blank" rel="noopener">beta firmware images on their website</a>, which contain everything. They are structured as GCD files, a file format that was <a href="https://www.memotech.franken.de/FileFormats/Garmin_GCD_Format.pdf" target="_blank" rel="noopener">unofficially documented by Herbert Oppmann</a>.</p>
<p>Parsing the GCD firmware update, I extracted the <code>FW_ALL_BIN</code> record that contained the raw image for my watch:</p>
<figure id="attachment_3975" aria-describedby="caption-attachment-3975"><img decoding="async" alt="" width="514" height="412" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Binwalk-entropy-analysis.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3975">Binwalk entropy analysis of the extracted FW_ALL_BIN record.</figcaption></figure>
<p>I could then directly load the firmware image as ARM:LE:32:Cortex using <a href="https://ghidra-sre.org/" target="_blank" rel="noopener">Ghidra</a>, with the following memory map after some trial and errors:</p>
<p><img decoding="async" alt="" width="1053" height="97" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Ghidra-memory-map.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/></p>

<p>You will note the starting address at <code>0x3000</code> for the flash. I mentioned that the beta firmware images contained everything but it is not accurate, since they are missing the bootloader that is most likely located between address <code>0x0</code> and <code>0x3000</code>.</p>
<p>Various miscellaneous information I gathered during reverse-engineering:</p>
<ul>
<li>MonkeyC has 21 data types:
<pre data-enlighter-language="java" data-enlighter-theme="dracula">// MonkeyC data types
 NULL(0),  
 INT(1),  
 FLOAT(2),  
 STRING(3),  
 OBJECT(4),  
 ARRAY(5),  
 METHOD(6),  
 CLASSDEF(7),  
 SYMBOL(8),  
 BOOLEAN(9),  
 MODULEDEF(10),  
 HASH(11),  
 RESOURCE(12),  
 PRIMITIVE_OBJECT(13),  
 LONG(14),  
 DOUBLE(15),  
 WEAK_POINTER(16),  
 PRIMITIVE_MODULE(17),  
 SYSTEM_POINTER(18),  
 CHAR(19),  
 BYTE_ARRAY(20);
</pre>
</li>
<li>TVM converts those objects into a 5-byte structure that is pushed onto the stack:
<ul>
<li>The first byte represents the data type (<code>0x01</code> for <code>int</code>, <code>0x02</code> for float, <code>0x05</code> for <code>Array</code>, <code>0x09</code> for Boolean, etc.)</li>
<li>The 4 remaining bytes represent either the direct value (e.g. <code>0x11223344</code> for an integer encoded using 32 bits) or an ID pointing to another structure located on the heap for more complex types (<code>Hash</code>, <code>Array</code>, <code>Resource</code>, etc.)</li>
</ul>
</li>
<li>TVM supports a total of 53 opcodes (<a href="https://github.com/anvilsecure/garmin-ciq-app-research/blob/main/ciq.ksy#L345-L400" target="_blank" rel="noopener">full list here</a>)
<ul>
<li>Including common ones like <code>add</code>, <code>sub</code>, <code>return</code>, <code>nop</code> for instance.</li>
<li>As well as more specialized ones like <code>newba</code> (to allocate <a href="https://developer.garmin.com/connect-iq/api-docs/Toybox/Lang/ByteArray.html" target="_blank" rel="noopener">ByteArray</a><a href="https://developer.garmin.com/connect-iq/api-docs/Toybox/Lang/ByteArray.html"> objects</a>) or <code>getm</code> (to resolve modules when using the <code>import</code> or <code>using</code> statement) for example.</li>
<li>Those opcodes are implemented in native code in C and were the focus of Atredis&#39; research, as mentioned before.</li>
</ul>
</li>
</ul>
<h3>CIQ Applications</h3>
<p>When compiling a CIQ application, the SDK generates a PRG file (I read it as &#34;Program”) containing multiple sections including the code, data, signature and permissions sections, to name a few.</p>
<p>PRG sections are defined using <a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">Type-Length-Value (TLV) encoding</a>, with:</p>
<ul>
<li>4 bytes: the section type, using a magic value (e.g. 0xc0debabe for the code section)</li>
<li>4 bytes: the section length</li>
<li>n bytes: the section data, as specified in the section length</li>
</ul>
<p>I very much enjoy <a href="https://kaitai.io/">Kaitai Struct</a> when I need to analyze binary blobs interactively. I wrote a Kaitai structure for PRG files, with support for disassembling (but not for resources; I think my Kaitai skills are not good enough for that). It is available on our <a href="https://github.com/anvilsecure/garmin-ciq-app-research/blob/main/ciq.ksy">GitHub</a>.</p>
<p>For example, disassembling the TLV sections can be done as follows:</p>
<pre data-enlighter-language="yaml" data-enlighter-theme="dracula">section:
doc: A section
seq:
  - id: section_type
    type: u4
  - id: length
    type: u4
  - id: data
    size: length
    type:
      switch-on: section_type
      cases:
      # [...]
      section_magic::section_magic_head: section_head
      # [...]
enums:
  section_magic:
    # [...]
    0xd000d000: section_magic_head
    # [...]

</pre>

<h4>Signature</h4>
<p>The PRG files are signed using RSA and the PKCS #1 v1.5 standard with SHA1. They can hold either of the following signature sections:</p>
<ul>
<li>App Store signature</li>
<li>Developer signature</li>
</ul>
<p>In the first case, only the 512-byte signature is included. In the second case, both the 512-byte signature and the public key is included. There does not seem to be an option to reject developer-signed apps on the watch.</p>
<p>It is straightforward to add support for developer signature in our Kaitai structure:</p>
<pre data-enlighter-language="yaml" data-enlighter-theme="dracula">section_developer_signature_block:
    doc: Developer signature block
    seq:
      - id: signature
        size: 512
      - id: modulus
        size: 512
      - id: exponent
        type: u4

</pre>
<p>When the compiler creates a PRG file, it first generates and appends all the sections (head, entry points, data, code, resource, and so on). It then computes the RSA signature and appends the signature section. Finally, it appends the end section, which contains all zeros (magic value is 0, and length is 0, for a total of 8 bytes).</p>
<p>I only performed a cursory review of the signature validation process, only just enough so that <a href="https://github.com/anvilsecure/garmin-ciq-app-research/blob/main/ciqpy/main.py#L90-L93">I could sign my own patched PRG files</a>.</p>
<p>If anyone is interested in looking closer at the signature validation performed by the firmware, let me know. I would love to team up. You can find my contact details at the bottom of this post.</p>
<h4>Attack Surface</h4>
<p>Since parsing PRG files is performed in native code, it is an interesting attack surface:</p>
<ul>
<li>The file format contains multiple offsets that could lead to integer over/underflows if they are not properly validated.</li>
<li>It specifies the permissions the application needs, as well as the signature for validation.</li>
<li>It contains a link table and other information used for resolving symbols or handling exceptions during execution.</li>
<li>It is possible to embed complex data structures within the PRG file, including images, animations and fonts, among others.</li>
</ul>
<p>Fortunately, Garmin properly handles section lengths (as far as I could tell). Other length attributes within those sections are often encoded using 2 bytes but stored inside 4-byte integers in the code, preventing a lot of integer overflow scenarios.</p>
<p>But there are still many elements to check. Let&#39;s go over several issues that I found while reversing PRG loading.</p>
<h3>Resources</h3>
<p>MonkeyC supports several types of resources. Their <a href="https://developer.garmin.com/connect-iq/core-topics/resources/">documentation</a> mentions strings, bitmaps, fonts, JSON data and animations.</p>
<h4>String Definitions</h4>
<p>String definitions (as shown below) are processed by the <code>news</code> opcode. When calling <code>news</code>, you pass the symbol to your string definition, which usually points inside your PRG&#39;s data section. A string definition starts with the sentinel value <code>0x1</code>, followed by the string length encoded using 2 bytes, followed by the string bytes.</p>
<figure id="attachment_3983" aria-describedby="caption-attachment-3983"><img decoding="async" alt="" width="755" height="201" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/String-definition-inside-a-PRG-file.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3983">String definition inside a PRG file.</figcaption></figure>
<p>The Atredis&#39; <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-27486">CVE-2020-27486</a> advisory explains that the <code>news</code> opcode allocates the string buffer based on the length specified in the string definition, and then proceeds to call <code>strcpy</code> to copy the string bytes. This can lead to memory corruption, since <code>strcpy</code> does not use the specified length and will only stop at the first null byte.</p>
<p>Looking at the <code>news</code> opcode, I confirmed that this was fixed by using <code>strncpy</code> now. However, digging further I noted another, albeit less impacting issue.</p>
<p>When loading the definition, TVM first resolves the symbol to its value that stands for a &#34;physical&#34; offset within a section. The most significant byte (MSB) of the symbol specifies which section:</p>
<ul>
<li>MSB<code> 0x00</code> (i.e. between <code>0x00000000</code> and <code>0x10000000</code> excluded), we&#39;re pointing inside the PRG data section</li>
<li>MSB<code> 0x10</code> (i.e. between <code>0x10000000</code> and <code>0x20000000</code> excluded), we&#39;re pointing inside the PRG code section</li>
<li>MSB<code> 0x20</code> (i.e. between <code>0x20000000</code> and <code>0x30000000</code> excluded), we&#39;re pointing inside the API data section (stored in the firmware)</li>
<li>MSB<code> 0x30</code> (i.e. between <code>0x30000000</code> and <code>0x40000000</code> excluded), we&#39;re pointing inside the API code section (also stored in the firmware)</li>
</ul>
<p>TVM then uses the lower 6 bytes as the offset within those sections. (There is also MSB <code>0x40</code> for native functions but I will get back to them later.)</p>
<p>By API data and code sections, I mean that the firmware embeds a copy of the SDK compiled from MonkeyC. Although it is not a PRG file like an application we would develop, they contain the same data structures. The API code section contains MonkeyC byte code and the API data section contains class and string definitions.</p>
<p>TVM checks that the offset computed from the symbol is within the bounds of the expected section. For instance, if your PRG data section is <code>0x1000</code> bytes and you specify the symbol <code>0xdeadbeef</code> whose value is <code>0x00aabbcc</code>, it will fail, since <code>0xaabbcc</code> is beyond the end of PRG data section (<code>0xaabbcc &gt; 0x1000</code>).</p>
<p>However, there is a problem with strings. String definitions specify the length of the data to read and TVM does not check if it goes beyond the end of the section. It is therefore possible to place a string definition at the border of a section, with a large size, and TVM will read data beyond the section&#39;s end (up until the next null byte).</p>
<figure id="attachment_3982" aria-describedby="caption-attachment-3982"><img decoding="async" alt="" width="3840" height="1349" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Placing-a-string-definition-near-the-end-of-a-section.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3982">Placing a string definition near the end of a section.</figcaption></figure>
<p>In fact, since the sentinel value for string definitions is just <code>0x01</code>, we can also easily find offsets within the API data and code sections that can be treated as valid string definitions. So we are not restricted in placing our invalid string definitions in our PRG sections, we can also find them in the API sections.</p>
<h4>Font Resources</h4>
<p>The firmware I analyzed supports two types of fonts: non-Unicode (sentinel value <code>0xf047</code>) and Unicode (sentinel value <code>0xf23b</code>). The former no longer is supported when compiling a PRG file but the code for handling them is still present inside the firmware (most likely for retro-compatibility reasons).</p>
<p>The non-Unicode format that is no longer supported is shorter and simpler to describe:</p>
<div>
<table>
<thead>
<tr>
<th><strong>Index</strong></th>
<th><strong>Size in bytes</strong></th>
<th><strong>Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>4</td>
<td>sentinel value</td>
</tr>
<tr>
<td>0x04</td>
<td>4</td>
<td>height</td>
</tr>
<tr>
<td>0x08</td>
<td>4</td>
<td>glyph count</td>
</tr>
<tr>
<td>0x0c</td>
<td>4</td>
<td>min</td>
</tr>
<tr>
<td>0x10</td>
<td>2</td>
<td>data size</td>
</tr>
<tr>
<td>0x12</td>
<td>3 * glyph count</td>
<td>glyph table buffer</td>
</tr>
<tr>
<td>n</td>
<td>4</td>
<td>glyph sentinel</td>
</tr>
<tr>
<td>n + 4</td>
<td>1 * data size</td>
<td>extra data buffer</td>
</tr>
</tbody>
</table>
</div>
<p>When loading a font, the native code incorrectly computes the size of the buffer needed to load the data due to an integer overflow line 7:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula" data-enlighter-highlight="7">e_tvm_error _tvm_app_load_resource(s_tvm_ctx *ctx,int fd,uint app_type,s_tvm_object *resource,s_tvm_object *out)
{
    uint size_buffer;
    // [...]
    file_read_4bytes(fd, &amp;font_glyph_count);
    file_read_2bytes(fd, &amp;font_data_size);
    size_buffer = (font_data_size &amp; 0xffff) + (int)font_glyph_count * 4 + 0x34;
    tvm_mem_alloc(ctx, glyph_table, &amp;glyph_table_data);
    // [...]
    for (i = 0; i &lt; font_glyph_count; i++) {
        glyph = glyph_table_data[i];
        file_read_2bytes(fd, glyph);
    }
    // [...]
}
</pre>
<p>It is possible to craft a font header that will result in out-of-bound write operations. For instance, selecting the following values:</p>
<p>- Glyph count: <code>0x4000001A</code></p>
<p>The computed buffer size will be: <code>(0x108 &amp; 0xffff) + 0x4000001A * 4 + 0x34 = 0x1000001a4</code>. Since the registers can only hold 32-bit values, it gets truncated to <code>0x1000001a4 &amp; 0xffffffff = 0x1a4</code>. The firmware will then try to copy <code>0x4000001A</code> glyphs to a buffer of <code>0x1a4</code> bytes.</p>
<p>Similar issues can be found when parsing Unicode fonts, as well as bitmap resources. However, trying to overwrite large buffers on small, embedded devices can be tricky. I decided to continue reversing the firmware to identify vulnerabilities that may be easier to exploit.</p>
<h3>Native Functions</h3>
<p>When extracting the API data and code sections from the firmware, I noted that although a lot of functions were implemented in MonkeyC, others were actually implemented natively (as denoted by their symbols starting with <code>0x40</code> as mentioned before).</p>
<p>When invoking a method, symbols starting with <code>0x40</code> are treated as an index inside a table of callbacks:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula">// [...]
if ((field_value[0].value &amp; 0xff000000) == 0x40000000) {
// `i * 4` is checked earlier in the function to be within bounds
tvm_native_method = *(code **)(PTR_tvm_native_callback_methods_00179984 + i * 4);
ctx-&gt;pc_ptr = (byte *)tvm_native_method;
err = (*tvm_native_method)(ctx, nb_args);
// [...]
</pre>
<p>In my firmware, I noted 460 native functions! This is quite a large attack surface, since a bug in any of those could potentially allow compromising the OS.</p>
<p>Something to note about symbols starting with <code>0x40</code>:</p>
<p>- Their 2nd MSB indicates the number of arguments</p>
<p>For example, the symbol <code>0x40050123</code> points to a native function (MSB is <code>0x40</code>) that expects 5 parameters (2nd MSB is <code>0x05</code>) and whose index in the table is <code>0x123</code>.</p>
<h4>Resolving Native Function Symbols</h4>
<p>I wanted to resolve the symbols of those native functions to speed up reversing. I located and extracted the API data section based on its <code>0xc1a55def</code> magic value.</p>
<figure id="attachment_3974" aria-describedby="caption-attachment-3974"><img decoding="async" alt="" width="829" height="610" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/API-data-section-embedded-in-the-firmware.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3974">API data section embedded in the firmware.</figcaption></figure>
<p><span>I then parsed and searched for all methods starting with </span><span>0x40</span><span>. For that, I compiled my Kaitai structure to Python to automate the process. Below is an example of such method from the Kaitai web IDE:</span></p>
<figure id="attachment_3977" aria-describedby="caption-attachment-3977"><img decoding="async" alt="" width="331" height="393" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Class-definition-with-a-native-function-in-the-second-field.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3977">Class definition with a native function in the second field definition.</figcaption></figure>
<p>In the screenshot above, we find the following information:</p>
<ul>
<li>We are inside the class definition of the module ID <code>0x800490</code>, which inherits from the module ID <code>0x800003</code>
</li>
<li>The first field definition is a method (type <code>0x6</code>), whose symbol is <code>0x800018</code> and value is <code>0x300055D9</code>
</li>
<li>The second field definition is also a method (type <code>0x6</code>), whose symbol is <code>0x800446</code> and value is <code>0x4002015F</code>
</li>
</ul>
<p>For now, let&#39;s focus on the second field definition. Since the MSB of its value is <code>0x40</code>, it is a native function, which takes 2 parameters and is located at offset <code>0x15F</code> in the callback table.</p>
<p>We can find the debug symbol of <code>0x800446</code> in the SDK provided to end-users:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="dracula">monkeybrains.jar.src$ grep $((16#800446)) ./com/garmin/monkeybrains/api.db
getHeartRateHistory 8389702

</pre>
<p>But there are two <code>getHeartRateHistory</code> according to their documentation. Which one is it? This is where we use the module ID:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="dracula">monkeybrains.jar.src$ grep $((16#800490)) ./com/garmin/monkeybrains/api.db
Toybox_SensorHistory 8389776

</pre>
<p>Therefore, the native callback at offset <code>0x15F</code> is <a href="https://developer.garmin.com/connect-iq/api-docs/Toybox/SensorHistory.html#getHeartRateHistory-instance_function" target="_blank" rel="noopener">Toybox.SensorHistory.getHeartRateHistory</a>. You would have guessed already: the parent module ID <code>0x800003</code> is <code>Toybox</code>.</p>
<p>This method appears to only take one parameter (<code>options</code>) but TVM is object-oriented so under the hood, <code>getHeartRateHistory</code> does take two parameters: <code>this</code> and <code>options</code>. (For the curious, the first field definition is the <code>&lt;init&gt;</code> method of the class.)</p>
<p>We can automate this process (Kaitai to Python, plus some additional Python code to parse the debug symbols) for all native functions and rename the functions in Ghidra using their Python scripting API.</p>
<figure id="attachment_3979" aria-describedby="caption-attachment-3979"><img decoding="async" alt="" width="594" height="571" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/List-of-native-functions-renamed-with-their-symbols.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3979">List of native functions renamed with their symbols.</figcaption></figure>
<p>It is now much easier to reverse the native functions, since we can already know their arguments based on the official documentation.</p>
<p><strong><code>Toybox.Cryptography.Cipher.initialize</code> Buffer Overflows</strong></p>
<ul>
<li>
<code>algorithm</code>, which is an enum to specify <code>AES128</code> or <code>AES256</code>.</li>
<li>
<code>mode</code>, which is an enum to specify <code>ECB</code> or <code>CBC</code>.</li>
<li>
<code>key</code>, which is a <code>ByteArray</code> of the secret key.</li>
<li>
<code>iv</code>, which is a <code>ByteArray</code> of the initialization vector.</li>
</ul>
<p>This <code>initialize</code> method is implemented natively in the firmware:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula" data-enlighter-highlight="16,30">e_tvm_error native:Toybox.Cryptography.Cipher.initialize(s_tvm_ctx *ctx,uint nb_args)
{
// [...]
  byte static_key_buffer [36];
  ushort key_data_length;
// [...]
  // Anvil: Retrieve the key parameter and store it into `key`.
// [...]
      // Anvil: Retrieve the underlying byte array data
      eVar1 = tvm_object_get_bytearray_data(ctx,(s_tvm_object *)key,&amp;bytearray_data);
      psVar2 = (s_tvm_ctx *)(uint)eVar1;
      if (psVar2 != (s_tvm_ctx *)0x0) goto LAB_0478fd0c;
      // Anvil: And the byte array length
      key_data_length = *(ushort *)&amp;bytearray_data-&gt;length;
      // Anvil: Copy the byte array data to the static buffer
      memcpy(static_key_buffer,bytearray_data + 1,(uint)key_data_length);
// [...]
      // Anvil: if CIPHER_AES128 then expected size is 16
      if (*(int *)(local_78 + 0x18) == 0) {
        expected_key_size = 0x10;
      }
      else {
        // Anvil: if CIPHER_AES256, then expected size is 32
        if (*(int *)(local_78 + 0x18) == 1) {
          expected_key_size = 0x20;
        }
// [...]
      }
      // Anvil: If the key size is unexpected, throw an exception
      if (((key_data_length != expected_key_size) &amp;&amp; (psVar2 = (s_tvm_ctx *)thunk_FUN_00179a5c(ctx,(uint *)object_InvalidOptionsException,PTR_s_Invalid_length_of_:key_for_reque_047900d0), psVar2 != (s_tvm_ctx *)0x0)) || /* [...] */ ) goto LAB_0478fd1a;
// [...]
</pre>
<p>In the code snippet above, the native function retrieves the key data and calls <code>memcpy</code> to copy it to the static buffer located on the stack. Once the copy is done, only then does it check the size of the key and throws an error if it has an invalid value.</p>
<p>However, at that point, we already corrupted the stack, including the value for the program counter (PC) register.</p>
<p>The same logic applies to the initialization vector later in the <code>initialize</code> function, although this time the buffer is located on the heap instead of the stack:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula" data-enlighter-highlight="10, 13">// [...]
      // Anvil: Retrieves the IV byte array data
      eVar1 = tvm_object_get_bytearray_data(ctx,(s_tvm_object *)iv,&amp;bytearray_data);
      psVar2 = (s_tvm_ctx *)(uint)eVar1;
      if (psVar2 != (s_tvm_ctx *)0x0) goto LAB_0478fc06;
      iv_length = bytearray_data-&gt;length;
      // Anvil: Assigns its length to a structure at offset 0x16
      *(short *)(local_78 + 0x16) = (short)iv_length;
      // Anvil: Copy the byte array data to the buffer on the heap
      memcpy(local_78 + 6,bytearray_data + 1,iv_length &amp; 0xffff);
// [...]
      // Anvil: If the IV size is not 16, throw an exception
      if (*(short *)(local_78 + 0x16) != 0x10) {
        if (psVar2 != (s_tvm_ctx *)0x0) goto LAB_0478fc06;
        psVar2 = (s_tvm_ctx *)thunk_FUN_00179a5c(ctx,(uint *)object_InvalidOptionsException,PTR_s_Invalid_length_of_:iv_for_reques_047900dc);
      }
// [...]
</pre>
<p>The following MonkeyC application can trigger the crash when the <code>key</code> parameter is copied:</p>
<pre data-enlighter-language="java" data-enlighter-theme="dracula">var keyConvertOptions = {
    :fromRepresentation =&gt; StringUtil.REPRESENTATION_STRING_HEX,
    :toRepresentation =&gt; StringUtil.REPRESENTATION_BYTE_ARRAY
};
var keyBytes = StringUtil.convertEncodedString(
    &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbb&#34;,
    keyConvertOptions
);
var ivBytes = StringUtil.convertEncodedString(
    &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;,
    keyConvertOptions
);

var myCipher = new Crypto.Cipher({
    :algorithm =&gt; Crypto.CIPHER_AES128,
    :mode =&gt; Crypto.MODE_ECB,
    :key =&gt; keyBytes,
    :iv =&gt; ivBytes
});
</pre>
<p><strong><code>Toybox.Ant.BurstPayload</code> Relative Out-of-Bounds Write</strong></p>
<p>Looking at the documentation, the <code>Toybox.Ant.BurstPayload.add</code> method expects just one parameter: <code>message</code> as an array or a byte array. The method adds the message object to an internal buffer. It is implemented natively:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula" data-enlighter-highlight="12,24,25">e_tvm_error native:Toybox.Ant.BurstPayload.add(s_tvm_ctx *ctx,uint nb_args)
{
// [...]
  // Anvil: Retrieves our current BurstPayload instance object
  object = (s_tvm_object *)(ctx-&gt;frame_ptr + 5);
  field_size = 0;
  // Anvil: Retrieves its `size` field
  eVar1 = tvm_get_field_size_as_int(ctx,object,&amp;field_size);
  uVar2 = (uint)eVar1;
  if (uVar2 == 0) {
    // Anvil: If the `size` field is &gt;= 0x2000, we abort
    if (0x1fff &lt; (int)field_size) { 
      return OUT_OF_MEMORY_ERROR; 
    } 
// [...] 
    // Anvil: Retrieves our `message` parameter 
    eVar1 = tvm_message_copy_payload_data(ctx,ctx-&gt;frame_ptr + 10,payload_data);
// [...]
      // Anvil: Retrieves our instance&#39;s `burstDataBlob` field
      eVar1 = tvm_object_get_field_value-?(ctx,object,field_burstDataBlob,&amp;burst_data_blob,1);
// [...]
      if ((uVar2 == 0) &amp;&amp; (uVar2 = _tvm_object_get_object_data(ctx,burst_data_blob.value,(undefined *)&amp;blob_data), uVar2 == 0)) {
        // Anvil: We write our `message` data to the internal buffer.
        *(undefined4 *)(blob_data + field_size + 0xc) = payload_data._0_4_;
        *(undefined4 *)(blob_data + field_size + 0x10) = payload_data._4_4_;
// [...]
</pre>
<p>The first thing that stands out is the <code>size</code> field validation. While the function checks the upper bound of its value, it does not check for negative values.</p>
<p>How do we control the <code>size</code> field of the <code>BurstPayload</code> object? MonkeyC supports inheritance, so we can simply inherit from the object and override its value after its constructor was called.</p>
<p>For example, the following code snippet overrides the <code>size</code> field with <code>0xdeadbeef</code> after calling its parent&#39;s <code>initialize</code> method. When calling <code>add</code>, the native function will attempt to write 8 bytes of <code>data</code>, starting at <code>blob_data + 0xdeadbeef + 0xc</code>.</p>
<pre data-enlighter-language="java" data-enlighter-theme="dracula">class MyBurstPayload extends Ant.BurstPayload {
    function initialize() {
        Ant.BurstPayload.initialize();
        self.size = 0xdeadbeef;
    }
}
// [...]


var burst = new MyBurstPayload();


var data = new[8];
for (var j = 0; j &lt; 8; j++) {
    data[j] = 0x44;
}

burst.add(data);
</pre>
<p><strong><code>Toybox.Ant.BurstPayload</code> Type Confusion</strong></p>
<p>However, using the same technique that we used to redefine the <code>size</code> field, we can change the <code>burstDataPayload</code> field to become another type of object.</p>
<p>For example, the following code changes the <code>burstDataBlob</code> field to an <code>Array</code> object:</p>
<pre data-enlighter-language="java" data-enlighter-theme="dracula">class MyBurstPayload extends Ant.BurstPayload {
    function initialize() {
        Ant.BurstPayload.initialize();
        self.size = 0;
        // Both objects are INT
        self.burstDataBlob = [0, 0];
    }
}


// [...]


var burst = new MyBurstPayload();


var data = [
    // First object, changing from INT to FLOAT
    0x02, 0x42, 0x42, 0x43, 0x43,
    // Second object, changing from INT to FLOAT
    0x02, 0x45, 0x45,
];
burst.add(data);

</pre>
<p>When the <code>add</code> function is called, the native function will override the first 8 bytes of the data of the array. These bytes represent the first 2 objects stored (5 bytes of the first object and 3 bytes of the second), which are of type <code>INT</code>. We override them with our own objects of type <code>FLOAT</code>.</p>
<p>The same pattern can be seen in other native functions, where they assume that the object&#39;s fields are the same as defined in the SDK. They do not take into consideration the case where those were modified via inheritance.</p>
<p>Now some of the vulnerable native functions require permissions. For the vulnerabilities related to <code>Toybox.Ant.BurstPayload</code>, our CIQ app must add the <code>Toybox.Ant</code> module to its permissions list (along with the <code>Toybox.Background</code> module).</p>
<p>I was interested in understanding how permissions were enforced by the firmware.</p>
<h3 id="permissions">Permissions</h3>
<p>Module definitions have a flag that specifies if they require permissions to be used. This flag is set for various core modules, such as:</p>
<ul>
<li>
<code>Toybox.Ant</code> for Ant-related communication</li>
<li>
<code>Toybox.Positioning</code> to retrieve GPS coordinates</li>
<li>
<code>Toybox.UserProfile</code> to retrieve user-related information such as date of birth, weight, etc.</li>
<li><a href="https://developer.garmin.com/connect-iq/core-topics/manifest-and-permissions/" target="_blank" rel="noopener">Complete list here</a></li>
</ul>
<p>Then, the PRG file includes the module IDs it needs access to in its permissions section. For instance, if your application needs access to <code>Toybox.UserProfile</code> module, it will include its ID (<code>0x800012</code>) in its permissions section, as shown below:</p>
<figure id="attachment_3981" aria-describedby="caption-attachment-3981"><img decoding="async" alt="" width="317" height="150" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Permissions-section-in-PRG-file.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3981">Permissions section in PRG file.</figcaption></figure>
<p>These permissions are then listed on the Connect IQ store for each application. For example, the <a href="https://apps.garmin.com/en-US/apps/30c6c876-ba43-4cbb-b4c7-03583a7cb66b">Spotify CIQ app</a> lists the following permission:</p>
<figure id="attachment_3980" aria-describedby="caption-attachment-3980"><img decoding="async" alt="" width="487" height="169" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Permissions-of-the-Spotify-CIQ-app.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3980">Permissions of the Spotify CIQ app.</figcaption></figure>
<p>Which corresponds to the <a href="https://developer.garmin.com/connect-iq/api-docs/Toybox/Communications.html">Toybox.Communications</a> module.</p>
<h4>Checking Permissions</h4>
<p>In the firmware, I found the following function that checks the permissions. Its pseudo-code looks as follows:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula">uint prg_tvm_has_permission(s_tvm_ctx *ctx, int module_id, byte *out_bool) {
    // For each module ID in the permissions section
        // Is it equal to requested module ID?
            // If yes, then we return true as in authorized
            // If no, we check the next ID in the section
    // No match found, we return false as in unauthorized
}

</pre>
<p>The first thing that stood out in this function was the following edge case handled early on:</p>
<pre data-enlighter-language="c" data-enlighter-theme="dracula">// [...]
bVar1 = module_id == module_Toybox_SensorHistory;
*out_bool = 0
if ((bVar1) &amp;&amp; (ctx-&gt;version &lt; VERSION_2.3.0)) {
    *out_bool = 1;
    return 0;
}
// [...]

</pre>
<p>Tracing the <code>version</code> attribute, I realized that it comes from the version specified in the PRG&#39;s head section. We can tamper with the head section to specify a lower version than 2.3.0 and be automatically granted access to the <a href="https://developer.garmin.com/connect-iq/api-docs/Toybox/SensorHistory.html">Toybox.SensorHistory</a> module. This module provides access to information such as heart rate, elevation, pressure, stress level, among others.</p>
<p>Up to this point, I was not sure when the <code>prg_tvm_has_permission</code> function was called. Digging further, I noted that it was referenced by the following opcodes:</p>
<ul>
<li>
<code>getm</code> to resolve a module</li>
<li>
<code>getv</code> to retrieve an attribute from a module</li>
<li>
<code>putv</code> to update an attribute from a module</li>
</ul>
<p>The <code>prg_tvm_has_permission</code> receives the module ID of the module that is either being resolved (with <code>getm</code>) or referenced when reading/writing an attribute (with <code>getv</code>/<code>putv</code>).</p>
<p>Unfortunately, we cannot tamper with that module ID since it is parsed directly from the class definitions in the SDK data section, stored in the firmware. Based on testing, attempting to inherit from a privileged module will not work either.</p>
<h4>Class and Field Definitions</h4>
<p>If you recall the class definition highlighted earlier when resolving symbols, it contains high-level information, such as the parent module ID (if any) and the application types, among others. It also contains a list of field definitions, corresponding to every field defined by the class.</p>
<p>Modules are defined as class definitions in the data section. This is the case for both the modules provided by the SDK and the modules that are created (under the hood) when writing a PRG application.</p>
<p>A field definition can be any MonkeyC type (as listed early on in this blog post) up to type 15 (double) due to how the type is <code>AND</code>ed with <code>0xf</code> when TVM parses it. This includes integers, strings, other class definitions and methods, among others. It cannot be a primitive module (type 17) or a system pointer (type 18) for instance.</p>
<figure id="attachment_3976" aria-describedby="caption-attachment-3976"><img decoding="async" alt="" width="477" height="429" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Class-definition-in-our-PRG-file.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3976">Class definition in our PRG file.</figcaption></figure>
<p>In the class definition shown above, we can see that the first field definition is a method (type 6), whose symbol is <code>0xD</code> and its value <code>0x100000D5</code>. If you recall string definitions from earlier, you understand that <code>0x100000D5</code> means it is found at offset <code>0xD5</code> in the code section of the PRG file.</p>
<p>When calling the method <code>0xD</code>, TVM will parse the class definition, then its field definitions, until it finds a match for that symbol value. In our case it will find <code>0x100000D5</code>, translate it to the offset in the correct section (here the PRG code section) and redirect execution there. I am simplifying but that is the gist of it.</p>
<p>Now you may be wondering: what if we updated our field definition value to point inside the SDK section instead? For instance, what if we were to do the following:</p>
<figure id="attachment_3984" aria-describedby="caption-attachment-3984"><img decoding="async" alt="" width="458" height="428" data-src="https://www.anvilsecure.com/wp-content/uploads/2023/04/Updated-class-definition.png" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/>
<figcaption id="caption-attachment-3984">Updated class definition with its method pointing to a native function.</figcaption></figure>
<p>In the updated field definition, we changed <code>0x100000D5</code> to <code>0x40040033</code>. If you recall, this is supposed to represent a native function (<code>0x40</code>) that takes 4 parameters (<code>0x04</code>) and is at offset <code>0x33</code> in the callbacks table (the <code>0x40040033</code> value is specific to my firmware version). This native function is in fact <a href="https://developer.garmin.com/connect-iq/api-docs/Toybox/Communications.html#openWebPage-instance_function">Toybox.Communications.openWebPage</a>, which is supposed to require permissions since it is inside the privileged <code>Toybox.Communications</code> module.</p>
<p>Now, when TVM checks for permissions, it will end up checking our module ID, meaning checking whether the class definition of our module requires permissions. Since it does not, it will happily let you call the method <code>0xD</code>, which ends up calling the <code>openWebPage</code> native function.</p>
<p>This can be generalized further: we could embed a full copy of the SDK in our PRG file! We would need to fix various offsets and clear the permission flags. Then, we could use any and all modules, even with an empty permissions section.</p>
<p>This effectively completely bypasses Garmin&#39;s permissions check.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this blog post, I retraced my steps looking at the Garmin Forerunner 245 Music watch. We focused on Garmin applications that can be developed using MonkeyC and run on the device.</p>
<p>We analyzed how the GarminOS TVM runs the apps, focusing on PRG parsing, native functions and permissions. We found bugs during our journey that allow escaping the VM layer and compromise the watch. We also found how we could bypass the Garmin permissions and call any functions, regardless of our app&#39;s permissions. I have compiled various scripts and proof-of-concepts to a <a href="https://github.com/anvilsecure/garmin-ciq-app-research">GitHub repository</a>.</p>
<p>Some of the vulnerabilities such as <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23299">CVE-2023-23299</a> were introduced in the first version of the CIQ API (1.0.0), published in 2015. They affect over one hundred Garmin devices, including fitness watches, outdoor handhelds and GPS for bikes.</p>
<h3 id="future-research-ideas">Future Research Ideas</h3>
<p>There are many areas that have not been looked at on Garmin watches (as far as public research shows). We already mentioned the signature validation earlier in this blog post but we also have:</p>
<ul>
<li>The Ant and Ant+ stack, used by the watch to communicate with external sensors (e.g. a heart-rate monitor or running pods)</li>
<li>The Bluetooth Low Energy (BLE) stack, also used with sensors, as well as when the watch communicates with the smartphone (to send data to the Garmin Connect mobile application for instance)</li>
<li>Some devices also have a Wi-Fi module</li>
<li>The USB stack, when connecting the device to a computer to copy files</li>
<li>The filesystem exposed by the device via USB</li>
</ul>
<p>It would be interesting to know if there are bugs in the protocol stacks, if it is possible to hijack an Ant (or BLE or Wi-Fi) connection for instance and feed malicious data from there. And if the firmware also improperly processes the data received from those protocols.</p>
<p>In addition, the watch can show notifications received on the phone. It could be interesting to understand how those notifications are handled, and if a malicious notification could exploit the watch (e.g. a string format vulnerability when displaying the notification message).</p>
<p>An aspect I did not cover either is per-application storage. Applications have a dedicated storage for saving preferences and other options. It could be interesting to understand how it is implemented, and if it is possible for a malicious application to access and manipulate data stored by another application.</p>
<p>Atredis mentioned trying to patch QEMU to run the watch firmware. I personally did not attempt to perform dynamic analysis, like fuzzing, but this is something that would more than likely help reveal more bugs.</p>
<p>One thing is for sure in my opinion: we only skimmed the surface.</p>
<h3 id="responsible-disclosure-timeline">Responsible Disclosure Timeline</h3>
<ul>
<li>2022-07-25: Anvil submitted the technical report to Garmin via their <a href="https://www.garmin.com/en-US/forms/report-a-security-issue/">web form</a> along with our 90-day disclosure policy.</li>
<li>2022-09-11: Garmin acknowledges the vulnerabilities and requests an extension until December 3rd, 2022. We agree.</li>
<li>2022-10-14: Anvil submitted a second technical report regarding the permission bypass.</li>
<li>2022-11-09: Garmin states that they are on track for December 3rd, 2022 for the initial findings. Garmin acknowledges the permission bypass and requests an extension until February 28th, 2023. We agree.</li>
<li>2022-12-01: Garmin states that they identified additional affected products and requests a new extension until March 14th, 2023 for all vulnerabilities.</li>
<li>2022-12-06: Anvil agrees on the new deadline and requests the list of affected products.</li>
<li>2022-12-13: Garmin provides the list of affected devices, identified by Connect IQ API version.</li>
<li>2023-01-09: Anvil requests CVE IDs.</li>
<li>2023-01-26: MITRE assigns CVE IDs (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23301">CVE-2023-23301</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23298">CVE-2023-23298</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23304">CVE-2023-23304</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23305">CVE-2023-23305</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23302">CVE-2023-23302</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23303">CVE-2023-23303</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23306">CVE-2023-23306</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23300">CVE-2023-23300</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23299">CVE-2023-23299</a>).</li>
<li>2023-01-27: Anvil shares CVE IDs with Garmin and asks if they are planning to publish a security advisory.</li>
<li>2023-02-01: Garmin states that they are not planning on publishing an advisory listing the CVEs.</li>
<li>2023-03-14: Anvil asks Garmin if they have released the new firmware images for the affected devices.</li>
<li>2023-03-16: Garmin states that the majority of the updates have been released. They specify that three devices have been delayed and that they are targeting March 22nd, 2023</li>
</ul>
</div>
</div></div></div></div></div>
  </body>
</html>
