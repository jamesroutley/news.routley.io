<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://derw.substack.com/p/the-case-for-building-something-wonderful">Original</a>
    <h1>The case for building something wonderful alone</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><span>I’ve been building </span><a href="https://www.derw-lang.com/" rel="nofollow ugc noopener">Derw</a><span> alone since sometime last year. Recently, someone asked if I was working on with others - and the answer is no, and it’s kinda intentional.</span></p><p><span>As I touched on in my </span><a href="https://derw.substack.com/p/all-branches-will-diverge-from-the" rel="nofollow ugc noopener">last post</a><span>, the community is something I’m planning to build once I get to 1.0.0. But what about building a team? Languages like </span><a href="https://github.com/roc-lang/roc/graphs/contributors" rel="nofollow ugc noopener">Roc</a><span> managed to build a team even before the repo was public, with several people contributing 100+ commits. I think that’s super cool - and I’m a strong believer in </span><em>making things better by working together</em><span>. That said, there’s benefits to avoiding working with others directly. </span></p><p>Working alone means you don’t have to share the context of your changes with others. It doesn’t mean that you don’t keep track of changes that you have made, nor that you don’t report them. But if there’s a change I wish to make, I can do so without consulting others. This is particularly useful, for example, when I want to rewrite a file from TypeScript to Derw. No collisions with other PRs, no need to warn anyone “hey I’m going to rewrite this file”. </p><p>You’re able to keep to your own schedule, and adjust it as necessary. Everyone has their own priorities, and without waiting for someone to finish something and without someone waiting for you to finish something, you’re able to move at your own pace. End users will have an impact on that timeline, if you listen to them, but when you’re working mostly on your spare time, it’s important to be able to take some days off and go play games instead.</p><p>Work teams go off and have workshops and meetups and parties to discuss their vision for the product they’re working on. In open source projects, you don’t have that luxury. Visions and plans have to be communicated in text, and often falls second place to just working on the vision inside your head. Shared goals have to be established through long conversations and RFCs. Working alone you don’t need that to the same extent: if you intend to have users, you need to tell them roughly what your goals are with a project, but you don’t need to have a back and forth discussion on a feature. You can just build it. That isn’t to say that other people’s visions for your project isn’t useful - nor does it mean that you never need to discuss a feature with someone. But you can do that on demand, as needed, and that makes it easier to execute.</p><p>If one of your goals with a project is simply to learn, when you build something alone, you have to learn all the awkward parts as well as the familiar parts. You might only have used webpack in the past but your project is more suited to esbuild. You’ve never had to interact with garbage collection in Node but to get the performance you want, it becomes relevant. A team can help steer you with their collective knowledge of all these random pieces, but self-learning can work just as well.</p><p>Some view development styles like Elm’s as a flaw, that working in mostly isolation defeats the point of open source. I don’t see it that way: a creator with a strong opinion and direction leads to a purer, more cohesive creation. It might not do everything the community wants, or it might implement things in a way that someone did not prefer. But early on into a library, framework or language’s lifeline, it is especially important to have a driving force, someone who can see where they want to take it - and act on it. Later on, it may make sense to share that load and become a Python-style BDFL. Early on, being pulled in multiple directions can fragment both the vision and the implementation.</p><p>With Derw, I will likely stay working without a core team for a good amount of time - probably past 1.0.0. I can make all the different features like built-in testing, built-in formatting, multiple target languages and package management work in a Derw-like way because I have the context of what I want Derw to be, and how the pieces should fit together. Eventually it will probably make sense to onboard others who can contribute along the line my own vision, but I suspect that will not be possible for a while. I still reach out to people when I have an idea I want to discuss: coworkers, friends, chat, Twitter. These inputs are great, and valuable, and have led to several nice aspects of Derw. But I can take this collective knowledge on a specific feature and implement it myself, and that’s likely the best way for a new language.</p><p><span>Like this post? Follow me on </span><a href="https://twitter.com/derwlang" rel="nofollow ugc noopener">Twitter</a><span> to stay updated, star </span><a href="https://github.com/eeue56/derw" rel="nofollow ugc noopener">Derw</a><span> on Github, or </span><a href="https://github.com/sponsors/eeue56" rel="nofollow ugc noopener">sponsor me on Github</a><span> to help support my work.</span></p></div></div></div></article></div></div></div>
  </body>
</html>
