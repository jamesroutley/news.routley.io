<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukeplant.me.uk/blog/posts/less-powerful-languages/">Original</a>
    <h1>We need less powerful languages (2015)</h1>
    
    <div id="readability-page-1" class="page"><div id="contentinner">
  <article itemscope="" itemtype="http://schema.org/BlogPosting"><header>
      
      
    </header><section itemprop="articleBody"><div>
        <p>Translations of this post (I can&#39;t vouch for their accuracy):</p>
<ul>
<li><p><a href="http://postd.cc/less-powerful-languages/">Japanese</a></p></li>
</ul>
<hr/>
<p>Many systems boast of being ‘powerful’, and it sounds difficult to argue that
this is a bad thing. Almost everyone who uses the word assumes that it is always
a good thing.</p>
<p>The thesis of this post is that in many cases we need <strong>less powerful</strong>
languages and systems.</p>
<p>Before I get going, there is very little original insight in this
post. The train of thought behind it was set off by
reading Hofstadter’s book <a href="https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">Gödel, Escher, Bach — an Eternal Golden Braid</a> which helped me pull
together various things in my own thinking where I’ve seen the principle in
action. Philip Wadler’s post on <a href="http://wadler.blogspot.co.uk/2006/03/rule-of-least-power.html">the rule of least power</a> was also
formative, and most of all I’ve also taken a lot from the content of <a href="https://www.youtube.com/watch?v=TS1lpKBMkgg&amp;t=28m32s">this video
from a Scala conference about everything that is wrong with Scala</a>, which makes the
following fairly central point:</p>
<blockquote>
<p>Every increase in expressiveness brings an increased burden on all who care
to understand the message.</p>
</blockquote>
<p>My aim is simply to illustrate this point using examples that might be more
accessible to the Python community than the internals of a Scala compiler.</p>
<p>I also need a word about definitions. What do we mean by “more powerful” or
“less powerful” languages? In this article, I mean something roughly like this:
“the freedom and ability to do whatever you want to do”, seen mainly from the
perspective of the human author entering data or code into the system. This
roughly aligns with the concept of “expressiveness”, though not perhaps with a
formal definition. (More formally, many languages have equivalent expressiveness
in that they are all Turing complete, but we still recognise that some are more
powerful in that they allow a certain outcome to be produced with fewer words or
in multiple ways, with greater freedoms for the author).</p>
<p>The problem with this kind of freedom is that every bit of power you insist on
having when writing in the language corresponds to power you must give up at other
points of the process — when ‘consuming’ what you have written. I’ll illustrate
this with various examples which range beyond what might be described as
programming, but have the same principle at heart.</p>
<p>We’ll also need to ask “Does this matter?” It matters, of course, to the extent
that you need to be able to ‘consume’ a message you have put in. Different
players who might ‘consume’ the message are software maintainers, compilers and
other development tools, which means you almost always care — this has
implications both for performance and correctness as well as human concerns.</p>
<section id="databases-and-schema"><h2>Databases and schema</h2>
<p>Starting at the low end of the scale in terms of expressiveness, there is what
you might call data rather than language. But both “data” and “language” can be
thought of as “messages to be received by someone”, and the principle applies
to both.</p>
<p>In my years of software development, I’ve found that clients and users often ask
for “free text” fields, often for “notes”. A free text field is maximally
powerfully as far as the end user is concerned — they can put whatever they like
in. In this sense, this is the “most useful” field — you can use it for
anything.</p>
<p>But precisely because of this, it is also the least useful, because it is the
least structured. Even search doesn’t work reliably because of typos and
alternative ways of expressing the same thing. The longer I do software
development involving databases, the more I want to tightly constrain everything
as much as possible. When I do so, the data I end up with is massively more
useful. I can do powerful things when consuming the data only when I severely
limit the power (i.e. the freedom) of the agents putting data into the system.</p>
<p>In terms of database technologies, the same point can be made. Databases that
are “schema-less” give you great flexibility and power when putting data in, and
are extremely unhelpful when getting it out. A key-value store is a more
technical version of “free text”, with the same drawbacks — it is pretty
unhelpful when you want to extract info or do anything with the data, since you
cannot guarantee that any specific keys will be there.</p>
</section><section id="html"><h2>HTML</h2>
<p>The success of the web has been partly due to the fact that some of the core
technologies, HTML and CSS, have been deliberately limited in power. Indeed,
you probably wouldn’t call them programming languages, but markup languages.
This, however, was not an accident, but a <a href="http://www.w3.org/DesignIssues/Principles.html#PLP">deliberate design principle</a> on the part of Tim
Berners Lee. I can’t do better than to quote that page at length:</p>
<blockquote>
<p>Computer Science in the 1960s to 80s spent a lot of effort making languages
which were as powerful as possible. Nowadays we have to appreciate the
reasons for picking not the most powerful solution but the least powerful.
The reason for this is that the less powerful the language, the more you can
do with the data stored in that language. If you write it in a simple
declarative form, anyone can write a program to analyze it in many ways. The
Semantic Web is an attempt, largely, to map large quantities of existing
data onto a common language so that the data can be analyzed in ways never
dreamed of by its creators. If, for example, a web page with weather data
has RDF describing that data, a user can retrieve it as a table, perhaps
average it, plot it, deduce things from it in combination with other
information. At the other end of the scale is the weather information
portrayed by the cunning Java applet. While this might allow a very cool
user interface, it cannot be analyzed at all. The search engine finding the
page will have no idea of what the data is or what it is about. This the
only way to find out what a Java applet means is to set it running in front
of a person.</p>
</blockquote>
<p>This is has become a <a href="http://www.w3.org/2001/tag/doc/leastPower-2006-02-23.html">W3C principle</a>:</p>
<blockquote>
<p>Good Practice: Use the least powerful language suitable for expressing
information, constraints or programs on the World Wide Web.</p>
</blockquote>
<p>Note that this is almost exactly the opposite of <a href="http://www.paulgraham.com/avg.html">Paul Graham’s advice</a> (with the caveat that ‘power’ is often
too informally defined to compare):</p>
<blockquote>
<p>if you have a choice of several languages, it is, all other things being
equal, a mistake to program in anything but the most powerful one.</p>
</blockquote>
</section><section id="python-setup-py-manifest-in-file"><h2>Python setup.py MANIFEST.in file</h2>
<p>Moving up towards ‘proper’ programming language, I came across this example —
the MANIFEST.in file format used by distutils/setuptools. If you have had to
create a package for a Python library, you may well have used it.</p>
<p>The file format is essentially a very small language for defining what files
should be included in your Python package (relative to the MANIFEST.in file,
which we’ll call the working directory from now on). It might look something
like this:</p>
<pre>include README.rst
recursive-include foo *.py
recursive-include tests *
global-exclude *~
global-exclude *.pyc
prune .DS_Store</pre>
<p>There are two types of directive: <code>include</code> type directives (<code>include</code>,
<code><span>recursive-include</span></code>, <code><span>global-include</span></code> and <code>graft</code>), and <code>exclude</code> type
directives (<code>exclude</code>, <code><span>recursive-exclude</span></code>, <code><span>global-exclude</span></code> and
<code>prune</code>).</p>
<p>There comes a question — how are these directives to be interpreted (i.e. what
are the semantics)?</p>
<p>You could interpret them in this way:</p>
<blockquote>
<p>A file from the working directory (or sub-directories) should be included in
the package if it matches at least one <code>include</code> type directive, and does
not match any <code>exclude</code> type directive.</p>
</blockquote>
<p>This would make it a declarative language.</p>
<p>Unfortunately, that is not how the language is defined. The <a href="https://docs.python.org/2/distutils/sourcedist.html#manifest-template">distutils docs for
MANIFEST.in</a> are
specific about this — the directives are to be understood as follows (my
paraphrase):</p>
<ol>
<li><p>Start with an empty list of files to include in the package (or technically,
a default list of files).</p></li>
<li><p>Go down the directives in the MANIFEST.in <strong>in order</strong>.</p></li>
<li><p>For every <code>include</code> type directive, copy any matching
files from the working directory to the list for the package.</p></li>
<li><p>For every <code>exclude</code> type directive, remove any matching
files from the list for the package.</p></li>
</ol>
<p>As you can see, this interpretation defines a language that is imperative in
nature — each line of MANIFEST.in is a command that implies an action with side
effects.</p>
<p>The point to note is that this makes the language <strong>more powerful</strong> than my
speculative declarative version above. For example, consider the following:</p>
<pre>recursive-include foo *
recursive-exclude foo/bar *
recursive-include foo *.png</pre>
<p>The end result of the above commands is that <code>.png</code> files that are below
<code>foo/bar</code> are included, but all other files below <code>foo/bar</code> are not. If I’m
thinking straight, to replicate the same result using the declarative language
is harder — you would have to do something like the following, which is
obviously sub-optimal:</p>
<pre>recursive-include foo *
recursive-exclude foo/bar *.txt *.rst *.gif *.jpeg *.py ...</pre>
<p>So, because the imperative language is more powerful, there is a temptation to
prefer that one. However, the imperative version comes with significant
drawbacks:</p>
<ol>
<li>
<p>It is much harder to optimise.</p>
<p>When it comes to interpreting the MANFIEST.in and building a list of files to
include in the package, one fairly efficient solution for a typical case is
to first build an immutable list of all files in the directory and its
sub-directories, and then apply the rules: addition rules involve copying
from the full list to an output list, and subtraction rules involve removing
from the output list. This is how the Python implementation currently does
it.</p>
<p>This works OK, unless you have many thousands of files in the full list, most
of which are going to get pruned or not included, in which case you can spend
a lot of time building up the full list, only to ignore most of it.</p>
<p>An obvious shortcut is to not recurse into directories that would be
excluded by some exclude directive. However, you can only do that if the
exclude directives come after all include directives.</p>
<p>This is not a theoretical problem — I’ve found that doing <code>setup.py sdist</code>
and other commands can take 10 minutes to run, due to a large number of files
in the working directory if you use the tool <a href="https://pypi.python.org/pypi/tox">tox</a> for instance. This means that runs of
<code>tox</code> itself (which uses <code>setup.py</code>) become very slow. I am currently
attempting to <a href="https://github.com/pypa/setuptools/issues/450">fix this issue</a>,
but it is looking like it will be really hard.</p>
<p>Adding the optimised case might not look that hard (you can shortcut the file
system traversal using any exclude directives that come after all include
directives), but it adds sufficiently to the complexity that a patch is
unlikely to be accepted — it increases the number of code paths and the
chances of mistakes, to the point of it not being worth it.</p>
<p>It might be that the only practical solution is to avoid MANIFEST.in
altogether and optimise only the case when it is completely empty.</p>
</li>
<li>
<p>The power has a second cost — MANIFEST.in files are harder to understand.</p>
<p>First, in understanding how the language works — the docs for this are
considerably longer than for the declarative version I imagined.</p>
<p>Second, in analysing a specific MANIFEST.in file — you have to execute the
commands in your head in order to work out what the result will be, rather
than being able to take each line on its own, or in any order that makes
sense to you.</p>
<p>This actually results in packaging bugs. For instance, it would be easy to believe
that a directive like:</p>
<pre>global-exclude *~</pre>
<p>at the top of a MANIFEST.in file would result in any file name ending in
<code>~</code> (temporary files created by some editors) being excluded from the
package. In reality it does nothing at all, and the files will be erroneously
included if other commands include them.</p>
<p>Examples I’ve found of this mistake (<code>exclude</code> directives that don’t
function as intended or are useless) include:</p>
<ul>
<li><p><a href="http://hg.logilab.org/master/hgview/file/fe00511ad0ad/MANIFEST.in">hgview</a> (exclude directives at the top do nothing)</p></li>
<li><p><a href="https://github.com/pinax/django-mailer/blob/db4aed00e13d9058f1b4b13e50bf7b6488e6cb47/MANIFEST.in">django-mailer</a> (global-exclude at the top does nothing)</p></li>
</ul>
</li>
<li><p>Another result is that you cannot groups lines in the MANIFEST.in file in any
way you please, for clarity, since re-ordering changes the meaning of the
file.</p></li>
</ol>
<p>In addition, virtually no-one will actually use the additional power. I’m
willing to bet that 99.99% MANIFEST.in files do not make use of the additional
power of the imperative language (I downloaded 250 and haven’t found any that
do). So we could have been served much better by a declarative language here
instead of an imperative one. But backwards compatibility forces us to stick
with this. That highlights another point — it is often possible to add features
to a language to make it more powerful, but compatibility concerns usually don’t
allow you to make it less powerful, for example by removing features or adding
constraints.</p>
</section><section id="url-reversing"><h2>URL reversing</h2>
<p>One core piece of the <a href="https://www.djangoproject.com/">Django</a> web framework
is URL routing. This is the component that parses URLs and dispatches them to
the handler for that URL, possibly passing some components extracted from the
URL.</p>
<p>In Django, this is done using regular expressions. For an app that displays
information about kittens, you might have a <code>kittens/urls.py</code> with the following:</p>
<div><pre><a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-1" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-1" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-1"></a><span>from</span> <span>django.conf.urls</span> <span>import</span> <span>url</span>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-2" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-2" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-2"></a>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-3" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-3" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-3"></a><span>from</span> <span>kittens</span> <span>import</span> <span>views</span>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-4" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-4" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-4"></a>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-5" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-5" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-5"></a><span>urlpatterns</span> <span>=</span> <span>[</span>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-6" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-6" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-6"></a>    <span>url</span><span>(</span><span>r</span><span>&#39;^kittens/$&#39;</span><span>,</span> <span>views</span><span>.</span><span>list_kittens</span><span>,</span> <span>name</span><span>=</span><span>&#34;kittens_list_kittens&#34;</span><span>),</span>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-7" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-7" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-7"></a>    <span>url</span><span>(</span><span>r</span><span>&#39;^kittens/(?P&lt;id&gt;\d+)/$&#39;</span><span>,</span> <span>views</span><span>.</span><span>show_kitten</span><span>,</span> <span>name</span><span>=</span><span>&#34;kittens_show_kitten&#34;</span><span>),</span>
<a id="rest_code_5028c5d294174bf8b5e70829ce022f3a-8" name="rest_code_5028c5d294174bf8b5e70829ce022f3a-8" href="#rest_code_5028c5d294174bf8b5e70829ce022f3a-8"></a><span>]</span>
</pre></div>
<p>The corresponding <code>views.py</code> file looks like:</p>
<div><pre><a id="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-1" name="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-1" href="#rest_code_7bbef86cb1964f1b8107db68cf27fbe7-1"></a><span>def</span> <span>list_kittens</span><span>(</span><span>request</span><span>):</span>
<a id="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-2" name="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-2" href="#rest_code_7bbef86cb1964f1b8107db68cf27fbe7-2"></a>    <span># ...</span>
<a id="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-3" name="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-3" href="#rest_code_7bbef86cb1964f1b8107db68cf27fbe7-3"></a>
<a id="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-4" name="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-4" href="#rest_code_7bbef86cb1964f1b8107db68cf27fbe7-4"></a><span>def</span> <span>show_kitten</span><span>(</span><span>request</span><span>,</span> <span>id</span><span>):</span>
<a id="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-5" name="rest_code_7bbef86cb1964f1b8107db68cf27fbe7-5" href="#rest_code_7bbef86cb1964f1b8107db68cf27fbe7-5"></a>    <span># ...</span>
</pre></div>
<p>Regular expressions have a capture facility built in, which is used to capture
parameters that are passed to the view functions. So, for example, if this app
were running on cuteness.com, a URL like <code><span>http://www.cuteness.com/kittens/23/</span></code>
results in calling the Python code <code>show_kitten(request, <span>id=&#34;23&#34;)</span></code>.</p>
<p>Now, as well as being able to route URLs to specific functions, web apps almost
always need to generate URLs. For example, the kitten list page will need to
include links to the individual kitten page i.e. <code>show_kitten</code>. Obviously we
would like to do this in a DRY way, re-using the URL routing configuration.</p>
<p>However, we would be using the URL routing configuration in the opposite
direction. When doing URL routing, we are doing:</p>
<pre>URL path -&gt; (handler function, arguments)</pre>
<p>In URL generation, we know the handler function and arguments we want the user
to arrive at, and want to generate a URL that will take the user there, <strong>after
going through the URL routing</strong>:</p>
<pre>(handler function, arguments) -&gt; URL path</pre>
<p>In order to do this, we essentially have to predict the behaviour of the URL
routing mechanism. We are asking “given a certain output, what is the input?”</p>
<p>In the very early days Django did not include this facility, but it was <a href="https://groups.google.com/d/msg/django-developers/pdErxPsHPyQ/kAzz0mwqddwJ">found</a>
that with most URLs, it was possible to &#39;reverse&#39; the URL pattern. The regex can
be parsed looking for the static elements and the capture elements.</p>
<p>Note, first of all, that this is only possible at all because the language being
used to define URL routes is a limited one — regular expressions. We could
easily have defined URL routes using a more powerful language. For example, we could
have defined them using functions that:</p>
<ul>
<li><p>take a URL path as input</p></li>
<li><p>raise NoMatch if they do not match</p></li>
<li><p>return a truncated URL and an optional set of captures if they do match.</p></li>
</ul>
<p>Our kittens urls.py would look like something like this:</p>
<div><pre><a id="rest_code_3d6d77136963445298ff1f69b607e088-1" name="rest_code_3d6d77136963445298ff1f69b607e088-1" href="#rest_code_3d6d77136963445298ff1f69b607e088-1"></a><span>from</span> <span>django.conf.urls</span> <span>import</span> <span>url</span><span>,</span> <span>NoMatch</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-2" name="rest_code_3d6d77136963445298ff1f69b607e088-2" href="#rest_code_3d6d77136963445298ff1f69b607e088-2"></a>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-3" name="rest_code_3d6d77136963445298ff1f69b607e088-3" href="#rest_code_3d6d77136963445298ff1f69b607e088-3"></a><span>def</span> <span>match_kitten</span><span>(</span><span>path</span><span>):</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-4" name="rest_code_3d6d77136963445298ff1f69b607e088-4" href="#rest_code_3d6d77136963445298ff1f69b607e088-4"></a>    <span>KITTEN</span> <span>=</span> <span>&#39;kitten/&#39;</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-5" name="rest_code_3d6d77136963445298ff1f69b607e088-5" href="#rest_code_3d6d77136963445298ff1f69b607e088-5"></a>    <span>if</span> <span>path</span><span>.</span><span>startswith</span><span>(</span><span>KITTEN</span><span>):</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-6" name="rest_code_3d6d77136963445298ff1f69b607e088-6" href="#rest_code_3d6d77136963445298ff1f69b607e088-6"></a>        <span>return</span> <span>path</span><span>[</span><span>len</span><span>(</span><span>KITTEN</span><span>):],</span> <span>{}</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-7" name="rest_code_3d6d77136963445298ff1f69b607e088-7" href="#rest_code_3d6d77136963445298ff1f69b607e088-7"></a>    <span>raise</span> <span>NoMatch</span><span>()</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-8" name="rest_code_3d6d77136963445298ff1f69b607e088-8" href="#rest_code_3d6d77136963445298ff1f69b607e088-8"></a>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-9" name="rest_code_3d6d77136963445298ff1f69b607e088-9" href="#rest_code_3d6d77136963445298ff1f69b607e088-9"></a><span>def</span> <span>capture_id</span><span>(</span><span>path</span><span>):</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-10" name="rest_code_3d6d77136963445298ff1f69b607e088-10" href="#rest_code_3d6d77136963445298ff1f69b607e088-10"></a>    <span>part</span> <span>=</span> <span>path</span><span>.</span><span>split</span><span>(</span><span>&#39;/&#39;</span><span>)[</span><span>0</span><span>]</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-11" name="rest_code_3d6d77136963445298ff1f69b607e088-11" href="#rest_code_3d6d77136963445298ff1f69b607e088-11"></a>    <span>try</span><span>:</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-12" name="rest_code_3d6d77136963445298ff1f69b607e088-12" href="#rest_code_3d6d77136963445298ff1f69b607e088-12"></a>        <span>id</span> <span>=</span> <span>int</span><span>(</span><span>part</span><span>)</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-13" name="rest_code_3d6d77136963445298ff1f69b607e088-13" href="#rest_code_3d6d77136963445298ff1f69b607e088-13"></a>    <span>except</span> <span>ValueError</span><span>:</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-14" name="rest_code_3d6d77136963445298ff1f69b607e088-14" href="#rest_code_3d6d77136963445298ff1f69b607e088-14"></a>        <span>raise</span> <span>NoMatch</span><span>()</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-15" name="rest_code_3d6d77136963445298ff1f69b607e088-15" href="#rest_code_3d6d77136963445298ff1f69b607e088-15"></a>    <span>return</span> <span>path</span><span>[</span><span>len</span><span>(</span><span>part</span><span>)</span><span>+</span><span>1</span><span>:],</span> <span>{</span><span>&#39;id&#39;</span><span>:</span> <span>id</span><span>}</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-16" name="rest_code_3d6d77136963445298ff1f69b607e088-16" href="#rest_code_3d6d77136963445298ff1f69b607e088-16"></a>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-17" name="rest_code_3d6d77136963445298ff1f69b607e088-17" href="#rest_code_3d6d77136963445298ff1f69b607e088-17"></a><span>urlpatterns</span> <span>=</span> <span>[</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-18" name="rest_code_3d6d77136963445298ff1f69b607e088-18" href="#rest_code_3d6d77136963445298ff1f69b607e088-18"></a>    <span>url</span><span>([</span><span>match_kitten</span><span>],</span> <span>views</span><span>.</span><span>list_kittens</span><span>,</span> <span>name</span><span>=</span><span>&#39;kittens_list_kittens&#39;</span><span>),</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-19" name="rest_code_3d6d77136963445298ff1f69b607e088-19" href="#rest_code_3d6d77136963445298ff1f69b607e088-19"></a>    <span>url</span><span>([</span><span>match_kitten</span><span>,</span> <span>capture_id</span><span>],</span> <span>views</span><span>.</span><span>show_kitten</span><span>,</span> <span>name</span><span>=</span><span>&#34;kittens_show_kitten&#34;</span><span>),</span>
<a id="rest_code_3d6d77136963445298ff1f69b607e088-20" name="rest_code_3d6d77136963445298ff1f69b607e088-20" href="#rest_code_3d6d77136963445298ff1f69b607e088-20"></a><span>]</span>
</pre></div>
<p>Of course, we could provide helpers that make things like <code>match_kitten</code> and
<code>capture_id</code> much more concise:</p>
<div><pre><a id="rest_code_2aa29bf5fff848a4a33adb032506e665-1" name="rest_code_2aa29bf5fff848a4a33adb032506e665-1" href="#rest_code_2aa29bf5fff848a4a33adb032506e665-1"></a><span>from</span> <span>django.conf.urls</span> <span>import</span> <span>url</span><span>,</span> <span>m</span><span>,</span> <span>c</span>
<a id="rest_code_2aa29bf5fff848a4a33adb032506e665-2" name="rest_code_2aa29bf5fff848a4a33adb032506e665-2" href="#rest_code_2aa29bf5fff848a4a33adb032506e665-2"></a>
<a id="rest_code_2aa29bf5fff848a4a33adb032506e665-3" name="rest_code_2aa29bf5fff848a4a33adb032506e665-3" href="#rest_code_2aa29bf5fff848a4a33adb032506e665-3"></a><span>urlpatterns</span> <span>=</span> <span>[</span>
<a id="rest_code_2aa29bf5fff848a4a33adb032506e665-4" name="rest_code_2aa29bf5fff848a4a33adb032506e665-4" href="#rest_code_2aa29bf5fff848a4a33adb032506e665-4"></a>    <span>url</span><span>([</span><span>m</span><span>(</span><span>&#39;kitten/&#39;</span><span>),</span> <span>views</span><span>.</span><span>list_kittens</span><span>,</span> <span>name</span><span>=</span><span>&#39;kittens_list_kittens&#39;</span><span>),</span>
<a id="rest_code_2aa29bf5fff848a4a33adb032506e665-5" name="rest_code_2aa29bf5fff848a4a33adb032506e665-5" href="#rest_code_2aa29bf5fff848a4a33adb032506e665-5"></a>    <span>url</span><span>([</span><span>m</span><span>(</span><span>&#39;kitten/&#39;</span><span>),</span> <span>c</span><span>(</span><span>id</span><span>=</span><span>int</span><span>)],</span> <span>views</span><span>.</span><span>show_kitten</span><span>,</span> <span>name</span><span>=</span><span>&#34;kittens_show_kitten&#34;</span><span>),</span>
<a id="rest_code_2aa29bf5fff848a4a33adb032506e665-6" name="rest_code_2aa29bf5fff848a4a33adb032506e665-6" href="#rest_code_2aa29bf5fff848a4a33adb032506e665-6"></a><span>]</span>
</pre></div>
<p>Now, this language for URL routing is actually a lot more powerful than our
regex based one, assuming that <code>m</code> and <code>c</code> are returning functions as above.
The interface for matching and capturing is not limited to the capabilities of
regexes — for instance, we could do database lookups for the IDs, or many other
things.</p>
<p>The downside, however, is that URL reversing would be entirely impossible. For
general, Turing complete languages, you cannot ask “given this output, what is
the input?”. We could potentially inspect the source code of the function and
look for known patterns, but it quickly becomes totally impractical.</p>
<p>With regular expressions, however, the limited nature of the language gives us
more options. In general, URL configuration based on regexes is not reversible —
a regex as simple as <code>.</code> cannot be reversed uniquely. (Since we want to
generate canonical URLs normally, a unique solution is important. As it happens,
for this wild card, Django currently picks an arbitrary character, but other
wild cards are not supported). But as long as wild cards of any sort are only
found within capture groups (and possibly some other constraints), the regex can
be reversed.</p>
<p>So, if we want to be able to reliably reverse the URL routes, we actually want a
language less powerful than regular expressions. Regular expressions were
presumably chosen because they were powerful enough, without realising that they
were too powerful.</p>
<p>Additionally, in Python defining mini-languages for this kind of thing is quite
hard, and requires a fair amount of boilerplate and verbosity both for
implementation and usage — much more than when using a string based language
like regexes. In languages like Haskell, relatively simple features like easy
definitions of algebraic data types and pattern matching make these things much
easier.</p>
</section><section id="regular-expressions"><h2>Regular expressions</h2>
<p>The mention of regexes as used in Django’s URL routing reminds me of another
problem:</p>
<p>Many usages of regexes are relatively simple, but whenever you invoke a regex,
you get the full power whether you need it or not. One consequence is that for
some regular expressions, the need to do backtracking to find all possible
matches means that it is possible to construct malicious input that takes a huge
amount of time to be processed by the regex implementation.</p>
<p>This has been the cause of a <a href="http://en.wikipedia.org/wiki/ReDoS">whole class of Denial Of Service vulnerabilities
in many web sites and services</a>, including
one in Django due to an accidentally &#39;evil&#39; regex in the URL validator —
<a href="https://www.djangoproject.com/weblog/2015/jul/08/security-releases/">CVE-2015-5145</a> (and one
that <a href="http://stackstatus.net/post/147710624694/outage-postmortem-july-20-2016">took down the whole of Stack Exchange</a> -
update 2016-07-22).</p>
<p>A less powerful string matching language wouldn’t have these problems.</p>
</section><section id="django-templates-vs-jinja-templates"><h2>Django templates vs Jinja templates</h2>
<p>The <a href="http://jinja.pocoo.org/">Jinja template engine</a> was inspired by the
<a href="https://docs.djangoproject.com/en/dev/topics/templates/#the-django-template-language">Django template language</a>,
but with some differences in philosophy and syntax.</p>
<p>One major advantage of Jinja2 over Django is that of <a href="https://docs.djangoproject.com/en/1.8/topics/performance/#alternatives-to-django-s-template-language">performance</a>.
Jinja2 has an implementation strategy which is to compile to Python code, rather
than run an interpreter written in Python, which is how Django works, and this
results in a big performance increase — <a href="https://tomforb.es/just-how-slow-are-django-templates">often 5 to 20 times</a>. (YMMV etc.)</p>
<p>Armin Ronacher, the author of Jinja, <a href="https://groups.google.com/forum/#!topic/django-developers/cQWfKuX5byk/discussion">attempted</a>
to use the same strategy to speed up Django template rendering. There were
problems, however.</p>
<p>The first he knew about when he <a href="https://groups.google.com/d/msg/django-developers/amUQgS4QvOM/OusiikZSc4cJ">proposed</a>
the project — namely that the extension API in Django makes the approach taken
in Jinja very difficult. Django allows custom template tags that have <a href="https://docs.djangoproject.com/en/dev/howto/custom-template-tags/#advanced-custom-template-tags">almost
complete control</a>
over the compilation and rendering steps. This allows some powerful custom
template tags like <a href="http://ojii.ch/post/why-sekizai/">addtoblock in django-sekizai that seems impossible</a> at first glance. However, if a slower
fallback was provided for these less common situations, a fast implementation
might still have been useful.</p>
<p>However, there is another key difference that affects a lot of templates, which
is that the context object that is passed in (which holds the data needed by the
template) is writable within the template rendering process in Django.
Template tags are able to assign to the context, and in fact some built-in
template tags like <a href="https://docs.djangoproject.com/en/dev/ref/templates/builtins/#url">url</a> do just
that.</p>
<p>The result of this is a <a href="https://www.youtube.com/watch?v=jXlR0Icvvh8&amp;t=19m3s">key part of the compilation to Python that happens in Jinja is impossible in Django</a>.</p>
<p>Notice that in both of these, it is the power of Django’s template engine that
is the problem — it allows code <strong>authors</strong> to do things that are not possible
in Jinja2. However, the result is that a very large obstacle is placed in the
way of attempts to compile to fast code.</p>
<p>This is not a theoretical consideration. At some point, performance of template
rendering becomes an issue for many projects, and <a href="http://insidenextstop.tumblr.com/post/425648605/real-world-django-vs-jinja-template-performance">a</a>
<a href="http://askbot.org/en/question/8105/why-does-askbot-use-jinja/">number</a> have
been forced to switch to Jinja because of that. This is far from an optimal
situation!</p>
<p>Often the issues that make optimisation difficult are only clear with the
benefit of hindsight, and it isn’t true to say that simply adding restrictions
to a language is necessarily going to make it easier to optimise. There are
certainly languages which somehow manage to hit a “sour spot” of providing
little to power to either the authors or the consumers!</p>
<p>You might also say that for the Django template designers, allowing the context
object to be writable was the obvious choice because Python data structures are
typically mutable by default. Which brings us to Python...</p>
</section><section id="python"><h2>Python</h2>
<p>There are many ways that we could think about the power of the Python language,
and how it makes life hard for every person and program that wants to make sense
of Python code.</p>
<p>Compilation and performance of Python is an obvious one. The unrestricted
effects that are possible at any point, including writable classes and modules
etc., not only allow authors to do some very useful things, they make it
extremely difficult to execute Python code quickly. <a href="http://pypy.org">PyPy</a>
has made some impressive progress, but looking at the <a href="http://speed.pypy.org">curve from PyPy 1.3
onward</a>, which shows diminishing returns, makes it
clear that they are unlikely to make much bigger gains in the future. And the
gains that have been made in terms of run time have often been at the expense of
memory usage. There is simply a limit to how well you can optimise Python code.</p>
<p>(Please note, to all who continue reading this — I’m not a Python basher, or a
Django basher for that matter. I’m a core developer of Django, and I use Python
and Django in almost all my professional programming work. The point of this
post is to illustrate the problems caused by powerful languages).</p>
<p>However, rather than focus on the performance problems of Python, I’m going to
talk about refactoring and maintenance. If you do any serious work in a
language, you find yourself doing a lot of maintenance, and being able to do it
quickly and correctly often becomes very important.</p>
<p>So, for example, in Python, and with typical VCS tools (Git or Mercurial, for
instance), if you re-order functions in a module e.g. move a 10 line function to
a different place, you get a 20 line diff, despite the fact that nothing changed
in terms of the meaning of the program. And if something did change (the
function was both moved and modified), it’s going to be very difficult to spot.</p>
<p>This happened to me recently, and set me off thinking just how ridiculously bad
our toolsets are. Why on earth are we treating our highly structured code as a
bunch of lines of text? I can’t believe that we are still programming like this,
it&#39;s insane!</p>
<p>At first, you might think that this could be solved with a <a href="https://www.semanticmerge.com/">more intelligent
diff tool</a>. But the problem is that in
Python, the order in which functions are defined can in fact change the meaning
of a program (i.e. change what happens when you execute it).</p>
<p>Here are a few examples:</p>
<p>Using a previously defined function as a default argument:</p>
<div><pre><a id="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-1" name="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-1" href="#rest_code_fd49fbc5881b46c281f45ab6ab46bc54-1"></a><span>def</span> <span>foo</span><span>():</span>
<a id="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-2" name="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-2" href="#rest_code_fd49fbc5881b46c281f45ab6ab46bc54-2"></a>    <span>pass</span>
<a id="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-3" name="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-3" href="#rest_code_fd49fbc5881b46c281f45ab6ab46bc54-3"></a>
<a id="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-4" name="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-4" href="#rest_code_fd49fbc5881b46c281f45ab6ab46bc54-4"></a><span>def</span> <span>bar</span><span>(</span><span>a</span><span>,</span> <span>callback</span><span>=</span><span>foo</span><span>):</span>
<a id="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-5" name="rest_code_fd49fbc5881b46c281f45ab6ab46bc54-5" href="#rest_code_fd49fbc5881b46c281f45ab6ab46bc54-5"></a>    <span>pass</span>
</pre></div>
<p>These functions can’t be re-ordered or you’ll get a <code>NameError</code> for <code>foo</code> in
the definition of <code>bar</code>.</p>
<p>Using a decorator:</p>
<div><pre><a id="rest_code_c77a853555b44ff9a52a0733023d31f6-1" name="rest_code_c77a853555b44ff9a52a0733023d31f6-1" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-1"></a><span>@decorateit</span>
<a id="rest_code_c77a853555b44ff9a52a0733023d31f6-2" name="rest_code_c77a853555b44ff9a52a0733023d31f6-2" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-2"></a><span>def</span> <span>foo</span><span>():</span>
<a id="rest_code_c77a853555b44ff9a52a0733023d31f6-3" name="rest_code_c77a853555b44ff9a52a0733023d31f6-3" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-3"></a>    <span>pass</span>
<a id="rest_code_c77a853555b44ff9a52a0733023d31f6-4" name="rest_code_c77a853555b44ff9a52a0733023d31f6-4" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-4"></a>
<a id="rest_code_c77a853555b44ff9a52a0733023d31f6-5" name="rest_code_c77a853555b44ff9a52a0733023d31f6-5" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-5"></a><span>@decorateit</span>
<a id="rest_code_c77a853555b44ff9a52a0733023d31f6-6" name="rest_code_c77a853555b44ff9a52a0733023d31f6-6" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-6"></a><span>def</span> <span>bar</span><span>():</span>
<a id="rest_code_c77a853555b44ff9a52a0733023d31f6-7" name="rest_code_c77a853555b44ff9a52a0733023d31f6-7" href="#rest_code_c77a853555b44ff9a52a0733023d31f6-7"></a>    <span>pass</span>
</pre></div>
<p>Due to unrestricted effects that are possible in <code>@decorateit</code>, you can’t
safely re-order these functions and be sure the program will do the same
thing afterwards. Similarly, calling some code in the function argument list:</p>
<div><pre><a id="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-1" name="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-1" href="#rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-1"></a><span>def</span> <span>foo</span><span>(</span><span>x</span><span>=</span><span>Something</span><span>()):</span>
<a id="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-2" name="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-2" href="#rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-2"></a>    <span>pass</span>
<a id="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-3" name="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-3" href="#rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-3"></a>
<a id="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-4" name="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-4" href="#rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-4"></a><span>def</span> <span>bar</span><span>(</span><span>x</span><span>=</span><span>Something</span><span>()):</span>
<a id="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-5" name="rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-5" href="#rest_code_e9dfc1bb2359451286b0e07bef9e7fa3-5"></a>    <span>pass</span>
</pre></div>
<p>Similarly, class level attributes can’t be re-ordered safely:</p>
<div><pre><a id="rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-1" name="rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-1" href="#rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-1"></a><span>class</span> <span>Foo</span><span>():</span>
<a id="rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-2" name="rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-2" href="#rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-2"></a>    <span>a</span> <span>=</span> <span>Bar</span><span>()</span>
<a id="rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-3" name="rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-3" href="#rest_code_2dd0b113bd2d47f5a0b752d8963e9fd7-3"></a>    <span>b</span> <span>=</span> <span>Bar</span><span>()</span>
</pre></div>
<p>Due to unrestricted effects possible inside the <code>Bar</code> constructor, the
definitions of <code>a</code> and <code>b</code> cannot be re-ordered safely. (This might seem
theoretical, but Django, for instance, actually uses this ability inside
<code>Model</code> and <code>Form</code> definitions to provide a default order for the fields,
using a cunning <a href="https://github.com/django/django/blob/976bd519a879b2fd7a356cb21bde32696adb545f/django/db/models/fields/__init__.py#L175">class level counter inside the base Field constructor</a>).</p>
<p>Ultimately, you have to accept that a sequence of function statements in Python
is a sequence of actions in which objects (functions and default arguments) are
created, possibly manipulated, etc. It is not a re-orderable set of function
declarations as it might be in other languages.</p>
<p>This gives Python an amazing power when it comes to writing it, but imposes
massive restrictions on what you can do in any automated way to manipulate
Python source code.</p>
<p>Above I used the simple example of re-ordering two functions or class
attributes. But every single type of refactoring that you might do in Python
becomes virtually impossible to do safely because of the power of the language
e.g. duck typing means you can’t do method renames, the possibility of
reflection/dynamic attribute access (<code>getattr</code> and friends) means you can’t in
fact do any kind of automated renames (safely).</p>
<p>So, if we are tempted to blame our crude VCS or refactoring tools, we actually
have to blame the power of Python — despite the huge amount of structure in
correct Python source code, there is very little that any software tool can do
with it when it comes to manipulating it, and the line-based diffing that got me
so mad is actually a reasonable approach.</p>
<p>Now, 99% of the time, we don’t write Python decorators which mean that the order
of function definitions makes a difference, or silly things like that — we are
responsible “adults”, as Guido put it, and this makes life easier for human
consumers. But the fact remains that our tools are limited by what we do in the
0.01% of cases. For some consumers, we can optimise on the basis of the common
case, and detect when that fails e.g. a JIT compiler using guards. But with
others e.g. VCS or refactoring tools, the “runtime” information that you hit the
unlucky case comes far too late — you might have released your subtly-broken code by the time
you find out, so you have to be safe rather than sorry.</p>
<p>In an ideal world, with my dream language, when you rename a function, the
entire “diff” in your VCS should simply be “Function foo renamed to bar”. (And,
this should be exportable/importable, so that when you upgrade a dependency to a
version in which foo is renamed to bar, it should be exactly zero work to deal
with this). In a “less powerful” language, this would be possible, but the power
given to the program author in Python has taken power from all the other tools
in the environment.</p>
<p>Does this matter? It depends on how much time you spend manipulating your
code, compared to using code to manipulate data.</p>
<p>At the beginning of a project, you may be tempted to desire the most powerful
language possible, because it gives you the most help and freedom in terms of
manipulating data. But later on, you spend a huge amount of time manipulating
code, and often using an extremely basic tool to do so — a text editor. This
treats your highly structured code as one of the least structured forms of data
— a string of text — exactly the kind of manipulation you would avoid at all
costs inside your code. But all the practices you would choose and rely on
inside your program (manipulating all data inside appropriate containers) are no
longer available to you when it comes to manipulating the program itself.</p>
<p>Some popular languages make automated refactoring easier, but more is needed: to
actually make use of the structure of your code, you need an editor and VCS that
understand your code properly. Projects like <a href="http://www.lamdu.org/">Lamdu</a>,
<a href="http://unisonweb.org/">Unison</a> and <a href="https://isomorf.io/">isomorf.io</a> are in
the right direction, but still in their infancy, and unfortunately involve
re-thinking the entire software development stack :-(</p>
</section><section id="summary"><h2>Summary</h2>
<p>When you consider the total system and all the players (whether software or
human), including the need to produce efficient code, and long term
maintainability, less powerful languages are actually more powerful — “slavery
is freedom”. There is a <a href="http://calculist.blogspot.co.uk/2005/04/balance-of-expressiveness-and.html">balance between expressiveness and reasonability</a>.</p>
<p>The more powerful a language, the greater the burden on software tools, which
either need to be more complicated in order to work, or are forced to do less
than they could. This includes:</p>
<ul>
<li><p>compilers — with big implications for performance.</p></li>
<li><p>automated refactoring and VCS tools — with big implications for maintenance.</p></li>
</ul>
<p>Similarly, the burden also increases for humans — for anyone attempting to
understand the code or modify it.</p>
<p>A natural instinct is to go for the most powerful solution, or a solution that
is much more powerful than is actually needed. We should try to do the opposite
— find the least powerful solution that will do the job.</p>
<p>This won’t happen if creating new languages (which might involve parsers etc.)
is hard work. We should prefer software ecosystems that make it easy to create
very small and weak languages.</p>
</section><section id="addendum"><h2>Addendum</h2>
<ul>
<li><p><a href="https://news.ycombinator.com/item?id=10567408">Discussion of this post on Hacker News</a></p></li>
<li><p><a href="https://www.reddit.com/r/programming/comments/3ssm52/we_need_less_powerful_languages/">Discussion of this post on reddit/r/programming</a></p></li>
<li><p><a href="http://postd.cc/less-powerful-languages/">Translation into Japanese</a></p></li>
</ul>
<p>Similar posts I&#39;ve found since writing this:</p>
<ul>
<li><p><a href="https://blog.higher-order.com/blog/2014/12/21/maximally-powerful/">Maximally powerful, minimally useful</a></p></li>
</ul></section>
</div>
    </section></article>



</div></div>
  </body>
</html>
