<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://trochilidae.blogspot.com/2021/07/stack-based-with-os-in-hardware.html">Original</a>
    <h1>Implementing a Transputer system using RasPi Pico and RAM expansion</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-5571571337166558963" itemprop="description articleBody">
<p><span><b> Transputer: Stack Based With OS in Hardware</b></span></p><p><span><b>Picoputer: RP Pico Hardware Transputer</b></span></p><p>The transputer was and still is an odd beast. It has hardware support for processes (hence OS in hardware, well, sort of), and its assembly language is such a pain that Occam is a much better way to program it. It&#39;s a language that is close to the hardware and allows parallel processing to be built in at a basic level. They have four fast (for the time) 10mbps (20mbps later) links that are used to communicate between devices and other systems. As the processors improved in capabilities and speed, the links remained compatible.</p><p>The later transputers have floating point in hardware, which makes them useful for computationally intense work, especially when configured in networks.<br/></p><p>The only real downside is that the chips were expensive, so they never really made it into common usage in embedded applications. Quite a few parallel processing systems using transputers were made, though. <br/></p><p>I read all about transputers when they came out but never had a chance to use any. Recently, though, I was looking at vintage processors and transputers came up, which triggered some memories. Unfortunately, the downside of high cost seems to still exist, and vintage transputers are quite expensive. Not as expensive as when they were new, but costly enough that I didn&#39;t just buy a few. </p><p>If you want to run some meaningful code on a transputer then you also need to add some RAM, as the chip itself only comes with about 2K onboard. A common &#39;unit of computing&#39; using a transputer is the TRAM (TRAnsputer Module) which is a transputer plus some RAM. These are very expensive to buy, to the extent that creating a system with more than one processor in it is just not economically sensible.</p><p><b>Raspberry Pi Pico</b><br/></p><p>At around the same time, the Raspberry Pi Pico came to my attention. This is a modern micro-controller board that uses the RP2040 device, which is interesting for me as it has a set of four intelligent hardware GPIO processors. I&#39;m think that these are very useful for interfacing to old hardware buses, such as the FX702P display bus I sniffed with a Blue Pill, or the FX502P external interface bus. When I implemented these projects I used firmware to interface to the bus, which was just about possible using the Blue Pill as it has a high clock rate relative to the bus. Interrupts were necessary in the case of the FX502P bus. The RP2040, though, has programmable hardware that can operate at frequencies of tens to a few hundreds of MHz. This, hopefully, should make it possible to interface to some devices that have higher clock rates.</p><p><iframe allowfullscreen="" height="266" src="https://www.youtube.com/embed/MV_q7ltG8gY" width="320" youtube-src-id="MV_q7ltG8gY"></iframe> <br/></p><p>While I was looking at the RP2040, it suddenly occurred to me that the four links on a transputer could be implemented using the eight PIO state machine son an RP2040. Each state machine handles data in one direction, leaving the processor(s) free for other work. What other work? Well, how about running an emulator of a transputer on the core? That would give you a hardware emulation of a transputer. How fast would it be? Well, the original transputers were running at about 20MHz, and the Pico runs at 135MHz. So it probably wouldn&#39;t run at the same speed as an original, but it would only be about an order of magnitude slower, maybe. And you can, of course, just add more transputers (real or emulated)  to speed things up...<br/></p><p>The links that the Pico provides can easily run at the standard 10MHz link speed (10Mbps) and running at the faster 20MHz shouldn&#39;t be a problem either. In fact, if only emulated transputers are talking then a faster link rate could maybe be used.</p><p><span><b>Host Communication</b></span></p><p>The transputer links can&#39;t be attached to a modern PC, but INMOS made some link adapter ICs (The IMSC011). These are fairly easy to buy, and provide two 8 bit data buses, one for the LinkIn direction and one for LinkOut. Adding one of these to an Arduino would give a way to interface a transputer to a PC.</p><p><a href="https://1.bp.blogspot.com/-ACq7mBXoENA/YQWiYH9LptI/AAAAAAAAQlo/ghZB0OmVMlgFD_K-f3lqZ03ieP-dhm_nwCLcBGAsYHQ/s2048/IMAG0853.jpg" imageanchor="1"><img data-original-height="2048" data-original-width="1226" height="320" src="https://1.bp.blogspot.com/-ACq7mBXoENA/YQWiYH9LptI/AAAAAAAAQlo/ghZB0OmVMlgFD_K-f3lqZ03ieP-dhm_nwCLcBGAsYHQ/s320/IMAG0853.jpg" width="192"/></a></p><p>As these are devices that run off 5V I decided to use an Arduino Mega Embedded, partly because I had one. The parallel buses can be wired up to the Mega, together with the Valid and Ack signals. these are used to signal that the data is valid (when Valid is active) and also allow data to be acknowledged (by Ack). The Arduino can then do whatever is needed with the data. i decided to send the data over USB to a host PC as that is the arrangement that the transputer originally used. The host PC then runs a server that handles the &#39;SP Protocol&#39; which allows input and output on a terminal and keyboard and also allows access to files in the file system.</p><p><b>Booting</b></p><p>A transputer can be booted either from ROM or from a link. I didn&#39;t want to boot from ROM, although a program can easily be stored in flash and executed at startup. It&#39;s more flexible to book from a link as the host can then supply the code which can be compiled Occam, or C, or any of the other languages that can generate transputer object code. I&#39;m particularly interested in Occam.<br/></p><p>Booting from a link is built in to hardware and involves sending a small (up to 255 bytes) bootstrap loader. This then executes and loads further data (the boot loading phase). That boot-loader then loads more chunks of code over the link.</p><p>For the host, this is all rather simple, all it does is send the boot file to the transputer link. The format of the data is set up to drive the three stage boot process.</p><p><b>Using PIOs As Transputer Links</b></p><p>The transputer links use a protocol that is very similar to asynchronous serial data. You can view data packets as having a start bit, a type bit and eight data bits followed by a stop bit. An ACK packet follows much the same format, except the data bits are missing. The type bit is 1 in a data packet and 0 in an ACK packet. I started with the serial UART PIO code in the Pico examples and adjusted it to use the transputer protocol. I have a bit of work to do concerning the ACK packet, as I treat the ACK packet as a 10 bit frame at the moment, just with trailing zeros. This could possibly lead to problems if serial data is sent within 7 bit times of an ACK packet, but is working OK for now.</p><p>I used one PIO for LinkOut and one for LinkIn, and for the prototype I generate a 5MHz clock with a PIO for the IMSC011 ClockIn pin. </p><p><a href="https://1.bp.blogspot.com/-RfJZqEDWD7I/YQWisbkJNoI/AAAAAAAAQlw/DbF-KWIC3PYA-U0Qtc0bdt3B0R2vlVchQCLcBGAsYHQ/s2048/IMAG0858.jpg" imageanchor="1"><img data-original-height="1226" data-original-width="2048" height="192" src="https://1.bp.blogspot.com/-RfJZqEDWD7I/YQWisbkJNoI/AAAAAAAAQlw/DbF-KWIC3PYA-U0Qtc0bdt3B0R2vlVchQCLcBGAsYHQ/s320/IMAG0858.jpg" width="320"/></a></p></div></div>
  </body>
</html>
