<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/the-halting-problem-is-a-terrible-example-of-np/">Original</a>
    <h1>The Halting Problem is a terrible example of NP-Harder</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                April 16, 2025
                
                
            </date>
            

            

            
            <h2>
                It&#39;s a justifiable copout, but it&#39;s still a copout.
            </h2>
            

            

            
            
            <p><em>Short one this time because I have a lot going on this week.</em></p>
<p>In computation complexity, <strong>NP</strong> is the class of all decision problems (yes/no) where a potential proof (or &#34;witness&#34;) for &#34;yes&#34; can be <em>verified</em> in polynomial time. For example, &#34;does this set of numbers have a subset that sums to zero&#34; is in NP. If the answer is &#34;yes&#34;, you can prove it by presenting a set of numbers. We would then verify the witness by 1) checking that all the numbers are present in the set (~linear time) and 2) adding up all the numbers (also linear). </p>
<p><strong>NP-complete</strong> is the class of &#34;hardest possible&#34; NP problems. Subset sum is NP-complete. <strong>NP-hard</strong> is the set all problems <em>at least as hard</em> as NP-complete. Notably, NP-hard is <em>not</em> a subset of NP, as it contains problems that are <em>harder</em> than NP-complete. A natural question to ask is &#34;like what?&#34; And the canonical example of &#34;NP-harder&#34; is the halting problem (HALT): does program P halt on input C? As the argument goes, it&#39;s undecidable, so obviously not in NP.</p>
<p>I think this is a bad example for two reasons:</p>
<ol>
<li>All NP requires is that witnesses for &#34;yes&#34; can be verified in polynomial time. It does not require anything for the &#34;no&#34; case! And even though HP is undecidable, there <em>is</em> a decidable way to verify a &#34;yes&#34;: let the witness be &#34;it halts in N steps&#34;, then run the program for that many steps and see if it halted by then. To prove HALT is not in NP, you have to show that this verification process grows faster than polynomially. It does (as <a href="https://en.wikipedia.org/wiki/Busy_beaver" target="_blank">busy beaver</a> is uncomputable), but this all makes the example needlessly confusing.<sup id="fnref:alternative"><a href="#fn:alternative">1</a></sup></li>
<li>&#34;What&#39;s bigger than a dog? THE MOON&#34;</li>
</ol>
<p>Really (2) bothers me a lot more than (1) because it&#39;s just so inelegant. It suggests that NP-complete is the upper bound of &#34;solvable&#34; problems, and after that you&#39;re in full-on undecidability. I&#39;d rather show intuitive problems that are harder than NP but not <em>that</em> much harder. </p>
<p>But in looking for a &#34;slightly harder&#34; problem, I ran into an, ah, problem. It <em>seems</em> like the next-hardest class would be <a href="https://en.wikipedia.org/wiki/EXPTIME" target="_blank">EXPTIME</a>, except we don&#39;t know <em>for sure</em> that NP != EXPTIME. We know <em>for sure</em> that NP != <a href="https://en.wikipedia.org/wiki/NEXPTIME" target="_blank">NEXPTIME</a>, but NEXPTIME doesn&#39;t have any intuitive, easily explainable problems. Most &#34;definitely harder than NP&#34; problems require a nontrivial background in theoretical computer science or mathematics to understand.</p>
<p>There is one problem, though, that I find easily explainable. Place a token at the bottom left corner of a grid that extends infinitely up and right, call that point (0, 0). You&#39;re given list of valid displacement moves for the token, like <code>(+1, +0)</code>, <code>(-20, +13)</code>, <code>(-5, -6)</code>, etc, and a target point like <code>(700, 1)</code>. You may make any sequence of moves in any order, as long as no move ever puts the token off the grid. Does any sequence of moves bring you to the target?</p>
<p>This is PSPACE-complete, I think, which still isn&#39;t proven to be harder than NP-complete (though it&#39;s widely believed). But what if you increase the number of dimensions of the grid? Past a certain number of dimensions the problem jumps to being EXPSPACE-complete, and then TOWER-complete (grows <a href="https://en.wikipedia.org/wiki/Tetration" target="_blank">tetrationally</a>), and then it keeps going. Some point might recognize this as looking a lot like the <a href="https://en.wikipedia.org/wiki/Ackermann_function" target="_blank">Ackermann function</a>, and in fact this problem is ACKERMANN-complete on the number of available dimensions.</p>
<p><a href="https://www.quantamagazine.org/an-easy-sounding-problem-yields-numbers-too-big-for-our-universe-20231204/" target="_blank">A friend wrote a Quanta article about the whole mess</a>, you should read it. </p>
<p>This problem is ludicrously bigger than NP (&#34;Chicago&#34; instead of &#34;The Moon&#34;), but at least it&#39;s clearly decidable, easily explainable, and definitely <em>not</em> in NP. </p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            





        </div></div>
  </body>
</html>
