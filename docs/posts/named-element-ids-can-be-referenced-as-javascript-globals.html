<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://css-tricks.com/named-element-ids-can-be-referenced-as-javascript-globals/">Original</a>
    <h1>Named element IDs can be referenced as JavaScript globals</h1>
    
    <div id="readability-page-1" class="page"><div>

          
          
<p>Did you know that DOM elements with IDs are accessible in JavaScript as global variables? It’s one of those things that’s been around, like, forever but I’m really digging into it for the first time.</p>



<p>If this is the first time you’re hearing about it, brace yourself! We can see it in action simply by adding an ID to an element in HTML:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;div id=&#34;cool&#34;&gt;&lt;/div&gt;</code></pre>



<p>Normally, we’d define a new variable using <code>querySelector(&#34;#cool&#34;)</code> or <code>getElementById(&#34;cool&#34;)</code> to select that element:</p>



<pre rel="JavaScript" data-line=""><code markup="tt">var el = querySelector(&#34;#cool&#34;);</code></pre>



<p>But we actually already have access to <code>#cool</code> without that rigamorale:</p>







<p>So, any <code>id</code> — or <code>name</code> attribute, for that matter — in the HTML can be accessed in JavaScript using <code>window[ELEMENT_ID]</code>. Again, this isn’t exactly “new” but it’s really uncommon to see.</p>



<p>As you may guess, accessing the global scope with named references isn’t the greatest idea. Some folks have come to call this the “global scope polluter.” We’ll get into why that is, but first…</p>


<h3 id="some-context"><a href="#aa-some-context" aria-hidden="true" id="aa-some-context"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Some context</h3>


<p>This approach is <a href="https://html.spec.whatwg.org/multipage/window-object.html#named-access-on-the-window-object" rel="noopener">outlined in the HTML specification</a>, where it’s described as “named access on the <code>Window</code> object.”</p>



<p>Internet Explorer was the first to implement the feature. All other browsers added it as well. Gecko was the only browser at the time to not support it directly in standards mode, opting instead to make it an experimental feature. There was hesitation to implement it at all, but it <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=622491#c8" rel="noopener">moved ahead in the name of browser compatibility</a> (Gecko even tried to <a href="https://bugs.webkit.org/show_bug.cgi?id=81972" rel="noopener">convince WebKit</a> to move it out of standards mode) and eventually made it to standards mode in Firefox 14.</p>



<p>One thing that might not be well known is that browsers had to put in place a few precautionary measures — with varying degrees of success — to ensure generated globals don’t break the webpage. One such measure is…</p>


<h3 id="variable-shadowing"><a href="#aa-variable-shadowing" aria-hidden="true" id="aa-variable-shadowing"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variable shadowing</h3>


<p>Probably the most interesting part of this feature is that named element references don’t <a href="https://en.wikipedia.org/wiki/Variable_shadowing" rel="noopener">shadow existing global variables</a>. So, if a DOM element has an <code>id</code> that is already defined as a global, it won’t override the existing one. For example:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;head&gt;
  &lt;script&gt;
    window.foo = &#34;bar&#34;;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&#34;foo&#34;&gt;I won&#39;t override window.foo&lt;/div&gt;
  &lt;script&gt;
    console.log(window.foo); // Prints &#34;bar&#34;
  &lt;/script&gt;
&lt;/body&gt;</code></pre>



<p>And the opposite is true as well:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;div id=&#34;foo&#34;&gt;I will be overridden :(&lt;/div&gt;
&lt;script&gt;
  window.foo = &#34;bar&#34;;
  console.log(window.foo); // Prints &#34;bar&#34;
&lt;/script&gt;</code></pre>



<p>This behavior is essential because it nullifies dangerous overrides such as <code>&lt;div id=&#34;alert&#34; /&gt;</code>, which would otherwise create a conflict by invalidating the <code>alert</code> API. This safeguarding technique may very well be the why you — if you’re like me — are learning about this for the first time.</p>


<h3 id="the-case-against-named-globals"><a href="#aa-the-case-against-named-globals" aria-hidden="true" id="aa-the-case-against-named-globals"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The case against named globals</h3>


<p>Earlier, I said that using global named elements as references might not be the greatest idea. There are lots of reasons for that, which <a href="https://www.tjvantoll.com/2012/07/19/dom-element-references-as-global-variables/" rel="noopener">TJ VanToll has covered nicely over at his blog</a> and I will summarize here:</p>



<ul><li><strong>If the DOM changes, then so does the reference.</strong> That makes for some really “brittle” (<a href="https://html.spec.whatwg.org/#named-access-on-the-window-object" rel="noopener">the spec’s term</a> for it) code where the separation of concerns between HTML and JavaScript might be too much.</li><li><strong>Accidental references are far too easy.</strong> A simple typo may very well wind up referencing a named global and give you unexpected results.</li><li><strong>It is implemented differently in browsers.</strong> For example, we should be able to access an anchor with an <code>id</code> — e.g. <code>&lt;a id=&#34;cool&#34;&gt;</code> — but some browsers (namely Safari and Firefox) return a <code>ReferenceError</code> in the console.</li><li><strong>It might not return what you think.</strong> According to the spec, when there are multiple instances of the same named element in the DOM — say, two instances of <code>&lt;div class=&#34;cool&#34;&gt;</code> — the browser should return an <code>HTMLCollection</code> with an array of the instances. Firefox, however, only returns the first instance. Then again, <a href="https://html.spec.whatwg.org/#global-attributes:concept-id" rel="noopener">the spec says</a> we ought to use one instance of an <code>id</code> in an element’s tree anyway. But doing so won’t stop a page from working or anything like that.</li><li><strong>Maybe there’s a performance cost?</strong> I mean, the browser’s gotta make that list of references and maintain it. A couple of folks ran tests <a href="https://stackoverflow.com/questions/3434278/do-dom-tree-elements-with-ids-become-global-properties" rel="noopener">in this StackOverflow thread</a>, where named globals were actually <a href="https://jsben.ch/AZD81" rel="noopener">more performant in one test</a> and <a href="https://jsben.ch/bexDw" rel="noopener">less performant in a more recent test</a>.</li></ul>


<h3 id="additional-considerations"><a href="#aa-additional-considerations" aria-hidden="true" id="aa-additional-considerations"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Additional considerations</h3>


<p>Let’s say we chuck the criticisms against using named globals and use them anyway. It’s all good. But there are some things you might want to consider as you do.</p>


<h4 id="polyfills"><a href="#aa-polyfills" aria-hidden="true" id="aa-polyfills"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Polyfills</h4>


<p>As edge-case-y as it may sound, these types of global checks are a typical setup requirement for polyfills. Check out the following example where we set a cookie using the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/CookieStore" rel="noopener"><code>CookieStore</code> API</a>, polyfilling it on browsers that don’t support it yet:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;body&gt;
  &lt;img id=&#34;cookieStore&#34;&gt;&lt;/img&gt;
  &lt;script&gt;
    // Polyfill the CookieStore API if not yet implemented.
    // https://developer.mozilla.org/en-US/docs/Web/API/CookieStore
    if (!window.cookieStore) {
      window.cookieStore = myCookieStorePolyfill;
    }
    cookieStore.set(&#34;foo&#34;, &#34;bar&#34;);
  &lt;/script&gt;
&lt;/body&gt;</code></pre>



<p>This code works perfectly fine in Chrome, but throws the following error in Safari.:</p>



<pre rel="" data-line=""><code markup="tt">TypeError: cookieStore.set is not a function</code></pre>



<p>Safari lacks support for the <code>CookieStore</code> API as of this writing. As a result, the polyfill is not applied because the <code>img</code> element ID creates a global variable that clashes with the <code>cookieStore</code> global.</p>


<h4 id="javascript-api-updates"><a href="#aa-javascript-api-updates" aria-hidden="true" id="aa-javascript-api-updates"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript API updates</h4>


<p>We can flip the situation and find yet another issue where updates to the browser’s JavaScript engine can break a named element’s global references.</p>



<p>For example:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;body&gt;
  &lt;input id=&#34;BarcodeDetector&#34;&gt;&lt;/input&gt;
  &lt;script&gt;
    window.BarcodeDetector.focus();
  &lt;/script&gt;
&lt;/body&gt;</code></pre>



<p>That script grabs a reference to the input element and invokes <code>focus()</code> on it. It works correctly. Still, we don’t know how <em>long</em> it will continue to work.</p>



<p>You see, the global variable we’re using to reference the input element will stop working as soon as browsers start supporting the <a href="https://developer.mozilla.org/en-US/docs/Web/API/BarcodeDetector" rel="noopener"><code>BarcodeDetector</code> API</a>. At that point, the <code>window.BarcodeDetector</code> global will no longer be a reference to the input element and <code>.focus()</code> will throw a “<code>window.BarcodeDetector.focus</code> is not a function” error.</p>


<h3 id="conclusion"><a href="#aa-conclusion" aria-hidden="true" id="aa-conclusion"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>


<p>Let’s sum up how we got here:</p>



<ul><li>All major browsers automatically create global references to each DOM element with an <code>id</code> (or, in some cases, a <code>name</code> attribute).</li><li>Accessing these elements through their global references is unreliable and potentially dangerous. Use <code>querySelector</code> or <code>getElementById</code> instead.</li><li>Since global references are generated automatically, they may have some side effects on your code. That’s a good reason to avoid using the <code>id</code> attribute unless you really need it.</li></ul>



<p>At the end of the day, it’s probably a good idea to avoid using named globals in JavaScript. I quoted the spec earlier about how it leads to “brittle” code, but here’s the full text to drive the point home:</p>



<blockquote><p>As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to this API can vary over time, as new features are added to the web platform, for example. Instead of this, use <code>document.getElementById()</code> or <code>document.querySelector()</code>.</p></blockquote>



<p>I think the fact that the HTML spec itself recommends to staying away from this feature speaks for itself.</p>

          
        </div></div>
  </body>
</html>
