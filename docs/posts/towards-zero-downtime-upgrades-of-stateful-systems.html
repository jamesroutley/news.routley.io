<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stevana.github.io/towards_zero-downtime_upgrades_of_stateful_systems.html">Original</a>
    <h1>Towards zero-downtime upgrades of stateful systems</h1>
    
    <div id="readability-page-1" class="page"><div>

<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#terminology" id="toc-terminology">Terminology</a>
<ul>
<li><a href="#software-systems" id="toc-software-systems">Software
systems</a></li>
<li><a href="#programs-and-their-upgrades" id="toc-programs-and-their-upgrades">Programs and their
upgrades</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation">Implementation</a>
<ul>
<li><a href="#state-machines" id="toc-state-machines">State
machines</a></li>
<li><a href="#example" id="toc-example">Example</a></li>
<li><a href="#semantics" id="toc-semantics">Semantics</a></li>
<li><a href="#pipelines" id="toc-pipelines">Pipelines</a></li>
<li><a href="#deployment" id="toc-deployment">Deployment</a></li>
<li><a href="#upgrades" id="toc-upgrades">Upgrades</a></li>
<li><a href="#sources-and-sinks" id="toc-sources-and-sinks">Sources and
sinks</a></li>
<li><a href="#remote-upgrades" id="toc-remote-upgrades">Remote
upgrades</a></li>
</ul></li>
<li><a href="#discussion-and-future-work" id="toc-discussion-and-future-work">Discussion and future work</a></li>
</ul>
</nav>
<p>Posted on Mar  7, 2024</p>
<h2 id="motivation">Motivation</h2>
<p>Most deployed programs need to be upgraded at some point. The reasons
vary from adding new features to patching a bug and potentially fixing a
broken state. Even though upgrades are an essential part of software
development and maintenance, programming languages tend to not help the
programmer deal with them in any way.</p>
<p>The situation reminds me of a remark made by Barbara Liskov about
deployment of software (which is related to upgrades) in her Turing
award <a href="https://youtu.be/qAKrMdUycb8?t=3058">lecture</a>
(2009):</p>
<blockquote>
<p>“There’s a funny disconnect in how we write distributed programs. You
write your individual modules, but then when you want to connect them
together you’re out of the programming language and into this other
world. Maybe we need languages that are a little bit more complete now,
so that we can write the whole thing in the language.”</p>
</blockquote>
<p>There’s one exception, that I know of, where upgrades are talked
about from within the language: Erlang/OTP. In OTP there’s a library
construct called <a href="https://www.erlang.org/doc/design_principles/release_structure"><em>release</em></a>,
which can be used to perform up- and downgrades. Furthermore, these up-
and downgrades can hot swap the running code resulting in zero-downtime
and no interruption of the service of connected clients.</p>
<p>If you haven’t seen Erlang’s hot swapping feature before, then you
might want to have a look at the classic <a href="https://www.youtube.com/watch?v=xrIjfIjssLE">Erlang the movie</a>,
which contains a telecommunications example of this. If you prefer
reading over watching, then I’ve written an earlier <a href="https://stevana.github.io/hot-code_swapping_a_la_erlang_with_arrow-based_state_machines.html">post</a>
which starts off by explaining a REPL session which performs an upgrade
(my example isn’t nearly as cool as in the movie though).</p>
<p>What is it that Erlang’s releases and hot swapping facilities do? Can
we steal those ideas and build upon them? These are the main questions
that motivated me in writing this post.</p>
<p>Let’s take a step back, ignoring Erlang for a moment, and ask
ourselves: what would good support for upgrades look like?</p>
<ul>
<li>Zero-downtime: seamless, don’t interrupt existing client connections
or sessions;</li>
<li>If there’s any state then migrate it in a type-safe way;</li>
<li>Backwards and forwards compatibility: old clients should be able to
talk to newer servers, and newer clients should be able to talk to old
servers;</li>
<li>Atomicity: upgrades either succeed, or fail and rollback any
changes;</li>
<li>Downgrades: even if an upgrade succeeds we might want to rollback to
an earlier version.</li>
</ul>
<p>In the rest of this post I’d like to explore how we can achieve some
of this.</p>
<h2 id="terminology">Terminology</h2>
<p>Having defined some desirable characteristics of upgrades, let’s move
on to defining what we mean by upgrades.</p>
<p>There are two notions I’d like clarify: what kind of software systems
the upgrades are targeting, and then how we represent programs and their
upgrades.</p>
<h3 id="software-systems">Software systems</h3>
<p>There’s different kinds of software systems one might want to
upgrade.</p>
<ol type="1">
<li><p>Client-only, e.g. a compiler, editor, or some command line
utility which runs locally on your computer and doesn’t interact with
any server. Downtime is typically not a problem, and the state of the
program is typically saved to disk. The operating system’s package
manager typically takes care of the upgrades, with minimal user
involvement. However there are situations where one might like to
perform an upgrade without first terminating the old version of a
client-only application, e.g. the fix-and-continue debugging <a href="https://lispcookbook.github.io/cl-cookbook/debugging.html#resume-a-program-execution-from-anywhere-in-the-stack">workflow</a>
from Lisp and Smalltalk, <a href="https://en.wikipedia.org/wiki/TidalCycles">live coding music</a>,
or when working with large data sets, e.g. in <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1386713/">bioinformatics</a>;</p></li>
<li><p>Client-server applications where the target of the upgrade is a
<em>stateless</em> component of the server, e.g. a front-end or a REST
API. The stateless components typically retrieve the state they need to
service a request from a stateful component, e.g. a database, but they
don’t maintain any state of their own, which makes stateless components
easier to upgrade. A common strategy is to stick a load balancer
in-front of the stateless component(s), spin up the new version of the
component while keeping the old version around, and then (slowly)
migrate traffic over to the new version. Notice that this wouldn’t
necessarily work if there was state in the components, as then the state
of the old and new versions of the components might diverge and
potentially have unexpected results;</p></li>
<li><p>Client-server applications where the target of the upgrade is a
<em>stateful</em> component of the server, e.g. a database or a service
with a stateful protocol like FTP. Databases were designed for
supporting upgrades, with features like schema migrations and
replication. The high-level idea would be to spin up the new version,
take a snapshot of the old database, start logically replicating all new
requests from the old to the new database while also restoring the
snapshot to the new database, once the new database has caught up, we
can switch over and tear down the old database. Depending on the volume
of the database and the rate of new traffic this can still be a
difficult operation.</p>
<p>A service like FTP, where once the user is connected they can “move
around” by e.g. changing the working directory and list the contents of
the current working directory, are typically not possible to upgrade
without downtime. The problem is that the response of one command
depends on the history of previous commands in that user sessions, and
this state is transient. If you think FTP is a silly protocol (it’s),
then consider the similarly stateful POSIX filesystem API, with its file
handles that can be opened, read, written, and closed;</p></li>
<li><p>Distributed stateful systems, e.g. a distributed key-value
database. This is similar to the above, but the replication of data is
performed all the time rather than only at the moment an upgrade is
performed. The disadvantage is that we need more hardware and bandwidth,
but on the other hand it makes upgrades much easier. Distributed systems
can typically tolerate and repair some amount of faulty replicas, which
allows for rolling upgrades where we replace one of the server
components at the time;</p></li>
<li><p>There’s also <a href="https://www.inkandswitch.com/local-first/">local-first</a>
systems, which are different to all the above. I’ve not had a chance to
think about upgrades in that context, so I won’t talk about them any
further.</p></li>
</ol>
<p>In this post I’d like to focus on upgrading stateful systems, like
non-distributed databases and stateful services like FTP or
filesystems.</p>
<p>Stateful systems arguably have the worst upgrade path of the ones
listed above, making them more interesting to work on. That said I hope
that the techniques can be used to simplify upgrades in the other kinds
of systems too, and potentially enabling other possibilities like better
debugging experience and live coding.</p>
<h3 id="programs-and-their-upgrades">Programs and their upgrades</h3>
<p>Having defined what kind of systems we’d like to upgrade, let’s turn
our attention to how we can represent programs and their upgrades.</p>
<p>We could choose to use the syntax of a specific programming language
to represent programs, but programming languages tend to be too big and
complicated. Or, we could be general and represent programs as
λ-calculus terms or equivalently Turing machines, but that would be too
clumsy and too low-level.</p>
<p>A happy middle ground, which is easy to implement in any programming
language while at the same time expressive enough to express any
algorithm at a desired level of abstraction, is the humble state
machine<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. There are different ways to define
state machines, we’ll go for a definition which is a simple function
from some input and a state to a pair of some output and a new
state:</p>
<pre><code>  input -&gt; state -&gt; (state, output)</code></pre>
<p>where inputs, states and outputs are algebraic datatypes
(records/structs and tagged unions).</p>
<p>To make things concrete, let’s consider an example where we represent
a counter as a state machine. One way to define such a state machine is
to use the enum <code>{ReadCount, IncrCount}</code> as input, set the
state to be an integer and the output to be a tagged union where in the
read case we return an integer and in the increment case we return an
acknowledgment (unit or void type). Given these types, the state machine
function of the counter can be defined as follows (in Python):</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>def</span> counter(<span>input</span>: Input, state: <span>int</span>) <span>-&gt;</span> (<span>int</span>, <span>int</span> <span>|</span> <span>None</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>match</span> <span>input</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span>case</span> Input.ReadCount: <span>return</span> (state, state)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span>case</span> Input.IncrCount: <span>return</span> (state <span>+</span> <span>1</span>, <span>None</span>)</span></code></pre></div>
<p>Assuming our programs are such state machines, what would it mean to
upgrade them? I think this is where having a simple representation of
programs where all of the state is explicit starts to shine. By merely
looking at the function type of a state machine, we can see that it
would make sense to be able to:</p>
<ol type="1">
<li>Extend the input type with more cases, e.g. a
<code>ResetCount</code> which sets the new state to <code>0</code>;</li>
<li>Refine an existing output with more data, e.g. we could return the
old count when we increment;</li>
<li>Extending the state, e.g. we could add a boolean to the state which
determines if we should increment by +1 or -1 (i.e. decrementing);</li>
<li>Refine an existing input, e.g. make <code>IncrCount</code> have an
integer value associated with it which determines by how much we want to
increment.</li>
</ol>
<p>I don’t know if the above list complete, but it’s a start.</p>
<p>If we go back to the list of criteria for good upgrade support, we
can see how some of the items there are more tangible now.</p>
<p>For example, typed state migrations means that if we change the state
type from <code>state</code> to <code>state&#39;</code> then when we migrate
to old to the new state using a function of type
<code>state -&gt; state&#39;</code>.</p>
<p>Similarly, what it means to support backwards compatibility is more
clear now. Imagine we upgrade from a server state machine:</p>
<pre><code>  input -&gt; state -&gt; (output, state)</code></pre>
<p>to a new version that has the following type:</p>
<pre><code>  input&#39; -&gt; state&#39; -&gt; (output&#39;, state&#39;)</code></pre>
<p>What would it take to still be able to serve old clients which make
requests using the old <code>input</code> type? If we had a function
from <code>input -&gt; input&#39;</code> we could upgrade the request, feed
it to the new state machine and get an <code>output&#39;</code> back, we
then see that we’d also need a way to downgrade the output, i.e. a
function <code>output&#39; -&gt; output</code><a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Forward compatibility, i.e. an upgraded client sends an
<code>input&#39;</code> to a server which haven’t been upgraded yet
(i.e. expects <code>input</code>), is a bit more tricky, but again at
least we can now start to be able to talk about these things in a more
concrete way.</p>
<p>One last thing with regard to how to represent programs. Our state
machines run entirely sequentially, which is a problem if we want to
implement servers that can handle more than one client at the time. A
simple way adding parallelism is make it possible to construct pipelines
of state machines, where the state machines run in parallel. Picture the
state machines as processing stages on a conveyor belt.</p>
<p><img src="https://raw.githubusercontent.com/stevana/hot-swapping-state-machines2/main/data/bottling_factory.png"/></p>
<p>The conveyor belt in our case, i.e. our pipeline, will be queues
which connect the state machines.</p>
<p>A typical TCP-based service can then be composed of a pipeline
that:</p>
<ol type="1">
<li>Accepts new connections/sockets from a client;</li>
<li>Waits for some of the accepted sockets to be readable (this requires
some <code>select/poll/io_uring</code>-like constructs);</li>
<li><code>recv</code> the bytes of a request;</li>
<li>Deserialise the request bytes into an input;</li>
<li>Process the input using the a state machine to produce an output
(potentially reading and writing to disk);</li>
<li>Serialise the output into a response in bytes;</li>
<li>Wait for the socket to be writable;</li>
<li><code>send</code> the response bytes back to the client and close
the socket.</li>
</ol>
<p>Each of these stages could be a state machine which runs in parallel
with all the other stages. Structuring services in this pipeline fashion
was <a href="https://www.youtube.com/watch?v=U3eo49nVxcA&amp;t=1949s">advocated</a>
by the late Jim Gray and more recently Martin Thompson et al have <a href="https://www.youtube.com/watch?v=qDhTjE0XmkE">been</a> giving <a href="https://www.youtube.com/watch?v=_KvFapRkR9I">talks</a> using a
similar approach. If a stage is slow, we can shard (or partition, using
Jim’s terminology) it by dedicating another CPU/core to that stage and
have even numbered requests to one CPU/core while odd numbered requests
go to the other. That way we effectively double the throughput, without
breaking determinism.</p>
<p>Let me just leave you with one final image. I like to think of state
machines on top of pipelines as a limited form of actors or Erlang
processes (<code>gen_server</code>s more precisely) that cannot send
messages to which other process they like (graph-like structure), but
rather only downstream (DAG-like structure)<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<h2 id="implementation">Implementation</h2>
<p>I hope that I’ve managed to convey what I’d like to do, why and where
my inspiration is coming from.</p>
<p>Next I’d like to make things more concrete with some code. But first
I’d like to apologies for my choice of using Haskell. I know it’s a
language that not that many people are comfortable with, but its
advanced type system (GADTs in particular) helps me express things more
cleanly. If anything isn’t clear, feel free to ask, I’m happy to try to
explain things in simpler terms. Also if anyone knows how to express
this without GADTs, while retaining type safety, then please let me
know. The code doesn’t add anything new to our previous discussion,
merely validates that at least some of it can be implemented, so even if
you can’t follow everything you won’t be missing out on anything
important.</p>
<p>A few notes on the implementation:</p>
<ul>
<li>To keep things simple we’ll only implement linear pipelines. Each
stage of the pipeline runs in parallel with all other stages, thus
giving us pipelining parallelism à la assembly lines;</li>
<li>The transformation at each stage is done via a state machine. The
syntax of state machines needs to be easily serialisable, so that we can
send upgrades over the wire;</li>
<li>The remote end will need to deserialise and typecheck the receiving
code in order to assure that it’s compatible with the already deployed
code.</li>
</ul>
<p>In the rest of this section we’ll try to fleshing out details of the
above.</p>
<h3 id="state-machines">State machines</h3>
<p>Typed state machines are represented using a datatype parametrised by
the state, <code>s</code>, and indexed by its input type,
<code>a</code>, and output type <code>b</code><a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>.
For example the <code>Id</code>entity state machine has the same input
and output type, while if we want to <code>Compose</code> to state
machines then output type of the first needs to be the same as the input
type of the second, and so on.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>T</span> s a b <span>where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span>-- Identity and composition.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span>Id</span><span>      ::</span> <span>T</span> s a a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span>Compose</span><span> ::</span> <span>T</span> s b c <span>-&gt;</span> <span>T</span> s a b <span>-&gt;</span> <span>T</span> s a c</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span>-- Introducing and incrementing integers.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span>Int</span><span>     ::</span> <span>Int</span> <span>-&gt;</span> <span>T</span> s () <span>Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span>Incr</span><span>    ::</span> <span>T</span> s <span>Int</span> <span>Int</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span>-- Mapping over sum types.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span>Case</span><span>    ::</span> <span>T</span> s a c <span>-&gt;</span> <span>T</span> s b d <span>-&gt;</span> <span>T</span> s (<span>Either</span> a b) (<span>Either</span> c d)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span>-- Read and update the state.</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span>Get</span><span>     ::</span> <span>T</span> s () s</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span>Put</span><span>     ::</span> <span>T</span> s s ()</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span>-- Converting values from and to strings.</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span>Read</span><span>    ::</span> <span>Read</span> a <span>=&gt;</span> <span>T</span> s <span>String</span> a</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span>Show</span><span>    ::</span> <span>Show</span> a <span>=&gt;</span> <span>T</span> s a <span>String</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span>-- Forward composition.</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span>(&gt;&gt;&gt;) ::</span> <span>T</span> s a b <span>-&gt;</span> <span>T</span> s b c <span>-&gt;</span> <span>T</span> s a c</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>f <span>&gt;&gt;&gt;</span> g <span>=</span> g <span>`Compose`</span> f</span></code></pre></div>
<h3 id="example">Example</h3>
<p>To keep things concrete let’s reimplement the counter example from
above.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>InputV1</span>  <span>=</span> <span>Either</span> () ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>OutputV1</span> <span>=</span> <span>Either</span> <span>Int</span> ()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ReadCountV1</span><span> ::</span> <span>InputV1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ReadCountV1</span> <span>=</span> <span>Left</span> ()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>IncrCountV1</span><span> ::</span> <span>InputV1</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>IncrCountV1</span> <span>=</span> <span>Right</span> ()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span>counterV1 ::</span> <span>T</span> <span>Int</span> <span>String</span> <span>String</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>counterV1 <span>=</span> <span>Read</span> <span>&gt;&gt;&gt;</span> counterV1&#39; <span>&gt;&gt;&gt;</span> <span>Show</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span>    counterV1&#39; ::</span> <span>T</span> <span>Int</span> <span>InputV1</span> <span>OutputV1</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    counterV1&#39; <span>=</span> <span>Get</span> <span>`Case`</span> (<span>Get</span> <span>&gt;&gt;&gt;</span> <span>Incr</span> <span>&gt;&gt;&gt;</span> <span>Put</span>)</span></code></pre></div>
<p>Notice how the two operations’ inputs and outputs are represented
with an <code>Either</code> over which the <code>Case</code>
operates.</p>
<h3 id="semantics">Semantics</h3>
<p>We can interpret our typed state machines in terms of the
<code>State</code> monad as follows.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>runT ::</span> <span>T</span> s a b <span>-&gt;</span> a <span>-&gt;</span> s <span>-&gt;</span> (b, s)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>runT f x s <span>=</span> runState (eval f x) s</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span>eval ::</span> <span>T</span> s a b <span>-&gt;</span> a <span>-&gt;</span> <span>State</span> s b</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>eval <span>Id</span>            <span>=</span> <span>return</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>eval (<span>Compose</span> g f) <span>=</span> eval g <span>&lt;=&lt;</span> eval f</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>eval (<span>Int</span> i)       <span>=</span> <span>return</span> <span>.</span> <span>const</span> i</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>eval <span>Incr</span>          <span>=</span> <span>return</span> <span>.</span> (<span>+</span> <span>1</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>eval (<span>Case</span> f g)    <span>=</span> <span>either</span> (<span>fmap</span> <span>Left</span> <span>.</span> eval f) (<span>fmap</span> <span>Right</span> <span>.</span> eval g)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>eval <span>Get</span>           <span>=</span> <span>const</span> get</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>eval <span>Put</span>           <span>=</span> put</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>eval <span>Read</span>          <span>=</span> <span>return</span> <span>.</span> <span>read</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>eval <span>Show</span>          <span>=</span> <span>return</span> <span>.</span> <span>show</span></span></code></pre></div>
<p>Using the above interpreter we can run our example from before.</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>&gt;</span> runT counterV1 (<span>show</span> <span>ReadCountV1</span>) <span>0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>(<span>&#34;Left 0&#34;</span>,<span>0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>&gt;</span> runT counterV1 (<span>show</span> <span>IncrCountV1</span>) <span>0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>(<span>&#34;Right ()&#34;</span>,<span>1</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>&gt;</span> runT counterV1 (<span>show</span> <span>ReadCountV1</span>) <span>1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(<span>&#34;Left 1&#34;</span>,<span>1</span>)</span></code></pre></div>
<p>These runs only step the counter by one input at the time, things get
more interesting when state machines get streams of inputs via
pipelines.</p>
<h3 id="pipelines">Pipelines</h3>
<p>Pipelines are represented by a type similar to that for typed state
machines, it’s also indexed by the input and output types.</p>
<p>We can picture a pipeline as a conveyor belt with state machines
operating on the items passing through.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>P</span> a b <span>where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span>IdP</span><span>    ::</span> <span>P</span> a a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>  (:&gt;&gt;&gt;) ::</span> <span>Typeable</span> b <span>=&gt;</span> <span>P</span> a b <span>-&gt;</span> <span>P</span> b c <span>-&gt;</span> <span>P</span> a c</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span>SM</span><span>     ::</span> <span>Typeable</span> s <span>=&gt;</span> <span>Name</span> <span>-&gt;</span> s <span>-&gt;</span> <span>T</span> s a b <span>-&gt;</span> <span>P</span> a b</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Name</span> <span>=</span> <span>String</span></span></code></pre></div>
<p>Notice how the state type of the state machines is existentially
quantified, meaning each state machine can have its own state.</p>
<h3 id="deployment">Deployment</h3>
<p>Pipelines can be deployed. Each state machine will be spawned on its
own thread, meaning that all state machines run in parallel, and they
will be connected via queues.</p>
<p>Given a pipeline <code>P a b</code> and an input
<code>Queue (Msg a)</code> we get an output
<code>Queue (Msg b)</code>:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>deploy ::</span> <span>forall</span> a b<span>.</span> (<span>Typeable</span> a, <span>Typeable</span> b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>       <span>=&gt;</span> <span>P</span> a b <span>-&gt;</span> <span>Queue</span> (<span>Msg</span> a) <span>-&gt;</span> <span>IO</span> (<span>Queue</span> (<span>Msg</span> b))</span></code></pre></div>
<p>where <code>Msg</code> is defined as follows.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Msg</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Item</span> (<span>Maybe</span> <span>Socket</span>) a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Upgrade</span> (<span>Maybe</span> <span>Socket</span>) <span>Name</span> <span>UpgradeData_</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span></code></pre></div>
<p>Think of <code>Msg a</code> as small wrapper around <code>a</code>
which might contain a client socket (so that we know where to send the
reply), or an upgrade. Upgrades are targeting a specific state machine
in our pipeline, that’s what the <code>Name</code> parameter is for, and
they also carry an untyped <code>UpgradeData_</code> payload which will
come back to shortly.</p>
<p>Given the above we can define deployment of pipelines as follows
(I’ll explain each case below the code).</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>deploy <span>IdP</span>             q <span>=</span> <span>return</span> q</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>deploy (f <span>:&gt;&gt;&gt;</span> g)      q <span>=</span> deploy g <span>=&lt;&lt;</span> deploy f q</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>deploy (<span>SM</span> name s0 f0) q <span>=</span> <span>do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  q&#39; <span>&lt;-</span> newQueue</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span>let</span><span> go ::</span> <span>Typeable</span> s <span>=&gt;</span> s <span>-&gt;</span> <span>T</span> s a b <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      go s f <span>=</span> <span>do</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        m <span>&lt;-</span> readQueue q</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span>case</span> m <span>of</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>          <span>Item</span> msock i <span>-&gt;</span> <span>do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span>let</span> (o, s&#39;) <span>=</span> runT f i s</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            writeQueue q&#39; (<span>Item</span> msock o)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            go s&#39; f</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>          <span>Upgrade</span> msock name&#39; ud</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span>|</span> name <span>/=</span> name&#39; <span>-&gt;</span> <span>do</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                writeQueue q&#39; (<span>Upgrade</span> msock name&#39; ud)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                go s f</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            <span>|</span> <span>otherwise</span> <span>-&gt;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                <span>case</span> typeCheckUpgrade f ud <span>of</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                  <span>Just</span> (<span>UpgradeData</span> (<span>f&#39; ::</span> <span>T</span> t&#39; a b) (<span>g ::</span> <span>T</span> () s t&#39;)) <span>-&gt;</span> <span>do</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                    <span>let</span> (t&#39;, ()) <span>=</span> runT g s ()</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                    <span>case</span> cast t&#39; <span>of</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                      <span>Just</span> s&#39; <span>-&gt;</span> go s&#39; f&#39;</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                      <span>Nothing</span> <span>-&gt;</span> go s f</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                  <span>Nothing</span> <span>-&gt;</span> go s f</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>          <span>...</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>  _pid <span>&lt;-</span> forkIO (go s0 f0)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>  <span>return</span> q&#39;</span></code></pre></div>
<p>The identity pipeline simply returns the input queue. We deploy
compositions of pipelines by deploying the components and connecting the
queues. Deploying state machines is the interesting part.</p>
<p>When we deploy state machines, we first create a new queue which will
hold the outputs, we then fork a new thread which reads from the input
queue and writes to this new output queue, and finally we return the
output queue. When reading from the input queue there’re two cases:</p>
<ol type="1">
<li>We can either get a regular <code>Item</code> in which case we step
our state machine using the <code>runT</code> function to obtain an
output and a new state, we write the output to the output queue and
continue processing with the new state;</li>
<li>Or, if the <code>Msg</code> is an <code>Upgrade</code> we first
check if the upgrade is targeting this state machine by checking if the
names match, if not we simply pass it further downstream. If the names
to match then we try to typecheck the untyped <code>UpgradeData_</code>.
If the typechecking succeeds, we’ll get a new state machine and a state
migration function, which allows us to migrate the current state and
continue processing with the new state machine.</li>
</ol>
<p>Next let’s have a look at how upgrades are represented and
typechecked.</p>
<h3 id="upgrades">Upgrades</h3>
<p>Upgrades are sent over the wire in a serialised format and
deserialised at the other end, so they need to be plain first-order
data.</p>
<p>This means we can’t merely send over our typed state machine type
<code>t :: T s a b</code>, or rather the receiver will have to
reconstruct the type information. If this sounds strange, the perhaps
easiest way to convince yourself is to imagine you receive
<code>show t</code> and now you want to reconstruct <code>t</code>. When
you call <code>read (show t)</code> you need to annotate it with what
type to read into, and that’s the problem: at this point you don’t have
the type annotation <code>T s a b</code>.</p>
<p>So the plan around this is to introduce a plain first-order datatype
for upgrades, which can easily be serialised and deserialised, and then
use <em>typechecking</em> to reconstruct the type information.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>UpgradeData_</span> <span>=</span> <span>UpgradeData_</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span> oldState        ::</span> <span>Ty_</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  ,<span> newState        ::</span> <span>Ty_</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  ,<span> newInput        ::</span> <span>Ty_</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  ,<span> newOutput       ::</span> <span>Ty_</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  ,<span> newStateMachine ::</span> <span>U</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  ,<span> stateMigration  ::</span> <span>U</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Read</span>)</span></code></pre></div>
<p>We can to typecheck the above untyped upgrade into the following
typed version.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>UpgradeData</span> s a b <span>=</span> <span>forall</span> s&#39;<span>.</span> <span>Typeable</span> s&#39; <span>=&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span>UpgradeData</span> (<span>T</span> s&#39; a b) (<span>T</span> () s s&#39;)</span></code></pre></div>
<p>The way typechecking for upgrades work is basically the user needs to
provide the untyped types of the state, input and output types of the
new state machine as well as the state migration function, from the
untyped types we can infer the typed types which we then typecheck the
new state machine and migration function against.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>typeCheckUpgrade ::</span> <span>forall</span> s a b<span>.</span> (<span>Typeable</span> s, <span>Typeable</span> a, <span>Typeable</span> b)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                 <span>=&gt;</span> <span>T</span> s a b <span>-&gt;</span> <span>UpgradeData_</span> <span>-&gt;</span> <span>Maybe</span> (<span>UpgradeData</span> s a b)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>typeCheckUpgrade _f (<span>UpgradeData_</span> t_ t&#39;_ a&#39;_ b&#39;_ f_ g_) <span>=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span>case</span> (inferTy t_, inferTy t&#39;_, inferTy a&#39;_, inferTy b&#39;_) <span>of</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (<span>ETy</span> (<span>t ::</span> <span>Ty</span> t), <span>ETy</span> (<span>t&#39; ::</span> <span>Ty</span> t&#39;), <span>ETy</span> (<span>a&#39; ::</span> <span>Ty</span> a&#39;), <span>ETy</span> (<span>b&#39; ::</span> <span>Ty</span> b&#39;)) <span>-&gt;</span> <span>do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span>Refl</span> <span>&lt;-</span> decT <span>@</span>a <span>@</span>a&#39;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span>Refl</span> <span>&lt;-</span> decT <span>@</span>b <span>@</span>b&#39;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span>Refl</span> <span>&lt;-</span> decT <span>@</span>s <span>@</span>t</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      f <span>&lt;-</span> typeCheck f_ t&#39; a&#39; b&#39;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>      g <span>&lt;-</span> typeCheck g_ <span>TUnit</span> t t&#39;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      <span>return</span> (<span>UpgradeData</span> f g)</span></code></pre></div>
<p>Where untyped types are defined as follows:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Ty_</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>UTUnit</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>UTInt</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>UTBool</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>UTString</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>UTPair</span> <span>Ty_</span> <span>Ty_</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>UTEither</span> <span>Ty_</span> <span>Ty_</span></span></code></pre></div>
<p>and typed types as follows:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Ty</span> a <span>where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span>TUnit</span><span>   ::</span> <span>Ty</span> ()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span>TInt</span><span>    ::</span> <span>Ty</span> <span>Int</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span>TBool</span><span>   ::</span> <span>Ty</span> <span>Bool</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span>TString</span><span> ::</span> <span>Ty</span> <span>String</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span>TPair</span><span>   ::</span> <span>Ty</span> a <span>-&gt;</span> <span>Ty</span> b <span>-&gt;</span> <span>Ty</span> (a, b)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span>TEither</span><span> ::</span> <span>Ty</span> a <span>-&gt;</span> <span>Ty</span> b <span>-&gt;</span> <span>Ty</span> (<span>Either</span> a b)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span></code></pre></div>
<p>and the way we infer typed types from the untyped ones is done as
follows:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>ETy</span> <span>where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span>ETy</span><span> ::</span> <span>Typeable</span> a <span>=&gt;</span> <span>Ty</span> a <span>-&gt;</span> <span>ETy</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span>inferTy ::</span> <span>Ty_</span> <span>-&gt;</span> <span>ETy</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>inferTy <span>UTUnit</span> <span>=</span> <span>ETy</span> <span>TUnit</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>inferTy <span>UTInt</span>  <span>=</span> <span>ETy</span> <span>TInt</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>inferTy <span>UTBool</span> <span>=</span> <span>ETy</span> <span>TBool</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>inferTy <span>UTString</span> <span>=</span> <span>ETy</span> <span>TString</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>inferTy (<span>UTPair</span> ua ub) <span>=</span> <span>case</span> (inferTy ua, inferTy ub) <span>of</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  (<span>ETy</span> a, <span>ETy</span> b) <span>-&gt;</span> <span>ETy</span> (<span>TPair</span> a b)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>inferTy (<span>UTEither</span> ua ub) <span>=</span> <span>case</span> (inferTy ua, inferTy ub) <span>of</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  (<span>ETy</span> a, <span>ETy</span> b) <span>-&gt;</span> <span>ETy</span> (<span>TEither</span> a b)</span></code></pre></div>
<p>Now the only piece missing is untyped state machines and how to
typecheck those into typed ones.</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>typeCheck ::</span> <span>U</span> <span>-&gt;</span> <span>Ty</span> s <span>-&gt;</span> <span>Ty</span> a <span>-&gt;</span> <span>Ty</span> b <span>-&gt;</span> <span>Maybe</span> (<span>T</span> s a b)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>U</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>IdU</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>ComposeU</span> <span>U</span> <span>U</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>IntU</span> <span>Int</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>CaseU</span> <span>U</span> <span>U</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>IncrU</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>GetU</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>PutU</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>ReadU</span> <span>Ty_</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>ShowU</span> <span>Ty_</span></span></code></pre></div>
<p>I’ll spare you from the <a href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/TypeCheck/StateMachine.hs">details</a>,
but the main ingredient is to use the <code>Data.Typeable</code>
instances to check if the types match up, similarly to how it was done
above in <code>typeCheckUpgrade</code>.</p>
<h3 id="sources-and-sinks">Sources and sinks</h3>
<p>Almost there. When we deploy a pipeline <code>P a b</code> we need to
provide a <code>Queue (Msg a)</code> and get a
<code>Queue (Msg b)</code>, what are we supposed to do with those
queues? We could manually feed them with items, but for convenience it’s
nice to have some basic reusable adapters that we can connect these
“garden hoses” to.</p>
<p>We call something that provides an input queue a <code>Source</code>
and something that consumes an output queue a <code>Sink</code>. Useful
sources and sinks include stdin/stdout, files, and TCP streams.</p>
<p>We can then implement a run function with the following type:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>run ::</span> (<span>Typeable</span> a, <span>Typeable</span> b)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span>=&gt;</span> <span>Source</span> a <span>-&gt;</span> <span>Codec</span> (<span>Msg</span> a) (<span>Msg</span> b) <span>-&gt;</span> <span>P</span> a b <span>-&gt;</span> <span>Sink</span> b r <span>-&gt;</span> <span>IO</span> r</span></code></pre></div>
<p>Where <code>Codec a b</code> contains a deserialiser from
<code>ByteString</code> to <code>Maybe a</code> and a serialiser from
<code>b</code> to <code>ByteString</code>. We need this because our
sources and sinks produce and consume <code>ByteString</code>s.</p>
<h3 id="remote-upgrades">Remote upgrades</h3>
<p>Putting it all together we can now create a TCP server for our
counter:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>run (<span>FromTCP</span> <span>&#34;127.0.0.1&#34;</span> <span>3000</span>) readShowCodec (<span>SM</span> <span>&#34;counter&#34;</span> <span>0</span> counterV1) <span>ToTCP</span></span></code></pre></div>
<p>If we run the above in a REPL, then from another terminal we can
interact with the server as follows.</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span># Get the current state of the counter.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span>$</span> echo <span>&#39;Item &#34;Left ()&#34;&#39;</span> <span>|</span> <span>nc</span> 127.0.0.1 3000</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span>Item</span> <span>&#34;Left 0&#34;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span># Increment the counter.</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span>$</span> echo <span>&#39;Item &#34;Right ()&#34;&#39;</span> <span>|</span> <span>nc</span> 127.0.0.1 3000</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span>Item</span> <span>&#34;Right ()&#34;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span># Read the counter again.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span>$</span> echo <span>&#39;Item &#34;Left ()&#34;&#39;</span> <span>|</span> <span>nc</span> 127.0.0.1 3000</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span>Item</span> <span>&#34;Left 1&#34;</span></span></code></pre></div>
<p>In order to make life a bit easier for ourselves, we can implement a
simple TCP client in Haskell and use from another REPL to achieve the
same result.</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV1</span>))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>IncrCountV1</span>))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>IncrCountV1</span>))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV1</span>))</span></code></pre></div>
<pre><code>Item &#34;Left 0&#34;               -- The initial value of the counter is 0.
Item &#34;Right ()&#34;             -- Two increments.
Item &#34;Right ()&#34;
Item &#34;Left 2&#34;               -- The value is now 2</code></pre>
<p>At this point, let’s imagine we want to add a reset feature to our
counter. Reset takes no argument and returns nothing, so we use the unit
type in both the input and output types.</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>InputV2</span>  <span>=</span> <span>Either</span> () <span>InputV1</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>OutputV2</span> <span>=</span> <span>Either</span> () <span>OutputV1</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ResetCountV2</span><span> ::</span> <span>InputV2</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ResetCountV2</span> <span>=</span> <span>Left</span> ()</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ReadCountV2</span><span> ::</span> <span>InputV2</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ReadCountV2</span>  <span>=</span> <span>Right</span> <span>ReadCountV1</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>IncrCountV2</span><span> ::</span> <span>InputV2</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>IncrCountV2</span>  <span>=</span> <span>Right</span> <span>IncrCountV1</span></span></code></pre></div>
<p>The state machine looks the same, except for the first
<code>Case</code> where we update the state to be <code>0</code>, thus
resetting the counter.</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>counterV2 ::</span> <span>T</span> <span>Int</span> <span>String</span> <span>String</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>counterV2 <span>=</span> <span>Read</span> <span>&gt;&gt;&gt;</span> counterV2&#39; <span>&gt;&gt;&gt;</span> <span>Show</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span>    counterV2&#39; ::</span> <span>T</span> <span>Int</span> <span>InputV2</span> <span>OutputV2</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    counterV2&#39; <span>=</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>      (<span>Int</span> <span>0</span> <span>&gt;&gt;&gt;</span> <span>Put</span>) <span>`Case`</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span>Get</span> <span>`Case`</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      (<span>Get</span> <span>&gt;&gt;&gt;</span> <span>Incr</span> <span>&gt;&gt;&gt;</span> <span>Put</span>)</span></code></pre></div>
<p>Back in our REPL we can now do the upgrade, by sending over a type
<code>erase</code>d version of <code>counterV2</code>.</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>let</span><span> msg ::</span> <span>Msg</span> ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    msg <span>=</span> <span>Upgrade</span> <span>Nothing</span> <span>&#34;counter&#34;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>            (<span>UpgradeData_</span> <span>UTInt</span> <span>UTInt</span> <span>UTString</span> <span>UTString</span> (erase counterV2) (erase <span>Id</span>))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> msg</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV2</span>))</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ResetCountV2</span>))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV2</span>))</span></code></pre></div>
<p>Which yields the following annotated output.</p>
<pre><code>UpgradeSucceeded &#34;counter&#34;
Item &#34;Right (Left 2)&#34;   -- The counter&#39;s state is preserved by the upgrade.
Item &#34;Left ()&#34;          -- Reset the counter.
Item &#34;Right (Left 0)&#34;   -- The value is back to 0.</code></pre>
<p>As a final example of an upgrade, let’s do a more interesting state
migration. Let’s say we want to add a boolean to the state which
determines if <code>IncrCount</code> should add by <code>1</code> or
<code>-1</code> (i.e. decrement). This boolean can be toggled by the
user using a new operation, while the signatures of the other operations
stay the same as before.</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>InputV3</span>  <span>=</span> <span>Either</span> () <span>InputV2</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>OutputV3</span> <span>=</span> <span>Either</span> () <span>OutputV2</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ToggleCountV3</span><span> ::</span> <span>InputV3</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ToggleCountV3</span> <span>=</span> <span>Left</span> ()</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>ReadCountV3</span>, <span>IncrCountV3</span>, <span>ToggleCountV3</span><span> ::</span> <span>InputV3</span></span></code></pre></div>
<p>In order to implement the toggle operation we need to extend the
syntax of our state machines to be able to deal with booleans and
products (the details can be found <a href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/Interpreter.hs">here</a>).</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span>counterV3 ::</span> <span>T</span> (<span>Int</span>, <span>Bool</span>) <span>String</span> <span>String</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>counterV3 <span>=</span> <span>Read</span> <span>&gt;&gt;&gt;</span> counterV3&#39; <span>&gt;&gt;&gt;</span> <span>Show</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span>    counterV3&#39; ::</span> <span>T</span> (<span>Int</span>, <span>Bool</span>) <span>InputV3</span> <span>OutputV3</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    counterV3&#39; <span>=</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>      <span>-- Toggle negates the boolean in the state (the second component).</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>      (<span>Get</span> <span>&gt;&gt;&gt;</span> <span>Second</span> <span>Not</span> <span>&gt;&gt;&gt;</span> <span>Put</span>) <span>`Case`</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>      <span>-- Reset resets the counter and the boolean back to false (i.e. incrementing).</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>      (<span>Int</span> <span>0</span> <span>:&amp;&amp;&amp;</span> <span>Bool</span> <span>False</span> <span>&gt;&gt;&gt;</span> <span>Put</span>) <span>`Case`</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>      <span>-- Reading the counter picks out the first component from the state.</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>      (<span>Get</span> <span>&gt;&gt;&gt;</span> <span>Fst</span>) <span>`Case`</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>      <span>-- Incrementing or decrementing, depending on the boolean in the state.</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>      (<span>Get</span> <span>&gt;&gt;&gt;</span> <span>If</span> <span>Decr</span> <span>Incr</span> <span>&gt;&gt;&gt;</span> (<span>Id</span> <span>:&amp;&amp;&amp;</span> (<span>Consume</span> <span>&gt;&gt;&gt;</span> <span>Get</span> <span>&gt;&gt;&gt;</span> <span>Snd</span>)) <span>&gt;&gt;&gt;</span> <span>Put</span>)</span></code></pre></div>
<p>We can then upgrade to our new version of the counter as follows.</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <span>let</span><span> msg2 ::</span> <span>Msg</span> ()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>      msg2 <span>=</span> <span>Upgrade</span> <span>Nothing</span> <span>&#34;counter&#34;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>               (<span>UpgradeData_</span> <span>UTInt</span> (<span>UTPair</span> <span>UTInt</span> <span>UTBool</span>) <span>UTString</span> <span>UTString</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                 (erase counterV3) (erase (<span>Id</span> <span>:&amp;&amp;&amp;</span> <span>Bool</span> <span>False</span>)))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> msg2</span></code></pre></div>
<p>Notice how the state is migrated using
<code>Id :&amp;&amp;&amp; Bool False</code>, i.e. create a pair where
the first component is the old value of the state (this is the current
count) and the second component is <code>False</code> (this is whether
we are decrementing).</p>
<p>Here’s a final example of how we can use the new counter.</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV3</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>IncrCountV3</span>))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>IncrCountV3</span>))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV3</span>))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ToggleCountV3</span>))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>IncrCountV3</span>))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  nc <span>&#34;127.0.0.1&#34;</span> <span>3000</span> (<span>Item</span> <span>Nothing</span> (<span>show</span> <span>ReadCountV3</span>))</span></code></pre></div>
<p>The above yields the following output.</p>
<pre><code>UpgradeSucceeded &#34;counter&#34;
Item &#34;Right (Right (Left 0))&#34;   -- The counter is 0.
Item &#34;Right (Right (Right ()))&#34; -- Two increments.
Item &#34;Right (Right (Right ()))&#34;
Item &#34;Right (Right (Left 2))&#34;   -- The counter is 2.
Item &#34;Left ()&#34;                  -- Toggle to decrementing.
Item &#34;Right (Right (Right ()))&#34; -- Decrement.
Item &#34;Right (Right (Left 1))&#34;   -- The value is 1.</code></pre>
<h2 id="discussion-and-future-work">Discussion and future work</h2>
<p>If we look back at the list, from the introduction, of properties
that we wanted from our upgrades, then I hope that I’ve managed to
provide a glimpse of a possible way of achieving zero-downtime upgrades
with type-safe state migrations that are atomic.</p>
<p>Downgrades can be thought of as an upgrade to an earlier version,
although it could be interesting to experiment with requiring an inverse
function to the state migration as part of an upgrade. That way the
system itself could downgrade in case there’s more than N errors within
some time period, or something like that.</p>
<p>I didn’t talk about backwards and forwards compatibility. We could
probably use an <a href="https://en.wikipedia.org/wiki/Interface_description_language">interface
description language</a>, such as Avro or Protobuf, but it could also be
interesting see if we could add input and output migrations as part of
upgrades (in addition to state migrations). Especially in conjunction
with being able to derive them generically and <a href="https://www.manuelbaerenz.de/essence-of-live-coding/EssenceOfLiveCoding.pdf">automatically</a>
from the schema change.</p>
<p>There’s also a bunch of other <a href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/TODO.md">things</a>
that I thought of while working on this, which I don’t have any good
answers for yet. If you feel that I’m missing something, or if you know
some answers or if any of these problems sound interesting to work on,
please do feel free to get in <a href="https://stevana.github.io/about.html">touch</a>!</p>
<p>Let me close by trying to tie it back to Barbara Liskov’s remark
about the need for more complete programming languages. In a world where
software systems are expected to evolve over time, wouldn’t it be neat
if programming languages provided some notion of upgrade and could
typecheck our code <em>across versions</em>, as opposed to merely
typechecking a version of the code in isolation from the next?</p>

</div></div>
  </body>
</html>
