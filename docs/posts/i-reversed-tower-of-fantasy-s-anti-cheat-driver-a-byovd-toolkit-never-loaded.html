<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vespalec.com/blog/tower-of-flaws/">Original</a>
    <h1>I reversed Tower of Fantasy&#39;s anti-cheat driver: a BYOVD toolkit never loaded</h1>
    
    <div id="readability-page-1" class="page"><div> <hr/>
<p>This all started because I wanted to delete my <a href="https://www.toweroffantasy-global.com/en-us/index.html" rel="nofollow noreferrer noopener" target="_blank">Tower of Fantasy</a> account from over 4 years ago.</p>
<p>For the life of me, I couldn’t find a way to do it without having the game installed. There was no web portal and no obvious support route. Eventually I gave up and decided to just download it.</p>
<p>Tower of Fantasy is over 100 GB so it would be a long install. I already knew the game shipped with an anti-cheat driver from past experience, so while the download crawled along I started poking around the launcher directory. That’s when I noticed <code>GameDriverX64.sys</code>.</p>
<p><img src="https://vespalec.com/_astro/driver-directory.BRtOEZKm_k1drg.png" alt="Driver file in directory" loading="lazy" decoding="async" fetchpriority="auto" width="1170" height="782"/></p>
<div>  <p>Kernel drivers run with the highest privileges on your machine. Anti-cheat drivers use this power to protect games from cheaters, but when they’re poorly written, attackers can abuse that same power against you.</p> </div>
<p>I opened the driver in IDA expecting a wall of virtualized code, probably VMProtect. Instead I got clean, readable functions with no obfuscation or virtualization at all.</p>
<p><img src="https://vespalec.com/_astro/ida.CDwpmWIX_297Hmn.png" alt="Driver file in directory" loading="lazy" decoding="async" fetchpriority="auto" width="2559" height="1439"/></p>
<p>By now, the install was at 9%. I had time to dig in.</p>
<div>  <p>There’s a lot of noise online about kernel anti-cheats being “spyware” or inherently privacy-invasive. Most of it misidentifies the actual risk. A usermode game client can already steal your browser cookies, log keystrokes, and exfiltrate files without ever touching the kernel. The real concern with kernel anti-cheats isn’t surveillance, it’s that they are security-critical code running at the highest privilege level. When they’re poorly written, they become attack surface, and when they fail, they can take your entire system down with them (e.g the CrowdStrike incident). For a thorough, level-headed breakdown of the privacy and security tradeoffs, I’d recommend <a href="https://bphilip.uk/blog/2024-07-29-evaluating-kernel-level-anti-cheats-as-a-consumer/" rel="nofollow noreferrer noopener" target="_blank">this post by Bevan Philip</a>.</p> </div>
<hr/>
<h2 id="why-isnt-this-obfuscated">Why Isn’t This Obfuscated?</h2>
<p>The previous version of this driver (<code>KSophon_x64.sys</code>) was VMProtect’d to hell, so I was curious why they’d strip protection from a security-critical kernel component. The reason is due to HVCI.</p>
<div>  <p><strong>HVCI</strong> (Hypervisor-Protected Code Integrity) is a Windows security feature that uses Hyper-V to enforce code integrity above the NT kernel, enabled by default on clean Windows 11 installs. The key constraint: W^X (Write XOR Execute) enforcement means code pages can’t be both writable and executable. VMProtect’s packing and import protection both violate this, so the driver fails integrity checks on HVCI-enabled systems.</p> </div>
<p>VMProtect <em>can</em> still work under HVCI if you stick to mutation and virtualization macros while avoiding the features that break W^X. They could still protect their imports manually and virtualize the bulk of their code. For some reason, they did neither.</p>
<p>Even with VMProtect, these vulnerabilities would still exist. The IOCTLs still do what they do and the authentication is essentially nonexistent. Obfuscation makes reversing harder, not impossible.</p>
<p><img src="https://vespalec.com/_astro/driver-entry.D5-2YsoI_1BNhtt.png" alt="Driver entry in IDA" loading="lazy" decoding="async" fetchpriority="auto" width="2559" height="1439"/></p>
<hr/>
<h2 id="what-the-driver-actually-does">What the Driver Actually Does</h2>
<p>It registers the following device:</p>
<div><figure><pre data-language="plaintext"><code><div><div><p>1</p></div><p><span>Device Name:     \Device\HtAntiCheatDriver</span></p></div><div><div><p>2</p></div><p><span>Symbolic Link:   \\.\HtAntiCheatDriver</span></p></div></code></pre></figure></div>
<h3 id="device-access-control">Device Access Control</h3>
<p>The <code>IRP_MJ_CREATE</code> handler checks whether the calling process has loaded one of three specific DLLs:</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>NTSTATUS </span><span>CreateHandler</span><span>(PDEVICE_OBJECT </span><span>DeviceObject</span><span>, PIRP </span><span>Irp</span><span>) {</span></p></div><div><div><p>2</p></div><p><span><span>  </span></span><span>NTSTATUS Status </span><span>=</span><span> STATUS_UNSUCCESSFUL;</span></p></div><div><div><p>3</p></div></div><div><div><p>4</p></div><p><span>  </span><span>if</span><span> (</span><span>VerifyRequiredModules</span><span>())</span></p></div><div><div><p>5</p></div><p><span><span>    </span></span><span>Status </span><span>=</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>6</p></div></div><div><div><p>7</p></div><p><span><span>  </span></span><span>Irp-&gt;IoStatus.Status </span><span>=</span><span> Status;</span></p></div><div><div><p>8</p></div><p><span><span>  </span></span><span>Irp-&gt;IoStatus.Information </span><span>=</span><span> </span><span>0</span><span>;</span></p></div><div><div><p>9</p></div></div><div><div><p>10</p></div><p><span>  </span><span>IoCompleteRequest</span><span>(Irp, IO_NO_INCREMENT);</span></p></div><div><div><p>11</p></div></div><div><div><p>12</p></div><p><span>  </span><span>return</span><span> Status;</span></p></div><div><div><p>13</p></div><p><span>}</span></p></div><div><div><p>14</p></div></div><div><div><p>15</p></div><p><span>BOOLEAN </span><span>VerifyRequiredModules</span><span>() {</span></p></div><div><div><p>16</p></div><p><span><span>  </span></span><span>UNICODE_STRING QmGUI4, QmGUI, GameUI{};</span></p></div><div><div><p>17</p></div></div><div><div><p>18</p></div><p><span>  </span><span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>QmGUI4, L</span><span>&#34;QmGUI4.dll&#34;</span><span>);</span></p></div><div><div><p>19</p></div><p><span>  </span><span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>QmGUI, L</span><span>&#34;QmGUI.dll&#34;</span><span>);</span></p></div><div><div><p>20</p></div><p><span>  </span><span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>GameUI, L</span><span>&#34;gameuirender.dll&#34;</span><span>);</span></p></div><div><div><p>21</p></div></div><div><div><p>22</p></div><p><span>  </span><span>// Get the PEB of the calling process</span></p></div><div><div><p>23</p></div><p><span><span>  </span></span><span>PEPROCESS Process </span><span>=</span><span> </span><span>IoGetCurrentProcess</span><span>();</span></p></div><div><div><p>24</p></div><p><span><span>  </span></span><span>PPEB Peb </span><span>=</span><span> </span><span>PsGetProcessPeb</span><span>(Process);</span></p></div><div><div><p>25</p></div><p><span><span>  </span></span><span>PPEB_LDR_DATA Ldr </span><span>=</span><span> Peb-&gt;Ldr;</span></p></div><div><div><p>26</p></div></div><div><div><p>27</p></div><p><span><span>  </span></span><span>PLIST_ENTRY Head </span><span>=</span><span> </span><span>&amp;</span><span>Ldr-&gt;InLoadOrderModuleList;</span></p></div><div><div><p>28</p></div><p><span><span>  </span></span><span>PLIST_ENTRY Entry </span><span>=</span><span> Head-&gt;Flink;</span></p></div><div><div><p>29</p></div></div><div><div><p>30</p></div><p><span>  </span><span>// Walk the loaded module list and check each DLL name</span></p></div><div><div><p>31</p></div><p><span>  </span><span>while</span><span> (Entry </span><span>!=</span><span> Head) {</span></p></div><div><div><p>32</p></div><p><span><span>    </span></span><span>PLDR_DATA_TABLE_ENTRY Module </span><span>=</span><span> </span><span>CONTAINING_RECORD</span><span>(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span></p></div><div><div><p>33</p></div></div><div><div><p>34</p></div><p><span>    </span><span>if</span><span> (</span><span>RtlCompareUnicodeString</span><span>(</span><span>&amp;</span><span>Module-&gt;BaseDllName, </span><span>&amp;</span><span>QmGUI4, </span><span>TRUE</span><span>) </span><span>==</span><span> </span><span>0</span><span> </span><span>||</span></p></div><div><div><p>35</p></div><p><span>        </span><span>RtlCompareUnicodeString</span><span>(</span><span>&amp;</span><span>Module-&gt;BaseDllName, </span><span>&amp;</span><span>QmGUI, </span><span>TRUE</span><span>) </span><span>==</span><span> </span><span>0</span><span>  </span><span>||</span></p></div><div><div><p>36</p></div><p><span>        </span><span>RtlCompareUnicodeString</span><span>(</span><span>&amp;</span><span>Module-&gt;BaseDllName, </span><span>&amp;</span><span>GameUI, </span><span>TRUE</span><span>) </span><span>==</span><span> </span><span>0</span><span>) {</span></p></div><div><div><p>37</p></div><p><span>      </span><span>return</span><span> </span><span>TRUE</span><span>;</span></p></div><div><div><p>38</p></div><p><span><span>    </span></span><span>}</span></p></div><div><div><p>39</p></div></div><div><div><p>40</p></div><p><span><span>    </span></span><span>Entry </span><span>=</span><span> Entry-&gt;Flink;</span></p></div><div><div><p>41</p></div><p><span><span>  </span></span><span>}</span></p></div><div><div><p>42</p></div></div><div><div><p>43</p></div><p><span>  </span><span>return</span><span> </span><span>FALSE</span><span>;</span></p></div><div><div><p>44</p></div><p><span>}</span></p></div></code></pre></figure></div>
<p>In practice, you don’t even need the real DLLs. The check only looks at module names in your PEB, so you can rename literally any DLL to <code>QmGUI.dll</code> for example and load it. My PoC just copies <code>version.dll</code> from System32 and renames it.</p>
<h3 id="handle-protection">Handle Protection</h3>
<p>The driver registers <code>ObRegisterCallbacks</code> to intercept handle operations on protected processes and strip dangerous access rights. The callbacks look like this:</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>NTSTATUS </span><span>ProcessPreCallback</span><span>(PVOID </span><span>RegistrationContext</span><span>, POB_PRE_OPERATION_INFO </span><span>OperationInfo</span><span>) {</span></p></div><div><div><p>2</p></div><p><span><span>  </span></span><span>PEPROCESS TargetProcess </span><span>=</span><span> OperationInfo-&gt;Object;</span></p></div><div><div><p>3</p></div><p><span><span>  </span></span><span>PEPROCESS CurrentProcess </span><span>=</span><span> </span><span>IoGetCurrentProcess</span><span>();</span></p></div><div><div><p>4</p></div></div><div><div><p>5</p></div><p><span>  </span><span>if</span><span> (</span><span>!</span><span>IsProtectedProcess</span><span>(TargetProcess))</span></p></div><div><div><p>6</p></div><p><span>    </span><span>return</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>7</p></div></div><div><div><p>8</p></div><p><span>  </span><span>if</span><span> (TargetProcess </span><span>==</span><span> CurrentProcess)</span></p></div><div><div><p>9</p></div><p><span>    </span><span>return</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>10</p></div></div><div><div><p>11</p></div><p><span>  </span><span>if</span><span> (</span><span>IsProtectedProcess</span><span>(CurrentProcess) </span><span>||</span><span> </span><span>IsWhitelistedProcess</span><span>(CurrentProcess))</span></p></div><div><div><p>12</p></div><p><span>    </span><span>return</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>13</p></div></div><div><div><p>14</p></div><p><span>  </span><span>// Strips: VM_READ, VM_WRITE, VM_OPERATION, DUP_HANDLE, SET_INFORMATION, SUSPEND_RESUME</span></p></div><div><div><p>15</p></div><p><span><span>  </span></span><span>OperationInfo-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess </span><span>&amp;=</span><span> </span><span>0x</span><span>FFFFF587</span><span>;</span></p></div><div><div><p>16</p></div></div><div><div><p>17</p></div><p><span>  </span><span>return</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>18</p></div><p><span>}</span></p></div><div><div><p>19</p></div></div><div><div><p>20</p></div><p><span>NTSTATUS </span><span>ThreadPreCallback</span><span>(PVOID </span><span>RegistrationContext</span><span>, POB_PRE_OPERATION_INFO </span><span>OperationInfo</span><span>) {</span></p></div><div><div><p>21</p></div><p><span><span>  </span></span><span>PETHREAD TargetThread </span><span>=</span><span> OperationInfo-&gt;Object;</span></p></div><div><div><p>22</p></div><p><span><span>  </span></span><span>PEPROCESS TargetProcess </span><span>=</span><span> </span><span>IoThreadToProcess</span><span>(TargetThread);</span></p></div><div><div><p>23</p></div><p><span><span>  </span></span><span>PEPROCESS CurrentProcess </span><span>=</span><span> </span><span>IoGetCurrentProcess</span><span>();</span></p></div><div><div><p>24</p></div></div><div><div><p>25</p></div><p><span>  </span><span>if</span><span> (</span><span>!</span><span>IsProtectedProcess</span><span>(TargetProcess))</span></p></div><div><div><p>26</p></div><p><span>    </span><span>return</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>27</p></div></div><div><div><p>28</p></div><p><span>  </span><span>// Same whitelist checks...</span></p></div><div><div><p>29</p></div></div><div><div><p>30</p></div><p><span>  </span><span>// Strips: TERMINATE, SUSPEND_RESUME, SET_CONTEXT</span></p></div><div><div><p>31</p></div><p><span><span>  </span></span><span>OperationInfo-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess </span><span>&amp;=</span><span> </span><span>0x</span><span>FFFFFFEC</span><span>;</span></p></div><div><div><p>32</p></div></div><div><div><p>33</p></div><p><span>  </span><span>return</span><span> STATUS_SUCCESS;</span></p></div><div><div><p>34</p></div><p><span>}</span></p></div></code></pre></figure></div>
<p>Notably, <code>PROCESS_TERMINATE</code> is <strong>not</strong> stripped from process handles, so external processes can still kill the game.</p>
<p>Before stripping, the callback checks a whitelist. One entry is hardcoded for <code>&#34;CrashCapture.e&#34;</code> (their crash handler) with zero integrity verification. The <code>.e</code> extension isn’t a typo by the way, <code>PsGetProcessImageFileName</code> returns from <code>EPROCESS.ImageFileName</code>, a 15-byte array, so “CrashCapture.exe” (16 chars) gets truncated to 14 chars + null. The check itself is just a filename comparison:</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>bool</span><span> </span><span>IsWhitelistedProcess</span><span>(PEPROCESS </span><span>Process</span><span>) {</span></p></div><div><div><p>2</p></div><p><span>  </span><span>char*</span><span> ProcessName </span><span>=</span><span> </span><span>PsGetProcessImageFileName</span><span>(Process);</span></p></div><div><div><p>3</p></div></div><div><div><p>4</p></div><p><span>  </span><span>// Hardcoded whitelist entry, no integrity check</span></p></div><div><div><p>5</p></div><p><span>  </span><span>if</span><span> (</span><span>strnicmp</span><span>(ProcessName, </span><span>&#34;CrashCapture.e&#34;</span><span>, </span><span>strlen</span><span>(ProcessName)) </span><span>==</span><span> </span><span>0</span><span>)</span></p></div><div><div><p>6</p></div><p><span>    </span><span>return</span><span> </span><span>true</span><span>;</span></p></div><div><div><p>7</p></div></div><div><div><p>8</p></div><p><span>  </span><span>// Dynamically whitelisted entries</span></p></div><div><div><p>9</p></div><p><span>  </span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> WhitelistCount; i</span><span>++</span><span>) {</span></p></div><div><div><p>10</p></div><p><span>    </span><span>if</span><span> (</span><span>strnicmp</span><span>(ProcessName, </span><span>Whitelist</span><span>[i].Name, </span><span>strlen</span><span>(ProcessName)) </span><span>==</span><span> </span><span>0</span><span>) {</span></p></div><div><div><p>11</p></div><p><span>      </span><span>// &#34;Validation&#34; that compare PE checksum from PEB</span></p></div><div><div><p>12</p></div><p><span><span>      </span></span><span>PPEB Peb </span><span>=</span><span> </span><span>PsGetProcessPeb</span><span>(Process);</span></p></div><div><div><p>13</p></div><p><span><span>      </span></span><span>PIMAGE_NT_HEADERS NtHeaders </span><span>=</span><span> </span><span>RtlImageNtHeader</span><span>(Peb-&gt;ImageBaseAddress);</span></p></div><div><div><p>14</p></div></div><div><div><p>15</p></div><p><span>      </span><span>if</span><span> (NtHeaders-&gt;OptionalHeader.CheckSum </span><span>==</span><span> </span><span>Whitelist</span><span>[i].ExpectedChecksum)</span></p></div><div><div><p>16</p></div><p><span>        </span><span>return</span><span> </span><span>true</span><span>;</span></p></div><div><div><p>17</p></div><p><span><span>    </span></span><span>}</span></p></div><div><div><p>18</p></div><p><span><span>  </span></span><span>}</span></p></div><div><div><p>19</p></div></div><div><div><p>20</p></div><p><span>  </span><span>return</span><span> </span><span>false</span><span>;</span></p></div><div><div><p>21</p></div><p><span>}</span></p></div></code></pre></figure></div>
<p>There’s also a subtle bug here: the <code>strnicmp</code> calls use <code>strlen(ProcessName)</code> as the comparison length, not the length of the constant string. This means the comparison is a <strong>prefix match</strong>. Any process whose name is a prefix of the whitelist entry will pass. A process named <code>&#34;Crash&#34;</code> or even <code>&#34;C&#34;</code> would match <code>&#34;CrashCapture.e&#34;</code>. The same bug applies to every dynamic whitelist entry.</p>
<p>Dynamic whitelist entries do one more check: comparing the caller’s <code>OptionalHeader.CheckSum</code> against a stored value. PE checksums aren’t cryptographic though, so anyone can set them to any value with a hex editor.</p>
<p>There’s also a background thread that runs anti-debug and integrity checks in a loop:</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>void</span><span> </span><span>MonitoringThread</span><span>() {</span></p></div><div><div><p>2</p></div><p><span>  </span><span>while</span><span> (</span><span>true</span><span>) {</span></p></div><div><div><p>3</p></div><p><span>    </span><span>KdDisableDebugger</span><span>();</span></p></div><div><div><p>4</p></div><p><span>    </span><span>KdChangeOption</span><span>(KD_OPTION_SET_BLOCK_ENABLE, </span><span>1</span><span>, ...);</span></p></div><div><div><p>5</p></div></div><div><div><p>6</p></div><p><span>    </span><span>if</span><span> (KdDebuggerEnabled)</span></p></div><div><div><p>7</p></div><p><span>      </span><span>TerminateAllProtected</span><span>();</span></p></div><div><div><p>8</p></div></div><div><div><p>9</p></div><p><span><span>    </span></span><span>KdDebuggerEnabled </span><span>=</span><span> </span><span>0</span><span>;</span></p></div><div><div><p>10</p></div></div><div><div><p>11</p></div><p><span>    </span><span>Sleep</span><span>(</span><span>40000</span><span>);</span></p></div><div><div><p>12</p></div></div><div><div><p>13</p></div><p><span>    </span><span>// Self-integrity: CRC32 check on driver memory regions</span></p></div><div><div><p>14</p></div><p><span>    </span><span>if</span><span> (</span><span>!</span><span>VerifyIntegrity</span><span>(...))</span></p></div><div><div><p>15</p></div><p><span>      </span><span>TerminateAllProtected</span><span>();</span></p></div><div><div><p>16</p></div><p><span><span>  </span></span><span>}</span></p></div><div><div><p>17</p></div><p><span>}</span></p></div></code></pre></figure></div>
<p>Plus a process creation callback that kills all protected processes if it sees <code>GPUView.exe</code> or <code>xperf.exe</code> launch, neither of which are reverse engineering tools. My best guess is this was cargo-culted from another anti-cheat driver’s blocklist.</p>
<hr/>
<h2 id="the-ioctl-interface">The IOCTL Interface</h2>
<p>The driver exposes 10 IOCTL codes, 7 of which are interesting:</p>





































<table><thead><tr><th>IOCTL Code</th><th>Purpose</th></tr></thead><tbody><tr><td><code>0x222000</code></td><td>Check if debugger attached via debug port</td></tr><tr><td><code>0x222004</code></td><td><strong>Register a process as “protected”</strong></td></tr><tr><td><code>0x222008</code></td><td>Heartbeat/keepalive</td></tr><tr><td><code>0x222020</code></td><td>Get list of protected processes</td></tr><tr><td><code>0x222040</code></td><td><strong>Terminate any process by PID</strong></td></tr><tr><td><code>0x222044</code></td><td>Strip handle access rights via ExEnumHandleTable</td></tr><tr><td><code>0x222048</code></td><td>Validate memory checksum</td></tr></tbody></table>
<p>The remaining three (<code>0x222080</code>, <code>0x222084</code>, <code>0x222088</code>) expose kernel memory scanning and module enumeration. Not the main finding here, but worth noting they exist behind the same weak authentication.</p>
<hr/>
<h2 id="the-authentication-mechanism-or-lack-thereof">The Authentication Mechanism (Or Lack Thereof)</h2>
<p>Every IOCTL is “protected” by this:</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>NTSTATUS </span><span>DispatchDeviceControl</span><span>(PDEVICE_OBJECT </span><span>DeviceObject</span><span>, PIRP </span><span>Irp</span><span>) {</span></p></div><div><div><p>2</p></div><p><span>  </span><span>if</span><span> (InputBuffer-&gt;Magic </span><span>!=</span><span> </span><span>0x</span><span>FA123456</span><span>)</span></p></div><div><div><p>3</p></div><p><span>    </span><span>return</span><span> STATUS_ACCESS_DENIED;</span></p></div><div><div><p>4</p></div></div><div><div><p>5</p></div><p><span>  </span><span>//</span></p></div><div><div><p>6</p></div><p><span>  </span><span>// Process IOCTL...</span></p></div><div><div><p>7</p></div><p><span>  </span><span>//</span></p></div><div><div><p>8</p></div><p><span>}</span></p></div></code></pre></figure></div>
<p><img src="https://vespalec.com/_astro/magic-key.BGgFfc0Q_Z8WkbG.png" alt="Magic key check 1" loading="lazy" decoding="async" fetchpriority="auto" width="543" height="487"/></p>
<p>A hardcoded 32-bit magic value. No cryptographic verification, no challenge-response, no signature validation. The driver is unobfuscated, so anyone can just read the value out of the binary and call whatever IOCTL they want.</p>
<h3 id="four-layers-none-of-them-do-anything">Four Layers, None of Them Do Anything</h3>
<p>The full “authentication” stack:</p>
<ol>
<li><strong>DLL presence check</strong> - bypassed by loading any renamed DLL</li>
<li><strong>Process name whitelist</strong> - bypassed by renaming your executable</li>
<li><strong>PE checksum validation</strong> - bypassed by writing 4 bytes with a hex editor</li>
<li><strong>Hardcoded magic number</strong> - bypassed by reading the binary</li>
</ol>
<hr/>
<h2 id="vulnerability-1-arbitrary-process-termination">Vulnerability #1: Arbitrary Process Termination</h2>
<p>IOCTL <code>0x222040</code> terminates any process on the system:</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>struct</span><span> TERMINATE_REQUEST {</span></p></div><div><div><p>2</p></div><p><span><span>  </span></span><span>DWORD Magic;</span><span>      // 0xFA123456</span></p></div><div><div><p>3</p></div><p><span><span>  </span></span><span>DWORD ProcessId;</span><span>  // PID to kill</span></p></div><div><div><p>4</p></div><p><span>};</span></p></div></code></pre></figure></div>
<p>The IOCTL dispatch routine validates the magic field, then passes just the PID to an internal <code>TerminateProcess</code> function. That function calls <code>ZwOpenProcess</code> with <code>GENERIC_ALL</code> (<code>0x10000000</code>), then <code>ZwTerminateProcess</code>. The <code>Zw</code> prefix is important here: <code>Zw*</code> functions set <code>PreviousMode</code> to <code>KernelMode</code> before entering the system service, which tells the object manager to skip security descriptor checks on the target process entirely. If they’d used the <code>Nt*</code> variants instead, the call would inherit the original caller’s previous mode and could actually be denied. But with <code>Zw*</code>, no access check will block the open. <code>GENERIC_ALL</code> maps to every access right, so the returned handle can do anything. Antivirus, EDR agents, system services, even PPL (Protected Process Light) processes are not safe. <code>ZwTerminateProcess</code> from kernel mode bypasses PPL protection entirely, which means even processes that Windows itself is supposed to shield from tampering are killable through this driver.</p>
<p><img src="https://vespalec.com/_astro/terminate.D_2VMgnO_H98lt.png" alt="Terminate process handler in IDA" loading="lazy" decoding="async" fetchpriority="auto" width="749" height="297"/></p>
<hr/>
<h2 id="vulnerability-2-arbitrary-process-protection">Vulnerability #2: Arbitrary Process Protection</h2>
<p>IOCTL <code>0x222004</code> registers <strong>any process</strong> as “protected.” The same <code>ObRegisterCallbacks</code> that strip handle access rights for the game now apply to whatever PID you pass in.</p>
<div><figure><pre data-language="c"><code><div><div><p>1</p></div><p><span>struct</span><span> PROTECT_REQUEST {</span></p></div><div><div><p>2</p></div><p><span><span>  </span></span><span>DWORD Magic;</span><span>      // 0xFA123456</span></p></div><div><div><p>3</p></div><p><span><span>  </span></span><span>DWORD ProcessId;</span><span>  // PID to protect</span></p></div><div><div><p>4</p></div><p><span><span>  </span></span><span>DWORD GroupId;</span><span>    // Protection group identifier</span></p></div><div><div><p>5</p></div><p><span><span>  </span></span><span>DWORD Reserved;</span></p></div><div><div><p>6</p></div><p><span>};</span></p></div></code></pre></figure></div>
<p>This doesn’t make your process invisible on its own. EDR agents register kernel callbacks (<code>PsSetCreateProcessNotifyRoutine</code>, <code>PsSetLoadImageNotifyRoutine</code>) to inject their monitoring DLLs during early process creation, before your entry point or even TLS callbacks run. By the time your code can call this IOCTL, the EDR’s hooks are already in your process.</p>
<p>What this does block is <em>future</em> handle operations. <code>ObRegisterCallbacks</code> intercepts both <code>OB_OPERATION_HANDLE_CREATE</code> and <code>OB_OPERATION_HANDLE_DUPLICATE</code>, so it covers <code>NtOpenProcess</code> and <code>NtDuplicateObject</code>. Important detail: the callback can’t outright deny the open. It strips access bits from the <code>DesiredAccess</code> mask, so the call still succeeds but returns a handle with reduced permissions (no <code>PROCESS_VM_READ</code>, no <code>PROCESS_VM_WRITE</code>, etc). Functionally useless for the caller.</p>
<p>That leaves existing handles. Any handles the EDR already holds from before the IOCTL remain valid with their original access rights. But the driver has a solution for that too: IOCTL <code>0x222044</code> calls <code>ExEnumHandleTable</code> to walk the system handle table and retroactively strip access rights from existing handles pointing at a target process. So the full protection chain doesn’t even require killing anything:</p>
<ol>
<li><code>0x222004</code> to register your PID as protected (blocks future handles via <code>ObRegisterCallbacks</code>)</li>
<li><code>0x222044</code> to strip all existing handles to your process (kills current EDR handles via <code>ExEnumHandleTable</code>)</li>
</ol>
<p>New handles get stripped on creation, existing handles get stripped after the fact. Combine that with Vulnerability #1 to kill the EDR service entirely and you have the complete BYOVD toolkit. If you remember <a href="https://github.com/kkent030315/evil-mhyprot-cli" rel="nofollow noreferrer noopener" target="_blank">mhyprot2</a> (the Genshin Impact driver that got <a href="https://www.trendmicro.com/en_us/research/22/h/ransomware-actor-abuses-genshin-impact-anti-cheat-driver-to-kill-antivirus.html" rel="nofollow noreferrer noopener" target="_blank">weaponized by ransomware groups</a>), this driver has the same kill-then-shield capability exposed through a comparably weak authentication mechanism.</p>
<hr/>
<h2 id="they-dont-even-use-it">They Don’t Even Use It</h2>
<p>After documenting all of this, I actually launched the game to see the driver in action.</p>
<p>It wasn’t running. I checked for a loaded driver, checked for associated services, tried deleting the file to see if anything held a handle. Nothing. The driver just sits in the game directory and never gets loaded.</p>
<p>The game process isn’t protected either. No <code>ObRegisterCallbacks</code> stripping handle access. You can freely open a handle and read/write its memory.</p>
<div>  <p>They ship a kernel driver with hardcoded authentication and full BYOVD capabilities, and they don’t even load it. It just sits on every player’s machine. Good to know.</p> </div>
<hr/>
<h2 id="proof-of-concept">Proof of Concept</h2>
<p>I wrote a PoC demonstrating both vulnerabilities. It bypasses the DLL check by loading one of the required DLLs, opens a handle to the driver, and first registers notepad.exe as a protected process via IOCTL <code>0x222004</code>. Once protected, it waits for you to press Delete, then terminates it via IOCTL <code>0x222040</code> with the magic value.</p>
<p>Full source on GitHub: <a href="https://github.com/svespalec/TowerOfFlaws" rel="nofollow noreferrer noopener" target="_blank">TowerOfFlaws</a></p>
<video src="/_astro/demo.DQIW4Q90.mp4" controls="" muted="" playsinline=""></video>
<hr/>
<h2 id="disclosure">Disclosure</h2>
<p>Someone already filed a CVE for this driver (<strong>CVE-2025-61155</strong>) before I started this work, but the entry has no writeup, no PoC, and no technical details. As far as I can tell, this is the first public documentation of how these vulnerabilities actually work. The driver isn’t actively loaded by the game (reducing immediate attack surface), the techniques involved are straightforward enough that any motivated attacker would find them independently, and if nothing else it’s a good reference for other anti-cheat vendors and driver developers on what not to do.</p>
<p><img src="https://vespalec.com/_astro/cve.Cfim3gqT_Z1fNBit.png" alt="CVE entry" loading="lazy" decoding="async" fetchpriority="auto" width="1419" height="344"/></p>
<hr/>
<h2 id="takeaways">Takeaways</h2>
<p><a href="https://github.com/kkent030315/evil-mhyprot-cli" rel="nofollow noreferrer noopener" target="_blank">mhyprot2</a> already proved that anti-cheat drivers make high-value BYOVD targets. This driver has the same capabilities behind weaker authentication, and it shipped anyway. HVCI doesn’t kill obfuscation entirely, but it does break major features like packing and import protection that protectors like VMProtect offer. It’s possible some vendors just see their protected driver fail on HVCI systems and strip it entirely without understanding what specifically broke. Code obfuscation is still possible under HVCI, just more constrained, and if your security model depended on it, you were already in trouble.</p>
<p>If you’re shipping a kernel driver and want to make sure it doesn’t end up as someone’s next blog post, feel free to <a href="https://vespalec.com/cdn-cgi/l/email-protection#5f2c293a2c2f3e333a3c1f2f3271323a">reach out</a>.</p>
<p>Thanks for reading!</p> </div></div>
  </body>
</html>
