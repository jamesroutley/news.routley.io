<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/02/8086-modrm-addressing.html">Original</a>
    <h1>Reverse-engineering the ModR/M addressing microcode in the Intel 8086 processor</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8745122849902587790" itemprop="description articleBody">



<p>One interesting aspect of a computer&#39;s instruction set is its addressing modes, how the computer determines the
address for a memory access.
The Intel 8086 (1978) used the
<a href="https://en.wikipedia.org/wiki/ModR/M">ModR/M</a> byte, a special byte following the opcode, to select the addressing mode.<span id="fnref:immediate"><a href="#fn:immediate">1</a></span>
The ModR/M byte has persisted into the modern x86 architecture, so it&#39;s interesting to look at its roots and original implementation.</p>
<p>In this post, I look at the hardware and microcode in the 8086 that implements ModR/M<span id="fnref:modes"><a href="#fn:modes">2</a></span>
and how the 8086 designers fit multiple addressing modes into the 8086&#39;s limited microcode ROM.
One technique was a hybrid approach that combined generic microcode with hardware logic that filled in the details for a particular instruction.
A second technique was modular microcode, with subroutines for various parts of the task.</p>
<p>I&#39;ve been reverse-engineering the 8086 starting with the silicon die.
The die photo below shows the chip under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes instructions and microcode.
Both units play important roles in memory addressing.</p>
<p><a href="https://static.righto.com/images/8086-addressing/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." height="622" src="https://static.righto.com/images/8086-addressing/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.</p>
<h2>8086 addressing modes</h2>
<p>Let&#39;s start with an addition instruction, <code>ADD</code> <em>dst</em>,<em>src</em>, which adds a source value to a destination value and stores the result in the destination.<span id="fnref:assembly"><a href="#fn:assembly">3</a></span>
What are the source and destination? Memory? Registers? The addressing mode answers this question.</p>
<p>You can use a register as the source and another register as the destination.
The instruction below uses the <code>AX</code> register as the destination and the <code>BX</code> register as the source. Thus, it adds <code>BX</code> to <code>AX</code> and puts the result
in <code>AX</code>.</p>
<pre>ADD AX, BX           <span>Add the contents of the BX register to the AX register</span>
</pre>

<p>A memory access is indicated with square brackets around the &#34;effective address&#34;<span id="fnref:effective-address"><a href="#fn:effective-address">4</a></span> to access.
For instance, <code>[1234]</code> means the memory location with address 1234,
while <code>[BP]</code> means the memory location that the <code>BP</code> register points to.
For a more complicated addressing mode, <code>[BP+SI+1234]</code> means the memory location is determined by adding the BP and SI registers to the constant 1234 (known as the displacement).
On the 8086, you can use memory for the source or the destination, but not both.
Here are some examples of using memory as a source:</p>
<pre>ADD AX, [1234]       <span>Add the contents of memory location 1234 to AX register</span>
ADD CX, [BP]         <span>Add memory pointed to by BP register to CX register</span>
ADD DX, [BX+SI+1234] <span>Source memory address is BX + SI + constant 1234</span>
</pre>

<p>Here are examples with memory as the destination:</p>
<pre>ADD [1234], AX       <span>Add AX to the contents of memory location 1234</span>
ADD [BP], CX         <span>Add CX to memory pointed to by BP register</span>
ADD [BX+SI+1234], DX <span>Destination memory address is BX + SI + constant 1234</span>
</pre>

<p>You can also operate on bytes instead of words, using a byte register and accessing a memory byte:</p>
<pre>ADD AL, [SI+1234]    <span>Add to the low byte of AX register</span>
ADD AH, [BP+DI+1234] <span>Add to the high byte of AX register</span>
</pre>

<p>As you can see, the 8086 supports many different addressing schemes.
To understand how they are implemented, we must first look at how instructions encode the addressing schemes in the ModR/M byte.</p>
<h2>The ModR/M byte</h2>
<p>The ModR/M byte follows many opcodes to specify the addressing mode.
This byte is fairly complicated but I&#39;ll try to explain it in this section.
The diagram below shows how the byte is split into three fields:<span id="fnref:octal"><a href="#fn:octal">5</a></span>
<code>mod</code> selects the overall mode, <code>reg</code> selects a register, and <code>r/m</code> selects either a register or memory mode.</p>


<table>
<tbody><tr><th colspan="2">mod</th><th colspan="3">reg</th><th colspan="3">r/m</th></tr><tr>
</tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</tbody></table>

<p>I&#39;ll start with the register-register mode, where the <code>mod</code> bits are <span>11</span> and the <code>reg</code> and <code>r/m</code> fields each select one of eight registers, as shown below.
The instruction <code>ADD AX,BX</code> would use <code>reg</code>=<span>011</span> to select <code>BX</code> and <code>r/m</code>=<span>000</span> to select <code>AX</code>, so the ModR/M byte would be
<span>11</span><span>011</span><span>000</span>.
(The register assignment depends on whether the instruction operates on words, bytes, or segment registers.
For instance, in a word instruction, <code>001</code> selects the <code>CX</code> register, while in a byte instruction, <code>001</code> selects the <code>CL</code> register, the low byte of <code>CX</code>.)</p>
<p><a href="https://static.righto.com/images/8086-addressing/reg-assignments.jpg"><img alt="The register assignments, from MCS-86 Assembly Language Reference Guide." height="189" src="https://static.righto.com/images/8086-addressing/reg-assignments-w400.jpg" title="The register assignments, from MCS-86 Assembly Language Reference Guide." width="400"/></a></p>
<p>The next addressing mode specifies a memory argument and a register argument. In this case, the <code>mod</code> bits are <span>00</span>, the <code>reg</code> field specifies a
register as described above, and the <code>r/m</code> field specifies a memory address according to the table below.
For example, the instruction <code>ADD [SI],CX</code> would use <code>reg</code>=<span>001</span> to select <code>CX</code> and <code>r/m</code>=<span>100</span> to select <code>[SI]</code>, so the ModR/M byte would be
<span>00</span><span>001</span><span>100</span>.</p>

<table>
<tbody><tr><th>r/m</th><th>Operand Address</th></tr>
<tr><td>000</td><td>[BX+SI]</td></tr>
<tr><td>001</td><td>[BX+DI]</td></tr>
<tr><td>010</td><td>[BP+SI]</td></tr>
<tr><td>011</td><td>[BP+DI]</td></tr>
<tr><td>100</td><td>[SI]</td></tr>
<tr><td>101</td><td>[DI]</td></tr>
<tr><td>110</td><td>[BP]</td></tr>
<tr><td>111</td><td>[BX]</td></tr>
</tbody></table>

<p>The next mode, <span>01</span>, adds an 8-bit signed displacement to the address. This displacement consists of one byte
following the ModR/M byte. This supports addressing modes such as <code>[BP+5]</code>.
The mode <span>10</span> is similar except the displacement is two bytes long,
for addressing modes such as <code>[BP+DI+0x1234]</code>.</p>
<!--

![A summary of the ModR/M byte, from <a href="http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf">MCS-86 Assembly Language Reference Guide</a>.](modrm.jpg "w500")



The diagram below summarizes the ModR/M byte.

<table class="modrm">
<tr><th style="vertical-align:bottom" rowspan=2>r/m</th><th class="bl" colspan=3>Effective Address</th><th colspan=2 class="bl">Register, mod=11</th></tr>
<tr><th class="bl">mod=00</th><th>mod=01</th><th>mod=10</th><th class="bl">W=0</th><th>W=1</th></tr>
<tr><td>000</td><td class="bl">(BX)+(SI)</td><td>(BX)+(SI)+d8</td><td>(BX)+(SI)+d16</td><td class="bl c">AL</td><td class="c">AX</td></tr>
<tr><td>001</td><td class="bl">(BX)+(DI)</td><td>(BX)+(DI)+d8</td><td>(BX)+(DI)+d16</td><td class="bl c">CL</td><td class="c">CX</td></tr>
<tr><td>010</td><td class="bl">(BP)+(SI)</td><td>(BP)+(SI)+d8</td><td>(BP)+(SI)+d16</td><td class="bl c">DL</td><td class="c">DX</td></tr>
<tr><td>011</td><td class="bl">(BP)+(DI)</td><td>(BP)+(DI)+d8</td><td>(BP)+(DI)+d16</td><td class="bl c">BL</td><td class="c">BX</td></tr>
<tr><td>100</td><td class="bl">(SI)</td><td>(SI)+d8</td><td>(SI)+d16</td><td class="bl c">AH</td><td class="c">SP</td></tr>
<tr><td>101</td><td class="bl">(DI)</td><td>(DI)+d8</td><td>(DI)+d16</td><td class="bl c">CH</td><td class="c">BP</td></tr>
<tr><td>110</td><td class="bl">direct access</td><td>(BP)+d8</td><td>(BP)+d16</td><td class="bl c">DH</td><td class="c">SI</td></tr>
<tr><td>111</td><td class="bl">(BX)</td><td>(BX)+d8</td><td>(BX)+d16</td><td class="bl c">BH</td><td class="c">DI</td></tr>
</table>
-->

<p>The table below shows the meaning of all 256 values for the ModR/M byte.
The <code>mod</code> bits are colored red, the <code>reg</code> bits green, and the <code>r/m</code> bits blue.
Note the special case &#34;disp16&#34; to support a 16-bit fixed address.</p>
<p><a href="https://static.righto.com/images/8086-addressing/modrm.png"><img alt="The ModR/M values. Note that this table would be trivial if it used octal rather than hexadecimal. Based on Table 6-13 in the ASM386 Assembly Language Reference." height="619" src="https://static.righto.com/images/8086-addressing/modrm-w600.png" title="The ModR/M values. Note that this table would be trivial if it used octal rather than hexadecimal. Based on Table 6-13 in the ASM386 Assembly Language Reference." width="600"/></a></p><p>The ModR/M values. Note that this table would be trivial if it used octal rather than hexadecimal. Based on Table 6-13 in the <a href="http://bitsavers.org/pdf/intel/iRMX/iRMX_III/iRMX_III_V2.2/469165-003_ASM386_Assembly_Language_Reference_1995.pdf">ASM386 Assembly Language Reference</a>.</p>
<p>The register combinations for memory accesses may seem random but they were designed to support the needs of high-level
languages, such as arrays and data structures.
The idea is to add a base register, an index register, and/or a fixed displacement to determine the address.<span id="fnref:system360"><a href="#fn:system360">6</a></span>
The base register can indicate the start of an array, the index register holds the offset in the array, and the displacement provides the
offset of a field in the array entry.
The base register is <code>BX</code> for data or <code>BP</code> for information on the stack.
The index registers are <code>SI</code> (Source Index) and <code>DI</code> (Destination Index).<span id="fnref:modrm"><a href="#fn:modrm">7</a></span></p>
<p>Some addressing features are handled by the opcode, not the ModR/M byte.
For instance, the ModR/M byte doesn&#39;t distinguish between
<code>ADD AX,[SI]</code> and <code>ADD [SI],AX</code>.
Instead, the two
variants are distinguished by bit 1 of the instruction, the <code>D</code> or &#34;direction&#34; bit.<span id="fnref:destination"><a href="#fn:destination">8</a></span>
Moreover, many instructions have one opcode that operates on words and another that operates on bytes, distinguished by bit 0 of
the opcode, the <code>W</code> or word bit.</p>
<p>The <code>D</code> and <code>W</code> bits are an example of orthogonality in the 8086 instruction set,
allowing features to be combined in various combinations.
For instance, the addressing modes combine 8 types of offset computation with three sizes of displacements and 8 target registers.
Arithmetic instructions combine these addressing modes with eight ALU operations,
each of which can act on a byte or a word, with two possible memory directions.
All of these combinations are implemented with one block of microcode, implementing a large instruction set with a small amount of microcode.
(The orthogonality of the 8086 shouldn&#39;t be overstated, though; it has many special cases and things that don&#39;t quite fit.)</p>
<h2>An overview of 8086 microcode</h2>
<p>Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.</p>
<p>The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.</p>
<p>A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction has a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field.
A &#34;short jump&#34; is a conditional jump within the current block of 16 micro-instructions.
An ALU operation sets up the arithmetic-logic unit to perform an operation.
Bookkeeping operations are anything from flushing the prefetch queue to ending the current instruction.
A memory operation triggers a bus cycle to read or write memory.
A &#34;long jump&#34; is a conditional jump to any of 16 fixed microcode locations (specified in an external table called the Translation ROM).
Finally, a &#34;long call&#34; is a conditional subroutine call to one of 16 locations.
For more about 8086 microcode, see my <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode blog post</a>.</p>
<p><a href="https://static.righto.com/images/8086-addressing/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-addressing/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<h2>Some examples of microcode for addressing</h2>
<p>In this section, I&#39;ll take a close look at a few addressing modes and how they are implemented in microcode.
In the next section, I&#39;ll summarize all the microcode for addressing modes.</p>
<h3>A register-register operation</h3>
<p>Let&#39;s start by looking at a register-to-register instruction, before we get into the complications of memory accesses: <code>ADD BX,AX</code> which adds <code>AX</code> to <code>BX</code>, storing the result in <code>BX</code>.  This instruction has the opcode value 01 and ModR/M value C3 (hex). </p>
<p>Before the microcode starts, the hardware performs some decoding of the opcode.
The Group Decode ROM (below) classifies an instruction into multiple categories:
this instruction contains a D bit, a W bit, and an ALU operation, and has a ModR/M byte.
Fields from the opcode and ModR/M bytes are extracted and stored in various internal registers.
The ALU operation type (<code>ADD</code>) is stored in the <code>ALU opr</code> register.
From the ModR/M byte,
the <code>reg</code> register code (<code>AX</code>) is stored in the <code>N</code> register, and the <code>r/m</code> register code
(<code>BX</code>) is stored in the <code>M</code> register.
(The <code>M</code> and <code>N</code> registers are internal registers that are invisible to the programmer; each holds a 5-bit register code that specifies a register.<span id="fnref:mn"><a href="#fn:mn">9</a></span>)</p>
<p><a href="https://static.righto.com/images/8086-addressing/group-decode-rom.jpg"><img alt="This diagram shows the Group Decode ROM. The Group Decode ROM is more of a PLA (programmable logic array) with two layers of NOR gates. Its input lines are at the lower left and its outputs are at the upper right." height="482" src="https://static.righto.com/images/8086-addressing/group-decode-rom-w500.jpg" title="This diagram shows the Group Decode ROM. The Group Decode ROM is more of a PLA (programmable logic array) with two layers of NOR gates. Its input lines are at the lower left and its outputs are at the upper right." width="500"/></a></p><p>This diagram shows the Group Decode ROM. The Group Decode ROM is more of a PLA (programmable logic array) with two layers of NOR gates. Its input lines are at the lower left and its outputs are at the upper right.</p>
<p>Once the preliminary decoding is done, the microcode below for this ALU instruction is executed.<span id="fnref:microcode"><a href="#fn:microcode">10</a></span>
(There are three micro-instructions, so the instruction takes three clock cycles.)
Each micro-instruction contains a move and an action.
First, the register specified by <code>M</code> (i.e. <code>BX</code>) is moved to the ALU&#39;s temporary A register (<code>tmpA</code>).
Meanwhile, the ALU is configured to perform the appropriate operation on <code>tmpA</code>; <code>XI</code> indicates that the ALU operation is specified by the instruction bits, i.e. <code>ADD</code>).</p>
<p>The second instruction moves the register specified by <code>N</code> (i.e. <code>AX</code>) to the ALU&#39;s <code>tmpB</code> register.
The action <code>NX</code> indicates that this is the next-to-last micro-instruction so
the microcode engine can start processing the next machine instruction.
The last micro-instruction stores the ALU&#39;s result (<code>Σ</code>) in the register indicated by <code>M</code> (i.e. <code>BX</code>).
The status flags are updated because of the <code>F</code>.
<code>WB,RNI</code> (Run Next Instruction) indicates that this is the end and the microcode engine can process the next machine instruction.
The <code>WB</code> prefix would skip the actions if a memory writeback were pending (which is not the case).</p>
<pre>  move       action
M → tmpA     XI tmpA   <span><b>ALU rm↔r</b>: BX to tmpA</span>
N → tmpB     WB,NX      <span>AX to tmpB</span>
Σ → M        WB,RNI F   <span>result to BX, run next instruction.</span>
</pre>

<p>This microcode packs a lot into three micro-instructions.
Note that it is very generic: the microcode doesn&#39;t know what ALU operation is being performed or which registers are being used.
Instead, the microcode deals with abstract registers and operations, while the hardware fills in the details using bits from the instructions.
The same microcode is used for eight different ALU operations. And as we&#39;ll see, it supports multiple addressing modes.</p>
<h3>Using memory as the destination</h3>
<p>Memory operations on the 8086 involve both microcode and hardware.
A memory operation uses two internal registers: <code>IND</code> (Indirect) holds the memory address, while <code>OPR</code> (Operand) holds the word that is read or written.
A typical memory micro-instruction is <code>R DS,P0</code>, which starts a read from the Data Segment
with a &#34;Plus 0&#34; on the <code>IND</code> register afterward. The Bus Interface Unit carries out this operation by adding the segment register
to compute the physical address, and then running the memory bus cycles.</p>
<p>With that background, let&#39;s look at the instruction <code>ADD [SI],AX</code>, which adds <code>AX</code> to the memory location indexed by <code>SI</code>.
As before, the hardware performs some analysis of the instruction (hex 01 04).
In the ModR/M byte, mod=00 (memory, no displacement), reg=000 (AX), and R/M=100 ([SI]).
The <code>N</code> register is loaded with the code for <code>AX</code> as before.
The <code>M</code> register, however, is loaded with <code>OPR</code> (the memory data register) since the Group Decode ROM determines that the instruction has a memory addressing mode.</p>
<p>The microcode below starts in an effective address microcode subroutine for the <code>[SI]</code> mode.
The first line of the microcode subroutine computes the effective address simply by loading the <code>tmpA</code> register with <code>SI</code>. It jumps to the micro-routine <code>EAOFFSET</code> which ends up at <code>EALOAD</code> (for reasons that will be described below), which loads the value from memory.
Specifically, <code>EALOAD</code> puts the address in <code>IND</code>, reads the value from memory, puts the value into <code>tmpB</code>, and returns from the subroutine.</p>
<pre>SI → tmpA   JMP EAOFFSET <span><b>[SI]</b>: put SI in tmpA</span>
tmpA → IND  R DS,P0      <span><b>EALOAD</b>: read memory</span>
OPR → tmpB  RTN  
M → tmpA    XI tmpA      <span><b>ALU rm↔r</b>: OPR to tmpA</span>
N → tmpB    WB,NX         <span>AX to tmpB</span>
Σ → M       WB,RNI F      <span>result to BX, run next instruction.</span>
            W DS,P0 RNI   <span>writes result to memory</span>
</pre>

<p>Microcode execution continues with the <code>ALU rm↔r</code> routine described above, but with a few differences.
The <code>M</code> register indicates <code>OPR</code>, so the value read from memory is put into <code>tmpA</code>.
As before, the <code>N</code> register specifies <code>AX</code>, so that register is put into <code>tmpB</code>.
In this case, the <code>WB,NX</code> determines that the result will be written back to memory so it skips the <code>NXT</code> operation.
The ALU&#39;s result (<code>Σ</code>) is stored in <code>OPR</code> as directed by <code>M</code>.
The <code>WB,RNI</code> is skipped so microcode execution continues.
The <code>W DS,P0</code> micro-instruction writes the result (in <code>OPR</code>) to the memory address in <code>IND</code>.
At this point, <code>RNI</code> terminates the microcode sequence.</p>
<p>A lot is going on here to add two numbers!  The main point is that the same microcode runs as in the register case, but the results are different due to
the <code>M</code> register and the conditional <code>WB</code> code.
By running different subroutines, different effective address computations can be performed.</p>
<!--
instruction 01 04 
D bit is 0 so store in R/M field (memory)
M is OPR
N is AX

M and N are swapped if D bit is 1.
-->

<h3>Using memory as the source</h3>
<p>Now let&#39;s look at how the microcode uses memory as a source, as in the instruction <code>ADD AX,[SI]</code>.
This instruction (hex 03 04) has the same
ModR/M byte as before, so the <code>N</code> register holds <code>AX</code> and the <code>M</code> register holds <code>OPR</code>.
However, because the opcode has the D bit set, the <code>M</code> and <code>N</code> registers are swapped when accessed.
Thus, when the microcode uses <code>M</code>, it gets the value <code>AX</code> from <code>N</code>, and vice versa. (Yes, this is confusing.)</p>
<p>The microcode starts the same as the previous example, reading <code>[SI]</code> into <code>tmpB</code> and returning to the ALU code.
However, since the meaning of <code>M</code> and <code>N</code> are reversed, the AX value goes into <code>tmpA</code> while the memory value goes into <code>tmpB</code>.
(This switch doesn&#39;t matter for addition, but would matter for subtraction.)
An important difference is that there is no writeback to memory, so <code>WB,NX</code> starts processing the next machine instruction.
In the last micro-instruction, the result is written to <code>M</code>, indicating the <code>AX</code> register. Finally, <code>WB,RNI</code> runs the next machine instruction.</p>
<pre>SI → tmpA   JMP EAOFFSET <span><b>[SI]</b>: put SI in tmpA</span>
tmpA → IND  R DS,P0      <span><b>EALOAD: read memory</b></span>
OPR → tmpB  RTN  
M → tmpA    XI tmpA      <span><b>ALU rm↔r</b>: AX to tmpA</span>
N → tmpB    WB,NX         <span>OPR to tmpB</span>
Σ → M       WB,RNI F      <span>result to AX, run next instruction.</span>
</pre>

<p>The main point is that the same microcode handles memory as a source and a destination, simply by setting the <code>D</code> bit.
First, the <code>D</code> bit reverses the operands by swapping <code>M</code> and <code>N</code>.
Second, the <code>WB</code> conditionals prevent the writeback to memory that happened in the previous case.</p>
<!--
(instruction 03 04).
mod = 00, reg = 000(AX), r/m = 04 [SI], D bit = 1
D bit is 1 so store in reg field
M is 00110 OPR from ?
N is 11000 AX from middle bits (reg field)
M->tmpA uses AX (N)
S->tmpB uses OPR
sigma->M uses AX (N)
-->

<!--
—
Now look at 01 C1 ADD CX, AX
M = 11001 CX from R/M (end bits): this is used for M and is the destination
N = 11000 AX from reg (middle bits)

—
With D bit set, look at 03 C8. This is also ADD CX, AX but the registers and the destination are reversed.
M = 11000 AX from end bits: this is used for N and is the source
N = 11001 CX from middle bits: this is used for M and is the destination
The W DS,P0 is skipped
-->

<h3>Using a displacement</h3>
<p>The memory addressing modes optionally support a signed displacement of one or two bytes.
Let&#39;s look at the instruction <code>ADD AX,[SI+0x1234]</code>.
In hex, this instruction is 03 84 34 12, where the last two bytes are the displacement, reversed because the 8086 uses little-endian numbers.
The mod bits are 10, indicating a 16-bit displacement, but the other bits are the same as in the previous example.</p>
<p>Microcode execution again starts with the <code>[SI]</code> subroutine.
However, the jump to <code>EAOFFSET</code> goes to <code>[i]</code> this time, to handle the displacement offset. (I&#39;ll explain how, shortly.)
This code loads the offset as two bytes from the instruction prefetch queue (<code>Q</code>) into the <code>tmpB</code> register.
It adds the offset to the previous address in <code>tmpA</code> and puts the sum Σ in <code>tmpA</code>, computing the effective address. Then it jumps to <code>EAFINISH</code> (<code>EALOAD</code>).
From there, the code continues as earlier, reading an argument from memory and computing the sum.</p>
<pre>SI → tmpA   JMP EAOFFSET <span><b>[SI]</b>: put SI in tmpA</span>
Q → tmpBL   JMPS MOD1 12 <span><b>[i]</b>: load from queue, conditional jump</span>
Q → tmpBH     
Σ → tmpA    JMP EAFINISH <span><b>12</b>:</span>
tmpA → IND  R DS,P0      <span><b>EALOAD: read memory</b></span>
OPR → tmpB  RTN  
M → tmpA    XI tmpA      <span><b>ALU rm↔r</b>: AX to tmpA</span>
N → tmpB    WB,NX         <span>OPR to tmpB</span>
Σ → M       WB,RNI F      <span>result to AX, run next instruction.</span>
</pre>

<p>For the one-byte displacement case,
the conditional <code>MOD1</code> will jump over the fetch of the second displacement byte.
When the first byte is loaded into the low byte of <code>tmpB</code>, it was sign-extended into the high byte.<span id="fnref:sign"><a href="#fn:sign">14</a></span>
Thus, the one-byte displacement case uses the same microcode but ends up with a sign-extended 1-byte displacement in <code>tmpB</code>.</p>
<h2>The Translation ROM</h2>
<p>Now let&#39;s take a closer look at the jumps to <code>EAOFFSET</code>, <code>EAFINISH</code>, and the effective address subroutines, which use something called the Translation ROM.
The Translation ROM converts the 5-bit jump tag in a micro-instruction into a 13-bit microcode address.
It also provides the addresses of the effective address subroutines.
As will be seen below, there are some complications.<span id="fnref:translation-pla"><a href="#fn:translation-pla">11</a></span></p>
<p><a href="https://static.righto.com/images/8086-addressing/translation-rom.jpg"><img alt="The Translation ROM as it appears on the die. The metal layer has been removed to expose the silicon and polysilicon underneath. The left half decodes the inputs to select a row. The right half outputs the corresponding microcode address." height="636" src="https://static.righto.com/images/8086-addressing/translation-rom-w350.jpg" title="The Translation ROM as it appears on the die. The metal layer has been removed to expose the silicon and polysilicon underneath. The left half decodes the inputs to select a row. The right half outputs the corresponding microcode address." width="350"/></a></p><p>The Translation ROM as it appears on the die. The metal layer has been removed to expose the silicon and polysilicon underneath. The left half decodes the inputs to select a row. The right half outputs the corresponding microcode address.</p>
<h2>The effective address micro-routines</h2>
<h3>Register calculations</h3>
<p>The Translation ROM has an entry for the addressing mode calculations such as <code>[SI]</code> and <code>[BP+DI]</code>, generally indicated by the <code>r/m</code> bits,
the three low bits of the ModR/M byte.
Each routine computes the effective address and puts it into the ALU&#39;s temporary A register and jumps to <code>EAOFFSET</code>, which adds any
displacement offset.
The microcode below shows the four simplest effective address calculations, which just load the appropriate register into <code>tmpA</code>.</p>
<pre>SI → tmpA   JMP EAOFFSET   <span><b>[SI]</b>: load SI into tmpA</span>
DI → tmpA   JMP EAOFFSET   <span><b>[DI]</b>: load SI into tmpA</span>
BP → tmpA   JMP EAOFFSET   <span><b>[BP]</b>: load BP into tmpA</span>
BX → tmpA   JMP EAOFFSET   <span><b>[BX]</b>: load BX into tmpA</span>
</pre>

<p>For the cases below, an addition is required, so the registers are loaded into the ALU&#39;s temporary A and temporary B registers.
The effective address is the sum (indicated by Σ), which is moved to temporary A.<span id="fnref:alu-default"><a href="#fn:alu-default">12</a></span>
These routines are carefully arranged in memory so <code>[BX+DI]</code> and <code>[BP+SI]</code> each execute one micro-instruction and then jump into
the middle of the other routines, saving code.<span id="fnref:timing"><a href="#fn:timing">13</a></span></p>
<pre>BX → tmpA         <span><b>[BX+SI]</b>: get regs</span>
SI → tmpB         <span><b>1</b>:</span>
Σ → tmpA   JMP EAOFFSET  

BP → tmpA         <span><b>[BP+DI]</b>: get regs</span>
DI → tmpB         <span><b>4</b>:</span>
Σ → tmpA   JMP EAOFFSET  

BX → tmpA  JMPS 4 <span><b>[BX+DI]</b>: short jump to 4</span>
BP → tmpA  JMPS 1 <span><b>[BP+SI]</b>: short jump to 1</span>
</pre>

<h3>The <code>EAOFFSET</code> and <code>EAFINISH</code> targets</h3>
<p>After computing the register portion of the effective address, the routines above jump to
<code>EAOFFSET</code>, but this is not a fixed target.
Instead, the Translation ROM selects one of three target microcode addresses based on the instruction and the ModR/M byte:
</p>
<p>For a displacement, the <code>[i]</code> immediate code below loads a 1-byte or 2-byte displacement into the <code>tmpB</code> register and adds it to the <code>tmpA</code> register,
as described earlier.
At the end of a displacement calculation, the microcode jumps to the <code>EAFINISH</code> tag, which is another branching target.
Based on the instruction, the Translation ROM selects one of two microcode targets: <code>EALOAD</code> to load from memory, or <code>EADONE</code> to skip the load.</p>
<pre>Q → tmpBL   JMPS MOD1 12 <span><b>[i]</b>: get byte(s)</span>
Q → tmpBH         
Σ → tmpA    JMP EAFINISH <span><b>12</b>: add displacement</span>
</pre>

<p>The <code>EALOAD</code> microcode below reads the value from memory, using the effective address in <code>tmpA</code>. It puts the result in <code>tmpB</code>.
The <code>RTN</code> micro-instruction returns to the microcode that implements the original machine instruction.</p>
<pre>tmpA → IND  R DS,P0   <span><b>EALOAD</b>: read from tmpA address</span>
OPR → tmpB  RTN        <span>store result in tmpB, return</span>
</pre>

<p>The <code>EADONE</code> routine puts the effective address in <code>IND</code>, but it doesn&#39;t read from the memory location.
This supports machine instructions such as <code>MOV</code> (some moves) and <code>LEA</code> (Load Effective Address) that don&#39;t read from memory</p>
<pre>tmpA → IND  RTN   <span><b>EADONE</b>: store effective address in IND</span>
</pre>

<p>To summarize, the microcode runs different subroutines and different paths, depending on the addressing mode, executing the appropriate code.
The Translation ROM selects the appropriate control flow path.</p>
<h2>Special cases</h2>
<p>There are a couple of special cases in addressing that I will discuss in this section.</p>
<h3>Supporting a fixed address</h3>
<p>It is common to access a fixed memory address, but the standard addressing modes use a base or index register. 
The 8086 replaces the mode of <code>[BP]</code> with no displacement with 16-bit fixed addressing.
In other words, a ModR/M byte with the pattern <code>00xxx110</code> is treated specially.
(This special case is the orange <code>disp16</code> line in the ModR/M table earlier.)
This is implemented in the Translation ROM which has additional rows to
detect this pattern and execute the immediate word <code>[iw]</code> microcode below instead.
This microcode fetches a word from the instruction prefetch queue (<code>Q</code>) into the <code>tmpA</code> register, a byte at a time.
It jumps to <code>EAFINISH</code> instead of <code>EAOFFSET</code> because it doesn&#39;t make sense to add another displacement.</p>
<pre>Q → tmpAL          <span><b>[iw]</b>: get bytes</span>
Q → tmpAH  JMP EAFINISH  
</pre>

<h3>Selecting the segment</h3>
<p>Memory accesses in the 8086 are relative to one of the 64-kilobyte segments: Data Segment, Code Segment, Stack Segment, or Extra Segment.
Most addressing modes use the Data Segment by default.
However, addressing modes that use the <code>BP</code> register use the Stack Segment by default.
This is a sensible choice since the <code>BP</code> (Base Pointer) register is intended for accessing values on the stack. </p>
<p>This special case is implemented in the Translation ROM.
It has an extra output bit that indicates that the addressing mode should use the Stack Segment.
Since the Translation ROM is already decoding the addressing mode to select the right microcode routine, adding
one more output bit is straightforward.
This bit goes to the segment register selection circuitry, changing the default segment.
This circuitry also handles prefixes that change the segment.
Thus, segment register selection is handled in hardware without any action by the microcode.</p>
<h2>Conclusions</h2>
<p>I hope you have enjoyed this tour through the depths of 8086 microcode.
The effective address calculation in the 8086 uses a combination of microcode and logic circuitry to implement
a variety of addressing methods.
Special cases make the addressing modes more useful, but make the circuitry more complicated.
This shows the CISC (Complex Instruction Set Computer) philosophy of x86, making the instructions complicated but
highly functional. In contrast, the RISC (Reduced Instruction Set Computer) philosophy takes the opposite approach,
making the instructions simpler but allowing the processor to run faster.
RISC vs. CISC was a big debate of the 1980s, but isn&#39;t as relevant nowadays.</p>
<p>People often ask if microcode could be updated on the 8086. Microcode was hardcoded into the ROM, so it could not be changed.
This became a big problem for Intel with the famous Pentium <a href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">floating-point division bug</a>.
The Pentium chip turned out to have a bug that resulted in rare but serious errors when dividing.
Intel recalled the defective processors in 1994 and replaced them at a cost of $475 million.
Starting with the Pentium Pro (1995), microcode could be patched at boot time, a useful feature that persists in modern CPUs.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="1d7271797f6469786e336e6d7c7e785d7678736e75746f6f747b7b">[email protected]</span></a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
