<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://failingfast.io/opentelemetry-observability/">Original</a>
    <h1>The Modern Observability Problem</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    

    

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        
        <ul>
  <li>Part 1: The Modern Observability Problem</li>
  <li><a href="https://failingfast.io/opentelemetry">Part 2: OpenTelemetry, The Missing Ingredient</a></li>
</ul>

<hr/>


<p><img src="https://failingfast.io/assets/images/opentelemetry/stack3.png" alt="image-center"/></p>

<p>Debugging an application in a single process tends to be easy ðŸ’ª and most of what goes wrong with our monoliths will already be recorded as known problems, with standard solutions. We may even have automated their fixes. But if not, we know there are finite routes through the application, and that tracing the cause of most problems is relatively trivial.</p>

<p>But the complexity of interactions in large, modern microservice architectures produces novel, one-off errors, that cross boundaries in space and time. Factor in components being built on a broad mix of tech stacks, and we have a proper challenge supporting them.</p>

<p>Imagine just a small number of services like those represented in the diagram below. We have a mix of synchronous REST communication and asynchronous<strong>*</strong> events. If we get an error in <code>service H</code> because of something that happened in <code>service B</code>, this would be non-trivial to investigate - without the right information.</p>

<p><img src="https://failingfast.io/assets/images/opentelemetry/microservices.png" alt="image-center"/></p>

<p><strong>*</strong> Synchronous HTTP calls will request and receive a response at the same time. Of course sometimes it might take a few seconds, but quick enough so that we can easily link it to any side effects it might have. Asynchronous communications, like events, wonâ€™t necessarily trigger an instant response. It could even be a day before an event added to some queue is processed! Clearly, it wonâ€™t be as easy to assign blame for some side effect to an event.</p>

<h3 id="visibility-is-not-observability">Visibility is not Observability</h3>

<p>Observability and monitoring are two different things. Weâ€™re usually pretty good at monitoring, or if that fails, the users will shout at us. Either way, we tend to know <em>when</em> there is a problem. We donâ€™t always do so well at answering the <em>why</em> questions.</p>

<p>That, for me, is the core observability problem: <strong>Why is the system exhibiting this behaviour?</strong></p>

<p>And if youâ€™re doing observability right, you should be able to answer that question without having to redeploy with additional logs or â€˜printsâ€™.</p>

<p>If you can only answer questions about predictable problems - thatâ€™s monitoring, not observability.</p>

<h2 id="telemetry-and-the-three-pillars-of-observability">Telemetry and the Three Pillars of Observability</h2>

<ul>
  <li>Your car dashboard displaying how much fuel is left in the tank</li>
  <li>When you filter log output from your code in a tool like Kibana</li>
  <li>When youâ€™ve looked at a histogram of events passing through your servers</li>
</ul>

<p>These are all examples of <strong>telemetry</strong> â€“ insights into the behaviour or inner workings of a system â€“ the data that the system emits about whatâ€™s happening inside the â€˜black boxâ€™. You may also hear these being called <strong>signals</strong>.</p>

<p>And <strong>instrumentation</strong> is what <em>produces</em> the telemetry. When we talk about instrumenting, we mean to add libraries and/or code to our applications that collects telemetry such as logs, metrics and traces.</p>

<p><img src="https://failingfast.io/assets/images/opentelemetry/signals2.png" alt="image-center"/></p>

<p>In software engineering, we often to simplify telemetry to three distinct things:</p>

<p><strong>Logs</strong>: More specifically, centralised logging â€“ shipping all the text log entries from our components to a single data source to easily draw correlations with searches. Logs typically describe in some detail, what is happening, so are expensive to store a long time. They are not always tied to a specific user/request and thus lack context, but nonetheless, are still heavily relied on to understand system behaviour.</p>

<p><strong>Metrics</strong>: Typically focusing on reliability, the type of stuff discussed for service level indicators (SLIs) and service level agreements (SLAs). As they are largely numerical data like counters and rates, they use significantly less storage than logging. This means it can be kept for longer, allowing for better analysis of trends over time. Caution though, size can increase with complexity â€“ the cardinality â€“ how much extra data we attach to each metric to make them more useful.</p>

<p><strong>Traces</strong>: More specifically, distributed tracing. Think of this as <strong>a stack trace across multiple components</strong> (and boundaries) of a distributed or large system. It offers some of the analytical benefits of metrics but with the cardinality of logging. Distributed tracing also relies on <strong>context propagation</strong>, a component to move shared information and identifiers used to associate traces, between the services.</p>

<p>With tracing instrumented across all our services, properly correlated with logs, then in our fictional system we could see the route our imaginary transaction has taken, leading us to the problem service(s), which in our imagined scenario, is some dodgy data in <code>service F</code> and the code in <code>service B</code> not gracefully handling it, such that the error didnâ€™t surface until <code>service H</code>.</p>

<p><img src="https://failingfast.io/assets/images/opentelemetry/microservices2.png" alt="image-center"/></p>

<p>A typical observability tool view of traces and logs, if an exception was thrown in <code>service B</code> after it was called from <code>service A</code> would be like the image below. With it, we can see exactly what call from <code>service A</code> made the request and drill down into it further to see associated logs and get a complete picture of the overall transaction.</p>

<p><img src="https://failingfast.io/assets/images/opentelemetry/ai-spans.png" alt="image-center"/></p>

<p>Weâ€™ll look at traces in more detail for <a href="https://failingfast.io/opentelemetry">part 2, on OpenTelemetry</a>.</p>

<p>Ultimately, logs, metrics, and traces are the rehearsed â€˜3 pillarsâ€™ but there are others, like health checks. Whichever way that we choose to break it down, <strong>we have some raw unstructured data that we need to transform to answer questions about the behaviour of our system</strong>.</p>

<h2 id="what-is-the-right-telemetry">What is the Right Telemetry?</h2>

<p>Shift away from that monitoring state of mind where youâ€™re looking for problems you can predict, and make sure your system emits enough of the right telemetry to allow you to troubleshoot the problems you cannot foresee, because microservice architectures in a production environment will provide plenty of those! <strong>Emitting the right telemetry is what makes a system observable</strong>.</p>

<p>What actually stops internal users working or external customers getting what they need done?</p>

<p>Whatâ€™s the business value of each service?</p>

<p>Keen an open dialogue with your colleagues in the business to understand what questions about the system  matter to them. Use this to decide what is the right data to be instrumented.</p>

<p>This turns observability into a more powerful tool that can be use for what..if scenarios and forecasting.</p>

<h2 id="the-technology-problem">The Technology Problem</h2>

<p><img src="https://failingfast.io/assets/images/opentelemetry/tech1.png" alt="image-center"/></p>

<p>We have our applications built in a mix of technologies (and more) here on the left, doing stuff we want to know about (this is intentionally getting more complicated as we purposefully shift to composed architectures and smaller microservices).</p>

<p>And we have all these options on the right (and more) that we might want to use to collect and analyse what the things on the left are doing.</p>

<p>The reality will be a bit of all of it. Some files, some custom database, maybe one team has gone their own way with elastic on prem., another in the cloud. All emitting telemetry signals but not necessarily in the same format, which means it becomes really difficult to get a joined up picture of what is going on in side the black box. For example:</p>

<ul>
  <li>Youâ€™re not going to be able to aggregate logs and run queries across the system if theyâ€™re not using a shared format. Iâ€™ve seen log shipping agents written to reformat logs but maintaining the agents and clients to do this, across tech stacks, uses a lot of resources.</li>
  <li>Iâ€™ve witnessed confusion between teams, each trying to find out what they should be adding to some common context in a transaction across services owned by a number of teams. A gap that can be easily be filled by establishing a standard but standards take time and effort to build in-house.</li>
</ul>

<h3 id="vendor-lock-in">Vendor Lock-in</h3>

<p>Itâ€™s okay to roll our own database or file logging and utilise the abstractions provided by our language frameworks. But at scale, we need the powerful features of dedicated self-hosted or SaaS observability solutions. The problem, is that they instrument code in their own way, which makes it a non-trivial piece of work to switch to a different solution.</p>

<p>We call this â€˜vendor lock-inâ€™ and its effects go both ways:</p>

<ul>
  <li>Our services all depend on the logging solution they are now plumbed into</li>
  <li>The logging solution will only support X and Y tech stacks, limiting our freedom to change these for our services</li>
</ul>

<p>Sure, if you have a handful of C# web applications and thatâ€™s all you ever make, then maybe it is okay to lock into specific observability backends:</p>

<p><img src="https://failingfast.io/assets/images/opentelemetry/tech2.png" alt="image-center"/></p>

<p>But we canâ€™t predict the future and we donâ€™t want to create future legacy.</p>

<h2 id="summary">Summary</h2>

<p><img src="https://failingfast.io/assets/images/opentelemetry/observable.png" alt="image-center"/></p>

<p>To resolve problems in a large microservice system:</p>

<ul>
  <li>We must be able to find out <em>why</em> they have occurred.</li>
  <li>For this, our system must be observable.</li>
  <li>To be observable, a system needs to be instrumented such that the code emits telemetry, which is typically logs, traces and metrics.</li>
  <li>This telemetry must be sent to a backend that supports joining up that telemetry data and answering questions about the systemâ€™s behaviour.</li>
</ul>

<p>There are lots of open-source and commercial backends, available as self-hosted or SaaS, many of which are really good at this. The problem, is that they all do things in their own ways - there is no standard. Plumbing our logging, metrics and traces into all our services is a big task, meaning when you have done it once for any vendor, you probably wonâ€™t be doing it again any time soon, greatly reducing your freedom to be flexible and adapt.</p>

<p>OpenTelemetry (OTeL) is the evolution of ideas from the OpenTracing and OpenCensus projects, to build a single, vendor-neutral standard. Weâ€™ll look at this in <strong><a href="https://failingfast.io/opentelemetry">Part 2: OpenTelemetry, The Missing Ingredient</a></strong>.</p>

        
      </section>

      

      


      
  

    </div></div>
  </body>
</html>
