<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://steck.tech/posts/rtsan-in-rust/">Original</a>
    <h1>RealtimeSanitizer for Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>A few months ago, I gave my first talk about Rust for audio apps at <a href="https://audio.dev/">AudioDevCon</a> in Bristol. There, I met Chris and David, who presented their work on <a href="https://clang.llvm.org/docs/RealtimeSanitizer.html">RealtimeSanitizer (RTSan)</a> - a tool that will be officially included in LLVM20. RTSan is a powerful addition to the developer toolkit, helping detect real-time violations in your code that can be particularly challenging to spot, especially for newcomers to real-time programming.</p>
<p>At the time, RTSan was only available for C++, and they were looking for someone to help make it accessible from Rust, given the growing interest in the community. Since this tool would be valuable for my daily work, I saw it as an opportunity to learn and create my first serious open source library. I took on the challenge, and now the first version is available!</p>
<h3 id="test-it-now">
  Test it now
  <a href="#test-it-now">#</a>
</h3>
<ul>
<li><strong>GitHub:</strong> <a href="https://github.com/realtime-sanitizer/rtsan-standalone-rs">https://github.com/realtime-sanitizer/rtsan-standalone-rs</a></li>
<li><strong>crates.io:</strong> <a href="https://crates.io/crates/rtsan-standalone">https://crates.io/crates/rtsan-standalone</a></li>
</ul>
<h2 id="understanding-real-time-constraints">
  Understanding Real-time Constraints
  <a href="#understanding-real-time-constraints">#</a>
</h2>
<p>Real-time programming requires guaranteeing that code will complete within a specific time frame. Take self-driving cars as an example: when detecting a person crossing the street, the car must apply the brakes within a guaranteed number of milliseconds. Even a one-in-a-million timing failure would be unacceptable.</p>
<p>In audio programming, while not as critical as automotive safety, we still face real-time requirements. Missing our timing window results in audible glitches - at best, it’s annoying for the user, at worst, imagine your code is running in the audio chain at a major concert and an audio glitch blasts through the PA system, potentially damaging expensive equipment and causing hearing damage.</p>
<p>Real-time requirements are also crucial in aerospace, robotics, industrial automation, medical devices, game development, and high-frequency trading systems where microsecond-level precision can make the difference between profit and loss.</p>
<h2 id="what-makes-code-non-real-time-safe">
  What Makes Code Non-Real-time Safe?
  <a href="#what-makes-code-non-real-time-safe">#</a>
</h2>
<p>Real-time safe code requires predictable execution time for every line of code. You can’t block execution waiting for operations outside your control. This rules out network requests, file I/O, thread creation, memory allocation/deallocation, and often mutex locking and unlocking.</p>
<p>While these constraints might seem manageable when working with basic language features, even standard library functions can cause headaches - enough to inspire entire <a href="https://www.youtube.com/watch?v=vn7563IAQ_E">conference talks</a>. Beyond the standard library, using third-party code becomes risky without thorough code review, as you can’t be certain what happens under the hood of each function call.</p>
<h2 id="how-rtsan-works">
  How RTSan Works
  <a href="#how-rtsan-works">#</a>
</h2>
<p>This is where RTSan comes in. It raises runtime errors when detecting real-time violations like malloc, free, pthread_mutex_lock, and system calls. While not perfect, it’s an invaluable tool. I’ve already had several eye-opening moments discovering memory allocations in places I thought were allocation-free.</p>
<h2 id="making-it-usable-from-rust">
  Making it Usable from Rust
  <a href="#making-it-usable-from-rust">#</a>
</h2>
<p>RTSan will be available with LLVM20, which Rust will adopt eventually. It could then be integrated like other sanitizers in <strong>unstable</strong> Rust and used with the compiler flag <code>-Zsanitizer=realtime</code>.</p>
<p>Unlike existing sanitizers like AddressSanitizer, which typically check entire programs, RTSan needs to target specific real-time sections of your code. Non-real-time parts, like initialization, don’t need these checks. That’s why RTSan introduced the <code>[[clang::nonblocking]]</code> attribute to activate the sanitizer for specific functions, and <code>[[clang::blocking]]</code> to mark known non-real-time-safe functions that the sanitizer might miss.</p>
<p>While these attributes could be added to unstable Rust (similar to the current <a href="https://doc.rust-lang.org/unstable-book/language-features/no-sanitize.html">no_sanitize</a> flag), we wanted to provide immediate access in stable Rust. This led to the creation of <a href="https://github.com/realtime-sanitizer/rtsan-standalone-rs">rtsan-standalone-rs</a> - “standalone” distinguishing it from the future built-in version.</p>
<h2 id="the-implementation">
  The Implementation
  <a href="#the-implementation">#</a>
</h2>
<p>The implementation was straightforward thanks to the existing <a href="https://github.com/realtime-sanitizer/rtsan/blob/main/include/rtsan_standalone/rtsan_standalone.h">C-Header</a>, which provides runtime functions to control the sanitizer.</p>
<p>The Rust wrapper consists of three crates:</p>
<ul>
<li>
<p><strong>rtsan-standalone</strong>: The main crate that provides safe wrappers for the C functions and defines the <code>scoped_disabler</code> macro for temporarily disabling sanitizer checks.</p>
</li>
<li>
<p><strong>rtsan-standalone-macros</strong>: Implements the procedural macros <code>nonblocking</code>, <code>blocking</code>, and <code>no_sanitize_realtime</code> - these are the primary interfaces you’ll use when working with RTSan.</p>
</li>
<li>
<p><strong>rtsan-standalone-sys</strong>: Handles the low-level integration by generating bindings to the C-Header, downloading LLVM20 pre-release source files, and building the RTSan library. The build process can take several minutes, producing a dynamic library on macOS and a static library on Linux. To avoid rebuilding, you can copy the RTSan library to a persistent location and set the <code>RTSAN_LIBRARY_PATH</code> environment variable.</p>
</li>
</ul>
<h2 id="using-the-sanitizer">
  Using the Sanitizer
  <a href="#using-the-sanitizer">#</a>
</h2>
<p>The sanitizer is opt-in via a feature flag. Add this to your Cargo.toml:</p>
<div><pre tabindex="0"><code data-lang="toml"><span><span>[dependencies]
</span></span><span><span>rtsan-standalone = <span>&#34;0.1.0&#34;</span>
</span></span><span><span>[features]
</span></span><span><span>rtsan = [<span>&#34;rtsan-standalone/enable&#34;</span>]
</span></span></code></pre></div><p>All macros and functions are zero-cost when the feature is disabled, so you can leave them in your code.</p>
<p>Here’s an example of using RTSan to catch a real-time violation. First, we mark our audio processing function as nonblocking:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> rtsan_standalone::nonblocking;
</span></span><span><span>
</span></span><span><span><span>#[nonblocking]</span>
</span></span><span><span><span>fn</span> <span>process</span>(data: <span>&amp;</span><span>mut</span> [<span>f32</span>]) {
</span></span><span><span>    <span>let</span> _ = vec![0.0; 16]; <span>// oops! allocating memory in a real-time context
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>The sanitizer immediately catches this violation and produces a detailed error trace:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>==<span>283082</span>==ERROR: RealtimeSanitizer: unsafe-library-call
</span></span><span><span>Intercepted call to real-time unsafe <span>function</span> calloc in real-time context!
</span></span><span><span>    <span>#0 0x55c0c3be8cf2 in calloc /tmp/.tmp6Qb4u2/llvm-project/compiler-rt/lib/rtsan/rtsan_interceptors_posix.cpp:470:34</span>
</span></span><span><span>    <span>#1 0x55c0c3be4e69 in alloc::alloc::alloc_zeroed::hf760e6484fdf32c8 /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/alloc/src/alloc.rs:170:14</span>
</span></span><span><span>    ...
</span></span></code></pre></div><h2 id="special-case-mutex">
  Special Case: Mutex
  <a href="#special-case-mutex">#</a>
</h2>
<p>An interesting discovery was the different mutex implementations between Linux and macOS. On macOS, mutex operations use <code>pthread_mutex_*</code> calls, with the first lock operation triggering an allocation. Setting <code>RTSAN_OPTIONS=halt_on_error=false</code> reveals the full sequence:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ <span>RTSAN_OPTIONS</span>=<span>halt_on_error</span>=<span>false</span> cargo run --example mutex --features <span>enable</span>
</span></span><span><span>
</span></span><span><span>==<span>2083</span>==ERROR: RealtimeSanitizer: unsafe-library-call
</span></span><span><span>Intercepted call to real-time unsafe <span>function</span> <span>`</span>calloc<span>`</span> in real-time context!
</span></span><span><span>
</span></span><span><span>==<span>8716</span>==ERROR: RealtimeSanitizer: unsafe-library-call
</span></span><span><span>Intercepted call to real-time unsafe <span>function</span> <span>`</span>pthread_mutex_lock<span>`</span> in real-time context!
</span></span><span><span>
</span></span><span><span>==<span>8716</span>==ERROR: RealtimeSanitizer: unsafe-library-call
</span></span><span><span>Intercepted call to real-time unsafe <span>function</span> <span>`</span>pthread_mutex_unlock<span>`</span> in real-time context!
</span></span></code></pre></div><p>Linux uses a futex-based implementation with a CAS loop for lock attempts. It first spins for a limited cycle count before falling back to a system call. RTSan only detects the Linux implementation when it resorts to the system call. While using such a mutex in real-time contexts might be acceptable if the system call is avoided, this ventures into complex lock-free programming territory that’s beyond my current expertise. If you’re knowledgeable about Linux mutex implementation, I’d love to hear your thoughts.</p>
<h2 id="extended-features">
  Extended Features
  <a href="#extended-features">#</a>
</h2>
<p>Check the examples for additional features:</p>
<ul>
<li>The <code>blocking</code> macro marks functions as non-real-time-safe</li>
<li><code>scoped_disabler</code> temporarily disables sanitizer checks within nonblocking functions</li>
<li><code>no_sanitize_realtime</code> disables checks for entire functions</li>
<li>RTSan behavior can be customized via <a href="https://clang.llvm.org/docs/RealtimeSanitizer.html#run-time-flags">runtime flags</a></li>
</ul>
<h2 id="learn-more">
  Learn more
  <a href="#learn-more">#</a>
</h2>
<ul>
<li><strong>GitHub Repository:</strong> <a href="https://github.com/realtime-sanitizer/rtsan-standalone-rs">https://github.com/realtime-sanitizer/rtsan-standalone-rs</a></li>
<li><strong>Original RTSan:</strong> <a href="https://github.com/realtime-sanitizer/rtsan">https://github.com/realtime-sanitizer/rtsan</a></li>
<li><strong>Official Documentation:</strong> <a href="https://clang.llvm.org/docs/RealtimeSanitizer.html">https://clang.llvm.org/docs/RealtimeSanitizer.html</a></li>
<li><strong>CppCon Talk:</strong> <a href="https://www.youtube.com/watch?v=KvhgNdxX6Uw&amp;t=2478s">https://www.youtube.com/watch?v=KvhgNdxX6Uw&amp;t=2478s</a></li>
</ul>
<h2 id="get-involved">
  Get Involved
  <a href="#get-involved">#</a>
</h2>
<p>We’d love your feedback and contributions!</p>
<ul>
<li><strong>Discord:</strong> <a href="https://discord.com/invite/DZqjbmSZzZ">RealtimeSanitizer (RTSan)</a></li>
<li><strong>Email:</strong> <a href="mailto:realtime.sanitizer@gmail.com">realtime.sanitizer@gmail.com</a></li>
</ul>

    
  </div></div>
  </body>
</html>
