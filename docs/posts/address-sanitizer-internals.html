<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gistre.epita.fr/posts/benjamin.peter-2022-10-28-address_sanitizer_internals/">Original</a>
    <h1>Address Sanitizer Internals</h1>
    
    <div id="readability-page-1" class="page"><div>
        <h2 id="prerequisite">Prerequisite</h2>
<p>For this article, you’ll need the following knowledge:</p>
<ul>
<li>Basic C understanding (Memory, Stack, Heap, Syscall).</li>
<li>(Optional) x86_64 Assembly</li>
</ul>
<h2 id="preamble">Preamble</h2>
<p><em>Xavier Login</em> is a freshly employee who got his internship in a big company.
On his first days, he was asked to do a little program to validate an input by verifying that a magic byte was set.</p>
<p>So this was the first attempt of <em>Xavier</em>:</p>
<blockquote>
<p>magic_checker.c</p>
</blockquote>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>int</span> <span>is_magic_byte_valid</span><span>(</span><span>char</span> <span>*</span><span>buffer</span><span>)</span> <span>{</span>
    <span>return</span> <span>buffer</span><span>[</span><span>10</span><span>]</span> <span>==</span> <span>&#39;A&#39;</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>char</span> <span>buffer</span><span>[]</span> <span>=</span> <span>&#34;Hello&#34;</span><span>;</span>

    <span>return</span> <span>is_magic_byte_valid</span><span>(</span><span>buffer</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div><p><em>Xavier</em> was in a good school and never forgot about enabling ASan flags with compiling c code.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/MagicCheckerOverflowDetected.jpg" alt="MagicCheckerOverflowDetected" loading="lazy"/>
</p>
<p><em>Xavier</em> screams internally seeing this big red line with written “stack-buffer-overflow”, knowing he did a big mistake.</p>
<p><em>Xavier</em> looks at his code and finally finds the error, it was obviously the index in the function <code>is_magic_byte_valid</code> because the team asked him to check the 42nd index, not the 10th one !</p>
<p>This is the new code he came up with:</p>
<blockquote>
<p>magic_checker.c</p>
</blockquote>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>int</span> <span>is_magic_byte_valid</span><span>(</span><span>char</span> <span>*</span><span>buffer</span><span>)</span> <span>{</span>
    <span>return</span> <span>buffer</span><span>[</span><span>42</span><span>]</span> <span>==</span> <span>&#39;A&#39;</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>char</span> <span>buffer</span><span>[]</span> <span>=</span> <span>&#34;Hello&#34;</span><span>;</span>

    <span>return</span> <span>is_magic_byte_valid</span><span>(</span><span>buffer</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div><p>After fixing it, <em>Xavier</em> compiles it, and executes it again.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/MagicCheckerOverflowUndetected.jpg" alt="MagicCheckerOverflowUndetected" loading="lazy"/>
</p>
<p>This time, he executes the program and… nothing happens !?</p>
<p>Here is what Xavier drew to represent the situation.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/xavier_buffer.png" alt="XavierBuffer" loading="lazy"/>
</p>
<p>And this doesn’t make sense for him. Why is the first error reported, and not the second ?</p>
<p>But ! Don’t worry Xavier, this document will help you learn and understand, how ASan works under the hood to show you (or not), invalid memory accesses and other memory mistakes.</p>
<p>This will also help you understand exactly what ASan is telling you when an error occurred.</p>
<h2 id="introduction-to-address-sanitizer">Introduction To Address Sanitizer</h2>
<p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank">AddressSanitizer</a> (ASan) is a memory misuse detector tool for C and C++.</p>
<p>It’s a tool who lives in a compiler toolbox and uses dynamic analysis.
Most modern compilers for C/C++ includes ASan supports.</p>
<p>List of compilers that supports ASan:</p>
<ul>
<li><a href="https://gcc.gnu.org/" target="_blank">GNU GCC</a> (since ver. 4.8)</li>
<li><a href="https://llvm.org/" target="_blank">Clang LLVM</a> (since ver. 3.1)</li>
<li><a href="https://learn.microsoft.com/en-us/cpp/" target="_blank">MSVC</a> (since ver. 16.4)</li>
</ul>
<p>ASan is a tool divided into 2 modules:</p>
<ul>
<li><strong>Instrumentation module</strong>
<ul>
<li>It consists on a compiler pass that will add instructions to our code on specific parts.</li>
</ul>
</li>
<li><strong>Run-time library</strong>
<ul>
<li>The library implements functions to replace used memory functions (like <a href="https://www.man7.org/linux/man-pages/man3/malloc.3.html" target="_blank">malloc(3)</a>).</li>
<li>The library implements functions to report errors nicely to the user.</li>
</ul>
</li>
</ul>
<p>For this post, we will look at all the <strong>types of errors</strong> that ASan can detect.</p>
<p>Then, we will start to see how ASan works by explaining it’s <strong>core concepts</strong>.</p>
<p>And finally, we will also understand how ASan uses both of the <strong>modules</strong> to provide an efficient
and fast memory error checking.</p>
<h2 id="error-types">Error types</h2>
<p>ASan can detect several classes of <strong>memory errors</strong> in C/C++.</p>
<p><strong>Memory Errors</strong></p>
<ul>
<li>Global buffer underflow/overflow</li>
<li>Stack buffer underflow/overflow</li>
<li>Heap buffer underflow/overflow</li>
<li>Initialization order bugs</li>
<li>Use after return</li>
<li>Use after scope</li>
<li>Use after free</li>
<li>Memory leaks</li>
</ul>
<h2 id="core-concepts">Core Concepts</h2>
<p>Let’s see what methods ASan can use to detect memory errors.</p>
<h3 id="memory-mapping">Memory Mapping</h3>
<p>It will first modify the structure of the <strong>Virtual Memory</strong> for the program.</p>
<p>The virtual address space used by a program is now divided in 3 parts:</p>
<ul>
<li><strong>Application memory</strong>: The application still uses the memory normally and can store all of its data.
<ul>
<li>It consists of ~7/8 of the virtual memory space.</li>
</ul>
</li>
<li><strong>Shadow memory</strong>: This part of the memory is handled by ASan.
<ul>
<li>It takes ~1/8 of the virtual memory space.</li>
</ul>
</li>
<li><strong>Protected memory</strong>: This parts of the memory is used by ASan to detect unwanted access to Shadow Memory.</li>
</ul>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/MemoryMapping64.jpg" alt="MemoryMapping" loading="lazy"/>
</p>
<blockquote>
<p>Memory Mapping for each architecture is defined here: <a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-12.2.0/libsanitizer/asan/asan_mapping.h" target="_blank">https://github.com/gcc-mirror/gcc/blob/releases/gcc-12.2.0/libsanitizer/asan/asan_mapping.h</a></p>
</blockquote>
<h3 id="shadow-memory">Shadow Memory</h3>
<p>The <strong>Shadow Memory</strong> is a part of the virtual memory used to store metadata about the data stored in the Application Memory of this virtual memory.</p>
<p>Each <strong>byte</strong> in the shadow memory, correspond to exactly <strong>8 bytes</strong> in the application memory.</p>
<p>ASan access the Shadow Memory via a function <code>MemToShadow</code> which will map the application memory address to the shadow memory address.</p>
<p>The goal of this function is to be fast and that it can allow ASan to map an address like such:
<code>shadow_address = MemToShadow(application_adress);</code></p>
<p>Each <strong>bit</strong> in the Shadow Memory can be then analyzed be ASan, and identify the <strong>wrongly accessed byte</strong> in the application memory.</p>
<p>ASan is able to detect memory errors thanks to the bytes contained in the Shadow Memory, in conjunction with a method called <strong>Infection</strong>.</p>
<h3 id="infection">Infection</h3>
<p>The <strong>Infection</strong> will <strong>poison</strong> <em>some</em> bytes allocated in Application Memory and store information about which bytes has been <strong>poisoned</strong> in the Shadow Memory.</p>
<p>The <strong>Infection</strong> takes place during a <code>malloc()</code> call (we will see later how can ASan modifies the behavior of <code>malloc()</code>).</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>void</span> <span>*</span><span>malloc</span><span>(</span><span>size_t</span> <span>size</span><span>)</span> <span>{</span>
    <span>// Allocate data
</span><span></span>    <span>char</span> <span>*</span><span>ptr</span> <span>=</span> <span>...;</span> <span>// Pointer to our allocated memory (8-bytes aligned).
</span><span></span>
    <span>// Infection
</span><span></span>    <span>AsanPoisonMemory</span><span>(</span><span>ptr</span><span>,</span> <span>size</span><span>);</span>

    <span>// Return address just like the normal malloc
</span><span></span>    <span>return</span> <span>ptr</span><span>;</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div><p>ASan manages to allocate <strong>everything</strong> (even the stack, which we’ll see later), using a call to <code>malloc()</code>.</p>
<p>This is used to ease and simplify the <strong>infection</strong> done by ASan because everything stored in virtual memory, will go through a <code>malloc()</code> call, thus infecting our program memory.</p>
<p>For example, let’s allocate a simple integer on the heap.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>int</span> <span>*</span><span>my_int</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>));</span>
</code></pre></td></tr></tbody></table>
</div>
</div><p>The memory around the <code>my_int</code> pointer will look like:</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/AsanPoisonedBytes.jpg" alt="MyIntMemoryPoisoning" loading="lazy"/>
</p>
<h4 id="poisoned">Poisoned</h4>
<p>A byte is <strong>Poisoned</strong> by ASan in the Application memory. <strong>Poisoning</strong> a byte means to write a special value to it.
This value is then used to identify the type of invalid memory access we are doing.</p>
<p>The goal of the Shadow Memory is only to store information on where the poisoned bytes are in the Application Memory.</p>
<p>We said that, 1 byte in the Shadow Memory corresponds to 8 bytes in the Application Memory.
Thus, we can represent the status (<strong>poisoned</strong>) of <strong>1 byte in Application Memory</strong>, with only <strong>1 bit in Shadow Memory</strong>.</p>
<p>And we can do this, because all memory allocated by our program will go through a <code>malloc()</code>.
Moreover, the 8 bytes will always be free to modify, because <code>malloc()</code> is guaranteed to always return an <a href="https://www.gnu.org/software/libc/manual/html_node/Aligned-Memory-Blocks.html" target="_blank">8-byte aligned chunk of memory</a>.</p>
<p>We will see in later in this document, the list of all the possible values of a byte in the Shadow Memory.</p>
<h3 id="conclusion-on-asan-core-concepts">Conclusion on ASan core concepts</h3>
<p>As we can see, ASan modifies the usage of the underlying <strong>virtual memory</strong> as it needs to ensure that we access the right bytes while <strong>accessing memory</strong>.</p>
<p>This allows it to check efficiently for errors while only impacting the running program by only removing ~1/8 of the total available memory for the application.</p>
<p>Thanks to what we have seen already, you can then see why <em>Xavier Login</em> first error was caught, but, you are not sure why the second error was not caught by ASan.
It should have detected it if ASan poison memory around the variable.</p>
<p>Unfortunately, one limitation of ASan, is that it can only poison bytes <strong>near</strong> an allocated memory.
Thus, there are places in memory not yet poisoned, and ASan can miss out of bound accesses if it’s too far from a known allocation point.</p>
<p>Now that you know the core concepts of ASan, we are able to deep dive into its source code and see how it uses instrumentation and a run-time library to do all the necessary checks and infection.</p>
<h2 id="instrumentation-module">Instrumentation Module</h2>
<p>The goal of the <strong>Instrumentation Module</strong> is to add <strong>run-time checks</strong> before every memory instruction.</p>
<h3 id="initialization">Initialization</h3>
<p>The first instrumentation will be located at the module initialization and will add a call to <code>__asan_init_vN()</code> where <code>N</code> is the desired API version (we will not look at API differences).</p>
<p>This function will be called at module initialization time in order for ASan to be initialized.</p>
<h3 id="instuctions">Instuctions</h3>
<p>Then, it needs to instruments certain types of instructions.</p>
<p>Actually, it only modifies 2 types of instructions:</p>
<ul>
<li><strong>load</strong>: When performing a <em>load</em> instruction (read).</li>
<li><strong>store</strong>: When performing a <em>store</em> instruction (write).</li>
</ul>
<p>The code:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>// Perform a load instruction on Addr
</span><span></span><span>read_value</span><span>(</span><span>Addr</span><span>);</span>
</code></pre></td></tr></tbody></table>
</div>
</div><p>Will be enhanced with memory checks, like follows:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>// Compute Shadow Address
</span><span></span><span>ShadowAddr</span> <span>=</span> <span>MemToShadow</span><span>(</span><span>Addr</span><span>);</span>

<span>// Get the Shadow Value
</span><span></span><span>ShadowValue</span> <span>=</span> <span>*</span><span>(</span><span>*</span><span>char</span><span>)</span><span>ShadowAddr</span><span>;</span> <span>// *(short*) for 16-byte access
</span><span></span>
<span>// If the ShadowValue is different from 0, there is a poisoned byte access
</span><span></span><span>if</span> <span>(</span><span>ShadowValue</span><span>)</span>
<span>{</span>
    <span>// If the load is for N=(1, 2 or 4) bytes from Addr,
</span><span></span>    <span>// we need to check each bit
</span><span></span>    <span>// For N=(8 or 16), this check is not needed
</span><span></span>    <span>if</span> <span>(</span><span>IsByteSet</span><span>(</span><span>ShadowValue</span><span>,</span> <span>Addr</span><span>,</span> <span>N</span><span>))</span>
    <span>{</span>
        <span>// ASan will report an error accessing unwanted memory
</span><span></span>        <span>__asan_report_loadN</span><span>(</span><span>Addr</span><span>);</span>
    <span>}</span>
<span>}</span>

<span>// Read the value
</span><span></span><span>read_value</span><span>(</span><span>Addr</span><span>);</span>
</code></pre></td></tr></tbody></table>
</div>
</div><blockquote>
<p>File: <a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-12.2.0/gcc/asan.cc" target="_blank">gcc/asan.cc</a></p>
</blockquote>
<p>It’s exactly the same for a <em>store</em> instruction. (ASan just update the <code>__asan_report_loadN</code> to <code>__asan_report_storeN</code>).</p>
<h3 id="stack">Stack</h3>
<p>The module will also instrument variables on the stack.</p>
<p>It will do so by creating a call for <code>__asan_stack_malloc()</code> which will take care of the creation of the Shadow Bytes in the stack alongside the stack variable.</p>
<h2 id="run-time-library">Run-time Library</h2>
<p>The Run-time library defines all the functions that we have seen in the instrumentation part.</p>
<p>It defines all the functions needed for ASan to work around the memory (poisoning bytes and checking for memory accesses), while also reporting error reports.</p>
<p>It consists of:</p>
<ul>
<li><strong>Mapping</strong> from/to Shadow Memory to/from Application Memory.</li>
<li><strong>Interception</strong> of memory related functions.</li>
<li>Handling the Stack and the <strong>Fake Stack</strong> implementation.</li>
<li>Functions to <strong>check</strong> if the <strong>memory accessed</strong> is (un)valid.</li>
<li>Functions to <strong>report errors</strong> when the <strong>check failed</strong>.</li>
</ul>
<h3 id="shadow-and-application-address-mapping">Shadow and Application Address Mapping</h3>
<p>The functions which are the most utilized through the program will be the functions to convert addresses from (or to) Shadow Memory to (or from) Application Memory.</p>
<p>These functions are defined in the <code>asan_mapping.cc</code> in order to change <em>scale</em> and <em>offset</em> depending on the architecture.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>// Memory to Shadow
</span><span></span><span>#    define MEM_TO_SHADOW(mem) \
</span><span>      (((mem) &gt;&gt; ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))
</span><span></span>
<span>static</span> <span>inline</span> <span>uptr</span> <span>MemToShadow</span><span>(</span><span>uptr</span> <span>p</span><span>)</span> <span>{</span>
  <span>PROFILE_ASAN_MAPPING</span><span>();</span>
  <span>// Checking if `p` is in the Application Memory
</span><span></span>  <span>CHECK</span><span>(</span><span>AddrIsInMem</span><span>(</span><span>p</span><span>));</span>
  <span>return</span> <span>MEM_TO_SHADOW</span><span>(</span><span>p</span><span>);</span>
<span>}</span>

<span>// Shadow to Memory
</span><span></span><span>#    define SHADOW_TO_MEM(mem) \
</span><span>      (((mem) - (ASAN_SHADOW_OFFSET)) &lt;&lt; (ASAN_SHADOW_SCALE))
</span><span></span>
<span>static</span> <span>inline</span> <span>uptr</span> <span>ShadowToMem</span><span>(</span><span>uptr</span> <span>p</span><span>)</span> <span>{</span>
  <span>PROFILE_ASAN_MAPPING</span><span>();</span>
  <span>// Checking if `p` is in the Shadow Memory
</span><span></span>  <span>CHECK</span><span>(</span><span>AddrIsInShadow</span><span>(</span><span>p</span><span>));</span>
  <span>return</span> <span>SHADOW_TO_MEM</span><span>(</span><span>p</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div><blockquote>
<p>File: <a href="https://github.com/gcc-mirror/gcc/blob/master/libsanitizer/asan/asan_mapping.h" target="_blank">libsanitizer/asan/asan_mapping.h</a></p>
</blockquote>
<p>For both functions, it checks whether the address is really in the specified region first.
Then it converts the address thanks to the 2 macros <code>MEM_TO_SHADOW</code> and <code>SHADOW_TO_MEM</code>.</p>
<p>These functions are inlined in order to reduce function overhead because it will be called a lot of times.
The faster this function is, the lower the performance impact ASan instrumentation will force on target code.</p>
<h3 id="interceptor">Interceptor</h3>
<p>One of the main challenges for ASan is to intercept all functions that need to alter memory.
For example, the famous <code>malloc/calloc/free</code> functions needs to be intercepted in order to poison memory before giving it back to the user.</p>
<p>In order to do this, ASan has a macro called <code>INTERCEPTOR</code>.
It takes in parameter the <strong>return type</strong>, the <strong>function name</strong> and the <strong>arguments</strong> of the function we want to replace.</p>
<p>Let’s see for example the Interceptor for <code>malloc()</code>.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span>INTERCEPTOR</span><span>(</span><span>void</span><span>*</span><span>,</span> <span>malloc</span><span>,</span> <span>uptr</span> <span>size</span><span>)</span> <span>{</span>
<span>//          -----|-------|----------
</span><span>//          rtype|fctname|argument
</span><span></span>
  <span>if</span> <span>(</span><span>DlsymAlloc</span><span>::</span><span>Use</span><span>())</span>
    <span>return</span> <span>DlsymAlloc</span><span>::</span><span>Allocate</span><span>(</span><span>size</span><span>);</span>
  <span>ENSURE_ASAN_INITED</span><span>();</span>
  <span>GET_STACK_TRACE_MALLOC</span><span>;</span>

  <span>// We can see here the call to the asan_malloc function which will allocate needed memory and poison it.
</span><span></span>  <span>return</span> <span>asan_malloc</span><span>(</span><span>size</span><span>,</span> <span>&amp;</span><span>stack</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div><blockquote>
<p>File: <a href="https://github.com/gcc-mirror/gcc/blob/master/libsanitizer/asan/asan_malloc_linux.cpp" target="_blank">libsanitizer/asan/asan_malloc_linux.cpp</a></p>
</blockquote>
<p>Now, every time we call <code>malloc()</code>, we will go through the function defined above, and not the libc <code>malloc()</code>.</p>
<h3 id="stack-1">Stack</h3>
<p>ASan can work with 2 “modes” for the Stack. It can stay with the basic Stack, or create a Fake Stack.</p>
<p>It can only do one stack mode at runtime, not both.</p>
<h4 id="normal-stack">Normal Stack</h4>
<p>For the normal Stack, the code has already been instrumented and it will call the <code>__asan_stack_malloc_N()</code> function which will allocate our local variable, as well as poison the memory around it.</p>
<p>The function <code>__asan_stack_malloc_N()</code> will call a function in the ASan Allocator currently selected, which depends on the type of Stack.</p>
<p>For the Normal Stack, the default Allocator is selected, and only local variables will be poisoned.</p>
<h4 id="fake-stack">Fake Stack</h4>
<p>The Fake Stack is used when doing <em>User after return</em> error detection.</p>
<p>ASan will use a special Allocator that will create a Fake Stack as well as Fake Frames that will be poisoned after being returned from.</p>
<h3 id="poisoning">Poisoning</h3>
<p>In order to poison Memory, ASan give a simple function <code>bool PoisonShadow(uptr addr, uptr size, u8 value)</code>.</p>
<p>Then, it can simply give the <code>size</code> of bytes at <code>addr</code> it wants to set to <code>value</code>.</p>
<p>On Linux, it’s simply a call to <code>memset()</code>.</p>
<h2 id="error-reporting">Error Reporting</h2>
<p>In this part, we will analyse the ASan output when an error occurred, and see what we can now understand from each part.</p>
<p>For this, we will take an example of a <code>stack_buffer_overflow</code>. And we will need a master of the art for C programing.</p>
<p>Xavier is once again asked to create a program that creates an array of integers and return the last element.</p>
<pre tabindex="0"><code data-lang="c=">// My beautifull program the returns the last element of an array of integer.

int main() {
    int number[4] = { 0 };

    return number[4];
}
</code></pre><p>Xavier now executes the program and…</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_stack_buffer_overflow.png" alt="AsanErrorReporting" loading="lazy"/>
</p>
<p><em>Ouch!!!</em>
That’s a lot of information for Xavier to take at once.</p>
<p>In order to teach Xavier how this works, we will take a closer look at each part of this output.</p>
<p>In fact, this output is divided into 6 distinct parts described below.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_summary.png" alt="AsanErrorReportingSummary" loading="lazy"/>
</p>
<h3 id="error-type">Error Type</h3>
<p>The <strong>first</strong> part of the output is the error type.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_error_type.png" alt="AsanErrorReportingErrorType" loading="lazy"/>
</p>
<p>It can be decomposed in 3 information.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_error_type_summary.png" alt="AsanErrorReportingErrorTypeSummary" loading="lazy"/>
</p>
<h4 id="error-type-1">Error Type</h4>
<p>The error type corresponds to the errors we defined in the introduction. It’s the name of the error we produced.</p>
<p>Here, we can see that we produced a <code>stack-buffer-overflow</code> as expected.</p>
<h4 id="address">Address</h4>
<p>The Address shows us the virtual address we tried to access and which generated a <code>stack_buffer_overflow</code>.</p>
<h4 id="registers">Registers</h4>
<p>Finally, ASan will output the state of 3 registers.</p>
<ul>
<li><strong>P</strong>rogram <strong>C</strong>ounter: Indicating the current instruction.</li>
<li><strong>B</strong>ase <strong>P</strong>ointer: The pointer indicating the start of our stack frame (also, the previous <strong>SP</strong>).</li>
<li><strong>S</strong>tack <strong>P</strong>ointer: The pointer indicating the current position of the top of our stack.</li>
</ul>
<p>This can help us to know exactly when and where the program failed.</p>
<h3 id="operation">Operation</h3>
<p>The <strong>second</strong> part is the type of operation which triggered the error.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_operation.png" alt="AsanErrorReportingOperation" loading="lazy"/>
</p>
<p>It can be decomposed in 4 information.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_operation_summary.png" alt="AsanErrorReportingOperationSummary" loading="lazy"/>
</p>
<h4 id="operation-1">Operation</h4>
<p>The operation tells us what we did during the memory error.</p>
<p>Here, it’s <code>READ</code>, because we are trying to read the memory out of bound.
But if we were trying to set a value in an array at an index out of bound, the operation will be <code>WRITE</code>.</p>
<h4 id="size">Size</h4>
<p>It corresponds to the size in bytes of the data we are trying to access.
Here, it’s 4 (bytes) because we are trying to access an <code>int</code>, which in <code>x86_64</code> under the <code>System V ABI</code> is stored under 4 bytes in memory.</p>
<h4 id="address-1">Address</h4>
<p>The address is the same as before, where exactly did we try to access invalid memory.</p>
<h4 id="threadid">ThreadID</h4>
<p>The ThreadID correspond of an unique identifier (ID) of the Thread we are currently running.
This is only useful if you have a multi-threaded application because it can tell you on which thread the invalid memory access was on.</p>
<h3 id="backtrace">Backtrace</h3>
<p>The <strong>third</strong> part of the output is a backtrace of your program. This tells you the state of your stack when the invalid memory access was done.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_operation.png" alt="AsanErrorReportingOperation" loading="lazy"/>
</p>
<p>If you had set the debug symbols, ASan can tell you exactly on which line of your program, the invalid memory access is located.
We can see that he tells us that the invalid access is on line 6, which is the <code>return number[4];</code>.</p>
<h3 id="address-2">Address</h3>
<p>The <strong>fourth</strong> part of the output is the address where the memory error occurred.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_address.png" alt="AsanErrorReportingAddress" loading="lazy"/>
</p>
<p>It can be decomposed in 4 information.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_address_summary.png" alt="AsanErrorReportingAddressSummary" loading="lazy"/>
</p>
<h4 id="address-3">Address</h4>
<p>Same as the last 2, where exactly is the invalid memory access.</p>
<h4 id="place">Place</h4>
<p>This tells us where the invalid access is. In which pool of memory.
It can be the <strong>stack</strong>, or the <strong>heap</strong>, or <strong>global memory</strong>.</p>
<h4 id="threadid-1">ThreadID</h4>
<p>This is the ThreadID we have seen before. It’s also here because each thread has its own Stack.</p>
<p>So we need to know the Thread associated with each stack.</p>
<h4 id="offset">Offset</h4>
<p>This tells us exactly where is the access located in the stack frame.</p>
<h3 id="memory-view">Memory View</h3>
<p>This is the most visual part and represent a snapshot of the memory around the invalid access when the error was thrown.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_memory_view.png" alt="AsanErrorReportingMemoryView" loading="lazy"/>
</p>
<p>The memory ASan is showing us here, represents the Shadow Bytes around the invalid memory access.</p>
<p>On the left, we can see the addresses of the memory, and on the right, each pair of digits means 8 bytes of the Application memory.</p>
<p>We can see that we accessed the third number on the line <code>0x1000_00f9_6e50</code>, and the value stored is <code>f3</code>. But what does it mean ? Maybe we can look down at the last section to know the answer.</p>
<h3 id="shadow-byte-legend">Shadow Byte Legend</h3>
<p>And you guessed right, the last part corresponds to the Shadow Bytes Legend. It tells you exactly the meaning of the magic values you see in the memory view.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_legend.png" alt="AsanErrorReportingShadowByteLegend" loading="lazy"/>
</p>
<p>We can then look at <code>f3</code> which means: <code>Stack right redzone</code>.</p>
<p>That tells us that the memory where the value stored is <code>f3</code>, it’s poisoned memory on the right side of a value in the stack.
Which correspond exactly to a <code>stack_buffer_overflow</code>.</p>
<p>We can also see <code>f1</code> before our variable in the Shadow Memory, which correspond to <code>Stack left redzone</code>, which enables ASan to trigger <code>stack_buffer_underflow</code> errors.</p>
<h3 id="summary">Summary</h3>
<p>Here is the summary of the parts we have seen.</p>
<p><img src="https://samuelselleck.com/images/benjamin.peter/benjamin.peter-2022-10-28-address_sanitizer_internals/Asan_error_reporting_parts.png" alt="AsanErrorReportingParts" loading="lazy"/>
</p>
<h2 id="performance">Performance</h2>
<p>In terms of performance, there are 2 parts to take into account here.</p>
<p>First of all, it’s the memory footprint. ASan will take ~1/8 of the available virtual memory of your program.</p>
<p>This part will be used to store the Shadow Bytes and prevent access to the Shadow Memory.</p>
<p>For the second part, ASan will <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerPerformanceNumbers" target="_blank">slowdown</a> your code by an average of 1.93. Which means that your program will run approximately 2 times slower than usual.</p>
<p>This is a good trade-off compared to other memory misuse detector tools.</p>
<p>For example, <a href="https://valgrind.org/" target="_blank">Valgrind</a>, will slowdown your code to 20 times more of your initial execution time.</p>
<p>ASan produces an overhead (~1.93) and it takes ~1/8 of your application memory, so this needs to be kept in mind when choosing ASan.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Address Sanitizer is a powerful tool to detect memory misuse cases.</p>
<p>It doesn’t hurt too much your performance, and is very easily enabled in your build environment thanks to a compiler/linker flag.</p>
<p>It is a very useful tool that any programmer can understand, and it gives a lot of information to help the programmer find the bug more easily.</p>
<p>I hope that this document will help you and Xavier on your future C projects. By helping you to avoid common memory misuse thanks to Address Sanitizer.</p>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li><a href="https://github.com/google/sanitizers/wiki" target="_blank">Github: Sanitizers Wiki</a></li>
<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html" target="_blank">Clang: AddressSanitizer Documentation</a></li>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" target="_blank">AddressSanitizerAlgorithm</a></li>
<li><a href="https://research.google/pubs/pub37752/" target="_blank">AddressSanitizer: A Fast Address Sanity Checker</a></li>
<li><a href="https://llvm.org/devmtg/2011-11/Serebryany_FindingRacesMemoryErrors.pdf" target="_blank">Finding races and memory errors with LLVM instrumentation</a></li>
<li><a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/asan.cc" target="_blank">GCC Asan Module Instrumentation</a></li>
</ul>

    </div></div>
  </body>
</html>
