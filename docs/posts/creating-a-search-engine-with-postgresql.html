<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xata.io/blog/postgres-full-text-search-engine">Original</a>
    <h1>Creating a search engine with PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is part 1 of a blog mini-series, in which we explore the full-text search functionality in PostgreSQL and investigate how much of the typical search engine functionality we can replicate. In part 2, we&#39;ll do a comparison between PostgreSQL&#39;s full-text search and Elasticsearch.</p>
<p>If you want to follow along and try out the sample queries (which we recommend; it&#39;s more fun that way), the code samples are executed against the <a href="https://www.kaggle.com/datasets/jrobischon/wikipedia-movie-plots">Wikipedia Movie Plots</a> data set from Kaggle. To import it, download the CSV file, then create this table:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>movies</span><span>(</span></span>
<span data-line=""><span>	ReleaseYear </span><span>int</span><span>,</span></span>
<span data-line=""><span>	Title </span><span>text</span><span>,</span></span>
<span data-line=""><span>	Origin </span><span>text</span><span>,</span></span>
<span data-line=""><span>	Director </span><span>text</span><span>,</span></span>
<span data-line=""><span>	Casting </span><span>text</span><span>,</span></span>
<span data-line=""><span>	Genre </span><span>text</span><span>,</span></span>
<span data-line=""><span>	WikiPage </span><span>text</span><span>,</span></span>
<span data-line=""><span>	Plot </span><span>text</span><span>);</span></span></code></pre></div></div>
<p>And import the CSV file like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>\</span><span>COPY</span><span> movies(ReleaseYear, Title, Origin, Director, Casting, Genre, WikiPage, Plot)</span></span>
<span data-line=""><span>	</span><span>FROM</span><span> </span><span>&#39;</span><span>wiki_movie_plots_deduped.csv</span><span>&#39;</span><span> DELIMITER </span><span>&#39;</span><span>,</span><span>&#39;</span><span> CSV HEADER;</span></span></code></pre></div></div>
<p>The dataset contains 34,000 movie titles and is about 81 MB in CSV format.</p>

<p>The Postgres approach to full-text search offers building blocks that you can combine to create your own search engine. This is quite flexible but it also means it generally feels lower-level compared to search engines like Elasticsearch, Typesense, or Mellisearch, for which full-text search is the primary use case.</p>
<p>The main building blocks, which we&#39;ll cover via examples, are:</p>
<ul role="list"><li>The <code>tsvector</code> and <code>tsquery</code> data types</li><li>The match operator <code>@@</code> to check if a <code>tsquery</code> matches a <code>tsvector</code></li><li>Functions to rank each match (<code>ts_rank</code>, <code>ts_rank_cd</code>)</li><li>The GIN index type, an inverted index to efficiently query <code>tsvector</code></li></ul>
<p>We&#39;ll start by looking at these building blocks and then we&#39;ll get into more advanced topics, covering relevancy boosters, typo-tolerance, and faceted search.</p>

<p>The <code>tsvector</code> data type stores a sorted list of <em>lexemes</em>. A <em>lexeme</em> is a string, just like a token, but it has been <em>normalized</em> so that different forms of the same word are made. For example, normalization almost always includes folding upper-case letters to lower-case, and often involves removal of suffixes (such as <code>s</code> or <code>ing</code> in English). Here is an example, using the <code>to_tsvector</code> function to parse an English phrase into a <code>tsvector</code>.</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> unnest(to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span></span>
<span data-line=""><span>	</span><span>&#39;</span><span>I</span><span>&#39;&#39;</span><span>m going to make him an offer he can</span><span>&#39;&#39;</span><span>t refuse. Refusing is not an option.</span><span>&#39;</span><span>));</span></span>
<span data-line=""> </span>
<span data-line=""><span> lexeme | positions | weights</span></span>
<span data-line=""><span>--------+-----------+---------</span></span>
<span data-line=""><span> </span><span>go</span><span>     | {</span><span>3</span><span>}       | {D}</span></span>
<span data-line=""><span> m      | {</span><span>2</span><span>}       | {D}</span></span>
<span data-line=""><span> make   | {</span><span>5</span><span>}       | {D}</span></span>
<span data-line=""><span> offer  | {</span><span>8</span><span>}       | {D}</span></span>
<span data-line=""><span> </span><span>option</span><span> | {</span><span>17</span><span>}      | {D}</span></span>
<span data-line=""><span> refus  | {</span><span>12</span><span>,</span><span>13</span><span>}   | {D,D}</span></span>
<span data-line=""><span>(</span><span>6</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>As you can see, stop words like “I”, “to” or “an” are removed, because they are too common to be useful for search. The words are normalized and reduced to their root (e.g. “refuse” and “Refusing” are both transformed into “refus”). The punctuation signs are ignored. For each word, the <strong>positions</strong> in the original phrase are recorded (e.g. “refus” is the 12th and the 13th word in the text) and the <strong>weights</strong> (which are useful for ranking and we&#39;ll discuss later).</p>
<p>In the example above, the transformation rules from words to <em>lexemes</em> are based on the <code>english</code> search configuration. Running the same query with the <code>simple</code> search configuration results in a <code>tsvector</code> that includes all the words as they were found in the text:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> unnest(to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>,</span></span>
<span data-line=""><span>	</span><span>&#39;</span><span>I</span><span>&#39;&#39;</span><span>m going to make him an offer he can</span><span>&#39;&#39;</span><span>t refuse. Refusing is not an option.</span><span>&#39;</span><span>));</span></span>
<span data-line=""> </span>
<span data-line=""><span>  lexeme  | positions | weights</span></span>
<span data-line=""><span>----------+-----------+---------</span></span>
<span data-line=""><span> an       | {</span><span>7</span><span>,</span><span>16</span><span>}    | {D,D}</span></span>
<span data-line=""><span> can      | {</span><span>10</span><span>}      | {D}</span></span>
<span data-line=""><span> going    | {</span><span>3</span><span>}       | {D}</span></span>
<span data-line=""><span> he       | {</span><span>9</span><span>}       | {D}</span></span>
<span data-line=""><span> him      | {</span><span>6</span><span>}       | {D}</span></span>
<span data-line=""><span> i        | {</span><span>1</span><span>}       | {D}</span></span>
<span data-line=""><span> </span><span>is</span><span>       | {</span><span>14</span><span>}      | {D}</span></span>
<span data-line=""><span> m        | {</span><span>2</span><span>}       | {D}</span></span>
<span data-line=""><span> make     | {</span><span>5</span><span>}       | {D}</span></span>
<span data-line=""><span> </span><span>not</span><span>      | {</span><span>15</span><span>}      | {D}</span></span>
<span data-line=""><span> offer    | {</span><span>8</span><span>}       | {D}</span></span>
<span data-line=""><span> </span><span>option</span><span>   | {</span><span>17</span><span>}      | {D}</span></span>
<span data-line=""><span> refuse   | {</span><span>12</span><span>}      | {D}</span></span>
<span data-line=""><span> refusing | {</span><span>13</span><span>}      | {D}</span></span>
<span data-line=""><span> t        | {</span><span>11</span><span>}      | {D}</span></span>
<span data-line=""><span> </span><span>to</span><span>       | {</span><span>4</span><span>}       | {D}</span></span>
<span data-line=""><span>(</span><span>16</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>As you can see, “refuse” and “refusing” now result in different lexemes. The <code>simple</code> configuration is particularly useful when you have columns that contain labels or tags.</p>
<p>PostgreSQL has built-in configurations for a pretty good set of languages. You can see the list by running:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> cfgname </span><span>FROM</span><span> pg_ts_config;</span></span></code></pre></div></div>
<p>Notably, however, there is no configuration for CJK (Chinese-Japanese-Korean), which is worth keeping in mind if you need to create a search query in those languages. While the <code>simple</code> configuration should work in practice quite well for unsupported languages, I&#39;m not sure if that is enough for CJK.</p>

<p>The <code>tsquery</code> data type is used to represent a normalized query. A <code>tsquery</code> contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. There are functions like <code>to_tsquery</code>, <code>plainto_tsquery</code>, and <code>websearch_to_tsquery</code> that are helpful in converting user-written text into a proper <code>tsquery</code>, primarily by normalizing words appearing in the text.</p>
<p>To get a feeling of <code>tsquery</code>, let&#39;s see a few examples using <code>websearch_to_tsquery</code>:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>the dark vader</span><span>&#39;</span><span>);</span></span>
<span data-line=""><span> websearch_to_tsquery</span></span>
<span data-line=""><span>----------------------</span></span>
<span data-line=""><span>&#39;</span><span>dark</span><span>&#39;</span><span> &amp; </span><span>&#39;</span><span>vader</span><span>&#39;</span></span></code></pre></div></div>
<p>That is a logical AND, meaning that the document needs to contain both “quick” and “dog” in order to match. You can do logical OR as well:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>quick OR dog</span><span>&#39;</span><span>);</span></span>
<span data-line=""><span> websearch_to_tsquery</span></span>
<span data-line=""><span>----------------------</span></span>
<span data-line=""><span> </span><span>&#39;</span><span>dark</span><span>&#39;</span><span> | </span><span>&#39;</span><span>vader</span><span>&#39;</span></span></code></pre></div></div>
<p>And you can exclude words:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>dark vader -wars</span><span>&#39;</span><span>);</span></span>
<span data-line=""><span>   websearch_to_tsquery</span></span>
<span data-line=""><span>---------------------------</span></span>
<span data-line=""><span> </span><span>&#39;</span><span>dark</span><span>&#39;</span><span> &amp; </span><span>&#39;</span><span>vader</span><span>&#39;</span><span> &amp; !</span><span>&#39;</span><span>war</span><span>&#39;</span></span></code></pre></div></div>
<p>Also, you can represent phrase searches:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>&#34;the dark vader son&#34;</span><span>&#39;</span><span>);</span></span>
<span data-line=""><span>     websearch_to_tsquery</span></span>
<span data-line=""><span>------------------------------</span></span>
<span data-line=""><span> </span><span>&#39;</span><span>dark</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>vader</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>son</span><span>&#39;</span></span></code></pre></div></div>
<p>This means: “dark”, followed by “vader”, followed by “son”.</p>
<p>Note, however, that the “the” word is ignored, because it&#39;s a stop word as per the <code>english</code> search configuration. This can be an issue on phrases like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>&#34;do or do not, there is no try&#34;</span><span>&#39;</span><span>);</span></span>
<span data-line=""><span> websearch_to_tsquery</span></span>
<span data-line=""><span>----------------------</span></span>
<span data-line=""><span> </span><span>&#39;</span><span>tri</span><span>&#39;</span></span>
<span data-line=""><span>(</span><span>1</span><span> </span><span>row</span><span>)</span></span></code></pre></div></div>
<p>Oops, almost the entire phrase was lost. Using the <code>simple</code> config gives the expected result:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, </span><span>&#39;</span><span>&#34;do or do not, there is no try&#34;</span><span>&#39;</span><span>);</span></span>
<span data-line=""><span>                           websearch_to_tsquery</span></span>
<span data-line=""><span>--------------------------------------------------------------------------</span></span>
<span data-line=""><span> </span><span>&#39;</span><span>do</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>or</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>do</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>not</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>there</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>is</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>no</span><span>&#39;</span><span> </span><span>&lt;-&gt;</span><span> </span><span>&#39;</span><span>try</span><span>&#39;</span></span></code></pre></div></div>
<p>You can check whether a <code>tsquery</code> matches a <code>tsvector</code> by using the match operator <code>@@</code>.</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>dark vader</span><span>&#39;</span><span>) @@</span></span>
<span data-line=""><span>	to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span></span>
<span data-line=""><span>		</span><span>&#39;</span><span>Dark Vader is my father.</span><span>&#39;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>?column?</span></span>
<span data-line=""><span>----------</span></span>
<span data-line=""><span> t</span></span></code></pre></div></div>
<p>While the following example doesn&#39;t match:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>dark vader -father</span><span>&#39;</span><span>) @@</span></span>
<span data-line=""><span>	to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span></span>
<span data-line=""><span>		</span><span>&#39;</span><span>Dark Vader is my father.</span><span>&#39;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>?column?</span></span>
<span data-line=""><span>----------</span></span>
<span data-line=""><span> f</span></span></code></pre></div></div>

<p>Now that we&#39;ve seen <code>tsvector</code> and <code>tsquery</code> at work, let&#39;s look at another key building block: the GIN index type is what makes it fast. GIN stands for <em>Generalized Inverted Index.</em> GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. This means that GIN can be used for more than just text search, notably for JSON querying.</p>
<p>You can create a GIN index on a set of columns, or you can first create a column of type <code>tsvector</code>, to include all the searchable columns. Something like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>ALTER</span><span> </span><span>TABLE</span><span> movies </span><span>ADD</span><span> search tsvector </span><span>GENERATED</span><span> </span><span>ALWAYS</span><span> </span><span>AS</span></span>
<span data-line=""><span>	(to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, Title) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, Plot) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Director) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>	 to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Genre) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Origin) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Casting)</span></span>
<span data-line=""><span>) STORED;</span></span></code></pre></div></div>
<p>And then create the actual index:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>idx_search</span><span> </span><span>ON</span><span> movies </span><span>USING</span><span> GIN(search);</span></span></code></pre></div></div>
<p>You can now perform a simple test search like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title </span><span>FROM</span><span> movies </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>dark vader</span><span>&#39;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>                        title</span></span>
<span data-line=""><span>--------------------------------------------------</span></span>
<span data-line=""><span> Star Wars Episode IV: A New Hope (aka Star Wars)</span></span>
<span data-line=""><span> </span><span>Return</span><span> of the Jedi</span></span>
<span data-line=""><span> Star Wars: Episode III – Revenge of the Sith</span></span>
<span data-line=""><span>(</span><span>3</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>To see the effects of the index, you can compare the timings of the above query with and without the index. The GIN index takes it from over 200 ms to about 4 ms on my computer.</p>

<p>So far, we&#39;ve seen how <code>ts_vector</code> and <code>ts_query</code> can match search queries. However, for a good search experience, it is important to show the best results first - meaning that the results need to be sorted by <em>relevancy</em>.</p>
<p>Taking it directly from the <a href="https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-RANKING">docs</a>:</p>
<blockquote data-status="info" role="alert">
<p>PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur. However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs.</p>
</blockquote>
<p>The two ranking functions mentioned are <code>ts_rank</code> and <code>ts_rank_cd</code>. The difference between them is that while they both take into account the frequency of the term, <code>ts_rank_cd</code> also takes into account the proximity of matching lexemes to each other.</p>
<p>To use them in a query, you can do something like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title,</span></span>
<span data-line=""><span>       ts_rank(search, websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>dark vader</span><span>&#39;</span><span>)) rank</span></span>
<span data-line=""><span>  </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span>  </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>dark vader</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span>  </span><span>ORDER BY</span><span> rank </span><span>DESC</span></span>
<span data-line=""><span>  </span><span>LIMIT</span><span> </span><span>10</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span> title                                            |    rank</span></span>
<span data-line=""><span>--------------------------------------------------+------------</span></span>
<span data-line=""><span> </span><span>Return</span><span> of the Jedi                               | </span><span>0</span><span>.</span><span>21563873</span></span>
<span data-line=""><span> Star Wars: Episode III – Revenge of the Sith     | </span><span>0</span><span>.</span><span>12592985</span></span>
<span data-line=""><span> Star Wars Episode IV: A New Hope (aka Star Wars) | </span><span>0</span><span>.</span><span>05174401</span></span></code></pre></div></div>
<p>One thing to note about <code>ts_rank</code> is that it needs to access the <code>search</code> column for each result. This means that if the <code>WHERE</code> condition matches a lot of rows, PostgreSQL needs to visit them all in order to do the ranking, and that can be slow. To exemplify, the above query returns in 5-7 ms on my computer. If I modify the query to do search for <code>dark OR vader</code>, it returns in about 80 ms, because there are now over 1000 matching result that need ranking and sorting.</p>

<p>While relevancy based on word frequency is a good default for the search sorting, quite often the data contains important indicators that are more relevant than simply the frequency.</p>
<p>Here are some examples for a movies dataset:</p>
<ul role="list"><li>Matches in the title should be given higher importance than matches in the description or plot.</li><li>More popular movies can be promoted based on ratings and/or the number of votes they receive.</li><li>Certain categories can be boosted more, considering user preferences. For instance, if a particular user enjoys comedies, those movies can be given a higher priority.</li><li>When ranking search results, newer titles can be considered more relevant than very old titles.</li></ul>
<p>This is why dedicated search engines typically offer ways to use different columns or fields to influence the ranking. Here are example tuning guides from <a href="https://www.elastic.co/guide/en/app-search/current/relevance-tuning-guide.html">Elastic</a>, <a href="https://typesense.org/docs/guide/ranking-and-relevance.html">Typesense</a>, and <a href="https://www.meilisearch.com/docs/learn/core_concepts/relevancy">Meilisearch</a>.</p>
<p>If you want a visual demo of the impact of relevancy tuning, here is a quick 4 minutes video about it:</p>
<div><p><iframe src="https://www.youtube.com/embed/GfgdQs4WuXM" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe></p></div>

<p>While Postgres doesn&#39;t have direct support for boosting based on other columns, the rank is ultimately just a sort expression, so you can add your own signals to it.</p>
<p>For example, if you want to add a boost for the number of votes, you can do something like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title,</span></span>
<span data-line=""><span>  ts_rank(search, websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>))</span></span>
<span data-line=""><span>    </span><span>-- numeric booster example</span></span>
<span data-line=""><span>    </span><span>+</span><span> </span><span>log</span><span>(NumberOfVotes)</span><span>*</span><span>0</span><span>.</span><span>01</span></span>
<span data-line=""><span> </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span> </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span> </span><span>ORDER BY</span><span> rank </span><span>DESC</span><span> </span><span>LIMIT</span><span> </span><span>10</span><span>;</span></span></code></pre></div></div>
<p>The logarithm is there to smoothen the impact, and the 0.01 factor brings the booster to a comparable scale with the ranking score.</p>
<p>You can also design more complex boosters, for example, boost by the rating, but only if the ranking has a certain number of votes. To do this, you can create a function like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>create</span><span> </span><span>function</span><span> </span><span>numericBooster</span><span>(rating </span><span>numeric</span><span>, votes </span><span>numeric</span><span>, voteThreshold </span><span>numeric</span><span>)</span></span>
<span data-line=""><span>	</span><span>returns</span><span> </span><span>numeric</span><span> </span><span>as</span><span> $$</span></span>
<span data-line=""><span>		</span><span>select</span><span> </span><span>case</span><span> </span><span>when</span><span> votes </span><span>&lt;</span><span> voteThreshold </span><span>then</span><span> </span><span>0</span><span> </span><span>else</span><span> rating </span><span>end</span><span>;</span></span>
<span data-line=""><span>$$ </span><span>language</span><span> </span><span>sql</span><span>;</span></span></code></pre></div></div>
<p>And use it like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title,</span></span>
<span data-line=""><span>  ts_rank(search, websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>))</span></span>
<span data-line=""><span>    </span><span>-- numeric booster example</span></span>
<span data-line=""><span>    </span><span>+</span><span> numericBooster(Rating, NumberOfVotes, </span><span>100</span><span>)</span><span>*</span><span>0</span><span>.</span><span>005</span></span>
<span data-line=""><span> </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span> </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span> </span><span>ORDER BY</span><span> rank </span><span>DESC</span><span> </span><span>LIMIT</span><span> </span><span>10</span><span>;</span></span></code></pre></div></div>
<p>Let&#39;s take another example. Say we want to boost the ranking of comedies. You can create a <code>valueBooster</code> function that looks like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>create</span><span> </span><span>function</span><span> </span><span>valueBooster</span><span> (col </span><span>text</span><span>, val </span><span>text</span><span>, factor </span><span>integer</span><span>)</span></span>
<span data-line=""><span>	</span><span>returns</span><span> </span><span>integer</span><span> </span><span>as</span><span> $$</span></span>
<span data-line=""><span>		</span><span>select</span><span> </span><span>case</span><span> </span><span>when</span><span> col </span><span>=</span><span> val </span><span>then</span><span> factor </span><span>else</span><span> </span><span>0</span><span> </span><span>end</span><span>;</span></span>
<span data-line=""><span>$$ </span><span>language</span><span> </span><span>sql</span><span>;</span></span></code></pre></div></div>
<p>The function returns a factor if the column matches a particular value and 0 instead. Use it in a query like this:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title, genre,</span></span>
<span data-line=""><span>   ts_rank(search, websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>))</span></span>
<span data-line=""><span>   </span><span>-- value booster example</span></span>
<span data-line=""><span>   </span><span>+</span><span> valueBooster(Genre, </span><span>&#39;</span><span>comedy</span><span>&#39;</span><span>, </span><span>0</span><span>.</span><span>05</span><span>) rank</span></span>
<span data-line=""><span>FROM</span><span> movies</span></span>
<span data-line=""><span>   </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)                                                                                                 </span><span>ORDER BY</span><span> rank </span><span>DESC</span><span> </span><span>LIMIT</span><span> </span><span>10</span><span>;</span></span>
<span data-line=""><span>                      title                       |               genre                |        rank</span></span>
<span data-line=""><span>--------------------------------------------------+------------------------------------+---------------------</span></span>
<span data-line=""><span> The Men Who Stare </span><span>at</span><span> Goats                       | comedy                             |  </span><span>0</span><span>.</span><span>1107927106320858</span></span>
<span data-line=""><span> Clerks                                           | comedy                             |  </span><span>0</span><span>.</span><span>1107927106320858</span></span>
<span data-line=""><span> Star Wars: The Clone Wars                        | animation                          | </span><span>0</span><span>.</span><span>09513916820287704</span></span>
<span data-line=""><span> Star Wars: Episode I – The Phantom Menace 3D     | sci</span><span>-</span><span>fi                             | </span><span>0</span><span>.</span><span>09471701085567474</span></span>
<span data-line=""><span> Star Wars: Episode I – The Phantom Menace        | space opera                        | </span><span>0</span><span>.</span><span>09471701085567474</span></span>
<span data-line=""><span> Star Wars: Episode II – Attack of the Clones     | science fiction                    | </span><span>0</span><span>.</span><span>09285612404346466</span></span>
<span data-line=""><span> Star Wars: Episode III – Revenge of the Sith     | science fiction, </span><span>action</span><span>            | </span><span>0</span><span>.</span><span>09285612404346466</span></span>
<span data-line=""><span> Star Wars: The </span><span>Last</span><span> Jedi                         | </span><span>action</span><span>, adventure, fantasy, sci</span><span>-</span><span>fi |  </span><span>0</span><span>.</span><span>0889768898487091</span></span>
<span data-line=""><span> </span><span>Return</span><span> of the Jedi                               | science fiction                    | </span><span>0</span><span>.</span><span>07599088549613953</span></span>
<span data-line=""><span> Star Wars Episode IV: A New Hope (aka Star Wars) | science fiction                    | </span><span>0</span><span>.</span><span>07599088549613953</span></span>
<span data-line=""><span>(</span><span>10</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>

<p>Remember when we talked about the <code>tsvector</code> lexemes and that they can have weights attached? Postgres supports 4 weights, named A, B, C, and D. A is the biggest weight while D is the lowest and the default. You can control the weights via the <code>setweight</code> function which you would typically call when building the <code>tsvector</code> column:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>ALTER</span><span> </span><span>TABLE</span><span> movies </span><span>ADD</span><span> search tsvector </span><span>GENERATED</span><span> </span><span>ALWAYS</span><span> </span><span>AS</span></span>
<span data-line=""><span>   (setweight(to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, Title), </span><span>&#39;</span><span>A</span><span>&#39;</span><span>) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, Plot) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Director) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Genre) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Origin) </span><span>||</span><span> </span><span>&#39;</span><span> </span><span>&#39;</span><span> </span><span>||</span></span>
<span data-line=""><span>   to_tsvector(</span><span>&#39;</span><span>simple</span><span>&#39;</span><span>, Casting)</span></span>
<span data-line=""><span>) STORED;</span></span></code></pre></div></div>
<p>Let&#39;s see the effects of this. Without <code>setweight</code>, a search for <code>dark vader OR jedi</code> returns:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title, ts_rank(search, websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)) rank</span></span>
<span data-line=""><span>   </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span>   </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span>   </span><span>ORDER BY</span><span> rank </span><span>DESC</span><span>;</span></span>
<span data-line=""><span>                      title                       |    rank</span></span>
<span data-line=""><span>--------------------------------------------------+-------------</span></span>
<span data-line=""><span> Star Wars: The Clone Wars                        |  </span><span>0</span><span>.</span><span>09513917</span></span>
<span data-line=""><span> Star Wars: Episode I – The Phantom Menace        |  </span><span>0</span><span>.</span><span>09471701</span></span>
<span data-line=""><span> Star Wars: Episode I – The Phantom Menace 3D     |  </span><span>0</span><span>.</span><span>09471701</span></span>
<span data-line=""><span> Star Wars: Episode III – Revenge of the Sith     | </span><span>0</span><span>.</span><span>092856124</span></span>
<span data-line=""><span> Star Wars: Episode II – Attack of the Clones     | </span><span>0</span><span>.</span><span>092856124</span></span>
<span data-line=""><span> Star Wars: The </span><span>Last</span><span> Jedi                         |  </span><span>0</span><span>.</span><span>08897689</span></span>
<span data-line=""><span> </span><span>Return</span><span> of the Jedi                               | </span><span>0</span><span>.</span><span>075990885</span></span>
<span data-line=""><span> Star Wars Episode IV: A New Hope (aka Star Wars) | </span><span>0</span><span>.</span><span>075990885</span></span>
<span data-line=""><span> Clerks                                           |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span> The Empire Strikes Back                          |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span> The Men Who Stare </span><span>at</span><span> Goats                       |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span> How </span><span>to</span><span> Deal                                      |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span>(</span><span>12</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>And with the <code>setweight</code> on the title column:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> title, ts_rank(search, websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>, </span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)) rank</span></span>
<span data-line=""><span>   </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span>   </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>jedi</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span>   </span><span>ORDER BY</span><span> rank </span><span>DESC</span><span>;</span></span>
<span data-line=""><span>                      title                       |    rank</span></span>
<span data-line=""><span>--------------------------------------------------+-------------</span></span>
<span data-line=""><span> Star Wars: The </span><span>Last</span><span> Jedi                         |   </span><span>0</span><span>.</span><span>6361112</span></span>
<span data-line=""><span> </span><span>Return</span><span> of the Jedi                               |   </span><span>0</span><span>.</span><span>6231253</span></span>
<span data-line=""><span> Star Wars: The Clone Wars                        |  </span><span>0</span><span>.</span><span>09513917</span></span>
<span data-line=""><span> Star Wars: Episode I – The Phantom Menace        |  </span><span>0</span><span>.</span><span>09471701</span></span>
<span data-line=""><span> Star Wars: Episode I – The Phantom Menace 3D     |  </span><span>0</span><span>.</span><span>09471701</span></span>
<span data-line=""><span> Star Wars: Episode III – Revenge of the Sith     | </span><span>0</span><span>.</span><span>092856124</span></span>
<span data-line=""><span> Star Wars: Episode II – Attack of the Clones     | </span><span>0</span><span>.</span><span>092856124</span></span>
<span data-line=""><span> Star Wars Episode IV: A New Hope (aka Star Wars) | </span><span>0</span><span>.</span><span>075990885</span></span>
<span data-line=""><span> The Empire Strikes Back                          |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span> Clerks                                           |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span> The Men Who Stare </span><span>at</span><span> Goats                       |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span> How </span><span>to</span><span> Deal                                      |  </span><span>0</span><span>.</span><span>06079271</span></span>
<span data-line=""><span>(</span><span>12</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>Note how the movie titles with “jedi” in their name have jumped to the top of the list, and their rank has increased.</p>
<p>It&#39;s worth pointing out that having only four weight “classes” is somewhat limiting, and that they need to be applied when computing the <code>tsvector</code>.</p>

<p>PostgreSQL doesn&#39;t support fuzzy search or typo-tolerance directly, when using <code>tsvector</code> and <code>tsquery</code>. However, working on the assumptions that the typo is in the query part, we can implement the following idea:</p>
<ul role="list"><li>index all <em>lexemes</em> from the content in a separate table</li><li>for each word in the query, use similarity or Levenshtein distance to search in this table</li><li>modify the query to include any words that are found</li><li>perform the search</li></ul>
<p>Here is how it works. First, use <code>ts_stats</code> to get all words in a materialized view:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>CREATE</span><span> MATERLIAZED VIEW unique_lexeme </span><span>AS</span></span>
<span data-line=""><span>   </span><span>SELECT</span><span> word </span><span>FROM</span><span> ts_stat(</span><span>&#39;</span><span>SELECT search FROM movies</span><span>&#39;</span><span>);</span></span></code></pre></div></div>
<p>Now, for each word in the query, check if it is in the <code>unique_lexeme</code> view. If it&#39;s not, do a fuzzy-search in that view to find possible misspellings of it:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> unique_lexeme</span></span>
<span data-line=""><span>   </span><span>WHERE</span><span> levenshtein_less_equal(word, </span><span>&#39;</span><span>pregant</span><span>&#39;</span><span>, </span><span>2</span><span>) </span><span>&lt;</span><span> </span><span>2</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>   word</span></span>
<span data-line=""><span>----------</span></span>
<span data-line=""><span> premant</span></span>
<span data-line=""><span> pregrant</span></span>
<span data-line=""><span> pregnant</span></span>
<span data-line=""><span> paegant</span></span></code></pre></div></div>
<p>In the above we use the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> because that&#39;s what search engines like Elasticsearch use for fuzzy search.</p>
<p>Once you have the candidate list of words, you need to adjust the query include them all.</p>

<p>Faceted search is popular especially on e-commerce sites because it helps customers to iteratively narrow their search. Here is an example from amazon.com:</p>
<div><p><a href="https://bea.goth.cafe/mdx/blog/amazon_faceted_search.png"><img alt="Faceted search on Amazon" loading="lazy" decoding="async" data-nimg="fill" sizes="100vw" srcset="/_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=3840&amp;q=75 3840w" src="https://bea.goth.cafe/_next/image?url=%2Fmdx%2Fblog%2Famazon_faceted_search.png&amp;w=3840&amp;q=75"/></a></p><p><figcaption>Faceted search on Amazon</figcaption></p></div>
<p>The above can implemented by manually defining categories and then adding them as <code>WHERE</code> conditions to the search. Another approach is to create the categories algorithmically based on the existing data. For example, you can use the following to create a “Decade” facet:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>SELECT</span><span> ReleaseYear</span><span>/</span><span>10</span><span>*</span><span>10</span><span> decade, </span><span>count</span><span>(Title) cnt </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span>  </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>star wars</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span>  </span><span>GROUP BY</span><span> decade </span><span>ORDER BY</span><span> cnt </span><span>DESC</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>decade | cnt</span></span>
<span data-line=""><span>--------+-----</span></span>
<span data-line=""><span>   </span><span>2000</span><span> |  </span><span>39</span></span>
<span data-line=""><span>   </span><span>2010</span><span> |  </span><span>31</span></span>
<span data-line=""><span>   </span><span>1990</span><span> |  </span><span>29</span></span>
<span data-line=""><span>   </span><span>1950</span><span> |  </span><span>28</span></span>
<span data-line=""><span>   </span><span>1940</span><span> |  </span><span>26</span></span>
<span data-line=""><span>   </span><span>1980</span><span> |  </span><span>22</span></span>
<span data-line=""><span>   </span><span>1930</span><span> |  </span><span>13</span></span>
<span data-line=""><span>   </span><span>1960</span><span> |  </span><span>11</span></span>
<span data-line=""><span>   </span><span>1970</span><span> |   </span><span>7</span></span>
<span data-line=""><span>   </span><span>1910</span><span> |   </span><span>3</span></span>
<span data-line=""><span>   </span><span>1920</span><span> |   </span><span>3</span></span>
<span data-line=""><span>(</span><span>11</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>This also provides counts of matches for each decade, which you can display in brackets.</p>
<p>If you want to get multiple facets in a single query, you can combine them, for example, by using CTEs:</p>
<div data-rehype-pretty-code-fragment=""><div role="group"><pre data-theme="default" tabindex="0" data-language="sql"><code><span data-line=""><span>WITH</span><span> releaseYearFacets </span><span>AS</span><span> (</span></span>
<span data-line=""><span>  </span><span>SELECT</span><span> </span><span>&#39;</span><span>Decade</span><span>&#39;</span><span> facet, (ReleaseYear</span><span>/</span><span>10</span><span>*</span><span>10</span><span>)::</span><span>text</span><span> val, </span><span>count</span><span>(Title) cnt</span></span>
<span data-line=""><span>  </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span>  </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>star wars</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span>  </span><span>GROUP BY</span><span> val </span><span>ORDER BY</span><span> cnt </span><span>DESC</span><span>),</span></span>
<span data-line=""><span>genreFacets </span><span>AS</span><span> (</span></span>
<span data-line=""><span>  </span><span>SELECT</span><span> </span><span>&#39;</span><span>Genre</span><span>&#39;</span><span> facet, Genre val, </span><span>count</span><span>(Title) cnt </span><span>FROM</span><span> movies</span></span>
<span data-line=""><span>  </span><span>WHERE</span><span> search @@ websearch_to_tsquery(</span><span>&#39;</span><span>english</span><span>&#39;</span><span>,</span><span>&#39;</span><span>star wars</span><span>&#39;</span><span>)</span></span>
<span data-line=""><span>  </span><span>GROUP BY</span><span> val </span><span>ORDER BY</span><span> cnt </span><span>DESC</span><span> </span><span>LIMIT</span><span> </span><span>5</span><span>)</span></span>
<span data-line=""><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> releaseYearFacets </span><span>UNION</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> genreFacets;</span></span>
<span data-line=""> </span>
<span data-line=""><span> facet  |   val   | cnt</span></span>
<span data-line=""><span>--------+---------+-----</span></span>
<span data-line=""><span> Decade | </span><span>1910</span><span>    |   </span><span>3</span></span>
<span data-line=""><span> Decade | </span><span>1920</span><span>    |   </span><span>3</span></span>
<span data-line=""><span> Decade | </span><span>1930</span><span>    |  </span><span>13</span></span>
<span data-line=""><span> Decade | </span><span>1940</span><span>    |  </span><span>26</span></span>
<span data-line=""><span> Decade | </span><span>1950</span><span>    |  </span><span>28</span></span>
<span data-line=""><span> Decade | </span><span>1960</span><span>    |  </span><span>11</span></span>
<span data-line=""><span> Decade | </span><span>1970</span><span>    |   </span><span>7</span></span>
<span data-line=""><span> Decade | </span><span>1980</span><span>    |  </span><span>22</span></span>
<span data-line=""><span> Decade | </span><span>1990</span><span>    |  </span><span>29</span></span>
<span data-line=""><span> Decade | </span><span>2000</span><span>    |  </span><span>39</span></span>
<span data-line=""><span> Decade | </span><span>2010</span><span>    |  </span><span>31</span></span>
<span data-line=""><span> Genre  | comedy  |  </span><span>21</span></span>
<span data-line=""><span> Genre  | drama   |  </span><span>35</span></span>
<span data-line=""><span> Genre  | musical |   </span><span>9</span></span>
<span data-line=""><span> Genre  | unknown |  </span><span>13</span></span>
<span data-line=""><span> Genre  | war     |  </span><span>15</span></span>
<span data-line=""><span>(</span><span>16</span><span> </span><span>rows</span><span>)</span></span></code></pre></div></div>
<p>The above should work quite well on small to medium data sets, however it can become slow on very large data sets.</p>

<p>We&#39;ve seen the PostgreSQL full-text search primitives, and how we can combine them to create a pretty advanced full-text search engine, which also happens to support things like joins and ACID transactions. In other words, it has functionality that the other search engines typically don&#39;t have.</p>
<p>There are more advanced search topics that would be worth covering in detail:</p>
<ul role="list"><li>suggesters / auto-complete</li><li>exact phrase matching</li><li>hybrid search (semantic + keyword) by combining with pg-vector</li></ul>
<p>Each of these would be worth their own blog post (coming!), but by now you should have an intuitive feeling about them: they are quite possible using PostgreSQL, but they require you to do the work of combining the primitives and in some cases the performance might suffer on very large datasets.</p>
<p>In part 2, we&#39;ll make a detailed comparison with Elasticsearch, looking to answer the question on when is it worth it to implement search into PostgreSQL versus adding Elasticsearch to your infrastructure and syncing the data. If you want to be notified when this gets published, you can follow us on <a href="https://twitter.com/xata">Twitter</a> or join our <a href="https://xata.io/discord">Discord</a>.</p></div></div>
  </body>
</html>
