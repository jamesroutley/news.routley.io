<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexyakunin.medium.com/net-6-vs-net-5-up-to-40-speedup-ceca9112d298">Original</a>
    
    <div id="readability-page-1" class="page"><div><div><p id="d8b1">It’s <a href="https://github.com/servicetitan/Stl.Fusion.Samples/blob/master/README.md#4-caching-sample" target="_blank" rel="noopener ugc nofollow">Fusion’s “Caching” sample</a>, which uses EF Core and ASP.NET Core. You can run it by cloning <a href="https://github.com/servicetitan/Stl.Fusion.Samples" target="_blank" rel="noopener ugc nofollow">https://github.com/servicetitan/Stl.Fusion.Samples</a> and starting <code>Run-Sample-Caching.cmd</code> or <code>Run-Sample-Caching-Net50.cmd</code></p><p id="accc">Besides that, all .NET 6.0 tests mentioned here were run with PGO enabled:</p><figure><div></div></figure><p id="62b6">A brief<span id="rmm"><span id="rmm"> </span></span>description of what above tests do:</p><ul><li id="1f06">Tests producing 20M+ operations/s (#1, #3) are mainly constrained by Fusion’s logic, <a href="http://www.castleproject.org/projects/dynamicproxy/" target="_blank" rel="noopener ugc nofollow">Castle.DynamicProxy</a>, and overall, it’s ~ mostly a cache key computation and lookup logic. Almost every iteration ends up with a cache hit there.</li><li id="c598">Tests producing &lt;1M operations/s are constrained by either EF &amp; SQL Server (#2, #5) or ASP.NET Core (#4 — it’s ~ the same as #5, but relying on <a href="https://github.com/servicetitan/Stl.Fusion.Samples/blob/master/docs/tutorial/Part05.md" target="_blank" rel="noopener ugc nofollow">Fusion’s caching features</a>).</li></ul><p id="d35a">So what do we see here:</p><ul><li id="a156">Caching / tight loop tests get up to 30% speedup</li><li id="81d4">Test #4, which basically adds Fusion cache to a regular web API, gets 15% speedup with .NET 6</li><li id="466d">“Typical” HTTP pipeline test (HttpClient hitting ASP.NET Core controller that hosts a CRUD style EF Core service) gets ~ 4.5% speedup.</li></ul><p id="dfc2">And interestingly, the same pattern is easy to see on <a href="https://github.com/servicetitan/Stl.Fusion/tree/master/docs/performance-test-results" target="_blank" rel="noopener ugc nofollow">performance test in Fusion test suite</a>:</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*WPLDz8za5OfJQbd3OdKeKQ.png?q=20" width="700" height="387" role="presentation"/></p><p><img alt="" width="700" height="387" role="presentation"/></p></div></div></div></div><figcaption>Spreadsheet w/ more data: <a href="https://docs.google.com/spreadsheets/d/1-zs6JMtsgQ3mll4whSDKl2T7l38ob4cW9trZNpEWaz4/edit?usp=sharing" target="_blank" rel="noopener ugc nofollow">https://docs.google.com/spreadsheets/d/1-zs6JMtsgQ3mll4whSDKl2T7l38ob4cW9trZNpEWaz4/edit?usp=sharing</a></figcaption></figure><p id="4891">You can run it by cloning <a href="https://github.com/servicetitan/Stl.Fusion" target="_blank" rel="noopener ugc nofollow">https://github.com/servicetitan/Stl.Fusion</a> and typing:</p><figure><div></div></figure><p id="0c06">Top test set is exactly the same as the bottom one, the only difference is that it relies on Fusion’s compute service instead of a regular one, i.e. it heavily benefits of Fusion’s transparent caching logic.</p><p id="75e7">So in terms of what happens under the hood,</p><ul><li id="cd29">Top tests mostly compute cache keys, hash them, acquire async locks, and run <code>ConcurrentDictionary</code> lookups</li><li id="6da8">Bottom tests actually run SQL commands — mostly <code>SELECT</code> -s fetching a single row.</li></ul><p id="bd89">And it’s clear that PGO in .NET 6 shines in the first case, so in-process caching definitely brings more advantages with .NET 6.</p><p id="fb18">As for the second category of tests, even ~ 5% speedup is quite impressive for a code which speed is mostly constrained by external service (PostgreSQL or SQL Server). And benchmarks with InMemory EF Core provider (which is also a .NET library) prove this by showing ~ 14–15% speedup.</p><p id="0a3b">The gist is: .NET 6 with PGO enabled may bring you:</p><ul><li id="7848">+30–40% speed on tight loops &amp; cache-friendly logic</li><li id="2224">+15% for an average code that doesn’t depend on networking &amp; IO</li><li id="2c44">+5% for a typical web service that mostly depends on networking &amp; IO.</li></ul><p id="a1a5">I plan to share a similar comparison w/ <a href="https://github.com/alexyakunin/GCBurn" target="_blank" rel="noopener ugc nofollow">GCBurn</a> (my garbage collection &amp; allocation performance test) and <a href="https://itnext.io/geting-4x-speedup-with-net-core-3-0-simd-intrinsics-5c9c31c47991" target="_blank" rel="noopener ugc nofollow">the code I used to compare SIMD-accelerated logic on C# &amp; C++</a>. But again, it’s absolutely clear that .NET 6 is truly the fastest .NET yet, so huge thanks to everyone who made this possible!</p><p id="1c86"><strong>P.S.</strong> My 3-month-old stealth startup is hiring a full-stack developer. If you know .NET really well and eager to use a cutting-edge real-time tech stack (Blazor, Fusion) to redefine the meaning of one of our daily activities, please PM me :)</p></div></div></div>
  </body>
</html>
