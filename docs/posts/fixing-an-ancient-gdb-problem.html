<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/909496/a56a9a4ab41ff079/">Original</a>
    <h1>Fixing an ancient GDB problem</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
The <a href="https://www.sourceware.org/gdb/">GDB debugger</a> has a long
history; it was first created in 1986.  It may thus be
unsurprising that some GDB development happens over relatively long time
frames but, even when taking that into account, the existence of an open
bug first <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=9425">reported</a> in
2007 may be a little surprising.  At the <a href="https://gcc.gnu.org/wiki/cauldron2022">2022 GNU Tools Cauldron</a>,
GDB maintainer Pedro Alves talked about why this problem has been difficult
to solve, and what the eventual solution looks like.
</p><p>
The problem in question, Alves said, has to do with the handling of
keyboard interrupts, which normally result from the user hitting control-C.
The user&#39;s normal expectation is that an interrupt within GDB while the target
program is running will stop the program and return the GDB prompt.  If,
however, that program has blocked the <tt>SIGINT</tt> signal, the interrupt
will never be delivered.  At best, GDB will not stop; at worst, the entire
debugging session can become stuck and need to be killed from another
terminal.  GDB users, it seems, tend not to like that behavior.
</p><p>
This problem results from how GDB handles both terminals and interrupt
signals.  A &#34;session&#34;, in the Unix sense, is a set of process groups, all
of which share a single controlling terminal.
Normally, the debugged process runs in the same session as — and shares the
terminal with — GDB, but GDB puts that process into a different process group.
Multiple process groups can share a terminal, but only one of those — the
foreground group — will receive signals generated by the user at that
terminal.  GDB normally runs as the foreground group but, when it runs the
target program, it designates that program&#39;s group as the foreground group
instead.
</p><p>
<a href="https://lwn.net/Articles/909503/"><img src="https://static.lwn.net/images/conf/2022/cauldron/PedroAlves-sm.png" alt="[Pedro Alves]" title="Pedro Alves"/></a>

Normally, if the target process receives a <tt>SIGINT</tt> signal, it will
be intercepted by GDB; that happens as part of how tracing with <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html"><tt>ptrace()</tt></a>
works.  GDB will respond by stopping the target program and putting out a
prompt; the signal is never actually delivered to that program.  If,
however, the program has blocked <tt>SIGINT</tt> then the signal remains
pending; since it is never delivered, <tt>ptrace()</tt> has nothing to
intercept.  That can result in everything getting stuck.  There are other
paths to the same situation; <a href="https://man7.org/linux/man-pages/man3/sigwait.3.html"><tt>sigwait()</tt></a>
calls, for example, can consume pending signals in a way that causes them
to never actually be delivered.
</p><p>
The solution, Alves said, is the same as for any other problem in computer
science: add another layer of indirection.  In this case, that layer takes
the form of a pseudo-terminal (PTY) that is given to the target process
rather than the real controlling terminal.  GDB then acts as an
intermediary between the two terminals.  Any output written by the target
program to the PTY is simply copied to the real terminal.  Input is a bit
trickier, since the target can have changed the terminal&#39;s modes; GDB has
to put the real terminal into raw mode, then copy all of the input from the
real terminal into the PTY.  When the target is not running, the terminal
is put back into &#34;readline mode&#34; for interaction with GDB.
</p><p>
Now, the target can do anything it wants with <tt>SIGINT</tt> without
affecting GDB, which, as the foreground process on the real terminal, can
handle events directly.  Since that terminal is in raw mode, that means
recognizing the interrupt character and responding accordingly.  There are
other advantages as well; since GDB remains in control of when output goes
to the (real) terminal, it can avoid intermixing its own output with that
from the target.  Another advantage is that GDB is now able to preserve the
user&#39;s thread selection (the specific thread that debugging activity is
focused on) after an interrupt; this wasn&#39;t possible before.
</p><p>
There is, he said, an &#34;escape hatch&#34; for anybody wanting the previous
behavior; it needs to be there to support other Unix systems in any case.
</p><p>
There were a few other remaining problems, he said.  The first process in
the foreground 
process group is considered the &#34;session leader&#34; by the kernel; if that
process exits, then its children will be sent a <tt>SIGHUP</tt> signal.
Most applications are not prepared for that and will be killed as a result.
Now that the target has its own terminal, it becomes the session leader
once it starts.  If that process forks and exits, its child processes are
likely to meet an untimely end — not the debugging experience that the user
is likely to have had in mind.
</p><p>
The solution in this case is a variation on the
double-fork technique; before launching the target, GDB will fork twice,
with the first process doing nothing but waiting.  It will become the
session leader; since it doesn&#39;t exit, no <tt>SIGHUP</tt> signals will be
generated if the target does surprising things.
</p><p>
GDB still has to be able to stop programs that block <tt>SIGINT</tt>; for
obvious reasons, it cannot use <tt>SIGINT</tt> for that purpose.  The
solution here, he said, is to use <tt>SIGSTOP</tt>, which cannot be
blocked, instead.
</p><p>
As is often the case, Emacs users present their own special challenges.
Emacs uses control-C for its own purposes, and remaps <tt>SIGINT</tt> to
control-G instead.  In cases like this, the user almost certainly wants
control-C to be passed through to the target.  The answer is a GDB command
that allows the user to specify which key should interrupt the process and
return to the GDB prompt.

</p><p>
This patch was first prototyped in 2019, but didn&#39;t make it to the GDB list
until 2021.  There were a few problems that turned up at that point,
including the session-leader difficulty.  Those have all been resolved, and
Alves intends to post the patch set again sometime soon.  His objective, he
concluded, is to post it at least once per year until the problem is
finally solved.
</p><p>
[Thanks to LWN subscribers for supporting my travel to this event.]<br clear="all"/></p>
               </div></div>
  </body>
</html>
