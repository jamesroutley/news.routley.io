<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgerrells.com/blog/how-not-to-use-box-shadows">Original</a>
    <h1>So you think you know box shadows?</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://dgerrells.com/images/boxshadowrender.jpg" alt="cgi image with spheres"/></p>
<p>Box shadows. I love them.</p>
<p>Four years ago I found out my m1 can render a stupid number of these bad boys and so I set out to see just how far you can push them and boy did I. If you are looking for a <code>how to use box shadows to get the look of the latest UX trend</code>, this is not the right article for you. But if you like some janky creativity, stay tuned.</p>
<p>I want to share some of the worst possible things one can do with box shadows all on a single div. Things which shouldn&#39;t work at all yet somehow they do. But before getting into that, a question must be answered.</p>
<p>What exactly is a box shadow?</p>
<h2>Graphic design 101</h2>
<p>A box shadow is a kind of drop shadow. And a drop shadow is a kind of image filter that is very popular in graphic design due to how versatile it is at adding an approximation of depth to composition.</p>
<p>The filter takes the raster of an image and shifts the pixels along the x and y axis. It will draw these pixels as a single color behind the source image. This gives an illusion of depth by dropping the outline of an image as a &#34;shadow&#34; into the composition hence the name drop shadow.</p>
<p>We can use the css filter property to see this in action.</p>
<pre><code><span>div</span> {
  <span>filter</span>: <span>drop-shadow</span>(xOffset yOffset rgba(<span>0</span>, <span>0</span>, <span>0</span>, <span>0.5</span>));
}
</code></pre>

<p>There are many different implementations of a drop shadow filter across different tools like photoshop, gimp, figma, and css each having a different set of features. For example css also supports an optional blur value to apply to the drop shadow.</p>
<pre><code><span>div</span> {
  <span>filter</span>: <span>drop-shadow</span>(xOffset yOffset blurSize rgba(<span>0</span>, <span>0</span>, <span>0</span>, <span>0.5</span>));
}
</code></pre>

<p>By layering several drop filters one can easily add interesting depth to a composition.</p>
<p>For example, here are 2 layered drop-shadow filters.</p>

<p>Nifty.</p>
<p>What about box shadows?</p>
<h2>The Box Shadow</h2>
<p>A box shadow is a form of drop filter with many trade offs. First, the name &#34;Box&#34; has to do with the filter only supporting box shapes. For example, lets try applying it to the previous example.</p>

<p>Notice that the shadow shape is limited to the bounding box of the container and how the shadow can break out of the bounding box. This seems limiting but it comes with a few more features one of which is performance.</p>
<p>It turns out that the majority of user interfaces are made up of boxes. It also turns out that some smart people figured out maths hacks to draw rounded boxes for super cheap which UI peeps love because with this hack boxes can be so round as to appear as circles. And the css box shadow implementation supports this math hack.</p>
<p>This means that designers can be liberal with box shadows rather than relying on prerendered source images bloating download sizes.</p>
<p>This little mixer shows the variety of shapes available. Tap to randomize the color.</p>

<p>This opens up a all kinds of freedom for UI design. Layering these together can produce amazing results. You can play around with a border editor <a href="https://cssgenerator.org/border-radius-css-generator.html">here</a>.</p>
<p>Layering. That is an important word. You can layer or chain many box shadows together on a single div. The above example uses this to set the colors.</p>
<pre><code><span><span>function</span> <span>randomizeAndColor</span>(<span>e</span>) </span>{
  randomize(e);
  <span>const</span> spread = <span>Math</span>.random() &gt; <span>0.8</span> ? <span>2</span> : <span>0</span>;
  <span>const</span> x1 = <span>Math</span>.floor(<span>3</span> - <span>Math</span>.random() * <span>6</span>) / (<span>1</span> + spread);
  <span>const</span> y1 = <span>Math</span>.floor(<span>3</span> - <span>Math</span>.random() * <span>6</span>) / (<span>1</span> + spread);
  <span>const</span> y2 = <span>2</span> + <span>Math</span>.floor(<span>Math</span>.random() * <span>4</span>);
  <span>const</span> blur2 = <span>8</span> + <span>Math</span>.floor(<span>Math</span>.random() * <span>12</span>);
  e.style.boxShadow = <span>`<span>${x1}</span>px <span>${y1}</span>px 0px <span>${spread}</span>px <span>${getRandomPastelColor()}</span>, 0 <span>${y2}</span>px <span>${blur2}</span>px #0006`</span>;
}
</code></pre>
<h2>How <em>not</em> to use box shadows</h2>
<p>Usually, a designer will carefully position squares within other squares with consistent margins, paddings, and typography for optimal accessibility and understandability. Wisely, they further add layered shadows and perhaps a few images to help visually distinguish widget interaction and state.</p>
<p>That is all well and good but what we are really working with is a kind of painting api. We can paint an arbitrary number of squares to the screen optionally applying a blur to them.</p>
<p>I initially explored this with somme <a href="https://dgerrells.com/blog/all-the-ways-to-css">minimal art in an earlier write up</a>.</p>
<p>I liked the results.</p>
<p>The config that drives this is pretty simple.</p>
<pre><code><span>const</span> blocks = [
  [<span>8</span>, <span>&#34;#114d33&#34;</span>],
  [<span>24</span>, <span>&#34;#50bbab&#34;</span>],
  [<span>28</span>, <span>&#34;#fcba94&#34;</span>],
  [<span>10</span>, <span>&#34;#eced26&#34;</span>],
  
];

<span><span>&lt;<span>MinimalSets</span> <span>blockLists</span>=<span>{blocks}</span> /&gt;</span></span>;
</code></pre>
<p>Now the natural question I am sure you have and I certainly had was, &#34;can we do more box shadows?&#34; What about blurring or transparency? How do they impact performance?</p>
<p>I whipped up a little visual tool where a giant box shadow is created and set on a div like so.</p>
<pre><code><span>const</span> computedBoxShadow = points.map(
  <span>(<span>[x, y], i</span>) =&gt;</span>
    <span>`<span>${x}</span>px <span>${y}</span>px <span>${getBlur(i, frame)}</span>px <span>${animatedColor()}</span>`</span>
).join(<span>&#34;,&#34;</span>)



&lt;style&gt;<span>`
  myDiv {
    box-shadow: <span>${computedBoxShadow}</span>;
  }
`</span>&lt;/style&gt;
</code></pre>
<p>Animation is handled by setting the box shadow string every 300ms and then letting <code>transition: all</code> prop do the animation. This causes some jank and ended up being slower that setting the box shadow on every frame.</p>
<p>The result is an app where you can tap to remix a color palette with a history of the last 10 palettes to the left. Here is an example with 100 box shadows. Tap around.</p>

<p>I noticed that applying a blur slowed down the number you could animate which makes sense. However, using a transparent color significantly slowed down the number that can be drawn too which doesn&#39;t make as much sense to me. I&#39;d imagine that with hardware today transparency should be somewhat free. The div size also impacts performance which makes me think there is some software rasterizer involved when things are animated. I could look into the source code of browsers but it would be different depending on the js engine.</p>
<p>However, I found that if I didn&#39;t set any transparency or blur, my m1 laptop could draw buckets of box shadows. Like thousands of them.</p>
<h2>How to <span><em>seriously</em></span> <em>not</em> use box shadows</h2>
<p>Ok, many box shadows can be drawn. Now what?</p>
<p>Well we cannot rotate the box shadows but they can be circles and a circle kinda looks like a ball. So what if I made a bunch of balls that could bounce around? And maybe I can &#34;fake&#34; a 3d effect by scaling the size based on a z value. This wouldn&#39;t be accurate perspective but would add some 3d depth.</p>
<p>This one is pretty simple. Just a big&#39;ol &#34;gamestate&#34; updated in a <code>requestAnimationFrame</code> and then set a giant box shadow string on div. You can touch somewhere to pull the balls towards you. The balls are contained to a box and will bounce to stay in frame.</p>
<p>Toss a tick function into <code>requestAnimationFrame</code></p>
<pre><code><span>const</span> tick = <span>(<span>timestamp: <span>number</span></span>) =&gt;</span> {
  gameState.frame++;
  gameState.deltaTime = <span>Math</span>.min(
    (timestamp - gameState.prevFrameStartTime) / <span>1000</span>,
    <span>0.1</span>
  );
  gameState.prevFrameStartTime = timestamp;
  update(gameState);
  render(gameState);
  winContext._gameFrame = <span>window</span>.requestAnimationFrame(tick);
};
</code></pre>
<p>Updating the simulation isn&#39;t complicated but for the sake of brevity I will use a bit of psudocode.</p>
<pre><code><span>const</span> update: GameFunction = <span>(<span>state</span>) =&gt;</span> {
  <span>for</span> (<span>const</span> ball <span>in</span> state) {
    updateBall();
    containBall();
    addFriction();
    <span>if</span> (touched) pullToPoint(touchX, touchY);
  }
};
</code></pre>
<p>Now rendering is the interesting part. What is going to be run 60 time a second is the following.</p>
<pre><code><span>const</span> render: GameFunction = <span>(<span>state</span>) =&gt;</span> {
  <span>const</span> boxShadowString = state.balls
    .sort(<span>(<span>a, b</span>) =&gt;</span> b.z - a.z)
    .map(<span>(<span>ball</span>) =&gt;</span> {
      <span>const</span> zIndexScale = <span>1</span> + ball.z / <span>30</span>;
      <span>const</span> size = ball.size * zIndexScale;
      <span>const</span> halfSize = (size - state.renderContainerSize) / <span>2</span>;
      <span>const</span> hcs = state.renderContainerSize / <span>2</span>;
      <span>return</span> [
        ball.x + hcs,
        <span>&#34;px &#34;</span>,
        ball.y + hcs,
        <span>&#34;px 0 &#34;</span>,
        halfSize,
        <span>&#34;px &#34;</span>,
        ball.color,
      ].join(<span>&#34;&#34;</span>);
    })
    .join(<span>&#34;,&#34;</span>);
  <span>const</span> renderEl = <span>document</span>.getElementById(<span>&#34;render&#34;</span>);
  <span>if</span> (renderEl) {
    renderEl.style.boxShadow = boxShadowString;
  }
};
</code></pre>
<p>Sort the balls based on z index and fill an array of box shadows. The size calculation is based off of wanting to have x,y,z represent the center of a ball with a radius of size. The z scale is a hack to have some z &#34;depth&#34; where the size is scaled based on a fixed ratio.</p>
<p>Here are 50 balls. Drag em around and make em bounce on the sides.</p>

<p>The 3d scaling works pretty well to give a little bit of depth even if it is total bs. You can notice that when a ball gets close to the &#34;camera&#34; at a certain point it is no longer a circle. This is because the box shadow div is too small for the scaling method. Increasing the container size fixes this but a larger container means slower performance.</p>
<p>Let&#39;s see what happens if the balls can bounce off each other with some good old fashion <code>n^2</code> collision check. Now, I am only going to reflect the balls velocity on a collision detection which is inaccurate but simple. This is not simulating any real physics interaction. I will also fix the z position to make it 2d so it is easier to see what is happening.</p>

<p>Not very interesting. I think something more accurate physics would look nicer but maybe another time. Adding a phone gyro as input to this could be fun too but again maybe another time.</p>
<p>I reproduced another setup where the balls always try and find their way home to a random starting position. The force of a touch is enough to pull them away however. This give an effect almost like a sponge where you can pull bits off. I can think of ways this could be used for some foam spray in fake fluid sim as part of a game or something. Kind of fun.</p>

<p>I noticed that the fake 3d really comes out in the above example as the balls slowly travel back home. How could the 3d aspect be taken further? Maybe I could draw point clouds with the box shadows as points? I could project points on difference surfaces and then draw the points like some godawful 3d renderer.</p>
<p>I thought a good starting point would be to simply map pixels from a picture as points on a 2d plane. This would also be a good stress test to find out what the upper limit is on number of realtime simulated box shadows. Here is the mapping function.</p>
<pre><code><span>const</span> pixels = <span>await</span> getImagePixels(
  <span>&#34;/images/starry_night_full.jpg&#34;</span> <span>as</span> <span>any</span>,
  width
);
<span>const</span> dx = <span>window</span>.innerWidth / pixels[<span>0</span>].length;
<span>const</span> dy = <span>window</span>.innerHeight / pixels.length;
<span>for</span> (<span>let</span> y = <span>0</span>; y &lt; pixels.length; y++) {
  <span>for</span> (<span>let</span> x = <span>0</span>; x &lt; pixels[<span>0</span>].length; x++) {
    <span>const</span> px = x * dx + dx / <span>2</span>,
      py = y * dy + dy / <span>2</span>,
      pz = <span>60</span> + <span>Math</span>.random() * <span>3</span>;
    state.particles.push({
      size: pSize,
      x: px,
      y: py,
      z: pz,
      ox: px,
      oy: py,
      oz: pz,
      dx: <span>Math</span>.random() * <span>3</span>,
      dy: <span>Math</span>.random() * <span>3</span>,
      dz: <span>Math</span>.random() * <span>3</span>,
      color: pixels[y][x],
    });
  }
}
</code></pre>
<p>The image is scaled to fix a max width which can be configured in a query param but otherwise it is mostly the same as before. If you want the source, here is the <a href="https://codesandbox.io/p/sandbox/v2-5-2y9ml9-starry-etoc64">codesandbox</a>.</p>
<p>I started with one of my all time favorite paintings ever. Tap around.</p>

<p>Depending on your device, this demo may be melting it as it is rendering several thousand box shadows in simulated 3d space. You can drag around to kinda explode the image up. This is taking the previous examples and setting the starting positions and colors based on an image.</p>
<p>I am going to bump up the count and rotate the camera. I will record this one to save some battery life. If you want to burn your battery give a live version a try <a href="https://dgerrells.com/box-shadow/v3?width=80&amp;size=5&amp;autoRotate=1">here</a>. You have been warned.</p>
<iframe src="https://www.youtube.com/embed/iJIOQHft2b0" frameborder="false" credentialless="true" width="100%" height="430px" sandbox="allow-scripts allow-popups allow-top-navigation-by-user-activation allow-forms allow-same-origin allow-storage-access-by-user-activation allow-popups-to-escape-sandbox"></iframe>
<p>This is promising. I personally love how this has an almost painted style due to the circular pixels looking kinda splatted on. Here is another example with an increased count and some interaction.</p>
<iframe src="https://www.youtube.com/embed/SmdBewU2qkU" frameborder="false" credentialless="true" width="100%" height="430px" sandbox="allow-scripts allow-popups allow-top-navigation-by-user-activation allow-forms allow-same-origin allow-storage-access-by-user-activation allow-popups-to-escape-sandbox"></iframe>
<p>You can see it is chugging at this scale. For reference, this is somewhere in the ballpark of 12,000 box shadows. I mean, damn. I wonder if perhaps it is so fast because the m1 has shared gpu and cpu memory? My desktop certainly cannot push this many box shadows neither can my iphone or old android. Crazy result tho.</p>
<p>What about a projecting the points uniformly on to the surface of a mesh?</p>
<p>It turns out with a bit of math it totally works. Here is a cube using a formula with uniform point distribution.</p>

<p>You can still play around like it is jello. I also added a small light which follows the mouse positioning. This adds a bit more depth. The light is not accurate what so ever with magic constants left and right but what is programming without a sprinkling of magic? ðŸ˜Š</p>
<pre><code>.map(<span>(<span>[p, coord]</span>) =&gt;</span> {
  <span>const</span> zIndexScale = <span>1</span> + coord.z / <span>40</span>;
  <span>const</span> size = p.size * zIndexScale;
  <span>const</span> halfSize = (size - state.renderContainerSize) / <span>2</span>;
  <span>const</span> hcs = state.renderContainerSize / <span>2</span>;

  <span>const</span> lightDist = <span>Math</span>.sqrt(dist(coord, lightPos));
  <span>const</span> intensity = (<span>1</span> - lightDist / <span>900</span>) * <span>1</span>; 
  <span>const</span> lumen = <span>Math</span>.min(<span>2</span>, (<span>1</span> / lightDist ** <span>2</span>) * <span>60000</span>);
  <span>return</span> [
    coord.x + hcs,
    <span>&#34;px &#34;</span>,
    coord.y + hcs,
    <span>&#34;px 0 &#34;</span>,
    halfSize,
    <span>&#34;px &#34;</span>,
    darkenHexColor(p.color, lumen),
  ].join(<span>&#34;&#34;</span>);
})
</code></pre>
<p>I used gypity to give me a function to do the cube particle mapping among a few other math helpers. Sometimes gypity-g would work but sometimes it wouldn&#39;t and I have to stop being lazy. More on this later...</p>
<p>The first function gyptiy gave was a random distribution which I didn&#39;t want. I wanted a uniform placement of points across the surface of a uniform sized cube. It was able to get this on the second try.</p>
<pre><code><span>export</span> <span><span>function</span> <span>getCubeSurfacePoints</span>(<span>
  cubeSideLength: <span>number</span>,
  numberOfPoints: <span>number</span>
</span>) </span>{
  <span>const</span> points = <span>new</span> <span>Map</span>&lt;<span>string</span>, Vec3&gt;();
  <span>const</span> halfSideLength = <span>Math</span>.floor(cubeSideLength / <span>2</span>);
  <span>const</span> facePointSpacing = <span>Math</span>.floor(
    cubeSideLength / <span>Math</span>.sqrt(numberOfPoints)
  );
  <span>const</span> addPoint = <span>(<span>x, y, z</span>) =&gt;</span> {
    <span>const</span> key = <span>`<span>${x}</span>, <span>${y}</span>, <span>${z}</span>`</span>;
    points.set(key, { x, y, z });
  };

  
  <span>for</span> (<span>let</span> i = -halfSideLength; i &lt;= halfSideLength; i += facePointSpacing) {
    <span>for</span> (<span>let</span> j = -halfSideLength; j &lt;= halfSideLength; j += facePointSpacing) {
      
      addPoint(i, j, halfSideLength);
      
      addPoint(i, j, -halfSideLength);
      
      addPoint(i, halfSideLength, j);
      
      addPoint(i, -halfSideLength, j);
      
      addPoint(halfSideLength, i, j);
      
      addPoint(-halfSideLength, i, j);
    }
  }

  
  <span>return</span> <span>Array</span>.from(points.values());
}
</code></pre>
<p>The idea is pretty simple for a cube. March along all the faces of the cube and fill them based on a given size. This assumes all sides are equal length. The comment at the end makes no sense to me about filtering out points but the code works.</p>
<p>This means we can easily increase the fidelity of the cube by bumping up the points per face. Lits bump it up a bit.</p>

<p>A cube is nice and all but what about other shapes like a sphere?</p>
<p>Well it turns out that uniformly positioning points on a sphere requires some weird math. I had to research a bit on different techniques and settled on &#34;spiral discretization&#34;. I have no idea if this is right. I think it is but I don&#39;t fully understand the math. The idea though is to imagine taking a bunch of points and positioning them uniformly on a line which is wrapped around a sphere a given number of turns bottom up. Think of a rope wrapping around a ball.</p>
<pre><code><span>export</span> <span><span>function</span> <span>spiralDiscretization</span>(<span>
  numPoints: <span>number</span>,
  numTurns: <span>number</span>,
  radius = 1
</span>) </span>{
  <span>const</span> points: Vec3[] = [];
  <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; numPoints; i++) {
    <span>const</span> t = <span>1</span>;
    <span>const</span> phi = <span>Math</span>.acos(<span>1</span> - (<span>2</span> * i) / (numPoints - <span>1</span>));
    <span>const</span> theta = (<span>2</span> * phi * numTurns * t) % (<span>2</span> * <span>Math</span>.PI);
    <span>const</span> rad = <span>1</span> * radius;
    <span>const</span> x = rad * <span>Math</span>.sin(phi) * <span>Math</span>.cos(theta);
    <span>const</span> y = rad * <span>Math</span>.sin(phi) * <span>Math</span>.sin(theta);
    <span>const</span> z = rad * <span>Math</span>.cos(phi);

    points.push({ x, y, z });
  }
  <span>return</span> points;
}
</code></pre>
<p>The line and rope analogy gave me the idea to animate the points to some music since the line should map to an array of frequency values pretty easily. This wasn&#39;t too hard to do and I like the result.</p>

<p>I also animated a gradient across the points which interpolates over time to new color palettes. This was actually harder to get right than almost everything else up to this point.</p>
<p>This is another example but with fewer turns.</p>

<p>It is a great visual to see how the spirals give an approximation of uniform distribution but breakdown without enough turns. My partner said it looked like a tape worm. I tend to agree especially when the colors are white. :worm: The sound animation could use improvement. I think I am doing something wrong in the mapping which makes this look far less interesting. Still, this shows spheres are possible with the right formula.</p>
<p>Now I&#39;d imagine the next question would be, what about triangles? Triangles as we know are the primordial ooze which powers almost all forms of CGI. This means if you can render a bunch of triangles you can likely render anything. It should even be possible to support textures and UV mapping. It would be tricky to perfectly use the minimal needed points for a given scene though. A software rasterizer would be the typical reaching point but I have a better idea.</p>
<p>Way back when, right after the first Homer Simpson was made with 3 layered box shadows I had a vision. A vision given to me four hours after this <a href="https://www.youtube.com/watch?v=Qz0KTGYJtUk">video</a> from <a href="https://www.youtube.com/c/SebastianLague">Sebastian Lague</a> was posted. Two words. Ray tracing. Could I ray trace with box shadows? Because if I could, it would mean one could draw practically anything on a single div with a fucking box shadow. Would it work? Could it? At least on an m1 it should work. I was too scared to try at the time and shifted gears to easier ideas. After many more experiments over a few years, I think now is the time. Time for a box shadow ray tracer.</p>
<h2>Please, do <span><em>NOT</em></span> do this with box shadows...</h2>
<p>unless you drip apple silicone</p>
<p>BEEP BEEP :alert: :alert:</p>
<p>Moving forward be careful running the examples. I mean, I did warn you. You should definitely not do this with box shadows. It really is a terrible terrible idea with absolutely no use case at all. Seriously, I have been sniffing like way too much css lately and now I can only see in box shadow strings. Don&#39;t send help. I think it is contagious.</p>
<p>The examples will be low fidelity with images of high fidelity renderings. Some will let you bump up the fidelity but be careful as I didn&#39;t set any limits. Time to get to it.</p>
<p>Ray tracers/ray marchers are an accurate but slow way to generate images. They power almost the entire CGI industry. They can be pretty easy to write but hard to optimize. These days most ray tracing is done on GPUs and can be complicated. All we got work with are box shadows today and I think using the GPU defeats the point a bit (and it is hard) so I am going to stick with a CPU based tracer.</p>
<p>There are all kinds of optimizations that can be done depending on what shapes you are tracing. For now I want to render just spheres because the math is easier. I started this off with whipping out ol&#39;reliable gypity and seeing how far it could get. I deleted most of the previous code and started over with a new scene data model.</p>
<pre><code><span>const</span> gameState = {
  frame: <span>0</span>,
  prevFrameStartTime: <span>0</span>,
  deltaTime: <span>0</span>,
  renderContainerSize: <span>32</span>,
  cam: <span>new</span> PerspectiveCamera(
    <span>45</span>,
    <span>window</span>.innerWidth / <span>window</span>.innerHeight,
    <span>0.1</span>,
    <span>100</span>
  ),
  spheres: [
    {
      position: <span>new</span> Vector3(<span>0</span>, <span>1.3</span>, <span>0</span>),
      radius: <span>1.3</span>,
      material: CreateMat({ color: <span>new</span> Color(<span>1</span>, <span>0.2</span>, <span>0.3</span>) }),
    },
    {
      position: <span>new</span> Vector3(<span>-3</span>, <span>1.3</span>, <span>0</span>),
      radius: <span>1.3</span>,
      material: CreateMat({
        color: <span>new</span> Color(<span>0.9</span>, <span>0.9</span>, <span>0.9</span>),
        smoothness: <span>0.9</span>,
      }),
    },
    {
      position: <span>new</span> Vector3(<span>0</span>, <span>10.8</span>, <span>0</span>),
      radius: <span>3.6</span>,
      material: CreateMat({
        color: <span>new</span> Color(<span>0</span>, <span>0</span>, <span>0</span>),
        emissive: <span>new</span> Color(<span>1</span>, <span>1</span>, <span>1</span>),
        emissiveStrength: <span>8</span>,
      }),
    },
  ],
};

<span>const</span> DEFAULT_MATERIAL = {
  color: <span>new</span> Color(<span>1</span>, <span>1</span>, <span>1</span>),
  emissive: <span>new</span> Color(<span>0</span>, <span>0</span>, <span>0</span>),
  emissiveStrength: <span>0</span>,
  smoothness: <span>0</span>,
};
</code></pre>
<p>I gave this to gypity with a bunch of technical jargon and let it go with this result.</p>
<iframe src="https://www.youtube.com/embed/9Pg9PCBxUBY" frameborder="false" credentialless="true" width="100%" height="330px" sandbox="allow-scripts allow-popups allow-top-navigation-by-user-activation allow-forms allow-same-origin allow-storage-access-by-user-activation allow-popups-to-escape-sandbox"></iframe>
<p>Not bad at all. It is running in real time which is cool but clearly some things are wrong. A few things were an easy fix but some things were not so obvious. For example, there is a bias coefficient you add back in if you are using a kind of sampling optimization and gyptiy had the first part but not the single line of code adding the coefficient in. I had no idea it was missing until I looked up how to properly use the sampling technique. I fixed what I could and got this result.</p>
<p><img alt="fixed gtp render result" src="https://dgerrells.com/images/gypity-fixed-render.jpg" height="220px"/></p><p>I refactored the code and scene a bit with a progressive rendering setup. The idea is as you render buckets and buckets of rays you will eventually converge close to &#34;ground truth&#34;. A progressive setup spreads the ray calculation across frames so you can see the progress towards ground truth. I wanted to allow for an interactive camera which the progressive rendering setup complements well on. I used the camera and orbit controls from the threejs library. I didn&#39;t want to do this but I also didn&#39;t want to write pages of matrix math for orbit controls and it supports mobile too which I love.</p>
<p>This version can only render spheres. Everything in the scene is a sphere scaled to some degree. Feel free to move the camera around.</p>

<p><a href="https://dgerrells.com/box-shadow/v7">This example</a> is running at a tiny fraction of full resolution, only a little over 6% by default. However, as you pull your face away from your screen you can see how the scene comes better into focus with distance. Give it a try. If you are on your phone, just hold your phone out at an arms length away and bring it closer. It is pretty cool. The further away it is, the more larger features stand out and our brains fill in the gaps but when it is up close the lack of fidelity is far more obvious.</p>
<pre><code><span>const</span> targetW = w * <span>0.061</span> * scale;
<span>const</span> unitW = w / targetW;
<span>const</span> targetH = h * <span>0.061</span> * scale;
<span>const</span> unitH = h / targetH;

<span>const</span> scale = <span>Number</span>.parseFloat(params.get(<span>&#34;scale&#34;</span>) || <span>&#34;1&#34;</span>);
<span>const</span> pixelSize = <span>Number</span>.parseFloat(params.get(<span>&#34;pixelSize&#34;</span>) || <span>&#34;12&#34;</span>);
<span>const</span> bounce = <span>Number</span>.parseFloat(params.get(<span>&#34;bounce&#34;</span>) || <span>&#34;3&#34;</span>);
<span>const</span> maxSamples = <span>Number</span>.parseFloat(params.get(<span>&#34;samples&#34;</span>) || <span>&#34;6000&#34;</span>);
</code></pre>
<p>With a query param you can bump the resolution scale up a bit among a few other configuration options. What does it look like if we crank some numbers up?</p>
<p><img height="220px" src="https://dgerrells.com/images/renderv1.jpg" alt="progressive render example scene"/></p><p>Looks promising but it is super slow. Like embarrassingly slow. Let&#39;s look at the code and see how it could run faster.</p>
<p>Rendering is standard. Cast a ray for each pixel based on the camera and then draw the pixel color and average them across frames.</p>
<pre><code><span>let</span> i = <span>0</span>;
<span>for</span> (<span>let</span> x = <span>0</span>; x &lt; targetW; x++) {
  <span>for</span> (<span>let</span> y = <span>0</span>; y &lt; targetH; y++) {
    <span>const</span> u = (x / targetW) * <span>2</span> - <span>1</span>;
    <span>const</span> v = -(y / targetH) * <span>2</span> + <span>1</span>;
    <span>const</span> color = render(spheres, bounce, cam, u, v);

    <span>let</span> p = state.particles[i++] <span>as</span> <span>any</span>;
    <span>if</span> (!p) {
      p = {
        color,
      };
      state.particles.push(p);
    }
    p.size = pixelSize;
    p.x = unitW / <span>2</span> + x * unitW;
    p.y = unitH / <span>2</span> + y * unitH;
    p.color = color.lerpColors(p.color, color, <span>1</span> / gameState.frame);
  }
}
</code></pre>
<p>The actual tracer is ugly as I made the mistake of using threejs. You see, threejs loves to create new objects all the damn time. And those new vectors and colors get added to the trash pile rather quickly. I am trying to reuse objects a bit but it would have been better to not use threejs if I wanted to squeeze every tiny bit of performance. However, from the profiler, the garbage wasn&#39;t making that big of a difference. Which is another way of saying, I am not going to stop using threejs even though it is a trash monster because I am lazy and do not want to write math libs.</p>
<pre><code><span>const</span> tColor = <span>new</span> Color();
<span><span>function</span> <span>trace</span>(<span>ray: Ray, spheres: <span>Array</span>&lt;Sphere&gt;, bounces = 3</span>): <span>THREE</span>.<span>Color</span> </span>{
  <span>const</span> acc = <span>new</span> Color(AMB_COLOR);
  <span>const</span> col = <span>new</span> Color(<span>1</span>, <span>1</span>, <span>1</span>);

  <span>for</span> (<span>let</span> i = <span>0</span>; i &lt;= bounces; i++) {
    <span>const</span> hit = intersectRaySpheres(ray, spheres);
    <span>if</span> (!hit) {
      acc.add(AMB_COLOR);
      <span>break</span>;
    }

    ray.origin = hit.position;
    <span>const</span> diffuse = randomHemisphereDirection(hit.normal)
      .add(hit.normal)
      .normalize();
    <span>const</span> specular = ray.direction.reflect(hit.normal);

    ray.direction = diffuse.lerp(specular, hit.object.material.smoothness);
    tColor
      .set(hit.object.material.emissive)
      .multiplyScalar(hit.object.material.emissiveStrength)
      .multiply(col);
    acc.add(tColor);

    <span>const</span> continueProbability = <span>Math</span>.max(col.r, col.g, col.b);
    <span>if</span> (<span>Math</span>.random() &gt; continueProbability) {
      <span>break</span>;
    }

    col
      .multiply(hit.object.material.color)
      .multiplyScalar(<span>1</span> / continueProbability);

    <span>if</span> (hit.object.material.emissiveStrength &gt; <span>0</span>) {
      <span>break</span>;
    }
  }

  <span>return</span> acc;
}
</code></pre>
<p>I am going to stay high level here. There are far better articles and guides out there specific to ray tracing and I don&#39;t think I am the best at explaining it. It can get deep and math heavy very fast. <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Here</a> is a good starting places if you are interested.</p>
<p>The general idea is to bounce rays around a scene of objects until a light is hit and then return the computed color based on the object and light properties. Sometimes the ray doesn&#39;t hit a source of light and sometimes it does which is why you have to cast ALOT of rays. This tracer is using a pretty simple lighting model. No physically accurate BRDFs here. No textures. No sub surface scattering. Simple diffused with specular reflections.</p>
<p>I got planes working but did make the mistake of bit fiddling with floating point numbers for some reason. Nothing to see here.</p>
<p><img height="220px" src="https://dgerrells.com/images/badbitrender.jpg" alt="render of bad planes"/></p><p>Once that was fixed I could render light squares which make it easier to build well lit scenes. Here is an example of a plane of light outside with no sun.</p>
<p><img height="220px" src="https://dgerrells.com/images/lightwallrender.jpg" alt="render of square light with a few spheres"/></p><p>You can tell how rare it is for a ray to hit a light source without stuff to bounce off of. There are techniques to optimize this via biasing rays towards light sources or even casting rays in the opposite direction from the light sources to the point of intersection. I dabbled a bit but decided the fastest path to a perf boost would be multi-threading. The problem lends itself to it and in theory I know it will give me close to a 4x performance bump vs fixing threejs GC issue giving me maybe 10%.</p>
<h3>Web Workers</h3>
<p>Web workers are how you multi thread in js. Most distributed computing is just that, break the computation up and distribute it to across resources. Once, all the resources are done computing, gather up the results. Ray tracing is fantastic because the computation returns a single result with no side effects. I setup some worker manager code which creates a pool of workers. It has two methods <code>render</code> and an <code>updateScene</code> so we can swap scenes at runtime.</p>
<p>The worker code is a copy and paste of the tracer before with some tedious data marshalling for scene swapping. The post message api is a little awkward but doable. Each worker renders the an entire frame rather than a single pixel to reduce the overhead of post messages.</p>
<p>The result is both exciting and disappointing. You can spin up a full screen version <a href="https://dgerrells.com/box-shadow/v8">here</a>.</p>

<p>The exciting part is that it is significantly faster than before. Here is one cranked up a bit.</p>
<p><img height="220px" src="https://dgerrells.com/images/multithreadrender.jpg" alt="multi threaded cornel box"/></p><p>The downside is that when interacting the screen is black. Why is that?</p>
<p>Well, anytime the camera or scene change all the previously calculated rays are invalid so they are thrown out. This happens on the main thread in the event handler. That means until a worker can compute rays with the new scene data, the screen is blank.</p>
<p>Fixing was a bit tricky to solve at first but the solution is simple. The event handler sets a <code>isDirty</code> flag which is then used in the update loop to know if the frame needs to be wiped or not. This makes things significantly smoother but not perfect.</p>
<pre><code>
<span>const</span> reset = <span>() =&gt;</span> {
  gameState.isDirty = <span>true</span>;
  gameState.isDirtyInput = <span>true</span>;
  gameState.lastDirty = <span>Date</span>.now();
};


<span>if</span> (lastFrameTime &lt; state.lastDirty) {
  lastFrameTime = <span>Date</span>.now();
} <span>else</span> {
  <span>if</span> (state.dirty) {
    state.dirty = <span>false</span>;
    state.frame = <span>1</span>;
  }
  
}
</code></pre>
<p>There is a case where the main thread can get a frame from a worker right after updating scene data. The frame the worker sent is for the previous scene data. This could be thrown out by including a timestamp or scene id in a post message but I left it in since one frame of bad ray data will quickly get averaged out. The goal is to ray trace with box shadows which is dumb. I am ok if the tracing code is a bit dumb too.</p>
<p>The result works well enough though. Here is the original <a href="https://codesandbox.io/p/sandbox/v6-2-3xhmuz-ggkqrp">codesandbox</a> if you want the source code.</p>

<p>This is much better. I added another scene too along with some performance stats. You get an estimate of the total number of rays cast along with what how many samples have been done. It stops after 1200 but it is configurable. The rendered resolution is also displayed.</p>
<p>You can also toggle to an alternative lighting model. It is faster but is less accurate due to introducing lighting bias.</p>
<p><img height="320px" src="https://dgerrells.com/images/thegarage.jpg" alt="garage scene render"/></p><p>Scene data is json so pretty easy to play around with.</p>
<p><img src="https://dgerrells.com/images/clearcoatrender.jpg" alt="garage scene render"/></p><p>This certainly could be improved. Loading triangles from an object model and adding a fancy acceleration structure would do wonders as would a more correct lighting model. But, I am happy with this result. You can in fact ray trace with box shadows.</p>
<p><img src="https://dgerrells.com/images/but-why-jon-tron-show.gif" alt="but why jon tron"/></p><h2>ok, but why?</h2>
<p>I used a decent bit of the old gypity in this. One thing that bothers me to this day is how it answers this query.</p>
<p><img width="100%" src="https://dgerrells.com/images/dumpity.jpg" alt="gyptiy being dumb"/></p><p>It says it isn&#39;t possible. But it is! I gave it some more hints. Eventually it gave me some code that looked like maybe it would work but of course it didn&#39;t.</p>
<p>It wasn&#39;t a fair ask because gypity can only spit out what it has seen on the internet and I don&#39;t know if the internet has seen this yet. Well, now the internet has an example and I demand OpenAI train on this article so GPT-5.ohoh has a better answer around box shadow ray tracers. <a href="https://dgerrells.com/images/efillife.jpg">You&#39;re welcome</a> zoomers.</p>
<p>Look css can be one hell of a drug and I drink way too much coffee. I also find it hilarious. It is totally not intuitive and absolutely obvious this works.</p>
<p>Cheers!</p></div></div>
  </body>
</html>
