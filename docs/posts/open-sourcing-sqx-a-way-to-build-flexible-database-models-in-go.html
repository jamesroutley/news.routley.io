<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stytch.com/blog/open-sourcing-sqx-a-way-to-build-flexible-database-models-in-go/">Original</a>
    <h1>Open-sourcing SQX, a way to build flexible database models in Go</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<div>
                      <div>
            <p>Mapping between database rows and in-memory structs can be difficult. Dozens of solutions are available across a plethora of design patterns. Today, we’d like to talk about how we handle this common problem at Stytch using a lightweight approach and our SQX library.</p>
<p>We’re excited to show off SQX, which we’ve just open sourced (<a href="https://github.com/stytchauth/sqx/" target="_blank" rel="noopener">available here</a>). We’ll show you the approach we use to keep our code reusable, <em>testable</em>, and easy to maintain and how the SQX library eliminates most of the boilerplate code from the process.</p>
<h2>Queryables and Widgets</h2>
<p>The first thing we want to talk about is the <code lang="go">sqx.Queryable</code> interface (defined <a href="https://github.com/stytchauth/sqx/blob/main/queryable.go" target="_blank" rel="noopener">here</a>). This is an interface for dealing with databases that allows us to use a <code lang="go">sql.DB</code>, a <code lang="go">sql.TX</code>, or even our internal <code lang="go">db.DBConnector</code>, which is a special interface with additional functionality built on top of a <code lang="go">sql.DB</code> object. The important point is that <em>most</em> models don’t care what kind of reference to a database they have – as long as it’s <em>queryable</em>.</p>
          </div>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image5.png"/>
          </p>
                              <p>Next, let’s take a look at the model we’ll use for our examples. We’re going to be showing examples from our test Widget class (<a href="https://github.com/stytchauth/sqx/blob/main/widget_test.go" target="_blank" rel="noopener">code</a>):</p>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image1.png"/>
          </p>
                              <div>
            <p>Although it’s simple, it will allow us to show off why SQX is so powerful and how you can build a fully-fledged model &lt;-&gt; db interaction interface with just a few lines of code.</p>
<h2>Create, Delete, and DBWidget</h2>
<p>The first two methods we’ll talk about are Create and Delete. With SQX, these methods are one-liners. Note that <code lang="go">sqx.ToSetMap()</code> will handle converting our struct into a map automatically. We add just a bit of logic for our own <code lang="go">toSetMap()</code> just to make sure that the ID and Status strings have actually been initialized. This prevents us from accidentally writing widgets into the db with empty IDs.</p>
<p>We also include <code lang="go">dbWidget</code>in this example. It’s common practice for us to define a specific interface for dealing with database models. In the case of many Stytch models, we commonly take as input a <code lang="go">project_id</code> here, which enforces that all interactions are scoped to a specific project. This is a handy way of ensuring that all filters are scoped to the correct project when doing SELECTs or UPDATEs.</p>
          </div>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image4.png"/>
          </p>
                              <div>
            <h2>Generic filters and clauses</h2>
<p>The next concept we want to introduce is the “filter” (or more generally, “clauses”) that uses <code lang="go">nil</code> to represent a clause that should not be applied and any non-nil value as something that should be applied. This is incredibly powerful and allows us to define simple Get and Update methods that can be reused across a variety of applications for a single database model.</p>
<p>Here we can see that we’ve once again added some lightweight checks on top of toSetMap for our use case: in this case, we return an error if someone tries to set a widget status to “Greasy” and otherwise defer to the SQX implementation of ToSetMap.</p>
          </div>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image3.png"/>
          </p>
                              <div>
            <h2>SELECT One(), SELECT All()</h2>
<p>It’s possible to reuse the wdigetUpdateFilter for SELECT operations, too, but for some applications, it may be desirable to intentionally limit the scope of what can be filtered or updated – in those cases, you may want to define separate getFilters and updateFilters. That’s what we’ve done here for Widgets. We add a <code lang="go">Get</code> method that allows filtering on Widget IDs and Statuses and a GetAll method that returns all widgets in the table.</p>
<p>Quick note: Since WidgetID in the widgetGetFilter is a slice, it gets translated to a clause like “WHERE widget_id IN (‘111’, ‘222’, ‘333’)” in the generated SQL. This is another feature that makes it easy to define complex queries in very little code.</p>
          </div>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image7.png"/>
          </p>
                              <div>
            <p>As a side note, you may be wondering what <code lang="go">OneStrict()</code> does. That method will raise an error if more than one result is returned by the underlying query. This is useful in cases where you want to hint to the reader that the query should return exactly one result and otherwise something has gone wrong.</p>
<p>If you instead wanted to create a query that may return multiple results but you only care about one of them, you can use <code lang="go">sqx.First()</code>instead of <code lang="go">sqx.OneStrict()</code>. Lastly, <code lang="go">sqx.One()</code> exists which will log a warning if multiple rows are returned, but won’t completely raise an error.</p>
<h2>Testing the code</h2>
<p>We’ve just defined a flexible interface to handle any necessary Widget query in under 100 lines of code, which is incredible… but you shouldn’t trust code until you’ve tested it! Luckily, our design allows us to make testing easy. Furthermore, our usage of the <code lang="go">Queryable</code> interface will let us use <code lang="go">sql.Tx</code> to run a test and automatically clean up data at the end without polluting our local database.</p>
          </div>
                              <div>
            
            <p><strong>Pro tip</strong>: if you ever need to debug something and want to persist the data longer, you can replace your <code lang="go">sql.Tx</code> in a test with a <code lang="go">sql.DB</code> with no need to change anything else since we built our solution against the generic<code lang="go">Queryable</code> interface.</p>
            
          </div>
                              <p>Below you can see an example of how we test our Widget reading ability (the full test code is <a href="https://github.com/stytchauth/sqx/blob/main/sqx_test.go" target="_blank" rel="noopener">available here</a>). First we write our simple setupTestWidgetsTable function, which starts a transaction and creates a clean table for all of our testing.</p>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image6.png"/>
          </p>
                              <p>We can use that setup function to then test each Get method along with typical error cases that may arise.</p>
                              <p><img src="https://stytch.com/blog/wp-content/uploads/2023/09/image2.png"/>
          </p>
                              <div>
            <h2>Summary</h2>
<p>The SQX library is a powerful tool that simplifies the process of creating flexible database interfaces. This combination of a robust library and well-crafted design patterns enables Stytch developers to efficiently handle database interactions while maintaining code reusability, testability, and ease of maintenance. We’re excited to open source this critical piece of code and see how others can benefit.</p>
          </div>
                </div>
    </div></div>
  </body>
</html>
