<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreasjhkarlsson.github.io//jekyll/update/2023/12/27/4-billion-if-statements.html">Original</a>
    <h1>4 billion if statements (2023)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>I recently stumbled upon this screenshot while researching social media on the train. Of course, it was followed by a cascade of spiteful comments, criticizing this fresh programmer’s attempt to solve a classical problem in computer science. The modulus operation.</p>

<p><img src="https://andreasjhkarlsson.github.io/assets/images/GCPVDa1WYAAoBut.jpg" alt="TikTok screenshot" width="250"/></p>

<p>Now, in a world where AI is replacing programmers by the minute, taking their jobs and revolutionizing the way we think about code, maybe we should be more open to the thoughts of the fresh new blood of the industry? In fact, the above code is a perfect example of a time-memory tradeoff. You’re trading off your time and at the same time, the computers memory and time as well! Truly a marvelous algorithm!</p>

<p>So I went to work to explore this idea of checking if a number is odd or even by only using comparisons to see how well it works in a real world scenario. Since I’m a great believer in performant code I decided to implement this in the C programming language as it’s by far the fastest language on the planet to this day (thanks to the visionary genius Dennis Richie).</p>

<p>So I started composing</p>

<figure><pre><code data-lang="c"><span>/* Copyright 2023. All unauthorized distribution of this source code 
   will be persecuted to the fullest extent of the law*/</span>
<span>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
</span><span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span><span>*</span> <span>argv</span><span>[])</span>
<span>{</span>
    <span>uint8_t</span> <span>number</span> <span>=</span> <span>atoi</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>]);</span> <span>// No problems here</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>0</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>1</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;odd</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>2</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>3</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;odd</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>4</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>5</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;odd</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>6</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>7</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;odd</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>8</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>9</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;odd</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>if</span> <span>(</span><span>number</span> <span>==</span> <span>10</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span></code></pre></figure>

<p>Beautiful! Lets compile the code, disabling optimizations with /Od to make sure that the pesky compiler doesn’t interfere with our algorithm. After compiling we can do a quick test of the program we get some positive results:</p>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span> </span><span>cl.exe</span><span> </span><span>/Od</span><span> </span><span>program.c</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>0</span><span> 
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>4</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>3</span><span>
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>7</span><span>
</span><span>odd</span></code></pre></figure>

<p>However, after doing some further testing I found some problems:</p>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>50</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>11</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>99</span></code></pre></figure>

<p>No output! It seems that the program only works for numbers under 11! Going back to the code we can find the issue right after the last if statement, we need more if statements!</p>

<p>Now, this is a time-memory tradeoff, but my time on this earth is limited so I decided to meta-program the if statements using a programmer program in a different programming language. To compensate for this cheating I decided to use the slowest language on the planet, Python (thanks to the visionary genius of Ross van der Gussom).</p>

<figure><pre><code data-lang="python"><span>print</span><span>(</span><span>&#34;/* Copyright 2023. All unauthorized distribution of this source code&#34;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;   will be persecuted to the fullest extent of the law*/&#34;</span><span>)</span>

<span>print</span><span>(</span><span>&#34;#include &lt;stdio.h&gt;&#34;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;#include &lt;stdint.h&gt;&#34;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;#include &lt;stdlib.h&gt;&#34;</span><span>)</span>

<span>print</span><span>(</span><span>&#34;int main(int argc, char* argv[])&#34;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;{&#34;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;    uint8_t number = atoi(argv[1]); // No problems here&#34;</span><span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>**</span><span>8</span><span>):</span>
    <span>print</span><span>(</span><span>&#34;    if (number == &#34;</span><span>+</span><span>str</span><span>(</span><span>i</span><span>)</span><span>+</span><span>&#34;)&#34;</span><span>)</span>
    <span>if</span> <span>i</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>:</span>
        <span>print</span><span>(</span><span>&#34;        printf(</span><span>\&#34;</span><span>even</span><span>\\</span><span>n</span><span>\&#34;</span><span>);&#34;</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>&#34;        printf(</span><span>\&#34;</span><span>odd</span><span>\\</span><span>n</span><span>\&#34;</span><span>);&#34;</span><span>)</span>

<span>print</span><span>(</span><span>&#34;}&#34;</span><span>)</span></code></pre></figure>

<p>Nice! Now we can generate a program that solves the even-odd problem for all 8-bit integers!</p>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span> </span><span>python</span><span> </span><span>programmer.py</span><span> </span><span>&gt;</span><span> </span><span>program.c</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>cl.exe</span><span> </span><span>/Od</span><span> </span><span>program.c</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>99</span><span>
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>50</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>240</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>241</span><span>
</span><span>odd</span></code></pre></figure>

<p>Would you look at that! It works flawlessly! Now, let’s scale it up to 16 bit!</p>

<figure><pre><code data-lang="python"><span>print</span><span>(</span><span>&#34;    uint16_t number = atoi(argv[1]); // No problems here&#34;</span><span>)</span>
<span>…</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>**</span><span>16</span><span>):</span></code></pre></figure>

<p>This gives a nice and thick c file of around 130k lines. Nothing really when looking back at some of the code bases I’ve worked on over the years. Let’s compile!</p>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span> </span><span>python</span><span> </span><span>programmer.py</span><span> </span><span>&gt;</span><span> </span><span>program.c</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>cl.exe</span><span> </span><span>/Od</span><span> </span><span>program.c</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>21000</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>3475</span><span> 
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>3</span><span>   
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>65001</span><span>
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span> </span><span>.</span><span>\program.exe</span><span> </span><span>65532</span><span>
</span><span>even</span></code></pre></figure>

<p>Beautiful! Our algorithm seems to scale with the data! The executable is around 2 MB, but that’s no match for my beefy gaming rig with a whopping 31.8 GB of memory.</p>

<p>Now, 16 bit is a very cool bitwidth, but as we all know, 32 bit is the holy grail of computing and is the final bitwidth that we need to solve all practical engineering and scientific problems. After all, IPv4 is still standing stronger than ever, 60 years after it was deemed deprecated due to so called <a href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion">“address exhaustion”</a>.</p>

<p>So without further ado, lets scale to our final size. 32 bit is only 65536 times as many numbers as 16 bit, what could go wrong?</p>

<figure><pre><code data-lang="python"><span>print</span><span>(</span><span>&#34;    uint32_t number = atoi(argv[1]); // No problems here&#34;</span><span>)</span>
<span>…</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>**</span><span>32</span><span>):</span></code></pre></figure>

<p>So I let the mighty snake do its work and after getting a cup of coffee and getting back to check on the program 48 hours later I was left with a beautiful c file, almost 330 GB in size! Almost certainly among the largest c files in history. My fingers were trembling when I entered the next command, surely MSVC had never before encountered such powerful source code. After abusing the pagefile of my poor, powerful computer for half an hour the following was spat out:</p>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span> </span><span>cl</span><span> </span><span>/Od</span><span> </span><span>program.c</span><span>
</span><span>Microsoft</span><span> </span><span>(</span><span>R</span><span>)</span><span> </span><span>C/C</span><span>++</span><span> </span><span>Optimizing</span><span> </span><span>Compiler</span><span> </span><span>Version</span><span> </span><span>19.32.31329</span><span> </span><span>for</span><span> </span><span>x64</span><span>
</span><span>Copyright</span><span> </span><span>(</span><span>C</span><span>)</span><span> </span><span>Microsoft</span><span> </span><span>Corporation.</span><span>  </span><span>All</span><span> </span><span>rights</span><span> </span><span>reserved.</span><span>

</span><span>program.c</span><span>
</span><span>program.c</span><span>(</span><span>134397076</span><span>):</span><span> </span><span>warning</span><span> </span><span>C4049:</span><span> </span><span>compiler</span><span> </span><span>limit:</span><span> </span><span>terminating</span><span> </span><span>line</span><span> </span><span>number</span><span> </span><span>emission</span><span>
</span><span>program.c</span><span>(</span><span>134397076</span><span>):</span><span> </span><span>note:</span><span> </span><span>Compiler</span><span> </span><span>limit</span><span> </span><span>for</span><span> </span><span>line</span><span> </span><span>number</span><span> </span><span>is</span><span> </span><span>16777215</span><span>
</span><span>program.c</span><span>(</span><span>41133672</span><span>):</span><span> </span><span>fatal</span><span> </span><span>error</span><span> </span><span>C1060:</span><span> </span><span>compiler</span><span> </span><span>is</span><span> </span><span>out</span><span> </span><span>of</span><span> </span><span>heap</span><span> </span><span>space</span></code></pre></figure>

<p>Pathetic!</p>

<p>And not only did the compiler fail us, but when looking into the limits of the Portable Executable format (.exe) for windows, I discovered that it cannot handle more than a <a href="https://stackoverflow.com/questions/6976693/what-is-the-maximum-size-of-a-pe-file-on-64-bit-windows">measly 4 GB</a>! With more than 4 billion comparisons needed to be encoded into the executable, this is a major obstacle for implementing our algorithm. Even if each comparison would use less than a single byte we would still be too heavy.</p>

<p>However, bad compilers and file formats should not stop us from achieving our dream. After all, all what a compiler does is writing some fancy machine code into a file and the file format is just some structure telling the OS how to put the binary code into memory. Really, we can do that ourselves.</p>

<p>Let’s start by writing an IsEven function in <a href="https://en.wikipedia.org/wiki/X86_assembly_language">x86-64 assembly</a> as it’s the native language of my Intel powered machine. It looks something like this:</p>

<figure><pre><code data-lang="assembly">; Argument is stored in ECX, return value in EAX
XOR EAX, EAX ; Set eax to zero (return value for odd number)
CMP ECX, 0h ; Compare arg to 0 
JNE 3h ; Skip next two instructions if it wasn&#39;t equal
INC EAX ; It was even, set even return value (1)
RET ; Return
CMP ECX, 1h ; Compare arg to 1
JNE 2 ; Skip next instruction if not equal
RET ; Odd return value already in EAX, just RET
; add the next 2...2^32-1 comparisons here
RET ; Fallback return</code></pre></figure>

<p>Not really correct asm, but it doesn’t matter much, because we’re gonna compile it into machine code manually.</p>

<p>How did I do this? Well I jumped online, using a mix of my early life experience coding emulators and hacking and looked into the x86(-64) architecture manuals to figure out the correct opcodes and format for each instruction.</p>

<p>… Just kidding, that’s horrible. I asked ChatGPT what the correct <a href="https://en.wikipedia.org/wiki/Opcode">opcode</a> was for each instruction and lucky for us it didn’t hallucinate any new extensions to x86-64.</p>

<p>So now we just write a “compiler” to output this code. Note that we will write the opcodes we got from the AI for the instructions directly. Here’s how it looks in our friend python:</p>

<figure><pre><code data-lang="python"><span>import</span> <span>struct</span>

<span>with</span> <span>open</span><span>(</span><span>&#39;isEven.bin&#39;</span><span>,</span> <span>&#39;wb&#39;</span><span>)</span> <span>as</span> <span>file</span><span>:</span>
   
    <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\x31\xC0</span><span>&#34;</span><span>)</span>                     <span># XOR EAX, EAX
</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>**</span><span>32</span><span>):</span>
        <span>ib</span> <span>=</span> <span>struct</span><span>.</span><span>pack</span><span>(</span><span>&#34;&lt;I&#34;</span><span>,</span> <span>i</span><span>)</span>               <span># Encode i as 32 bit little endian integer
</span>
        <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\x81\xF9</span><span>&#34;</span> <span>+</span> <span>ib</span><span>)</span>            <span># CMP ECX, i
</span>
        <span>if</span> <span>i</span><span>%</span><span>2</span> <span>==</span> <span>0</span><span>:</span>
            <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\x75\x03</span><span>&#34;</span><span>)</span>             <span># JNE +3
</span>            <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\xFF\xC0</span><span>&#34;</span><span>)</span>             <span># INC EAX
</span>            <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\xC3</span><span>&#34;</span><span>)</span>                 <span># RET
</span>        <span>else</span><span>:</span>
            <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\x75\x01</span><span>&#34;</span><span>)</span>             <span># JNE +1
</span>            <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\xC3</span><span>&#34;</span><span>)</span>                 <span># RET
</span>
    <span>file</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;</span><span>\xC3</span><span>&#34;</span><span>)</span>                         <span># Fallback RET</span></code></pre></figure>

<p>While we somewhat deviated from the original vision of the TikTok post, the essence remains the same. We create a long, long, long list of if-statements to determine if any number is even or odd, ignoring any arithmetic operation that would help out.</p>

<p>Running this gives us a nice 40 GB file which contains all 4.2 billion comparisons needed to determine if any 32 bit number is even or odd! Now we just need to write our host program that can load and use these instructions. For added performance (it is very important), I decided to map the file into the address space instead of reading all of it. By doing this, we can just pretend that the entire file is already in memory and let the poor OS deal with fitting a 40 GB blob into virtual memory. After mapping the file with READ and EXECUTE permissions we can call into the code by using a function pointer. It looks like this:</p>

<figure><pre><code data-lang="c"><span>#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;stdint.h&gt;
</span>
<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span><span>*</span> <span>argv</span><span>[])</span>
<span>{</span>
    <span>uint32_t</span> <span>number</span> <span>=</span> <span>atoi</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>]);</span> <span>// No problems here</span>

    <span>// Open code file</span>
    <span>HANDLE</span> <span>binFile</span> <span>=</span> <span>CreateFileA</span><span>(</span>
                        <span>&#34;isEven.bin&#34;</span><span>,</span>
                        <span>GENERIC_READ</span> <span>|</span> <span>GENERIC_EXECUTE</span><span>,</span> <span>FILE_SHARE_READ</span><span>,</span>
                        <span>NULL</span><span>,</span>
                        <span>OPEN_EXISTING</span><span>,</span>
                        <span>FILE_ATTRIBUTE_NORMAL</span><span>,</span>
                        <span>NULL</span><span>);</span>
   
    <span>// Get 64 bit size of file</span>
    <span>LARGE_INTEGER</span> <span>codeSize</span><span>;</span>
    <span>GetFileSizeEx</span><span>(</span><span>binFile</span><span>,</span> <span>&amp;</span><span>codeSize</span><span>);</span>

    <span>// Create memory map of the file</span>
    <span>HANDLE</span> <span>mapping</span> <span>=</span> <span>CreateFileMapping</span><span>(</span>
                        <span>binFile</span><span>,</span>
                        <span>NULL</span><span>,</span>
                        <span>PAGE_EXECUTE_READ</span><span>,</span>
                        <span>0</span><span>,</span>
                        <span>0</span><span>,</span>
                        <span>NULL</span><span>);</span>

    <span>// Get a pointer to the code</span>
    <span>LPVOID</span> <span>code</span> <span>=</span> <span>MapViewOfFile</span><span>(</span>
                    <span>mapping</span><span>,</span><span>FILE_MAP_EXECUTE</span> <span>|</span> <span>FILE_MAP_READ</span><span>,</span>
                    <span>0</span><span>,</span>
                    <span>0</span><span>,</span>
                    <span>codeSize</span><span>.</span><span>QuadPart</span><span>);</span>

    <span>// Create a function that points to the code</span>
    <span>int</span> <span>(</span><span>*</span><span>isEven</span><span>)(</span><span>int</span><span>)</span> <span>=</span> <span>(</span><span>int</span><span>(</span><span>*</span><span>)(</span><span>int</span><span>))</span><span>code</span><span>;</span>

    <span>if</span> <span>(</span><span>isEven</span><span>(</span><span>number</span><span>))</span>
        <span>printf</span><span>(</span><span>&#34;even</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>else</span>
        <span>printf</span><span>(</span><span>&#34;odd</span><span>\n</span><span>&#34;</span><span>);</span>

    <span>CloseHandle</span><span>(</span><span>binFile</span><span>);</span>
<span>}</span></code></pre></figure>

<p>And there we go! We now have everything to check if any 32 bit number is even or odd. Let’s take it for a spin:</p>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>300</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>0</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>1000000</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>100000007</span><span>
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>400000000</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>400000001</span><span>
</span><span>odd</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>400000006</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>4200000000</span><span>
</span><span>odd</span><span> </span><span>&lt;</span><span>----</span><span> </span><span>WRONG</span><span>!</span></code></pre></figure>

<p>Almost! Seems like the algorithm has some issues with signedness, any value over 2^31 seems to give random results. Sad!</p>

<p>Let’s fix the final bug.</p>

<p>It turns out that atoi cannot deal with unsigned pureness, so it failed to parse our big boy numbers. Replacing it with strtoul fixes everything.</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>number</span> <span>=</span> <span>strtoul</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>NULL</span><span>,</span> <span>10</span><span>);</span><span>// No problems here</span></code></pre></figure>

<figure><pre><code data-lang="powershell"><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>4200000000</span><span>
</span><span>even</span><span>
</span><span>PS</span><span> </span><span>&gt;</span><span>.</span><span>\program.exe</span><span> </span><span>4200000001</span><span>
</span><span>odd</span></code></pre></figure>

<p>As a side note, the program is amazingly performant. For small numbers the results are instantaneous and for the large number close to the 2^32 limit the result is still returned in around 10 seconds. Considering the computer has to read 40 GB of data from disk, map it to physical memory and then let the CPU has a rip of it without many chances of caching is honestly quite mind blowing. For reference, the computer is a Core i5 12600K with 32 GB memory and the files are residing on a M.2 SSD disk. While calculating, the peak read speed I saw from the SSD was around 800 MB/s (which doesn’t really make sense as that should give execution speeds at 40+ seconds, but computers are magical so who knows what is going on).</p>

<p>And there we have it! The Internet proven wrong once again, not only can you actually write a fully functioning and performant program in the manner of the TikTok post, but it’s also very fun.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
