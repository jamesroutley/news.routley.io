<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maplant.com/2024-12-13-Scheme-to-the-Spec-Part-I:-Concurrent-Cycle-Collection.html">Original</a>
    <h1>Garbage collected smart pointers in Rust via concurrent cycle collection</h1>
    
    <div id="readability-page-1" class="page">
    
    
    
by Matthew Plant

<p>Scheme to the Spec is a series on the more complex, often overlooked aspects of programming language
implementation.</p>
<p>In this series we will dive deep into my work-in-progress implementation of R6RS scheme, <a href="https://www.github.com/maplant/scheme-rs">scheme-rs</a>,
an implementation designed to integrate seamlessly with the async-rust ecosystem.</p>
<p>Our first article discusses how to implement Garbage-Collected smart pointers that we can use both within the interpreter
and the interfacing Rust code. In later articles we will discuss topics such as tail call optimizations, implementing continuations,
and syntax transformers. Our final article will be implementing <a href="https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/OnStackReplacement/">on-stack replacement</a> with LLVM.</p>
<h2>Part I: Garbage Collected Smart Pointers via Concurrent Cycle Collection</h2>
<p>Ten years ago I wrote an article on how to implement a conservative garbage collector for C, and I got a lot of constructive
criticism regarding the actual usefulness of the code presented. It only makes sense that on the ten-year anniversary of
publishing I should try to fix my error by writing a garbage collector that is precise, does not make assumptions, and (hopefully)
actually works.</p>

<ol>
<li><a href="#the-gc-smart-pointer">The <code>Gc&lt;T&gt;</code> smart pointer</a>
<ol>
<li><a href="#scaffolding-and-allocation">Scaffolding and allocation</a>
<ol>
<li><a href="#variance">Variance</a></li>
<li><a href="#drop-checking">Drop checking</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#thread-safe-interior-mutability">Thread-safe interior mutability</a>
<ol>
<li><a href="#semaphores">Semaphores</a></li>
<li><a href="#read-write-guards">Read/write guards</a></li>
</ol>
</li>
<li><a href="#garbage-collection">Garbage collection</a>
<ol>
<li><a href="#cycles">Cycles</a></li>
<li><a href="#synchronous-cycle-collection">Synchronous cycle collection</a></li>
<li><a href="#the-trace-trait-and-derive-macro">The Trace trait and derive macro</a></li>
<li><a href="#deallocation">Deallocation</a></li>
<li><a href="#extending-from-synchronous-to-concurrent">Extending from synchronous to concurrent</a>
<ol>
<li><a href="#the-mutation-buffer">The mutation buffer</a></li>
<li><a href="#the-cyclical-reference-count">The Cyclical Reference Count</a></li>
<li><a href="#the-safety-phase">The safety phase</a>
<ol>
<li><a href="#sigma-test">Σ-test</a></li>
<li><a href="#delta-test">Δ-test</a></li>
</ol>
</li>
<li><a href="#cleaning-up">Cleaning up</a></li>
<li><a href="#misc-helper-functions">Misc helper functions</a></li>
</ol>
</li>
<li><a href="#bringing-it-all-together">Bringing it all together</a></li>
</ol>
</li>
<li><a href="#testing">Testing</a></li>
<li><a href="#footnotes">Footnotes</a></li>
</ol>
<h2>1. The <code>Gc&lt;T&gt;</code> smart pointer <a name="the-gc-smart-pointer"></a></h2>
<p>Before we can start writing code, we have to figure out what goals we want to accomplish. More specifically, what do we want our
<code>Gc&lt;T&gt;</code> type to <em>do</em>? How does it <em>behave</em>? What kind of <em>data can it contain</em>?</p>
<p>I want the <code>Gc&lt;T&gt;</code> type to work as follows:</p>
<ul>
<li>The API for the <code>Gc&lt;T&gt;</code> should behave similarly to a <code>Arc&lt;tokio::sync::RwLock&lt;T&gt;&gt;</code>; that is, it should support interior mutability
through a read/write lock and it should be clonable and sendable across threads.</li>
<li><code>T</code> is allowed to be <em>any</em> data type that satisfies <code>&#39;static + Send + Sync</code>. This includes <code>Arc</code>.</li>
<li>When <code>Gc&lt;T&gt;</code> no longer has any references to it reachable from the stack, then we should clean it up properly, <em>including any cycles</em>.</li>
</ul>
<p>Why a <code>RwLock</code> and not a <code>Mutex</code>? <code>RwLocks</code> are not always ideal as a lock, so we need a particularly good justification for
choosing them. Since read and write locks are given access in a FIFO queue and neither has a higher priority than the other, acquiring
a write lock can take a disproportionate amount of time. But, let’s consider the language we are implementing: a functional language
with relatively few concurrent writes.</p>
<p>In Scheme, writes occur most often when adding a variable to a lexical environment, and by and large that happens synchronously. For
example, in the following snippet</p>
<pre><span>(</span><span>define</span> <span>pi</span> 3.1415<span>)</span>
<span>(</span><span>define</span> <span>e</span>  2.7182<span>)</span>
</pre>
<p>write locks are acquired on the environment sequentially, and thus the process does not need to wait.</p>
<p><code>RwLocks</code> would be a poor choice for Scheme code with multiple threads all reading and writing to a global variable. This pattern is
just not very common in functional programming where message passing is vastly preferred.</p>
<p>Now that we have an idea as to how our smart pointer should behave, we can begin our implementation.</p>
<h3>1.1. Scaffolding and allocation <a name="scaffolding-and-allocation"></a></h3>
<p>Our Gc type will be composed of three separate types:</p>
<ul>
<li><code>Gc&lt;T&gt;</code>: User-facing type, contains a pointer to our heap allocated memory.</li>
<li><code>GcInner&lt;T&gt;</code>: The inner data type, which contains <code>T</code> and any other information we may need to keep track of our data.</li>
<li><code>GcHeader</code>: Internal book-keeping information.</li>
</ul>
<p>To begin, we have no extra information we need to store in <code>GcHeader</code>, so we can knock it out quickly:</p>
<pre><span>struct</span> <span>GcHeader</span><span>;</span>
</pre>
<p><code>GcInner&lt;T&gt;</code> is just the header and the data, so it is equally simple:</p>
<pre><span>struct</span> <span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    header<span>:</span> <span>GcHeader</span><span>,</span>
    data<span>:</span> <span>T</span><span>,</span>
<span>}</span>
</pre>
<p>We are ready to put together our <code>Gc&lt;T&gt;</code> type. One might define it rather simply as the following:</p>
<pre><span>struct</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    ptr<span>:</span> <span>*</span><span>mut</span> <span>T</span><span>,</span>
<span>}</span>
</pre>
<p>Unfortunately, this definition has two major problems:</p>
<h4>1.1.1. Variance <a name="variance"></a></h4>
<p>This struct does not pass through subtyping relationships on T; i.e., this structure is <em>invariant</em> over T.
Ideally, for every two type parameters <code>A</code> and <code>B</code>, if <code>A</code> is a subtype of <code>B</code> we would also like <code>Gc&lt;A&gt;</code> to
be a subtype of <code>Gc&lt;B&gt;</code> because we want a <code>Gc&lt;T&gt;</code> to behave as close to a <code>T</code> as possible. The reason this
occurs is because pointer types in Rust are <em>invariant</em>, and thus our wrapper type will be as well.</p>
<p>We can fix this by using a <code>NonNull&lt;T&gt;</code> pointer type, which is <em>covariant</em> over <code>T</code>. Additionally, this
ensures that any Gc we successfully create will <em>never</em> contain a null pointer, which is a plus.</p>
<p>In reality, variance is not particularly useful for our struct since we only support types that are <code>&#39;static</code>,
and most subtyping relationships in Rust regard references. However, there are a few times when it may come up ,
so there is no reason to not support it.</p>
<h4>1.1.2. Drop checking <a name="drop-checking"></a></h4>
<p>As it’s specified now, the Rust compiler is forced to assume that any <code>Gc&lt;T&gt;</code> will be strictly out-lived by the
underlying data. For our data type this not the case. Although a lot of <code>Gc</code>s represent references to data,
<em>some</em> <code>Gc</code>s represent the entire lifetime - they represent the data itself. Therefore, dropping a <code>Gc</code> can potentially
drop the underlying <code>T</code> value. The Rust compiler <em>needs</em> to know about this in order to perform its drop check
analysis, or else potentially unsound code can be constructed .</p>
<p>In order to indicate this information, we can use a <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"><code>PhantomData</code></a>, a neat wrapper type that indicates to the compiler that our data type should behave as if it has ownership over
a type <code>T</code>.</p>
<p>With these two data types we can put together our Gc<t>:</t></p>
<pre><span>pub</span> <span>struct</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    ptr<span>:</span> <span>NonNull</span><span>&lt;</span><span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span><span>&gt;</span><span>,</span>
    marker<span>:</span> <span>PhantomData</span><span>&lt;</span><span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span><span>data</span><span>:</span> <span>T</span><span>)</span> -&gt; <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
        <span>Self</span> <span>{</span>
            ptr<span>:</span> <span>NonNull</span><span>::</span><span>from</span><span>(</span><span>Box</span><span>::</span><span>leak</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span><span>GcInner</span> <span>{</span>
                header<span>:</span> <span>GcHeader</span><span>::</span><span>default</span><span>(</span><span>)</span><span>,</span>
                data<span>,</span>
            <span>}</span><span>)</span><span>)</span><span>)</span><span>,</span>
            marker<span>:</span> <span>PhantomData</span><span>,</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<p>The <code>new</code> function is rather straightforward but worth commenting on. The easiest way to allocate a pointer in
Rust is to use the <code>Box::new</code> function to allocate space and copy data onto the heap, and then use the <code>Box::leak</code>
function to consume the box without running its destructor and returning us a dangling pointer.</p>
<h2>2. Thread-safe interior mutability <a name="thread-safe-interior-mutability"></a></h2>
<p>After our data is allocated, we need a way to read and write to it in a thread-safe manner. By default, Rust
assumes that for the lifetime an immutable reference is held, the data referenced to will not be modified. We would like to opt
out of that assumption. To that end, we must use the <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> wrapper.</p>
<p>Of course, we want to ensure that if someone is trying to read the data behind a a Gc that no one is trying
to modify it at the same time, as that would be unsound.</p>
<p>Additionally, we are going to tell Rust that it should trust us to implement these rules in a thread-safe manner.
Our <code>GcInner</code> type now looks like the following:</p>
<pre><span>pub</span> <span>struct</span> <span>GcInner</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>{</span>
    header<span>:</span> <span>UnsafeCell</span><span>&lt;</span><span>GcHeader</span><span>&gt;</span><span>,</span>
    data<span>:</span> <span>UnsafeCell</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span> + <span>Send</span><span>&gt;</span> <span>Send</span> <span>for</span> <span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span><span>}</span>
<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span> + <span>Sync</span><span>&gt;</span> <span>Sync</span> <span>for</span> <span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span><span>}</span>


<span>unsafe</span> <span>impl</span> <span>Send</span> <span>for</span> <span>GcHeader</span> <span>{</span><span>}</span>
<span>unsafe</span> <span>impl</span> <span>Sync</span> <span>for</span> <span>GcHeader</span> <span>{</span><span>}</span>
</pre>
<p>This sets up our <code>Gc&lt;T&gt;</code> type to have thread-safe interior mutability. We must now implement it.</p>
<h3>2.1. Semaphores <a name="semaphores"></a></h3>
<p>A <a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore</a> is a way to control access to a
resource. Essentially, it is an array of N slots that each process is allowed to claim ownership of.
If all N slots are claimed, then processes must queue up and wait for the processes with ownership
to relinquish them.</p>
<pre>Acquire(Semaphore&lt;N&gt;) -&gt; Option&lt;Permit&gt;
Release(Permit) 
</pre>
<p>(both of these operations are atomic)</p>
<p>The ordering of these slots is irrelevant. Processes are only concerned with having ownership of a slot or
not. If the Semaphore has only one slot, you can make this value behave exactly like a typical Mutex:</p>
<pre>Lock(Semaphore) -&gt; Permit:
    loop:
        match Acquire(Semaphore):
            Some(Permit) =&gt; return Permit,
</pre>
<p>If we were to change our semaphore to have N &gt; 1 slots, we need to add another atomic operation in order to properly
mimic our <code>Mutex</code>:</p>
<pre>AcquireMany(Semaphore<n>, NumSlots) -&gt; Option&lt;Permit&gt;
</n></pre>
<p>Locking is pretty much the same but instead of attempting to acquire one slot we attempt to acquire all N.</p>
<p>We don’t have to always lock a variable. We can use semaphores with N &gt; 1 to mimic Rust’s safety rules - we can
have an unlimited number of immutable references OR one single mutable reference, and never both. The trick is
to have our reads only acquire one slot and to have our writes acquire all N.</p>
<p>To implement this, we’re going to use <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Semaphore.html">tokio’s Semaphore</a>,
which interfaces well with async rust. Let’s add it to <code>GcHeader</code>:</p>
<pre><span>struct</span> <span>GcHeader</span> <span>{</span>
    semaphore<span>:</span> tokio<span>::</span>sync<span>::</span><span>Semaphore</span><span>,</span>
<span>}</span>
</pre>
<h3>2.2. Read/write guards <a name="read-write-guards"></a></h3>
<p>We need some types to represent our acquired resources. In Rust, this done with Guards. Guards are
structs that:</p>
<ul>
<li>hold a reference and a permit of use for a resource</li>
<li>are treated transparently as a reference to the resource (via <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> and/or <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>)</li>
<li>release the permit when they are dropped</li>
<li>has the lifetime of the struct used to create the guard (so cannot be returned from a function with the smart pointer as a local)</li>
</ul>
<pre><span>pub</span> <span>struct</span> <span>GcReadGuard</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>{</span>
    _permit<span>:</span> tokio<span>::</span>sync<span>::</span><span>SemaphorePermit</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>,</span>
    data<span>:</span> <span>*</span><span>const</span> <span>T</span><span>,</span>
    marker<span>:</span> <span>PhantomData</span><span>&lt;</span><span>&amp;</span><span>&#39;</span><span>a</span> <span>T</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>Deref</span> <span>for</span> <span>GcReadGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
    <span>type</span> <span>Target</span> = <span>T</span><span>;</span>

    <span>fn</span> <span>deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>&amp;</span><span>T</span> <span>{</span>
        <span>unsafe</span> <span>{</span> <span>&amp;</span><span>*</span><span>self</span><span>.</span>data <span>}</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>AsRef</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>for</span> <span>GcReadGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>as_ref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>&amp;</span><span>T</span> <span>{</span>
        <span>self</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span> + <span>Send</span><span>&gt;</span> <span>Send</span> <span>for</span> <span>GcReadGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span><span>}</span>
<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span> + <span>Sync</span><span>&gt;</span> <span>Sync</span> <span>for</span> <span>GcReadGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span><span>}</span>

<span>pub</span> <span>struct</span> <span>GcWriteGuard</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>{</span>
    _permit<span>:</span> tokio<span>::</span>sync<span>::</span><span>SemaphorePermit</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>,</span>
    data<span>:</span> <span>*</span><span>mut</span> <span>T</span><span>,</span>
    marker<span>:</span> <span>PhantomData</span><span>&lt;</span><span>&amp;</span><span>&#39;</span><span>a</span> <span>mut</span> <span>T</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Deref</span> <span>for</span> <span>GcWriteGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>{</span>
    <span>type</span> <span>Target</span> = <span>T</span><span>;</span>

    <span>fn</span> <span>deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>&amp;</span><span>T</span> <span>{</span>
        <span>unsafe</span> <span>{</span> <span>&amp;</span><span>*</span><span>self</span><span>.</span>data <span>}</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>DerefMut</span> <span>for</span> <span>GcWriteGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>:</span> ?<span>Sized</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>deref_mut</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> -&gt; <span>&amp;</span><span>mut</span> <span>T</span> <span>{</span>
        <span>unsafe</span> <span>{</span> <span>&amp;</span><span>mut</span> <span>*</span><span>self</span><span>.</span>data <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span> + <span>Send</span><span>&gt;</span> <span>Send</span> <span>for</span> <span>GcWriteGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span><span>}</span>
<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> ?<span>Sized</span> + <span>Sync</span><span>&gt;</span> <span>Sync</span> <span>for</span> <span>GcWriteGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span><span>}</span>
</pre>
<p>Again, you will notice that in both of these structs we use the same trick to ensure the desired variance
(covariance) over each of the guards type parameters.</p>
<p>Since we use the tokio semaphore, we can create futures that await the acquisition of a permit:</p>
<pre><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
        <span>pub</span> <span>async</span> <span>fn</span> <span>read</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>GcReadGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
        <span>unsafe</span> <span>{</span>
            <span>let</span> _permit = <span>(</span><span>*</span><span>self</span><span>.</span>ptr<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>header<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span>
                <span>.</span>semaphore
                <span>.</span><span>acquire</span><span>(</span><span>)</span>
                <span>.</span><span>await</span>
                <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
            <span>let</span> data = <span>&amp;</span><span>*</span><span>self</span><span>.</span>ptr<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>data<span>.</span><span>get</span><span>(</span><span>)</span> <span>as</span> <span>*</span><span>const</span> <span>T</span><span>;</span>
            <span>GcReadGuard</span> <span>{</span>
                _permit<span>,</span>
                data<span>,</span>
                marker<span>:</span> <span>PhantomData</span><span>,</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

        <span>pub</span> <span>async</span> <span>fn</span> <span>write</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>GcWriteGuard</span><span>&lt;</span><span>&#39;</span><span>_</span><span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
        <span>unsafe</span> <span>{</span>
            <span>let</span> _permit = <span>(</span><span>*</span><span>self</span><span>.</span>ptr<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>header<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span>
                <span>.</span>semaphore
                <span>.</span><span>acquire_many</span><span>(</span><span>MAX_READS</span><span>)</span>
                <span>.</span><span>await</span>
                <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
            <span>let</span> data = <span>&amp;</span><span>mut</span> <span>*</span><span>self</span><span>.</span>ptr<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>data<span>.</span><span>get</span><span>(</span><span>)</span> <span>as</span> <span>*</span><span>mut</span> <span>T</span><span>;</span>
            <span>GcWriteGuard</span> <span>{</span>
                _permit<span>,</span>
                data<span>,</span>
                marker<span>:</span> <span>PhantomData</span><span>,</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<p>This gives us a heap allocated object with thread-safe interior mutability that lives forever.
Our last task is to make it mortal.</p>
<h2>3. Garbage collection <a name="garbage-collection"></a></h2>
<p>There are two main techniques for determining if allocated objects should be freed; tracing and reference
counting. Besides practical differences in performance and memory overhead, they differ in what information they
take as input:</p>
<ul>
<li>Tracing algorithms require a set of roots; values that one is required to travese in order to reach heap
objects. This includes stack variables and globals.</li>
<li>Reference counting algorithms require the number of active references to an object.</li>
</ul>
<p>Determining an object’s reference count in Rust is fairly straightforward. In Rust, an object’s reference count is equal to
the difference of clones and drops plus one. This is because Rust has an <a href="https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems">affine type system</a> for objects that do not implement <code>Copy</code>, which means that an object that does not implement <code>Copy</code> can be moved
at <em>most</em> once. Therefore, moves do not affect the reference count of an object. </p>
<p>To contrast this, figuring out the root objects in Rust is difficult. It’s certainly possible, but reference counts are
much easier to work with. This is why Rust’s default automatic memory management types, <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>
and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>, are both reference counted and can be easily implemented in user
code. Therefore, we will use reference counting.</p>
<p>But reference counting has a key problem. If it didn’t we wouldn’t have a reason to implement our own type.</p>
<h3>3.1. Cycles <a name="cycles"></a></h3>
<img src="https://maplant.com/fig1.jpg" alt="A simple cyclic data structure consisting of two nodes: A and B, and two edges: AB and BA"/>
<p>An object can be unreachable but still have a positive reference count. This is because our <code>Gc</code> type allows for
the creation of cyclical data structures (see fig. 1). Such data structures are pretty common to, especially in functional languages like Scheme. In order to ensure that cyclical data structures are collected
appropriately, we will be implementing
<a href="https://dl.acm.org/doi/10.5555/646158.680003">Concurrent Cycle Collection in Reference Counted Systems by David F. Bacon and V.T. Rajan</a> ,
an algorithm for automatically detecting and collecting cycles in reference counted data structures.</p>
<h3>3.2. Synchronous cycle collection <a name="synchronous-cycle-collection"></a></h3>
<p>Before we implement concurrent cycle detection, let’s start with synchronous. Here is the code
listing for the synchronous cycle collection algorithm:</p>
<table>
  <tbody><tr>
    <td>
<pre>Increment(s)
    RC(S) = RC(S) + 1
    color(S) = black
</pre>
    </td>
    <td>
<pre>ScanRoots()
    for S in Roots
        Scan(s)
</pre>
    </td>
  </tr>
  <tr>
    <td>
<pre>Decrement(S) 
    RC(S) = RC(S) - 1
    if (RC(S) == 0) 
        Release(S) 
    else 
        PossibleRoot(S)
</pre>
    </td>
    <td>
<pre>CollectRoots()
    for S in Roots
        remove S from Roots
        buffered(S) = false
        CollectWhite(S)
</pre>
    </td>
  </tr>
  
  <tr>
    <td>
<pre>Release(S)
    for T in children(S)
        Decrement(T)
    color(S) = black
    if (! buffered(S))
        Free(S)
</pre>
    </td>
    <td>
<pre>MarkGray(S)
    if (color(S) != gray)
        color(S) = gray
        for T in children(S)
            Rc(T) = RC(T) - 1
            MarkGray(T)
</pre>
</td>
</tr>
  <tr>
    <td>
<pre>PossibleRoot(S)
    if (color(S) != purple)
        color(S) = purple
        if (! buffered(S))
            buffered(S) = true
            append S to Roots
</pre>
    </td>
    <td>
<pre>Scan(S)
    if (color(S) == gray)
        if (RC(S) &gt; 0)
            ScanBlack(S)
        else
            color(S) = white
            for T in children(S)
                Scan(T)
</pre>
    </td>
  </tr>
  <tr>
    <td>
<pre>CollectCycles()
    MarkRoots()
    ScanRoots()
    CollectRoots()
</pre>
    </td>
    <td>
<pre>ScanBlack(S)
    color(S) = black
    for T in children(S)
        RC(T) = RC(T) + 1
        if (color(T) != black)
            ScanBlack(T)
</pre>
    </td>
  </tr>
<tr>
    <td>
<pre>MarkRoots()
    for S in Roots
        if (color(S) == purple)
            MarkGray(S)
        else
            buffered(S) = false
            remove S from Roots
            if (color(S) == black and RC(S) == 0)
                Free(S)
</pre>
    </td>
    <td>
<pre>CollectWhite(S)
    if (color(S) == white and !buffered(S))
        color(S) = black
        for T in children(S)
            CollectWhite(T)
        Free(S)
</pre>
</td>
</tr>
</tbody></table>
<p>Everyone loves to trust code at face value, but how does this actually work? I encourage you to read the paper, but I
will summarize the operation leaving out some very important details.</p>
<p>Cycle Collection relies on this key insight: if you were to perform a drop on every node in a cycle, that cycle will be
garbage if the remaining ref count of every node in that cycle is zero. This kind of makes sense intuitively, what we’re
basically saying here is that if we somehow already knew that a data structure was cyclic, we could just manually sever
an outgoing reference for some random node and the cascade of decrementing reference counts would cleanly free the whole
data structure.</p>
<p>With this in mind, we can can construct an efficient algorithm to collect cyclical garbage. We’ll color the nodes in
different colors as they pass through different stages</p>
<ul>
<li><code>Decrement</code>: When we decrement a reference count and the reference count is greater than zero, add it to our list of
possible roots. If we’ve already added it before performing a collection cycle (it’s been marked <em>purple</em>), skip this.</li>
<li><code>Mark</code>: Go through the roots, and perform the test described in the previous paragraph. Practically, this works by
performing a depth first search on the root, marking each node gray and decrementing the reference count of each child
and repeating the process on them. If the child is already marked gray, we skip them.</li>
<li><code>Scan</code>: Go through the roots and recursively check their children for reference counts greater than zero. If there is
any greater than zero, recursively mark all of their children black to indicate the data is live. Otherwise, the
structure is marked white, to indicate it is ready to be freed.</li>
<li><code>Collect</code>: Go through the roots marked white and free them.</li>
</ul>
<p>There is one thing in particular that is not immediately clear as to how we are going to implement. How do
we iterate over the children? We haven’t put any bounds on the <code>T</code> in our <code>Gc&lt;T&gt;</code> beyond that it has to be <code>&#39;static</code>. Well,
until Rust gains a more powerful reflection story, we are going to have to add a classic Trait plus derive macro combo.</p>
<h3>3.3. The Trace trait and derive macro <a name="the-trace-trait-and-derive-macro"></a></h3>
<p>Let’s define the trait we need to implement the above code. We need a function that matches the following form:</p>
<pre>for T in children(S):
    F(T)
</pre>
<p>We can extract two type parameters from this statement: S, and F(T) where T == S. Therefore, the function we want will
have the form <code>fn for_each_children(S, impl FnMut(S))</code>.</p>
<p>It’s not entirely obvious at first glance, but there is another function that we must pay attention to: <code>free</code>.
The <code>free</code> function presented in the above code listing does <em>not</em> correspond to how memory is freed in Rust. That is
because this code assumes that when we free code we are not running any of its members destructors. But we <em>do</em> want to
run our destructors. At least, we want to run the destructor <em>if</em> the type is <em>not</em> a <code>Gc</code>. We’re going to have to add
a <code>finalize</code> function to handle a custom drop routine:</p>
<pre><span>unsafe</span> <span>trait</span> <span>Trace</span><span>:</span> <span>&#39;</span><span>static</span> <span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_children</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span><span>;</span>
    
    <span>unsafe</span> <span>fn</span> <span>finalize</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>drop_in_place</span><span>(</span><span>self</span> <span>as</span> <span>*</span><span>mut</span> <span>Self</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<p>These two things are in fact the <em>only</em>  two things our collection algorithm cares about in regards to <code>Gc</code>’s data.
Therefore, whenever we’re in the context of the collection algorithm, we will cast our Gc’s into a trait object:</p>
<pre><span>type</span> <span>OpaqueGc</span> = <span>GcInner</span><span>&lt;</span><span>dyn</span> <span>Trace</span><span>&gt;</span><span>;</span>
<span>pub</span> <span>type</span> <span>OpaqueGcPtr</span> = <span>NonNull</span><span>&lt;</span><span>OpaqueGc</span><span>&gt;</span><span>;</span>

<span>impl</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span><span>&gt;</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>as_opaque</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>OpaqueGcPtr</span> <span>{</span>
        <span>self</span><span>.</span>ptr <span>as</span> <span>OpaqueGcPtr</span>
    <span>}</span>
<span>}</span>
</pre>
<p>With the Trace trait defined, we can implement it for some primitive types to give us some building blocks with which
to implement composite structures. A good starting point will be Rust’s std library, since those data structures are used
throughout the entire Rust ecosystem. I won’t provide all of the ones I implemented, but here
are a few:</p>
<pre><span>unsafe</span> <span>trait</span> <span>GcOrTrace</span><span>:</span> <span>&#39;</span><span>static</span> <span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_or_recurse</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span><span>;</span>

    <span>unsafe</span> <span>fn</span> <span>finalize_or_skip</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span><span>;</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span><span>&gt;</span> <span>GcOrTrace</span> <span>for</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_or_recurse</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
        <span>visitor</span><span>(</span><span>self</span><span>.</span><span>as_opaque</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    <span>unsafe</span> <span>fn</span> <span>finalize_or_skip</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span><span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span> + ?<span>Sized</span><span>&gt;</span> <span>GcOrTrace</span> <span>for</span> <span>T</span> <span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_or_recurse</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
        <span>self</span><span>.</span><span>visit_children</span><span>(</span>visitor<span>)</span><span>;</span>
    <span>}</span>

    <span>unsafe</span> <span>fn</span> <span>finalize_or_skip</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>self</span><span>.</span><span>finalize</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Trace</span> <span>for</span> <span>Vec</span><span>&lt;</span><span>T</span><span>&gt;</span>
<span>where</span>
    <span>T</span><span>:</span> <span>GcOrTrace</span><span>,</span>
<span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_children</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
        <span>for</span> child <span>in</span> <span>self</span> <span>{</span>
            child<span>.</span><span>visit_or_recurse</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>unsafe</span> <span>fn</span> <span>finalize</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>for</span> <span>mut</span> child <span>in</span> std<span>::</span>mem<span>::</span><span>take</span><span>(</span><span>self</span><span>)</span><span>.</span><span>into_iter</span><span>(</span><span>)</span> <span>{</span>
            child<span>.</span><span>finalize_or_skip</span><span>(</span><span>)</span><span>;</span>
            std<span>::</span>mem<span>::</span><span>forget</span><span>(</span>child<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Trace</span> <span>for</span> <span>Option</span><span>&lt;</span><span>T</span><span>&gt;</span>
<span>where</span>
    <span>T</span><span>:</span> <span>GcOrTrace</span><span>,</span>
<span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_children</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span><span>(</span>inner<span>)</span> = <span>self</span> <span>{</span>
            inner<span>.</span><span>visit_or_recurse</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>unsafe</span> <span>fn</span> <span>finalize</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span><span>(</span>inner<span>)</span> = <span>self</span> <span>{</span>
            inner<span>.</span><span>finalize_or_skip</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Trace</span> <span>for</span> std<span>::</span>sync<span>::</span><span>Arc</span><span>&lt;</span><span>T</span><span>&gt;</span>
<span>where</span>
    <span>T</span><span>:</span> <span>GcOrTrace</span><span>,</span>
<span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_children</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
         <span>self</span><span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span><span>visit_or_recurse</span><span>(</span>visitor<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<p>If you are able to immediately spot the error in the code above, you are much smarter than
I am. I hope you at least have the courtesy to be less good looking. Anyway, this code isn’t
correct with our current set of assumptions. And that’s due to the implementation for Arc,
which recurses into its data.</p>
<p>The problem is that we are basically disregarding the reference count of the <code>Arc</code>. Consider the
following structure:</p>
<img src="https://maplant.com/fig2.jpg" alt="A data structure with three nodes: A, B, C and Arc, with three edges: A-&gt;Arc, B-&gt;Arc, Arc-&gt;C"/>
<p>In this case, dropping A results in the immediate dropping of C while a dangling reference from B remains.
Essentially, the <code>Arc</code> collapses all of the incoming references to C into one.</p>
<p>Here is the correct code for <code>Arc</code>. Part of what makes this code correct is that we added an
explanation, so be sure to always do that.</p>
<pre><span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Trace</span> <span>for</span> std<span>::</span>sync<span>::</span><span>Arc</span><span>&lt;</span><span>T</span><span>&gt;</span>
<span>where</span>
    <span>T</span><span>:</span> ?<span>Sized</span> + <span>&#39;</span><span>static</span><span>,</span>
<span>{</span>
    <span>unsafe</span> <span>fn</span> <span>visit_children</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>_visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
        
        
        
        
    <span>}</span>
<span>}</span>
</pre>
<p>Another important thing to discuss is the operation of <code>finalize</code> for <code>Vec</code> (and other container types):</p>
<pre><span>unsafe</span> <span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Trace</span> <span>for</span> <span>Vec</span><span>&lt;</span><span>T</span><span>&gt;</span>
<span>where</span>
    <span>T</span><span>:</span> <span>GcOrTrace</span><span>,</span>
<span>{</span>
    <span>unsafe</span> <span>fn</span> <span>finalize</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>for</span> <span>mut</span> child <span>in</span> std<span>::</span>mem<span>::</span><span>take</span><span>(</span><span>self</span><span>)</span><span>.</span><span>into_iter</span><span>(</span><span>)</span> <span>{</span>
            child<span>.</span><span>finalize_or_skip</span><span>(</span><span>)</span><span>;</span>
            std<span>::</span>mem<span>::</span><span>forget</span><span>(</span>child<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<p>Our finalization here is pretty particular: we <em>take</em> the memory allocated by the <code>Vec</code>, convert it into
and owned iterator so we can be sure there are no dangling references to child that <code>drop</code> may be run on,
and drop the children.</p>
<p>I am not going to get too into the Trait derive proc macro code as it’s not particularly interesting and
quite long. But it’s important to note what it is actually doing for any given type <code>T</code>:</p>
<ul>
<li><code>visit_children</code>: for every field, if the type is a <code>Gc</code>, call <code>visitor</code> on the <code>OpaqueGcPtr</code> of the field.
If the type is <em>not</em> a <code>Gc</code>, recursively call <code>visit_children</code> on it.</li>
<li><code>finalize</code>: for every field that is <em>not</em> a <code>Gc</code>, call <code>finalize</code> on it.</li>
</ul>
<p>If you would like to see how this is done, the code is available <a href="https://github.com/maplant/scheme-rs/blob/main/proc-macros/src/lib.rs">here</a>.</p>
<h3>3.4. Deallocation <a name="deallocation"></a></h3>
<p>The <code>free</code> function needs to call <a href="https://doc.rust-lang.org/std/alloc/fn.dealloc.html"><code>std::alloc::dealloc</code></a> to
<code>free</code> the allocated memory. This function takes a <a href="https://doc.rust-lang.org/std/alloc/struct.Layout.html">Layout</a> (a size
and alignment). How do we find this for our opaque <code>dyn Trace</code> pointer? Turns out the size and alignment of the
underlying data is part of Rust’s vtable. So, we can just call <code>Layout::for_value</code> on our reference and create one.
Here’s the resulting free function:</p>
<pre><span>unsafe</span> <span>fn</span> <span>trace</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> -&gt; <span>&amp;</span><span>&#39;</span><span>a</span> <span>mut</span> <span>dyn</span> <span>Trace</span> <span>{</span>
    <span>&amp;</span><span>mut</span> <span>*</span>s<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>data<span>.</span><span>get</span><span>(</span><span>)</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>free</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    
    <span>let</span> trace = <span>trace</span><span>(</span>s<span>)</span><span>;</span>
    <span>let</span> layout = <span>Layout</span><span>::</span><span>for_value</span><span>(</span>trace<span>)</span><span>;</span>
    trace<span>.</span><span>finalize</span><span>(</span><span>)</span><span>;</span>
    std<span>::</span>alloc<span>::</span><span>dealloc</span><span>(</span>s<span>.</span><span>as_ptr</span><span>(</span><span>)</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span> layout<span>)</span><span>;</span>
<span>}</span>
</pre>
<h3>3.5. Extending from synchronous to concurrent <a name="extending-from-synchronous-to-concurrent"></a></h3>
<p>If we wish to move our collection into a separate thread, we are somehow going to have to deal
with two things:</p>
<ul>
<li>Increment and Decrement operations can happen in parallel while our algorithm is running. In
the synchronous algorithm, we could guarantee that reference counts would stay the same for the
lifetime of <code>CollectCycles</code>.</li>
<li>The mutation of the reference graph can causes the <code>MarkGray</code> function to incorrectly mark
a live object as garbage.</li>
</ul>
<p>In order to explain how each of these things are dealt with, let’s take a look at our final <code>GcHeader</code>:</p>
<pre><span>pub</span> <span>struct</span> <span>GcHeader</span> <span>{</span>
    rc<span>:</span> <span>usize</span><span>,</span>
    crc<span>:</span> <span>usize</span><span>,</span>
    color<span>:</span> <span>Color</span><span>,</span>
    buffered<span>:</span> <span>bool</span><span>,</span>
    semaphore<span>:</span> <span>Semaphore</span><span>,</span>
<span>}</span>

<span>enum</span> <span>Color</span> <span>{</span>
        <span>Black</span><span>,</span>
        <span>Gray</span><span>,</span>
        <span>White</span><span>,</span>
        <span>Purple</span><span>,</span>
        <span>Red</span><span>,</span>
        <span>Orange</span><span>,</span>
<span>}</span>
</pre>
<p>This header is quite large and therefore a lot of overhead. It can be made smaller with some tricks,
such as assuming that most nodes will not have more than 255 reference counts and storing overflowing
ref counts externally, but we will ignore those tricks for now.</p>
<h4>3.5.1. The mutation buffer <a name="the-mutation-buffer"></a></h4>
<p>You will notice that the ref counts for our <code>Gc</code> type are <em>not</em> atomic. This is because our concurrent
algorithm requires a constraint: only one thread at a time can <em>ever</em> modify the ref count, or indeed
<em>any</em> field in the <code>GcHeader</code> except for semaphore (which is already thread safe). This gives our
garbage collection process exclusive read and write access to most of the header.</p>
<p>What gives? How does <em>that</em> work? Isn’t this algorithm supposed to be concurrent? We don’t want
decrementing or incrementing ref counts to wait on the completion of the GC process. That would make
our drop and clone functions blocking, which would gum up our whole system.</p>
<p>The solution is the mutation buffer, an unbounded channel that lets us buffer incremements and
decrements to be handled by our collection process as it pleases.</p>
<p>This wil allow our collector to stop processing incremements and decrements at any time and effectively
have a snapshot of the system without causing any pauses in other threads. Since the buffer is <em>unbounded</em>,
calling <code>send</code> is a non-blocking, sync operation:</p>
<pre><span>#<span>[</span>derive<span>(</span><span>Copy</span><span>,</span> <span>Clone</span><span>)</span><span>]</span></span>
<span>struct</span> <span>Mutation</span> <span>{</span>
    kind<span>:</span> <span>MutationKind</span><span>,</span>
    gc<span>:</span> <span>NonNull</span><span>&lt;</span><span>OpaqueGc</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Mutation</span> <span>{</span>
    <span>fn</span> <span>new</span><span>(</span><span>kind</span><span>:</span> <span>MutationKind</span><span>,</span> <span>gc</span><span>:</span> <span>NonNull</span><span>&lt;</span><span>OpaqueGc</span><span>&gt;</span><span>)</span> -&gt; <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span> kind<span>,</span> gc <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>impl</span> <span>Send</span> <span>for</span> <span>Mutation</span> <span>{</span><span>}</span>
<span>unsafe</span> <span>impl</span> <span>Sync</span> <span>for</span> <span>Mutation</span> <span>{</span><span>}</span>

<span>#<span>[</span>derive<span>(</span><span>Copy</span><span>,</span> <span>Clone</span><span>)</span><span>]</span></span>
<span>enum</span> <span>MutationKind</span> <span>{</span>
    <span>Inc</span><span>,</span>
    <span>Dec</span><span>,</span>
<span>}</span>

<span>struct</span> <span>MutationBuffer</span> <span>{</span>
    mutation_buffer_tx<span>:</span> <span>UnboundedSender</span><span>&lt;</span><span>Mutation</span><span>&gt;</span><span>,</span>
    mutation_buffer_rx<span>:</span> <span>Mutex</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>UnboundedReceiver</span><span>&lt;</span><span>Mutation</span><span>&gt;</span><span>&gt;</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>unsafe</span> <span>impl</span> <span>Sync</span> <span>for</span> <span>MutationBuffer</span> <span>{</span><span>}</span>

<span>impl</span> <span>Default</span> <span>for</span> <span>MutationBuffer</span> <span>{</span>
    <span>fn</span> <span>default</span><span>(</span><span>)</span> -&gt; <span>Self</span> <span>{</span>
        <span>let</span> <span>(</span>mutation_buffer_tx<span>,</span> mutation_buffer_rx<span>)</span> = <span>unbounded_channel</span><span>(</span><span>)</span><span>;</span>
        <span>Self</span> <span>{</span>
            mutation_buffer_tx<span>,</span>
            mutation_buffer_rx<span>:</span> <span>Mutex</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span>mutation_buffer_rx<span>)</span><span>)</span><span>,</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>static</span> <span>MUTATION_BUFFER</span><span>:</span> <span>OnceLock</span><span>&lt;</span><span>MutationBuffer</span><span>&gt;</span> = <span>OnceLock</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

<span>fn</span> <span>inc_rc</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span><span>&gt;</span><span>(</span><span>gc</span><span>:</span> <span>NonNull</span><span>&lt;</span><span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>MUTATION_BUFFER</span>
        <span>.</span><span>get_or_init</span><span>(</span><span>MutationBuffer</span><span>::</span>default<span>)</span>
        <span>.</span>mutation_buffer_tx
        <span>.</span><span>send</span><span>(</span><span>Mutation</span><span>::</span><span>new</span><span>(</span><span>MutationKind</span><span>::</span><span>Inc</span><span>,</span> gc <span>as</span> <span>NonNull</span><span>&lt;</span><span>OpaqueGc</span><span>&gt;</span><span>)</span><span>)</span>
        <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>dec_rc</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span><span>&gt;</span><span>(</span><span>gc</span><span>:</span> <span>NonNull</span><span>&lt;</span><span>GcInner</span><span>&lt;</span><span>T</span><span>&gt;</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>MUTATION_BUFFER</span>
        <span>.</span><span>get_or_init</span><span>(</span><span>MutationBuffer</span><span>::</span>default<span>)</span>
        <span>.</span>mutation_buffer_tx
        <span>.</span><span>send</span><span>(</span><span>Mutation</span><span>::</span><span>new</span><span>(</span><span>MutationKind</span><span>::</span><span>Dec</span><span>,</span> gc <span>as</span> <span>NonNull</span><span>&lt;</span><span>OpaqueGc</span><span>&gt;</span><span>)</span><span>)</span>
        <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</pre>
<p>And now we finally can implement <code>Clone</code> and <code>Drop</code> for <code>Gc&lt;T&gt;</code>:</p>
<pre><span>impl</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span><span>&gt;</span> <span>Clone</span> <span>for</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>clone</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
        <span>inc_rc</span><span>(</span><span>self</span><span>.</span>ptr<span>)</span><span>;</span>
        <span>Self</span> <span>{</span>
            ptr<span>:</span> <span>self</span><span>.</span>ptr<span>,</span>
            marker<span>:</span> <span>PhantomData</span><span>,</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>:</span> <span>Trace</span><span>&gt;</span> <span>Drop</span> <span>for</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>dec_rc</span><span>(</span><span>self</span><span>.</span>ptr<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<p>This also presents a structure for our collection process: wait for some increments and
decrements, process them, then decide if we want to try to perform a collection:</p>
<pre><span>static</span> <span>COLLECTOR_TASK</span><span>:</span> <span>OnceLock</span><span>&lt;</span><span>JoinHandle</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span><span>&gt;</span> = <span>OnceLock</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>init_gc</span><span>(</span><span>)</span> <span>{</span>
    
    <span>let</span> _ = <span>MUTATION_BUFFER</span><span>.</span><span>get_or_init</span><span>(</span><span>MutationBuffer</span><span>::</span>default<span>)</span><span>;</span>
    <span>let</span> _ = <span>COLLECTOR_TASK</span>
        <span>.</span><span>get_or_init</span><span>(</span>|| tokio<span>::</span>task<span>::</span><span>spawn</span><span>(</span><span>async</span> <span>{</span> <span>unsafe</span> <span>{</span> <span>run_garbage_collector</span><span>(</span><span>)</span><span>.</span><span>await</span> <span>}</span> <span>}</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>MUTATIONS_BUFFER_DEFAULT_CAP</span><span>:</span> <span>usize</span> = <span>10_000</span><span>;</span>

<span>async</span> <span>unsafe</span> <span>fn</span> <span>run_garbage_collector</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> last_epoch = <span>Instant</span><span>::</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> <span>mut</span> mutation_buffer_rx = <span>MUTATION_BUFFER</span>
        <span>.</span><span>get_or_init</span><span>(</span><span>MutationBuffer</span><span>::</span>default<span>)</span>
        <span>.</span>mutation_buffer_rx
        <span>.</span><span>lock</span><span>(</span><span>)</span>
        <span>.</span><span>take</span><span>(</span><span>)</span>
        <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> <span>mut</span> mutation_buffer<span>:</span> <span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span> = <span>Vec</span><span>::</span><span>with_capacity</span><span>(</span><span>MUTATIONS_BUFFER_DEFAULT_CAP</span><span>)</span><span>;</span>
    <span>loop</span> <span>{</span>
        <span>epoch</span><span>(</span><span>&amp;</span><span>mut</span> last_epoch<span>,</span> <span>&amp;</span><span>mut</span> mutation_buffer<span>)</span><span>.</span><span>await</span><span>;</span>
        mutation_buffer<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>async</span> <span>unsafe</span> <span>fn</span> <span>epoch</span><span>(</span><span>last_epoch</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Instant</span><span>,</span> <span>mutation_buffer</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>Mutation</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>process_mutation_buffer</span><span>(</span>mutation_buffer<span>)</span><span>.</span><span>await</span><span>;</span>
    <span>let</span> duration_since_last_epoch = <span>Instant</span><span>::</span><span>now</span><span>(</span><span>)</span> - <span>*</span>last_epoch<span>;</span>
    <span>if</span> duration_since_last_epoch &gt; <span>Duration</span><span>::</span><span>from_millis</span><span>(</span><span>100</span><span>)</span> <span>{</span>
        tokio<span>::</span>task<span>::</span><span>spawn_blocking</span><span>(</span>|| <span>unsafe</span> <span>{</span> <span>process_cycles</span><span>(</span><span>)</span> <span>}</span><span>)</span>
            <span>.</span><span>await</span>
            <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
        <span>*</span>last_epoch = <span>Instant</span><span>::</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>async</span> <span>unsafe</span> <span>fn</span> <span>process_mutation_buffer</span><span>(</span>
    <span>mutation_buffer_rx</span><span>:</span> <span>&amp;</span><span>mut</span> <span>UnboundedReceiver</span><span>&lt;</span><span>Mutation</span><span>&gt;</span><span>,</span>
    <span>mutation_buffer</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>Mutation</span><span>&gt;</span>
<span>)</span> <span>{</span>
    
    
    <span>let</span> to_recv = mutation_buffer_rx<span>.</span><span>len</span><span>(</span><span>)</span><span>;</span>
    mutation_buffer_rx
        <span>.</span><span>recv_many</span><span>(</span>mutation_buffer<span>,</span> to_recv<span>)</span>
        <span>.</span><span>await</span><span>;</span>

    <span>for</span> mutation <span>in</span> mutation_buffer <span>{</span>
        <span>match</span> mutation<span>.</span>kind <span>{</span>
            <span>MutationKind</span><span>::</span><span>Inc</span> =&gt; <span>increment</span><span>(</span>mutation<span>.</span>gc<span>)</span><span>,</span>
            <span>MutationKind</span><span>::</span><span>Dec</span> =&gt; <span>decrement</span><span>(</span>mutation<span>.</span>gc<span>)</span><span>,</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<h4>3.5.2. The Cyclical Reference Count <a name="the-cyclical-reference-count"></a></h4>
<p>You will notice in the <code>GcHeader</code> we added a second reference counting field called the CRC. This is distinguished
from the “true” reference count, the RC, by being the hypothetical reference count of the node that has perhaps
become invalidated during the epoch. We can modify the code listing to create the following functions that use the CRC
instead :</p>
<pre>

<span>static</span> <span>mut</span> <span>ROOTS</span><span>:</span> <span>Vec</span><span>&lt;</span><span>OpaqueGcPtr</span><span>&gt;</span> = <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
<span>static</span> <span>mut</span> <span>CYCLE_BUFFER</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>OpaqueGcPtr</span><span>&gt;</span><span>&gt;</span> = <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
<span>static</span> <span>mut</span> <span>CURRENT_CYCLE</span><span>:</span> <span>Vec</span><span>&lt;</span><span>OpaqueGcPtr</span><span>&gt;</span> = <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

<span>unsafe</span> <span>fn</span> <span>increment</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>*</span><span>rc</span><span>(</span>s<span>)</span> += <span>1</span><span>;</span>
    <span>scan_black</span><span>(</span>s<span>)</span><span>;</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>decrement</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>*</span><span>rc</span><span>(</span>s<span>)</span> -= <span>1</span><span>;</span>
    <span>if</span> <span>*</span><span>rc</span><span>(</span>s<span>)</span> == <span>0</span> <span>{</span>
        <span>release</span><span>(</span>s<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>possible_root</span><span>(</span>s<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>release</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>for_each_child</span><span>(</span>s<span>,</span> decrement<span>)</span><span>;</span>
    <span>*</span><span>color</span><span>(</span>s<span>)</span> = <span>Color</span><span>::</span><span>Black</span><span>;</span>
    <span>if</span> !<span>*</span><span>buffered</span><span>(</span>s<span>)</span> <span>{</span>
        <span>free</span><span>(</span>s<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>possible_root</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>scan_black</span><span>(</span>s<span>)</span><span>;</span>
    <span>*</span><span>color</span><span>(</span>s<span>)</span> = <span>Color</span><span>::</span><span>Purple</span><span>;</span>
    <span>if</span> !<span>*</span><span>buffered</span><span>(</span>s<span>)</span> <span>{</span>
        <span>*</span><span>buffered</span><span>(</span>s<span>)</span> = <span>true</span><span>;</span>
        <span>(</span><span>&amp;</span>raw <span>mut</span> <span>ROOTS</span><span>)</span><span>.</span><span>as_mut</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>.</span><span>push</span><span>(</span>s<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>


<span>unsafe</span> <span>fn</span> <span>mark_roots</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> new_roots = <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> s <span>in</span> <span>(</span><span>&amp;</span>raw const <span>ROOTS</span><span>)</span><span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>.</span><span>iter</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>*</span><span>color</span><span>(</span><span>*</span>s<span>)</span> == <span>Color</span><span>::</span><span>Purple</span> &amp;&amp; <span>*</span><span>rc</span><span>(</span><span>*</span>s<span>)</span> &gt; <span>0</span> <span>{</span>
            <span>mark_gray</span><span>(</span><span>*</span>s<span>)</span><span>;</span>
            new_roots<span>.</span><span>push</span><span>(</span><span>*</span>s<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>*</span><span>buffered</span><span>(</span><span>*</span>s<span>)</span> = <span>false</span><span>;</span>
            <span>if</span> <span>*</span><span>rc</span><span>(</span><span>*</span>s<span>)</span> == <span>0</span> <span>{</span>
                <span>free</span><span>(</span><span>*</span>s<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>ROOTS</span> = new_roots<span>;</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>scan_roots</span><span>(</span><span>)</span> <span>{</span>
    <span>for</span> s <span>in</span> <span>(</span><span>&amp;</span>raw const <span>ROOTS</span><span>)</span><span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>.</span><span>iter</span><span>(</span><span>)</span> <span>{</span>
        <span>scan</span><span>(</span><span>*</span>s<span>)</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>collect_roots</span><span>(</span><span>)</span> <span>{</span>
    <span>for</span> s <span>in</span> std<span>::</span>mem<span>::</span><span>take</span><span>(</span><span>(</span><span>&amp;</span>raw <span>mut</span> <span>ROOTS</span><span>)</span><span>.</span><span>as_mut</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>*</span><span>color</span><span>(</span>s<span>)</span> == <span>Color</span><span>::</span><span>White</span> <span>{</span>
            <span>collect_white</span><span>(</span>s<span>)</span><span>;</span>
            <span>let</span> current_cycle = std<span>::</span>mem<span>::</span><span>take</span><span>(</span><span>(</span><span>&amp;</span>raw <span>mut</span> <span>CURRENT_CYCLE</span><span>)</span><span>.</span><span>as_mut</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>(</span><span>&amp;</span>raw <span>mut</span> <span>CYCLE_BUFFER</span><span>)</span>
                <span>.</span><span>as_mut</span><span>(</span><span>)</span>
                <span>.</span><span>unwrap</span><span>(</span><span>)</span>
                <span>.</span><span>push</span><span>(</span>current_cycle<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>*</span><span>buffered</span><span>(</span>s<span>)</span> = <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>mark_gray</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>if</span> <span>*</span><span>color</span><span>(</span>s<span>)</span> != <span>Color</span><span>::</span><span>Gray</span> <span>{</span>
        <span>*</span><span>color</span><span>(</span>s<span>)</span> = <span>Color</span><span>::</span><span>Gray</span><span>;</span>
        <span>*</span><span>crc</span><span>(</span>s<span>)</span> = <span>*</span><span>rc</span><span>(</span>s<span>)</span> <span>as</span> <span>isize</span><span>;</span>
        <span>for_each_child</span><span>(</span>s<span>,</span> |t| <span>{</span>
            <span>mark_gray</span><span>(</span>t<span>)</span><span>;</span>
            <span>if</span> <span>*</span><span>crc</span><span>(</span>t<span>)</span> &gt; <span>0</span> <span>{</span>
                <span>*</span><span>crc</span><span>(</span>t<span>)</span> -= <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>scan</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>if</span> <span>*</span><span>color</span><span>(</span>s<span>)</span> == <span>Color</span><span>::</span><span>Gray</span> <span>{</span>
        <span>if</span> <span>*</span><span>crc</span><span>(</span>s<span>)</span> == <span>0</span> <span>{</span>
            <span>*</span><span>color</span><span>(</span>s<span>)</span> = <span>Color</span><span>::</span><span>White</span><span>;</span>
            <span>for_each_child</span><span>(</span>s<span>,</span> scan<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>scan_black</span><span>(</span>s<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>scan_black</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>if</span> <span>*</span><span>color</span><span>(</span>s<span>)</span> != <span>Color</span><span>::</span><span>Black</span> <span>{</span>
        <span>*</span><span>color</span><span>(</span>s<span>)</span> = <span>Color</span><span>::</span><span>Black</span><span>;</span>
        <span>for_each_child</span><span>(</span>s<span>,</span> scan_black<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>collect_white</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>if</span> <span>*</span><span>color</span><span>(</span>s<span>)</span> == <span>Color</span><span>::</span><span>White</span> <span>{</span>
        <span>*</span><span>color</span><span>(</span>s<span>)</span> = <span>Color</span><span>::</span><span>Orange</span><span>;</span>
        <span>*</span><span>buffered</span><span>(</span>s<span>)</span> = <span>true</span><span>;</span>
        <span>(</span><span>&amp;</span>raw <span>mut</span> <span>CURRENT_CYCLE</span><span>)</span><span>.</span><span>as_mut</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>.</span><span>push</span><span>(</span>s<span>)</span><span>;</span>
        <span>for_each_child</span><span>(</span>s<span>,</span> collect_white<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<h4>3.5.3. The safety phase <a name="the-safety-phase"></a></h4>
<p>Because of concurrent mutations to the edges of our graph, there is a possibility that our mark algorithm
will produce results that are incorrect. Therefore, we divide our collection algorithm into two phases:</p>
<ul>
<li>The marking phase, which produces candidate cycles.</li>
<li>The <em>safety</em> phase, which determines if candidate cycles are garbage.</li>
</ul>
<p>The correctness of this approach relies on another key insight: any mutation that occurs while we are
marking our cycles <em>must</em> appear in the next epoch. Therefore, we need to check that no external node adds
an edge to our potential cycle over the current and next epoch.</p>
<p>We have two tests for this, corresponding to the current and next epoch respectively:</p>
<h5>3.5.3.1. Σ-test <a name="sigma-test"></a></h5>
<p>The sigma test requires preparation. In essence preparation boils down to using the same algorithm as
<code>MarkGray</code>, but we are restricting it to only the nodes of a given cycle:</p>
<pre><span>unsafe</span> <span>fn</span> <span>sigma_preparation</span><span>(</span><span>)</span> <span>{</span>
    <span>for</span> c <span>in</span> <span>(</span><span>&amp;</span>raw const <span>CYCLE_BUFFER</span><span>)</span><span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span> n <span>in</span> c <span>{</span>
            <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span> = <span>Color</span><span>::</span><span>Red</span><span>;</span>
            <span>*</span><span>crc</span><span>(</span><span>*</span>n<span>)</span> = <span>*</span><span>rc</span><span>(</span><span>*</span>n<span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> n <span>in</span> c <span>{</span>
            <span>for_each_child</span><span>(</span><span>*</span>n<span>,</span> |m| <span>{</span>
                <span>if</span> <span>*</span><span>color</span><span>(</span>m<span>)</span> == <span>Color</span><span>::</span><span>Red</span> &amp;&amp; <span>*</span><span>crc</span><span>(</span>m<span>)</span> &gt; <span>0</span> <span>{</span>
                    <span>*</span><span>crc</span><span>(</span>m<span>)</span> -= <span>1</span><span>;</span>
                <span>}</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> n <span>in</span> c <span>{</span>
            <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span> = <span>Color</span><span>::</span><span>Orange</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<p>At the end of prepartion, if any of the circular reference counts are greater than zero, the graph is live.
We check this in the next epoch:</p>
<pre><span>unsafe</span> <span>fn</span> <span>sigma_test</span><span>(</span><span>c</span><span>:</span> <span>&amp;</span><span>[</span><span>OpaqueGcPtr</span><span>]</span><span>)</span> -&gt; <span>bool</span> <span>{</span>
    <span>for</span> n <span>in</span> c <span>{</span>
        <span>if</span> <span>*</span><span>crc</span><span>(</span><span>*</span>n<span>)</span> &gt; <span>0</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>true</span>
<span>}</span>
</pre>
<p>The <em>reason</em> that this test is called the “sigma” test is because the <em>sum</em> of the circular reference
counts will remain zero in a garbage cycle.</p>
<h5>3.5.3.2. Δ-test <a name="delta-test"></a></h5>
<p>If any node’s reference count is incremented in the next epoch, it will be colored black and fail the
delta test:</p>
<pre><span>unsafe</span> <span>fn</span> <span>delta_test</span><span>(</span><span>c</span><span>:</span> <span>&amp;</span><span>[</span><span>OpaqueGcPtr</span><span>]</span><span>)</span> -&gt; <span>bool</span> <span>{</span>
    <span>for</span> n <span>in</span> c <span>{</span>
        <span>if</span> <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span> != <span>Color</span><span>::</span><span>Orange</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>true</span>
<span>}</span>
</pre>
<h4>3.5.4. Cleaning up <a name="cleaning-up"></a></h4>
<p>If a candidate cycle fails either of the tests, we want to make sure to properly re-color the nodes.
There’s an additional heuristic that adds some nodes back to the roots list.</p>
<pre><span>unsafe</span> <span>fn</span> <span>refurbish</span><span>(</span><span>c</span><span>:</span> <span>&amp;</span><span>[</span><span>OpaqueGcPtr</span><span>]</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span>i<span>,</span> n<span>)</span> <span>in</span> c<span>.</span><span>iter</span><span>(</span><span>)</span><span>.</span><span>enumerate</span><span>(</span><span>)</span> <span>{</span>
        <span>match</span> <span>(</span>i<span>,</span> <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span><span>)</span> <span>{</span>
            <span>(</span><span>0</span><span>,</span> <span>Color</span><span>::</span><span>Orange</span><span>)</span> | <span>(</span>_<span>,</span> <span>Color</span><span>::</span><span>Purple</span><span>)</span> =&gt; <span>{</span>
                <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span> = <span>Color</span><span>::</span><span>Purple</span><span>;</span>
                <span>unsafe</span> <span>{</span>
                    <span>(</span><span>&amp;</span>raw <span>mut</span> <span>ROOTS</span><span>)</span><span>.</span><span>as_mut</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>.</span><span>push</span><span>(</span><span>*</span>n<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            _ =&gt; <span>{</span>
                <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span> = <span>Color</span><span>::</span><span>Black</span><span>;</span>
                <span>*</span><span>buffered</span><span>(</span><span>*</span>n<span>)</span> = <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<p>If a candidate cycle passes both tests, we need to free it and decrement any outgoing reference counts.
This is pretty straightforward:</p>
<pre><span>unsafe</span> <span>fn</span> <span>cyclic_decrement</span><span>(</span><span>m</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> <span>{</span>
    <span>if</span> <span>*</span><span>color</span><span>(</span>m<span>)</span> != <span>Color</span><span>::</span><span>Red</span> <span>{</span>
        <span>if</span> <span>*</span><span>color</span><span>(</span>m<span>)</span> == <span>Color</span><span>::</span><span>Orange</span> <span>{</span>
            <span>*</span><span>rc</span><span>(</span>m<span>)</span> -= <span>1</span><span>;</span>
            <span>*</span><span>crc</span><span>(</span>m<span>)</span> -= <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>decrement</span><span>(</span>m<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>


<span>unsafe</span> <span>fn</span> <span>free_cycle</span><span>(</span><span>c</span><span>:</span> <span>&amp;</span><span>[</span><span>OpaqueGcPtr</span><span>]</span><span>)</span> <span>{</span>
    <span>for</span> n <span>in</span> c <span>{</span>
        <span>*</span><span>color</span><span>(</span><span>*</span>n<span>)</span> = <span>Color</span><span>::</span><span>Red</span><span>;</span>
    <span>}</span>
    <span>for</span> n <span>in</span> c <span>{</span>
        <span>for_each_child</span><span>(</span><span>*</span>n<span>,</span> cyclic_decrement<span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> n <span>in</span> c <span>{</span>
        <span>free</span><span>(</span><span>*</span>n<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<h4>3.5.5. Misc helper functions <a name="misc-helper-functions"></a></h4>
<p>Before we put everything together, let’s briefly talk about some of the helper functions:</p>
<pre><span>unsafe</span> <span>fn</span> <span>color</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> -&gt; <span>&amp;</span><span>&#39;</span><span>a</span> <span>mut</span> <span>Color</span> <span>{</span>
    <span>&amp;</span><span>mut</span> <span>(</span><span>*</span>s<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>header<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span>color
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>rc</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> -&gt; <span>&amp;</span><span>&#39;</span><span>a</span> <span>mut</span> <span>usize</span> <span>{</span>
    <span>&amp;</span><span>mut</span> <span>(</span><span>*</span>s<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>header<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span>rc
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>buffered</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> -&gt; <span>&amp;</span><span>&#39;</span><span>a</span> <span>mut</span> <span>bool</span> <span>{</span>
    <span>&amp;</span><span>mut</span> <span>(</span><span>*</span>s<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>header<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span>buffered
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>semaphore</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>)</span> -&gt; <span>&amp;</span><span>&#39;</span><span>a</span> <span>Semaphore</span> <span>{</span>
    <span>&amp;</span><span>(</span><span>*</span>s<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>header<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span>semaphore
<span>}</span>

<span>fn</span> <span>acquire_permit</span><span>(</span><span>semaphore</span><span>:</span> <span>&amp;</span><span>&#39;</span><span>_</span> <span>Semaphore</span><span>)</span> -&gt; <span>SemaphorePermit</span><span>&lt;</span><span>&#39;</span><span>_</span><span>&gt;</span> <span>{</span>
    <span>loop</span> <span>{</span>
        <span>if</span> <span>let</span> <span>Ok</span><span>(</span>permit<span>)</span> = semaphore<span>.</span><span>try_acquire</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> permit<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>for_each_child</span><span>(</span><span>s</span><span>:</span> <span>OpaqueGcPtr</span><span>,</span> <span>visitor</span><span>:</span> <span>unsafe</span> <span>fn</span><span>(</span><span>OpaqueGcPtr</span><span>)</span><span>)</span> <span>{</span>
    <span>let</span> permit = <span>acquire_permit</span><span>(</span><span>semaphore</span><span>(</span>s<span>)</span><span>)</span><span>;</span>
    <span>(</span><span>*</span>s<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span>data<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span><span>visit_children</span><span>(</span>visitor<span>)</span><span>;</span>
    <span>drop</span><span>(</span>permit<span>)</span><span>;</span>
<span>}</span>
</pre>
<p>These are all pretty straightforward, but you may notice that we acquire a read lock on
the data for the <code>Gc</code> when we call <code>for_each_child</code>. I couldn’t find any mention of it in the
paper but it has the assumption that pointer store and loads are atomic.</p>
<p>The way this is implemented is not ideal as the permit is acquired for the lifetime of the
<code>visit_children</code> function. A better approach would be to collect all of the <code>OpaqueGcPtr</code>s into
a buffer and traverse them after releasing the permit.</p>
<h3>3.6. Bringing it all together <a name="bringing-it-all-together"></a></h3>
<p>Finally, we can write the last of our functions:</p>
<pre><span>unsafe</span> <span>fn</span> <span>process_cycles</span><span>(</span><span>)</span> <span>{</span>
    <span>free_cycles</span><span>(</span><span>)</span><span>;</span>
    <span>collect_cycles</span><span>(</span><span>)</span><span>;</span>
    <span>sigma_preparation</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>unsafe</span> <span>fn</span> <span>collect_cycles</span><span>(</span><span>)</span> <span>{</span>
    <span>mark_roots</span><span>(</span><span>)</span><span>;</span>
    <span>scan_roots</span><span>(</span><span>)</span><span>;</span>
    <span>collect_roots</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</pre>
<h2>4. Testing <a name="testing"></a></h2>
<p>Garbage Collection is very hard to properly test. Often times testing is done via metrics:
For example, there were x<sub>1</sub> allocations time t<sub>1</sub>, there were x<sub>2</sub> allocations
at time t<sub>2</sub>, t<sub>1</sub> &lt;  t<sub>2</sub> and x<sub>1</sub> &gt; x<sub>2</sub>
so the garbage collector did some work over t<sub>2</sub> -  t<sub>1</sub>.</p>
<p>Because we are building our garbage collector on top of a system that already supports reference
counted smart pointers, we can use an <code>Arc</code> to analyse the operation of our collection algorithms.
By analyzing the strong reference count of an <code>Arc</code> embedded in a garbage cyclical data structure,
we can determine that our cycle was properly destroyed if the strong reference count for the <code>Arc</code>
decreases.</p>
<p>We could also do this with our own <code>Gc</code> type, but as we have established only one thread can ever
read the reference count. Therefore, if we want to adapt our unit tests to include the collector
running in parallel, we cannot use them.</p>
<p>This is a pretty nice consequence of allowing <code>Arc</code> in our <code>Gc&lt;T&gt;</code>s, we can add a very simple unit
test to our code. It is insufficient amount of testing, but this article is already quite long, so
I will leave the rest up to you dear reader.</p>
<p>Consider the following structure:</p>
<img src="https://maplant.com/fig3.jpg" alt="A data structure with three nodes: A, B, C and Arc, with four edges: A-&gt;B, B-&gt;C, B-&gt;Arc, C-&gt;A"/>
<p>The following unit test replicates it:</p>
<pre><span>#<span>[</span>cfg<span>(</span>test<span>)</span><span>]</span></span>
<span>mod</span> test <span>{</span>
    <span>use</span> <span>super</span><span>::</span><span>*</span><span>;</span>
    <span>use</span> <span>crate</span><span>::</span>gc<span>::</span><span>*</span><span>;</span>
    <span>use</span> std<span>::</span>sync<span>::</span><span>Arc</span><span>;</span>

    <span>#<span>[</span>tokio<span>::</span>test<span>]</span></span>
    <span>async</span> <span>fn</span> <span>cycles</span><span>(</span><span>)</span> <span>{</span>
        <span>#<span>[</span>derive<span>(</span><span>Default</span><span>,</span> <span>Trace</span><span>)</span><span>]</span></span>
        <span>struct</span> <span>Cyclic</span> <span>{</span>
            next<span>:</span> <span>Option</span><span>&lt;</span><span>Gc</span><span>&lt;</span><span>Cyclic</span><span>&gt;</span><span>&gt;</span><span>,</span>
            out<span>:</span> <span>Option</span><span>&lt;</span><span>Arc</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span><span>&gt;</span><span>,</span>
        <span>}</span>

        <span>let</span> out_ptr = <span>Arc</span><span>::</span><span>new</span><span>(</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>let</span> a = <span>Gc</span><span>::</span><span>new</span><span>(</span><span>Cyclic</span><span>::</span><span>default</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>let</span> b = <span>Gc</span><span>::</span><span>new</span><span>(</span><span>Cyclic</span><span>::</span><span>default</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>let</span> c = <span>Gc</span><span>::</span><span>new</span><span>(</span><span>Cyclic</span><span>::</span><span>default</span><span>(</span><span>)</span><span>)</span><span>;</span>

        
        
        a<span>.</span><span>write</span><span>(</span><span>)</span><span>.</span><span>await</span><span>.</span>next = <span>Some</span><span>(</span>b<span>.</span><span>clone</span><span>(</span><span>)</span><span>)</span><span>;</span>
        b<span>.</span><span>write</span><span>(</span><span>)</span><span>.</span><span>await</span><span>.</span>next = <span>Some</span><span>(</span>c<span>.</span><span>clone</span><span>(</span><span>)</span><span>)</span><span>;</span>
        b<span>.</span><span>write</span><span>(</span><span>)</span><span>.</span><span>await</span><span>.</span>out = <span>Some</span><span>(</span>out_ptr<span>.</span><span>clone</span><span>(</span><span>)</span><span>)</span><span>;</span>
        c<span>.</span><span>write</span><span>(</span><span>)</span><span>.</span><span>await</span><span>.</span>next = <span>Some</span><span>(</span>a<span>.</span><span>clone</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>assert_eq</span><span>!</span><span>(</span><span>Arc</span><span>::</span><span>strong_count</span><span>(</span><span>&amp;</span>out_ptr<span>)</span><span>,</span> <span>2</span><span>)</span><span></span><span>;</span>

        <span>drop</span><span>(</span>a<span>)</span><span>;</span>
        <span>drop</span><span>(</span>b<span>)</span><span>;</span>
        <span>drop</span><span>(</span>c<span>)</span><span>;</span>
        <span>let</span> <span>mut</span> mutation_buffer = <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
        <span>unsafe</span> <span>{</span>
            <span>process_mutation_buffer</span><span>(</span><span>&amp;</span><span>mut</span> mutation_buffer<span>)</span><span>.</span><span>await</span><span>;</span>
            <span>process_cycles</span><span>(</span><span>)</span><span>;</span>
            <span>process_cycles</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>assert_eq</span><span>!</span><span>(</span><span>Arc</span><span>::</span><span>strong_count</span><span>(</span><span>&amp;</span>out_ptr<span>)</span><span>,</span> <span>1</span><span>)</span><span></span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<h2>Footnotes <a name="footnotes"></a></h2>










  
</div>
  </body>
</html>
