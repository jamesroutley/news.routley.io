<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://deno.com/blog/the-future-and-past-is-server-side-rendering">Original</a>
    <h1>The Future (and the Past) of the Web Is Server Side Rendering</h1>
    
    <div id="readability-page-1" class="page"><div><p>When servers were in
<a href="https://deno.com/blog/the-future-of-web-is-on-the-edge" rel="noopener noreferrer">Swiss basements</a>, all
they had to serve was static HTML. Maybe, if you were lucky, you got
<a href="https://i.cbc.ca/1.4206994.1500143738!/fileImage/httpImage/image.jpg_gen/derivatives/16x9_780/les-horribles-cernettes-25-year-anniversary-first-personal-photo-on-internet.jpg" rel="noopener noreferrer">an image</a>.</p>
<p>Now, a webpage can be a full-blown app, pulling in data from multiple sources,
doing on the fly manipulations, and allowing an end-user full interactivity.
This has greatly improved the utility of the web, but at the cost of size,
bandwidth, and speed. In the past 10 years,
<a href="https://almanac.httparchive.org/en/2021/page-weight" rel="noopener noreferrer">the median size for a desktop webpage</a>
has gone from 468 KB to 2284 KB, a 388.3% increase. For mobile, this jump is
even more staggering — 145 KB to 2010 KB — a whopping 1288.1% increase.</p>
<p>That’s a lot of weight to ship over a network, especially for mobile. As a
result, users experience terrible UX, slow loading times, and a lack of
interactivity until everything is rendered. But all that code is necessary to
make our sites work the way we want.</p>
<p>This is the problem with being a frontend dev today. What started out fun for
frontend developers, building shit-hot sites with all the bells and whistles,
has kinda turned into not fun. We&#39;re now fighting different browsers to support,
slow networks to ship code over, and intermittent, mobile connections.
Supporting all these permutations is a giant headache.</p>
<p>How do we square this circle? By heading back to the server (Swiss basement not
required).</p>
<h2 id="a-brief-tour-of-how-we-got-here"><a aria-hidden="true" tabindex="-1" href="#a-brief-tour-of-how-we-got-here"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A brief tour of how we got here</h2><p>In the beginning there was PHP, and lo it was great, as long as you liked
question marks.</p>
<p>The web started as a network of static HTML, but CGI scripting languages like
Perl and PHP, which allow developers to render backend data sources into HTML,
introduced the idea that websites could be dynamic based on the visitor.</p>
<p>This meant developers were able to build dynamic sites and serve real time data,
or data from a database, to an end user (as long as their #, !, $, and ? keys
were working).</p>
<p><img src="https://deno.com/the-future-and-past-is-server-side-rendering/pooh-meme.jpg" alt="Pooh on writing good php."/></p>
<p>PHP worked on the server because servers were the powerful part of the network.
You could grab your data and render the HTML on the server, then ship it all to
a browser. The browser&#39;s job was limited — simply interpret the document and
show the page. This worked well, but this solution was all about showing
information, not interacting with it.</p>
<p>Then two things happened: JavaScript got good and browsers got powerful.</p>
<p>This meant we could do a ton of fun things directly on the client. Why bother
rendering everything on the server first and shipping that when you could just
pipe a basic HTML page to the browser along with some JS and let the client take
care of it all?</p>
<p>This was the birth of single page applications
(<a href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener noreferrer">SPAs</a>) and client-side
rendering
(<a href="https://web.dev/rendering-on-the-web/#client-side-rendering-csr" rel="noopener noreferrer">CSR</a>).</p>
<h2 id="client-side-rendering"><a aria-hidden="true" tabindex="-1" href="#client-side-rendering"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Client-side rendering</h2><p>In CSR, also known as dynamic rendering, the code runs primarily on the
client-side, the user&#39;s browser. The client&#39;s browser downloads the necessary
HTML, JavaScript, and other assets, and then runs the code to render the UI.</p>
<p><img src="https://deno.com/the-future-and-past-is-server-side-rendering/walmart-csr-diagram.png" alt="A diagram of client-side rendering"/>
<em><a href="https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8" rel="noopener noreferrer">(source: Walmart)</a></em></p>
<p>The benefits of this approach are two-fold:</p>
<ul>
<li><strong>Great user experience</strong>. If you have a wicked-fast network and can get the
bundle and data downloaded quickly then, once everything is in place, you’ll
have a super-speedy site. You don’t have to go back to the server for more
requests, so every page change or data change happens immediately.</li>
<li><strong>Caching</strong>. Because you aren’t using a server, you can cache the core HTML
and JS bundles on a CDN. This means they can be quickly accessed by users and
keeps costs low for the company.</li>
</ul>
<p>As the web got more interactive (thank you JavaScript and browsers), client-side
rendering and SPAs became default. The web felt fast and furious… especially if
you were on a desktop, using a popular browser, with a wired internet
connection.</p>
<p>For everyone else, the web slowed to a crawl. As the web matured, it became
available on more devices and on different connections. Managing SPAs to ensure
a consistent user experience became harder. Developers had to not only make sure
a site rendered the same on IE as it did in Chrome, but also consider how it
would render on a phone on a bus in the middle of a busy city. If your data
connection couldn’t download that bundle of JS from the cache, you had no site.</p>
<p>How can we <em>easily</em> ensure consistency across a wide range of devices and
bandwidths? The answer: heading back to the server.</p>
<h2 id="server-side-rendering"><a aria-hidden="true" tabindex="-1" href="#server-side-rendering"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Server-side rendering</h2><p>There are many benefits to moving the work a browser does to render a website to
the server:</p>
<ul>
<li><strong>Performance is higher</strong> with the server because the HTML is already
generated and ready to be displayed when the page is loaded.</li>
<li><strong>Compatibility is higher</strong> with server-side rendering because, again, the
HTML is generated on the server, so it is not dependent on the end browser.</li>
<li><strong>Complexity</strong> is lower because the server does most of the work of generating
the HTML so can often be implemented with a simpler and smaller codebase.</li>
</ul>
<p>With SSR, we do everything on the server:</p>
<p><img src="https://deno.com/the-future-and-past-is-server-side-rendering/walmart-ssr-diagram.png" alt="A diagram of server-side rendering"/></p>
<p><em><a href="https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8" rel="noopener noreferrer">(source: Walmart)</a></em></p>
<p>There are many
<a href="https://en.wikipedia.org/wiki/Isomorphic_JavaScript" rel="noopener noreferrer">isomorphic JavaScript</a>
frameworks that support SSR: they render HTML on the server with JavaScript and
ship that HTML bundled with JavaScript for interactivity to the client. Writing
isomorphic JavaScript means a smaller code base that is easier to reason about.</p>
<p>Some of these frameworks, such as NextJS and Remix, are built on React.
Out-of-the-box, React is a client-side rendering framework, but it does have SSR
capabilities, using
<a href="https://reactjs.org/docs/react-dom-server.html#rendertostring" rel="noopener noreferrer"><code>renderToString</code></a>
(and other recommended versions such as
<a href="https://reactjs.org/docs/react-dom-server.html#rendertopipeablestream" rel="noopener noreferrer"><code>renderToPipeableStream</code></a>,
<a href="https://reactjs.org/docs/react-dom-server.html#rendertoreadablestream" rel="noopener noreferrer"><code>renderToReadableStream</code></a>,
and more). NextJS and Remix offer higher abstractions over <code>renderToString</code>,
making it easy to build SSR sites.</p>
<p>SSR does come with tradeoffs. We can control more and ship faster, but the
limitation with SSR is that for interactive websites, you still need to send JS,
which is combined with the static HTML in a process called
<a href="https://en.wikipedia.org/wiki/Hydration_(web_development)" rel="noopener noreferrer">&#34;hydration&#34;</a>.</p>
<p>Sending JS for hydration runs into complexity issues:</p>
<ul>
<li>Do we send all JS on every request? Or do we base it on the route?</li>
<li>Is hydration done top-down, and how expensive is that?</li>
<li>How does a dev organize the code base?</li>
</ul>
<p>On the client side, large bundles can lead to memory issues and the “Why is
nothing happening?” feeling for the user as all the HTML is there, but you can’t
actually use it until it hydrates.</p>
<p>One approach that we like here at Deno is
<a href="https://jasonformat.com/islands-architecture/" rel="noopener noreferrer">islands architecture</a>, as in, in
a sea of static SSR&#39;d HTML, there are <strong>islands of interactivity</strong>. (You&#39;ve
probably picked up that <a href="https://fresh.deno.dev/" rel="noopener noreferrer">Fresh</a>, our modern web
framework that sends zero JavaScript to the client by default, uses islands.)</p>
<p>What you want to happen with SSR is for the HTML to be served and rendered
quickly, then each of the individual components to be served and rendered
independently. This way you are sending smaller chunks of JavaScript and doing
smaller chunks of rendering on the client.</p>
<p>This is how islands work.</p>
<p><img src="https://deno.com/the-future-and-past-is-server-side-rendering/merch-islands-example.png" alt="Example of islands on our merch store."/></p>
<p>Islands aren’t progressively rendered, they are separately rendered. The
rendering of an island isn’t dependent on the rendering of any previous
component, and updates to other parts of the virtual DOM don’t lead to a
re-render of any individual island.</p>
<p>Islands keep the benefits of overall SSR but without the tradeoff of big
hydration bundles. Great success.</p>
<h2 id="how-to-render-from-the-server"><a aria-hidden="true" tabindex="-1" href="#how-to-render-from-the-server"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How to render from the server</h2><p>Not all server-side rendering is equal. There’s server side rendering, then
there’s Server-Side Rendering.</p>
<p>Here we’re going to take you through a few different examples of rendering from
a server in Deno. We’ll port Jonas Galvez’s great
<a href="https://hire.jonasgalvez.com.br/2022/apr/30/a-gentle-introduction-to-ssr/" rel="noopener noreferrer">introduction to server rendering</a>
to Deno, <a href="https://deno.land/x/oak" rel="noopener noreferrer">Oak</a>, and
<a href="https://handlebarsjs.com/" rel="noopener noreferrer">Handlebars</a>, with three variations of the same app:</p>
<ol>
<li>A straightforward, templated, server-rendered HTML example without any
client-side interaction
(<a href="https://github.com/denoland/deno-ssr-examples/tree/main/ssr-example-01" rel="noopener noreferrer">source</a>)</li>
<li>An initially server-side rendered example that is then updated client-side
(<a href="https://github.com/denoland/deno-ssr-examples/tree/main/ssr-example-02" rel="noopener noreferrer">source</a>)</li>
<li>A fully server side rendered version with isomorphic JS and a shared data
model
(<a href="https://github.com/denoland/deno-ssr-examples/tree/main/ssr-example-03" rel="noopener noreferrer">source</a>)</li>
</ol>
<p><a href="https://github.com/denoland/deno-ssr-examples" rel="noopener noreferrer">View the source of all examples here.</a></p>
<p>It is this third version that is SSR in the truest sense. We’ll have a single
JavaScript file that will be used by both the server and the client, and any
updates to the list will be made by updating the data model.</p>
<p>But first, let’s do some templating. In this first example, all we’re going to
do is render a list. Here is the main server.ts:</p>
<div><pre><span>import</span> <span>{</span> Application<span>,</span> Router <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/oak@v11.1.0/mod.ts&#34;</span><span>;</span>
<span>import</span> <span>{</span> Handlebars <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/handlebars@v0.9.0/mod.ts&#34;</span><span>;</span>

<span>const</span> dinos <span>=</span> <span>[</span><span>&#34;Allosaur&#34;</span><span>,</span> <span>&#34;T-Rex&#34;</span><span>,</span> <span>&#34;Deno&#34;</span><span>]</span><span>;</span>
<span>const</span> handle <span>=</span> <span>new</span> <span>Handlebars</span><span>(</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>async</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  context<span>.</span>response<span>.</span>body <span>=</span> <span>await</span> handle<span>.</span><span>renderView</span><span>(</span><span>&#34;index&#34;</span><span>,</span> <span>{</span> dinos<span>:</span> dinos <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> app <span>=</span> <span>new</span> <span>Application</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>await</span> app<span>.</span><span>listen</span><span>(</span><span>{</span> port<span>:</span> <span>8000</span> <span>}</span><span>)</span><span>;</span></pre></div><p>Note we don’t need a <code>client.html</code>. Instead, with Handlebars we create the
following file structure:</p>
<pre><code>|--Views
|    |--Layouts
|    |     |
|    |     |--main.hbs
|    |
|    |--Partials
|    |
|    |--index.hbs</code></pre><p><code>main.hbs</code> contains your main HTML layout with a placeholder for our
<code>{{{body}}}</code>:</p>
<pre><code>&lt;html lang=&#34;en&#34;&gt;
 &lt;head&gt;
   &lt;meta charset=&#34;UTF-8&#34; /&gt;
   &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34; /&gt;
   &lt;title&gt;Dinosaurs&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;div&gt;
     &lt;!--content--&gt;
     {{{body}}}
   &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre><p>The <code>{{{body}}}</code> comes from <code>index.hbs</code>. In this case it is using Handlebars
syntax to iterate through our list:</p>
<pre><code>&lt;ul&gt;
 {{#each dinos}}
   &lt;li&gt;{{this}}&lt;/li&gt;
 {{/each}}
&lt;/ul&gt;</code></pre><p>So what happens is:</p>
<ul>
<li>The root gets called by the client</li>
<li>The server passes the dinos list to the Handlebars renderer</li>
<li>Each element of that list is rendered within the list within <code>index.hbs</code></li>
<li>The whole list from index.hbs is rendered within <code>main.hbs</code></li>
<li>All this HTML is sent in the response body to the client</li>
</ul>
<p>Server-side rendering! Well, kinda. While it <em>is</em> rendered on the server, this
is non-interactive.</p>
<p>Let’s add some interactivity to the list — the ability to add an item. This is a
classic client-side rendering use-case, basically an SPA. The server doesn’t
change much, with the exception of the addition of an /add endpoint to add an
item to the list:</p>
<div><pre><span>import</span> <span>{</span> Application<span>,</span> Router <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/oak@v11.1.0/mod.ts&#34;</span><span>;</span>
<span>import</span> <span>{</span> Handlebars <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/handlebars@v0.9.0/mod.ts&#34;</span><span>;</span>

<span>const</span> dinos <span>=</span> <span>[</span><span>&#34;Allosaur&#34;</span><span>,</span> <span>&#34;T-Rex&#34;</span><span>,</span> <span>&#34;Deno&#34;</span><span>]</span><span>;</span>
<span>const</span> handle <span>=</span> <span>new</span> <span>Handlebars</span><span>(</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>async</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  context<span>.</span>response<span>.</span>body <span>=</span> <span>await</span> handle<span>.</span><span>renderView</span><span>(</span><span>&#34;index&#34;</span><span>,</span> <span>{</span> dinos<span>:</span> dinos <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>post</span><span>(</span><span>&#34;/add&#34;</span><span>,</span> <span>async</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>{</span> value <span>}</span> <span>=</span> <span>await</span> context<span>.</span>request<span>.</span><span>body</span><span>(</span><span>{</span> type<span>:</span> <span>&#34;json&#34;</span> <span>}</span><span>)</span><span>;</span>
  <span>const</span> <span>{</span> item <span>}</span> <span>=</span> <span>await</span> value<span>;</span>
  dinos<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
  context<span>.</span>response<span>.</span>status <span>=</span> <span>200</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> app <span>=</span> <span>new</span> <span>Application</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>await</span> app<span>.</span><span>listen</span><span>(</span><span>{</span> port<span>:</span> <span>8000</span> <span>}</span><span>)</span><span>;</span></pre></div><p>The Handlebars code changes substantially this time, though. We still have the
Handlebars template for generating the HTML list, but <code>main.hbs</code> includes its
own JavaScript to deal with the <code>Add</code> button: an <code>EventListener</code> event bound to
the button that will:</p>
<ul>
<li><code>POST</code> the new list item to the <code>/add</code> endpoint</li>
<li>Add the item to the HTML list</li>
</ul>
<pre><code>[...]
  &lt;input /&gt;
  &lt;button&gt;Add&lt;/button&gt;
 &lt;/body&gt;
&lt;/html&gt;

&lt;script&gt;
 document.querySelector(&#34;button&#34;).addEventListener(&#34;click&#34;, async () =&gt; {
   const item = document.querySelector(&#34;input&#34;).value;
   const response = await fetch(&#34;/add&#34;, {
     method: &#34;POST&#34;,
     headers: {
       &#34;Content-Type&#34;: &#34;application/json&#34;,
     },
     body: JSON.stringify({ item }),
   });
   const status = await response.status;
   if (status === 200) {
     const li = document.createElement(&#34;li&#34;);
     li.innerText = item;
     document.querySelector(&#34;ul&#34;).appendChild(li);
     document.querySelector(&#34;input&#34;).value = &#34;&#34;;
   }
 });
&lt;/script&gt;</code></pre><p>But this isn’t server-side rendering in the true sense. With SSR you are running
the same isomorphic JS on the client and the server side, and it just acts
differently depending on where it’s running. In the above examples, we have JS
running on the server and client, but they are working independently.</p>
<p>So on to true SSR. We’re going to do away with Handlebars and templating and
instead create a DOM that we’re going to update with our Dinosaurs. We’ll have
three files. First, <code>server.ts</code> again:</p>
<div><pre><span>import</span> <span>{</span> Application <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/oak@v11.1.0/mod.ts&#34;</span><span>;</span>
<span>import</span> <span>{</span> Router <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/oak@v11.1.0/mod.ts&#34;</span><span>;</span>
<span>import</span> <span>{</span> DOMParser <span>}</span> <span>from</span> <span>&#34;https://deno.land/x/deno_dom@v0.1.36-alpha/deno-dom-wasm.ts&#34;</span><span>;</span>
<span>import</span> <span>{</span> render <span>}</span> <span>from</span> <span>&#34;./client.js&#34;</span><span>;</span>

<span>const</span> html <span>=</span> <span>await</span> Deno<span>.</span><span>readTextFile</span><span>(</span><span>&#34;./client.html&#34;</span><span>)</span><span>;</span>
<span>const</span> dinos <span>=</span> <span>[</span><span>&#34;Allosaur&#34;</span><span>,</span> <span>&#34;T-Rex&#34;</span><span>,</span> <span>&#34;Deno&#34;</span><span>]</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>&#34;/client.js&#34;</span><span>,</span> <span>async</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>await</span> context<span>.</span><span>send</span><span>(</span><span>{</span>
    root<span>:</span> Deno<span>.</span><span>cwd</span><span>(</span><span>)</span><span>,</span>
    index<span>:</span> <span>&#34;client.js&#34;</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> document <span>=</span> <span>new</span> <span>DOMParser</span><span>(</span><span>)</span><span>.</span><span>parseFromString</span><span>(</span>
    <span>&#34;&lt;!DOCTYPE html&gt;&#34;</span><span>,</span>
    <span>&#34;text/html&#34;</span><span>,</span>
  <span>)</span><span>;</span>
  <span>render</span><span>(</span>document<span>,</span> <span>{</span> dinos <span>}</span><span>)</span><span>;</span>
  context<span>.</span>response<span>.</span>type <span>=</span> <span>&#34;text/html&#34;</span><span>;</span>
  context<span>.</span>response<span>.</span>body <span>=</span> <span><span>`</span><span><span>${</span>document<span>.</span>body<span>.</span>innerHTML<span>}</span></span><span><span>${</span>html<span>}</span></span><span>`</span></span><span>;</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>&#34;/data&#34;</span><span>,</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  context<span>.</span>response<span>.</span>body <span>=</span> dinos<span>;</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>post</span><span>(</span><span>&#34;/add&#34;</span><span>,</span> <span>async</span> <span>(</span>context<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>{</span> value <span>}</span> <span>=</span> <span>await</span> context<span>.</span>request<span>.</span><span>body</span><span>(</span><span>{</span> type<span>:</span> <span>&#34;json&#34;</span> <span>}</span><span>)</span><span>;</span>
  <span>const</span> <span>{</span> item <span>}</span> <span>=</span> <span>await</span> value<span>;</span>
  dinos<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
  context<span>.</span>response<span>.</span>status <span>=</span> <span>200</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> app <span>=</span> <span>new</span> <span>Application</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>await</span> app<span>.</span><span>listen</span><span>(</span><span>{</span> port<span>:</span> <span>8000</span> <span>}</span><span>)</span><span>;</span></pre></div><p>A lot has changed this time. Firstly, again, we have some new endpoints:</p>
<ul>
<li>A GET endpoint that’s going to serve our <code>client.js</code> file</li>
<li>A GET endpoint that’s going to serve our data</li>
</ul>
<p>But there is also a big change in our root endpoint. Now, we are creating a DOM
document object using <code>DOMParser</code> from
<a href="https://deno.land/x/deno_dom" rel="noopener noreferrer"><code>deno_dom</code></a>. The <code>DOMParser</code> module works like
<code>ReactDOM</code>, allowing us to recreate the DOM on the server. We’re then using the
document created to render the notes list, but instead of using the handlebars
templating, now we’re getting this render function from a new file, <code>client.js</code>:</p>
<div><pre><span>let</span> isFirstRender <span>=</span> <span>true</span><span>;</span>


<span>function</span> <span>sanitizeHtml</span><span>(</span><span>text</span><span>)</span> <span>{</span>
  <span>return</span> text
    <span>.</span><span>replace</span><span>(</span><span><span>/</span><span>&amp;</span><span>/</span><span>g</span></span><span>,</span> <span>&#34;&amp;amp;&#34;</span><span>)</span>
    <span>.</span><span>replace</span><span>(</span><span><span>/</span><span>&lt;</span><span>/</span><span>g</span></span><span>,</span> <span>&#34;&amp;lt;&#34;</span><span>)</span>
    <span>.</span><span>replace</span><span>(</span><span><span>/</span><span>&gt;</span><span>/</span><span>g</span></span><span>,</span> <span>&#34;&amp;gt;&#34;</span><span>)</span>
    <span>.</span><span>replace</span><span>(</span><span><span>/</span><span>&#34;</span><span>/</span><span>g</span></span><span>,</span> <span>&#34;&amp;quot;&#34;</span><span>)</span>
    <span>.</span><span>replace</span><span>(</span><span><span>/</span><span>&#39;</span><span>/</span><span>g</span></span><span>,</span> <span>&#34;&amp;#039;&#34;</span><span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>async</span> <span>function</span> <span>render</span><span>(</span><span>document<span>,</span> dinos</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>isFirstRender<span>)</span> <span>{</span>
    <span>const</span> jsonResponse <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#34;http://localhost:8000/data&#34;</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>jsonResponse<span>.</span>ok<span>)</span> <span>{</span>
      <span>const</span> jsonData <span>=</span> <span>await</span> jsonResponse<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
      <span>const</span> dinos <span>=</span> jsonData<span>;</span>
      <span>let</span> html <span>=</span> <span>&#34;&lt;html&gt;&lt;ul&gt;&#34;</span><span>;</span>
      <span>for</span> <span>(</span><span>const</span> item <span>of</span> dinos<span>)</span> <span>{</span>
        html <span>+=</span> <span><span>`</span><span>&lt;li&gt;</span><span><span>${</span><span>sanitizeHtml</span><span>(</span>item<span>)</span><span>}</span></span><span>&lt;/li&gt;</span><span>`</span></span><span>;</span>
      <span>}</span>
      html <span>+=</span> <span>&#34;&lt;/ul&gt;&lt;input&gt;&#34;</span><span>;</span>
      html <span>+=</span> <span>&#34;&lt;button&gt;Add&lt;/button&gt;&lt;/html&gt;&#34;</span><span>;</span>
      document<span>.</span>body<span>.</span>innerHTML <span>=</span> html<span>;</span>
      isFirstRender <span>=</span> <span>false</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      document<span>.</span>body<span>.</span>innerHTML <span>=</span> <span>&#34;&lt;html&gt;&lt;p&gt;Something went wrong.&lt;/p&gt;&lt;/html&gt;&#34;</span><span>;</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>let</span> html <span>=</span> <span>&#34;&lt;ul&gt;&#34;</span><span>;</span>
    <span>for</span> <span>(</span><span>const</span> item <span>of</span> dinos<span>)</span> <span>{</span>
      html <span>+=</span> <span><span>`</span><span>&lt;li&gt;</span><span><span>${</span><span>sanitizeHtml</span><span>(</span>item<span>)</span><span>}</span></span><span>&lt;/li&gt;</span><span>`</span></span><span>;</span>
    <span>}</span>
    html <span>+=</span> <span>&#34;&lt;/ul&gt;&#34;</span><span>;</span>
    document<span>.</span><span>querySelector</span><span>(</span><span>&#34;ul&#34;</span><span>)</span><span>.</span>outerHTML <span>=</span> html<span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>function</span> <span>addEventListeners</span><span>(</span><span>)</span> <span>{</span>
  document<span>.</span><span>querySelector</span><span>(</span><span>&#34;button&#34;</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;click&#34;</span><span>,</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> item <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>&#34;input&#34;</span><span>)</span><span>.</span>value<span>;</span>
    <span>const</span> dinos <span>=</span> Array<span>.</span><span>from</span><span>(</span>
      document<span>.</span><span>querySelectorAll</span><span>(</span><span>&#34;li&#34;</span><span>)</span><span>,</span>
      <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> e<span>.</span>innerText<span>,</span>
    <span>)</span><span>;</span>
    dinos<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#34;/add&#34;</span><span>,</span> <span>{</span>
      <span>method</span><span>:</span> <span>&#34;POST&#34;</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span>
        <span>&#34;Content-Type&#34;</span><span>:</span> <span>&#34;application/json&#34;</span><span>,</span>
      <span>}</span><span>,</span>
      <span>body</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span> item <span>}</span><span>)</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>response<span>.</span>ok<span>)</span> <span>{</span>
      <span>render</span><span>(</span>document<span>,</span> dinos<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      
      console<span>.</span><span>error</span><span>(</span><span>&#34;Something went wrong.&#34;</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></pre></div><p>This <code>client.js</code> file is available to both the server and the client — it is the
isomorphic JavaScript we need for true SSR. We’re using the <code>render</code> function
within the server to render the HTML initially, but then we&#39;re also using
<code>render</code> within the client to render updates.</p>
<p>Also, on each call, the data is pulled directly from the server. Data is added
to the data model using the <code>/add</code> endpoint. Compared to the second example,
where the client appends the item to the list directly in the HTML, in this
example all the data is routed through the server.</p>
<p>The JS from <code>client.js</code> is also used directly on the client, in <code>client.html</code>:</p>
<div><pre><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>&#34;</span>module<span>&#34;</span></span><span>&gt;</span></span><span><span>
  <span>import</span> <span>{</span> render<span>,</span> addEventListeners <span>}</span> <span>from</span> <span>&#34;./client.js&#34;</span><span>;</span>
  <span>await</span> <span>render</span><span>(</span>document<span>)</span><span>;</span>
  <span>addEventListeners</span><span>(</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span></pre></div><p>When the client calls <code>client.js</code> for the first time, the HTML becomes hydrated,
where <code>client.js</code> calls the <code>/data</code> endpoint to get the data needed for future
renders. Hydration can get slow and complex for larger SSR pages (and where
<a href="https://fresh.deno.dev/docs/concepts/islands" rel="noopener noreferrer">islands</a> can really help).</p>
<p>This is how SSR works. You have:</p>
<ul>
<li>DOM recreated on the server</li>
<li>isomorphic JS available to both the server and the client to render data in
either, and a hydration set on the initial load on the client to grab all the
data needed to make the app fully interactive for the user</li>
</ul>
<h2 id="simplifying-a-complex-web-with-ssr"><a aria-hidden="true" tabindex="-1" href="#simplifying-a-complex-web-with-ssr"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Simplifying a complex web with SSR</h2><p>We&#39;re building complex apps for every screen size and every bandwidth. People
might be using your site on a train in a tunnel. The best way to ensure a
consistent experience across all these scenarios, while keeping your code base
small and easy to reason about is SSR.</p>
<p>Performant frameworks that care about user experience will send exactly what&#39;s
needed to the client, and nothing more. To minimize latency even more, deploy
your SSR apps close to your users at the edge. You can do all of this today with
<a href="https://fresh.deno.dev" rel="noopener noreferrer">Fresh</a> and <a href="https://deno.com/deploy" rel="noopener noreferrer">Deno Deploy</a>.</p>
<p><em>Stuck? Come get your questions answered in
<a href="https://discord.gg/deno" rel="noopener noreferrer">our Discord</a>.</em></p>
</div></div>
  </body>
</html>
