<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.nelhage.com/post/regex-crosswords-z3/">Original</a>
    <h1>Solving Regex Crosswords with Z3</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>For a while now, Iâ€™ve been fascinated by <a href="https://microsoft.github.io/z3guide/">Z3</a> and by <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solving</a> more broadly. While on pat leave recently, I was reminded of the existence of <a href="https://regexle.com/">regular-expression crossword puzzles</a>, and allowed myself to get nerdsniped by writing a Z3-backed solver.</p>
<p>I expected to spend perhaps an afternoon cranking out a quick solver; I ended up getting sucked into understanding and debugging Z3 performance, and learning far more about Z3 and about SMT than I expected. In this post, Iâ€™ll describe my approach and my initial solver, and then dive into some of the improvements and variations I explored.</p>
<p>All of my code is <a href="https://github.com/nelhage/nelhage-sandbox/tree/main/regexle">available on github</a>, if you want to follow along or check out my final results.</p>
<h2 id="regular-expression-crosswords">Regular expression crosswordsÂ <a href="#regular-expression-crosswords"><i>	ğŸ”—ï¸</i></a> </h2>
<p>To briefly recap: A regular-expression crossword consists of a grid of (unknown) characters, which are to-be-determined. These characters are constrained by a set of given <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>, which must match a given row or column, once filled in. I chose to solve the <a href="https://regexle.com/">regexle</a> variant, specifically, which uses a hexagonal grid, but most of my code would readily adapt to other variants.</p>
<h2 id="regexes-as-dfas">Regexes as DFAsÂ <a href="#regexes-as-dfas"><i>	ğŸ”—ï¸</i></a> </h2>
<p>In order to solve the puzzle with a constraint solver like Z3, we need to find a way to encode the constraint â€œ<em>this</em> sequence of characters matches <em>this</em> regular expression,â€ and then just assert all of the clues, and ask for a grid that satisfies all the constraints.</p>
<p>My immediate first thought was to rely on the fact that a regular expression describes a <a href="https://en.wikipedia.org/wiki/Regular_language">regular language</a><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, and thus can be recognized using a deterministic finite automaton. Thus, I can encode a regular expression into a DFA, and then express regex matching in Z3 in terms of its transition function<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>That is, if we have a three-character string <code>S = [c0, c1, c2]</code>, and we have the transition table <code>T : State Ã— Char â†’ State</code> for our regex, we can express â€œthe regex matches Sâ€ as something like:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>state_0 <span>=</span> init_state
</span></span><span><span>state_1 <span>=</span> T(state_0, c0)
</span></span><span><span>state_2 <span>=</span> T(state_1, c1)
</span></span><span><span>state_3 <span>=</span> T(state_2, c2)
</span></span><span><span><span>assert</span>(state_3 <span>in</span> accept_states)
</span></span></code></pre></div><h2 id="turning-a-regular-expression-into-a-dfa">Turning a regular expression into a DFAÂ <a href="#turning-a-regular-expression-into-a-dfa"><i>	ğŸ”—ï¸</i></a> </h2>
<p>With a bit of searching, I discovered <a href="https://qntm.org/">qntm</a>â€™s <a href="https://github.com/qntm/greenery">greenery library</a>, which was pleasingly exactly what I was looking for â€“ a relatively straightforward Python library for manipulating regular expressions, including transforming back and forth between regex syntax and DFAs (which it calls <a href="https://github.com/qntm/greenery?tab=readme-ov-file#fsm">FSMs</a>). It will build an FSM for us, and in general it is pleasingly straightforward, optimized for simplicity, ease-of-use, and experimentation instead of raw performance, which is just fine for us â€“ weâ€™re going to make Z3 do all the heavy lifting.</p>
<p>One complication is that <code>greenery</code> handles regular expressions over arbitrary Unicode characters; in order to avoid enormous lookup tables, it represents transitions in terms of character ranges, which I found slightly more annoying to work with. For this project, Iâ€™m willing to assume an alphabet of English letters (A-Z), so I wrote a helper to translate <code>greenery</code>â€™s structure into a flat <code>numpy</code> transition table:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>ALPHABET <span>=</span> string<span>.</span>ascii_uppercase
</span></span><span><span>
</span></span><span><span><span>def</span> <span>flatten_fsm</span>(fsm):
</span></span><span><span>    nstate <span>=</span> len(fsm<span>.</span>states)
</span></span><span><span>    nvocab <span>=</span> len(ALPHABET)
</span></span><span><span>
</span></span><span><span>    <span>assert</span> fsm<span>.</span>states <span>==</span> set(range(nstate))
</span></span><span><span>    state_map <span>=</span> np<span>.</span>full((nstate, nvocab), <span>-</span><span>1</span>, dtype<span>=</span>np<span>.</span>int32)
</span></span><span><span>    <span>for</span> st, map <span>in</span> fsm<span>.</span>map<span>.</span>items():
</span></span><span><span>        <span>for</span> i, c <span>in</span> enumerate(ALPHABET):
</span></span><span><span>            <span>for</span> cc, dst <span>in</span> map<span>.</span>items():
</span></span><span><span>                <span>if</span> cc<span>.</span>accepts(c):
</span></span><span><span>                    state_map[st, i] <span>=</span> dst
</span></span><span><span>                    <span>break</span>
</span></span><span><span>    <span>return</span> state_map
</span></span></code></pre></div><p>I also defined a small dataclass to bundle together various representations and analysis for a single regular expression:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>@dataclass</span>
</span></span><span><span><span>class</span> <span>Regex</span>:
</span></span><span><span>    pattern: str
</span></span><span><span>    parsed: greenery<span>.</span>Pattern
</span></span><span><span>
</span></span><span><span>    <span># 2d: (state, vocab) -&gt; new state</span>
</span></span><span><span>    transition: np<span>.</span>ndarray
</span></span><span><span>    <span># 1d: state -&gt; bool</span>
</span></span><span><span>    accept: np<span>.</span>ndarray
</span></span><span><span>
</span></span><span><span>    <span>@classmethod</span>
</span></span><span><span>    <span>def</span> <span>from_pattern</span>(cls, pattern: str):
</span></span><span><span>        parsed <span>=</span> greenery<span>.</span>parse(pattern)
</span></span><span><span>        fsm <span>=</span> parsed<span>.</span>to_fsm()<span>.</span>reduce()
</span></span><span><span>
</span></span><span><span>        transition <span>=</span> flatten_fsm(fsm)
</span></span><span><span>        nstate <span>=</span> transition<span>.</span>shape[<span>0</span>]
</span></span><span><span>        accept <span>=</span> np<span>.</span>zeros((nstate,), bool)
</span></span><span><span>        <span>for</span> st <span>in</span> fsm<span>.</span>finals:
</span></span><span><span>            accept[st] <span>=</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>        <span>return</span> cls(
</span></span><span><span>            pattern<span>=</span>pattern,
</span></span><span><span>            parsed<span>=</span>parsed,
</span></span><span><span>            transition<span>=</span>transition,
</span></span><span><span>            accept<span>=</span>accept,
</span></span><span><span>        )
</span></span></code></pre></div><h2 id="mapping-into-z3">Mapping into Z3Â <a href="#mapping-into-z3"><i>	ğŸ”—ï¸</i></a> </h2>
<p>In order to put the pieces together, we need to teach Z3 about the transition functions for each clue, define Z3 variables for each character in our grid, and then add appropriate constraints on the characters using the relevant transition functions.</p>
<p>I chose to represent both states and characters as integers (adding assertions to ensure that they were in-range), since that seemed simplest. Then, we need to encode the transition function relationship, between states and characters.</p>
<p>Z3 supports <a href="https://microsoft.github.io/z3guide/docs/logic/Uninterpreted-functions-and-constants">function types</a>, which can be declared and manipulated in expressions and assertions. Thus, I declared a function of the appropriate type, and informed Z3 of the transition table using an assertion for each entry in the transition table:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>build_func</span>(solv: z3<span>.</span>Solver, clue: Clue):
</span></span><span><span>    ctx <span>=</span> solv<span>.</span>ctx
</span></span><span><span>    state_func <span>=</span> z3<span>.</span>Function(
</span></span><span><span>        clue<span>.</span>name <span>+</span> <span>&#34;_trans&#34;</span>,
</span></span><span><span>        z3<span>.</span>IntSort(ctx),
</span></span><span><span>        z3<span>.</span>IntSort(ctx),
</span></span><span><span>        z3<span>.</span>IntSort(ctx),
</span></span><span><span>    )
</span></span><span><span>    pat <span>=</span> clue<span>.</span>pattern
</span></span><span><span>
</span></span><span><span>    <span>for</span> (state, char), next_state <span>in</span> pat<span>.</span>all_transitions():
</span></span><span><span>        solv<span>.</span>add(state_func(state, char) <span>==</span> next_state)
</span></span><span><span>
</span></span><span><span>    <span>return</span> state_func
</span></span></code></pre></div><p>Given that definition, and given a string (represented as a list of characters), we can easily express the â€œregex matchingâ€ constraint:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>assert_matches</span>(solv: z3<span>.</span>Solver, clue: Clue, chars: list[z3<span>.</span>AstRef]):
</span></span><span><span>    state_func <span>=</span> self<span>.</span>build_func(solv, clue)
</span></span><span><span>    pat <span>=</span> clue<span>.</span>pattern
</span></span><span><span>
</span></span><span><span>    <span># Create constants for each state</span>
</span></span><span><span>    states <span>=</span> z3<span>.</span>IntVector(clue<span>.</span>name <span>+</span> <span>&#34;_state&#34;</span>, <span>1</span> <span>+</span> nchar, ctx<span>=</span>solv<span>.</span>ctx)
</span></span><span><span>
</span></span><span><span>    <span># Express the transition requirement</span>
</span></span><span><span>    <span>for</span> i, ch <span>in</span> enumerate(chars):
</span></span><span><span>        solv<span>.</span>add(state_func(states[i], ch) <span>==</span> states[i <span>+</span> <span>1</span>])
</span></span><span><span>
</span></span><span><span>    <span># Each state must be valid</span>
</span></span><span><span>    <span>for</span> st <span>in</span> states:
</span></span><span><span>        solv<span>.</span>add(<span>0</span> <span>&lt;=</span> st)
</span></span><span><span>        solv<span>.</span>add(st <span>&lt;</span> pat<span>.</span>nstate)
</span></span><span><span>    <span># State zero is the initial state</span>
</span></span><span><span>    solv<span>.</span>add(states[<span>0</span>] <span>==</span> <span>0</span>)
</span></span><span><span>
</span></span><span><span>    <span># The final state must be accepting</span>
</span></span><span><span>    solv<span>.</span>add(z3<span>.</span>Or([
</span></span><span><span>        states[<span>-</span><span>1</span>] <span>==</span> i
</span></span><span><span>        <span>for</span> i, ok <span>in</span> enumerate(pat<span>.</span>accept) <span>if</span> ok
</span></span><span><span>    ])
</span></span></code></pre></div><h2 id="putting-it-together">Putting it togetherÂ <a href="#putting-it-together"><i>	ğŸ”—ï¸</i></a> </h2>
<p>With those primitives, we now just need to define a grid of characters, and add appropriate assertions. I was still using <a href="https://regexle.com/">regexle</a> as a source of test cases; it operates on a hexagonal grid, and mapping coordinates between the hex grid and the three different clue axes was honestly one of the hardest parts of this exercise! Glossing over that bit, though, the code is quite simple:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>make_char</span>(solv: z3<span>.</span>Solver, name: str) <span>-&gt;</span> z3<span>.</span>ExprRef:
</span></span><span><span>    ch <span>=</span> z3<span>.</span>Int(name, solv<span>.</span>ctx)
</span></span><span><span>    solv<span>.</span>add(<span>0</span> <span>&lt;=</span> ch)
</span></span><span><span>    solv<span>.</span>add(ch <span>&lt;</span> len(ALPHABET))
</span></span><span><span>    <span>return</span> ch
</span></span><span><span>
</span></span><span><span>grid <span>=</span> [
</span></span><span><span>    [make_char(solv, <span>f</span><span>&#34;grid_</span><span>{</span>x<span>}</span><span>_</span><span>{</span>y<span>}</span><span>&#34;</span>) <span>for</span> y <span>in</span> range(maxdim)]
</span></span><span><span>    <span>for</span> x <span>in</span> range(maxdim)
</span></span><span><span>]
</span></span><span><span>
</span></span><span><span><span>for</span> clue <span>in</span> all_clues:
</span></span><span><span>    coords <span>=</span> word_coords(clue<span>.</span>axis, clue<span>.</span>index)
</span></span><span><span>    chars <span>=</span> [grid[x][y] <span>for</span> x, y <span>in</span> coords]
</span></span><span><span>
</span></span><span><span>    assert_matches(
</span></span><span><span>        solv,
</span></span><span><span>        clue,
</span></span><span><span>        chars,
</span></span><span><span>    )
</span></span></code></pre></div>
<p>At this point â€“ once I put all the pieces together â€“ I was able to solve crosswords, but it was â€¦ painfully slow. Some 3x3 puzzles took upwards of <strong>ten minutes</strong> of Z3 time on my M1 Macbook Air! I figured out how to let Z3 use multiple cores, which was a small constant-factor speedup, but this fundamentally seemed way too slow.</p>
<p>I expected â€“ on vague internal heuristics â€“ that Z3 should be able to solve these puzzles in milliseconds. Thus, I felt compelled to spend some time debugging and understanding just why my solver was so slow, and how to speed it up.</p>
<p>At the time, I was a total Z3 novice so I didnâ€™t really know what to try or what to look at; during the adventures that followed I would learn a <strong>ton</strong> more. I ultimately achieved the speeds I expected, but there were a lot of red herrings and surprises along the way.</p>
<p>Even before this project, I had a vague sense that that SMT solvers have notoriously opaque and <a href="https://ceur-ws.org/Vol-4008/SMT_paper21.pdf">unstable</a> performance properties. Nonetheless, I found myself surprised by just how true that turned out to be, even for what I thought was a pretty simple problem. I still do not fully understand a number of the behaviors I encountered.</p>
<p>Iâ€™ll start by sharing the two changes I made which ultimately had the greatest impact â€“ producing, as best I can tell, a fast and reliable solver â€“ but then Iâ€™ll share some of my false starts and other oddities.</p>
<h2 id="pruning-states">Pruning statesÂ <a href="#pruning-states"><i>	ğŸ”—ï¸</i></a> </h2>
<p>As I mentioned, Iâ€™m not (wasnâ€™t?) a Z3 expert, but I do understand regexes quite well. Thus, my first idea was to help Z3 out by doing some domain-specific analysis to generate additional constraints.</p>
<p>As a motivating example, consider the regex <code>(NR|Q|I)+</code>, from <a href="https://regexle.com/?side=3&amp;day=458">todayâ€™s regexle</a> as I write this. Itâ€™s immediately obvious that the answer can only contain the letters N, R, Q, and I. However, my code hard-codes an alphabet of <code>A-Z</code> for all squares, and requires Z3 to rule out all the other letters. What if we instead detected the actual legal alphabet, and encoded it into our Z3 problem?</p>
<p>As humans we easily detect that property by looking at the regex source. We could write code to do a similar analysis, but in general the problem is not quite as straightforward. I realized, however, that we can instead do a similar analysis on the transition tables we already have. Moreover, because I am now <a href="https://transformer-circuits.pub/2021/framework/index.html">a scientist</a> as well an engineer, I choose to do so in a few scant lines using some <code>numpy</code> tricks.</p>
<p>We define a state in our FSM as â€œdeadâ€ if there is no sequence of transitions leading from that state to any accepting state. Because we work on a minimal FSM, courtesy of <a href="https://github.com/qntm/greenery/blob/e55c96712677d56ef14664a1595a47fb7f26bc01/greenery/fsm.py#L166-L172">a <code>greenery</code> analysis pass</a>, we know there is at-most one dead state, and all out-edges from that state will be self-loops. We can easily detect the dead state by looking for that condition:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Method on the above class `Regex`</span>
</span></span><span><span><span>@cached_property</span>
</span></span><span><span><span>def</span> <span>dead_states</span>(self) <span>-&gt;</span> set[int]:
</span></span><span><span>    looped <span>=</span> self<span>.</span>transition <span>==</span> np<span>.</span>arange(self<span>.</span>nstate)[:, <span>None</span>]
</span></span><span><span>    <span>return</span> set(np<span>.</span>flatnonzero(looped<span>.</span>all(<span>-</span><span>1</span>) <span>&amp;</span> <span>~</span>self<span>.</span>accept))
</span></span></code></pre></div><p>(Note that we will only ever have zero or one dead states, but using <code>set[int]</code> will let us treat those cases uniformly by iterating over the set, which I found a bit cleaner than using <code>int | None</code>)</p>
<p>Given the dead state, we can define a dead <strong>character</strong> as one which always transitions to a dead state, from any initial state:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>@cached_property</span>
</span></span><span><span><span>def</span> <span>dead_vocab</span>(self) <span>-&gt;</span> set[int]:
</span></span><span><span>    dead <span>=</span> set()
</span></span><span><span>    <span>for</span> d <span>in</span> self<span>.</span>dead_states:
</span></span><span><span>        dead <span>|=</span> set(np<span>.</span>flatnonzero((self<span>.</span>transition <span>==</span> d)<span>.</span>all(<span>0</span>)))
</span></span><span><span>    <span>return</span> dead
</span></span></code></pre></div><p>We can also ask which characters are dead starting from any given state:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>dead_from</span>(self, state: int) <span>-&gt;</span> set[int]:
</span></span><span><span>    dead <span>=</span> set()
</span></span><span><span>    <span>for</span> d <span>in</span> self<span>.</span>dead_states:
</span></span><span><span>        dead <span>|=</span> set(np<span>.</span>flatnonzero((self<span>.</span>transition <span>==</span> d)[state]))
</span></span><span><span>    <span>return</span> dead
</span></span></code></pre></div><p>Armed with that information, we can give Z3 a few more constraints:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>for</span> d <span>in</span> pat<span>.</span>dead_vocab:
</span></span><span><span>    <span>for</span> ch <span>in</span> chars:
</span></span><span><span>        solv<span>.</span>add(ch <span>!=</span> d)
</span></span><span><span>
</span></span><span><span><span>for</span> d <span>in</span> pat<span>.</span>dead_from(<span>0</span>):
</span></span><span><span>    solv<span>.</span>add(chars[<span>0</span>] <span>!=</span> d)
</span></span><span><span>
</span></span><span><span><span>for</span> d <span>in</span> pat<span>.</span>dead_states:
</span></span><span><span>    <span>for</span> st <span>in</span> states:
</span></span><span><span>        solv<span>.</span>add(st <span>!=</span> d)
</span></span></code></pre></div><p>These constraints are, strictly-speaking redundant, but our hope is that our knowledge of the problem structure lets us find these facts more easily than Z3 can, and let Z3 focus faster on the â€œinterestingâ€ part of the search space.</p>
<p>Indeed, I found this pruning exercise an interesting example of how you can use a generic prover/solver like Z3, but nonetheless augment it with domain-specific heuristics to improve performance. My sense is that this hybrid is fairly common in practice; solvers arenâ€™t magical and if you can deduce additional structure using domain-specific analysis, it will often give the solver an important boost.</p>
<p>If I wanted, it would be relatively straightforward to additionally ask Z3 to <strong>verify</strong>, on some specific puzzles, that these constraints are redundant, which would be a useful correctness check. For this toy project I didnâ€™t bother.</p>
<h2 id="defining-the-transition-function-explicitly">Defining the transition function explicitlyÂ <a href="#defining-the-transition-function-explicitly"><i>	ğŸ”—ï¸</i></a> </h2>
<p>I described, above, encoding the transition table for each regex as a Z3 function, and then nailing down its behavior using pointwise assertions about each <code>(state, character)</code> pair. I eventually discovered that I could get better performance by representing the transition as an explicit expression, instead of an uninterpreted function; I speculate that doing so encouraged Z3 to reason through the relation equationally instead of falling back on search, but Iâ€™m honestly unclear.</p>
<p>Weâ€™ll write a Python function which represents the transition table as an explicit <code>if-then</code> ladder analyzing a (state, character) input. Weâ€™ll start with a helper which effectively does a â€œmatchâ€ or â€œswitchâ€ statement on a single variable:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>build_match</span>(
</span></span><span><span>    var: z3<span>.</span>AstRef,
</span></span><span><span>    test: list[z3<span>.</span>AstRef],
</span></span><span><span>    result: list[z3<span>.</span>AstRef],
</span></span><span><span>) <span>-&gt;</span> z3<span>.</span>AstRef:
</span></span><span><span>    <span>&#34;&#34;&#34;Return a Z3 `if` ladder comparing var against each `test` value.
</span></span></span><span><span><span>
</span></span></span><span><span><span>    If `var == test[i]`, the ladder evaluates to `result[i]`. If no
</span></span></span><span><span><span>    `test` matches, evaluate to `result[-1]`; it is anticipated that
</span></span></span><span><span><span>    normally the list of tests will be exhaustive.
</span></span></span><span><span><span>    &#34;&#34;&#34;</span>
</span></span><span><span>    expr <span>=</span> result[<span>-</span><span>1</span>]
</span></span><span><span>    <span>for</span> test_, then_ <span>in</span> zip(test[:<span>-</span><span>1</span>], result[:<span>-</span><span>1</span>], strict<span>=</span><span>True</span>):
</span></span><span><span>        expr <span>=</span> z3<span>.</span>If(var <span>==</span> test_, then_, expr)
</span></span><span><span>    <span>return</span> expr
</span></span></code></pre></div><p>Now, given Z3 expressions corresponding to a state and a character, we can build an explicit expression computing the new state:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>build_next_state</span>(
</span></span><span><span>    self, clue: Clue, st: z3<span>.</span>AstRef, ch: z3<span>.</span>AstRef
</span></span><span><span>) <span>-&gt;</span> z3<span>.</span>AstRef:
</span></span><span><span>    pat <span>=</span> clue<span>.</span>pattern
</span></span><span><span>    by_state <span>=</span> [
</span></span><span><span>        build_match(
</span></span><span><span>            ch,
</span></span><span><span>            self<span>.</span>alphabet,
</span></span><span><span>            [self<span>.</span>states[out] <span>for</span> out <span>in</span> pat<span>.</span>transition[i]],
</span></span><span><span>        )
</span></span><span><span>        <span>for</span> i <span>in</span> range(pat<span>.</span>nstate)
</span></span><span><span>    ]
</span></span><span><span>
</span></span><span><span>    <span>return</span> build_match(
</span></span><span><span>        st,
</span></span><span><span>        self<span>.</span>states[: pat<span>.</span>nstate],
</span></span><span><span>        by_state,
</span></span><span><span>    )
</span></span></code></pre></div><p>Now, where previously we had written <code>state_func(states[i], ch) == states[i + 1]</code>, we can instead embed the entire expression for each transition:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>for</span> i, ch <span>in</span> enumerate(chars):
</span></span><span><span>    solv<span>.</span>add(self<span>.</span>build_next_state(clue, states[i], ch) <span>==</span> states[i <span>+</span> <span>1</span>])
</span></span></code></pre></div><p>This approach resulted in a substantial speedup, and, in particular, made performance much more <strong>consistent</strong>; at larger puzzle sizes, I saw many fewer â€œslow puzzlesâ€ than with the old pointwise-assertion approach.</p>
<p>Unfortunately, this direct approach had a significant downside: constructing the huge Z3 if-then ladders turned out to be quite expensive, to the point where we spent far longer constructing the Z3 expression than we spent solving it!</p>
<h3 id="sharing-the-expression">Sharing the expressionÂ <a href="#sharing-the-expression"><i>	ğŸ”—ï¸</i></a> </h3>
<p>Can we get the best of both worlds? It took me a fair bit of digging and experimentation, but I was able to find a way to get the same performance as the explicit expression, but only construct the expression once. In fact, I found two different strategies, illustrating a number of Z3 features.</p>
<h4 id="using-a-z3-lambda-expression">Using a Z3 lambda expressionÂ <a href="#using-a-z3-lambda-expression"><i>	ğŸ”—ï¸</i></a> </h4>
<p>Instead of using a Z3 function object, we can wrap the big <code>if</code> ladder in a <code>z3.Lambda</code> expression, which gives us a way to explicitly instantiate it multiple times with different parameters. Given our <code>build_next_state</code> function above, itâ€™s a very small change to do so:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>st <span>=</span> z3<span>.</span>Int(<span>&#34;st&#34;</span>)
</span></span><span><span>ch <span>=</span> z3<span>.</span>Int(<span>&#34;ch&#34;</span>)
</span></span><span><span>
</span></span><span><span>lambda_ <span>=</span> z3<span>.</span>Lambda([st, ch], self<span>.</span>build_funcexpr(clue, st, ch))
</span></span><span><span>
</span></span><span><span><span>for</span> i, ch <span>in</span> enumerate(chars):
</span></span><span><span>    solv<span>.</span>add(lambda_[states[i], ch] <span>==</span> states[i <span>+</span> <span>1</span>])
</span></span></code></pre></div><h4 id="using-a-z3-function-and-macro-finder">Using a Z3 function and <code>macro-finder</code>Â <a href="#using-a-z3-function-and-macro-finder"><i>	ğŸ”—ï¸</i></a> </h4>
<p>While exploring other options, however, I was reading <a href="https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-07-07.pdf">the SMT-LIB specification</a>, and noticed that SMT-LIB allows defining functions with explicit bodies:</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span>(define-fun double ((x Int)) Int (<span>*</span> x <span>2</span>))
</span></span><span><span>
</span></span><span><span><span>;; evaluates to `8`</span>
</span></span><span><span>(simplify (double <span>4</span>))
</span></span></code></pre></div><p>I was unable to find a way to create such a function using Z3â€™s Python API. Reading the spec some more, though, I learned that the above syntax is defined in terms of <code>declare-fun</code> and a <code>forall</code> assertion:</p>

<figure><img src="https://immich.app/post/regex-crosswords-z3/smt-define-fun.png" srcset="/post/regex-crosswords-z3/smt-define-fun@2x.png 2x" width="768" height="112" alt="Screenshot of the SMT-LIB specification, defining &amp;ldquo;define-fun&amp;rdquo; as equivalent to declaring the named function using &amp;ldquo;declare-fun&amp;rdquo;, and asserting its behavior using a &amp;ldquo;forall&amp;rdquo; ranging over the input variables." title="SMT-LIB specification v2.7, p66, defining the semantics of `define-fun`"/>

<figcaption>SMT-LIB specification v2.7, p66, defining the semantics of <code>define-fun</code></figcaption>

</figure>
<p>Z3 gives us access to those tools, so I tried using them:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>state_expr <span>=</span> self<span>.</span>build_funcexpr(clue, st, ch)
</span></span><span><span>solv<span>.</span>add(z3<span>.</span>ForAll([st, ch], state_func(st, ch) <span>==</span> state_expr))
</span></span></code></pre></div><p>This approach worked, in the sense of producing correct solutions, but it turned out to be one of the slowest approaches I tried!</p>
<p>After even <strong>more</strong> digging, however, I found a fix! Z3 has a <a href="https://microsoft.github.io/z3guide/docs/strategies/summary#tactic-macro-finder">â€œtacticâ€ by the name of â€œmacro-finderâ€</a>. Z3 tactics are transformations which allow for user-directed simplification or transformation passes outside of the core SMT solver. <code>macro-finder</code> implements a number of transformations, but at its most basic, it finds <code>forall</code> assertions which â€œdefineâ€ the meaning of a function, and effectively copy-pastes them in place of invocations of that function. Essentially, it transforms our <code>forall</code> variant into the â€œexplicit expression every timeâ€ variant, but by virtue of being implemented in C++ and closer to the Z3 core, it does so quite efficiently.</p>
<p>I found that all three approaches (the explicit expression, a Z3 <code>lambda</code>, and a <code>forall</code>+<code>macro-finder</code>) resulted in similar solve times in Z3, and the <code>z3.Lambda</code> and <code>macro-finder</code> approaches were both comparably-fast in terms of runtime to define the problem.</p>
<h2 id="false-starts">False startsÂ <a href="#false-starts"><i>	ğŸ”—ï¸</i></a> </h2>
<p>Now, we can dig into all the things that didnâ€™t work, or at least werenâ€™t necessary. In doing so, weâ€™ll learn about even more Z3 features, and some surprising performance behaviors. If you prefer, you can jump to <a href="#conclusion">my closing thoughts</a>.</p>
<h3 id="z3-enumsort">Z3 <code>EnumSort</code>Â <a href="#z3-enumsort"><i>	ğŸ”—ï¸</i></a> </h3>
<p>Z3 knows a <strong>lot</strong> about the integers, and has <a href="https://z3prover.github.io/papers/programmingz3.html#sec-solving-arithmetical-fragments">many different solvers</a> for different classes of integer arithmetic. I wondered: Can we speed up the solver by using some other data type, and just avoid invoking any of that integer logic, at all?</p>
<p>Thus, I tried replacing my states and characters with <a href="https://microsoft.github.io/z3guide/docs/theories/Datatypes#scalars-enumeration-types">SMT-LIB enumeration types</a> (exposed to Python as <a href="https://z3prover.github.io/api/html/namespacez3py.html#a9cf7ec94a9dd102286790774b5359556">z3.EnumSort</a>).</p>
<p>We can define an enumeration sort for our states and for our characters, creating a new type with no behavior other than having exactly N distinct values:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>nstates <span>=</span> max(c<span>.</span>pattern<span>.</span>nstate <span>for</span> c <span>in</span> all_clues)
</span></span><span><span>state_sort, states <span>=</span> z3<span>.</span>EnumSort(
</span></span><span><span>    <span>&#34;State&#34;</span>,
</span></span><span><span>    [<span>f</span><span>&#34;S</span><span>{</span>i<span>}</span><span>&#34;</span> <span>for</span> i <span>in</span> range(nstates)],
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span>char_sort, alphabet <span>=</span> z3<span>.</span>EnumSort(<span>&#34;Char&#34;</span>, list(ALPHABET))
</span></span></code></pre></div><p>The rest of our code also only minimally changes; we need to replace <code>IntSort</code> in the declaration of our transition functions, and we need to replace <code>i</code> with <code>states[i]</code> or <code>alphabet[i]</code> any time we are encoding a specific state or character.</p>
<h4 id="enumsort-performance"><code>EnumSort</code> performanceÂ <a href="#enumsort-performance"><i>	ğŸ”—ï¸</i></a> </h4>
<p>When I first switched to <code>EnumSort</code>, I saw a <strong>massive</strong> speedup!</p>

<figure><img src="https://immich.app/post/regex-crosswords-z3/int-v-enum.png" srcset="/post/regex-crosswords-z3/int-v-enum@2x.png 2x" width="400" height="400" alt="Z3 solve time, integer encoding vs EnumSort. EnumSort solves every side-3 puzzles in under a tenth of second, while the integer encoding takes at least 0.2s and as much as 3s" title="An early violin plot I made of Z3 solve times for side-3 puzzles, using two different representations. These runs use the pruning described above, but still the original pointwise function definition."/>

<figcaption>An early violin plot I made of Z3 solve times for side-3 puzzles, using two different representations. These runs use the pruning described above, but still the original pointwise function definition.</figcaption>

</figure>
<p>However, it turned out that I was at-best partially correct about why I saw that speedup. Hereâ€™s the same plot, but now Iâ€™ve added two new panels: One, which still uses the pointwise function definition but with a small change Iâ€™ll mention in a minute, and one which uses the <code>z3.Lambda</code> encoding I described above:</p>

<figure><img src="https://immich.app/post/regex-crosswords-z3/int-v-enum-new.png" srcset="/post/regex-crosswords-z3/int-v-enum-new@2x.png 2x" width="800" height="400" alt="The same plot, with two new panels for &amp;ldquo;pointwise (new)&amp;rdquo; and &amp;ldquo;z3.Lambda&amp;rdquo;." title="The same plot, with two new panels for different representations of the transition function."/>

<figcaption>The same plot, with two new panels for different representations of the transition function.</figcaption>

</figure>
<p>With my current code, <code>IntSort</code> is <strong>faster</strong> with the pointwise function definition, and the speedup from explicitly encoding the transition function dwarfs any other change.</p>
<h4 id="a-bizarre-performance-instability">A bizarre performance instabilityÂ <a href="#a-bizarre-performance-instability"><i>	ğŸ”—ï¸</i></a> </h4>
<p>What did I change between â€œ(old)â€ and â€œ(new)â€?</p>
<p>When weâ€™re using integers to represent states, we bound the integers with additional assertions. Above, I showed the original code I wrote for those bounds:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Each state must be valid</span>
</span></span><span><span><span>for</span> st <span>in</span> states:
</span></span><span><span>    solv<span>.</span>add(<span>0</span> <span>&lt;=</span> st)
</span></span><span><span>    solv<span>.</span>add(st <span>&lt;</span> pat<span>.</span>nstate)
</span></span></code></pre></div><p>When I was refactoring my code to experiment with other representations, I unintentionally changes the behavior to instead bound our states using the <strong>maximum</strong> number of states for any clue, not just the current one:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>max_nstate <span>=</span> max(clue<span>.</span>pattern<span>.</span>nstate <span>for</span> clue <span>in</span> all_clues)
</span></span><span><span>
</span></span><span><span><span>for</span> st <span>in</span> states:
</span></span><span><span>    solv<span>.</span>add(<span>0</span> <span>&lt;=</span> st)
</span></span><span><span>    solv<span>.</span>add(st <span>&lt;</span> max_nstate)
</span></span></code></pre></div><p>At least on my version of Z3, the second approach â€“ which is a <strong>looser</strong> bound! â€“ is much, much faster. That change is, I believe, the only meaningful difference between the <code>IntSort</code> plots for â€œ(old)â€ and â€œ(new)â€!</p>
<p>In addition, I donâ€™t actually understand why <code>EnumSort</code> is slower for the pointwise function definition. Iâ€™ve poked at Z3 traces and statistics, and it looks like Z3 is somehow struggling to reason equationally through our <code>xfer(st, ch) == st_next</code> assertions in the Enum case, necessitating a bit more search-and-backtracking, but I donâ€™t understand why.</p>
<h2 id="using-z3-regular-expressions">Using Z3 regular expressionsÂ <a href="#using-z3-regular-expressions"><i>	ğŸ”—ï¸</i></a> </h2>
<p>Somewhere amid refactoring to support a whole matrix of representations, and profiling and plotting them, I also tried a <strong>completely</strong> different approach to solving the problem!</p>
<p>Z3, it turns out, also has a <a href="https://microsoft.github.io/z3guide/docs/theories/Regular%20Expressions">theory of regular expressions</a>! We can bypass our state-machine machinery entirely, and directly encode the regex clues as Z3 regular expressions.</p>
<p>Z3 does not come with a regular-expression parser, but instead has combinators to build up patterns, such as <code>z3.Re(char)</code>, <code>z3.Range(start, end)</code>, <code>z3.Star(re)</code>, and so on. Thus, I <a href="https://github.com/nelhage/nelhage-sandbox/blob/main/regexle/src/regexle/z3_re.py">wrote a simple translation layer</a> which recursively walks the <code>greenery</code> <code>Pattern</code> AST, and translates it into a Z3 regex. From there, we can just declare each unknown character as a Z3 string object, and assert each clue like so:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>re <span>=</span> greenery_to_z3(clue<span>.</span>pattern)
</span></span><span><span>
</span></span><span><span>string <span>=</span> z3<span>.</span>Concat(chars)
</span></span><span><span>solv<span>.</span>add(z3<span>.</span>InRe(string, re))
</span></span></code></pre></div><p>Arguably much simpler! Is it fast? Itâ€™s â€¦ decent.</p>

<figure><img src="https://immich.app/post/regex-crosswords-z3/perf-overview.png" srcset="/post/regex-crosswords-z3/perf-overview@2x.png 2x" width="600" height="400" alt="A line plot, with &amp;ldquo;puzzle side length&amp;rdquo; on the X axis, and &amp;ldquo;solve time in seconds&amp;rdquo; on the Y. There are three lines. My current-fastest solver goes from about 10ms at size=3 to about 30ms at size=8. Using Z3 regular expressions goes from about 150ms to about 11s. My original, slow, code has a lot of variance and takes over 10s by size=5, which is the last point shown." title="Comparing performance, as a function of puzzle size, for three variants. \&#34;Current best\&#34; is my best-performing approach, using IntSort, pruning, and z3.Lambda. \&#34;Pointwise, no pruning\&#34; is similar to my very first implementation."/>

<figcaption>Comparing performance, as a function of puzzle size, for three variants. &#34;Current best&#34; is my best-performing approach, using IntSort, pruning, and z3.Lambda. &#34;Pointwise, no pruning&#34; is similar to my very first implementation.</figcaption>

</figure>
<p>On the one hand â€“ especially for large puzzles â€“ we can solve puzzles much faster by pulling in all of the tricks Iâ€™ve discussed in this post. On the other, the solver using Z3 regexes is probably by-far the simplest any I considered or implemented, and itâ€™s nearly 10x faster than my initial, naive, attempt.</p>
<p>I suspect the pattern generalizes: If Z3 has first-class support for your problem domain, itâ€™s worth starting there! However, Z3 shines first-and-foremost in being a very general tool and offering a uniform interface for many, many different problem types; if youâ€™re willing to invest effort, to do experiments, and to deploy domain-specific expertise, thereâ€™s a good chance you solve instances faster, at the cost of adding complexity on your side.</p>

<p>This was a fun project! I originally expected it would be a fun afternoon nerd-snipe, and indeed my original script took maybe an hour or two to whip together. However, I wasnâ€™t able to shake the urge to optimize, and to understand Z3 better, and in the time since Iâ€™ve spent a somewhat-unreasonable time refactoring, exploring variations, running benchmarks, making plots, and so on. However, in doing so I now understand both Z3 and SMT-LIB much, much better, which was, after all, my original goal! Iâ€™m excited to find more opportunities to deploy them â€œin angerâ€ in the future.</p>
<p>Iâ€™ll close with a few reflections/lessons about working with Z3 that Iâ€™ve taken away from this experience.</p>
<h4 id="z3-supports-many-more-features-than-id-realized">Z3 supports many more features than Iâ€™d realized.Â <a href="#z3-supports-many-more-features-than-id-realized"><i>	ğŸ”—ï¸</i></a> </h4>
<p>Iâ€™ve mostly encountered Z3 (in passing) as a solver for problems involving integers, bit-vectors, and sometimes arrays. I learned about many new datatypes and theories which it supports, including:</p>
<ul>
<li>Strings, sequences, and regular expressions</li>
<li>Algebraic datatypes</li>
<li>Uninterpreted functions, including recursive functions</li>
</ul>
<p>I also had never encountered the Z3 <a href="https://microsoft.github.io/z3guide/docs/strategies/tactics">tactics</a> system, which can be used both to help solve problems which are beyond the reach of the base SMT solver, and also to implement custom rewrite/simplification strategies in order to optimize for a certain class of problems. I learned that <a href="https://github.com/AliveToolkit/alive2">Alive2</a>, my personal favorite Z3-backed tool, makes <a href="https://z3prover.github.io/papers/z3internals.html#sec-a-use-case-of-tactics-from-alive2">heavy use of Z3 tactics</a> to optimize for the specific kinds of expressions that Alive2 generates.</p>
<h4 id="z3-performance-is-indeed-quite-unstable-and-unpredictable-at-least-at-times">Z3 performance is, indeed, quite unstable and unpredictable, at least at times.Â <a href="#z3-performance-is-indeed-quite-unstable-and-unpredictable-at-least-at-times"><i>	ğŸ”—ï¸</i></a> </h4>
<p>As I mentioned earlier, I was vaguely aware of this property, in the sense that Iâ€™d heard it in passing, but this project really drove it home. By tweaking all the various combinations of encodings and approaches I came up with for this problem, I was able to make the solver ~100x faster or slower, even aside from the domain-specific pruning optimizations. And some of the performance behaviors were baffling, such as the <a href="#a-bizarre-performance-instability">10x speedup</a> by slightly <strong>loosening</strong> an integer range bound!</p>
<h5 id="use-z3-enumerations-for-more-predictable-performance">Use Z3 enumerations for more predictable performanceÂ <a href="#use-z3-enumerations-for-more-predictable-performance"><i>	ğŸ”—ï¸</i></a> </h5>
<p>A bit of tactical/concrete advice, on the topic of performance.</p>
<p>If youâ€™re encoding some problem into Z3 where you want to represent â€œOne of N possibilities,â€ and those possibilities <strong>donâ€™t</strong> have natural numeric interpretations (weâ€™re not, for instance, treating them as integers and summing them), then I suggest declaring a new <a href="https://microsoft.github.io/z3guide/docs/theories/Datatypes#scalars-enumeration-types">enumeration sort</a>, instead of just labeling them using integers.</p>
<p>If my experience is any guide, this change <strong>often</strong> wonâ€™t make any difference, but from time-to-time it can avoid mysterious performance instability and 10x slowdowns, by side-stepping all of Z3â€™s specialized knowledge and solvers for arithmetic and other properties of numbers.</p>
<p>One caveat, though, re: usability: new sorts are global per-z3-<a href="https://z3prover.github.io/api/html/classz3py_1_1_context.html">Context</a>, so if you (e.g.) declare an <code>EnumSort</code> named â€œState,â€ you canâ€™t re-declare a different one with the same name and a different set of values, without restarting your program or creating a whole new context object.</p>
<h4 id="z3-documentation-is-mixed-but-does-exist">Z3 documentation is mixed, but does existÂ <a href="#z3-documentation-is-mixed-but-does-exist"><i>	ğŸ”—ï¸</i></a> </h4>
<p>I found it pretty hard, at first, to find good documentation that answered deep questions about Z3 internals or strategies or information beyond surface usage, but eventually I collected quite a list. I think that â€œask an expertâ€ remains far and away the most effective way to use Z3 (thanks to <a href="https://www.hillelwayne.com/">Hillel Wayne</a> for answering some questions as I worked on this project!), but here are the some other excellent links I found:</p>
<ul>
<li>Microsoftâ€™s <a href="https://microsoft.github.io/z3guide/">Z3 Guide</a>, including its <a href="https://microsoft.github.io/z3guide/docs/strategies/summary">list of tactics</a> and <a href="https://microsoft.github.io/z3guide/programming/Parameters">solver options</a>.</li>
<li><a href="https://microsoft.github.io/z3guide/programming/Parameters"><em>Programming Z3</em></a>, a paper by some Z3 developers.</li>
<li><a href="https://z3prover.github.io/papers/z3internals.html"><em>Z3 Internals</em></a> contains excellent detail about how Z3 works under the hood.</li>
</ul>



</div></div>
  </body>
</html>
