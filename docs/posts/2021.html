<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/writing/2021/">Original</a>
    <h1>2021</h1>
    
    <div id="readability-page-1" class="page"><article><p>I felt like I didn&#39;t do much this year, but now that I write it all down...</p><h2 id="streaming-incremental">Streaming/incremental</h2><pre><code><span>streaming-consistency: 94 commits, 2952 insertions(+), 36 deletions(-)
</span></code></pre><p>I wanted to understand this whole space better.</p><p>The goal was to produce the high-level view that appears in <a href="https://www.nationalobserver.com/writing/an-opinionated-map-of-incremental-and-streaming-systems/">An opinionated map of incremental and streaming systems</a>.</p><p>At first I thought that the way to understand the tradeoffs between different systems would be to characterize them by performance on different workloads, like we do with databases. You can see the start of a plan for that in <a href="https://www.nationalobserver.com/writing/thoughts-on-benchmarking-streaming-systems/">Thoughts on benchmarking streaming systems</a>.</p><p>To fairly compare databases you have to benchmark them at the same consistency levels. But I found that none of the popular streaming systems had any documentation about consistency at all. Worse, when I was reading the implementations I didn&#39;t find any of the metadata that I expected to be used to enforce consistency. So I ended up testing consistency instead in <a href="https://www.nationalobserver.com/writing/internal-consistency-in-streaming-systems/">Internal consistency in streaming systems</a>.</p><p>I found that both flink (barring custom operators) and ksqldb have no concept of internal consistency at all, and that for many kinds of computations they will produce outputs that are not correct for any point in time, and often not even possible for any set of inputs.</p><p>(I also found what I suspect is a <a href="https://issues.apache.org/jira/browse/FLINK-22075?focusedCommentId=17319406&amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-17319406">violation of eventual consistency in flink</a> but the authors disagreed and the issue is now marked as stale.)</p><p>I didn&#39;t test noria, but I talked to the author and after some time struggling to reach shared terminology I <em>think</em> we&#39;re agreed that it will also exhibit the same kinds of internal consistency violations.</p><p>I never managed to produce output at all from kafka streams.</p><p>Only differential dataflow (and materialize) produced correct answers for my examples.</p><p>I investigated maybe 4-5 other systems but none of them could even express the examples, usually because they don&#39;t support non-windowed joins at all.</p><p>So this was pretty disappointing. I did get a much better understanding of the space, but the outcome was that almost nothing in the space is applicable to the kinds of database-esque problems I had in mind.</p><p>I had one last braindump in <a href="https://www.nationalobserver.com/writing/thoughts-on-benchmarking-streaming-systems/">Thoughts on benchmarking</a> before moving on.</p><h2 id="dida">Dida</h2><pre><code><span>dida: 212 commits, 7752 insertions(+), 37 deletions(-)
</span></code></pre><p>Differential dataflow was the only streaming system I found that can handle basic relational algebra in the presence of deletions and also guarantees correct answers.</p><p><a href="https://www.nationalobserver.com/writing/why-isnt-differential-dataflow-more-popular/">Why isn&#39;t differential dataflow more popular?</a> produced a lot of feedback. Much of it centered around differential dataflow being too hard to understand and use.</p><p>So I wrote <a href="https://github.com/jamii/dida">dida</a>, a simplified version of the same algorithms. It&#39;s still in a very alpha state, with few tests. But it is able to produce correct answers for the examples I used in the internal consistency investigations above. And the understanding I got from days poring over the dd code and papers is condensed in <a href="https://github.com/jamii/dida/blob/main/docs/why.md">How dida works</a>.</p><p>Dida also has javascript bindings, both natively in node and in the browser via wasm. They&#39;re barely tested and leak memory, but there are <a href="https://github.com/jamii/dida/tree/0ed26ffa2c1e1d7a1f98df8e2770d7d2bad0de6d/examples">working examples</a> for both.</p><p>Debugging dida is difficult. Symptoms appear very far away from the actual cause of the bug. Most of the intermediate state is multiversion indexes over multi-dimensional timestamps. Printlns just weren&#39;t cutting it. So I made my own little debugger which snapshots the state of the dataflow at every transition, augments each state with additional views, check for violations of invariants and allows stepping back and forth through the timeline in a nice gui.</p><iframe src="https://player.vimeo.com/video/646122696?h=0d059b5cb3" allowfullscreen="" frameborder="0" height="359" title="vimeo-player" width="640"></iframe><p>This was my first time using <a href="https://github.com/ocornut/imgui">dear imgui</a> and I was blown away by how many orders of magnitude less time it takes to build dev tooling compared to trying to do the same on the web. I&#39;m going to put guis on everything now.</p><h2 id="imp">Imp</h2><pre><code><span>imp: 95 commits, 3764 insertions(+), 2487 deletions(-)
</span><span>bounded-live-eval: 496 insertions(+), 49 deletions(-)
</span><span>relational-crdts: 5 commits, 251 insertions(+), 138 deletions(-)
</span></code></pre><p><a href="https://github.com/jamii/imp">Imp</a> is a relational programming language.</p><p>I&#39;ve been interested for <a href="https://news.ycombinator.com/item?id=4734327">a</a> <a href="http://witheve.com/">long</a> <a href="https://www.relational.ai/">time</a> in blurring the lines between databases and programming languages, but the most recent motivation came from working on <a href="https://github.com/MaterializeInc/materialize/">materialize</a>. Writing a spec-compliant SQL engine made me realize what a fractally awful language SQL is, culminating this year in writing <a href="https://www.nationalobserver.com/writing/against-sql">Against SQL</a>.</p><p>I worked out much of the language design for imp <a href="https://www.nationalobserver.com/writing/imp-intro/">last year</a>. It can express roughly the same operations as SQL-92 DML, plus recursion, nested relations and first-class functions. But the grammar, denotational semantics and type system each fit on a single page, many queries are much easier to write and modify, and every imp program can still be compiled to a static graph of relational algebra operations.</p><p>The magic sauce (other than basics like non-insane name resolution) is to model functions as infinite sets. Then function application and subqueries are both just a kind of join. Most other relational operations can be expressed in terms of these two primitives, and if you can <a href="https://www.scattered-thoughts.net/writing/imp-decorrelation/">decorrelate every subquery</a> then all the functions disappear and you can still compile to relational algebra.</p><p>(I also wrote a survey of decorrelation techniques in <a href="https://www.nationalobserver.com/writing/materialize-decorrelation">How Materialize and other databases optimize SQL subqueries</a>.)</p><p>This year I made the syntax much more compact (as an aside - <a href="https://www.nationalobserver.com/writing/better-operator-precedence/">Better operator precedence</a>), drastically improved the type system and added a <a href="https://www.scattered-thoughts.net/writing/making-live-repls-behave/">live repl</a>.</p><iframe allow="autoplay; fullscreen; picture-in-picture" src="https://player.vimeo.com/video/600484645?h=03492be7fc" allowfullscreen="" frameborder="0" height="360" width="640"></iframe><p>It&#39;s hard to convey how different it feels from a regular repl without using it yourself. Instead of inserting printlns and rerunning the code, I can just put the cursor on the expression I&#39;m interested in and see every execution at that point.</p><p>(Unfortunately the only editor currently supported is one I wrote myself, which is probably difficult to build on any other machine. But most of logic is in <a href="https://github.com/jamii/imp/blob/d2c84c531d5a43b0662183475856fe0044633352/lib/imp/lang.zig#L261-L280">imp.lang.Worker</a> which should be easy to embed in other editors.)</p><p>I also spent some time on more challenging queries in <a href="https://www.nationalobserver.com/writing/implicit-ordering-in-relational-languages">Implicit ordering in relational languages</a>. It&#39;s an interesting problem for incremental maintenance, and I think it also does a good job of showcasing how imp can be more compact than sql.</p><p>SQL:</p><pre data-lang="sql"><code data-lang="sql"><span>with</span><span> recursive
</span><span>rightmost_child(id, parent_id) </span><span>as</span><span> (
</span><span>    </span><span>select </span><span>max</span><span>(id), </span><span>edit</span><span>.</span><span>parent_id
</span><span>    </span><span>from</span><span> edit
</span><span>    </span><span>where </span><span>edit</span><span>.</span><span>parent_id </span><span>is not </span><span>null
</span><span>    </span><span>group by</span><span> parent_id
</span><span>),
</span><span>rightmost_descendant(id, child_id) </span><span>as</span><span> (
</span><span>    </span><span>select</span><span> id, id
</span><span>    </span><span>from</span><span> edit
</span><span>    </span><span>union
</span><span>    </span><span>select </span><span>parent</span><span>.</span><span>parent_id</span><span>, </span><span>child</span><span>.</span><span>child_id
</span><span>    </span><span>from</span><span> rightmost_child </span><span>as</span><span> parent, rightmost_descendant </span><span>as</span><span> child
</span><span>    </span><span>where </span><span>parent</span><span>.</span><span>id </span><span>= </span><span>child</span><span>.</span><span>id
</span><span>),
</span><span>rightmost_leaf(id, leaf_id) </span><span>as</span><span> (
</span><span>    </span><span>select</span><span> id, </span><span>max</span><span>(child_id) </span><span>as</span><span> leaf_id
</span><span>    </span><span>from</span><span> rightmost_descendant
</span><span>    </span><span>group by</span><span> id
</span><span>),
</span><span>prev_sibling(id, prev_id) </span><span>as</span><span> (
</span><span>    </span><span>select </span><span>edit</span><span>.</span><span>id</span><span>, (
</span><span>        </span><span>select </span><span>max</span><span>(</span><span>sibling</span><span>.</span><span>id</span><span>)
</span><span>        </span><span>from</span><span> edit </span><span>as</span><span> sibling
</span><span>        </span><span>where </span><span>edit</span><span>.</span><span>parent_id </span><span>= </span><span>sibling</span><span>.</span><span>parent_id
</span><span>        </span><span>and </span><span>edit</span><span>.</span><span>id </span><span>&gt; </span><span>sibling</span><span>.</span><span>id
</span><span>    ) </span><span>as</span><span> prev_id
</span><span>    </span><span>from</span><span> edit
</span><span>    </span><span>where</span><span> prev_id </span><span>is not </span><span>null
</span><span>),
</span><span>prev_edit(id, prev_id) </span><span>as</span><span> (
</span><span>    </span><span>-- edits that have no prev siblings come after their parent
</span><span>    </span><span>select </span><span>edit</span><span>.</span><span>id</span><span>, </span><span>edit</span><span>.</span><span>parent_id
</span><span>    </span><span>from</span><span> edit
</span><span>    </span><span>where</span><span> not </span><span>exists</span><span>(
</span><span>        </span><span>select </span><span>*
</span><span>        </span><span>from</span><span> prev_sibling
</span><span>        </span><span>where </span><span>prev_sibling</span><span>.</span><span>id </span><span>= </span><span>edit</span><span>.</span><span>id
</span><span>    )
</span><span>    </span><span>union all
</span><span>    </span><span>-- other edits come after the rightmost leaf of their prev sibling
</span><span>    </span><span>select </span><span>edit</span><span>.</span><span>id</span><span>, </span><span>rightmost_leaf</span><span>.</span><span>leaf_id
</span><span>    </span><span>from</span><span> edit, prev_sibling, rightmost_leaf
</span><span>    </span><span>where </span><span>edit</span><span>.</span><span>id </span><span>= </span><span>prev_sibling</span><span>.</span><span>id
</span><span>    </span><span>and </span><span>prev_sibling</span><span>.</span><span>prev_id </span><span>= </span><span>rightmost_leaf</span><span>.</span><span>id
</span><span>),
</span><span>position(id, position, character) </span><span>as</span><span> (
</span><span>  </span><span>-- root is at position 0
</span><span>  </span><span>select </span><span>edit</span><span>.</span><span>id</span><span>, </span><span>0</span><span>, </span><span>edit</span><span>.</span><span>character
</span><span>  </span><span>from</span><span> edit
</span><span>  </span><span>where </span><span>edit</span><span>.</span><span>parent_id </span><span>is </span><span>null
</span><span>  </span><span>union all
</span><span>  </span><span>-- every other edit comes after their prev edit
</span><span>  </span><span>select </span><span>edit</span><span>.</span><span>id</span><span>, </span><span>position</span><span>.</span><span>position </span><span>+ </span><span>1</span><span>, </span><span>edit</span><span>.</span><span>character
</span><span>  </span><span>from</span><span> edit, prev_edit, position
</span><span>  </span><span>where </span><span>edit</span><span>.</span><span>id </span><span>= </span><span>prev_edit</span><span>.</span><span>id
</span><span>  </span><span>and </span><span>prev_edit</span><span>.</span><span>prev_id </span><span>= </span><span>position</span><span>.</span><span>id
</span><span>)
</span><span>select </span><span>*
</span><span>from</span><span> position
</span><span>order by </span><span>position</span><span>.</span><span>position</span><span>;
</span></code></pre><p>Imp:</p><pre data-lang="imp"><code data-lang="imp"><span>rightmost_child: edits.?edit edit parent~ @ max;
</span><span>fix rightmost_leaf: edits.?edit edit | edit rightmost_child rightmost_leaf @ max;
</span><span>prev_sibling: edits.?edit edit parent parent~ .(?sibling edit &gt; sibling) @ max;
</span><span>prev: edits.?edit edit prev_sibling !! then edit prev_sibling rightmost_leaf else edit parent;
</span><span>fix position: root, 0 | position ?edit ?pos edit prev~, pos+1;
</span><span>edits ?edit (edit position), edit, (edit character)
</span></code></pre><p>This is especially true in the last approach in that article. The sql version uses arrays, which imp doesn&#39;t have. But imp is able to build abstractions over relations:</p><pre data-lang="imp"><code data-lang="imp"><span>// functions for working with &#39;arrays&#39;
</span><span>insert: ?@sequence ?pos ?item
</span><span>    | pos, item
</span><span>    | sequence ?old_pos ?old_item
</span><span>        , old_pos + (old_pos &gt;= pos then 1 else 0)
</span><span>        , old_item;
</span><span>find_min_pos: ?@sequence ?@cond
</span><span>    sequence (?pos ?item cond pos item then pos) @ min;
</span></code></pre><p>The one fly in this beautiful ointment is that the old version of the codebase supported compiling to relational algebra, and the new version supports the live repl and other improvements this year, but I&#39;ve yet to merge both sets of features. I&#39;ve been procrastinating on it for almost a year. Maybe I have decorrelation ptsd.</p><h2 id="focus">Focus</h2><pre><code><span>focus: 99 commits, 2695 insertions(+), 1674 deletions(-)
</span></code></pre><p><a href="https://github.com/jamii/focus">Focus</a> is a text editor that I wrote for myself. Much of the core was done at the end of 2020, but this year I added syntax highlighting, make mode, error squigglies, jump-to-error, async ripgrep and many other minor improvements and bugfixes.</p><p>I also started writing a series of articles explaining how it works (<a href="https://www.scattered-thoughts.net/writing/focus-intro/">1</a>, <a href="https://www.scattered-thoughts.net/writing/focus-rendering/">2</a>, <a href="https://www.scattered-thoughts.net/writing/focus-text/">3</a>) but I kind of lost interest. It just seemed less valuable than other things I wanted to write this year. Maybe in a few years once the code has settled down I&#39;ll try again.</p><p>When it came to syntax highlighting I looked around for some kind of reasoning about why highlighting works and how one should do it. I didn&#39;t find anything. Almost every editor highlights by token kind (ie one colour for keywords, one colour for functions, etc). I&#39;m not sure that this is particularly useful, so instead I tried giving each token a hue that is determined by the token&#39;s hash.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/4f4b0602795f0a5505e39343f9699392808209fc/9a0db/writing/2021/highlighting.png"/></p><p>This does occasionally catch bugs where there are several lines with similar structure but I made a copy-paste bug.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/a97808ecd0d79da25e8b6a57c26ca608ea98472d/7b8e4/writing/2021/bug.png"/></p><p>You can also see in the bigger screenshot that control-flow keywords like <code>catch</code>, <code>defer</code>, <code>break</code> etc are brighter, so that they pop out when scanning the code, and this has definitely helped me spot several subtle bugs.</p><p>Focus is the text editor that I used for all of my writing and coding this year. In purely practical terms, it may not have been an efficient use of time. But it&#39;s hard to put a value on the satisfaction that I get from spending so much time in a world that I made.</p><h2 id="zig">Zig</h2><p>Almost all of the code I&#39;ve written this year has been in <a href="https://ziglang.org/">zig</a>.</p><p>Everything I wrote last year in <a href="https://www.scattered-thoughts.net/writing/assorted-thoughts-on-zig-and-rust/">Assorted thoughts on zig (and rust)</a> still holds.</p><p>Many of the metaprogramming problems I worked on this year, like the dida debugger and the dida javascript bindings, would have been much harder to solve in rust, maybe to the point that I just wouldn&#39;t have done it at all. Whereas metaprogramming in zig just feels like regular programming. (See <a href="https://www.scattered-thoughts.net/writing/mmio-in-zig/">Memory-mapped IO registers in zig</a> for a taste). I just write the code that does the things that I want to happen. And if I mess it up I get a stack trace at compile time and I can insert compile-time printlns.</p><p>(By contrast, I spent most of a day in February trying to figure out how to get f64 to impl <a href="https://docs.rs/timely/0.12.0/timely/trait.ExchangeData.html">ExchangeData</a> and eventually <a href="https://github.com/jamii/streaming-consistency/blob/main/differential-dataflow/src/main.rs#L19-L23">gave up</a>.)</p><p>I&#39;ve been enjoying the easy interop with c too. I&#39;d never written c bindings in any language before, but in a year with zig I&#39;ve used libgl, sdl, freetype, pcre2, the nrf52 sdk, node-api, sqlite3, microui, nuklear, dear imgui and implot. It doesn&#39;t feel like a big deal.</p><p>I&#39;m still conflicted about security. I wrote <a href="https://www.scattered-thoughts.net/writing/how-safe-is-zig/">How safe is zig?</a>, thinking out loud. My position at the moment is that for the kinds of projects I&#39;m working on right now the main risk is not that I&#39;ll have some serious vulnerability but that I&#39;ll never ship anything at all.</p><p>It&#39;s not just <em>speed</em> of development that matters either. In zig I spend more time thinking about my actual problem and less time being frustrated at my tools. I don&#39;t miss 10 minute incremental debug builds, forking crates to work around orphan rules, looking up how declarative macros work every time I use them, procrastinating on ever learning how to write procedural macros, repeatedly forgetting how lifetimes and associated types interact etc. Every speedbump breaks my flow and reduces my motivation, and motivation is my main bottleneck.</p><h2 id="reflections">Reflections</h2><p>This series of articles was the result of various conversations where I complained about how bad most online material about programming is and people encouraged me to write down my complaints. I was aiming for one short article but it got out of hand.</p><ul><li><a href="https://www.nationalobserver.com/writing/reflections-on-a-decade-of-coding/">Reflections on a decade of coding</a></li><li><a href="https://www.nationalobserver.com/writing/on-bad-advice/">On bad advice</a></li><li><a href="https://www.nationalobserver.com/writing/things-unlearned/">Things unlearned</a></li><li><a href="https://www.nationalobserver.com/writing/emotional-management/">Emotional management</a></li><li><a href="https://www.nationalobserver.com/writing/setting-goals/">Setting goals</a></li><li><a href="https://www.nationalobserver.com/writing/speed-matters/">Speed matters</a></li><li><a href="https://www.nationalobserver.com/writing/moving-faster/">Moving faster</a></li><li><a href="https://www.nationalobserver.com/writing/coding/">Coding</a></li><li><a href="https://www.nationalobserver.com/writing/testing/">Testing</a></li><li><a href="https://www.nationalobserver.com/writing/writing/">Writing</a></li></ul><p>I&#39;m still very uncomfortable writing this kind of material, given how easy it is to be misleading or straight up wrong, but I keep getting emails from people who say they found it useful. I&#39;ll console myself that it&#39;s at least less bad than average.</p><h2 id="hytradboi">HYTRADBOI</h2><p>Late in the year I found myself accidentally organizing a conference called <a href="https://www.hytradboi.com/">Have you tried rubbing a database on it?</a>. I wrote about how that happened in <a href="https://www.nationalobserver.com/writing/why-start-a-new-database-conference/">Why start a new database conference?</a>.</p><p>In the three weeks since the website was launched 596 people signed up to be notified when tickets are available. Of the speakers I invited, 12 said yes, 3 said maybe and only 2 haven&#39;t replied. Plus another 13 proposals have been submitted via the website and there is still 2 months to go until the submission deadline.</p><p>This is so much more than I was expecting and maybe also more than I&#39;m actually prepared for. But I&#39;ll figure it out.</p><p>In January I signed up for github sponsors. I didn&#39;t expect it to be remotely successful, but Dan Luu spent several months convincing me that it was a worth a try.</p><p>He was right, I was wrong.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/72ca7a0eed9f001fefcbb134990cd4a46101b22e/36a3d/writing/2021/sponsorship.png"/></p><p>That came to ~27k CAD in 2020. If it stays at the current rate it will be ~33k CAD in 2021, which covers about 73% of my budget.</p><p>As a result of the sponsorship I spent a lot of time this year writing: 66757 words on this site and 21740 in my sponsors newsletter. That&#39;s a book!</p><p>Well over half the writing on this site was written this year. At least half of it is work I&#39;m proud of. So I think we can call the sponsors project a success. Thanks to <a href="https://github.com/sponsors/jamii/#sponsors">everyone</a> who contributed.</p><h2 id="consulting">Consulting</h2><p>Right at the end of the year I started consulting for a company who are starting a new sql implementation.</p><p>I&#39;ve turned down a lot of consulting requests in the last year because I want to have time and energy to focus on my own projects. This time I replied that I could probably only commit one day per month, thinking that they probably wouldn&#39;t be interested but that it didn&#39;t hurt to try. To my surprise they said yes.</p><p>So far it seems to be actually valuable, in that I can share all the mistakes I made at materialize and the things I would do differently if I were to do it again. If I can save them even a few engineer-days of wasted work each month then it ends up being a pretty good deal.</p><p>I&#39;ve had a few similar requests in the last few months (mostly around streaming/incremental systems rather than sql) so in the spirit of trying things I put up a <a href="https://appointmentthing.com/scattered-thoughts/OY14788">page</a> where people can pay to book a call. I&#39;m not expecting anyone to just stumble across this and give me money, but if I can streamline the process then it reduces the cost of suggesting such an arrangement the next time someone emails me.</p><h2 id="office-hours">Office hours</h2><p>I moved to Vancouver in 2019 the day before they entered their first lockdown. Between the pandemic isolation, moving to a new continent were I don&#39;t know anyone, and living for the first time in a city that is decidedly not a STEM hub, I&#39;ve been starved of nerd talk.</p><p>So in the spirit of just trying things I put up a <a href="https://appointmentthing.com/scattered-thoughts/Eb14790">page</a> where anyone can schedule a call. Three days later 12/15 slots are already booked. I have no idea how this will turn out, but I doubt I&#39;ll regret the experiment.</p><p>It is kind of strange to be simultaneously wanting to charge companies money for advice whilst also offering to talk to anyone for free. But I think people will probablhy do the right thing.</p><h2 id="2022">2022</h2><p>The main theme of 2021 for me was unexpected success. Several friends have been trying to convince me that I am systematically underconfident. Whenever I&#39;ve put that to the test by trying something that they&#39;ve suggested and that I expect to fail, they&#39;ve been right.</p><p>I&#39;m not sure exactly how to recalibrate. But it&#39;s clear that I could benefit by just trying more things that I expect to fail, especially when the costs are low.</p><hr/><p>The sponsorship curve seems to have leveled off now, but there is very little churn. Together with the trickle of consulting I&#39;ve signed up for I can comfortably cover my own expenses.</p><p>I might take on a little more consulting in 2022 because my wife has been waiting for a work permit since June 2021. Between covid and the Afghan refugee crisis the immigration office has built up a huge backlog so it probably won&#39;t arrive any time soon. It would be comforting to cover that gap.</p><hr/><p>I&#39;m not sure what I&#39;ll work on next year. I don&#39;t know if it even makes sense to plan on that timescale. But I can think about what kinds of changes I&#39;d like to see.</p><p>I want to spend less time reading blogs and forums and more time reading books and papers. When I was working at eve I spent an hour reading papers every morning, which added up to 200-400 papers per year. Much of my knowledge of databases was built on that backbone and I haven&#39;t updated it since. There is nothing on the frothy web that can offer that much value.</p><p>I&#39;ll maybe write less. The writing that I was happiest with this year was the result of deep technical work rather than quantity of writing. If in 2022 I could produce 3-4 pieces of work on par with the <a href="https://www.scattered-thoughts.net/writing/internal-consistency-in-streaming-systems/">internal consistency investigation</a> I&#39;d be very happy.</p><p>I didn&#39;t write much code this year. Depending on what measure I use, I wrote between 2-8x as much code in the year that I worked at materialize. It&#39;s always frustrating that I don&#39;t manage to put the same kind of sustained efforts into things that I care about. I think the main difference is in having to decide what to do and maintain direction, vs working towards some pre-existing goal. I don&#39;t know how to create that same kind of certainty in my own work.</p><p>Working alone probably doesn&#39;t help either, but I don&#39;t think there is much likelihood of fixing that until the world approaches normal again.</p><hr/><p>I notice that I keep drifting towards working on things that are relevant for industrial software. These problems of scale and efficiency are what is legible and respectable, so it&#39;s easier to justify projects by appealing to that framing. But the problem is that I just don&#39;t care enough about industrial software development to actually finish the work.</p><p>I&#39;ve always been much more inspired by ideas like <a href="https://www.inkandswitch.com/end-user-programming/">end-user programming</a>, <a href="https://numinous.productions/ttft/">tools for thought</a>, <a href="https://2020.programming-conference.org/home/salon-2020">convivial computing</a>, <a href="https://malleable.systems/">malleable systems</a>, <a href="https://www.scattered-thoughts.net/writing/scaling-down/">scaling down</a> and so on. And even then people want it to be justified in terms of how it will help users fulfill their role in the economy. But what I actually care about is that these machines were supposed to contain magic and we&#39;ve made them boring.</p><p>So above all what I will keep in mind next year is to forget about the things that I think I&#39;m supposed to care about and instead hunt for signs of magic.</p></article></div>
  </body>
</html>
