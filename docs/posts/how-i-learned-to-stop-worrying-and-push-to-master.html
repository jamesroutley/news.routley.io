<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thenable.io/push-to-master/">Original</a>
    <h1>How I learned to stop worrying and push to master</h1>
    
    <div id="readability-page-1" class="page"><div><p>If you&#39;ve ever worked on a team of developers of any size, your team has undoubtedly reached an agreement among your team about how your code will be branched and integrated.</p>
<p>For most of my career, I&#39;ve been following one form or another of a <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">GitFlow branching model</a>.</p>
<p>If you&#39;re not familiar with GitFlow, it is a branching model where you isolate <strong>feature branches</strong> and carefully craft them into <strong>release branches</strong> that make their way back into your <strong>master</strong> or <strong>main</strong> branch. If this sounds complicated, hang tight - I come bearing diagrams!</p>
<p>In the past couple of months, my team at <a href="https://evolutionv.com/">Evolution Virtual</a> has switched from <em>GitFlow</em> to <em>Trunk-Based Development</em>. As a result, we have observed huge gains both in our productivity and overall morale.</p>
<p>The idea behind <em>Trunk-Based Development</em> is that every commit goes straight to the <strong>main</strong> branch. These means that you often have many developers committing to the same branch multiple times a day.</p>
<h3>Why would anyone do this?</h3>
<p>Isn&#39;t it a nightmare to manage releases and bugfixes if the state of your <strong>main</strong> branch is in a constant state of metamorphosis?</p>
<p>I can already feel the nervous twitching from the <em>GitFlow</em> purists. Allow me to make my case. I believe that if you approach your branching model with an open mind, you may even end up agreeing with me.</p>
<p><img src="https://thenable.io/images/push-to-master.png" alt="How I Learned To Stop Worrying and Pushed To Master"/></p><h2>Why GitFlow Wasn&#39;t Working For Us</h2>
<p>The practice of <em>GitFlow</em> is a set of checks and balances designed to <strong>slow you down</strong>. This is by design. The theory is that if there are more stopgaps in your workflow, you will catch more mistakes and ensure higher quality code in your main branch.</p>
<p>The <em>GitFlow</em> workflow is essentially:</p>
<ul>
<li>Branch new features off of the <strong>develop</strong> branch</li>
<li>Iterate on your feature branch until it is completed</li>
<li>Merge back to <strong>develop</strong></li>
<li>A <strong>release</strong> branch is cut to merge back to the <strong>main</strong> or <strong>master</strong> branch. The <strong>main</strong> branch is the source of truth of what is deployed to production</li>
</ul>
<p><img src="https://thenable.io/images/gitflow.png" alt="GitFlow"/></p><p>In practice, slowing down the flow of integration into the <strong>main</strong> branch can arguably introduce more bugs and lower quality than moving fast and pushing smaller changes more frequently. I&#39;ll discuss why that is in a moment.</p>
<h3>GitFlow Was Slowing Us Down</h3>
<p>As I already said, slowing down the integration flow is partly by design with <em>GitFlow</em>. The issue was that slowing down our integration flow was also slowing down our rate of development.</p>
<p>Our workflow was admittedly tedious, but I don&#39;t know that there was much more ceremony than most of the other places I&#39;ve worked.</p>
<p>For a feature to be considered ready to merge into the <strong>main</strong> branch, it had to go through:</p>
<ul>
<li>Code review ( in GitHub )</li>
<li>Pass all unit tests in CI</li>
<li>Build on CircleCI</li>
<li>Get deployed to a user acceptance testing (UAT) environment</li>
<li>Pass manual and automated QA (there were often multiple rounds of QA if small details were overlooked)</li>
</ul>
<p>Our velocity was taking a huge hit.</p>
<p>Quality Assurance was under-resourced. They had a huge job of checking and re-checking every feature to verify that there were no regressions. After merging a feature into <strong>develop</strong>, they had to check again to see if there were any new issues that were introduced by bad merges or conflicting feature requirements.</p>
<p>Our team was consistently completing between 6 and 8 story points. It was simple to project out and see we were going to be missing our deadlines if nothing was adjusted.</p>
<p>By changing our flow, we went from 8 points to 16 points per sprint. In the past few weeks, as bugs started pouring in from QA, we have gotten down to 12 points, but so far we have never gone lower.</p>
<p><img src="https://media.tenor.com/images/3af4839208018dbe5b7a8786a78b1eb7/raw" alt=""/></p>
<h3>Merge Of Doom</h3>
<p>One of the biggest issues with a sophisticated branching model is that working branches tend to diverge from each other over time.</p>
<p>No matter how much you try to keep developers working on their own corners of the application, there will inevitably be overlap, and where there is overlap, there are conflicts.</p>
<p>The element of <em>time</em> compounds the problem even further. The more time that passes from the point a branch is broken off from <strong>develop</strong> to the time it is merged back in, the more opportunity there is for other branches to diverge in drastic ways.</p>
<p>A helpful illustration is to imagine you are writing a novel with one of your friends. You write the first chapter and then you ask your friend to write the second chapter while you tackle the third. Without extremely careful planning, your friend may end his chapter in a place that doesn&#39;t flow into yours. You may have different ideas of what the plot should be or who the characters really are.</p>
<p>If each chapter is fifty pages, it&#39;s almost impossible that the two will work together without heavy rewriting. However, if every chapter is only a few sentences, you&#39;ll have more opportunity to course correct as you discover new elements of the story.</p>
<p>Like our novel example, we actually reduce the chance of big conflicts the more frequently we push to our source of truth.</p>
<p>Conflicts are costly when managed well. In the past, we would often pair program through our merge conflicts to make sure we weren&#39;t accidentally overwriting something important that another developer had worked on.</p>
<p>It would often mean a couple of hours a week with two or more developers comparing notes on a conflict, trying to make sure our changes didn&#39;t get lost.</p>
<p>When managed poorly, conflicts can be even more costly.</p>
<p>Features we thought were completed would sometimes be missing important requirements that had been overwritten. Bugs that were fixed would be broken again. New bugs would be introduced.</p>
<p>The threshold of conflict was amplified by the time that passed between when a branch was cut from develop to the time when it was merged back.</p>
<p>For bigger features, a branch&#39;s life could last one or even two weeks. The more time that passed, the greater divergence there would be from the other code.</p>
<p>If a feature was left undone for a month or more, it was almost impossible to resurrect and merge back into the codebase because the shape of the codebase would change so much over time.</p>
<p><img src="https://c.tenor.com/ye8cOK2ZjrMAAAAd/phantom-menace.gif" alt=""/></p>
<h2>The Solution: Delete All the Branches</h2>
<p>One day, I was programming something and couldn&#39;t get it working. My eight year old son came upstairs. I decided to use him as my <a href="https://rubberduckdebugging.com/">rubber duck</a>. After I explained the issue in a way I thought an eight your old could grasp, he looked at me and said &#34;why don&#39;t you just delete all your code and start over?&#34;</p>
<p>What I&#39;m proposing here is a <em>process equivalent</em> to deleting all of your code. What I&#39;m proposing is deleting all of your branches. Well, all of your branches but one.</p>
<p>This all came together for me when I was catching up on YouTube and stumbled across Dave Farley&#39;s video
<a href="https://www.youtube.com/watch?v=v4Ijkq6Myfc">Continuous Integration vs Feature Branch Workflow</a>. He explained many of the inherent problems that I was seeing in my team&#39;s ability to deliver code quickly.</p>
<p>To be fair, I have always done <em>Trunk-Based Development</em> on personal projects and open-source libraries, but never in a team setting. My question was whether <em>Continuous Integration</em> could work in the real world with multiple developers pushing code constantly. I did some investigation and a lot of large companies use the <em>Continuous Integration</em> model. If it worked for them, it should be able to work for us.</p>
<p>With <em>Trunk-Based Development</em> (or <em>Continuous Integration</em>), developers are encouraged to push their code to the <strong>main</strong> branch frequently. Not just when a feature is finished, but every time there is new meaningful working code.</p>
<p>The trick is to separate code deployments from new features becoming available. We found that features can be toggled on and off with feature flags, so our code releases could become separate from our feature releases. This allowed us to push incomplete features frequently without a fear of releasing anything half-baked.</p>
<p><img src="https://thenable.io/images/Trunk-Based.png" alt="Trunk Based Flow"/></p><h2>The Changes We Made</h2>
<p>Moving to continuous integration meant changing our processes at many levels.</p>
<p>I considered all of the things that were slowing us down from the point of a developer finishing a task to the code finally getting merged. Our team has made the following adjustments:</p>
<h3>Code Reviews After Merge</h3>
<p>Before moving away from <em>GitFlow</em>, we reviewed our code before merging it using GitHub&#39;s pull requests.</p>
<p>Since we didn&#39;t have <em>branches</em> anymore, we also didn&#39;t have <em>pull requests</em>.</p>
<p>Our code reviews needed to take place at a different point in the process.</p>
<p>We have transitioned to having a meeting once a week where we walk through the code that was committed the previous week.</p>
<p>Code review is a time to make suggestions on ways we can improve our codebase. We find areas where we&#39;re duplicating code and refactor it. We use the time as an opportunity to gain a better understanding of the pieces of the system that we haven&#39;t personally touched.</p>
<p>I feel that post-merge code reviews have actually been more productive than the asynchronous pull requests we were doing before. It gives each developer an opportunity to explain their intent and the reason they made each choice.</p>
<h3>QA In Staging</h3>
<p>On a typical day, we will push code to the <strong>main</strong> branch between 10 and 20 times. If the code builds and the tests pass, it automatically deploys to a <strong>staging</strong> environment.</p>
<p>Before switching to <em>Trunk-Based Development</em>, we were building ephemeral UAT environments for each feature. Each feature was independently tested before graduating to the <strong>develop</strong> branch, merging into <strong>staging</strong> and getting deployed to <strong>production</strong>.</p>
<p>We have now eliminated every environment but <strong>staging</strong> and <strong>production</strong>.</p>
<p>We are now using <a href="https://docs.serverless-stack.com/">Serverless Stack (SST)</a> for all of our serverless infrastructure. Since we&#39;re able to run our own infrastructure for local development, our local environment essentially serves as a testing sandbox for our features prior to getting merged back to the <strong>main</strong> branch.</p>
<p>We do have a manual QA step in <strong>staging</strong>, but since we are continuously integrating our code, every issue that is found is considered a new bug in our system. We do have more bug tickets than we did before changing our process, but it also allows us to complete features more quickly and iterate on them.</p>
<p>Iterating through bug tickets has helped to allow us to do less context switching. We can finish the task that we&#39;re working on and then tackle bugs that come in below it.</p>
<p>When we do start work on a bug or a feature, it is always in the context of the latest state of the <strong>main</strong> branch.</p>
<h3>Manual Release to Production</h3>
<p>After our code automatically deploys to <strong>staging</strong>, it goes into a hold state. At that point, we can click a button and it will release to <strong>production</strong> once we manually verify that there are no regressions.</p>
<p>We can release to <strong>production</strong> as often as needed, but so far, it&#39;s usually been once or twice a week.</p>
<h3>Are We Even Really Agile Now?</h3>
<p>Because of the new flow, we barely have formal sprints. We do continue to do daily standups as well as some informal pop-up sprint planning sessions.</p>
<p>We aren&#39;t exactly doing a sprint. We are pushing continual value to our users. Our flow is basically <a href="https://en.wikipedia.org/wiki/Kanban">Kanban</a> and it honestly works really well with the <em>Continuous Integration</em> flow.</p>
<p>That said, I think what we&#39;re doing is very much in line with the <em>spirit</em> of Agile. The first principle of the Agile manifesto is <strong>&#34;Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.&#34;</strong></p>
<p>Our process is designed to continuously deliver valuable software, so if Agile is about people over processes, I think we may check the box.</p>
<h2>Is It Working?</h2>
<p>For our team, the answer is definitely yes.</p>
<p>I&#39;m always hesitant to be overly prescriptive about particular solutions or processes, but in our case, we&#39;ve doubled and tripled our productivity. We have gotten much more responsive to issues and bugs. We barely ever have a merge conflict that is more than a couple of lines of easily resolved code.</p>
<p>That said, <em>GitFlow</em> and other git branching strategies work well for a lot of people. If it works for you, I say keep doing what you&#39;re doing. For the rest of us, <em>Continuous Integration</em> has been a breath of fresh air!</p></div></div>
  </body>
</html>
