<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/XWindowsAllTheWayDown">Original</a>
    <h1>A peculiarity of the X Window System: Windows all the way down</h1>
    
    <div id="readability-page-1" class="page"><div><h2>A peculiarity of the X Window System: Windows all the way down</h2>

	<p><small>March  5, 2024</small></p>
</div><div><p>Every window system has windows, as an entity. Usually we think of these
as being used for, well, windows and window like things; application
windows, those extremely annoying pop-up modal dialogs that are always
interrupting you at the wrong time, even perhaps things like pop-up
menus. In its original state, X has more windows than that. Part of how
and why it does this is that X allows windows to nest inside each other,
in a window tree, which you can still see today with &#39;<code>xwininfo -root
-tree</code>&#39;.</p>

<p>One of the reasons that X has copious nested windows is that X was
designed with a particular model of writing X programs in mind, and
that model made everything into a (nested) window. Seriously,
everything. In an old fashioned X application, windows are everywhere.
Buttons are windows (or several windows if they&#39;re radio buttons
or the like), text areas are windows, menu entries are each a
window of their own within the window that is the menu, visible
containers of things are windows (with more windows nested inside
them), and so on.</p>

<p>This copious use of windows allows a lot of things to happen on the
server side, because various things (like mouse cursors) are defined
on a per-window basis, and also <a href="https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#requests:CreateWindow">windows can be created with things
like server-set borders</a>.
So the X server can render sub-window borders to give your buttons
an outline and automatically change the cursor when the mouse moves
into and out of a sub-window, all without the client having to do
anything. And often input events like mouse clicks or keys can be
specifically tied to some sub-window, so your program doesn&#39;t have
to hunt through its widget geometry to figure out what was clicked.
There are more tricks; for example, you can get &#39;enter&#39; and &#39;leave&#39;
events when the mouse enters or leaves a (sub)window, which programs
can use to highlight the current thing (ie, subwindow) under the
cursor without the full cost of constantly tracking mouse motion
and working out what widget is under the cursor every time.</p>

<p>The old, classical X toolkits like <a href="https://en.wikipedia.org/wiki/X_Toolkit_Intrinsics">Xt</a> and <a href="https://en.wikipedia.org/wiki/X_Athena_Widgets">the
Athena widget set (Xaw)</a>
heavily used this &#39;tree of nested windows&#39; approach, and you can
still see large window trees with &#39;<code>xwininfo</code>&#39; when you apply it
to old applications with lots of visible buttons; one example is
&#39;xfontsel&#39;. Even the venerable xterm normally contains a nested
window (for the scrollbar, which I believe it uses partly to
automatically change the X cursor when you move the mouse into the
scrollbar). However, this doesn&#39;t seem to be universal; when I look
at <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/ToolsXrun">one Xaw-based application</a> I have handy,
it doesn&#39;t seem to use subwindows despite having <a href="https://www.x.org/releases/current/doc/libXaw/libXaw.html#List_Widget">a list widget
of things to click on</a>.
Presumably in Xaw and perhaps Xt it depends on what sort of widget
you&#39;re using, with some widgets using sub-windows and some not.
<a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/ToolsPyhosts">Another program</a>, written using <a href="https://www.tcl.tk/">Tk</a>, does use subwindows for its buttons (with
them clearly visible in &#39;<code>xwininfo -tree</code>&#39;).</p>

<p>This approach fell out of favour for various reasons, but certainly
one significant one is that it&#39;s strongly tied to <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/XRenderingVsWaylandRendering">X&#39;s server side
rendering</a>. Because these subwindows
are &#39;on top of&#39; their parent (sub)windows, they have to be rendered
individually; otherwise they&#39;ll cover what was rendered into the
parent (and naturally they clip what is rendered to them to their
visible boundaries). If you&#39;re sending rendering commands to the
server, this is just a matter of what windows they&#39;re for and what
coordinates you draw at, but if you render on the client, you have
to ship over a ton of little buffers (one for each sub-window)
instead of one big one for your whole window, and in fact you&#39;re
probably sending extra data (the parts of all of the parent windows
that gets covered up by child windows).</p>

<p>So in modern toolkits, the top level window and everything in it
is generally only one X window with no nested subwindows, and all
buttons and other UI elements are drawn by the client directly into
that window (usually with client side drawing). The client itself
tracks the mouse pointer and sends &#39;change the cursors to &lt;X&gt;&#39; requests
to the server as the pointer moves in and out of UI elements that
should have different mouse cursors, and when it gets events, the
client searches its own widget hierarchy to decide what should handle
them (possibly including <a href="https://en.wikipedia.org/wiki/Client-side_decoration">client side window decorations (CSD)</a>).</p>

<p>(I think toolkits may create some invisible sub-windows for event
handling reasons. Gnome-terminal and other Gnome applications appear to
create a 1x1 sub-window, for example.)</p>

<p>As a side note, another place you can still find this many-window
style is in some old fashioned X window managers, such as
<a href="https://fvwm.org/">fvwm</a>. When fvwm puts a frame around a
window (such as the ones visible on windows on <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/MyDesktopTour">my desktop</a>), the specific elements of the frame
(the title bar, any buttons in the title bar, the side and corner
drag-to-resize areas, and so on) are all separate X sub-windows. One
thing I believe this is used for is to automatically show an appropriate
mouse cursor when the mouse is over the right spot. For example, if
your mouse is in the right side &#39;grab to resize right&#39; border, the mouse
cursor changes to show you this.</p>

<p>(The window managers for modern desktops, like Cinnamon, don&#39;t handle
their window manager decorations like this; they draw everything as
decorations and handle the &#39;widget&#39; nature of title bar buttons and so
on internally.)</p>
</div></div>
  </body>
</html>
