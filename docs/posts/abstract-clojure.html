<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.juxt.pro/blog/abstract-clojure">Original</a>
    
    <div id="readability-page-1" class="page"><div><div id="preamble">
<div>
<p>A great deal can be achieved in the first few years of a software project, with a small team and the right tools we can quickly deliver features to appease both businesses and their clients. In the early stages of a project, delivery is often prioritised over architecture, but the architecture needs to evolve if the software is to be developed and maintained in the longer term. Any project that lives for longer than a few years will experience change, business requirements will change, developers will come and go, platform services on which the software depends will be deprecated and replaced, deployment environments will change, and new technologies will offer new possibilities as older technologies become obsolete.</p>
<p>Abstraction is at the heart of software architecture, separating <code>what</code> from <code>how</code> enables us to focus on the core business problem we are trying to solve without getting lost in the details of a particular implementation.</p>
</div>
</div>
<div>
<h2 id="_abstraction"><a href="#_abstraction"></a>Abstraction</h2>
<div>
<div>
<blockquote>
<p>Depend on abstractions, not on concretions</p>
</blockquote>
<p>
— Dependency Inversion Principle
</p>
</div>
<p>Concretion is when we depend on implementations as opposed to abstractions, consider the following application that exposes a REST API to retrieve a blog article from a SQL database:</p>
<div>
<div>
<pre><code data-lang="clojure">(ns app.db
  (:require [next.jdbc.sql :as sql]))

(defn get-article-by-id
  &#34;`data-source`: javax.sql.DataSource, `id`: article id&#34;
  [data-source id]
  (sql/get-by-id data-source :article id))</code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="clojure">(ns app.server
  (:require [app.db :as db]
            [reitit.ring :as ring]))

(defn get-article [data-source request]
  (let [id (get-in request [:path-params :id])
        article (db/get-article-by-id data-source id)]
    {:status 200
     :body article}))

(defn router [data-source]
  (ring/router
    [[&#34;/api/article/:id&#34; {:get {:parameters {:path {:id int?}}}
                          :handler #(get-article data-source %)}]]))</code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="clojure">(ns app.system
  (:require [app.server :as server]
            [next.jdbc :as jdbc]))

(defn init [db-spec]
  (let [data-source (jdbc/get-datasource db-spec) ;; javax.sql.DataSource
        router      (server/router data-source)] ;; reitit.core/Router
    ...))</code></pre>
</div>
</div>
<p>In the example, <code>get-article</code> is coupled to the implementation <code>get-article-by-id</code>; the router is coupled to <code>get-article</code>. The result is a rippling effect that requires the router and the handler to be aware of the <code>data-source</code> yet the only function that needs to know about the <code>data-source</code> is <code>get-article-by-id</code>. We need a running SQL database to test the current routing implementation.</p>
<p>We can invert the dependencies using abstraction. If we use the same signature as <code>db/get-article-by-id</code> but remove the <code>data-source</code> we are left with a function that takes an <code>id</code> and returns an <code>article</code>:</p>
<div>
<div>
<pre><code data-lang="clojure">(fn get-article-by-id [id]
  article)</code></pre>
</div>
</div>
<p>We can construct an implementation of our abstraction using higher-order functions:</p>
<div>
<div>
<pre><code data-lang="clojure">(fn [id]
  (db/get-article-by-id data-source id))

(partial db/get-article-by-id data-source)

#(db/get-article-by-id data-source %)</code></pre>
</div>
</div>
<p>We can now pass a function to <code>server/get-article</code> where we previously passed the <code>data-source</code>, resulting in a pure function:</p>
<div>
<div>
<pre><code data-lang="clojure">(defn get-article
 &#34;`get-article-by-id`: (fn [id] article)&#34;
 [get-article-by-id request]
  (let [id (get-in request [:path-params :id])
        article (get-article-by-id id)]
    {:status 200
     :body article}))</code></pre>
</div>
</div>
<p>Following the same approach, we can remove the first parameter of <code>get-article</code> to form our next abstraction; a request handler:</p>
<div>
<div>
<pre><code data-lang="clojure">(fn handler [request]
  response)

#(server/get-article get-article-by-id %)</code></pre>
</div>
</div>
<p>The last change required is to the router; we need a way to pass in the handler. Our example shows a single route, but in practice, we are likely to have many; we can use a function that takes a <code>route</code> key and returns a handler:</p>
<div>
<div>
<pre><code data-lang="clojure">(fn route-&gt;handler [route]
  (fn handler [request]
    response))</code></pre>
</div>
</div>
<p>We can implement <code>route→handler</code> using a map:</p>
<div>
<div>
<pre><code data-lang="clojure">{:get-article #(server/get-article get-article-by-id %)}</code></pre>
</div>
</div>
<p>We have now decoupled the router and handler, and removed the <code>data-source</code> dependency:</p>
<div>
<div>
<pre><code data-lang="clojure">(ns app.server
  (:require [reitit.ring :as ring]))

(defn get-article
 &#34;`get-article-by-id`: (fn [id] article)&#34;
 [get-article-by-id request]
  (let [id (get-in request [:path-params :id])
        article (get-article-by-id id)]
    {:status 200
     :body article}))

(defn router
  &#34;`route-&gt;handler`: (fn [route] (fn [request] response))&#34;
  [route-&gt;handler]
  (ring/router [[&#34;/api/article/:id&#34; {:get {:parameters {:path {:id int?}}}
                                     :handler (route-&gt;handler :get-article)}]]))</code></pre>
</div>
</div>
<p>At first glance, it may seem like a small change, but the refactored version is significantly different: the functions are now pure and can be tested in isolation without a running database.</p>
<p>We can <a href="https://blog.thecodewhisperer.com/permalink/liskov-substitution-principle-demystified">substitute</a> <code>get-article-by-id</code> for any function with the same signature without any change to the <code>app.server</code> code. This could be a stub/mock during testing, a wrapper that adds monitoring/logging/caching, or an alternative implementation that fetches the article from a different database or external source.</p>
<p>The router has a <a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html">single responsibility</a>: routing an incoming request to a handler. The handler also has a single responsibility: transforming the incoming request into an internal call where the action is performed.</p>
<div>
<h3 id="_protocols"><a href="#_protocols"></a>Protocols</h3>
<p>The <a href="https://clojure.org/reference/protocols">protocol</a> is another form of abstraction we can use to decouple modules, the approach is more object-oriented than functional, but protocols can be useful where we desire a more formal abstraction, or where it makes sense to form a <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">cohesive</a> collection of behaviours. In the previous example, we used a single function for the abstraction to retrieve an article, alternatively, we could use the <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design">Repository Pattern</a> popularised by Domain Driven Design:</p>
<div>
<div>
<pre><code data-lang="clojure">(ns app.article-repository)

(defprotocol ArticleRepository
  (create [_ article])
  (get-by-id [_ id])
  (publish [_ id])
  (archive [_ id])
  (update-title [_ id title]))</code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="clojure">(ns app.db
  (:require [app.article-repository :refer [ArticleRepository]]
            [next.jdbc.sql :as sql]))

(defrecord SqlArticleRepository [data-source]
  ArticleRepository
  (get-by-id [_ id]
    (sql/get-by-id data-source :article id))
  ...)</code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="clojure">(ns app.server
  (:require [reitit.ring :as ring]
            [app.article-repository :as article-repository]))

(defn get-article [article-repository request]
  (let [id (get-in request [:path-params :id])
        article (article-repository/get-by-id article-repository id)]
    {:status 200
     :body article}))</code></pre>
</div>
</div>
<p>The interface in this example is more formal in that we require the repository namespace and refer to it directly, this is different from the initial use of referring to the function defined via <code>defn</code> as we refer to the abstraction, not the concretion of the protocol defined in <code>app.db</code>.</p>
<p>It is more verbose, but it may be preferable to pass around instances of protocols than to pass around lots of functions, particularly where many behaviours are needed that are closely related; ultimately, it comes down to a matter of style. One of the advantages of protocols over functions is that it is clearer to the reader what a function depends on; we <code>require</code> the namespace and our code points to where the protocol is defined. On the other hand, this is not as flexible or as concise as the functional alternative.</p>
</div>
</div>
</div>
<div>
<h2 id="_composition"><a href="#_composition"></a>Composition</h2>
<div>
<p>We achieved decoupling by introducing abstractions, the next step is to compose our functions into a system. We start by creating a <code>data-source</code> and using an anonymous function to wrap <code>db/get-article-by-id</code> resulting in a function <code>(fn [id] article)</code>. The <code>get-article-handler</code> is created in the same way, resulting in a function <code>(fn [request] response)</code> which is placed inside a map to construct the <code>route→handler</code> abstraction:</p>
<div>
<div>
<pre><code data-lang="clojure">(ns app.system
  (:require [app.db :as db]
            [app.server :as server]
            [next.jdbc :as jdbc]))

(defn init [db-spec]
  (let [data-source         (jdbc/get-datasource db-spec)               ;; javax.sql.DataSource
        get-article-by-id   #(db/get-article-by-id data-source %)       ;; (fn [id] article)
        get-article-handler #(server/get-article get-article-by-id %)   ;; (fn [request] response)
        route-&gt;handler      {:get-article get-article-handler}          ;; (fn [route] (fn [request] response))
        router              (server/router route-&gt;handler)]             ;; reitit.core/Router
    ...))</code></pre>
</div>
</div>
<p>One of the trade-offs with this approach is that it results in additional wiring; functions must be passed their dependencies and wired together to form a system. The indirection means we can no longer jump to the definition of <code>get-article-by-id</code> in the server namespace. Whether the trade-offs are worth it is for you to decide; the abstraction may be premature for short-lived projects, but decoupling can help ensure larger projects are easier to maintain.</p>
<p>Composing large systems can be challenging. Processes need to be started and stopped in a particular order and the graph of dependencies can be large when following the Dependency Inversion Principle. We often reach out to frameworks such as <a href="https://github.com/stuartsierra/component">Component</a> or <a href="https://github.com/weavejester/integrant">Integrant</a> to help us construct larger systems, at the time of writing Integrant is the recommended option on our <a href="https://www.juxt.pro/radar">Clojure Radar</a>.</p>
<p>The code to construct a system with Integrant is similar to the code we defined in the <code>let</code> binding:</p>
<div>
<div>
<pre><code data-lang="clojure">(defmethod ig/init-key ::get-article-by-id [_ {:keys [data-source]}]
  #(db/get-article-by-id data-source %))

(defmethod ig/init-key ::get-article-handler [_ {:keys [get-article-by-id]}]
  #(server/get-article get-article-by-id %))

(defmethod ig/init-key ::router [_ {:keys [route-&gt;handler]}]
  (server/router route-&gt;handler))</code></pre>
</div>
</div>
<p>With the system declared in a map:</p>
<div>
<div>
<pre><code data-lang="clojure">{::data-source {:db-spec db-spec}
 ::get-article-by-id {:data-source (ig/ref ::data-source)}
 ::get-article-handler {:get-article-by-id (ig/ref ::get-article-by-id)}
 ::router {:route-&gt;handler {:get-article (ig/ref ::get-article-handler)}}}</code></pre>
</div>
</div>
<p>As the system grows, we can split it up into cohesive modules, with maps created per module, then merged to form larger systems. We can make use of <a href="https://github.com/weavejester/integrant#specs">ig/pre-init-spec</a> to assert the dependencies are as expected:</p>
<div>
<div>
<pre><code data-lang="clojure">(s/def ::data-source #(instance? javax.sql.DataSource %))

(defmethod ig/pre-init-spec ::get-article-by-id [_]
  (s/keys :req-un [::data-source]))</code></pre>
</div>
</div>
<p>Protocols work well here; we can validate them using <a href="https://clojuredocs.org/clojure.core/satisfies_q">satisfies?</a> and catch wiring issues as the system is initialised:</p>
<div>
<div>
<pre><code data-lang="clojure">(s/def ::article-repository #(satisfies? ArticleRepository %))

(defmethod ig/pre-init-spec ::get-article-handler [_]
  (s/keys ::req-un [::article-repository]))

(defmethod ig/init-key ::get-article-handler [_ {:keys [article-repository]}]
  #(server/get-article article-repository %))</code></pre>
</div>
</div>
<p>Frameworks such as Component or Integrant can help us when building larger systems, but we should take care to keep them at the periphery, design decisions taken by frameworks can have an impact on the design within your project. If you find yourself forced into using a certain data structure within your internal code to meet the restrictions of a framework you should consider whether it is helping or hindering your architecture.</p>
</div>
</div>
<div>
<h2 id="_stability"><a href="#_stability"></a>Stability</h2>
<div>
<div>
<blockquote>
<p>Depend in the direction of stability</p>
</blockquote>
<p>
— Stable Dependencies Principle
</p>
</div>
<p>Every system has stable and volatile components. In Clojure, we can consider a function to be stable if it is <a href="https://lispcast.com/what-is-referential-transparency">referentially transparent</a>, conversely, we can consider any function which talks to the outside world or depends on something not referentially transparent as being volatile.</p>
<p>In our example application, the database is a volatile component which in turn makes the server and system namespaces unstable. The red arrows on the diagram show the components that are volatile due to their dependencies:</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-article-pre-abstraction.png" alt="abstract clojure article pre abstraction"/>
</p>
</div>
<p>With the abstractions introduced, the <code>server</code> namespace no longer depends on the volatile dependency; it is now a stable component.</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-article-post-abstraction.png" alt="abstract clojure article post abstraction"/>
</p>
</div>
<p>The alternate implementation with the <code>ArticleRepository</code> protocol has additional arrows shown in light green that point to the protocol:</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-article-post-abstraction-protocol.png" alt="abstract clojure article post abstraction protocol"/>
</p>
</div>
<div>
<h3 id="_example_project_management_application"><a href="#_example_project_management_application"></a>Example: Project Management Application</h3>
<p>With such a trivial example the benefits of decoupling are perhaps not so obvious, consider a more complicated example of a project management application where users can create projects and manage tickets within a project, with notifications sent when the ticket status changes:</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-project-management-app-high-level.png" alt="abstract clojure project management app high level"/>
</p>
</div>
<p>The managed services are volatile components, and implementations are required directly throughout the project, resulting in a tightly coupled system where everything is volatile. Whilst some components within a system must be volatile it is not desirable for everything to be volatile.</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-project-management-pre-abstraction.png" alt="abstract clojure project management pre abstraction"/>
</p>
</div>
</div>
</div>
</div>
<div>
<h2 id="_layered_architectures"><a href="#_layered_architectures"></a>Layered Architectures</h2>
<div>
<p>The Hexagonal Architecture, Onion Architecture, <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>, and <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Functional Core, Imperative Shell</a> all put high-level business logic at the core of the application and make use of layers to keep low-level details such as the database and transport protocols at the periphery.</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-layered-architecture.png" alt="abstract clojure layered architecture"/>
</p>
</div>
<p>We can split the project management application into layers, separating the core domain from the implementation specifics. The result is a <code>domain</code> layer that depends only on abstractions and has no knowledge of external dependencies; notice that the arrows never point from the domain to the infrastructure layer. Abstractions are implemented in the <code>infrastructure</code> layer and wired together to form a system:</p>
<div>
<p><img src="https://juxt-resources.netlify.app/img/abstract-clojure-project-management-post-abstraction.png" alt="abstract clojure project management post abstraction"/>
</p>
</div>
<p>There are more nodes on the layered architecture and more edges where abstractions have been introduced, but the graph is not as deep and all components in the domain are now stable. The volatile components in the infrastructure provide implementations for the abstractions in the domain layer, the relationships within the domain layer remain the same but are now provided via abstractions.</p>
</div>
</div>
<div>
<h2 id="_conclusion"><a href="#_conclusion"></a>Conclusion</h2>
<div>
<div>
<blockquote>
<p>Recognize that when you simplify things, you often end up with more things. Simplicity is not about counting. I’d rather have more things hanging nice, straight down, not twisted together, than just a couple of things tied in a knot. And the beautiful thing about making them separate is you’ll have a lot more ability to change it, which is where I think the benefits lie.</p>
</blockquote>

</div>
<div>
<blockquote>
<p>Strictly separating what from how is the key to making how somebody else’s problem. If you’ve done this really well, you can pawn off the work of how on somebody else. You can say database engine, you figure out how to do this thing or, logic engine, you figure out how to search for this. I don’t need to know.</p>
</blockquote>

</div>
<p>Abstractions are fundamental if we strive to design larger systems that are simple and maintainable in the long term. Look at your own codebase and see where you’re tied to a certain implementation, draw a graph and see where all the arrows point, find the volatile components and consider introducing abstractions to decouple modules and to separate <code>what</code> from <code>how</code>.</p>
<p>Software design is a well researched and understood problem, patterns and principles have been widely adopted since the start of the century, with many of the ideas the solutions are based on coming decades before that. Many of the ideas are equally applicable to functional programming and they can help us design applications that are maintainable in the longer term.</p>
<p><em>Image credit:</em> <a href="https://twitter.com/jackrusher/status/1451258627310903296">jackrusher</a> Generative art crafted in Clojure!</p>

</div>
</div></div></div>
  </body>
</html>
