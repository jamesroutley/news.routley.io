<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2895.htm">Original</a>
    <h1>A simple defer feature for C</h1>
    
    <div id="readability-page-1" class="page">
  



<nav id="TOC">
<ul>
<li><a href="#revision-history">Revision history</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#rationale">Rationale</a><ul>
<li><a href="#simplifying-the-feature-by-using-lambdas">Simplifying the feature by using lambdas</a></li>
</ul></li>
<li><a href="#existing-practice-for-c">Existing practice for C</a><ul>
<li><a href="#posix-pthread_cleanup_push-and-pthread_cleanup_pop-for-thread-cancelation">POSIX’ <code>pthread_cleanup_push</code> and <code>pthread_cleanup_pop</code> for thread cancelation</a></li>
<li><a href="#microsoft-__try-and-__finally-extentions">Microsoft <code>__try</code> and <code>__finally</code> extentions</a></li>
<li><a href="#the-cleanup-attribute">The <code>cleanup</code> attribute</a></li>
</ul></li>
<li><a href="#design-choices">Design choices</a><ul>
<li><a href="#possible-scopes-of-attachment">Possible scopes of attachment</a></li>
<li><a href="#fixed-order-of-encounter-of-defer-declarations">Fixed order of encounter of <strong><code>defer</code></strong> declarations</a></li>
<li><a href="#behavior-under-abnormal-termination-of-the-block">Behavior under abnormal termination of the block</a></li>
</ul></li>
<li><a href="#suggested-changes">Suggested changes</a><ul>
<li><a href="#syntax-anchor">Syntax anchor</a></li>
<li><a href="#specific-clause">Specific clause</a></li>
<li><a href="#optional-addition-for-thrd_exit-exit-abort-sigint-sigterm-and-sigabrt">Optional addition for <code>thrd_exit</code>, <code>exit</code>, <code>abort</code>, <code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGABRT</code></a></li>
<li><a href="#alternative-version-for-thrd_exit-exit-abort-sigint-sigterm-and-sigabrt-with-feature-tests">Alternative version for <code>thrd_exit</code>, <code>exit</code>, <code>abort</code>, <code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGABRT</code> with feature tests</a></li>
<li><a href="#optional-addition-of-an-example">Optional addition of an example</a></li>
</ul></li>
<li><a href="#possible-future-extensions">Possible future extensions</a><ul>
<li><a href="#default-versions-of-captures">Default versions of captures</a></li>
<li><a href="#possible-syntax-extensions">Possible syntax extensions</a></li>
<li><a href="#defer-in-file-scope">Defer in file scope</a></li>
</ul></li>
<li><a href="#questions-to-wg14">Questions to WG14</a><ul>
<li><a href="#base">Base</a></li>
<li><a href="#options-for-abnormal-termination">Options for abnormal termination</a></li>
<li><a href="#example">Example</a></li>
</ul></li>
</ul>
</nav>
<table>
<tbody>
<tr>
<td>org:</td>
<td>ISO/IEC JCT1/SC22/WG14</td>
<td>document:</td>
<td>N2895</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>target:</td>
<td>IS 9899:2023</td>
<td>version:</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>date:</td>
<td>2021-12-31</td>
<td>license:</td>
<td><a href="https://creativecommons.org/licenses/by/4.0/" title="Distributed under a Creative Commons Attribution 4.0 International License">CC BY</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr/>
<blockquote>
<blockquote>
<blockquote>
<p><strong>The final html for WG14 is produced with a little script, so please don’t worry too much about page layout or similar.</strong></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong>Also paper numbers like 2895 will be replaced automatically.</strong></p>
</blockquote>
</blockquote>
</blockquote>
<hr/>
<h2 id="revision-history">Revision history</h2>
<table>
<thead>
<tr>
<th>Paper number</th>
<th>Title</th>
<th>Changes</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>N2542</td>
<td>Defer Mechanism for C</td>
<td>Initial version</td>
<td>WG14 poll:</td>
</tr>
<tr>
<td>N2895</td>
<td>A simple <strong><code>defer</code></strong> feature for C</td>
<td>split of N2542</td>
<td>complicated parts → TR</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>based on lambdas</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="introduction">Introduction</h2>
<p>Many implementations provide extensions that allow programmers to attach a block of cleanup code to another block or function such that this cleanup code is executed unconditionally when execution of the block is terminated. These existing extensions don’t have a unified API, some use pseudo-function calls, some compiler specific attributes and yet another a try/finally notion.</p>
<p>In a follow-up to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf">N2542</a>. we propose to encapsulate these extensions by a feature called <strong><code>defer</code></strong> that is syntactically and semantically inspired by the similar construct in the golang programming language. For an exhaustive overview on the possible extensions to the feature as proposed here, please refer to the link above.</p>
<p>For this paper here we make the assumption that simple lambdas are integrated into C23. Thereby the addition of the <strong><code>defer</code></strong> feature is much easier. Several properties of deferred statements that were contentious can be left to the programmer; they can be tuned according to each individual use case.</p>
<h2 id="rationale">Rationale</h2>
<p>Consistent resource management is key for the security of modern applications. Many modern programming languages (such as C++, Go, D, or Java), operating systems (such as POSIX) or libraries (such as boost) provide proper constructs to specify callbacks that are automatically launched on the exit of a block or function. For the complete motivation for this paper and the provided feature see <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf">N2542</a>. For this paper here we concentrate on the functional intersection of several existing extensions to the C programming language that are implemented in the field; since none of these extensions is predominant and since they are syntactically quite different, we propose to map these on a similar feature as it is found in Go, coined <strong><code>defer</code></strong>.</p>
<p>The top-level view of this feature is that each defer declaration specifies a callback for which the execution is deferred until the current scope is left for whatever reason. For a given resource, this allows to specify a callback close to the resource definition, that “cleans up” at the end; it avoids the necessity to specify cleanup during further processing, each time that a exceptional condition is met.</p>
<h3 id="simplifying-the-feature-by-using-lambdas">Simplifying the feature by using lambdas</h3>
<p>This paper builds on the assumption that at least simple lambdas are integrated into C23; otherwise it is obsolete. That assumption helps to simplify the proposal a lot and evacuates certain points that had be contentious, even between the original authors of <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf">N2542</a>.</p>
<h4 id="status-of-the-access-to-variables">Status of the access to variables</h4>
<p>In a defer <em>statement</em> that would be formulated with a compound statement as in</p>

<p>it would not be clear which value of <code>q</code> would be used for the call to <code>free</code> at the end of the surrounding block. Would it be the current value of <code>q</code> at the moment when the <strong><code>defer</code></strong> is met, or would it be the value that <code>q</code> has at the end of the execution of the block?</p>
<p>People were much divided here and it was not possible to reach a satisfying consensus, so probably the community is not (yet?) ready to establish a default behavior for that choice.</p>
<h4 id="basic-models-for-the-usage-of-captures">Basic models for the usage of captures</h4>
<p>In this proposal we use lambdas to specify the defer callback and thus the decision about the point of evaluation of variables boils down all naturally to captures. <!-- comment --> So it is the user who will explicitly chose one model or the other according to their needs. There are several principal scenarios.</p>
<h5 id="explicit-shadow-capture">explicit shadow capture</h5>

<p>Here, <code>q</code> is explicitly listed in the capture list and the value is frozen at the point of the <strong><code>defer</code></strong> and a new local object <code>q</code> shadows the use inside the defer callback.</p>
<h5 id="explicit-identifier-capture">explicit identifier capture</h5>

<p><code>q</code> is explicitly listed as identifier capture. The identifier is evaluated when the defer callback is executed; in that case with the execution of the callback sees the last value of <code>q</code> when leaving the surrounding function or lambda.</p>
<h5 id="explicit-reference-as-value-capture">explicit reference as value capture</h5>

<p>An alternative to an identifier capture could be to take the address of the corresponding variable explicitly and memorize it in a value capture.</p>
<h5 id="default-shadow-capture">default shadow capture</h5>

<p>All variables (and so <code>q</code>) are shadow captures and the value is frozen at the point of the <strong><code>defer</code></strong>.</p>
<h5 id="default-identifier-capture">default identifier capture</h5>

<p>All variables (and so <code>q</code>) are identifier captures and the value is determined when the defer callback is executed.</p>
<h4 id="better-expressivity">Better expressivity</h4>
<p>Using lambdas makes it even possible to use mixed captures as in the following.</p>

<p>Here is possible to capture the initial value of <code>q</code> and use this inside the defer callback to test if the initial buffer (an automatic array) has been replaced by a large allocation.</p>
<h4 id="attachment-of-a-defer-feature-to-a-function-or-a-compound-statement">Attachment of a defer feature to a function or a compound statement</h4>
<p>We also had much debate if a deferred statement (as we called it) should be attached to a function or to a block (AKA compound statement). Using lambdas as callbacks instead of compound statements eases the argument and probably also the implementation.</p>
<p>The present proposal avoids to position itself with respect to that question.</p>
<ul>
<li><p>The proposal is formulated as attaching defer <em>declarations</em> (and not statements) to blocks, but makes the appearance in blocks other than function bodies implementation-defined. Thereby implementations may add the feature to other blocks than functions, but are not forced to do so. So for a particular implementation the following code may be valid.</p>

<p>If it is valid, the semantics are well defined by the proposed text; if it is not valid, a diagnostic is required.</p></li>
<li><p>The presence of lambdas in the language makes it easy to reformulate defer declarations that are attached to a block. A portable rewrite of the above can look as follows</p>

<p>This is semantically equivalent to the above and should be accepted by all implementations.</p></li>
</ul>
<h4 id="status-of-the-deferred-statement">Status of the deferred statement</h4>
<p>In <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf">N2542</a> we had formulated the defer feature as a control statement, the present one changes this to make <strong><code>defer</code></strong> a declaration. This makes a description of the feature much easier, lambdas are first of all values, and it clearly anchors the lifetime and scope of applicability of the feature at the innermost enclosing block.</p>
<h2 id="existing-practice-for-c">Existing practice for C</h2>
<h3 id="posix-pthread_cleanup_push-and-pthread_cleanup_pop-for-thread-cancelation">POSIX’ <code>pthread_cleanup_push</code> and <code>pthread_cleanup_pop</code> for thread cancelation</h3>
<p>POSIX has these two functions (or macros) to ensure that a cleanup functionality can be attached to an implicit scope that is established by paired function calls to the following functions:</p>

<p>Here the argument <code>arg</code> is a pointer to a context that will be passed on to the <code>routine</code> callback when either the <code>pthread_cleanup_pop</code> call is met (<code>execute</code> has to be non-zero in that case) or if a thread exits prematurely, for example by <code>pthread_exit</code> or by being killed.</p>
<p>The calls must be paired, that is they must be statements that are attached to the same innermost compound statement. By that property they form some sort of implicit block, and implementations my even enforce that by hiding <code>{}</code>-pairs inside the macros.</p>
<p>If the cleanup task is a simple deallocation, the usage is relatively simple.</p>

<p>But such a simple usage does not extend easily when for example <code>q</code> may change during the execution of the inner code. For such a scenario a proper function that performs the cleanup has to be provided.</p>

<h4 id="differences-against-the-proposed-feature">Differences against the proposed feature</h4>
<p>Compared to the <strong><code>defer</code></strong> feature as proposed here, this feature has several differences that we mostly see as disadvantages</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td>➕</td>
<td>The callbacks are called on preliminary exit from the thread.</td>
</tr>
<tr>
<td>➖</td>
<td>The callbacks are necessarily associated to exactly one resource</td>
</tr>
<tr>
<td>➖</td>
<td>The cleanup callbacks are not called on function return.</td>
</tr>
<tr>
<td>➖</td>
<td>The pairing of the two calls is not properly embedded into the syntax and can be difficult to follow visually.</td>
</tr>
<tr>
<td>➖</td>
<td>It is unspecified if such a pairing constitutes a scope. So local variables that are declared between the two calls may or may not survive after the second.</td>
</tr>
<tr>
<td>➖</td>
<td>A callback has to be defined as a separate function, usually far from its use.</td>
</tr>
<tr>
<td>➖</td>
<td>The function has to have a return type of <code><span>void</span></code>, a possible return value cannot be ignored.</td>
</tr>
<tr>
<td>➖</td>
<td>The use of <code><span>void</span>*</code> for the context undermines type safety.</td>
</tr>
</tbody>
</table>
<h3 id="microsoft-__try-and-__finally-extentions">Microsoft <code>__try</code> and <code>__finally</code> extentions</h3>
<p>This feature is very similar in its functionality to what is proposed here. It allows to add a finally-block to a try-block such that the finally-block is executed independently from how the try-block is terminated.</p>

<h4 id="differences-against-the-proposed-feature-1">Differences against the proposed feature</h4>
<p>Compared to the <strong><code>defer</code></strong> feature as proposed here, this feature has several differences that we mostly see as disadvantages</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td>➖</td>
<td>Only one finally-block can be added to a try-block</td>
</tr>
<tr>
<td>➖</td>
<td>The finally-block has no access to local variables of the try-block</td>
</tr>
<tr>
<td>➖</td>
<td>The resource that is cleaned up by the finally-block must live in a surrounding scope</td>
</tr>
<tr>
<td>➖</td>
<td>An additional compound statement must be put around the try-finally combination to secure against accidental access of <code>q</code>.</td>
</tr>
<tr>
<td>➖</td>
<td>The finally-block is usually declared far from the initialization of the feature to be cleaned up.</td>
</tr>
<tr>
<td>➖</td>
<td>The syntax provides no obvious connection between try- and finally-block.</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="the-cleanup-attribute">The <code>cleanup</code> attribute</h3>
<p>The Gcc, Clang and Icc compilers implement a feature that has a functionality that has the same expressiveness to our proposal, namely the <code>cleanup</code> attribute. It allows to attach a callback to a variable in the top level scope of a function as follows:</p>

<p>where <code>callback</code> has to be a function with the prototype</p>

<p>That is, <code>callback</code> is a function that receives a pointer to the variable and is supposed to do the necessary cleanup for that variable.</p>
<p>The main characteristics of this feature are:</p>
<ul>
<li>a callback is attached to a local variable of the function</li>
<li>it is not possible to use the feature for inner blocks of a function</li>
<li>callbacks are called in reverse order in which they are met</li>
<li>a command line switch can be used to force execution of callbacks even if C++ exceptions are caught</li>
</ul>
<p>Unfortunately this feature cannot be easily lifted into C23 as a standard attribute, because the <code>cleanup</code> feature clearly changes the semantics of a program and can thus not be ignored.</p>
<blockquote>
<p><strong>Removing a <code>cleanup</code> feature changes the semantics of the program.</strong></p>
</blockquote>
<p>Although this feature is attached to specific variables, it can easily be used and extended for arbitrary callbacks with a signature of <code>void (*)(void)</code>. Therefore only a stub callback</p>

<p>is needed that then can be applied as follows</p>

<p>That is, an auxiliary variable <code>someUnusedId</code> of pointer to function type is used to attach the meta-callback that in turn calls the callback that we are interested in.</p>
<p>Because Gcc has nested functions, code with functionality that is close to what we propose here could be something as the following.</p>

<p>This function has an output that is similar to</p>
<pre><code>will be cleaning 0x56380b7222a0 and 0x56380b722460
freeing unsigned 0x56380b722460
freeing double 0x56380b7222a0</code></pre>
<p>Clang has similar possibilities to express semantically the same features, but this would need either the use of a plain function (with less expressiveness) or the use of the block extension that they borrowed from Objective C. Similarly, the code can be adapted to Microsoft’s MVC to implement the same semantics with <code>__try</code> and <code>__finally</code>. We will not go into details how this can be achieved.</p>
<p>Our proposal puts the feature into a simple normative framework, makes it portable across implementations and, maybe most importantly, facilitates its use. Code with the same functionality as above is somewhat simpler expressed as follows.</p>

<h4 id="differences-against-the-proposed-feature-2">Differences against the proposed feature</h4>
<p>Compared to the <strong><code>defer</code></strong> feature as proposed here, this feature has several differences that we mostly see as disadvantages</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td>➖</td>
<td>The callbacks are necessarily associated to exactly one resource</td>
</tr>
<tr>
<td>➖</td>
<td>A callback has to be defined as a separate function, usually far from its use.</td>
</tr>
<tr>
<td>➖</td>
<td>The function has to have a return type of <code><span>void</span></code>, a possible return value cannot be ignored.</td>
</tr>
<tr>
<td>➖</td>
<td>The syntax cannot easily be adopted for C23 because it comes as a non-ignorable attribute.</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="design-choices">Design choices</h2>
<p>As explained above, using lambdas as a main tool to express defer callbacks implies that we don’t have to decide if variables inside these are accessed by their value when the <strong><code>defer</code></strong> is met or when it is executed. The different types of captures for lambdas here provide the possibility for users to chose the variant they need for their particular case.</p>
<p>Other design choices that we discussed for the original proposal are not directly impacted by the implementation as lambdas. We try to be mostly conservative here: the proposed feature should be functional, easy to implement and not inhibit future extensions that might be proposed with a TR.</p>
<h3 id="possible-scopes-of-attachment">Possible scopes of attachment</h3>
<p>It was much discussed if <strong><code>defer</code></strong> should be a feature that is attached to functions or to blocks, and even the existing prior art follows different strategies, here. Whereas gcc’s <code>cleanup</code> attribute is attached to functions, POSIX’ cleanup functions and the try/finally are attached to possibly nested blocks.</p>
<p>This indicates that existing mechanism in compilers may have difficulties with a block model. So we only require it to be implemented for function bodies and make it implementation-defined if it is also offered for internal blocks.</p>
<p>Nevertheless, we think that it is important that the semantics for the feature are clearly specified for the case of blocks, such that all implementations that do offer such a feature follow the same semantics. Therefore it is also a constraint violation to ask for the feature for blocks on implementations that don’t have support for it.</p>
<h3 id="fixed-order-of-encounter-of-defer-declarations">Fixed order of encounter of <strong><code>defer</code></strong> declarations</h3>
<p>One of the possible difficulties for implementing the feature is if the list of <strong><code>defer</code></strong> that has to be processed can have an order that depends on the execution. This could happen for example because some <strong><code>defer</code></strong> is conditionally omitted or when a local jump interchanges the order in which two <strong><code>defer</code></strong> declarations are seen for the first time.</p>
<p>We think that the feature should be implementable with very little effort and resources. So we propose that</p>
<ul>
<li><p>for a given execution of a block, a <strong><code>defer</code></strong> declaration can be met at most once</p></li>
<li><p>if a <strong><code>defer</code></strong> declaration is met during such an execution, all lexically preceeding <strong><code>defer</code></strong> declarations within the same block have been met</p></li>
<li><p>each block has to make room for a finite number of defer callbacks that is known at compile time</p></li>
<li><p>these callbacks can be organized in an array that has defer callbacks in a fixed order, namely declaration order</p></li>
<li><p>the state of an execution of a block with respect to the defer feature can simply be described by the number of <strong><code>defer</code></strong> declarations that have already been met.</p></li>
</ul>
<p>These properties are enforced by an interdiction to jump over a <strong><code>defer</code></strong> declaration by means of <code><span>switch</span></code>, <code><span>goto</span></code> or <code>longjmp</code>. This requirement is a natural extension of the fact that jumping over any kind of declaration skips the initialization of a variable.</p>
<h3 id="behavior-under-abnormal-termination-of-the-block">Behavior under abnormal termination of the block</h3>
<p>The original proposal had several features that are designed to handle exceptional control flow, such as preliminary exists of the whole execution, of a thread or if signals are met. These features found a mixed reception and with this paper we do not want to impose any such feature for implementations that do not yet have mechanisms to which they could attach such features.</p>
<p>It is difficult to foresee which kind of requirements would be consensual for WG14, so we make one main proposal which leaves most of the stack unwind properties undefined (in the direct sense of the term) and only imposes that for any such scenarios none or all registered defer callbacks must be called. Two optional scenarios build on that, the first just forcing implementations to document their behavior by making the stack unwind features implementation-defined. The second additionally introduces feature tests that give the possibility to test dynamically at runtime if the present incarnation of the C library allows to unwind the stack or not.</p>
<h4 id="thrd_exit-and-similar"><code>thrd_exit</code> and similar</h4>
<p>The existence of the POSIX cleanup feature shows that there is a demand for tools that cleanup a whole stack of callbacks that are attached to a thread of execution. Also, implementations that are POSIX compliant and that would want to build upon their existing implementation of the cleanup feature should not be penalized.</p>
<h4 id="exit-and-similar"><code>exit</code> and similar</h4>
<p>For the terminating functions in <code>&lt;stdlib.h&gt;</code> we try to follow the directions that the standard already has for callbacks; that is in particular that <code>abort</code> should never call callbacks. On the other hand, a preliminary exit by one of these functions should always have defined behavior.</p>
<p>For other functions that implementations offer we cannot impose much, in particular if we want to allow future extensions (such as a <code>panic</code> function) or if we have to take well-established termination functions such a <code>pthread_kill</code> into account. Therefore we make the behavior of all such extensions explicitly undefined and leave room for implementations to be creative.</p>
<h4 id="signals">Signals</h4>
<p>Signals are only scarcely specified in the C standard. In particular it only explicitly defines 3 software triggered signals for which we may specify behavior in case they lead to a termination of a thread or execution. We don’t think that it would make any sense for the standard to impose any type of behavior for the remaining 3 hardware interrupts that it describes, so we leave the handling of these signals undefined by omission.</p>
<h2 id="suggested-changes">Suggested changes</h2>
<h3 id="syntax-anchor">Syntax anchor</h3>
<p>Add a new keyword <strong><code>defer</code></strong> to the list of keywords in <strong>6.4.1</strong>.</p>
<p>Add a new term <em>defer-declaration</em> to the end of the <em>declaration</em> rule in <strong>6.7 p1</strong>.</p>
<p>Change <strong>6.7 p2</strong>:</p>
<blockquote>
<p>2 A declaration other than a static_assert<del> or</del><ins>,</ins> attribute<ins> or defer</ins> declaration shall declare at least a declarator (other than the parameters of a function or the members of a structure or union), a tag, or the members of an enumeration.</p>
</blockquote>
<h3 id="specific-clause">Specific clause</h3>
<blockquote>
<ins>
<p><strong>6.7.12 Defer declaration</strong></p>
</ins></blockquote>
<blockquote>
<ins>
<p><strong>Syntax</strong></p>
</ins></blockquote>
<blockquote>
<ins>
<p>1 defer-declaration:</p>
<blockquote>
<ins>
<p><strong><code>defer</code></strong> lambda-expression <strong><code>;</code></strong></p>
</ins></blockquote>
</ins></blockquote>
<blockquote>
<ins>
<p><strong>Constraints</strong></p>
</ins></blockquote>
<blockquote>
<ins>
<p>2 A defer declaration shall have block scope. It is implementation-defined if a defer declaration in a block other than the outermost block of a function definition or lambda expression is accepted.<sup>1)</sup></p>
</ins></blockquote>
<blockquote>
<ins>
<p>3 The lambda expression shall have no parameter type list or such a list specified as <code>()</code> or <code>(<span>void</span>)</code>.</p>
</ins></blockquote>
<blockquote>
<ins>
<p><strong>Description</strong></p>
</ins></blockquote>
<blockquote>
<ins>
<p>4 A defer declaration defines an unnamed object <code>λ</code>, called a <em>defer callback</em>, of lambda type and automatic storage duration that is initialized with the lambda expression. The object has a lifetime that corresponds to the current execution of the innermost block <code>B</code> in which the declaration is found. An <em>abnormal termination</em> of <code>B</code> is a termination of <code>B</code> that is caused by a function call that does not return, by a signal or by a <code><span>goto</span></code> statement. Sequenced immediately after the definition, <code>λ</code> is registered with the execution of <code>B</code>; when the execution of <code>B</code> terminates normally calls without arguments to the registered defer callbacks are sequenced as void expressions</p>
<ul>
<li>after the last evaluation within that execution of <code>B</code>,</li>
<li>in the reverse order they had been registered with that execution of <code>B</code>, and</li>
<li>before leaving <code>B</code>.</li>
</ul>
<p>Recursively, if during the execution of a defer callback <code>λ</code> a defer declaration is met during the execution of a block <code>D</code>, the corresponding defer callback <code>κ</code> is registered for that execution of <code>D</code>.<sup>2)</sup></p>
</ins></blockquote>
<blockquote>
<ins>
<p>5 Jumps by means of <code><span>switch</span></code>, <code><span>goto</span></code> or <code>longjmp</code> shall not be used to jump over a defer declaration.<sup>3)</sup> If <code>λ</code> does not return, the behavior is undefined.<sup>4)</sup></p>
</ins></blockquote>
<blockquote>
<ins>
<p>6 Unless specified otherwise, abnormal termination of the execution of <code>B</code> shall not call defer callbacks; the behavior is undefined unless the abnormal termination is caused</p>
<ul>
<li>by a call to one of the library functions of clause <strong>7.22.4</strong> that are declared with <code><span>_Noreturn</span></code>,<sup>5)</sup></li>
<li>by the signals <code>SIGABRT</code>, <code>SIGINT</code> or <code>SIGTERM</code>,<sup>6)</sup> or</li>
<li>by a call to <code>thrd_exit</code>.<sup>7)</sup></li>
</ul>
</ins></blockquote>
<blockquote>
<hr/>
</blockquote>
<blockquote>
<ins>
<p><small><sup>1)</sup> Thus an implementation may allow a defer declaration for example as the declaration expression of a <code><span>for</span></code>-loop or inside another compound statement, but programs using such a mechanism would not be portable. If a translation unit that uses such a defer declaration is not accepted, a diagnostic is required.</small></p>
</ins></blockquote>
<blockquote>
<ins>
<p><small><sup>2)</sup> Thus the call to <code>κ</code> is terminated before <code>λ</code> returns.</small></p>
</ins></blockquote>
<blockquote>
<ins>
<p><small><sup>3)</sup> This ensures that defer callbacks are properly initialized at the same time they are registered, that defer declarations are not revisited during the same execution of a block, and that, within their block, defer callbacks are registered in lexicographic order of their defer declarations.</small></p>
</ins></blockquote>
<blockquote>
<ins>
<p><small><sup>4)</sup> So using calls to <code>exit</code>, <code>thrd_exit</code>, <code>longjmp</code> or any other library function that is specified with <code><span>_Noreturn</span></code> to terminate a defer callback has undefined behavior.</small></p>
</ins></blockquote>
<blockquote>
<ins>
<p><small><sup>5)</sup> Implementations that provide other functionality to terminate execution are invited to document their behavior with respect to defer callbacks.</small></p>
</ins></blockquote>
<blockquote>
<ins>
<p><small><sup>6)</sup> Implementations that provide other signal values that terminate execution per default are invited to document their behavior with respect to defer callbacks.</small></p>
</ins></blockquote>
<blockquote>
<ins>
<p><small><sup>7)</sup> Implementations that provide other functionality to terminate execution of a thread, for example by killing it from another thread, are invited to document their behavior with respect to defer callbacks.</small></p>
</ins></blockquote>
<blockquote>
<hr/>
</blockquote>
<h3 id="optional-addition-for-thrd_exit-exit-abort-sigint-sigterm-and-sigabrt">Optional addition for <code>thrd_exit</code>, <code>exit</code>, <code>abort</code>, <code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGABRT</code></h3>
<p>Add to the new clause <strong>6.7.12</strong></p>
<blockquote>
<ins>
<p>7 It is implemementation-defined if an explicit call to <code>thrd_exit</code> calls any defer callbacks. If it does so, it calls the defer callbacks of all active execution of blocks of the thread that are registered before the call to <code>thrd_exit</code>, sequenced in the reverse order they had been registered. These calls happen before any other action defined for the <code>thrd_exit</code> library function are performed and take place within the scope of the block for which they have been registered.</p>
</ins></blockquote>
<blockquote>
<ins>
<p>8 Similarly, it is implementation-defined, if an explicit call to <code>exit</code> calls defer callbacks for the current thread. If the execution is terminated by a call to a different <code><span>_Noreturn</span></code> function of clause <strong>7.22.4</strong> than <code>exit</code>, no defer callbacks shall be called.</p>
</ins></blockquote>
<blockquote>
<ins>
<p>9 Similarly, it is implementation-defined, if a default handling of the signals <code>SIGINT</code> and <code>SIGTERM</code> that terminates execution calls defer callbacks for the current thread. If the execution is terminated because the signal <code>SIGABRT</code> occurred, no defer callbacks shall be called.</p>
</ins></blockquote>
<h3 id="alternative-version-for-thrd_exit-exit-abort-sigint-sigterm-and-sigabrt-with-feature-tests">Alternative version for <code>thrd_exit</code>, <code>exit</code>, <code>abort</code>, <code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGABRT</code> with feature tests</h3>
<p>Add to the new clause <strong>6.7.12</strong></p>
<blockquote>
<ins>
<p>7 If the value of <strong><code>thrd_exit_defer</code></strong> is <code>true</code>, see <strong>7.26</strong>, the defer callbacks of all active executions of blocks of the thread that are registered before an explicit call to <code>thrd_exit</code> are called, sequenced in the reverse order they had been registered. These calls happen before any other action defined for the <code>thrd_exit</code> library function are performed and take place within the scope of the block for which they have been registered. If the value is <code>false</code>, no defer callbacks are called.</p>
</ins></blockquote>
<blockquote>
<ins>
<p>8 Similarly, if the value of <strong><code>__exit_defer</code></strong> is <code>true</code>, see <strong>7.22</strong>, an explicit call to <code>exit</code> calls the defer callbacks for the current thread. If the value is <code>false</code>, no defer callbacks are called. If the execution is terminated by a call to a different <code><span>_Noreturn</span></code> function of clause <strong>7.22.4</strong> than <code>exit</code>, no defer callbacks shall be called.</p>
</ins></blockquote>
<blockquote>
<ins>
<p>9 Similarly, if the value of <strong><code>sig_exit_defer</code></strong> is <code>true</code>, see <strong>7.14</strong>, a default termination of the executions for the signals <code>SIGINT</code> or <code>SIGTERM</code> calls the defer callbacks for the current thread. If the value is <code>false</code>, no defer callbacks are called. If the execution is terminated because the signal <code>SIGABRT</code> occurred, no defer callbacks shall be called.</p>
</ins></blockquote>
<p>Add a new paragraph <strong>7.14 p1’</strong> (<code>&lt;signal.h&gt;</code>)</p>
<blockquote>
<ins>
<p>1’ The feature test macro <strong>STDC_VERSION_SIGNAL_H</strong> expands to the token yyyymmL .</p>
</ins></blockquote>
<p>Add a new paragraph <strong>7.14 p5</strong> (<code>&lt;signal.h&gt;</code>)</p>
<blockquote>
<ins>
<p>5 The macro</p>
</ins></blockquote>
<blockquote>
<blockquote>
<ins>
<p><strong><code>sig_exit_defer</code></strong></p>
</ins></blockquote>
</blockquote>
<blockquote>
<ins>
<p>expands to a value of type <code><span>bool</span></code> that is <code>true</code> if the implementation executes defer callbacks when the default handling of signals <code>SIGINT</code> and <code>SIGTERM</code> terminates the execution, see <strong>6.7.12</strong>, and <code>false</code> otherwise; the expansion is not an lvalue and the value is the same for the whole execution.</p>
</ins></blockquote>
<p>Add a new paragraph <strong>7.22 p6</strong> (<code>&lt;stdlib.h&gt;</code>)</p>
<blockquote>
<ins>
<p>6 The macro</p>
</ins></blockquote>
<blockquote>
<blockquote>
<ins>
<p><strong><code>__exit_defer</code></strong></p>
</ins></blockquote>
</blockquote>
<blockquote>
<ins>
<p>expands to a value of type <code><span>bool</span></code> that is <code>true</code> if the implementation executes defer callbacks on explicit calls to <code>exit</code>, see <strong>6.7.12</strong>, and <code>false</code> otherwise; the expansion is not an lvalue and the value is the same for the whole execution.</p>
</ins></blockquote>
<p>Add a new paragraph <strong>7.26.1 p6</strong> (<code>&lt;threads.h&gt;</code>, introduction)</p>
<blockquote>
<ins>
<p>6 The macro</p>
</ins></blockquote>
<blockquote>
<blockquote>
<ins>
<p><strong><code>thrd_exit_defer</code></strong></p>
</ins></blockquote>
</blockquote>
<blockquote>
<ins>
<p>expands to a value of type <code><span>bool</span></code> that is <code>true</code> if the implementation executes defer callbacks on explicit calls to <code>thrd_exit</code>, see <strong>6.7.12</strong>, and <code>false</code> otherwise; the expansion is not an lvalue and the value is the same for the whole execution.</p>
</ins></blockquote>
<h3 id="optional-addition-of-an-example">Optional addition of an example</h3>
<p>Depending on the version of lambdas that are integrated into C23, this example might need small adjustments.</p>
<blockquote>
<ins>
<p>10 <strong>EXAMPLE</strong> In the following, the values of <code>p</code>, <code>q</code> and <code>r</code> are used as arguments to <code>free</code> at the end of the execution of <code>main</code>. Because the corresponding capture is a shadow capture, for <code>p</code> the initial value is used as argument to the call; for <code>q</code> it is an identifier capture and thus the value is used that was stored last before a <code><span>return</span></code> statement is met or the execution of the function body ends. Similarly, for <code>r</code> the value capture <code>rp</code> has the address of <code>r</code> and frees the last allocation for which the address was stored in <code>r</code>. The four <code><span>return</span></code> statements are all valid and according to the control flow that is taken the function executes <code><span>0</span></code>, <code><span>1</span></code>, <code><span>2</span></code>, or <code><span>3</span></code> defer callbacks. If at least the first three allocations are successful, the storage is freed in the order <code>r</code>, <code>q</code> and <code>p</code>. If the call to <code>realloc</code> fails, the initial value of <code>q</code> is passed as argument to <code>free</code>.</p>
</ins></blockquote>
<blockquote>

</blockquote>
<h2 id="possible-future-extensions">Possible future extensions</h2>
<p>Our orginal paper <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf">N2542</a>. discusses a lot of features that could be added to the defer feature and that will give rise to a TR, such as</p>
<ul>
<li><p>a panic/recover mechanism and a more sophisticated specification for error paths such as preliminary exits and signal handling</p></li>
<li><p>an extension that allows to attach defer callbacks to all blocks</p></li>
<li><p>to allow defer callbacks to appear within conditionals such that they are registered dynamically in varying order as they are met during execution</p></li>
</ul>
<p>Other possible extensions would arise from the choices that are made in this proposal.</p>
<h3 id="default-versions-of-captures">Default versions of captures</h3>
<p>Using lambdas as the base feature as we propose here opens other possibilities, in particular for the status of captures. This example from the beginning is not valid with our proposal:</p>

<p>The use of a compound statement here could be seen as an indication that the access to <code>q</code> is meant to be an identifier capture, and we could then per default expand this to</p>

<p>On the other hand, in golang from where we borrowed this feature a version without <code>{}</code></p>

<p>would use the value of <code>q</code> as it is evaluated when the defer declaration is met. So in this sense this would probably best be expanded with as value closure</p>

<h3 id="possible-syntax-extensions">Possible syntax extensions</h3>
<p>Over all it seems that several extension of the syntax seem possible to the syntax</p>
<blockquote>
<p>1 defer-declaration:</p>
<blockquote>
<p><strong><code>defer</code></strong> defer-callback <strong><code>;</code></strong></p>
</blockquote>
<p>defer-callback:</p>
<blockquote>
<p>no-argument-callable</p>
<p>function-call</p>
<p>compound-statement</p>
</blockquote>
<p>no-argument-callable:</p>
<blockquote>
<p>expression</p>
</blockquote>
</blockquote>
<p>With the following constraints</p>
<blockquote>
<p>The expression of a no argument callable shall evaluate to a function pointer type or to a lambda value type that receive no arguments. A defer declaration with a function call or compound statement behaves, respectively, as if it were specified with lambda expressions as in the following</p>
<blockquote>
<p><strong><code>defer [=](<span>void</span>) { (<span>void</span>)</code></strong> function-call <strong><code>; };</code></strong></p>
<p><strong><code>defer [&amp;](<span>void</span>)</code></strong> compound-statement <strong><code>;</code></strong></p>
</blockquote>
<p>The corresponding constraints for lambda expressions then shall apply.</p>
</blockquote>
<h3 id="defer-in-file-scope">Defer in file scope</h3>
<p>If we would extend the possibility to have defer declarations in file scope this could have the similar semantics as calls to <code>atexit</code>.</p>

<p>This could be equivalent to define a function</p>

<p>and to call <code>atexit(logfile_callback)</code> at program initialization before entering <code>main</code>.</p>
<h2 id="questions-to-wg14">Questions to WG14</h2>
<h3 id="base">Base</h3>
<blockquote>
<p>Does WG14 want to integrate a defer feature as proposed in 6.1 and 6.2 of N2895 into C23?</p>
</blockquote>
<h3 id="options-for-abnormal-termination">Options for abnormal termination</h3>
<p>Since we don’t really have a possibility to vote for multiple choices, we propose to escalate the feature.</p>
<blockquote>
<p>Does WG14 want to integrate previsions for abnormal termination as in 6.3 of N2895 into C23?</p>
</blockquote>
<p>If the answer here is positive</p>
<blockquote>
<p>Does WG14 want to replace the previsions for abnormal termination and use 6.4 instead of 6.3 of N2895 into C23?</p>
</blockquote>
<h3 id="example">Example</h3>
<blockquote>
<p>Does WG14 want to integrate the example as in 6.5 of N2895 into C23?</p>
</blockquote>


</div>
  </body>
</html>
