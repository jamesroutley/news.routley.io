<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/confusing-rust-lifetime-elision/">Original</a>
    <h1>A confusing lifetime error related to Rust&#39;s lifetime elision</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Monday, January  2, 2023</strong></p>

    <p>Earlier this week, I ran into a confusing situation with lifetimes and the borrow checker while working on my <a href="https://craftinginterpreters.com/the-lox-language.html">Lox</a> interpreter.
It took me a little while to figure out, and it&#39;s an instructive situation.</p>
<p>Here&#39;s a reduced-down version of what I was working on.
It&#39;s an interpreter, so there is a scanner which produces tokens.
Ideally these tokens are references back into the underlying original string so that you can avoid any more memory allocation.</p>
<p>Simple enough, I thought, so I implemented a <code>Scanner</code> which produced <code>Tokens</code>:</p>
<pre><code><span>/// An overly simplified Scanner, containing just
/// enough fields to produce fake tokens.
</span><span>struct </span><span>Scanner</span><span>&lt;</span><span>&#39;source</span><span>&gt; {
    source</span><span>: </span><span>&amp;</span><span>&#39;source str</span><span>,
    count</span><span>: </span><span>usize</span><span>,
}

</span><span>/// An overly simplified Token, containing just
/// a reference to a str to reproduce the error.
</span><span>struct </span><span>Token</span><span>&lt;</span><span>&#39;source</span><span>&gt; {
    lexeme</span><span>: </span><span>&amp;</span><span>&#39;source str</span><span>,
}

</span><span>impl </span><span>Scanner</span><span>&lt;&#39;</span><span>_</span><span>&gt; {
    </span><span>/// next_token produces a fake token which
    /// reproduces the error; you&#39;d want to do
    /// some real scanning here, of course!
    </span><span>pub fn </span><span>next_token</span><span>(</span><span>&amp;</span><span>mut </span><span>self</span><span>) </span><span>-&gt;</span><span> Token {
        </span><span>self</span><span>.</span><span>count </span><span>+= </span><span>1</span><span>;
</span><span>        Token { lexeme</span><span>: </span><span>self</span><span>.</span><span>source }
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let</span><span> source </span><span>= </span><span>&#34;x = 10&#34;</span><span>;
    </span><span>let mut</span><span> scanner </span><span>=</span><span> Scanner { source</span><span>,</span><span> count</span><span>: </span><span>0 </span><span>}</span><span>;

    </span><span>let</span><span> token </span><span>=</span><span> scanner</span><span>.</span><span>next_token</span><span>()</span><span>;
    </span><span>println!</span><span>(</span><span>&#34;token: </span><span>{}</span><span>&#34;</span><span>,</span><span> token</span><span>.</span><span>lexeme)</span><span>;
</span><span>}
</span></code></pre>
<p>This compiles, and it has a sprinkling of named lifetimes within it.
Those are important so that the compiler can reason about how long the references will live.
If you have a reference in a struct, it always needs a lifetime annotation, unless it falls under one of the three lifetime elision rules, which we&#39;ll get to.</p>
<p>For now, though, let&#39;s do something more with our scanner.
We&#39;ll get a second token in <code>main</code>, the way you might see in a parser where you keep the current and previous tokens:</p>
<pre><code><span>fn </span><span>main</span><span>() {
    </span><span>let</span><span> source </span><span>= </span><span>&#34;x = 10&#34;</span><span>;
    </span><span>let mut</span><span> scanner </span><span>=</span><span> Scanner { source</span><span>,</span><span> count</span><span>: </span><span>0 </span><span>}</span><span>;

    </span><span>let</span><span> previous </span><span>=</span><span> scanner</span><span>.</span><span>next_token</span><span>()</span><span>;
    </span><span>let</span><span> current </span><span>=</span><span> scanner</span><span>.</span><span>next_token</span><span>()</span><span>;

    </span><span>println!</span><span>(</span><span>&#34;previous: </span><span>{}</span><span>&#34;</span><span>,</span><span> previous</span><span>.</span><span>lexeme)</span><span>;
    </span><span>println!</span><span>(</span><span>&#34;current: </span><span>{}</span><span>&#34;</span><span>,</span><span> current</span><span>.</span><span>lexeme)</span><span>;
</span><span>}
</span></code></pre>
<p>Now this looks like it <em>should</em> work, since all the tokens will live as long as the source, which lives as long as the main function does.
However, we get this output when we try to compile it:</p>
<pre><code><span>error[E0499]: cannot borrow `scanner` as mutable more than once at a time
  --&gt; lifetime.rs:29:19
   |
28 |     let previous = scanner.next_token();
   |                    -------------------- first mutable borrow occurs here
29 |     let current = scanner.next_token();
   |                   ^^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here
30 |
31 |     println!(&#34;previous: {}&#34;, previous.lexeme);
   |                              --------------- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
</span></code></pre>
<p>Somehow, we&#39;re trying to hold onto two mutable references to <code>scanner</code> at the same time!
But why?</p>
<p>It comes down to those lifetime elision rules.
There are <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">three lifetime elision rules</a>, which apply to both <code>impl</code> blocks and <code>fn</code>s:</p>
<ol>
<li>Each parameter that&#39;s a reference gets a lifetime. These are <em>input</em> lifetimes.</li>
<li>If there&#39;s exactly one input lifetime parameter, that lifetime is used for all <em>output</em> lifetimes.</li>
<li>If there are multiple input lifetime parameters but one is <code>&amp;self</code> or <code>&amp;mut self</code>, the <code>self</code> lifetime &#34;wins&#34; and is used for all output lifetimes.</li>
</ol>
<p>So what&#39;s happening here is that <code>next_token</code> gets implicit lifetimes assigned to it, and those end up forcing a longer lifetime than we really need <em>on the borrow</em>.
To understand it, we can write out what the elision rules would do for us.
We apply rule 1 to know that we&#39;ll need an input lifetime for both <code>self</code> (let&#39;s call it <code>&#39;scanner</code>) and for the source/lexeme (let&#39;s call it <code>&#39;source</code>).
We also know from rule 3 that since <code>Token</code> has a lifetime parameter and is returned, it will be the same as the reference itself.</p>
<p>So we end up with this:</p>
<pre><code><span>impl</span><span>&lt;</span><span>&#39;source</span><span>, </span><span>&#39;scanner</span><span>&gt; </span><span>Scanner</span><span>&lt;</span><span>&#39;source</span><span>&gt; {
    </span><span>/// next_token produces a fake token which
    /// reproduces the error; you&#39;d want to do
    /// some real scanning here, of course!
    </span><span>pub fn </span><span>next_token</span><span>(</span><span>&amp;</span><span>&#39;scanner mut </span><span>self</span><span>) </span><span>-&gt; </span><span>Token&lt;</span><span>&#39;scanner</span><span>&gt; {
        </span><span>self</span><span>.</span><span>count </span><span>+= </span><span>1</span><span>;
</span><span>        Token { lexeme</span><span>: </span><span>self</span><span>.</span><span>source }
    }
}
</span></code></pre>
<p>If we compile it with this implementation instead, we get <em>the same compiler error</em>.
But this is <strong>clearly not what we want</strong>: we don&#39;t want tokens to live as long as the <em>reference</em> to the scanner, we want them to live as long as the <em>source</em>!
Since their lifetime is linked to the mutable reference to the scanner, it forces that reference to be held for at least as long as the tokens are.</p>
<p>We can fix this pretty simply by instead annotating with the correct lifetime on the returned <code>Token</code>.
You can also omit the <code>&#39;scanner</code> lifetime, but I chose to leave it in here to be a little more explicit for clarity in this example.</p>
<pre><code><span>impl</span><span>&lt;</span><span>&#39;source</span><span>, </span><span>&#39;scanner</span><span>&gt; </span><span>Scanner</span><span>&lt;</span><span>&#39;source</span><span>&gt; {
    </span><span>/// next_token produces a fake token which
    /// reproduces the error; you&#39;d want to do
    /// some real scanning here, of course!
    </span><span>pub fn </span><span>next_token</span><span>(</span><span>&amp;</span><span>&#39;scanner mut </span><span>self</span><span>) </span><span>-&gt; </span><span>Token&lt;</span><span>&#39;source</span><span>&gt; {
        </span><span>self</span><span>.</span><span>count </span><span>+= </span><span>1</span><span>;
</span><span>        Token { lexeme</span><span>: </span><span>self</span><span>.</span><span>source }
    }
}
</span></code></pre>
<p>And with that small change, the whole thing compiles!
Of course, in retrospect, it&#39;s really clear that I <em>should</em> have specified the lifetime parameter for <code>Token</code> in the first place, but you live and learn.</p>

  </article></div>
  </body>
</html>
