<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.denormalized.io/blog/building-databases">Original</a>
    <h1>Building Databases over a Weekend</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><p>Databases are some of the most complex pieces of software conceived
since the advent of the computing age over half a century ago. [1]
Nearly every piece of technology ends up touching the database in some
way shape or form. Despite the ubiquity of Databases in the software
stack, the vast majority of developers have been conditioned to treat
databases as more or less a <em>black box</em> -- complex dense pieces of
software conjured up by arch wizards and mavens ensconced in the
rarified elite tiers of database companies or places like Google. The
adage for the rest of us as it goes is <em>never attempt to write your own
database</em>.</p>
<p>That said, despite their longevity, we have seen continued innovation in
the space that first started with Hadoop arriving on the scene about 2
decades ago. The ClickBench website now lists over 50+ databases in its
benchmark suite [2] . And that&#39;s just the analytics engines. With the
recent trends of rewriting everything big data in Rust [3] not a month
goes by without an interesting new project trending in the Hacker News.
In this post we will take a look at how easy (or hard) it is to build
Databases using Apache Datafusion and whether you <em>can in fact, as a
mere mortal</em> realistically build a custom database and innovate around
the developer experience.</p>
<p>Most modern databases can be disaggregated into compute and storage
layers, with sophisticated query engines responsible for the &#34;compute&#34;
portion of the database. A query engine typically consists of a Query
Parser, Logical Plan generation and then the Physical Plan generation to
run the computations on the Execution Engine. A query generally goes
through multiple optimization phases in the logical plan generation as
well as physical plan generation. No matter what the target use-case of
the end system is, the query engine more or less follows this model.</p>
<p>Given decades of database research that has gone into each of these
individual layers, the bar for writing a functional query engine with
table stakes features remains strikingly high. And you need to nail <em>all
that</em> before you can get around to writing your use-case specific
features. While there are many projects that help you write some of
these layers individually, Apache DataFusion remains the only game in
town that helps you with the entire gamut.</p>
<p>You can think of DataFusion extensible database development toolkit. At
its most basic level, you can use it as a query engine a la DuckDB with
its builtin SQL and Dataframe front ends, while at the same time you can
extend or even wholesale replace different layers to build your own
experience entirely.</p>
<p>In the rest of this post we will walk through how to extend DataFusion
to add your own operators to its execution engine and then weave it
through the Physical and Logical planners and expose it to the frontend.</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*jjrNhgIlapa-Ih2P.png" alt="DataFusion architecture"/></p>
<p><strong>DataFusion architecture</strong></p>
<p>At Denormalized, we are building a duck db like single node experience
for stream processing applications. While DataFusion does have some
support for unbounded computations, it doesn&#39;t have a streaming window
operator. Windows are at the core of stream processing applications,
they provide an easy way to bucket infinite data streams into finite
buckets so that we can apply aggregations over them.</p>
<p>For this tutorial we will implement a simple window operator for
infinite streams. Our operator will have the following signature --</p>
<pre><code>    pub fn window(
			    self
			    group_expr: Vec&lt;Expr&gt;,
			    aggr_expr: Vec&lt;Expr&gt;,
			    window_length: Duration,
			    slide: Option&lt;Duration&gt;,
			    ) -&gt; Result&lt;Self&gt; { ... }
</code></pre>
<h2>Writing the Execution Plan</h2>
<p>An <a href="https://docs.rs/datafusion/latest/datafusion/physical_plan/execution_plan/trait.ExecutionPlan.html">ExecutionPlan represents</a> a node in the DataFusion Physical plan. This is where
the actual code with our custom computations would go. DataFusions execution model
is pull based, meaning that the execution starts at the sinks and works its
way up the physical plan. Calling the <em>execute</em> method on this trait
produces an asynchronous <a href="https://docs.rs/datafusion/latest/datafusion/physical_plan/type.SendableRecordBatchStream.html">SendableRecordBatchStream</a> of record batches
by incrementally deriving a partition of the output by running
computations over Execution Plan&#39;s input.</p>
<p>In our use case, <a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/physical_plan/continuous/streaming_window.rs#L423-L427">ExecutionPlan&#39;s execute()</a> method returns a struct
<a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/physical_plan/continuous/grouped_window_agg_stream.rs#L62">GroupedWindowAggStream</a> which implements a RecordBatchStream,  a wrapper around
futures::Stream trait. The actual computations should be implemented
within the <em>poll_next()</em> of the Stream implementation.</p>
<pre><code>    impl RecordBatchStream for GroupedWindowAggStream {
	    fn schema(&amp;self) -&gt; SchemaRef {
		    self.schema.clone()
	    }
    }
    
    impl Stream for GroupedWindowAggStream {
    
	    type Item = Result&lt;RecordBatch&gt;;
	    
	    fn poll_next(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;) -&gt;
	    Poll&lt;Option&lt;Self::Item&gt;&gt; {
	    
		    let poll = self.poll_next_inner(cx); // Code to compute the record batch goes
		    here.
	    
	    ...
    
    }
</code></pre>
<p>Here in our example, calling the <em>poll_next_inner</em> for a streaming
window takes care of</p>
<ol>
<li>
<p>Processing the incoming data.</p>
</li>
<li>
<p>Accumulating rows into open windows.</p>
</li>
<li>
<p>Updating the watermark (which is behind a mutex)</p>
</li>
<li>
<p>Opening new windows if required.</p>
</li>
<li>
<p>Closing any triggering windows and producing the output
RecordBatches from them.</p>
</li>
</ol>
<h2>Hooking into the Physical Planner</h2>
<p>Having created our custom Execution Plan, we need to make the Physical
Planner aware of its existence. <a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/planner/streaming_window.rs#L69-L173">Implementing the ExtensionPlanner</a> for our
ExtensionPlan is all we need to do here.</p>
<h2>Extending the Logical Plan</h2>
<p>Now that we have the custom Execution Plan implemented along with
ExtensionPlanner, we need to add a companion node to the Logical Plan.
This not only allows us to expose this to the SQL/DataFrame frontends
but also hook into the logical optimizers for optimizations such as the
predicate pushdowns.</p>
<p>In DataFusion we need to first implement a <a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/logical_plan/streaming_window.rs#L28">user defined Logical Plan
Node</a> and then add a <a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/logical_plan/mod.rs#L47-L59">LogicalPlanExtension</a>
to the logical plan builder which exposes this to SQL/DataFrame
frontends.</p>
<h2>Logical Plan to Physical Plan</h2>
<p>The last piece of the puzzle is the touch point where the logical plan
gets converted into the physical plan. For this, we will implement a
<a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/query_planner.rs#L13-L30">custom QueryPlanner</a> that ensures that the physical planner is initialized with
the custom extensions we wrote for our ExecutionPlan.</p>
<h2>Custom Optimization Rules</h2>
<p>Since our operator implemented a group by aggregation, we need to ensure
that all the rows for a particular group end up in the same partition.
To that end we will add a <a href="https://github.com/probably-nothing-labs/denormalized/blob/f65268972da3a6f21eac0ab4bf3e4ca9b558c6ed/crates/core/src/physical_optimizer/coalesce_before_streaming_window_aggregate.rs#L32">new physical optimization
rule</a> to add a HashPartition operator on our group keys.</p>
<h2>Putting it all together</h2>
<p>Finally, all we need to do is construct a DataFusion session with the
custom QueryPlanner we wrote above as well as the additional physical
optimizer rule we added and voila, now we have our own extended version
of DataFusion.</p>
<pre><code>    let state = SessionStateBuilder::new()
      .with_default_features()
      .with_config(config)
      .with_query_planner(Arc::new(StreamingQueryPlanner {}))
      .with_optimizer_rules(get_default_optimizer_rules()).with_physical_optimizer_rule(Arc::new(EnsureHashPartititionOnGroupByForStreamingAggregates::new(),
      ))
      .build();
</code></pre>
<h3>Footnotes</h3>
<ol>
<li><a href="https://db.cs.cmu.edu/papers/2024/whatgoesaround-sigmodrec2024.pdf">https://db.cs.cmu.edu/papers/2024/whatgoesaround-sigmodrec2024.pdf</a></li>
<li><a href="https://benchmark.clickhouse.com">https://benchmark.clickhouse.com</a></li>
<li><a href="https://github.com/rewrite-bigdata-in-rust/RBIR">https://github.com/rewrite-bigdata-in-rust/RBIR</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3626246.3653368">https://dl.acm.org/doi/10.1145/3626246.3653368</a></li>
</ol></div></article></div></div></div>
  </body>
</html>
