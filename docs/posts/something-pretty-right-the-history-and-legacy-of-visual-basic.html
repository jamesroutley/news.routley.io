<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retool.com/visual-basic/">Original</a>
    <h1>Something Pretty Right: The History and Legacy of Visual Basic</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="spring-1988">The Spring of 1988</h2><div><p>In the spring of 1988, Alan Cooper sat in front of a computer in a large boardroom at the Microsoft headquarters in Redmond, Washington, patiently waiting for Bill Gates to arrive.</p><p>At the time, Cooper&#39;s main business was writing desktop application software to sell to publishers. “I was one of the first companies to realize that you could retail software without needing to sell a computer,” he recalls. But for the past month, Cooper had been frantically coding in preparation for this Microsoft demo, adding last-minute features to Tripod, a shell construction set for the Windows operating system that he&#39;d been working on as a side project.</p><p>In late 1985 or early 1986, a friend had brought Cooper to Microsoft&#39;s annual technical conference in Silicon Valley. On stage was Steve Ballmer, presenting the first version of Windows. Cooper was impressed, not by the graphical multitasking system—something he&#39;d already written himself—but by Microsoft&#39;s dynamic-link libraries, or DLLs. In Windows, much of the operating system&#39;s functionality was provided by DLLs, a new concept of shared libraries with code and data that could be used by more than one program at the same time.</p></div><figure><blockquote><p>“Might as well have had a neon sign saying, ‘Market Opportunity.&#39; And it just really intrigued me. So I started saying, ‘Okay, I&#39;m going to build a shell.&#39;”</p></blockquote><div></div></figure><div><p>“There were some things that I couldn&#39;t do because I didn&#39;t have access to the deep guts of the operating system. And there were things that I wanted, which were interprocess communication, dynamic relocation, and [...] dynamic loading of modules that could run and go out without shutting down the operating system. So I went home and I put my little graphic frontend and multitasking dispatcher in the sock drawer and started building software in Windows,” Cooper explains.</p><p>In Cooper&#39;s eyes, though, Windows had one major drawback. The shell—the graphical face of the operating system where you started programs and looked for files—was rudimentary, lacking overlapping windows and visual polish. Compared to Apple&#39;s Macintosh GUI released almost two years earlier, it was clearly an aspect of the project into which Microsoft just hadn&#39;t put much effort. “It was a program called MSDOS.exe and it was very clear that somebody had written it in a weekend,” Cooper observes. “[Microsoft] might as well have had a neon sign saying, ‘Market Opportunity.&#39; And it just really intrigued me. So I started saying, ‘Okay, I&#39;m going to build a shell.&#39;”</p></div><div><figure><img src="http://jimkang.com/static/ms-dos-e1f76dd95975a40f4f59db4e773cb54d.jpg" alt="A screenshot of a the Windows 1.0 shell on top of MS-DOS." loading="lazy"/><figcaption><h3>Windows 1.0&#39;s 16-bit shell ran on top of MS-DOS</h3><p>A program run from the command line called MS-DOS Executive (the equivalent of the modern day Explorer or Finder). Windows came with a few built-in programs—like a notepad, calculator, and clock—that could be launched into a non-overlapping application window by clicking the .exe file or an associate file, like a .doc.</p></figcaption></figure></div><figure><p><img src="http://jimkang.com/static/win1-demo-cover-e4d00dcec8c281c61d98900a9c9c67cb.jpg" alt="An image of the Microsoft Windows box with a play button icon over it." loading="lazy"/></p><div><div><div><p>00:00</p><!-- --><p> / </p><!-- --><p>00:00</p></div></div></div><p>Ken Doe gives a detailed ten minute demo of the Windows 1.0 shell, 30 years after its release.</p></figure><h2 id="shell-construction-kit">A (not so) simple shell construction kit</h2><div><p>“I started writing little programs that could be shells for Windows,” Cooper remembers. “But that&#39;s actually a hard problem! You know, what would a shell be for Windows? It&#39;s an operating system that serves a lot of people.”</p><p>Cooper&#39;s solution to this problem didn&#39;t click until late 1987, when a friend at Microsoft brought him along on a sales call with an IT manager at Bank of America. The manager explained that he needed Windows to be usable by all of the bank&#39;s employees: highly technical systems administrators, semi-technical analysts, and even users entirely unfamiliar with computers, like tellers.</p><p>In an instant, I perceived the solution to the shell design problem: it would be a shell construction set—a tool where each user would be able to construct exactly the shell that they needed for their unique mix of applications and training. Instead of me telling the users what the ideal shell was, they could design their own, personalized ideal shell.</p><p>Cooper began working on this new idea in earnest. His prototype had a palette of controls, such as buttons and listboxes, that users could drag and drop onto the screen, populating “forms.” Some of these controls were preconfigured for common shell functionality, like a listbox that automatically showed the contents of a directory. Michael Geary, one of the programmers that Cooper eventually hired to help with Tripod development, describes naming these elements:</p><p>“They weren&#39;t called ‘controls&#39; originally. Alan was going to call them ‘waldos&#39;, named after <a href="https://en.wikipedia.org/wiki/Remote_manipulator" target="_blank">remote manipulator arms</a>. I couldn&#39;t make sense out of that name, so I called them ‘gizmos&#39;. Microsoft must have thought this name was too frivolous, so they renamed them ‘controls&#39;.”</p><p>The “gizmos” would be a large part of what made Tripod groundbreaking: it wasn&#39;t so much what the resulting shells could do, but the interaction details which had never been well-implemented on a PC before. Cooper built drag-and-drop protocols and a sprite animation system from scratch.</p><p>Tripod also used an event-driven model: when the user performed an action like clicking a button, it would trigger specific code to execute. To connect events fired by one gizmo to actions taken on another, users would drag out an arrow between the gizmos. Geary remembers this as the origin for the programming phrase “fire an event”:</p><p>“I was looking for a name for one gizmo sending a message to another. I knew that SQL had ‘triggers,&#39; and Windows had SendMessage but I didn&#39;t like those names.</p><p>“I got frustrated one night and started firing rubber bands at my screen to help me think. It was a habit I had back then to shake up my thinking. Probably more practical on a tough glass CRT than on a modern flat screen! After firing a few rubber bands, I was still stuck. So I fired up a doobie to see if that would help. As I flicked my lighter and looked at the fire, it all came together. Fire a rubber band. Fire up a doobie. Fire an event!”</p></div><figure><blockquote><p>“It blew his mind, he had never seen anything like it ... at one point he turned to his retinue and asked ‘Why can&#39;t we do stuff like this?&#39;”</p></blockquote><div></div></figure><h2 id="why-cant-we">“Why can&#39;t we do stuff like this?”</h2><div><p>Once Cooper had a working prototype, he shopped it to publishers around the Valley. Everyone he spoke to told him the same thing: show it to Microsoft, we don&#39;t want any part of competing with them on this.</p><p>Cooper had met Bill Gates years back in the early days of Microsoft, but they were hardly on speed dial. Cooper&#39;s friend at Microsoft managed to arrange an audience with Gabe Newell, then a mid-level executive who worked on Windows. (Newell went on to become co-founder and CEO of the video game company Valve.)</p><p>When they finally met, Newell abruptly stopped Cooper five minutes into his demo: “Bill&#39;s got to see this.” He sent Cooper home and arranged for him to come back up to Redmond in a month to meet with Gates directly. Cooper spent the time furiously coding more features into Tripod.</p><p>A month later (back to that spring of 1988), Cooper sat in that large Microsoft boardroom, but this time with Gates and an entourage of a dozen Microsoft employees. Cooper ran through the demo.</p><p>“It blew his mind, he had never seen anything like it,” Cooper remembers of Gates&#39;s reaction, “at one point he turned to his retinue and asked ‘Why can&#39;t we do stuff like this?&#39;”</p><p>When one of the Microsoft employees pointed out some problems that the tool didn&#39;t address, Gates himself lept to Tripod&#39;s defense.</p><p>“At that point I knew that something was going to happen,” Cooper says.</p><p>Something did happen, although not exactly what he expected. There was no way he could know, sitting in that boardroom, that his project would eventually become Visual Basic, a visual programming environment that would reign for a decade and become the gateway to application programming for countless users. All he knew was that he had built something cool, something that no one had done before—not even the hotshots at Microsoft.</p></div><h2 id="tripod-to-ruby">From Tripod to Ruby</h2><div><p>Gates wanted Tripod. The parties hammered out a deal over the next few months. Cooper would finish the project and ensure it passed through Microsoft&#39;s rigorous formal QA process, at which point it would be bundled in the upcoming Windows 3.0.</p><p>With contract in hand, Cooper wrote a detailed spec and hired a team of programmers—Frank Raab, Michael Geary, Gary Kratkin, and Mark Merker. Cooper decided to promptly throw away the 25,000 lines of messy prototype C code that comprised Tripod and start over from scratch, feeling like it was so irredeemably full of time-pressured hacks, it&#39;d simply be easier to rewrite it with a cleaner design. Russell Werner, Microsoft&#39;s GM of the DOS and Windows business unit, was not pleased.</p><p>“When Russ found out I had discarded [the code], he freaked out,” Cooper recalls.</p><p>“He started shouting at me, saying that I would miss our deadlines, I would derail the entire project, and that I would delay the shipment of the whole Windows 3.0 product. Having presented him with a fait accompli, there was little he could do except predict failure.” The team dove into the rewrite—now codenamed “Ruby” to distinguish it from the prototype version.</p></div><div><figure><img src="http://jimkang.com/static/ruby-team-5b691a85bc9c6bf9efd128579ed82e71.jpg" alt="A pixelated photograph of the Microsoft Ruby team." loading="lazy"/><figcaption><h3>The Ruby Team in spring of 1989</h3><p><strong>From left to right:</strong> Frank Raab, Mike Geary, Alan Cooper, Gary Kratkin and Mark Merker.</p></figcaption></figure></div><p>A major change was architecting the gizmo palette to load in dynamically (using Windows&#39; new DLL concept), with an API for third-party developers to create and distribute their own gizmos. Cooper describes the design decision:</p><figure><blockquote><p>I envisioned a product where third-party vendors could write their own gizmo DLLs and users could add them to the product in the field without needing to recompile. We defined an interface whereby Ruby would interrogate nearby executable files with a query message. If the file responded appropriately, Ruby knew that it was a cooperating gizmo and proceeded to request its icon to display in the tool palette.</p></blockquote></figure><div><figure><img src="http://jimkang.com/static/no-ruby-b339e1cb7b78bec1538a36896b32aa21.jpg" alt="A photograph of a printed manual titled &#39;Cooper Software Development, Inc proudly presents: RUBY!&#39; which has an image of a happy man in a suit with arms wide open." loading="lazy"/><figcaption><h3>18 months after starting work</h3><p>In early 1990, Cooper&#39;s team turned over the golden master to Microsoft right on time. But Windows 3.0, it turns out, would ship eight months late anyway—and not include Ruby at all.</p></figcaption></figure></div><h2 id="ruby-to-thunder">From Ruby to Thunder</h2><div><p>Officially, Ruby wasn&#39;t included as the default Windows 3.0 shell because it wasn&#39;t keystroke-for keystroke, pixel-for-pixel, identical to the OS/2 shell. The more likely reason, though, was that Ruby was political collateral damage inside of Microsoft. Few remember that Microsoft was at this time simultaneously developing Windows and jointly developing the OS/2 operating system with IBM. Tensions between the teams—OS/2 was originally considered the more strategic product and Windows the underdog—boiled over with Ruby as a proxy fight. Cooper suspects that the root issue was professional jealousy; some of the engineers on the Windows team had been present at the 1988 demo when Gates had been ever so effusive about Tripod. “He was making all those guys hate me,” Cooper suggests, “because I showed them up, really badly.”</p><p>Whatever the cause, Ruby was now orphaned inside of Microsoft less than a year after it was delivered. Frustrated, Cooper flew to Redmond, met with Bill Gates, and offered to buy the software back. “I said, ‘I&#39;ll release it myself, as a shell construction set for Windows&#39;.”</p><p>Gates refused.</p><p>Cooper had no leverage, and Gates, according to Cooper, figured he could keep Ruby around and do something with it.</p><p>And indeed he did. Gates loved BASIC—the programming language upon which Microsoft was founded—and believed that, with graphical user interfaces starting to define desktop computing, BASIC needed a visual component. Perhaps inspired by Apple&#39;s HyperCard, he came up with the idea of taking Ruby&#39;s visual programming frontend and replacing its small custom internal language with BASIC, effectively creating a visual programming language for developers.</p><p>In a 1989 Byte article <a href="https://d3399nw8s4ngfo.cloudfront.net/visual-basic/Byte_Magazine_Vol_14-10.pdf" target="_blank">celebrating the 25th birthday of BASIC</a>, Gates hinted at what he&#39;d directed the team to work on:</p></div><figure><blockquote><p>After all, the best way to design a form is to draw the form, not write code to reproduce it. With a mouse and a palette of pre-dawn graphics images, you should be able to combine lines, boxes, and buttons interactively on a screen to design a form for a program. That kind of interactive design of objects should also let you attach to or combine your creations within a program.</p></blockquote></figure><p>The Business Languages Group at Microsoft was tasked with making Gates&#39;s vision a reality. This was not received enthusiastically. The group was already stretched thin, charged with maintaining Microsoft&#39;s QuickBASIC IDE, the BASIC compiler, and developing a new language engine (dubbed Embedded Basic) for inclusion in a relational database product codenamed Omega (which would eventually become Microsoft Access).</p><div><figure><img src="http://jimkang.com/static/mblg-2a2a56f661a587b8680ba16d62607652.jpg" alt="An photograph of the Microsoft Business Language Group members at a team event. Some people are holding signs that read &#39;Thunder&#39;, &#39;BASIC&#39;, and &#39;Silver&#39;." loading="lazy"/><figcaption><h3>The Microsoft Business Language Group in 1990</h3><p><cite>(Image credit: Scott Ferguson)</cite></p></figcaption></figure></div><div><p>To pacify Gates, the unit staffed the project with a team of young, first-time leads, including Scott Ferguson, who was appointed Visual Basic&#39;s development lead and architect. Codenaming the project “Thunder,” the rookie team leaned hard on Michael Geary from Cooper&#39;s team to ease the transition.</p><p>“While we were experts in the intricacies of Windows UI development by the end of the project, we had only rudimentary skills at the start. [We had Michael] to familiarize us with the internals of Ruby and teach us the ‘weirding way&#39; of coercing the Windows USER APIs to make things happen that most Windows developers never cared about or experienced but were stressed to the breaking point by VB,” recalls Ferguson.</p></div><div><figure><img src="http://jimkang.com/static/vb-team-d37b68de531a63eb1a57f37a31b94d36.jpg" alt="A photograph of the Visual Basic Team after Microsoft 1.0 shipped. It includes the names of several members: John Fine, Adam Rauch, Rick Olson, Scott Ferguson, Chris Fraley, Nancy Barnes, Brian Overland, Nevet Basket, and Mr. and Mrs. Filler." loading="lazy"/><figcaption><h3>The Visual Basic team leads at Microsoft right after Visual Basic 1.0 shipped</h3><div><p>According to Ferguson, the photographer thought he needed more people to balance out the composition, so he brought in two of his assistants to act as “filler”.</p><p><cite>(Image credit: Scott Ferguson)</cite></p></div></figcaption></figure></div><div><p>Originally intended to be a quick 6-month project, the complexity of translating Ruby&#39;s shell construction kit into a full-fledged programming environment resulted in 18 laborious months of development.</p><p>The first breaking change was excising Ruby&#39;s “arrows between gizmos” graph for passing messages between controls.</p><p>The team considered simply replacing the crude string language with BASIC, but while a visual graph may have worked well for the simpler needs of a shell construction kit, it wouldn&#39;t scale for a general programming language. They ultimately decided to borrow Omega&#39;s Embedded Basic code editor and event model, a process Ferguson recounts as being “roughly equivalent to reaching into a monkey&#39;s brain and pulling out only the mushy bits relating to vision.”</p><p>The team settled on a final architecture for Thunder composed of three elements: the Embedded Basic language engine, a forms engine (based on the Ruby code from Cooper&#39;s team), and the shell—UI code both ported over from the Omega project and written from scratch.</p><p>By the time the project was ready to ship, little of Ruby&#39;s code remained. Ferguson recalls being asked if Ruby accounted for more than 15% of the product code, the contractual criterion for including attribution to Cooper&#39;s team:</p></div><figure><blockquote><p>Given that the forms engine was roughly a third of the product and the recognizable parts of Ruby remaining there were surely less than half of that, I might have said ‘no.&#39; But I offered that rounding up seemed fair, given that VB would likely not have happened at all if it were not for Ruby being thrust upon us.</p></blockquote></figure><div><figure><img src="http://jimkang.com/static/vb-1-2c4ef1cdba4ee6ea80e8681ba0acf409.jpg" alt="A screenshot of the Visual Basic 1.0 interface including a programming editor that&#39;s creating a calculator, combining both code and visual editing tools." loading="lazy"/><figcaption><h3>Visual Basic 1.0</h3><p>Visual Basic 1.0 combined the component tool palette and forms engine from Cooper&#39;s Ruby with Microsoft&#39;s Embedded Basic engine and Windows shell code.</p></figcaption></figure></div><div><p>Alas, the final product horrified Cooper—who loathed BASIC—when he heard about it. When Visual Basic 1.0 was released in 1991—just a year after Windows 3.0—Cooper flew up to Redmond and sat in the front row at the event, frustrated with what Microsoft had done to his baby.</p><p>Luckily for Microsoft, the market didn&#39;t share Cooper&#39;s opinion. Visual Basic was an immediate hit.</p></div><div><figure><img src="http://jimkang.com/static/immediate-hit-e160ac551a030b6b506b23c82ab53c60.jpg" alt="A picture of a CRT monitor with Visual Basic 1.0 on it. In front of that is a manual titled &#39;Microsoft Visual Basic&#39;." loading="lazy"/><figcaption><h3>An immediate hit</h3><p>PC Magazine awarded Visual Basic 1.0 for technical excellence in its December 1991 issue.</p></figcaption></figure></div><figure><p><img src="http://jimkang.com/static/gates-demo-cover-9e846ac1645a0f5ac42778e7f020342e.jpg" alt="A photograph of Bill Gates speaking with his hand raised. It has a play button on top of it." loading="lazy"/></p><div><div><div><p>00:00</p><!-- --><p> / </p><!-- --><p>00:00</p></div></div></div><p>Bill Gates demos Visual Basic 1.0 at its launch event.</p></figure><h2 id="something-pretty-right">Something pretty right</h2><div><p>Visual Basic burst onto the scene at a magical, transitional moment. Microcomputers were officially ascendant in the business world—and businesses needed software to run on them. Windows 3.0 was a huge success, selling 4 million copies in its first year and finally giving users of IBM-compatible PCs a graphical interface that rivaled the Apple Macintosh.</p><p>For the hundreds of thousands of mainframe programmers whose jobs were now under threat, though, this transition presented a professional quandary.</p><p>“The prevailing method of writing Windows programs in 1990 was the raw Win32 API. That meant the &#39;C&#39; Language WndProc(), giant switch case statements to handle WM_PAINT messages. Basically, all the stuff taught in the thick Charles Petzold book. This was a very tedious and complex type of programming. It was not friendly to a corporate ‘enterprise apps&#39; type of programming,” added a Hacker News commenter.</p></div><div><figure><img src="http://jimkang.com/static/programming-windows-40afba72c47c4818b49611993460f5c8.jpg" alt="A photograph of a book title &#39;Programming Windows: Second edition&#39;." loading="lazy"/><figcaption><h3>1990&#39;s Programming Windows 3.0 by Charles Petzold</h3><div><p>The 1000+ page Petzold books were a prerequisite for any developer wrestling with the Windows API.</p><p><cite>(Image credit: Foone Turing)</cite></p></div></figcaption></figure></div><div><p>And sure enough, for “millions of mainframe COBOL programmers who were looking with terror at the microcomputer invasion,” remembers Cooper, “Visual Basic basically became their safety net.” Instead of the steep learning curve of C/C++ and the low-level Win32 API, Visual Basic provided a simpler abstraction layer.</p><p>To design their UI, developers could drag and drop out components onto a WYSIWYG canvas. To add behavior to a UI element, they could simply select it and choose a click event handler from a dropdown. Mainframe programmers were suddenly empowered to quickly get up to speed writing Windows apps.</p><p>“For years, you know, guys would come up to me and go: ‘you saved my career&#39;,” Cooper notes. Geary noted that regularly encountering this sentiment from programmers “was one of the most gratifying things for all of us who worked on VB.”</p><p>Mainframe veterans weren&#39;t the only ones drawn to Visual Basic&#39;s accessibility. For many young people using computers for the first time, Visual Basic was the initial exposure to the power and joy of programming. “It gave me the start in understanding how functions work, how sub-procedures work, and how objects work. More importantly though, Visual Basic gave me the excitement and possibility that I could make this thing on my family&#39;s desk do pretty much whatever I wanted,” reminisced another Hacker News commenter.</p></div><figure><p><img src="http://jimkang.com/static/computer-chronicles-demo-cover-6b255988afc3f8666e3518ca498622b4.jpg" alt="A photograph of two men in collared shirts, both using computers, speaking to another man in a suit. There&#39;s a computer in the background and a large title that says &#39;Computer Chronicles&#39;." loading="lazy"/></p><div><div><div><p>00:00</p><!-- --><p> / </p><!-- --><p>00:00</p></div></div></div><p>Cornelius Willis and Jeff Beehler from Microsoft demo Visual Basic on a 1993 episode of “The Computer Chronicles” dedicated to visual programming environments.</p></figure><p>Another reason for Visual Basic&#39;s success was the direct result of a design decision originally made by Cooper&#39;s team. Like Ruby, Visual Basic had a palette of controls that you could drag and drop onto a form. Each of these controls was implemented as a separate, dynamically loaded DLL module. Michael Geary initially helped the Microsoft team carry this feature over from Ruby to Visual Basic, but finishing it continually fell below the product&#39;s cut list. Scott Ferguson described the team&#39;s dogged efforts to keep the feature alive amidst the pressure to ship:</p><figure><blockquote><p>The feature&#39;s high cost derived mostly from the testing and documentation efforts required. There would also be an effort to recruit and coordinate with third parties to build custom controls ready to ship with the new VB; plus development resources to assist all these efforts. At one time marketing even suggested that if we did not ship by Christmas we had just as well not ship the product at all! Fortunately, [Bill Gates&#39;s] patient genius prevailed and he insisted that we increase the schedule and delay shipping to allow for Custom Controls. Once again, the idea that something was ‘mostly done&#39; influenced the decision to get it done. And a whole new cottage industry was born as a side effect.</p></blockquote></figure><div><p>This interface for custom controls, known as VBX, grew into a booming third-party marketplace. Developers bought add-on VBX widgets from various companies to enhance their UIs—calendar date pickers, data grids, charts, barcode scanners, and more—without having to program the controls themselves.</p><p>Visual Basic&#39;s initial release in 1991 was followed by five major versions (not including an ill-fated version for DOS). By the time Visual Basic 6.0 was released in 1998, its dominance was absolute: two-thirds of all business application programming on Windows PCs was done in Visual Basic. At its peak, Visual Basic had nearly 3.5 million developers worldwide, more than ten times the number of C++ programmers.</p></div><figure><div><ol><li><img src="http://jimkang.com/static/Visual%20Basic%201.0%20A-37612d54f55d6d0d3ee5f5fa09ca8df5.jpg" alt="A screenshot showing the Visual Basic 1.0 starting interface. There are 16 buttons in the left panel." loading="lazy"/><p>1.0</p></li><li><img src="http://jimkang.com/static/Visual%20Basic%202.0%20A-0eafbfe04af0fc9e979020489a49d8f0.jpg" alt="A screenshot showing the Visual Basic 2.0 starting interface. There are 36 buttons in the left panel along with other new controls. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/><p>2.0</p></li><li><img src="http://jimkang.com/static/Visual%20Basic%203.0%20A-4cf1ef027244c8c23919a8eaf2428fde.jpg" alt="A screenshot showing the Visual Basic 3.0 starting interface. There are 38 buttons in the left panel. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/><p>3.0</p></li><li><img src="http://jimkang.com/static/Visual%20Basic%204.0%20A-3a0c448d9a2afa4671b28c5c28cd815d.jpg" alt="A screenshot showing the Visual Basic 4.0 starting interface. There are 26 buttons in the left panel. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/><p>4.0</p></li><li><img src="http://jimkang.com/static/Visual%20Basic%205.0%20A-fcb28d74ff25b0cbf219a87d4932c737.jpg" alt="A screenshot showing the Visual Basic 5.0 starting interface. There are 21 buttons in the left panel. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/><p>5.0</p></li><li><img src="http://jimkang.com/static/Visual%20Basic%206.0%20A-262e2cf31db67eb1c7571a7f1414f99d.jpg" alt="A screenshot showing the Visual Basic 1.0 starting interface. There is 1 button in the left panel but two rows of buttons on the top." loading="lazy"/><p>6.0</p></li></ol></div><div><h3>Visual Basic 1.0</h3><h3>Visual Basic 2.0</h3><h3>Visual Basic 3.0</h3><h3>Visual Basic 4.0</h3><h3>Visual Basic 5.0</h3><h3>Visual Basic 6.0</h3><p><img src="http://jimkang.com/static/Visual%20Basic%201.0%20A-37612d54f55d6d0d3ee5f5fa09ca8df5.jpg" alt="A screenshot showing the Visual Basic 1.0 starting interface. There are 16 buttons in the left panel." loading="lazy"/></p><p><img src="http://jimkang.com/static/Visual%20Basic%202.0%20A-0eafbfe04af0fc9e979020489a49d8f0.jpg" alt="A screenshot showing the Visual Basic 2.0 starting interface. There are 36 buttons in the left panel along with other new controls. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/></p><p><img src="http://jimkang.com/static/Visual%20Basic%203.0%20A-4cf1ef027244c8c23919a8eaf2428fde.jpg" alt="A screenshot showing the Visual Basic 3.0 starting interface. There are 38 buttons in the left panel. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/></p><p><img src="http://jimkang.com/static/Visual%20Basic%204.0%20A-3a0c448d9a2afa4671b28c5c28cd815d.jpg" alt="A screenshot showing the Visual Basic 4.0 starting interface. There are 26 buttons in the left panel. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/></p><p><img src="http://jimkang.com/static/Visual%20Basic%205.0%20A-fcb28d74ff25b0cbf219a87d4932c737.jpg" alt="A screenshot showing the Visual Basic 5.0 starting interface. There are 21 buttons in the left panel. There&#39;s also a row of buttons on the top of the screen." loading="lazy"/></p><p><img src="http://jimkang.com/static/Visual%20Basic%206.0%20A-262e2cf31db67eb1c7571a7f1414f99d.jpg" alt="A screenshot showing the Visual Basic 1.0 starting interface. There is 1 button in the left panel but two rows of buttons on the top." loading="lazy"/></p></div></figure><p>Cooper eventually came to appreciate Visual Basic&#39;s impact. “Had Ruby gone to the market as a shell construction set it, would have made millions of people happier, but then Visual Basic made hundreds of millions of people happier. I was not right, or rather, I was right enough, had a modicum of rightness. Same for Bill Gates, but the two of us together did something pretty right.”</p><figure><p><img src="http://jimkang.com/static/pioneer-award-cover-3002e2806609c9be1d1c73782d95e3db.jpg" alt="A picture of Alan Cooper in a suit smiling and speaking while he receives an award. Bill Gates is looking on from the side, also smiling. There&#39;s a play button overlayed on top." loading="lazy"/></p><div><div><div><p>00:00</p><!-- --><p> / </p><!-- --><p>00:00</p></div></div></div><p>Bill Gates presents Alan Cooper with the Windows Pioneer Award in recognition of his contributions to Microsoft Windows as “the father of Visual Basic.”</p></figure><h2 id="unforced-error">Microsoft&#39;s unforced error</h2><div><p>Just when Visual Basic seemed unstoppable, there came a painful corporate decision that would lead to endless conjecture.</p><p>In the late 1990s, partially in response to the competitive threat of Sun&#39;s Java, Microsoft shifted its focus to a new development framework and common language runtime called .NET. Microsoft pushed hard for developers to adopt .NET, and Visual Basic was pulled into a ground-up rewrite to move it from a procedural language to an object-oriented one better suited to the new framework. The successor to Visual Basic 6.0, dubbed VB.NET and released in 2002, completely changed the ethos of the product, and turned out to be the death knell for the original idea of Visual Basic.</p><p>While Visual Basic was an easy on-ramp for developers with heavy abstractions, VB.NET was a more complex, full-featured programming language. It shared many complex concepts with Microsoft&#39;s new C# language, including threads, inheritance, and polymorphism. And like C#, it had a much higher learning curve for developers to become proficient.</p><p>In a Microsoft blog post from 2012, .NET instructor David Platt recounts that Microsoft committed a classic mistake in product development—listening only to their most vocal customers:</p></div><figure><blockquote><div><p>Almost all Visual Basic 6 programmers were content with what Visual Basic 6 did. They were happy to be bus drivers: to leave the office at 5 p.m. (or 4:30 p.m. on a really nice day) instead of working until midnight; to play with their families on weekends instead of trudging back to the office. They didn&#39;t lament the lack of operator overloading or polymorphism in Visual Basic 6, so they didn&#39;t say much.</p><p>The voices that Microsoft heard, however, came from the 3 percent of Visual Basic 6 bus drivers who actively wished to become fighter pilots. These guys took the time to attend conferences, to post questions on CompuServe forums, to respond to articles. Not content to merely fantasize about shooting a Sidewinder missile up the tailpipe of the car that had just cut them off in traffic, they demanded that Microsoft install afterburners on their buses, along with missiles, countermeasures and a head-up display. And Microsoft did.</p></div></blockquote></figure><div><p>Worse, there was no reliable migration path for legacy apps from “classic” Visual Basic to VB.NET. While Microsoft released porting tools, they were unreliable at best, and users were faced with manual, time-consuming, error-prone rewrites. “[Microsoft] left everybody&#39;s VB6 code completely stranded with no path forward to making modern apps on the latest versions of Windows. A lot of times you couldn&#39;t even get your VB6 apps to install on the latest version of Windows,” recalls a Slashdot commenter.</p><p>Microsoft had broken the trust of its army of Visual Basic developers. Faced with the options of either starting over from scratch in VB.NET or moving to new web-native languages like JavaScript and PHP, most developers chose the latter—a brutal unforced error by Microsoft. (It&#39;s easy to forget the pole position that Microsoft had on the web in 2001: Internet Explorer had 96% market share, and Visual Basic apps could even be embedded into web pages via ActiveX controls.)</p><p>Evans Data estimated that from spring of 2006 to winter 2007, developer usage of the entire Visual Basic Family dropped by 35%. By 2008, Microsoft officially sunsetted support for the VB6 IDE. It did, however, extend support of the VB6 runtime in Windows in effective perpetuity—a testament to the amount of critical legacy business applications that their customers had built with Visual Basic.</p></div><figure><blockquote><p>“...Visual Basic did more for programming than Object-Oriented Languages did...”</p></blockquote><div></div></figure><div><p>In 2006, an 18-year-old blogger and coder named Jaroslaw Rzeszótko emailed a series of unsolicited questions to a group of famous developers. Among his questions was a future looking solicitation: “What will be the next big thing in programming?” Most of his audience rejected the basis of the question or demurred, but Linus Torvalds, creator of the Linux kernel, took the bait. He predicted the importance of incremental improvements in programming, specifically “tools to help make all the everyday drudgery easier.”</p><p>“For example, I personally believe that Visual Basic did more for programming than Object-Oriented Languages did,” Torvalds wrote, “yet people laugh at VB and say it&#39;s a bad language, and they&#39;ve been talking about OO languages for decades. And no, Visual Basic wasn&#39;t a great language, but I think the easy DB interfaces in VB were fundamentally more important than object orientation is, for example.”</p><p>Torvalds, as it turns out, was right: it was primarily the tools, ecosystems, integrations, and frameworks that would define the near future, not the design of the languages themselves.</p><p>Coincidentally or not, the demise of Visual Basic lined up perfectly with the rise of the web as the dominant platform for business applications. If the microcomputer supercharged demand for business software, the Internet strapped it to a rocket and fired it into space. IDC predicts that between 2019 and 2023, over 500 million applications will be developed using cloud-native approaches, most targeted at industry-specific line-of-business use cases. In five years, that&#39;s the same number of apps as developed in the prior 40 years entirely.</p><p>Satiating this global demand for software has not come with exponential growth in the number of developers. Hired reports that employment demand for developers doubled in 2021, but Evans Data projects that the total number of developers in the world will only grow by 20% from 2019 to 2024. In this gap, the single biggest lever (as Torvalds predicted) has been making developers more productive.</p><p>20 years ago, deploying an application on Windows meant walking around 3.5” floppies or a CD-R and manually running an installer on each machine (a process repeated for every upgrade or bug fix). Deploying software to the web avoided the sneakernet, but required developers to buy expensive servers, physically rack them in a colocated data center, and manually fix or replace the hardware when it inevitably failed.</p><p>Jeff Bezos famously referred to tasks like these as “<a href="https://techtv.mit.edu/videos/d651efff51bf42e2b936335069bd5178/?start=1665" target="_blank">undifferentiated heavy lifting</a>,” all of the prerequisite, unrelated slogs that stand between a programmer and realizing an idea in the world. Today, thanks to the continued development of abstraction layers like Amazon Web Services, a developer can instantaneously deploy an application to the edge right from the command line, never once reasoning about physical locations, hardware, operating systems, runtimes, or servers.</p><p>Still, the abstractions at the infrastructure layer have perhaps outpaced that of the client-side: many of the innovations that Alan Cooper and Scott Ferguson&#39;s teams introduced 30 years ago are nowhere to be found in modern development. Where developers once needed to wrestle with an arcane Win32 API, they now have to figure out how to build custom Select components to work around browser limitations, or struggle to glue together disparate SaaS tools with poorly documented APIs. This, perhaps, fuels much of the nostalgic fondness for Visual Basic—that it delivered an ease and magic we have yet to rekindle.</p><p>It hasn&#39;t been for want of trying. The ideas behind Visual Basic have been remarkably, stubbornly persistent. Whether built on spreadsheets, code, nodes, direct manipulation—or some combination thereof—novel <a href="https://github.com/ivanreese/visual-programming-codex/blob/main/implementations.md" target="blank">authoring</a> <a href="http://presentations.dubberly.com/data_authoring_environments.pdf" target="blank">environments</a> <a href="http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/" target="blank">for</a> <a href="https://docs.google.com/presentation/d/e/2PACX-1vSPuf3eQ2tlCtXAif4gEWQQU-xK8EzhiH3SIfuD7vWy7eP4NN0-KRejbec_m-GF6-f_D95OOFyyoolx/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.g1da0625f1b_0_56" target="blank">programming</a> continue to capture the imagination of developers. Even Microsoft itself has continued to chase the dream since sunsetting VB6, with efforts like LightSwitch, Expression Blend, Project Siena, and PowerApps.</p></div><div><figure><img src="http://jimkang.com/static/lightswitch-26631626f26b63f8c8db4d7a69f1d6a0.jpg" alt="A screenshot of Visual Studio LightSwitch, including a tree of elements and a list of customers in an administrative panel." loading="lazy"/><figcaption><h3>Visual Studio LightSwitch</h3><p>Visual Studio LightSwitch was one of Microsoft&#39;s many subsequent attempts to recapture the original magic—and market—of Visual Basic.</p></figcaption></figure></div><p>As for Alan Cooper, he considers himself lucky. Neither mathematically inclined nor particularly disposed to engineering, he happened to start his career during a time in software when what was needed was neither mathematics nor engineering, but carpentry. “I knew how to build stuff,” he recounts. And he created a piece of software that enabled other people to build stuff to solve their problems. Perhaps not perfectly, but pragmatically. The languages may change, the infrastructure may change, the runtimes may change—but that&#39;s an idea that will never go out of fashion.</p><figure><blockquote><p>From Visual Basic to HyperCard, at Retool we continually draw inspiration from the rich legacy of tools that have changed how we think about programming. We’re building a development environment that carries these ideas forward: combining the richness of visual direct manipulation with the ergonomics, expressiveness, and hackability of code.</p><a href="http://jimkang.com/" target="_blank"></a></blockquote><div></div></figure></div></div>
  </body>
</html>
