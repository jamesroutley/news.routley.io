<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dust.tt/spreadsheets-databases-and-beyond-creating-a-universal-ai-query-layer/">Original</a>
    <h1>Building AI agents to query your databases</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        <div>
        <section>

            <ul>
                <li>
                    <a href="http://approximateknowledge.net/author/stanislas/" aria-label="Read more of Stanislas Polu">
                        <img src="http://approximateknowledge.net/content/images/size/w100/2025/01/stan.webp" alt="Stanislas Polu"/>
                    </a>
                </li>
            </ul>

            <div>
                
                <p><time datetime="2025-03-13">13 Mar 2025</time>
                        <span><span>•</span> 8 min read</span>
                </p>
            </div>

        </section>
        </div>

            <figure>
                <img srcset="/content/images/size/w300/2025/03/-5.jpg 300w,
                            /content/images/size/w600/2025/03/-5.jpg 600w,
                            /content/images/size/w1000/2025/03/-5.jpg 1000w,
                            /content/images/size/w2000/2025/03/-5.jpg 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="http://approximateknowledge.net/content/images/size/w2000/2025/03/-5.jpg" alt="Spreadsheets, Databases, and Beyond: Creating a Universal AI Query Layer"/>
            </figure>

    </header>

    <section>
        <p>In the world of AI agents, the ability to understand and analyze structured data is a game-changer. While large language models excel at understanding natural language, they struggle with quantitative analysis when data is presented as unstructured text. This is where <a href="https://docs.dust.tt/docs/table-queries?ref=blog.dust.tt">Query Tables</a> comes in – a powerful feature that enables agents to execute SQL queries on structured data, providing precise answers to analytical questions.</p><p>At Dust, we&#39;ve been on a journey to build and evolve our Query Table agent tool from a simple CSV file parser to a sophisticated system that can connect to enterprise data warehouses. This blog post details that journey – the technical challenges we faced, the architectural decisions we made, and how we&#39;ve maintained a unified abstraction layer that makes it easy for our users to work with structured data regardless of its source.</p><figure data-kg-thumbnail="https://blog.dust.tt/content/media/2025/03/Snowflake-AI-agents-in-Dust-1_thumb.jpg" data-kg-custom-thumbnail="">
            <div>
                <video src="https://blog.dust.tt/content/media/2025/03/Snowflake-AI-agents-in-Dust-1.mp4" poster="https://img.spacergif.org/v1/2912x2160/0a/spacer.png" width="2912" height="2160" playsinline="" preload="metadata"></video>
                
                <div>
                    <div>
                        <p>
                        
                        <span>0:00</span></p><p>
                            /<span>0:17</span>
                        </p>
                        </div>
                </div>
            </div>
            
        </figure><h2 id="the-problem-why-semantic-search-falls-short-for-quantitative-analysis">The problem: why semantic search falls short for quantitative analysis.</h2><p>Before diving into our solution, it&#39;s important to understand the problem we were trying to solve. Semantic search is great for retrieving relevant chunks of information from unstructured text, but it has significant limitations when it comes to quantitative analysis:</p><ol><li><strong>Incomplete data access</strong>: Semantic search only retrieves chunks of data, not the entire dataset, making it impossible to perform comprehensive analysis.</li><li><strong>No computation capabilities</strong>: Even if all the data were retrieved, LLMs have no built-in ability to perform calculations or aggregations.</li><li><strong>Relevance vs. completeness</strong>: Semantic search optimizes for relevance, not completeness, which is problematic for analytical queries that require full datasets.</li></ol><p>We saw this limitation firsthand when users tried to ask quantitative questions about their CSV files, Notion databases, or Google Sheets. The answers were often incomplete or inaccurate because the agent couldn&#39;t &#34;see&#34; the entire dataset or perform the necessary calculations.</p><h2 id="the-origin-story-csv-files-and-sqlite">The origin story: CSV files and SQLite.</h2><h3 id="early-conceptualization">Early Conceptualization</h3><p>Our journey began when users started asking about importing CSV files into Dust. Initially, these files were loaded directly into the context window as plain text, which created two major limitations: we could only handle small files due to context window constraints, and even when the data fit, the LLM struggled to perform accurate calculations or analysis on the raw tabular text. The results were often inconsistent and unreliable, especially for anything beyond the most basic arithmetic operations.</p><p>We started exploring a more sophisticated approach: using SQLite as an in-memory database to execute SQL queries against structured data. This decision was driven by several factors:</p><ol><li><strong>Simplicity</strong>: SQLite is lightweight and requires no additional infrastructure</li><li><strong>Security</strong>: In-memory databases provide strong isolation for user data</li><li><strong>Performance</strong>: Early tests showed it was fast enough for our use cases</li><li><strong>Familiarity</strong>: SQL is a well-established language for data analysis</li></ol><h3 id="technical-implementation">Technical Implementation</h3><p>The core of our implementation was a system that could:</p><ol><li>Parse CSV files and infer their schema</li><li>Create an in-memory SQLite database</li><li>Load the data into the database</li><li>Allow the agent to generate and execute SQL queries</li><li>Return the results to the user</li></ol><p>Performance was a concern, but our initial tests were promising. For a typical CSV file of ~2MB, the entire process from file reading to query execution took less than a second:</p><pre><code>File reading: 14 ms
Schema inference: 162 ms
Table creation and data insertion: ~600 ms
Querying: 15 ms
</code></pre><p>An important advantage of this approach is that we perform the data loading concurrently while the AI is generating the SQL query—making these operations effectively invisible in terms of user-perceived latency since they happen during time the model would be generating text anyway. For most use cases, this was fast enough, and the in-memory approach meant we didn&#39;t need to maintain persistent database instances for each table.</p><p>To optimize resource usage while maintaining responsiveness, we implemented a caching mechanism for our in-memory databases. After the initial query completes, the database instance remains alive for several minutes, allowing follow-up questions to be answered without the overhead of recreating the database.</p><p>Each active database is tracked with a lightweight heartbeat system, and instances that haven&#39;t been queried for a configurable period (typically 5 minutes) are automatically shut down and their resources reclaimed. This approach strikes a balance between performance for multi-turn conversations and efficient resource management, which is particularly important as the number of concurrent users grows.</p><h3 id="query-generation-and-execution">Query Generation and Execution</h3><p>With the database set up, the next step is generating and executing the SQL query. This involves:</p><ol><li>Providing the agent with the schema information</li><li>Letting the agent generate a SQL query based on the user&#39;s question</li><li>Validating the query to ensure it&#39;s safe and well-formed</li><li>Executing the query against the in-memory database</li><li>Formatting the results for presentation to the user</li></ol><h2 id="expanding-to-connected-data-sources">Expanding to Connected Data Sources</h2><h3 id="the-connected-data-challenge">The Connected Data Challenge</h3><p>We had a solid foundation for handling CSV files, but our users wanted more. They needed to query data that lived in connected systems like Notion databases, Google Sheets, and Office 365 spreadsheets – data that was constantly changing and couldn&#39;t be effectively managed through manual uploads.</p><p>This presented new challenges:</p><ol><li><strong>Data synchronization</strong>: How to keep the data up-to-date without manual intervention</li><li><strong>Schema discovery</strong>: How to automatically detect and map schemas from different sources</li><li><strong>Hierarchical structures</strong>: How to handle nested structures like sheets within spreadsheets</li><li><strong>Performance at scale</strong>: How to maintain performance with larger, more complex datasets</li></ol><h3 id="notion-databases">Notion Databases</h3><p>Our first connected data source was Notion. Notion databases are structured collections of pages with consistent properties, making them a natural fit for our Query Tables agent tool.</p><p>One challenge was handling Notion&#39;s flexible property types, which include text, numbers, dates, selects, multi-selects, and more. We had to develop robust type conversion logic to map these properties to SQL data types.</p><h3 id="google-sheets-and-office-365">Google Sheets and Office 365</h3><p>Next came Google Sheets and Office 365 spreadsheets. These presented their own challenges:</p><ol><li><strong>Sheet hierarchy</strong>: A single spreadsheet file could contain multiple sheets</li><li><strong>Data quality and structure</strong>: Many spreadsheets contain loosely structured or completely unstructured data – merged cells, multi-level headers, embedded charts, formatting as data, inconsistent value representations, and free-form notes mixed with tabular data. This &#34;human-friendly but machine-unfriendly&#34; formatting makes a significant percentage of real-world spreadsheets impossible to reliably parse as structured tables without cleanup or preprocessing.</li><li><strong>Header detection</strong>: Determining which row contained the headers</li><li><strong>Type inference</strong>: Inferring data types from cell values</li></ol><h3 id="unified-data-source-abstraction">Unified Data Source Abstraction</h3><p>A key architectural decision was maintaining a unified abstraction layer for all data sources. Regardless of whether data came from a CSV file, a Notion database, or a Google Sheet, it would be represented as a table with:</p><ul><li>A unique ID</li><li>A name and description</li><li>A schema (columns and their types)</li><li>A source URL (for tracking back to the original data)</li></ul><p>This abstraction made it possible for agents to work with any data source using the same SQL interface without needing to know the underlying details.</p><p><strong>What makes this approach powerful is that it allows users to join tables from completely different sources – combining data from a CSV file with a Notion database and a Google Sheet in a single SQL query, something that would be difficult to accomplish manually.</strong></p><h2 id="extending-to-data-warehouses-snowflake-and-bigquery">Extending to data warehouses: Snowflake and BigQuery.</h2><h3 id="the-enterprise-data-challenge">The Enterprise Data Challenge</h3><p>We were then ready for the next evolution: connecting to enterprise data warehouses like Snowflake and BigQuery. This was driven by strong customer demand, particularly from companies with significant investments in these platforms.</p><p>Unlike our previous data sources, enterprise data warehouses:</p><ol><li>Can contain terabytes or petabytes of data</li><li>Have complex permission models</li><li>Use specialized SQL dialects</li><li>Often sit behind firewalls with strict access controls</li></ol><p>Importing this data into SQLite wasn&#39;t feasible – we needed a different approach.</p><h3 id="remote-database-architecture">Remote Database Architecture</h3><p>For data warehouses, we adopted a &#34;remote database&#34; pattern:</p><ol><li><strong>Metadata Synchronization</strong>: Instead of syncing the data itself, we sync metadata about tables, schemas, and relationships</li><li><strong>Remote Query Execution</strong>: Queries are executed directly on the remote database, not in SQLite</li><li><strong>Result Limiting</strong>: We limit the amount of data returned to prevent overwhelming the system</li><li><strong>Permission Enforcement</strong>: Before executing any query, we run an <code>EXPLAIN</code> command that analyzes the query plan without executing it. This reveals all tables the query will access, allowing us to verify they match the permissions defined in the agent’s configuration. If the query attempts to access unauthorized tables, it&#39;s rejected immediately, even if the database role itself has broader permissions. This creates a crucial security layer that prevents agents from accessing data outside of their permissions, regardless of the underlying database permissions.</li></ol><p>This approach allows us to leverage the performance and scale of the data warehouse while maintaining our unified abstraction layer.</p><h2 id="just-in-time-tables-query-results-are-also-tables"><strong>Just-in-time tables: query results are also tables.</strong></h2><p>Our JIT tables feature treats query results as first-class tables, enabling powerful multi-step data analysis.</p><p>When an assistant executes a query against Snowflake, Google Sheets, or any tabular data source, the results automatically become a queryable table within the conversation. This allows users to join these results with data from other sources—like a Datadog CSV, they just uploaded or metrics from another database—in subsequent queries.</p><p>By making every query result a potential input for the next operation, users can build complex analytical workflows without leaving the conversation, seamlessly bridging data across previously isolated sources.</p><h2 id="the-future-salesforce-and-beyond">The future: Salesforce and beyond.</h2><h3 id="salesforce-integration">Salesforce Integration</h3><p>Our next frontier is Salesforce, which is currently in development. Salesforce presents unique challenges:</p><ol><li><strong>Object-Oriented Data Model</strong>: Salesforce uses objects instead of tables, with relationships between objects</li><li><strong>SOQL Dialect</strong>: Salesforce uses its own query language (SOQL) that differs from standard SQL</li><li><strong>Mixed Data Types</strong>: Salesforce contains both structured data and long-form text fields</li></ol><p>Our approach combines:</p><ol><li>Remote database querying for structured data through SOQL</li><li>Semantic search for long-form text fields</li></ol><h3 id="enforcing-permissions-for-salesforce-queries">Enforcing permissions for Salesforce Queries</h3><p>One of the most interesting challenges with Salesforce integration is &#34;sandboxing&#34; the agent’s access to the Salesforce database to respect our permission model. In our space-based permission system, users can grant access to specific Salesforce objects but not others. However, Salesforce&#39;s query language (SOQL) allows for complex relationship traversal that could potentially access unauthorized objects.</p><p>Unlike SQL databases where we can use <code>EXPLAIN</code> to analyze which tables a query will access, Salesforce&#39;s query plans only reveal the main object being queried, not the related objects accessed through relationship notation (like <code>Comment.Post.content</code>).</p><p>After exploring several approaches, including regex-based parsing and custom SOQL parsers, we settled on a JSON-based query format that gives us precise control over which objects are accessed. Instead of having the AI agent generate SOQL directly, it generates a structured JSON representation of the query:</p><pre><code>{
  &#34;object&#34;: &#34;Account&#34;,
  &#34;fields&#34;: [&#34;Id&#34;, &#34;Name&#34;, &#34;Industry&#34;],
  &#34;where&#34;: {
    &#34;condition&#34;: &#34;AND&#34;,
    &#34;filters&#34;: [
      { &#34;field&#34;: &#34;Industry&#34;, &#34;operator&#34;: &#34;=&#34;, &#34;value&#34;: &#34;Technology&#34; },
      { &#34;field&#34;: &#34;AnnualRevenue&#34;, &#34;operator&#34;: &#34;&gt;&#34;, &#34;value&#34;: 1000000 }
    ]
  },
  &#34;orderBy&#34;: [
    { &#34;field&#34;: &#34;Name&#34;, &#34;direction&#34;: &#34;ASC&#34; }
  ],
  &#34;limit&#34;: 50
}
</code></pre><p>This approach offers several advantages:</p><ol><li><strong>Complete control</strong>: We can validate exactly which objects and fields are being accessed</li><li><strong>Easy to parse</strong>: JSON is straightforward to validate compared to parsing SOQL</li><li><strong>Future-proof</strong>: The format can be extended to support additional features</li></ol><p>On the backend, we convert this JSON representation to SOQL before sending it to Salesforce. This approach maintains our unified abstraction layer while respecting the space-based permission model that&#39;s core to our platform.</p><h2 id="conclusion-the-power-of-a-unified-abstraction">Conclusion: the power of a unified abstraction</h2><p>What makes our approach to the Query Tables agent tool powerful is the unified abstraction layer we&#39;ve maintained throughout this evolution. <strong>Whether data lives in a CSV file, a Notion database, a Google Sheet, or a Snowflake data warehouse, agents interact with it through the same Query Tables tool.</strong></p><p>This abstraction shields users from the complexity of the underlying systems and allows us to add new data sources without changing the user experience.</p><p>As we continue to evolve our Query Tables agent tool, we remain committed to this principle: making structured data accessible to AI agents, regardless of where it lives or how it&#39;s formatted. By doing so, we&#39;re enabling a new generation of agents that can not only understand natural language but also perform sophisticated data analysis, bringing the power of data to everyone.</p>
    </section>


</article>
</div></div>
  </body>
</html>
