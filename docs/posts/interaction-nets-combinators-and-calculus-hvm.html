<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/">Original</a>
    <h1>Interaction Nets, Combinators, and Calculus ‚Äì HVM</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>I&#39;ve recently <a href="https://zicklag.github.io/blog/hvm-what-is-functional-programming/">posted</a> about <a href="https://github.com/HigherOrderCO/HVM">HVM</a>, a highly parallel, functional runtime with awesome potential, and, just maybe, the computing model of the future.</p>
<p>But what what <em>is</em> HVM built on? From the readme we hear about things such as <em>Interaction Nets</em> and <em>Lambda Calculus</em>, but it&#39;s hard to grasp what those are and how they relate to each-other without some investigation.</p>
<p>In this post, I&#39;m going to cover some of the important concepts at a medium-high level. I&#39;m going just deep enough to see how some of the theoretical pieces fit together, while trying to avoid getting bogged down with too many details.</p>
<p>Let&#39;s get started!</p>
<h2 id="interaction-nets">Interaction Nets</h2>
<p>The first thing to understand are <strong>Interacion Nets</strong>. Interaction Nets provide a way of programming that has some useful properties:</p>
<ul>
<li>They evaluate deterministically.</li>
<li>They are parallel friendly, by not requiring lots of global synchronization.</li>
<li>They don&#39;t need a garbage collector to be evaluated.</li>
<li>They are Turing complete, which means they can be used to represent any computation.</li>
<li>They can be efficiently executed on sequential machines like our modern processors.</li>
</ul>
<p>An interaction net is made up of an undirected graph of labeled nodes, along with a set of rules that define how nodes with different labels interact with each-other. These interactions are represented by substitutions on the graph, which move the computation forward.</p>
<h3 id="interaction-nodes">Interaction Nodes</h3>
<p>Each node in the grpah must have one active port, and zero or more secondary ports. For instance, some nodes that we might use to make up a Cons list would be:</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/nodes.excalidraw.png">
    <img alt="Append, Cons, and Nil Nodes" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/nodes.excalidraw.png"/>
</a></p><blockquote>
<p>üí° <strong>Diagram Source:</strong> Some of the node examples have been taken from Yves Lafont&#39;s paper <em>Interaction Nets</em>, and other examples have been taken from drawings by <a href="https://github.com/VictorTaelin">Victor Taelin</a>, both were rendered into new diagrams by me.</p>
</blockquote>
<p>In the diagrams, each active port is indicated with an arrow going out from a node.</p>
<h3 id="substitution-rules">Substitution Rules</h3>
<p>Substitution rules are applied when <em>two nodes&#39; active ports are connected to each-other</em>. That&#39;s the only time we may define substitutions. If we don&#39;t have two active ports connected, no substitutions will happen.</p>
<p>Here are the two rules we could use to implement the interaction between the <code>Append</code> node and the <code>Cons</code> and <code>Nil</code> nodes. This is essentially the same thing we did when we implemented <code>List.append</code> for HVM in my <a href="https://zicklag.github.io/blog/hop-hvm-mini-language-part-2/#appending-to-strings-and-lists">previous post</a>.</p>
<h4 id="append-to-cons-rule">Append to Cons Rule</h4>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/append-cons-rule.excalidraw.png">
    <img alt="Append to Cons Rule" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/append-cons-rule.excalidraw.png"/>
</a></p><h4 id="append-to-nil-rule">Append to Nil Rule</h4>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/append-nil-rule.excalidraw.png">
    <img alt="Append to Nil Rule" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/append-nil-rule.excalidraw.png"/>
</a></p><hr/>
<p>That&#39;s the basic idea! There are a few more restrictions and details about the concept, but I&#39;m not going to go over them here. The restrictions make it possible to prove some of the properties of interaction nets, such as their deterministic evaluation.</p>
<p>Because node substitution rules are only applied on active pairs, it gives us a way to know exactly where to apply substitutions first, and we can potentially do those substitutions on different parts of the graph in parallel, which is awesome.</p>
<h2 id="interaction-combinators">Interaction Combinators</h2>
<p>The next important concept is <strong>Interaction Combinators</strong>. Interaction Combinators are specific set of nodes and rules for interaction nets that are in fact <em>universal</em>. This means that <em>any</em> interaction net could actually be converted to an interaction net made up only of interaction combinators, and still perform the same computation.</p>
<p>The beauty of interaction combinators is their simplicity. There are only three kinds of nodes, and only three kinds of substitution rules.</p>
<h3 id="combinator-nodes">Combinator Nodes</h3>
<p>The three kinds of interaction combinator nodes are <strong>constructors</strong>, <strong>duplicators</strong>, and <strong>erasers</strong>.</p>
<blockquote>
<p><strong>Note:</strong> For the sake of the examples below, we don&#39;t need to use erasers, so we&#39;re going to leave them out for now. In concept, an eraser is a node with only one port that deletes anything that&#39;s plugged into it, so it is easy to imagine how it might play into things after we understand constructors and duplicators.</p>
</blockquote>
<p>To simplify our graphs, we&#39;re going to constructors and duplicators a little different than the nodes in our examples above. They will look like this:</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/duplicator-constructor.excalidraw.png">
    <img alt="Duplicator and Constructor Nodes" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/duplicator-constructor.excalidraw.png"/>
</a></p><p>We use the greek delta symbol, Œ¥, for duplicators, and the greek gamma symbol, Œ≥, for constructors. Both constructors and duplicators have one active port, and two secondary ports.</p>
<h3 id="combinator-rules">Combinator Rules</h3>
<p>The first rule is annihilation.</p>
<blockquote>
<p><strong>Annihilation:</strong> ‚ÄúWhen the active ports of two nodes <strong>of the same kind</strong> are connected, delete the nodes, and connect their corresponding secondary ports.‚Äù</p>
</blockquote>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/annihilation.excalidraw.png">
    <img alt="Annihilation Rule" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/annihilation.excalidraw.png"/>
</a></p><p>The second rule is duplication:</p>
<blockquote>
<p><strong>Duplication:</strong> ‚ÄúWhen the active ports of two nodes <strong>of different kinds</strong> are connected, then you duplicate both nodes, rotate them around, then connect the four nodes&#39; non-active ports to each-other.‚Äù</p>
</blockquote>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/duplication.excalidraw.png">
    <img alt="Duplication Rule" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/duplication.excalidraw.png"/>
</a></p><h3 id="combinator-computation">Combinator Computation</h3>
<p>Computing interaction combinators happens the same way as any other interaction net:</p>
<ul>
<li>Search the graph for any pair of nodes with their active ports connected.</li>
<li>Apply the applicable substitution for those active nodes.</li>
<li>Keep repeating those steps until there are no active pairs.</li>
</ul>
<p>Despite their simplicity, interaction combinators are still Turing complete! You can represent any computation with just <strong>constructors</strong>, <strong>duplicators</strong>, <strong>annihilations</strong>, <strong>duplications</strong>, and <strong>erasers</strong>.</p>
<p>But how can we go about producing interaction nets that will do the computations that we want them to? To answer that, we have to take a slight detour.</p>
<h2 id="lambda-calculus">Lambda Calculus</h2>
<p>Lambda calculus is a simple programming form that forms the foundation for functional programming, and understanding it is important to understanding how we can program with Interaction Combinators.</p>
<blockquote>
<p><strong>‚ÑπÔ∏è Note:</strong> <a href="https://lambdaexplorer.com/">LambdaExplorer.com</a> provides a great tutorial introduction to Lambda Calculus with an interactive calculator if you want to learn more about how it works. You can even put some of the samples below into the calculator to have it reduce them.</p>
</blockquote>
<p>A lambda is kind of like a function that can take a single argument, and returns it&#39;s body.</p>
<p>For instance, this is a simple lambda that takes an argument, and just returns it unchanged.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>Œªx</span><span>.x
</span></code></pre>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda.excalidraw.png">
    <img alt="A Lambda" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda.excalidraw.png"/>
</a></p><p>Since a lambda could return another lambda, you can use that to simulate lambdas with multiple arguments.</p>
<p>This lambda takes two arguments, and returns the second one unchanged.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>Œªa</span><span>.(</span><span>Œªb</span><span>.</span><span>b</span><span>)
</span></code></pre>
<h3 id="lambda-application">Lambda Application</h3>
<p>Computation is powered by <strong>Lambda Application</strong>. Lambda application is kind of like calling the lambda like a function. You take the lambda body and substitute all occurrences of the lambda&#39;s argument for some value.</p>
<p>We indicate lambda application by placing one expression after another. So <code>xy</code> actually means, ‚ÄúApply <code>x</code> to <code>y</code>‚Äù.</p>
<p>For example, if we apply <code>(Œªx.x)</code> to the variable <code>y</code> we get.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-application.excalidraw.png">
    <img alt="Lambda Application" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-application.excalidraw.png"/>
</a></p><p>For another example, here is a lambda that means: ‚Äútake an argument <code>x</code> and then apply <code>x</code> to itself‚Äù:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>Œªx</span><span>.</span><span>xx
</span></code></pre>
<p>Once there are no more lambda applications to make, we have reached what we call the <strong>normal form</strong>, and the computation is done.</p>
<p>Let&#39;s look at one more lambda expression and see how it reduces to normal form:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>(</span><span>Œªx</span><span>.</span><span>xx</span><span>)(</span><span>Œªx</span><span>.x) </span><span>// Replace each `x` in the first lambda&#39;s body with (Œªx.x)
</span><span>(</span><span>Œªx</span><span>.x)(</span><span>Œªx</span><span>.x)  </span><span>// Again, replace the `x` in the first lambda&#39;s body with (Œªx.x)
</span><span>Œªx</span><span>.x
</span></code></pre>
<p>If this doesn&#39;t make sense to you yet, maybe go through the <a href="https://lambdaexplorer.com/">lambda explorer</a> tutorial to get a better idea of what&#39;s going on. It&#39;s got a really great walk-through.</p>
<h2 id="interaction-calculus">Interaction Calculus</h2>
<p>Finally we introduce <strong>Interaction Calculus</strong>. Interaction Calculus is a language inspired by lambda calculus, that, in fact, represents a net of interaction combinators.</p>
<p>We can quite simply represent lambdas and lambda applications with interaction combinator constructor nodes, and we can use a duplicator node whenever we need to use a value twice. We also introduce the root node, which represents the end result of the computation.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-nodes.excalidraw.png">
    <img alt="Interaction Combinators As Lambda Calculus Nodes" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-nodes.excalidraw.png"/>
</a></p><h3 id="example-expressions">Example Expressions</h3>
<p>For instance, if we want to represent the simple lambda <code>Œªx.x</code>, which just returns it&#39;s argument, we would do that with an interaction net like this:</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lam-x-x.excalidraw.png">
    <img alt="Œªx.x as an Interaction Combinator" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lam-x-x.excalidraw.png"/>
</a></p><p>Notice how the argument port of the lambda, is connected to the body port of the lambda in a loop, as representative of the lambda taking it&#39;s argument, and using it as it&#39;s body.</p>
<p>Here&#39;s another example for <code>Œªx.xx</code>.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lam-x-xx.excalidraw.png">
    <img alt="Œªx.xx as an Interaction Combinator" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lam-x-xx.excalidraw.png"/>
</a></p><p>This is a lot more complicated, so let&#39;s try to break it down. We can see that this expression is made up of one lambda node, one duplicator node, and one lambda application node.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lam-x-xx-annotated.excalidraw.png">
    <img alt="Œªx.xx as an Interaction Combinator Annotated" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lam-x-xx-annotated.excalidraw.png"/>
</a></p><p>If you follow it slowly you can see how this net does exactly what lambda expression does: it is a lambda, where the argument is taken, duplicated, and then applied to itself, before being returned as the body of the lambda.</p>
<p>If you don&#39;t get it right away, don&#39;t worry, it&#39;s a little tricky! Just try to follow the process carefully and compare the node ports and connections with the list of nodes above.</p>
<h3 id="a-reducible-expression">A Reducible Expression</h3>
<p>Once you&#39;ve got that down, lets see what <code>(Œªx.xx)(Œªx.x)</code> looks like. Note that the previous examples were already in their normal form, but this expression is not. Again, if you look carefully at the above two graphs, neither of them had any active pairs, so there are no substitutions that we could make.</p>
<p>But, if we represent <code>(Œªx.xx)(Œªx.x)</code> as a graph, it is <strong>not</strong> in normal form, and will therefore have active pairs that we can reduce.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-lam-x-xx-app-lam-x-x.excalidraw.png">
    <img alt="(Œªx.xx)(Œªx.x) as an Interaction Combinator" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-lam-x-xx-app-lam-x-x.excalidraw.png"/>
</a></p><p>If you break this down you can see it&#39;s made by combining our graphs for <code>(Œªx.xx)</code> and <code>(Œªx.x)</code> with a lambda application node:</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-lam-x-xx-app-lam-x-x-annotated.excalidraw.png">
    <img alt="(Œªx.xx)(Œªx.x) as an Interaction Combinator Annotated" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/lambda-lam-x-xx-app-lam-x-x-annotated.excalidraw.png"/>
</a></p><p>Now that we have an active pair, between two nodes of the same kind, we can apply our annihilation rule, and begin reducing the graph to normal form. This gives us a new graph:</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/reduction-example1.excalidraw.png">
    <img alt="Example Reduction Step 1" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/reduction-example1.excalidraw.png"/>
</a></p><p>And now there&#39;s a new active pair, so we can further reduce this graph. This time the active pair contains a constructor and a duplicator node, so we need to use the duplication rule.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/reduction-example2.excalidraw.png">
    <img alt="Example Reduction Step 2" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/reduction-example2.excalidraw.png"/>
</a></p><p>This <em>also</em> created another active pair, so we apply the annihilation rule again, and finally, one more time.</p>
<p><a href="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/reduction-example3.excalidraw.png">
    <img alt="Example Reduction Step 3" src="https://zicklag.github.io/blog/interaction-nets-combinators-calculus/reduction-example3.excalidraw.png"/>
</a></p><p>And look at that, the final graph is the same as the graph for <code>Œªx.x</code>, which, in fact, is the normal form of <code>(Œªx.xx)(Œªx.x)</code>! We just reduced a lambda expression using interaction combinators!</p>
<p>An amazing thing about reducing lambda expressions like this is that the reductions are <em>optimal</em>, meaning that they avoid unnecessary work.</p>
<h3 id="relation-to-lambda-calculus">Relation to Lambda Calculus</h3>
<p>A caveat of this technique for reducing lambdas is that it doesn&#39;t exactly match the behavior of the normal lambda calculus. While it might reduce the same as the normal lambda calculus in many cases, it doesn&#39;t always. And that&#39;s totally fine, it doesn&#39;t need to match perfectly to be useful in it&#39;s own right.</p>
<p>Another thing to be aware of is that certain terms that can reduce under lambda calculus don&#39;t reduce under interaction calculus, but this is a rare edge-case.</p>
<p>I also haven&#39;t covered the whole set of rules for interaction calculus here. You can read a little more by checking the comments in the <a href="https://github.com/HigherOrderCO/Wikind/blob/master/IC/_.kind2">source code</a> for the latest implementation of interaction calculus in the Kind language.</p>
<h3 id="relation-to-garbage-collection">Relation to Garbage Collection</h3>
<p>Part of the key to HVMs performance is the way that it doesn&#39;t need a garbage collector, and that is partially owed to the semantics of interaction calculus. It just so happens that the interaction between constructor and duplicator nodes gives us a way to <em>incrementally clone</em> a lambda expression. This is incredibly important to being able to avoid using references and keep things simple and performant.</p>
<p>You can read a bit more about this in the <a href="https://github.com/HigherOrderCO/HVM/blob/87147d64421909d55dc57a1c4db03ac6b0f1fe2a/guide/HOW.md#what-makes-it-fast">What Makes it Fast</a> section of the work-in-progress HVM explanation doc.</p>
<h2 id="summary">Summary</h2>
<p>And that concludes your tour! We&#39;ve taken an ultra quick look at a lot of the foundational theoretical elements behind HVM and, while some of it&#39;s a little hard to wrap your head around, it&#39;s also not that complicated!</p>
<p>It&#39;s really exciting to me that such a powerful concept can be expressed in such simple terms, and I&#39;m intrigued enough that I might play around with my own implementation just to see how simple it could be to make a runtime that out-performs runtimes like Python, JavaScript, etc.</p>
<p>I just started investigating all of this 4 days ago, so my understanding on any of these topics may not be 100% accurate. If somebody find somethings incorrect in this post, I&#39;d be grateful if you <a href="https://github.com/zicklag/blog/discussions/new?category=general">opened a discussion</a> so that I can correct it.</p>
<p>I can&#39;t wait to keep learning and trying stuff out. I&#39;ll be posting more as I progress. To the future! üöÄ</p>

        </div></div>
  </body>
</html>
