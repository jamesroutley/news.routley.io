<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chromium.googlesource.com/linux-syscall-support/">Original</a>
    <h1>Linux Syscall Support</h1>
    
    <div id="readability-page-1" class="page"><div><p>Every so often, projects need to directly embed Linux system calls instead of calling the implementations in the system runtime library.</p><p>This project provides a header file that can be included into your application whenever you need to make direct system calls.</p><p>The goal is to provide an API that generally mirrors the standard C library while still making direct syscalls.  We try to hide some of the differences between arches when reasonably feasible.  e.g. Newer architectures no longer provide an <code>open</code> syscall, but do provide <code>openat</code>.  We will still expose a <code>sys_open</code> helper by default that calls into <code>openat</code> instead.</p><p>We explicitly do not expose the raw syscall ABI including all of its historical warts to the user.  We want people to be able to easily make a syscall, not have to worry that on some arches size args are swapped or they are shifted.</p><p>Please be sure to review the Caveats section below however.</p><h2><a name="How-to-include-linux_syscall_support_h-in-your-project" href="#How-to-include-linux_syscall_support_h-in-your-project"><span></span></a><a name="how-to-include-linux_syscall_support_h-in-your-project" href="#how-to-include-linux_syscall_support_h-in-your-project"><span></span></a>How to include linux_syscall_support.h in your project</h2><p>You can either copy the file into your project, or preferably, you can set up Git submodules to automatically pull from our source repository.</p><h2><a name="Supported-targets" href="#Supported-targets"><span></span></a><a name="supported-targets" href="#supported-targets"><span></span></a>Supported targets</h2><p>The following architectures/ABIs have been tested (at some point) and should generally work.  If you don&#39;t see your combo listed here, please double check the header itself as this list might be out of date.</p><ul><li>x86 32-bit (i.e. i386, i486, i586, i686, Intel, AMD, etc...)</li><li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64 64-bit</a> (i.e. x86-64, amd64, etc...)</li><li><a href="https://sites.google.com/site/x32abi/">x32 32-bit</a></li><li><a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM 32-bit</a> OABI</li><li><a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM 32-bit</a> EABI (i.e. armv6, armv7, etc...)</li><li>AARCH64 64-bit (i.e. arm64, armv8, etc...)</li><li>PowerPC 32-bit (i.e. ppc, ppc32, etc...)</li><li>MIPS 32-bit o32 ABI</li><li>MIPS 32-bit n32 ABI</li><li>MIPS 64-bit n64 ABI</li><li>LOONGARCH 64-bit ABI</li></ul><h2><a name="API" href="#API"><span></span></a><a name="api" href="#api"><span></span></a>API</h2><p>By default, you can just add a <code>sys_</code> prefix to any function you want to call. So if you want to call <code>open(...)</code>, use <code>sys_open(...)</code> instead.</p><h3><a name="Knobs" href="#Knobs"><span></span></a><a name="knobs" href="#knobs"><span></span></a>Knobs</h3><p>The linux_syscall_support.h header provides many knobs for you to control the exported API.  These are all documented in the top of the header in a big comment block, so refer to that instead.</p><h2><a name="Caveats" href="#Caveats"><span></span></a><a name="caveats" href="#caveats"><span></span></a>Caveats</h2><h3><a name="ABI-differences" href="#ABI-differences"><span></span></a><a name="abi-differences" href="#abi-differences"><span></span></a>ABI differences</h3><p>Some functions that the standard C library exposes use a different ABI than what the Linux kernel uses.  Care must be taken when making syscalls directly that you use the right structure and flags.  e.g. Most C libraries define a <code>struct stat</code> (commonly in <code>sys/stat.h</code> or <code>bits/stat.h</code>) that is different from the <code>struct stat</code> the kernel uses (commonly in <code>asm/stat.h</code>).  If you use the wrong structure layout, then you can see errors like memory corruption or weird/shifted values.  If you plan on making syscalls directly, you should focus on headers that are available under the <code>linux/</code> and <code>asm/</code> namespaces.</p><p>Note: LSS provides structs for most of these cases.  For <code>sys_stat()</code>, it provides <code>struct kernel_stat</code> for you to use.</p><h3><a name="Transparent-backwards-compatibility-with-older-kernels" href="#Transparent-backwards-compatibility-with-older-kernels"><span></span></a><a name="transparent-backwards-compatibility-with-older-kernels" href="#transparent-backwards-compatibility-with-older-kernels"><span></span></a>Transparent backwards compatibility with older kernels</h3><p>While some C libraries (notably, glibc) take care to fallback to older syscalls when running on older kernels, there is no such support in LSS.  If you plan on trying to run on older kernels, you will need to handle errors yourself (e.g. <code>ENOSYS</code> when using a too new syscall).</p><p>Remember that this can happen with new flag bits too.  e.g. The <code>O_CLOEXEC</code> flag was added to many syscalls, but if you try to run use it on older kernels, it will fail with <code>EINVAL</code>.  In that case, you must handle the fallback logic yourself.</p><h3><a name="Variable-arguments-varargs" href="#Variable-arguments-varargs"><span></span></a><a name="variable-arguments-varargs" href="#variable-arguments-varargs"><span></span></a>Variable arguments (varargs)</h3><p>We do not support vararg type functions.  e.g. While the standard <code>open()</code> function can accept 2 or 3 arguments (with the mode field being optional), the <code>sys_open()</code> function always requires 3 arguments.</p><h2><a name="Bug-reports-feature-requests" href="#Bug-reports-feature-requests"><span></span></a><a name="bug-reports-feature-requests" href="#bug-reports-feature-requests"><span></span></a>Bug reports &amp; feature requests</h2><p>If you wish to report a problem or request a feature, please file them in our <a href="https://bugs.chromium.org/p/linux-syscall-support/issues/">bug tracker</a>.</p><p>Please do not post patches to the tracker.  Instead, see below for how to send patches to us directly.</p><p>While we welcome feature requests, please keep in mind that it is unlikely that anyone will find time to implement them for you.  Sending patches is strongly preferred and will often move things much faster.</p><h2><a name="Projects-that-use-LSS" href="#Projects-that-use-LSS"><span></span></a><a name="projects-that-use-lss" href="#projects-that-use-lss"><span></span></a>Projects that use LSS</h2><ul><li><a href="https://www.chromium.org/">Chromium</a></li><li><a href="https://chromium.googlesource.com/breakpad/breakpad">Breakpad</a></li><li><a href="https://developer.chrome.com/native-client">Native Client</a>, in nacl_bootstrap.c</li></ul><h2><a name="How-to-get-an-LSS-change-committed" href="#How-to-get-an-LSS-change-committed"><span></span></a><a name="how-to-get-an-lss-change-committed" href="#how-to-get-an-lss-change-committed"><span></span></a>How to get an LSS change committed</h2><h3><a name="Review" href="#Review"><span></span></a><a name="review" href="#review"><span></span></a>Review</h3><p>You get your change reviewed, you can upload it to <a href="https://chromium-review.googlesource.com/q/project:linux-syscall-support+status:open">Gerrit</a> using <code>git cl upload</code> from <a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html">Chromium&#39;s depot-tools</a>.</p><h3><a name="Testing" href="#Testing"><span></span></a><a name="testing" href="#testing"><span></span></a>Testing</h3><p>Tests are found in the <a href="https://avi.im/blag/2024/disaggregated-storage/+/HEAD/tests">tests/</a> subdirectory.  It does not (yet) offer 100% coverage, but should grow over time.</p><p>New commits that update/change/add syscall wrappers should include tests for them too.  Consult the <a href="https://avi.im/blag/2024/disaggregated-storage/+/HEAD/tests/README.md">test documentation</a> for more details.</p><p>To run, just run <code>make</code> inside the tests directory.  It will compile &amp; execute the tests locally.</p><p>There is some limited cross-compile coverage available if you run <code>make cross</code>. It only compiles things (does not execute at all).</p><h3><a name="Rolling-into-Chromium" href="#Rolling-into-Chromium"><span></span></a><a name="rolling-into-chromium" href="#rolling-into-chromium"><span></span></a>Rolling into Chromium</h3><p>If you commit a change to LSS, please also commit a Chromium change to update <code>lss_revision</code> in <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/DEPS">Chromium&#39;s DEPS</a> file.</p><p>This ensures that the LSS change gets tested, so that people who commit later LSS changes don&#39;t run into problems with updating <code>lss_revision</code>.</p></div></div>
  </body>
</html>
