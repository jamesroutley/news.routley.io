<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://coderoasis.com/implementing-rsa-from-scratch-in-python/">Original</a>
    <h1>Implementing RSA in Python from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
    <article>

        <header>


            


            <div>
                <section>
                    <ul>
                        <li>
                            <a href="https://coderoasis.com/author/franx1024/"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"></path></g></svg>
</a>
                        </li>
                    </ul>
                    <div>
                        
                        <p><time datetime="2021-08-19">Aug 19, 2021</time>
                            <span><span>•</span> 5 min read</span>
                        </p>
                    </div>
                </section>
            </div>

            <figure>
                <img srcset="https://images.unsplash.com/photo-1515879218367-8466d910aaa4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHB5dGhvbnxlbnwwfHx8fDE2MzExNzg0NTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 300w,
                            https://images.unsplash.com/photo-1515879218367-8466d910aaa4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHB5dGhvbnxlbnwwfHx8fDE2MzExNzg0NTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 600w,
                            https://images.unsplash.com/photo-1515879218367-8466d910aaa4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHB5dGhvbnxlbnwwfHx8fDE2MzExNzg0NTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 1000w,
                            https://images.unsplash.com/photo-1515879218367-8466d910aaa4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHB5dGhvbnxlbnwwfHx8fDE2MzExNzg0NTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://images.unsplash.com/photo-1515879218367-8466d910aaa4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHB5dGhvbnxlbnwwfHx8fDE2MzExNzg0NTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Implementing RSA in Python from Scratch (Part 1)"/>
                    <figcaption>Photo by <a href="https://unsplash.com/@cdr6934?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Chris Ried</a> / <a href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Unsplash</a></figcaption>
            </figure>
        </header>

        <section>
            <p>I&#39;m sure many programmers, particularly web developers have heard of the RSA cryptography system. RSA is an asymmetric cryptography system, meaning that one key is used for encryption and the other for decryption. I&#39;ve seen a lot of articles explaining the general principles of asymmetric cryptography, but I have not seen any that give easy-to-understand explanations of the mathematical background behind these algorithms, so I decided to write this article.</p><!--kg-card-begin: markdown--><h2 id="explanation-of-the-math-behind-rsa">Explanation of the math behind RSA</h2>
<!--kg-card-end: markdown--><p>For start, as I&#39;ve mentioned in the paragraph above, to transmit an RSA-encrypted message, you need 2 keys. One that can only encrypt and one that can decrypt. Let encryption key be denoted as `e`, the decryption key will be denoted as `d` and the message will be denoted as `m`. The key principle behind RSA is that in the following notion:</p><!--kg-card-begin: markdown--><p>(m^e)^d ≡ m (mod n)</p>
<!--kg-card-end: markdown--><p>The difficulty of finding `d`, knowing `e` and `n` can be very hard if these numbers are chosen properly (as will be demonstrated below).</p><!--kg-card-begin: markdown--><p>But first, we need to introduce some new concepts in number theory.</p>
<ul>
<li>a ≡ b (mod n) means that there is an integer x such that a + nx = b. A more intuitive explanation is that the reminder of a / n equals the reminder of b / n.</li>
<li>gcd(a, b) is the greatest number that divides both a and b.</li>
<li>lcm(a, b) is the smallest number that is a multiple of both a and b.</li>
<li>λ(n) is a number such that x^λ(n) ≡ 1 (mod n) for any x such that gcd(x, n) = 1. From this you can conclude that x^a ≡ x^b (mod n) if a ≡ b (mod λ(n))</li>
</ul>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="generating-keys">Generating keys</h3>
<p>Let&#39;s make n = pq where p and q are 2 prime numbers. Since λ(p) = p - 1 and λ(q) = q - 1 (lookup Fermat&#39;s little theorem proof for why), λ(n) = (p - 1) * (q - 1).</p>
<p>Now we have to slove ed ≡ 1 (mod λ(n)). e can be some prime number (usually 65537) and d can be calculated using extended Euclidian&#39;s algorithm (will be written and explained in the code section) from the equation ed + xλ(n) = gcd(e, λ(n)) (d and x are coefficients to be calculated).</p>
<p>pair (e, n) is used for encryption (<code>(m^e) % n</code>) and pair (d, n) is used for decryption (<code>(m^d) % n</code>)</p>
<p>After computing the keys, p and q can be thrown away. Notice that without p and q, finding λ(n) would mean factorizing n, which is not an easy problem to solve for values of n up to 2^2048, which are regularily used.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="implementing-rsa-in-python">Implementing RSA in Python</h2>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>First to list procedures and their steps:</p>
<h4 id="keys-generation">keys generation:</h4>
<ul>
<li>find 2 random prime numbers, <code>p</code> and <code>q</code></li>
<li>compute <code>n = p * q</code> and <code>λ(n) = (p - 1) * (q - 1)</code></li>
<li>make <code>e</code> equal some prime number, e.g. <code>e = 35537</code></li>
<li>compute <code>d</code> from equation <code>ed + λ(n)x = gcd(e, λ(n)) = 1</code> using Extended Euclidian Algorithm (from this point on we will call it <code>eucalg</code>)</li>
</ul>
<h5 id="encryption">Encryption:</h5>
<ul>
<li>divide the message into sections (of 256 bits if n is 2048-bit)</li>
<li>each section (denoted as <code>m</code>) is encrypted as <code>(m^e) % n</code></li>
</ul>
<h4 id="decryption">Decryption:</h4>
<ul>
<li>divide the message into sections, same as above</li>
<li>each section (denoted as <code>m</code>) is decrypted as <code>(m^d) % n</code></li>
</ul>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="implementation-of-extended-euclidian-algorithm">Implementation of Extended Euclidian Algorithm</h3>
<p>This algorithm relies on the fact that if <code>x</code> divides both <code>a</code> and <code>b</code>, there will be a pair of coefficients <code>(k, l)</code> such that:</p>
<pre><code>def eucalg(a, b):
	# make a the bigger one and b the lesser one
	swapped = False
	if a &lt; b:
		a, b = b, a
		swapped = True
	# ca and cb store current a and b in form of
	# coefficients with initial a and b
	# a&#39; = ca[0] * a + ca[1] * b
	# b&#39; = cb[0] * a + cb[1] * b
	ca = (1, 0)
	cb = (0, 1)
	while b != 0:
		# k denotes how many times number b
		# can be substracted from a
		k = a // b
		# a  &lt;- b
		# b  &lt;- a - b * k
		# ca &lt;- cb
		# cb &lt;- (ca[0] - k * cb[0], ca[1] - k * cb[1])
		a, b, ca, cb = b, a-b*k, cb, (ca[0]-k*cb[0], ca[1]-k*cb[1])
	if swapped:
		return (ca[1], ca[0])
	else:
		return ca
</code></pre>
<p>Notice that the function above can produce negative numbers for coefficients, so in case that happens, all that we need to do is set <code>d</code> to <code>λ(n) - d</code>.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="implementing-fast-exponentiation-with-modulo">Implementing fast exponentiation with modulo</h3>
<p>Some might suggest to just use <code>(b ** e) % n</code>, but this approach is not very good time and memory -wise because <code>b ** e</code> can be very big despite only the last 2000 bits or so being needed. The solution is to reinplement exponentiation with calculating modulo after every division.</p>
<p>Exponentiation implementation below has logarithmic time complexity. Instead of itterating from 1 to <code>e</code> and multiplying <code>r</code> (result) by <code>b</code>, it itterates from the most significant bit of <code>e</code> to the least significant bit of <code>e</code>, and at each bit it does <code>r = r*r + bit</code>. This works because if <code>r</code> equals <code>b^x</code> and you&#39;re appending a bit to the end of x, new x will be <code>x * 2 + bit</code>.</p>
<pre><code>def modpow(b, e, n):
	# find length of e in bits
	tst = 1
	siz = 0
	while e &gt;= tst:
		tst &lt;&lt;= 1
		siz += 1
	siz -= 1
	# calculate the result
	r = 1
	for i in range(siz, -1, -1):
		r = (r * r) % n
		if (e &gt;&gt; i) &amp; 1: r = (r * b) % n
	return r
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="key-generation-encryption-and-decryption">Key generation, encryption and decryption</h3>
<p>Keys generation, encryption and decryption have all been explained in the math section and the code below is simply implementation of that.</p>
<pre><code>def keysgen(p, q):
	n = p * q
	lambda_n = (p - 1) * (q - 1)
	e = 35537
	d = eucalg(e, lambda_n)[0]
	if d &lt; 0: d += lambda_n
        # both private and public key must have n stored with them
	return {&#39;priv&#39;: (d, n), &#39;pub&#39;: (e, n)}

def numencrypt(m, pub):
	return modpow(m, pub[0], pub[1])

def numdecrypt(m, priv):
	return modpow(m, priv[0], priv[1])
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="testing-the-code-we-have-until-now">Testing the code we have until now</h3>
<p>I stored the code into a file named rsa.py and run the following in Python shell:</p>
<pre><code>&gt;&gt;&gt; import rsa
&gt;&gt;&gt; keys = rsa.keysgen(31337, 31357)
&gt;&gt;&gt; keys
{&#39;priv&#39;: (720926705, 982634309), &#39;pub&#39;: (35537, 982634309)}
&gt;&gt;&gt; priv = keys[&#39;priv&#39;]
&gt;&gt;&gt; pub = keys[&#39;pub&#39;]
&gt;&gt;&gt; msg = 80087
&gt;&gt;&gt; enc = rsa.numencrypt(msg, priv)
&gt;&gt;&gt; enc
34604568
&gt;&gt;&gt; dec = rsa.numdecrypt(enc, pub)
&gt;&gt;&gt; dec
80087
&gt;&gt;&gt; 
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="conclusion">Conclusion</h2>
<p>In the end of writing this article I realized that implementation of a usable Python RSA program is more complicated than I initially speculated. Because of that, I decided to split the topic up in multiple articles. With the code presented in this article you have all core parts of RSA written. But you still need a random prime generator and plaintext encryption (<code>numencrypt</code> and <code>numdecrypt</code> are suitable only for numbers <code>m</code> smaller in size than <code>n</code>). All these will be included in the next article that will be published shortly.</p>
<p><a href="https://coderoasis.com/implementing-rsa-in-python-from-scratch-part-2/">[PART 2]</a></p>
<!--kg-card-end: markdown-->
        </section>


    </article>
</div></div>
  </body>
</html>
