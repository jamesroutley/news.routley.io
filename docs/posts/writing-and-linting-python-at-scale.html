<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2023/08/07/developer-tools/fixit-2-linter-meta/">Original</a>
    <h1>Writing and linting Python at scale</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>Fixit is dead! Long live Fixit 2 – the latest version of our open-source auto-fixing linter.</span></li>
<li aria-level="1"><span>Fixit 2 allows developers to efficiently build custom lint rules and perform auto-fixes for their codebases.</span></li>
<li aria-level="1"><span>Fixit 2 is </span><span>available today on </span><a href="https://pypi.org/project/fixit/2.0.0a1/" target="_blank" rel="noopener"><span>PyPI</span></a><span>.</span></li>
</ul>
<p><a href="https://engineering.fb.com/2022/07/27/developer-tools/programming-languages-endorsed-for-server-side-use-at-meta/" target="_blank" rel="noopener"><span>Python is one of the most popular languages in use at Meta.</span></a><span> Meta’s production engineers (PEs) are specialized software engineers (SWEs) who focus on reliability, efficiency, and scalability. They work on various projects, including debugging production services, rewriting inefficient libraries, orchestrating project deployments at scale, or capacity planning and scheduling. And Python is often one of the first tools that PEs reach for, as it offers rapid development, easy to read syntax, and a massive array of open source libraries.</span></p>
<p><span>Meta’s Python Language Foundation team — a hybrid team of both PEs and traditional SWEs — helps own and maintain the infrastructure and tooling for Python at Meta. The team supports engineers, data scientists, researchers, and anyone else at Meta using Python to get their work done.</span></p>
<p><span>One of the ways we accomplish this is building tools that enable Python developers to write better, and more reliable code more efficiently. This includes tools like</span> <a href="https://ufmt.omnilib.dev" target="_blank" rel="noopener"><span>automatic formatting</span></a><span> and</span> <a href="https://usort.rtfd.io/" target="_blank" rel="noopener"><span>import sorting</span></a><span> that eliminate tedium, or linters that guide engineers toward maintainable code with fewer bugs.</span></p>
<p><span>This year, we have been building a new linter, </span><a href="https://pypi.org/project/fixit/2.0.0a1/" target="_blank" rel="noopener"><span>Fixit 2</span></a><span>, designed from the ground up to make developers more efficient and capable, both in open source projects and the diverse landscape of our internal monorepo. At Meta, we are using Fixit 2 with a few early adopters, and plan to roll it out to the rest of our monorepo soon. But any developer can use it to </span><span>perform auto-fixing more efficiently and make faster improvements to their own codebases.</span></p>
<h2><span>Why a new linter? (why not X?)</span></h2>
<p><span>There are a variety of excellent linters in the Python ecosystem, many of which have a large community of third-party plugins providing a diverse array of lint rules. We have used </span><a href="https://flake8.pycqa.org" target="_blank" rel="noopener"><span>Flake8</span></a><span> internally at Meta since 2016, and it has been very successful in helping developers reduce bugs and keep a clean codebase. The popular flake8-bugbear plugin was even created by Łukasz Langa (author of </span><a href="https://black.readthedocs.io" target="_blank" rel="noopener"><span>Black</span></a><span>, PSF developer-in-residence, and release manager for Python 3.8 and 3.9) while working at Meta (then Facebook), as a home for more opinionated lint rules that we could both use internally and share with the rest of the Python developer community. </span></p>
<p><span>We also have a large number of internal plugins built by various teams, and Flake8 allows them to write and enable custom lint rules directly in the codebase without getting sign-off from a central gatekeeper, and without waiting for a new deployment of Flake8 to roll out.</span></p>
<p><span>But while Flake8 has long been a cornerstone of our linting solution, it also has some rough edges. Writing new lint rules requires building entire plugins (each claiming a portion of the “namespace” for error codes) and encourages developers to build complicated plugins covering multiple classes of errors. When those lint errors are found, Flake8 can only point to a line and column number where it occurred, but has no way of suggesting changes to the developer looking at a list of lint results, leaving them in a state of trial and error to find changes that make the linter happy. Also, Flake8 uses the stdlib </span><span>ast</span><span> module, making it unable to parse future syntax features and forcing developers to wait for tools to upgrade before they can use the shiny new hotness.</span></p>
<p><span>There are alternatives to Flake8 of course, but many of them suffer from one or more drawbacks: </span></p>
<ul>
<li aria-level="1"><span>A lack of support for “local” in-repo plugins or custom lint rules. </span></li>
<li aria-level="1"><span>Limited or no support for hierarchical configuration for different projects within a monorepo.</span></li>
<li aria-level="1"><span>No option for auto-fixes when errors are found.</span></li>
<li aria-level="1"><span>Slow performance on large codebases.</span></li>
</ul>
<p><span>While some of those features aren’t critical, the most important for developer efficiency is offering auto-fixes – automatic suggested changes that would satisfy the lint rule. This takes the guesswork out of using a linter, and allows users to quickly review and accept those changes when possible, eliminating the need to re-run the linter until the code is finally clean. Combining these auto-fixes with in-repo, custom lint rules provides a level of tailored code quality improvements that is hard to beat.</span></p>
<p><span>Unfortunately, even Fixit, the auto-fixing linter that we built for Instagram and open sourced, did not support local lint rules or hierarchical configuration – core requirements for our monorepo that is home to thousands of projects, many of which are themselves open source projects with their own distinct needs for linting and CI. We received many requests from developers to support Fixit in our monorepo, but there were enough hurdles that we were only able to support a small set of security lint rules, reducing the direct benefits to our Python codebase. </span></p>
<h2><span>Meet Fixit 2</span></h2>
<p><span>After discussions with other teams, especially in the rapidly growing AI/ML space, we considered our options and decided upon a partial rewrite of Fixit. We intentionally designed the new version with an open source-first mindset, while incorporating the needs and requirements of our own monorepos and open source projects from day one.</span></p>
<p><span>The framework and linting engine would be rebuilt from the ground up while leaving the core design of lint rules largely untouched. The new system provides a hierarchical configuration based on the TOML format; support for local, in-repo lint rules similar to Flake8; and a much improved CLI and API for integration with other tools and automation. </span></p>
<p><span>Fixit itself builds on top of another Instagram open source project, </span><a href="https://libcst.rtfd.io/" target="_blank" rel="noopener"><span>LibCST</span></a><span>, a concrete syntax tree for Python with a tree and node API following the patterns of the <span>ast</span> </span><span>module in the standard library. The “concrete” part of CST means that LibCST includes every part of the source file in the resulting tree after parsing, including whitespace, comments, and formatting elements that are ignored by the <span>ast</span> </span><span>module. This is what allows Fixit (and other tools we built, like </span><a href="https://usort.rtfd.io/" target="_blank" rel="noopener"><span>µsort</span></a><span>) to safely modify source files, without using regular expressions or the risk of producing broken syntax, and provides the foundation for Fixit to offer auto-fixes suggested by the lint rules themselves.</span></p>
<p><span>Writing a new lint rule can be done with less than a dozen lines of code, and test cases are defined inline. You can even place it right next to the code that it will be linting:</span></p>
<pre><code># teambread/rules/hollywood.py
import fixit
import libcst
class HollywoodName(fixit.LintRule):
    VALID = [...] # no lint errors here
    INVALID = [...] # bad code samples here
    def visit_SimpleString(self, node: libcst.SimpleString):
        if node.value in (&#39;&#34;Paul&#34;&#39;, &#34;&#39;Paul&#39;&#34;):
            self.report(node, &#34;It&#39;s underbaked!&#34;)</code></pre>
<p><span>Suggesting auto-fixes for the user is as easy as including a new CST node when reporting an error:</span></p>
<pre><code>def visit_SimpleString(self, node: libcst.SimpleString):
    if node.value in (&#39;&#34;Paul&#34;&#39;, &#34;&#39;Paul&#39;&#34;):
        new_node = libcst.SimpleString(&#39;&#34;Mary&#34;&#39;)
        self.report(node, new_node)</code></pre>
<p><span>Enabling this new rule within the project’s codebase can be done with a simple config change:</span></p>
<pre><code># teambread/sourdough/fixit.toml
[tool.fixit]
enable = [&#34;.rules.hollywood&#34;]
</code></pre>
<p><span>Now we can run our linter against our project:</span></p>
<pre><code># teambread/sourdough/baker.py
name = &#34;Paul&#34;
print(f&#34;hello {name}!&#34;)</code></pre>
<pre><code>$ fixit lint --diff sourdough/baker.py
sourdough/baker.py@7:11 HollywoodName: It&#39;s underbaked! (has autofix)
--- a/baker.py
+++ b/baker.py
@@ -6,3 +6,3 @@
def main():
-    name = &#34;Paul&#34;
+    name = &#34;Mary&#34;
    print(f&#34;hello {name}&#34;)
🛠️  1 file checked, 1 file with errors, 1 auto-fix available 🛠️
[1]</code></pre>
<p><span>The `lint` command only shows errors and suggested changes. If we use the `fix` command, we can apply those suggested changes back to the codebase:</span></p>
<pre><code>$ fixit fix --automatic sourdough/baker.py
sourdough/baker.py@7:11 HollywoodName: It&#39;s underbaked! (has autofix)
🛠️  1 file checked, 1 file with errors, 1 auto-fix available, 1 fix applied 🛠️
</code></pre>
<p><span>Now that our auto-fixes have been applied, we can confirm that the project is now clean and lint-free:</span></p>
<pre><code>$ fixit lint sourdough/baker.py
🧼 1 file clean 🧼</code></pre>
<p><span>When running Fixit 2 with auto-fixing lint rules, any code that triggers the lint rule is an opportunity to get an automatic replacement, improving the codebase with less effort from the developer. Applied more broadly, Fixit 2 can even be used as a tool to enact sweeping codemods against a large codebase, while leaving a lint rule in place to handle any matching code in the future.</span></p>
<h2><span>Try Fixit 2 </span></h2>
<p><span>Fixit 2 is available today on </span><a href="https://pypi.org/project/fixit/2.0.0a1/" target="_blank" rel="noopener"><span>PyPI</span></a><span>. You can install and test Fixit 2 with </span><span><span>pip</span> <span>install</span> </span><span><span>fixit</span>. </span></p>
<p><span>We have a </span><a href="https://github.com/Instagram/Fixit/milestones" target="_blank" rel="noopener"><span>roadmap</span></a><span> with plans for future improvements and features, and a rich set of </span><a href="https://fixit.rtfd.io/en/latest/" target="_blank" rel="noopener"><span>documentation and user guides</span></a><span> to help you get started with Fixit 2 in your own projects or repositories. </span><span>We hope it proves useful in your projects, and we look forward to </span><a href="https://github.com/Instagram/Fixit/issues" target="_blank" rel="noopener"><span>hearing your feedback</span></a><span>!</span></p>

		
	</div></div>
  </body>
</html>
