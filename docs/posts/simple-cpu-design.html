<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://simplecpudesign.com/">Original</a>
    <h1>Simple CPU Design</h1>
    
    <div id="readability-page-1" class="page">


<p><a href="http://simplecpudesign.com/Images/simplecpu.jpg"><img src="http://simplecpudesign.com/Images/simplecpu_tmb.jpg"/></a></p>



<p>Figure 1: the SimpleCPU processor</p>



<p>Welcome to the world of tomorrow (<a href="https://www.youtube.com/watch?v=aiwA0JrGfjA">Link</a>), the past and the present of computer architectures, with a small sprinkling of flashing LEDs. All good computers have to have banks of flashing lights. This web site was inspired by an article by Alan Clements (<a href="http://alanclements.org/teachingarchitecture.html">Link</a>), in this he discusses the pressures faced in teaching computer architectures. After teaching this topic for about 20 years i also came to the same conclusions, although being an electronic engineer i still embrace the power of ICs, wires and LEDs as teaching tools :). Therefore, to hopefully support computer architectures teaching i have created the resources below.</p>

<p>For those who have not taught computer architectures before this may seem an outdated, or redundant topic i.e. why do students need to know what happens inside a CPU, very few students will go on design one? To me this way of thinking highlights the misunderstanding of the purpose of teaching computer architectures. To steal a quote from Alan:</p>

<p><i>&#34;Computer architecture is awash with concepts that are fundamental to computer science generally and which do not appear in other parts of the undergraduate curriculum. A course in computer architecture can provide a suitable forum for incorporating fundamental principles in the CS curriculum.&#34; </i></p>

<p>Computer architectures for me was never really about hardware design (although its the bit i enjoy the most), its about understanding the complete system, software and hardware. How the software we write is translated into results we can use. I&#39;m a great believer in that you don&#39;t truly understand something until you can build it yourself and use it to solve a real world problem. To often i find students that are taught computer science at A-level know the words, but have not had the opportunity of apply this knowledge, therefore, have not had the chance to make those all important final steps to upstanding what the words really mean. Therefore, i designed the SimpleCPU architecture. Over a series of labs students design and implement this architecture using Xilinx&#39;s ISE schematic tools, so that you see the wires, not HDL :), configure FPGA boards and program these systems using assembler and macros to solve image processing problems e.g. find Bob the Bug, shown below.</p>

<p><a href="http://simplecpudesign.com/Images/bob.jpg"><img src="http://simplecpudesign.com/Images/bob_tmb.jpg"/></a></p>

<p>Figure 2 : Bob</p>

<p>To me this is how computer architectures should be taught, a journey from being to end, no hidden details, just simple fundamental computer science, that hopefully everyone can understand. To conclude, i&#39;m not saying that every student has to be able to understand Intels latest and greatest beasts (architectures) to use them, but if you don&#39;t have a basic understanding of how data is represented, or how instructions are processed, very strange things can happen when you try to run your code. At best it may just take a little longer to execute, at worst it can take down the whole machine.</p>

<h2>Number representations</h2>

<ul>
	<li><a href="http://simplecpudesign.com/difference_engine/index.html">Difference Engine 0.5</a>: work in progress, my implementation of Babbage&#39;s Difference engine.</li>
	<li><a href="http://simplecpudesign.com/difference_engine_9000/index.html">Difference Engine 9000</a>: your next generation Babbage Difference engine.</li>
</ul>

<h2>Boolean Logic</h2>

<ul>
	<li><a href="http://simplecpudesign.com/relay_computer/index.html">Relay Computer</a>: switch logic, logic gates from relays</li>
	<li><a href="http://simplecpudesign.com/bug_trap_v1/index.html">Bug Trap version 1</a>: logic tutor, basic logic gates and flip-flops</li>
	<li><a href="http://simplecpudesign.com/bug_trap_v2/index.html">Bug Trap version 2</a>: new, improved and optimised ...</li>
	<li><a href="http://simplecpudesign.com/robot_cockroach/index.html">Robot cockroach</a>: designing a brain - a digital logic subsumption architecture</li>
	<li><a href="http://simplecpudesign.com/robot_cockroach_2/index.html">Robot cockroach version 2</a>: all new and improved, well i added micro-switches :)</li>
</ul>

<h2>A Simple CPU</h2>

<p>Below are a series of blog type discussions on the development of the SimpleCPU processor, their aim is to give an insight into the design decisions made when implementing these machines. To often when discussing computer architectures we use adjectives such as complex, simple e.g. CISC (<a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer">Link</a>) and RISC (<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">Link</a>). I&#39;ve grownup with this machine evolution, programmed them and designed a few, so i can place these words into a software and hardware context. For people new to this topic these are just words. What is simple? What is complex? How do you measure/compare these design philosophies? To me this disconnect is a problem. Therefore, being an engineer the only valid solution to teach people these ideas is: build it. In the past building your own processor was a little on the tricky side, but with the advent of programmable logic devices it now a possibility. I hope the source files and discussions below will be the starting point for people wanting to design their own processors and machine languages. These are not intended to be a complete set of notes on computer architectures, rather an introduction to this topic through the implementation of this processor in either SPLD or FPGA devices. A starting point, a foot on the road to CPU design, hopefully highlighting questions about computer architectures people have not considered before. Have fun and don&#39;t under estimate he power of the flashing LED, there is nothing more satisfying than convincing a processor to do what you tell it to :).</p>

<ul>
	<li><a href="http://simplecpudesign.com/minimal_cpu/index.html">MinimalCPU</a>: for when a SimpleCPU is just tooooooooo complex :)</li>
	<li><a href="http://simplecpudesign.com/xilinx_ise/index.html">Xilinx ISE</a>: the software used to design, implement, simulate and test the simpleCPU.</li>	
	<li><a href="http://simplecpudesign.com/simple_cpu_simulators/index.html">SimpleCPU Simulators</a>: a set of simple instruction-set simulators for the SimpleCPUs.</li> 
	<li><a href="http://simplecpudesign.com/simple_cpu_v1/index.html">SimpleCPU version 1</a>: trust me CPUs are simple: a simple 8bit RISCy CPU</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1abc/index.html">SimpleCPU versions 1a/b/c</a>: new, improved and optimised ...</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a/index.html">SimpleCPU version 1a - back to basics</a>: implementing a simulator in CPUSim</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_bread_board/index.html">SimpleCPU version 1a - bread boarded</a>: simpleCPU v1a implemented on bread board</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_assembler/index.html">SimpleCPU version 1a - python assembler</a>: you can only write so much machine code before you write an assembler :)</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_fpga/index.html">SimpleCPU version 1a - fpga</a>: simpleCPU v1a implemented on FPGA (redrawn)</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_logisim/index.html">SimpleCPU version 1a - Logisim</a>: simpleCPU v1a implemented in Logisim, the free digital electronics simulator.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_hello/index.html">SimpleCPU version 1a - serial IO</a> : an updated hello-world bit-banged serial IO example.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_TTL/index.html">SimpleCPU version 1a - TTL</a>: simpleCPU v1a implemented in TTL.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a_datasheet/index.html">SimpleCPU version 1a - datasheet</a>: a quick reference guide of its architecture and instruction set.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1a1_fpga/index.html">SimpleCPU version 1a1 - fpga</a>: simpleCPU v1a1 how to add new instructions.</li>	
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_fpga/index.html">SimpleCPU version 1d - fpga</a>: an improved simpleCPU, more memory, more instructions, more addressing modes.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_image/index.html">SimpleCPU version 1d - images</a>: what do you need from your HW / SW to process an image?</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_pong/index.html">SimpleCPU version 1d - pong</a>: the beginning, turning the SimpleCPU into a games console.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_snake/index.html">SimpleCPU version 1d - snake</a>: a PS2 keyboard interface upgrade and a snake game.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_datasheet/index.html">SimpleCPU version 1d - datasheet</a>: a quick reference guide of its architecture and instruction set.</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_irq/index.html">SimpleCPU version 1d1 - interrupts</a>: improving functionality, adding interrupt support</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_clock/index.html">SimpleCPU version 1d1 - clock</a>: how to implement an interrupt driven clock</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_space_invaders/index.html">SimpleCPU version 1d - space invaders</a>: finally, getting closer to building a games console :)</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1d_game_of_life/index.html">SimpleCPU version 1d - game of life</a>: the classic zero player game</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1e_fpga/index.html">SimpleCPU version 1e - fpga</a>: what changes do we need to make to support a data stack?</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v1e_datasheet/index.html">SimpleCPU version 1e - datasheet</a>: a quick reference guide of its architecture and instruction set.</li>
	<li><a href="http://simplecpudesign.com/game_controller/index.html">Game Controllers</a>: to play a game you need a game controller.</li>
	<li><a href="http://simplecpudesign.com/games_console/index.html">Video Game Console</a>: version 1 of the simpleCPU games console.</li>	
	<li><a href="http://simplecpudesign.com/simple_cpu_v2/index.html">SimpleCPU version 2</a>: trust me again CPUs are simple: a simple 8bit CISCy CPU</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v3/index.html">SimpleCPU version 3</a>: a simple CPU optimised for simple image processing, what could be simpler :)</li>
	<li><a href="http://simplecpudesign.com/simple_cpu_v4/index.html">SimpleCPU version 4</a>: a pipelined version of the SimpleCPU.</li>	
</ul>

<h2>Computer Architecture Teaching Material</h2>

<p>A mix of material from the past and present. Current computer architecture modules are titled: Systems and Devices 1 (SYS1). However, in the past we did a LOT more hardware teaching : electronics, analogue and digtial design, micro-controllers etc. These modules are no longer taught e.g. ICAR, DACS, FESC and PROM, but, i have include some of these past practicals as examples.  </p>
<ul>
	<li>Systems and Devices 1 (SYS1), a lecture series from AND gate to VHDL, discussing the evolution of the simpleCPU processor from version 1a to version 1d : <a href="http://simplecpudesign.com/simple_cpu_lectures/index.html">Link</a>.</li></ul>

<h2>Networking</h2>

<p>In addition to teaching an introductory module on basic computer architectures i now also teach an introductory module on basic networking, starting to forgot what my specialism is :). As always the only way to understand anything is to build it, get hand on experience of &#34;real&#34; networks, well as real as i can make them given security considerations. This module is designed around a collection of different Raspberry Pi based systems, giving students the opportunity to get hands on experience of designing and building actual networks, and the real world joys that come with networking :). Confess, when i think about networking i&#39;m always reminded of an old  nursery rhyme, to paraphrase: when it is good, its very, very good, but when it is bad it is horrid. Tracking down network faults are an adventure into the world of &#34;but it should work&#34;, a multidimensional puzzle, but very rewarding when the pieces fall into place and it just works. Below are a series of blog type discussions on the development of this hardware, as with the SimpleCPU their aim is give an insight into the design decisions made when implementing these machines. Supporting these web pages are a series of related videos on my Youtube channel, links below.</p>

<ul>
	<li>Systems and Devices 2 (SYS2), a lecture series discussing the joys of networking : <a href="http://simplecpudesign.com/networking_lectures/index.html">Link</a>.</li></ul>
	
<h2>Announcements</h2>

<p>
<b>UPDATE: 04/01/2025</b> PS2 keyboard interface, snake game and games console updates. </p>

<p>Contact email: mike@simplecpudesign.com</p>


</div>
  </body>
</html>
