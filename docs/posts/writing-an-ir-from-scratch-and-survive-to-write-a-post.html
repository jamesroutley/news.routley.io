<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://farena.in/compilers/programming/writing-an-ir-from-scratch/">Original</a>
    <h1>Writing an IR from Scratch and survive to write a post</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          


        </header>
      

      <section itemprop="text">
        
          
        
        <p>In this post, I will talk about the first version of the Intermediate Representation I designed for <em>Kunai Static Analyzer</em>, this is a dalvik analysis library that I wrote as a project for my PhD, also as a way of learning about the Dalvik file format and improving my programming skills.</p>



<p>Writer:</p>

<ul>
  <li>Eduardo Blazquez</li>
</ul>

<p>Technical and English reviewer:</p>

<ul>
  <li><a href="https://twitter.com/yates82">Robert Yates</a></li>
</ul>

<h2 id="kunai-static-analyzer">Kunai Static Analyzer</h2>

<p>Kunai was a static analysis library for dalvik bytecode. This library was published on Github, and it also was a paper published in the journal <em>SoftwareX</em> describing the projects and its benefits against another tool of the state of the art.</p>

<p>You can find the source code here: https://github.com/Fare9/KUNAI-static-analyzer</p>

<p>And the paper here: https://www.sciencedirect.com/science/article/pii/S2352711023000663</p>

<p>Although the project is discontinued (a new version is being written here <a href="https://github.com/Fare9/Shuriken-Analyzer/">Shuriken</a>), I thought it would be interesting to write about my experience of how I wrote the first version of its Intermediate Representation (from now on IR), how I implemented the different algorithms, and how I transformed Dalvik bytecode into this IR.</p>

<p>As I said, this IR is the first version I wrote for Kunai, after that I decided to move my implementation to <a href="https://mlir.llvm.org/">MLIR</a>, an approach for writing specific IRs using a reusable and extensible compiler infrastructure. You can find my presentation of this new IR that I implemented, at <a href="https://www.youtube.com/watch?v=hfqOivYdD40">EuroLLVM2023</a>.</p>

<p>As I said, in this post I will dig into the process of creating an IR for supporting analysis of Dalvik Bytecode, the algorithms I followed and implemented, and finally the process for lifting the dalvik bytecode into this IR.</p>

<p>Please, grab a drink, play your favorite music (I recommend the following one if you want to chill: <a href="https://www.youtube.com/watch?v=Lk3LesfKg2c">Dreamcatcher chill</a>, or the next one if you prefer something with more rhythm: <a href="https://www.youtube.com/watch?v=a4KPtXOYlME">Dreamcatcher no ballad</a>).</p>

<h2 id="references">References</h2>

<p>For the design and development of the IR I read chapters from different books, and I studied the code from different projects. Here you can find those books and projects:</p>

<h3 id="books">Books</h3>

<ul>
  <li>Advanced Compiler Design &amp; Implementation</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/acdi.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/acdi.jpg"/>
    </a>
</figure>

<ul>
  <li>An Introduction to the Theory of Optimizing Compilers</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/aitoc.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/aitoc.jpg"/>
    </a>
</figure>

<ul>
  <li>Compilers Principle, Techniques &amp; Tools</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/dragon-2007.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/dragon-2007.jpg"/>
    </a>
</figure>

<ul>
  <li>Introduction to Compilers and Language Design</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/icld.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/icld.jpg"/>
    </a>
</figure>

<ul>
  <li>SSA-based Compiler Design</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/ssa-based_compiler_design.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/ssa-based_compiler_design.jpg"/>
    </a>
</figure>

<h3 id="projects">Projects</h3>

<ul>
  <li><a href="https://github.com/llvm/llvm-project">LLVM</a></li>
  <li><a href="https://github.com/JonathanSalwan/Triton">Triton</a></li>
  <li><a href="https://github.com/cea-sec/miasm">Miasm</a></li>
  <li><a href="https://github.com/plum-umd/redexer">Redexer</a></li>
  <li><a href="https://github.com/soot-oss/soot">Soot</a></li>
  <li><a href="https://www.abartel.net/dexpler/">Dexpler</a></li>
  <li><a href="https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/pcoderef.html">P-Code (An IR used in Ghidra)</a></li>
  <li><a href="https://docs.binary.ninja/dev/bnil-overview.html">Binary Ninja IL</a></li>
  <li><a href="https://binary.ninja/presentations/Modern%20Binary%20Analysis%20with%20ILs%20with%20notes.pdf">Modern Binary Analysis with ILs</a></li>
  <li><a href="https://docs.angr.io/en/latest/advanced-topics/ir.html">Angr VEX IR</a></li>
  <li><a href="https://book.rada.re/disassembling/esil.html">Radare2 ESIL</a></li>
</ul>

<h2 id="mjolnir---kunais-ir">MjolnIR - Kunai’s IR</h2>

<p>My idea behind writing an IR for Kunai came from all the work I did during my PhD using Androguard. Many times using Androguard, I had to rely on the output of its disassembler and manually check the opcodes or even the mnemonic from the operation. While this process was easy for small analyses, it became hard for other projects. For example, I remember helping my friend Julien with one of his papers, at that moment we wanted to write a static taint analysis tool for Dalvik, and one of the ideas we had was to include a simple IR that would help us to recognize instructions in Androguard. It was at that moment when I saw the disadvantages of using Androguard, there was not a representation that could help us with the analysis (some time after that I discovered an Abstract Syntax Tree representation, but it is mostly used for the decompiler). After that, once I was writing Kunai, I thought that Kunai would benefit from an IR that would help analysts to write analyses with Kunai.</p>

<p>First of all, the most challenging decision choice was “what’s a cool name I can give it?”. Of course, a cool project needs a cool name. And because the project already had the name <em>Kunai</em> (a japanese farming tool popular for being the most used weapon in the manga/anime Naruto), the name of a weapon would be really cool as a name, and at that moment I remembered the following:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/mjolnir-thor.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/mjolnir-thor.jpg"/>
    </a>
</figure>

<p><strong>Mjölnir</strong>, the weapon of <strong>Thor</strong>, god of thunder in Norse Mythology. I had a cool name, and if I wrote it like <em>MjolnIR</em>, I could say that the last two characters come from <em>Intermediate Representation</em>.</p>

<p>Although the idea was good, my knowledge of the IRs was limited, and mostly based on using tools like <a href="https://github.com/JonathanSalwan/Triton">Triton</a> that gave me access to <a href="https://github.com/llvm/llvm-project">LLVM-IR</a> code, or analyzing binaries using <a href="https://ghidra-sre.org/">Ghidra</a> and observing the generated P-code. Of course, I also remembered the little knowledge I gained in the Compiler’s class during the undergraduate bachelor in Computer Engineering. But I was willing to write the IR, and I had enough bibliography to start reading, as well as different projects to start learning from their code.</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/speed-reading.gif">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/speed-reading.gif"/>
    </a>
</figure>

<h3 id="mjolnir---structure-of-an-ir">MjolnIR - Structure of an IR</h3>

<p>Each Intermediate Representation or Intermediate Language can have its own shape, and own design. We can have that it is text-based or binary-based, or even a mix of both (for allowing modifications directly with a text-editor but fast processing with tools). We can have the next like Intermediate Representations (from the book Introduction to Compilers and Language Design) :</p>

<ul>
  <li>Abstract Syntax Tree (AST): although this representation is commonly used by the compiler’s front-end, it can be also used as an IR. Small simplifications are allowed in this representation. We can find that Triton uses a tree to represent the different expressions executed by its symbolic execution engine, and it is used for different translations like: expression tree to Z3 for expressions solving, or expression tree to LLVM IR. Being honest, in my first design I included some structures in the IR to allow a tree design, but I wasn’t completely sure about it, so I removed it from the design.</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/ast.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/ast.png"/>
    </a>
    <figcaption>An Abstract Syntax Tree for a source code</figcaption>
</figure>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/triton_expression_tree.svg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/triton_expression_tree.svg"/>
    </a>
    <figcaption>A tree used by Triton to represent an expression</figcaption>
</figure>

<ul>
  <li>Directed Acyclic Graph (DAG): this is one step simplified from the AST, in a compiler this DAG can provide us with the type and value of each node, but in binary analysis, this information should be recovered. Probably it could be more useful for a compiler than for a binary analysis tool, since the information that would be needed to be recovered for using it would require a big effort.</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/dag.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/dag.jpg"/>
    </a>
    <figcaption>A simple dag</figcaption>
</figure>

<ul>
  <li>Control-Flow Graph (CFG): this is a commonly used representation in binary analysis. A CFG is a graph in which blocks and edges represent the code and the control-flow of a function, in source code we can have that each block represents one statement from the source code, but in binary analysis commonly a block is a list of instructions (assembly or another intermediate language) with one entry point, and one exit point (a termination instruction, or an instruction to transfer the control of execution)</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/cfg-code.svg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/cfg-code.svg"/>
    </a>
    <figcaption>A Control-Flow Graph from a source code</figcaption>
</figure>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/cfg-binary.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/cfg-binary.png"/>
    </a>
    <figcaption>A Control-Flow Graph from a binary</figcaption>
</figure>

<ul>
  <li>Static-Single Assignment (SSA): this representation form represents an intermediate language with one restriction, the variables can be assigned only once, so their value cannot change. In case we want to give a new value to a previously defined variable, we create a new variable but with another subindex. This makes algorithms like <em>def-use</em> trivial (we’ll see later in a part dedicated to the implemented algorithms). In some cases, we will need a special instruction called <em>phi</em> to create a new value that will hold a value depending on where the control-flow came from.</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/SSA_example.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/SSA_example.png"/>
    </a>
    <figcaption>An Example of SSA IR</figcaption>
</figure>

<ul>
  <li>Linear IR: an intermediate representation that represents the instructions one after another as a sequence, which is similar to the assembly language. We have instructions to transfer values between memory and multiple registers etc. An example could be Dalvik’s bytecode, which is based on registers, and it is a kind of linear IR.</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/dalvik-bytecode.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/dalvik-bytecode.png"/>
    </a>
    <figcaption>An Example of Dalvik Bytecode</figcaption>
</figure>

<ul>
  <li>Stack-Machine IR: In this case, we have a stack that is used to “store” values from the program, this kind of IR is designed to execute on a virtual stack machine. A good example of this one would be the bytecode of Java, which is stack-based.</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/java-bytecode.webp">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/java-bytecode.webp"/>
    </a>
    <figcaption>An example of Java bytecode</figcaption>
</figure>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/stack-vs-register.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/stack-vs-register.png"/>
    </a>
    <figcaption>A comparison between a stack and register bytecode</figcaption>
</figure>

<p>In general, my observation from the different books and projects is that an IR has a container for storing functions/methods from the programs. As I said, many of the IRs I have used so far use a <em>Control-Flow Graph</em> representation, so inside this container we have a block structure, and inside of the blocks a list of instructions.</p>

<p>The blocks in the CFG will have a single point of entry, and a single point of exit. The point of exit can be an instruction that represents a jump, a conditional jump or a switch statement. We can also find some instructions that have only a fallthrough (another instruction that doesn’t jump). Or in another case, we can find an exit block that ends with a return or throwing an exception.</p>

<p>Finally, we have the instructions inside the blocks. These instructions can represent a subset of real assembly instructions, and they can be used to represent all the semantics from a real machine. Of course, the complexity of these IR instructions will depend on the machines we want to represent. Mostly, we should have the following category of instructions:</p>

<ul>
  <li>Control-Flow instructions: instructions representing jumps, returns, switch, etc.</li>
  <li>Data-Flow instructions: instructions to access memory for reading or writing to memory.</li>
  <li>Operations: it wouldn’t be useful having access to memory data if we cannot work with that data, so here we have this category. The category would include binary operations, unary operations, comparisons, and assignments.</li>
  <li>Values: we need some type of data to work with. Memory can have different representations, for example, a map of addresses. We can have registers, these registers can represent those from the machine, or we could have virtual registers. In an SSA representation, we have an infinite number of registers, and each register can be assigned a value only once. Register and memory can have an associated type, or at least an associated size.</li>
</ul>

<p>In the next section, we will cover all these different instructions from the point of view of MjolnIR, and what are the instructions that I decided to implement with a schematic view of the instructions. Later I will present the implementation in C++ code of the types and some of the design decisions.</p>

<h3 id="mjolnir---structure-of-mjolnir">MjolnIR - Structure of MjolnIR</h3>

<p>Although I had many examples, deciding how to create one IR is not something very straightforward or easy, so my best resource in this case was reading about <a href="https://docs.binary.ninja/dev/bnil-overview.html">Binary Ninja ILs</a>, and also the book <em>Advanced Compiler Design &amp; Implementation</em>, in both resources they talk about three-levels of representation, from a more low level syntax like assembly to higher level closer to source code (llil-mlil-hlil), and I thought that the <em>Medium Level IL</em> was a good design for what I wanted to do.</p>

<p>First of all, I thought I would need to represent a Method from Dalvik, and the best way to represent a method was using a control-flow graph, and this control-flow graph would have blocks.</p>

<p>Secondly, the blocks would have instructions, but we have different types of instructions, so let’s call all of them <em>statements</em>, and here we have condition-flow instructions, a nop instruction, and return instructions. But a fundamental one was the <em>expressions</em>, these expressions are the instructions that perform operations, we have assignments, we have arithmetic-logic instructions, comparisons, call to instructions, and memory usage. These expressions are applied over registers which have a type, so we also have types representing different things like registers, memory, constant ints, called methods, classes and even temporal registers.</p>

<p>I joined all of these, and I ended up having a type of tree structure, I represented that structure using a (probably not really well) Backus-Naur form (<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>). In the next section, I will show the BNFs that represent all the statements from the IR, I will also talk about the different instructions that are part of that BNF and what I represent with them.</p>

<h4 id="backus-naur-forms">Backus-Naur forms</h4>

<h5 id="irstmnt"><strong>IRStmnt</strong></h5>

<p>At the top of the IR we have the statements, these will be every instruction from the IR that could be executed by the program, between these IRStmnt are the expressions (explained later), but more specific statements are those that change the Control-Flow Graph from the function/method, these are conditional and unconditional jumps, return statements, etc.</p>

<div><div><pre><code>IRStmnt     --&gt;     IRUJmp   |
                    IRCJmp   |
                    IRRet    |
                    IRBlock  |
                    IRNop    |
                    IRSwitch |
                    IRExpr 

IRUJmp      --&gt;     jmp addr
IRCJmp      --&gt;     if (IRStmnt) { jmp addr } NEXT fallthrough_addr
IRRet       --&gt;     Ret IRStmnt
IRBlock     --&gt;     IRStmnt1, IRStmnt2, ..., IRStmntN
IRSwitch    --&gt;     switch (IRStmnt) { case X1 -&gt; addr, case X2 -&gt; addr, case XN -&gt; addr }
</code></pre></div></div>

<p>All the instructions that are in a block are statements. Even the Blocks are statements. As I previously said, an IR needs Control-Flow instructions, these kinds of instructions would be:</p>

<ul>
  <li>Unconditional jumps that specify the address where they jump.</li>
  <li>Conditional jumps that takes a comparison a statement and the address where to jump to in the case where the condition is met.</li>
  <li>Return instruction that can specify a returned value.</li>
  <li>Blocks, in my design blocks are statements too, and they contain a list of instructions.</li>
  <li>Switch, like conditional jumps but these take an expression for the value to check and lookup various cases of addresses where to jump to.</li>
  <li>Expressions, expressions are a special type of statements that will be subdivided into other instructions, we will see it in the next section.</li>
</ul>

<h5 id="irexpr"><strong>IRExpr</strong></h5>

<p>The IR requires to support various instructions from the code, these are what we call IRExpr, these kinds of instructions don’t modify the control flow of the method but apply different kinds of operations to the variables/registers/memory in the program. They can affect the call-graph of a program, since one of the expressions allows calling other methods.</p>

<div><div><pre><code>IRExpr    --&gt;   IRBinOp   |
                IRUnaryOp | 
                IRAssign  |
                IRPhi     |
                IRCall    |
                IRLoad    |
                IRStore   |
                IRZComp   |
                IRBComp   |
                IRNew     |
                IRAlloca  |
                IRType    
                
IRBinOp   --&gt;   IRExpr &lt;- IRExpr bin_op_t IRExpr
IRUnaryOp --&gt;   IRExpr &lt;- unary_op_t IRExpr
IRAssign  --&gt;   IRExpr &lt;- IRExpr
IRPhi     --&gt;   IRExpr &lt;- IRExpr, IRExpr, ..., IRExpr
IRCall    --&gt;   IRExpr(IRExpr1, IRExpr2, ..., IRExprN)
IRLoad    --&gt;   IRExpr &lt;- *IRExpr
IRStore   --&gt;   *IRExpr &lt;- IRExpr
IRZComp   --&gt;   IRExpr zero_comp_t
IRBComp   --&gt;   IRExpr comp_t IRExpr
IRNew     --&gt;   IRExpr &lt;- new IRExpr
IRAlloca  --&gt;   IRExpr &lt;- new IRExpr[IRExpr]

# kind of operations
bin_op_t  --&gt;   ADD_OP_T   |
                SUB_OP_T   |
                S_MUL_OP_T |
                U_MUL_OP_T |
                S_DIV_OP_T |
                U_DIV_OP_T |
                MOD_OP_T
unary_op_t   --&gt;   INC_OP_T    |
                   DEC_OP_T    |
                   NOT_OP_T    |
                   NEG_OP_T    |
                   CAST_OP_T   |
                   Z_EXT_OP_T  |
                   S_EXT_OP_T
zero_comp_t  --&gt;   EQUAL_ZERO_T |
                   NOT_EQUAL_ZERO_T
comp_t       --&gt;   EQUAL_T              |
                   NOT_EQUAL_T          |
                   GREATER_T            |
                   GREATER_EQUAL_T      |
                   LOWER_T              |
                   ABOVE_T              |
                   ABOVE_EQUAL_T        |
                   BELOW_T
</code></pre></div></div>

<p>Here we have the second type of instructions, we have operations that work with data, loading and storing data in memory, assigning values to registers, doing comparisons and memory allocations, etc.</p>

<ul>
  <li>Binary operations: those expressions that have two operands and store the result in a register/temporal register. We have different binary operations: add operation, sub operation, signed and unsigned multiplication and division, and finally mod operation.</li>
  <li>Unary operations: expressions that only use one operand, the result is stored in a register/temporal register. We have different unary operations: increment, decrement, not, neg, casting to a different type, zero extension and sign extension.</li>
  <li>Assignment operation: assign a value from one register/temporal register to another.</li>
  <li>PHI instruction: this instruction is used in IRs to represent the same value coming from different blocks. The Phi instruction has as many operands as predecessor blocks. Conceptually, Phi returns a value depending on which block is executed before the phi instruction.</li>
</ul>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/phi-instruction.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/phi-instruction.png"/>
    </a>
    <figcaption>Example of a PHI instruction.</figcaption>
</figure>

<ul>
  <li>Call instruction: this instruction has a Callee that is called, it gets a variable number of operands, and it optionally returns a value.</li>
  <li>Load and Store operations: used to load and store values from memory. In the case of Android, here we would have access to the class fields.</li>
  <li>Zero comparison operation: a comparison with a zero value, to know if the provided expression is equals or not equal to zero. The value returned by the operation is commonly used in a conditional jump.</li>
  <li>Binary comparison operation: this operation receives two expressions and a type of comparison, the available comparisons are equal, not equal, greater, greater-equal, lower, above, above-equal and below (for signed and unsigned comparisons). The value returned by the operation is commonly used in a conditional jump.</li>
  <li>New operation: used to initialize a new object.</li>
  <li>Alloca operation: used to initialize arrays with a specific size.</li>
  <li>Type: this is an especial expression that represents the different types available for the IR.</li>
</ul>

<h5 id="irtype"><strong>IRType</strong></h5>

<p>For supporting the types we find in the binary code, we have written a series of classes which derive from a superclass named IRType, as derived classes we have: registers, constant values, strings, memory, callee types.</p>

<div><div><pre><code>IRType   --&gt;   IRReg |
               IRTempReg |
               IRConstInt |
               IRMemory |
               IRString |
               IRCallee |
               IRField  |
               IRClass  |
               IRFundamental |
               NONE

IRFundamental   --&gt; F_BOOLEAN   |
                    F_BYTE      |
                    F_CHAR      |
                    F_DOUBLE    |
                    F_FLOAT     |
                    F_INT       |
                    F_LONG      |
                    F_SHORT     |
                    F_VOID
</code></pre></div></div>

<p>Finally, we have values that are used in the expressions and also in the statements. Some IRs call some of these <code>Values</code>, others have <code>registers</code>, etc. In case of MjolnIR, I included registers that represent the registers from Dalvik, and also temporal registers that are used as results for some of the expression operations. Now we will list all of them with a description:</p>

<ul>
  <li>Registers: used to represent the registers from Dalvik.</li>
  <li>Temporal registers: used as an intermediate storage for operations in the expressions.</li>
  <li>Constant Integers: integer values used, for example, in binary operations or comparisons.</li>
  <li>Memory: addresses of memory, including an accessed offset.</li>
  <li>String: a constant string value.</li>
  <li>Callee: a method called by the call instruction from the expressions.</li>
  <li>Field: a field from a Java-like language, the field contains information like the class it belongs, the name of the field, the type, etc.</li>
  <li>Class: a Java-like language class, with the name of the class.</li>
  <li>Fundamental: it represents the fundamental values available in a Java-like language.</li>
</ul>

<h5 id="summary-of-the-ir-instructions">Summary of the IR instructions</h5>

<p>Next I show a summary of the IR:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/Mjolnir.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/Mjolnir.png"/>
    </a>
    <figcaption>Structure of MjolnIR.</figcaption>
</figure>

<p>In this image, I include all the statements from the IR, together with that in the bottom of the image we have what will be later explained, the lifter from Dalvik to MjolnIR. The lifter generate <code>IRGraphs</code> that contains <code>IRBlocks</code> which contain a list of <code>IRStmnt</code>s. Finally, from an <code>IRGraph</code>, an SSA form can be obtained, I will explain the algorithm used later. As part of the original idea, an optimizer was going to be written.</p>

<h4 id="implementation">Implementation</h4>

<p>The idea behind this post is not only providing a theoretical view like you can see in a compiler’s book, but also to provide a real life implementation of such an IR, and an explanation of it’s implementation. After explaining each one of the instructions, I will explain the different algorithms used for manipulating the CFG.</p>

<p>One clarification before starting, from now on I will use the following notation, I write the name of the classes using uppercase for the first character of the name, and in case of the IR all the classes start with <code>IR</code> followed by the name of the component that it represents (for example <code>IRStmnt</code>). Most of these classes have their version as a smart pointer, the name of the smart pointer type is the same as its class but in lowercase and followed by <code>_t</code> (for example <code>IRBlock</code> -&gt; <code>irblock_t</code>). For the name of the variables and the name of the functions, I use snake case.</p>

<h5 id="irgraph-implementation"><em>IRGraph</em> Implementation</h5>

<p>Although previously I wrote the BNF from <code>IRGraph</code>, here I will explain the implementation from the class.</p>

<p>First of all, for the graph we will change the notation and instead of having blocks or a pair of blocks, we will have nodes and edges. In <em>C++</em> we will do this with <code>using</code> to give another name to the data types:</p>

<div><div><pre><code><span>using</span> <span>Nodes</span> <span>=</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span><span>;</span>
<span>using</span> <span>Edge</span>  <span>=</span> <span>std</span><span>::</span><span>pair</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span><span>;</span>
<span>using</span> <span>Edges</span> <span>=</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>Edge</span><span>&gt;</span><span>;</span>
<span>using</span> <span>Paths</span> <span>=</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irblock_t</span><span>&gt;&gt;</span><span>;</span>
</code></pre></div></div>

<p>Here we can see that the nodes are a vector of blocks, and the edges are a pair of blocks, and edges just a vector of edge. Finally, for some algorithms we will use Paths, which are a list of blocks.</p>

<p>Now we can move to see the implementation of a graph. I will not paste the implementation of the functions as I will explain some implementations later in depth, and also the whole code will be included in a repository with all the code.</p>

<div><div><pre><code><span>class</span> <span>IRGraph</span> <span>{</span>
    <span>IRGraph</span><span>();</span>
    <span>~</span><span>IRGraph</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>bool</span> <span>add_node</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>void</span> <span>add_edge</span><span>(</span><span>irblock_t</span> <span>src</span><span>,</span> <span>irblock_t</span> <span>dst</span><span>);</span>
    <span>void</span> <span>add_uniq_edge</span><span>(</span><span>irblock_t</span> <span>src</span><span>,</span> <span>irblock_t</span> <span>dst</span><span>);</span>
    <span>void</span> <span>add_block_to_sucessors</span><span>(</span><span>irblock_t</span> <span>node</span><span>,</span> <span>irblock_t</span> <span>successor</span><span>);</span>
    <span>void</span> <span>add_block_to_predecessors</span><span>(</span><span>irblock_t</span> <span>node</span><span>,</span> <span>irblock_t</span> <span>predecessor</span><span>);</span>
    <span>Nodes</span><span>&amp;</span> <span>get_nodes</span><span>();</span>
    <span>Edges</span><span>&amp;</span> <span>get_edges</span><span>();</span>
    <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>get_node_by_start_idx</span><span>(</span><span>std</span><span>::</span><span>uint64_t</span> <span>idx</span><span>);</span>
    <span>void</span> <span>merge_graph</span><span>(</span><span>irgraph_t</span> <span>graph</span><span>);</span>
    <span>void</span> <span>del_edge</span><span>(</span><span>irblock_t</span> <span>src</span><span>,</span> <span>irblock_t</span> <span>dst</span><span>);</span>
    <span>void</span> <span>del_node</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>void</span> <span>delete_block_from_sucessors</span><span>(</span><span>irblock_t</span> <span>node</span><span>,</span> <span>irblock_t</span> <span>block</span><span>);</span>
    <span>void</span> <span>delete_block_from_precessors</span><span>(</span><span>irblock_t</span> <span>node</span><span>,</span> <span>irblock_t</span> <span>block</span><span>);</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>get_leaves</span><span>();</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>get_heads</span><span>();</span>
    <span>Paths</span> <span>find_path</span><span>(</span><span>irblock_t</span> <span>src</span><span>,</span>
                    <span>irblock_t</span> <span>dst</span><span>,</span>
                    <span>size_t</span> <span>cycles_count</span><span>,</span>
                    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>size_t</span><span>&gt;</span> <span>done</span><span>);</span>
    <span>Paths</span> <span>find_path_from_src</span><span>(</span><span>irblock_t</span> <span>src</span><span>,</span>
                                <span>irblock_t</span> <span>dst</span><span>,</span>
                                <span>size_t</span> <span>cycles_count</span><span>,</span>
                                <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>size_t</span><span>&gt;</span> <span>done</span><span>);</span>
    <span>Nodes</span> <span>reachable_sons</span><span>(</span><span>irblock_t</span> <span>head</span><span>);</span>
    <span>Nodes</span> <span>reachable_parents</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>);</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>compute_dominators</span><span>(</span><span>irblock_t</span> <span>head</span><span>);</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>compute_postdominators</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>);</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>compute_immediate_dominators</span><span>();</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>compute_immediate_postdominators</span><span>();</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>std</span><span>::</span><span>set</span><span>&lt;</span><span>irblock_t</span><span>&gt;&gt;</span> <span>compute_dominance_frontier</span><span>();</span>
    <span>irgraph_t</span> <span>copy</span><span>();</span>
    <span>// node information</span>
    <span>size_t</span> <span>get_number_of_successors</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>Nodes</span><span>&amp;</span> <span>get_successors</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>size_t</span> <span>get_number_of_predecessors</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>Nodes</span><span>&amp;</span> <span>get_predecessors</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>node_type_t</span> <span>get_type_of_node</span><span>(</span><span>irblock_t</span> <span>node</span><span>);</span>
    <span>// algorithms from Advanced Compiler Design and Implementation</span>
    <span>Nodes</span> <span>reachable_nodes_forward</span><span>(</span><span>irblock_t</span> <span>head</span><span>);</span>
    <span>Nodes</span> <span>reachable_nodes_backward</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>);</span>
    <span>Nodes</span> <span>build_ebb</span><span>(</span><span>irblock_t</span> <span>r</span><span>);</span>
    <span>Nodes</span> <span>Depth_First_Search</span><span>(</span><span>irblock_t</span> <span>head</span><span>);</span>
    <span>Nodes</span> <span>Breadth_First_Search</span><span>(</span><span>irblock_t</span> <span>head</span><span>);</span>
    <span>void</span> <span>generate_dot_file</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>name</span><span>);</span>
    <span>void</span> <span>generate_dominator_tree</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>name</span><span>);</span>
    <span>const</span> <span>std</span><span>::</span><span>uint64_t</span> <span>get_cyclomatic_complexity</span><span>();</span>
    <span>void</span> <span>set_last_temporal</span><span>(</span><span>std</span><span>::</span><span>uint64_t</span> <span>last_temporal</span><span>);</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>get_last_temporal</span><span>();</span>
    
    <span>private:</span>
    <span>Nodes</span> <span>nodes</span><span>;</span>
    <span>Edges</span> <span>edges</span><span>;</span>

    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>successors</span><span>;</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>predecessors</span><span>;</span>
    
    <span>std</span><span>::</span><span>uint64_t</span> <span>cyclomatic_complexity</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>last_temporal</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As we can see, the graph contains the nodes which are a list of blocks, and the edges which are pairs of nodes (blocks connected through the control-flow). For each node, we store a list of successors and predecessors. And finally, some auxiliary variables, like the cyclomatic complexity of that function, and a variable that stores the last assigned temporal register.</p>

<p>For the graph, we have common utilities for adding blocks, removing them, connecting those blocks through edges, etc. But also other utilities not so common like: <code>get_leaves</code> to get nodes without successors, <code>get_heads</code> to get nodes without predecessors, <code>find_path</code> to find a connection between two blocks in the graph searching backwards, <code>find_path_from_src</code> to find a connection between two blocks in the graph searching forward, <code>reachable_*</code> that is used to get sons or parents, and others that implement common algorithms in graphs. For the last algorithms, I will explain them in-depth discussing the implementation code and the algorithm used.</p>

<h5 id="irblock-implementation"><code>IRBlock</code> implementation</h5>

<p>Now we can see the code from the basic blocks:</p>

<div><div><pre><code><span>class</span> <span>IRBlock</span> <span>{</span>
    <span>IRBlock</span><span>();</span>
    <span>~</span><span>IRBlock</span><span>()</span> <span>=</span> <span>default</span><span>;</span>

    <span>void</span> <span>add_statement_at_beginning</span><span>(</span><span>irstmnt_t</span> <span>statement</span><span>);</span>
    <span>void</span> <span>append_statement_to_block</span><span>(</span><span>irstmnt_t</span> <span>statement</span><span>);</span>
    <span>bool</span> <span>delete_statement_by_position</span><span>(</span><span>size_t</span> <span>pos</span><span>);</span>
    <span>size_t</span> <span>get_number_of_statements</span><span>();</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;</span> <span>&amp;</span><span>get_statements</span><span>();</span>
    <span>void</span> <span>set_start_idx</span><span>(</span><span>uint64_t</span> <span>start_idx</span><span>);</span>
    <span>void</span> <span>set_end_idx</span><span>(</span><span>uint64_t</span> <span>end_idx</span><span>);</span>
    <span>uint64_t</span> <span>get_start_idx</span><span>();</span>
    <span>uint64_t</span> <span>get_end_idx</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_name</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>void</span> <span>set_phi_node</span><span>();</span>
    <span>void</span> <span>clear_phi_node</span><span>();</span>
    <span>bool</span> <span>contains_phi_node</span><span>()</span>
    
    <span>private:</span>
    <span>bool</span> <span>phi_node</span> <span>=</span> <span>false</span><span>;</span>
    <span>//! starting idx and last idx (used for jump calculation)</span>
    <span>uint64_t</span> <span>start_idx</span><span>,</span> <span>end_idx</span><span>;</span>
    <span>//! statements from the basic block.</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;</span> <span>block_statements</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The basic blocks do not contain much code, they just keep the first and the last index of their instructions, and information to know if a phi instruction exists in the block (for an explanation about the Phi instructions you can go to <code>BNF</code> section). Finally, the block contains a list of instructions belonging to that block. The included functions are just utilities for inserting instructions, deleting instructions, etc.</p>

<h5 id="irstmnt-implementation"><code>IRStmnt</code> implementation</h5>

<p>Now, we can see the implementation of the statements, as I previously said, the statements are the root of all the instructions (including the basic blocks). The statement class store also the enum with the type of the statements:</p>

<div><div><pre><code><span>enum</span> <span>stmnt_type_t</span>
<span>{</span>
    <span>UJMP_STMNT_T</span><span>,</span>
    <span>CJMP_STMNT_T</span><span>,</span>
    <span>RET_STMNT_T</span><span>,</span>
    <span>NOP_STMNT_T</span><span>,</span>
    <span>SWITCH_STMNT_T</span><span>,</span>
    <span>EXPR_STMNT_T</span><span>,</span>
    <span>NONE_STMNT_T</span> <span>=</span> <span>99</span> <span>// used to finish the chain of statements</span>
<span>};</span>
</code></pre></div></div>

<p>Also, we have an enum for all the operations, I included this enum as part of <code>IRStmnt</code> class too, so we can check which operation we are working with if we have an <code>IRStmnt</code>.</p>

<div><div><pre><code><span>enum</span> <span>op_type_t</span>
<span>{</span>
    <span>UJMP_OP_T</span><span>,</span>
    <span>CJMP_OP_T</span><span>,</span>
    <span>RET_OP_T</span><span>,</span>
    <span>NOP_OP_T</span><span>,</span>
    <span>SWITCH_OP_T</span><span>,</span>
    <span>EXPR_OP_T</span><span>,</span>
    <span>BINOP_OP_T</span><span>,</span>
    <span>UNARYOP_OP_T</span><span>,</span>
    <span>ASSIGN_OP_T</span><span>,</span>
    <span>PHI_OP_T</span><span>,</span>
    <span>CALL_OP_T</span><span>,</span>
    <span>OP_T_OP_T</span><span>,</span>
    <span>LOAD_OP_T</span><span>,</span>
    <span>STORE_OP_T</span><span>,</span>
    <span>ZCOMP_OP_T</span><span>,</span>
    <span>BCOMP_OP_T</span><span>,</span>
    <span>NEW_OP_T</span><span>,</span>
    <span>ALLOCA_OP_T</span><span>,</span>
    <span>TYPE_OP_T</span><span>,</span>
    <span>REGISTER_OP_T</span><span>,</span>
    <span>TEMP_REGISTER_OP_T</span><span>,</span>
    <span>CONST_INT_OP_T</span><span>,</span>
    <span>CONST_FLOAT_OP_T</span><span>,</span>
    <span>FIELD_OP_T</span><span>,</span>
    <span>MEM_OP_T</span><span>,</span>
    <span>STRING_OP_T</span><span>,</span>
    <span>CLASS_OP_T</span><span>,</span>
    <span>CALLEE_OP_T</span><span>,</span>
    <span>FUNDAMENTAL_OP_T</span><span>,</span>
    <span>NONE_OP_T</span> <span>=</span> <span>99</span> <span>// used to finish the chain of statements</span>
<span>};</span>
</code></pre></div></div>

<p>Having <code>IRStmnt</code> as the top of the classes allows to provide it as a value for many parameters, or for variables, then we can cast the pointers in order to work with different classes. Maybe using classes and inheritance is not the best way to generate the IR instructions, but it was the one I had in mind when I thought about providing statements as part of the other instructions.</p>

<p>Now we will see the <code>IRStmnt</code> class:</p>

<div><div><pre><code><span>class</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRStmnt</span><span>(</span><span>stmnt_type_t</span> <span>stmnt_type</span><span>,</span> <span>op_type_t</span> <span>op_type</span><span>);</span>
    <span>virtual</span> <span>~</span><span>IRStmnt</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>stmnt_type_t</span> <span>get_statement_type</span><span>();</span>
    <span>op_type_t</span> <span>get_op_type</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>const</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;</span> <span>&amp;</span><span>get_use_def_chain</span><span>()</span> <span>const</span><span>;</span>
    <span>const</span> <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>irexpr_t</span><span>,</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;&gt;</span> <span>&amp;</span><span>get_def_use_chains</span><span>()</span> <span>const</span><span>;</span>
    <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;</span> <span>*&gt;</span> <span>get_def_use_chain_by_value</span><span>(</span><span>irexpr_t</span> <span>value</span><span>);</span>
    <span>void</span> <span>add_instr_to_use_def_chain</span><span>(</span><span>irstmnt_t</span> <span>instr</span><span>);</span>
    <span>void</span> <span>add_instr_to_def_use_chain</span><span>(</span><span>irexpr_t</span> <span>var</span><span>,</span> <span>irstmnt_t</span> <span>instr</span><span>);</span>
    <span>void</span> <span>invalidate_chains</span><span>();</span>
    <span>void</span> <span>invalidate_use_def_chain</span><span>();</span>
    <span>void</span> <span>invalidate_def_use_chains</span><span>();</span>
    <span>void</span> <span>print_use_def_and_def_use_chain</span><span>();</span>

<span>private:</span>
    <span>//! Type of the statement.</span>
    <span>stmnt_type_t</span> <span>stmnt_type</span><span>;</span>
    <span>//! Op type</span>
    <span>op_type_t</span> <span>op_type</span><span>;</span>

    <span>//! Vectors used for use-def and def-use chains</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;</span> <span>use_def_chain</span><span>;</span>
    <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>irexpr_t</span><span>,</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;&gt;</span> <span>def_use_chains</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>This code represents the base of all the other instructions. As we can see, we have a couple of getters to know what kind the statement is, or what kind of operation it is. And then one of the most important parts. MjolnIR implemented both <code>def-use</code> and <code>use-def</code> chains, these are two lists that for each variable (register), it provides where the register is defined, and where it is used. Later I will provide a better description and the implementation of these algorithms. We have getters, setters and also functions to invalidate those chains.</p>

<h6 id="irujmp-implementation"><code>IRUJmp</code> implementation</h6>

<p>Let’s see the implementation of an unconditional jump:</p>

<div><div><pre><code><span>class</span> <span>IRUJmp</span> <span>:</span> <span>public</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRUJmp</span><span>(</span><span>uint64_t</span> <span>addr</span><span>,</span> <span>irblock_t</span> <span>target</span><span>);</span>
    <span>~</span><span>IRUJmp</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>void</span> <span>set_jump_target</span><span>(</span><span>irblock_t</span> <span>target</span><span>);</span>
    <span>irblock_t</span> <span>get_jump_target</span><span>();</span>
    <span>uint64_t</span> <span>get_jump_addr</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>

<span>private:</span>
    <span>//! offset or address of target</span>
    <span>uint64_t</span> <span>addr</span><span>;</span>
    <span>//! target where the jump will fall</span>
    <span>irblock_t</span> <span>target</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>The most important part of this instruction in the way I implemented it is the <code>target</code>. With this <code>target</code>, given a basic block, we can know where the block will jump.</p>

<h6 id="ircjmp-implementation"><code>IRCJmp</code> implementation</h6>

<p>Implementation of the conditional jump:</p>

<div><div><pre><code><span>class</span> <span>IRCJmp</span> <span>:</span> <span>public</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRCJmp</span><span>(</span><span>uint64_t</span> <span>addr</span><span>,</span> <span>irstmnt_t</span> <span>condition</span><span>,</span> <span>irblock_t</span> <span>target</span><span>,</span> <span>irblock_t</span> <span>fallthrough</span><span>);</span>
    <span>~</span><span>IRCJmp</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>uint64_t</span> <span>get_addr</span><span>();</span>
    <span>irstmnt_t</span> <span>get_condition</span><span>();</span>
    <span>void</span> <span>set_jump_target</span><span>(</span><span>irblock_t</span> <span>target</span><span>);</span>
    <span>irblock_t</span> <span>get_jump_target</span><span>();</span>
    <span>void</span> <span>set_fallthrough_Target</span><span>(</span><span>irblock_t</span> <span>fallthrough</span><span>);</span>
    <span>irblock_t</span> <span>get_fallthrough_target</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();;</span>
<span>private:</span>
    <span>//! offset or address of target</span>
    <span>uint64_t</span> <span>addr</span><span>;</span>
    <span>//! Condition for taking the target jump</span>
    <span>irstmnt_t</span> <span>condition</span><span>;</span>
    <span>//! target where the jump will fall</span>
    <span>irblock_t</span> <span>target</span><span>;</span>
    <span>//! fallthrough target.</span>
    <span>irblock_t</span> <span>fallthrough</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>The implementation is similar to <code>IRUJmp</code>, but in this case we need two targets, one taken if the condition matches, and another for the fallthrough target. The condition is provided as an <code>IRStmnt</code> so any expression or type can be given as a condition (probably in a better implementation, that condition should be restricted to a few types or expressions).</p>

<h6 id="irret-implementation"><code>IRRet</code> implementation</h6>

<div><div><pre><code><span>class</span> <span>IRRet</span> <span>:</span> <span>public</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRRet</span><span>(</span><span>irstmnt_t</span> <span>ret_value</span><span>);</span>
    <span>~</span><span>IRRet</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irstmnt_t</span> <span>get_return_value</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
<span>private:</span>
    <span>//! Returned value, commonly a NONE IRType, or an IRReg.</span>
    <span>irstmnt_t</span> <span>ret_value</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>A return instruction can optionally have a return value. A return instruction creates a <code>leaf</code> node, these are nodes that terminate the graph.</p>

<h6 id="irnop-implementation"><code>IRNop</code> implementation</h6>

<p>The nop instruction doesn’t receive any parameter, and can be used to create empty blocks (blocks that do nothing). So its implementation is pretty simple:</p>

<div><div><pre><code><span>class</span> <span>IRRet</span> <span>:</span> <span>public</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRRet</span><span>(</span><span>irstmnt_t</span> <span>ret_value</span><span>);</span>
    <span>~</span><span>IRRet</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irstmnt_t</span> <span>get_return_value</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
<span>private:</span>
    <span>//! Returned value, commonly a NONE IRType, or an IRReg.</span>
    <span>irstmnt_t</span> <span>ret_value</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irswitch-implementation"><code>IRSwitch</code> implementation</h6>

<p>The last type of jump is the switch instruction; switch allows given an expression, jumps to different blocks.</p>

<div><div><pre><code><span>class</span> <span>IRSwitch</span> <span>:</span> <span>public</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRSwitch</span><span>(</span><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int32_t</span><span>&gt;</span> <span>offsets</span><span>,</span>
                <span>irexpr_t</span> <span>condition</span><span>,</span>
                <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int32_t</span><span>&gt;</span> <span>constants_checks</span><span>);</span>
    <span>~</span><span>IRSwitch</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>const</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int32_t</span><span>&gt;</span> <span>&amp;</span><span>get_offsets</span><span>()</span> <span>const</span><span>;</span>
    <span>irexpr_t</span> <span>get_condition</span><span>();</span>
    <span>const</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int32_t</span><span>&gt;</span> <span>&amp;</span><span>get_constants_checks</span><span>()</span> <span>const</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>

<span>private:</span>
    <span>//! switch offsets where instruction will jump.</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int32_t</span><span>&gt;</span> <span>offsets</span><span>;</span>
    <span>//! condition taken to decide where to jump</span>
    <span>irexpr_t</span> <span>condition</span><span>;</span>
    <span>//! conditions checked during switch.</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int32_t</span><span>&gt;</span> <span>constants_checks</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>We have a list of offsets and a list of checks for the <code>case</code> blocks from the switch statement. For the condition value, we have an expression (commonly a temporal register).</p>

<h5 id="irexpr-implementation"><code>IRExpr</code> implementation</h5>

<p>Although the <code>IRExpr</code> instruction does not have itself a long codebase, it is the base class for all the expressions in MjolnIR, and it contains an enum to specify the type of expression we are working with:</p>

<div><div><pre><code><span>enum</span> <span>expr_type_t</span>
<span>{</span>
    <span>BINOP_EXPR_T</span><span>,</span>
    <span>UNARYOP_EXPR_T</span><span>,</span>
    <span>ASSIGN_EXPR_T</span><span>,</span>
    <span>PHI_EXPR_T</span><span>,</span>
    <span>CALL_EXPR_T</span><span>,</span>
    <span>TYPE_EXPR_T</span><span>,</span>
    <span>LOAD_EXPR_T</span><span>,</span>
    <span>STORE_EXPR_T</span><span>,</span>
    <span>ZCOMP_EXPR_T</span><span>,</span>
    <span>BCOMP_EXPR_T</span><span>,</span>
    <span>NEW_EXPR_T</span><span>,</span>
    <span>ALLOCA_EXPR_T</span><span>,</span>
    <span>NONE_EXPR_T</span> <span>=</span> <span>99</span> <span>// used to finish the expressions</span>
<span>};</span>
</code></pre></div></div>

<p>Finally, the code from the <code>IRExpr</code> class, contains the code that other expressions will need to create:</p>

<div><div><pre><code><span>class</span> <span>IRExpr</span> <span>:</span> <span>public</span> <span>IRStmnt</span>
<span>{</span>
<span>public:</span>
    <span>IRExpr</span><span>(</span><span>expr_type_t</span> <span>type</span><span>,</span> <span>op_type_t</span> <span>op_type</span><span>);</span>
    <span>~</span><span>IRExpr</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>expr_type_t</span> <span>get_expression_type</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irexpr_t</span> <span>irexpr</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRExpr</span> <span>&amp;</span><span>,</span> <span>IRExpr</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! ir expression as string</span>
    <span>std</span><span>::</span><span>string</span> <span>ir_expr_str</span><span>;</span>

    <span>//! expression type</span>
    <span>expr_type_t</span> <span>type</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irbinop-implementation"><code>IRBinOp</code> implementation</h6>

<p>One of the most important operations are binary operations, we have different mathematical operations we do with two operators, and then we store the result in another expression (commonly a register or a temporal register). This class is also the enum of the binary operations:</p>

<div><div><pre><code><span>enum</span> <span>bin_op_t</span>
<span>{</span>
    <span>// common arithmetic instructions</span>
    <span>ADD_OP_T</span><span>,</span>
    <span>SUB_OP_T</span><span>,</span>
    <span>S_MUL_OP_T</span><span>,</span>
    <span>U_MUL_OP_T</span><span>,</span>
    <span>S_DIV_OP_T</span><span>,</span>
    <span>U_DIV_OP_T</span><span>,</span>
    <span>MOD_OP_T</span><span>,</span>
    <span>// common logic instructions</span>
    <span>AND_OP_T</span><span>,</span>
    <span>XOR_OP_T</span><span>,</span>
    <span>OR_OP_T</span><span>,</span>
    <span>SHL_OP_T</span><span>,</span>
    <span>SHR_OP_T</span><span>,</span>
    <span>USHR_OP_T</span><span>,</span>
<span>};</span>
</code></pre></div></div>

<p>The implementation includes the two operands as expressions, and finally another expression as the place where to store the result</p>

<div><div><pre><code><span>class</span> <span>IRBinOp</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>IRBinOp</span><span>(</span><span>bin_op_t</span> <span>bin_op_type</span><span>,</span>
            <span>irexpr_t</span> <span>result</span><span>,</span>
            <span>irexpr_t</span> <span>op1</span><span>,</span>
            <span>irexpr_t</span> <span>op2</span><span>);</span>
    <span>~</span><span>IRBinOp</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>bin_op_t</span> <span>get_bin_op_type</span><span>();</span>
    <span>irexpr_t</span> <span>get_result</span><span>();</span>
    <span>irexpr_t</span> <span>get_op1</span><span>();</span>
    <span>irexpr_t</span> <span>get_op2</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irbinop_t</span> <span>irbinop</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRBinOp</span> <span>&amp;</span><span>,</span> <span>IRBinOp</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! type of binary operation</span>
    <span>bin_op_t</span> <span>bin_op_type</span><span>;</span>
    <span>//! IRBinOp =&gt;  IRExpr(result) = IRExpr(op1) &lt;binop&gt; IRExpr(op2)</span>
    <span>//! for the result we will have an IRExpr too.</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>//! now each one of the operators</span>
    <span>irexpr_t</span> <span>op1</span><span>;</span>
    <span>irexpr_t</span> <span>op2</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irunaryop-implementation"><code>IRUnaryOp</code> implementation</h6>

<p>Similar as the previous operation, we have types of unary operations:</p>

<div><div><pre><code><span>enum</span> <span>unary_op_t</span>
<span>{</span>
    <span>NONE_UNARY_OP_T</span><span>,</span>
    <span>INC_OP_T</span><span>,</span>
    <span>DEC_OP_T</span><span>,</span>
    <span>NOT_OP_T</span><span>,</span>
    <span>NEG_OP_T</span><span>,</span>
    <span>CAST_OP_T</span><span>,</span>  <span>// maybe not used in binary</span>
    <span>Z_EXT_OP_T</span><span>,</span> <span>// zero extend</span>
    <span>S_EXT_OP_T</span>  <span>// sign extend</span>
<span>};</span>
</code></pre></div></div>

<p>And because we have a cast operation, we have different casting operation enum values:</p>

<div><div><pre><code><span>enum</span> <span>cast_type_t</span>
<span>{</span>
    <span>NONE_CAST</span><span>,</span>
    <span>TO_BYTE</span><span>,</span>
    <span>TO_CHAR</span><span>,</span>
    <span>TO_SHORT</span><span>,</span>
    <span>TO_INT</span><span>,</span>
    <span>TO_LONG</span><span>,</span>
    <span>TO_FLOAT</span><span>,</span>
    <span>TO_DOUBLE</span><span>,</span>
    <span>TO_ADDR</span><span>,</span>
    <span>TO_BOOLEAN</span><span>,</span>
    <span>TO_CLASS</span><span>,</span>
    <span>TO_VOID</span><span>,</span>
    <span>TO_ARRAY</span><span>,</span>
<span>};</span>
</code></pre></div></div>

<p>As part of the implementation, we have a normal constructor that is used to initialize the unary operations, and in case of cast operation, we have another constructor that also initializes the type of cast operation. Also, if the cast is to a class, we can specify the name of the class we are casting too:</p>

<div><div><pre><code><span>class</span> <span>IRUnaryOp</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>IRUnaryOp</span><span>(</span><span>unary_op_t</span> <span>unary_op_type</span><span>,</span>
                <span>irexpr_t</span> <span>result</span><span>,</span>
                <span>irexpr_t</span> <span>op</span><span>);</span>
    <span>/**
     * @param cast_type: instruction is cast, specify type of cast.
     */</span>
    <span>IRUnaryOp</span><span>(</span><span>unary_op_t</span> <span>unary_op_type</span><span>,</span>
                <span>cast_type_t</span> <span>cast_type</span><span>,</span>
                <span>irexpr_t</span> <span>result</span><span>,</span>
                <span>irexpr_t</span> <span>op</span><span>);</span>
    <span>/**
     * @param cast_type: instruction is cast, specify type of cast.
     * @param class_name: if cast is TO_CLASS, specify the name of the class.
     */</span>
    <span>IRUnaryOp</span><span>(</span><span>unary_op_t</span> <span>unary_op_type</span><span>,</span>
                <span>cast_type_t</span> <span>cast_type</span><span>,</span>
                <span>std</span><span>::</span><span>string</span> <span>class_name</span><span>,</span>
                <span>irexpr_t</span> <span>result</span><span>,</span>
                <span>irexpr_t</span> <span>op</span><span>);</span>
    <span>~</span><span>IRUnaryOp</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>unary_op_t</span> <span>get_unary_op_type</span><span>();</span>
    <span>irexpr_t</span> <span>get_result</span><span>();</span>
    <span>irexpr_t</span> <span>get_op</span><span>();</span>
    <span>void</span> <span>set_cast_type</span><span>(</span><span>cast_type_t</span> <span>cast_type</span><span>);</span>
    <span>cast_type_t</span> <span>get_cast_type</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_class_cast</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irunaryop_t</span> <span>irunaryop</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRUnaryOp</span> <span>&amp;</span><span>,</span> <span>IRUnaryOp</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! type of unary operation </span>
    <span>unary_op_t</span> <span>unary_op_type</span><span>;</span>
    <span>//! used for casting operations</span>
    <span>cast_type_t</span> <span>cast_type</span><span>;</span>
    <span>//! Class casted to</span>
    <span>std</span><span>::</span><span>string</span> <span>class_name</span><span>;</span>
    <span>//! IRUnaryOp =&gt; IRExpr(result) = &lt;unaryop&gt; IRExpr(op)</span>
    <span>//! an IRExpr for where the result is stored.</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>// operator</span>
    <span>irexpr_t</span> <span>op</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>The operand and the result are two expressions (commonly are registers or temporal registers).</p>

<h6 id="irassign-implementation"><code>IRAssign</code> implementation</h6>

<p>The implementation of this operation is similar to the previous one, since we have only one operand and one result. But conceptually it is very different because this operation is mostly used to move values between registers (registers/temporal registers). So instead of operand and result, we have source and destination. This instruction shouldn’t be used to move from or to memory, since we already have load and store for that.</p>

<div><div><pre><code><span>class</span> <span>IRAssign</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>IRAssign</span><span>(</span><span>irexpr_t</span> <span>destination</span><span>,</span>
                <span>irexpr_t</span> <span>source</span><span>);</span>
    <span>~</span><span>IRAssign</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_destination</span><span>();</span>
    <span>irexpr_t</span> <span>get_source</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irassign_t</span> <span>irassign</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRAssign</span> <span>&amp;</span><span>,</span> <span>IRAssign</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! destination where the value will be stored.</span>
    <span>irexpr_t</span> <span>destination</span><span>;</span>
    <span>//! source expression from where the value is taken</span>
    <span>irexpr_t</span> <span>source</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irphi-implementation"><code>IRPhi</code> implementation</h6>

<p>This instruction is a special instruction in an IR. An IR does not execute the code, but it represents the code. We have cases where the same variable can come from different paths, and depending on the path where the variable comes, its value is one or another. An example with source code would be like so:</p>

<div><div><pre><code><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span>
<span>int</span> <span>absolute</span><span>(</span><span>int</span> <span>x</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>x</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>-</span><span>x</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>x</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>int</span> <span>value</span> <span>=</span> <span>-</span><span>42</span><span>;</span>
    <span>int</span> <span>absValue</span> <span>=</span> <span>absolute</span><span>(</span><span>value</span><span>);</span>
    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Absolute value of &#34;</span> <span>&lt;&lt;</span> <span>value</span> <span>&lt;&lt;</span> <span>&#34; is &#34;</span> <span>&lt;&lt;</span> <span>absValue</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>A simplified version of the IR, generated from <code>absolute</code> and generated with LLVM, would be like so:</p>

<div><div><pre><code><span>define</span> <span>i32</span> <span>@absolute</span><span>(</span><span>i32</span> <span>%x</span><span>)</span> <span>#0</span> <span>{</span>
<span>entry:</span>
  <span>%cmp</span> <span>=</span> <span>icmp</span> <span>slt</span> <span>i32</span> <span>%x</span><span>,</span> <span>0</span>
  <span>br</span> <span>i1</span> <span>%cmp</span><span>,</span> <span>label</span> <span>%if.then</span><span>,</span> <span>label</span> <span>%if.end</span>

<span>if.then:</span>                                          <span>; preds = %entry</span>
  <span>%neg</span> <span>=</span> <span>sub</span> <span>nsw</span> <span>i32</span> <span>0</span><span>,</span> <span>%x</span>
  <span>br</span> <span>label</span> <span>%if.end</span>

<span>if.end:</span>                                           <span>; preds = %if.then, %entry</span>
  <span>%retval.0</span> <span>=</span> <span>phi</span> <span>i32</span> <span>[</span> <span>%x</span><span>,</span> <span>%entry</span> <span>],</span> <span>[</span> <span>%neg</span><span>,</span> <span>%if.then</span> <span>]</span>
  <span>ret</span> <span>i32</span> <span>%retval.0</span>
<span>}</span>
</code></pre></div></div>

<p>We have a <code>phi</code> instruction that, depending on what the last executed incoming block was, the value of <code>%retval.0</code> will be <code>%x</code> if the code came from <code>%entry</code>, or <code>%neg</code> if it came from <code>%if.then</code>.</p>

<p>My implementation includes a map, the map has as a key which identifies the block from where the variable comes from, and as value the expression with the variable (register/temporal register). Finally, we have another expression as result, which will be the final register which will contain the value that will be used from that block.</p>

<div><div><pre><code><span>class</span> <span>IRPhi</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>IRPhi</span><span>();</span>
    <span>~</span><span>IRPhi</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>uint32_t</span><span>,</span> <span>irexpr_t</span><span>&gt;</span> <span>&amp;</span><span>get_params</span><span>();</span>
    <span>void</span> <span>add_param</span><span>(</span><span>irexpr_t</span> <span>param</span><span>,</span> <span>uint32_t</span> <span>id</span><span>);</span>
    <span>irexpr_t</span> <span>get_result</span><span>();</span>
    <span>void</span> <span>add_result</span><span>(</span><span>irexpr_t</span> <span>result</span><span>);</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irphi_t</span> <span>irphi</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRPhi</span> <span>&amp;</span><span>,</span> <span>IRPhi</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>uint32_t</span><span>,</span> <span>irexpr_t</span><span>&gt;</span> <span>params</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="ircall-implementation"><code>IRCall</code> implementation</h6>

<p>The instruction <code>IRCall</code> was designed as a call to different types of functions. I implemented internal calls which are calls to functions in the binary, external calls which would be calls to library functions, and finally syscalls. The previous values are <code>enum</code> values in the code:</p>

<div><div><pre><code><span>enum</span> <span>call_type_t</span>
<span>{</span>
    <span>INTERNAL_CALL_T</span><span>,</span>  <span>// call to internal component</span>
    <span>EXTERNAL_CALL_T</span><span>,</span>  <span>// call to external library (example DLL, .so file, external component, etc)</span>
    <span>SYSCALL_T</span><span>,</span>        <span>// a syscall type</span>
    <span>NONE_CALL_T</span> <span>=</span> <span>99</span><span>,</span> <span>// Not specified</span>
<span>};</span>
</code></pre></div></div>

<p>The instruction stores as an <code>IRExpr</code> a callee, later we will see a type <code>IRCallee</code> that implements these functions for Java-type languages. Then the instruction also contains a vector for the parameters and an optional return value.</p>

<div><div><pre><code><span>class</span> <span>IRCall</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>IRCall</span><span>(</span><span>irexpr_t</span> <span>callee</span><span>,</span>
            <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>args</span><span>);</span>
    <span>IRCall</span><span>(</span><span>irexpr_t</span> <span>callee</span><span>,</span>
            <span>call_type_t</span> <span>call_type</span><span>,</span>
            <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>args</span><span>);</span>
    <span>~</span><span>IRCall</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_callee</span><span>();</span>
    <span>const</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>&amp;</span><span>get_args</span><span>()</span> <span>const</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>void</span> <span>set_ret_val</span><span>(</span><span>irexpr_t</span> <span>ret_val</span><span>);</span>
    <span>irexpr_t</span> <span>get_ret_val</span><span>();</span>
    <span>call_type_t</span> <span>get_call_type</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>ircall_t</span> <span>ircall</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRCall</span> <span>&amp;</span><span>,</span> <span>IRCall</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! Type of call</span>
    <span>call_type_t</span> <span>call_type</span><span>;</span>
    <span>//! Type representing the function/method called</span>
    <span>irexpr_t</span> <span>callee</span><span>;</span>
    <span>//! Vector with possible arguments</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>args</span><span>;</span>
    <span>//! Return value (if it&#39;s for example a register)</span>
    <span>irexpr_t</span> <span>ret_val</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>The return value is optional, since we can have <code>void</code> return values, and parameters can be an empty vector.</p>

<h6 id="irload--irstore-implementations"><code>IRLoad</code> &amp; <code>IRStore</code> implementations</h6>

<p>I will put together these instructions since they represent a same concept. These two instructions are used to operate with memory. In the IR I tried to follow the convention <code>pcode</code>, and I created these instructions to operate with memory, so instead of working with memory directly in the operations, memory values are loaded in registers or in temporal registers. After that, we can operate with those values. The operations contains a <code>destination</code> and a <code>source</code> value expressed as <code>IRExpr</code> but it also has a size value (the size of the loaded or stored value), and also an index in case the memory is accessed using some index.</p>

<div><div><pre><code><span>class</span> <span>IRLoad</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRLoad class, this class represent a load from memory (using memory or using register).
     * @param destination: register where the value will be stored.
     * @param source: expression from where the memory will be retrieved.
     * @param size: loaded size.
     * @return void
     */</span>
    <span>IRLoad</span><span>(</span><span>irexpr_t</span> <span>destination</span><span>,</span>
            <span>irexpr_t</span> <span>source</span><span>,</span>
            <span>std</span><span>::</span><span>uint32_t</span> <span>size</span><span>);</span>
    <span>/**
     * @brief Constructor of IRLoad class, this class represent a load from memory (using memory or using register).
     * @param destination: register where the value will be stored.
     * @param source: expression from where the memory will be retrieved.
     * @param index: index from the load if this is referenced with an index.
     * @param size: loaded size.
     * @return void
     */</span>
    <span>IRLoad</span><span>(</span><span>irexpr_t</span> <span>destination</span><span>,</span>
            <span>irexpr_t</span> <span>source</span><span>,</span>
            <span>irexpr_t</span> <span>index</span><span>,</span>
            <span>std</span><span>::</span><span>uint32_t</span> <span>size</span><span>);</span>
    <span>~</span><span>IRLoad</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_destination</span><span>();</span>
    <span>irexpr_t</span> <span>get_source</span><span>();</span>
    <span>irexpr_t</span> <span>get_index</span><span>();</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>get_size</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irload_t</span> <span>irload</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRLoad</span> <span>&amp;</span><span>,</span> <span>IRLoad</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! Register where the memory pointed by a register will be loaded.</span>
    <span>irexpr_t</span> <span>destination</span><span>;</span>
    <span>//! Expression from where memory is read.</span>
    <span>irexpr_t</span> <span>source</span><span>;</span>
    <span>//! Index if this is referenced by for example a register.</span>
    <span>irexpr_t</span> <span>index</span><span>;</span>
    <span>//! Size of loaded value</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>size</span><span>;</span>
<span>};</span>

<span>class</span> <span>IRStore</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRStore class, this represent an store to memory instruction.
     * @param destination: Expression where value is written to.
     * @param source: register with the value to be stored.
     * @param size: size of the stored value.
     * @return void
     */</span>
    <span>IRStore</span><span>(</span><span>irexpr_t</span> <span>destination</span><span>,</span>
            <span>irexpr_t</span> <span>source</span><span>,</span>
            <span>std</span><span>::</span><span>uint32_t</span> <span>size</span><span>);</span>
    <span>/**
     * @brief Constructor of IRStore class, this represent an store to memory instruction.
     * @param destination: Expression where value is written to.
     * @param source: register with the value to be stored.
     * @param index: index where value is stored.
     * @param size: size of the stored value.
     * @return void
     */</span>
    <span>IRStore</span><span>(</span><span>irexpr_t</span> <span>destination</span><span>,</span>
            <span>irexpr_t</span> <span>source</span><span>,</span>
            <span>irexpr_t</span> <span>index</span><span>,</span>
            <span>std</span><span>::</span><span>uint32_t</span> <span>size</span><span>);</span>
    <span>~</span><span>IRStore</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_destination</span><span>();</span>
    <span>irexpr_t</span> <span>get_source</span><span>();</span>
    <span>irexpr_t</span> <span>get_index</span><span>();</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>get_size</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irstore_t</span> <span>irstore</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRStore</span> <span>&amp;</span><span>,</span> <span>IRStore</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! Memory pointed by register where value will be stored.</span>
    <span>irexpr_t</span> <span>destination</span><span>;</span>
    <span>//! Expression with source of value to be stored.</span>
    <span>irexpr_t</span> <span>source</span><span>;</span>
    <span>//! Index if this is referenced by for example a register.</span>
    <span>irexpr_t</span> <span>index</span><span>;</span>
    <span>//! Size of stored value</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>size</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irzcomp-implementation"><code>IRZComp</code> implementation</h6>

<p>Since this IR was mainly implemented for Java-like languages, I implemented an instruction to compare with a zero value. There are different <code>enum</code> values that will tell the type of comparator:</p>

<div><div><pre><code><span>enum</span> <span>zero_comp_t</span>
<span>{</span>
    <span>EQUAL_ZERO_T</span><span>,</span>       <span>// ==</span>
    <span>NOT_EQUAL_ZERO_T</span><span>,</span>   <span>// !=</span>
    <span>LOWER_ZERO_T</span><span>,</span>       <span>// &lt;</span>
    <span>GREATER_EQUAL_ZERO</span><span>,</span> <span>// &gt;=</span>
    <span>GREATER_ZERO_T</span><span>,</span>     <span>// &gt;</span>
    <span>LOWER_EQUAL_ZERO</span>    <span>// &lt;=</span>
<span>};</span>
</code></pre></div></div>

<p>Then the instruction contains a register for the compared operand, and a register for storing the result. In both cases the values are provided as <code>IRExpr</code>:</p>

<div><div><pre><code><span>class</span> <span>IRZComp</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRZComp, this is a comparison with zero.
     * @param comp: type of comparison (== or !=).
     * @param result: register or temporal register where result is stored.
     * @param reg: register used in the comparison.
     * @return void
     */</span>
    <span>IRZComp</span><span>(</span><span>zero_comp_t</span> <span>comp</span><span>,</span>
            <span>irexpr_t</span> <span>result</span><span>,</span>
            <span>irexpr_t</span> <span>reg</span><span>);</span>
    <span>~</span><span>IRZComp</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_result</span><span>();</span>
    <span>irexpr_t</span> <span>get_reg</span><span>();</span>
    <span>zero_comp_t</span> <span>get_comparison</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irzcomp_t</span> <span>irzcomp</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRZComp</span> <span>&amp;</span><span>,</span> <span>IRZComp</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! Register where result is stored</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>//! Register for comparison with zero.</span>
    <span>irexpr_t</span> <span>reg</span><span>;</span>
    <span>//! Type of comparison</span>
    <span>zero_comp_t</span> <span>comp</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irbcomp-implementation"><code>IRBComp</code> implementation</h6>

<p>In the case, we do not compare with zero, but between two registers, we use this instruction. Again we have different types of comparisons:</p>

<div><div><pre><code><span>enum</span> <span>comp_t</span>
<span>{</span>
    <span>EQUAL_T</span><span>,</span>         <span>// ==</span>
    <span>NOT_EQUAL_T</span><span>,</span>     <span>// !=</span>
    <span>GREATER_T</span><span>,</span>       <span>// &gt;</span>
    <span>GREATER_EQUAL_T</span><span>,</span> <span>// &gt;=</span>
    <span>LOWER_T</span><span>,</span>         <span>// &lt;</span>
    <span>LOWER_EQUAL_T</span><span>,</span>   <span>// &lt;=</span>
    <span>ABOVE_T</span><span>,</span>         <span>// (unsigned) &gt;</span>
    <span>ABOVE_EQUAL_T</span><span>,</span>   <span>// (unsigned) &gt;=</span>
    <span>BELOW_T</span><span>,</span>         <span>// (unsigned) &lt;</span>
<span>};</span>
</code></pre></div></div>

<p>The instruction implementation is almost the same as the previous one, but this time with two registers as operators:</p>

<div><div><pre><code><span>class</span> <span>IRBComp</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRBComp, this class represent a comparison between two types.
     * @param comp: type of comparison from an enum.
     * @param result: register or temporal register where result is stored.
     * @param reg1: first type where the comparison is applied.
     * @param reg2: second type where the comparison is applied.
     * @return void
     */</span>
    <span>IRBComp</span><span>(</span><span>comp_t</span> <span>comp</span><span>,</span>
            <span>irexpr_t</span> <span>result</span><span>,</span>
            <span>irexpr_t</span> <span>reg1</span><span>,</span>
            <span>irexpr_t</span> <span>reg2</span><span>);</span>
    <span>~</span><span>IRBComp</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_result</span><span>();</span>
    <span>irexpr_t</span> <span>get_reg1</span><span>();</span>
    <span>irexpr_t</span> <span>get_reg2</span><span>();</span>
    <span>comp_t</span> <span>get_comparison</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irbcomp_t</span> <span>bcomp</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRBComp</span> <span>&amp;</span><span>,</span> <span>IRBComp</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! register or temporal register where result is stored</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>//! registers used in the comparisons.</span>
    <span>irexpr_t</span> <span>reg1</span><span>;</span>
    <span>irexpr_t</span> <span>reg2</span><span>;</span>
    <span>//! Type of comparison</span>
    <span>comp_t</span> <span>comp</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irnew-implementation"><code>IRNew</code> implementation</h6>

<p>Java-type languages contain a <code>new</code> instruction for allocating memory for a new object. This instruction contains a result value (which will be a register) and a class instance that will be the type of the new object. We will later see in types the <code>IRClass</code>:</p>

<div><div><pre><code><span>class</span> <span>IRNew</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Construct a new IRNew::IRNew object which represents
     *        the creation of an instance of a class.
     *
     * @param result: result register where object is stored.
     * @param class_instance: IRClass object which represent the instance.
     * @return void
     */</span>
    <span>IRNew</span><span>(</span><span>irexpr_t</span> <span>result</span><span>,</span>
            <span>irexpr_t</span> <span>class_instance</span><span>);</span>
    <span>~</span><span>IRNew</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_result</span><span>();</span>
    <span>irexpr_t</span> <span>get_source_class</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>irnew_t</span> <span>new_i</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRNew</span> <span>&amp;</span><span>,</span> <span>IRNew</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! register where the result will be stored.</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>//! class type which will create a new instance.</span>
    <span>irexpr_t</span> <span>class_instance</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="iralloca-implementation"><code>IRAlloca</code> implementation</h6>

<p>In opposite to a <code>new</code> instruction, we can allocate memory to store an array. In Java-type languages, the arrays are allocated as objects. <code>IRAlloca</code> has this purpose, allocating memory for an array. And for that reason <code>IRAlloca</code> has a size value:</p>

<div><div><pre><code><span>class</span> <span>IRAlloca</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Construct a new IRAlloca object,  this kind of
     *        expression creates &#34;allocates&#34; memory for an array
     *        having this class will be useful also for allocating
     *        memory in other architectures.
     *
     * @param result register or address where data will be stored
     * @param type_instance type to create an array
     * @param size size of the given array
     */</span>
    <span>IRAlloca</span><span>(</span><span>irexpr_t</span> <span>result</span><span>,</span>
                <span>irexpr_t</span> <span>type_instance</span><span>,</span>
                <span>irexpr_t</span> <span>size</span><span>);</span>
    <span>~</span><span>IRAlloca</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>irexpr_t</span> <span>get_result</span><span>()</span>
    <span>irexpr_t</span> <span>get_source_type</span><span>();</span>
    <span>irexpr_t</span> <span>get_size</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equals</span><span>(</span><span>iralloca_t</span> <span>alloca</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRAlloca</span> <span>&amp;</span><span>,</span> <span>IRAlloca</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! register or variable where result will be stored.</span>
    <span>irexpr_t</span> <span>result</span><span>;</span>
    <span>//! type which it will create a new instance</span>
    <span>irexpr_t</span> <span>type_instance</span><span>;</span>
    <span>//! size of the allocated space</span>
    <span>irexpr_t</span> <span>size</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h5 id="irtype-implementation"><code>IRType</code> implementation</h5>

<p>Finally, we arrive to the objects that represent the operands of the operations, the memory, the classes, the fields, etc. For that reason, <code>IRType</code> contains an enum that specify the type:</p>

<div><div><pre><code><span>enum</span> <span>type_t</span>
<span>{</span>
    <span>REGISTER_TYPE</span> <span>=</span> <span>0</span><span>,</span>
    <span>TEMP_REGISTER_TYPE</span><span>,</span>
    <span>CONST_INT_TYPE</span><span>,</span>
    <span>CONST_FLOAT_TYPE</span><span>,</span>
    <span>FIELD_TYPE</span><span>,</span>
    <span>MEM_TYPE</span><span>,</span>
    <span>STRING_TYPE</span><span>,</span>
    <span>CLASS_TYPE</span><span>,</span>
    <span>CALLEE_TYPE</span><span>,</span>
    <span>FUNDAMENTAL_TYPE</span><span>,</span>
    <span>NONE_TYPE</span> <span>=</span> <span>99</span>
<span>};</span>
</code></pre></div></div>

<p>An idea I had was to store the order of the memory access. Commonly architectures like x86, x86-64 stores the memory in a format known as <code>little-endian</code>, but other architectures can store the data in <code>big-endian</code>, even the crazy idea of a <code>middle-endian</code> exists!!! You can read more about endianness at <a href="https://en.wikipedia.org/wiki/Endianness">wikipedia</a>:</p>

<div><div><pre><code><span>enum</span> <span>mem_access_t</span>
<span>{</span>
    <span>LE_ACCESS</span> <span>=</span> <span>0</span><span>,</span> <span>//! little-endian access</span>
    <span>BE_ACCESS</span><span>,</span>     <span>//! big-endian access</span>
    <span>ME_ACCESS</span><span>,</span>     <span>//! This shouldn&#39;t commonly happen?</span>
    <span>NONE_ACCESS</span> <span>=</span> <span>99</span>
<span>};</span>
</code></pre></div></div>

<p>The instruction stores the type, a name to represent the type, even a field for annotations to store and show from the type.</p>

<div><div><pre><code><span>class</span> <span>IRType</span> <span>:</span> <span>public</span> <span>IRExpr</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of the IRType, this will be the generic type used for the others.
     * @param type: type of the class.
     * @param op_type: global type of operation
     * @param type_name: name used for representing the type while printing.
     * @param type_size: size of the type in bytes.
     * @return void
     */</span>
    <span>IRType</span><span>(</span><span>type_t</span> <span>type</span><span>,</span> <span>op_type_t</span> <span>op_type</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRType</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_name</span><span>();</span>
    <span>size_t</span> <span>get_type_size</span><span>();</span>
    <span>type_t</span> <span>get_type</span><span>();</span>
    <span>virtual</span> <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>void</span> <span>write_annotations</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>annotations</span><span>);</span>
    <span>std</span><span>::</span><span>string</span> <span>read_annotations</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irtype_t</span> <span>type</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRType</span> <span>&amp;</span><span>,</span> <span>IRType</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! type value as a type_t</span>
    <span>type_t</span> <span>type</span><span>;</span>
    <span>//! name used to represent the type in IR representation.</span>
    <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>;</span>
    <span>//! size of the type, this can vary depending on architecture</span>
    <span>//! and so on.</span>
    <span>size_t</span> <span>type_size</span><span>;</span>
    <span>//! annotations are there for you to write whatever you want</span>
    <span>std</span><span>::</span><span>string</span> <span>annotations</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irreg-implementation"><code>IRReg</code> implementation</h6>

<p>The IRs commonly operate with values or with registers. These are the basic types in the operations. The registers can be those from the architecture using the name of that computer architecture, or like in SSA-form IRs we can use an infinite set of registers. Compilers when they transform from IR to assembly apply different optimizations to reduce the number of registers, and then to assign the registers from the IR, to those from the real machine. In the case of virtual architectures like dalvik, the VM has 64K registers for each called method, since these are virtual registers. The registers of MjolnIR contain an id, and depending on the architecture, the id can represent one register from that architecture or not. Although I didn’t use it, following Triton’s implementation, I created the next types (but I didn’t ever use them…):</p>

<div><div><pre><code><span>const</span> <span>int</span> <span>x86_arch</span> <span>=</span> <span>1</span><span>;</span>

<span>enum</span> <span>x86_regs_t</span>
<span>/**
 * @brief X86 registers, enums for IR, sizes and strings.
 */</span>
<span>{</span>
    <span>// General purpose registers</span>
    <span>rax</span><span>,</span> <span>eax</span><span>,</span> <span>ax</span><span>,</span> <span>ah</span><span>,</span> <span>al</span><span>,</span>
    <span>rbx</span><span>,</span> <span>ebx</span><span>,</span> <span>bx</span><span>,</span> <span>bh</span><span>,</span> <span>bl</span><span>,</span>
    <span>rcx</span><span>,</span> <span>ecx</span><span>,</span> <span>cx</span><span>,</span> <span>ch</span><span>,</span> <span>cl</span><span>,</span>
    <span>rdx</span><span>,</span> <span>edx</span><span>,</span> <span>dx</span><span>,</span> <span>dh</span><span>,</span> <span>dl</span><span>,</span>
    <span>// pointer registers</span>
    <span>rdi</span><span>,</span> <span>edi</span><span>,</span> <span>di</span><span>,</span>
    <span>rsi</span><span>,</span> <span>esi</span><span>,</span> <span>si</span><span>,</span>
    <span>// stack registers</span>
    <span>rbp</span><span>,</span> <span>ebp</span><span>,</span> <span>bp</span><span>,</span>
    <span>rsp</span><span>,</span> <span>esp</span><span>,</span> <span>sp</span><span>,</span>
    <span>// program counter</span>
    <span>rip</span><span>,</span> <span>eip</span><span>,</span> <span>ip</span><span>,</span>
    <span>// extended registers in x86-64</span>
    <span>r8</span><span>,</span> <span>r8d</span><span>,</span> <span>r8w</span><span>,</span> <span>r8b</span><span>,</span> 
    <span>r9</span><span>,</span> <span>r9d</span><span>,</span> <span>r9w</span><span>,</span> <span>r9b</span><span>,</span> 
    <span>r10</span><span>,</span> <span>r10d</span><span>,</span> <span>r10w</span><span>,</span> <span>r10b</span><span>,</span>
    <span>r11</span><span>,</span> <span>r11d</span><span>,</span> <span>r11w</span><span>,</span> <span>r11b</span><span>,</span> 
    <span>r12</span><span>,</span> <span>r12d</span><span>,</span> <span>r12w</span><span>,</span> <span>r12b</span><span>,</span> 
    <span>r13</span><span>,</span> <span>r13d</span><span>,</span> <span>r13w</span><span>,</span> <span>r13b</span><span>,</span> 
    <span>r14</span><span>,</span> <span>r14d</span><span>,</span> <span>r14w</span><span>,</span> <span>r14b</span><span>,</span> 
    <span>r15</span><span>,</span> <span>r15d</span><span>,</span> <span>r15w</span><span>,</span> <span>r15b</span><span>,</span> 
    <span>// flags for state representation</span>
    <span>eflags</span><span>,</span>
    <span>mm0</span><span>,</span> <span>mm1</span><span>,</span> <span>mm2</span><span>,</span> <span>mm3</span><span>,</span> <span>mm4</span><span>,</span> <span>mm5</span><span>,</span> <span>mm6</span><span>,</span> <span>mm7</span><span>,</span>
    <span>zmm0</span><span>,</span> <span>zmm1</span><span>,</span> <span>zmm2</span><span>,</span> <span>zmm3</span><span>,</span> <span>zmm4</span><span>,</span> <span>zmm5</span><span>,</span> <span>zmm6</span><span>,</span> 
    <span>zmm7</span><span>,</span> <span>zmm8</span><span>,</span> <span>zmm9</span><span>,</span> <span>zmm10</span><span>,</span> <span>zmm11</span><span>,</span> <span>zmm12</span><span>,</span> <span>zmm13</span><span>,</span> 
    <span>zmm14</span><span>,</span> <span>zmm15</span><span>,</span> <span>zmm16</span><span>,</span> <span>zmm17</span><span>,</span> <span>zmm18</span><span>,</span> <span>zmm19</span><span>,</span> <span>zmm20</span><span>,</span> 
    <span>zmm21</span><span>,</span> <span>zmm22</span><span>,</span> <span>zmm23</span><span>,</span> <span>zmm24</span><span>,</span> <span>zmm25</span><span>,</span> <span>zmm26</span><span>,</span> <span>zmm27</span><span>,</span> 
    <span>zmm28</span><span>,</span> <span>zmm29</span><span>,</span> <span>zmm30</span><span>,</span> <span>zmm31</span><span>,</span> <span>mxcsr</span><span>,</span>
    <span>cr0</span><span>,</span> <span>cr1</span><span>,</span> <span>cr2</span><span>,</span> <span>cr3</span><span>,</span> <span>cr4</span><span>,</span> <span>cr5</span><span>,</span> <span>cr6</span><span>,</span> <span>cr7</span><span>,</span> <span>cr8</span><span>,</span> <span>cr9</span><span>,</span>
    <span>cr10</span><span>,</span> <span>cr11</span><span>,</span> <span>cr12</span><span>,</span> <span>cr13</span><span>,</span> <span>cr14</span><span>,</span> <span>cr15</span><span>,</span>
    <span>cs</span><span>,</span> <span>ds</span><span>,</span> <span>es</span><span>,</span> <span>fs</span><span>,</span> <span>gs</span><span>,</span> <span>ss</span><span>,</span>
    <span>dr0</span><span>,</span> <span>dr1</span><span>,</span> <span>dr2</span><span>,</span> <span>dr3</span><span>,</span> <span>dr6</span><span>,</span> <span>dr7</span>
<span>};</span>

<span>static</span> <span>const</span> <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>x86_regs_t</span><span>,</span> <span>size_t</span><span>&gt;</span> <span>x86_regs_size</span> <span>=</span> <span>{</span>
    <span>{</span><span>rax</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>eax</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>ax</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>ah</span><span>,</span><span>1</span><span>},</span> <span>{</span><span>al</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>rbx</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>ebx</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>bx</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>bh</span><span>,</span><span>1</span><span>},</span> <span>{</span><span>bl</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>rcx</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>ecx</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>cx</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>ch</span><span>,</span><span>1</span><span>},</span> <span>{</span><span>cl</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>rdx</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>edx</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>dx</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>dh</span><span>,</span><span>1</span><span>},</span> <span>{</span><span>dl</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>rdi</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>edi</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>di</span><span>,</span><span>2</span><span>},</span>
    <span>{</span><span>rsi</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>esi</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>si</span><span>,</span><span>2</span><span>},</span>
    <span>{</span><span>rip</span><span>,</span><span>8</span><span>},</span> <span>{</span><span>eip</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>ip</span><span>,</span><span>2</span><span>},</span>
    <span>{</span><span>r8</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r8d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r8w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r8b</span><span>,</span><span>1</span><span>},</span> 
    <span>{</span><span>r9</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r9d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r9w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r9b</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>r10</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r10d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r10w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r10b</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>r11</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r11d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r11w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r11b</span><span>,</span><span>1</span><span>},</span> 
    <span>{</span><span>r12</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r12d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r12w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r12b</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>r13</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r13d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r13w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r13b</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>r14</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r14d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r14w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r14b</span><span>,</span><span>1</span><span>},</span>
    <span>{</span><span>r15</span><span>,</span> <span>8</span><span>},</span> <span>{</span><span>r15d</span><span>,</span><span>4</span><span>},</span> <span>{</span><span>r15w</span><span>,</span><span>2</span><span>},</span> <span>{</span><span>r15b</span><span>,</span><span>1</span><span>}</span>
<span>};</span>

<span>static</span> <span>const</span> <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>x86_regs_t</span><span>,</span> <span>std</span><span>::</span><span>string</span><span>&gt;</span> <span>x86_regs_name</span> <span>=</span> <span>{</span>
    <span>{</span><span>rax</span><span>,</span><span>&#34;rax&#34;</span><span>},</span> <span>{</span><span>eax</span><span>,</span><span>&#34;eax&#34;</span><span>},</span> <span>{</span><span>ax</span><span>,</span><span>&#34;ax&#34;</span><span>},</span> <span>{</span><span>ah</span><span>,</span><span>&#34;ah&#34;</span><span>},</span> <span>{</span><span>al</span><span>,</span><span>&#34;al&#34;</span><span>},</span>
    <span>{</span><span>rbx</span><span>,</span><span>&#34;rbx&#34;</span><span>},</span> <span>{</span><span>ebx</span><span>,</span><span>&#34;ebx&#34;</span><span>},</span> <span>{</span><span>bx</span><span>,</span><span>&#34;bx&#34;</span><span>},</span> <span>{</span><span>bh</span><span>,</span><span>&#34;bh&#34;</span><span>},</span> <span>{</span><span>bl</span><span>,</span><span>&#34;bl&#34;</span><span>},</span>
    <span>{</span><span>rcx</span><span>,</span><span>&#34;rcx&#34;</span><span>},</span> <span>{</span><span>ecx</span><span>,</span><span>&#34;ecx&#34;</span><span>},</span> <span>{</span><span>cx</span><span>,</span><span>&#34;cx&#34;</span><span>},</span> <span>{</span><span>ch</span><span>,</span><span>&#34;ch&#34;</span><span>},</span> <span>{</span><span>cl</span><span>,</span><span>&#34;cl&#34;</span><span>},</span>
    <span>{</span><span>rdx</span><span>,</span><span>&#34;rdx&#34;</span><span>},</span> <span>{</span><span>edx</span><span>,</span><span>&#34;edx&#34;</span><span>},</span> <span>{</span><span>dx</span><span>,</span><span>&#34;dx&#34;</span><span>},</span> <span>{</span><span>dh</span><span>,</span><span>&#34;dh&#34;</span><span>},</span> <span>{</span><span>dl</span><span>,</span><span>&#34;dl&#34;</span><span>},</span>
    <span>{</span><span>rdi</span><span>,</span><span>&#34;rdi&#34;</span><span>},</span> <span>{</span><span>edi</span><span>,</span><span>&#34;edi&#34;</span><span>},</span> <span>{</span><span>di</span><span>,</span><span>&#34;di&#34;</span><span>},</span>
    <span>{</span><span>rsi</span><span>,</span><span>&#34;rsi&#34;</span><span>},</span> <span>{</span><span>esi</span><span>,</span><span>&#34;esi&#34;</span><span>},</span> <span>{</span><span>si</span><span>,</span><span>&#34;si&#34;</span><span>},</span>
    <span>{</span><span>rip</span><span>,</span><span>&#34;rip&#34;</span><span>},</span> <span>{</span><span>eip</span><span>,</span><span>&#34;eip&#34;</span><span>},</span> <span>{</span><span>ip</span><span>,</span><span>&#34;ip&#34;</span><span>},</span>
    <span>{</span><span>r8</span><span>,</span><span>&#34;r8&#34;</span><span>},</span> <span>{</span><span>r8d</span><span>,</span><span>&#34;r8d&#34;</span><span>},</span> <span>{</span><span>r8w</span><span>,</span><span>&#34;r8w&#34;</span><span>},</span> <span>{</span><span>r8b</span><span>,</span><span>&#34;r8b&#34;</span><span>},</span> 
    <span>{</span><span>r9</span><span>,</span><span>&#34;r9&#34;</span><span>},</span> <span>{</span><span>r9d</span><span>,</span><span>&#34;r9d&#34;</span><span>},</span> <span>{</span><span>r9w</span><span>,</span><span>&#34;r9w&#34;</span><span>},</span> <span>{</span><span>r9b</span><span>,</span><span>&#34;r9b&#34;</span><span>},</span>
    <span>{</span><span>r10</span><span>,</span><span>&#34;r10&#34;</span><span>},</span> <span>{</span><span>r10d</span><span>,</span><span>&#34;r10d&#34;</span><span>},</span> <span>{</span><span>r10w</span><span>,</span><span>&#34;r10w&#34;</span><span>},</span> <span>{</span><span>r10b</span><span>,</span><span>&#34;r10b&#34;</span><span>},</span>
    <span>{</span><span>r11</span><span>,</span><span>&#34;r11&#34;</span><span>},</span> <span>{</span><span>r11d</span><span>,</span><span>&#34;r11d&#34;</span><span>},</span> <span>{</span><span>r11w</span><span>,</span><span>&#34;r11w&#34;</span><span>},</span> <span>{</span><span>r11b</span><span>,</span><span>&#34;r11b&#34;</span><span>},</span> 
    <span>{</span><span>r12</span><span>,</span><span>&#34;r12&#34;</span><span>},</span> <span>{</span><span>r12d</span><span>,</span><span>&#34;r12d&#34;</span><span>},</span> <span>{</span><span>r12w</span><span>,</span><span>&#34;r12w&#34;</span><span>},</span> <span>{</span><span>r12b</span><span>,</span><span>&#34;r12b&#34;</span><span>},</span>
    <span>{</span><span>r13</span><span>,</span><span>&#34;r13&#34;</span><span>},</span> <span>{</span><span>r13d</span><span>,</span><span>&#34;r13d&#34;</span><span>},</span> <span>{</span><span>r13w</span><span>,</span><span>&#34;r13w&#34;</span><span>},</span> <span>{</span><span>r13b</span><span>,</span><span>&#34;r13b&#34;</span><span>},</span>
    <span>{</span><span>r14</span><span>,</span><span>&#34;r14&#34;</span><span>},</span> <span>{</span><span>r14d</span><span>,</span><span>&#34;r14d&#34;</span><span>},</span> <span>{</span><span>r14w</span><span>,</span><span>&#34;r14w&#34;</span><span>},</span> <span>{</span><span>r14b</span><span>,</span><span>&#34;r14b&#34;</span><span>},</span>
    <span>{</span><span>r15</span><span>,</span><span>&#34;r15&#34;</span><span>},</span> <span>{</span><span>r15d</span><span>,</span><span>&#34;r15d&#34;</span><span>},</span> <span>{</span><span>r15w</span><span>,</span><span>&#34;r15w&#34;</span><span>},</span> <span>{</span><span>r15b</span><span>,</span><span>&#34;r15b&#34;</span><span>}</span>
<span>};</span>
</code></pre></div></div>

<p>The first implementation of MjolnIR wasn’t using an SSA form but directly used the values from Dalvik. Later I implemented the SSA form, and for that the <code>IRReg</code> contains a <code>sub_id</code> field, to express the SSA form in the registers:</p>

<div><div><pre><code><span>class</span> <span>IRReg</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRReg type.
     * @param reg_id: id of the register this can be an enum if is a well known register, or just an id.
     * @param current_arch: curreng architecture to create the register.
     * @param type_name: string for representing the register.
     * @param type_size: size of the register.
     * @return void
     */</span>
    <span>IRReg</span><span>(</span><span>std</span><span>::</span><span>uint32_t</span> <span>reg_id</span><span>,</span> <span>int</span> <span>current_arch</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>/**
     * @brief Constructor of IRReg type.
     * @param reg_id: id of the register this can be an enum if is a well known register, or just an id.
     * @param reg_sub_id: sub id of the register used in the SSA form.
     * @param current_arch: curreng architecture to create the register.
     * @param type_name: string for representing the register.
     * @param type_size: size of the register.
     * @return void
     */</span>
    <span>IRReg</span><span>(</span><span>std</span><span>::</span><span>uint32_t</span> <span>reg_id</span><span>,</span> <span>std</span><span>::</span><span>int32_t</span> <span>reg_sub_id</span><span>,</span> <span>int</span> <span>current_arch</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRReg</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>get_id</span><span>();</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>get_sub_id</span><span>();</span>
    <span>int</span> <span>get_current_arch</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>same</span><span>(</span><span>irreg_t</span> <span>reg</span><span>);</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irreg_t</span> <span>reg</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRReg</span> <span>&amp;</span><span>,</span> <span>IRReg</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! id of the register, this will be an enum</span>
    <span>//! in case the arquitecture contains a known set</span>
    <span>//! of registers, for example x86-64 will have a</span>
    <span>//! well known set of registers, e.g. EAX, AX, RSP</span>
    <span>//! RIP, etc.</span>
    <span>//! Other arquitectures like DEX VM will not have</span>
    <span>//! an specific set.</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>id</span><span>;</span>
    <span>//! sub id of the register, this sub id will be used</span>
    <span>//! in the SSA form, and used to check if a register</span>
    <span>//! is the same than other.</span>
    <span>std</span><span>::</span><span>int32_t</span> <span>sub_id</span><span>;</span>
    <span>int</span> <span>current_arch</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irtempreg-implementation"><code>IRTempReg</code> implementation</h6>

<p>In some cases, the instructions implement intrinsic operands, an IR instead of representing instrinsic operands it can use registers. In MjolnIR for doing so, I implemented temporal registers. For example, if a language uses 3 operands like the next:</p>

<div><div><pre><code><span>int</span> <span>x</span> <span>=</span> <span>2</span><span>;</span>
<span>int</span> <span>y</span> <span>=</span> <span>1</span><span>;</span>
<span>int</span> <span>z</span> <span>=</span> <span>5</span><span>;</span>
<span>int</span> <span>d</span> <span>=</span> <span>x</span> <span>+</span> <span>y</span> <span>+</span> <span>z</span><span>;</span>
</code></pre></div></div>

<p>Commonly an IR instruction only contains two operands, and then the result value. For that reason we can use a temporal register to represent the previous sequence of instructions in the next way:</p>

<div><div><pre><code><span>int</span> <span>x</span> <span>=</span> <span>2</span><span>;</span>
<span>int</span> <span>y</span> <span>=</span> <span>1</span><span>;</span>
<span>int</span> <span>z</span> <span>=</span> <span>5</span><span>;</span>
<span>temp_reg1</span> <span>=</span> <span>x</span> <span>+</span> <span>y</span><span>;</span>
<span>int</span> <span>d</span> <span>=</span> <span>temp_reg1</span> <span>+</span> <span>z</span><span>;</span>
</code></pre></div></div>

<p>Now the instruction only has two operands. For doing these operations, MjolnIR uses <code>IRTempReg</code> operands:</p>

<div><div><pre><code> <span>class</span> <span>IRTempReg</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRTempReg type.
     * @param reg_id: id of the register this will be an incremental id.
     * @param type_name: string for representing the register.
     * @param type_size: size of the register.
     * @return void
     */</span>
    <span>IRTempReg</span><span>(</span><span>std</span><span>::</span><span>uint32_t</span> <span>reg_id</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRTempReg</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>get_id</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irtempreg_t</span> <span>temp_reg</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRTempReg</span> <span>&amp;</span><span>,</span> <span>IRTempReg</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! This id will be just an incremental number</span>
    <span>//! as these are temporal registers.</span>
    <span>std</span><span>::</span><span>uint32_t</span> <span>id</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irconstint-implementation"><code>IRConstInt</code> implementation</h6>

<p>This object is just a wrapper for constant integer values. It is also used to store metadata like if the value is signed or not, and the byte order (this maybe was a foolish decision on my side…). Since a possible optimization for obfuscated values was constant folding, I implemented the different operators on the class. The operators internally check if the values are signed or unsigned, and finally return another <code>IRConstInt</code> with the proper size:</p>

<div><div><pre><code><span>IRConstInt</span> <span>operator</span><span>+</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>a</span><span>.</span><span>is_signed</span><span>)</span>
    <span>{</span>
        <span>int64_t</span> <span>result</span> <span>=</span> <span>static_cast</span><span>&lt;</span><span>int64_t</span><span>&gt;</span><span>(</span><span>a</span><span>.</span><span>value</span><span>)</span> <span>+</span> <span>static_cast</span><span>&lt;</span><span>int64_t</span><span>&gt;</span><span>(</span><span>b</span><span>.</span><span>value</span><span>);</span>
        <span>IRConstInt</span> <span>res</span><span>(</span><span>result</span><span>,</span> <span>a</span><span>.</span><span>is_signed</span><span>,</span> <span>a</span><span>.</span><span>byte_order</span><span>,</span> <span>a</span><span>.</span><span>get_type_name</span><span>(),</span> <span>a</span><span>.</span><span>get_type_size</span><span>());</span>

        <span>return</span> <span>res</span><span>;</span>
    <span>}</span>
    <span>uint64_t</span> <span>result</span> <span>=</span> <span>a</span><span>.</span><span>value</span> <span>+</span> <span>b</span><span>.</span><span>value</span><span>;</span>

    <span>IRConstInt</span> <span>res</span><span>(</span><span>result</span><span>,</span> <span>a</span><span>.</span><span>is_signed</span><span>,</span> <span>a</span><span>.</span><span>byte_order</span><span>,</span> <span>a</span><span>.</span><span>get_type_name</span><span>(),</span> <span>a</span><span>.</span><span>get_type_size</span><span>());</span>
    <span>return</span> <span>res</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Next, the implementation of <code>IRConstInt</code>:</p>

<div><div><pre><code><span>class</span> <span>IRConstInt</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRConstInt this represent any integer used in the code.
     * @param value: value of the constant integer
     * @param is_signed: is signed value (true) or unsigned (false).
     * @param byte_order: byte order of the value.
     * @param type_name: name used for representing the value.
     * @param type_size: size of the integer.
     * @return void
     */</span>
    <span>IRConstInt</span><span>(</span><span>std</span><span>::</span><span>uint64_t</span> <span>value</span><span>,</span> <span>bool</span> <span>is_signed</span><span>,</span> <span>mem_access_t</span> <span>byte_order</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRConstInt</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>bool</span> <span>get_is_signed</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>uint64_t</span> <span>get_value_unsigned</span><span>();</span>
    <span>int64_t</span> <span>get_value_signed</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irconstint_t</span> <span>const_int</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>+</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>-</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>/</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>*</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>%</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>&amp;</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>|</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>^</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>&lt;&lt;</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>&gt;&gt;</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>IRConstInt</span> <span>&amp;</span><span>b</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>++</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>int</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>--</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>,</span> <span>int</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>!</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>);</span>
    <span>friend</span> <span>IRConstInt</span> <span>operator</span><span>~</span><span>(</span><span>IRConstInt</span> <span>&amp;</span><span>a</span><span>);</span>
<span>private:</span>
    <span>//! Value of the integer</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>value</span><span>;</span>
    <span>//! Check to know if the constant is a unsigned</span>
    <span>//! or signed value.</span>
    <span>bool</span> <span>is_signed</span><span>;</span>
    <span>//! byte order of the value.</span>
    <span>mem_access_t</span> <span>byte_order</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irmemory-implementation"><code>IRMemory</code> implementation</h6>

<p>Memory operands are specified as the memory address, an offset, a byte order and a size.</p>

<div><div><pre><code><span>class</span> <span>IRMemory</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief IRMemory constructor this represent a memory address with accessed offset and size.
     * @param mem_address: address of the memory.
     * @param offset: offset accessed (commonly 0).
     * @param byte_order: byte order of the memory (LE, BE, ME?).
     * @param type_name: memory representation with a string.
     * @param type_size: size of the memory.
     * @return void
     */</span>
    <span>IRMemory</span><span>(</span><span>std</span><span>::</span><span>uint64_t</span> <span>mem_address</span><span>,</span> <span>std</span><span>::</span><span>int32_t</span> <span>offset</span><span>,</span> <span>mem_access_t</span> <span>byte_order</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRMemory</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>get_mem_address</span><span>();</span>
    <span>std</span><span>::</span><span>int32_t</span> <span>get_offset</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irmemory_t</span> <span>memory</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRMemory</span> <span>&amp;</span><span>,</span> <span>IRMemory</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! accessed address</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>mem_address</span><span>;</span>
    <span>//! offset of the memory accessed</span>
    <span>std</span><span>::</span><span>int32_t</span> <span>offset</span><span>;</span>
    <span>//! byte order of the memory.</span>
    <span>mem_access_t</span> <span>byte_order</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irstring-implementation"><code>IRString</code> implementation</h6>

<p>Languages like C or C++, represent strings as constant strings in read-only memory, and then a pointer is used to access that data. Java-type languages use String objects. This operand is used to represent those string constant values:</p>

<div><div><pre><code><span>class</span> <span>IRString</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRString class, this represent strings used in code.
     * @param str_value: value of that string.
     * @param type_name: some meaninful string name.
     * @param type_size: size of the type (probably here string length)
     * @return void
     */</span>
    <span>IRString</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>str_value</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRString</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>get_str_value</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irstring_t</span> <span>str</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRString</span> <span>&amp;</span><span>,</span> <span>IRString</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! string value, probably nothing more will be here</span>
    <span>std</span><span>::</span><span>string</span> <span>str_value</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irclass-implementation"><code>IRClass</code> implementation</h6>

<p>For instructions like <code>IRNew</code> a class is provided as parameter to specify the object type of the created object. <code>IRClass</code> just stores the fully qualified name of the class.</p>

<div><div><pre><code><span>class</span> <span>IRClass</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRClass, this represent the name of a class
     *        that is assigned as a type.
     * @param class_name: name of the class.
     * @param type_name: should be the same value than previous one.
     * @param type_size: should be 0.
     * @return void
     */</span>
    <span>IRClass</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>class_name</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRClass</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>get_class</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irclass_t</span> <span>class_</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRClass</span> <span>&amp;</span><span>,</span> <span>IRClass</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! class name including path, used for instructions</span>
    <span>//! of type const-class</span>
    <span>std</span><span>::</span><span>string</span> <span>class_name</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="ircallee-implementation"><code>IRCallee</code> implementation</h6>

<p>In binaries created from languages like C or C++, a call specifies a register or an address where to jump, and if there are no symbols, an analysis must be done to obtain how many parameters are passed to the call. In Java-type languages, these called methods are specified by class, name and the description of the method. That description contains the return type and the parameters. MjolnIR was thought to support both, but I implemented for Dalvik, so I had all the method descriptions. <code>IRCallee</code> stores all that information:</p>

<div><div><pre><code><span>class</span> <span>IRCallee</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Constructor of IRCallee this represent any function/method called by a caller!
     * @param addr: address of the function/method called (if available).
     * @param name: name of the function/method called (if available).
     * @param class_name: name of the class from the method called (if available).
     * @param n_of_params: number of the parameters for the function/method (if available).
     * @param description: description of the parameters from the function/method (if available).
     * @param type_name: some meaninful string name.
     * @param type_size: size of the type (probably here 0)
     * @return void
     */</span>
    <span>IRCallee</span><span>(</span><span>std</span><span>::</span><span>uint64_t</span> <span>addr</span><span>,</span>
                <span>std</span><span>::</span><span>string</span> <span>name</span><span>,</span>
                <span>std</span><span>::</span><span>string</span> <span>class_name</span><span>,</span>
                <span>int</span> <span>n_of_params</span><span>,</span>
                <span>std</span><span>::</span><span>string</span> <span>description</span><span>,</span>
                <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span>
                <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRCallee</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>get_addr</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_name</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_class_name</span><span>();</span>
    <span>int</span> <span>get_number_of_params</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_description</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_str</span><span>();</span>
    <span>mem_access_t</span> <span>get_access</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>ircallee_t</span> <span>callee</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRCallee</span> <span>&amp;</span><span>,</span> <span>IRCallee</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! for those functions of binary formats we will mostly have the address</span>
    <span>//! only, these can be from a library, from the same binary, etc.</span>
    <span>std</span><span>::</span><span>uint64_t</span> <span>addr</span><span>;</span>
    <span>//! name of the callee function or method, this can be resolved from the</span>
    <span>//! binary symbols if those exist or is given in case of other formats.</span>
    <span>std</span><span>::</span><span>string</span> <span>name</span><span>;</span>
    <span>//! in case it is a method, probably we will need to know class name</span>
    <span>//! for possible analysis which requires to know about a calls.</span>
    <span>std</span><span>::</span><span>string</span> <span>class_name</span><span>;</span>
    <span>//! there are cases where functions/methods can have the same name but</span>
    <span>//! different parameters, you can give the number of parameters (if recognized)</span>
    <span>//! or the string with the description of the method</span>
    <span>int</span> <span>n_of_params</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>description</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irfield-implementation"><code>IRField</code> implementation</h6>

<p>Java-type languages are object-oriented programming languages, and we create classes, these classes can contain methods, but also they can store fields. Fields are variables global to the objects that can be used in any method. The field can have different types, and these are expressed as an enum value:</p>

<div><div><pre><code><span>enum</span> <span>field_t</span>
<span>{</span>
    <span>CLASS_F</span><span>,</span>
    <span>BOOLEAN_F</span><span>,</span>
    <span>BYTE_F</span><span>,</span>
    <span>CHAR_F</span><span>,</span>
    <span>DOUBLE_F</span><span>,</span>
    <span>FLOAT_F</span><span>,</span>
    <span>INT_F</span><span>,</span>
    <span>LONG_F</span><span>,</span>
    <span>SHORT_F</span><span>,</span>
    <span>VOID_F</span><span>,</span>
    <span>ARRAY_F</span>
<span>};</span>
</code></pre></div></div>

<p>Then the fields in Mjolnir contain the name of the class, the name of the field, the type, and in case it is a class, the name of the class.</p>

<div><div><pre><code><span>class</span> <span>IRField</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>/**
     * @brief Construct a new IRField::IRField object
     *
     * @param class_name: class name of the field
     * @param type: type from field_t
     * @param field_name: name of the field.
     * @param type_name: some meaninful string name.
     * @param type_size: size of the type (probably here 0)
     */</span>
    <span>IRField</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>class_name</span><span>,</span>
            <span>field_t</span> <span>type</span><span>,</span>
            <span>std</span><span>::</span><span>string</span> <span>field_name</span><span>,</span>
            <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span>
            <span>size_t</span> <span>type_size</span><span>);</span>
    <span>IRField</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>class_name</span><span>,</span>
            <span>std</span><span>::</span><span>string</span> <span>type_class_name</span><span>,</span>
            <span>std</span><span>::</span><span>string</span> <span>field_name</span><span>,</span>
            <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>,</span>
            <span>size_t</span> <span>type_size</span><span>);</span>
    <span>~</span><span>IRField</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>std</span><span>::</span><span>string</span> <span>get_class_name</span><span>();</span>
    <span>field_t</span> <span>get_type</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_type_class</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>get_name</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
    <span>bool</span> <span>equal</span><span>(</span><span>irfield_t</span> <span>field</span><span>);</span>
    <span>friend</span> <span>bool</span> <span>operator</span><span>==</span><span>(</span><span>IRField</span> <span>&amp;</span><span>,</span> <span>IRField</span> <span>&amp;</span><span>);</span>
<span>private:</span>
    <span>//! Class name of the field</span>
    <span>std</span><span>::</span><span>string</span> <span>class_name</span><span>;</span>
    <span>//! Type of the field</span>
    <span>field_t</span> <span>type</span><span>;</span>
    <span>//! if type is class set class name</span>
    <span>std</span><span>::</span><span>string</span> <span>type_class</span><span>;</span>
    <span>//! Field name</span>
    <span>std</span><span>::</span><span>string</span> <span>field_name</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h6 id="irfundamental-type"><code>IRFundamental</code> type</h6>

<p>In the case where we want to do data analysis and assign a type to registers or temporal registers, we can use a fundamental value. Fundamental values are provided as an enum:</p>

<div><div><pre><code><span>enum</span> <span>fundamental_t</span>
<span>{</span>
    <span>F_BOOLEAN</span><span>,</span>
    <span>F_BYTE</span><span>,</span>
    <span>F_CHAR</span><span>,</span>
    <span>F_DOUBLE</span><span>,</span>
    <span>F_FLOAT</span><span>,</span>
    <span>F_INT</span><span>,</span>
    <span>F_LONG</span><span>,</span>
    <span>F_SHORT</span><span>,</span>
    <span>F_VOID</span>
<span>};</span>
</code></pre></div></div>

<p>Finally, this fundamental object only contains this enum value.</p>

<div><div><pre><code><span>class</span> <span>IRFundamental</span> <span>:</span> <span>public</span> <span>IRType</span>
<span>{</span>
<span>public:</span>
    <span>IRFundamental</span><span>(</span><span>fundamental_t</span> <span>type</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>type_name</span><span>);</span>
    <span>~</span><span>IRFundamental</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
    <span>fundamental_t</span> <span>get_type</span><span>();</span>
    <span>std</span><span>::</span><span>string</span> <span>to_string</span><span>();</span>
<span>private:</span>
    <span>fundamental_t</span> <span>type</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h4 id="mjolnir---graph-algorithms">MjolnIR - Graph Algorithms</h4>

<p>In this part of the post, we’ll dig deeper into the graph algorithms I implemented into MjolnIR. Graph algorithms can be useful to detect possible behaviors in a control-flow graph, for example, to understand from which nodes the control-flow goes from the beginning of a method to a given node. We can also use them to go over a control-flow graph in depth or in breadth order. Most of the theory from this part will be directly extracted from the book <em>Advanced Compiler Design</em> by <em>Steven S. Muchnick</em>. This is a review of an implementation, so I think it’s okay to take the theory from a well-written book.</p>

<h5 id="dominators">Dominators</h5>

<p>Having a Control-Flow Graph, we can detect things like loops in that CFG. To do that, we need to define a relation called dominance between nodes. We have that a node <code>d</code> <em>dominates</em> a node <code>i</code> (<code>d dom i</code>), if every path from the <code>entry</code> node to the node <code>i</code> goes over <code>d</code> (ALWAYS!!!)</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/d_dom_i.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/d_dom_i.png"/>
    </a>
    <figcaption>Graph where d dominates i</figcaption>
</figure>

<p>In the previous image we can clearly see that it doesn’t matter where control comes from to <code>i</code>, it always goes through <code>d</code>.</p>

<p><code>dom</code> is a reflexive relation (every node dominates itself), transitive (if <code>a dom b</code> and <code>b dom c</code>, then <code>a dom c</code>), and also antisymmetric (if <code>a dom b</code> and <code>b dom a</code> clearly <code>a=b</code>). Later we will see another relation called <em>immediate dominance</em>. Next we can see the pseudo-code given by <em>Muchnick</em>:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/dom_pseudocode.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/dom_pseudocode.png"/>
    </a>
    <figcaption>Pseudocode from the dominance algorithm</figcaption>
</figure>

<p>Now, we will analyze the implementation used in MjolnIR. First of all, let’s see how the function was:</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>compute_dominators</span><span>(</span><span>irblock_t</span> <span>head</span><span>);</span>
</code></pre></div></div>

<p>The function returns a map with all the blocks, and for each block, the value is the list of dominator nodes. As a parameter, the head from the CFG is given as a starting point to start calculating the dominators.</p>

<p>First of all, we will calculate all the <code>reachable_sons</code> of the head block provided by parameter, these <code>reachable_sons</code> are the nodes we can reach forward from the provided node:</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>IRGraph</span><span>::</span><span>compute_dominators</span><span>(</span><span>irblock_t</span> <span>head</span><span>)</span>
<span>{</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>dominators</span><span>;</span>

    <span>auto</span> <span>nodes</span> <span>=</span> <span>reachable_sons</span><span>(</span><span>head</span><span>);</span>
</code></pre></div></div>

<p>The implementation of <code>reachable_sons</code> directly calls to <code>reachable_nodes_forward</code>, as I said, are all the nodes we can reach from the provided node, to calculate this, we will go through the successors of the head node, then from the successors we will go to their successors, and so on:</p>

<div><div><pre><code><span>Nodes</span> <span>IRGraph</span><span>::</span><span>reachable_sons</span><span>(</span><span>irblock_t</span> <span>head</span><span>)</span>
<span>{</span>
    <span>return</span> <span>IRGraph</span><span>::</span><span>reachable_nodes_forward</span><span>(</span><span>head</span><span>);</span>
<span>}</span>

<span>Nodes</span> <span>IRGraph</span><span>::</span><span>reachable_nodes_forward</span><span>(</span><span>irblock_t</span> <span>head</span><span>)</span>
<span>{</span>
    <span>Nodes</span> <span>todo</span><span>;</span>
    <span>Nodes</span> <span>reachable</span><span>;</span>

    <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>head</span><span>);</span>

    <span>while</span> <span>(</span><span>!</span><span>todo</span><span>.</span><span>empty</span><span>())</span>
    <span>{</span>
        <span>// similar to python pop.</span>
        <span>auto</span> <span>node_it</span> <span>=</span> <span>todo</span><span>.</span><span>begin</span><span>();</span>
        <span>auto</span> <span>node</span> <span>=</span> <span>*</span><span>node_it</span><span>;</span>
        <span>todo</span><span>.</span><span>erase</span><span>(</span><span>node_it</span><span>);</span>

        <span>// node already in reachable</span>
        <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>reachable</span><span>.</span><span>begin</span><span>(),</span> <span>reachable</span><span>.</span><span>end</span><span>(),</span> <span>node</span><span>)</span> <span>!=</span> <span>reachable</span><span>.</span><span>end</span><span>())</span>
            <span>continue</span><span>;</span>

        <span>reachable</span><span>.</span><span>push_back</span><span>(</span><span>node</span><span>);</span>

        <span>for</span> <span>(</span><span>auto</span> <span>next_node</span> <span>:</span> <span>get_successors</span><span>(</span><span>node</span><span>))</span>
            <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>next_node</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>reachable</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Next, similarly to the pseudocode, we will assign to each block from <code>reachable_sons</code> that same list as dominators of that node, later we will go discarding the blocks, finally the only dominator for the head node will be the head node itself (because it is a reflexive relation). We include all those nodes in a set to apply the dominance analysis in all of them:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>auto</span> <span>node</span> <span>:</span> <span>nodes</span><span>)</span>
    <span>dominators</span><span>[</span><span>node</span><span>]</span> <span>=</span> <span>nodes</span><span>;</span>

<span>dominators</span><span>[</span><span>head</span><span>]</span> <span>=</span> <span>{</span><span>head</span><span>};</span>

<span>std</span><span>::</span><span>set</span><span>&lt;</span><span>KUNAI</span><span>::</span><span>MJOLNIR</span><span>::</span><span>irblock_t</span><span>&gt;</span> <span>todo</span><span>;</span>

<span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>node</span> <span>:</span> <span>nodes</span><span>)</span>
    <span>todo</span><span>.</span><span>insert</span><span>(</span><span>node</span><span>);</span>
</code></pre></div></div>

<p>Then we have the key of the algorithm. First, we retrieve from the set the node to analyze, and we need to calculate all the predecessors of that node with a function called <code>get_predecessors</code>, for each predecessor, we have to calculate the <em>intersection</em> of their dominators (those they have in common). For example, if we have the predecessors p1, p2, p3 and p4, we will take the dominators of p1 we call it <code>dom(p1)</code>, then we will apply the intersection between <code>dom(p1)</code> and <code>dom(p2)</code>, so we will take just those elements in common, then the same with p3 <code>(dom(p1) Inter dom(p2)) Inter dom(p3)</code>, finally the same with p4. To the resulting list we will add the analyzed node itself, and in case the final list is different to the original <code>dom(node)</code>, we have the resulting dominators list from <code>node</code>, then we add all the successors from <code>node</code> and we add them to the <em>ToDo</em> list:</p>

<div><div><pre><code><span>while</span> <span>(</span><span>!</span><span>todo</span><span>.</span><span>empty</span><span>())</span>
<span>{</span>
    <span>auto</span> <span>node_it</span> <span>=</span> <span>todo</span><span>.</span><span>begin</span><span>();</span>
    <span>auto</span> <span>node</span> <span>=</span> <span>*</span><span>node_it</span><span>;</span>
    <span>todo</span><span>.</span><span>erase</span><span>(</span><span>node_it</span><span>);</span>

    <span>if</span> <span>(</span><span>node</span> <span>==</span> <span>head</span><span>)</span>
        <span>// do not use head for computing dominators</span>
        <span>continue</span><span>;</span>

    <span>// computer intersection of all predecessors&#39;dominators</span>
    <span>Nodes</span> <span>new_dom</span> <span>=</span> <span>{};</span>
    <span>for</span> <span>(</span><span>auto</span> <span>pred</span> <span>:</span> <span>get_predecessors</span><span>(</span><span>node</span><span>))</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>nodes</span><span>.</span><span>begin</span><span>(),</span> <span>nodes</span><span>.</span><span>end</span><span>(),</span> <span>pred</span><span>)</span> <span>==</span> <span>nodes</span><span>.</span><span>end</span><span>())</span> <span>// pred is not in nodes</span>
            <span>continue</span><span>;</span>

        <span>if</span> <span>(</span><span>new_dom</span><span>.</span><span>empty</span><span>())</span>
            <span>new_dom</span> <span>=</span> <span>dominators</span><span>[</span><span>pred</span><span>];</span>

        <span>Nodes</span> <span>intersect_aux</span><span>;</span>

        <span>std</span><span>::</span><span>set_intersection</span><span>(</span><span>new_dom</span><span>.</span><span>begin</span><span>(),</span> <span>new_dom</span><span>.</span><span>end</span><span>(),</span>
                              <span>dominators</span><span>[</span><span>pred</span><span>].</span><span>begin</span><span>(),</span> <span>dominators</span><span>[</span><span>pred</span><span>].</span><span>end</span><span>(),</span>
                              <span>std</span><span>::</span><span>inserter</span><span>(</span><span>intersect_aux</span><span>,</span> <span>intersect_aux</span><span>.</span><span>begin</span><span>()));</span>

        <span>new_dom</span> <span>=</span> <span>intersect_aux</span><span>;</span>
    <span>}</span>

    <span>new_dom</span><span>.</span><span>push_back</span><span>(</span><span>node</span><span>);</span>

    <span>if</span> <span>(</span><span>new_dom</span> <span>==</span> <span>dominators</span><span>[</span><span>node</span><span>])</span>
        <span>continue</span><span>;</span>

    <span>dominators</span><span>[</span><span>node</span><span>]</span> <span>=</span> <span>new_dom</span><span>;</span>
    <span>for</span> <span>(</span><span>auto</span> <span>succ</span> <span>:</span> <span>get_successors</span><span>(</span><span>node</span><span>))</span>
        <span>todo</span><span>.</span><span>insert</span><span>(</span><span>succ</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>And finally, our map will contain for each node, the list of dominators! Pseudocode commonly uses mathematical notation, and it is common that algorithms expressed with this notation use things like recursion, but in languages like C++ using this can make memory usage grow because each call to the same function will create a new stack, and more memory will be used.</p>

<p>We can read one example of using this algorithm by Tim Blazytko - <a href="https://www.synthesis.to/2021/03/15/control_flow_analysis.html">Introduction to Control-flow Graph Analysis</a>.</p>

<h5 id="post-dominators">Post-dominators</h5>

<p>Another concept we have is the post-dominators. We say that a node <code>p</code> <em>postdominates</em> a node <code>i</code>, written <code>p pdom i</code>, if every possible execution path from <code>i</code> to <code>exit</code> node includes <code>p</code>, this is the same that saying <code>i dom p</code> in a CFG with all the edges reversed and <code>entry</code> and <code>exit</code> interchanged. Next I post the pseudocode algorithm from the paper <a href="https://dl.acm.org/doi/pdf/10.1145/143165.143216">Generalized Dominators and Post-dominators</a>.</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/post-dom-algorithm.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/post-dom-algorithm.png"/>
    </a>
    <figcaption>Pseudocode from the post-dominance algorithm</figcaption>
</figure>

<p>This time the function that implements the algorithm instead of receiving as a parameter the head of the CFG, it receives a leaf from the CFG:</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>compute_postdominators</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>);</span>
</code></pre></div></div>

<p>And now we reverse the calls, where we called <code>reachable_sons</code> now we call <code>reachable_parents</code>, where we had a call to <code>get_predecessors</code> we will have a call to <code>get_successors</code>, and vice versa.</p>

<p>First of all from the leaf retrieve all the parents, this is a call that calls the function <code>reachable_nodes_backward</code> which retrieves the predecessors, and the predecessors of the predecessors, etc.:</p>

<div><div><pre><code><span>Nodes</span> <span>IRGraph</span><span>::</span><span>reachable_parents</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>)</span>
<span>{</span>
    <span>return</span> <span>IRGraph</span><span>::</span><span>reachable_nodes_backward</span><span>(</span><span>leaf</span><span>);</span>
<span>}</span>

<span>Nodes</span> <span>IRGraph</span><span>::</span><span>reachable_nodes_backward</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>)</span>
<span>{</span>
    <span>Nodes</span> <span>todo</span><span>;</span>
    <span>Nodes</span> <span>reachable</span><span>;</span>

    <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>leaf</span><span>);</span>

    <span>while</span> <span>(</span><span>!</span><span>todo</span><span>.</span><span>empty</span><span>())</span>
    <span>{</span>
        <span>// similar to python pop.</span>
        <span>auto</span> <span>node_it</span> <span>=</span> <span>todo</span><span>.</span><span>begin</span><span>();</span>
        <span>auto</span> <span>node</span> <span>=</span> <span>*</span><span>node_it</span><span>;</span>
        <span>todo</span><span>.</span><span>erase</span><span>(</span><span>node_it</span><span>);</span>

        <span>// node already in reachable</span>
        <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>reachable</span><span>.</span><span>begin</span><span>(),</span> <span>reachable</span><span>.</span><span>end</span><span>(),</span> <span>node</span><span>)</span> <span>!=</span> <span>reachable</span><span>.</span><span>end</span><span>())</span>
            <span>continue</span><span>;</span>

        <span>reachable</span><span>.</span><span>push_back</span><span>(</span><span>node</span><span>);</span>

        <span>for</span> <span>(</span><span>auto</span> <span>next_node</span> <span>:</span> <span>get_predecessors</span><span>(</span><span>node</span><span>))</span>
            <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>next_node</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>reachable</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>After getting all the reachable parents, the algorithm assigns to all the nodes from the list, that list as post-dominators, assigning to the provided leaf node that same node as post-dominator.</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>IRGraph</span><span>::</span><span>compute_postdominators</span><span>(</span><span>irblock_t</span> <span>leaf</span><span>)</span>
<span>{</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>postdominators</span><span>;</span>

    <span>auto</span> <span>nodes</span> <span>=</span> <span>reachable_parents</span><span>(</span><span>leaf</span><span>);</span>

    <span>for</span> <span>(</span><span>auto</span> <span>node</span> <span>:</span> <span>nodes</span><span>)</span>
        <span>postdominators</span><span>[</span><span>node</span><span>]</span> <span>=</span> <span>nodes</span><span>;</span>

    <span>postdominators</span><span>[</span><span>leaf</span><span>]</span> <span>=</span> <span>{</span><span>leaf</span><span>};</span>
</code></pre></div></div>

<p>Then, as we did with dominators, we must create a <em>ToDo</em> list to go through the nodes calculating the post-dominators from each node. This time, for the analyzed node, we will retrieve the successors, and we will apply the intersection of their post-dominators, then once we have applied the intersection to all the post-dominators of the successors, we add the node itself as a post-dominator, and we add its predecessors to the <em>ToDo</em> list. And with that, we will have the post-dominators algorithm!</p>

<div><div><pre><code><span>Nodes</span> <span>todo</span> <span>=</span> <span>nodes</span><span>;</span>

<span>while</span> <span>(</span><span>!</span><span>todo</span><span>.</span><span>empty</span><span>())</span>
<span>{</span>
    <span>auto</span> <span>node_it</span> <span>=</span> <span>todo</span><span>.</span><span>begin</span><span>();</span>
    <span>auto</span> <span>node</span> <span>=</span> <span>*</span><span>node_it</span><span>;</span>
    <span>todo</span><span>.</span><span>erase</span><span>(</span><span>node_it</span><span>);</span>

    <span>if</span> <span>(</span><span>node</span> <span>==</span> <span>leaf</span><span>)</span>
        <span>// do not use head for computing dominators</span>
        <span>continue</span><span>;</span>

    <span>// computer intersection of all predecessors&#39;dominators</span>
    <span>Nodes</span> <span>new_dom</span> <span>=</span> <span>{};</span>
    <span>for</span> <span>(</span><span>auto</span> <span>succ</span> <span>:</span> <span>get_successors</span><span>(</span><span>node</span><span>))</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>nodes</span><span>.</span><span>begin</span><span>(),</span> <span>nodes</span><span>.</span><span>end</span><span>(),</span> <span>succ</span><span>)</span> <span>==</span> <span>nodes</span><span>.</span><span>end</span><span>())</span> <span>// pred is not in nodes</span>
            <span>continue</span><span>;</span>
        <span>if</span> <span>(</span><span>new_dom</span><span>.</span><span>empty</span><span>())</span>
            <span>new_dom</span> <span>=</span> <span>postdominators</span><span>[</span><span>succ</span><span>];</span>

        <span>Nodes</span> <span>intersect_aux</span><span>;</span>
        <span>std</span><span>::</span><span>set_intersection</span><span>(</span><span>new_dom</span><span>.</span><span>begin</span><span>(),</span> <span>new_dom</span><span>.</span><span>end</span><span>(),</span>
                              <span>postdominators</span><span>[</span><span>succ</span><span>].</span><span>begin</span><span>(),</span> <span>postdominators</span><span>[</span><span>succ</span><span>].</span><span>end</span><span>(),</span>
                              <span>std</span><span>::</span><span>inserter</span><span>(</span><span>intersect_aux</span><span>,</span> <span>intersect_aux</span><span>.</span><span>begin</span><span>()));</span>
        <span>new_dom</span> <span>=</span> <span>intersect_aux</span><span>;</span>
    <span>}</span>

    <span>new_dom</span><span>.</span><span>push_back</span><span>(</span><span>node</span><span>);</span>

    <span>if</span> <span>(</span><span>new_dom</span> <span>==</span> <span>postdominators</span><span>[</span><span>node</span><span>])</span>
        <span>continue</span><span>;</span>

    <span>postdominators</span><span>[</span><span>node</span><span>]</span> <span>=</span> <span>new_dom</span><span>;</span>
    <span>for</span> <span>(</span><span>auto</span> <span>pred</span> <span>:</span> <span>get_predecessors</span><span>(</span><span>node</span><span>))</span>
        <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>pred</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<h5 id="immediate-dominators">Immediate Dominators</h5>

<p>Before I wrote about the definition of dominators, but we can define a subrelation called <em>immediate dominance</em> (known as <code>idom</code>) such that for a node <code>a</code> different to node <code>b</code>, <code>a idom b</code> if and only if <code>a dom b</code> and it does not exist a node <code>c</code> different to <code>a</code> and different to <code>b</code>, for which <code>a dom c</code> and <code>c dom b</code>, so a dominator of <code>b</code> such that there’s not another dominator node in the middle (for that reason immediate…). And we write it as <code>idom(b)</code>. This dominator is an immediate dominator and is clearly unique, and the relation forms a tree of the nodes of a flow-graph whose root is the entry node, whose edges are the immediate dominances, and whose paths display all the dominance relationship. I think this explanation by Muchnick is clear enough. We can see the generated tree of immediate dominators in the next image:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/immediate-dominators-tree.jpg">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/immediate-dominators-tree.jpg"/>
    </a>
    <figcaption>Tree of immediate dominators from a graph (taken from the slides &#34;Dominators and CFGs&#34; from University of Delaware Compiler Notes.</figcaption>
</figure>

<p>Muchnick for calculating the immediate dominators use the previously calculated dominators, we can see it in the next pseudocode:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/immediate-dominator-algorithm.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/immediate-dominator-algorithm.png"/>
    </a>
    <figcaption>Pseudocode of immediate dominators algorithm.</figcaption>
</figure>

<p>This time MjolnIR’s function to calculate immediate dominators, returns a map, but the map is only a pair of nodes to map one node with its immediate dominator:</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>compute_immediate_dominators</span><span>();</span>
</code></pre></div></div>

<p>The first thing we do for calculating the immediate dominators is calculating the dominators as we have already seen in the pseudocode:</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>IRGraph</span><span>::</span><span>compute_immediate_dominators</span><span>()</span>
<span>{</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>tmp</span><span>;</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>idom</span><span>;</span>

    <span>if</span> <span>(</span><span>nodes</span><span>.</span><span>size</span><span>()</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>idom</span><span>;</span>

    <span>auto</span> <span>first_node</span> <span>=</span> <span>nodes</span><span>[</span><span>0</span><span>];</span>

    <span>// compute the dominators</span>
    <span>tmp</span> <span>=</span> <span>compute_dominators</span><span>(</span><span>first_node</span><span>);</span>
</code></pre></div></div>

<p>Then, from the list of dominators of each node, we remove the node itself from that list:</p>

<div><div><pre><code><span>// remove itself from dominators</span>
<span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>item</span> <span>:</span> <span>tmp</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>rem</span> <span>=</span> <span>std</span><span>::</span><span>find</span><span>(</span><span>item</span><span>.</span><span>second</span><span>.</span><span>begin</span><span>(),</span> <span>item</span><span>.</span><span>second</span><span>.</span><span>end</span><span>(),</span> <span>item</span><span>.</span><span>first</span><span>);</span>

    <span>if</span> <span>(</span><span>rem</span> <span>!=</span> <span>item</span><span>.</span><span>second</span><span>.</span><span>end</span><span>())</span>
        <span>item</span><span>.</span><span>second</span><span>.</span><span>erase</span><span>(</span><span>rem</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The algorithm then takes a node for the analysis. From that node, we will use the dominator list of its dominators to obtain the immediate dominators. We can clearly see it with an example from Muchnick’s book, first we have a list of dominators for each node:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/idom-1.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/idom-1.png"/>
    </a>
    <figcaption>Tmp initialize with dominators, without the node itself.</figcaption>
</figure>

<p>Now, we go to <code>B1</code>, from <code>B1</code> from the list of dominators of <code>B1</code> (<code>{entry}</code>) we will remove the dominators from its dominators (in this case <code>entry</code>), because the list of its dominators is empty, the <code>idom(B1)</code> is <code>{entry}</code>. Now we go with <code>B2</code>, we have its list of dominators <code>{entry, B1}</code>, now we will go over the dominators list of its dominators (<code>B1</code> and <code>entry</code>) and we will remove the node that appears in those lists. The current <code>dom(B1)</code> now it is only <code>{entry}</code>, and we have that <code>dom(B2) = {entry, B1}</code>, we remove <code>{entry}</code> and we have that <code>dom(B2) = {B1}</code>, because the <code>dom(entry)</code> is empty, the algorithm is finished. We apply the same algorithm with all the next nodes. The C++ code for this is as follows:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>auto</span> <span>n</span> <span>:</span> <span>nodes</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>auto</span> <span>s</span> <span>:</span> <span>tmp</span><span>[</span><span>n</span><span>])</span>
    <span>{</span>
        <span>for</span> <span>(</span><span>auto</span> <span>t</span> <span>:</span> <span>tmp</span><span>[</span><span>n</span><span>])</span>
        <span>{</span>
            <span>if</span> <span>(</span><span>t</span> <span>==</span> <span>s</span><span>)</span>
                <span>continue</span><span>;</span>

            <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>tmp</span><span>[</span><span>s</span><span>].</span><span>begin</span><span>(),</span> <span>tmp</span><span>[</span><span>s</span><span>].</span><span>end</span><span>(),</span> <span>t</span><span>)</span> <span>!=</span> <span>tmp</span><span>[</span><span>s</span><span>].</span><span>end</span><span>())</span>
            <span>{</span>
                <span>auto</span> <span>rem</span> <span>=</span> <span>std</span><span>::</span><span>find</span><span>(</span><span>tmp</span><span>[</span><span>n</span><span>].</span><span>begin</span><span>(),</span> <span>tmp</span><span>[</span><span>n</span><span>].</span><span>end</span><span>(),</span> <span>t</span><span>);</span>

                <span>if</span> <span>(</span><span>rem</span> <span>!=</span> <span>tmp</span><span>[</span><span>n</span><span>].</span><span>end</span><span>())</span>
                    <span>tmp</span><span>[</span><span>n</span><span>].</span><span>erase</span><span>(</span><span>rem</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Finally, if the <code>tmp</code> list is not empty, we have that the last node from that list of dominators will be the immediate dominator. In the example from Muchnick we have the next final list:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/idom-2.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/idom-2.png"/>
    </a>
    <figcaption>List of immediate dominators for each node.</figcaption>
</figure>

<p>We implement it in C++ like so:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>auto</span> <span>n</span> <span>:</span> <span>nodes</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>tmp</span><span>[</span><span>n</span><span>].</span><span>size</span><span>()</span> <span>&gt;=</span> <span>1</span><span>)</span>
        <span>idom</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>tmp</span><span>[</span><span>n</span><span>][</span><span>tmp</span><span>[</span><span>n</span><span>].</span><span>size</span><span>()</span> <span>-</span> <span>1</span><span>];</span>
    <span>else</span>
        <span>idom</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>nullptr</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>idom</code> map contains for each node the immediate dominators.</p>

<p>We can go again to Tim Blazytko’s blog again, and see how to use immediate dominators for <a href="https://synthesis.to/2021/03/03/flattening_detection.html">Automated Detection of Control-flow Flattening</a>.</p>

<h5 id="immediate-post-dominators">Immediate Post-dominators</h5>

<p>Similarly to Immediate Dominators, we have the concept of Immediate Post-Dominators. The algorithm is basically the same but getting the post-dominators instead of the dominators, so here we can just check the algorithm with the explanation from the previous point:</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>IRGraph</span><span>::</span><span>compute_immediate_postdominators</span><span>()</span>
<span>{</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>Nodes</span><span>&gt;</span> <span>tmp</span><span>;</span>
    <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irblock_t</span><span>&gt;</span> <span>ipdom</span><span>;</span>

    <span>if</span> <span>(</span><span>nodes</span><span>.</span><span>size</span><span>()</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>ipdom</span><span>;</span>

    <span>// compute post dominators</span>
    <span>auto</span> <span>last_node</span> <span>=</span> <span>nodes</span><span>.</span><span>back</span><span>();</span>

    <span>tmp</span> <span>=</span> <span>compute_postdominators</span><span>(</span><span>last_node</span><span>);</span>

    <span>// remove itself from postdominators</span>
    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>item</span> <span>:</span> <span>tmp</span><span>)</span>
    <span>{</span>
        <span>auto</span> <span>rem</span> <span>=</span> <span>std</span><span>::</span><span>find</span><span>(</span><span>item</span><span>.</span><span>second</span><span>.</span><span>begin</span><span>(),</span> <span>item</span><span>.</span><span>second</span><span>.</span><span>end</span><span>(),</span> <span>item</span><span>.</span><span>first</span><span>);</span>

        <span>if</span> <span>(</span><span>rem</span> <span>!=</span> <span>item</span><span>.</span><span>second</span><span>.</span><span>end</span><span>())</span>
            <span>item</span><span>.</span><span>second</span><span>.</span><span>erase</span><span>(</span><span>rem</span><span>);</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>n</span> <span>:</span> <span>nodes</span><span>)</span>
    <span>{</span>
        <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>s</span> <span>:</span> <span>tmp</span><span>[</span><span>n</span><span>])</span> <span>// get the post dominators</span>
        <span>{</span>
            <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>t</span> <span>:</span> <span>tmp</span><span>[</span><span>n</span><span>])</span> <span>// get again the post dominators except for s</span>
            <span>{</span>
                <span>if</span> <span>(</span><span>t</span> <span>==</span> <span>s</span><span>)</span>
                    <span>continue</span><span>;</span>

                <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>tmp</span><span>[</span><span>s</span><span>].</span><span>begin</span><span>(),</span> <span>tmp</span><span>[</span><span>s</span><span>].</span><span>end</span><span>(),</span> <span>t</span><span>)</span> <span>!=</span> <span>tmp</span><span>[</span><span>s</span><span>].</span><span>end</span><span>())</span>
                <span>{</span>
                    <span>auto</span> <span>rem</span> <span>=</span> <span>std</span><span>::</span><span>find</span><span>(</span><span>tmp</span><span>[</span><span>n</span><span>].</span><span>begin</span><span>(),</span> <span>tmp</span><span>[</span><span>n</span><span>].</span><span>end</span><span>(),</span> <span>t</span><span>);</span>

                    <span>if</span> <span>(</span><span>rem</span> <span>!=</span> <span>tmp</span><span>[</span><span>n</span><span>].</span><span>end</span><span>())</span>
                        <span>tmp</span><span>[</span><span>n</span><span>].</span><span>erase</span><span>(</span><span>rem</span><span>);</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>auto</span> <span>n</span> <span>:</span> <span>nodes</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>tmp</span><span>[</span><span>n</span><span>].</span><span>size</span><span>()</span> <span>&gt;=</span> <span>1</span><span>)</span>
            <span>ipdom</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>tmp</span><span>[</span><span>n</span><span>][</span><span>tmp</span><span>[</span><span>n</span><span>].</span><span>size</span><span>()</span> <span>-</span> <span>1</span><span>];</span>
        <span>else</span>
            <span>ipdom</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>nullptr</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>ipdom</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h5 id="dominance-frontier">Dominance Frontier</h5>

<p>We can find this concept in the paper <a href="https://www.cs.utexas.edu/~pingali/CS380C/2010/papers/ssaCytron.pdf"><em>Efficiently Computing Static Single Assignment Form and the Control Dependence Graph</em></a> by Cytron et al. We have that a <em>dominance frontier</em> (commonly written as <code>DF(X)</code>) of a CFG node <code>X</code> is the set of all CFG nodes <code>Y</code> such that <code>X</code> dominates a predecessor of <code>Y</code> but does not strictly dominate <code>Y</code>. What does “Strictly dominate” mean? We can return to Muchnick, after explaining immediate dominators it says <em>“We say that d strictly dominates i, written d sdom i, if d dominates i and d is different to i”</em>. This algorithm of Dominance Frontier is commonly used to place the Phi functions (already explained in the instructions for MjolnIR). Next, the pseudocode of Dominance Frontier by Cytron et al.</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/cytron_df.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/cytron_df.png"/>
    </a>
    <figcaption>Pseudocode of Dominance Frontier by Cytron et al.</figcaption>
</figure>

<p>Now we will see the algorithm in MjolnIR used to obtain the dominance frontier; the algorithm is a C++ version of the one used in <code>Miasm</code>.</p>

<p>First of all, the algorithm computes the immediate dominators, with the immediate dominator tree. It will be easy to see which nodes dominate one of the analyzed node’s predecessors, and do not strictly dominate the analyzed node.</p>

<div><div><pre><code><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>std</span><span>::</span><span>set</span><span>&lt;</span><span>irblock_t</span><span>&gt;&gt;</span> <span>IRGraph</span><span>::</span><span>compute_dominance_frontier</span><span>()</span>
<span>{</span>
    <span>/*
     * Compute the immediate dominators from all the
     * nodes.
     */</span>
    <span>auto</span> <span>idoms</span> <span>=</span> <span>compute_immediate_dominators</span><span>();</span>
</code></pre></div></div>

<p>Since the Dominance Frontier will be used to detect places where to write phi instructions, we will need to get the dominance frontier from the convergence nodes (those with two or more predecessors). The way we do that is checking the predecessors from the nodes from the <code>idom</code> tree:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>idom</span> <span>:</span> <span>idoms</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>predecessors</span><span>.</span><span>find</span><span>(</span><span>idom</span><span>.</span><span>first</span><span>)</span> <span>==</span> <span>predecessors</span><span>.</span><span>end</span><span>()</span> <span>||</span> <span>predecessors</span><span>.</span><span>at</span><span>(</span><span>idom</span><span>.</span><span>first</span><span>).</span><span>size</span><span>()</span> <span>&lt;</span> <span>2</span><span>)</span>
        <span>continue</span><span>;</span>
</code></pre></div></div>

<p>Then, we go through the predecessors from the analyzed node (<code>idom.first</code> the key from the map of immediate dominators). For each predecessor we will check if it is in the <code>idoms</code> tree. Then we will go through the <code>idom</code> tree from the current node, and from the predecessors. Inside of this loop we have to check if we are in a loop, because we are using predecessors. If we are in a loop, this loop would run forever. After that, we add in the frontier of the <code>predecessor</code> the current analyzed node, and we take the <code>idom</code> from the current predecessor as the new predecessor.</p>

<div><div><pre><code><span>for</span> <span>(</span><span>auto</span> <span>predecessor</span> <span>:</span> <span>predecessors</span><span>[</span><span>idom</span><span>.</span><span>first</span><span>])</span>
<span>{</span>
    <span>if</span> <span>(</span><span>idoms</span><span>.</span><span>find</span><span>(</span><span>predecessor</span><span>)</span> <span>==</span> <span>idoms</span><span>.</span><span>end</span><span>())</span>
        <span>continue</span><span>;</span>

    <span>while</span> <span>(</span><span>predecessor</span> <span>!=</span> <span>idom</span><span>.</span><span>second</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>frontier</span><span>[</span><span>predecessor</span><span>].</span><span>find</span><span>(</span><span>idom</span><span>.</span><span>first</span><span>)</span> <span>!=</span> <span>frontier</span><span>[</span><span>predecessor</span><span>].</span><span>end</span><span>())</span>
            <span>break</span><span>;</span>

        <span>frontier</span><span>[</span><span>predecessor</span><span>].</span><span>insert</span><span>(</span><span>idom</span><span>.</span><span>first</span><span>);</span>

        <span>predecessor</span> <span>=</span> <span>idoms</span><span>[</span><span>predecessor</span><span>];</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>We will later use this frontier to calculate where to write the phi nodes when moving from the current IR to an SSA-form.</p>

<h5 id="depth-first-search">Depth-First Search</h5>

<p>After explaining a few complicated algorithms, we will move to something simpler. Depth-First search, and Breadth-First Search, these algorithms are useful to go through the control-flow graph using two different approaches. While in MjolnIR these two algorithms are used to retrieve the list of nodes sorted, in Muchnick’s book these are used to apply transformations before or after visiting the nodes. Four different transformations are explained:</p>

<ol>
  <li>Process_Before() to perform an action before visiting each node.</li>
  <li>Process_After() to perform an action after visiting each node.</li>
  <li>Process_Succ_Before() to perform an action before visiting each successor of a node.</li>
  <li>Process_Succ_After() to perform an action after visiting each successor of a node.</li>
</ol>

<p>In the case of Depth-First Search, the algorithm visits the descendents of a node in the graph before visiting any of its siblings that are not also descendents.</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/dfs.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/dfs.png"/>
    </a>
    <figcaption>Order of visiting nodes in a tree using Depth-First Search (image from wikipedia).</figcaption>
</figure>

<p>Next the algorithm by Muchnick:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/dfs-algorithm.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/dfs-algorithm.png"/>
    </a>
    <figcaption>Pseudocode of Depth-First Search.</figcaption>
</figure>

<p>The algorithm is easy to implement using an iterative algorithm, we create a <em>ToDo</em> list for the analysis with the head of the graph. From the <em>ToDo</em> list we will take the nodes from the back of the list, in that way we always go to the successors. Finally, we retrieve the successors, and we add it to the <em>ToDo</em> list in reverse order, so once we obtain the back from the <em>ToDo</em> list, we will retrieve the first successor.</p>

<div><div><pre><code><span>Nodes</span> <span>IRGraph</span><span>::</span><span>Depth_First_Search</span><span>(</span><span>irblock_t</span> <span>head</span><span>)</span>
<span>{</span>
    <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>todo</span><span>;</span>
    <span>Nodes</span> <span>done</span><span>;</span>

    <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>head</span><span>);</span>

    <span>while</span> <span>(</span><span>!</span><span>todo</span><span>.</span><span>empty</span><span>())</span>
    <span>{</span>
        <span>// pop last element</span>
        <span>auto</span> <span>node</span> <span>=</span> <span>todo</span><span>.</span><span>back</span><span>();</span>
        <span>todo</span><span>.</span><span>pop_back</span><span>();</span>

        <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>done</span><span>.</span><span>begin</span><span>(),</span> <span>done</span><span>.</span><span>end</span><span>(),</span> <span>node</span><span>)</span> <span>!=</span> <span>done</span><span>.</span><span>end</span><span>())</span>
            <span>continue</span><span>;</span>

        <span>done</span><span>.</span><span>push_back</span><span>(</span><span>node</span><span>);</span>

        <span>// push the nodes in reverse order</span>
        <span>// so we go from left to right in depth</span>
        <span>auto</span> <span>succs</span> <span>=</span> <span>get_successors</span><span>(</span><span>node</span><span>);</span>
        <span>for</span> <span>(</span><span>auto</span> <span>succ</span> <span>=</span> <span>succs</span><span>.</span><span>rbegin</span><span>();</span> <span>succ</span> <span>!=</span> <span>succs</span><span>.</span><span>rend</span><span>();</span> <span>++</span><span>succ</span><span>)</span>
            <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>*</span><span>succ</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>done</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h5 id="breadth-first-search">Breadth-First Search</h5>

<p>Next, we have the Breadth-First Search. In this algorithm, all nodes that are immediate descendants are processed before any of their unprocessed descendants. Next is Muchnick’s algorithm using recursion:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/bfs.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/bfs.png"/>
    </a>
    <figcaption>Pseudocode of Breadth-First Search.</figcaption>
</figure>

<p>And a visual representation of how visiting a tree using a breadth-first search algorithm is:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/bfs-representation.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/bfs-representation.png"/>
    </a>
    <figcaption>Tree representation of Breadth-First Search algorithm.</figcaption>
</figure>

<p>Now the implementation in C++, this is even simpler to the previous one, we just create a list with the head of the graph, and then retrieve the successors and add it to the list , in that way we will always go in a breadth-first order:</p>

<div><div><pre><code><span>Nodes</span> <span>IRGraph</span><span>::</span><span>Breadth_First_Search</span><span>(</span><span>irblock_t</span> <span>head</span><span>)</span>
<span>{</span>
    <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>todo</span><span>;</span>
    <span>Nodes</span> <span>done</span><span>;</span>

    <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>head</span><span>);</span>

    <span>while</span> <span>(</span><span>!</span><span>todo</span><span>.</span><span>empty</span><span>())</span>
    <span>{</span>
        <span>// pop first element</span>
        <span>auto</span> <span>node</span> <span>=</span> <span>todo</span><span>.</span><span>front</span><span>();</span>
        <span>todo</span><span>.</span><span>pop_front</span><span>();</span>

        <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>done</span><span>.</span><span>begin</span><span>(),</span> <span>done</span><span>.</span><span>end</span><span>(),</span> <span>node</span><span>)</span> <span>!=</span> <span>done</span><span>.</span><span>end</span><span>())</span>
            <span>continue</span><span>;</span>

        <span>done</span><span>.</span><span>push_back</span><span>(</span><span>node</span><span>);</span>

        <span>for</span> <span>(</span><span>auto</span> <span>succ</span> <span>:</span> <span>get_successors</span><span>(</span><span>node</span><span>))</span>
            <span>todo</span><span>.</span><span>push_back</span><span>(</span><span>succ</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>done</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h5 id="cyclomatic-complexity">Cyclomatic Complexity</h5>

<p>This metric by Thomas J. McCabe allows to know the complexity of a program, or in the case of MjolnIR, to detect the complexity of a Dalvik method using the IR. We can consult it in <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">wikipedia</a> for example, where we can find an equation for the complexity: <code>M = E - N + 2P</code>, where <code>M</code> is the complexity, <code>E</code> the number of edges, <code>N</code> the number of nodes in the graph and <code>P</code> the number of connected components.</p>

<p>The implementation of MjolnIR is based on the implementation from Radare2, to calculate the strongly connected components, we just count those nodes that contain a return statement:</p>

<div><div><pre><code><span>const</span> <span>std</span><span>::</span><span>uint64_t</span> <span>IRGraph</span><span>::</span><span>get_cyclomatic_complexity</span><span>()</span>
<span>{</span>
    <span>if</span> <span>(</span><span>cyclomatic_complexity</span> <span>!=</span> <span>-</span><span>1</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>cyclomatic_complexity</span><span>;</span>
    <span>}</span>

    <span>auto</span> <span>logger</span> <span>=</span> <span>LOGGER</span><span>::</span><span>logger</span><span>();</span>

    <span>// take a copy of nodes and edges</span>
    <span>auto</span> <span>&amp;</span><span>nodes_aux</span> <span>=</span> <span>nodes</span><span>;</span>
    <span>auto</span> <span>&amp;</span><span>edges_aux</span> <span>=</span> <span>edges</span><span>;</span>

    <span>auto</span> <span>E</span> <span>=</span> <span>edges_aux</span><span>.</span><span>size</span><span>();</span>
    <span>auto</span> <span>N</span> <span>=</span> <span>nodes_aux</span><span>.</span><span>size</span><span>();</span>

    <span>size_t</span> <span>P</span> <span>=</span> <span>0</span><span>;</span>

    <span>// Go through all the nodes to calculate those</span>
    <span>// which are exit nodes</span>
    <span>for</span> <span>(</span><span>auto</span> <span>node</span> <span>:</span> <span>nodes_aux</span><span>)</span>
    <span>{</span>
        <span>auto</span> <span>statements</span> <span>=</span> <span>node</span><span>-&gt;</span><span>get_statements</span><span>();</span>
        <span>// check all instructions</span>
        <span>for</span> <span>(</span><span>auto</span> <span>stmnt</span> <span>:</span> <span>statements</span><span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span><span>ret_ir</span><span>(</span><span>stmnt</span><span>))</span>
            <span>{</span>
                <span>P</span> <span>+=</span> <span>1</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>cyclomatic_complexity</span> <span>=</span> <span>E</span> <span>-</span> <span>N</span> <span>+</span> <span>P</span> <span>*</span> <span>2</span><span>;</span>

    <span>logger</span><span>-&gt;</span><span>info</span><span>(</span><span>&#34;Calculated cyclomatic complexity: {}&#34;</span><span>,</span> <span>cyclomatic_complexity</span><span>);</span>

    <span>return</span> <span>cyclomatic_complexity</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h5 id="reaching-definition">Reaching Definition</h5>

<p>Before explaining something like <em>def-use/use-def chains</em> I need to define the concept of <em>reading definition</em>. Again, we will go to Muchnick’s book to know what is this reaching definition. First of all, a definition is an assignment of some value to a variable. We say the definition reaches a given point in a method if there is an execution path from the definition to that point such that the variable may have, at that point, the value assigned by the definition. This is, from the definition, to the selected point, there’s not a redefinition of the value. The next picture shows a very simple pseudocode of that algorithm from the next link https://www.csd.uwo.ca/~mmorenom/CS447/Lectures/CodeOptimization.html/node7.html:</p>

<figure>
    <a href="https://loeber.substack.com/assets/images/kunai_ir/reaching-def-alg.png">
        <img src="https://loeber.substack.com/assets/images/kunai_ir/reaching-def-alg.png"/>
    </a>
    <figcaption>Pseudocode from Reaching definition analysis.</figcaption>
</figure>

<p>This analysis is a bit more complex, so I implemented in MjolnIR it in a whole class. First of all, the algorithm involves creating a few types to store certain data. For example, we will have <code>blockinstrtuple_t</code> that is used to store the id of a basic block, and the id of an instruction:</p>

<div><div><pre><code><span>using</span> <span>blockinstrtuple_t</span> <span>=</span> <span>std</span><span>::</span><span>tuple</span><span>&lt;</span>
    <span>std</span><span>::</span><span>uint32_t</span><span>,</span> <span>// block id</span>
    <span>std</span><span>::</span><span>uint32_t</span>  <span>// instruction id</span>
    <span>&gt;</span><span>;</span>
</code></pre></div></div>

<p>This tuple of data is used for storing something I called <code>regdefinitionmap_t</code> which stores the register or temporal register or whatever is defined as an <code>IRExpr</code> and the place where it is defined:</p>

<div><div><pre><code><span>using</span> <span>regdefinitionmap_t</span> <span>=</span> <span>std</span><span>::</span><span>map</span><span>&lt;</span>
    <span>irexpr_t</span><span>,</span> <span>// reg or temp reg</span>
    <span>blockinstrtuple_t</span><span>&gt;</span><span>;</span>
</code></pre></div></div>

<p>Finally, MjolnIR’s code contains a set of <code>regdefinitionmap_t</code> called <code>regdefinitionset_t</code>, and each instruction <code>blockinstrtuple_t</code> will contain a <code>regdefinitionset_t</code> in a type called <code>reachingdeftype_t</code>:</p>

<div><div><pre><code><span>using</span> <span>reachingdeftype_t</span> <span>=</span> <span>std</span><span>::</span><span>map</span><span>&lt;</span>
    <span>blockinstrtuple_t</span><span>,</span>
    <span>regdefinitionset_t</span><span>&gt;</span><span>;</span>
</code></pre></div></div>

<p>Next, the definition of the functions that will compute the reaching definition, the analysis involves understanding what the instructions do, since different instructions can be used to define a value.</p>

<div><div><pre><code><span>class</span> <span>ReachingDefinition</span> <span>{</span>
    <span>...</span>
    <span>/**
     * @brief Compute the reaching definition of the IRGraph given
     *        for each line we will have a definition of where variables
     *        are defined, and this is nice, because it will be useful
     *        to calculate the def-use and use-def chains.
     *
     */</span>
    <span>void</span> <span>compute</span><span>();</span>
    
    <span>/**
     * @brief Analyze a block looking for definitions and updating the global
     *        reaching definitions object.
     *
     * @param block block to analyze.
     */</span>
    <span>bool</span> <span>analyze_block</span><span>(</span><span>irblock_t</span> <span>&amp;</span><span>block</span><span>);</span>

     <span>/**
     * @brief Analyze the given instruction, checking if the instruction create
     *        a definition, in case a definition exists, update the set of definitions.
     *
     * @param block current analyzed block
     * @param instruction_id index of the instruction to analyze
     * @return true
     * @return false
     */</span>
    <span>bool</span> <span>analyze_instruction</span><span>(</span><span>irblock_t</span> <span>&amp;</span><span>block</span><span>,</span> <span>std</span><span>::</span><span>uint32_t</span> <span>instruction_id</span><span>);</span>
    
    <span>/**
     * @brief Check if the given instruction is an instruction where there is some
     *        kind of definition or redefinition of a register, in that case return
     *        the reference of the register, in other case use optional to return
     *        a std::nullopt value.
     *
     * @param instr
     * @return std::optional&lt;irexpr_t&amp;&gt;
     */</span>
    <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>is_reg_defined</span><span>(</span><span>irstmnt_t</span> <span>&amp;</span><span>instr</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The first thing we will do for computing the reaching definition on each line from the IR code will be to get the blocks in a Depth-First search order, then we will call <code>analyze_block</code> for each block. We will do this while new definitions are found:</p>

<div><div><pre><code><span>void</span> <span>ReachingDefinition</span><span>::</span><span>compute</span><span>()</span>
<span>{</span>
    <span>bool</span> <span>change</span> <span>=</span> <span>true</span><span>;</span>

    <span>auto</span> <span>dfs</span> <span>=</span> <span>graph</span><span>-&gt;</span><span>Depth_First_Search</span><span>(</span><span>graph</span><span>-&gt;</span><span>get_nodes</span><span>()[</span><span>0</span><span>]);</span>

    <span>while</span> <span>(</span><span>change</span><span>)</span>
    <span>{</span>
        <span>change</span> <span>=</span> <span>false</span><span>;</span>
        <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>block</span> <span>:</span> <span>dfs</span><span>)</span>
            <span>change</span> <span>|=</span> <span>analyze_block</span><span>(</span><span>block</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>For doing the analysis of each block, what we will do first is to generate the list of input definitions of the current block, that we will call <code>in(w)</code>, this list is created with the output definitions from the predecessors of the current block, we will call each list of the out definitions from each predecessor <code>out(p)</code>, then we will have that <code>in(w) = U out(p) for each p in predecessor(w)</code>. The list <code>out(p)</code> are the definitions in the last instruction of the block (these lists will be empty at the beginning of the execution, for that reason the algorithm runs iterations until no more changes appear). This is the implementation of <code>in(w) = U out(p) for each p in predecessor(w)</code> in C++:</p>

<div><div><pre><code><span>bool</span> <span>ReachingDefinition</span><span>::</span><span>analyze_block</span><span>(</span><span>irblock_t</span> <span>&amp;</span><span>block</span><span>)</span>
<span>{</span>
    <span>regdefinitionset_t</span> <span>predecesor_state</span><span>;</span>
    <span>bool</span> <span>modified</span><span>;</span>

    <span>// Go through each predecessor of the current block</span>
    <span>// in(w) = U out(p) for p in pred(w)</span>
    <span>for</span> <span>(</span><span>auto</span> <span>pred</span> <span>:</span> <span>graph</span><span>-&gt;</span><span>get_predecessors</span><span>(</span><span>block</span><span>))</span>
    <span>{</span>
        <span>// take the set of definitions from the last instruction of previous block</span>
        <span>auto</span> <span>&amp;</span><span>lval_definitions</span> <span>=</span> <span>reaching_definitions</span><span>[</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>pred</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>pred</span><span>-&gt;</span><span>get_number_of_statements</span><span>())];</span>

        <span>// add it to predecesor state</span>
        <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>lval_definition</span> <span>:</span> <span>lval_definitions</span><span>)</span>
            <span>predecesor_state</span><span>.</span><span>insert</span><span>(</span><span>lval_definition</span><span>);</span>
    <span>}</span>
</code></pre></div></div>

<p>Then detect if there was a modification, that means checking if previously <code>in(w)</code> didn’t exist, or if the calculated <code>in(w)</code> is different to a previous <code>in(w)</code> from another iteration. For doing that, we need to do checking with the previously seen <code>reaching_definitions</code> variable, which contains all the reaching definition values. If no modification exists, return false:</p>

<div><div><pre><code><span>modified</span> <span>=</span> <span>(</span><span>reaching_definitions</span><span>.</span><span>find</span><span>(</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>0</span><span>))</span> <span>==</span> <span>reaching_definitions</span><span>.</span><span>end</span><span>())</span> <span>||</span> <span>(</span><span>reaching_definitions</span><span>[</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>0</span><span>)]</span> <span>!=</span> <span>predecesor_state</span><span>);</span>

<span>if</span> <span>(</span><span>!</span><span>modified</span><span>)</span>
    <span>return</span> <span>false</span><span>;</span>
</code></pre></div></div>

<p>Now, we save this new <code>in(w)</code> in the <code>reaching_definitions</code> variable:</p>

<div><div><pre><code><span>reaching_definitions</span><span>[</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>0</span><span>)]</span> <span>=</span> <span>predecesor_state</span><span>;</span>
</code></pre></div></div>

<p>Now that we have <code>in(w)</code> we need to analyze each instruction looking for definitions, a definition in a new instruction, kills a definition in a previous instruction if they are defining the same value. We do it with a loop and calling <code>analyze_instruction</code>:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>size_t</span> <span>index</span> <span>=</span> <span>0</span><span>,</span> <span>size</span> <span>=</span> <span>block</span><span>-&gt;</span><span>get_number_of_statements</span><span>();</span> <span>index</span> <span>&lt;</span> <span>size</span><span>;</span> <span>index</span><span>++</span><span>)</span>
    <span>modified</span> <span>|=</span> <span>analyze_instruction</span><span>(</span><span>block</span><span>,</span> <span>index</span><span>);</span>

<span>return</span> <span>modified</span><span>;</span>
</code></pre></div></div>

<p>And here we would have finished the analysis of the blocks. Now we can move to the analysis of the instructions.</p>

<p>First of all, we obtain the definitions that come to the current instruction, we need the next <code>defs = in(instr)</code>:</p>

<div><div><pre><code><span>bool</span> <span>ReachingDefinition</span><span>::</span><span>analyze_instruction</span><span>(</span><span>irblock_t</span> <span>&amp;</span><span>block</span><span>,</span> <span>std</span><span>::</span><span>uint32_t</span> <span>instruction_id</span><span>)</span>
<span>{</span>
    <span>bool</span> <span>modified</span><span>;</span>

    <span>irstmnt_t</span> <span>&amp;</span><span>instr</span> <span>=</span> <span>block</span><span>-&gt;</span><span>get_statements</span><span>().</span><span>at</span><span>(</span><span>instruction_id</span><span>);</span>
    <span>// defs = in(instr)</span>
    <span>auto</span> <span>defs</span> <span>=</span> <span>reaching_definitions</span><span>[</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>instruction_id</span><span>)];</span>
</code></pre></div></div>

<p>Now we need to retrieve if the current instruction generates a new definition of a variable (register in this case), and in case there’s a definition we need to update the list of <code>out(instruction)</code> which are the definitions that goes out from this instruction, we can express it in the next way: <code>out(instr) =  gen(instr) U (in(instr) - kill(instr))</code>, the output generations are, the current generations joined with the generations that comes from previous instructions without taking in consideration those definitions that were killed by the current one! We will obtain if a register is defined calling <code>is_reg_defined</code>. All of this, is translated into C++ in the following way:</p>

<div><div><pre><code><span>auto</span> <span>reg_defined</span> <span>=</span> <span>is_reg_defined</span><span>(</span><span>instr</span><span>);</span>

<span>if</span> <span>(</span><span>reg_defined</span><span>)</span>
<span>{</span>
    <span>// out(instr) =  gen(instr) U (in(instr) - kill(instr))</span>

    <span>// in(instr) - kill(instr)</span>
    <span>for</span> <span>(</span><span>auto</span> <span>it</span> <span>=</span> <span>defs</span><span>.</span><span>begin</span><span>();</span> <span>it</span> <span>!=</span> <span>defs</span><span>.</span><span>end</span><span>();</span> <span>it</span><span>++</span><span>)</span>
    <span>{</span>
        <span>const</span> <span>auto</span><span>&amp;</span> <span>map_value</span> <span>=</span> <span>*</span><span>it</span><span>;</span>

        <span>if</span> <span>(</span><span>map_value</span><span>.</span><span>find</span><span>(</span><span>reg_defined</span><span>.</span><span>value</span><span>())</span> <span>!=</span> <span>map_value</span><span>.</span><span>end</span><span>())</span>
            <span>// we are going to remove previous definitions</span>
            <span>// of the same registers</span>
            <span>it</span> <span>=</span> <span>defs</span><span>.</span><span>erase</span><span>(</span><span>it</span><span>);</span>
    <span>}</span>

    <span>// gen(instr)</span>
    <span>defs</span><span>.</span><span>insert</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>Finally, to know if we have some modification, we have to compare the current <code>out(instruction)</code> with the previously stored <code>out(instruction)</code>, and in case there’s some modification we store this new <code>out(instruction)</code> (which is the same as <code>in(instruction+1)</code>), and return true!</p>

<div><div><pre><code>    <span>// old out(instr) == out(instr)?</span>
    <span>modified</span> <span>=</span> <span>(</span><span>reaching_definitions</span><span>.</span><span>find</span><span>(</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>instruction_id</span> <span>+</span> <span>1</span><span>))</span> <span>==</span> <span>reaching_definitions</span><span>.</span><span>end</span><span>())</span> <span>||</span> <span>reaching_definitions</span><span>[</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>instruction_id</span> <span>+</span> <span>1</span><span>)]</span> <span>!=</span> <span>defs</span><span>;</span>

    <span>if</span> <span>(</span><span>modified</span><span>)</span>
        <span>// in(instr+1) = out(instr)</span>
        <span>reaching_definitions</span><span>[</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>instruction_id</span> <span>+</span> <span>1</span><span>)]</span> <span>=</span> <span>defs</span><span>;</span>

    <span>return</span> <span>modified</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>And how does is the <code>is_reg_defined</code> function look? It’s just a function that checks the type of instruction, checks if a register is defined, and then returns that register:</p>

<div><div><pre><code><span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>ReachingDefinition</span><span>::</span><span>is_reg_defined</span><span>(</span><span>irstmnt_t</span> <span>&amp;</span><span>instr</span><span>)</span>
<span>{</span>
    <span>irexpr_t</span> <span>reg</span><span>;</span>
    <span>// A = B</span>
    <span>if</span> <span>(</span><span>auto</span> <span>assign_instr</span> <span>=</span> <span>assign_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
    <span>}</span>
    <span>// A = IRUnaryOp B</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>unary_instr</span> <span>=</span> <span>unary_op_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>unary_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
    <span>}</span>
    <span>// A = B IRBinaryOp C</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>bin_instr</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>bin_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
    <span>}</span>
    <span>// A = load(MEM)</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>load_instr</span> <span>=</span> <span>load_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
    <span>}</span>
    <span>// A = New Class</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>new_instr</span> <span>=</span> <span>new_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>new_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
    <span>}</span>
    <span>// A = New Array</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>alloca_instr</span> <span>=</span> <span>alloca_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>alloca_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
    <span>}</span>
    <span>// A = phi(A, A, A...)</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>phi_instr</span> <span>=</span> <span>phi_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>reg</span> <span>=</span> <span>phi_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
    <span>}</span>
    <span>else</span>
        <span>return</span> <span>std</span><span>::</span><span>nullopt</span><span>;</span>

    <span>return</span> <span>reg</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>In this way, we loop until no more definitions exist, and with all these algorithms we will have the definitions from the program, where the definitions were done, and until when these definitions exist.</p>

<p>For seeing a python implementation, I highly recommend going to the following code from <a href="https://github.com/cea-sec/miasm/blob/master/miasm/analysis/data_flow.py#L20">Miasm</a>, also as stated in their comment, I recommend reading the paper <em>A survey of data flow analysis techniques.</em> by <em>Kennedy, K. (1979)</em>.</p>

<h5 id="def-useuse-def-chains">Def-Use/Use-Def chains</h5>

<p>Finally, we arrive to an important concept from the analysis of IRs which are the def-use and the use-def chains. We previously defined the definitions as any point where a value is set in a variable. On the other side, we have uses, which are points in the graph where a variable with a definition is used. These two concepts are also referred as <em>Du-Chains</em> and <em>Ud-Chains</em> in Muchnick’s book. <em>Du-Chains</em> for a variable connects a definition of that variable to all the uses it may flow to, while a <em>ud-chain</em> connects a use to all the definitions that may flow to it. The complexity of this analysis is in detecting where a definition is used without being redefined, and which are the definitions connected to a usage.
Although we haven’t seen the implementation of the SSA form yet, it is useful saying that things like Def-Use and Use-Def chains are much easier to implement than in an IR without an SSA form. In SSA each variable can be defined just once, so for each variable we will have only one definition and multiple uses. If we do not use SSA, each variable can have multiple definitions.</p>

<p>For understanding how are def-use and use-def chains, we can go to the following link from the Miasm Project <a href="https://miasm.re/blog/2017/02/03/data_flow_analysis_depgraph.html#id18">use-def</a>, they perfectly explain how the values of two parameters from a call can come from two previous blocks, in that case, for variable <code>a</code> we have two definitions as well as for <code>b</code>. But those definitions have as use the <code>call(a,b)</code>. In that case, we would have the next <code>def-use/use-def chain</code>:</p>

<div><div><pre><code>a = {def: lbl1.1, lbl2.1, use: lbl3.1}
b = {def: lbl1.2, lbl2.2, use: lbl3.1}
</code></pre></div></div>

<p>I also like the example they provide in the comment from their code which I highly recommend to read: <a href="https://github.com/cea-sec/miasm/blob/master/miasm/analysis/data_flow.py#L114">miasm def-use/use-def</a>.</p>

<div><div><pre><code><span>&#34;&#34;&#34;
IR block:
    lbl0:
       0 A = 1
         B = 3
       1 B = 2
       2 A = A + B + 4

    Def use analysis:
    (lbl0, 0, A) =&gt; {(lbl0, 2, A)}
    (lbl0, 0, B) =&gt; {}
    (lbl0, 1, B) =&gt; {(lbl0, 2, A)}
    (lbl0, 2, A) =&gt; {}
&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>Now, I will go with the implementation from MjolnIR. The implementation of the computation of def-use and use-def chains was done in the class <code>Optimizer</code> both in <code>optimizer.hpp</code> and <code>optimizer.cpp</code>. For calculating these chains we will need three parameters, one <code>IRGraph</code> containing the method to analyze and <code>reachingdefinition_t</code> a reaching definition analysis output from the previous point. The next functions will calculate these chains:</p>

<div><div><pre><code><span>class</span> <span>Optimizer</span> <span>{</span>
    <span>...</span>
    <span>/**
     * @brief Calculate the def-use and use-def chains in an IRGraph
     *        for doing that we need to accept a reaching definition
     *        with the analysis already run. All the changes will be
     *        applied directly to the instructions of the IRGraph.
     *
     * @param ir_graph graph of a function in MjolnIR to calculate its def-use, use-def chains
     * @param reachingdefinition the object with the reaching definition.
     */</span>
    <span>void</span> <span>calculate_def_use_and_use_def_analysis</span><span>(</span><span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>ir_graph</span><span>,</span>
                                                <span>reachingdefinition_t</span> <span>&amp;</span><span>reachingdefinition</span><span>);</span>
    <span>...</span>               
    <span>/**
     * @brief Solve a def_use and use_def chain given an operand and a instruction
     *        here we will solve the reaching definition value and then we will cross-reference
     *        the instructions.
     *
     * @param operand
     * @param expr
     * @param reach_def_set
     * @param ir_graph
     */</span>
    <span>void</span> <span>solve_def_use_use_def</span><span>(</span><span>irexpr_t</span> <span>&amp;</span><span>operand</span><span>,</span> <span>irstmnt_t</span> <span>expr</span><span>,</span> <span>regdefinitionset_t</span> <span>&amp;</span><span>reach_def_set</span><span>,</span> <span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>ir_graph</span><span>);</span>
    <span>...</span>
<span>}</span>
</code></pre></div></div>

<p>The first function <code>calculate_def_use_and_use_def_analysis</code> is the public function that will analyze the <code>IRGraph</code> and will do some kind of magic to collect the information. First of all we will go through the <code>IRBlock</code>s that belong to the graph, and as expected, from each block, we will go through the instructions (easy cheesy!):</p>

<div><div><pre><code><span>void</span> <span>Optimizer</span><span>::</span><span>calculate_def_use_and_use_def_analysis</span><span>(</span><span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>ir_graph</span><span>,</span>
                                                       <span>reachingdefinition_t</span> <span>&amp;</span><span>reachingdefinition</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>block</span> <span>:</span> <span>ir_graph</span><span>-&gt;</span><span>get_nodes</span><span>())</span>
    <span>{</span>
        <span>auto</span> <span>&amp;</span><span>instructions</span> <span>=</span> <span>block</span><span>-&gt;</span><span>get_statements</span><span>();</span>

        <span>for</span> <span>(</span><span>size_t</span> <span>_size_instr</span> <span>=</span> <span>block</span><span>-&gt;</span><span>get_number_of_statements</span><span>(),</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>_size_instr</span><span>;</span> <span>i</span><span>++</span><span>)</span>
        <span>{</span>
</code></pre></div></div>

<p>After this, we will retrieve one of the instructions, and we will check if that index (block index, instruction index) contains a <code>regdefinitionset_t</code> (if you do not remember it, you can check it in the previous section). With this, we know if there’s some definitions in that instruction or not:</p>

<div><div><pre><code><span>auto</span> <span>&amp;</span><span>instr</span> <span>=</span> <span>instructions</span><span>.</span><span>at</span><span>(</span><span>i</span><span>);</span>

<span>auto</span> <span>reach_def_instr</span> <span>=</span> <span>reachingdefinition</span><span>-&gt;</span><span>get_reach_definition_point</span><span>(</span><span>block</span><span>-&gt;</span><span>get_start_idx</span><span>(),</span> <span>i</span><span>);</span>

<span>// check if there was a reach_def</span>
<span>if</span> <span>(</span><span>!</span><span>reach_def_instr</span><span>.</span><span>has_value</span><span>())</span>
    <span>continue</span><span>;</span>

<span>auto</span> <span>reach_def_set</span> <span>=</span> <span>reach_def_instr</span><span>.</span><span>value</span><span>();</span>

<span>// check if set is empty</span>
<span>if</span> <span>(</span><span>reach_def_set</span><span>.</span><span>empty</span><span>())</span>
    <span>continue</span><span>;</span>
</code></pre></div></div>

<p>The reaching definitions will tell us where a defined register value will reach (for that reason reaching, and for that reason definition, again easy cheesy). Now we will apply the analysis to the different MjolnIR’s instructions, some of them define registers, some of them use them. In any case, we need to apply the function <code>solve_def_use_use_def</code> to all the used registers (not the defined ones). Next is the code that cast the <code>IRStmnt</code> and applies different code for each instruction type:</p>

<div><div><pre><code><span>// A = B</span>
<span>if</span> <span>(</span><span>auto</span> <span>assign_instr</span> <span>=</span> <span>assign_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>assign_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>op</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>
    <span>solve_def_use_use_def</span><span>(</span><span>op</span><span>,</span> <span>assign_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// A = phi(A1, A2, A3, ...)</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>phi_instr</span> <span>=</span> <span>phi_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>phi_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span><span>&amp;</span> <span>params</span> <span>=</span> <span>phi_instr</span><span>-&gt;</span><span>get_params</span><span>();</span>
    <span>for</span> <span>(</span><span>auto</span><span>&amp;</span> <span>op</span> <span>:</span> <span>params</span><span>)</span>
        <span>solve_def_use_use_def</span><span>(</span><span>op</span><span>.</span><span>second</span><span>,</span> <span>phi_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// A = IRUnaryOp B</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>unary_op_instr</span> <span>=</span> <span>unary_op_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>unary_op_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>op</span> <span>=</span> <span>unary_op_instr</span><span>-&gt;</span><span>get_op</span><span>();</span>

    <span>solve_def_use_use_def</span><span>(</span><span>op</span><span>,</span> <span>unary_op_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// A = B IRBinaryOp C</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>bin_op_instr</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>bin_op_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>op1</span> <span>=</span> <span>bin_op_instr</span><span>-&gt;</span><span>get_op1</span><span>();</span>
    <span>auto</span> <span>op2</span> <span>=</span> <span>bin_op_instr</span><span>-&gt;</span><span>get_op2</span><span>();</span>

    <span>solve_def_use_use_def</span><span>(</span><span>op1</span><span>,</span> <span>bin_op_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
    <span>solve_def_use_use_def</span><span>(</span><span>op2</span><span>,</span> <span>bin_op_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// CALL (A,B,C,...)</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>call_instr</span> <span>=</span> <span>call_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>for</span> <span>(</span><span>auto</span> <span>op</span> <span>:</span> <span>call_instr</span><span>-&gt;</span><span>get_args</span><span>())</span>
    <span>{</span>
        <span>solve_def_use_use_def</span><span>(</span><span>op</span><span>,</span> <span>call_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
    <span>}</span>
<span>}</span>
<span>// A = *B[C]</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>load_instr</span> <span>=</span> <span>load_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>load_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>source</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>
    <span>auto</span> <span>index</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_index</span><span>();</span>

    <span>solve_def_use_use_def</span><span>(</span><span>source</span><span>,</span> <span>load_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>

    <span>if</span> <span>(</span><span>index</span><span>)</span>
        <span>solve_def_use_use_def</span><span>(</span><span>index</span><span>,</span> <span>load_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// *B[C] = A</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>store_instr</span> <span>=</span> <span>store_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>store_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>source</span> <span>=</span> <span>store_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>

    <span>solve_def_use_use_def</span><span>(</span><span>source</span><span>,</span> <span>store_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// RET A</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>ret_instr</span> <span>=</span> <span>ret_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>ret_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>ret_value</span> <span>=</span> <span>ret_instr</span><span>-&gt;</span><span>get_return_value</span><span>();</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg_value</span> <span>=</span> <span>expr_ir</span><span>(</span><span>ret_value</span><span>))</span>
        <span>solve_def_use_use_def</span><span>(</span><span>reg_value</span><span>,</span> <span>ret_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// JCC &lt;condition&gt;</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>jcc_instr</span> <span>=</span> <span>conditional_jump_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>jcc_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>auto</span> <span>condition</span> <span>=</span> <span>jcc_instr</span><span>-&gt;</span><span>get_condition</span><span>();</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg_value</span> <span>=</span> <span>expr_ir</span><span>(</span><span>condition</span><span>))</span>
        <span>solve_def_use_use_def</span><span>(</span><span>reg_value</span><span>,</span> <span>jcc_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// BComp A, B</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>bcomp_instr</span> <span>=</span> <span>bcomp_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>bcomp_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>bcomp_instr</span><span>-&gt;</span><span>get_reg1</span><span>())</span>
        <span>solve_def_use_use_def</span><span>(</span><span>reg</span><span>,</span> <span>bcomp_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
    
    <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>bcomp_instr</span><span>-&gt;</span><span>get_reg2</span><span>())</span>
        <span>solve_def_use_use_def</span><span>(</span><span>reg</span><span>,</span> <span>bcomp_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// ZComp A, 0</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>zcomp_instr</span> <span>=</span> <span>zcomp_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>zcomp_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>zcomp_instr</span><span>-&gt;</span><span>get_reg</span><span>())</span>
        <span>solve_def_use_use_def</span><span>(</span><span>reg</span><span>,</span> <span>zcomp_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
<span>}</span>
<span>// A = Alloca[REG]</span>
<span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>alloca_instr</span> <span>=</span> <span>alloca_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>alloca_instr</span><span>-&gt;</span><span>invalidate_chains</span><span>();</span>

    <span>irstmnt_t</span> <span>size</span> <span>=</span> <span>alloca_instr</span><span>-&gt;</span><span>get_size</span><span>();</span>

    <span>if</span> <span>(</span><span>irexpr_t</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>size</span><span>))</span>
        <span>solve_def_use_use_def</span><span>(</span><span>reg</span><span>,</span> <span>alloca_instr</span><span>,</span> <span>reach_def_set</span><span>,</span> <span>ir_graph</span><span>);</span>
    
<span>}</span>
</code></pre></div></div>

<p>MjolnIR had helper instructions that applied the casts, or returned <code>nullptr</code> in case the instruction was not the checked one, allowing the use of <code>if</code> code to enter or not to the condition. Also, we have <code>register_ir</code> to know if a provided value is a register or not. One interesting thing is that we find the call to the function <code>invalidate_chains</code> from <code>IRStmnt</code> that will delete the def-use and the use-def chain for each instruction.</p>

<div><div><pre><code><span>void</span> <span>IRStmnt</span><span>::</span><span>invalidate_chains</span><span>()</span>
<span>{</span>
    <span>invalidate_use_def_chain</span><span>();</span>
    <span>invalidate_def_use_chains</span><span>();</span>
<span>}</span>

<span>void</span> <span>invalidate_use_def_chain</span><span>()</span>
<span>{</span>
    <span>use_def_chain</span><span>.</span><span>clear</span><span>();</span>
<span>}</span>

<span>void</span> <span>invalidate_def_use_chains</span><span>()</span>
<span>{</span>
    <span>def_use_chains</span><span>.</span><span>clear</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s move to <code>solve_def_use_use_def</code>, here we got as parameters the operand, the expression with the instruction, the reaching definitions for that instruction and the graph with the whole method. What we do is pretty easy, we need to detect that the operand is in the reaching definition. If we detect it, we are detecting a use from a register, and with the reaching definition map we will detect where the value was defined. Then we will obtain the instruction where the register was defined and we do the next: in the definition instruction set a use for the defined register, in the current instruction set a definition for the used register.</p>

<div><div><pre><code><span>void</span> <span>Optimizer</span><span>::</span><span>solve_def_use_use_def</span><span>(</span><span>irexpr_t</span> <span>&amp;</span><span>operand</span><span>,</span>
                                      <span>irstmnt_t</span> <span>expr</span><span>,</span>
                                      <span>regdefinitionset_t</span> <span>&amp;</span><span>reach_def_set</span><span>,</span>
                                      <span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>ir_graph</span><span>)</span>
<span>{</span>
    <span>// we need to detect the operand in the reach definition</span>
    <span>// and in case we find it, we will create the def-use and</span>
    <span>// use-def chains.</span>
    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>reach_def_map</span> <span>:</span> <span>reach_def_set</span><span>)</span>
    <span>{</span>
        <span>// look for the operand in the Reaching definition</span>
        <span>if</span> <span>(</span><span>reach_def_map</span><span>.</span><span>find</span><span>(</span><span>operand</span><span>)</span> <span>!=</span> <span>reach_def_map</span><span>.</span><span>end</span><span>())</span>
        <span>{</span>
            <span>auto</span> <span>&amp;</span><span>reach_def</span> <span>=</span> <span>reach_def_map</span><span>.</span><span>at</span><span>(</span><span>operand</span><span>);</span>

            <span>// extract where the operand was defined.</span>
            <span>auto</span> <span>block</span> <span>=</span> <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>0</span><span>&gt;</span><span>(</span><span>reach_def</span><span>);</span>
            <span>auto</span> <span>instr</span> <span>=</span> <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>reach_def</span><span>);</span>

            <span>auto</span> <span>definition_block</span> <span>=</span> <span>ir_graph</span><span>-&gt;</span><span>get_node_by_start_idx</span><span>(</span><span>block</span><span>);</span>

            <span>if</span> <span>(</span><span>!</span><span>definition_block</span><span>.</span><span>has_value</span><span>())</span>
                <span>continue</span><span>;</span>

            <span>// get the instruction, we will use it to cross-reference both</span>
            <span>auto</span> <span>definition_instr</span> <span>=</span> <span>definition_block</span><span>.</span><span>value</span><span>()</span><span>-&gt;</span><span>get_statements</span><span>().</span><span>at</span><span>(</span><span>instr</span><span>);</span>

            <span>// set one use of a definition</span>
            <span>definition_instr</span><span>-&gt;</span><span>add_instr_to_use_def_chain</span><span>(</span><span>expr</span><span>);</span>

            <span>// set one definition of a use</span>
            <span>expr</span><span>-&gt;</span><span>add_instr_to_def_use_chain</span><span>(</span><span>operand</span><span>,</span> <span>definition_instr</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Then, we will have in each instruction the uses as a list of instructions where the defined value is used. And in the use instruction, we will have for the operand a list of definition instructions. <code>IRStmnt</code> has a method for printing these chains:</p>

<div><div><pre><code><span>void</span> <span>IRStmnt</span><span>::</span><span>print_use_def_and_def_use_chain</span><span>()</span>
<span>{</span>

    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Use-Def and Def-Use chain of: &#34;</span> <span>&lt;&lt;</span> <span>this</span><span>-&gt;</span><span>to_string</span><span>()</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span><span>use_def_chain</span><span>.</span><span>empty</span><span>())</span>
    <span>{</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\t</span><span>Use-Def chain:</span><span>\n</span><span>&#34;</span><span>;</span>

        <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>use_def</span> <span>:</span> <span>use_def_chain</span><span>)</span>
            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\t\t</span><span>&#34;</span> <span>&lt;&lt;</span> <span>use_def</span><span>-&gt;</span><span>to_string</span><span>()</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>!</span><span>def_use_chains</span><span>.</span><span>empty</span><span>())</span>
    <span>{</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\t</span><span>Def-Use chains:</span><span>\n</span><span>&#34;</span><span>;</span>

        <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>def_use</span> <span>:</span> <span>def_use_chains</span><span>)</span>
        <span>{</span>
            <span>auto</span> <span>&amp;</span><span>value</span> <span>=</span> <span>def_use</span><span>.</span><span>first</span><span>;</span>
            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\t\t</span><span>&#34;</span> <span>&lt;&lt;</span> <span>value</span><span>-&gt;</span><span>to_string</span><span>()</span> <span>&lt;&lt;</span> <span>&#34;: &#34;</span><span>;</span>
            <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>def</span> <span>:</span> <span>def_use</span><span>.</span><span>second</span><span>)</span>
                <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>def</span><span>-&gt;</span><span>to_string</span><span>()</span> <span>&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>As I commented, for an SSA-form this will be simpler since only one definition exists with multiple uses. But for now, this is all!</p>

<h4 id="mjolnir---analysis">MjolnIR - Analysis</h4>

<p>Once we have seen all the graph algorithms, we can go to the usage of these algorithms. This section of the long post will have one larger subsection, and others are shorter because I couldn’t improve that part of the code in the past.</p>

<h5 id="ssa-graph-generation">SSA Graph generation</h5>

<p>As I previously said, there is a form of IR known as Static-Single Assignment Form (SSA Form). In this form, each time a variable is defined after an assignment, or after an operation that generates some result, a new variable is created, and that’s because variables can be assigned only once and used multiple times. This IR form was developed by IBM researchers in the 80s, and it became beneficial to apply optimizations in the IR. For example, an analysis as the def-use/use-def chains we previously saw, it becomes a single point of definition and then a list of uses, making this representation easy to obtain.</p>

<p>For obtaining this representation, there are algorithms that can be used to directly obtain this representation without obtaining an intermediate form of an IR, in this post a friend of mine and I explain this method used in a new version of MjolnIR: <a href="https://farena.in/compilers/mlir/ssa-mlir-algorithm/">https://farena.in/compilers/mlir/ssa-mlir-algorithm/</a>. But for the primitive version of MjolnIR I used the next <a href="https://www.cs.utexas.edu/~pingali/CS380C/2010/papers/ssaCytron.pdf"><em>Efficiently Computing Static Single Assignment Form and the Control Dependence Graph</em></a> by Cytron et al., as I previously said. This is because MjolnIR with <code>IRGraph</code> already had an intermediate form of IR that I was able to use (and also because at that moment it was the only way I knew).</p>

<p>For constructing the SSA Graph a new class called <code>IRGraphSSA</code> exists, this class receives in the constructor an <code>IRGraph</code> as parameter, with this the new graph will be generated, with this, and with all the next functions:</p>

<div><div><pre><code><span>/**
 * @brief Obtain all kind of assignment that can generate
 *        a newer value for a variable.
 *
 * @param graph
 */</span>
<span>void</span> <span>collect_var_assign</span><span>();</span>

<span>/**
 * @brief Look for a place in the dominance frontier where
 *        to write
 *
 */</span>
<span>void</span> <span>insert_phi_node</span><span>();</span>

<span>/**
 * @brief Apply variable renaming to a basic block of the IRGraph
 *        here we will apply the global variables in order to translate
 *        each instruction.
 *
 * @param v basic block to translate.
 */</span>
<span>void</span> <span>search</span><span>(</span><span>const</span> <span>irblock_t</span> <span>&amp;</span><span>v</span><span>);</span>

<span>/**
 * @brief Translate an instruction to an SSA form this will involve
 *        parsing the instruction and checking if it contains registers
 *        to translate to a new SSA form.
 *
 * @param instr instruction to translate to an SSA form
 * @param p defined registers that we must remove later from stack.
 * @return irstmnt_t
 */</span>
<span>irstmnt_t</span> <span>translate_instruction</span><span>(</span><span>irstmnt_t</span> <span>&amp;</span><span>instr</span><span>,</span> <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>&amp;</span><span>p</span><span>);</span>

<span>/**
 * @brief Create a new register for the SSA, this will be used
 *        in the renaming algorithm, the algorithm is based in
 *        the one of the book
 *        &#34;An Introduction to the Theory of Optimizing Compilers&#34;.
 *        This function will use both C and S.
 *
 * @param old_reg register we want to transform to SSA
 * @param p defined registers that we must remove later from stack.
 * @return irreg_t
 */</span>
<span>irreg_t</span> <span>create_new_ssa_reg</span><span>(</span><span>irreg_t</span> <span>old_reg</span><span>,</span> <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>&amp;</span><span>p</span><span>);</span>

<span>/**
 * @brief Get the top of the S stack for a given register, in case
 *        it doesn&#39;t exist yet, call to create_new_ssa_reg function.
 * 
 * @param old_reg register we want to transform to SSA
 * @param p definedd registers that we must remove later from stack
 * @return irreg_t 
 */</span>
<span>irreg_t</span> <span>get_top_or_create</span><span>(</span><span>irreg_t</span> <span>old_reg</span><span>,</span> <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>&amp;</span><span>p</span><span>);</span>
</code></pre></div></div>

<p>All these functions are used to do tasks like inserting phi instructions using the previously defined dominance frontier. Also, the algorithm needs to rename all the registers, adding a sub-index (e.g. from <code>r0</code> we will need <code>r0_1</code>, <code>r0_2</code>, etc) for each assignment done to the register. Let’s move to the constructor of this class.</p>

<p>The first thing we do in the constructor is copying the nodes and the edges, as well as calculating the dominance tree (calculating the immediate dominators).</p>

<div><div><pre><code><span>IRGraphSSA</span><span>::</span><span>IRGraphSSA</span><span>(</span><span>irgraph_t</span> <span>&amp;</span><span>code_graph</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>nodes</span> <span>=</span> <span>code_graph</span><span>-&gt;</span><span>get_nodes</span><span>();</span>
    <span>auto</span> <span>edges</span> <span>=</span> <span>code_graph</span><span>-&gt;</span><span>get_edges</span><span>();</span>

    <span>for</span> <span>(</span><span>auto</span> <span>node</span> <span>:</span> <span>nodes</span><span>)</span>
        <span>add_node</span><span>(</span><span>node</span><span>);</span>
    <span>for</span> <span>(</span><span>auto</span> <span>edge</span> <span>:</span> <span>edges</span><span>)</span>
        <span>add_edge</span><span>(</span><span>edge</span><span>.</span><span>first</span><span>,</span> <span>edge</span><span>.</span><span>second</span><span>);</span>

    <span>dominance_tree</span> <span>=</span> <span>compute_immediate_dominators</span><span>();</span>
</code></pre></div></div>

<ul>
  <li><strong>collect_var_assign Analysis</strong></li>
</ul>

<p>Then the algorithm calls to <code>collect_var_assign</code>, this function simply collects for each register the blocks where a definition exists. First of all let’s see the call to that function:</p>

<div><div><pre><code><span>IRGraphSSA</span><span>::</span><span>IRGraphSSA</span><span>(</span><span>irgraph_t</span> <span>&amp;</span><span>code_graph</span><span>)</span>
<span>{</span>
    <span>...</span>
    <span>collect_var_assign</span><span>();</span>
    <span>...</span>
<span>}</span>
</code></pre></div></div>

<p>And now what this function does:</p>

<div><div><pre><code><span>void</span> <span>IRGraphSSA</span><span>::</span><span>collect_var_assign</span><span>()</span>
<span>{</span>
    <span>auto</span> <span>&amp;</span><span>blocks</span> <span>=</span> <span>get_nodes</span><span>();</span>

    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>block</span> <span>:</span> <span>blocks</span><span>)</span>
    <span>{</span>
        <span>auto</span> <span>&amp;</span><span>instrs</span> <span>=</span> <span>block</span><span>-&gt;</span><span>get_statements</span><span>();</span>

        <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>instr</span> <span>:</span> <span>instrs</span><span>)</span>
        <span>{</span>
            <span>// A = B</span>
            <span>if</span> <span>(</span><span>auto</span> <span>assign_instr</span> <span>=</span> <span>assign_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// A = IRUnaryOp B</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>unary_instr</span> <span>=</span> <span>unary_op_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>unary_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// A = B IRBinaryOp C</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>binary_instr</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>binary_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// A = LOAD(B[INDEX])</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>load_instr</span> <span>=</span> <span>load_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// A = New Class</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>new_ir_instr</span> <span>=</span> <span>new_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>new_ir_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// call &lt;callee&gt;(arg1, arg2, arg3...)</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>call_instr</span> <span>=</span> <span>call_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>ret_val</span> <span>=</span> <span>call_instr</span><span>-&gt;</span><span>get_ret_val</span><span>();</span>

                <span>// it can be void call</span>
                <span>if</span> <span>(</span><span>ret_val</span> <span>==</span> <span>nullptr</span><span>)</span>
                    <span>continue</span><span>;</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>ret_val</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// STORE(A) = B</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>store_instr</span> <span>=</span> <span>store_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>store_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// A = Alloca(B)</span>
            <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>alloca_instr</span> <span>=</span> <span>alloca_ir</span><span>(</span><span>instr</span><span>))</span>
            <span>{</span>
                <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>alloca_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
                <span>irstmnt_t</span> <span>size</span> <span>=</span> <span>alloca_instr</span><span>-&gt;</span><span>get_size</span><span>();</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                <span>}</span>

                <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>size</span><span>))</span>
                <span>{</span>
                    <span>var_block_map</span><span>[</span><span>reg</span><span>].</span><span>insert</span><span>(</span><span>block</span><span>);</span>
                <span>}</span>

                <span>continue</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<ul>
  <li><strong>insert_phi_node Analysis</strong></li>
</ul>

<p>So now, we should clearly see all the instructions that produce some register as a result. All of those registers are key for a map called <code>var_block_map</code> that will keep the blocks where the definitions exist. We will use that list right now for inserting the phi, because after calling <code>collect_var_assign</code>, the constructor calls <code>insert_phi_node</code>:</p>

<div><div><pre><code><span>IRGraphSSA</span><span>::</span><span>IRGraphSSA</span><span>(</span><span>irgraph_t</span> <span>&amp;</span><span>code_graph</span><span>)</span>
<span>{</span>
    <span>...</span>
    <span>insert_phi_node</span><span>();</span>
    <span>...</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s take a look to <code>insert_phi_node</code>, the first thing the algorithm does is to calculate the <code>dominance frontier</code>, it will be used to detect if a phi node must be inserted:</p>

<div><div><pre><code><span>void</span> <span>IRGraphSSA</span><span>::</span><span>insert_phi_node</span><span>()</span>
<span>{</span>
    <span>Nodes</span> <span>work_list</span><span>;</span>
    <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>seen</span><span>;</span>

    <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>irblock_t</span><span>,</span> <span>irreg_t</span><span>&gt;</span> <span>inserted</span><span>;</span>
    <span>auto</span> <span>dominance_frontier</span> <span>=</span> <span>compute_dominance_frontier</span><span>();</span>
</code></pre></div></div>

<p>Now, we will loop through the <code>var_block_map</code> previously created, we will take the register from the key as the current register to analyze, and we will create a work list with all the blocks where the register is defined, this work list will be complemented with the <code>seen</code> list to avoid analyzing a block twice:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>const</span> <span>auto</span> <span>&amp;</span><span>p</span> <span>:</span> <span>var_block_map</span><span>)</span>
<span>{</span>
    <span>const</span> <span>irreg_t</span> <span>&amp;</span><span>reg</span> <span>=</span> <span>p</span><span>.</span><span>first</span><span>;</span>

    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>block</span> <span>:</span> <span>p</span><span>.</span><span>second</span><span>)</span>
        <span>work_list</span><span>.</span><span>push_back</span><span>(</span><span>block</span><span>);</span>
</code></pre></div></div>

<p>We will retrieve the dominance frontier for each block, and for each one of those blocks in the dominance frontier we will add a phi instruction, we will add the result register where we assign the final value, but we will have to wait until the end of <code>IRGraphSSA</code> constructor to assign the parameters to that phi instruction, and to remove the phi values that are not needed (optimization of phi nodes).</p>

<div><div><pre><code><span>while</span> <span>(</span><span>!</span><span>work_list</span><span>.</span><span>empty</span><span>())</span>
<span>{</span>
    <span>auto</span> <span>&amp;</span><span>block</span> <span>=</span> <span>work_list</span><span>.</span><span>front</span><span>();</span>
    <span>work_list</span><span>.</span><span>erase</span><span>(</span><span>work_list</span><span>.</span><span>begin</span><span>());</span>
    <span>seen</span><span>.</span><span>push_back</span><span>(</span><span>block</span><span>);</span>

    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>df_block</span> <span>:</span> <span>dominance_frontier</span><span>[</span><span>block</span><span>])</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>inserted</span><span>[</span><span>df_block</span><span>]</span> <span>!=</span> <span>reg</span><span>)</span>
        <span>{</span>
            <span>// add phi node</span>
            <span>inserted</span><span>[</span><span>df_block</span><span>]</span> <span>=</span> <span>reg</span><span>;</span>

            <span>auto</span> <span>phi_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRPhi</span><span>&gt;</span><span>();</span>
            <span>phi_instr</span><span>-&gt;</span><span>add_result</span><span>(</span><span>reg</span><span>);</span>

            <span>df_block</span><span>-&gt;</span><span>add_statement_at_beginning</span><span>(</span><span>phi_instr</span><span>);</span>

            <span>df_block</span><span>-&gt;</span><span>set_phi_node</span><span>();</span>

            <span>if</span> <span>(</span><span>std</span><span>::</span><span>find</span><span>(</span><span>seen</span><span>.</span><span>begin</span><span>(),</span> <span>seen</span><span>.</span><span>end</span><span>(),</span> <span>df_block</span><span>)</span> <span>==</span> <span>seen</span><span>.</span><span>end</span><span>())</span>
                <span>// finally add the block from dominance_frontier</span>
                <span>// into the worklist</span>
                <span>work_list</span><span>.</span><span>push_back</span><span>(</span><span>df_block</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<ul>
  <li><strong>Return to IRGraphSSA constructor</strong></li>
</ul>

<p>Finally, we will call a function called <code>search</code>, that we will later analyze, for both the nodes without predecessors (for example those from catch blocks), and the first node:</p>

<div><div><pre><code><span>IRGraphSSA</span><span>::</span><span>IRGraphSSA</span><span>(</span><span>irgraph_t</span> <span>&amp;</span><span>code_graph</span><span>)</span>
<span>{</span>
    <span>...</span>
    <span>auto</span> <span>&amp;</span><span>first_node</span> <span>=</span> <span>get_nodes</span><span>()[</span><span>0</span><span>];</span>

    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span> <span>node</span> <span>:</span> <span>get_nodes</span><span>())</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>get_predecessors</span><span>(</span><span>node</span><span>).</span><span>size</span><span>()</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>node</span> <span>!=</span> <span>first_node</span><span>)</span>
            <span>search</span><span>(</span><span>node</span><span>);</span>
    <span>}</span>

    <span>search</span><span>(</span><span>first_node</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<ul>
  <li><strong>Renaming the registers</strong></li>
</ul>

<p>Now that we have the phi instructions in the dominance frontiers, we will apply renaming to the registers, and we will fill the phi instructions with registers for the parameters. Before digging deeper into the <code>search</code> function, let’s see two functions that are used for creating the new registers, these new registers are based in the number of the previous registers, but they include a new sub-index. For storing them, I used a stack, and I was able to retrieve the last generated register, or create a new one with a newer sub-index:</p>

<div><div><pre><code><span>irreg_t</span> <span>IRGraphSSA</span><span>::</span><span>get_top_or_create</span><span>(</span><span>irreg_t</span> <span>old_reg</span><span>,</span> <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>&amp;</span><span>p</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>S</span><span>.</span><span>find</span><span>(</span><span>old_reg</span><span>)</span> <span>!=</span> <span>S</span><span>.</span><span>end</span><span>()</span> <span>&amp;&amp;</span> <span>S</span><span>[</span><span>old_reg</span><span>].</span><span>size</span><span>()</span> <span>!=</span> <span>0</span><span>)</span>
        <span>return</span> <span>S</span><span>[</span><span>old_reg</span><span>].</span><span>top</span><span>();</span>
    <span>else</span>
        <span>return</span> <span>create_new_ssa_reg</span><span>(</span><span>old_reg</span><span>,</span> <span>p</span><span>);</span>
<span>}</span>

<span>irreg_t</span> <span>IRGraphSSA</span><span>::</span><span>create_new_ssa_reg</span><span>(</span><span>irreg_t</span> <span>old_reg</span><span>,</span> <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>&amp;</span><span>p</span><span>)</span>
<span>{</span>
    <span>irreg_t</span> <span>new_reg</span><span>;</span> 

    <span>if</span> <span>(</span><span>C</span><span>.</span><span>find</span><span>(</span><span>old_reg</span><span>)</span> <span>==</span> <span>C</span><span>.</span><span>end</span><span>())</span>
        <span>C</span><span>[</span><span>old_reg</span><span>]</span> <span>=</span> <span>0</span><span>;</span>

    <span>new_reg</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRReg</span><span>&gt;</span><span>(</span><span>old_reg</span><span>-&gt;</span><span>get_id</span><span>(),</span>
                                      <span>C</span><span>[</span><span>old_reg</span><span>],</span>
                                      <span>old_reg</span><span>-&gt;</span><span>get_current_arch</span><span>(),</span>
                                      <span>old_reg</span><span>-&gt;</span><span>to_string</span><span>()</span> <span>+</span> <span>&#34;.&#34;</span> <span>+</span> <span>std</span><span>::</span><span>to_string</span><span>(</span><span>C</span><span>[</span><span>old_reg</span><span>]),</span>
                                      <span>old_reg</span><span>-&gt;</span><span>get_type_size</span><span>());</span>

    <span>// save last index of the register</span>
    <span>C</span><span>[</span><span>old_reg</span><span>]</span><span>++</span><span>;</span>
    <span>// save all the references to new registers</span>
    <span>// from old one</span>
    <span>S</span><span>[</span><span>old_reg</span><span>].</span><span>push</span><span>(</span><span>new_reg</span><span>);</span>
    <span>// save the old register from the newer one</span>
    <span>ssa_to_non_ssa_form</span><span>[</span><span>new_reg</span><span>]</span> <span>=</span> <span>old_reg</span><span>;</span>

    <span>p</span><span>.</span><span>push_back</span><span>(</span><span>old_reg</span><span>);</span>

    <span>return</span> <span>new_reg</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As we can appreciate, <code>S</code> is used to store the new registers given the old one, <code>C</code> keeps for each old register, the last sub-index used, and finally we also have a map for translating from a new register to an old one (<code>ssa_to_non_ssa_form</code>). Finally, we can start with <code>search</code> function.</p>

<p>First of all, the function will go through each instruction from the block, each statement will be processed and translated to an SSA-form. In some case, like it could be some phi instructions, the translation will return null, and in that case we can annotate the instruction as an instruction to be removed. In another case, what we will have is a new instruction to be inserted in the list of statements.</p>

<div><div><pre><code><span>void</span> <span>IRGraphSSA</span><span>::</span><span>search</span><span>(</span><span>const</span> <span>irblock_t</span> <span>&amp;</span><span>v</span><span>)</span>
<span>{</span>
    <span>// defined registers in the block</span>
    <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>p</span><span>;</span>
    <span>// instructions to remove</span>
    <span>std</span><span>::</span><span>stack</span><span>&lt;</span><span>size_t</span><span>&gt;</span> <span>to_remove</span><span>;</span>

    <span>auto</span> <span>&amp;</span><span>statements</span> <span>=</span> <span>v</span><span>-&gt;</span><span>get_statements</span><span>();</span>
    
    <span>// process each statement of the block</span>
    <span>for</span> <span>(</span><span>size_t</span> <span>v_size</span> <span>=</span> <span>statements</span><span>.</span><span>size</span><span>(),</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>v_size</span><span>;</span> <span>i</span><span>++</span><span>)</span>
    <span>{</span>
        <span>auto</span> <span>&amp;</span><span>instr</span> <span>=</span> <span>statements</span><span>[</span><span>i</span><span>];</span>

        <span>auto</span> <span>new_instr</span> <span>=</span> <span>translate_instruction</span><span>(</span><span>instr</span><span>,</span> <span>p</span><span>);</span>
        <span>// check if the instruction have been removed</span>
        <span>if</span> <span>(</span><span>new_instr</span> <span>==</span> <span>nullptr</span><span>)</span>
        <span>{</span>
            <span>to_remove</span><span>.</span><span>push</span><span>(</span><span>i</span><span>);</span>
            <span>continue</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>new_instr</span> <span>!=</span> <span>instr</span><span>)</span>
            <span>statements</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>new_instr</span><span>;</span>
    <span>}</span>
</code></pre></div></div>

<p>Next, it is time to remove all the instructions from the statement list:</p>

<div><div><pre><code><span>// remove from vector in post order</span>
<span>while</span><span>(</span><span>!</span><span>to_remove</span><span>.</span><span>empty</span><span>())</span>
<span>{</span>
    <span>auto</span> <span>index</span> <span>=</span> <span>to_remove</span><span>.</span><span>top</span><span>();</span>
    <span>to_remove</span><span>.</span><span>pop</span><span>();</span>

    <span>statements</span><span>.</span><span>erase</span><span>(</span><span>statements</span><span>.</span><span>begin</span><span>()</span> <span>+</span> <span>index</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Then, we need to go through the phi instructions from the successors. Since we have translated the instructions, we know which are the last registers that have been created using SSA form, so if we find in a successor a phi instruction that as a result has one of the registers we have converted to SSA, it means that the Phi instruction receives as one of the parameters that new defined register (this is the trick why we also have <code>ssa_to_non_ssa_form</code>, to convert the registers to non-SSA form, and being able to discover if we can insert a parameter into phi :D). Finally, to know which position the parameter is, we see the position of the current analyzed block in the list of predecessors from the node with the phi instruction:</p>

<div><div><pre><code><span>// process the phi statements from the successors</span>
<span>auto</span> <span>&amp;</span><span>succs</span> <span>=</span> <span>get_successors</span><span>(</span><span>v</span><span>);</span>
<span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>w</span> <span>:</span> <span>succs</span><span>)</span>
<span>{</span>
    <span>// if the next block does not contain</span>
    <span>// a phi node, just continue, avoid</span>
    <span>// all the other calculations</span>
    <span>if</span> <span>(</span><span>!</span><span>w</span><span>-&gt;</span><span>contains_phi_node</span><span>())</span>
        <span>continue</span><span>;</span>

    <span>// extract which_pred is v for w</span>
    <span>// this will take by index which</span>
    <span>// predecessor is v from w</span>
    <span>auto</span> <span>&amp;</span><span>preds</span> <span>=</span> <span>get_predecessors</span><span>(</span><span>w</span><span>);</span>
    <span>auto</span> <span>it</span> <span>=</span> <span>find</span><span>(</span><span>preds</span><span>.</span><span>begin</span><span>(),</span> <span>preds</span><span>.</span><span>end</span><span>(),</span> <span>v</span><span>);</span>

    <span>int</span> <span>j</span> <span>=</span> <span>-</span><span>1</span><span>;</span>

    <span>if</span> <span>(</span><span>it</span> <span>!=</span> <span>preds</span><span>.</span><span>end</span><span>())</span>
        <span>j</span> <span>=</span> <span>it</span> <span>-</span> <span>preds</span><span>.</span><span>begin</span><span>();</span>

    <span>// now look for phi functions.</span>
    <span>auto</span> <span>&amp;</span><span>w_stmnts</span> <span>=</span> <span>w</span><span>-&gt;</span><span>get_statements</span><span>();</span>
    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>w_stmnt</span> <span>:</span> <span>w_stmnts</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>auto</span> <span>phi_instr</span> <span>=</span> <span>phi_ir</span><span>(</span><span>w_stmnt</span><span>))</span>
        <span>{</span>
            <span>// trick to fill the parameters from the PHI function</span>
            <span>// extract the result register, and turn it to a non SSA form</span>
            <span>// if needed, then assign the register to the phi statement</span>
            <span>// as one of the parameters.</span>

            <span>irreg_t</span> <span>reg</span> <span>=</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRReg</span><span>&gt;</span><span>(</span><span>phi_instr</span><span>-&gt;</span><span>get_result</span><span>());</span>

            <span>if</span> <span>(</span><span>reg</span><span>-&gt;</span><span>get_sub_id</span><span>()</span> <span>!=</span> <span>-</span><span>1</span><span>)</span>
                <span>reg</span> <span>=</span> <span>ssa_to_non_ssa_form</span><span>[</span><span>reg</span><span>];</span>

            <span>if</span> <span>(</span><span>S</span><span>.</span><span>find</span><span>(</span><span>reg</span><span>)</span> <span>!=</span> <span>S</span><span>.</span><span>end</span><span>()</span> <span>&amp;&amp;</span> <span>S</span><span>[</span><span>reg</span><span>].</span><span>size</span><span>()</span> <span>&gt;</span> <span>0</span><span>)</span>
                <span>phi_instr</span><span>-&gt;</span><span>get_params</span><span>()[</span><span>j</span><span>]</span> <span>=</span> <span>S</span><span>[</span><span>reg</span><span>].</span><span>top</span><span>();</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Finally, the <code>search</code> function will call itself with the next block to analyze, which is the next block to analyze? The one that is strictly dominated by the current one, and for that we calculated the dominance tree. In that way, we will go through all the blocks in a correct order. Finally, the algorithm pops all the registers defined in that block, finishing the algorithm for transforming the <code>IRGraph</code> into an <code>IRGraphSSA</code>:</p>

<div><div><pre><code>    <span>// go through each child from the dominance tree</span>
    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>doms</span> <span>:</span> <span>dominance_tree</span><span>)</span>
        <span>// check that current block strictly</span>
        <span>// dominates the next one to analyze</span>
        <span>if</span> <span>(</span><span>doms</span><span>.</span><span>second</span> <span>==</span> <span>v</span><span>)</span>
        <span>{</span>
            <span>auto</span> <span>&amp;</span><span>child</span> <span>=</span> <span>doms</span><span>.</span><span>first</span><span>;</span>
            <span>search</span><span>(</span><span>child</span><span>);</span>
        <span>}</span>

    <span>// now POP all the defined variables here!</span>
    <span>for</span> <span>(</span><span>auto</span> <span>x</span> <span>:</span> <span>p</span><span>)</span>
        <span>S</span><span>[</span><span>x</span><span>].</span><span>pop</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<ul>
  <li><strong>Translating the instructions to SSA</strong></li>
</ul>

<p>Each instruction will need to be handled differently to be translated to an SSA form, since each instruction uses the registers differently. For example an assignment can contain two registers, one source and one destination, if both operands are registers, we need to check if a previous SSA register exists for the source, and then create a new SSA register for the destination register. Here it is the code for doing that:</p>

<div><div><pre><code><span>// A = B</span>
<span>if</span> <span>(</span><span>auto</span> <span>assign_instr</span> <span>=</span> <span>assign_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
    <span>irstmnt_t</span> <span>source</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>source</span><span>))</span>
        <span>source</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
        <span>destination</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

    <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRAssign</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>destination</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>source</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>Mostly, the translation of the instructions is: for the register operands we look for the last created register, or we create one; for the register sources, we create a new one.</p>

<p>The phi instruction is a different case, since the code from <code>search</code> already assigned the parameters from Phi instruction as SSA registers, so only the destination register is created. But if the phi instruction contains less than two parameters, it means that the phi instruction is not necessary, so we can remove it, we do that returning null as we previously saw in the <code>search</code> function:</p>

<div><div><pre><code><span>// Phi node (only the result)</span>
<span>if</span> <span>(</span><span>auto</span> <span>phi_instr</span> <span>=</span> <span>phi_ir</span><span>(</span><span>instr</span><span>))</span>
<span>{</span>
    <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>phi_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>

    <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
        <span>result</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

    <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRPhi</span><span>&gt;</span><span>();</span>

    <span>auto</span> <span>aux</span> <span>=</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRPhi</span><span>&gt;</span><span>(</span><span>new_instr</span><span>);</span>
    <span>aux</span><span>-&gt;</span><span>add_result</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>));</span>

    <span>for</span> <span>(</span><span>auto</span> <span>param</span> <span>:</span> <span>phi_instr</span><span>-&gt;</span><span>get_params</span><span>())</span>
    <span>{</span>
        <span>aux</span><span>-&gt;</span><span>add_param</span><span>(</span><span>param</span><span>.</span><span>second</span><span>,</span> <span>param</span><span>.</span><span>first</span><span>);</span>
    <span>}</span>

    <span>// not necessary a phi where we do not have</span>
    <span>// more than one parameter</span>
    <span>if</span> <span>(</span><span>aux</span><span>-&gt;</span><span>get_params</span><span>().</span><span>size</span><span>()</span> <span>&lt;</span> <span>2</span><span>)</span>
        <span>return</span> <span>nullptr</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>For finishing this part, you can find here the whole method used for translating the instructions to an SSA form:</p>

<div><div><pre><code><span>irstmnt_t</span> <span>IRGraphSSA</span><span>::</span><span>translate_instruction</span><span>(</span><span>irstmnt_t</span> <span>&amp;</span><span>instr</span><span>,</span> <span>std</span><span>::</span><span>list</span><span>&lt;</span><span>irreg_t</span><span>&gt;</span> <span>&amp;</span><span>p</span><span>)</span>
<span>{</span>
    <span>irstmnt_t</span> <span>new_instr</span> <span>=</span> <span>instr</span><span>;</span>

    <span>// A = B</span>
    <span>if</span> <span>(</span><span>auto</span> <span>assign_instr</span> <span>=</span> <span>assign_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
        <span>irstmnt_t</span> <span>source</span> <span>=</span> <span>assign_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>source</span><span>))</span>
            <span>source</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
            <span>destination</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRAssign</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>destination</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>source</span><span>));</span>
    <span>}</span>
    <span>// A = IRUnaryOp B</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>unary_instr</span> <span>=</span> <span>unary_op_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>unary_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
        <span>irstmnt_t</span> <span>op</span> <span>=</span> <span>unary_instr</span><span>-&gt;</span><span>get_op</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>op</span><span>))</span>
            <span>op</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
            <span>result</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>unary_instr</span><span>-&gt;</span><span>get_unary_op_type</span><span>()</span> <span>==</span> <span>IRUnaryOp</span><span>::</span><span>CAST_OP_T</span> <span>&amp;&amp;</span> <span>unary_instr</span><span>-&gt;</span><span>get_cast_type</span><span>()</span> <span>==</span> <span>IRUnaryOp</span><span>::</span><span>TO_CLASS</span><span>)</span>
            <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRUnaryOp</span><span>&gt;</span><span>(</span><span>IRUnaryOp</span><span>::</span><span>CAST_OP_T</span><span>,</span> <span>IRUnaryOp</span><span>::</span><span>TO_CLASS</span><span>,</span> <span>unary_instr</span><span>-&gt;</span><span>get_class_cast</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op</span><span>));</span>
        <span>else</span> <span>if</span> <span>(</span><span>unary_instr</span><span>-&gt;</span><span>get_unary_op_type</span><span>()</span> <span>==</span> <span>IRUnaryOp</span><span>::</span><span>CAST_OP_T</span><span>)</span>
            <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRUnaryOp</span><span>&gt;</span><span>(</span><span>IRUnaryOp</span><span>::</span><span>CAST_OP_T</span><span>,</span> <span>unary_instr</span><span>-&gt;</span><span>get_cast_type</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op</span><span>));</span>
        <span>else</span>
            <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRUnaryOp</span><span>&gt;</span><span>(</span><span>unary_instr</span><span>-&gt;</span><span>get_unary_op_type</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op</span><span>));</span>
    <span>}</span>
    <span>// A = B IRBinaryOp C</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>binary_instr</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>binary_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>
        <span>irstmnt_t</span> <span>op1</span> <span>=</span> <span>binary_instr</span><span>-&gt;</span><span>get_op1</span><span>();</span>
        <span>irstmnt_t</span> <span>op2</span> <span>=</span> <span>binary_instr</span><span>-&gt;</span><span>get_op2</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>op1</span><span>))</span>
            <span>op1</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>op2</span><span>))</span>
            <span>op2</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
            <span>result</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRBinOp</span><span>&gt;</span><span>(</span><span>binary_instr</span><span>-&gt;</span><span>get_bin_op_type</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op1</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op2</span><span>));</span>
    <span>}</span>
    <span>// A = LOAD(B[INDEX])</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>load_instr</span> <span>=</span> <span>load_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
        <span>irstmnt_t</span> <span>source</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>
        <span>irstmnt_t</span> <span>index</span> <span>=</span> <span>load_instr</span><span>-&gt;</span><span>get_index</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>source</span><span>))</span>
            <span>source</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>index</span><span>))</span>
            <span>index</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
            <span>destination</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRLoad</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>destination</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>source</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>index</span><span>),</span> <span>load_instr</span><span>-&gt;</span><span>get_size</span><span>());</span>
    <span>}</span>
    <span>// A = New Class</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>new_ir_instr</span> <span>=</span> <span>new_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>new_ir_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
            <span>result</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRNew</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>),</span> <span>new_ir_instr</span><span>-&gt;</span><span>get_source_class</span><span>());</span>
    <span>}</span>
    <span>// ret &lt;reg&gt;</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>ret_instr</span> <span>=</span> <span>ret_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>return_value</span> <span>=</span> <span>ret_instr</span><span>-&gt;</span><span>get_return_value</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>return_value</span><span>))</span>
            <span>return_value</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRRet</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>return_value</span><span>));</span>
    <span>}</span>
    <span>// call &lt;callee&gt;(arg1, arg2, arg3...)</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>call_instr</span> <span>=</span> <span>call_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>irexpr_t</span><span>&gt;</span> <span>new_args</span><span>;</span>
        <span>auto</span> <span>args</span> <span>=</span> <span>call_instr</span><span>-&gt;</span><span>get_args</span><span>();</span>
        <span>irstmnt_t</span> <span>ret_val</span> <span>=</span> <span>call_instr</span><span>-&gt;</span><span>get_ret_val</span><span>();</span>

        <span>for</span> <span>(</span><span>auto</span> <span>arg</span> <span>:</span> <span>args</span><span>)</span>
        <span>{</span>
            <span>auto</span> <span>reg</span> <span>=</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRReg</span><span>&gt;</span><span>(</span><span>arg</span><span>);</span>
            <span>new_args</span><span>.</span><span>push_back</span><span>(</span><span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>));</span>
        <span>}</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRCall</span><span>&gt;</span><span>(</span><span>call_instr</span><span>-&gt;</span><span>get_callee</span><span>(),</span> <span>call_instr</span><span>-&gt;</span><span>get_call_type</span><span>(),</span> <span>new_args</span><span>);</span>
        
        <span>// maybe a return void method</span>
        <span>if</span> <span>(</span><span>ret_val</span> <span>!=</span> <span>nullptr</span><span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>ret_val</span><span>))</span>
            <span>{</span>
                <span>ret_val</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>
                <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRCall</span><span>&gt;</span><span>(</span><span>new_instr</span><span>)</span><span>-&gt;</span><span>set_ret_val</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>ret_val</span><span>));</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>// STORE(A) = B</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>store_instr</span> <span>=</span> <span>store_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>destination</span> <span>=</span> <span>store_instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
        <span>irstmnt_t</span> <span>source</span> <span>=</span> <span>store_instr</span><span>-&gt;</span><span>get_source</span><span>();</span>
        <span>irstmnt_t</span> <span>index</span> <span>=</span> <span>store_instr</span><span>-&gt;</span><span>get_index</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>source</span><span>))</span>
            <span>source</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>index</span><span>))</span>
            <span>index</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>destination</span><span>))</span>
            <span>destination</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRStore</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>destination</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>source</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>index</span><span>),</span> <span>store_instr</span><span>-&gt;</span><span>get_size</span><span>());</span>
    <span>}</span>
    <span>// ZComp</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>zcomp</span> <span>=</span> <span>zcomp_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>op</span> <span>=</span> <span>zcomp</span><span>-&gt;</span><span>get_reg</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>op</span><span>))</span>
            <span>op</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRZComp</span><span>&gt;</span><span>(</span><span>zcomp</span><span>-&gt;</span><span>get_comparison</span><span>(),</span> <span>zcomp</span><span>-&gt;</span><span>get_result</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op</span><span>));</span>
    <span>}</span>
    <span>// BComp</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>bcomp</span> <span>=</span> <span>bcomp_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>op1</span> <span>=</span> <span>bcomp</span><span>-&gt;</span><span>get_reg1</span><span>();</span>
        <span>irstmnt_t</span> <span>op2</span> <span>=</span> <span>bcomp</span><span>-&gt;</span><span>get_reg2</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>op1</span><span>))</span>
            <span>op1</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>op2</span><span>))</span>
            <span>op2</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRBComp</span><span>&gt;</span><span>(</span><span>bcomp</span><span>-&gt;</span><span>get_comparison</span><span>(),</span> <span>bcomp</span><span>-&gt;</span><span>get_result</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op1</span><span>),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>op2</span><span>));</span>
    <span>}</span>
    <span>// Alloca</span>
    <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>alloca</span> <span>=</span> <span>alloca_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>alloca</span><span>-&gt;</span><span>get_result</span><span>();</span>
        <span>irstmnt_t</span> <span>size</span> <span>=</span> <span>alloca</span><span>-&gt;</span><span>get_size</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
            <span>result</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>size</span><span>))</span>
            <span>size</span> <span>=</span> <span>get_top_or_create</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRAlloca</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>),</span> <span>alloca</span><span>-&gt;</span><span>get_source_type</span><span>(),</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>size</span><span>));</span>
    <span>}</span>
    <span>// Phi node (only the result)</span>
    <span>if</span> <span>(</span><span>auto</span> <span>phi_instr</span> <span>=</span> <span>phi_ir</span><span>(</span><span>instr</span><span>))</span>
    <span>{</span>
        <span>irstmnt_t</span> <span>result</span> <span>=</span> <span>phi_instr</span><span>-&gt;</span><span>get_result</span><span>();</span>

        <span>if</span> <span>(</span><span>auto</span> <span>reg</span> <span>=</span> <span>register_ir</span><span>(</span><span>result</span><span>))</span>
            <span>result</span> <span>=</span> <span>create_new_ssa_reg</span><span>(</span><span>reg</span><span>,</span> <span>p</span><span>);</span>

        <span>new_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRPhi</span><span>&gt;</span><span>();</span>

        <span>auto</span> <span>aux</span> <span>=</span> <span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRPhi</span><span>&gt;</span><span>(</span><span>new_instr</span><span>);</span>
        <span>aux</span><span>-&gt;</span><span>add_result</span><span>(</span><span>std</span><span>::</span><span>dynamic_pointer_cast</span><span>&lt;</span><span>IRExpr</span><span>&gt;</span><span>(</span><span>result</span><span>));</span>

        <span>for</span> <span>(</span><span>auto</span> <span>param</span> <span>:</span> <span>phi_instr</span><span>-&gt;</span><span>get_params</span><span>())</span>
        <span>{</span>
            <span>aux</span><span>-&gt;</span><span>add_param</span><span>(</span><span>param</span><span>.</span><span>second</span><span>,</span> <span>param</span><span>.</span><span>first</span><span>);</span>
        <span>}</span>

        <span>// not necessary a phi where we do not have</span>
        <span>// more than one parameter</span>
        <span>if</span> <span>(</span><span>aux</span><span>-&gt;</span><span>get_params</span><span>().</span><span>size</span><span>()</span> <span>&lt;</span> <span>2</span><span>)</span>
            <span>return</span> <span>nullptr</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>new_instr</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h5 id="optimizer">optimizer</h5>

<p>We end the analysis part with the module I wasn’t able to fully program, the optimizer. The optimizer idea was having something like the optimization passes from LLVM, but of course, this is one of the most complex parts from the framework (even older versions from LLVM used an old version of the optimizer, and that part of LLVM was rewritten for a better version). In MjolnIR it was much more simple, so for the moment there was defined a function for optimizing one instruction from the IR (an <code>IRStmnt</code>), and for optimizing a full block (An <code>IRBlock</code> from an <code>IRGraph</code>), and they were defined in the following way:</p>

<div><div><pre><code><span>using</span> <span>one_stmnt_opt_t</span> <span>=</span> <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irstmnt_t</span><span>&gt;</span> <span>(</span><span>*</span><span>)(</span><span>irstmnt_t</span> <span>&amp;</span><span>);</span>
<span>using</span> <span>one_block_opt_t</span> <span>=</span> <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>(</span><span>*</span><span>)(</span><span>irblock_t</span> <span>&amp;</span><span>,</span> <span>irgraph_t</span> <span>&amp;</span><span>);</span>
</code></pre></div></div>

<p>The optimizer class contained a vector to store functions from both:</p>

<div><div><pre><code><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>one_stmnt_opt_t</span><span>&gt;</span> <span>single_statement_optimization</span><span>;</span>
<span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>one_block_opt_t</span><span>&gt;</span> <span>single_block_optimization</span><span>;</span>
</code></pre></div></div>

<p>And methods to add them:</p>

<div><div><pre><code><span>/**
 * @brief Add a single line optimization to the vector of optimizations
 *
 * @param opt
 */</span>
<span>void</span> <span>add_single_stmnt_pass</span><span>(</span><span>one_stmnt_opt_t</span> <span>opt</span><span>);</span>

<span>/**
 * @brief Add a single block optimization to the vector of optimizations
 * 
 * @param opt 
 */</span>
<span>void</span> <span>add_single_block_pass</span><span>(</span><span>one_block_opt_t</span> <span>opt</span><span>);</span>
</code></pre></div></div>

<p>Finally, there was a method to run the optimization pipeline:</p>

<div><div><pre><code><span>/**
 * @brief Run all the selected optimizations.
 *
 * @param func
 */</span>
<span>void</span> <span>run_analysis</span><span>(</span><span>irgraph_t</span> <span>func</span><span>);</span>
</code></pre></div></div>

<p>First, the optimizations were run instruction by instruction through the single statement optimizers, and statements were updated accordingly in case there was an optimization. Secondly, the optimizations for blocks, as well, the blocks were updated accordingly. Finally, since the <code>optimizer</code> class contained the reaching definition, this reaching definition analysis was re-run after the optimizations.</p>

<p>At that moment, I wrote a few optimizations, and the user was able to retrieve a new default optimizer with those optimizations:</p>

<div><div><pre><code><span>optimizer_t</span> <span>NewDefaultOptimizer</span><span>()</span>
<span>{</span>
    <span>auto</span> <span>optimizer</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>Optimizer</span><span>&gt;</span><span>();</span>

    <span>// single statement optimizers</span>
    <span>optimizer</span><span>-&gt;</span><span>add_single_stmnt_pass</span><span>(</span><span>KUNAI</span><span>::</span><span>MJOLNIR</span><span>::</span><span>constant_folding</span><span>);</span>

    <span>// single block optimizers</span>
    <span>optimizer</span><span>-&gt;</span><span>add_single_block_pass</span><span>(</span><span>KUNAI</span><span>::</span><span>MJOLNIR</span><span>::</span><span>nop_removal</span><span>);</span>
    <span>optimizer</span><span>-&gt;</span><span>add_single_block_pass</span><span>(</span><span>KUNAI</span><span>::</span><span>MJOLNIR</span><span>::</span><span>expression_simplifier</span><span>);</span>
    <span>optimizer</span><span>-&gt;</span><span>add_single_block_pass</span><span>(</span><span>KUNAI</span><span>::</span><span>MJOLNIR</span><span>::</span><span>instruction_combining</span><span>);</span>

    <span>return</span> <span>optimizer</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Later in the links you will be able to see how the optimizations were written, but here you have an example of <code>expression_simplifier</code> which took a block of code, and then tried to simplify mathematical expressions:</p>

<div><div><pre><code><span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>expression_simplifier</span><span>(</span><span>irblock_t</span> <span>&amp;</span><span>block</span><span>,</span> <span>irgraph_t</span> <span>&amp;</span><span>graph</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>&amp;</span><span>stmnts</span> <span>=</span> <span>block</span><span>-&gt;</span><span>get_statements</span><span>();</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>KUNAI</span><span>::</span><span>MJOLNIR</span><span>::</span><span>irstmnt_t</span><span>&gt;</span> <span>new_statements</span><span>;</span>

    <span>// The idea here is to create a new vector with new statements</span>
    <span>// also we will apply this optimizations until no more modifications</span>
    <span>// are applied, because we can apply simplification in cascase.</span>
    <span>bool</span> <span>modified</span> <span>=</span> <span>true</span><span>;</span>
    <span>while</span> <span>(</span><span>modified</span><span>)</span>
    <span>{</span>
        <span>// create a new state</span>
        <span>modified</span> <span>=</span> <span>false</span><span>;</span>
        <span>new_statements</span><span>.</span><span>clear</span><span>();</span>

        <span>// here analyze the instructions, and apply simplifications</span>
        <span>for</span> <span>(</span><span>size_t</span> <span>i</span> <span>=</span> <span>0</span><span>,</span> <span>stmnts_size</span> <span>=</span> <span>stmnts</span><span>.</span><span>size</span><span>();</span> <span>i</span> <span>&lt;</span> <span>stmnts_size</span><span>;)</span>
        <span>{</span>
            <span>// SimplifySubInst</span>
            <span>// X - (X - Y) -&gt; Y</span>
            <span>if</span> <span>(</span><span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>SUB_OP_T</span> <span>&amp;&amp;</span> <span>(</span><span>stmnts_size</span> <span>-</span> <span>i</span><span>)</span> <span>&gt;=</span> <span>2</span> <span>&amp;&amp;</span>
                <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>SUB_OP_T</span><span>)</span>
            <span>{</span>
                <span>auto</span> <span>first_instr</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>]);</span>
                <span>auto</span> <span>second_instr</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>]);</span>

                <span>if</span> <span>(</span><span>first_instr</span><span>-&gt;</span><span>get_op1</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>first_instr</span><span>-&gt;</span><span>get_op2</span><span>())</span> <span>&amp;&amp;</span>
                    <span>second_instr</span><span>-&gt;</span><span>get_op1</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>first_instr</span><span>-&gt;</span><span>get_result</span><span>()))</span>
                <span>{</span>
                    <span>irassign_t</span> <span>assign_inst</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRAssign</span><span>&gt;</span><span>(</span><span>second_instr</span><span>-&gt;</span><span>get_result</span><span>(),</span> <span>second_instr</span><span>-&gt;</span><span>get_op2</span><span>());</span>
                    <span>new_statements</span><span>.</span><span>push_back</span><span>(</span><span>assign_inst</span><span>);</span>
                    <span>i</span> <span>+=</span> <span>2</span><span>;</span>
                    <span>modified</span> <span>=</span> <span>true</span><span>;</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
            <span>}</span>
</code></pre></div></div>

<p>Another one, <code>instruction_combining</code> was also fun to write in order to simplify other mathematical instructions, combining operands:</p>

<div><div><pre><code><span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>irblock_t</span><span>&gt;</span> <span>instruction_combining</span><span>(</span><span>irblock_t</span> <span>&amp;</span><span>block</span><span>,</span> <span>irgraph_t</span> <span>&amp;</span><span>graph</span><span>)</span>
<span>{</span>
    <span>...</span>
    <span>// (A | (B ^ C)) ^ ((A ^ C) ^ B)</span>
    <span>// =============================</span>
    <span>// (A &amp; (B ^ C))</span>
    <span>if</span> <span>(</span><span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>XOR_OP_T</span>
        <span>&amp;&amp;</span> <span>(</span><span>stmnts_size</span> <span>-</span> <span>i</span><span>)</span> <span>&gt;=</span> <span>5</span>
        <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>1</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>1</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>OR_OP_T</span>
        <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>2</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>2</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>XOR_OP_T</span>
        <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>3</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>3</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>XOR_OP_T</span>
        <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>4</span><span>])</span> <span>&amp;&amp;</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>4</span><span>])</span><span>-&gt;</span><span>get_bin_op_type</span><span>()</span> <span>==</span> <span>IRBinOp</span><span>::</span><span>XOR_OP_T</span><span>)</span>
    <span>{</span>
        <span>auto</span> <span>first_xor</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>]);</span>
        <span>auto</span> <span>second_or</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>1</span><span>]);</span>
        <span>auto</span> <span>third_xor</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>2</span><span>]);</span>
        <span>auto</span> <span>fourth_xor</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>3</span><span>]);</span>
        <span>auto</span> <span>fifth_xor</span> <span>=</span> <span>bin_op_ir</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>+</span><span>4</span><span>]);</span>
    
        <span>auto</span> <span>B</span> <span>=</span> <span>first_xor</span><span>-&gt;</span><span>get_op1</span><span>();</span>
        <span>auto</span> <span>C</span> <span>=</span> <span>first_xor</span><span>-&gt;</span><span>get_op2</span><span>();</span>
        <span>auto</span> <span>A</span> <span>=</span> <span>second_or</span><span>-&gt;</span><span>get_op1</span><span>();</span>
    
        <span>if</span> <span>(</span>
            <span>second_or</span><span>-&gt;</span><span>get_op2</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>first_xor</span><span>-&gt;</span><span>get_result</span><span>())</span>
            <span>&amp;&amp;</span> <span>third_xor</span><span>-&gt;</span><span>get_op1</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>A</span><span>)</span>
            <span>&amp;&amp;</span> <span>third_xor</span><span>-&gt;</span><span>get_op2</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>C</span><span>)</span>
            <span>&amp;&amp;</span> <span>fourth_xor</span><span>-&gt;</span><span>get_op1</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>third_xor</span><span>-&gt;</span><span>get_result</span><span>())</span>
            <span>&amp;&amp;</span> <span>fourth_xor</span><span>-&gt;</span><span>get_op2</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>B</span><span>)</span>
            <span>&amp;&amp;</span> <span>fifth_xor</span><span>-&gt;</span><span>get_op1</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>second_or</span><span>-&gt;</span><span>get_result</span><span>())</span>
            <span>&amp;&amp;</span> <span>fifth_xor</span><span>-&gt;</span><span>get_op2</span><span>()</span><span>-&gt;</span><span>equals</span><span>(</span><span>fourth_xor</span><span>-&gt;</span><span>get_result</span><span>())</span>
        <span>)</span>
        <span>{</span>
            <span>auto</span> <span>new_temporal</span> <span>=</span> <span>graph</span><span>-&gt;</span><span>get_last_temporal</span><span>()</span> <span>+</span> <span>1</span><span>;</span>
            <span>graph</span><span>-&gt;</span><span>set_last_temporal</span><span>(</span><span>new_temporal</span><span>);</span>
            
            <span>std</span><span>::</span><span>string</span> <span>temp_name</span> <span>=</span> <span>&#34;t&#34;</span> <span>+</span> <span>new_temporal</span><span>;</span>
    
            <span>auto</span> <span>temp_reg</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRTempReg</span><span>&gt;</span><span>(</span><span>new_temporal</span><span>,</span><span>temp_name</span><span>,</span> <span>4</span><span>);</span>
    
            <span>auto</span> <span>created_xor</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRBinOp</span><span>&gt;</span><span>(</span><span>IRBinOp</span><span>::</span><span>XOR_OP_T</span><span>,</span> <span>temp_reg</span><span>,</span> <span>B</span><span>,</span><span>C</span><span>);</span>
            <span>auto</span> <span>created_and</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>IRBinOp</span><span>&gt;</span><span>(</span><span>IRBinOp</span><span>::</span><span>AND_OP_T</span><span>,</span> <span>fifth_xor</span><span>-&gt;</span><span>get_result</span><span>(),</span> <span>temp_reg</span><span>,</span> <span>A</span><span>);</span>
    
            <span>new_statements</span><span>.</span><span>push_back</span><span>(</span><span>created_xor</span><span>);</span>
            <span>new_statements</span><span>.</span><span>push_back</span><span>(</span><span>created_and</span><span>);</span>
            <span>i</span> <span>+=</span> <span>5</span><span>;</span>
            <span>modified</span> <span>=</span> <span>true</span><span>;</span>
            <span>continue</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>// if the instruction has not been optimized,</span>
    <span>// means it is not an interesting expression</span>
    <span>// then push it and go ahead.</span>
    <span>new_statements</span><span>.</span><span>push_back</span><span>(</span><span>stmnts</span><span>[</span><span>i</span><span>]);</span>
    <span>i</span><span>++</span><span>;</span>
    <span>}</span>
</code></pre></div></div>

<p>I agree that the method wasn’t good since you had to specifically match each operand with each side of the instruction. In future versions the idea was to improve the optimizer to allow better rules, but finally, the project changed.</p>

<h4 id="mjolnir---dalvik-bytecode-lifting">MjolnIR - Dalvik Bytecode Lifting</h4>

<p>We reach the last section, which covers the lifting process that I will try to summarize to make this last part of the blog simple.</p>

<p>The lifter was able to lift the disassembled instructions from Kunai, the lifter was able to lift one single instruction to add it to a block, a block to add it to an <code>IRGraph</code>, and the main method <code>lift_android_method</code> received two Kunai objects in order to provide a full lifted Method in an <code>IRGraph</code> object.</p>

<div><div><pre><code><span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>lift_android_method</span><span>(</span><span>DEX</span><span>::</span><span>MethodAnalysis</span><span>*</span> <span>method_analysis</span><span>,</span> <span>DEX</span><span>::</span><span>Analysis</span><span>*</span> <span>android_analysis</span><span>);</span>
<span>bool</span> <span>lift_android_basic_block</span><span>(</span><span>DEX</span><span>::</span><span>DVMBasicBlock</span><span>*</span> <span>basic_block</span><span>,</span> <span>MJOLNIR</span><span>::</span><span>irblock_t</span><span>&amp;</span> <span>bb</span><span>);</span>
<span>bool</span> <span>lift_android_instruction</span><span>(</span><span>DEX</span><span>::</span><span>Instruction</span><span>*</span> <span>instruction</span><span>,</span> <span>MJOLNIR</span><span>::</span><span>irblock_t</span><span>&amp;</span> <span>bb</span><span>);</span>
</code></pre></div></div>

<p>The process of lifting was just going block by block, lifting it, and for each block, instruction by instruction. Once all the instructions were lifted, the control-flow was created between blocks. Jump analysis and a fallthrough analysis were done to correctly detect the targets from the jumps, but also to correctly detect the fallthrough blocks. This is the function used to lift each Android method:</p>

<div><div><pre><code><span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>LifterAndroid</span><span>::</span><span>lift_android_method</span><span>(</span><span>DEX</span><span>::</span><span>MethodAnalysis</span><span>*</span> <span>method_analysis</span><span>,</span> <span>DEX</span><span>::</span><span>Analysis</span><span>*</span> <span>android_analysis</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>&amp;</span> <span>bbs</span> <span>=</span> <span>method_analysis</span><span>-&gt;</span><span>get_basic_blocks</span><span>()</span><span>-&gt;</span><span>get_basic_blocks</span><span>();</span>
    <span>size_t</span> <span>n_bbs</span> <span>=</span> <span>bbs</span><span>.</span><span>size</span><span>();</span>
    <span>// set android_analysis</span>
    <span>this</span><span>-&gt;</span><span>android_analysis</span> <span>=</span> <span>android_analysis</span><span>;</span>
    <span>// graph returnedd by</span>
    <span>MJOLNIR</span><span>::</span><span>irgraph_t</span> <span>method_graph</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>MJOLNIR</span><span>::</span><span>IRGraph</span><span>&gt;</span><span>();</span>

    <span>// first of all lift all the blocks</span>
    <span>for</span> <span>(</span><span>auto</span> <span>bb</span> <span>:</span> <span>bbs</span><span>)</span>
    <span>{</span>
        <span>MJOLNIR</span><span>::</span><span>irblock_t</span> <span>lifted_bb</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>MJOLNIR</span><span>::</span><span>IRBlock</span><span>&gt;</span><span>();</span>

        <span>this</span><span>-&gt;</span><span>lift_android_basic_block</span><span>(</span><span>bb</span><span>.</span><span>get</span><span>(),</span> <span>lifted_bb</span><span>);</span>

        <span>lifted_blocks</span><span>[</span><span>bb</span><span>.</span><span>get</span><span>()]</span> <span>=</span> <span>lifted_bb</span><span>;</span>

        <span>method_graph</span><span>-&gt;</span><span>add_node</span><span>(</span><span>lifted_bb</span><span>);</span>
    <span>}</span>

    <span>// Create Control Flow Graph using the children nodes</span>
    <span>// from the method blocks.</span>
    <span>for</span> <span>(</span><span>auto</span> <span>bb</span> <span>:</span> <span>bbs</span><span>)</span>
    <span>{</span>
        <span>auto</span> <span>&amp;</span> <span>next_bbs</span> <span>=</span> <span>bb</span><span>-&gt;</span><span>get_next</span><span>();</span>

        <span>auto</span> <span>current_bb</span> <span>=</span> <span>lifted_blocks</span><span>[</span><span>bb</span><span>.</span><span>get</span><span>()];</span>

        <span>for</span> <span>(</span><span>auto</span> <span>next_bb</span> <span>:</span> <span>next_bbs</span><span>)</span>
        <span>{</span>
            <span>auto</span> <span>block</span> <span>=</span> <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>2</span><span>&gt;</span><span>(</span><span>next_bb</span><span>).</span><span>get</span><span>();</span>

            <span>if</span> <span>(</span><span>lifted_blocks</span><span>.</span><span>find</span><span>(</span><span>block</span><span>)</span> <span>==</span> <span>lifted_blocks</span><span>.</span><span>end</span><span>())</span>
                <span>continue</span><span>;</span>

            <span>if</span> <span>(</span><span>lifted_blocks</span><span>[</span><span>block</span><span>]</span><span>-&gt;</span><span>get_number_of_statements</span><span>()</span> <span>==</span> <span>0</span><span>)</span>
                <span>continue</span><span>;</span>

            <span>auto</span> <span>last_instr</span> <span>=</span> <span>lifted_blocks</span><span>[</span><span>block</span><span>]</span><span>-&gt;</span><span>get_statements</span><span>().</span><span>back</span><span>();</span>

            <span>// unsigned jumps are fixed later, they only have to point</span>
            <span>// to where jump targets</span>
            <span>if</span> <span>(</span><span>last_instr</span><span>-&gt;</span><span>get_op_type</span><span>()</span> <span>!=</span> <span>MJOLNIR</span><span>::</span><span>IRStmnt</span><span>::</span><span>UJMP_OP_T</span><span>)</span>
                <span>method_graph</span><span>-&gt;</span><span>add_edge</span><span>(</span><span>current_bb</span><span>,</span> <span>lifted_blocks</span><span>[</span><span>block</span><span>]);</span>
        <span>}</span>
    <span>}</span>

    <span>this</span><span>-&gt;</span><span>jump_target_analysis</span><span>(</span><span>bbs</span><span>,</span> <span>method_graph</span><span>);</span>
    <span>optimizer</span><span>-&gt;</span><span>fallthrough_target_analysis</span><span>(</span><span>method_graph</span><span>);</span>


    <span>method_graph</span><span>-&gt;</span><span>set_last_temporal</span><span>(</span><span>temp_reg_id</span> <span>-</span> <span>1</span><span>);</span>
    <span>// clean android_analysis</span>
    <span>this</span><span>-&gt;</span><span>android_analysis</span> <span>=</span> <span>nullptr</span><span>;</span>

    <span>return</span> <span>method_graph</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The translation of every instruction means understanding the semantic of each instruction, and creating an IR instruction that fits that semantic. The <code>lift_android_instruction</code> function was a veeeery long function with a veeeery long switch statement that detected the opcode of the instruction, and depending on the opcode, the functionality of the instruction was emulated with an IR instruction. A very simple example, the move instruction:</p>

<div><div><pre><code><span>case</span> <span>DEX</span><span>::</span><span>DVMTypes</span><span>::</span><span>Opcode</span><span>::</span><span>OP_MOVE</span><span>:</span>
<span>case</span> <span>DEX</span><span>::</span><span>DVMTypes</span><span>::</span><span>Opcode</span><span>::</span><span>OP_MOVE_WIDE</span><span>:</span>
<span>case</span> <span>DEX</span><span>::</span><span>DVMTypes</span><span>::</span><span>Opcode</span><span>::</span><span>OP_MOVE_OBJECT</span><span>:</span>
<span>{</span>
    <span>MJOLNIR</span><span>::</span><span>irstmnt_t</span> <span>assignment_instr</span><span>;</span>

    <span>auto</span> <span>instr</span> <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>DEX</span><span>::</span><span>Instruction12x</span><span>*&gt;</span><span>(</span><span>instruction</span><span>);</span>
    <span>auto</span> <span>dest</span> <span>=</span> <span>instr</span><span>-&gt;</span><span>get_destination</span><span>();</span>
    <span>auto</span> <span>src</span> <span>=</span> <span>instr</span><span>-&gt;</span><span>get_source</span><span>();</span>

    <span>auto</span> <span>dest_reg</span> <span>=</span> <span>make_android_register</span><span>(</span><span>dest</span><span>);</span>
    <span>auto</span> <span>src_reg</span> <span>=</span> <span>make_android_register</span><span>(</span><span>src</span><span>);</span>

    <span>assignment_instr</span> <span>=</span> <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>MJOLNIR</span><span>::</span><span>IRAssign</span><span>&gt;</span><span>(</span><span>dest_reg</span><span>,</span> <span>src_reg</span><span>);</span>

    <span>bb</span><span>-&gt;</span><span>append_statement_to_block</span><span>(</span><span>assignment_instr</span><span>);</span>

    <span>break</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The design of a very long switch wasn’t good at all I think, so in newer versions, this long switch was replaced by an <code>unordered_map</code> and function pointers, these functions created through a template, and from the template different functions were specialized depending on the opcode or the type of the instruction.</p>

<p>Together with the lifter for the instructions, I created different helper functions to create data types like registers, temporal registers, strings, classes, fields, etc:</p>

<div><div><pre><code><span>MJOLNIR</span><span>::</span><span>irreg_t</span> <span>make_android_register</span><span>(</span><span>std</span><span>::</span><span>uint32_t</span> <span>reg_id</span><span>);</span>

<span>MJOLNIR</span><span>::</span><span>irtempreg_t</span> <span>make_temporal_register</span><span>();</span>

<span>MJOLNIR</span><span>::</span><span>irtype_t</span> <span>make_none_type</span><span>();</span>

<span>MJOLNIR</span><span>::</span><span>irconstint_t</span> <span>make_int</span><span>(</span><span>std</span><span>::</span><span>uint64_t</span> <span>value</span><span>,</span> <span>bool</span> <span>is_signed</span><span>,</span> <span>size_t</span> <span>type_size</span><span>);</span>

<span>MJOLNIR</span><span>::</span><span>irstring_t</span> <span>make_str</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>value</span><span>);</span>

<span>MJOLNIR</span><span>::</span><span>irclass_t</span> <span>make_class</span><span>(</span><span>DEX</span><span>::</span><span>Class</span><span>*</span> <span>value</span><span>);</span>

<span>MJOLNIR</span><span>::</span><span>irfundamental_t</span> <span>make_fundamental</span><span>(</span><span>DEX</span><span>::</span><span>Fundamental</span><span>*</span> <span>value</span><span>);</span>

<span>MJOLNIR</span><span>::</span><span>irfield_t</span> <span>make_field</span><span>(</span><span>DEX</span><span>::</span><span>FieldID</span><span>*</span> <span>field</span><span>);</span>
</code></pre></div></div>

<h2 id="links">Links</h2>

<p>Next, I will paste the links of the code where you can read the whole sources for all I have talked about in the post.</p>

<ul>
  <li>Headers
    <ul>
      <li>IRGraph: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/include/KUNAI/mjolnIR/ir_graph.hpp</li>
      <li>All the classes for defining the instructions of MjolnIR: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/include/KUNAI/mjolnIR/ir_grammar.hpp</li>
      <li>All the analysis classes, the graph analyses, the optimizer, reaching definition, etc: https://github.com/Fare9/KUNAI-static-analyzer/tree/main/old/src/include/KUNAI/mjolnIR/Analysis</li>
      <li>The definitions from the lifter: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/include/KUNAI/mjolnIR/Lifters/lifter_android.hpp</li>
    </ul>
  </li>
  <li>Sources
    <ul>
      <li>Code from <code>IRBlock</code>s: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/ir_blocks.cpp</li>
      <li>Code from <code>IRExpr</code>s: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/ir_expr.cpp</li>
      <li>Code from <code>IRGraph</code>: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/ir_graph.cpp</li>
      <li>Code from <code>IRStmnt</code>s: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/ir_stmnt.cpp</li>
      <li>Code from <code>IRType</code>s: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/ir_type.cpp</li>
      <li>Some utilities to work with the IR: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/ir_utils.cpp</li>
      <li>All the analysis code: https://github.com/Fare9/KUNAI-static-analyzer/tree/main/old/src/mjolnIR/Analysis</li>
      <li>The code from the lifter: https://github.com/Fare9/KUNAI-static-analyzer/blob/main/old/src/mjolnIR/Lifters/lifter_android.cpp</li>
    </ul>
  </li>
</ul>

<h2 id="last-words">Last Words</h2>

<p>So… Here we are my old friend… This is the end of this long post. And maybe you jumped here directly from the beginning… But I really hope this post was useful for you, or for your team, or for your PhD thesis, master thesis or even undergrad thesis.</p>

<p>I wrote Kunai, mostly by my own, with learning purposes, even if the code grew enough to become part of my PhD thesis, but I was just chasing knowledge. I was able to improve my knowledge about the Android Dalvik file format, in programming with C++, in writing static binary analysis tools… I learned a lot. And this knowledge was pretty useful to get my current job. And now I wanted to give this knowledge to everyone else.</p>

<p>I think here is the place where I can say thank you to some people, so… Special thanks to Rob who has helped me a lot during my beginnings in Quarkslab, Matteo who always gave me his opinion about the implemented analyses, to Juan, Antonio, Angela (who also added her small contribution to the project), Qiqi (who was with me when I published this version of Kunai: Japanese version), to all my colleagues from Quarkslab, and my friends from Lega Kai. Probably I forget many other people, but specially thanks to you for reading until here.</p>

<figure>
<a href="https://loeber.substack.com/assets/images/hacklu-ollvm/seeu.jpeg"><img src="https://loeber.substack.com/assets/images/hacklu-ollvm/seeu.jpeg"/></a>
</figure>

        
      </section>

      

      


      
  

    </div></div>
  </body>
</html>
