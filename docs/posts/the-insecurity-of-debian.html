<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unix.foo/posts/insecurity-of-debian/">Original</a>
    <h1>The Insecurity of Debian</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>In June of 2023 Red Hat made a controversial decision to change how they distribute the source code behind Red Hat Enterprise Linux (RHEL). There have been a lot of keyboards tapped angrily across social media that left many uncertain about the ramifications of the decision. There were many questions about the future viability of downstream rebuilds of RHEL affecting distributions like Rocky Linux, AlmaLinux, Oracle Linux, and others. Each have since made announcements to try and calm their communities.</p>
<p>Still. Many in the open source community have interpreted Red Hat’s decision for what it really was: A dick move.</p>
<p>There has been a steady uptick of people stating that they will migrate (or already have) to Debian – seeking refuge from what they see as greedy corporate influence. I understand the sentiment fully. However, there’s a problem here that I want to talk about: security.</p>
<p>The ugly truth is that security is hard. It’s tedious. Unpleasant. And requires a lot of work to get right.</p>
<p>Debian does not do enough here to protect users.</p>
<p>Long ago, Red Hat embraced the usage of <a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux">SELinux</a>. And they took it beyond just enabling the feature in their kernel. They put in the arduous work of crafting default SELinux policies for their distribution.</p>
<p>These <a href="https://www.redhat.com/sysadmin/selinux-kata-containers">policies ship enabled by default</a> in their distribution. The policies help protect a variety of daemons that run by default on RHEL, as well as many of the most popular daemons folks tend to use on the server.</p>
<p>Apache, nginx, MariaDB, PostgreSQL, OpenSSH, etc. are all covered by SELinux policies that ship on RHEL distributions.</p>
<p>The protection even extends to containers. Containers are increasingly the preferred method for developers to deploy their software – myself included. A common misconception is that if you run something in a container, it’s inherently secure. This is absolutely not true. Containers by themselves do not solve a security problem. They solve a software distribution problem. They give a false impression of security to those that run them.</p>
<p>On Red Hat based distributions, you can use a drop-in Docker alternative named podman which allows you to run containers without needing a daemon (unlike Docker) and it provides other benefits like being able to run fully root-less. But Red Hat takes it a step further here and applies strong default SELinux policies that separate the container from the host OS and even from other containers!</p>
<p>There have been numerous <a href="https://www.redhat.com/en/blog/latest-container-exploit-runc-can-be-blocked-selinux?intcmp=701f20000012ngPAAQ">examples</a> of being able to escape from a container and touch the host OS or other containers. This is where tools like SELinux step in. The application of SELinux policies on a container allows for a hardened sarcophagus to place your application in which mitigates the risk of unknown future exploits. And it’s nearly effortless to use on RHEL.</p>
<p>Red Hat was aware that unless they put in the work on these default policies, their users would simply not embrace the technology and millions of servers would remain vulnerable. Because let’s be real here. SELinux is hard. The policy language and tooling is cumbersome, obtuse, and is about as appealing as filling out tax forms. It frankly sucks to use – if you are manually creating your own policies that is.</p>
<p>But due to the work Red Hat has put in, the usage of SELinux on RHEL is mostly transparent and provides real security benefits to their users.</p>
<h2 id="debians-approach">Debian’s Approach</h2>
<p>Debian, a stalwart of the open-source community, is revered for its stability and extensive software library. I am a fan and <a href="https://www.debian.org/donations">donate</a> to the project every year (you should too!) even though I don’t run it in production environments.</p>
<p>However, its default security framework leaves much to be desired. Debian’s decision to enable <a href="https://en.wikipedia.org/wiki/AppArmor">AppArmor</a> by default starting with version 10 signifies a positive step towards improved security, yet it falls short due to the half-baked implementation across the system.</p>
<p>Debian’s reliance on AppArmor and its default configurations reveals a systemic issue with its approach to security. While AppArmor is capable of providing robust security when properly configured, Debian’s out-of-the-box settings fail to leverage its full potential:</p>
<p><strong>Limited Default Profiles:</strong> Debian ships with a minimal set of AppArmor profiles, leaving many critical services unprotected.</p>
<p><strong>Reactive vs. Proactive Stance:</strong> Debian’s security model often relies on users to implement stricter policies, rather than providing a secure-by-default configuration.</p>
<p><strong>Inconsistent Application:</strong> Unlike SELinux in Red Hat systems, which applies to the entire system consistently, AppArmor in Debian is applied piecemeal, leading to potential security gaps.</p>
<p><strong>Lack of Resources:</strong> Debian as a community-driven project lacks the resources to develop and maintain comprehensive security policies comparable to those provided by Red Hat.</p>
<p>It’s very common for folks to run container workloads on Debian via Docker – which <a href="https://docs.docker.com/engine/security/apparmor/">does automatically generate</a> and load a default AppArmor profile for containers named <code>docker-default</code>. Unfortunately, it’s not a very strong profile for security and is overly permissive.</p>
<p>This profile, while providing some protection, <a href="https://github.com/moby/moby/blob/master/profiles/apparmor/template.go">leaves significant attack surfaces</a> exposed. For instance:</p>
<div><pre tabindex="0"><code data-lang="gdscript3"><span><span>  <span>network</span><span>,</span>
</span></span><span><span>  <span>capability</span><span>,</span>
</span></span><span><span>  <span>file</span><span>,</span>
</span></span><span><span>  <span>umount</span><span>,</span>
</span></span><span><span>  <span># Host (privileged) processes may send signals to container processes.</span>
</span></span><span><span>  <span>signal</span> <span>(</span><span>receive</span><span>)</span> <span>peer</span><span>=</span><span>unconfined</span><span>,</span>
</span></span><span><span>  <span># runc may send signals to container processes (for &#34;docker stop&#34;).</span>
</span></span><span><span>  <span>signal</span> <span>(</span><span>receive</span><span>)</span> <span>peer</span><span>=</span><span>runc</span><span>,</span>
</span></span><span><span>  <span># crun may send signals to container processes (for &#34;docker stop&#34; when used with crun OCI runtime).</span>
</span></span><span><span>  <span>signal</span> <span>(</span><span>receive</span><span>)</span> <span>peer</span><span>=</span><span>crun</span><span>,</span>
</span></span><span><span>  <span># dockerd may send signals to container processes (for &#34;docker kill&#34;).</span>
</span></span><span><span>  <span>signal</span> <span>(</span><span>receive</span><span>)</span> <span>peer</span><span>=</span><span>{{</span><span>.</span><span>DaemonProfile</span><span>}},</span>
</span></span><span><span>  <span># Container processes may send signals amongst themselves.</span>
</span></span><span><span>  <span>signal</span> <span>(</span><span>send</span><span>,</span><span>receive</span><span>)</span> <span>peer</span><span>=</span><span>{{</span><span>.</span><span>Name</span><span>}},</span>
</span></span><span><span>  <span>deny</span> <span>@</span><span>{</span><span>PROC</span><span>}</span><span>/*</span> <span>w</span><span>,</span>   <span># deny write for all files directly in /proc (not in a subdir)</span>
</span></span><span><span>  <span># deny write to files not in /proc/&lt;number&gt;/** or /proc/sys/**</span>
</span></span><span><span>  <span>deny</span> <span>@</span><span>{</span><span>PROC</span><span>}</span><span>/</span><span>{[</span><span>^</span><span>1</span><span>-</span><span>9</span><span>],[</span><span>^</span><span>1</span><span>-</span><span>9</span><span>][</span><span>^</span><span>0</span><span>-</span><span>9</span><span>],[</span><span>^</span><span>1</span><span>-</span><span>9</span><span>s</span><span>][</span><span>^</span><span>0</span><span>-</span><span>9</span><span>y</span><span>][</span><span>^</span><span>0</span><span>-</span><span>9</span><span>s</span><span>],[</span><span>^</span><span>1</span><span>-</span><span>9</span><span>][</span><span>^</span><span>0</span><span>-</span><span>9</span><span>][</span><span>^</span><span>0</span><span>-</span><span>9</span><span>][</span><span>^</span><span>0</span><span>-</span><span>9</span><span>/</span><span>]</span><span>*</span><span>}</span><span>/**</span> <span>w</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>@</span><span>{</span><span>PROC</span><span>}</span><span>/</span><span>sys</span><span>/</span><span>[</span><span>^</span><span>k</span><span>]</span><span>**</span> <span>w</span><span>,</span>  <span># deny /proc/sys except /proc/sys/k* (effectively /proc/sys/kernel)</span>
</span></span><span><span>  <span>deny</span> <span>@</span><span>{</span><span>PROC</span><span>}</span><span>/</span><span>sys</span><span>/</span><span>kernel</span><span>/</span><span>{</span><span>?</span><span>,</span><span>??</span><span>,[</span><span>^</span><span>s</span><span>][</span><span>^</span><span>h</span><span>][</span><span>^</span><span>m</span><span>]</span><span>**</span><span>}</span> <span>w</span><span>,</span>  <span># deny everything except shm* in /proc/sys/kernel/</span>
</span></span><span><span>  <span>deny</span> <span>@</span><span>{</span><span>PROC</span><span>}</span><span>/</span><span>sysrq</span><span>-</span><span>trigger</span> <span>rwklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>@</span><span>{</span><span>PROC</span><span>}</span><span>/</span><span>kcore</span> <span>rwklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>mount</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>[</span><span>^</span><span>f</span><span>]</span><span>*/**</span> <span>wklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>f</span><span>[</span><span>^</span><span>s</span><span>]</span><span>*/**</span> <span>wklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>fs</span><span>/</span><span>[</span><span>^</span><span>c</span><span>]</span><span>*/**</span> <span>wklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>fs</span><span>/</span><span>c</span><span>[</span><span>^</span><span>g</span><span>]</span><span>*/**</span> <span>wklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>fs</span><span>/</span><span>cg</span><span>[</span><span>^</span><span>r</span><span>]</span><span>*/**</span> <span>wklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>firmware</span><span>/**</span> <span>rwklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>devices</span><span>/</span><span>virtual</span><span>/</span><span>powercap</span><span>/**</span> <span>rwklx</span><span>,</span>
</span></span><span><span>  <span>deny</span> <span>/</span><span>sys</span><span>/</span><span>kernel</span><span>/</span><span>security</span><span>/**</span> <span>rwklx</span><span>,</span>
</span></span></code></pre></div><p>The <strong>network</strong> rule allows all network-related syscalls without restriction.</p>
<p>The <strong>capability</strong> rule, without specific denials, permits most capabilities by default.</p>
<p>The <strong>file</strong> rule grants broad file access permissions, relying on specific deny rules for protection.</p>
<h2 id="apparmor-vs-selinux">AppArmor vs. SELinux</h2>
<p>The fundamental difference between AppArmor and SELinux lies in their approach to Mandatory Access Control (MAC). AppArmor operates on a path-based model, while SELinux employs a significantly more complex type enforcement system. This distinction becomes particularly evident in container environments.</p>
<p>SELinux applies a type to every object in the system - files, processes, ports, you name it. When you launch a container on a SELinux-enabled RHEL system, it’s immediately assigned the <strong>container_t</strong> type – a strict access control mechanism. The <strong>container_t</strong> type effectively cordons off the container, preventing it from interacting with any object not explicitly labeled for container use.</p>
<p>But SELinux doesn’t stop at type enforcement. It takes container isolation a step further with <a href="https://en.wikipedia.org/wiki/Multi_categories_security">Multi-Category Security (MCS)</a> labels. These labels function as an additional layer of segregation, ensuring that even containers of the same type (<strong>container_t</strong>) remain isolated from each other. Each container gets its own unique MCS label, creating what amounts to a private sandbox within the broader <strong>container_t</strong> environment.</p>
<p>AppArmor, in contrast, doesn’t concern itself with types or categories. It focuses on limiting the capabilities of specific programs based on pre-defined profiles. These profiles specify which files a program can access and which operations it can perform. While this approach is more straightforward to implement and understand, it lacks the granularity and system-wide consistency of SELinux’s type enforcement. Almost no mainstream Linux distribution distributes comprehensive AppArmor profiles for all common network-facing daemons by default.</p>
<p>The practical implications of these differences are significant. In a SELinux environment, a compromised container faces substantial hurdles in accessing or affecting the host system or other containers, thanks to the dual barriers of type enforcement and MCS labels.</p>
<p>This isn’t to say one is universally superior to the other. SELinux offers more robust isolation but at the cost of increased complexity and potential performance overhead. AppArmor provides a simpler, more approachable security model that can still be quite effective when configured properly. The root of my point though is that Red Hat has put in the work here to make the use of SELinux and containers seamless and easy for its users. You aren’t left to fend for yourself.</p>
<p>In the end, the choice between Debian and Red Hat isn’t just about corporate influence versus community-driven development. It’s also a choice between a system that assumes the best and one that prepares for the worst. Unfortunately in today’s highly connected world, pessimism is a necessity.</p>

    </div></div>
  </body>
</html>
