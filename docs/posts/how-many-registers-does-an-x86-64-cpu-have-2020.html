<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2020/11/30/How-many-registers-does-an-x86-64-cpu-have">Original</a>
    <h1>How many registers does an x86-64 CPU have? (2020)</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://probablydance.com/">Home</a></li>
    <li><a href="https://probablydance.com/tags">Tags</a></li>
    <li><a href="https://probablydance.com/series">Series</a></li>
    <li><a href="https://probablydance.com/favorites">Favorites</a></li>
    <li><a href="https://probablydance.com/archive">Archive</a></li>
    
    <li><a href="https://yossarian.net">Main Site</a></li>
    <li><a href="https://yossarian.net/til">TILs</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Nov 30, 2020</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://probablydance.com/tags#programming">programming</a>,
        
          <a href="https://probablydance.com/tags#x86">x86</a>
        
      </span>
    

       

    
  </p>
</h2>






<p>
  This post is at least a year old.
  </p>


<p>x86 is back in the general programmer discourse, in part thanks to Apple’s M1 and
<a href="https://developer.apple.com/documentation/apple_silicon/about_the_rosetta_translation_environment">Rosetta 2</a>.
As such, I figured I’d do <em>yet another</em> x86-64 post.</p>

<p>Just like <a href="https://probablydance.com/2020/06/13/How-x86_64-addresses-memory">the last one</a>,
I’m going to cover a facet of the x86-64 ISA that sets it apart
as unusually complex among modern ISAs: the number and diversity of registers available.</p>

<p><a href="https://stefanheule.com/blog/how-many-x86-64-instructions-are-there-anyway/">Like instruction counting</a>,
register counting on x86-64 is subject to debates over methodology. In particular, for this blog
post, I’m going to lay the following ground rules:</p>

<ul>
  <li>
    <p>I <strong>will</strong> count sub-registers (e.g., <code>EAX</code> for <code>RAX</code>) as distinct registers. My justification:
they have different instruction encodings, and both Intel and AMD optimize/pessimize
particular sub-register use patterns in their microcode.</p>
  </li>
  <li>
    <p>I <strong>will</strong> count registers that are present on x86-64 CPUs, but that can’t be used in long mode.</p>
  </li>
  <li>
    <p>I <strong>won’t</strong> count registers that are <em>only</em> present on older x86 CPUs, like the 80386 and
80486 <a href="https://en.wikipedia.org/wiki/Test_register">test registers</a>.</p>
  </li>
  <li>
    <p>I <strong>won’t</strong> count microarchitectural implementation details, like shadow registers.</p>
  </li>
  <li>
    <p>I <strong>will</strong> count registers that aren’t directly addressable, like MSRs that can only be accessed
through <code>RDMSR</code>. However, I <strong>won’t</strong> (or will try not to) double-count registers that
have multiple access mechanisms (like <code>RDMSR</code> and <code>RDTSC</code>).</p>
  </li>
  <li>
    <p>I <strong>won’t</strong> count model-specific registers that fall into these categories:</p>
    <ul>
      <li>MSRs that are only present on niche x86 vendors (Cyrix, Via)</li>
      <li>MSRs that aren’t widely available on recent-ish x86-64 CPUs
        <ul>
          <li><strong>Errata</strong>: I accidentally included AVX-512 in some of the original counts below,
  not realizing that it hadn’t been released on any AMD CPUs. The post has been updated.</li>
        </ul>
      </li>
      <li>MSRs that are <em>completely</em> undocumented (both officially and unofficially)</li>
    </ul>
  </li>
</ul>

<p>In addition to the rules above, I’m going to use the following considerations and methodology
for grouping registers together:</p>

<ul>
  <li>
    <p>Many sources, both official and unofficial, use “model-specific register” as an umbrella term
for any non-core or non-feature-set register supplied by an x86-64 CPU. Whenever possible, I’ll
try to avoid this in favor of more specific categories.</p>
  </li>
  <li>
    <p>Both Intel and AMD provide synonyms for registers (e.g. <code>CR8</code> as the “task priority register,” or
<code>TPR</code>). Whenever possible, I’ll try to use the more generic/category conforming name (like <code>CR8</code>
in the case above).</p>
  </li>
  <li>
    <p>In general, the individual cores of a multicore processor have independent register states.
Whenever this <strong>isn’t</strong> the case, I’ll make an effort to document it.</p>
  </li>
</ul>

<hr/>

<h2 id="general-purpose-registers">General-purpose registers</h2>

<p>The general-purpose registers (or GPRs) are <strong>the</strong> primary registers in the x86-64 register model.
As their name implies, they are the <strong>only</strong> registers that are <em>general purpose</em>: each has a set
of conventional uses<sup id="fnref:conventional"><a href="#fn:conventional" rel="footnote" role="doc-noteref">1</a></sup>, but programmers are generally free to ignore those conventions and use
them as they please<sup id="fnref:ignore"><a href="#fn:ignore" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>Because x86-64 evolved from a 32-bit ISA which in turn evolved from a 16-bit ISA, each
GPR has a set of <em>subregisters</em> that hold the lower 8, 16 and 32 bits of the full 64-bit
register.</p>

<p>As a table:</p>

<table>
  <tbody><tr>
    
    <th>64-bit</th>
    
    <th>32-bit</th>
    
    <th>16-bit</th>
    
    <th>8-bit (low)</th>
    
  </tr>
  
  <tr>
    
    <td>RAX</td>
    
    <td>EAX</td>
    
    <td>AX</td>
    
    <td>AL</td>
    
  </tr>
  
  <tr>
    
    <td>RBX</td>
    
    <td>EBX</td>
    
    <td>BX</td>
    
    <td>BL</td>
    
  </tr>
  
  <tr>
    
    <td>RCX</td>
    
    <td>ECX</td>
    
    <td>CX</td>
    
    <td>CL</td>
    
  </tr>
  
  <tr>
    
    <td>RDX</td>
    
    <td>EDX</td>
    
    <td>DX</td>
    
    <td>DL</td>
    
  </tr>
  
  <tr>
    
    <td>RSI</td>
    
    <td>ESI</td>
    
    <td>SI</td>
    
    <td>SIL</td>
    
  </tr>
  
  <tr>
    
    <td>RDI</td>
    
    <td>EDI</td>
    
    <td>DI</td>
    
    <td>DIL</td>
    
  </tr>
  
  <tr>
    
    <td>RBP</td>
    
    <td>EBP</td>
    
    <td>BP</td>
    
    <td>BPL</td>
    
  </tr>
  
  <tr>
    
    <td>RSP</td>
    
    <td>ESP</td>
    
    <td>SP</td>
    
    <td>SPL</td>
    
  </tr>
  
  <tr>
    
    <td>R8</td>
    
    <td>R8D</td>
    
    <td>R8W</td>
    
    <td>R8B</td>
    
  </tr>
  
  <tr>
    
    <td>R9</td>
    
    <td>R9D</td>
    
    <td>R9W</td>
    
    <td>R9B</td>
    
  </tr>
  
  <tr>
    
    <td>R10</td>
    
    <td>R10D</td>
    
    <td>R10W</td>
    
    <td>R10B</td>
    
  </tr>
  
  <tr>
    
    <td>R11</td>
    
    <td>R11D</td>
    
    <td>R11W</td>
    
    <td>R11B</td>
    
  </tr>
  
  <tr>
    
    <td>R12</td>
    
    <td>R12D</td>
    
    <td>R12W</td>
    
    <td>R12B</td>
    
  </tr>
  
  <tr>
    
    <td>R13</td>
    
    <td>R13D</td>
    
    <td>R13W</td>
    
    <td>R13B</td>
    
  </tr>
  
  <tr>
    
    <td>R14</td>
    
    <td>R14D</td>
    
    <td>R14W</td>
    
    <td>R14B</td>
    
  </tr>
  
  <tr>
    
    <td>R15</td>
    
    <td>R15D</td>
    
    <td>R15W</td>
    
    <td>R15B</td>
    
  </tr>
  
</tbody></table>

<p>Some of the 16-bit subregisters are also special: the original 8086 allowed the <strong>high</strong> byte
of <code>AX</code>, <code>BX</code>, <code>CX</code>, and <code>DX</code> to be accessed indepenently, so x86-64 preserves this for some
encodings:</p>

<table>
  <tbody><tr>
    
    <th>16-bit</th>
    
    <th>8-bit (high)</th>
    
  </tr>
  
  <tr>
    
    <td>AX</td>
    
    <td> AH</td>
    
  </tr>
  
  <tr>
    
    <td>BX</td>
    
    <td> BH</td>
    
  </tr>
  
  <tr>
    
    <td>CX</td>
    
    <td> CH</td>
    
  </tr>
  
  <tr>
    
    <td>DX</td>
    
    <td> DH</td>
    
  </tr>
  
</tbody></table>

<p>So that’s 16 full-width GPRs, fanning out to another 52 subregisters.</p>

<p><strong>Registers in this group: 68</strong>.</p>

<p><strong>Running total: 68</strong>.</p>

<h2 id="special-registers">Special registers</h2>

<p>This is sort of an artificial category: like every ISA, x86-64 has a few “special” registers that
keep things moving along. In particular:</p>

<ul>
  <li>
    <p>The <em>instruction pointer</em>, or <code>RIP</code>.</p>

    <p>x86-64 has 32- and 16-bit variants of <code>RIP</code> (<code>EIP</code> and <code>IP</code>), but I’m <strong>not</strong> going to count
  them as separate registers: they have identical encodings and can’t be used in the same
  CPU mode<sup id="fnref:ip"><a href="#fn:ip" rel="footnote" role="doc-noteref">3</a></sup>.</p>
  </li>
  <li>
    <p>The <em>status register</em>, or <code>RFLAGS</code>.</p>

    <p>Just like <code>RIP</code>, <code>RFLAGS</code> has 32- and 16-bit counterparts (<code>EFLAGS</code> and <code>FLAGS</code>). Unlike
  <code>RIP</code>, these counterparts can be partially mixed: <code>PUSHF</code> and <code>PUSHFQ</code> are both valid in
  long mode, and <code>LAHF</code>/<code>SAHF</code> can operate on the bits of <code>FLAGS</code> on some x86-64 CPUs
  outside of compatiblility mode<sup id="fnref:cpuid-lahf-sahf"><a href="#fn:cpuid-lahf-sahf" rel="footnote" role="doc-noteref">4</a></sup>. So I’m going to go ahead and count them.</p>
  </li>
</ul>

<p><strong>Registers in this group: 4</strong>.</p>

<p><strong>Running total: 72</strong>.</p>

<h2 id="segment-registers">Segment registers</h2>

<p>x86-64 has a total of 6 segment registers: <code>CS</code>, <code>SS</code>, <code>DS</code>, <code>ES</code>, <code>FS</code>, and <code>GS</code>. The operation
varies with the CPU’s mode:</p>

<ul>
  <li>
    <p>In all modes except for long mode, each segment register holds a <em>selector</em>, which indexes into
either the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">GDT</a> or
<a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table#Local_Descriptor_Table">LDT</a>. That yields
a segment <em>descriptor</em> which, among other things, supplies the base address and extent of the
segment.</p>
  </li>
  <li>
    <p>In long mode all but <code>FS</code> and <code>GS</code> are treated as having a base address of zero and a 64-bit
extent, effectively producing a flat address space. <code>FS</code> and <code>GS</code> are retained as special cases,
but no longer use the segment descriptor tables: instead, they access base addresses that
are stored in the <code>FSBASE</code> and <code>GSBASE</code> model-specific registers<sup id="fnref:kernelgsbase"><a href="#fn:kernelgsbase" rel="footnote" role="doc-noteref">5</a></sup>.
More on those later.</p>
  </li>
</ul>

<p><strong>Registers in this group: 6</strong>.</p>

<p><strong>Running total: 78</strong>.</p>

<h2 id="simd-and-fp-registers">SIMD and FP registers</h2>

<p>The x86 family has gone through <em>several</em> generations of SIMD and floating-point instruction
groups, each of which has introduced, extended, or re-contextualized various registers:</p>

<ul>
  <li>x87</li>
  <li>MMX</li>
  <li>SSE (SSE2, SSE3, SSE4, SSE4, …)</li>
  <li>AVX (AVX2, AVX512)</li>
</ul>

<p>Let’s do them in rough order.</p>

<h3 id="x87">x87</h3>

<p>Originally a discrete coprocessor with its own instruction set and register file, the x87
instructions have been regularly baked into x86 cores themselves since the 80486.</p>

<p>Because of its coprocessor history, x87 defines both normal registers<sup id="fnref:normal-ish"><a href="#fn:normal-ish" rel="footnote" role="doc-noteref">6</a></sup>
(akin to GPRs) and a variety of special registers needed to control the FPU state:</p>

<ul>
  <li><code>ST0</code> through <code>ST7</code>: 8 80-bit floating-point registers</li>
  <li><code>FPSW</code>, <code>FPCW</code>, <code>FPTW</code> <sup id="fnref:mynames"><a href="#fn:mynames" rel="footnote" role="doc-noteref">7</a></sup>: Control, status, and tag-word registers</li>
  <li>“Data operand pointer”: I don’t know what this one does, but the Intel SDM specifies it<sup id="fnref:sdm"><a href="#fn:sdm" rel="footnote" role="doc-noteref">8</a></sup></li>
  <li>Instruction pointer: the x87 state machine apparently holds its own copy of the current
x87 instruction</li>
  <li>Last instruction opcode: this is apparently distinct from the x87 opcode, and has its
own register</li>
</ul>

<p><strong>Registers in this group: 14</strong>.</p>

<p><strong>Running total: 92</strong>.</p>

<h3 id="mmx">MMX</h3>

<p>MMX was Intel’s first attempt at consumer SIMD in their x86 chips, released back in 1997.</p>

<p>For design reasons that are a complete mystery to me, the MMX registers are actually sub-registers
of the x87 <code>STn</code> registers: each 64-bit <code>MMn</code> occupies the mantissa component of its corresponding
<code>STn</code>. Consequently, x86 (and x86-64) CPUs cannot execute MMX and x87 instructions at the same time.</p>

<p><em>Edit</em>: This section incorrectly included <code>MXCSR</code>, which was actually introduced with SSE.
Thanks to <a href="https://www.reddit.com/user/Skorezore">/u/Skorezore</a> for pointing out the error.</p>

<p><strong>Registers in this group: 8</strong>.</p>

<p><strong>Running total: 100</strong>.</p>

<h3 id="sse-and-avx">SSE and AVX</h3>

<p>For simplicity’s sake, I’m going to wrap SSE and AVX into a single section: they use the same
sub-register pattern as the GPRs and x87/MMX do, so they fit well into a single table:</p>

<table>
  <tbody><tr>
    
    <th>AVX-512 (512-bit)</th>
    
    <th>AVX-2 (256-bit)</th>
    
    <th>SSE (128-bit)</th>
    
  </tr>
  
  <tr>
    
    <td>ZMM0</td>
    
    <td>YMM0</td>
    
    <td>XMM0</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM1</td>
    
    <td>YMM1</td>
    
    <td>XMM1</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM2</td>
    
    <td>YMM2</td>
    
    <td>XMM2</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM3</td>
    
    <td>YMM3</td>
    
    <td>XMM3</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM4</td>
    
    <td>YMM4</td>
    
    <td>XMM4</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM5</td>
    
    <td>YMM5</td>
    
    <td>XMM5</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM6</td>
    
    <td>YMM6</td>
    
    <td>XMM6</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM7</td>
    
    <td>YMM7</td>
    
    <td>XMM7</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM8</td>
    
    <td>YMM8</td>
    
    <td>XMM8</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM9</td>
    
    <td>YMM9</td>
    
    <td>XMM9</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM10</td>
    
    <td>YMM10</td>
    
    <td>XMM10</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM11</td>
    
    <td>YMM11</td>
    
    <td>XMM11</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM12</td>
    
    <td>YMM12</td>
    
    <td>XMM12</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM13</td>
    
    <td>YMM13</td>
    
    <td>XMM13</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM14</td>
    
    <td>YMM14</td>
    
    <td>XMM14</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM15</td>
    
    <td>YMM15</td>
    
    <td>XMM15</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM16</td>
    
    <td>YMM16</td>
    
    <td>XMM16</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM17</td>
    
    <td>YMM17</td>
    
    <td>XMM17</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM18</td>
    
    <td>YMM18</td>
    
    <td>XMM18</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM19</td>
    
    <td>YMM19</td>
    
    <td>XMM19</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM20</td>
    
    <td>YMM20</td>
    
    <td>XMM20</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM21</td>
    
    <td>YMM21</td>
    
    <td>XMM21</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM22</td>
    
    <td>YMM22</td>
    
    <td>XMM22</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM23</td>
    
    <td>YMM23</td>
    
    <td>XMM23</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM24</td>
    
    <td>YMM24</td>
    
    <td>XMM24</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM25</td>
    
    <td>YMM25</td>
    
    <td>XMM25</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM26</td>
    
    <td>YMM26</td>
    
    <td>XMM26</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM27</td>
    
    <td>YMM27</td>
    
    <td>XMM27</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM28</td>
    
    <td>YMM28</td>
    
    <td>XMM28</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM29</td>
    
    <td>YMM29</td>
    
    <td>XMM29</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM30</td>
    
    <td>YMM30</td>
    
    <td>XMM30</td>
    
  </tr>
  
  <tr>
    
    <td>ZMM31</td>
    
    <td>YMM31</td>
    
    <td>XMM31</td>
    
  </tr>
  
</tbody></table>

<p>In other words: the lower half of each <code>ZMMn</code> is <code>YMMn</code>, and the lower half of each <code>YMMn</code> is
<code>XMMn</code>. There’s no direct way register access for just the upper half of <code>YMMn</code>, nor does
<code>ZMMn</code> have direct 256- or 128-bit access for the thunks of its upper half.</p>

<p>SSE also defines a new status register, <code>MXCSR</code>, that contains flags roughly parallel
to the arithmetic flags in <code>RFLAGS</code> (along with floating-point flags in the x87 status word).
SSE also introduces a load/store instruction pair for manipulating it (<code>LDMXCSR</code> and <code>STMXCSR</code>).</p>

<p>AVX-512 <strong>also</strong> introduces eight <em>opmask</em> registers, <code>k0</code> through <code>k7</code>. <code>k0</code> is a special case
that behaves much like the “zero” register on some RISC ISAs: it can’t be stored to, and
loads from it always produce a bitmask of all ones.</p>

<p><strong>Errata</strong>: The table above includes AVX-512, which isn’t available on any AMD CPUs as of 2020.
I’ve updated the counts below to only include SSE and AVX2-introduced registers.</p>

<p><strong>Registers in this group: 33</strong>.</p>

<p><strong>Running total: 133</strong>.</p>

<h2 id="bounds-registers">Bounds registers</h2>

<p>Intel added these with <a href="https://en.wikipedia.org/wiki/Intel_MPX">MPX</a>, which was intended to
offer hardware-accelerated bounds checking. Nobody uses it, since
<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Intel-MPX-Is-Dead">it doesn’t work very well</a>.
But x86 is eternal and slow to fix mistakes, so we’ll probably have these registers taking up space
for at least a while longer:</p>

<ul>
  <li><code>BND0</code> — <code>BND3</code>: Individual 128-bit registers, each containing a pair of addresses
for a bound.</li>
  <li><code>BNDCFG</code>: Bound configuration, kernel mode.</li>
  <li><code>BNDCFU</code>: Bound configuration, user mode.</li>
  <li><code>BNDSTATUS</code>: Bound status, after a <code>#BR</code> is raised.</li>
</ul>

<p><strong>Registers in this group: 7</strong>.</p>

<p><strong>Running total: 140</strong>.</p>

<h2 id="debug-registers">Debug registers</h2>

<p>These are what they sound like: registers that aid and accelerate software debuggers, like
<a href="https://www.gnu.org/software/gdb/">GDB</a>.</p>

<p>There are 6 debug registers of two types:</p>

<ul>
  <li>
    <p><code>DR0</code> through <code>DR3</code> contain linear addresses, each of which is associated with a breakpoint
condition.</p>
  </li>
  <li>
    <p><code>DR6</code> and <code>DR7</code> are the debug status and control registers. <code>DR6</code>’s lower bits indicate which
debug conditions were encountered (upon entering the debug exception handler), while <code>DR7</code> controls
which breakpoint addresses are enabled and their breakpoint conditions (e.g., when a particular
address is written to).</p>
  </li>
</ul>

<p>What about <code>DR4</code> and <code>DR5</code>? For reasons that are unclear to me, they don’t (and have never)
existed<sup id="fnref:guess"><a href="#fn:guess" rel="footnote" role="doc-noteref">9</a></sup>. They <em>do</em> have encodings but are treated as <code>DR6</code> and <code>DR7</code>, respective, or produce
an <code>#UD</code> exception when <code>CR4.DE[bit 3] = 1</code>.</p>

<p><strong>Registers in this group: 6.</strong></p>

<p><strong>Running total: 146</strong>.</p>

<h2 id="control-registers">Control registers</h2>

<p>x86-64 defines a set of <em>control registers</em> that can be used to manage and inspect the state of the
CPU.</p>

<p>There are 16 “main” control registers, all of which can be accessed with a
<a href="https://www.felixcloutier.com/x86/mov-1"><code>MOV</code> variant</a>:</p>

<table>
  <tbody><tr>
    
    <th>Name</th>
    
    <th>Purpose</th>
    
  </tr>
  
  <tr>
    
    <td>CR0</td>
    
    <td>Basic CPU operation flags</td>
    
  </tr>
  
  <tr>
    
    <td>CR1</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR2</td>
    
    <td>Page-fault linear address</td>
    
  </tr>
  
  <tr>
    
    <td>CR3</td>
    
    <td>Virtual addressing state</td>
    
  </tr>
  
  <tr>
    
    <td>CR4</td>
    
    <td>Protected mode operation flags</td>
    
  </tr>
  
  <tr>
    
    <td>CR5</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR6</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR7</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR8</td>
    
    <td>Task priority register (TPR)</td>
    
  </tr>
  
  <tr>
    
    <td>CR9</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR10</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR11</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR12</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR13</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR14</td>
    
    <td>Reserved</td>
    
  </tr>
  
  <tr>
    
    <td>CR15</td>
    
    <td>Reserved</td>
    
  </tr>
  
</tbody></table>

<p>All reserved control registers result in an <code>#UD</code> when accessed, which makes me inclined to not
count them in this post.</p>

<p>In addition to the “main” <code>CRn</code> control registers there are also the “extended” control registers,
introduced with the <code>XSAVE</code> feature set. As of writing, <code>XCR0</code> is the only specified extended
control register.</p>

<p>The extended control registers use <a href="https://www.felixcloutier.com/x86/xgetbv"><code>XGETBV</code></a> and
<a href="https://www.felixcloutier.com/x86/xsetbv"><code>XSETBV</code></a> instead of a <code>MOV</code> variant.</p>

<p><strong>Registers in this group: 6.</strong></p>

<p><strong>Running total: 152</strong>.</p>

<h2 id="system-table-pointer-registers">“System table pointer registers”</h2>

<p>That’s what the Intel SDM calls these<sup id="fnref:sdm:1"><a href="#fn:sdm" rel="footnote" role="doc-noteref">8</a></sup>: these registers hold sizes and pointers to various
protected mode tables.</p>

<p>As best I can tell, there are four of them:</p>

<ul>
  <li><code>GDTR</code>: Holds the size and base address of the GDT</li>
  <li><code>LDTR</code>: Holds the size and base address of the LDT</li>
  <li><code>IDTR</code>: Holds the size and base address of the IDT</li>
  <li><code>TR</code>: Holds the TSS selector and base address for the TSS</li>
</ul>

<p>The <code>GDTR</code>, <code>LDTR</code>, and <code>IDTR</code> each seem to be 80 bits in 64-bit modes: 16 lower bits for
the size of the register’s table, and then the upper 64 bits for the table’s starting address.</p>

<p><code>TR</code> is likewise 80 bits: 16 bits for the selector (which behaves identically to a segment
selector), and then another 64 for the base address of the TSS<sup id="fnref:unsure"><a href="#fn:unsure" rel="footnote" role="doc-noteref">10</a></sup>.</p>

<p><strong>Registers in this group: 4.</strong></p>

<p><strong>Running count: 156</strong>.</p>

<h2 id="memory-type-ranger-registers">Memory-type-ranger registers</h2>

<p>These are an interesting case: unlike all of the other registers I’ve covered so far,
these are <strong>not</strong> unique to a particular CPU in a multicore chip; instead, they’re shared
across all cores<sup id="fnref:sdm2"><a href="#fn:sdm2" rel="footnote" role="doc-noteref">11</a></sup>.</p>

<p>The number of MTTRs seems to vary by CPU model, and have been largely superseded by entries in
the <a href="https://en.wikipedia.org/wiki/Page_attribute_table">page attribute table</a>, which is programmed
with an MSR<sup id="fnref:ia32-pat"><a href="#fn:ia32-pat" rel="footnote" role="doc-noteref">12</a></sup>.</p>

<p><strong>Registers in this group:</strong></p>

<p><img src="https://probablydance.com/assets/dont_know.png" alt=""/></p>

<p><strong>Running count: &gt;156</strong>.</p>

<h2 id="model-specific-registers">Model specific registers</h2>

<p>Model-specific registers are where things get fun.</p>

<p>Like extended control registers, they’re accessed indirectly (by identifier) through a pair
of instructions: <code>RDMSR</code> and <code>WRMSR</code>. MSRs themselves are 64-bits but originated during the
32-bit era, so <code>RDMSR</code> and <code>WRMSR</code> read from and write to <em>two</em> 32-bit registers: <code>EDX</code> and <code>EAX</code>.</p>

<p>By way of example: here’s the setup and <code>RDMSR</code> invocation for accessing the <code>IA32_MTRRCAP</code> MSR,
which includes (among other things) that actual number of MTRRs available on the system:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>MOV</span> <span>ECX</span><span>,</span> <span>0xFE</span> <span>; 0xFE = IA32_MTRRCAP</span>
<span>RDMSR</span>
<span>; The bits of IA32_MTRRCAP are now in EDX:EAX</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>RDMSR</code> and <code>WRMSR</code> are privileged instructions, so normal ring-3 code can’t access MSRs
directly<sup id="fnref:msr-driver"><a href="#fn:msr-driver" rel="footnote" role="doc-noteref">13</a></sup>. The one (?) exception that I know of is the timestamp counter (<code>TSC</code>),
which is stored in the <code>IA32_TSC</code> MSR but can be read from non-privileged contexts with
<code>RDTSC</code> and <code>RDTSCP</code>.</p>

<p>Two other interesting (but still privileged<sup id="fnref:fsgsbase"><a href="#fn:fsgsbase" rel="footnote" role="doc-noteref">14</a></sup>) cases are <code>FSBASE</code> and <code>GSBASE</code>, which are
stored as <code>IA32_FS_BASE</code> and <code>IA32_GS_BASE</code>, respectively. As mentioned in the segment register
section, these store the <code>FS</code> and <code>GS</code> segment bases on x86-64 CPUs. This makes them targets of
relatively frequent use (by MSR standards), so they have their own dedicated R/W opcodes:</p>

<ul>
  <li><code>RDFSBASE</code> and <code>RDGSBASE</code> for reading</li>
  <li><code>WRFSBASE</code> and <code>WRGSBASE</code> for writing</li>
</ul>

<p>But back to the meat of things: how many MSRs <em>are</em> there?</p>

<p>Using the standards laid out at the beginning of this post, we’re interested in counting what
Intel calls “architectural” MSRs. From the SDM<sup id="fnref:sdm3"><a href="#fn:sdm3" rel="footnote" role="doc-noteref">15</a></sup>:</p>

<blockquote>
  <p>Many MSRs have carried over from one generation of IA-32 processors to the next and to Intel
64 processors. A subset of MSRs and associated bit fields, which do not change on future
processor generations, are now considered architectural MSRs. For historical reasons (beginning
with the Pentium 4 processor), these “architectural MSRs” were given the prefix “IA32_”.</p>
</blockquote>

<p>According to the subsequent table<sup id="fnref:sdm4"><a href="#fn:sdm4" rel="footnote" role="doc-noteref">16</a></sup>, the highest architectural MSR is <code>6097</code>/<code>17D1H</code>, or
<code>IA32_HW_FEEDBACK_CONFIG</code>. So, the naïve answer is over 6000.</p>

<p>However, there are significant gaps in the documented MSR ranges: Intel’s documentation jumps
directly from <code>3506</code>/<code>DB2H</code> (<code>IA32_THREAD_STALL</code>) to <code>6096</code>/<code>17D0H</code> (<code>IA32_HW_FEEDBACK_PTR</code>). On
top of the empty ranges, there are also ranges that are explicitly marked as reserved, either
generally or explicitly for later expansion of a particular MSR family.</p>

<p>To count the <em>actual</em> number of MSRs, I did a bit of pipeline ugliness:</p>

<ul>
  <li>
    <p>Extract just table 2-2 from Volume 4 of the SDM
(<a href="https://software.intel.com/content/dam/develop/external/us/en/documents-tps/335592-sdm-vol-4.pdf">link</a>):</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>  <span>$ </span>pdfjam 335592-sdm-vol-4.pdf 19-67 <span>-o</span> 2-2.pdf
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>Use <code>pdftotext</code> to convert it to plain text and manually trim the next table from the last page:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>  <span>$ </span>pdftotext 2-2.pdf table.txt
  <span># edit table.txt by hand</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>Split the plain text table into a sequence of words, filter by <code>IA32_</code>, remove cruft, and do a
standard sort-unique-count:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre>  <span>$ </span><span>tr</span> <span>-s</span> <span>&#39;[:space:]&#39;</span> <span>&#39;\n&#39;</span> &lt; table.txt <span>\</span>
      | <span>grep</span> <span>&#39;IA32_&#39;</span> <span>\</span>
      | <span>tr</span> <span>-d</span> <span>&#39;.&#39;</span> <span>\</span>
      | <span>sed</span> <span>&#39;s/\[.*$//&#39;</span> <span>\</span>
      | <span>sort</span> | <span>uniq</span> | <span>wc</span> <span>-l</span>
  404
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>(Output preserved for posterity <a href="https://probablydance.com/assets/ia32-architectural-msrs.txt">here</a>).</p>
  </li>
</ul>

<p>That pipeline left a bit of cruft towards the end thanks to quoted variants, so I count the actual
number at 400 architectural MSRs. That’s a lot more reasonable than 6096!</p>

<p><strong>Registers in this group: 400</strong></p>

<p><strong>Running count: &gt;556</strong>.</p>

<h2 id="other-bits-and-wrapup">Other bits and wrapup</h2>

<p>The footnotes at the bottom of this post cover most of my notes, but I also wanted to dump some
other resources that I found useful while discovering registers:</p>

<ul>
  <li>
    <p><a href="https://sandpile.org/x86/msr.htm">sandpile.org</a> has a nice visualization of many of the
architectural MSRs, including field breakdowns.</p>
  </li>
  <li>
    <p>Vol. 3A § 8.7.1 (“State of the Logical Processors”) of the Intel SDM has a useful list of
nearly all of the registers that are either unique to or shared between x86-64 cores.</p>
  </li>
  <li>
    <p>The <a href="https://wiki.osdev.org">OSDev Wiki</a> has collection of helpful pages on various x86-64
registers, including a <a href="https://wiki.osdev.org/SWAPGS">great page</a> on the behavior of the segment
base MSRs.</p>
  </li>
</ul>

<p>All told, I think that there are <em>roughly</em> <strong>557</strong> registers on the average (relatively recent)
x86-64 CPU core. With that being said, I have some peripheral cases that I’m not sure about:</p>

<ul>
  <li>
    <p>Modern Intel CPUs use integrated
<a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APICs</a> as part of
their SMT implementation. These APICs have
<a href="https://wiki.osdev.org/APIC#Local_APIC_registers">their own register banks</a> which can be
memory-mapped for reading and potential modification by an x86 core. I didn’t count them because
(1) they’re memory mapped, and thus behave more like mapped registers from an arbitrary piece of
hardware than CPU registers, and (2) I’m not sure whether AMD uses the same
mechanism/implementation.</p>
  </li>
  <li>
    <p>The Intel SDM implies that <a href="https://lwn.net/Articles/680996/">Last Branch Records</a> are stored
in discrete, non-MSR registers. AMD’s developer manual, on the other hand, specifies a range of
MSRs. As such, I didn’t attempt to count these separately.</p>
  </li>
  <li>
    <p>Both Intel and AMD have their own (and incompatible) virtualization extensions, as well as their
own enclave/hardened execution extensions. My intuition is that each introduces some additional
registers (or maybe just MSRs), but their vendor-specificity made me inclined to not look too
deeply.</p>
  </li>
</ul>

<p>Information on these (and any other) registers would be deeply appreciated.</p>

<hr/>




<hr/>


<span>
  Discussions:
  
  <a href="https://www.reddit.com/r/enosuchblog/comments/k3wfbr/how_many_registers_does_an_x8664_cpu_have/">Reddit</a>
  
</span>
<hr/>



  


  





</div>
  </body>
</html>
