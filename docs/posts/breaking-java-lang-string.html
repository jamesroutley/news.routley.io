<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wouter.coekaerts.be/2023/breaking-string">Original</a>
    <h1>Breaking java.lang.String</h1>
    
    <div id="readability-page-1" class="page"><div><p>
Let&#39;s abuse a bug in <code>java.lang.String</code> to make some <em>weird</em> Strings.
We&#39;ll make &#34;hello world&#34; not start with &#34;hello&#34;, and show that not all empty Strings are equal to each other.
</p>

<h2>Intro: Equality among Strings</h2>

<p>
Before we get started, we look at what it takes for two Strings to be equal in the JDK.
</p>

<blockquote>
  Why is <code>&#34;foo&#34;.equals(&#34;fox&#34;)</code> false?
</blockquote>

<p>
Because Strings are compared character by character, and the third character of those Strings is different.
</p>

<blockquote>
  Why is <code>&#34;foo&#34;.equals(&#34;foo&#34;)</code> true?
</blockquote>

<p>
You might think that in this case the Strings are also compared character by character.
But String literals are <em>interned</em>.
When the same String appears as a constant multiple times in the source code, it&#39;s not just another String with the same content.
It is the same instance of String.
And the first thing that String.equals does is <code>if (this == anObject) { return true; }</code>, so it doesn&#39;t even look at the contents.
</p>

<blockquote>
  Why is <code>&#34;foo!&#34;.equals(&#34;foo⁉&#34;)</code> false?
</blockquote>

<p>
Since JDK 9 (since <a href="https://openjdk.org/jeps/254">JEP 254: Compact Strings</a>), a String represents its content internally as a byte array.
&#34;foo!&#34; only contains simple characters, with a codepoint less than 256. The String class internally encodes such values using the latin-1 encoding, with one byte per character.
&#34;foo⁉&#34; contains a character (⁉) that cannot be represented using latin-1, so it encodes the whole String using UTF-16, with two bytes per character.
The <code>String.coder</code> field keeps track of which of the two encodings was used.
When comparing two Strings with a different <code>coder</code>, then <code>String.equals</code> always returns false.
It does not even look at the contents, because if one String can be represented in latin-1, and the other one can not, then they can&#39;t be the same. Or can they?
</p>

<p>
Note: The compact strings feature can be disabled, but it&#39;s enabled by default. This blog post assumes it is enabled.
</p>

<h2>Creating a broken String</h2>

<blockquote>
How are Strings created? How exactly does <code>java.lang.String</code> choose to use latin-1 or not?
</blockquote>
<p>
Strings can be created in multiple ways, we&#39;ll focus here on the String constructor that takes a <code>char[]</code>.
It first tries to encode the characters as latin-1 using <code>StringUTF16.compress</code>. If that fails, it returns <code>null</code> and the constructor falls back to using UTF-16.
Here is a simplified version of how that is implemented.
(For readability I removed irrelevant indirections, checks and arguments from the actual implementation
  <a href="https://github.com/openjdk/jdk/blob/b3f34039fedd3c49404783ec880e1885dceb296b/src/java.base/share/classes/java/lang/String.java#L277-L279">here</a>
  and <a href="https://github.com/openjdk/jdk/blob/b3f34039fedd3c49404783ec880e1885dceb296b/src/java.base/share/classes/java/lang/String.java#L4757-L4772">here</a>)

</p><figure><pre><code data-lang="java"><span>/**
 * Allocates a new {@code String} so that it represents the sequence of
 * characters currently contained in the character array argument. The
 * contents of the character array are copied; subsequent modification of
 * the character array does not affect the newly created string.
 */</span>
<span>public</span> <span>String</span><span>(</span><span>char</span> <span>value</span><span>[])</span> <span>{</span>
  <span>byte</span><span>[]</span> <span>val</span> <span>=</span> <span>StringUTF16</span><span>.</span><span>compress</span><span>(</span><span>value</span><span>);</span>
  <span>if</span> <span>(</span><span>val</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>value</span> <span>=</span> <span>val</span><span>;</span>
    <span>this</span><span>.</span><span>coder</span> <span>=</span> <span>LATIN1</span><span>;</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>this</span><span>.</span><span>coder</span> <span>=</span> <span>UTF16</span><span>;</span>
  <span>this</span><span>.</span><span>value</span> <span>=</span> <span>StringUTF16</span><span>.</span><span>toBytes</span><span>(</span><span>value</span><span>);</span>
<span>}</span></code></pre></figure>

<p>
There is the bug. This code does not always preserve the assumptions that <code>String.equals</code> makes that we talked about above.
Do you see it?

</p><p>
The javadoc points out that &#34;subsequent modification of the character array does not affect the newly created string&#34;.
But how about <em>concurrent</em> modification?
The String constructor has a race condition.
The contents of <code>value</code> may have changed between trying to encode it as latin-1, and encoding it as UTF-16.
That way we can end up with a String that only contains latin-1 characters, but is encoded as UTF-16.
We can trigger that race condition like this:

</p><figure><pre><code data-lang="java"><span>/**
 * Given a latin-1 String, creates a copy that is
 * incorrectly encoded as UTF-16.
 */</span>
<span>static</span> <span>String</span> <span>breakIt</span><span>(</span><span>String</span> <span>original</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>original</span><span>.</span><span>chars</span><span>().</span><span>max</span><span>().</span><span>orElseThrow</span><span>()</span> <span>&gt;</span> <span>256</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span>
        <span>&#34;Can only break latin-1 Strings&#34;</span><span>);</span>
  <span>}</span>

  <span>char</span><span>[]</span> <span>chars</span> <span>=</span> <span>original</span><span>.</span><span>toCharArray</span><span>();</span>

  <span>// in another thread, flip the first character back</span>
  <span>// and forth between being encodable as latin-1 or not</span>
  <span>Thread</span> <span>thread</span> <span>=</span> <span>new</span> <span>Thread</span><span>(()</span> <span>-&gt;</span> <span>{</span>
    <span>while</span> <span>(!</span><span>Thread</span><span>.</span><span>interrupted</span><span>())</span> <span>{</span>
      <span>chars</span><span>[</span><span>0</span><span>]</span> <span>^=</span> <span>256</span><span>;</span>
    <span>}</span>
  <span>});</span>
  <span>thread</span><span>.</span><span>start</span><span>();</span>

  <span>// at the same time call the String constructor,</span>
  <span>// until we hit the race condition</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>String</span> <span>s</span> <span>=</span> <span>new</span> <span>String</span><span>(</span><span>chars</span><span>);</span>
    <span>if</span> <span>(</span><span>s</span><span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>&lt;</span> <span>256</span> <span>&amp;&amp;</span> <span>!</span><span>original</span><span>.</span><span>equals</span><span>(</span><span>s</span><span>))</span> <span>{</span>
      <span>thread</span><span>.</span><span>interrupt</span><span>();</span>
      <span>return</span> <span>s</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure>

<p>
The broken Strings we can create this way have some interesting properties.

</p><figure><pre><code data-lang="java"><span>String</span> <span>a</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>
<span>String</span> <span>b</span> <span>=</span> <span>breakIt</span><span>(</span><span>a</span><span>);</span>

<span>// they are not equal to each other</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>a</span><span>.</span><span>equals</span><span>(</span><span>b</span><span>));</span>
<span>// =&gt; false</span>

<span>// they do contain the same series of characters</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>equals</span><span>(</span><span>a</span><span>.</span><span>toCharArray</span><span>(),</span>
    <span>b</span><span>.</span><span>toCharArray</span><span>()));</span>
<span>// =&gt; true</span>

<span>// compareTo does consider them equal (even though its javadoc</span>
<span>// specifies that &#34;compareTo returns 0 exactly when the</span>
<span>// equals(Object) method would return true&#34;)</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>a</span><span>.</span><span>compareTo</span><span>(</span><span>b</span><span>));</span>
<span>// =&gt; 0</span>

<span>// they have the same length, and one startsWith the other,</span>
<span>// but not the other way around (because if it wasn&#39;t broken,</span>
<span>// a latin-1 string cannot start with a non-latin-1</span>
<span>// substring).</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>a</span><span>.</span><span>length</span><span>()</span> <span>==</span> <span>b</span><span>.</span><span>length</span><span>());</span>
<span>// =&gt; true</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>b</span><span>.</span><span>startsWith</span><span>(</span><span>a</span><span>));</span>
<span>// =&gt; true</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>a</span><span>.</span><span>startsWith</span><span>(</span><span>b</span><span>));</span>
<span>// =&gt; false</span></code></pre></figure><p>

Strange. I didn&#39;t expect this weird behaviour from such a fundamental Java class.

</p><h2>Spooky action at a distance</h2>

<p>
Just because we can, let&#39;s have some more fun with this.
We can not only create a broken String, we can also break a String <em>at a distance</em>, in another class.

</p><figure><pre><code data-lang="java"><span>class</span> <span>OtherClass</span> <span>{</span>
  <span>static</span> <span>void</span> <span>startWithHello</span><span>()</span> <span>{</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;hello world&#34;</span><span>.</span><span>startsWith</span><span>(</span><span>&#34;hello&#34;</span><span>));</span>
  <span>}</span>
<span>}</span></code></pre></figure>

<p>
If we write that in IntelliJ then it warns us that <em>Result of &#39;&#34;hello world&#34;.startsWith(&#34;hello&#34;)&#39; is always &#39;true&#39;</em>.
This code doesn&#39;t even take any input, but we can still make it print <code>false</code>, by injecting a broken &#34;hello&#34; into it, through interning:
We break a String containing hello before any other code has literally mentioned or explicitly interned it, and we intern that broken version.
That way, we have broken every <code>&#34;hello&#34;</code> String literal in our JVM.

</p><figure><pre><code data-lang="java"><span>breakIt</span><span>(</span><span>&#34;hell&#34;</span><span>.</span><span>concat</span><span>(</span><span>&#34;o&#34;</span><span>)).</span><span>intern</span><span>();</span>
<span>OtherClass</span><span>.</span><span>startWithHello</span><span>();</span> <span>// prints false</span></code></pre></figure>

<h2>Challenge: Empty or not?</h2>

<p>
Using our breakIt method, we can create an equivalent but not-actually-equal String of any latin-1 String.
But it doesn&#39;t work for the empty String, because that one doesn&#39;t have any characters to trigger the race condition.
Yet, we can still create a broken empty String. I&#39;ll leave that as a challenge to the reader.

</p><p>
Concretely:
Can you make a <code>java.lang.String</code> object, for which this is true: <code>s.isEmpty() &amp;&amp; !s.equals(&#34;&#34;)</code>.
No cheating: You&#39;re only allowed to use public APIs for this, e.g. no <code>.setAccessible</code> to access privates, no instrumentation.

</p><p>
If you find it, let me know <a href="https://docs.google.com/forms/d/e/1FAIpQLSc7NQr97AA8R-4-NhaL4g1B3yGNkjXVLJqMM3aIcbJtMEn6-A/viewform?usp=sf_link">here</a>.
I&#39;ll update this page with submitted answers later.


</p></div></div>
  </body>
</html>
