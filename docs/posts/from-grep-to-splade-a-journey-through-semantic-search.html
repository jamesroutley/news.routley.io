<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.elicit.com/semantic-search/">Original</a>
    <h1>From grep to SPLADE: a journey through semantic search</h1>
    
    <div id="readability-page-1" class="page"><section>
    <p>Almost every app needs search. If you’ve attempted to implement it in your app, you may have discovered that what seems simple on the surface is a deeply challenging technical problem that has kept the brightest minds in computer science busy for decades.</p><p>In recent years, machine learning has given us semantic search, vastly improving the capability of search. However, the black-box nature of these tools can make them unsuited for some domains, like academic literature review. How can those domains take advantage of better search, while still having reproducible results?</p><p>This article will take you on a journey to understanding search, including the capabilities and weaknesses of the state of the art in semantic search.</p><h2 id="the-olden-days-string-matching-and-full-text-search">The olden days: string matching and full-text search</h2><p>A simple string comparison like the unix tool grep is the obvious and naive way to implement search. Of course, we quickly see that it doesn’t get anywhere near the results that users want. It may produce false positives like “car” matching “scar,” and false negatives like “goose” not matching “geese.” It also isn’t fast enough once you have a decently-sized corpus of data to search across.</p><p><a href="https://en.wikipedia.org/wiki/Full-text_search?ref=blog.elicit.com"><u>Full-text search</u></a> has been the gold standard for decades, with powerful capabilities for this built into databases like <a href="https://www.postgresql.org/?ref=blog.elicit.com"><u>Postgres</u></a>. Full-text search uses complex heuristics for better matching (such as pluralization) and indexing to keep search fast in large datasets. <a href="https://app.dealroom.co/companies/elastic?ref=blog.elicit.com"><u>Elastic</u></a> built a $10 billion company on the foundation of full-text search.</p><p>This remained the state of the art for almost all apps until the arrival of general-purpose ML-powered search.</p><h2 id="embeddings-and-latent-space">Embeddings and latent space</h2><p>An early idea of mathematically representing words as their underlying concepts <a href="https://en.wikipedia.org/wiki/Word_embedding?useskin=vector&amp;ref=blog.elicit.com#Development_and_history_of_the_approach"><u>goes back as far as the 1950s</u></a>. Semantic search, as this is now known, focuses on searching for <em>ideas rather than words.</em> Major milestones include <a href="https://www.tensorflow.org/text/tutorials/word2vec?ref=blog.elicit.com"><u>Word2vec</u></a> (2013) and Google’s <a href="https://research.google/blog/open-sourcing-bert-state-of-the-art-pre-training-for-natural-language-processing/?ref=blog.elicit.com"><u>BERT</u></a> (2018).</p><p>Semantic search works by turning the user’s search query from text into a high-dimensional vector, basically just several hundred numbers in an array. This words-to-vector conversion is known as an <em>embedding</em>, and the conceptual search space the vector implies is called the <em>latent space</em>.</p><figure><img src="https://blog.elicit.com/content/images/2024/06/latent-space-framed.png" alt="" loading="lazy" width="1602" height="858" srcset="https://blog.elicit.com/content/images/size/w600/2024/06/latent-space-framed.png 600w, https://blog.elicit.com/content/images/size/w1000/2024/06/latent-space-framed.png 1000w, https://blog.elicit.com/content/images/size/w1600/2024/06/latent-space-framed.png 1600w, https://blog.elicit.com/content/images/2024/06/latent-space-framed.png 1602w" sizes="(min-width: 720px) 720px"/><figcaption><span>Embeddings in latent space: items nearer each other will be more similar. This is 2D for human legibility, but embeddings are typically many hundreds of dimensions, giving many degrees of freedom for similarity of concepts.</span></figcaption></figure><p>This means that the text “flower” and the text “dandelion”, once encoded this way, will result in vectors that are fairly similar. These can be understood as near each other in the latent space, with distance between them computed in the same way you would compute distance between two points on a geographical map.</p><p>So far, we’ve only talked about embeddings for single words. What about more complex phrases?</p><p>We could simply calculate the embeddings for each individual term and take the average, but unfortunately this doesn’t work for natural language. For example, the phrases “chocolate is tastier than liver” and “liver is tastier than chocolate” mean completely opposite things, but—in our naïve averaging scheme—would have the exact same embedding.</p><p>To handle the nuanced and messy semantics of natural language, we need a more powerful tool.This is where large language models come into play. Rather than processing each word independently, the text is split into chunks and fed as a sequence into the LLM, allowing the model to perceive the richer semantics woven into our languages. The end result is still an embedding, but it’s one which better captures the meaning of the input.</p><p>Despite being a relatively new and incredibly powerful tool, the generation of high-quality embeddings has quickly become commoditized. For example, using <a href="https://platform.openai.com/docs/guides/embeddings?ref=blog.elicit.com"><u>OpenAI’s embeddings API</u></a> you can easily add Google-quality search to your app. Simply feed each document in your search corpus into the API to generate an embedding for that document, and do the same for any search query your user provides. Then for each document embedding, calculate the similarity between the query and the document and return the set of documents as your search result.</p><h2 id="semantic-search-is-not-ideal-for-literature-search">Semantic search is not ideal for literature search</h2><p>Semantic search works well in many cases, but it has some shortcomings:</p><ol><li>The nature of most embedding models (and efficient dense vector search algorithms) means that—if you’re not careful—the same query could produce different results between runs.</li><li>It’s a black box. End users don’t understand how the results are ranked. Even ML researchers consider the process a “gray box”: we know the models work but can’t give a great description as to how or why.</li></ol><p>At <a href="https://elicit.com/?ref=blog.elicit.com"><u>Elicit</u></a>, we’re building a tool for systematic literature review. The first step in that review is a search that looks similar to what you would see in Google Scholar. The shortcomings of semantic search are acceptable for consumer web search, but less so in the domain literature review. Why?</p><p>When academics want to use a search as part of a systematic review or meta-analysis, they need to be able to explain how they got the papers they included. They need to know that it was comprehensive: they haven’t missed any important papers. And others need to be able to reproduce their work.</p><p>Other domains might have similar needs and find web-style semantic short too limiting. For example, attorneys or judges search for relevant case law—leaving out important precedent could be disastrous. Even the more common case of searching your own email (where you expect comprehensive, repeatable searches) struggles with semantic search, as <a href="https://aletteraday.substack.com/p/letter-70-paul-bucheit-and-jessica?ref=blog.elicit.com"><u>the creator of GMail described</u></a> in their attempts to use Google’s web search infrastructure for their private email search.</p><p>So what else can we do?</p><h2 id="query-expansion">Query expansion</h2><p>One <a href="https://maggieappleton.com/folk-interfaces?ref=blog.elicit.com"><u>folk practice</u></a> of systematic reviewers is to manually create a huge fanout of search terms. This makes sure every possible permutation is included.</p><figure><img src="https://blog.elicit.com/content/images/2024/06/systematic-review-2.png" alt="" loading="lazy" width="1012" height="286" srcset="https://blog.elicit.com/content/images/size/w600/2024/06/systematic-review-2.png 600w, https://blog.elicit.com/content/images/size/w1000/2024/06/systematic-review-2.png 1000w, https://blog.elicit.com/content/images/2024/06/systematic-review-2.png 1012w" sizes="(min-width: 720px) 720px"/><figcaption><span>Example of query expansion found in a </span><a href="https://www.researchgate.net/publication/276070900_Return_to_Preinjury_Levels_of_Participation_After_Superior_Labral_Repair_in_Overhead_Athletes_A_Systematic_Review?ref=blog.elicit.com"><u><span>systematic review on performance of athletes after surgery</span></u></a><span>.</span></figcaption></figure><p>Query expansion, then, is just automating this process. A generic language model can be prompted to specify all the variations on each search term, and those can be fed into a regular full-text search.</p><p>This method is transparent and understandable, as the intermediate step is directly legible to humans. The downside is that it’s slow, and the search results are generally still much worse than a vector search.</p><h2 id="splade">SPLADE</h2><p>That brings us to the method that Elicit is working on today: Sparse Lexical and Expansion model, aka <a href="https://www.pinecone.io/learn/splade/?ref=blog.elicit.com"><u>SPLADE</u></a>.</p><p>SPLADE is similar to query expansion—in that the user’s query is enriched with synonymous or related terms—but rather than this expansion being a manual process, we instead lean on language models to suggest additional search terms.</p><p>One way to think about this is that the language model has already built up a high-dimensional map of how terms are related to each other: this is the latent space of embeddings we described above. Using this map, we can automatically find terms semantically-associated with the user query, and enrich the query with those model-suggested terms. Those are then fed into a regular full-text search.</p><figure><img src="https://lh7-us.googleusercontent.com/docsz/AD_4nXffmM7jdM6iQTkEI0mJS8gOe8dby65XkQ0iSZoK-00Svl__1SEC40uZJwW2xeqrL6ruMvmN7wkjmZfMSYbYaCf0hynGHwAFWtLIomLOhn7Zw2zeM9oUMZUjDD9lxjx7OrUFrXC5F843_E-ESBulvcMlES9w?key=a2xoKoGf9WxcKvzidZrG3A" alt="" loading="lazy" width="1600" height="562"/><figcaption><span>A hypothetical subset of the SPLADE query expansion, using embeddings to fan out terms.</span></figcaption></figure><p>The result:</p><ul><li>It’s deterministic, for a given SPLADE model.</li><li>It’s transparent. Like manual query expansion, SPLADE adds additional language model tokens (conceptually very similar to human-readable search terms) to the query which can be viewed and double-checked by the user if they wish.</li><li>It’s obviously faster, more accurate, and requires less human effort than manual expansion.</li></ul><p>So the SPLADE path is fast and close to semantic search quality, while still giving us the reproducibility and transparency that literature search users demand.</p><p>As a bonus, we can also train a custom SPLADE model on the particular domain we’re operating in. That means the query expansion would be smarter about, for example, particular jargon used within a domain like athletics, biomedicine, or law.</p><h2 id="one-more-thing-automated-comprehensive-search">One more thing: automated comprehensive search</h2><p>As a thought experiment, imagine you had infinite research assistants. How would you search for relevant papers?</p><p>You wouldn’t limit yourself to keyword matches! Instead you might instruct your infinite labor pool read and understand every single paper and check whether or not they are relevant to your query. Indeed, there is a step in systematic review called screening, which is the <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6771536/?ref=blog.elicit.com"><u>“tedious but vital first step to synthesize the extant literature”</u></a>.</p><p>Automated Comprehensive Search (ACS) is an attempt to do this with a language model. Although it would be cost-prohibitive to have the language model actually read everything, our friends at <a href="https://undermind.ai/home/?ref=blog.elicit.com"><u>Undermind</u></a> used a clever trick: use semantic search to sort papers by relevancy, and have the language model “read” them in that order. As it proceeds, each paper will become less and less relevant. Model this curve and you can probabilistically guarantee you’ve found everything relevant.</p><figure><img src="https://blog.elicit.com/content/images/2024/06/acs-2.png" alt="" loading="lazy" width="877" height="362" srcset="https://blog.elicit.com/content/images/size/w600/2024/06/acs-2.png 600w, https://blog.elicit.com/content/images/2024/06/acs-2.png 877w" sizes="(min-width: 720px) 720px"/><figcaption><i><em>Sort by relevancy and read in descending order. From </em></i><a href="https://www.undermind.ai/static/Undermind_whitepaper.pdf?ref=blog.elicit.com"><u><i><em>Benchmarking the Undermind Search Assistant</em></i></u></a><i><em>.</em></i></figcaption></figure><p>The relevancy score doesn’t need to be perfect: as you go, you can recalculate the scores based on your fine-grained judgments and <a href="https://libguides.uvic.ca/librarysearchhelp/citationtrailing?ref=blog.elicit.com"><u>follow citation trails</u></a>. This isn’t as reproducible as the SPLADE method described previously, but the exhaustiveness means that matters less. You can state exactly what papers were included, excluded, and on what basis across your entire search space.</p><p>There are downsides to this method: it requires including more data for people to analyze, and at the moment it’s very slow and expensive. But the upsides are that it avoids many issues with search bias, and we expect the cost to come down in time.</p><h2 id="conclusion">Conclusion</h2><p>Semantic search uses ideas instead of words, which makes it a huge step forward from traditional full-text search. But it still has weaknesses in many domains that require transparency and reproducibility. At Elicit we’re continuing to use the latest developments in thinking on semantic search technologies to give our customers the results they’re looking for. Come <a href="https://elicit.com/careers?ref=blog.elicit.com"><u>join us</u></a> if this sort of problem is interesting to you.</p>
</section></div>
  </body>
</html>
