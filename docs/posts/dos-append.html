<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.os2museum.com/wp/dos-append/">Original</a>
    <h1>DOS APPEND</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>For a long time, I couldn’t quite grasp what the DOS APPEND command could possibly be good for. Until I came across a situation which APPEND was made for.</p>



<p>When I worked on organizing and building the <a href="https://www.os2museum.com/wp/dos-2-11-from-scratch/" data-type="post" data-id="5611">DOS 2.11 source code</a>, I tried to place the source files in a tree structure similar to that used by DOS 3.x (this is known from DOS 3.x OAKs):</p>



<pre>C:.</pre>



<p>The <code>inc</code> subdirectory unsurprisingly contains shared include files such as <code>DOSSYM.ASM</code>, which are included just about from everywhere. No problem, right?</p>



<p>Except… to get output that most closely matches existing DOS 2.x binaries, it is necessary to use an old version of MASM (version 1.25 seems to do the trick). But MASM 1.25 is designed to run on top of DOS 1.x, and knows nothing whatsoever about directories.</p>



<p>It is possible that back in the day, DOS 2.x was built from a single huge directory on a hard disk. In fact it is known that DOS 2.0 could not be built on PCs at all, and was built on DEC mainframes. Yet DOS 2.11 was also clearly modified such that it <em>could</em> be build on PCs using Microsoft’s development tools.</p>



<p>However it was done back in 1983, lumping 150+ assembler source files into a single directory, and then adding hundreds of object and executable files, did not sound <em>at all</em> appealing. Cloning <code>DOSSYM.ASM</code> to every directory where it was needed seemed even worse.</p>



<p>That’s when I somehow remembered that APPEND exists, and realized that it’s the perfect solution to the problem. Before building, one can run</p>



<pre>APPEND ..\..\INC;..\INC</pre>



<p>and the <code>inc</code> directory becomes accessible from all of its sibling subdirectories and from subdirectories one level deeper. It would have been possible to use an absolute path as well, but this way the build batch file does not need to know where it lives.</p>



<p>With APPEND in place, the old MASM 1.25 which uses FCB I/O will find the centrally located include files, and the source code can be organized into a neat hierarchical structure that’s far easier to work with than one giant blob.</p>



<h3>What is APPEND?</h3>



<p>APPEND is a “DOS extension”, in fact it is a TSR which intercepts INT 21h and adds special handling for several subfunctions. These are primarily:</p>



<ul>
<li><strong>0Fh</strong> FCB File Open</li>



<li><strong>3Dh</strong> Handle File Open</li>



<li><strong>23h</strong> Get File Size</li>
</ul>



<p>If these subfunctions fail to find a file in the current directory, APPEND will retry them using the list of paths it manages.</p>



<p>When building DOS 2.11, MASM 1.25 will try to open DOSSYM.ASM using INT 21h/0Fh (FCB File Open). Because the file does not exist in the current directory, the initial attempt will fail. APPEND will then try opening <code>..\INC\DOSSYM.ASM</code> and, if that is unsuccessful, also <code>..\..\INC\DOSSYM.ASM</code>. Old MASM is thus magically upgraded to handle multiple directories, without actually knowing anything about them.</p>



<p>The working principle of APPEND is not complicated. It primarily serves as a bridge between old DOS applications which have no or poor support for directories, and users who really, really want to organize files and programs in multiple directories and possibly across multiple drive letters. Of course the actual APPEND implementation is anything but straightforward.</p>



<h3>APPEND Evolution and Implementation</h3>



<p>The first DOS version which came with APPEND was DOS 3.3 (1987), not coincidentally the first DOS version developed by IBM.</p>



<p>But APPEND is older than that—it first appeared in the IBM PC Network Program 1.0 in 1985. It is hard to speculate why it was shipped with the PC Network Program (later the PC LAN Program) because APPEND does not <em>really</em> have anything to do with networking. It is plausible that it was especially useful with networking, when users were motivated to store applications on a central network server and data files on their own machines. And that’s a problem for applications which cannot handle directories well.</p>



<p>Now that we can see the <a href="https://github.com/microsoft/MS-DOS/blob/main/v4.0/src/CMD/APPEND/APPEND.ASM">source code for APPEND</a>, some things are clearer. The original PC Network Program version of APPEND was written by someone with initials G. G. A., and in 1986 it was adapted for shipping with DOS by B. A. F., no doubt Barry A. Feigenbaum (best known for developing the SMB protocol).</p>



<p>APPEND by default manages the path list in its own internal storage. But it also has a <code>/E</code> option which instead causes APPEND to look for an eponymous environment variable. This mechanism has a disadvantage in that the <code>APPEND=</code> variable needs space in every newly created environment. On the other hand, it also allows different DOS processes to have different APPEND paths.</p>



<p>It should be noted that OS/2 implements a mechanism analogous to <code>APPEND /E</code> through the <code>DPATH</code> environment variable. Only on OS/2 it’s built in, with no need to load TSRs.</p>



<p>Another APPEND addition was the <code>/X</code> switch, which causes APPEND to hook further DOS subfunctions, most notably Find First and Exec. This effectively allows APPEND to supplant the <code>PATH</code> environment variable.</p>



<p>APPEND is listed in the PC DOS 3.3 reference as both internal and external command. At first glance that doesn’t make any sense, but it’s actually true.</p>



<p>The first time APPEND is run, it is an external command. But when it installs itself as a TSR, it hooks INT 2Fh/AEh. COMMAND.COM, in turn, calls INT 2Fh/AEh when it is asked to execute a command that COMMAND.COM does not know about. This mechanism allows APPEND to function as an internal command once it is installed.</p>



<p>That is, the first time APPEND is run, it must be loaded and executed from disk. But any subsequent attempt to run APPEND through COMMAND.COM, either from the command line or a batch file, will take a shortcut directly to the already installed TSR, effectively turning APPEND into an internal command. The INT 2Fh/AEh interface between COMMAND.COM and a TSR was added in DOS 3.3, quite likely for the benefit of APPEND.</p>



<p>APPEND also has its own programming interface, accessed through INT 2Fh/B7h. This allows programs to control APPEND behavior and query the current APPEND path. How widely this is used isn’t entirely clear.</p>



<h3>Summary</h3>



<p>APPEND is one of the things that are completely irrelevant 99.99% of the time… yet can be extremely useful when the need arises. It is a TSR which allows applications to find files in a directory other than the current one.</p>



<p>The first appearance in APPEND was in the IBM PC Network Program (1985), but since version 3.3 (1987) it was integrated into DOS, with an interesting link to COMMAND.COM which allows APPEND to become an internal command once it is installed.</p>
											</div></div>
  </body>
</html>
