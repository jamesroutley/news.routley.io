<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://oshub.org/projects/retros-32/posts/defer-resource-cleanup-in-c-with-gccs-magic">Original</a>
    <h1>Defer: Resource cleanup in C with GCCs magic</h1>
    
    <div id="readability-page-1" class="page"><div><div>
  <div><action-text-attachment sgid="eyJfcmFpbHMiOnsiZGF0YSI6ImdpZDovL29zLWh1Yi9BY3RpdmVTdG9yYWdlOjpCbG9iLzc1ZmY1NTBkLTA0NGQtNDc5NC1iNDUyLWU4OWVmNTdmOTkzOT9leHBpcmVzX2luIiwicHVyIjoiYXR0YWNoYWJsZSJ9fQ==--c39883fd3ce0be96e128f362bb9535a7f75765f7" content-type="image/png" url="https://oshub.org/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsiZGF0YSI6Ijc1ZmY1NTBkLTA0NGQtNDc5NC1iNDUyLWU4OWVmNTdmOTkzOSIsInB1ciI6ImJsb2JfaWQifX0=--669f520fe11acacebd1bf93555ddb19de89134a7/Screenshot%202025-09-24%20at%2008.59.18.png" filename="Screenshot 2025-09-24 at 08.59.18.png" filesize="73798" width="1136" height="250" previewable="true" presentation="gallery" caption="Defer Macro"><figure>
    <img src="https://cdn.oshub.org/rails/active_storage/representations/proxy/eyJfcmFpbHMiOnsiZGF0YSI6Ijc1ZmY1NTBkLTA0NGQtNDc5NC1iNDUyLWU4OWVmNTdmOTkzOSIsInB1ciI6ImJsb2JfaWQifX0=--669f520fe11acacebd1bf93555ddb19de89134a7/eyJfcmFpbHMiOnsiZGF0YSI6eyJmb3JtYXQiOiJwbmciLCJyZXNpemVfdG9fbGltaXQiOlsxMDI0LDc2OF19LCJwdXIiOiJ2YXJpYXRpb24ifX0=--3809ed6c4e3d2e44bade8a316b9825d8584dbfa4/Screenshot%202025-09-24%20at%2008.59.18.png"/>

  <figcaption>
      Defer Macro
  </figcaption>
</figure></action-text-attachment></div><blockquote><strong>Warning</strong>: This is experimental, relies on GCC-specific extensions (__attribute__((cleanup)) and nested functions), and is not portable C. It’s just for fun and exploration. </blockquote><pre>/* The function must take one parameter,
 * a pointer to a type compatible with the variable.
 * The return value of the function (if any) is ignored.
 */
void free_ptr(void* ptr) {
    free(*(void**)ptr);
}

int example(){
    __attribute(cleanup(free_ptr)) char* ptr = malloc(32);
    return 0;
}</pre><div><p>This works, but it isn’t exactly safe. If malloc fails and returns NULL, the cleanup function will still be called, and there’s no simple way to add a guard inside free_ptr. Because of issues like that, I didn’t really use the feature at first.</p></div><pre>int example() {
    int a = 1;

    void set(){
        a = 2;
    }
    set();

    return a;
}</pre><pre>#define __DEFER__(F, V)      \
    auto void F(int*);         \
    __attribute__((cleanup(F))) int V; \
    void F(int*)

#define __DEFER_(N) __DEFER__(__DEFER_FUNCTION_ ## N, __DEFER_VARIABLE_ ## N)
#define __DEFER(N) __DEFER_(N)
#define defer __DEFER(__COUNTER__)x</pre><pre>int example() {
    char* ptr = malloc(32);

    defer { free(ptr); }

    return 0;
}</pre><pre># AT&amp;T syntax
__DEFER_FUNCTION_0.0:
        pushq   %rbp
        movq    %rsp, %rbp
        subq    $16, %rsp
        movq    %rdi, -8(%rbp)
        movq    %r10, %rax
        movq    %r10, -16(%rbp)
        movq    (%rax), %rax
        movq    %rax, %rdi
        call    free
        nop
        leave
        ret
example:
        pushq   %rbp
        movq    %rsp, %rbp
        pushq   %rbx
        subq    $40, %rsp
        leaq    16(%rbp), %rax
        movq    %rax, -40(%rbp)
        movl    $32, %edi
        call    malloc
        movq    %rax, -48(%rbp) # &lt;--- return value set
        
        movl    $0, %ebx
        leaq    -20(%rbp), %rax
        leaq    -48(%rbp), %rdx
        movq    %rdx, %r10
        movq    %rax, %rdi
        call    __DEFER_FUNCTION_0.0
        
        movl    %ebx, %eax # &lt;--- return value restored
        movq    -8(%rbp), %rbx
        leave
        ret</pre><pre>#define __DEFER__(F, V)      \
    auto inline __attribute__((always_inline)) void F(int*);         \
    __attribute__((cleanup(F))) int V; \
    inline __attribute__((always_inline)) void F(int*)
#define __DEFER_(N) __DEFER__(__DEFER_FUNCTION_ ## N, __DEFER_VARIABLE_ ## N)
#define __DEFER(N) __DEFER_(N)
#define defer __DEFER(__COUNTER__)</pre><pre>#include &lt;stdlib.h&gt;

struct object {
    int value;
};

int example(int val) {
    
    struct object* obj = malloc(sizeof(struct object));
    if(obj == NULL) return -1;

    defer { free(obj); }

    obj-&gt;value = val;
    if(obj-&gt;value == 8){
        return obj-&gt;value;
    }

    obj-&gt;value = 10;
    return obj-&gt;value;
}</pre><pre># AT&amp;T syntax
example:
        pushq   %rbp
        movq    %rsp, %rbp
        pushq   %rbx
        subq    $56, %rsp
        movl    %edi, -52(%rbp)
        leaq    16(%rbp), %rax
        movq    %rax, -40(%rbp)
        movl    $4, %edi
        call    malloc
        movq    %rax, -48(%rbp)
        movq    -48(%rbp), %rax
        testq   %rax, %rax
        jne     .L2
        movl    $-1, %ebx
        jmp     .L6 # &lt;--- instant jump to return, no defer.
.L2:
        movq    -48(%rbp), %rax
        movl    -52(%rbp), %edx
        movl    %edx, (%rax)
        movq    -48(%rbp), %rax
        movl    (%rax), %eax
        cmpl    $8, %eax
        jne     .L4
        movq    -48(%rbp), %rax
        movl    (%rax), %ebx
        jmp     .L5
.L4:
        movq    -48(%rbp), %rax
        movl    $10, (%rax)
        movq    -48(%rbp), %rax
        movl    (%rax), %ebx
.L5:
        leaq    -28(%rbp), %rax
        movq    %rax, -24(%rbp)
        movq    -48(%rbp), %rax
        movq    %rax, %rdi
        call    free # &lt;--- Defer&#39;d free called before return
        nop
.L6:
        movl    %ebx, %eax
        movq    -8(%rbp), %rbx
        leave
        ret</pre><ul><li>The malloc failure check jumps straight to .L6, skipping defer entirely. This makes sense, since the defer was defined after the allocation.</li><li>Early returns still trigger the cleanup. At .L2 you can see the code checking for obj-&gt;value == 8. Instead of jumping out immediately, it goes through .L5, where the free call happens.</li><li>The return value is always stored before defer runs. Even when freeing the object, the function returns the right value without accessing freed memory.</li></ul><pre>int example(int val) {
    struct object* obj = malloc(sizeof(struct object));
    if (obj == NULL) return -1;

    obj-&gt;value = val;
    if (obj-&gt;value == 8) {
        int result = obj-&gt;value;
        goto cleanup;   // jump to cleanup before returning
    }

    obj-&gt;value = 10;
    int result = obj-&gt;value;
    goto cleanup;

cleanup:
    free(obj);
    return result;
}</pre>
</div>
</div></div>
  </body>
</html>
