<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vikramoberoi.com/a-primer-on-roaring-bitmaps-what-they-are-and-how-they-work/">Original</a>
    <h1>Roaring bitmaps: what they are and how they work</h1>
    
    <div id="readability-page-1" class="page"><div>
        <figure><img src="https://vikramoberoi.com/content/images/2022/08/24af07058354b122975355ca6527a5cdc2f7a1eb.png" alt="" loading="lazy" width="2000" height="2100" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/24af07058354b122975355ca6527a5cdc2f7a1eb.png 600w, https://vikramoberoi.com/content/images/size/w1000/2022/08/24af07058354b122975355ca6527a5cdc2f7a1eb.png 1000w, https://vikramoberoi.com/content/images/size/w1600/2022/08/24af07058354b122975355ca6527a5cdc2f7a1eb.png 1600w, https://vikramoberoi.com/content/images/2022/08/24af07058354b122975355ca6527a5cdc2f7a1eb.png 2000w" sizes="(min-width: 720px) 720px"/><figcaption>Unfortunately not what this post is about. Credit: <a href="https://katiebcartoons.com">katiebcartoons.com</a></figcaption></figure><p>I came across Roaring bitmaps when I learned about <a href="https://vikramoberoi.com/using-bitmaps-to-run-interactive-retention-analyses-over-billions-of-events-for-less-than-100-mo/">this fun hack to do retention analyses at scale with bitmaps</a>. Using Roaring bitmaps instead of traditional bitmaps in that application reduced memory usage from ~125GB to 300MB, an impressive 99.8% savings.</p><p>But... how?</p><p>You can learn about Roaring bitmaps over two research papers: </p><ol><li><a href="https://arxiv.org/pdf/1402.6407.pdf">This one proposes the data structure.</a></li><li><a href="https://arxiv.org/pdf/1603.06549.pdf">This one introduces a critical optimization.</a></li></ol><p>In this post I briefly describe what bitmaps are, what they&#39;re used for, and what Roaring bitmaps solve that traditional bitmaps don&#39;t. Then, I distill the high-level structure of Roaring bitmaps and how they work, one step at a time.</p><p>Roaring bitmaps employ a number of algorithms, techniques, and heuristics that I won&#39;t go into in detail. They also offer some operations beyond the ones I describe. These details are not critical to understanding the basic internal structure and operation of Roaring bitmaps which is the focus of this post.</p><p>Let&#39;s begin!</p><p><a href="https://en.wikipedia.org/wiki/Bit_array">Bitmaps</a> are arrays of bits used to store sets of integers.</p><p>They work by setting the Nth bit when an integer N is in the set, as illustrated in <strong>Figure 1.</strong></p><figure><img src="https://vikramoberoi.com/content/images/2022/08/bitmap-3.png" alt="" loading="lazy" width="534" height="340"/><figcaption><strong>Figure 1. </strong>An illustration of how a bitmap works.</figcaption></figure><p>By storing sets of integers this way, bitmaps can take advantage of extremely fast bitwise-AND and bitwise-OR CPU instructions to compute set intersections and unions.</p><p>It turns out that fast set intersections and unions are critical for many search and database applications. Various operations exist in search and database indexes that boil down to having two sets of integers and needing to intersect or union them quickly.</p><p>Take an inverted search index, for example:</p><!--kg-card-begin: markdown--><ul>
<li><strong>You&#39;ve indexed billions of documents.</strong> Each document has an integer id.</li>
<li><strong>The index maps terms to a set of documents in which they appear.</strong> For example, the term <code>pigeon</code> appears in documents with these ids: <code>{2, 345, 2034, ...}</code>.</li>
<li><strong>Queries that search across terms use set operations.</strong> In order to resolve a search query like <code>carrier AND pigeon</code> you need the intersection of the set of documents that contain <code>carrier</code> and the set of documents that contain <code>pigeon</code>.</li>
<li><strong>Bitwise operations can perform these set operations quickly.</strong> If you  represent sets of document ids as bitmaps, the query above is a bitwise-AND.</li>
</ul>
<!--kg-card-end: markdown--><p>Columnar databases use set operations similarly for certain classes of queries.</p><p>If you&#39;d like to dive into a use case outside search and databases, <a href="https://vikramoberoi.com/using-bitmaps-to-run-interactive-retention-analyses-over-billions-of-events-for-less-than-100-mo/">a previous post I wrote</a> discusses how bitmaps can be used to analyze user retention for SaaS products.</p><p>Unfortunately, bitmaps suffer from awful compression in common cases involving very large sets of integers – scenarios that appear frequently in the use cases I just described.</p><p>Recall the figure I cited at the beginning of the post:</p><blockquote>Using Roaring bitmaps instead of traditional bitmaps in that application reduced memory usage from ~125GB to 300MB, an impressive 99.8% savings.</blockquote><p><em>That&#39;s</em> the problem with bitmaps, and I&#39;ll walk you through why this happens shortly.</p><p>From <a href="https://roaringbitmap.org">roaringbitmap.org</a>:</p><blockquote>Roaring bitmaps are compressed bitmaps. They can be hundreds of times faster.</blockquote><p>A great, pithy marketing statement on the Roaring bitmap website! Let&#39;s expand on it a wee bit.</p><p>Roaring bitmaps are just optimized bitmaps, <em>which I&#39;ll refer to henceforth as &#34;traditional bitmaps&#34;</em>.</p><p>Both traditional and Roaring bitmaps offer a set data structure for integers. You can insert integers, check the existence of an integer, and get the intersection and union of two sets of integers.</p><p>Roaring bitmaps offer better compression than traditional bitmaps. Importantly, they do so without significantly sacrificing the performance of set operations.</p><p><a href="https://roaringbitmap.org">roaringbitmap.org</a> boasts an impressive list of OLAP databases and search systems that use Roaring bitmaps under the hood. These are all applications that:</p><ul><li>... need to store large sets of integers</li><li>... in as little memory as possible</li><li>... and execute fast set operations.</li></ul><p>When a set is <strong>sparse</strong>, traditional bitmaps compress poorly.</p><p>Recall that traditional bitmaps will set the Nth bit when you add an integer N to it (see <strong>Figure 1</strong>).</p><p>Let&#39;s say you have an empty traditional bitmap to which you add the integer 8,000,000. Here&#39;s what will happen:</p><ul><li>It will allocate 1,000,000 bytes.</li><li>It will set the 8,000,000th bit.</li></ul><p>This is illustrated in <strong>Figure 2</strong>.</p><figure><img src="https://vikramoberoi.com/content/images/2022/08/8mm-bit.png" alt="" loading="lazy" width="590" height="366"/><figcaption><strong>Figure 2. </strong>What happens if you allocate the 8 millionth bit outright in an empty bitmap.</figcaption></figure><p>Why is this bad?</p><ul><li>Your set has 1 integer.</li><li>An integer takes up 4 bytes.</li><li>Your traditional bitmap has allocated 1 megabyte.</li></ul><p>That&#39;s 6 orders of magnitude more memory than you need.</p><p>Whoops!</p><p>Roaring bitmaps solve this problem. Importantly, they do so <strong>while maintaining fast set operations</strong>. This is what makes Roaring bitmaps special.</p><p>Prior research attempts to solve poor compression in bitmaps achieve impressive results too, but at the cost of efficient set operations.</p><p>There isn&#39;t one deep insight that allows Roaring bitmaps to perform well. But there is <em>a lot of stuff</em> going on that is greater than the sum of its parts. </p><p>The following builds up an understanding of Roaring bitmaps one concept at a time.</p><h2 id="part-1-how-roaring-bitmaps-are-represented-in-memory">Part 1: how Roaring bitmaps are represented in memory</h2><h3 id="all-32-bit-integers-are-partitioned-into-contiguous-chunks">All 32-bit integers are partitioned into contiguous chunks.</h3><figure><img src="https://vikramoberoi.com/content/images/2022/08/chunks-1.png" alt="" loading="lazy" width="1276" height="678" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/chunks-1.png 600w, https://vikramoberoi.com/content/images/size/w1000/2022/08/chunks-1.png 1000w, https://vikramoberoi.com/content/images/2022/08/chunks-1.png 1276w" sizes="(min-width: 720px) 720px"/><figcaption><strong>Figure 3. </strong>How the space of 32-bit integers is partitioned into chunks in Roaring bitmaps.</figcaption></figure><p>Each chunk shares the same 16 most significant bits.</p><p>As shown in <strong>Figure 3, </strong>the partitioning scheme used by Roaring bitmaps ensures that an integer will always belong to the same chunk of 2^16, or 65,536 consecutive integers.</p><p><strong>Note: </strong>there are 64-bit implementations of Roaring bitmaps, but this post does not go into them. See <a href="https://github.com/RoaringBitmap/CRoaring">CRoaring</a>, this <a href="https://github.com/outcaste-io/sroar">native Go implementation</a>, and, uh, <a href="https://r-libre.teluq.ca/930/1/Roaring64bits.pdf">this paper written in French</a> (if you find a translation, please let me know).</p><h3 id="integers-in-the-same-chunk-are-stored-in-containers">Integers in the same chunk are stored in containers.</h3><p>Chunks are how integers are logically partitioned in Roaring bitmaps. All integers that belong to a chunk are physically (in memory) stored in the same <strong><em>container</em></strong>.</p><figure><img src="https://vikramoberoi.com/content/images/2022/08/containers-3.png" alt="" loading="lazy" width="1696" height="964" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/containers-3.png 600w, https://vikramoberoi.com/content/images/size/w1000/2022/08/containers-3.png 1000w, https://vikramoberoi.com/content/images/size/w1600/2022/08/containers-3.png 1600w, https://vikramoberoi.com/content/images/2022/08/containers-3.png 1696w" sizes="(min-width: 720px) 720px"/><figcaption><strong>Figure 4. </strong>Three contrived examples of containers from the first Roaring bitmap paper. </figcaption></figure><p><strong>Figure 4 </strong>shows examples of three different containers for three different chunks.</p><p>A chunk will always only have one container in a Roaring bitmap, defined by the 16 most significant bits of all the integers in the chunk.</p><p>If your program inserted the first 1,000 multiples of 62 into a Roaring bitmap, then they would be end up in the left-most container in <strong>Figure 4. </strong>That container&#39;s cardinality would be 1,000.</p><p>If you later inserted the integer 63, it would end up in the same container. The container&#39;s cardinality would then be 1,001.</p><p>As you&#39;ll see next, the cardinality of a container determines how it will be represented in memory.</p><h3 id="sparse-containers-contain-4096-integers-these-are-stored-as-sorted-packed-arrays">Sparse containers contain &lt;= 4,096 integers. These are stored as sorted packed arrays.</h3><p>Two of the containers in in <strong>Figure 4</strong> are sparse (with cardinalities 1,000 and 100) so they will be stored as <strong><em>sorted packed arrays </em></strong>of 16-bit integers.</p><p>By <strong>packed</strong>, we mean that we will be packing 32-bit integers into 16-bit integers as shown in <strong>Figure 5</strong>. </p><figure><img src="https://vikramoberoi.com/content/images/2022/08/sparse-containers-2.png" alt="" loading="lazy" width="1668" height="522" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/sparse-containers-2.png 600w, https://vikramoberoi.com/content/images/size/w1000/2022/08/sparse-containers-2.png 1000w, https://vikramoberoi.com/content/images/size/w1600/2022/08/sparse-containers-2.png 1600w, https://vikramoberoi.com/content/images/2022/08/sparse-containers-2.png 1668w" sizes="(min-width: 720px) 720px"/><figcaption><strong>Figure 5. </strong>Two sparse Roaring bitmap containers from Figure 2 alongside examples of how they are stored in memory.</figcaption></figure><p>Packing integers is possible because each container can store at most 2^16 distinct integers. To get the original 32-bit integer in a sparse container, we have to unpack<strong> </strong>it by combining the 16-bit integer with its 16 most significant bits.</p><p>These arrays are dynamically allocated so the memory used by a sparse container grows as it accrues integers.</p><h3 id="dense-containers-contain-4096-integers-these-are-stored-as-bitmaps">Dense containers contain &gt; 4,096 integers. These are stored as bitmaps.</h3><p>One of the containers in <strong>Figure 4 </strong>is dense (with cardinality 2<sup>15</sup>) so it will be stored as a traditional bitmap.</p><figure><img src="https://vikramoberoi.com/content/images/2022/08/dense-containers-2.png" alt="" loading="lazy" width="1668" height="288" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/dense-containers-2.png 600w, https://vikramoberoi.com/content/images/size/w1000/2022/08/dense-containers-2.png 1000w, https://vikramoberoi.com/content/images/size/w1600/2022/08/dense-containers-2.png 1600w, https://vikramoberoi.com/content/images/2022/08/dense-containers-2.png 1668w" sizes="(min-width: 720px) 720px"/><figcaption><strong>Figure 6. </strong>A dense Roaring bitmap container from Figure 2 alongside an example of how it is stored in memory.</figcaption></figure><p>Dense containers are bitmaps containing 2^16 bits (8 kilobytes), allocated outright. The Nth bit in the bitmap maps to the Nth integer in a chunk.</p><h3 id="a-first-level-index-points-to-all-containers-the-index-is-stored-as-a-sorted-array">A first-level index points to all containers. The index is stored as a sorted array.</h3><p>The first-level index stores the 16 most significant bits for each container in the Roaring bitmap along with a pointer to the corresponding container.</p><figure><img src="https://vikramoberoi.com/content/images/2022/08/index-1.png" alt="" loading="lazy" width="1234" height="600" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/index-1.png 600w, https://vikramoberoi.com/content/images/size/w1000/2022/08/index-1.png 1000w, https://vikramoberoi.com/content/images/2022/08/index-1.png 1234w" sizes="(min-width: 720px) 720px"/><figcaption><strong>Figure 7. </strong>The containers described in Figure 2, 3, and 4 with a first-level index pointing to them.</figcaption></figure><p>The index is stored as a sorted array and grows dynamically as new containers are added to the Roaring bitmap.</p><h2 id="part-2-how-set-operations-work-with-roaring-bitmaps">Part 2: how set operations work with Roaring bitmaps</h2><h3 id="integer-insertion-varies-by-container-type-and-may-cause-a-containers-type-to-change">Integer insertion varies by container type and may cause a container&#39;s type to change.</h3><p>To insert an integer, N, get N&#39;s 16 most significant bits (<code>N / 2^16</code>) and use it to find N&#39;s corresponding container in the Roaring bitmap.</p><p>Insertions in array and bitmap containers work differently:</p><ul><li><strong>Bitmap: </strong>set the bit at <code>N % 2^16</code>.</li><li><strong>Array: </strong>insert <code>N % 2^16</code> in its position in the sorted array.</li></ul><p><em>Insertions may change the container type. </em>If an array container has 4,096 integers, first convert it to a bitmap container. Then set the bit at <code>N % 2^16</code>.</p><p>If a container doesn&#39;t already exist then create a new array container, add it to the Roaring bitmap&#39;s first-level index, and add N to the array.</p><h3 id="checking-for-existence-varies-by-container-type">Checking for existence varies by container type.</h3><p>To check if an integer N exists, get N&#39;s 16 most significant bits (<code>N / 2^16</code>) and use it to find N&#39;s corresponding container in the Roaring bitmap.</p><p>If the container doesn&#39;t exist, then N is not in the Roaring bitmap.</p><p>Checking for existence in array and bitmap containers works differently:</p><ul><li><strong>Bitmap: </strong>check if the bit at <code>N % 2^16</code> is set.</li><li><strong>Array: </strong>use binary search to find <code>N % 2^16</code> in the sorted array.</li></ul><h3 id="intersect-matching-containers-to-intersect-two-roaring-bitmaps-algorithms-vary-by-container-types-and-container-types-may-change">Intersect matching containers to intersect two Roaring bitmaps. Algorithms vary by container type(s), and container types may change.</h3><p>To intersect Roaring bitmaps A and B, it is sufficient to intersect matching containers in A and B.</p><p>This is possible because of how integers are partitioned in Roaring bitmaps: matching containers in A and B store integers with the same 16 most significant bits (the same chunks).</p><p>Intersection algorithms vary by the types of the containers involved, as do the resulting container types:</p><ul><li><strong>Bitmap /</strong> <strong>Bitmap: </strong>Compute the bitwise AND of the two bitmaps. If the cardinality is &lt;= 4,096, store the result in an array container, otherwise store it in a bitmap container.</li><li><strong>Bitmap / Array: </strong>Iterate over the array, checking for the existence of each 16-bit integer in the bitmap. If the integer exists, add it to the resulting array container – note that intersections of bitmap and array container types will always create an array container.</li><li><strong>Array / Array: </strong>Intersections of two array containers always create a new array container. The algorithm used to compute the intersection varies by a <a href="https://arxiv.org/pdf/1402.6407.pdf">cardinality heuristic described at the bottom of page 5 here</a>. It will either be a simple merge (as used in merge sort) or a galloping intersection, <a href="https://dl.acm.org/doi/10.1145/1877766.1877767">described in this paper</a>.</li></ul><p>If there is a container in either Roaring bitmap without a corresponding container in the other, it will not exist in the result: the intersection of an empty set and any set is an empty set.</p><h3 id="union-matching-containers-to-produce-a-roaring-bitmap-union-algorithms-vary-by-container-types-and-container-types-may-change">Union matching containers to produce a Roaring bitmap union. Algorithms vary by container type(s), and container types may change.</h3><p>To union Roaring bitmaps A and B, union all matching containers in A and B. </p><p>Union algorithms vary by the container types involved, as do the resulting container types:</p><ul><li><strong>Bitmap / Bitmap: </strong>Compute the bitwise OR of the two bitmaps. Unions of two bitmap containers will always create another bitmap container.</li><li><strong>Bitmap / Array: </strong>Copy the bitmap and set corresponding bits for all the integers in the array container. Unions of a bitmap and array container will always create another bitmap container.</li><li><strong>Array / Array: </strong>If the sum of the cardinalities of the two array containers is &lt;= 4,096, the resulting container will be an array container. In this case, add all integers from both arrays to a new array container. Otherwise, optimistically assume the resulting container will be a bitmap: create a new bitmap container and set all corresponding bits for all integers in both arrays. If the cardinality of the resulting container is &lt;= 4,096, convert the bitmap container back into an array container.</li></ul><p>Finally, add all containers in A and B that do not have a matching container to the result. Remember: this is a union, so all integers in Roaring bitmaps A and B must be in the resulting set.</p><h2 id="part-3-how-a-third-and-final-container-type-%E2%80%93-the-run-container-%E2%80%93-optimizes-long-runs-of-consecutive-integers">Part 3: how a third and final container type – the &#34;run&#34; container – optimizes long runs of consecutive integers.</h2><p>Parts 1 and 2 of this post cover most of the internal structure and operation of Roaring bitmaps. This final part covers an important optimization described in <a href="https://arxiv.org/pdf/1603.06549.pdf">the second Roaring bitmap paper.</a></p><h3 id="run-containers-represent-runs-of-consecutive-integers-with-two-16-bit-integers-the-run-start-and-run-length">Run containers represent runs of consecutive integers with two 16-bit integers: the run start and run length.</h3><p>From page 3 of the <a href="https://arxiv.org/pdf/1603.06549.pdf">second Roaring bitmap paper</a>:</p><blockquote>The new container is conceptually simple: given a run (e.g., [10, 1000]), we store the starting point (10) and its length minus one (990) ... packing the starting points and the lengths in pairs, using 16 bits each ...</blockquote><p>This technique is known as <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a> and seems to back most of the prior art described in the two papers. Run-length encoding can compress bitmaps effectively but degrades performance for set operations in many cases.</p><h3 id="run-containers-are-formed-explicitly-when-a-client-invokes-a-runoptimize-function-or-in-some-cases-implicitly-when-a-large-range-is-added-to-the-roaring-bitmap">Run containers are formed explicitly when a client invokes a <em>runOptimize </em>function or, in some cases, implicitly when a large range is added to the Roaring bitmap.</h3><p>Unlike sparse and dense containers, run containers generally do not materialize automatically.</p><ol><li>Clients can invoke <em>runOptimize </em>to optimize their Roaring bitmap for large runs of consecutive integers. Run containers <strong><em>may </em></strong>replace existing array or bitmap containers in this case.</li><li>Roaring bitmaps offer an operation to add a range of values. Run containers <strong><em>may </em></strong>materialize automatically in this case.</li></ol><p>The papers don&#39;t actually prescribe how or when #2 should happen. I&#39;d guess that if a range of values were added for a chunk that does not yet have a container, it makes sense to create a run container instead of an array or bitmap container.</p><h3 id="runoptimize-only-creates-a-run-container-if-it-will-be-smaller-than-the-container-it-would-replace"><em>runOptimize </em>only creates a run container if it will be smaller than the container it would replace.</h3><p><em>runOptimize </em>first counts the number of runs in a container.</p><p>Then, it decides whether or not to create a run container using a simple heuristic: the run container must be smaller than its equivalent array or bitmap container. </p><p>The algorithms used to count runs and a description of how to compute the heuristic above are described on <a href="https://arxiv.org/pdf/1603.06549.pdf">page 6 and 7 in the second Roaring bitmap paper</a>.</p><p>If you&#39;d like to work out computing the heuristic yourself, it&#39;ll help to recall the following:</p><ul><li>... array containers contain no more than 4,096 integers, packed into 16-bits each.</li><li>... bitmap containers contain &gt; 4,096 integers in a bitmap with 2^16 bits (8,192 bytes).</li><li>... each run in a run container takes up 32 bits (16 bits for the start, 16 bits for the length).</li></ul><h3 id="the-addition-of-run-containers-introduces-new-algorithms-for-all-set-operations">The addition of run containers introduces new algorithms for all set operations.</h3><p>The Roaring bitmap papers do not describe the algorithms used to insert and check for the existence of integers in run containers: these operations are relatively straightforward.</p><p>But the addition of run containers requires that Roaring bitmaps implement performant algorithms for unions and intersections of <em>three </em>new container type pairs:</p><ul><li>Run / Run</li><li>Run / Array</li><li>Run / Bitmap</li></ul><p>These algorithms also introduce new heuristics to determine the resulting container type from these operations.</p><p>I won&#39;t go into the details of these algorithms as I did in Part 2. The algorithms are not significantly more complicated (their descriptions start <a href="https://arxiv.org/pdf/1603.06549.pdf">on page 10 here</a> if you&#39;re curious), but the numerous details are beyond the scope of this post and the paper is well-written and makes them extremely accessible.</p><figure><img src="https://vikramoberoi.com/content/images/2022/08/6roe7c.jpg" alt="" loading="lazy" width="666" height="500" srcset="https://vikramoberoi.com/content/images/size/w600/2022/08/6roe7c.jpg 600w, https://vikramoberoi.com/content/images/2022/08/6roe7c.jpg 666w"/><figcaption>A Roaring bitmap creator hard at work.</figcaption></figure><p>Roaring bitmaps use a kitchen sink of algorithms and techniques to achieve better compression and faster performance than other bitmap implementations.</p><p>They&#39;re challenging to implement but they do the job extremely well, especially when used in OLAP workloads. The creators managed to root out inefficiencies in common yet very different scenarios – sparse data, dense data, data with a lot of runs – and address all of them at once.</p><p>And they go even further!</p><p>A <a href="https://arxiv.org/pdf/1709.07821v4.pdf">third paper</a> describes an implementation the creators wrote in C that leverages vectorized algorithms they designed to use SIMD (single instruction multiple data) instructions. That implementation, CRoaring, along with bindings and implementations in multiple other languages are <a href="https://github.com/RoaringBitmap">available here</a>. They&#39;re used in mainstream columnar databases and search applications and are actively maintained, improved, and optimized regularly.</p><p>Very cool.</p><p>If you enjoyed reading this post and want to dig in further, I recommend reading the Roaring bitmap papers. They&#39;re well-written and accessible.</p><ul><li><a href="https://arxiv.org/pdf/1402.6407.pdf">Better bitmap performance with Roaring bitmaps</a></li><li><a href="https://arxiv.org/pdf/1603.06549.pdf">Consistently faster and smaller compressed bitmaps with Roaring</a></li><li><a href="https://arxiv.org/pdf/1709.07821v4.pdf">Roaring Bitmaps: Implementation of an Optimized Software Library</a></li></ul><p>Roaring bitmap implementations are <a href="https://github.com/RoaringBitmap">available on Github</a>.</p><!--kg-card-begin: html--><p><span>Thanks to Chuck Groom, Andy O&#39;Neill, Phil Eaton, Ben Johnson, and Simon Willems.</span></p><!--kg-card-end: html--><hr/><figure><blockquote><p lang="en" dir="ltr">Roaring bitmaps compress bitmaps impressively well and still offer fast set operations. In a use case I wrote about recently, they compressed 125GB of data to 300MB.</p>— Vikram Oberoi (@voberoi) <a href="https://twitter.com/voberoi/status/1565724262798868488?ref_src=twsrc%5Etfw">September 2, 2022</a></blockquote>

</figure>
    </div></div>
  </body>
</html>
