<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://clace.io/blog/sqlite/">Original</a>
    <h1>Using SQLite as Storage for Web Server Static Content</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Clace is an
<a href="https://github.com/claceio/clace">open source project</a>
building a secure platform for easily developing and deploying internal
tools across a team. Clace can be used to develop actions which present a
simple auto-generated web UI for backend operations. Clace also implements
an appserver for containerized web apps implemented in any language.<br/></p></div></div><h2>Background<span id="background"></span>
<a href="#background" aria-label="Permalink for this section"></a></h2><p>Clace is built to serve web applications, primarily for internal tools. Clace provides functionality usually handled separately by a web server and an application server. When the development of Clace was started last year, one of the first decisions was how to store the application data (files) and metadata. The app metadata obviously made sense to store in a database, since apps are created dynamically. The app data (static files, app code, config files etc) is usually stored on the file system by most web servers.</p><h2>Using SQLite for serving files<span id="using-sqlite-for-serving-files"></span>
<a href="#using-sqlite-for-serving-files" aria-label="Permalink for this section"></a></h2><p>For Clace, the decision was made to use <a href="https://www.sqlite.org/" target="_blank" rel="noopener">SQLite</a> for app files storage instead of using the file system. The reasoning was mainly to be able to do atomic version changes. When updating an app, since there could be lots of files being updated, using a database would allow all changes to be done atomically in a transaction. This would prevent broken web pages from being served during a version change.</p><p>Clace uploads all files to the SQLite database during app creation and updates. Files are uploaded from GitHub or from local disk. Only for <a href="https://clace.io/docs/applications/lifecycle/#development-apps">development mode</a>, the local file system is used.</p><h2>Benefits of using SQLite<span id="benefits-of-using-sqlite"></span>
<a href="#benefits-of-using-sqlite" aria-label="Permalink for this section"></a></h2><p>The decision to use SQLite for file storage has provided lots of additional benefits (some unanticipated).</p><ul><li><p><strong>Transactional Updates</strong> : This is the main benefit. Updating multiple files can be done in one transaction. Isolation ensures that there are no broken webapps during the update.</p></li><li><p><strong>Deployment Rollbacks</strong>: Another of the transactional benefits is the ability to roll back deployment in case of errors. If multiple apps are being updated, all of them can be rolled back in one go. Rolling back a database transaction is much easier than cleaning up files on the file system.</p></li><li><p><strong>File De-duplication Across Versions</strong>: Clace automatically <a href="https://clace.io/docs/applications/overview/#app-listing">versions</a> all updates. This can lead to lots of duplicate files. The file data is stored in a table with the schema</p></li></ul><p>The uncompressed content SHA256 hash is used as the primary key to store the file data. This means that even if multiple versions of an app have the same file, the file contents are stored only once.</p><ul><li><p><strong>De-duplication Across Apps</strong> : Each production app in Clace has an <a href="https://clace.io/docs/applications/lifecycle/#application-types">staging app</a>. Apps can have multiple <a href="https://clace.io/docs/applications/lifecycle/#preview-apps">previews apps</a>. This can lead to lots of duplication of files. Using the database helps avoid all the duplication. Even across apps, there are files which have the same contents. Files are de-duplicated across apps also.</p></li><li><p><strong>Easy Backups</strong>: Using SQLite means that backups are easy. The state of the whole system, metadata and files can be backed up easily using SQLite backup tools like <a href="https://litestream.io/" target="_blank" rel="noopener">Litestream</a>.</p></li><li><p><strong>Content Hashing</strong>: For content caching on the browser, web servers return a <a href="https://en.wikipedia.org/wiki/HTTP_ETag" target="_blank" rel="noopener">ETag</a> header. Using the database for files makes it easy to save the content SHA once during file upload without having to recompute it later.</p></li><li><p><strong>Compression</strong>: The file contents are saved <a href="https://en.wikipedia.org/wiki/Brotli" target="_blank" rel="noopener">Brotli</a> compressed in the SQLite table. The database approach has the advantage that contents can be saved in multiple formats easily. GZip compressed data and uncompressed data can be added by just adding a column in the <code>files</code> table.</p></li></ul><h2>Performance<span id="performance"></span>
<a href="#performance" aria-label="Permalink for this section"></a></h2><p>For Clace, the SQLite database approach provides great performance. There is no equivalent implementation using the file system to compare against, so a direct benchmark test is not done. Based on <a href="https://www.sqlite.org/fasterthanfs.html" target="_blank" rel="noopener">benchmarking</a> done by the SQLite team, SQLite can have better performance than direct file system use for some workloads.</p><h2>Multi-Node Support<span id="multi-node-support"></span>
<a href="#multi-node-support" aria-label="Permalink for this section"></a></h2><p>Clace currently runs on a single node. When multi-node support is added later, the plan is to use a shared Postgres database instead of using local SQLite for metadata and file data storage. This will come with latency issues. The plan is to use a local SQLite database as a file cache to avoid latency while accessing Postgres.</p><h2>Why this approach is not more common?<span id="why-this-approach-is-not-more-common"></span>
<a href="#why-this-approach-is-not-more-common" aria-label="Permalink for this section"></a></h2><p>One of the reasons most web servers use the file system is convenience. File updates can be done using any file system tool: rsync, tar etc work for copying files over. The other reason is probably historical: file systems are what were used before there were good in-process relational databases available. Using a database means some kind of API interface is required for uploading files, which is not always feasible.</p></div></div>
  </body>
</html>
