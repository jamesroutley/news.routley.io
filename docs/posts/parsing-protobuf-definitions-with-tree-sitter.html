<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://relistan.com/parsing-protobuf-files-with-treesitter">Original</a>
    <h1>Parsing Protobuf Definitions with Tree-sitter</h1>
    
    <div id="readability-page-1" class="page"><div>
      



<div id="main" role="main">
  
  



  <div>
    
      
    
    <p><img src="https://relistan.com/images/tree-sitter-small.png" alt="Tree-sitter logo"/></p>

<p>If you work with Protocol Buffers (<code>protobuf</code>), you can really save time,
boredom, and headache by parsing your definitions to build tools and generate
code.</p>

<p>The usual tool for doing that is <code>protoc</code>. It supports plugins to generate
output of various kinds: language bindings, documentation etc. But, if you want
to do anything custom, you are faced with either using something limited like
<a href="https://github.com/moul/protoc-gen-gotemplate">protoc-gen-gotemplate</a> or
writing your own plugin. <code>protoc-gen-gotemplate</code> works well, but you can’t
build complex logic into the workflow. You are limited to what is possible in a
simple Go template.</p>

<p>It’s also possible to use <code>protoreflect</code> from Go to process the compiled results
at runtime. This is painful. Really painful.</p>

<p>So, at work, we had made limited use of the <code>protobuf</code> definitions other than
for their main purpose and for documentation and package configuration via
custom options (these are supported in <code>protobuf</code>). Writing the <code>protoreflect</code>
code to make that work is not something I want to repeat.</p>

<p>Then I recently revamped my editor setup and moved from
<a href="https://www.vim.org/">Vim</a> to <a href="https://neovim.io/">Neovim</a>. In the process I
realized how awesome the
<a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> parsing library is
and that it probably was going to support extracting everything I wanted to get
from our <code>protobuf</code> definitions. Neovim uses Tree-sitter extensively.</p>

<h2 id="why-this-matters">Why This Matters</h2>

<p>Our evented and event-sourced backend at <a href="https://mozi.app">Mozi</a> relies on
<code>protobuf</code> for schema definitions and serialization of events. We use these
same schemas everywhere from the frontend all the way to the backend. This
means our whole system is working on the exact same entity definitions
throughout. Good Stuff™.</p>

<p>In Go, the bindings are not really native structs and require a lot of
<code>GetXYZ()</code> and <code>GetValue()</code> calls chained with nil checking to work around the
fact that <code>nil</code> and zero values are encoded the same way in Protobuf. You also
can’t use them in conjunction with anything that uses <code>struct</code> tags because you
can’t apply tags. I am told by the mobile devs that the Swift bindings are
similarly unfriendly.</p>

<p>We use a mapping layer to paper over this and to make these easier to work with
in in our Go code, in data stores, and with off-the-shelf libraries.</p>

<p>We were maintaining custom mappings by hand. That’s a waste of time and even
getting GPT to write the transformations back and forth is annoying, and
invariably requires tweaking. So I wanted a solution that was much more
automatic and repeatable.</p>

<p>Here’s what I did.</p>

<h2 id="example-definition">Example Definition</h2>

<p>First we’ll have a look at one <code>protobuf</code> definition. Then we’ll talk about
extracting the information we want from it.</p>

<p>Imagine that we’re working with the following fairly typical <code>protobuf</code> message
definition. We want to be able to extract the name of the message, the enum
names and values, and the fields and their types. Here we are not particularly
interested in the field numbers, but you could also extract them, of course.</p>

<figure><pre><code data-lang="protobuf"><span>syntax</span> <span>=</span> <span>&#34;proto3&#34;</span><span>;</span>
<span>package</span> <span>entities</span><span>;</span>
<span>import</span> <span>&#34;google/protobuf/wrappers.proto&#34;</span><span>;</span>

<span>// A BlogPost represents a single post on the blog.</span>
<span>message</span> <span>BlogPost</span> <span>{</span>
  <span>// Some custom configuration options</span>
  <span>// ...</span>

  <span>// Each blog post is assigned a type so we can identify how it will be used</span>
  <span>enum</span> <span>PostType</span> <span>{</span>
    <span>POST_TYPE_NOT_SET</span> <span>=</span> <span>0</span><span>;</span>
    <span>POST_TYPE_ARTICLE</span> <span>=</span> <span>1</span><span>;</span>
    <span>POST_TYPE_PAGE</span> <span>=</span> <span>2</span><span>;</span>
    <span>POST_TYPE_SPLASH</span> <span>=</span> <span>3</span><span>;</span>
  <span>}</span>

  <span>google.protobuf.StringValue</span> <span>post_id</span> <span>=</span> <span>1</span><span>;</span> <span>// The ID of the blog post</span>
  <span>PostType</span> <span>post_type</span> <span>=</span> <span>2</span><span>;</span> <span>// What kind of post is this?</span>
  <span>google.protobuf.StringValue</span> <span>title</span> <span>=</span> <span>3</span><span>;</span> <span>// The title of the post</span>
  <span>google.protobuf.StringValue</span> <span>body</span> <span>=</span> <span>4</span><span>;</span> <span>// The actual contents of the post</span>
<span>}</span></code></pre></figure>

<p>This typical message contains a single enum type and 4 fields. Real life
messages will contain many more fields, but this is enough for us in this post.
Looking at this, we <em>could</em> hack something to parse this fairly simple example
using regexes or other string matching. But it would end up being pretty
brittle. You could even break most trivial parsers by commenting out one or
more lines of valid code with <code>/* */</code> style. So let’s take a look at how we
could get the data we need using a real parser: Tree-sitter.</p>

<h2 id="parsing-and-querying-the-document">Parsing and Querying the Document</h2>

<p>Tree-sitter has numerous bindings that enable parsing programming languages and
data formats and protobuf is supported. There are also good Go bindings for
Tree-sitter that make it possible to interact with all of this in a
straightforward way from Go code. We’ll use the
<a href="https://github.com/smacker/go-tree-sitter">github.com/smacker/go-tree-sitter</a>
package and the <a href="https://github.com/smacker/go-tree-sitter/protobuf">associated <code>protobuf</code>
bindings</a>.</p>

<p>The library supports various methods of access to the parsed tree, but the one
we’ll use here is a query expression that will extract only the data we care
about.</p>

<p>We can use an <a href="https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax">S
expression</a>
to query the parsed tree. But, we need to understand what the parsed tree looks
like before we can query it. How do we visualize what is in the AST? One way
would be to use the <a href="https://tree-sitter.github.io/tree-sitter/playground">online
playground</a>, but that
lacks support for Protobuf. Because I was already working in Neovim, I decided
to use the excellent built-in visualization and query tools!</p>

<p>Inside Neovim you can run <code>:InspectTree</code> on any open document where the bindings
are included, and see a nice tree. Here is me running the inspector on the
source code for this blog post. (See if you can spot the code error)</p>

<p><a href="https://relistan.com/images/Tree-sitter-inspect.jpg" caption="" data-lightbox="">
  <img src="https://relistan.com/images/Tree-sitter-inspect.jpg" width="" alt=""/>
</a></p>

<p>In <code>:InspectTree</code>, if I highlight things in the document, I see them reflected
in the tree, and vice versa. This is invaluable for working with the queries,
since we can identify what each element in the AST actually is in the document,
live.</p>

<p>We can do the same thing for our Protobuf document. Then, it’s a matter of
constructing a query to find and extract the parts of the document we want:</p>

<ol>
  <li>Message Name</li>
  <li>Enum names, keys, and values</li>
  <li>Field names and types</li>
</ol>

<p>Writing a query using the Neovim tools is also nice, and straightforward. From
the <code>:InspectTree</code> panel, you can open the query editor by typing <code>:EditQuery</code>.
This brings up another pane where we can type queries and see them reflected in
the original document via highlighting and annotation.</p>

<p>This is what writing a query looks like in the Neovim query window:</p>

<p><a href="https://relistan.com/images/Tree-sitter-query.jpg" caption="" data-lightbox="">
  <img src="https://relistan.com/images/Tree-sitter-query.jpg" width="" alt=""/>
</a></p>

<p>When I put the cursor over the named capture <code>@name</code> in the query, it
highlights any matched parts of the document. There are many ways to write the
queries that we might use here. You essentially just walk through the tree in
the viewer and mark the things you’d like to return as named captures.</p>

<p>The simplest query, shown in the screenshot, is to simply extract the message name:</p>

<figure><pre><code data-lang="common_lisp"><span>(</span><span>message_name</span> <span>(</span><span>identifier</span><span>))</span> <span>@name</span></code></pre></figure>

<p>Here we found by inspecting the tree, that a <code>message_name</code> type is always
followed by an <code>identifier</code>. If we capture the <code>identifier</code> as <code>@name</code> we can
then refer to that capture when we want the message name. Then we can just
build it up from there.</p>

<p>Here you can see me traversing a query that I built, and how the editor
highlights the matches:</p>

<p><a href="https://relistan.com/images/Tree-sitter-Neovim.mov"><img src="https://relistan.com/images/Tree-sitter-Neovim.jpg" alt=""/></a></p>

<p>This is an example of a single query that will extract all of our required data
from the <code>protobuf</code> definition:</p>

<figure><pre><code data-lang="common_lisp"><span>(</span><span>message_name</span> <span>(</span><span>identifier</span><span>))</span> <span>@message_name</span>
<span>(</span><span>enum_name</span> <span>(</span><span>identifier</span><span>))</span> <span>@enum_name</span>
<span>(</span><span>enum_field</span>
	<span>(</span><span>identifier</span><span>)</span> <span>@enum_key</span>
	<span>(</span><span>int_lit</span> <span>(</span><span>_</span><span>)</span> <span>@enum_value</span><span>)</span>
<span>)</span>
<span>(</span><span>field</span> <span>(</span>
<span>(</span><span>type</span> <span>(</span><span>message_or_enum_type</span><span>))</span> <span>@field_type</span>
	<span>)</span>
	<span>(</span><span>identifier</span><span>)</span> <span>@field_name</span>
<span>)</span></code></pre></figure>

<p>Captures from the document will be returned by Tree-sitter in order. This is
very helpful. We can then walk the results to generate a structure more easily
reference in code. So let’s take a look at some Go code to interact with this
document using the query we built.</p>

<h2 id="working-with-tree-sitter-from-go">Working with Tree-Sitter from Go</h2>

<p>We need to import the two packages mentioned earlier. This is truncated for
clarity: you will need other simple stdlib import.</p>

<figure><pre><code data-lang="go"><span>import</span> <span>(</span>
	<span>sitter</span> <span>&#34;github.com/smacker/go-tree-sitter&#34;</span>   <span>// Tree-sitter bindings</span>
	<span>&#34;github.com/smacker/go-tree-sitter/protobuf&#34;</span> <span>// Protobuf definitions</span>
<span>)</span></code></pre></figure>

<p>We need some kind of data structure to store our parsed info in. The simplest
starting point is something like this:</p>

<figure><pre><code data-lang="go"><span>// A Message represents a single Protobuf message definition</span>
<span>type</span> <span>Message</span> <span>struct</span> <span>{</span>
	<span>Name</span>   <span>string</span>
	<span>Fields</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>string</span>
	<span>Enums</span>  <span>map</span><span>[</span><span>string</span><span>]</span><span>map</span><span>[</span><span>string</span><span>]</span><span>int</span>
<span>}</span></code></pre></figure>

<p>You could, of course, use a more structured type if that suits your purpose
better.</p>

<p>Then we need a function to read in the file and run it through the parser:</p>

<figure><pre><code data-lang="go"><span>// ParseMessage parses the message file and returns a Message struct</span>
<span>func</span> <span>ParseMessage</span><span>(</span><span>filename</span> <span>string</span><span>)</span> <span>(</span><span>*</span><span>Message</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
    <span>content</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>filename</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;failed to read file: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
    <span>}</span>

    <span>// Create a new parser</span>
    <span>parser</span> <span>:=</span> <span>sitter</span><span>.</span><span>NewParser</span><span>()</span>
    <span>parser</span><span>.</span><span>SetLanguage</span><span>(</span><span>protobuf</span><span>.</span><span>GetLanguage</span><span>())</span>

    <span>// Parse the content of the protobuf file</span>
    <span>tree</span><span>,</span> <span>err</span> <span>:=</span> <span>parser</span><span>.</span><span>ParseCtx</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(),</span> <span>nil</span><span>,</span> <span>content</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;failed to parse protobuf: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
    <span>}</span>

    <span>fields</span><span>,</span> <span>enums</span><span>,</span> <span>err</span> <span>:=</span> <span>GetMessageFields</span><span>(</span><span>tree</span><span>,</span> <span>content</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>err</span>
    <span>}</span>

    <span>msg</span> <span>:=</span> <span>&amp;</span><span>Message</span><span>{</span>
        <span>Name</span><span>:</span>   <span>name</span><span>,</span>
        <span>Fields</span><span>:</span> <span>fields</span><span>[</span><span>name</span><span>],</span>
        <span>Enums</span><span>:</span>  <span>enums</span><span>,</span>
    <span>}</span>

    <span>return</span> <span>msg</span><span>,</span> <span>nil</span>
<span>}</span></code></pre></figure>

<p>You will note in the above that the majority of the hard work is being done by
a function we have not seen yet: <code>GetMessageFields()</code>. That should look
something like this:</p>

<figure><pre><code data-lang="go"><span>// GetMessageFields runs the Treesitter query and returns the  two maps</span>
<span>func</span> <span>GetMessageFields</span><span>(</span><span>tree</span> <span>*</span><span>sitter</span><span>.</span><span>Tree</span><span>,</span> <span>content</span> <span>[]</span><span>byte</span><span>)</span> <span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>,</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>map</span><span>[</span><span>string</span><span>]</span><span>int</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
    <span>query</span> <span>:=</span> <span>`
        (message_name (identifier)) @message_name
        (enum_name (identifier)) @enum_name
        (enum_field
            (identifier) @enum_key
            (int_lit (_) @enum_value)
        )
        (field (
        (type (message_or_enum_type)) @field_type
            )
            (identifier) @field_name
        )
  `</span>

    <span>q</span><span>,</span> <span>qc</span><span>,</span> <span>err</span> <span>:=</span> <span>queryTree</span><span>(</span><span>tree</span><span>,</span> <span>query</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>err</span>
    <span>}</span>

    <span>fields</span> <span>:=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>)</span>
    <span>enumFields</span> <span>:=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>map</span><span>[</span><span>string</span><span>]</span><span>int</span><span>)</span>

    <span>var</span> <span>(</span>
        <span>fieldName</span><span>,</span> <span>fieldType</span><span>,</span> <span>messageName</span> <span>string</span>
        <span>enumName</span><span>,</span> <span>enumKey</span><span>,</span> <span>enumValue</span>      <span>string</span>
    <span>)</span>

    <span>// Iterate over the matches and print the field names and types</span>
    <span>for</span> <span>{</span>
        <span>match</span><span>,</span> <span>ok</span> <span>:=</span> <span>qc</span><span>.</span><span>NextMatch</span><span>()</span>
        <span>if</span> <span>!</span><span>ok</span> <span>{</span>
            <span>break</span>
        <span>}</span>

        <span>for</span> <span>_</span><span>,</span> <span>capture</span> <span>:=</span> <span>range</span> <span>match</span><span>.</span><span>Captures</span> <span>{</span>
            <span>node</span> <span>:=</span> <span>capture</span><span>.</span><span>Node</span>
            <span>captureName</span> <span>:=</span> <span>q</span><span>.</span><span>CaptureNameForId</span><span>(</span><span>capture</span><span>.</span><span>Index</span><span>)</span>
            <span>switch</span>  <span>captureName</span> <span>{</span>
            <span>case</span> <span>&#34;message_name&#34;</span><span>:</span>
                <span>messageName</span> <span>=</span> <span>node</span><span>.</span><span>Content</span><span>(</span><span>content</span><span>)</span>
                <span>fields</span><span>[</span><span>messageName</span><span>]</span> <span>=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>)</span>
            <span>case</span> <span>&#34;field_name&#34;</span><span>:</span>
                <span>fieldName</span> <span>=</span> <span>node</span><span>.</span><span>Content</span><span>(</span><span>content</span><span>)</span>
                <span>fields</span><span>[</span><span>messageName</span><span>][</span><span>fieldName</span><span>]</span> <span>=</span> <span>fieldType</span>
            <span>case</span> <span>&#34;field_type&#34;</span><span>:</span>
                <span>fieldType</span> <span>=</span> <span>node</span><span>.</span><span>Content</span><span>(</span><span>content</span><span>)</span>
            <span>case</span> <span>&#34;enum_name&#34;</span><span>:</span>
                <span>enumName</span> <span>=</span> <span>node</span><span>.</span><span>Content</span><span>(</span><span>content</span><span>)</span>
                <span>enumFields</span><span>[</span><span>enumName</span><span>]</span> <span>=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>int</span><span>)</span>
            <span>case</span> <span>&#34;enum_key&#34;</span><span>:</span>
                <span>enumKey</span> <span>=</span> <span>node</span><span>.</span><span>Content</span><span>(</span><span>content</span><span>)</span>
            <span>case</span> <span>&#34;enum_value&#34;</span><span>:</span>
                <span>enumValue</span> <span>=</span> <span>node</span><span>.</span><span>Content</span><span>(</span><span>content</span><span>)</span>
                <span>// Treesitter thinks zeroes are octal, let&#39;s work around it</span>
                <span>if</span> <span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>enumValue</span><span>,</span> <span>&#34;0x&#34;</span><span>)</span> <span>{</span>
                    <span>enumFields</span><span>[</span><span>enumName</span><span>][</span><span>enumKey</span><span>]</span> <span>=</span> <span>0</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>enumFields</span><span>[</span><span>enumName</span><span>][</span><span>enumKey</span><span>],</span> <span>err</span> <span>=</span> <span>strconv</span><span>.</span><span>Atoi</span><span>(</span><span>enumValue</span><span>)</span>
                    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
                        <span>return</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>err</span>
                    <span>}</span>
                <span>}</span>
      <span>default</span><span>:</span>
        <span>return</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;unexpected match type: %s&#34;</span><span>,</span> <span>captureName</span><span>)</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>fields</span><span>,</span> <span>enumFields</span><span>,</span> <span>nil</span>
<span>}</span></code></pre></figure>

<p>Here we define the query, ask Tree-sitter to kick off the query, and then we
loop over the matches, inspecting their name and then building up the maps.</p>

<p>The last piece of code to show is the <code>queryTree()</code> function that kicks off the
query and cursor. It looks like this:</p>

<figure><pre><code data-lang="go"><span>// queryTree runs a Treesitter query over a pre-existing tree</span>
<span>func</span> <span>queryTree</span><span>(</span><span>tree</span> <span>*</span><span>sitter</span><span>.</span><span>Tree</span><span>,</span> <span>query</span> <span>string</span><span>)</span> <span>(</span><span>*</span><span>sitter</span><span>.</span><span>Query</span><span>,</span> <span>*</span><span>sitter</span><span>.</span><span>QueryCursor</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
    <span>q</span><span>,</span> <span>err</span> <span>:=</span> <span>sitter</span><span>.</span><span>NewQuery</span><span>([]</span><span>byte</span><span>(</span><span>query</span><span>),</span> <span>protobuf</span><span>.</span><span>GetLanguage</span><span>())</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;failed to run query: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
    <span>}</span>

    <span>// Execute the query</span>
    <span>qc</span> <span>:=</span> <span>sitter</span><span>.</span><span>NewQueryCursor</span><span>()</span>
    <span>qc</span><span>.</span><span>Exec</span><span>(</span><span>q</span><span>,</span> <span>tree</span><span>.</span><span>RootNode</span><span>())</span>

    <span>return</span> <span>q</span><span>,</span> <span>qc</span><span>,</span> <span>nil</span>
<span>}</span></code></pre></figure>

<p>And that’s pretty much the meat of it. We can call <code>ParseMessage()</code> and we get back
a <code>Message{}</code> struct that is populated with our message name, fields, and enums. In
JSON representation, it would look something like this:</p>

<figure><pre><code data-lang="json"><span>{</span><span>
   </span><span>&#34;Enums&#34;</span><span>:</span><span> </span><span>{</span><span>
      </span><span>&#34;PostType&#34;</span><span>:</span><span> </span><span>{</span><span>
         </span><span>&#34;POST_TYPE_NOT_SET&#34;</span><span>:</span><span> </span><span>0</span><span>,</span><span>
         </span><span>&#34;POST_TYPE_ARTICLE&#34;</span><span>:</span><span> </span><span>1</span><span>,</span><span>
         </span><span>&#34;POST_TYPE_PAGE&#34;</span><span>:</span><span>    </span><span>2</span><span>,</span><span>
         </span><span>&#34;POST_TYPE_SPLASH&#34;</span><span>:</span><span>  </span><span>3</span><span>
      </span><span>}</span><span>
   </span><span>},</span><span>
   </span><span>&#34;Fields&#34;</span><span>:</span><span> </span><span>{</span><span>
      </span><span>&#34;post_id&#34;</span><span>:</span><span>   </span><span>&#34;google.protobuf.StringValue&#34;</span><span>,</span><span>
      </span><span>&#34;post_type&#34;</span><span>:</span><span> </span><span>&#34;PostType&#34;</span><span>,</span><span>
      </span><span>&#34;title&#34;</span><span>:</span><span>     </span><span>&#34;google.protobuf.StringValue&#34;</span><span>
      </span><span>&#34;body&#34;</span><span>:</span><span>      </span><span>&#34;google.protobuf.StringValue&#34;</span><span>,</span><span>
   </span><span>},</span><span>
   </span><span>&#34;Name&#34;</span><span>:</span><span> </span><span>&#34;BlogPost&#34;</span><span>
</span><span>}</span></code></pre></figure>

<p>And that’s it! It’s up to you what you do with this, but that gets you started.
If you need to parse sub-types, you could design a query to do that. If you
want to parse RPC definitions, you could do that, too. We use this information
to generate out our bindings (which includes some logic).</p>

<h2 id="conclusion">Conclusion</h2>

<p>This basis for tooling has been pretty good for us. I will undoubtedly bring
Tree-sitter and the Neovim tooling to bear on other problems in the future.
Hopefully this overview gets you a starting point.</p>


  </div>
</div>
      
    </div></div>
  </body>
</html>
