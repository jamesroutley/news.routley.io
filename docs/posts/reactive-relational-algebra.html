<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taylor.town/reactive-relational-algebra">Original</a>
    <h1>Reactive Relational Algebra</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Personally,
<a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> feels
more &#34;invented&#34; than &#34;discovered&#34;. Sometimes the whole thing smells like a
<a href="https://en.wikipedia.org/wiki/Kludge">kludge</a> that weasled its way into modern
CS curricula.</p>
<p>But hey, if you&#39;re rigorously thinking about databases/tables/spreadsheets, and
you need to build on the work of really really smart people, then relational
algebra starts looking like an attractive corner of math &amp; computing theory.</p>
<p>Anyway, so here I am, trying to build
<a href="https://taylor.town/better-spreadsheets">&#34;better spreadsheets&#34;</a>, and I&#39;m playing with &#34;derived&#34;
tables that feel like
<a href="https://en.wikipedia.org/wiki/View_(SQL)">database views</a>:</p>
<pre><code>A[t+1] = B[t] ∪ C[t]</code></pre>

<p>The whole reason I added the
<a href="https://tardis.fandom.com/wiki/Wibbly_wobbly,_timey_wimey">wibbly wobbly timey wimey</a>
stuff is that my spreadsheet program works with async data (e.g. HTTP requests,
SQL queries).</p>

<p>I really wanted to model concurrent async database operations like this:</p>
<pre><code>A[t+n+1] = B[t] ∪ C[t+n]</code></pre>

<p>This notation was surprisingly helpful for thinking through some hairy
concurrency stuff!</p>
<p>But anyway, when I started building actual async spreadsheets, I found myself
making lots of intermediate tables to emulate &#34;memory&#34;. At some point, I
realized it was easiest to &#34;merge&#34; tables using self-reference:</p>
<pre><code>A[t+1] = A[t] ∪ B[t]</code></pre>
<p>For example:</p>
<table>
<thead>
<tr>
<th id="t">t</th>
<th id="a">A</th>
<th id="b">B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[]</td>
<td>[{a},{b}]</td>
</tr>
<tr>
<td>1</td>
<td>[{a},{b}]</td>
<td>[{a}}]</td>
</tr>
<tr>
<td>2</td>
<td>[{a},{b}]</td>
<td>[]</td>
</tr>
<tr>
<td>3</td>
<td>[{a},{b}]</td>
<td>[{c}]</td>
</tr>
<tr>
<td>4</td>
<td>[{a},{b},{c}]</td>
<td>[{c}]</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Hey, this feels pretty good!</p>
<p>Intuitively, you can guess that self-unioning sets can only gain rows; likewise,
self-intersecting sets only lose rows. Intuitively, you can also guess that the
behavior of all other operators are trivial exercises in some category theory
theorem that bounced off the surface of my smooth brain.</p>
<p>With all of relational algebra (and its extensions) at your disposal, you can
express some pretty cool stuff:</p>
<pre><code>A[t+1] = φ{i&gt;=max(i)-5}(A[t] ∪ B[t] ⨝ C[t])</code></pre>

<p>My latest equivalent <a href="https://scrapscript.org">scrapscript</a> notation looks
something like this:</p>
<pre><code>a1 . a1 = a0 |&gt; sheet/union (sheet/join b0 c0) |&gt; sheet/limit 5</code></pre>
<p>This query DSL feels very natural in my experimental scrapsheet demos! I&#39;m
excited to see whether the paradigm handles more complexity.</p>
<p>Anyway, this is where my reactive relational algebra ends for now (and probably
forever). Feel free to email me at <a href="https://taylor.town/cdn-cgi/l/email-protection#bbd3ded7d7d4fbcfdac2d7d4c995cfd4ccd5"><span data-cfemail="274f424b4b486753465e4b48550953485049">[email protected]</span></a>
if you have any ideas on where to go next.</p>
<p>See you in the next timestep!</p></div></div>
  </body>
</html>
