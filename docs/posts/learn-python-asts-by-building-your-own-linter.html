<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sadh.life/post/ast/">Original</a>
    <h1>Learn Python ASTs, by building your own linter</h1>
    
    <div id="readability-page-1" class="page"><article>
    <main>
      <blockquote>
<p>Hi! Before we start, a word of caution: This is an extremely long article, and it might take multiple hours to finish completely. But I promise it&#39;ll be worth it.</p>
<p>Oh, and follow me on <a href="https://twitter.com/sadhlife">twitter</a>, I frequently post Python content there as well.</p>
</blockquote><h3 id="index">Index</h3><ul>
<li><a href="#so-what-is-an-ast">So what is an AST?</a></li>
<li><a href="#pythons-ast-module">Python&#39;s <code data-astro-raw="">ast</code> module</a>
<ul>
<li><a href="#all-the-nodes">All the <code data-astro-raw="">Node</code>s</a></li>
<li><a href="#expressions-vs-statements">Expressions vs. Statements</a></li>
<li><a href="#whats-a-ctx">What&#39;s a <code data-astro-raw="">ctx</code>?</a></li>
</ul>
</li>
<li><a href="#walking-the-syntax-trees-with-visitors">Walking the Syntax Trees with Visitors</a></li>
<li><a href="#the-power-of-ast-manipulation">The power of AST manipulation</a></li>
<li><a href="#lets-build-a-simple-linter">Let&#39;s build: A simple linter</a></li>
<li><a href="#ast-utilities">AST utilities</a></li>
<li><a href="#what-about-code-formatters">What about code formatters?</a></li>
<li><a href="#where-can-i-learn-more">Where can I learn more?</a></li>
</ul><h2 id="so-what-is-an-ast">So what is an AST?</h2><p>In programmer terms, &#34;ASTs are a programmatic way to understand the structure of your source code&#34;. But to understand what that really means, we must first understand a few things about the structure of a computer program.</p><p>The programs that you and I write in our language of choice is usually called the &#34;source code&#34;, and I&#39;ll be referring to it as such in this article.</p><p>On the other end, computer chips can only understand &#34;machine code&#34;, which is a set of binary numbers that have special meanings for that model of the chip. Some of these numbers are <em>instructions</em>, which tell the CPU a simple task to perform, like &#34;add the numbers stored in these two places&#34;, or &#34;jump 10 numbers down and continue running code from there&#34;. The instructions run one by one, and they dictate the flow of the program.</p><p>Similarly, you define your programs as a set of &#34;statements&#34;, with each statement being one thing that you want your code to do. They&#39;re sort of a more human-friendly version of the CPU instructions, that we can write and reason with more easily.</p><p>Now, I know that theory can get boring really quick, so I&#39;m going to go through a bunch of examples. Let&#39;s write the same piece of code in many languages, and notice the similarities:</p><ul>
<li>
<p>Python</p>
<pre><code data-astro-raw=""><span>def</span> <span>area_of_circle</span><span>(</span>radius<span>)</span><span>:</span>
    pi <span>=</span> <span>3.14</span>
    <span>return</span> pi <span>*</span> radius <span>*</span> radius

area_of_circle<span>(</span><span>5</span><span>)</span>
</code></pre>
</li>
<li>
<p>Scheme Lisp</p>
<pre><code data-astro-raw=""><span>(</span><span>define</span> <span>(</span><span>area_of_circle</span> radius<span>)</span>
  <span>(</span><span>define</span> pi <span>3.14</span><span>)</span>
  <span>(</span><span>*</span> pi radius radius<span>)</span><span>)</span>

<span>(</span><span>area_of_circle</span> <span>5</span><span>)</span>
</code></pre>
</li>
<li>
<p>Go</p>
<pre><code data-astro-raw=""><span>package</span> main

<span>func</span> <span>area_of_circle</span><span>(</span>radius <span>float64</span><span>)</span> <span>float64</span> <span>{</span>
  pi <span>:=</span> <span>3.14</span>
  <span>return</span> pi <span>*</span> radius <span>*</span> radius
<span>}</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>println</span><span>(</span><span>area_of_circle</span><span>(</span><span>5</span><span>)</span><span>)</span>
<span>}</span>
</code></pre>
</li>
</ul><p>We&#39;re doing essentially the same thing in all of these, and I&#39;ll break it down piece by piece:</p><ul>
<li>
<p>We&#39;re defining our source code as a block of statements. In our case, there are two statements at the top-level of our source code: one statement that defines our <code data-astro-raw="">area_of_circle</code> function, and another statement that runs this function with the value &#34;5&#34;.</p>
</li>
<li>
<p>The definition of the <code data-astro-raw="">area_of_circle</code> function has two parts: the input parameters (the radius, in our case), and the body, which itself is a block of statements. There&#39;s two statements inside <code data-astro-raw="">area_of_circle</code> to be specific: the first one defines <code data-astro-raw="">pi</code>, and the second one uses it to calculate the area, and returns it.</p>
</li>
<li>
<p>For the languages that have a main function, the definition of the main function itself is a statement. Inside that statement we are writing <em>more statements</em>, like one that prints out the value of <code data-astro-raw="">area_of_circle</code> called with the radius of 5.</p>
</li>
</ul><p>You can start to see the somewhat repetitive nature of source code. There&#39;s blocks of statements, and sometimes within those statements there can be more statements, and so on. If you imagine each statement to be a &#34;node&#34;, then you can think of each of these nodes being composed of one or more other &#34;nodes&#34;. You can properly define this kind of structure as a &#34;tree&#34;:</p><pre><code data-astro-raw="">                 (program)
                /         \
  (area_of_circle r)      (main)
  /           |             |
define    calculate        run area_of_circle
  pi        area             with r = 5
           /   |
     multiply  (pi, r, r)</code></pre><p>The nodes here can be anything, from statements, to expressions, to any other construct that the language defines. Once the code is in this tree structure, computers can start to make sense of it, such as traversing its nodes one by one and generate the appropriate machine code.</p><p>Essentially, all your code represents a tree of data. And that tree is called the <strong>Abstract Syntax Tree</strong>. Each programming language has its own AST representation, but the idea is always the same.</p><p>To be able to create tools that do things like auto-format your code, or find subtle bugs automatically, you need ASTs to be able to meaningfully read through the code, find items or patterns inside the code, and act on them.</p><h2 id="pythons-ast-module">Python&#39;s <code data-astro-raw="">ast</code> module</h2><p>Python has a builtin <code data-astro-raw="">ast</code> module, which has a rich set of features to create, modify and run ASTs from Python code. Not all languages provide easy access to their syntax trees, so Python is already pretty good in that regard. Let&#39;s take a look at what all the <code data-astro-raw="">ast</code> module gives us, and try to do something interesting with it:</p><h3 id="all-the-nodes">All the <code data-astro-raw="">Node</code>s</h3><p>There are lots of kinds of &#34;Nodes&#34; in a Python AST each with their own functionalities, but you can broadly divide them into four categories: <strong>Literals</strong>, <strong>Variables</strong>, <strong>Statements</strong> and <strong>Expressions</strong>. We&#39;ll take a look at them one by one, but before we do that we need to understand how a &#34;Node&#34; is represented.</p><p>The role of a node is to concretely represent the features of a language.</p><p>It does so by:</p><ul>
<li>Storing the attributes specific to itself, (for example, an <code data-astro-raw="">If</code> node that represents an if-statement might need a <code data-astro-raw="">condition</code> attribute, which is an expression that evaluates to <code data-astro-raw="">true</code> or <code data-astro-raw="">false</code>. The if statement&#39;s body will only run when <code data-astro-raw="">condition</code> ends up being <code data-astro-raw="">true</code>.</li>
<li>Defining what children the node can have. (In our <code data-astro-raw="">If</code> node&#39;s case, it should have a <code data-astro-raw="">body</code>, that is a list of statements.)</li>
</ul><blockquote>
<p>In Python&#39;s case, the AST nodes also hold their exact location in the source code. You can find out from where in the Python file a node came from, by checking the <code data-astro-raw="">lineno</code> and <code data-astro-raw="">col_offset</code> parameters.</p>
</blockquote><p>Let&#39;s see the concrete example of this if statement, in Python&#39;s AST representation.</p><p>For this source code:</p><pre><code data-astro-raw=""><span>if</span> answer <span>==</span> <span>42</span><span>:</span>
    <span>print</span><span>(</span><span>&#39;Correct answer!&#39;</span><span>)</span></code></pre><p>The AST looks like this:</p><pre><code data-astro-raw="">Module<span>(</span>
  body<span>=</span><span>[</span>
    If<span>(</span>
      test<span>=</span>Compare<span>(</span>
        left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;answer&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        ops<span>=</span><span>[</span>Eq<span>(</span><span>)</span><span>]</span><span>,</span>
        comparators<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>42</span><span>)</span><span>]</span>
      <span>)</span><span>,</span>
      body<span>=</span><span>[</span>
        Expr<span>(</span>
          value<span>=</span>Call<span>(</span>
            func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
            args<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>&#39;Correct answer!&#39;</span><span>)</span><span>]</span><span>,</span>
            keywords<span>=</span><span>[</span><span>]</span>
          <span>)</span>
        <span>)</span>
      <span>]</span><span>,</span>
      orelse<span>=</span><span>[</span><span>]</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre><p>Let&#39;s break this down:</p><p>Ignoring the details for now, the overall structure of the AST looks like this:</p><pre><code data-astro-raw="">Module<span>(</span>
  body<span>=</span><span>[</span>
    If<span>(</span>
      test<span>=</span>Compare<span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>,</span>
      body<span>=</span><span>[</span>
        <span>.</span><span>.</span><span>.</span>
      <span>]</span><span>,</span>
    <span>)</span>
  <span>]</span><span>,</span>
<span>)</span></code></pre><p>At the top level, is a <code data-astro-raw="">Module</code>. All Python files are compiled as &#34;modules&#34; when making the AST. Modules have a very specific meaning: anything that can be run by Python classifies as a module. So by definition, our Python file is a module.</p><p>It has a body, which is a list. Specifically, a list of <strong>statements</strong>. All Python files are just that: a list of statements. Every Python program that you&#39;ve ever written, read or run -- just that.</p><p>In our case, we have just one statement in the module&#39;s body: an <code data-astro-raw="">If</code>-statement. The if-statement has two components: a <code data-astro-raw="">test</code>, and a <code data-astro-raw="">body</code>. The <code data-astro-raw="">test</code> part holds the <em>condition expression</em>, and the <code data-astro-raw="">body</code> holds the block of statements that&#39;s inside the if.</p><p>Let&#39;s look at the <code data-astro-raw="">test</code> &#34;expression&#34; first:</p><pre><code data-astro-raw="">If<span>(</span>
  test<span>=</span>Compare<span>(</span>
    left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;answer&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
    ops<span>=</span><span>[</span>Eq<span>(</span><span>)</span><span>]</span><span>,</span>
    comparators<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>42</span><span>)</span><span>]</span>
  <span>)</span><span>,</span>
  <span>.</span><span>.</span><span>.</span></code></pre><p>In our case, we have a <code data-astro-raw="">Compare</code> expression -- which makes sense. Python defines comparisons <a href="https://docs.python.org/3/reference/expressions.html#comparisons">quite thoroughly</a> in its reference, and if you read it, you&#39;ll find that Python supports <em>comparison chaining</em>.</p><p>From the docs:</p><blockquote>
<p>Python&#39;s comparison expressions support this syntax:</p>
<p><code data-astro-raw="">a op1 b op2 c ...</code></p>
<p>Which is equivalent to:</p>
<p><code data-astro-raw="">a op1 b and b op2 c and ...</code></p>
</blockquote><p>In human terms, this means that Python can support stuff like this:</p><pre><code data-astro-raw="">x <span>=</span> get_number<span>(</span><span>)</span>
<span>if</span> <span>0</span> <span>&lt;</span> x <span>&lt;</span> <span>10</span><span>:</span>
    <span>print</span><span>(</span><span>&#39;Your number is a single digit!&#39;</span><span>)</span></code></pre><p>And <code data-astro-raw="">0 &lt; x &lt; 10</code> is the same as asking <code data-astro-raw="">0 &lt; x and x &lt; 10</code>.</p><p>Here&#39;s the important part: for Python to support this, the <em>AST needs to support this</em>. And Python&#39;s AST supports comparison chaining by storing the operators and the comparators (variables) inside <strong>lists</strong>. You can look at it in the REPL itself:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> <span>def</span> <span>get_ast</span><span>(</span>code<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>ast<span>.</span>dump<span>(</span>ast<span>.</span>parse<span>(</span>code<span>)</span><span>,</span> indent<span>=</span><span>2</span><span>)</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;a &lt; b &gt; c &gt; d&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>Compare<span>(</span>
        left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;a&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        ops<span>=</span><span>[</span>Lt<span>(</span><span>)</span><span>,</span> Gt<span>(</span><span>)</span><span>,</span> Gt<span>(</span><span>)</span><span>]</span><span>,</span>
        comparators<span>=</span><span>[</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;b&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;c&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;d&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
        <span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre><blockquote>
<p>If you actually run this code, you might notice that the output here has different whitespace compared to what I have in my blog. It&#39;s just personal preference, if you find an output similar to mine more readable you can install <code data-astro-raw="">astpretty</code> from pip, and use:</p>
<pre><code data-astro-raw=""><span>def</span> <span>get_ast</span><span>(</span>code<span>)</span><span>:</span>
    astpretty<span>.</span>pprint<span>(</span>ast<span>.</span>parse<span>(</span>code<span>)</span><span>,</span> show_offsets<span>=</span><span>False</span><span>,</span> indent<span>=</span><span>2</span><span>)</span></code></pre>
</blockquote><p>You can see that the operators <code data-astro-raw="">&lt;</code>, <code data-astro-raw="">&gt;</code> and <code data-astro-raw="">&gt;</code> are stored as <code data-astro-raw="">ops=[Lt(), Gt(), Gt()]</code> inside the <code data-astro-raw="">Compare</code> object. The four values are stored a bit more peculiarly: The variable <code data-astro-raw="">a</code> is stored in a separate field called <code data-astro-raw="">left</code>, and then every other variable is stored in a list called <code data-astro-raw="">comparators</code>:</p><pre><code data-astro-raw="">comparators<span>=</span><span>[</span>
  Name<span>(</span><span>id</span><span>=</span><span>&#39;b&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  Name<span>(</span><span>id</span><span>=</span><span>&#39;c&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  Name<span>(</span><span>id</span><span>=</span><span>&#39;d&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
<span>]</span><span>,</span>
<span>.</span><span>.</span><span>.</span></code></pre><p>In other words: the leftmost variable is stored in <code data-astro-raw="">left</code>, and every variable on the right of each operator is stored in the respective index of <code data-astro-raw="">comparators</code>.</p><p>Hopefully that clarifies what the <code data-astro-raw="">test</code> expression means in our example code:</p><pre><code data-astro-raw="">If<span>(</span>
  test<span>=</span>Compare<span>(</span>
    left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;answer&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
    ops<span>=</span><span>[</span>Eq<span>(</span><span>)</span><span>]</span><span>,</span>
    comparators<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>42</span><span>)</span><span>]</span>
  <span>)</span><span>,</span>
  <span>.</span><span>.</span><span>.</span></code></pre><p><code data-astro-raw="">left</code> is the <code data-astro-raw="">Name</code> node &#39;answer&#39; (basically, a variable), and we have just one comparison going on: <code data-astro-raw="">Eq</code> being applied on the constant value <code data-astro-raw="">42</code>. Essentially it is the <code data-astro-raw="">answer == 42</code> part of the code.</p><p>Now let&#39;s look at the body:</p><pre><code data-astro-raw="">    If<span>(</span>
      test<span>=</span><span>.</span><span>.</span><span>.</span><span>,</span>
      body<span>=</span><span>[</span>
        Expr<span>(</span>
          value<span>=</span>Call<span>(</span>
            func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
            args<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>&#39;Correct answer!&#39;</span><span>)</span><span>]</span><span>,</span>
            keywords<span>=</span><span>[</span><span>]</span>
          <span>)</span>
        <span>)</span>
      <span>]</span><span>,</span>
      orelse<span>=</span><span>[</span><span>]</span>
    <span>)</span></code></pre><p>The body in our case is a single <code data-astro-raw="">Expr</code>ession. Note that, when I said that a block or module always contains a list of statements, I wasn&#39;t lying. This <code data-astro-raw="">Expr</code> right here is actually an <strong>expression-statement</strong>. Yeah, I&#39;m not making this up, it will make sense in a bit.</p><h3 id="expressions-vs-statements">Expressions vs. Statements</h3><p>Statements are pretty easy to define. They&#39;re kind of like the building blocks of your code. Each statement does something that you can properly define. Such as:</p><ul>
<li>
<p>Creating a variable</p>
<pre><code data-astro-raw="">x <span>=</span> <span>5</span></code></pre>
<p>This one becomes an <code data-astro-raw="">Assign</code> statement:</p>
<pre><code data-astro-raw="">Assign<span>(</span>
  targets<span>=</span><span>[</span>
    Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
  <span>]</span><span>,</span>
  value<span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span>
<span>)</span></code></pre>
<p>Pretty straightforward, the node stores a target and a value. <code data-astro-raw="">targets</code> here is a list because you can also do multiple assignments: <code data-astro-raw="">a = b = 5</code>. There will only be one value, though.</p>
</li>
<li>
<p>Importing a module</p>
<pre><code data-astro-raw=""><span>import</span> random</code></pre>
<p>This one becomes an <code data-astro-raw="">Import</code> statement:</p>
<pre><code data-astro-raw="">Import<span>(</span>
  names<span>=</span><span>[</span>
    alias<span>(</span>name<span>=</span><span>&#39;random&#39;</span><span>)</span>
  <span>]</span>
<span>)</span></code></pre>
</li>
<li>
<p>Asserting some property</p>
<pre><code data-astro-raw=""><span>assert</span> <span>False</span></code></pre>
<p>Becomes:</p>
<pre><code data-astro-raw="">Assert<span>(</span>
  test<span>=</span>Constant<span>(</span>value<span>=</span><span>False</span><span>)</span>
<span>)</span></code></pre>
</li>
<li>
<p>Doing absolutely nothing</p>
<pre><code data-astro-raw=""><span>pass</span></code></pre>
<p>Becomes:</p>
<pre><code data-astro-raw="">Pass<span>(</span><span>)</span></code></pre>
</li>
</ul><p>On the other hand, an expression is basically anything that evaluates to a value. Any piece of syntax that ends up turning into a &#34;value&#34;, such as a number, a string, an object, even a class or function. As long as it returns a value to us, it is an expression.</p><p>This includes:</p><ul>
<li>
<p>Identity checks</p>
<p>This refers to the <code data-astro-raw="">is</code> expression:</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> a <span>=</span> <span>5</span>
<span>&gt;&gt;</span><span>&gt;</span> b <span>=</span> a
<span>&gt;&gt;</span><span>&gt;</span> b
<span>5</span>
<span>&gt;&gt;</span><span>&gt;</span> a <span>is</span> b
<span>True</span></code></pre>
<p>Clearly, <code data-astro-raw="">a is b</code> returns either <code data-astro-raw="">True</code> or <code data-astro-raw="">False</code>, just like any other conditional check. And since it returns a value, it is an expression.</p>
<p>Here&#39;s its AST:</p>
<pre><code data-astro-raw="">Compare<span>(</span>
  left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;a&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  ops<span>=</span><span>[</span>Is<span>(</span><span>)</span><span>]</span><span>,</span>
  comparators<span>=</span><span>[</span>
    Name<span>(</span><span>id</span><span>=</span><span>&#39;b&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
  <span>]</span>
<span>)</span></code></pre>
<p>And it really is just like conditionals. Turns out <code data-astro-raw="">is</code> is treated just as a special operator (like <code data-astro-raw="">&lt;</code>, <code data-astro-raw="">==</code> and so on) inside a <code data-astro-raw="">Compare</code> object when talking about ASTs.</p>
</li>
<li>
<p>Function calls</p>
<p>Function calls return a value. That makes them the most obvious example of an expression:</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>from</span> os <span>import</span> getpid
<span>&gt;&gt;</span><span>&gt;</span> getpid<span>(</span><span>)</span>
<span>15206</span></code></pre>
<p>Here&#39;s what the AST for <code data-astro-raw="">getpid()</code> looks like, it&#39;se essrntially just a <code data-astro-raw="">Call</code>:</p>
<pre><code data-astro-raw="">Call<span>(</span>
  func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;getpid&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  args<span>=</span><span>[</span><span>]</span><span>,</span>
  keywords<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre>
<p><code data-astro-raw="">print(&#39;Hello&#39;)</code> would look like this, it has one argument:</p>
<pre><code data-astro-raw="">Call<span>(</span>
  func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  args<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>&#39;hello&#39;</span><span>)</span><span>]</span><span>,</span>
  keywords<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre>
</li>
<li>
<p>Lambdas</p>
<p>Lambdas themselves are expressions. When you create a lambda function, you usually pass it directly as an argument to another function, or assign it to a variable. Here&#39;s some examples:</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>lambda</span><span>:</span> <span>5</span>
<span>&lt;</span>function <span>&lt;</span><span>lambda</span><span>&gt;</span> at <span>0x7f684169cb80</span><span>&gt;</span>
<span>&gt;&gt;</span><span>&gt;</span> returns_five <span>=</span> <span>lambda</span><span>:</span> <span>5</span>
<span>&gt;&gt;</span><span>&gt;</span> returns_five<span>(</span><span>)</span>
<span>5</span>
<span>&gt;&gt;</span><span>&gt;</span> is_even <span>=</span> <span>lambda</span> num<span>:</span> num <span>%</span> <span>2</span> <span>==</span> <span>0</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>list</span><span>(</span><span>filter</span><span>(</span>is_even<span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>)</span><span>)</span>
<span>[</span><span>2</span><span>,</span> <span>4</span><span>]</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>list</span><span>(</span><span>filter</span><span>(</span><span>lambda</span> num<span>:</span> num <span>%</span> <span>2</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>)</span><span>)</span>
<span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span></code></pre>
<p>And there&#39;s the <code data-astro-raw="">Lambda</code> expression for <code data-astro-raw="">lambda: 5</code> in the AST:</p>
<pre><code data-astro-raw="">Lambda<span>(</span>
  args<span>=</span>arguments<span>(</span>
    posonlyargs<span>=</span><span>[</span><span>]</span><span>,</span>
    args<span>=</span><span>[</span><span>]</span><span>,</span>
    kwonlyargs<span>=</span><span>[</span><span>]</span><span>,</span>
    kw_defaults<span>=</span><span>[</span><span>]</span><span>,</span>
    defaults<span>=</span><span>[</span><span>]</span>
  <span>)</span><span>,</span>
  body<span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span>
<span>)</span></code></pre>
</li>
</ul><p>Now, if you think about it, a call to <code data-astro-raw="">print()</code> in a regular code, it&#39;s technically a statement, right?</p><pre><code data-astro-raw=""><span>def</span> <span>greet</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>&#39;Hello world!&#39;</span><span>)</span></code></pre><p>As I&#39;ve said before, blocks of code are essentially just a list of statements. And we also know, that calling <code data-astro-raw="">print</code> is technically an expression (it even returns <code data-astro-raw="">None</code>!). So what&#39;s going on here?</p><p>The answer is simple: Python lets you treat any expression as a standalone statement. The expression is going to return some value, but that value just gets discarded.</p><p>Getting back to our original AST:</p><pre><code data-astro-raw="">    If<span>(</span>
      test<span>=</span><span>.</span><span>.</span><span>.</span><span>,</span>
      body<span>=</span><span>[</span>
        Expr<span>(</span>
          value<span>=</span>Call<span>(</span>
            func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
            args<span>=</span><span>[</span>Constant<span>(</span>value<span>=</span><span>&#39;Correct answer!&#39;</span><span>)</span><span>]</span><span>,</span>
            keywords<span>=</span><span>[</span><span>]</span>
          <span>)</span>
        <span>)</span>
      <span>]</span><span>,</span>
      orelse<span>=</span><span>[</span><span>]</span>
    <span>)</span></code></pre><p>We have an <code data-astro-raw="">Expr</code> in our body, which is Python&#39;s way of saying &#34;This is an expression that&#39;s being used as a statement&#34;. The actual expression is inside it, a <code data-astro-raw="">Call</code> to <code data-astro-raw="">print</code>.</p><p>The last thing left in this example AST is the last line: <code data-astro-raw="">orelse=[]</code>. <code data-astro-raw="">orelse</code> refers to <code data-astro-raw="">else:</code> blocks anywhere in the AST. The name <code data-astro-raw="">orelse</code> was chosen because <code data-astro-raw="">else</code> itself is a keyword and can&#39;t be used as an attribute name.</p><p>Oh, did you know that <code data-astro-raw="">for</code> loops in Python can have an else clause?</p><details>
<summary> Extras: The for-else clause </summary>
<p><code data-astro-raw="">for</code>-<code data-astro-raw="">else</code> is really interesting. The <code data-astro-raw="">else</code> in for loops is run whenever the loop runs to its entirety. In other words, it is <em>not</em> run, when you break out of the loop before it finishes.</p>
<p>It&#39;s useful for many use-cases, one of them being searching through a list:</p>
<pre><code data-astro-raw="">items <span>=</span> <span>[</span><span>&#39;Bag&#39;</span><span>,</span> <span>&#39;Purse&#39;</span><span>,</span> <span>&#39;Phone&#39;</span><span>,</span> <span>&#39;Wallet&#39;</span><span>]</span>

<span>for</span> item <span>in</span> items<span>:</span>
    <span>if</span> item <span>==</span> <span>&#39;Phone&#39;</span><span>:</span>
        <span>print</span><span>(</span><span>&#39;Phone was found in items!&#39;</span><span>)</span>
        <span>break</span>

<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#39;Phone was not found in items :(&#39;</span><span>)</span></code></pre>
<p>If we had an <code data-astro-raw="">else</code>-clause on our for loop, like:</p>
<pre><code data-astro-raw=""><span>for</span> item <span>in</span> items<span>:</span>
    <span>print</span><span>(</span>item<span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#39;All done&#39;</span><span>)</span></code></pre>
<p>The AST would look more interesting:</p>
<pre><code data-astro-raw="">For<span>(</span>
  target<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;item&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span><span>,</span>
  <span>iter</span><span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;items&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  body<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;item&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>]</span><span>,</span>
        keywords<span>=</span><span>[</span><span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  orelse<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Constant<span>(</span>value<span>=</span><span>&#39;All done&#39;</span><span>)</span>
        <span>]</span><span>,</span>
        keywords<span>=</span><span>[</span><span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span>
<span>)</span></code></pre>
<p>Pretty straightforward. Also, <code data-astro-raw="">If</code> statements have the exact same <code data-astro-raw="">orelse</code> property as for loops when it comes to ASTs.</p>
</details><p>If you want a detailed reference of all the Nodes that we have in a Python AST, and the corresponding syntax it belongs to, you can either head on to the <a href="https://docs.python.org/3/library/ast.html#node-classes">docs here</a>, or just use <code data-astro-raw="">ast.dump</code> on a line of code to try and find out for yourself.</p><h3 id="whats-a-ctx">What&#39;s a <code data-astro-raw="">ctx</code>?</h3><p>Ideally, I want you to leave this article understanding every single aspect of Python&#39;s ASTs. And if you&#39;re one of the few super observant readers, you might have noticed that we glanced over a very small thing in the AST examples shown. You can see it in this code snippet:</p><pre><code data-astro-raw="">Compare<span>(</span>
  left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;a&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
  ops<span>=</span><span>[</span>Eq<span>(</span><span>)</span><span>]</span><span>,</span>
  comparators<span>=</span><span>[</span>
    Name<span>(</span><span>id</span><span>=</span><span>&#39;b&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
  <span>]</span>
<span>)</span></code></pre><p>We&#39;ve talked about <code data-astro-raw="">Compare</code>, we&#39;ve talked about what the <code data-astro-raw="">left</code>, <code data-astro-raw="">ops</code> and <code data-astro-raw="">comparators</code> fields represent, we&#39;ve also talked about <code data-astro-raw="">Name</code> nodes. The only thing left is <code data-astro-raw="">ctx=Load()</code>. What exactly does that mean?</p><p>If you check all the code snippets we&#39;ve seen so far, we&#39;ve actually seen 27 instances of <code data-astro-raw="">Name</code> nodes in the examples. Out of the 27, 25 have had the property <code data-astro-raw="">ctx=Load()</code>, but two of them have a different value: <code data-astro-raw="">ctx=Store()</code>. Like this one:</p><pre><code data-astro-raw="">Assign<span>(</span>
  targets<span>=</span><span>[</span>
    Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
  <span>]</span><span>,</span>
  value<span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span>
<span>)</span></code></pre><p><code data-astro-raw="">ctx</code> (short for &#34;context&#34;) is an essential concept of Python (and many other programming languages), and it is related to the whole concept of &#34;variables&#34;.</p><p>If I were to ask you &#34;what&#39;s a variable?&#34; You might say something like &#34;It can store values which you can use later.&#34;, and give some example like:</p><pre><code data-astro-raw="">age <span>=</span> <span>21</span>    
<span>print</span><span>(</span>age<span>)</span>  </code></pre><p>And that&#39;s exactly what it is. If you look at the AST for this code:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>def</span> <span>get_ast</span><span>(</span>code<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>      <span>print</span><span>(</span>ast<span>.</span>dump<span>(</span>ast<span>.</span>parse<span>(</span>code<span>)</span><span>,</span> indent<span>=</span><span>2</span><span>)</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;&#39;&#39;
... age = 21
... print(age)
... &#39;&#39;&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Assign<span>(</span>
      targets<span>=</span><span>[</span>
        Name<span>(</span><span>id</span><span>=</span><span>&#39;age&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
      <span>]</span><span>,</span>
      value<span>=</span>Constant<span>(</span>value<span>=</span><span>21</span><span>)</span><span>)</span><span>,</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;age&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
        <span>]</span><span>,</span>
        keywords<span>=</span><span>[</span><span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span></code></pre><p>So the first statement is an <code data-astro-raw="">Assign</code>, and the variable <code data-astro-raw="">age</code> is in the &#34;Store&#34; context (because a new value is being stored into it), and in the second statement it is in &#34;Load&#34; context. Interestingly, <code data-astro-raw="">print</code> itself is a variable that&#39;s being loaded in this statement. Which makes sense, print is essentially a function somewhere in memory, which is accessible by us using the name <code data-astro-raw="">print</code>.</p><p>Let&#39;s look at a couple more. What about this?</p><pre><code data-astro-raw="">age <span>=</span> age <span>+</span> <span>1</span></code></pre><p>The AST looks like this:</p><pre><code data-astro-raw="">Assign<span>(</span>
  targets<span>=</span><span>[</span>
    Name<span>(</span><span>id</span><span>=</span><span>&#39;age&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
  <span>]</span><span>,</span>
  value<span>=</span>BinOp<span>(</span>
    left<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;age&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
    op<span>=</span>Add<span>(</span><span>)</span><span>,</span>
    right<span>=</span>Constant<span>(</span>value<span>=</span><span>1</span><span>)</span>
  <span>)</span>
<span>)</span></code></pre><p>The <code data-astro-raw="">age</code> on the right is in &#34;Load&#34; mode and the one on the left is in &#34;Store&#34; mode. That&#39;s why this line of code makes sense: we are Loading the old value, adding 1 to it, and then Storing it.</p><p>This should probably help in explaining how this kind of self-assigning code <em>really works</em> to a newbie programmer in the future.</p><p>One more interesting example is this:</p><pre><code data-astro-raw="">x<span>[</span><span>5</span><span>]</span> <span>=</span> y</code></pre><p>The AST looks like this:</p><pre><code data-astro-raw="">Assign<span>(</span>
  targets<span>=</span><span>[</span>
    Subscript<span>(</span>
      value<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
      <span>slice</span><span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span><span>,</span>
      ctx<span>=</span>Store<span>(</span><span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  value<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;y&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
<span>)</span></code></pre><p>Here, <code data-astro-raw="">x</code> is actually in &#34;Load&#34; mode even though it&#39;s on the left side of the assignment. And if you think about it, it makes sense. We need to load <code data-astro-raw="">x</code>, and then modify one of its indices. It&#39;s not <code data-astro-raw="">x</code> which is being assigned to, only one <em>index</em> of it is being assigned. So the part of the AST that is in <code data-astro-raw="">Store</code> context is the <code data-astro-raw="">Subscript</code>, i.e. it is <code data-astro-raw="">x[5]</code> that&#39;s being assigned a new value.</p><p>Hopefully this explains <em>why</em> we explicitly need to tell each variable whether it is in a load or store context in the AST.</p><p>Now unless you&#39;re super familiar with Python, you&#39;d think that <code data-astro-raw="">Load</code> and <code data-astro-raw="">Store</code> cover everything that the language needs, but weirdly enough there&#39;s a third possible <code data-astro-raw="">ctx</code> value, <code data-astro-raw="">Del</code>:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;del x&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Delete<span>(</span>
      targets<span>=</span><span>[</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Del<span>(</span><span>)</span><span>)</span><span>]</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre><details>
<summary> Extras: why `del` exists </summary>
<p>So Python is a <em>reference-counted, garbage collected language</em>. What that means is that there&#39;s a very clear distinction between variables and values. Values are essentially just objects floating around in memory, and variables are just names that point to the said objects in memory.</p>
<p>For each variable that points to a value (a.k.a &#34;references&#34; that value), the reference count of that value is increased. For example:</p>
<pre><code data-astro-raw="">x <span>=</span> <span>&#39;some string&#39;</span>  
y <span>=</span> x              </code></pre>
<p>When a value in memory reaches a reference count of zero, that value is no longer used anywhere in the program. Once that happens, the value is deleted from memory (garbage collected). There&#39;s a few reasons why a value can get to zero reference counts, like a function returning:</p>
<pre><code data-astro-raw=""><span>def</span> <span>f</span><span>(</span><span>)</span><span>:</span>
    x <span>=</span> <span>&#39;some string&#39;</span>  
    <span>print</span><span>(</span>x<span>)</span>
    
    

f<span>(</span><span>)</span></code></pre>
<p>Or, if you explicitly delete it:</p>
<pre><code data-astro-raw="">x <span>=</span> <span>&#39;some string&#39;</span>  
<span>del</span> x              </code></pre>
<p>Note that re-assigning a variable is the same as deleting it and then assigning it. Which means this:</p>
<pre><code data-astro-raw="">x <span>=</span> <span>&#39;some string&#39;</span>   
x <span>=</span> <span>&#39;other string&#39;</span>  </code></pre>
<p>... is the same as this:</p>
<pre><code data-astro-raw="">x <span>=</span> <span>&#39;some string&#39;</span>  
<span>del</span> x              
x <span>=</span> <span>&#39;other string&#39;</span></code></pre>
<p>If you want more examples of this, there&#39;s a <a href="https://www.youtube.com/watch?v=GGKerIMqHCk">much more in-depth video by Anthony</a>.</p>
</details><p>And just like <code data-astro-raw="">Store</code>, you can also <code data-astro-raw="">Del</code> an attribute or an index, and it behaves similarly:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;del x[y]&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Delete<span>(</span>
      targets<span>=</span><span>[</span>
        Subscript<span>(</span>
          value<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
          <span>slice</span><span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;y&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
          ctx<span>=</span>Del<span>(</span><span>)</span>
        <span>)</span>
      <span>]</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre><details>
<summary> Extras: type_ignores </summary>
<p>We also haven&#39;t talked about the <code data-astro-raw="">type_ignores=[]</code> thing present at the bottom of every <code data-astro-raw="">Module</code> we output have seen so far.</p>
<p>It&#39;s a topic related to Python&#39;s type hints. More specifically, it refers to <code data-astro-raw=""># type: ignore</code> comments present in source code. They&#39;re not normally parsed by the AST, but you can pass a flag to the parsing step to tell it to check for these comments. Type checkers like <a href="https://github.com/python/mypy">mypy</a> will use this to get type more information. Take a look at this:</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>ast<span>.</span>dump<span>(</span>
<span>.</span><span>.</span><span>.</span>   ast<span>.</span>parse<span>(</span><span>&#39;x = 5 # type: ignore&#39;</span><span>,</span> type_comments<span>=</span><span>True</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span>   indent<span>=</span><span>2</span>
<span>.</span><span>.</span><span>.</span> <span>)</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Assign<span>(</span>
      targets<span>=</span><span>[</span>
        Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
      <span>]</span><span>,</span>
      value<span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span>
    TypeIgnore<span>(</span>lineno<span>=</span><span>1</span><span>,</span> tag<span>=</span><span>&#39;&#39;</span><span>)</span>
  <span>]</span>
<span>)</span></code></pre>
<p>If you want to learn more about mypy and type checkers, I have a <a href="https://sadh.life/post/mypy-guide">super long blog</a> on that.</p>
</details><h2 id="walking-the-syntax-trees-with-visitors">Walking the Syntax Trees with Visitors</h2><p>So now we know that our AST represents code using nested Nodes, a structure that is called a &#34;tree&#34;. We also know that in a tree structure, a node can have as many children nodes inside it as needed. With all that, comes the question of how does one &#34;read&#34; the tree.</p><p>The most obvious way would be to read it top to bottom, the way it appears in the AST dump that we&#39;ve seen so many times:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;&#39;&#39;
... age = 21
... print(age)
... &#39;&#39;&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Assign<span>(</span>
      targets<span>=</span><span>[</span>
        Name<span>(</span><span>id</span><span>=</span><span>&#39;age&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
      <span>]</span><span>,</span>
      value<span>=</span>Constant<span>(</span>value<span>=</span><span>21</span><span>)</span><span>)</span><span>,</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;age&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
        <span>]</span><span>,</span>
        keywords<span>=</span><span>[</span><span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre><p>We have a <code data-astro-raw="">Module</code>, which has two nodes in its body: an <code data-astro-raw="">Assign</code> which has a <code data-astro-raw="">Name</code> and a <code data-astro-raw="">Constant</code>, and an <code data-astro-raw="">Expr</code> which has a <code data-astro-raw="">Call</code> with a couple <code data-astro-raw="">Name</code> nodes.</p><p>This way of reading from parent node to child node, in the sequence they appear, is called a pre-order traversal of the tree. And for most intents and purposes, it is what you need.</p><p>To implement this sort of traversal of an AST, Python provides you the <code data-astro-raw="">NodeVisitor</code> class, which you can use like this:</p><pre><code data-astro-raw=""><span>import</span> ast

<span>class</span> <span>MyVisitor</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f&#39;entering </span><span><span>{</span>node<span>.</span>__class__<span>.</span>__name__<span>}</span></span><span>&#39;</span></span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

visitor <span>=</span> MyVisitor<span>(</span><span>)</span>

tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;&#39;&#39;
age = 21
print(age)
&#39;&#39;&#39;</span><span>)</span>
visitor<span>.</span>visit<span>(</span>tree<span>)</span></code></pre><blockquote>
<p>We&#39;ll look closer at the code inside <code data-astro-raw="">MyVisitor</code> very soon, but let&#39;s try and examine its output first.</p>
</blockquote><p>This outputs the following:</p><pre><code data-astro-raw="">entering Module
entering Assign
entering Name
entering Store
entering Constant
entering Expr
entering Call
entering Name
entering Load
entering Name
entering Load</code></pre><p>To make this output slightly more detailed, let&#39;s not just print the class name, but the entire node:</p><pre><code data-astro-raw=""><span>import</span> ast

<span>class</span> <span>MyVisitor</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f&#39;entering </span><span><span>{</span>ast<span>.</span>dump<span>(</span>node<span>)</span><span>}</span></span><span>&#39;</span></span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

visitor <span>=</span> MyVisitor<span>(</span><span>)</span>

tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;&#39;&#39;
x = 5
print(x)
&#39;&#39;&#39;</span><span>)</span>
visitor<span>.</span>visit<span>(</span>tree<span>)</span></code></pre><p>There&#39;s a lot more output, but it might help to look at it:</p><pre><code data-astro-raw="">entering Module<span>(</span>body<span>=</span><span>[</span>Assign<span>(</span>targets<span>=</span><span>[</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span><span>]</span><span>,</span> value<span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span><span>)</span><span>,</span> Expr<span>(</span>value<span>=</span>Call<span>(</span>func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span> args<span>=</span><span>[</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>]</span><span>,</span> keywords<span>=</span><span>[</span><span>]</span><span>)</span><span>)</span><span>]</span><span>,</span> type_ignores<span>=</span><span>[</span><span>]</span><span>)</span>
entering Assign<span>(</span>targets<span>=</span><span>[</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span><span>]</span><span>,</span> value<span>=</span>Constant<span>(</span>value<span>=</span><span>5</span><span>)</span><span>)</span>
entering Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Store<span>(</span><span>)</span><span>)</span>
entering Store<span>(</span><span>)</span>
entering Constant<span>(</span>value<span>=</span><span>5</span><span>)</span>
entering Expr<span>(</span>value<span>=</span>Call<span>(</span>func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span> args<span>=</span><span>[</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>]</span><span>,</span> keywords<span>=</span><span>[</span><span>]</span><span>)</span><span>)</span>
entering Call<span>(</span>func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span> args<span>=</span><span>[</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>]</span><span>,</span> keywords<span>=</span><span>[</span><span>]</span><span>)</span>
entering Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
entering Load<span>(</span><span>)</span>
entering Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
entering Load<span>(</span><span>)</span></code></pre><p>You might notice that the first line output is the entire <code data-astro-raw="">Module</code>. The second line is the <code data-astro-raw="">Assign</code> node that is inside the <code data-astro-raw="">Module</code>, and the third line is a <code data-astro-raw="">Name</code> node which is inside that. Interesting.</p><p>With that, let&#39;s understand what&#39;s going on. You can imagine this &#34;visitor&#34; moving from up to down, left to right in this tree structure:</p><pre><code data-astro-raw="">               &lt;----Module----&gt;
              /                \
         Assign                 Expr
        /      \                 |
 Name(&#39;x&#39;)   Constant(5)        Call
  |                            /    \
Store()            Name(&#39;print&#39;)    Name(&#39;x&#39;)
                    |                |
                   Load()           Load()</code></pre><p>It starts from the <code data-astro-raw="">Module</code>, then for each child it visits, it visits the entirety of one of its children before going to the next child. As in, it visits the entirety of the <code data-astro-raw="">Assign</code> sub-tree before moving on to <code data-astro-raw="">Expr</code> part of the tree, and so on.</p><p>How it does this, is all hidden in our <code data-astro-raw="">generic_visit()</code> implementation. Let&#39;s start tweaking it to see what results we get. Here&#39;s a simpler example:</p><pre><code data-astro-raw=""><span>class</span> <span>MyVisitor</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f&#39;entering </span><span><span>{</span>node<span>.</span>__class__<span>.</span>__name__<span>}</span></span><span>&#39;</span></span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

visitor <span>=</span> MyVisitor<span>(</span><span>)</span>

tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;x = 5&#39;</span><span>)</span>
visitor<span>.</span>visit<span>(</span>tree<span>)</span></code></pre><pre><code data-astro-raw="">entering Module
entering Assign
entering Name
entering Store
entering Constant</code></pre><p>Now let&#39;s move the <code data-astro-raw="">print</code> statement to below the <code data-astro-raw="">super</code> call, see what happens:</p><pre><code data-astro-raw=""><span>class</span> <span>MyVisitor</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>
        <span>print</span><span>(</span><span><span>f&#39;leaving </span><span><span>{</span>node<span>.</span>__class__<span>.</span>__name__<span>}</span></span><span>&#39;</span></span><span>)</span>

visitor <span>=</span> MyVisitor<span>(</span><span>)</span>

tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;x = 5&#39;</span><span>)</span>
visitor<span>.</span>visit<span>(</span>tree<span>)</span></code></pre><pre><code data-astro-raw="">leaving Store
leaving Name
leaving Constant
leaving Assign
leaving Module</code></pre><p>Interesting. So now the prints suddenly happen in sort-of &#34;reverse&#34; order. It&#39;s not actually reversed though, but now every child appears before the parent. This bottom-to-top, left-to-right traversal is called post-order traversal.</p><p>So how about if we do both prints together?</p><pre><code data-astro-raw=""><span>class</span> <span>MyVisitor</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f&#39;entering </span><span><span>{</span>node<span>.</span>__class__<span>.</span>__name__<span>}</span></span><span>&#39;</span></span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>
        <span>print</span><span>(</span><span><span>f&#39;leaving </span><span><span>{</span>node<span>.</span>__class__<span>.</span>__name__<span>}</span></span><span>&#39;</span></span><span>)</span>

visitor <span>=</span> MyVisitor<span>(</span><span>)</span>

tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;x = 5&#39;</span><span>)</span>
visitor<span>.</span>visit<span>(</span>tree<span>)</span></code></pre><pre><code data-astro-raw="">entering Module
entering Assign
entering Name
entering Store
leaving Store
leaving Name
entering Constant
leaving Constant
leaving Assign
leaving Module</code></pre><p>If you follow the enter and leave commands one by one, you&#39;ll see how this traversal is happening. I&#39;ve added the corresponding line numbers for each node in an <code data-astro-raw="">[enter, leave]</code> pair in this graph, and you can follow the traversal from 1 through 10:</p><pre><code data-astro-raw="">           Module [1, 10]
             |
           Assign [2, 9]
          /         \
 Name(&#39;x&#39;) [3, 6]    Constant(5) [7, 8]
   |
Store() [4, 5]</code></pre><blockquote>
<p>You can keep this in mind, that anything that comes before the <code data-astro-raw="">super()</code> call is being done in pre-order, and anything that comes after the <code data-astro-raw="">super()</code> call is being done in post-order.</p>
</blockquote><p>So let&#39;s say that for some reason I wanted to find how many statements exist inside all the <code data-astro-raw="">for</code> loops in my code. To do that, I&#39;d need to do the following:</p><ul>
<li>Traverse through the code to find all <code data-astro-raw="">For</code> nodes. We&#39;re already sorted with that.</li>
<li>Each time we see a <code data-astro-raw="">For</code> node, we need to start our count from zero.</li>
<li>We must keep counting until we see this same <code data-astro-raw="">For</code> node again during post-order traversal.</li>
<li>For every node we find below the <code data-astro-raw="">For</code> node, check if it&#39;s a statement, and increment count.</li>
</ul><p>The code for that would look like this:</p><pre><code data-astro-raw=""><span>import</span> ast

<span>class</span> <span>ForStmtCounter</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    current_for_node <span>=</span> <span>None</span>
    stmt_count <span>=</span> <span>0</span>

    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        
        <span>if</span> self<span>.</span>current_for_node <span>is</span> <span>not</span> <span>None</span><span>:</span>
            <span>if</span> <span>isinstance</span><span>(</span>node<span>,</span> ast<span>.</span>stmt<span>)</span><span>:</span>
                self<span>.</span>stmt_count <span>+=</span> <span>1</span>

        
        <span>elif</span> <span>isinstance</span><span>(</span>node<span>,</span> ast<span>.</span>For<span>)</span><span>:</span>
            self<span>.</span>current_for_node <span>=</span> node
            self<span>.</span>stmt_count <span>=</span> <span>0</span>

        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

        
        <span>if</span> node <span>is</span> self<span>.</span>current_for_node<span>:</span>
            
            <span>print</span><span>(</span><span><span>f&#39;For node contains </span><span><span>{</span>self<span>.</span>stmt_count<span>}</span></span><span> statements&#39;</span></span><span>)</span>
            self<span>.</span>current_for_node <span>=</span> <span>None</span>

for_statement_counter <span>=</span> ForStmtCounter<span>(</span><span>)</span>

tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;&#39;&#39;
for i in range(10):
    print(i)

for item in items:
    if item == 42:
        print(&#39;Magic item found!&#39;)
        break
&#39;&#39;&#39;</span><span>)</span>
for_statement_counter<span>.</span>visit<span>(</span>tree<span>)</span></code></pre><p>And this is the output:</p><pre><code data-astro-raw="">For node contains 1 statements
For node contains 3 statements</code></pre><h2 id="the-power-of-ast-manipulation">The power of AST manipulation</h2><p>The real power of ASTs comes from the fact that you can edit an AST, and then compile and run it, to modify your source code&#39;s behaviour at runtime.</p><p>To get into all of that, let me explain a little bit about how Python runs your source code:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> code <span>=</span> <span>&#39;print(&#34;hello&#34;)&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span>code<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>ast<span>.</span>dump<span>(</span>tree<span>,</span> indent<span>=</span><span>2</span><span>)</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Constant<span>(</span>value<span>=</span><span>&#39;hello&#39;</span><span>)</span>
        <span>]</span><span>,</span>
        keywords<span>=</span><span>[</span><span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> code_object <span>=</span> <span>compile</span><span>(</span>tree<span>,</span> <span>&#39;&lt;my ast&gt;&#39;</span><span>,</span> <span>&#39;exec&#39;</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>exec</span><span>(</span>code_object<span>)</span>
hello</code></pre><ul>
<li>The first step is to parse the source code. This actually involves two steps, converting the source code into tokens, and then converting the tokens into a valid AST. Python neatly exposes these two parts of the compilation step with the <code data-astro-raw="">ast.parse</code> function. You can examine the AST produced in the output above.</li>
<li>The next step is to &#34;compile&#34; the given AST into a code object. Code objects are objects that contain compliled pieces of Python &#34;bytecode&#34;, the variable names present in the bytecode, and the locations of each part in the actual source.
The <code data-astro-raw="">compile</code> function takes in the AST, a file name (which we set to <code data-astro-raw="">&#39;&lt;my ast&gt;&#39;</code> in our case), and a mode, which we set to <code data-astro-raw="">&#39;exec&#39;</code>, which tells compile that we want an executable code object to come out.</li>
<li>The third step is to run the <code data-astro-raw="">exec()</code> on this code object, which runs this bytecode in the interpreter. It provides the bytecode with all the values present in the local and global scopes, and lets the code run. In our case, this makes the object print out <code data-astro-raw="">hello</code>.</li>
</ul><blockquote>
<p>If you want a more in-depth explanation of this, I have an entire section on it in my <a href="https://sadh.life/post/builtins#compile-exec-and-eval-how-the-code-works">builtins</a> blog.</p>
</blockquote><p>Now since we have the AST in step 1 of this part, we can simply <em>modify the AST</em>, before we run the compile and execute steps, and the output of the program will be different. How cool is that!</p><p>Let&#39;s just jump into it with a few simple examples, before we do something really awesome with this.</p><p>Let&#39;s write one that changes all numbers in our code to become <code data-astro-raw="">42</code>, because why not. Here&#39;s our test code:</p><pre><code data-astro-raw=""><span>print</span><span>(</span><span>13</span><span>)</span>  

num <span>=</span> <span>28</span>
<span>print</span><span>(</span>num<span>)</span>

<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y

<span>for</span> i <span>in</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>:</span>
    <span>print</span><span>(</span>i<span>)</span>

output <span>=</span> add<span>(</span>num<span>,</span> <span>100</span><span>)</span>
<span>print</span><span>(</span>output<span>)</span></code></pre><p>Running this, we get:</p><pre><code data-astro-raw="">13
28
1
2
3
128</code></pre><p>Now, if all numbers in this code were 42, our output would be:</p><pre><code data-astro-raw="">42
42
42
42
42
84</code></pre><p>The last <code data-astro-raw="">84</code> is from 42 + 42 (instead of 28 + 100).</p><p>So, how would you do this? It&#39;s quite straightforward actually. What we do is define a <code data-astro-raw="">NodeTransformer</code> class. The difference between this and a <code data-astro-raw="">NodeVisitor</code> is that a <code data-astro-raw="">Transformer</code> actually returns a node on every visit, which replaces the old node:</p><pre><code data-astro-raw=""><span>import</span> ast

<span>class</span> <span>NumberChanger</span><span>(</span>ast<span>.</span>NodeTransformer<span>)</span><span>:</span>
    <span>&#34;&#34;&#34;Changes all number literals to 42.&#34;&#34;&#34;</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        
        <span>if</span> <span>not</span> <span>isinstance</span><span>(</span>node<span>,</span> ast<span>.</span>Constant<span>)</span> <span>or</span> <span>not</span> <span>isinstance</span><span>(</span>node<span>.</span>value<span>,</span> <span>int</span><span>)</span><span>:</span>
            <span>return</span> node

        <span>return</span> ast<span>.</span>Constant<span>(</span>value<span>=</span><span>42</span><span>)</span></code></pre><p>Let&#39;s run it and see our output:</p><pre><code data-astro-raw="">$ python <span>-</span>i code<span>.</span>py
<span>&gt;&gt;</span><span>&gt;</span> code <span>=</span> <span>&#39;&#39;&#39;
... print(13)  # definitely not 42
...
... num = 28
... print(num)
...
... for i in [1, 2, 3]:
...     print(i)
...
... output = add(num, 100)
... print(output)
... &#39;&#39;&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span>code<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> modified_tree <span>=</span> NumberChanger<span>(</span><span>)</span><span>.</span>visit<span>(</span>tree<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>exec</span><span>(</span><span>compile</span><span>(</span>modified_tree<span>,</span> <span>&#39;&lt;my ast&gt;&#39;</span><span>,</span> <span>&#39;exec&#39;</span><span>)</span><span>)</span></code></pre><p>And, as expected, the output is:</p><pre><code data-astro-raw="">13
28
3
128</code></pre><p>... wait. That&#39;s not right. Something&#39;s definitely not right.</p><p>And with that, we are going to talk about something that&#39;s really important when it comes to playing around with ASTs: Sometimes, it can be quite hard to get right.</p><p>A tutorial can make any topic seem easy and obvious, but often times it misses out on the whole learning process of making mistakes, discovering new edge cases, and actually understanding how to debug some of these things.</p><p>Okay, mini-rant over. Let&#39;s try and debug this thing. To do that, the first thing that we should do is head to the docs:</p><p><a href="https://docs.python.org/3/library/ast.html#ast.NodeTransformer"><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m9rahn5ut20dcpo3jaqu.png" alt="ast.NodeTransformer Docs"/></a></p><p>The first line below a code example says:</p><blockquote>
<p>&#34;Keep in mind that if the node you’re operating on has child nodes you must either transform the child nodes yourself or call the <code data-astro-raw="">generic_visit()</code> method for the node first.&#34;</p>
</blockquote><p>Ah, yes, we forgot the <code data-astro-raw="">super()</code> call. But why does that matter?</p><p>The <code data-astro-raw="">super()</code> call is what propagates the tree traversal down the tree. If you don&#39;t call that, the visit method will stop on that specific node, and never visit the node&#39;s children. So, let&#39;s fix this:</p><pre><code data-astro-raw=""><span>import</span> ast

<span>class</span> <span>NumberChanger</span><span>(</span>ast<span>.</span>NodeTransformer<span>)</span><span>:</span>
    <span>&#34;&#34;&#34;Changes all number literals to 42.&#34;&#34;&#34;</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>  

        
        <span>if</span> <span>not</span> <span>isinstance</span><span>(</span>node<span>,</span> ast<span>.</span>Constant<span>)</span> <span>or</span> <span>not</span> <span>isinstance</span><span>(</span>node<span>.</span>value<span>,</span> <span>int</span><span>)</span><span>:</span>
            <span>return</span> node

        <span>return</span> ast<span>.</span>Constant<span>(</span>value<span>=</span><span>42</span><span>)</span></code></pre><p>Let&#39;s run it again:</p><pre><code data-astro-raw="">$ python <span>-</span>i code<span>.</span>py
<span>&gt;&gt;</span><span>&gt;</span> code <span>=</span> <span>&#39;&#39;&#39;
... print(13)  # definitely not 42
...
... num = 28
... print(num)
...
... for i in [1, 2, 3]:
...     print(i)
...
... output = add(num, 100)
... print(output)
... &#39;&#39;&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span>code<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> modified_tree <span>=</span> NumberChanger<span>(</span><span>)</span><span>.</span>visit<span>(</span>tree<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>exec</span><span>(</span><span>compile</span><span>(</span>modified_tree<span>,</span> <span>&#39;&lt;my ast&gt;&#39;</span><span>,</span> <span>&#39;exec&#39;</span><span>)</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>&gt;</span>
TypeError<span>:</span> required field <span>&#34;lineno&#34;</span> missing <span>from</span> expr</code></pre><p>Uh oh. Another error. Welp, back to the docs.</p><p>This is what the rest of the section on <code data-astro-raw="">NodeTransformer</code> says:</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fuy4bsireiy58qunpjom.png" alt="There&#39;s a section about fix_missing_locations"/></p><p>That&#39;s exactly what we need to do, run <code data-astro-raw="">fix_missing_locations</code>. Always read the entirety of the docs, folks. Let&#39;s run it again:</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> modified_tree <span>=</span> ast<span>.</span>fix_missing_locations<span>(</span>modified_tree<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>exec</span><span>(</span><span>compile</span><span>(</span>modified_tree<span>,</span> <span>&#39;&lt;my ast&gt;&#39;</span><span>,</span> <span>&#39;exec&#39;</span><span>)</span><span>)</span>
<span>42</span>
<span>42</span>
<span>42</span>
<span>42</span>
<span>42</span>
<span>84</span></code></pre><p>Finally! We were able to modify and run our AST 🎉</p><p>Let&#39;s go a little more in depth. This article is super long already, might as well add some more interesting stuff.</p><p>Since it&#39;s very common for AST modifications to deal with a specific kind of node, and nothing else (We&#39;ve already seen a few examples where that would&#39;ve been useful, such as turning every number into <code data-astro-raw="">42</code>), The <code data-astro-raw="">NodeVisitor</code> and <code data-astro-raw="">NodeTransformer</code> classes both let you define Node-specific visitor methods.</p><p>You define a node-specific visitor method by defining a <code data-astro-raw="">visit_&lt;NodeName&gt;</code> method, just as <code data-astro-raw="">visit_For</code> to just visit for-loops. If the visitor encounters a for loop, it will first see if a <code data-astro-raw="">visit_For</code> is defined in the class, and run that. If there isn&#39;t, it runs <code data-astro-raw="">generic_visit</code> as the fallback.</p><p>Here&#39;s a somewhat wacky example, which lets you run a program that outputs to the terminal, and make it so that it outputs to a file instead. To do that, we&#39;re going to rewrite every <code data-astro-raw="">print</code> call, and add an attribute, <code data-astro-raw="">file=...</code>, which will make it print to that file instead.</p><p>Let&#39;s see what the AST looks like, for a <code data-astro-raw="">print()</code> call with and without a <code data-astro-raw="">file=...</code> attribute.</p><pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;print(x)&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
        <span>]</span><span>,</span>
        keywords<span>=</span><span>[</span><span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span>

<span>&gt;&gt;</span><span>&gt;</span> get_ast<span>(</span><span>&#39;print(x, file=myfile)&#39;</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>Call<span>(</span>
        func<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;print&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
        args<span>=</span><span>[</span>
          Name<span>(</span><span>id</span><span>=</span><span>&#39;x&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
        <span>]</span><span>,</span>
        keywords<span>=</span><span>[</span>
          keyword<span>(</span>
            arg<span>=</span><span>&#39;file&#39;</span><span>,</span>
            value<span>=</span>Name<span>(</span><span>id</span><span>=</span><span>&#39;myfile&#39;</span><span>,</span> ctx<span>=</span>Load<span>(</span><span>)</span><span>)</span>
          <span>)</span>
        <span>]</span>
      <span>)</span>
    <span>)</span>
  <span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span>
<span>)</span></code></pre><p>So we need to find every <code data-astro-raw="">Call</code> with the <code data-astro-raw="">func</code> attribute being <code data-astro-raw="">Name(id=&#39;print&#39;)</code>, and add a <code data-astro-raw="">file</code> property to the <code data-astro-raw="">Call</code>&#39;s <code data-astro-raw="">keywords</code>.</p><pre><code data-astro-raw=""><span>import</span> ast

<span>class</span> <span>FileWriter</span><span>(</span>ast<span>.</span>NodeTransformer<span>)</span><span>:</span>
    <span>def</span> <span>visit_Call</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

        <span>if</span> <span>isinstance</span><span>(</span>node<span>.</span>func<span>,</span> ast<span>.</span>Name<span>)</span> <span>and</span> node<span>.</span>func<span>.</span><span>id</span> <span>==</span> <span>&#34;print&#34;</span><span>:</span>
            node<span>.</span>keywords<span>.</span>append<span>(</span>
                ast<span>.</span>keyword<span>(</span>
                    arg<span>=</span><span>&#34;file&#34;</span><span>,</span>
                    value<span>=</span>ast<span>.</span>Name<span>(</span><span>id</span><span>=</span><span>&#34;myfile&#34;</span><span>,</span> ctx<span>=</span>ast<span>.</span>Load<span>(</span><span>)</span><span>)</span><span>,</span>
                <span>)</span>
            <span>)</span>

        
        <span>return</span> node</code></pre><p>Time to test this:</p><pre><code data-astro-raw="">$ python <span>-</span>i code<span>.</span>py
<span>&gt;&gt;</span><span>&gt;</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>6</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>&#39;*&#39;</span> <span>*</span> i<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>*</span>
<span>**</span>
<span>**</span><span>*</span>
<span>**</span><span>**</span>
<span>**</span><span>**</span><span>*</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> code <span>=</span> <span>&#39;&#39;&#39;
... for i in range(1, 6):
...     print(&#39;*&#39; * i)
... &#39;&#39;&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span>code<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> new_tree <span>=</span> FileWriter<span>(</span><span>)</span><span>.</span>visit<span>(</span>tree<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> new_tree <span>=</span> ast<span>.</span>fix_missing_locations<span>(</span>new_tree<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>with</span> <span>open</span><span>(</span><span>&#39;output.txt&#39;</span><span>,</span> <span>&#39;w&#39;</span><span>)</span> <span>as</span> myfile<span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>exec</span><span>(</span><span>compile</span><span>(</span>new_tree<span>,</span> <span>&#39;&lt;ast&gt;&#39;</span><span>,</span> <span>&#39;exec&#39;</span><span>)</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>&gt;&gt;</span><span>&gt;</span> exit<span>(</span><span>)</span>

$ cat output<span>.</span>txt
<span>*</span>
<span>**</span>
<span>**</span><span>*</span>
<span>**</span><span>**</span>
<span>**</span><span>**</span><span>*</span></code></pre><p>If you want to, a nice exercise for checking your understanding would be to re-write every <code data-astro-raw="">generic_visit</code> based code we have written so far, and simplify it using <code data-astro-raw="">visit_X</code> methods instead.</p><p>I&#39;d love to talk a lot more in depth about all the insane stuff you can do in Python by modifying and executing ASTs. But unfortunately there&#39;s not enough space in this blog post for that. Trust me.</p><blockquote>
<p>If you really want to look into more examples of this, you can check out the source code of <a href="https://github.com/tusharsadhwani/zxpy">zxpy</a> after reading this article. It is a library that essentially adds new syntax to Python strings, to seamlessly execute shell code within Python. It is mind-bending stuff though.</p>
</blockquote><h2 id="lets-build-a-simple-linter">Let&#39;s build: A simple linter</h2><p>We&#39;ve learned all the key components for this, all that&#39;s left to do is to put everything together. Let&#39;s write our own linter from scratch.</p><p>Here&#39;s the idea:</p><ul>
<li>We&#39;re gonna make a <code data-astro-raw="">Linter</code> class, which holds our &#34;lint rules&#34;.</li>
<li>Lint rules are the actual checks that run on the code. They comprise of 3 things:
<ul>
<li>A rule &#34;code&#34; that uniquely identifies it,</li>
<li>A message that explains the rule violation to the user,</li>
<li>And a <code data-astro-raw="">Checker</code> class, which is an AST visitor that checks which nodes violate this rule in the source code.</li>
</ul>
</li>
<li>Our linter class will register these rules, run them on a file, and print out all violations.</li>
</ul><p>So let&#39;s write down our linter framework, <code data-astro-raw="">mylint.py</code>:</p><pre><code data-astro-raw=""><span>import</span> ast
<span>import</span> os
<span>from</span> typing <span>import</span> NamedTuple


<span>class</span> <span>Violation</span><span>(</span>NamedTuple<span>)</span><span>:</span>
    <span>&#34;&#34;&#34;
    Every rule violation contains a node that breaks the rule,
    and a message that will be shown to the user.
    &#34;&#34;&#34;</span>

    node<span>:</span> ast<span>.</span>AST
    message<span>:</span> <span>str</span>


<span>class</span> <span>Checker</span><span>(</span>ast<span>.</span>NodeVisitor<span>)</span><span>:</span>
    <span>&#34;&#34;&#34;
    A Checker is a Visitor that defines a lint rule, and stores all the
    nodes that violate that lint rule.
    &#34;&#34;&#34;</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> issue_code<span>)</span><span>:</span>
        self<span>.</span>issue_code <span>=</span> issue_code
        self<span>.</span>violations <span>=</span> <span>set</span><span>(</span><span>)</span>


<span>class</span> <span>Linter</span><span>:</span>
    <span>&#34;&#34;&#34;Holds all list rules, and runs them against a source file.&#34;&#34;&#34;</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>checkers <span>=</span> <span>set</span><span>(</span><span>)</span>

    <span>@staticmethod</span>
    <span>def</span> <span>print_violations</span><span>(</span>checker<span>,</span> file_name<span>)</span><span>:</span>
        <span>for</span> node<span>,</span> message <span>in</span> checker<span>.</span>violations<span>:</span>
            <span>print</span><span>(</span>
                <span><span>f&#34;</span><span><span>{</span>file_name<span>}</span></span><span>:</span><span><span>{</span>node<span>.</span>lineno<span>}</span></span><span>:</span><span><span>{</span>node<span>.</span>col_offset<span>}</span></span><span>: &#34;</span></span>
                <span><span>f&#34;</span><span><span>{</span>checker<span>.</span>issue_code<span>}</span></span><span>: </span><span><span>{</span>message<span>}</span></span><span>&#34;</span></span>
            <span>)</span>

    <span>def</span> <span>run</span><span>(</span>self<span>,</span> source_path<span>)</span><span>:</span>
        <span>&#34;&#34;&#34;Runs all lints on a source file.&#34;&#34;&#34;</span>
        file_name <span>=</span> os<span>.</span>path<span>.</span>basename<span>(</span>source_path<span>)</span>

        <span>with</span> <span>open</span><span>(</span>source_path<span>)</span> <span>as</span> source_file<span>:</span>
            source_code <span>=</span> source_file<span>.</span>read<span>(</span><span>)</span>

        tree <span>=</span> ast<span>.</span>parse<span>(</span>source_code<span>)</span>
        <span>for</span> checker <span>in</span> self<span>.</span>checkers<span>:</span>
            checker<span>.</span>visit<span>(</span>tree<span>)</span>
            self<span>.</span>print_violations<span>(</span>checker<span>,</span> file_name<span>)</span></code></pre><p>Sweet. Now that we have a framework, we can start writing our own checkers. Let&#39;s start with a simple one, one that checks if a set has duplicate items:</p><pre><code data-astro-raw=""><span>class</span> <span>SetDuplicateItemChecker</span><span>(</span>Checker<span>)</span><span>:</span>
    <span>&#34;&#34;&#34;Checks if a set in your code has duplicate constants.&#34;&#34;&#34;</span>

    <span>def</span> <span>visit_Set</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>&#34;&#34;&#34;Stores all the constants this set holds, and finds duplicates&#34;&#34;&#34;</span>
        seen_values <span>=</span> <span>set</span><span>(</span><span>)</span>
        <span>for</span> element <span>in</span> node<span>.</span>elts<span>:</span>
            
            <span>if</span> <span>not</span> <span>isinstance</span><span>(</span>element<span>,</span> ast<span>.</span>Constant<span>)</span><span>:</span>
                <span>continue</span>

            
            value <span>=</span> element<span>.</span>value
            <span>if</span> value <span>in</span> seen_values<span>:</span>
                violation <span>=</span> Violation<span>(</span>
                    node<span>=</span>element<span>,</span>
                    message<span>=</span><span><span>f&#34;Set contains duplicate item: </span><span><span>{</span>value<span>!r</span><span>}</span></span><span>&#34;</span></span><span>,</span>
                <span>)</span>
                self<span>.</span>violations<span>.</span>add<span>(</span>violation<span>)</span>

            <span>else</span><span>:</span>
                seen_values<span>.</span>add<span>(</span>element<span>.</span>value<span>)</span></code></pre><p>The only thing left, is to write a <code data-astro-raw="">main</code> function, that takes the filenames from the commandlint, and runs the linter:</p><pre><code data-astro-raw=""><span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    source_path <span>=</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span>

    linter <span>=</span> Linter<span>(</span><span>)</span>
    linter<span>.</span>checkers<span>.</span>add<span>(</span>SetDuplicateItemChecker<span>(</span>issue_code<span>=</span><span>&#34;W001&#34;</span><span>)</span><span>)</span>

    linter<span>.</span>run<span>(</span>source_path<span>)</span>


<span>if</span> __name__ <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    main<span>(</span><span>)</span></code></pre><p>That was a lot of code, but hopefully you were able to make sense of all of it. Alright, time to lint some files. I wrote a <code data-astro-raw="">test.py</code> file to test our linter:</p><pre><code data-astro-raw="">$ cat test<span>.</span>py
s <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>}</span>
l <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>for</span> item <span>in</span> l<span>:</span>
        methods <span>=</span> <span>{</span>
            <span>&#34;GET&#34;</span><span>,</span>
            <span>&#34;PUT&#34;</span><span>,</span>
            <span>&#34;POST&#34;</span><span>,</span>
            <span>&#34;DELETE&#34;</span><span>,</span>
            <span>&#34;PUT&#34;</span><span>,</span>   
        <span>}</span>
        <span>if</span> item <span>in</span> methods<span>:</span>
            <span>print</span><span>(</span>item<span>)</span>

s2 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>}</span>  </code></pre><p>Let&#39;s run:</p><pre><code data-astro-raw="">$ python mylint.py test.py
test.py:11:12: W001: Set contains duplicate item: <span>&#39;PUT&#39;</span>
test.py:16:15: W001: Set contains duplicate item: <span>1</span></code></pre><p>We&#39;ve successfully written a linter!</p><p>The real fun starts though, with the really intricate lint rules that you can write. So let&#39;s write one of those. <strong>Let&#39;s try to write a checker that checks for unused variables.</strong></p><p>Here&#39;s the idea: Every function has a local scope, where you can define new variables. These variables only exist within that function, they have to be created and used all within that function. But, if a variable is defined but isn&#39;t used in a function, that&#39;s an unused variable.</p><p>To detect unused variables, we can visit all <code data-astro-raw="">Name</code> nodes inside a function or class, and see if there&#39;s any in <code data-astro-raw="">Load</code> context. If a variable is only ever present in <code data-astro-raw="">Store</code> context, that means it&#39;s defined but never used. So let&#39;s do that:</p><pre><code data-astro-raw=""><span>class</span> <span>UnusedVariableInScopeChecker</span><span>(</span>Checker<span>)</span><span>:</span>
    <span>&#34;&#34;&#34;Checks if any variables are unused in this node&#39;s scope.&#34;&#34;&#34;</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> issue_code<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>__init__<span>(</span>issue_code<span>)</span>
        
        
        
        self<span>.</span>unused_names <span>=</span> <span>{</span><span>}</span>

        
        self<span>.</span>name_nodes <span>=</span> <span>{</span><span>}</span>

    <span>def</span> <span>visit_Name</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>&#34;&#34;&#34;Find all nodes that only exist in `Store` context&#34;&#34;&#34;</span>
        var_name <span>=</span> node<span>.</span><span>id</span>

        <span>if</span> <span>isinstance</span><span>(</span>node<span>.</span>ctx<span>,</span> ast<span>.</span>Store<span>)</span><span>:</span>
            
            <span>if</span> var_name <span>not</span> <span>in</span> self<span>.</span>name_nodes<span>:</span>
                self<span>.</span>name_nodes<span>[</span>var_name<span>]</span> <span>=</span> node

            
            <span>if</span> var_name <span>not</span> <span>in</span> self<span>.</span>unused_names<span>:</span>
                self<span>.</span>unused_names<span>[</span>var_name<span>]</span> <span>=</span> <span>True</span>

        <span>else</span><span>:</span>
            
            self<span>.</span>unused_names<span>[</span>var_name<span>]</span> <span>=</span> <span>False</span></code></pre><p>There&#39;s just one caveat: We can&#39;t just use this visitor on our entire file, as it won&#39;t find all unused variables. Here&#39;s a quick code example to demonstrate:</p><pre><code data-astro-raw=""><span>def</span> <span>func</span><span>(</span><span>)</span><span>:</span>
    var <span>=</span> <span>5</span>

var <span>=</span> <span>10</span>
<span>print</span><span>(</span>var<span>)</span></code></pre><p>Here, we would see <code data-astro-raw="">var</code> being used in the global scope. Because of that, the checker won&#39;t catch the unused <code data-astro-raw="">var</code> inside <code data-astro-raw="">func()</code>, if we only run it on the entire file. We actually want to run this checker on <em>every single function and class in the file</em>.</p><p>So that&#39;s exactly what we are going to do. We will write a checker that runs this checker inside it. Yeah, my mind was also blown when I realised I can run visitors inside visitors. But here&#39;s the plan: For every <code data-astro-raw="">ClassDef</code> and <code data-astro-raw="">FunctionDef</code>, we will run the above checker on them to find unused local variables, and we will also run it on the <code data-astro-raw="">Module</code> to find globally unused variables. Sounds good?</p><pre><code data-astro-raw=""><span>class</span> <span>UnusedVariableChecker</span><span>(</span>Checker<span>)</span><span>:</span>
    <span>def</span> <span>check_for_unused_variables</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>&#34;&#34;&#34;Find unused variables in the local scope of this node.&#34;&#34;&#34;</span>
        visitor <span>=</span> UnusedVariableInScopeChecker<span>(</span>self<span>.</span>issue_code<span>)</span>
        visitor<span>.</span>visit<span>(</span>node<span>)</span>

        
        <span>for</span> name<span>,</span> unused <span>in</span> visitor<span>.</span>unused_names<span>.</span>items<span>(</span><span>)</span><span>:</span>
            <span>if</span> unused<span>:</span>
                node <span>=</span> visitor<span>.</span>name_nodes<span>[</span>name<span>]</span>
                self<span>.</span>violations<span>.</span>add<span>(</span>Violation<span>(</span>node<span>,</span> <span><span>f&#34;Unused variable: </span><span><span>{</span>name<span>!r</span><span>}</span></span><span>&#34;</span></span><span>)</span><span>)</span>

    <span>def</span> <span>visit_Module</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        self<span>.</span>check_for_unused_variables<span>(</span>node<span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

    <span>def</span> <span>visit_ClassDef</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        self<span>.</span>check_for_unused_variables<span>(</span>node<span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

    <span>def</span> <span>visit_FunctionDef</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        self<span>.</span>check_for_unused_variables<span>(</span>node<span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span></code></pre><p>All that&#39;s left now, is to enable this checker in the <code data-astro-raw="">main</code> function:</p><pre><code data-astro-raw=""><span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    source_path <span>=</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span>

    linter <span>=</span> Linter<span>(</span><span>)</span>
    linter<span>.</span>checkers<span>.</span>add<span>(</span>SetDuplicateItemChecker<span>(</span>issue_code<span>=</span><span>&#34;W001&#34;</span><span>)</span><span>)</span>
    linter<span>.</span>checkers<span>.</span>add<span>(</span>UnusedVariableChecker<span>(</span>issue_code<span>=</span><span>&#34;W002&#34;</span><span>)</span><span>)</span>

    linter<span>.</span>run<span>(</span>source_path<span>)</span></code></pre><p>I&#39;ve also prepared a new test file, with some more variables:</p><pre><code data-astro-raw="">s <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>}</span>  
l <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    var <span>=</span> <span>5</span>  
    <span>for</span> item <span>in</span> l<span>:</span>
        methods <span>=</span> <span>{</span>
            <span>&#34;GET&#34;</span><span>,</span>
            <span>&#34;PUT&#34;</span><span>,</span>
            <span>&#34;POST&#34;</span><span>,</span>
            <span>&#34;DELETE&#34;</span><span>,</span>
            <span>&#34;PUT&#34;</span><span>,</span>  
        <span>}</span>
        <span>if</span> item <span>in</span> methods<span>:</span>
            <span>print</span><span>(</span>item<span>)</span>

s2 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>}</span>  
var <span>=</span> <span>7</span>
<span>print</span><span>(</span>var<span>)</span></code></pre><p>Alright, let&#39;s run it!</p><pre><code data-astro-raw="">$ python mylint.py test.py
test.py:1:0: W002: Unused variable: <span>&#39;s&#39;</span>
test.py:17:0: W002: Unused variable: <span>&#39;s2&#39;</span>
test.py:5:4: W002: Unused variable: <span>&#39;var&#39;</span>
test.py:17:15: W001: Set contains duplicate item: <span>1</span>
test.py:12:12: W001: Set contains duplicate item: <span>&#39;PUT&#39;</span></code></pre><p>It works! We did it, we&#39;ve built our own linter 🥳</p><p>If you&#39;ve made it all the way to this part of the post, congratulations. Even though I&#39;ve tried my best, I wouldn&#39;t be surprised if people still find this article too hard to follow. But, that&#39;s just the nature of code analysis -- it&#39;s hard. It took me 6 months of working with Python&#39;s AST every single day to be able to write this blog, so if you&#39;ve appreciated the work I&#39;d love to hear about it 🙌</p><h2 id="ast-utilities">AST utilities</h2><p>The AST module gives you a few other useful utility classes:</p><ul>
<li>
<p><code data-astro-raw="">ast.literal_eval</code> can be used as a safer alternative to <code data-astro-raw="">eval</code>, as <code data-astro-raw="">literal_eval</code> doesn&#39;t access the Python environment, and can only parse literal values, like <code data-astro-raw="">&#39;abc&#39;</code> or <code data-astro-raw="">&#34;{&#39;name&#39;: &#39;Mike&#39;, &#39;age&#39;: 25}&#34;</code>. But sometimes, that&#39;s all you need to evaluate, and it&#39;s infinitely safer than using <code data-astro-raw="">eval</code> for that.</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> ast<span>.</span>literal_eval<span>(</span><span>&#39;5&#39;</span><span>)</span>
<span>5</span>
<span>&gt;&gt;</span><span>&gt;</span> ast<span>.</span>literal_eval<span>(</span><span>&#34;{&#39;name&#39;: &#39;Mike&#39;, &#39;age&#39;: 25}&#34;</span><span>)</span>
<span>{</span><span>&#39;name&#39;</span><span>:</span> <span>&#39;Mike&#39;</span><span>,</span> <span>&#39;age&#39;</span><span>:</span> <span>25</span><span>}</span>
<span>&gt;&gt;</span><span>&gt;</span> your_password <span>=</span> <span>&#39;password123&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>eval</span><span>(</span><span>&#39;&#34;abc&#34; + your_password&#39;</span><span>)</span>  
<span>&#39;abcpassword123&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> ast<span>.</span>literal_eval<span>(</span><span>&#39;&#34;abc&#34; + your_password&#39;</span><span>)</span>  
ValueError<span>:</span> malformed node <span>or</span> string<span>:</span> <span>&lt;</span>ast<span>.</span>Constant <span>object</span> at <span>0x7f33a7cdaa90</span><span>&gt;</span></code></pre>
</li>
<li>
<p><code data-astro-raw="">ast.unparse</code> was added in Python 3.9, and can take an AST node and convert it back to source code.</p>
<p>Note that ASTs don&#39;t store all the information from a source file, so things like exact whitespace information, comments, use of single/double quotes etc. will be lost when you do this. But it still works:</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> code <span>=</span> <span>&#39;&#39;&#39;
... def x():
...   print(&#34;Hello&#34;)  # Some comment
... def y(): pass
... &#39;&#39;&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span>code<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>ast<span>.</span>unparse<span>(</span>tree<span>)</span><span>)</span>
<span>def</span> <span>x</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>&#39;Hello&#39;</span><span>)</span>

<span>def</span> <span>y</span><span>(</span><span>)</span><span>:</span>
    <span>pass</span></code></pre>
<p>Re-parsing an un-parsed AST again should generate the same AST.</p>
</li>
<li>
<p><code data-astro-raw="">ast.walk</code> takes in an AST node and returns a generator, that yields all of its children one by one, in no specific order.</p>
<pre><code data-astro-raw=""><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;&#39;&#39;
... while True:
...     x = &#39;hi&#39;
...     if len(x) == 2:
...         break
... &#39;&#39;&#39;</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>for</span> node <span>in</span> ast<span>.</span>walk<span>(</span>tree<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>&#39;Found&#39;</span><span>,</span> node<span>.</span>__class__<span>.</span>__name__<span>)</span>
<span>.</span><span>.</span><span>.</span>
Found Module
Found While
Found Constant
Found Assign
Found If
Found Name
Found Constant
Found Compare
Found Break
Found Store
Found Call
Found Eq
Found Constant
Found Name
Found Name
Found Load
Found Load</code></pre>
</li>
</ul><h2 id="what-about-code-formatters">What about code formatters?</h2><p>A little while ago I mentioned that ASTs don&#39;t contain certain information like whitespaces, comments, and quote styles. This is because ASTs are meant to be a representation of what the code <em>means</em>, not how the code looks. Anything that Python won&#39;t need to store to run the code, is stripped out.</p><p>Turns out, this is a huge problem if you want to create things like code formatters, which need to be able to produce the exact source code that was used to build the syntax trees. If you don&#39;t, everytime the code formatter runs on your file, the whole file will look completely different from how you wrote the code.</p><p>For such use cases, we need what is called a <strong>Concrete Syntax Tree</strong>, or CST. A CST is essentially just an AST which contains style information as well, such as where the newlines are, how many spaces are used for indentation, and so on.</p><p>If you need to build a code editor, formatter, or something of that sort for Python, I&#39;ll highly recommend <a href="https://github.com/Instagram/LibCST">libcst</a>. It&#39;s the best CST library for Python that I know of.</p><h2 id="where-can-i-learn-more">Where can I learn more?</h2><p>If you somehow still want to learn more about ASTs, then my first recommendation would be to read all of the <a href="https://docs.python.org/3/library/ast.html">documentation of the ast module</a>. Furthermore, you should also check out <a href="https://greentreesnakes.readthedocs.io/">greentreesnakes</a>, which was the original source of most of the code examples in the official tutorial today. There&#39;s a lot of material to read there.</p><p>One of the craziest parts about the <code data-astro-raw="">ast</code> module is that, even with all the amazing things it lets us do, the entire source code <code data-astro-raw="">ast.py</code> is just <a href="https://github.com/python/cpython/blob/main/Lib/ast.py">1700 lines of Python code</a>. It&#39;s a definite must-read if you want to dive deeper into ASTs.</p><p>The linter that I wrote can be found on <a href="https://github.com/tusharsadhwani/mylint">my github</a>. It can be thought of as an an extremely simplified version of <a href="https://github.com/pycqa/pylint">pylint</a>, one of the most popular linters in Python, which also has its own AST wrapper called <a href="https://github.com/pycqa/astroid">astroid</a>.</p><p>And with that, you&#39;ve reached the end of the article. I hope you find good use of this.</p>
    </main>
  </article></div>
  </body>
</html>
