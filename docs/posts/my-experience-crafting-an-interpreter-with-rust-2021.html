<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/">Original</a>
    <h1>My experience crafting an interpreter with Rust (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Last year I finally decided to learn some Rust. The <a href="https://doc.rust-lang.org/book/">official book </a>by Steve Klabnik and Carol Nichols is excellent, but even after reading it and working on some small code exercises, I felt that I needed more to really understand the language. I wanted to work on a small project to get some hands-on experience, but most of my ideas didn’t feel very well suited for Rust.</p>



<p>Then I started reading the amazing book <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> by Bob Nystrom. As the name suggests, the book is about writing an interpreter for a dynamic language named Lox. The book is split into two parts: the first one shows how to implement a simple tree-walking interpreter using Java. The second part shows how to implement the same interpreter, but this time using a high-performance bytecode VM using C. I implemented<a href="https://github.com/ceronman/cloxure"> the first part in Clojure</a>, and then I realized that the second part was the perfect project for trying Rust.</p>



<p>The domain of language VMs seems to be almost entirely dominated by C/C++.  VMs are very performance sensitive and often require a lot of micro-optimization. This project seemed like a perfect exercise to compare Rust against these languages. I was especially interested in checking if Rust could match the same speed while providing better safety and ergonomics.</p>



<p><em>Disclaimer: It’s been a long time since I used C/C++, probably more than 15 years. Even then, I mostly used these languages for university projects or some open source contributions. During my entire professional career, I have only used higher-level languages. Consider this post as coming from a beginner.</em></p>



<p>Now, matching the speed of the C version of the Lox interpreter (<em>clox</em>) is no easy feat. While many books on the topic of compilers and interpreters focus exclusively on explaining the algorithms and leave performance as an afterthought, Crafting Interpreters shows how to implement a really fast interpreter. For example, in some simple benchmarks, it is common to observe that <em>clox</em> is 2x or even 3x faster than equivalent Python or Perl code.</p>



<p><em>Side note: Take this comparison with a grain of salt. The reason Python and Perl are slower is that these languages provide more flexibility and that comes with a performance cost. This is better explained in </em><a href="https://wren.io/performance.html"><em>Wren’s web page</em></a><em>, which is another language by the same author whose interpreter inspired clox. So yes, the comparison with Python and Perl is a bit oranges and apples, but the main point here is that clox performance is really good and very production-ready.</em></p>



<h2>Using only safe code</h2>



<p>When I began coding my Rust implementation of Lox, I decided to stick to purely safe code. Rust’s main selling point is its safety, but of course you have to stick to the safe part of the language. Rust also allows you to use unsafe code, and if you do that, I think there is no blocker to match the speed of C, although that also means matching its unsafety. It made sense to stick to safe code to begin with.</p>



<p>I also decided to take advantage of Rust standard library as much as possible. One more interesting fact about <em>Crafting Interpreters</em> is that it does everything from scratch. The book doesn’t use libraries or parser generators or any tool besides a C compiler and standard library (which is pretty bare-bones). Every single line of code is in the book and I find this absolutely amazing. So there are some chapters dedicated to showing how to write dynamic arrays, strings, and hash maps. Given that Rust’s standard library already has those and they are very optimized, I decided to use them and skip a custom implementation. Besides, implementing those manually most likely requires writing unsafe code.</p>



<p>I also wanted to take advantage of Rust’s advanced type system as much as possible. The <em>clox</em> implementation uses variable-length opcodes where most of them use one byte but some use adjacent bytes to pack parameters or data. In my implementation, I decided to use fixed-length opcodes using an <code>enum</code>. Rust’s sum types are a delight to use because the compiler always has your back and warns you if you ever forget to check for a specific case. I consider this a huge advance in ergonomics.</p>



<p>The beginning of writing the lox interpreter in Rust was a breeze. The compiler in particular was a joy to write. Rust felt much nicer to write than the old and quirky C. The initial parts of the VM were also really nice to write thanks to sum types, compile-time checks, and a ready-to-use standard library. However, things started to get very tricky once I worked on more advanced stuff such as closures and classes. The <em>clox</em> implementation uses pointers and aliasing very liberally, while Rust’s aliasing rules are very strict and the borrow checker disallows many patterns to ensure safety. Because of this, I spent a ton of time finding workarounds to make the borrow checker happy.</p>



<p><em>Side note: Dealing with the borrow checker is a well-known struggle for Rust beginners. This was the reason why I spent so much time here. The rules are simple but for some reason, it’s really hard to keep track of them in a big system. I would often write huge refactorings thinking that they would be a solution to a borrow checker error, just to get another one at the end of the refactoring. This happens less frequently the more experience I get with the language, but it still happens. The book </em><a href="https://rust-unofficial.github.io/too-many-lists/"><em>Learn Rust With Entirely Too Many Linked Lists</em></a><em>  has some good examples of how brutally complex the borrow checker can be.</em></p>



<h2>A garbage collector in safe Rust</h2>



<p>By far the hardest part to implement in my safe Rust implementation of Lox was the garbage collector. How do you even write a GC without manual memory allocation and deallocation? I spent quite some time experimenting and trying different approaches.</p>



<p>One quick idea that crossed my mind was that perhaps I could skip the GC completely. If Rust can be memory safe without GC, perhaps I could use the same mechanisms to do the same for Lox. For example, using reference counted smart pointers. But I quickly discarded this idea. The Lox language doesn’t have the strict rules that Rust has; it’s easy to create cyclic data structures that would leak memory if implemented using reference counting. A GC is a must here.</p>



<p>So I got an idea from a<a href="https://www.youtube.com/watch?v=aKLntZcp27M&amp;t=1960s"> very interesting talk at RustConf 2018 by Catherine West</a>. A common workaround in the Rust world to deal with graph-like structures with cycles is to use vector indices as some sort of pointer. I decided to study the code of some popular crates such as <a href="http://id-arena">id-arena</a> and <a href="https://crates.io/crates/typed-arena">typed-arena</a> that use this concept in some way. But the main issue with <em>id-arena</em> is that it doesn’t support deletion of individual objects because there is the risk of running into <a href="https://en.wikipedia.org/wiki/ABA_problem">the ABA problem</a>. This happens when you delete an object and later reuse its slot while there is a live reference somewhere, which will then be pointed to the wrong place in the vector. There are ways to solve this issue, such as using a <a href="https://crates.io/crates/generational-arena">generational arena</a>, but this felt like over-complicating things.</p>



<p>One day I realized something that now feels so obvious that I’m almost ashamed to admit it: I am writing a garbage collector and its main job is to find objects with no references from the live parts of the program. This means that, if my GC works correctly, I should not worry about the ABA problem at all, because the GC would ensure that there will be no live references of the freed objects.</p>



<p>With this idea in mind, I ended up with a very simple design for a GC in safe Rust. It’s basically a vector of trait objects. Every object should implement a trait (<code>GcTrace</code>), which has methods for tracing an object. Additionally, there is a second vector that contains <em>tombstones</em> to keep track of the deleted objects. The allocation of an object means adding it to the vector and returning the index which will act as some sort of pointer. Freeing an object means swapping it out of the vector and putting some placeholder instead, and adding the index to the list of tombstones that will be reused in a future allocation.</p>



<p>Instead of returning plain integers, I also created a generic wrapper struct to get some type safety, so that if I allocate objects of different types, the result index is also of a different type. This is very similar to what the <em>id-arena</em> crate does. This result index is <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a>, which means that I can pass it around as I want without getting nagged by the borrow checker. This also facilitated the design of the interpreter quite a lot, as I was able to get rid of many workarounds that I added to please the borrow checker such as using <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> and <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>. In the end, using the GC looks like this:</p>



<!-- HTML generated using hilite.me --><div><pre><span>// creates an object</span>
<span>let</span> closure: GcRef&lt;Closure&gt; = gc.alloc(Closure { <span>/*…*/</span> }); 
</pre></div>



<p>Then I can copy and pass around this closure reference everywhere, but when I actually need to do something with the object, I can borrow it from the garbage collector. For example:</p>



<!-- HTML generated using hilite.me --><div><pre><span>let</span> upvalues = gc.deref(closure).upvalues;
</pre></div>



<p>This de-reference dance is a bit unergonomic. I have to call <code>gc.deref()</code> every time I want to work with any GC object. I thought that perhaps I could implement <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> and make the Rust compiler do it automatically for me, but this would require each <code>GcRef</code> object to hold a reference to the GC and dealing with the lifetimes would be a nightmare. I could also make the GC completely static, but I don’t even know how to do that with safe Rust only, so I decided to just live with it.</p>



<p>This GC design is extremely simple and it has a bunch of shortcomings. One of them is the fact that the memory needed for the vector of trait objects and the tombstones never shrinks. So if a program suddenly allocates a lot of objects and those are then freed by the GC, the space required for the slots remains there forever. Another shortcoming has to do with when to run the collection process. The GC in <em>clox</em> has precise control of every allocation, and there is a count of the number of the total bytes allocated. When this count reaches some threshold, the collection process runs. In my Rust GC, I can’t have a precise count of the number of bytes allocated because objects often have dynamically sized fields such as strings or vectors. As a workaround, I added a <code>size()</code> method to the <code>GcTrace</code> trait to estimate the size of an object and use it to keep count of the allocated bytes. But this is just an approximation.</p>



<p>Once I was done with the GC, the remaining parts of the Lox interpreter were easy to write. I ended up with a <a href="https://github.com/ceronman/loxido">Lox implementation written in 100% safe Rust</a> code and passing the 243 tests from the Lox integration test suite.</p>



<h2>Performance</h2>



<p>After having a working Lox interpreter and a green test suite to validate any change, it was time to start working on improving performance. At this point I had already abandoned any hope of matching the speed of <em>clox</em> with only safe Rust. As I mentioned before, <em>clox</em> is a really fast implementation and it uses all sorts of tricks to achieve this. From using pointer arithmetic without any runtime checks to the super tricky <a href="https://brionv.com/log/2018/05/17/javascript-engine-internals-nan-boxing/">NaN boxing</a>. However, I thought that if I added a few unsafe blocks to my code base, I could at least come close to the speed of <em>clox</em>.</p>



<p>The first step is, of course, measuring the performance. I decided to use the <a href="https://github.com/munificent/craftinginterpreters/tree/master/test/benchmark">same benchmark programs available in the crafting interpreters repository</a>. This way of measuring might not be the best, but it’s good enough for a language without any real-world programs. I also decided to manually transpile the benchmark programs to Python and Perl to have some point of comparison. I was expecting some bad results for my very first implementation, but they were much worse than I anticipated:</p>



<figure><a href="https://ceronman.files.wordpress.com/2021/07/image-2.png"><img data-attachment-id="590" data-permalink="https://ceronman.com/image-2/" data-orig-file="https://ceronman.files.wordpress.com/2021/07/image-2.png" data-orig-size="1742,2018" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.files.wordpress.com/2021/07/image-2.png?w=259" data-large-file="https://ceronman.files.wordpress.com/2021/07/image-2.png?w=884" src="https://ceronman.files.wordpress.com/2021/07/image-2.png?w=884" alt="" srcset="https://ceronman.files.wordpress.com/2021/07/image-2.png?w=884 884w, https://ceronman.files.wordpress.com/2021/07/image-2.png?w=129 129w, https://ceronman.files.wordpress.com/2021/07/image-2.png?w=259 259w, https://ceronman.files.wordpress.com/2021/07/image-2.png?w=768 768w, https://ceronman.files.wordpress.com/2021/07/image-2.png 1742w" sizes="(max-width: 884px) 100vw, 884px"/></a></figure>



<p>Not only is <em><a href="https://github.com/ceronman/loxido">Loxido</a></em> (my implementation) often several times slower than <em>clox</em>, but, in many cases, it’s even slower than <em>jlox</em> (the tree walking implementations written in Java)! After the initial shock, I realized that there was no other way than to start profiling and shave those times as much as possible.</p>



<p>The very first run of <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> showed me a clear target to blame for my poor performance:</p>



<figure><a href="https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png"><img data-attachment-id="588" data-permalink="https://ceronman.com/screenshot-from-2021-05-08-17-32-48-1/" data-orig-file="https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png" data-orig-size="2000,2186" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="screenshot-from-2021-05-08-17-32-48-1" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=274" data-large-file="https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937" src="https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937" alt="" srcset="https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937 937w, https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=1874 1874w, https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=137 137w, https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=274 274w, https://ceronman.files.wordpress.com/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=768 768w" sizes="(max-width: 937px) 100vw, 937px"/></a></figure>



<p>One of the problems was related to my GC implementation and the way I was dereferencing my index-based pointers. Using vector indices is slower than a regular pointer dereference. An arithmetic operation is needed to get the address of the element, but more importantly, Rust will always check if the index is out of bounds. For the vast majority of use cases, these extra steps are completely negligible, however when you have a VM that processes ~350 million instructions per second, and then you have to do three or four dereferences per instruction, then it shows. But even then, this was not the main problem. The big problem was with some of the workarounds that I had to add to please the borrow checker. I’ll try to explain this:</p>



<p>The core of a VM is basically a huge loop that increments the <em>program counter</em> (PC), grabs the next instruction and runs a big <code>match</code> expression. The PC is part of the current frame. The current frame has a reference to a closure object, which has a reference to a function object, which then has a reference to the chunk of bytecode that contains the instructions. In code it roughly looks like this:</p>



<!-- HTML generated using hilite.me --><div><pre><span>loop</span> {
    <span>let</span> <span>mut</span> frame = self.frames.last_mut().unwrap();
    <span>let</span> closure = self.gc.deref(frame.closure);
    <span>let</span> function = self.gc.deref(closure.function);
    <span>let</span> chunk = &amp;function.chunk;
    <span>let</span> instruction = chunk.code[frame.ip];
    frame.ip += 1;
    <span>match</span> instruction {
        ...
    }
}
</pre></div>



<p>The first part of the loop is what was causing the problem. However, I don’t really need to do this on every single iteration. For most instructions, the active frame and chunk of bytecode remains the same. The current frame only changes when a function is invoked or when the current function returns. I could store this in a local variable as a reference and change it only on those instructions, for example:</p>



<!-- HTML generated using hilite.me --><div><pre><span>let</span> <span>mut</span> frame = self.frames.last_mut().unwrap();
<span>let</span> closure = self.gc.deref(frame.closure);
<span>let</span> function = self.gc.deref(closure.function);
<span>let</span> <span>mut</span> chunk = &amp;function.chunk;
<span>loop</span> {
    <span>let</span> instruction = chunk.code[frame.ip];
    frame.ip += 1;
    <span>match</span> instruction {
        Instruction::Call =&gt; {
            <span>// update frame and chunk</span>
        }
    }
}
</pre></div>



<p>This would increase the speed considerably. But there is a problem: Rust is not very happy about it. The way my implementation works is that the GC owns every object created. If I need an object, I could borrow it, and while I borrow it I’m also borrowing the whole GC. Because of Rust’s aliasing rules, if I decide to have a long-lived reference to the current chunk of byte code, I won’t be able to ever borrow mutably from the GC. So this causes a ton of borrow checker complaints. That’s why I ended up returning every borrow immediately. But this implies a ton of unnecessary dereferences.</p>



<p><em>Side note: A similar issue with the borrow checker that I often encountered is the one of interprocedural conflicts. There is a nice </em><a href="http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/"><em>blog post by Niko Matsakis</em></a><em> explaining this problem. I would love to see Rust improving in this area, as I see it as a major headache for beginners.</em></p>



<p>I tried quite some different approaches to work around this with safe Rust, but I failed on every single one of them. This was often frustrating because it required long refactorings and it was only until the end that I realized that it doesn’t work. </p>



<p>A simpler solution was to use raw pointers instead of references. This is easy to implement but requires unsafe blocks to dereference those two pointers. I ended up doing that and improvement was massive, with some benchmarks taking up to 74% less time.</p>



<p>After doing this I also decided to rewrite the GC and make the references wrap raw pointers instead of vector indices. This also required some unsafe code, but it also came with some nice speed improvements. And even better, it allowed me to get rid of a lot of boilerplate code because I could finally use <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a>. So instead of doing things like</p>



<!-- HTML generated using hilite.me --><div><pre><span>let</span> closure = self.gc.deref(frame.closure);
<span>let</span> function = self.gc.deref(closure.function);
<span>let</span> chunk = &amp;function.chunk;
</pre></div>



<p>I could simply:</p>



<!-- HTML generated using hilite.me --><div><pre><span>let</span> chunk = frame.closure.function.chunk;
</pre></div>



<p>This simplified a lot of code, and after these changes, my benchmarks improved considerably:</p>



<figure><a href="https://ceronman.files.wordpress.com/2021/07/image-3.png"><img data-attachment-id="596" data-permalink="https://ceronman.com/image-3/" data-orig-file="https://ceronman.files.wordpress.com/2021/07/image-3.png" data-orig-size="1742,2018" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.files.wordpress.com/2021/07/image-3.png?w=259" data-large-file="https://ceronman.files.wordpress.com/2021/07/image-3.png?w=884" src="https://ceronman.files.wordpress.com/2021/07/image-3.png?w=884" alt="" srcset="https://ceronman.files.wordpress.com/2021/07/image-3.png?w=884 884w, https://ceronman.files.wordpress.com/2021/07/image-3.png?w=129 129w, https://ceronman.files.wordpress.com/2021/07/image-3.png?w=259 259w, https://ceronman.files.wordpress.com/2021/07/image-3.png?w=768 768w, https://ceronman.files.wordpress.com/2021/07/image-3.png 1742w" sizes="(max-width: 884px) 100vw, 884px"/></a></figure>



<p>I was still far from the speed of <em>clox</em>, but at least I was already better than <em>jlox</em> and very close to Python and Perl.</p>



<h2>Improving HashMap performance</h2>



<p>The next thing that showed up in the profiler was <code>HashMap</code> operations. This was kind of expected. Like most dynamic languages, Lox uses hash tables heavily. They’re used to store global variables, interning strings, fields and methods. Any improvement in this area will definitely have a huge impact on the overall performance of the interpreter. In fact, the last chapter of the book, which is dedicated to optimizations, shows how a tiny change in the hash table code allows to shave up to 42% of the running time of a benchmark. That was impressive.</p>



<p>The easiest thing to try was to change the hashing algorithm. The <code>HashMap</code> implementation in Rust’s standard library uses <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> by default, while <em>clox</em> uses <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV</a>. I knew that <em>SipHash</em> is not that fast, so I thought I could get some easy wins replacing it. In Rust it’s very easy to switch hash function implementations. Just use a different constructor and the rest of the code remains intact.</p>



<p>I found a Rust <a href="https://crates.io/crates/fnv">crate</a> that implements the FNV algorithm, but I also found one called <a href="https://crates.io/crates/ahash">aHash</a> which claims to be “the fastest, DOS resistant hash currently available in Rust”. I tried both and indeed <em>aHash</em> gave better results.</p>



<p>With this tiny change I was able to shave up to 45% of the running time of some of the benchmarks. That’s super amazing for such a small change.</p>



<p>Later I found out that the Rust compiler uses another hashing algorithm called <a href="https://crates.io/crates/fxhash">fxhash</a>. Even though <em>aHash</em> claims to be faster than <em>fxhash</em>, given how easy it is to switch algorithms, I decided to try it. I was surprised to find improvements on all of the benchmarks. In some cases shaving up to 25% of time from the <em>aHash</em> results!</p>



<p><em>Side note: Don’t get super excited about these results. There is a very good reason why Rust uses SipHash by default. Algorithms such as FNV and fxhash are prone to </em><a href="https://en.wikipedia.org/wiki/Algorithmic_complexity_attack"><em>algorithmic complexity DOS attacks</em></a><em>. It’s probably not a good idea to use them for an interpreter. But given that this is not a real-world language, and I’m trying to match clox speed using FNV, I decided to ignore this fact for the moment. aHash, however, claims to be DOS resistant, which might be a very interesting option for a real language.</em></p>



<p>The improvements of switching hash function were quite significant. However, the profiler kept showing some performance bottlenecks caused by hash table operations. I also profiled <em>clox</em> and I found out that hash operations were not taking that much time there. I had to investigate more.</p>



<p>Rust’s standard library is using a very sophisticated hash map implementation called <a href="https://github.com/rust-lang/hashbrown">HashBrown</a>. This is a port of <a href="https://abseil.io/about/design/swisstables">Google’s SwissTables</a>, a high-performance hash map implementation in C++. It even uses SIMD instructions to scan multiple hash entries in parallel. How could I ever improve on that? This seemed completely impossible.</p>



<p>So I decided to re-read the chapter of Crafting Interpreters dedicated to hash tables to see if I was missing any tricks. And this was the case indeed!</p>



<p>Unlike <em>HashBrown</em>, which is a general-purpose hash table implementation, the hash table in <em>clox</em> is tailored for a very specific use case. While <em>HashBrown</em> is generic, <em>clox</em>‘s <code>Table</code> only uses Lox strings as keys and Lox values as values. Lox strings are immutable, interned, and they can cache their own hashes. This means that hashing only occurs once ever for each string and comparison is as fast as comparing two pointers. Additionally, not dealing with generic types has the advantage of ignoring type system edge cases such as <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Data Types</a>.</p>



<p>So I decided to bite the bullet and write my own hash map implementation in Rust closely following the code from <em>clox</em>. The results were very positive, I was able to shave time on most of the benchmarks, with a cut of 44% for the best case compared to <em>HashBrown</em> with <em>fxhash</em>. In the end, it was not a lot of code either. My hash map implementation is roughly 200 lines of mostly unsafe Rust.</p>



<p><em>Side note: Before writing my own hash table, I tried to mimic the same special conditions of clox tables using HashBrown. For example, I implemented PartialEq on GcRef&lt;String&gt; to ensure that the comparison of interned strings were done by comparing pointers. And I also implemented my own caching hash function based on fxhash. But these efforts didn’t show any significant results. The simplicity of the clox hashmap implementation is just fast!</em></p>



<h2>The price of dynamic dispatch</h2>



<p>I was getting closer to the speed of <em>clox</em>, but there was a long way to go. One thing I noticed is that the time difference was much bigger in the benchmarks that ended up stressing the GC. The profiler showed that the tracing part of the garbage collection process was taking quite a lot of time.</p>



<p>As I mentioned before, I used trait objects to keep track of anything that should be garbage collected. I copied this idea from crates such as <a href="https://crates.io/crates/gc">gc</a> and <a href="https://crates.io/crates/gc-arena">gc_arena</a>. Using a trait object allowed me to keep a list of all the objects, which is necessary for the sweeping process. The trait also would contain methods for tracing an object. Each object type had different ways of tracing. For example, a string should only mark itself, but an object instance should mark itself and its fields. Each garbage collected type should implement the <code>GcTrace</code> trait with the specific logic to trace it. Then, thanks to polymorphism, the tracing part of the garbage collector was as simple as this:</p>



<!-- HTML generated using hilite.me --><div><pre><span>fn</span> trace_references(&amp;<span>mut</span> self) {
    <span>while</span> <span>let</span> Some(object) = self.grey_stack.pop() {
        object.trace(self);
    }
}
</pre></div>



<p>As usual with polymorphism, this was short and elegant. I liked it a lot. However, there was a problem: This kind of polymorphism uses <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">dynamic dispatch</a>, which has a cost. In this particular case, the compiler is unable to inline the tracing functions, so every single trace of an object is a function call. Again, this is usually not a big problem, but when you have millions of traces per second, it shows. In comparison, <em>clox</em> was simply using a <code>switch</code> statement. This is less flexible but the compiler inlines it tightly which makes it really fast.</p>



<p>So instead of using a trait object, I rewrote the GC to use an <code>enum</code> instead. Then I wrote a <code>match</code> expression that would do the right tracing logic for each type. This is a bit less flexible, and it also wastes memory because the <code>enum</code> effectively makes all objects use the same space. But it also improved tracing speed considerably with up to 28% less time for the most problematic benchmark.</p>



<p><em>Side note: clox uses a different approach called </em><a href="https://craftinginterpreters.com/strings.html#struct-inheritance"><em>Struct Inheritance</em></a><em>. There is a struct that acts as a header and contains meta-information about each object. Then each struct that represents an object managed by the GC has this header as its first field. Using </em><a href="https://en.wikipedia.org/wiki/Type_punning"><em>type punning</em></a><em>, it’s possible to cast a pointer to the header to a specific object and vice versa. This is possible because in C structs are laid out in the same order as defined in the source. Rust by default doesn’t guarantee the order of the data layout, so this technique is not possible. There are ways to tell the Rust compiler to use the same data layout as C, which is used for compatibility, but I wanted to stay with Rust as intended.</em></p>



<h2>Small unsafety speedups</h2>



<p>There were other small details that made <em>clox</em> faster and were related to avoiding safety checks. For example, the stack in <em>clox</em> is represented by a fixed-size array and a pointer that indicates the top of the stack. No underflow or overflow checks are done at all. In contrast, in my Rust implementation, I was using a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a> and the standard <code>push()</code> and <code>pop()</code> operations which are, of course, checked. I rewrote the stack code to use a similar approach as <em>clox</em> and I was able to shave up to 25% of the running time.</p>



<p>Similarly, the program counter in <em>clox</em> is represented as a C pointer to the next instruction in the bytecode array. Increasing the PC is done with pointer arithmetic and no checks. In my Rust implementation, the PC was an integer with the index in the position in the bytecode chunk vector. Changing this to work as <em>clox</em> allowed me to shave up to 11% from the running time.</p>



<p>Getting speed-up improvements is nice, but the downside is that the code becomes unsafe. One of the best parts of Rust is its safety, and if you abandon it, it feels as dangerous like C but a bit uglier. But at least it’s nice that you can be very specific about what parts of your code are unsafe, this makes it much easier to debug when things go wrong.</p>



<p><em>Side note: How can clox live with all these unchecked pointer arithmetic? Well, the VM assumes that the bytecode will always be correct. The VM is not supposed to take any arbitrary bytecode, but only bytecode generated by the compiler. It’s the compiler’s responsibility to produce correct bytecode that would not cause underflows or overflows of the stack or frames. While the clox compiler does prevent a lot of these cases, it does not prevent stack overflows. The author intentionally decided to skip this check because it would require a lot of boilerplate code. Real-world interpreters using unsafe structures like these must absolutely do it though.</em></p>



<p>After the tweaks, my Rust implementation finally started to get really close to <em>clox</em>:</p>



<figure><a href="https://ceronman.files.wordpress.com/2021/07/image-5.png"><img data-attachment-id="602" data-permalink="https://ceronman.com/image-5/" data-orig-file="https://ceronman.files.wordpress.com/2021/07/image-5.png" data-orig-size="1742,2018" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-5" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.files.wordpress.com/2021/07/image-5.png?w=259" data-large-file="https://ceronman.files.wordpress.com/2021/07/image-5.png?w=884" src="https://ceronman.files.wordpress.com/2021/07/image-5.png?w=884" alt="" srcset="https://ceronman.files.wordpress.com/2021/07/image-5.png?w=884 884w, https://ceronman.files.wordpress.com/2021/07/image-5.png?w=129 129w, https://ceronman.files.wordpress.com/2021/07/image-5.png?w=259 259w, https://ceronman.files.wordpress.com/2021/07/image-5.png?w=768 768w, https://ceronman.files.wordpress.com/2021/07/image-5.png 1742w" sizes="(max-width: 884px) 100vw, 884px"/></a></figure>



<p>For most benchmarks, the running time of <em>loxido</em> is between 20% and 50% more than <em>clox</em>. It’s close, but not entirely satisfactory. Unfortunately, I reached a point where profiling my existing benchmarks doesn’t give me clear information about what parts of the code are making <em>loxido</em> slower.</p>



<p>I probably need to write some more targeted benchmarks. And I should start looking for clues beyond the profiler data, such as checking for cache misses, branch mispredictions and taking a look at the generated machine code. But this goes beyond my available time and knowledge, so I decided to leave <em>loxido</em> as it is here.</p>



<p>I have a few hunches of things that could improve performance. One is using struct inheritance to represent GC objects instead of using an <code>enum</code>. This would require changing the data layout of the structs to match C. The problem with using an <code>enum</code> is that a <code>match</code> operation is required on every dereference. I believe this <code>match</code> should be optimized out by the compiler, but I haven’t properly checked. But even then, struct inheritance is simpler and it will require fewer instructions in many places.</p>



<p>The second hunch is that perhaps using variable-length instructions might end up in a tighter bytecode that produces better cache utilization. I feel this is unlikely as the byte code is usually so small that I find it hard that this makes any difference. But I would like to have the time to test it anyway.</p>



<p>I also considered the fact that I compiled <em>clox</em> using GCC 10.3.1, while Rust 1.51.0 uses LLVM. I tried compiling <em>clox</em> using <a href="https://clang.llvm.org/">clang</a> instead and indeed some benchmarks took up to 15% more time. But a few others were faster than the GCC version. So I discarded this as a big factor. My Rust implementation is consistently slower on all the benchmarks.</p>



<p>One more thing to consider was the impact of the <a href="https://brionv.com/log/2018/05/17/javascript-engine-internals-nan-boxing/">NaN boxing optimization</a>. Which I had zero plans to implement in Rust. I compiled <em>clox</em> without NaN boxing and compared the results. It almost made no difference. There were time variations of +- 5% across the benchmarks. So I don’t think this is a factor at all.</p>



<h2>Final Thoughts</h2>



<p>I enjoyed writing Rust very much and learning how to write a language VM with it. <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> is one of the most amazing technical books that I have ever read, I totally recommend it.</p>



<p>Rust can be frustrating sometimes, that’s undeniable. But Rust is also very rewarding. Besides the modern features in the language and its great tooling, I find the Rust community to be awesome. I know the hype can be annoying sometimes, especially when fans feel the need to jump into every single discussion to evangelize about the language, but, for the most part, the hype has a lot of positive things. The Rust community is vibrant, people are sharing knowledge all the time in the form of blog posts, discussions, tools, and libraries. The community is also very beginner-friendly, with tons of people willing to help even when the question has been repeated a thousand times in multiple places.</p>



<p>In some areas, Rust feels a bit half-baked. For example, dealing with variance in the type system is confusing and feels very hacky. The new allocator API is not there yet, which would have been very useful when writing my GC. And I think the borrow checker could be smarter in many cases. I would like to write in more detail about these things, but this post is already too long. Nevertheless, I think the language has very good prospects of improving and I’m glad the creators are not afraid of the language not being perfect. I look forward to keeping writing Rust and learning about it.</p>



<p>This is it! Thanks for reading!</p>
	</div></div>
  </body>
</html>
