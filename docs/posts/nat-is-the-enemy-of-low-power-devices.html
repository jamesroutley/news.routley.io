<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.golioth.io/nat-is-the-enemy-of-low-power-devices/">Original</a>
    <h1>NAT Is the Enemy of Low Power Devices</h1>
    
    <div id="readability-page-1" class="page"><div data-td-block-uid="tdi_75">

<div><p>If you have ever tried communicating with a device on a private network, you may have encountered <a href="https://en.wikipedia.org/wiki/Network_address_translation">Network Address Translation (NAT)</a>. Fundamentally, when one device needs to send data to another device, it needs to know how to address it. On <a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP-based networks</a>, devices are addressed using an IP address. Unfortunately, the number of connected devices has long outpaced the number of unique addresses in the <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> address space. Because of this, public IP addresses have to be shared between devices, which causes a few problems.</p>
<h2>How to Share an IP Address</h2>
<p>You probably accessed this blog post from a machine that does not have a public IP address. Rather, it has been assigned a private IP address on a network, perhaps via the <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Dynamic Host Configuration Protocol (DHCP)</a>, and it talks to a router that is responsible for sending data to and from the device. To access this post, your device first had to use the <a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System (DNS</a>) to map a public IP address to <code>blog.golioth.io</code>, then had to send a request to that IP address for the content of this page.</p>

<p><img fetchpriority="high" decoding="async" src="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1.png" alt="NAT - Device to Cloud" width="1920" height="1080" srcset="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1.png 1920w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1-320x180.png 320w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1-650x366.png 650w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1-768x432.png 768w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1-1536x864.png 1536w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1-1500x844.png 1500w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-1-6-1-705x397.png 705w" sizes="(max-width: 1920px) 100vw, 1920px"/></p>
<p>When that request arrives at a router or some other intermediary, it knows where to deliver the request because the IP address of the server hosting <code>blog.golioth.io</code> is specified. It forwards the request along, and the server responds with the requested content. However, the server does not know that your device sent the request. The router has replaced the private IP address and port from your device with its own public IP address and port, and it has made an entry in a translation table noting that incoming data for that port should be directed to your device. The server sends the content back to the router, which replaces its own public IP address and port with your device’s IP address and port, then forwards it along. The content arrives at your device, appearing as though the server sent it directly to you. Meanwhile, the router is doing the same song and dance for many other devices, maintaining all of the mappings from its own IP address and ports to internal IP addresses and ports. This is known as <strong>Network Address Translation (NAT)</strong>.<!-- notionvc: 09a688ad-6069-4a87-bf90-e05ec263b72d --></p>
<p><img decoding="async" src="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1.png" alt="NAT - Cloud to Device" width="1920" height="1080" srcset="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1.png 1920w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1-320x180.png 320w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1-650x366.png 650w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1-768x432.png 768w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1-1536x864.png 1536w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1-1500x844.png 1500w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-2-4-1-705x397.png 705w" sizes="(max-width: 1920px) 100vw, 1920px"/></p>
<h2><a href="#what-could-go-wrong" aria-hidden="true" id="what-could-go-wrong"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What Could Go Wrong?</h2>
<p>This works great in simple request-response scenarios like fetching a blog post from a server with a public IP address. However, what if the server wants to say something to the device before the device talks to it? The server may know the public IP address of the router, but the router has no way of knowing which device the message is actually intended for. There is no entry in the NAT translation table until an <em>outgoing</em> message creates one. This also becomes a problem in peer-to-peer scenarios, where both devices are on a private network, making it such that neither device can talk to the other (this is solved using a public rendezvous point, such as a <a href="https://en.wikipedia.org/wiki/STUN">STUN server</a>, but that’s a story for another post).</p>

<p><img decoding="async" src="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1.png" alt="NAT - Cloud to Device, Cloud Initiates" width="1920" height="1080" srcset="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1.png 1920w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1-320x180.png 320w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1-650x366.png 650w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1-768x432.png 768w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1-1536x864.png 1536w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1-1500x844.png 1500w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-3-6-1-705x397.png 705w" sizes="(max-width: 1920px) 100vw, 1920px"/></p>
<p>Another problem is that routers don’t want to maintain mappings forever. At some point if no outgoing messages have been observed, the entry will be removed from the translation table and any subsequent incoming traffic will be dropped. In many cases, this timeout is quite aggressive (e.g. 5 minutes or less). Typically this is resolved by sending “keep alive” messages, ensuring that entries are not removed and data can flow freely in both directions. For your laptop or a server in a data center that might work fine for the most part. For highly constrained devices, it can quickly drain battery or consume precious limited bandwidth.</p>
<p><img loading="lazy" decoding="async" src="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1.png" alt="NAT - Cloud to Device Timeout" width="1920" height="1080" srcset="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1.png 1920w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1-320x180.png 320w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1-650x366.png 650w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1-768x432.png 768w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1-1536x864.png 1536w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1-1500x844.png 1500w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-6-4-1-705x397.png 705w" sizes="(max-width: 1920px) 100vw, 1920px"/></p>
<p>Maybe you decide that its okay for incoming traffic to be dropped after some period of time, as long as when you next contact the server you are able to re-establish a mapping and fetch any data that you need. Unfortunately, there is no guarantee that the router, or any other layer in the hierarchy of intermediaries performing NAT (it’s actually much more complicated, with <a tabindex="0" href="https://en.wikipedia.org/wiki/Carrier-grade_NAT" rel="noopener noreferrer" data-token-index="1"><span>Carrier-Grade NAT</span></a> adding even more translation steps), will assign you the same public IP address and port. Therefore, when you try to continue talking to the server over a previously established session, it will not recognize you. This means you’ll have to re-establish the session, which typically involves expensive cryptographic operations and sending a handful of messages back and forth before actually delivering the data you were interested in sending originally.<!-- notionvc: 4bf46849-889d-49ea-a057-fd8677f72f16 --></p>
<p><img loading="lazy" decoding="async" src="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1.png" alt="NAT - Device to Cloud, New Session" width="1920" height="1080" srcset="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1.png 1920w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1-320x180.png 320w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1-650x366.png 650w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1-768x432.png 768w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1-1536x864.png 1536w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1-1500x844.png 1500w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-4-4-1-705x397.png 705w" sizes="(max-width: 1920px) 100vw, 1920px"/></p>
<p>The worst case scenario is that your device needs to send data somewhat frequently, but not frequently enough that NAT mappings are maintained. For example, if a device needs to send a tiny sensor reading every 30 minutes, and the NAT timeout is 5 minutes, it will either need to send a keep alive message every 5 minutes (that’s 5x the messages you actually need to send!), or it will need to re-establish the session every time it delivers a reading. In both cases, you are going to be using much more power than if you were just able to send your sensor reading alone every 30 minutes.</p>
<h2><a href="#solving-the-problem" aria-hidden="true" id="solving-the-problem"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solving the Problem</h2>
<p>Unfortunately, the distributed nature of the internet means that we aren’t going to be able to address the issue by nicely asking carriers and ISPs to extend their NAT timeouts. However, we <em>can</em> make it such that being issued a new IP address and port doesn’t force us to re-establish a session.</p>
<p>More than a year ago, we <a href="https://blog.golioth.io/golioth-announces-connection-id-support/">announced support</a> for DTLS 1.2 Connection IDs. DTLS provides a secure transport over UDP, which many devices, especially those that are power constrained, use to communicate with Golioth’s CoAP device APIs. Typically, DTLS sessions are established based on a “five tuple”: source address, source port, transport protocol, destination address, destination port. If any of these change, a handshake must be performed to establish a new session. To mitigate this overhead, a Connection ID can be negotiated during the initial handshake, and can be used in subsequent records to continue to associate messages even after changes in source IP or port.</p>

<p><img loading="lazy" decoding="async" src="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1.png" alt="NAT - DTLS Connection ID" width="1920" height="1080" srcset="https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1.png 1920w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1-320x180.png 320w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1-650x366.png 650w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1-768x432.png 768w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1-1536x864.png 1536w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1-1500x844.png 1500w, https://blog.golioth.io/wp-content/uploads/2024/10/Slide-16_9-7-2-1-705x397.png 705w" sizes="(max-width: 1920px) 100vw, 1920px"/></p>
<p>Going back to our previous example of a device that sends a single sensor reading message every 30 minutes, enabling Connection ID would mean that a new handshake would not have to be performed after NAT timeout, and that single message can be sent then the device can go back to sleep. In fact, depending on how long the server is willing to store connection state, the device could sleep for much longer, sending once a day or more infrequently. This doesn’t solve the issue of cloud to device traffic being dropped after NAT timeout (check back for another post on that topic), but for many low power use cases, being able to sleep for an extended period of time is more important than being able to immediately push data to devices.</p>
<h2><a href="#configuring-the-golioth-firmware-sdk-for-sleepy-devices" aria-hidden="true" id="configuring-the-golioth-firmware-sdk-for-sleepy-devices"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Configuring the Golioth Firmware SDK for Sleepy Devices</h2>
<p>By default, the <a href="https://github.com/golioth/golioth-firmware-sdk">Golioth Firmware SDK</a> will send keep alive messages to ensure that an entry is preserved in the NAT translation table. However, this functionality can be disabled by setting <code>CONFIG_GOLIOTH_COAP_KEEPALIVE_INTERVAL</code> to 0, or just modifying it to be set to a large upper bound.</p>
<pre data-enlighter-language="generic">CONFIG_GOLIOTH_COAP_KEEPALIVE_INTERVAL_S=0</pre>
<p>If using Zephyr, we’ll also need to set the receive timeout to a value greater than the interval at which we will be sending data. Otherwise, the client will attempt to reconnect after 30 seconds by default if it has not received any messages. In this example we’ll send data every 130 seconds, so setting the receive timeout to 200 ensures that we won’t attempt to reconnect between sending.</p>
<pre data-enlighter-language="generic">CONFIG_GOLIOTH_COAP_CLIENT_RX_TIMEOUT_SEC=200</pre>
<p>To demonstrate the impact of NAT timeouts, we’ll initially build the <code>hello</code> example without enabling Connection IDs. To ensure that we wait long enough for a NAT timeout, we need to update the <a href="https://github.com/golioth/golioth-firmware-sdk/blob/2e405f9d00a64b20f5b8d434b88db0069418d0cb/examples/zephyr/hello/src/main.c#L57">loop</a> to send every 130 seconds instead of every 5 seconds.</p>
<blockquote><p>This example is using a <a href="https://www.hologram.io/">Hologram</a> SIM and connecting via the AT&amp;T network. NAT timeouts may vary from one carrier to another. AT&amp;T currently <a href="https://developer.att.com/technical-library/network-technologies/network-timers">documents UDP inactivity timeouts</a> as 30 seconds.</p></blockquote>
<pre data-enlighter-language="generic">while (true)
{
    LOG_INF(&#34;Sending hello! %d&#34;, counter);

    ++counter;
    k_sleep(K_SECONDS(130));
}</pre>
<p>Building and flashing the <code>hello</code> sample on a Nordic Thingy91 results in the following behavior.</p>
<pre data-enlighter-language="generic">*** Booting nRF Connect SDK v2.7.0-5cb85570ca43 ***
*** Using Zephyr OS v3.6.99-100befc70c74 ***
[00:00:00.506,378] &lt;dbg&gt; hello_zephyr: main: start hello sample
[00:00:00.506,378] &lt;inf&gt; golioth_samples: Bringing up network interface
[00:00:00.506,408] &lt;inf&gt; golioth_samples: Waiting to obtain IP address
[00:00:13.236,877] &lt;inf&gt; lte_monitor: Network: Searching
[00:00:17.593,994] &lt;inf&gt; lte_monitor: Network: Registered (roaming)
[00:00:17.594,696] &lt;inf&gt; golioth_mbox: Mbox created, bufsize: 1232, num_items: 10, item_size: 112
[00:00:18.839,904] &lt;inf&gt; golioth_coap_client_zephyr: Golioth CoAP client connected
[00:00:18.840,118] &lt;inf&gt; hello_zephyr: Sending hello! 0
[00:00:18.840,179] &lt;inf&gt; hello_zephyr: Golioth client connected
[00:00:18.840,270] &lt;inf&gt; golioth_coap_client_zephyr: Entering CoAP I/O loop
[00:02:28.840,209] &lt;inf&gt; hello_zephyr: Sending hello! 1
[00:02:32.194,396] &lt;wrn&gt; golioth_coap_client: 1 resends in last 10 seconds
[00:02:46.252,868] &lt;wrn&gt; golioth_coap_client: 4 resends in last 10 seconds
[00:03:03.419,219] &lt;wrn&gt; golioth_coap_client: 3 resends in last 10 seconds
[00:03:04.986,389] &lt;wrn&gt; golioth_coap_client: Packet 0x2001e848 (reply 0x2001e890) was not replied to
[00:03:06.045,715] &lt;wrn&gt; golioth_coap_client: Packet 0x2001e638 (reply 0x2001e680) was not replied to
[00:03:15.213,592] &lt;wrn&gt; golioth_coap_client: 6 resends in last 10 seconds
[00:03:21.874,298] &lt;wrn&gt; golioth_coap_client: Packet 0x2001ec90 (reply 0x2001ecd8) was not replied to
[00:03:25.419,921] &lt;wrn&gt; golioth_coap_client: 5 resends in last 10 seconds
[00:03:36.565,765] &lt;wrn&gt; golioth_coap_client: 5 resends in last 10 seconds
[00:03:40.356,933] &lt;wrn&gt; golioth_coap_client_zephyr: Receive timeout
[00:03:40.356,964] &lt;inf&gt; golioth_coap_client_zephyr: Ending session
[00:03:40.356,994] &lt;inf&gt; hello_zephyr: Golioth client disconnected
[00:03:47.035,675] &lt;inf&gt; golioth_coap_client_zephyr: Golioth CoAP client connected
[00:03:47.035,705] &lt;inf&gt; hello_zephyr: Golioth client connected
[00:03:47.035,827] &lt;inf&gt; golioth_coap_client_zephyr: Entering CoAP I/O loop</pre>
<p>After initially connecting and successfully sending <code>Sending hello! 0</code>, we are inactive for 130 seconds (<code>00:18</code> to <code>02:28</code>), then when we attempt to send <code>Sending hello! 1</code>, we see that the server never responds, eventually causing us to reach the <code>Receive timeout</code> and reconnect. This is because when we send <code>Sending hello! 1</code>, our entry has been removed from the NAT translation table, and when we are assigned a new public IP address and port the server is unable to associate messages with the existing DTLS session.</p>
<p>Because using Connection IDs does involve sending extra data in every message, it is disabled in the Golioth Firmware SDK by default. In scenarios such as this one where the few extra bytes clearly outweigh more frequent handshakes, Connection IDs can be enabled with <code>CONFIG_GOLIOTH_USE_CONNECTION_ID</code>.</p>
<pre data-enlighter-language="generic">CONFIG_GOLIOTH_USE_CONNECTION_ID=y</pre>
<p>Now when we build and flash the <code>hello</code> example on a Thingy91, we can see our 130 second delay, but then the successful delivery of <code>Sending hello! 1</code>. 130 seconds later, we see another successful delivery of <code>Sending hello! 2</code>.</p>
<pre data-enlighter-language="generic">*** Booting nRF Connect SDK v2.7.0-5cb85570ca43 ***
*** Using Zephyr OS v3.6.99-100befc70c74 ***
[00:00:00.508,636] &lt;dbg&gt; hello_zephyr: main: start hello sample
[00:00:00.508,666] &lt;inf&gt; golioth_samples: Bringing up network interface
[00:00:00.508,666] &lt;inf&gt; golioth_samples: Waiting to obtain IP address
[00:00:13.220,001] &lt;inf&gt; lte_monitor: Network: Searching
[00:00:16.318,908] &lt;inf&gt; lte_monitor: Network: Registered (roaming)
[00:00:16.319,641] &lt;inf&gt; golioth_mbox: Mbox created, bufsize: 1232, num_items: 10, item_size: 112
[00:00:21.435,180] &lt;inf&gt; golioth_coap_client_zephyr: Golioth CoAP client connected
[00:00:21.435,394] &lt;inf&gt; hello_zephyr: Sending hello! 0
[00:00:21.435,424] &lt;inf&gt; hello_zephyr: Golioth client connected
[00:00:21.435,546] &lt;inf&gt; golioth_coap_client_zephyr: Entering CoAP I/O loop
[00:02:31.435,455] &lt;inf&gt; hello_zephyr: Sending hello! 1
[00:04:41.435,546] &lt;inf&gt; hello_zephyr: Sending hello! 2</pre>
<h2><a href="#next-steps" aria-hidden="true" id="next-steps"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Next Steps</h2>
<p>To see how often your devices are being forced to reconnect to Golioth after periods of inactivity, check out our <a href="https://docs.golioth.io/reference/device-api/device-connectivity">documentation on device connectivity metrics</a>. Devices that effectively maintain long lasting connections will see a significant difference between their <code>Session Established</code> and <code>Last Report</code> timestamps. If you have any questions about optimizing your devices for low power, reach out to us on the <a href="https://forum.golioth.io/">forum</a>!</p>
</div></div><div data-td-block-uid="tdi_78">


<div><p><a href="https://blog.golioth.io/author/dan/" title="Dan Mangum"><img width="96" height="96" src="https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-96x96.webp" alt="Dan Mangum" decoding="async" loading="lazy" srcset="https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-96x96.webp 96w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-80x80.webp 80w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-36x36.webp 36w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-180x180.webp 180w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-24x24.webp 24w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-48x48.webp 48w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-150x150.webp 150w, https://blog.golioth.io/wp-content/uploads/2023/05/663c908cbfb2d08e06b277e2_dan_mangum_headshot-300x300.webp 300w" sizes="(max-width: 96px) 100vw, 96px"/></a></p><div><p><a href="https://blog.golioth.io/author/dan/">Dan Mangum</a></p><p>Dan is an experienced engineering leader, having built products and teams at both large companies and small startups. He has a history of leadership in open source communities, and has worked across many layers of the technical stack, giving him unique insight into the constraints faced by Golioth’s customers and the requirements of a platform that enables their success.</p></div></div></div></div>
  </body>
</html>
