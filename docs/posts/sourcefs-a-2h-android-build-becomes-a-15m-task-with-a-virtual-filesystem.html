<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.source.dev/journal/sourcefs">Original</a>
    <h1>SourceFS: A 2h&#43; Android build becomes a 15m task with a virtual filesystem</h1>
    
    <div id="readability-page-1" class="page"><p>SourceFS - a high-performance virtual filesystem that builds Android 9× faster, cuts compute costs by 14×, and reduces disk usage by 83× — unlocking a new level of developer productivity.</p><div><h4>Slow Builds and Code Checkouts</h4><p>Today&#39;s connected devices are powered by some of the largest codebases ever developed.</p><p>The latest Linux kernel has 40 Million lines of code while the Android AOSP has 140M+, and this is just the foundation. Real-world device codebases are far larger – add the code for hardware support, custom features, services, additional OSs and a smartphone quickly tops 200M lines of code, while an Electric Vehicle exceeds 500M. And these codebases continue to grow throughout a device’s lifetime, with each software update.</p><p>Every code checkout pulls millions of files and hundreds of GB, every build runs hundreds of thousands of steps. And because dependency graphs at this scale are imperfect, even a small change can trigger a massive rebuild or, worse, produce an incorrect result. </p><p><strong>The impact: hours of developer time lost every day and $ millions wasted</strong> on ever increasing CI compute requirements — or more often, configurations that are not tested due to compute constraints.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6b8548743e18d36bb90a4_Chart_Divider.png" loading="lazy" alt=""/></p></figure><h4></h4><p>Not another build system. Meet SourceFS – a high-performance virtual file system that delivers <strong>unparalleled speedups when checking out and building the Android codebase</strong>. It integrates seamlessly into your existing developer workflows and CI, with near-zero migration overhead, and dramatically lowers compute costs. Here’s how it works.<strong>‍</strong></p><p>At its core, SourceFS virtualizes everything, materializes on demand, and does all of this transparently — so neither you nor the rest of the system ever notice it.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6d589a9ae1ac87ad83532_Chart_01b.png" loading="lazy" alt=""/></p></figure><p>‍</p><p><strong>SourceFS accelerates code checkouts by over 10×.</strong> It does this by creating a virtual file representation of the entire codebase at checkout and materializing files on demand, instantly, the moment you need them. These virtual files look and behave just like real ones, with the correct permissions, timestamps, and attributes, yet their content appears, as if by magic, only if required.</p><p>This eliminates the need to download hundreds of GB of untouched code, drastically reducing disk space requirements. And given that most changes only affect a small fraction of the codebase, most files remain virtual and are never materialized. All this is seamlessly integrated with Git and Repo.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6b7fddb372107ab1bdc6b_Chart_02b.png" loading="lazy" alt=""/></p></figure><p><strong>SourceFS accelerates builds by up to 10×. </strong>Every build step, when first encountered, is executed in a lightweight sandbox that records all inputs, outputs, and environment. This covers over 99% of the build steps – not just compilation, but linking, packaging, generating docs, and more. As the build runs, any step that exactly matches a prior record is skipped and the results are automatically reused; any new or invalidated steps, for example from your local changes, are executed and recorded for future use.</p><p>Under the hood, SourceFS packs novel algorithms, advanced virtualization, high-performance caching and replay, efficient sandboxing, and a state-of-the-art backend with near-zero overhead, that is built to scale across your entire organization. Most of this is written in Rust and powered by decades of kernel and operating system advancements and expertise.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6b8548743e18d36bb90a4_Chart_Divider.png" loading="lazy" alt=""/></p></figure><h4>Fast Builds, Efficient Storage and Cost Savings</h4><p>The results of checking out code and building in a SourceFS environment are truly impressive.</p><p><strong>Fast checkouts</strong>, even when compared to the most optimised standard way of downloading the code, are over 20x faster. The SourceFS code checkout gives developers a working Git tree, and aside from running in a SourceFS backed folder, everything else is the same workflows developers are already used to. </p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6cde678a5cf4caef8753e_Chart_06b.png" loading="lazy" alt=""/></p></figure><p>In addition to speed, a non-obvious superpower is the fact that with SourceFS a codebase takes a small amount of disk space. This is game-changing for device developers, who often need to switch between multiple codebases — one for each device type, and sometimes even for individual device versions.</p><p>Fixing large-scale bugs, that affect multiple device codebases, or even just checking out another codebase to see how something is implemented is seamless and similar to working on a small GitHub repository.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68f79c8abcdc09a88be5ec66_Chart_07C.png" loading="lazy" alt=""/></p></figure><p><strong>Fast builds</strong> are what truly makes a difference to developer productivity. With SourceFS builds complete over 9x faster on a regular developer machine. This sets a new standard as it enables developers to get their <a href="https://xkcd.com/303/">sword fighting time back</a> and speeds-up the lengthy feedback loop on CI pipelines.</p><p>Even compared to other fast build solutions, SourceFS achieves significantly better performance, by being able to replay nearly all the build steps - across all programming languages, compilers and all the other tools used in a device codebase – think packaging, linking, documentation and a lot more. </p><p>‍</p><p>‍<strong>Cost savings</strong> are what makes a difference for organizations. The ability to achieve more with the same compute budget or to reduce the costs where they have grown out of control is what truly matters from a financial standpoint.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68f79c98ceb9d2d1b92ea888_Chart_12D.png" loading="lazy" alt=""/></p></figure><p>To understand the impact SourceFS has on costs, it helps to look at the priorities of fast-paced device organizations, where developers can’t wait for over two hours for a build to finish. In such teams, developers use the most powerful machines available to stay productive.</p><p>While powerful machines reduce build times to a more reasonable level, they still perform significantly slower than SourceFS running on a standard machine — and at a much higher cost. Here, SourceFS not only delivers better performance but also enables cost savings of up to 14×.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6b8548743e18d36bb90a4_Chart_Divider.png" loading="lazy" alt=""/></p></figure><h4>Alternatives: Why They Fall Short</h4><p>SourceFS builds on prior efforts. Each approach listed below has its own place, yet in our experience they all fall short when faced with the complexity of a modern device codebase.</p><h5>Migrating to a new build system (Bazel, Buck2)</h5><p>SourceFS delivers the performance gains of modern build systems like Bazel or Buck2 – while also accelerating checkouts – all without requiring any migration.</p><p>Moving a device codebase to a new build system is a massive undertaking that even well-resourced teams have <a href="https://x.com/MishaalRahman/status/1779985959926288407">abandoned midway</a>.<strong> </strong>Further still, this complexity multiplies for real device codebases, like electric vehicles, that incorporate multiple operating systems (Yocto, Android, QNX), each with its own bespoke build system.</p><h5>Using a compiler wrapper (REClient, Goma)</h5><p>An intermediate step, short of migrating to a new build system, is to use a compiler wrapper that enables caching and replay via a remote-execution protocol. However, wrappers cover only a subset of build actions, so they speed up only part of the build – and don’t help checkouts. They’re also brittle as they rely on parsing command-line flags and correctly inferring inputs/outputs, which can break in unexpected ways.</p><figure><p><img src="https://cdn.prod.website-files.com/68d1b6747213f7da602977fb/68e6b8548743e18d36bb90a4_Chart_Divider.png" loading="lazy" alt=""/></p></figure><h4>Next Steps</h4><p>We are rapidly expanding SourceFS support to more real world device codebases, including support for other operating systems, like Yocto, in parallel with optimising performance even further.</p><p>Fast builds and checkouts are the first superpowers in our mission to transform how software for smart devices is developed and maintained – making it simpler, faster, and cost-effective. Stay tuned!  </p></div></div>
  </body>
</html>
