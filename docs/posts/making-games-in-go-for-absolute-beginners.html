<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://threedots.tech/post/making-games-in-go/">Original</a>
    <h1>Making games in Go for absolute beginners</h1>
    
    <div id="readability-page-1" class="page"><div><p>Here‚Äôs a rant I often see in developer communities:</p>
<blockquote>
<p>I used to love programming because I like building stuff. But my full-time job killed my passion. I spend more time in meetings, fighting over deadlines, and arguing in reviews than working with code. Am I burned out? Is there hope, or do I need a new hobby?</p>
</blockquote>
<p>Sounds familiar? No wonder we keep looking forward to using a new framework or database ‚Äî we‚Äôre bored. So here‚Äôs my tip to cure some of your burnout: <strong>Start coding for fun again and reclaim your hobby.</strong> And what is more fun than creating your own world with code?</p>
<p>Wanting to make my own video game pushed me into programming 20 years ago. I didn‚Äôt make a career out of it, even though I created some small games using different tech stacks. I keep returning to it, and for me, it‚Äôs the most fun activity related to coding. Especially if done with friends over a weekend for a <a href="https://ldjam.com/users/m110/games" target="_blank">game jam</a>.</p>
<p>This post is my attempt at getting you to write games from scratch. (And if you want to pick up a new language too, check <a href="https://threedots.tech/go-in-one-evening/?utm_source=making-games" target="_blank">Go in One Evening</a> ‚Äî we have the black friday sale running now!)</p>
<p>Why Go? I like it, and <a href="https://ebitengine.org" target="_blank">Ebitengine</a>, the library I will show here, is great to work with. Like many Go libraries, it helps you do what you need and stays out of the way ‚Äî it‚Äôs not a framework.</p>
<p>Of course, a bigger game engine simplifies many things but also comes with bloat and a specific approach. <strong>A big part of why making games is fun is you get to do things your way and don‚Äôt need to care if it‚Äôs the right way.</strong> And it‚Äôs a great exercise to learn how games work.</p>
<p>First, a warning. Once you understand how games work, some of the magic is gone when playing them. You will start wondering, ‚ÄúHow does it work?‚Äù instead of enjoying the game. Thankfully, making games compensates for this.</p>

<h2 id="the-basics">The basics</h2>
<p>I remember having a hard time understanding how exactly games work. How do you make the objects in the game do what they do? It‚Äôs more obvious if you use a game engine, but what if you start from scratch?</p>
<p>You probably know that a movie is a very long collection of images, displayed one after the other so fast that our brains can‚Äôt tell the difference. Usually, 24 or 60 images (frames) per second (FPS).</p>
<p>A video game is the same idea, but the images (frames) don‚Äôt exist beforehand, so you must generate (draw) them on the fly. And you can press some buttons to change how the next frame looks.</p>
<p>This may seem too simplistic, right? ‚ÄúWhat? But how do you make a character jump?‚Äù You move the image up the screen over time and then back down. And you stop it from moving when it ‚Äútouches‚Äù other images. 2D games are basically made of images drawn on top of each other.</p>
<p>I was surprised to learn that games are basically infinite loops. You keep drawing images on the screen.</p>
<p>Besides drawing, you need to update the logic of the game. It includes things like checking buttons pressed, updating the player‚Äôs health, and checking collisions. The logic decides what images to draw and where, and the Draw function does it. Each time the logic is updated is known as a <em>tick</em>.</p>
<div><pre tabindex="0"><code data-lang="go"><span>for</span> {
	<span>// One tick
</span><span></span>	<span>UpdateLogic</span>()
	<span>DrawFrame</span>()
}
</code></pre></div><p>I know this looks hardly exciting, but let this idea sink in: your game does these two things over and over, 60 times per second. Just a single thread with this infinite loop (for now, forget goroutines exist).</p>
<p>Even though the idea is simple, keeping the loop running at the same speed on all systems is not trivial. Ebitengine takes care of this for you, running the game at 60 ticks per second.</p>
<p>Logic is the part you should be familiar with: it‚Äôs regular Go code. Drawing images is where things get more complex, and that‚Äôs why you use Ebitengine. It helps with drawing images, playing sounds, and checking inputs. How the logic works is mainly on you.</p>
<p>Ebitengine provides a <code>Game</code> interface you need to implement.</p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Game</span> <span>interface</span> {
	<span>Update</span>() <span>error</span>
	<span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>)
	<span>Layout</span>(<span>outsideWidth</span>, <span>outsideHeight</span> <span>int</span>) (<span>screenWidth</span>, <span>screenHeight</span> <span>int</span>)
}
</code></pre></div><p>The <code>Update</code> and <code>Draw</code> functions work as in the loop above. <code>Layout</code> is used for scaling the game screen ‚Äî you don‚Äôt need to worry about it now.</p>
<p><code>Update</code> is called every tick and updates the game logic. If an error is returned, the game quits.</p>
<p><code>Draw</code> is called every frame. The <code>screen</code> argument is an image you draw on, like a canvas.</p>
<h2 id="setting-up-the-project">Setting up the project</h2>
<p>First, let‚Äôs kick off the boring stuff: create a module and add Ebitengine (formerly called Ebiten, hence the package name).</p>
<div><pre tabindex="0"><code data-lang="go"><span>go</span> <span>mod</span> <span>init</span> <span>game</span>
<span>go</span> <span>get</span> <span>github</span>.<span>com</span><span>/</span><span>hajimehoshi</span><span>/</span><span>ebiten</span><span>/</span><span>v2</span>
</code></pre></div><p>Here‚Äôs the minimal code you need to start a game. It‚Äôs just an empty implementation of the Game interface. Running it should show a blank black window.</p>
<div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>main</span>

<span>import</span> <span>&#34;github.com/hajimehoshi/ebiten/v2&#34;</span>

<span>type</span> <span>Game</span> <span>struct</span>{}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Update</span>() <span>error</span> {
	<span>return</span> <span>nil</span>
}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>) {
	
}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Layout</span>(<span>outsideWidth</span>, <span>outsideHeight</span> <span>int</span>) (<span>screenWidth</span>, <span>screenHeight</span> <span>int</span>) {
	<span>return</span> <span>outsideWidth</span>, <span>outsideHeight</span>
}

<span>func</span> <span>main</span>() {
	<span>g</span> <span>:=</span> <span>&amp;</span><span>Game</span>{}

	<span>err</span> <span>:=</span> <span>ebiten</span>.<span>RunGame</span>(<span>g</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		panic(<span>err</span>)
	}
}
</code></pre></div>
<h2 id="loading-assets">Loading assets</h2>
<p>If your graphic skills are similar to mine (the term ‚Äúprogrammer art‚Äù exists for a reason üôÉ), you may prefer using ready assets when prototyping.</p>
<p>Unless you want to create them yourself, I encourage you to play with free-to-use assets. Personally, I love the collection from <a href="https://kenney.nl" target="_blank">Kenney</a>. Every time I look for inspiration, I browse the 2D assets there and find something that looks like a cool game to make. I‚Äôll use the <a href="https://kenney.nl/assets/space-shooter-extension" target="_blank">space </a><a href="https://kenney.nl/assets/space-shooter-redux" target="_blank">shooter</a> pack below to make a trivial Asteroids clone.</p>
<p>To load the assets in code, use <code>embed</code> ‚Äî it‚Äôs like it was meant for making games. You know the paths are right on compile time. You also don‚Äôt need to care about the distribution, as the binary contains the assets. It works even for mobile apps!</p>
<p>You will likely have many assets, so consider embedding the entire directory:</p>
<div><pre tabindex="0"><code data-lang="go"><span>import</span> <span>&#34;embed&#34;</span>

<span>//go:embed assets/*
</span><span></span><span>var</span> <span>assets</span> <span>embed</span>.<span>FS</span>
</code></pre></div><p>You can now load the images from the <code>assets</code> collection. I‚Äôm using the <code>must</code> pattern here and keep sprites as global variables for simplicity. (A sprite is just another name for a 2D graphic.)</p>
<p>Note the empty <code>&#34;image/png&#34;</code> import used for decoding.</p>
<div><pre tabindex="0"><code data-lang="go"><span>import</span> (
	<span>&#34;image&#34;</span>
	<span>_</span> <span>&#34;image/png&#34;</span>

	<span>&#34;github.com/hajimehoshi/ebiten/v2&#34;</span>
)

<span>var</span> <span>PlayerSprite</span> = <span>mustLoadImage</span>(<span>&#34;assets/player.png&#34;</span>)

<span>func</span> <span>mustLoadImage</span>(<span>name</span> <span>string</span>) <span>*</span><span>ebiten</span>.<span>Image</span> {
	<span>f</span>, <span>err</span> <span>:=</span> <span>assets</span>.<span>Open</span>(<span>name</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		panic(<span>err</span>)
	}
	<span>defer</span> <span>f</span>.<span>Close</span>()

	<span>img</span>, <span>_</span>, <span>err</span> <span>:=</span> <span>image</span>.<span>Decode</span>(<span>f</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		panic(<span>err</span>)
	}

	<span>return</span> <span>ebiten</span>.<span>NewImageFromImage</span>(<span>img</span>)
}
</code></pre></div><h3 id="drawing-images">Drawing Images</h3>
<p>All the drawing happens in the <code>Draw</code> method.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>) {

}
</code></pre></div><p>The <code>screen</code> argument is the image displayed every frame (after the method returns). Your job is to draw other images (or text) on it.</p>
<p>The key method of <code>ebiten.Image</code> is <code>DrawImage</code>, which draws another image onto it.</p>
<div><pre tabindex="0"><code data-lang="go"><span>screen</span>.<span>DrawImage</span>(<span>PlayerSprite</span>, <span>nil</span>)
</code></pre></div><p>The first argument is the image you want to draw. The second is the <code>ebiten.DrawImageOptions</code> struct that decides where and how the image is drawn. Passing <code>nil</code> keeps the default options.</p>
<p>Here‚Äôs the result: the player‚Äôs spaceship is drawn in the screen‚Äôs top-left corner.</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_1.png" alt="Image.png"/></p>
<p>The drawing options struct has a few fields; the one to focus on first is the <code>GeoM</code> matrix. The <a href="https://ebitengine.org/en/documents/matrix.html" target="_blank">docs</a> go into detail on the math behind it, and math is super helpful in making games. But if I just wanted to make a game, the last thing I‚Äôd like to read about is algebra, so I‚Äôll try to simplify it here.</p>
<p>Do you know how when you copy and paste an image in a graphics editor, the pasted part stays selected, and you can keep moving and transforming it? That‚Äôs how I see <code>DrawImage</code>. You can think of <code>DrawImageOptions</code> as a ‚Äúcursor‚Äù you can use to position and change the image.</p>
<p><strong>Drawing uses X and Y coordinates, with the Y axis going downward.</strong> By default, everything is drawn at the (0, 0) point, so the top-left corner of the base image.</p>
<p>To move the image, use <code>GeoM.Translate</code>:</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>150</span>, <span>200</span>)
<span>screen</span>.<span>DrawImage</span>(<span>PlayerSprite</span>, <span>op</span>)
</code></pre></div><p>This <code>Translate</code> call moves the image 150 pixels right and 200 pixels down. You can use negative numbers to go left and up, respectively. (If you move too far away, you may not see the image on the screen).</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_2.png" alt="Image.png"/></p>
<p>Use <code>GeoM.Rotate</code> to rotate the image:</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
<span>op</span>.<span>GeoM</span>.<span>Rotate</span>(<span>45.0</span> <span>*</span> <span>math</span>.<span>Pi</span> <span>/</span> <span>180.0</span>)
<span>screen</span>.<span>DrawImage</span>(<span>PlayerSprite</span>, <span>op</span>)
</code></pre></div><p>This rotates the image 45¬∞ clockwise. (The unit is radians. If you prefer working with degrees, use the <code>degrees * math.Pi / 180.0</code> formula to get them.)</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_3.png" alt="Image.png"/></p>
<p>Can you see how the image is partially off-screen now? That‚Äôs because the pivot point (the point ‚Äúaround‚Äù which the image is being rotated) is the top-left corner of the image. I‚Äôll show how to work around this in a bit.</p>
<p>Using negative values rotates the image counter-clockwise.</p>
<p>Finally, there‚Äôs <code>GeoM.Scale</code>, which lets you draw smaller or bigger images:</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
<span>op</span>.<span>GeoM</span>.<span>Scale</span>(<span>2</span>, <span>2</span>)
<span>screen</span>.<span>DrawImage</span>(<span>PlayerSprite</span>, <span>op</span>)
</code></pre></div><p>This <code>Scale</code> call makes the image twice as big horizontally and vertically.</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_4.png" alt="Image.png"/></p>
<p>Passing negative values flips the image horizontally or vertically. For example, to draw the image upside-down, use:</p>
<p><strong>You now know the basic tools to control images in a game: their position, rotation, and scale.</strong></p>
<p>You can combine all of them in a single <code>DrawImage</code> call. There‚Äôs a caveat, though: the order matters. If you use <code>Translate</code> first and then apply the rotation or scale, you may not see what you expect because the change will be applied to the new position.</p>
<p>To illustrate this, let‚Äôs see how to rotate the image around its center (a common use case).</p>
<p>You need to move the pivot point to the image‚Äôs center. You can find it simply by dividing the image‚Äôs width and height by half. (Calculating stuff based on the image size is also super common.)</p>
<div><pre tabindex="0"><code data-lang="go"><span>width</span> <span>:=</span> <span>PlayerSprite</span>.<span>Bounds</span>().<span>Dx</span>()
<span>height</span> <span>:=</span> <span>PlayerSprite</span>.<span>Bounds</span>().<span>Dy</span>()

<span>halfW</span> <span>:=</span> float64(<span>width</span> <span>/</span> <span>2</span>)
<span>halfH</span> <span>:=</span> float64(<span>height</span> <span>/</span> <span>2</span>)
</code></pre></div><p>You need to move the image by <strong>the negative values</strong> first. This is so the image‚Äôs center aligns with the origin point (0, 0). Then, apply the rotation and move the image ‚Äúback‚Äù by the same amount.</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>-</span><span>halfW</span>, <span>-</span><span>halfH</span>)
<span>op</span>.<span>GeoM</span>.<span>Rotate</span>(<span>45.0</span> <span>*</span> <span>math</span>.<span>Pi</span> <span>/</span> <span>180.0</span>)
<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>halfW</span>, <span>halfH</span>)
</code></pre></div><p><img src="https://reubenson.com/recurse/week-3/images/image_5.png" alt="Image.png"/></p>
<p>It might be easier to grasp using this animation of all steps (scaled three times):</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_6.gif" alt="AnimatedImage.gif"/></p>
<h2 id="changing-colors">Changing colors</h2>
<p>Another useful option is changing the sprite‚Äôs color. You can use it to draw an image that looks like the sprite but with a solid color. Of course, this makes the most sense if you use sprites with a transparent background.</p>
<p>The syntax is similar, although you need to use the recently added <code>colorm</code> package.</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span> <span>:=</span> <span>&amp;</span><span>colorm</span>.<span>DrawImageOptions</span>{}
<span>cm</span> <span>:=</span> <span>colorm</span>.<span>ColorM</span>{}
<span>cm</span>.<span>Translate</span>(<span>1.0</span>, <span>1.0</span>, <span>1.0</span>, <span>0.0</span>)
<span>colorm</span>.<span>DrawImage</span>(<span>screen</span>, <span>PlayerSprite</span>, <span>cm</span>, <span>op</span>)
</code></pre></div><p><img src="https://reubenson.com/recurse/week-3/images/image_7.png" alt="Image.png"/></p>
<p>The first three arguments of <code>Translate</code> are <code>red</code>, <code>green</code>, and <code>blue</code> values and go from <code>0.0</code> to <code>1.0</code> (0% to 100%). The last one is <code>alpha</code> (transparency).</p>
<p>You can control the <code>alpha</code> field to make sprites transparent, creating cool effects like adding a shadow. To keep the transparent background unchanged, use <code>Scale</code> instead of <code>Translate</code>. Keep the first three arguments at <code>1.0</code>, so they don‚Äôt change.</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span> <span>:=</span> <span>&amp;</span><span>colorm</span>.<span>DrawImageOptions</span>{}
<span>cm</span> <span>:=</span> <span>colorm</span>.<span>ColorM</span>{}
<span>cm</span>.<span>Scale</span>(<span>1.0</span>, <span>1.0</span>, <span>1.0</span>, <span>0.5</span>)
<span>colorm</span>.<span>DrawImage</span>(<span>screen</span>, <span>PlayerSprite</span>, <span>cm</span>, <span>op</span>)
</code></pre></div><p><img src="https://reubenson.com/recurse/week-3/images/image_8.png" alt="Image.png"/></p>
<h2 id="combining-options">Combining options</h2>
<p>You can do more with <code>DrawImageOptions</code>, but this should be all you need to start making games.</p>
<p>For example, here‚Äôs an evolution animation I created in <a href="https://github.com/m110/airplanes" target="_blank">airplanes</a>:</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_9.gif" alt="AnimatedImage.gif"/></p>
<p>I really like how it turned out. The best part is that I didn‚Äôt use graphic assets for the animation. It‚Äôs all done with <code>DrawImageOptions</code> and goes like this:</p>
<ul>
<li>Change the color of the sprite to white.</li>
<li>Create a new sprite (also white) on top of the current one, with the scale set to (0, 0) (invisible).</li>
<li>Scale the new sprite to scale (1, 1) over time.</li>
<li>Scale the old sprite to scale (0, 0) over time.</li>
<li>Remove the white color.</li>
</ul>
<p>Can you notice how the shadow evolves as well? It‚Äôs the same idea but using a gray sprite and some transparency.</p>

<h2 id="the-logic">The logic</h2>
<p>To make the game do anything interesting, you need to fill in the <code>Update</code> method. You keep all logic there while the <code>Draw</code> method draws images (on the screen or on top of each other).</p>
<p>The basic idea of the game logic is simple: the <code>Game</code> struct holds some state, and the <code>Update</code> method changes this state. <code>Draw</code> reads the state and draws images based on it.</p>
<p>A classic example of a game state is the player‚Äôs position. In 2D games, this will usually be <strong>a pair of (X, Y) values, also known as a vector.</strong></p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Vector</span> <span>struct</span> {
	<span>X</span> <span>float64</span>
	<span>Y</span> <span>float64</span>
}

<span>type</span> <span>Game</span> <span>struct</span> {
	<span>playerPosition</span> <span>Vector</span>
}
</code></pre></div><p>The zero-value of <code>Vector</code> is (0, 0), like any struct in Go. Let‚Äôs initialize the game state with a predefined value:</p>
<div><pre tabindex="0"><code data-lang="go"><span>g</span> <span>:=</span> <span>&amp;</span><span>Game</span>{
	<span>playerPosition</span>: <span>Vector</span>{<span>X</span>: <span>100</span>, <span>Y</span>: <span>100</span>},
}
</code></pre></div><p>All left to do is to update the <code>Draw</code> method so it draws the player‚Äôs sprite at the given position. This shouldn‚Äôt be surprising:</p>
<div><pre tabindex="0"><code data-lang="go"><span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>g</span>.<span>playerPosition</span>.<span>X</span>, <span>g</span>.<span>playerPosition</span>.<span>Y</span>)
<span>screen</span>.<span>DrawImage</span>(<span>PlayerSprite</span>, <span>op</span>)
</code></pre></div><p>Note how we call <code>Translate</code> <strong>always with the current position of the player</strong>. Each time <code>Draw</code> is called, the screen is empty, and the images are drawn from scratch. (Ebitengine might optimize this, but we don‚Äôt need to care now.)</p>
<h2 id="movement">Movement</h2>
<p>To move the player to the right, keep increasing the <code>X</code> position in <code>Update</code>.</p>
<p>Do you remember that <code>Update</code> is called in an infinite loop? This becomes important now, as you need to decide how fast to move the player.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Update</span>() <span>error</span> {
	<span>speed</span> <span>:=</span> <span>5.0</span>
    <span>g</span>.<span>playerPosition</span>.<span>X</span> <span>+=</span> <span>speed</span>
  
	<span>return</span> <span>nil</span>
}
</code></pre></div><p><code>speed</code> is the number of pixels the position changes <strong>in a single tick (one <code>Update</code> call)</strong>. With the default 60 ticks per second, the image would move 300 pixels per second to the right.</p>
<p>It may be easier to keep the speed as ‚Äúpixels per second‚Äù instead of ‚Äúpixels per tick‚Äù. In this case, calculate it like this:</p>
<div><pre tabindex="0"><code data-lang="go"><span>// Move 300 pixels per second
</span><span></span><span>speed</span> <span>:=</span> float64(<span>300</span> <span>/</span> <span>ebiten</span>.<span>TPS</span>())
</code></pre></div><h2 id="controls">Controls</h2>
<p>Let‚Äôs now allow moving the player using the arrow keys. The idea stays the same: we need to update the position. Not every tick, though, but only if a key is pressed.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Update</span>() <span>error</span> {
	<span>speed</span> <span>:=</span> <span>5.0</span>

	<span>if</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeyDown</span>) {
		<span>g</span>.<span>playerPosition</span>.<span>Y</span> <span>+=</span> <span>speed</span>
	}
	<span>if</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeyUp</span>) {
		<span>g</span>.<span>playerPosition</span>.<span>Y</span> <span>-=</span> <span>speed</span>
	}
	<span>if</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeyLeft</span>) {
		<span>g</span>.<span>playerPosition</span>.<span>X</span> <span>-=</span> <span>speed</span>
	}
	<span>if</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeyRight</span>) {
		<span>g</span>.<span>playerPosition</span>.<span>X</span> <span>+=</span> <span>speed</span>
	}

	<span>return</span> <span>nil</span>
}
</code></pre></div><p><code>ebiten.IsKeyPressed</code> returns <code>true</code> if the given key is pressed in the current ‚Äútick‚Äù (remember, <code>Update</code> is called about 60 times per second by default).</p>
<p>The other function you might need is <code>ebitenutil.IsKeyJustPressed</code>, which returns true just in the tick the player presses the key. It‚Äôs the difference between ‚Äúhold space to keep jumping‚Äù and ‚Äúeven if you keep holding space, you jump just once‚Äù. Note it‚Äôs in the <code>ebitenutil</code> package not <code>ebiten</code>, in contrast to <code>IsKeyPressed</code>.</p>
<p>Note how we don‚Äôt use <code>if-else</code> ‚Äî thanks to this, the player can move diagonally by holding two arrows at a time.</p>

<h2 id="timers">Timers</h2>
<p>A very common need in games is changing the logic with time. For example, you want the enemy object to move for two seconds to the right and then back to the left. Or you want the boss to cast a spell every five seconds.</p>
<p>You can‚Äôt use a regular way to measure time, using <code>time.Now()</code> and <code>time.Since()</code> due to how the <code>Update</code> method works (running at a constant speed of 60 ticks per second).</p>
<p>The idea is to keep counting ticks that have happened since the timer started. Then, you take some action and reset it.</p>
<p>I like to keep the Timer as a separate struct with a nice API.</p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Timer</span> <span>struct</span> {
	<span>currentTicks</span> <span>int</span>
	<span>targetTicks</span>  <span>int</span>
}

<span>func</span> <span>NewTimer</span>(<span>d</span> <span>time</span>.<span>Duration</span>) <span>*</span><span>Timer</span> {
	<span>return</span> <span>&amp;</span><span>Timer</span>{
		<span>currentTicks</span>: <span>0</span>,
		<span>targetTicks</span>:  int(<span>d</span>.<span>Milliseconds</span>()) <span>*</span> <span>ebiten</span>.<span>TPS</span>() <span>/</span> <span>1000</span>,
	}
}

<span>func</span> (<span>t</span> <span>*</span><span>Timer</span>) <span>Update</span>() {
	<span>if</span> <span>t</span>.<span>currentTicks</span> &lt; <span>t</span>.<span>targetTicks</span> {
		<span>t</span>.<span>currentTicks</span><span>++</span>
	}
}

<span>func</span> (<span>t</span> <span>*</span><span>Timer</span>) <span>IsReady</span>() <span>bool</span> {
	<span>return</span> <span>t</span>.<span>currentTicks</span> <span>&gt;=</span> <span>t</span>.<span>targetTicks</span>
}

<span>func</span> (<span>t</span> <span>*</span><span>Timer</span>) <span>Reset</span>() {
	<span>t</span>.<span>currentTicks</span> = <span>0</span>
}
</code></pre></div><p>And here‚Äôs a short example of using it:</p>
<div><pre tabindex="0"><code data-lang="go"><span>g</span> <span>:=</span> <span>&amp;</span><span>Game</span>{
	<span>attackTimer</span>: <span>NewTimer</span>(<span>5</span> <span>*</span> <span>time</span>.<span>Second</span>),
}

<span>// ...
</span><span></span>
<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Update</span>() <span>error</span> {
	<span>g</span>.<span>attackTimer</span>.<span>Update</span>()
	<span>if</span> <span>g</span>.<span>attackTimer</span>.<span>IsReady</span>() {
		<span>g</span>.<span>attackTimer</span>.<span>Reset</span>()

		<span>// Execute the attack!
</span><span></span>	}
}
</code></pre></div><h2 id="game-objects">Game Objects</h2>
<p>Keeping the player‚Äôs position directly in the <code>Game</code> struct is like using global variables. It would be challenging to maintain non-trivial games this way.</p>
<p>Encapsulation is a good improvement: having building blocks you can use instead of dealing with the details. A simple game object (or entity or whatever you want to call it) can be a struct with a position and sprite.</p>
<p>There are many approaches to organizing the game logic, and you can use whatever makes sense to you. An easy way to start is to have each game object expose its own <code>Update</code> and <code>Draw</code> methods, and call them in the <code>Game</code>‚Äôs <code>Update</code> and <code>Draw</code>.</p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Player</span> <span>struct</span> {
	<span>position</span> <span>Vector</span>
	<span>sprite</span>   <span>*</span><span>ebiten</span>.<span>Image</span>
}

<span>func</span> <span>NewPlayer</span>() <span>*</span><span>Player</span> {
	<span>return</span> <span>&amp;</span><span>Player</span>{
		<span>position</span>: <span>Vector</span>{<span>X</span>: <span>100</span>, <span>Y</span>: <span>100</span>},
		<span>sprite</span>:   <span>PlayerSprite</span>,
	}
}

<span>func</span> (<span>p</span> <span>*</span><span>Player</span>) <span>Update</span>() {
  
}

<span>func</span> (<span>p</span> <span>*</span><span>Player</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>) {
	<span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
	<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>p</span>.<span>position</span>.<span>X</span>, <span>p</span>.<span>position</span>.<span>Y</span>)
	<span>screen</span>.<span>DrawImage</span>(<span>p</span>.<span>sprite</span>, <span>op</span>)
}
</code></pre></div><p>Now the <code>Game</code> methods don‚Äôt concern about the details of the <code>Player</code>:</p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Game</span> <span>struct</span> {
	<span>player</span> <span>*</span><span>Player</span>
}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Update</span>() <span>error</span> {
	<span>g</span>.<span>player</span>.<span>Update</span>()
}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>) {
	<span>g</span>.<span>player</span>.<span>Draw</span>(<span>screen</span>)
}
</code></pre></div><p>Let‚Äôs finish the Player implementation for this Asteroids clone.</p>
<p>The player should be spawned in the center of the screen. It‚Äôs easy to calculate if we know the screen‚Äôs width and height. First, define the screen size as constants.</p>
<div><pre tabindex="0"><code data-lang="go"><span>const</span> (
	<span>ScreenWidth</span>  = <span>800</span>
	<span>ScreenHeight</span> = <span>600</span>
)
</code></pre></div><p>Now is the time we use the third method of <code>ebiten.Game</code>‚Äôs interface: the <code>Layout</code>. It should return the size of the game window.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Layout</span>(<span>outsideWidth</span>, <span>outsideHeight</span> <span>int</span>) (<span>int</span>, <span>int</span>) {
	<span>return</span> <span>ScreenWidth</span>, <span>ScreenHeight</span>
}
</code></pre></div><p>Now, back to the <code>NewPlayer</code> constructor to set the initial position. The center of the screen is half of the screen‚Äôs width and height (X and Y). But remember, the player‚Äôs sprite top-left corner will be drawn at the given position. To keep it precisely in the center, we must move it left and up by half the sprite‚Äôs width and height.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>NewPlayer</span>() <span>*</span><span>Player</span> {
  	<span>sprite</span> <span>:=</span> <span>PlayerSprite</span>

	<span>bounds</span> <span>:=</span> <span>sprite</span>.<span>Bounds</span>()
	<span>halfW</span> <span>:=</span> float64(<span>bounds</span>.<span>Dx</span>()) <span>/</span> <span>2</span>
	<span>halfH</span> <span>:=</span> float64(<span>bounds</span>.<span>Dy</span>()) <span>/</span> <span>2</span>

  	<span>pos</span> <span>:=</span> <span>Vector</span>{
		<span>X</span>: <span>ScreenWidth</span><span>/</span><span>2</span> <span>-</span> <span>halfW</span>,
		<span>Y</span>: <span>ScreenHeight</span><span>/</span><span>2</span> <span>-</span> <span>halfH</span>,
	}

	<span>return</span> <span>&amp;</span><span>Player</span>{
		<span>position</span>: <span>pos</span>,
		<span>sprite</span>:   <span>sprite</span>,
	}
}
</code></pre></div><p><img src="https://reubenson.com/recurse/week-3/images/image_10.png" alt="Image.png"/></p>
<p>Instead of moving the spaceship, the player should be able to rotate it. We can keep the rotation as <code>float64</code> in the <code>Player</code> struct.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>p</span> <span>*</span><span>Player</span>) <span>Update</span>() {
	<span>speed</span> <span>:=</span> <span>math</span>.<span>Pi</span> <span>/</span> float64(<span>ebiten</span>.<span>TPS</span>())

	<span>if</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeyLeft</span>) {
		<span>p</span>.<span>rotation</span> <span>-=</span> <span>speed</span>
	}
	<span>if</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeyRight</span>) {
		<span>p</span>.<span>rotation</span> <span>+=</span> <span>speed</span>
	}
}
</code></pre></div><p>Remember, the rotation unit is radians. <code>2œÄ</code> is a full rotation. I‚Äôll stick to <code>œÄ / TPS</code>, which means the player can rotate 180¬∞ per second.</p>
<p>Now, we need to update the <code>Draw</code> struct to take rotation into account (using the trick of rotating the image around its center).</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>p</span> <span>*</span><span>Player</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>) {
	<span>bounds</span> <span>:=</span> <span>p</span>.<span>sprite</span>.<span>Bounds</span>()
	<span>halfW</span> <span>:=</span> float64(<span>bounds</span>.<span>Dx</span>()) <span>/</span> <span>2</span>
	<span>halfH</span> <span>:=</span> float64(<span>bounds</span>.<span>Dy</span>()) <span>/</span> <span>2</span>

	<span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
	<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>-</span><span>halfW</span>, <span>-</span><span>halfH</span>)
	<span>op</span>.<span>GeoM</span>.<span>Rotate</span>(<span>p</span>.<span>rotation</span>)
	<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>halfW</span>, <span>halfH</span>)

	<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>p</span>.<span>position</span>.<span>X</span>, <span>p</span>.<span>position</span>.<span>Y</span>)

	<span>screen</span>.<span>DrawImage</span>(<span>p</span>.<span>sprite</span>, <span>op</span>)
}
</code></pre></div><h2 id="spawning-objects">Spawning objects</h2>
<p>Following the game object idea, let‚Äôs create a Meteor object. We can load many assets and pick one randomly to make it more interesting.</p>
<div><pre tabindex="0"><code data-lang="go"><span>var</span> <span>MeteorSprites</span> = <span>mustLoadImages</span>(<span>&#34;meteors/*.png&#34;</span>)

<span>type</span> <span>Meteor</span> <span>struct</span> {
	<span>position</span> <span>Vector</span>
	<span>sprite</span>   <span>*</span><span>ebiten</span>.<span>Image</span>
}

<span>func</span> <span>NewMeteor</span>() <span>*</span><span>Meteor</span> {
	<span>sprite</span> <span>:=</span> <span>MeteorSprites</span>[<span>rand</span>.<span>Intn</span>(len(<span>MeteorSprites</span>))]

	<span>return</span> <span>&amp;</span><span>Meteor</span>{
		<span>position</span>: <span>Vector</span>{},
		<span>sprite</span>:   <span>sprite</span>,
	}
}
</code></pre></div><p>The <code>Draw</code> method is pretty much the same as for <code>Player</code>. (As you can imagine, there‚Äôs room for improvement here to keep the common code in one place ‚Äî more on this later).</p>
<p>Now, <code>Game</code> needs to keep track of meteors. It‚Äôs the same idea as with <code>Player</code>, except we now need a slice of objects. Let‚Äôs also add a spawn timer.</p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Game</span> <span>struct</span> {
	<span>player</span>           <span>*</span><span>Player</span>
	<span>meteorSpawnTimer</span> <span>*</span><span>Timer</span>
	<span>meteors</span>          []<span>*</span><span>Meteor</span>
}
</code></pre></div><p><code>Update</code> and <code>Draw</code> iterate over all meteors and call their respective methods. And every time the timer is ready, a new meteor is added to the slice.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Update</span>() <span>error</span> {
	<span>g</span>.<span>player</span>.<span>Update</span>()

	<span>g</span>.<span>meteorSpawnTimer</span>.<span>Update</span>()
	<span>if</span> <span>g</span>.<span>meteorSpawnTimer</span>.<span>IsReady</span>() {
		<span>g</span>.<span>meteorSpawnTimer</span>.<span>Reset</span>()

		<span>m</span> <span>:=</span> <span>NewMeteor</span>()
		<span>g</span>.<span>meteors</span> = append(<span>g</span>.<span>meteors</span>, <span>m</span>)
	}

  	<span>for</span> <span>_</span>, <span>m</span> <span>:=</span> <span>range</span> <span>g</span>.<span>meteors</span> {
		<span>m</span>.<span>Update</span>()
	}

	<span>return</span> <span>nil</span>
}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>) {
	<span>g</span>.<span>player</span>.<span>Draw</span>(<span>screen</span>)

	<span>for</span> <span>_</span>, <span>m</span> <span>:=</span> <span>range</span> <span>g</span>.<span>meteors</span> {
		<span>m</span>.<span>Draw</span>(<span>screen</span>)
	}
}
</code></pre></div>
<h3 id="details-of-the-meteor">Details of the meteor</h3>
<p>The meteor should spawn at the edge of the screen. Here‚Äôs one approach to do it.</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_15.png" alt="Image.png"/></p>
<div><pre tabindex="0"><code data-lang="go"><span>// Figure out the target position ‚Äî the screen center, in this case
</span><span></span><span>target</span> <span>:=</span> <span>Vector</span>{
	<span>X</span>: <span>ScreenWidth</span> <span>/</span> <span>2</span>,
	<span>Y</span>: <span>SreenHeight</span> <span>/</span> <span>2</span>,
}

<span>// The distance from the center the meteor should spawn at ‚Äî half the width
</span><span></span><span>r</span> <span>:=</span> <span>ScreenWidth</span> <span>/</span> <span>2.0</span>

<span>// Pick a random angle ‚Äî 2œÄ is 360¬∞ ‚Äî so this returns 0¬∞ to 360¬∞
</span><span></span><span>angle</span> <span>:=</span> <span>rand</span>.<span>Float64</span>() <span>*</span> <span>2</span> <span>*</span> <span>math</span>.<span>Pi</span>

<span>// Figure out the spawn position by moving r pixels from the target at the chosen angle
</span><span></span><span>pos</span> <span>:=</span> <span>Vector</span>{
	<span>X</span>: <span>target</span>.<span>X</span> <span>+</span> <span>math</span>.<span>Cos</span>(<span>angle</span>)<span>*</span><span>r</span>,
	<span>Y</span>: <span>target</span>.<span>Y</span> <span>+</span> <span>math</span>.<span>Sin</span>(<span>angle</span>)<span>*</span><span>r</span>,
}
</code></pre></div><p>As I mentioned, math is often handy for making games! You don‚Äôt need to know how it works in depth; just know the basic operations like ‚Äúmove 100 pixels from position (100, 200) at 30¬∞ angle‚Äù. (There‚Äôs absolutely no shame in having to consult the internet or AI every time you do it. üòÖ)</p>
<p>Next, the meteor should keep moving toward the player‚Äôs position (the screen center).</p>
<div><pre tabindex="0"><code data-lang="go"><span>// Randomized velocity
</span><span></span><span>velocity</span> <span>:=</span> <span>0.25</span> <span>+</span> <span>rand</span>.<span>Float64</span>()<span>*</span><span>1.5</span>

<span>// Direction is the target minus the current position
</span><span></span><span>direction</span> <span>:=</span> <span>Vector</span>{
	<span>X</span>: <span>target</span>.<span>X</span> <span>-</span> <span>pos</span>.<span>X</span>,
	<span>Y</span>: <span>target</span>.<span>Y</span> <span>-</span> <span>pos</span>.<span>Y</span>,
}

<span>// Normalize the vector ‚Äî get just the direction without the length
</span><span></span><span>normalizedDirection</span> <span>:=</span> <span>direction</span>.<span>Normalize</span>()

<span>// Multiply the direction by velocity
</span><span></span><span>movement</span> <span>:=</span> <span>Vector</span>{
	<span>X</span>: <span>normalizedDirection</span>.<span>X</span> <span>*</span> <span>velocity</span>,
	<span>Y</span>: <span>normalizedDirection</span>.<span>Y</span> <span>*</span> <span>velocity</span>,
}
</code></pre></div><p><code>NewMeteor</code> can store the <code>movement</code> in the struct, and then the <code>Update</code> becomes trivial:</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>m</span> <span>*</span><span>Meteor</span>) <span>Update</span>() {
	<span>m</span>.<span>position</span>.<span>X</span> <span>+=</span> <span>m</span>.<span>movement</span>.<span>X</span>
	<span>m</span>.<span>position</span>.<span>Y</span> <span>+=</span> <span>m</span>.<span>movement</span>.<span>Y</span>
}
</code></pre></div><p>A final touch is adding a random rotation to each meteor. You can calculate it in the constructor:</p>
<div><pre tabindex="0"><code data-lang="go"><span>rotationSpeed</span> <span>:=</span> <span>-</span><span>0.02</span> <span>+</span> <span>rand</span>.<span>Float64</span>()<span>*</span><span>0.04</span>,
</code></pre></div><p>Then, keep moving and rotating the meteor.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>m</span> <span>*</span><span>Meteor</span>) <span>Update</span>() {
	<span>m</span>.<span>position</span>.<span>X</span> <span>+=</span> <span>m</span>.<span>movement</span>.<span>X</span>
	<span>m</span>.<span>position</span>.<span>Y</span> <span>+=</span> <span>m</span>.<span>movement</span>.<span>Y</span>
	<span>m</span>.<span>rotation</span> <span>+=</span> <span>m</span>.<span>rotationSpeed</span>
}
</code></pre></div><p><img src="https://reubenson.com/recurse/week-3/images/image_11.png" alt="Image.png"/></p>
<h2 id="shooting-bullets">Shooting Bullets</h2>
<p>Shooting bullets shouldn‚Äôt be surprising by now, so I won‚Äôt describe it in detail.
You can see the complete source in the <a href="https://github.com/ThreeDotsLabs/meteors" target="_blank">repository</a>.</p>
<p>We need to:</p>
<ul>
<li>Keep a timer with a shooting cooldown.</li>
<li>Spawn a new bullet when a button is pressed.</li>
<li>Rotate the bullet and keep it moving in the direction it faces.</li>
</ul>
<div><pre tabindex="0"><code data-lang="go"><span>p</span>.<span>shootCooldown</span>.<span>Update</span>()
<span>if</span> <span>p</span>.<span>shootCooldown</span>.<span>IsReady</span>() <span>&amp;&amp;</span> <span>ebiten</span>.<span>IsKeyPressed</span>(<span>ebiten</span>.<span>KeySpace</span>) {
	<span>p</span>.<span>shootCooldown</span>.<span>Reset</span>()
	<span>// Spawn the bullet
</span><span></span>}
</code></pre></div><p>One new thing is having <code>Player</code> spawn bullets instead of <code>Game</code>.
But <code>Game</code> needs to keep track of the bullets, similar to meteors.</p>
<p>The simplest way is to pass <code>Game</code> to <code>Player</code>‚Äôs constructor and keep it in the struct.
Then, expose an <code>AddBullet</code> method from <code>Game</code>.
It‚Äôs not ideal, as it creates a cross-dependency between <code>Player</code> and <code>Game</code>, but it‚Äôs good enough for now.</p>
<p>I decided to calculate the spawn point on the <code>Player</code> side and make the <code>Bullet</code>‚Äôs constructor take it as an argument.</p>
<div><pre tabindex="0"><code data-lang="go"><span>bulletSpawnOffset</span> <span>:=</span> <span>50.0</span>

<span>bounds</span> <span>:=</span> <span>p</span>.<span>sprite</span>.<span>Bounds</span>()
<span>halfW</span> <span>:=</span> float64(<span>bounds</span>.<span>Dx</span>()) <span>/</span> <span>2</span>
<span>halfH</span> <span>:=</span> float64(<span>bounds</span>.<span>Dy</span>()) <span>/</span> <span>2</span>

<span>spawnPos</span> <span>:=</span> <span>Vector</span>{
	<span>p</span>.<span>position</span>.<span>X</span> <span>+</span> <span>halfW</span> <span>+</span> <span>math</span>.<span>Sin</span>(<span>p</span>.<span>rotation</span>)<span>*</span><span>bulletSpawnOffset</span>,
	<span>p</span>.<span>position</span>.<span>Y</span> <span>+</span> <span>halfH</span> <span>+</span> <span>math</span>.<span>Cos</span>(<span>p</span>.<span>rotation</span>)<span>*-</span><span>bulletSpawnOffset</span>,
}

<span>bullet</span> <span>:=</span> <span>NewBullet</span>(<span>spawnPos</span>, <span>p</span>.<span>rotation</span>)
<span>p</span>.<span>game</span>.<span>AddBullet</span>(<span>bullet</span>)
</code></pre></div><p><img src="https://reubenson.com/recurse/week-3/images/image_12.png" alt="Image.png"/></p>
<h2 id="collisions">Collisions</h2>
<p>Detecting collisions is a complex topic, although, at the basic level, the concept is as simple as iterating over all objects and checking if they intersect.</p>
<p>To make things easier, let‚Äôs introduce a <code>Rect</code> struct that represents a rectangle and makes it easy to check intersections.</p>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Rect</span> <span>struct</span> {
	<span>X</span>      <span>float64</span>
	<span>Y</span>      <span>float64</span>
	<span>Width</span>  <span>float64</span>
	<span>Height</span> <span>float64</span>
}

<span>func</span> <span>NewRect</span>(<span>x</span>, <span>y</span>, <span>width</span>, <span>height</span> <span>float64</span>) <span>Rect</span> {
	<span>return</span> <span>Rect</span>{
		<span>X</span>:      <span>x</span>,
		<span>Y</span>:      <span>y</span>,
		<span>Width</span>:  <span>width</span>,
		<span>Height</span>: <span>height</span>,
	}
}

<span>func</span> (<span>r</span> <span>Rect</span>) <span>MaxX</span>() <span>float64</span> {
	<span>return</span> <span>r</span>.<span>X</span> <span>+</span> <span>r</span>.<span>Width</span>
}

<span>func</span> (<span>r</span> <span>Rect</span>) <span>MaxY</span>() <span>float64</span> {
	<span>return</span> <span>r</span>.<span>Y</span> <span>+</span> <span>r</span>.<span>Height</span>
}

<span>func</span> (<span>r</span> <span>Rect</span>) <span>Intersects</span>(<span>other</span> <span>Rect</span>) <span>bool</span> {
	<span>return</span> <span>r</span>.<span>X</span> <span>&lt;=</span> <span>other</span>.<span>MaxX</span>() <span>&amp;&amp;</span>
		<span>other</span>.<span>X</span> <span>&lt;=</span> <span>r</span>.<span>MaxX</span>() <span>&amp;&amp;</span>
		<span>r</span>.<span>Y</span> <span>&lt;=</span> <span>other</span>.<span>MaxY</span>() <span>&amp;&amp;</span>
		<span>other</span>.<span>Y</span> <span>&lt;=</span> <span>r</span>.<span>MaxY</span>()
}
</code></pre></div><p>Next, each game object exposes a <code>Collider() Rect</code> method.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>p</span> <span>*</span><span>Player</span>) <span>Collider</span>() <span>Rect</span> {
	<span>bounds</span> <span>:=</span> <span>p</span>.<span>sprite</span>.<span>Bounds</span>()

	<span>return</span> <span>NewRect</span>(
		<span>p</span>.<span>position</span>.<span>X</span>,
		<span>p</span>.<span>position</span>.<span>Y</span>,
		float64(<span>bounds</span>.<span>Dx</span>()),
		float64(<span>bounds</span>.<span>Dy</span>()),
	)
}
</code></pre></div><p>In the Game‚Äôs <code>Update</code>, iterate over all objects and check for collisions.</p>
<div><pre tabindex="0"><code data-lang="go"><span>for</span> <span>i</span>, <span>m</span> <span>:=</span> <span>range</span> <span>g</span>.<span>meteors</span> {
	<span>for</span> <span>j</span>, <span>b</span> <span>:=</span> <span>range</span> <span>g</span>.<span>bullets</span> {
		<span>if</span> <span>m</span>.<span>Collider</span>().<span>Intersects</span>(<span>b</span>.<span>Collider</span>()) {
			<span>// A meteor collided with a bullet
</span><span></span>		}
	}
}

<span>for</span> <span>_</span>, <span>m</span> <span>:=</span> <span>range</span> <span>g</span>.<span>meteors</span> {
	<span>if</span> <span>m</span>.<span>Collider</span>().<span>Intersects</span>(<span>g</span>.<span>player</span>.<span>Collider</span>()) {
		<span>// A meteor collided with the player
</span><span></span>	}
}
</code></pre></div><p>When a bullet collides with a meteor, we want to destroy both objects. In our case, this means just dropping them using slice operations. If they‚Äôre gone from the list, the game won‚Äôt call their <code>Update</code> and <code>Draw</code> methods, so they effectively disappear (and the garbage collector handles the rest for us).</p>
<div><pre tabindex="0"><code data-lang="go"><span>if</span> <span>m</span>.<span>Collider</span>().<span>Intersects</span>(<span>b</span>.<span>Collider</span>()) {
	<span>g</span>.<span>meteors</span> = append(<span>g</span>.<span>meteors</span>[:<span>i</span>], <span>g</span>.<span>meteors</span>[<span>i</span><span>+</span><span>1</span>:]<span>...</span>)
	<span>g</span>.<span>bullets</span> = append(<span>g</span>.<span>bullets</span>[:<span>j</span>], <span>g</span>.<span>bullets</span>[<span>j</span><span>+</span><span>1</span>:]<span>...</span>)
}
</code></pre></div><p>A meteor colliding with the player means the game is over. Let‚Äôs restart the game in this case.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Reset</span>() {
	<span>g</span>.<span>player</span> = <span>NewPlayer</span>(<span>g</span>)
	<span>g</span>.<span>meteors</span> = <span>nil</span>
	<span>g</span>.<span>bullets</span> = <span>nil</span>
}
</code></pre></div><h2 id="ui">UI</h2>
<p>Drawing UI is similar to drawing other sprites. Two rules of thumb:</p>
<ul>
<li>It‚Äôs usually the last layer you draw, so it always stays on top.</li>
<li>Sometimes, you want it on a separate section of the screen. In this case, you want to draw the game not directly on the screen but on a smaller canvas that you eventually draw next to the UI.
(You can create an empty image with <a href="https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2#NewImage" target="_blank"><code>ebiten.NewImage</code></a> and use it as a ‚Äúpanel‚Äù).</li>
</ul>
<p>A classic UI example is the score the player gets after shooting down a meteor. We can keep the <code>score</code> as an integer in the <code>Game</code> struct, increment it when a meteor collides with a bullet, and reset it to zero on the game over.</p>
<p>What‚Äôs left is drawing the score on the screen. First, you need to load a font, which is similar to loading a sprite. (I‚Äôm using <a href="https://www.kenney.nl/assets/kenney-fonts" target="_blank">Kenney Fonts</a>.)</p>
<div><pre tabindex="0"><code data-lang="go"><span>var</span> <span>ScoreFont</span> = <span>mustLoadFont</span>(<span>&#34;font.ttf&#34;</span>)

<span>func</span> <span>mustLoadFont</span>(<span>name</span> <span>string</span>) <span>font</span>.<span>Face</span> {
	<span>f</span>, <span>err</span> <span>:=</span> <span>assets</span>.<span>ReadFile</span>(<span>name</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		panic(<span>err</span>)
	}

	<span>tt</span>, <span>err</span> <span>:=</span> <span>opentype</span>.<span>Parse</span>(<span>f</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		panic(<span>err</span>)
	}

	<span>face</span>, <span>err</span> <span>:=</span> <span>opentype</span>.<span>NewFace</span>(<span>tt</span>, <span>&amp;</span><span>opentype</span>.<span>FaceOptions</span>{
		<span>Size</span>:    <span>48</span>,
		<span>DPI</span>:     <span>72</span>,
		<span>Hinting</span>: <span>font</span>.<span>HintingVertical</span>,
	})
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		panic(<span>err</span>)
	}

	<span>return</span> <span>face</span>
}
</code></pre></div><p>Then, call <a href="https://pkg.go.dev/github.com/hajimehoshi/ebiten/text#Draw" target="_blank"><code>text.Draw</code></a> in <code>Game</code>‚Äôs <code>Draw</code>:</p>
<div><pre tabindex="0"><code data-lang="go"><span>text</span>.<span>Draw</span>(<span>screen</span>, <span>fmt</span>.<span>Sprintf</span>(<span>&#34;%06d&#34;</span>, <span>g</span>.<span>score</span>), <span>ScoreFont</span>, <span>ScreenWidth</span><span>/</span><span>2</span><span>-</span><span>100</span>, <span>50</span>, <span>color</span>.<span>White</span>)
</code></pre></div><p>If you want to be precise with the position, use <a href="https://pkg.go.dev/golang.org/x/image/font#BoundString" target="_blank"><code>font.BoundString</code></a>
to get the bounds. In the example above, I just estimated something that looks good enough.</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_13.png" alt="Image.png"/></p>
<h2 id="other-concepts">Other concepts</h2>
<p>This article is already quite long, but I want to mention some ideas you may find helpful once you start making games.</p>
<h3 id="scenes">Scenes</h3>
<p>A scene is a standalone part of your game. For example, the welcome screen, the main menu, or the game itself.</p>
<p>In the <em>meteors</em> project, there‚Äôs a single <code>Game</code> scene.
This could be extended so it‚Äôs possible to switch between scenes, and each has its own <code>Update</code> and <code>Draw</code> methods.
(And manages its own game objects.)</p>
<h3 id="camera">Camera</h3>
<p>I was initially intimidated by the camera concept, but it turned out to be a simple idea.
Your game ‚Äúworld‚Äù can be a big area, and you often don‚Äôt want to show all of it at once. With the camera concept, you draw only part of the bigger image. You can move the camera, make it follow the player, or scale it up and down to achieve the zoom effect.</p>
<p>A trivial example needs just two things:</p>
<ul>
<li>A <code>Camera</code> struct that keeps the position (and optionally scale and other fields).</li>
<li>An <code>offscreen</code> image (initialized with <code>ebiten.NewImage</code>).</li>
</ul>
<div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Game</span> <span>struct</span> {
	<span>camera</span>    <span>*</span><span>Camera</span>
	<span>offscreen</span> <span>*</span><span>ebiten</span>.<span>Image</span>
	
	<span>player</span>  <span>*</span><span>Player</span>
	<span>enemies</span> []<span>*</span><span>Enemy</span>
}

<span>func</span> (<span>g</span> <span>*</span><span>Game</span>) <span>Draw</span>(<span>screen</span> <span>*</span><span>ebiten</span>.<span>Image</span>){
	<span>g</span>.<span>offscreen</span>.<span>Clear</span>()
	
	<span>// Draw the game on the offscreen image
</span><span></span>	<span>g</span>.<span>player</span>.<span>Draw</span>(<span>g</span>.<span>offscreen</span>)
	<span>for</span> <span>_</span>, <span>e</span> <span>:=</span> <span>range</span> <span>g</span>.<span>enemies</span> {
		<span>e</span>.<span>Draw</span>(<span>g</span>.<span>offscreen</span>)
	}

	<span>// Draw the offscreen image on the screen
</span><span></span>	<span>op</span> <span>:=</span> <span>&amp;</span><span>ebiten</span>.<span>DrawImageOptions</span>{}
	<span>op</span>.<span>GeoM</span>.<span>Translate</span>(<span>-</span><span>g</span>.<span>camera</span>.<span>X</span>, <span>-</span><span>g</span>.<span>camera</span>.<span>Y</span>)
	<span>screen</span>.<span>DrawImage</span>(<span>g</span>.<span>offscreen</span>, <span>op</span>)
}
</code></pre></div><p>As you update the camera‚Äôs position, the part of the offscreen image will also change.</p>
<h3 id="animations">Animations</h3>
<p>An animation means changing the sprite of an object over time.
Sometimes, just two or three sprites can create an animation that makes the game look more alive.</p>
<p>To implement it, create a slice of sprites, a timer, and a ‚Äúcurrent sprite index‚Äù. Then, increase the index as the timer resets.</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> (<span>p</span> <span>*</span><span>Player</span>) <span>Update</span>() {
	<span>p</span>.<span>timer</span>.<span>Update</span>()
	<span>if</span> <span>p</span>.<span>timer</span>.<span>IsReady</span>() {
		<span>p</span>.<span>timer</span>.<span>Reset</span>()

		<span>p</span>.<span>index</span><span>++</span>
		<span>if</span> <span>p</span>.<span>index</span> <span>&gt;=</span> len(<span>p</span>.<span>sprites</span>) {
			<span>p</span>.<span>index</span> = <span>0</span>
		}

		<span>p</span>.<span>sprite</span> = <span>p</span>.<span>sprites</span>[<span>p</span>.<span>index</span>]
	}
}
</code></pre></div><p>Animation sprites often come as a single file with frames next to each other.
You can use the <a href="https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2#Image.SubImage" target="_blank"><code>SubImage</code></a> method to extract a single frame from the loaded image.</p>
<p>You can also ‚Äúanimate‚Äù other parameters of an object, like the sprite‚Äôs color or scale.</p>
<h3 id="deploying-to-the-web">Deploying to the web</h3>
<p>It‚Äôs easy to deploy your game with WebAssembly and host it anywhere.</p>
<p>See more details in the <a href="https://ebitengine.org/en/documents/webassembly.html" target="_blank">docs</a>
and on <a href="https://github.com/ThreeDotsLabs/meteors" target="_blank">GitHub</a>.</p>
<h3 id="entity-component-system">Entity Component System</h3>
<p>You probably noticed many common parts between the <code>Player</code>, <code>Meteor</code>, and <code>Bullet</code> game objects. It‚Äôs tempting to extract the common code so it‚Äôs easier to create new objects, and it definitely makes sense.</p>
<p>One way to do it is by keeping a generic <code>GameObject</code> struct from which other game objects inherit. In Go, you could use struct embedding with similar results.</p>
<p>Entity Component System (ECS) is another approach that prefers composition over inheritance.
The idea is to keep common <em>components</em> like position, sprite, and collider as separate structs and then create game objects (<em>entities</em>) by combining them.
All the logic is kept in <em>systems</em> that iterate over all entities and update them.</p>
<p>There are many ECS libraries for Go. My pick is <a href="https://github.com/yohamta/donburi" target="_blank">donburi</a>, and my <a href="https://github.com/m110/airplanes" target="_blank">airplanes</a> game is based on it.</p>
<h3 id="debugging">Debugging</h3>
<p>As with any code, you will sometimes get stuck with hard-to-debug bugs. While using prints for debugging sometimes helps, I like adding visual helpers in place, sort of ‚Äúdebug mode.‚Äù It often shows in a very explicit way where the issue is.</p>
<p>You can make it appear and hide after a key so it doesn‚Äôt interfere with regular gameplay. Here‚Äôs an example debug mode I introduced in <a href="https://github.com/m110/airplanes" target="_blank">airplanes</a>:</p>
<p><img src="https://reubenson.com/recurse/week-3/images/image_14.png" alt=""/></p>
<p>Ebitengine provides some utils for this:</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/ebitenutil#DebugPrintAt" target="_blank"><code>ebitenutil.DebugPrintAt</code></a> ‚Äî to quickly draw a text.</li>
<li>The <a href="https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/vector" target="_blank"><code>vector</code></a> package has functions like <code>StrokeLine</code>, <code>StrokeRect</code>, and <code>StroneCircle</code>.</li>
</ul>
<h2 id="go-build-something">Go build something!</h2>
<p>All this barely scratches the surface of Gamedev. I picked topics that should let you make games and learn the basics. Let me know if you‚Äôd like to see more posts on some topics.</p>
<p>To learn more about Ebitengine, the <a href="https://ebitengine.org/en/examples/" target="_blank">official examples</a> are a great starting point.</p>
<p>My example project is on <a href="https://github.com/ThreeDotsLabs/meteors" target="_blank">GitHub</a>, and you can <a href="https://threedotslabs.github.io/meteors/" target="_blank">play it online</a>. Feel free to fork the repository and iterate over it!</p>
<p>Here are some ideas to implement:</p>
<ul>
<li>Add support for controls using a mouse or gamepad.</li>
<li>Make big meteors ‚Äúbreak‚Äù into small ones instead of disappearing.</li>
<li>Have meteors drop power-ups that the player can collect.</li>
<li>Allow switching weapons.</li>
<li>Add AI spaceships that follow a more complex pattern than flying towards the player.</li>
<li>Add more scenes like the main menu and high scores.</li>
<li>Add sound effects. (It really makes a difference!)</li>
</ul>
<p>If you can‚Äôt figure out how to create some mechanic you came up with (and it will happen a lot), try to figure out each step that needs to happen. For me, sketching using pen and paper often helps.</p>
<p>Now, it‚Äôs time to go and build something. Have fun!</p>
</div></div>
  </body>
</html>
