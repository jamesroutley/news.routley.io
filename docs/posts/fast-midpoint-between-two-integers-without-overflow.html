<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/12/06/fast-midpoint-between-two-integers-without-overflow/">Original</a>
    <h1>Fast midpoint between two integers without overflow</h1>
    
    <div id="readability-page-1" class="page"><article id="post-20061">

<div>
<p>Let us say that I ask you to find the number I am thinking about between -1000 and 1000, by repeatedly guessing a number. With each guess, I tell you whether your guess is correct, smaller or larger than my number. A binary search algorithm tries to find a value in an interval by repeating finding the midpoint, using smaller and smaller intervals. You might start with 0, then use either -500 or 500 and so forth.</p>
<p>Thus we sometimes need a fast algorithm to find the midpoint in an interval of integers.The following simple routine to find the midpoint is incorrect:</p>
<pre><span>int</span> f<span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
  <span>return</span> <span>(</span>x <span>+</span> y<span>)</span><span>/</span><span>2</span><span>;</span>
<span>}</span>
</pre>
<p>If the integers use a 64-bit two’s complement representation, we could pick 1 for x and 9223372036854775807 for y, and then the result of the function could be a large negative value.</p>
<p>Efficient solutions are provided by Warren in Hacker’s Delight (section 2.5):</p>
<pre><span>int</span> f<span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span> 
  <span>return</span> <span>(</span>x|y<span>) </span><span>- </span><span>(</span><span>(</span>x^y<span>)</span><span>&gt;</span><span>&gt;</span><span>1</span><span>)</span><span>;</span> 
<span>}</span>
</pre>

<pre><span>int</span> f<span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span> 
  <span>return</span> <span>(</span><span>(</span>x^y<span>)</span><span>&gt;</span><span>&gt;</span><span>1</span><span>)</span> <span>+</span> <span>(</span>x&amp;y<span>)</span><span>;</span> 
<span>}</span>
</pre>
<p>They provide respectively the smallest value no smaller than (x+y)/2 and the largest value no larger than (x+y)/2. The difference between the two values is <tt>(x ^ y) &amp; 1</tt> (credit: Harold Aptroot).</p>
<p>They follow from the following identities: <tt>x+y=(x^y)+2*(x&amp;y)</tt> and <tt>x+y=2*(x|y)-(x^y)</tt>.</p>
<p><strong>Update</strong>: Reader BartekF observes that C++20 added a dedicated function for this problem: <a href="https://en.cppreference.com/w/cpp/numeric/midpoint">std::midpoint</a>.</p>
</div>
<div>

<p><img alt="" src="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=112&amp;d=mm&amp;r=g 2x" height="56" width="56" loading="lazy" decoding="async"/> </p>

</div>

</article></div>
  </body>
</html>
