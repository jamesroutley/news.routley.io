<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sql-bits.com/the-difference-between-where-and-having/">Original</a>
    <h1>SQL: The difference between WHERE and HAVING</h1>
    
    <div id="readability-page-1" class="page"><article id="post-300">

	<!-- .entry-header -->

	<div>
		
<p><em>SQL clauses </em><code>WHERE</code><em> and </em><code>HAVING</code><em> have different functions. But they both filter out rows, so many people don’t know the important difference between them. Let’s shred some light.</em></p>



<h2>WHERE</h2>



<p>In a single-table query, <code>WHERE</code> comes in at the beginning of a query execution. We used to think that it determines which rows will be returned by the query, but this is not accurate:</p>



<p><strong><code>WHERE</code> determines which rows will be processes by the query.</strong></p>



<p>The difference becomes clear when we use a <code>GROUP BY</code> clause.</p>



<h2>HAVING</h2>



<p>HAVING comes in at the end of a query execution.</p>



<p><strong>After all rows have been processed, <code>HAVING</code> determines which of rows will be sent to the client.</strong></p>



<h2>The differences</h2>



<p>The theory should be clear. But let’s see the differences between <code>WHERE</code> and <code>HAVING</code> in practice.</p>



<h3>GROUP BY</h3>



<p>The difference between <code>WHERE</code> and <code>HAVING</code> becomes clear when we run a query with <code>GROUP BY</code>:</p>



<pre><code>SELECT department_id, count(*) AS employees_no
    FROM employee
    WHERE gender = &#39;F&#39;
    GROUP BY department_id
    HAVING <meta charset="utf-8"/>employees_no &lt; 10;</code></pre>



<p>The query counts the number of female employees  in each department, and only returns the departments where this number is less than 10.</p>



<ul><li><code>WHERE</code> excludes non-female employees. Those rows are not read at all by the query.</li><li><code>GROUP BY</code> <em>groups</em> (or aggregates) the found rows, producing only one row for each distinct <code>department_id</code>.</li><li><code>HAVING</code> eliminates the <em>aggregated</em> rows where <code>employees_no</code> is less than 10.</li></ul>



<p>Note that:</p>



<ul><li><code>WHERE employees_no &lt; 10</code> would fail with an error, because that value doesn’t exist before aggregation.</li><li><code>HAVING gender = &#39;F&#39;</code> would fail with an error, because the gender column doesn’t exist in the aggregated rows (or, if you prefer, in the <code>SELECT</code> clause).</li></ul>



<h3>Query performance</h3>



<p>Sometimes you may think that both <code>WHERE</code> and <code>HAVING</code> can be used, and that they’re equivalent. An example:</p>



<pre><code>SELECT *
    FROM employee
    WHERE date_of_birth &gt; &#39;2000-01-01&#39;;</code></pre>



<p>This query finds the employees that were born in this century.</p>



<p>Could we use <code>HAVING</code> instead of <code>WHERE</code>? In theory, yes. But in that case we’re telling the database to read all rows, and only return the ones that match the condition. This is unnecessarily slow.</p>



<p>With the <code>WHERE</code> clause, we’re asking the database to only read the rows we’re interested in. If there is an index that starts with the date_of_birth column, it will be used.</p>



<p>Note that some DBMSs are smart enough to translate an unnecessary HAVING clause into a WHERE clause. But not all DBMSs do so, and there may always be complex cases when a DBMS fails to apply this optimisation.</p>




















































	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
