<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://srcreigh.ca/posts/error-payloads-in-zig/">Original</a>
    <h1>Error payloads in Zig</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-losip7nv="">  <article>  <time datetime="2026-02-13T00:00:00.000Z"> Feb 13, 2026 </time> <p>I do error payloads in Zig by making a <code>union(enum)</code>-based
Diagnostics type for each function. These types have special methods which
remove code bloat at call sites. A Diagnostics
type can be defined inline, and the errorset can be generated inline from the
Diagnostic’s enum tag.</p>
<pre tabindex="0" data-language="zig"><code><span><span>pub</span><span> fn</span><span> scan</span><span>(</span></span>
<span><span>    db</span><span>: </span><span>*</span><span>c</span><span>.</span><span>sqlite</span><span>,</span></span>
<span><span>    diag</span><span>: </span><span>*</span><span>diagnostics</span><span>.</span><span>FromUnion</span><span>(</span><span>union</span><span>(</span><span>enum</span><span>) {</span></span>
<span><span>        SqliteError</span><span>: </span><span>sqlite</span><span>.</span><span>ErrorPayload</span><span>,</span></span>
<span><span>        OutOfMemory</span><span>: </span><span>void</span><span>,</span></span>
<span><span>        LoadPluginsError</span><span>: </span><span>diagnostics</span><span>.</span><span>OfFunction</span><span>(</span><span>transforms</span><span>.</span><span>loadPlugins</span><span>).</span><span>ErrorPayload</span><span>(</span><span>error</span><span>.</span><span>LoadPluginsError</span><span>),</span></span>
<span><span>    }),</span></span>
<span><span>): </span><span>diagnostics</span><span>.</span><span>Error</span><span>(</span><span>@TypeOf</span><span>(</span><span>diag</span><span>))</span><span>!void</span><span> {</span></span>
<span><span>    // ...</span></span>
<span><span>}</span></span></code></pre>
<p><a href="https://gist.github.com/srcreigh/1d05f1e74150e9c50938c1b6e7bcdff6">My diagnostics module as a gist</a></p>
<p>The generated type is a wrapper around an optional payload. It generates
an error set type from the <code>union(enum)</code> fields.</p>
<pre tabindex="0" data-language="zig"><code><span><span>// diagnostics.zig</span></span>
<span><span>pub</span><span> fn</span><span> FromUnion</span><span>(</span><span>comptime</span><span> _Payload</span><span>: </span><span>type</span><span>) </span><span>type</span><span> {</span></span>
<span><span>    return</span><span> struct</span><span> {</span></span>
<span><span>        pub</span><span> const</span><span> Payload</span><span> =</span><span> _Payload</span><span>;</span></span>
<span><span>        pub</span><span> const</span><span> Error</span><span> =</span><span> ErrorSetFromEnum</span><span>(</span><span>std</span><span>.</span><span>meta</span><span>.</span><span>FieldEnum</span><span>(</span><span>Payload</span><span>));</span></span>
<span></span>
<span><span>        payload</span><span>: </span><span>?</span><span>Payload</span><span> =</span><span> null</span><span>,</span></span>
<span></span>
<span><span>        // ... methods ...</span></span>
<span><span>    };</span></span>
<span><span>}</span></span></code></pre>
<p>The first thing you will want to do is set a payload while you return
an error. For this, there is the <code>withContext</code> method.</p>
<pre tabindex="0" data-language="zig"><code><span><span>pub</span><span> fn</span><span> countRows</span><span>(</span></span>
<span><span>    alloc</span><span>: </span><span>std</span><span>.</span><span>mem</span><span>.</span><span>Allocator</span><span>,</span></span>
<span><span>    db</span><span>: </span><span>*</span><span>c</span><span>.</span><span>sqlite</span><span>,</span></span>
<span><span>    opts</span><span>: </span><span>Options</span><span>,</span></span>
<span><span>    diag</span><span>: </span><span>*</span><span>diagnostics</span><span>.</span><span>FromUnion</span><span>(</span><span>union</span><span>(</span><span>enum</span><span>) {</span></span>
<span><span>        SqliteError</span><span>: </span><span>sqlite</span><span>.</span><span>ErrorPayload</span><span>,</span></span>
<span><span>        OutOfMemory</span><span>: </span><span>void</span><span>,</span></span>
<span><span>    }),</span></span>
<span><span>) </span><span>!usize</span><span> {</span></span>
<span><span>    const</span><span> st</span><span> =</span><span> sqlite</span><span>.</span><span>prepareStmt</span><span>(</span></span>
<span><span>        alloc</span><span>,</span></span>
<span><span>        db</span><span>,</span></span>
<span><span>        &#34;SELECT COUNT(*) FROM {0s} WHERE ({1s})&#34;</span><span>,</span></span>
<span><span>        .{ </span><span>opts</span><span>.</span><span>table_name</span><span>, </span><span>opts</span><span>.</span><span>where_expr</span><span> },</span></span>
<span><span>    ) </span><span>catch</span><span> |</span><span>err</span><span>|</span><span> return</span><span> switch</span><span> (</span><span>err</span><span>) {</span></span>
<span><span>        error</span><span>.</span><span>SqliteError</span><span> =&gt;</span><span> diag</span><span>.</span><span>withContext</span><span>(</span><span>error</span><span>.</span><span>SqliteError</span><span>, .</span><span>init</span><span>(</span><span>db</span><span>)),</span></span>
<span><span>        error</span><span>.</span><span>OutOfMemory</span><span> =&gt;</span><span> error</span><span>.</span><span>OutOfMemory</span><span>,</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // ...</span></span>
<span><span>}</span></span></code></pre>
<p>Here, <code>sqlite.ErrorPayload.init</code> saves 500 bytes of error message from
sqlite. That payload gets saved to <code>diag</code> and the error is returned.</p>
<p>You would expect callsites to need tons of boilerplate, but it’s actually
very common to just need to value copy a payload from one
diag to another, and this can be done in a single line of code.</p>
<pre tabindex="0" data-language="zig"><code><span><span>pub</span><span> const</span><span> BuildDiagnostics</span><span> =</span><span> diagnostics</span><span>.</span><span>FromUnion</span><span>(</span><span>union</span><span>(</span><span>enum</span><span>) {</span></span>
<span><span>    SqliteError</span><span>: </span><span>sqlite</span><span>.</span><span>ErrorPayload</span><span>,</span></span>
<span><span>    OutOfMemory</span><span>: </span><span>void</span><span>,</span></span>
<span><span>    // ... 15 more ...</span></span>
<span><span>});</span></span>
<span></span>
<span><span>pub</span><span> fn</span><span> build</span><span>(..., </span><span>diag</span><span>: </span><span>*</span><span>BuildDiagnostics</span><span>) </span><span>!void</span><span> {</span></span>
<span><span>    // Choose N chunks</span></span>
<span><span>    const</span><span> n_rows</span><span> =</span><span> try</span><span> diag</span><span>.</span><span>call</span><span>(</span><span>countRows</span><span>, .{ </span><span>alloc</span><span>, </span><span>db</span><span>, </span><span>opts</span><span> });</span></span>
<span><span>    const</span><span> n_chunks</span><span> =</span><span> @max</span><span>(</span><span>1</span><span>, </span><span>n_rows</span><span> /</span><span> opts</span><span>.</span><span>chunk_size</span><span>);</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>countRows</code> func needs 4 arguments, but the tuple only has 3.
The <code>call</code> method inspects
the type of <code>countRows</code> to determine the type of its <code>diag</code> arg,
instantiates the diag, calls <code>countRows</code>, and if there is an error, copies the
error payload to the <code>*BuildDiagnostics</code>.</p>
<p>Written explicitly, this call would be around 5 lines of code.</p>
<pre tabindex="0" data-language="zig"><code><span><span>pub</span><span> fn</span><span> build</span><span>(..., </span><span>diag</span><span>: </span><span>*</span><span>BuildDiagnostics</span><span>) </span><span>!void</span><span> {</span></span>
<span><span>    // Choose N chunks</span></span>
<span><span>    var</span><span> count_rows_diag</span><span>: </span><span>diagnostics</span><span>.</span><span>OfFunction</span><span>(</span><span>countRows</span><span>) </span><span>=</span><span> .{};</span></span>
<span><span>    const</span><span> n_rows</span><span> =</span><span> countRows</span><span>(</span><span>alloc</span><span>, </span><span>db</span><span>, </span><span>opts</span><span>, </span><span>&amp;</span><span>count_rows_diag</span><span>) </span><span>catch</span><span> |</span><span>err</span><span>|</span><span> return</span><span> switch</span><span> (</span><span>err</span><span>) {</span></span>
<span><span>        error</span><span>.</span><span>SqliteError</span><span> =&gt;</span><span> diag</span><span>.</span><span>withContext</span><span>(</span><span>error</span><span>.</span><span>SqliteError</span><span>, </span><span>count_rows_diag</span><span>.</span><span>get</span><span>(</span><span>error</span><span>.</span><span>SqliteError</span><span>)),</span></span>
<span><span>        error</span><span>.</span><span>OutOfMemory</span><span> =&gt;</span><span> error</span><span>.</span><span>OutOfMemory</span><span>,</span></span>
<span><span>    }</span></span>
<span><span>    const</span><span> n_chunks</span><span> =</span><span> @max</span><span>(</span><span>1</span><span>, </span><span>n_rows</span><span> /</span><span> opts</span><span>.</span><span>chunk_size</span><span>);</span></span>
<span><span>}</span></span></code></pre>
<p>At the edges, the error payload is accessible for logging or other purposes.</p>
<pre tabindex="0" data-language="zig"><code><span><span>fn</span><span> logBuildError</span><span>(</span><span>diag</span><span>: </span><span>build</span><span>.</span><span>BuildDiagnostics</span><span>, </span><span>err</span><span>: </span><span>build</span><span>.</span><span>BuildDiagnostics</span><span>.</span><span>Error</span><span>) </span><span>void</span><span> {</span></span>
<span><span>    switch</span><span> (</span><span>err</span><span>) {</span></span>
<span><span>        error</span><span>.</span><span>LoadPluginError</span><span> =&gt;</span><span> if</span><span> (</span><span>diag</span><span>.</span><span>get</span><span>(</span><span>error</span><span>.</span><span>LoadPluginError</span><span>)) </span><span>|</span><span>info</span><span>|</span><span> {</span></span>
<span><span>            std</span><span>.</span><span>log</span><span>.</span><span>err</span><span>(</span><span>&#34;failed to load plugin &#39;{s}&#39;: {s}&#34;</span><span>, .{ </span><span>info</span><span>.</span><span>name</span><span>, </span><span>@errorName</span><span>(</span><span>info</span><span>.</span><span>err</span><span>) });</span></span>
<span><span>        } </span><span>else</span><span> {</span></span>
<span><span>            std</span><span>.</span><span>log</span><span>.</span><span>err</span><span>(</span><span>&#34;failed to load plugin: unknown error&#34;</span><span>, .{});</span></span>
<span><span>        },</span></span>
<span></span>
<span><span>        // ... (handle many other errors) ...</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>ZLS can’t infer the result of the <code>diag.call</code> invocations, so it can be useful to put
in an explicit type annotations.</p>
<p><a href="https://gist.github.com/srcreigh/1d05f1e74150e9c50938c1b6e7bcdff6">My diagnostics module as a gist</a></p> </article>  </div></div>
  </body>
</html>
