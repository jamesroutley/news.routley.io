<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.seangoedecke.com/you-cant-design-software-you-dont-work-on/">Original</a>
    <h1>You can&#39;t design software you don&#39;t work on</h1>
    
    <div id="readability-page-1" class="page"><div><article><header></header><section><p>Only the engineers who work on a large software system can meaningfully participate in the design process. That’s because you cannot do good software design without an intimate understanding of the concrete details of the system. In other words, <strong>generic software design advice is typically useless</strong> for most practical software design problems.</p>
<h3>Generic software design</h3>
<p>What is generic software design? It’s “designing to the problem”: the kind of advice you give when you have a reasonable understanding of the <em>domain</em>, but very little knowledge of the existing <em>codebase</em>. Unfortunately, this is the only kind of advice you’ll read in software books and blog posts<sup id="fnref-1"><a href="#fn-1">1</a></sup>. Engineers love giving generic software design advice for the same reason that all technical professionals love “talking shop”. However, you should be very careful about applying generic advice to your concrete day-to-day work problems<sup id="fnref-2"><a href="#fn-2">2</a></sup>.</p>
<p><strong>When you’re doing real work, concrete factors dominate generic factors</strong>. Having a clear understanding of what the code looks like right now is far, far more important than having a good grasp on general design patterns or principles. For instance:</p>
<ul>
<li>In large codebases, consistency is more important than “good design”. I won’t argue that point here, but I wrote about it at length in <a href="https://www.seangoedecke.com/large-established-codebases"><em>Mistakes engineers make in large established codebases</em></a>.</li>
<li>Real codebases are typically full of complex, hard-to-predict consequences. If you want to make your change safely, that typically constrains your implementation choices down to a bare handful of possibilities.</li>
<li>Large shared codebases never reflect a single design, but are always in some intermediate state between different software designs. How the codebase will hang together after an individual change is thus way more important than what ideal “north star” you’re driving towards.</li>
</ul>
<p>In a world where you could rewrite the entire system at will, generic software design advice would be much more practical. Some projects are like this! But <strong>the majority of software engineering work is done on systems that cannot be safely rewritten</strong>. These systems cannot rely on “software design”, but must instead rely on internal consistency and the carefulness of their engineers.</p>
<h3>Concrete software design</h3>
<p>What does good software design look like, then?</p>
<p>In my experience, the most useful software design happens in conversations between a small group of engineers who all have deep understanding of the system, because they’re the ones working on it every day. These design discussions are often <strong>really boring</strong> to outsiders, because they revolve around arcane concrete details of the system, not around general principles that any technical person can understand and have an opinion on.</p>
<p>The kinds of topic being discussed are not “is DRY better than WET”, but instead “could we put this new behavior in subsystem A? No, because it needs information B, which isn’t available to that subsystem in context C, and we can’t expose that without rewriting subsystem D, but if we split up subsystem E here and here…“.</p>
<p>Deep philosophical points about design are rarely important to the discussion. Instead, the most critical contributions point out small misunderstandings of concrete points, like: “oh, you thought B wasn’t available in context C, but we recently refactored C so now we could thread in B if we needed to”.</p>
<h3>When generic software design is useful</h3>
<p>Generic software design advice is not useful for practical software design problems, but that doesn’t mean it’s totally useless.</p>
<p><strong>Generic software design advice is useful for building brand-new projects.</strong> As I argued above, when you’re designing a new feature in an existing system, concrete factors of the system dominate. But when you’re designing a <em>new system</em>, there are no concrete factors, so you can be entirely guided by generic advice.</p>
<p><strong>Generic software design advice is useful for tie-breaking concrete design decisions.</strong> I don’t think you should start with a generic design, but if you have a few candidate concrete pathways that all seem acceptable, generic principles can help you decide between them.</p>
<p>This is particularly true at the level of the entire company. In other words, <strong>generic software design advice can help ensure consistency across different codebases</strong>. This is one of the most useful functions of an official “software architect” role: to provide a set of general principles so that individual engineers can all tie-break their concrete decisions in the same direction<sup id="fnref-3"><a href="#fn-3">3</a></sup>.</p>
<p><strong>Generic software design principles can also guide company-wide architectural decisions.</strong> Should we run our services in our own datacenter, or in the cloud? Should we use k8s? AWS or Azure? Once you get broad enough, the concrete details of individual services almost don’t matter, because it’s going to be a huge amount of work either way. Still, even for these decisions, concrete details matter a lot. There are certain things you just can’t do in the cloud (like rely on bespoke hardware setups), or that you can’t do in your own datacenter (like deploy your service to the edge in twelve different regions). If the concrete details of your codebase rely on one of those things, you’ll be in for a bad time if you ignore them when making company-wide architectural decisions.</p>
<h3>Architects and local minima</h3>
<p>Those are all good reasons to do generic software design. One bad reason companies do generic software design is that it just sounds like a really good idea to people who aren’t working software engineers. Once you’re doing it, the incentives make it hard to stop. Many tech companies fall into this local minimum.</p>
<p>Why not have your highest-paid software engineers spend their time exclusively making the most abstract, highest-impact decisions? You want your structural engineers to be drawing, not laying bricks, after all. I don’t know if structural engineering works like this, but I do know that software engineering doesn’t. In practice, <strong>software architecture advice often has to be ignored by the people on the ground</strong>. There’s simply no way to actually translate it into something they can implement, in the context of the current system as it exists.</p>
<p>However, for a practice that doesn’t work, “have your top engineers just do generic design” is surprisingly robust. <strong>Architects don’t have any skin in the game</strong><sup id="fnref-4"><a href="#fn-4">4</a></sup>, because their designs are handed off to actual engineering teams to implement. Because those designs can never be implemented perfectly, architects can both claim credit for successes (after all, it was their design) and disclaim failures (if only those fools had followed my design!)</p>
<h3>Summary</h3>
<p>When working on large existing codebases, useful software design discussions are way, way more concrete than many people believe. They typically involve talking about individual files or even lines of code. You thus can’t do useful software design without being intimately familiar with the codebase (in practice, that almost always means being an active contributor).</p>
<p>Purely generic architecture is not <em>useless</em>, but its role should be restricted to (a) setting out paved paths for brand new systems, (b) tie-breaking decisions on existing systems, and (c) helping companies make broad technology choices.</p>
<p>In my opinion, formal “big-picture software architect” roles that spend all their time laying out the initial designs for projects are doomed to failure. They sound like a good idea (and they’re a good deal for the architect, who can claim credit without risking blame), but they provide very little value to the engineering teams that are tasked with actually writing the code.</p>
<p>Personally, I believe that <strong>if you come up with the design for a software project, you ought to be responsible for the project’s success or failure</strong>. That would rapidly ensure that the people designing software systems are the people who know how to ship software systems. It would also ensure that the <em>real</em> software designers - the ones that have to take into account all the rough edges and warts of the codebase - get credit for the difficult design work they do.</p>
</section><p>If you liked this post, consider<!-- --> <a href="https://buttondown.com/seangoedecke" target="_blank">subscribing</a> <!-- -->to email updates about my new posts, or<!-- --> <a href="https://news.ycombinator.com/submitlink?u=https://www.seangoedecke.com/you-cant-design-software-you-dont-work-on/&amp;t=You can&#39;t design software you don&#39;t work on" target="_blank">sharing it on Hacker News</a>.<!-- --> Here&#39;s a preview of a related post that shares tags with this one.</p><blockquote><p>Pure and impure software engineering</p><div><p>Why do solo game developers tend to get into fights with big tech engineers? Why do high-profile external hires to large companies often fizzle out? Why is AI-assisted development amazing for some engineers and completely useless for others?</p><p>I think it’s because some engineers are doing very different kinds of work to other engineers. Those two types of engineers often assume their counterparts are simply incompetent, but they’re really just working in different fields.</p></div></blockquote><hr/></article></div></div>
  </body>
</html>
