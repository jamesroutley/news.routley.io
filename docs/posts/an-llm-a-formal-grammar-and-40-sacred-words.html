<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scd31.com/posts/person-do-thing-llm">Original</a>
    <h1>An LLM, a Formal Grammar, and 40 Sacred Words</h1>
    
    <div id="readability-page-1" class="page"><div><section><p>There&#39;s a game my friend Spencer introduced me to called &#34;<a href="https://persondothing.com/">Person Do Thing</a>&#34;. The basic premise of the game is one person will have a random word, which they have to describe to other players. The catch is they can only use 40 basic words to do this, as listed below. For example, if your word was &#34;intuition&#34;, you might say &#34;Person do thing fast and good, person no think&#34;. Other players may make guesses at what the word might be, and you can continue to narrow the word down by providing additional clues.</p><p><a href="https://stytch.com/img/person-do-thing.png"><img src="https://stytch.com/thumb/person-do-thing.png"/></a></p><small>The allowed words of Person Do Thing</small><p>I thought it would be fun to get an LLM to play this game. Spencer and I spent the last few days getting this implemented, and it kind of works. More importantly though, we learned a lot about LLMs.</p><p>The basic premise is pretty simple. We&#39;d use a formal grammar to constrain the LLM&#39;s output to match the rules of the game, and use a system prompt to tell the LLM how to actually play.</p></section><h2>An Informal Definition of Formal Grammar</h2><section><p>Formal grammars are essentially a way to describe how to form strings which conform to a specific formal language. What this means in practice is you can unambiguously define a language in such a way that a computer can decide whether or not a block of text is part of that language or not.</p><p>As a simple example, imagine your formal grammar is <code>root ::= (&#34;yes&#34; | &#34;no&#34;)</code>. The only strings that are valid here would be &#34;yes&#34; or &#34;no&#34;. Formal grammars can be made much more complicated than this by defining more than one rule. You can think of them roughly as Regex on steroids.</p><p>Our grammar for our LLM is as follows (subject to change!). My input to this was minimal - Spencer did the brunt of the work here.</p><pre><span>root </span><span>::= </span><span>thinking newline </span><span>(</span><span>congrats </span><span>| </span><span>sentence </span><span>(</span><span>space sentence</span><span>){</span><span>0</span><span>,</span><span>4</span><span>})
</span><span>thinking</span><span> ::= &#34;</span><span>&lt;think&gt;</span><span>&#34; ([^&lt;&gt;]){</span><span>3500</span><span>,</span><span>10000</span><span>} &#34;</span><span>&lt;/think&gt;</span><span>&#34;
</span><span>sentence</span><span> ::= </span><span>delimitedwords terminal
</span><span>delimitedwords</span><span> ::= </span><span>word </span><span>(</span><span>space word </span><span>| </span><span>comma space word</span><span>){</span><span>0</span><span>,</span><span>100</span><span>}
</span><span>space</span><span> ::= &#34; &#34;
</span><span>comma</span><span> ::= &#34;</span><span>,</span><span>&#34;
</span><span>newline</span><span> ::= &#34;</span><span>\n</span><span>&#34;
</span><span>terminal</span><span> ::= &#34;</span><span>.</span><span>&#34; | &#34;</span><span>?</span><span>&#34; | &#34;</span><span>!</span><span>&#34;
</span><span>congrats</span><span> ::= &#34;</span><span>YOU WIN!!!!!</span><span>&#34;
</span><span>word</span><span> ::= &#34;</span><span>Person</span><span>&#34; | &#34;</span><span>person</span><span>&#34; | &#34;</span><span>Place</span><span>&#34; | &#34;</span><span>place</span><span>&#34; | &#34;</span><span>Thing</span><span>&#34; | &#34;</span><span>thing</span><span>&#34; | &#34;</span><span>Do</span><span>&#34; | &#34;</span><span>do</span><span>&#34; | &#34;</span><span>Eat</span><span>&#34; | &#34;</span><span>eat</span><span>&#34; | &#34;</span><span>Feel</span><span>&#34; | &#34;</span><span>feel</span><span>&#34; | &#34;</span><span>Get</span><span>&#34; | &#34;</span><span>get</span><span>&#34; | &#34;</span><span>Go</span><span>&#34; | &#34;</span><span>go</span><span>&#34; | &#34;</span><span>Have</span><span>&#34; | &#34;</span><span>have</span><span>&#34; | &#34;</span><span>Like</span><span>&#34; | &#34;</span><span>like</span><span>&#34; | &#34;</span><span>Make</span><span>&#34; | &#34;</span><span>make</span><span>&#34; | &#34;</span><span>Say</span><span>&#34; | &#34;</span><span>say</span><span>&#34; | &#34;</span><span>Hear</span><span>&#34; | &#34;</span><span>hear</span><span>&#34; | &#34;</span><span>See</span><span>&#34; | &#34;</span><span>see</span><span>&#34; | &#34;</span><span>Think</span><span>&#34; | &#34;</span><span>think</span><span>&#34; | &#34;</span><span>Use</span><span>&#34; | &#34;</span><span>use</span><span>&#34; | &#34;</span><span>Want</span><span>&#34; | &#34;</span><span>want</span><span>&#34; | &#34;</span><span>Big</span><span>&#34; | &#34;</span><span>big</span><span>&#34; | &#34;</span><span>Far</span><span>&#34; | &#34;</span><span>far</span><span>&#34; | &#34;</span><span>Fast</span><span>&#34; | &#34;</span><span>fast</span><span>&#34; | &#34;</span><span>Good</span><span>&#34; | &#34;</span><span>good</span><span>&#34; | &#34;</span><span>Hot</span><span>&#34; | &#34;</span><span>hot</span><span>&#34; | &#34;</span><span>Many</span><span>&#34; | &#34;</span><span>many</span><span>&#34; | &#34;</span><span>Other</span><span>&#34; | &#34;</span><span>other</span><span>&#34; | &#34;</span><span>Real</span><span>&#34; | &#34;</span><span>real</span><span>&#34; | &#34;</span><span>Hard</span><span>&#34; | &#34;</span><span>hard</span><span>&#34; | &#34;</span><span>Same</span><span>&#34; | &#34;</span><span>same</span><span>&#34; | &#34;</span><span>After</span><span>&#34; | &#34;</span><span>after</span><span>&#34; | &#34;</span><span>Before</span><span>&#34; | &#34;</span><span>before</span><span>&#34; | &#34;</span><span>Again</span><span>&#34; | &#34;</span><span>again</span><span>&#34; | &#34;</span><span>And</span><span>&#34; | &#34;</span><span>and</span><span>&#34; | &#34;</span><span>But</span><span>&#34; | &#34;</span><span>but</span><span>&#34; | &#34;</span><span>In</span><span>&#34; | &#34;</span><span>in</span><span>&#34; | &#34;</span><span>On</span><span>&#34; | &#34;</span><span>on</span><span>&#34; | &#34;</span><span>With</span><span>&#34; | &#34;</span><span>with</span><span>&#34; | &#34;</span><span>More</span><span>&#34; | &#34;</span><span>more</span><span>&#34; | &#34;</span><span>Yes</span><span>&#34; | &#34;</span><span>yes</span><span>&#34; | &#34;</span><span>No</span><span>&#34; | &#34;</span><span>no</span><span>&#34; | &#34;</span><span>Can</span><span>&#34; | &#34;</span><span>can</span><span>&#34; | &#34;</span><span>Up</span><span>&#34; | &#34;</span><span>up</span><span>&#34;
</span><span>
</span></pre>
<p>This formal grammar basically says the following:</p><ul><li><p>The LLM can think freely inside of &lt;think&gt;&lt;/think&gt; XML tags</p></li><li><p>Outside of the XML tags, the LLM can only construct 1-5 sentences using the 40 basic words allowed by the game</p></li><li><p>Alternatively, the LLM can say <code>YOU WIN!!!!!</code> if the user correctly guessed the word</p></li></ul><p>The reason for the &lt;think&gt; tags is for something called Chain of Thought, or CoT. CoT allows the LLM to think before it answers, and in practice this can massively improve the quality of the output. Especially with us constraining the output format as much as we are, CoT helps even more. The model we&#39;re using, distilled from DeepSeek R1, is trained to perform CoT inside of these &lt;think&gt; tags. Note that we force the thinking to be between 3500 and 10000 characters, as we found the quality was reduced when it thought for less than that.</p></section><h2>Formal Grammars and LLMs</h2><section><p>So now that we have a formal grammar, how can we use it with an LLM? One naive approach would be to just give it to the LLM and tell it &#34;make your output conform to this&#34;. But LLMs are pretty bad at this, and there would be nothing enforcing that the LLM actually sticks to the grammar.</p><p>Instead, we can use the formal grammar to inform the token sampler. That is to say, when the LLM spits out the next batch of possible tokens, the token sampler will only choose one that conforms to the formal grammar we specified. This means the LLM has to conform to the grammar no matter what.</p><p>As you can imagine, this property is extremely useful. Outside of this silly game, I&#39;ve used this technique extensively to force LLMs to output e.g. valid JSON that has a precise structure that I expect.</p></section><h2>Prompt Engineering and Murder</h2><section><p>The formal grammar on its own is not a silver bullet. Ideally we want the LLM to choose tokens that almost always match the formal grammar so that we rarely need to &#34;steer&#34; it. Without this, we would see the LLM want to say a forbidden word, and then the sampler would have to choose a much less likely token. This massively reduced the quality of the output and sometimes the LLM would go completely off the rails.</p><p>Our prompt is primarily a description of the game along with all allowed words. This helped a lot with getting the LLM to output high-quality hints. We did find it would ignore the prompt at times, but adding a &#34;Do XYZ or else you will die&#34; made it a lot less willing to deviate. I&#39;ve had good success with similar techniques in the past, where threatening murder (or similarly bad things) really help the LLM stay on course.</p></section><h2>Infrastructure and Front-end</h2><section><p>For doing silly LLM projects I normally like to use Ollama, because it exposes an HTTP API. I like this because it means I can run Ollama on my GPU server and have other projects connect to it. Unfortunately, Ollama&#39;s formal grammar support is extremely lackluster and is only good for structured JSON. I&#39;m not sure why they chose to do this - even for practical things (i.e. not this game), there are other formats that require fewer tokens (such as XML) and thus use less processing power.</p><p>Anyway, Ollama is out, so I chose to just go with Llama.cpp. This is a powerful inference engine which supports a ton of features. Most importantly, its token sampler can follow a custom formal grammar, which is what we need.</p><p>We can&#39;t expose Llama.cpp directly to the end-user, though, because it would give away the answer. The LLM&#39;s thinking must be hidden away. When play-testing, Spencer would hold a piece of paper over my screen, which obviously would need to be handled more gracefully. The fancy approach would be to use actual bindings to interface with Llama.cpp. Instead, I went with the hacky approach of writing a basic front-end around Llama.cpp&#39;s command-line interface. This front-end chooses a random word, inserts it into the prompt, and obscures the thinking of the LLM from the user.</p><p>We rented a cheap GPU server for actually demoing the project to people. My GPU server is alright, but for under a dollar an hour we can rent some much more powerful hardware. Our friend <a href="https://eieio.games/">Nolen</a> pointed out that speed is really important for engagement, and he&#39;s absolutely right. Taking a minute for the computer to think in between guesses really ruined the flow of the game, especially when compared to the real-time feedback you get when playing with other people.</p></section><h2>Earlier Attempts</h2><section><p>While getting our prompt and grammar fine-tuned, we ran into all sorts of hilarity from the LLM. Especially in the thinking block, the computer said all sorts of funny (and kind of cute!) things.</p></section><h3>Cats are real and have fur</h3><section><blockquote><p>A cat is a <b><b>big</b></b> <b><b>real</b></b> <b><b>fur</b></b> creature that can move <b><b>fast</b></b> when it&#39;s running. It is <b><b>big</b></b> while sleeping on <b><b>soft</b></b> ground. The cat can move <b><b>fast</b></b> when it&#39;s moving. It is <b><b>big</b></b> when it&#39;s on <b><b>big</b></b> ground because the ground is soft. The cat is <b><b>real</b></b> because it is a living creature. It can move <b><b>fast</b></b> when it&#39;s moving. It is <b><b>big</b></b> when it&#39;s on <b><b>big</b></b> ground because the ground is soft. The cat can
move <b><b>fast</b></b> when it&#39;s moving. It is <b><b>real</b></b> because it is a living creature. It is <b><b>big</b></b> when it&#39;s on <b><b>big</b></b> ground because the ground is soft. The cat can move <b><b>fast</b></b> when it is moving. It is <b><b>big</b></b> when it is on <b><b>big</b></b> ground because the ground is soft.</p></blockquote></section><h3>Trucks are not wolves?</h3><section><blockquote><p>Alright, the user guessed &#34;truck&#34; in response to my description of &#34;wolf&#34;. I need to respond in a way that&#39;s encouraging but clear that it&#39;s not correct.</p><p>First, I should acknowledge the guess positively. &#34;Truck&#34; is a thing, so that&#39;s on the right track. I should say &#34;yes&#34; to acknowledge the correct category but then clarify that it&#39;s not the right word.</p><p>Now, I need to provide more clues without giving it away. Since the target is &#34;wolf&#34;, I can mention that the thing has fur, which differentiates it from a truck. <b><b>Trucks have wheels and engines, while wolves have fur and live in the wild.</b></b></p><p>I should also mention that the thing moves on its own, which is true for both wolves and trucks, but adding that it moves in groups (packs) can help narrow it down. Additionally, I can hint at the sound it makes, like howling, which is another unique characteristic of wolves.</p><p>Putting this all together, my response should reinforce that it&#39;s a thing, provide new information about fur, movement, and sound, without directly saying &#34;wolf&#34;. This way, the user gets more clues to narrow down the correct answer.</p><p>&lt;/think&gt;</p><p>Yes, it is a thing, but it is not a truck. The thing has fur. It moves on its own. Many of them go together. They make a sound.</p></blockquote></section><h3>No more thinking</h3><section><p>This was a problem of our grammar being insufficiently constrained, and our system prompt not being refined/specific enough.</p><blockquote><p>&gt; is it a truck</p><p>&lt;think&gt;</p><p>Alright, so the user guessed &#34;truck&#34; when I described &#34;cat.&#34; Let me break down how to respond appropriately.</p><p>First, I need to acknowledge that &#34;truck&#34; isn&#39;t correct but provide feedback that&#39;s encouraging. Since &#34;truck&#34; is a thing, the category is right, so I should mention that.</p><p>Next, I should clarify that while a truck is a thing, it&#39;s not the same as the target word. I can add that the thing I&#39;m describing is smaller. Maybe something like, &#34;Yes, it is a thing, but no, it is not a truck.&#34;</p><p>Then, to give a hint, I can mention another characteristic of a cat. For example, it has fur. So, I can say, &#34;It has fur.&#34;</p><p>Putting it all together, the response should be positive, confirm the correct category, explain why &#34;truck&#34; isn&#39;t the answer, and provide another clue to help the user get closer to the right word.</p><p>&lt;/think&gt;</p><p>Yes, but no. Yes, person have thing. Yes, thing go place. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink. No, nothink.</p></blockquote></section><h2>Closing Thoughts</h2><section><p>We learned a lot while building this, and the LLM is a lot better at playing &#34;Person Do Thing&#34; than when we started, but it&#39;s still pretty terrible. It&#39;s a fun proof of concept but humans are way better at the game. I think a big part of this is that LLMs are currently quite bad at theory of mind, which is important for playing &#34;Person Do Thing&#34;. The hints you give depend heavily on what the other players are thinking, and this is where the LLM really struggles.</p></section><h2>Source</h2><section><p>If you want to see our (pretty hacky) source code, it&#39;s on <a href="https://gitlab.scd31.com/stephen/person-do-thing-llm">my Git server</a>, as usual!</p></section></div></div>
  </body>
</html>
