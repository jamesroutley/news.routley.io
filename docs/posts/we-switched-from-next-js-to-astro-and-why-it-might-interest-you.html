<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datocms.com/blog/why-we-switched-to-astro">Original</a>
    <h1>We switched from Next.js to Astro (and why it might interest you)</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content"> <div>  <p>If everything went according to plan, no one should have noticed anything. But for a few days now, this site has been completely new.</p><p><strong>We took our old Next 13 site and completely rewrote it in Astro! üßë‚ÄçüöÄüöÄ</strong></p><p>Not only that: we also moved from the classic Vercel hosting to a completely server-side rendering approach on a VPS, which allows our team an editing experience with immediate feedback, combined with a blazing-fast CDN for the website visitors.</p><p>Astro was a bet. We didn&#39;t know it well enough to be sure everything would go as expected. But <strong>the result was a complete success from every perspective</strong>, and the development experience was extremely educational and ‚Äî not something to be taken for granted ‚Äî <em>fun</em>.</p><p>The final architecture offers performance and consumption typical of a static site, coupled with instant and granular page-level invalidation thanks to our <a href="https://www.datocms.com/blog/introducing-datocms-cache-tags">Cache Tags</a>. The dream of every website. </p><p>This is part one of a series of articles in which we&#39;ll try to summarize our journey, sharing many cool little Astro details we discovered (or totally came up with) in the process. We hope they can be useful to those, who like us, manage a content-driven site and would like to consider an alternative to the classic Next/Nuxt/Svelte + Vercel/Netlify stack.</p><p>Now let‚Äôs be clear ‚Äì by no means are we suggesting we‚Äôre <em>against </em>Next.js. Heck, we‚Äôre incredibly proud of the official <a href="http://next.js">Next.js conference starter</a> which was originally built with DatoCMS in 2020! However, considering our content and sitemap, several factors came into play to make this decision.</p><h2> Why did you do it? <a data-anchor="why-did-you-do-it" id="why-did-you-do-it"></a><a data-permalink="" href="#why-did-you-do-it"></a></h2><p>There are many reasons why we needed to make BIG changes to our website.</p><h5> TypeScript <a data-anchor="typescript" id="typescript"></a><a data-permalink="" href="#typescript"></a></h5><p>Our Next site was a project born in 2019: five years in the magical frontend world is a geological era (unfortunately). At the time, there were no reliable typed GraphQL schema generators. The result was that the old site was written in pure JS, without TypeScript. Over time, as pages increased, we felt less and less comfortable making big modifications with the confidence of not breaking anything.</p><p>Hence the first objective: <strong>regain confidence by switching to a complete TypeScript codebase</strong>, where every GraphQL query would be fully typed. But since that meant rewriting a good chunk of our code anyways, why not consider alternatives to Next.js?</p><h5> Eating our own dog food <a data-anchor="eating-our-own-dog-food" id="eating-our-own-dog-food"></a><a data-permalink="" href="#eating-our-own-dog-food"></a></h5><p>Our product, DatoCMS, has changed A LOT since 2019. Yet our Next site wasn&#39;t leveraging some of the coolest features we&#39;ve released in recent times, like <a href="https://www.datocms.com/blog/introducing-strict-mode-for-graphql-cda-get-the-best-typescript-dx">GraphQL &#34;Strict Mode&#34;</a> ‚Äî which pairs wonderfully with TypeScript ‚Äî but especially <a href="https://www.datocms.com/blog/introducing-datocms-cache-tags">Cache Tags</a>, which can offer top-notch performance through <strong>completely static and cached content</strong>, while still letting visitors access the latest version of any page, seconds after changes have been published.</p><p>We wanted a site that represented <strong>the state of the art of what DatoCMS can offer</strong>.</p><h5> A simpler mental model <a data-anchor="a-simpler-mental-model" id="a-simpler-mental-model"></a><a data-permalink="" href="#a-simpler-mental-model"></a></h5><p>In 2019, Next.js introduced <a href="https://nextjs.org/blog/next-9-3#next-gen-static-site-generation-ssg-support"><code>getStaticProps()</code></a> along with <a href="https://nextjs.org/blog/next-9-3#preview-mode">Draft Mode </a>‚Äî a revolutionary hybrid static/dynamic approach that was a breath of fresh air compared to our former Gatsby setup. The developer experience was delightful and straightforward.</p><p>Fast forward to today, and the React ecosystem has transformed dramatically. Setting up React is now so complex that React itself <a href="https://react.dev/learn/start-a-new-react-project">recommends using it exclusively through a framework</a>. Next.js and React have become almost indistinguishable, to the point where, at the time of its public launch, Next.js 15 was using... an unreleased React release candidate?</p><p>Starting with Next.js 14, the introduction of the app router, Server Components, and Incremental Regeneration (ISR) have <strong>exponentially increased complexity</strong>. Our team frequently encountered bewildering results and errors, with Next.js documentation offering little clarity about the underlying mechanics. We&#39;re not alone in this frustration ‚Äî many developers are questioning the framework&#39;s direction (i.e. <a href="https://www.epicweb.dev/why-i-wont-use-nextjs">Why I Won&#39;t Use Next.js</a>).</p><p>While Next.js 15 addresses some issues, and is an incredibly powerful framework, it feels like React/Next is moving in a direction that isn&#39;t ours. <strong>For a content-driven site with static pages that look the same to every visitor, these increasingly sophisticated solutions feel like overkill </strong>and force us into unnecessary complexity.</p><p>Hence the last objectives:</p><ul><li><p><strong>return to a simple mental model</strong> that doesn&#39;t require a frontend degree to navigate without making massive errors.</p></li><li><p><strong>design a simple, standards-based architecture</strong> that offers maximum control and remains cost-effective.</p></li></ul><h2> Why Astro? <a data-anchor="why-astro" id="why-astro"></a><a data-permalink="" href="#why-astro"></a></h2><p>With these premises, choosing Astro as the reference framework was quite an obvious consequence.</p><p>To use DatoCMS Cache Tags, the only requirement at the &#34;engine&#34; level of the website is to offer a server-side rendering mode capable of freely manipulating the headers of each page&#39;s response, and <a href="https://docs.astro.build/en/reference/api-reference/">Astro checks the box</a>. This is certainly not a strict requirement: Next, Nuxt, SvelteKit... are all frameworks that offer server-side rendering.</p><p>The critical distinction lies in their core architectures. Next, Nuxt, and SvelteKit are built with complex, runtime browser rendering engines ‚Äî a massive overhead for content-driven websites with minimal interactive elements. This approach introduces unnecessary mental overhead for developers, forcing them to constantly juggle the cognitive load of writing code that must execute flawlessly in both server and browser environments. It also increases the overall computational complexity and page size for the final visitor.</p><p>Astro takes a bold and clear position: it is firmly focused on server-side and static generation. Unlike its competitors, <strong>Astro categorically refuses browser-side rendering</strong>. It doesn&#39;t just minimize client-side rendering ‚Äî it eliminates it entirely. And this goes exactly towards our goal: a simple mental model.</p><blockquote> <p>Wait, why not just use PHP then? üëÄ</p>  </blockquote><p>Because web development isn&#39;t black and white. No site can be completely absent of JavaScript ‚Äî <em>certainly not ours!</em> And when you need to break free from pure server-side rendering and add interactive elements, Astro provides a seamless solution that PHP simply cannot match.</p><p>Having Vite as its engine, Astro allows you to effortlessly insert JavaScript code, handling all the bundling for you. Moreover: if for particular areas of the page you need strong browser-side interactivity, Astro allows you to insert entire <a href="https://docs.astro.build/en/concepts/islands/">interactive &#34;islands&#34;</a> of React/Vue/Svelte, limiting hydration only to those specific parts.</p><p>That&#39;s exactly what we, and most content-driven websites, need: the performance and simplicity of server-side rendering for the vast majority of the pages, combined with targeted, rich interactivity where necessary.</p><p><em>(Also, as you may recall, one of our goals was to incorporate a form of safety net through typed languages. PHP/Ruby/Python are not inherently typed, plus lack advanced tools like TypeScript for automatically managing the typing of GraphQL queries. So yeah, PHP will need to take a backseat for now. </em>ü§∑‚Äç‚ôÇÔ∏è<em>)</em></p><h2> The new stack <a data-anchor="the-new-stack" id="the-new-stack"></a><a data-permalink="" href="#the-new-stack"></a></h2><figure> <img-lightbox> <a href="https://www.datocms-assets.com/205/1732877403-schema.svg?auto=format&amp;fit=max&amp;w=2000"><img src="https://www.datocms-assets.com/205/1732877403-schema.svg"/></a></img-lightbox>  <figcaption>Wow, that&#39;s a lot of arrows! (14 to be precise)</figcaption> </figure><p>Let&#39;s analyze it point by point what we came out with:</p><ul><li><p>The new site is written in Astro and uses the <a href="https://docs.astro.build/en/guides/integrations-guide/node/">Node adapter</a>, meaning the final output of a build is a <strong>Node.js server</strong> that needs to run on a physical server. Astro generates new server-side responses for each incoming request.</p></li><li><p>The server in question is a VPS on <a href="https://www.hetzner.com/">Hetzner</a>. The app deployment is managed by <a href="https://kamal-deploy.org/">Kamal</a>, and can occur manually from the command line or via GitHub Actions. With Hetzner&#39;s outrageous prices, you can acquire all the necessary hardware for the task, and more, for just ‚Ç¨15/month.</p></li><li><p>The domain <code>www-draft.datocms.com</code> points directly to the Astro server.</p></li><li><p>The domain <code>www.datocms.com</code>, on the other hand, points to Fastly, a CDN that supports <a href="https://docs.fastly.com/en/guides/working-with-surrogate-keys">surrogate keys</a>. Fastly uses <code>www-draft.datocms.com</code> as the origin.</p></li><li><p>Astro pages, depending on whether the request host is either <code>www-draft</code> or <code>www</code>, will execute GraphQL requests to DatoCMS with the <a href="https://www.datocms.com/docs/content-delivery-api/api-endpoints#preview-mode-to-retrieve-draft-content"><code>X-Include-Drafts</code> header</a> either active or not. This allows our team to access draft content while regular visitors do not.</p></li><li><p>Astro also leverages <a href="https://www.datocms.com/blog/introducing-datocms-cache-tags">DatoCMS Cache Tags</a> to cache pages on Fastly indefinitely. In practical terms, Astro reads the <code>X-Cache-Tags</code> header for each GraphQL request made to DatoCMS, and applies those tags identically in its own response via the <code>Surrogate-Key</code> header.</p></li></ul><p>There&#39;s only one missing piece: cache invalidation. DatoCMS, through webhooks, sends cache invalidation tags to the Astro server with every content change on the CMS. Astro then uses those tags to <a href="https://docs.fastly.com/en/guides/purging-with-surrogate-keys">purge the Fastly cache</a> via an API call:</p><figure> <img-lightbox> <a href="https://www.datocms-assets.com/205/1732877411-schema2.svg?auto=format&amp;fit=max&amp;w=2000"><img src="https://www.datocms-assets.com/205/1732877411-schema2.svg"/></a></img-lightbox>  <figcaption>Cache invalidation via DatoCMS Webhooks</figcaption> </figure><h2> How did it go? <a data-anchor="how-did-it-go" id="how-did-it-go"></a><a data-permalink="" href="#how-did-it-go"></a></h2><p>Honestly, <strong>we cannot be happier</strong> about the final result:</p><ul><li><p>Astro&#39;s support for TypeScript is excellent, and in general, it has allowed us to do everything we needed, even when we had to go outside &#34;the norm&#34;.</p></li><li><p>The mental model of the architecture is extremely simple: <strong>everything&#39;s server-side generated. Period.</strong> No re-hydration, no huge client-side JavaScript bundles.</p></li><li><p>Our team can work on the content and see the results in real-time as they save their drafts through <a href="https://www.datocms.com/marketplace/plugins/i/datocms-plugin-web-previews">Web Previews</a> and <a href="https://www.datocms.com/docs/astro/real-time-updates">Real-time Updates</a>.</p></li><li><p>End visitors always get cached content from CDN (thanks to <a href="https://httpwg.org/specs/rfc5861.html#rfc.section.3"><code>stale-while-revalidate</code></a>), so the <strong>response is immediate</strong>.</p></li><li><p>Thanks to cache tags, <strong>cache purging is laser-precise</strong>, ensuring that only the pages that truly require updates are invalidated...</p></li><li><p>...yet, developers do not need to take any action to manage all the traditional complexity of caching. Once again, the mental model is straightforward, to the extent that <strong>you can forget about it</strong>.</p></li><li><p>Thanks to Fastly, <strong>cache purging happens in less than 150ms</strong>: if we accidentally publish incorrect content, we can correct it instantly, without having to wait minutes for a build to complete.</p></li><li><p>Complete builds and cache purging only occur when a new version of the repo is pushed. In our case, the <strong>total build time is approximately 3 minutes</strong>. We can probably improve this if we commit ourselves... the important feature, however, is that this time is <strong>independent of the number of pages</strong> on the site.</p></li><li><p>Last, but not least: <strong>hosting costs are ridiculously low</strong>.</p></li></ul><h2> How bad was the actual migration? <a data-anchor="how-bad-was-the-actual-migration" id="how-bad-was-the-actual-migration"></a><a data-permalink="" href="#how-bad-was-the-actual-migration"></a></h2><p>Our site is about a hundred different sections: from the beginning of the first tests to the full release, approximately <strong>two and a half months</strong> have passed. Not bad, considering it was never a full-time commitment, and that it has only been <a href="https://www.marcomezzavilla.com/">Marco</a> and me working on it.</p><p>Astro&#39;s <a href="https://docs.astro.build/en/basics/astro-syntax/">JSX-like syntax</a> made it pretty easy to transition all the components. Only the more complex components have remained in React as <a href="https://docs.astro.build/en/concepts/islands/">Astro Islands</a>, while small interactivity (<code>useState</code>, <code>useEffect</code>, etc.) has been <strong>converted into Web Components</strong> fairly easily. </p><h2> &#34;I want the juicy details!&#34; <a data-anchor="i-want-the-juicy-details" id="i-want-the-juicy-details"></a><a data-permalink="" href="#i-want-the-juicy-details"></a></h2><p>Good, because we can&#39;t wait to talk to you about it! üòú After this first introduction to the overall architecture of the new site, the upcoming articles will explore in detail many practical topics related to Astro in conjunction with DatoCMS, and how we achieved clear, clean, and highly maintainable code.</p><p>These are just a few of the topics we want to discuss:</p><ul><li><p>Typed GraphQL schema;</p></li><li><p>GraphQL Fragment Colocation;</p></li><li><p>URL Building / SEO Management / Sitemaps;</p></li><li><p>Error management;</p></li><li><p>Astro Actions;</p></li><li><p>Replacing React with Web Components;</p></li><li><p>View Transitions;</p></li><li><p>SVGs;</p></li></ul><p>Whether you&#39;re considering a similar migration or just curious about modern web development best practices, we hope our journey inspires and informs yours. See you in the next episode! üëã</p>  </div> </div></div>
  </body>
</html>
