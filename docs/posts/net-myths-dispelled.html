<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.devgenius.io/6-net-myths-dispelled-celebrating-21-years-of-net-652795c2ea27?gi=7ef0cf441b4f">Original</a>
    <h1>.NET Myths Dispelled</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><div><div><div><a href="https://chrlschn.medium.com/?source=post_page-----652795c2ea27-----------------------------------" rel="noopener follow"><div><p><img alt="Charles Chen" src="https://miro.medium.com/fit/c/96/96/1*Ma9WNU9-D07rYJ0oShp-og.jpeg" width="48" height="48"/></p></div></a></div></div></div></div></div><p id="82b4">According to Wikipedia, <a href="https://en.wikipedia.org/wiki/.NET_Framework" rel="noopener ugc nofollow" target="_blank">.NET will be celebrating it’s 21st birthday this year</a> on February 14, 2022 (<em>author’s note: the date was changed! It’s the 20th birthday of the official release!</em>).</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*14rbEu7li0QXVha6qDwWNQ.png" width="700" height="467" role="presentation"/></p></div></figure><p id="4e78">It’s been around for so long that I think many myths and misunderstandings about .NET from the early days persist; modern .NET is very different from the .NET Framework that started the whole journey.</p><p id="44f6">In celebration of .NET reaching Minimum Legal Drinking Age here in the US, grab a cold one and let’s dispel 6 common myths about .NET!</p><ol><li id="5e2b">.NET is for Windows</li><li id="4dbb">It’s slower than Node/Python/Go/Rust</li><li id="0111">It’s a legacy platform</li><li id="8b3c">The tooling is expensive</li><li id="edc4">.NET isn’t open source friendly</li><li id="9459">It’s for boomer enterprise development</li></ol><p id="7e22">This myth persists from the early days of the .NET Framework. Indeed, it was true: the .NET Framework was initially built for Windows and in its internals, had many references to the Win32 APIs via P/Invoke which barred it from being cross platform and this persisted even while <a href="https://en.wikipedia.org/wiki/Mono_(software)" rel="noopener ugc nofollow" target="_blank">the Mono project was started by Miguel de Icaza</a> to bring .NET to Linux.</p><p id="0f71">It wasn’t until Microsoft got serious with .NET Core in 2016 did they start to address many of the gaps in Mono and the lingering dependencies on the Win32 APIs. Those early days of .NET <em>Core </em>vs .NET <em>Framework </em>were a mess, but thankfully, that’s all in the past with .NET 5 and now .NET 6.</p><p id="308e">Today, .NET 6 — the most current .NET — <a href="https://dotnet.microsoft.com/en-us/download/dotnet/6.0" rel="noopener ugc nofollow" target="_blank">runs on <strong>Windows</strong>, <strong>Linux</strong>, and <strong>macOS</strong> with support for <strong>x86</strong>, <strong>x64</strong>, <strong>Arm32</strong>, and <strong>Arm64</strong></a>.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/0*4r_04ef-HRDBYDKS?q=20" width="663" height="292" role="presentation"/></p><p><img alt="" width="663" height="292" role="presentation"/></p></div></div></div><figcaption>Microsoft ships SDKs and runtimes for multiple platforms.</figcaption></figure><p id="72d6">This means that, yes, <strong>you can build .NET applications on the latest M1 MacBooks</strong>:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/0*aUH9Xg0bsM1hQo8N?q=20" width="631" height="396" role="presentation"/></p><p><img alt="" width="631" height="396" role="presentation"/></p></div></div></div><figcaption>Building a simple console app from the command line on a 2021 MacBook Pro M1.</figcaption></figure><p id="eeac">And run them on the latest AWS Arm-based EC2 instances. <a href="https://hub.docker.com/_/microsoft-dotnet" rel="noopener ugc nofollow" target="_blank">Microsoft’s official Docker images</a> includes builds for all major Linux platforms:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/0*CkT7iy5aLHEVbiPM?q=20" width="660" height="114" role="presentation"/></p><p><img alt="" width="660" height="114" role="presentation"/></p></div></div></div><figcaption>Microsoft’s Docker Hub listings for .NET include multiple flavors of Linux.</figcaption></figure><p id="cced">This also means that you can build .NET in your CI/CD pipelines on Linux whether you’re using GitHub, GitLab, or other CI/CD tools.</p><p id="5797">In reality, .NET 6 is <strong><em>extremely high throughput</em></strong> and in web workloads provides <em>many times the throughput</em> of any of the frameworks running on Node and Python.</p><p id="d9e5">Where this myth may have started is with earlier versions of ASP.NET. You see, ASP.NET and .NET have always supported asynchronous programming models (what we know today as async/await), but it was somewhat awkward to use and inaccessible to developers in the earlier days (using asynchronous delegates) and thus rarely (and I mean <em>very, very rarely</em>) ever used by most developers. Without asynchronous programming, blocking I/O becomes a key constraint, even in a multi-threaded runtime.</p><p id="e4b5">In the TechEmpower Benchmarks, <a href="https://www.techempower.com/benchmarks/#section=data-r20&amp;hw=ph&amp;test=composite" rel="noopener ugc nofollow" target="_blank">Round 15 from February 14, 2018</a>, you can see that ASP.NET actually trails Node.js:</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*f23b39QbaT92kNo48mMRlg.png?q=20" width="700" height="308" role="presentation"/></p><p><img alt="" width="700" height="308" role="presentation"/></p></div></div></div></div><figcaption>2018: Node.js at <strong>#8</strong>, ASP.NET Core at<strong> #13</strong>, Express at <strong>#28</strong>, Flask at <strong>#57</strong>, Django at<strong> #61</strong></figcaption></figure><p id="b4bc">But by <a href="https://www.techempower.com/benchmarks/#section=data-r20&amp;hw=ph&amp;test=composite&amp;l=yykfst-sf" rel="noopener ugc nofollow" target="_blank">Round 20 in February 8, 2021</a> — just 3 years later — it is <strong><em>absolutely crushing</em></strong> Node (teal-green) and Python (blue):</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*EpmbENFwek0Jscb1Cg6CSA.png?q=20" width="700" height="464" role="presentation"/></p><p><img alt="" width="700" height="464" role="presentation"/></p></div></div></div></div><figcaption>2021: ASP.NET Core at <strong>#8</strong>, Node.js at <strong>#56</strong>, Express at <strong>#94</strong>, Flask at <strong>#111</strong>, Django at <strong>#118</strong></figcaption></figure><p id="798d">What seems insane is that .NET scores <em>3x higher on JSON handling</em> than Node and scores <em>an order of magnitude higher</em> in plaintext handling. Just what are these benchmarks? Are they somehow biased towards .NET? <a href="https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/JavaScript/express/app.js" rel="noopener ugc nofollow" target="_blank">Here’s the code for Express</a>:</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*zsht7DjxXO6ce-pNb8qcdQ.png?q=20" width="700" height="264" role="presentation"/></p><p><img alt="" width="700" height="264" role="presentation"/></p></div></div></div></div><figcaption>Line 36 is the JSON benchmark and line 38–39 is the plain text benchmark.</figcaption></figure><p id="600e">And here’s <a href="https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/CSharp/aspnetcore/Benchmarks/Controllers/HomeController.cs" rel="noopener ugc nofollow" target="_blank">the code for .NET 6</a> (to be benchmarked in round 21):</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*JO4z3f5IP_udsWUESKZP5A.png?q=20" width="700" height="264" role="presentation"/></p><p><img alt="" width="700" height="264" role="presentation"/></p></div></div></div></div><figcaption>Line 15 returns the plain text response “Hello, World!”, as does line 20 in JSON.</figcaption></figure><p id="8978">If we look at the chart above, <em>there is an order of magnitude in scale</em> between Express and .NET in these two actions (JSON: 105,747 vs 1,242,834 and text: 140,585 vs 7,022,212) and I expect the raw numbers to widen with .NET 6 in round 21.</p><p id="370c">Don’t be fooled by the visual position in this chart; I’ve filtered to only JavaScript, Python, Rust, and Go runtimes. Overall, Node is in <strong><em>56th</em></strong> position while Express is all the ways down at the bottom in <strong><em>94th </em></strong>with no Python based framework higher than <strong><em>61st</em></strong>.</p><p id="62d9"><a href="https://github.com/LesnyRumcajs/grpc_bench/wiki/2022-01-11-bench-results" rel="noopener ugc nofollow" target="_blank">In gRPC benchmarks, .NET is also <strong><em>crushing </em></strong>it</a> (an order of magnitude greater throughput than Node):</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*NzxfoNSBTcR4R4MSomZxFw.png?q=20" width="700" height="605" role="presentation"/></p><p><img alt="" width="700" height="605" role="presentation"/></p></div></div></div></div><figcaption>If you’re doing gRPC, don’t even think about Node or Python.</figcaption></figure><p id="4f24">If I told you that there was a way to achieve <strong><em>multiples</em></strong> of your current application throughput using a well-supported, mainstream, mature, open source, mutli-platform runtime, and a language that looks an awful lot like TypeScript — on your current infrastructure or cloud budget — wouldn’t that be worthwhile to seriously consider? At scale, this delta in throughput can equate to a significant delta in cost.</p><p id="03bd">It’s not just in web benchmarks. In fact, <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html" rel="noopener ugc nofollow" target="_blank">.NET even <em>trounces</em> Go</a> in raw compute. (See <a href="https://medium.com/u/cbe3ffdda648?source=post_page-----652795c2ea27-----------------------------------" rel="noopener" target="_blank">Alex Yakunin</a>’s <a href="https://medium.com/servicetitan-engineering/go-vs-c-part-3-compiler-runtime-type-system-modules-and-everything-else-faa423dddb34" rel="noopener">series on Go vs C#</a> for a much deeper dive.)</p><p id="cabb">Of course, there are cases where .NET will lose to Go, Python, and Node. This is especially true when it comes to “cold starts” because of the nature of the just-in-time compilation to machine code (plus other nuances of how .NET processes start) and thus making it unsuitable for certain types of applications such as CLI tools or serverless functions that require near instant response for a single request.</p><p id="de08">However, it’s not nearly as bad as it once was. <a href="https://medium.com/@tainguyenbui/optimizing-c-aws-lambda-with-custom-runtime-2f1f69f0431a" rel="noopener">Tai Nguyen Bui has a great set of benchmarks</a> that show how .NET cold starts can be reduced in AWS Lambda with very little effort and the Microsoft team is working on an <a href="https://twitter.com/davidfowl/status/1391580410119819265?lang=en" rel="noopener ugc nofollow" target="_blank">improved native ahead-of-time compilation (“native AOT”) for .NET 7</a>.</p><p id="be7e"><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-aspnet-core-6/" rel="noopener ugc nofollow" target="_blank">With additional improvements and a focus on performance with each release</a>, I have no doubt that .NET will continue to get faster.</p><p id="9f6a">To be fair, .NET would now be considered an adult here in the US so it’s easy to see it as a “legacy” platform with the new cool kids being Go and Rust.</p><p id="0f31">Yet I find this assessment of the platform to be misaligned with reality. In 2010, <a href="https://twitter.com/davidfowl/status/1391580410119819265?lang=en" rel="noopener ugc nofollow" target="_blank">.NET shipped with the Dynamic Language Runtime (DLR)</a> and in doing so, ushered in an era of rapid and continued innovation with respect to the runtime and supported programming languages as it allowed dynamic languages and dynamic language features to be incorporated on top of .NET. <a href="https://charliedigital.com/2009/05/28/visitor-pattern-in-c-4-0/" rel="noopener ugc nofollow" target="_blank">Here’s a blog post I wrote in 2009 showing how to implement the Visitor pattern using double dispatch in C# 4.0</a>.</p><p id="7fd5">As .NET has evolved, it has also adopted many functional programming techniques. Today, it is possible to build using a mixture of object-oriented and functional techniques in .NET. The runtime supports:</p><ul><li id="8b28"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching" rel="noopener ugc nofollow" target="_blank">pattern matching</a></li><li id="8a96"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards" rel="noopener ugc nofollow" target="_blank">discards</a></li><li id="2fcc"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct" rel="noopener ugc nofollow" target="_blank">deconstructing and tuples</a></li><li id="b106"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members" rel="noopener ugc nofollow" target="_blank">expression-bodied members</a></li></ul><p id="b9f0">It has <a href="https://csharpindepth.com/articles/Closures" rel="noopener ugc nofollow" target="_blank">lambda closures</a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics" rel="noopener ugc nofollow" target="_blank">generics</a> (which <a href="https://go.dev/doc/tutorial/generics" rel="noopener ugc nofollow" target="_blank">Go is just getting around to</a>), <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="noopener ugc nofollow" target="_blank">extension methods</a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types" rel="noopener ugc nofollow" target="_blank">anonymous types</a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/records" rel="noopener ugc nofollow" target="_blank">record types</a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions" rel="noopener ugc nofollow" target="_blank">local functions</a>, <a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/" rel="noopener ugc nofollow" target="_blank">channels</a>, and more!</p><p id="23b9"><a href="https://octoverse.github.com/#top-languages-over-the-years" rel="noopener ugc nofollow" target="_blank">According to GitHubs 2021 State of the Octoverse report</a>, C# has had a bit of a resurgence in the last few years:</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*QMTzx9D59KdMx8LQYlmc7Q.png?q=20" width="700" height="360" role="presentation"/></p><p><img alt="" width="700" height="360" role="presentation"/></p></div></div></div></div><figcaption>C# making a comeback; TypeScript going meteoric! Anders Hejlsberg and Microsoft claiming two of the top 5!</figcaption></figure><p id="30ed">There’s good reason for more developers to consider C# on the server, <a rel="noopener ugc nofollow" target="_blank" href="https://blog.devgenius.io/building-up-from-javascript-to-typescript-to-c-10-and-net-6-669a70cd0a66">especially if they are already comfortable with JavaScript and TypeScript</a>.</p><p id="334e">With LINQ, C# looks an awful lot like JavaScript:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*5bTKzUqtLm2OaK-stZRH5Q.png?q=20" width="680" height="270" role="presentation"/></p><p><img alt="" width="680" height="270" role="presentation"/></p></div></div></div><figcaption>TypeScript/JavaScript array functions up top and LINQ extensions in C# below.</figcaption></figure><p id="b431">It should be no surprise that C# and TypeScript bear a striking resemblance because <a href="https://en.wikipedia.org/wiki/Anders_Hejlsberg" rel="noopener ugc nofollow" target="_blank">they were both designed by Anders Hejlsberg of Microsoft:</a></p><p id="7846">TypeScript:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*zX0Xb92X7f43twcFYV0Nxg.png?q=20" width="680" height="602" role="presentation"/></p><p><img alt="" width="680" height="602" role="presentation"/></p></div></div></div><figcaption>TypeScript code listing with an interface, class, and inheritance.</figcaption></figure><p id="1af7">C#:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*oNljROkFp-Ttg1fXHPlrkA.png?q=20" width="680" height="602" role="presentation"/></p><p><img alt="" width="680" height="602" role="presentation"/></p></div></div></div><figcaption>The same listing in C#</figcaption></figure><p id="5a09">(If you like Nest.js, chances are you’ll probably like .NET Web APIs because of how congruent the two frameworks are.)</p><p id="3ca0">C# — the most dominant language on .NET — <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10" rel="noopener ugc nofollow" target="_blank">continues to evolve and add features</a>. And as Microsoft continues to invest in <a href="https://fsharp.org/" rel="noopener ugc nofollow" target="_blank">F#</a>, C# will inherit many of the dynamic, functional elements of F#.</p><p id="7055">(<a href="https://www.reddit.com/r/dotnet/comments/sbsoyd/comment/hu1xvbx/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">via u/swalpaExtraChutney</a>)</p><p id="ea97">Like many myths about .NET, this likely formed based on early tooling in Visual Studio which was indeed, quite expensive (in the thousands of dollars!).</p><p id="2173">These days, not only does Microsoft provide a free, pretty much fully featured <a href="https://visualstudio.microsoft.com/vs/community/" rel="noopener ugc nofollow" target="_blank">Community Edition of Visual Studio</a>, there are other options to choose from as well:</p><ul><li id="8bff"><a href="https://www.jetbrains.com/rider/buy/#discounts" rel="noopener ugc nofollow" target="_blank">JetBrains Rider with paid and free licenses</a></li><li id="3048"><a href="https://visualstudio.microsoft.com/vs/mac/preview/" rel="noopener ugc nofollow" target="_blank">Visual Studio for macOS</a></li><li id="7c85">and of course, <a href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">VS Code</a></li></ul><p id="6082">These days, <a href="https://chrlschn.medium.com/dev-diaries-net-development-on-a-macbook-pro-m1-75359c25b697" rel="noopener">I do most of my C#/.NET in VS Code on a 2021 MacBook Pro M1</a>:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/0*3FDyFbeVMO3MkGxG?q=20" width="660" height="395" role="presentation"/></p><p><img alt="" width="660" height="395" role="presentation"/></p></div></div></div><figcaption>C# in VS Code on a 2021 MacBook Pro M1 with the OmniSharp extension for language features.</figcaption></figure><p id="7330">And it works (mostly) flawlessly.</p><p id="ef5f">Even fully featured Enterprise Visual Studio is reasonably priced nowadays for the productivity that it provides.</p><p id="4b71">Like many .NET myths, this one originates from the days of Microsoft under Steve Ballmer.</p><p id="62a3">Since Satya Nadella has taken the reigns, Microsoft’s entire trajectory with respect to open source has shifted.</p><p id="1379">.NET itself is governed by the <a href="https://dotnetfoundation.org/" rel="noopener ugc nofollow" target="_blank">.NET Foundation</a>, the <a href="https://github.com/dotnet/roslyn" rel="noopener ugc nofollow" target="_blank">.NET compiler</a> along with <a href="https://github.com/dotnet" rel="noopener ugc nofollow" target="_blank">many other internals</a> are all in GitHub public repos, and since 2015, <a href="https://developers.redhat.com/blog/2015/11/04/red-hat-microsoft-making-dot-net-on-linux-for-enterprises" rel="noopener ugc nofollow" target="_blank">it has been certified for Red Hat Enterprise Linux</a>.</p><p id="ccfb">While the usual suspects dominate <a href="https://madnight.github.io/githut/#/pull_requests/2021/4" rel="noopener ugc nofollow" target="_blank">GitHub’s language charts</a>, C# pulls in at a respectable 9th place.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/0*2rnjEK2M5-3A_SpS?q=20" width="660" height="350" role="presentation"/></p><p><img alt="" width="660" height="350" role="presentation"/></p></div></div></div><figcaption>C# has pretty much always been in the 2–4% range</figcaption></figure><p id="324a">While <a href="https://www.nuget.org/packages" rel="noopener ugc nofollow" target="_blank">the Nuget package repository</a> doesn’t have nearly as many package options as NPM, I find that the key packages that matter are all very stable, well written, secure, and well documented; I’ve rarely felt lacking in open source options for the applications I’ve built.</p><p id="972a">What’s more is that Nuget tends to have less “filler”. This is a side effect of a much richer set of standard and base class libraries for .NET. Having a deep set of first party libraries written and maintained by paid professionals is an incredible asset.</p><p id="ee27">(via <a href="https://www.reddit.com/r/dotnet/comments/sbsoyd/comment/hu2dvs5/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">u/similarintrests</a>)</p><p id="db37">Yes; it <strong><em>is</em></strong> a great platform for enterprise development, but .NET is also one of the most versatile platforms to build on, full stop.</p><p id="2d64">Very few languages are as accessible as C# while being able to build applications for virtually any use case from desktop to devices to web servers to 3D games. <a href="https://docs.unity3d.com/2020.1/Documentation/Manual/CreatingAndUsingScripts.html" rel="noopener ugc nofollow" target="_blank">The Unity game engine natively supports C#</a> and a ton of games are built on Unity <a href="https://www.thegamer.com/unity-game-engine-great-games/" rel="noopener ugc nofollow" target="_blank">including Cuphead, Hearthstone, Rust</a>, and <a href="https://unity.com/madewith" rel="noopener ugc nofollow" target="_blank">Escape from Tarkov</a>!</p><figure><div></div><figcaption>Tutorial by Charger Games showing how to use C# to script games in Unity.</figcaption></figure><p id="59a9">.NET can also be used to build cross-platform apps using a number of frameworks like:</p><ul><li id="9141"><a href="https://docs.microsoft.com/en-us/dotnet/maui/what-is-maui" rel="noopener ugc nofollow" target="_blank">Microsoft’s own Multi-platform App UI</a></li><li id="a4b4"><a href="https://platform.uno/" rel="noopener ugc nofollow" target="_blank">The Uno Platform</a></li><li id="ed70">and <a href="https://avaloniaui.net/" rel="noopener ugc nofollow" target="_blank">Avalonia</a></li></ul><p id="a3c3">With .NET 6 minimal APIs, Microsoft moves .NET closer to the realm of “simpler” language runtimes such as Go, Python, and Node.js and makes it far more approachable for hobbyists and weekend hackers.</p><p id="9a10">Here’s a .NET 6 minimal Web API:</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*NCf-qyJzXB0UzeT3aYyu7Q.png?q=20" width="680" height="171" role="presentation"/></p><p><img alt="" width="680" height="171" role="presentation"/></p></div></div></div><figcaption>C# .NET 6 minimal style REST API</figcaption></figure><p id="b2bf">Compare that to Express (JavaScript):</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*l3OR0fVdI26yfNGtsOYV7A.png?q=20" width="680" height="171" role="presentation"/></p><p><img alt="" width="680" height="171" role="presentation"/></p></div></div></div><figcaption>JavaScript Express.js REST API</figcaption></figure><p id="41ec">Or Fiber (Go):</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*N0pdeVwt-vSlheckuxrEDA.png?q=20" width="680" height="264" role="presentation"/></p><p><img alt="" width="680" height="264" role="presentation"/></p></div></div></div><figcaption>Go Fiber REST API</figcaption></figure><p id="f576">Or Flask (Python):</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*xl4j9LrWG4KPpQNVlgWcWA.png?q=20" width="680" height="150" role="presentation"/></p><p><img alt="" width="680" height="150" role="presentation"/></p></div></div></div><figcaption>Python Flask REST API</figcaption></figure></div></div></div><div><div><div><p id="eadc">My hope is that as .NET turns 21, this post helps dispel a few of the long-standing myths about .NET which continue to be prevalent in the development community.</p><p id="5d5c">The reality is that .NET and C# are an extremely versatile and highly performant runtime and language to work with while providing many additional benefits for developers, teams, and enterprises; the platform and language continue to evolve and innovate.</p><p id="7a3d">Especially for teams considering TypeScript on Node.js web frameworks like Express or Nest, .NET and C# should definitely be evaluated given the tremendous advantage in throughput that can be achieved!🍻</p><p id="0a1c">(For more discussion, check out <a href="https://www.reddit.com/r/dotnet/comments/sbsoyd/what_are_some_net_myths_that_need_to_be_dispelled/" rel="noopener ugc nofollow" target="_blank"><strong>this Reddit post</strong></a> and <a href="https://news.ycombinator.com/item?id=30654114" rel="noopener ugc nofollow" target="_blank"><strong>this Hacker News thread</strong></a>)</p></div></div></div></div>
  </body>
</html>
