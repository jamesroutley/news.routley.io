<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.neilhenning.dev/posts/yourownconstantfolder/">Original</a>
    <h1>Own Constant Folder in C/C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        <p>I was talking with someone today that really really wanted the <code>sqrtps</code> to be used in some code they were writing. And because of a quirk with clang (still there as of clang 18.1.0), if you happened to use <code>-ffast-math</code> clang would butcher the use of the intrinsic. So for the code:</p>
<pre tabindex="0"><code>__m128 test(const __m128 vec)
{
    return _mm_sqrt_ps(vec);
}
</code></pre><p>Clang would compile it correctly without fast-math:</p>
<pre tabindex="0"><code>test:                                   # @test
        sqrtps  xmm0, xmm0
        ret
</code></pre><p>And create this monstrosity with <code>-ffast-math</code>:</p>
<pre tabindex="0"><code>.LCPI0_0:
        .long   0xbf000000                      # float -0.5
        .long   0xbf000000                      # float -0.5
        .long   0xbf000000                      # float -0.5
        .long   0xbf000000                      # float -0.5
.LCPI0_1:
        .long   0xc0400000                      # float -3
        .long   0xc0400000                      # float -3
        .long   0xc0400000                      # float -3
        .long   0xc0400000                      # float -3
test:
        rsqrtps xmm1, xmm0
        movaps  xmm2, xmm0
        mulps   xmm2, xmm1
        movaps  xmm3, xmmword ptr [rip + .LCPI0_0] # xmm3 = [-5.0E-1,-5.0E-1,-5.0E-1,-5.0E-1]
        mulps   xmm3, xmm2
        mulps   xmm2, xmm1
        addps   xmm2, xmmword ptr [rip + .LCPI0_1]
        mulps   xmm2, xmm3
        xorps   xmm1, xmm1
        cmpneqps        xmm0, xmm1
        andps   xmm0, xmm2
        ret
</code></pre><p>The optimization flow here in LLVM is:</p>
<ul>
<li>That under fast-math conditions, <code>sqrt(x)</code> == <code>x * rsqrt(x)</code>, so it uses <code>rsqrtps</code> instead.</li>
<li>But that has precision issues between Intel and AMD due to a high ULP tolerance for the <code>rsqrtps</code> instruction.</li>
<li>So LLVM does two newton-raphson iterations anytime it calls <code>rsqrtps</code> to correct the precision between the CPU implementations.</li>
</ul>
<p>The ‘fix’ here is just to use inline assembly to guarantee you’ll get the instruction selection you want always:</p>
<pre tabindex="0"><code>__m128 test(__m128 vec)
{
    __asm__ (&#34;sqrtps %1, %0&#34; : &#34;=x&#34;(vec) : &#34;x&#34;(vec));
    return vec;
}
</code></pre><p>But there is one additional thing I’d advocate you do if you need to use inline assembly - write your own constant folding.</p>
<p>See the one downside to the inline assembly above is that if <code>test</code> is inlined and <code>vec</code> was a constant, it wouldn’t constant fold it. For example:</p>
<pre tabindex="0"><code>__attribute__((always_inline)) __m128 test(__m128 vec)
{
    __asm__ (&#34;sqrtps %1, %0&#34; : &#34;=x&#34;(vec) : &#34;x&#34;(vec));
    return vec;
}

__m128 call_test()
{
    return test(_mm_setr_ps(1.f, 2.f, 3.f, 4.f));
}
</code></pre><p>Will produce:</p>
<pre tabindex="0"><code>test:
        sqrtps  xmm0, xmm0
        ret
.LCPI1_0:
        .long   0x3f800000                      # float 1
        .long   0x40000000                      # float 2
        .long   0x40400000                      # float 3
        .long   0x40800000                      # float 4
call_test:
        movaps  xmm0, xmmword ptr [rip + .LCPI1_0] # xmm0 = [1.0E+0,2.0E+0,3.0E+0,4.0E+0]
        sqrtps  xmm0, xmm0
        ret
</code></pre><p>So that even under inlining, when we could have constant folded it away entirely, we are still calling <code>sqrtps</code> when we don’t have to. So what is the fix?</p>
<p>LLVM has an intrinsic <code>is_constant</code> which can be got at via the Clang-supported GCC extension <code>__builtin_constant_p</code>. If we extend our <code>test</code> above to check when <code>vec</code> is constant, we can call <code>_mm_sqrt_ps</code> when it is constant, and benefit from the constant folder doing its thing and removing the call entirely. So our code becomes:</p>
<pre tabindex="0"><code>__attribute__((always_inline)) __m128 test(__m128 vec)
{
    if (__builtin_constant_p(vec))
    {
        return _mm_sqrt_ps(vec);
    }

    __asm__ (&#34;sqrtps %1, %0&#34; : &#34;=x&#34;(vec) : &#34;x&#34;(vec));
    return vec;
}

__m128 call_test()
{
    return test(_mm_setr_ps(1.f, 2.f, 3.f, 4.f));
}
</code></pre><p>And we get:</p>
<pre tabindex="0"><code>call_test:
        movaps  xmm0, xmmword ptr [rip + .LCPI11_0] # xmm0 = [1.0E+0,2.0E+0,3.0E+0,4.0E+0]
        sqrtps  xmm0, xmm0
        ret
</code></pre><p>What the heck?! It hasn’t constant folded! Turns out GCC is a bit picky with this builtin, and it looks like LLVM has inherited that funky behaviour. You cannot use it with a vector - even though LLVM happily has the support in the IR for it. But there is a workaround, an ugly one:</p>
<pre tabindex="0"><code>__attribute__((always_inline)) __m128 test(__m128 vec)
{
    if (__builtin_constant_p(vec[0]) &amp;&amp;
      __builtin_constant_p(vec[1]) &amp;&amp;
      __builtin_constant_p(vec[2]) &amp;&amp;
      __builtin_constant_p(vec[3]))
    {
        return _mm_sqrt_ps(vec);
    }

    __asm__ (&#34;sqrtps %1, %0&#34; : &#34;=x&#34;(vec) : &#34;x&#34;(vec));
    return vec;
}

__m128 call_test()
{
    return test(_mm_setr_ps(1.f, 2.f, 3.f, 4.f));
}
</code></pre><p>Will produce:</p>
<pre tabindex="0"><code>.LCPI15_0:
        .long   0x3f800000                      # float 1
        .long   0x3fb504f3                      # float 1.41421354
        .long   0x3fddb3d7                      # float 1.73205078
        .long   0x40000000                      # float 2
call_test:
        movaps  xmm0, xmmword ptr [rip + .LCPI15_0] # xmm0 = [1.0E+0,1.41421354E+0,1.73205078E+0,2.0E+0]
        ret
</code></pre><p>Nice! We’ve got the constant folding we want. And also nicely, if we mark <code>test</code> as <code>noinline</code> instead, the code for <code>test</code> is:</p>
<pre tabindex="0"><code>test:
        sqrtps  xmm0, xmm0
        ret
</code></pre><p>Meaning the branch is folded away. In both cases we now get the behaviour we want. We’ve wrote our own constant folder. Nice! You can see the full example on <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1AB9U8lJL6yAngGVG6AMKpaAVxYMQkgMykHAGTwGTAA5dwAjTGIQAE4NUgAHVAVCWwZnNw8vXySUmwFA4LCWSOi4i0wrfIYhAiZiAgz3Tx8KqrTa%2BoJC0Iio2PiFOoamrNahrp7i0oGASgtUV2Jkdg4AUgAmbyDkNywAajXvR1UWFiCCYiCAOgQj7DWNAEFHp4B6N/2AFQRMfZI8MAgmJ9mgsNdXqYmARLnhwq4CJhTFAGKggrQgphZrN9qYWFwNgAOfbhJjoYyo9GYiB4gnEgBumGQs1eawA7AAhV77Hn7YiYAhLBi4s7GBQARwaxgSCggjOZRy5z3ZABFWc9aUTQWJaMZSeTKQwMcEICzlZzubz%2BYLiML9RS0UbqcZRUpLtLZVxrlRSPsNt7fd4A/tJN7sYrWWy1cqNcZobD4YjkRAxAB3JgATwUxipwWxuJddJJZLjtHTWZzTpNmoZTLNLwtz15fIFQpFLDFkoIHrldYj5ujL1j%2BK1olouvtacz2dzmFNkaVT2b1rbk7L08rxrnLo7buIPa9Pr9waDR9DVHD3kXqvV70%2BPz%2BNFUmHQoIwmAhsfjV0TSOMKMdLd8xrfYnwdWcaULLV5XrdlF2bKEFA7Yx9ggTYNglBoZUODYAFYuF9TZcI0dD9hAHCNiOFVVHQ3tmTIiiaI2DY6MveCrVbW19nlfsG0HSEoOJMddTAw0t3nc12J5FcuNEwDnVdAV9xlCBD19f0j1PX1zzYyN%2BK/GEfwRP8oCnCtZ2AwTQLwVRS3LGcq23KyYIXS0eUQ5DUPQzCCGwoiCJw4jSPI9CqKYliYIY9DwtYlkrzclsbWFHj4oHW8QOE4wwLMhzxNgxslw4pLrNsnLNwU3clIPYMNMDYMdLi68o1vV4Pm%2BX4SWIVAAGtGDfcEBO/OFjOTMTMUskdiXCLreoYcDHMgybuL7SSErwKhUNMeE6BsOa0AYCZBGlWKErghLl044Ud07KUVJc1LCp5G8Y0egsmCQ0wvOYny/LwgKiJI5iouYsLaMikLmJimDGoSmTkqZXjnqHJ4Mp1PUZsYea8tcpsitXDG5rG6tFPdFS1OPTT6rDGG0peqFDOGpN/xTddzMciai2mnrMbKiCQJc1bcZ5dbNr1VwdqCYx9sO7sEhOoXDgK5sLuK66fJ7e6pMV/TXo8z60O%2Brtfvwwi8MBjZgco7xqLButLahusadeuHluQRHmrpqzMq52a7I3CD8q1l2fZ51ncoqsUqrJmqTypi8naR282ofElMCGfqP0Ghnf1G%2BS8xxEDIiGLHnWclaGy1kXIO22hdqlgQZeOnjcI5EjcJVHFNgANm7gsa7r6W6iOuXm45Lg1nbzuNh76e%2B/F2vJcHwxZboieOUoyecJnru54lvaG6HlfR%2B8CeO/rZszoVlW2zVrsNb7B6L495GELjD6UINjCjYUQL/rN4KKKg2Yqxe2ttmRO2vlxFKTUdao3HHqNO3YiZzkDrDS6qdi7IJpCTZSnoY6UzPNTd2sC4zZxGszXm7MC5WSLt2Sh4l%2Bbl0vq9KuW154DwPsvJuCMW5tw7lvXubC971wOofbhbsW7j03t3QRYthFL2HqvFuG9%2BEyNnkIhe%2B9RFcJHjwjkJ9J7n15Mw5WeMuK31urKTWp1n4JT1h/by39f6myCkDCGVsbbAPBoxMBukFYu2gXpdKXs0a0L9mzbGgtnboLCfQiOe5qpHlqvsLSIYiEPSRhweYtBOC4V4J4DgWhSCoE4I4fYChFjLD%2BJsbwPBSAEE0Fk%2BY3UQDEX0JwSQ%2BTGnFM4LwBQIB4gNMKVk0gcBYAwEQCgVALAEh0CiOQSgaAZlzOiMgXYhhgBcEJFweINBa5RH6RAcI3TwjAmIBmTgdTTnMHOQAeXCNoJkQy6lLLYIIW5RoLnDNIFgeEwBHA6n6dwXgWAWAbPEN8/A/JrB4EZECopmBnzIGMpc3gFxKjdIxNNeoGZnBYG6bCFgqL5hUAMMABQAA1PAmBUy3ISIwVFMhBAiDEOwKQTL5BKDUN03QBEDBGBAKYKW%2Bg4T9MgPMVACRqhAoALS3O8LwVAjJiBXCwGK00bQnlpHsAwJwLhmgSA2H4XVUw%2BhlHiLkVIAhRieAJIkZIVqGCmpKP0colgtUCE6CMfVWQ7XuphZ64Y3RMTTFdYMINNrDUWCDc6mYcR5gVKWCsCQ2TcldO%2BSUjg%2BxVCEi7jKrukhQT8uAPsLZ1wvQaFQrgQgJAcK1NmLwIZWhsSkBad4IM7bO1du7V3dpHBOmkCJW0gpRTM19IGfUxp8wxmTKWbM%2BgZAKAQDnSslA6yjBbJ2XwHaBzKDHO%2BdcnFjLD13IeU8xlrzGAEA%2BbQL5RTfmuH%2BYCxloLwWrHvXgaFNg4XdMRUyFFwLyCCAxd8rFxAcV4vfY2q4RLgUkrJZS6ltL6UFLqfwZlY42XSHQ5ylQ6hvm6F8MWwVZgRXhHVRKqVaRZVUCoO9AgMqwUEAQPsOVCrinKtVWneACbKges8BABwka7UBBDWaiQXACKWuqMJ%2B1eQ0ixv6DsmImqA01AjT621Rr/XVC9cGoo4nJMEQmN6zItro2TDEy66IymE2VOTVwVNHA8mkBHYqzg2bc35sLeuktZaK1VvwEQYgdbHONqnfMX4ZJ%2Bgapyf23gQ74huZ6RwcdgyIuttafEOL7HktjsncMltcWNjptHb0grzb5jKpSHYSQQA">godbolt</a>.</p>
<p>It’d be nice if we could just use the vector in <code>__builtin_constant_p</code>, but I think the LLVM folks have purposefully tried to match what GCC would do. I’d personally advocate for a loosening of the builtin, and I might file a GitHub issue about just that.</p>

      </div></div></div>
  </body>
</html>
