<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dolphin-emu.org/blog/2022/12/21/dolphin-progress-report-september-october-november-2022/">Original</a>
    <h1>Dolphin Progress September, October, and November 2022</h1>
    
    <div id="readability-page-1" class="page"><div>
      <header>
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/progressreportheader-octo2022.jpg"/>
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/progressreportheader-octo2022mini.jpg"/>
</header>

<p>As we hit the holiday season, our Progress Report <em>might</em> be considered a bit late.  A two month report became a three month report as we realized just how much work we had to catch up on.  While the usual <em>summer</em> burst of activity didn&#39;t come, it seems instead everyone poured their time in throughout the autumn months!  There&#39;s so many features, performance improvements, quality of life updates, and more that had to be considered.</p>
<p>We&#39;re going to have to skip out on some of the smaller updates this time around because there are so many big hitters.  For instance, if you hate shader stuttering, Dolphin&#39;s <a href="https://dolphin-emu.org/blog/2017/07/30/ubershaders/">Ubershaders</a> have gotten a new tool that helps smooth out issues on Vulkan, D3D12, and Metal thanks to Dynamic Vertex Shaders that help reduce/remove pipeline compiles during gameplay.</p>
<p>If you&#39;re on a weaker device that stays away from Ubershaders... maybe after these optimizations you might finally be able to make the leap.  Raw performance in Dolphin is up across the board thanks to many optimizations to the GPU emulation thread (which is emulated on CPU).  Because this optimization affects the very core of Dolphin, pretty much every game should be faster, with a few select games seeing improvements of <em>roughly 50%</em>!</p>
<p>If you&#39;re looking to play with friends, we have some good news on that front as well.  Dolphin&#39;s &#34;experimental&#34; Wii Remote Netplay support has finally received some much needed attention that may help it break free of that experimental moniker in the coming months.  </p>
<p>And, for our Android users, a lot of the performance improvements also affect tablets and phones, but we also have a special treat <em>only</em> for you.  The Android GUI has also seen a huge overhaul that should make it easier to use and easier on the eyes.  And for those having problems with particular games using features Dolphin <em>can&#39;t</em> reasonably emulate, we have a few presents from an old friend to patch them up.</p>
<p>We could go on and on, but you know what time it is.  Please enjoy these Notable Changes!</p>

<h3 id="notable-changes"><strong>Notable Changes</strong><a href="#notable-changes" title="Permanent link">¶</a></h3>
<h4 id="50-17613-implement-missing-features-for-wiiconnect24-support-by-noahpistilli"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17613/">5.0-17613 - Implement Missing Features for WiiConnect24 Support</a></strong>  by <strong><a href="https://github.com/noahpistilli">noahpistilli</a></strong><a href="#50-17613-implement-missing-features-for-wiiconnect24-support-by-noahpistilli" title="Permanent link">¶</a></h4>
<p><a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiconnect24logo.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiconnect24logobig.png"/>
</a></p>

<p>And after all of the changes and features we mentioned in the intro, we neglected to mention our headline change for this report.  It&#39;s almost fitting - WiiConnect24 came and went without leaving much of a mark in the gaming world. It was touted as a new way to be connected to the internet 24/7, with access to up to date information from the comfort of your couch. You could see the weather, the latest news, receive messages (with pictures!) and more through the WiiConnect24 service. Even if your console wasn&#39;t on, the disc tray would glow blue if you have a new message, a Wii Update, or something else awaiting you for the next time you booted things up.</p>
<p>By 2013, the unending march of technology had already consumed much of the usefulness of the service, and everyone expected it to slowly fade away. But to our surprise, on 13 April 2013 Nintendo announced the closure of WiiConnect24 in <em>late June</em>, only 44 days away. At the time <a href="https://wiki.dolphin-emu.org/index.php?title=Wii_Network_Guide">Nintendo Wii Wi-Fi Connectivity Support</a> was in its infancy. Our mastery of NAND and IOS features was simply not good enough to support WiiConnect24, and many of its channels didn&#39;t even run in Dolphin at the time. When WiiConnect24 disappeared, we were years away from being able to support it. As much as it pained us, we were unable assist in the efforts to preserve WiiConnect24.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/nintendochannel.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/nintendochannel_thumb.jpg"/></a>
<figcaption>The sudden passing of WiiConnect24 put its many supported channels, promotional demos, cheesy videos and advertisements at risk of disappearing forever.</figcaption>
</figure>
</div>

<p>However, there was another option for testing and preserving WiiConnect24 - the actual Wii.  From the <a href="https://rc24.xyz/about.html">early days after WiiConnect24</a>&#39;s closure, preservationists and reverse engineers have been chipping away at reviving many of the channels and features seemingly lost.  For international/default channels, <a href="https://rc24.xyz/">RiiConnect24</a> offers good support across a lot of channels.  For players looking for some Japanese exclusive channels, <a href="https://www.wiilink24.com/">WiiLink</a> has been slowly building support for these obscure channels that offer up some neat experiences that never saw the light outside of Japan.</p>
<p>Some efforts have been made by the <a href="https://rc24.xyz/">RiiConnect24</a> developers to bring their service to Dolphin, but these have been a bit hacky. They have workarounds to get <em>certain</em> channels working within Dolphin, though it required a lot of setup in order to prepare VFFs (Virtual FAT Filesystems) that the channels used to store WiiConnect24 data.  It was not user friendly, as it was difficult to set up, had limited functionality, and could easily break at any time.</p>
<p><strong><a href="https://github.com/noahpistilli">Sketch</a></strong>, <a href="https://www.wiilink24.com/">WiiLink</a> project lead and <a href="https://rc24.xyz/">RiiConnect24</a> contributor,  realized that direct support in Dolphin would be a boon to both projects.  It would open up their replacement services to more users and also make it easier to debug issues. But of course, it was easier imagined than executed. Sketch identified three major challenges that blocked WiiConnect24 emulation: support for VFF files, implementing some of the missing IOS functions, and figuring out the many fields of nwc24dl.bin and what they do.</p>
<p>Figuring out nwc24dl.bin was a reverse engineering job.  We mentioned that WiiConnect24 titles could download updates <em>while</em> the Wii was in standby mode.  How often it checked among other important things is stored in nwc24dl.bin.  Emulating the standby feature is <em>thankfully</em> unnecessary, as WiiConnect24 channels also check for updates while the actual Wii is running and when you load them.  Because Dolphin doesn&#39;t support the Wii&#39;s background scheduler, the only check it could possibly support is on channel boot.</p>
<p>Once the many fields of nwc24dl.bin were reverse engineered and understood so it could be HLE&#39;d, the next thing that needed to be handled was actually downloading the data needed for these channels.  To do this, an IOS function called <code>DownloadNowEX</code> needed to be supported.  This is a download handler that can download anywhere from 1 to 32 files.  If it is downloading more than one file in a single task, these files are called &#34;subtasks&#34; and there is a flag set in memory saying this download is a subtask and how many files it needs to download.  Many of the channels take advantage of the subtask functionality, and the News Channel will download 24 subtask files when it updates!</p>
<p>These files that are downloaded now need to be packed into VFF files for use by the channels.  Thankfully, Dolphin already has to handle the FAT filesystem thanks to SD cards and whatnot, so <strong><a href="https://github.com/noahpistilli">Sketch</a></strong> could get a jump start on support by copying code from there.  But this wasn&#39;t an easy task, and actually supporting the VFF files required a little bit of finessing.  The headers on the files were mostly undocumented and needed some digging into.  However, once that was taken care of, <strong><a href="https://github.com/noahpistilli">Sketch</a></strong> streamlined the solution with <strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong>&#39;s help.</p>
<p>With these changes, WiiConnect24 channels like the <a href="https://wiki.dolphin-emu.org/index.php?title=News_Channel">News Channel</a>, <a href="https://wiki.dolphin-emu.org/index.php?title=Forecast_Channel#Emulation_Information">Forecast Channel</a>, and others can resume service in Dolphin! </p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/everybodyvotes.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/everybodyvotes_thumb.png"/></a>
<figcaption>WiiConnect24 is working in Dolphin at long last!</figcaption>
</figure>
</div>

<p>Is the situation perfect?  Absolutely not.  Like we said, Dolphin doesn&#39;t support background updates, so on their very first boot most of these channels will error out.  After that they should work normally as long as the NAND stays intact.  The other thing to note is that Dolphin currently doesn&#39;t have a way to redirect WiiConnect24 requests.  That means users will need to patch the channels to seek out the third party servers.</p>
<p>If you&#39;re into weird era specific features, connecting to these services is absolutely worth the time.  Just to give you a taste of what you can find, here is a clip from <a href="https://en.wikipedia.org/wiki/Nintendo_Channel#Nintendo_Channel">Nintendo Week</a> 7 Dec 2009, captured from Dolphin using RiiConnect24.</p>
<div>
<figure>

<figcaption></figcaption>
</figure>
</div>

<p>If you want to see more great videos like this, patch your Nintendo Channel today and check out the Nintendo Channel on <a href="https://rc24.xyz/">RiiConnect24</a> with either your Wii or the latest builds of Dolphin!</p>
<hr/>
<p><strong>Note:</strong>  <a href="https://rc24.xyz/">RiiConnect24</a> and <a href="https://www.wiilink24.com/">WiiLink</a> are third party services much like <a href="https://wiimmfi.de/">Wiimmfi</a>.  You should make sure that you trust any third party service before connecting to it via <em>any</em> emulator.  However, both <a href="https://github.com/RiiConnect24">RiiConnect</a> and <a href="https://github.com/WiiLink24">WiiLink</a> are both open source, and were tested by developers during the development/testing of WiiConnect24 changes.</p>
<hr/>
<h4 id="50-17527-netplay-redesign-wii-remote-data-exchange-by-admiralcurtiss"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17527/">5.0-17527 - Netplay:  Redesign Wii Remote Data Exchange</a></strong>  by <strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong><a href="#50-17527-netplay-redesign-wii-remote-data-exchange-by-admiralcurtiss" title="Permanent link">¶</a></h4>
<p>As we said in the intro, Wii Remote Netplay has been a frustrating, yet tantalizing, feature since its inception.  The Wii has a <em>ton</em> of multiplayer games that either didn&#39;t support Wi-Fi, or had substandard Wi-Fi support leading to couch multiplayer being the superior choice.  Dolphin has netplay that lets you take couch multiplayer online.  Everyone wins, right?  There&#39;s one problem:  Wii Remotes.</p>
<p>Using Wii Remote Netplay is a test of frustration for all but the most hardened of users.  A ton of pitfalls awaited anyone who dared try to use it.</p>
<ul>
<li>Wii Remote Netplay did not support automatic port assignment, which was completely the opposite of GameCube Controller Netplay.  This meant each player had to configure the actual Wii Remote slot&#39;s profile to match what slot they were assigned to on netplay.  <a href="https://wiki.dolphin-emu.org/index.php?title=Netplay_Guide">To see how automatic port assignment works in Netplay now, please check out the netplay guide.</a></li>
<li>Wii Remote Netplay would crash on close due a previously undetermined bug with <em>Safe Shutdown</em> on netplay.  Some Wii games flush saves during &#34;Safe Shutdown&#34; so we couldn&#39;t just outright disable this feature on netplay.</li>
<li>Wii Netplay has to export saves at the end of a Netplay Session if a user wants to permanently save them.  But, because Wii Remotes would usually cause Wii Netplay to crash during safe shutdown, this meant that saves would get lost in limbo.  While it was technically possible to restore them, it required expert knowledge and manual reconstruction of the NAND.</li>
<li>If a Wii Remote disconnected during a netplay session, for any reason, Dolphin would crash. This is despite there being code designed to handle this exact situation.  Unfortunately, this meant that games like Donkey Kong Country Returns and Dokapon Kingdom couldn&#39;t be played on netplay, as these games will disconnect various Wii Remotes during the menus.</li>
<li>The <em>Real Wii Remote</em> setting will never work on Netplay.  This is less of a problem nowadays thanks to the innovation of <a href="https://dolphin-emu.org/blog/2020/04/05/dolphin-progress-report-february-2020/#50-11684-add-support-for-wii-remotes-over-inputcommon-by-billiard">connecting physical Wii Remotes as emulated controllers</a> and the &#34;Wii Remote&#34; controller profile.  Some problems solve themselves.</li>
</ul>
<p>These limitations and a confusing UI for setting up Wii Remotes on netplay meant that only extremely well researched users could actually use it.  In order to fix all of these problems, <strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong> decided to rethink how Dolphin would communicate Wii Remotes over netplay.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/DKCR-Netplay.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/DKCR-Netplay_thumb.jpg"/></a>
<figcaption>Donkey Kong Country Returns struggled with netplay because it disconnected Wii Remotes.</figcaption>
</figure>
</div>

<p>If it wasn&#39;t obvious by the list of problems, Dolphin&#39;s netplay was not designed for the complexity of the Wii Remote.  Still, it was implemented because we figured <em>someone</em> would want to use it, even if it was a pain in the ass to setup and use.  Unfortunately, it was hard to recommend to anyone but the most desperate of players because of all the hoops you had to jump to get there.</p>
<p>The <a href="https://dolphin-emu.org/download/dev/master/4.0-17/">initial implementation</a> from <a href="https://github.com/RachelBryk">RachelBryk</a>, was an experimental solution to enable functionality.  It was meant more for experimentation and testing than general users, but once they saw it <em>could</em> work, users obviously wanted to use it.  It was hard to provide help for the feature because it was so temperamental that most developers couldn&#39;t tell what was wrong.  It got to the point where Wii Remote Netplay was one of the few features <a href="https://github.com/dolphin-emu/dolphin/pull/3691">outright removed</a> for the Dolphin 5.0 release in order to prevent users from thinking it was a fully working stable feature.</p>
<div>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiremotenetplay-40-8032.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiremotenetplay-40-8032_thumb.png"/></a>
<figcaption>Experimental Wii Remote Netplay was available throughout most of the 4.0 era.</figcaption>
</figure>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiremotenetplay-40-9050.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiremotenetplay-40-9050_thumb.png"/></a>
<figcaption>However it was removed before 5.0, and <a href="https://dolphin-emu.org/blog/2016/08/02/dolphin-progress-report-june-july-2016/#50-133-50-136-50-222-50-290-restore-and-repair-wiimote-netplay-by-mimimi-and-jmc47">restored after the release.</a></figcaption>
</figure>
</div>
</div>

<p>Dolphin&#39;s Netplay has evolved over the years.  The advent of the desync checker revolutionized netplay, and allowed users to immediately know if something was wrong on boot.  Other features, like the <a href="https://dolphin-emu.org/blog/2015/07/01/dolphin-progress-report-june-2015/#netplay-infrastructure-updates-40-6512-wii-blank-nand-on-netplay-by-comex-40-6638-netplay-desync-detection-by-rachelb-40-6839-synchronize-gamecube-sram-settings-file-on-netplay-by-admiralcurtiss">&#34;Blank NAND&#34;</a> further stabilized Wii Netplay in general.  Wii Netplay was on the rise, but one problem remained constant: The Wii Remote.</p>
<p>The problem with fixing this is that the Wii Remotes are so complicated to handle.  They communicate over Bluetooth at a high polling rate of 200hz, have their own logic for attachments, come equipped with accelerometers and (optionally) a gyroscope, carry a speaker which can play 8-bit PCM audio, and even come with an infrared camera with a resolution of 128x96.  While Dolphin doesn&#39;t enable it on netplay, Wii Remotes even have a small bit of EEPROM for storing Miis on them! Wii Remotes are weird. But worse of all, the Wii Remote&#39;s reporting mode can change at any time, and the sessions have to be <strong>perfectly</strong> synced in order to prevent a deadlock from the wrong inputs being received on one or more Wii instances.</p>
<hr/>
<p>Sometimes in order to make things work, you need to start fresh.  In order to start the healing, <strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong> did the most logical thing and immediately threw out most of the existing Wii Remote handling code used for Netplay.  At this point, we knew the problems with Wii Remote Netplay and could now try again to write a solution that avoided these issues.</p>
<p>The big one is that when a Wii Remote talks to the Wii, it does this with <em>input reports</em> - small chunks of data sent over the Bluetooth connection that contain a partial Wii Remote state. These reports are what was sent over the network during Wii Remote Netplay. The problem comes that the game can configure at any time what kind of report it wants the Wii Remote to send.  This means if there&#39;s any kind of problem on netplay on any of the clients and the reports don&#39;t match what the game is expecting, Dolphin would lock-up.  In the best case, netplay would close but usually the entire emulator would crash.</p>
<p>Because of how sensitive this is, <strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong> decided to take a different route.  Instead of sending <em>just</em> what the game is requesting, all players will send <em>all</em> of the Wii Remote state across netplay and let each Dolphin instance translate those into an input report.  This makes Wii Remote netplay more resilient to crashes over minor configuration problems and also opens up a ton of new features. Since we&#39;re no longer relying on each Dolphin instance to sort out the Wii Remote state, players on netplay can now do things like <em>change attachments</em> during netplay and it can handle events where the game might forcibly disconnect a Wii Remote.</p>
<p><strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong> also standardized Wii Remotes to use the same conventions as GameCube netplay.  This means Dolphin&#39;s automatic port assignment now works the same across all controller types.  Best of all, Dolphin <em>no longer crashes when you attempt to end a Wii Remote Netplay session</em>.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiremotenetplay-current.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/wiiremotenetplay-current.png"/></a>
<figcaption>Wii Remotes have seen some renovations and should be just as easy to setup as GameCube Controllers for netplay.</figcaption>
</figure>
</div>

<p>That&#39;s not to say everything is perfect.  <strong><a href="https://github.com/AdmiralCurtiss">AdmiralCurtiss</a></strong> mostly focused on getting things working with this rewrite, but there are still some missing features.  &#34;Golf Mode&#34; and &#34;Host Input Authority&#34; should be able to work under the new implementation, but weren&#39;t done alongside the first wave of changes.  As well, SD cards <em>are not</em> synced on netplay, so it&#39;s usually best to unplug them <em>or</em> make sure they are manually synced between players if SD cards are absolutely necessary.</p>
<p>With these changes, we&#39;re hoping that Wii Remote Netplay will <em>finally</em> be a feature that our general users can setup and enjoy.</p>
<h4 id="50-17681-vulkan-use-vma-for-memory-allocations-by-k0bin"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17681/">5.0-17681 - Vulkan: Use VMA for memory allocations</a></strong>  by <strong><a href="https://github.com/K0bin">K0bin</a></strong><a href="#50-17681-vulkan-use-vma-for-memory-allocations-by-k0bin" title="Permanent link">¶</a></h4>
<p>We&#39;re going to be talking <em>a lot</em> about Vulkan coming up as there were some renovations done throughout the backend.  A consequence of these renovations is that Dolphin now uses <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a> (used by many open source projects to efficiently allocate memory, including other emulators) to handle memory management with Vulkan.</p>
<p>This is a definite improvement, but it didn&#39;t exactly fix anything.  The problem was that other changes to the Vulkan backend left us with some instability problems and we thought that <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a> would fix the issue and most likely improve performance.  It didn&#39;t fix the issue and didn&#39;t have an <em>immediate</em> impact on performance, but it still optimizes how we&#39;re handling memory in Vulkan.  VMA is a definite improvement and we&#39;re happy to join the ranks of projects using the library.</p>
<h4 id="50-17499-vulkan-raise-number-of-command-buffers-and-50-17620-vulkan-allocate-descriptor-pools-as-needed-by-k0bin"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17499/">5.0-17499 - Vulkan: Raise number of command buffers</a></strong> and <strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17620/">5.0-17620 - Vulkan: Allocate descriptor pools as needed</a></strong>  by <strong><a href="https://github.com/K0bin">K0bin</a></strong><a href="#50-17499-vulkan-raise-number-of-command-buffers-and-50-17620-vulkan-allocate-descriptor-pools-as-needed-by-k0bin" title="Permanent link">¶</a></h4>
<p>Now we&#39;re going to get into why VMA was thought to be needed.  Namely, Dolphin&#39;s usage of Vulkan was pretty primitive in some ways.  The emulator was only using <em>two</em> command buffers and a single descriptor pool of 100,000 descriptor sets every frame.  These choices weren&#39;t exactly efficient, but they weren&#39;t exactly causing problems either.  Except on Android.</p>
<p>Our eternal battle with GPU drivers on Android has an ebb and flow.  While we love to blame the drivers for their problems, there&#39;s always the otherside of things where Dolphin does something stupid.  This time, we were the ones being grossly inefficient.</p>
<p><strong><a href="https://github.com/K0bin">K0bin</a></strong> found out that Adreno GPUs were forced to stall when running Dolphin because they were waiting on an available command buffer, particularly in games that need readbacks (EFB/XFB2RAM titles.)  By increasing the number of command buffers to eight, <strong><a href="https://github.com/K0bin">K0bin</a></strong> reduced GPU stalling and made it so the mobile GPUs could work more efficiently.  This doesn&#39;t mean your maximum performance at 1x Internal Resolution will go up, but this might mean you&#39;ll be able to play at a higher internal resolution before you become GPU limited!</p>
<p>This is a <em>major</em> optimization and we wanted to show some fancy graphs showing how much better things were running.  Unfortunately, Android said no.  Even though we reduced GPU usage by <em>up to 30%</em>, due to performance governors on the phone clocking things down, we were unable to see a difference in framerate on our devices.  While <em>sometimes</em> the CPU would clock up, the numbers varied so greatly even within the same build, that we no longer feel confident in giving performance numbers on Android.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidcharts.jpg">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidcharts_thumb.jpg"/></a>
<figcaption>&#34;You need this? No, I don&#39;t think you need this.&#34;</figcaption>
</figure>
</div>

<p>The good news?  This brings Vulkan&#39;s performance roughly in line with OpenGL on Android under Adreno devices.  While we can&#39;t guarantee the drivers play nice in every game because performance testing has been a nightmare, we were able to confirm this fixes NES VC games being abnormally slow on Vulkan + Adreno.</p>
<hr/>
<p>Unfortunately, this optimization had some unintended effects that reverberated through the Vulkan backend, especially for our macOS users through MoltenVK.  Players were reporting new and exciting crashes throughout tons of games, forcing <strong><a href="https://github.com/K0bin">K0bin</a></strong> into figuring out what was going wrong.  </p>
<p>Thankfully, the issue became apparent relatively fast.  The new code wasn&#39;t <em>wrong</em> but other parts of the backend relied on how things worked before.  Previously, if Dolphin ran out of descriptors, it would submit a command buffer expecting that to get it a fresh descriptor pool.  With the new changes, submitting a command buffer would no longer get a fresh pool, and Dolphin would find itself still out of descriptors, at which point it would skip the draw.</p>
<p>In order to prevent the crashes, graphical issues, and <em>further</em> reduce memory overhead, <strong><a href="https://github.com/K0bin">K0bin</a></strong> changed Dolphin to now allocate descriptor pools as needed.  This <em>technically</em> could positively affect performance, but we weren&#39;t able to measure any difference in practice.</p>
<h4 id="50-17357-optimize-getvertexsize-and-50-17370-cache-vertex-sizes-by-k0bin"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17357/">5.0-17357 - Optimize GetVertexSize</a></strong> and <strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17370/">5.0-17370 - Cache Vertex Sizes</a></strong>  by <strong><a href="https://github.com/K0bin">K0bin</a></strong><a href="#50-17357-optimize-getvertexsize-and-50-17370-cache-vertex-sizes-by-k0bin" title="Permanent link">¶</a></h4>
<p>New hardware always brings new opportunities.  But that new hardware <em>doesn&#39;t</em> need to be something that pushes the boundaries of performance.  In fact, one of the most exciting new devices this year is made up of decent, but unremarkable hardware in an interesting form factor.  Of course, we&#39;re talking about the Steam Deck.  This is an exciting target for Dolphin because it&#39;s got a respectable CPU and <em>real</em> GPU drivers paired with a mobile gaming form factor.  In theory, it should be great for Dolphin.</p>
<p>However, early days of testing has been a somewhat rocky experience.  Using Dolphin&#39;s desktop GUI on the Steam Deck isn&#39;t fun and takes a lot longer than you would like.  Setting up controls is frustrating and actually getting Dolphin to compile on the Steam Deck is a nightmare unless you&#39;re fairly well versed in &#34;Linux-fu&#34;.  Thankfully, there is an easily accessible flatpak version (not maintained by Dolphin Emulator Staff) that keeps up with our beta builds, but it has a few problems not present when you compile yourself.</p>
<p>Thankfully, the situation improves a lot <em>once</em> you get past the setup stage.  Light-to-midweight games run very well, and if you need a bit more juice you can always lock the GPU at a higher clockrate in exchange for lower battery life.  But the hardware was <em>just</em> missing full speed on some mainstream titles.  One game in particular was <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a>, which hovered around 80 to 90% speed in several strenuous areas.</p>
<p>A slight optimization wouldn&#39;t be enough to make one of the Wii&#39;s premiere 3D platformers fullspeed on the Steam Deck, but it was close enough to at least give it a shot.  Having observed the performance problems first hand, <strong><a href="https://github.com/K0bin">K0bin</a></strong> downclocked their desktop and decided to profile things there.  While a 20% jump in performance was <em>a lot</em> to ask for, they figured they could look for some low-hanging fruit and at least bring it closer.</p>
<p>Things took a twist when they discovered that the function GetVertexSize was using <strong>a lot</strong> of CPU time on the GPU emulation thread.  This function should only need to come up once per vertex format and isn&#39;t anything that you&#39;d expect to see in a flame graph.  Surely there was a reason, right?  Well, they started optimizing it and immediately got positive results.  In fact, just optimizing this alone was able to push performance up on a downclocked R9 5900 roughly 30%!  That&#39;s a huge jump, and one that had to be seen to be believed.  </p>
<p>Testing it on the Steam Deck didn&#39;t provide as huge of a jump everywhere, but it was just enough to push it to nearly full speed in most demanding areas.  But then the question became how we missed such an obvious problem.</p>
<p><code>git blame</code> revealed that this is a performance regression from just under 2 years ago during the fifoplayer quality of life updates.  We didn&#39;t notice the performance regression because other optimizations were masking it, but an erroneous duplicate GetVertexSize was added which was causing it to be called for <strong>every single primitive.</strong>  Suddenly something that should only take a little CPU time was taking a lot.</p>
<p>Finding this issue inspired <strong><a href="https://github.com/K0bin">K0bin</a></strong> to continue to optimize that part of the code.  They discovered that we could also use the cached VertexSize instead of having use GetVertexSize again in some cases.  This gave another jolt to performance.</p>

<p>The fix plus the optimization put together more than did the trick.  We tested the Steam Deck after <em>painfully</em> compiling a build with the optimizations and played through a good bit of <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a> and a little of <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy_2">Super Mario Galaxy 2</a>) at full speed and 2x Internal Resolution without any noticeable slowdown.  In fact, you can even throw on Hybrid Ubershaders and get a pretty smooth experience on par with a mid-range desktop!</p>
<hr/>
<p>So, at this point you&#39;re probably wondering if this optimization carries over into other games.  After all, pretty much every game is going to be using primitives, right?  </p>
<p>The answer is yes, but the numbers aren&#39;t <em>usually</em> this ridiculous.  On high-end gaming PCs using Dolphin&#39;s default settings, the Super Mario Galaxy games saw an improvement of around 30% when running at 4x Internal Resolution.  High polygon games that lack other bottlenecks will improve similarly, but games that have different performance profiles may not see as big of a benefit.  If a game is <em>really</em> difficult to run with tons of different bottlenecks, they will see very little gain.  <a href="https://wiki.dolphin-emu.org/index.php?title=Star_Wars_Rogue_Squadron_III:_Rebel_Strike">Rogue Squadron 3</a> gains less than ~1.5% performance in most areas.</p>
<p>Most <em>normal</em> games will see an increase in performance ranging from around 5% to 10%, with some anomalies like <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a> seeing larger gains.</p>
<h4 id="50-17542-update-efb-peek-cache-on-draw-done-and-tokens-by-k0bin"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17542/">5.0-17542 - Update EFB Peek Cache on Draw Done and Tokens</a></strong>  by <strong><a href="https://github.com/K0bin">K0bin</a></strong><a href="#50-17542-update-efb-peek-cache-on-draw-done-and-tokens-by-k0bin" title="Permanent link">¶</a></h4>
<p>The other major bottleneck in the <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a> games comes from their use of <strong>EFB Peeks</strong>.  In essence, an EFB Peek is when the GameCube/Wii CPU reads pixels of the Embedded FrameBuffer (EFB).  By <em>peeking</em> into it the game can learn information about one or more pixels, such as their depth, color, etc. </p>
<p><a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy 1</a> and <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy_2">2</a> use EFB Peeks for two things, and only one of them is necessary for gameplay.  The first thing is a depth check for pixels on screen.  This is how the game is able to tell where your cursor is in relation to 3D space.  It&#39;s used to tell where to shoot starbits and can be used to see if you&#39;re trying to grab objects like Pull Stars.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/galaxy-pullstars.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/galaxy-pullstars_thumb.jpg"/></a>
<figcaption>Pull Stars are essential to proceed throughout the game, much to the chagrin of many Android users.</figcaption>
</figure>
</div>

<p>The other use <em>doesn&#39;t</em> affect gameplay but can hurt performance just as much.  This check is only active while a &#34;sun&#34; is on screen.  Even when the sun is within the field of view of the camera, that doesn&#39;t mean it&#39;s actually visible.  There might be a wall, planet, ground, or something else occluding (blocking) the view.  That&#39;s where EFB Peeks come in - the game uses EFB peeks whenever a sun is in front of the camera to make sure it is actually visible!  This is why many users complain of slowdown on weak devices <em>only</em> when a sun is on screen!</p>
<div>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/galaxyflare-on.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/galaxyflare-on_thumb.jpg"/></a>
<figcaption>Galaxy uses EFB Peeks to look at the screen coordinates where the sun should be.</figcaption>
</figure>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/galaxyflare-off.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/galaxyflare-off_thumb.jpg"/></a>
<figcaption>If the EFB Peek cannot &#34;see&#34; the sun, the game will not render the sunflare. In this demonstration we disabled EFB Peeks to force it to fail.</figcaption>
</figure>
</div>
</div>

<p>This technique is an easy and effectively free way to sample the screen for occlusion on the GameCube and Wii.  Tons of games use this technique (or a variation on it) for rendering lens flares only when the source light is visible.  For example, <a href="https://wiki.dolphin-emu.org/index.php?title=The_Legend_of_Zelda:_The_Wind_Waker">The Legend of Zelda: The Wind Waker</a> does the same check but with inverted conditions - it isn&#39;t checking if the sun is visible but if it is blocked.  However, not every developer got the memo on this simple lesson.  See <a href="https://wiki.dolphin-emu.org/index.php?title=Rune_Factory:_Tides_of_Destiny">Rune Factory: Tides of Destiny</a>.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/runefactoryflare.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/runefactoryflare_thumb.jpg"/></a>
<figcaption>If only they had used EFB Peeks.</figcaption>
</figure>
</div>

<p>While this technique is more-or-less free on the GameCube, it is an absolute pain to emulate. We&#39;ve covered something similar in the previous Progress Report so this explanation will be a little familiar.</p>
<p>The GameCube and Wii use a unified memory model, where the CPU and GPU can read or edit eachother&#39;s memory at any point with no performance cost. However, Dolphin runs on split memory model systems where the CPU and GPU cannot access eachother&#39;s memory easily. To emulate the unified memory model, Dolphin duplicates the GC/Wii Main Memory on both the host&#39;s system memory and the host&#39;s GPU vram, and we sync any changes across both memory pools. Any time a sync is issued, we have to stop all work until the sync is complete, so the host hardware will just sit and wait while the data is moving through the system. At the speed computer&#39;s operate, moving data from system RAM to GPU VRAM takes <strong>ages</strong>, so all that waiting causes a sizable performance hit.</p>
<p>Specifically with EFB Peeks, we have to stall the GPU and synchronize the memory pools so the CPU can read the rendered frame.</p>
<p>Fortunately, desktop GPU drivers have many optimizations to minimize the impact of stalls, and modern desktops are so powerful they can usually just eat the performance hit while keeping emulation far above full speed.  The only time that EFB Peeks become a problem for Dolphin is in <em>very</em> extreme cases where they are combined with other shenanigans (EFB Pokes, Store EFB Copies to Texture and RAM, etc.) <em>or</em> weaker hardware with iffy drivers and stingy governors.</p>

<p><img src="https://dolphin-emu.org/m/user/blog/progress-report/2017-april/android-logo-peeking.png"/></p>


<p>Whether you&#39;re on Adreno, Mali, or PowerVR, a game using EFB Peeks, Pokes, or one that requires the use of Store EFB/XFB Copies to RAM usually spells doom for performance. In the mobile landscape, everything is optimized to save power.  But mobile SoCs do not understand Dolphin&#39;s weird workload.  If a game triggers a memory pool sync, we have to stall the GPU while data is moving around. Mobile power governors see us stalling and think we are done with work, and immediately drop the clocks back to idle. But a few microseconds later we&#39;re back to needing maximum power.  Unfortunately, the SoC will take its time and <em>reluctantly</em> raise clocks back up.  <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a> and <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy_2">Super Mario Galaxy 2</a> will be doing many of these checks <em>every frame</em>. Unless your phone is absurdly powerful or your performance governor is extra forgiving, it&#39;s very hard to maintain to maintain full speed with all of this going on.  Many of our mobile players have been working around this by only enabling EFB Peeks in stages that <em>absolutely need them</em>.</p>
<p>There is no way to make stalls cheap, and power governors are mostly out of our control, so the challenge becomes bundling and reducing the number of required readbacks as much as possible.  This optimization by <strong><a href="https://github.com/K0bin">K0bin</a></strong> helps us get a little more mileage out of our last GPU sync/stall.  <em>Instead</em> of just invalidating the EFB Peek cache, on tokens and drawdone, we can queue an update to all previously used EFB tiles.  If the game only does work on the CPU between the DrawDone or Token and the actual EFB read, the read is able to hit the prepopulated cache and no longer needs to stall the GPU for another readback.  This reduces the number of readbacks in many situations.</p>
<p>With this change, EFB Peeks are significantly less costly. In our testing, a Snapdragon 865 was able to run many stages of <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a> at 60 FPS <em>without</em> disabling &#34;Skip EFB Access to CPU&#34;, including ones with Pull Stars that would need the performance the most.</p>
<p>Is this a catch all to improve performance across all games?  Unfortunately, not really.  EFB Peeks are pretty much the <em>best</em> case scenario of readbacks, and this change further cements this.  Other games like <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Sunshine">Super Mario Sunshine</a> uses Peeks, Pokes, PerfQueries, Store EFB Copies to RAM, and more.  Even though this game only runs at 30 FPS (unless you choose to use a 60 FPS mod), the fact it uses so many difficult to emulate features turns it into a performance nightmare on Android.</p>
<p>This optimization has been merged into the setting <em>Defer EFB Cache Invalidation</em>, which is enabled automatically for the Super Mario Galaxy games.  Because these cached results <em>could</em> break things in other games, we haven&#39;t enabled this optimization everywhere.  You can test this change out in other games by enabling it under Options -&gt; Graphics Settings -&gt; Advanced -&gt; Defer EFB Cache Invalidation.</p>
<h4 id="50-17762-d3d12-fix-numerous-hangs-by-k0bin"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17762/">5.0-17762 - D3D12: Fix Numerous hangs</a></strong>  by <strong><a href="https://github.com/K0bin">K0bin</a></strong><a href="#50-17762-d3d12-fix-numerous-hangs-by-k0bin" title="Permanent link">¶</a></h4>
<p><a href="https://dolphin-emu.org/m/user/blog/videocommon/d3d12logo.jpg">
<img src="https://dolphin-emu.org/m/user/blog/videocommon/d3d12logo_thumb.jpg"/>
</a></p>

<p>D3D12 is usually considered Dolphin&#39;s most performant backend for integrated and low-end graphics cards on Windows.  Unfortunately it&#39;s also gotten another reputation among people with stronger computers: the most unstable backend.  In fact, there have been dozens of reports of crashing in games specifically when using D3D12, forcing users to switch to other backends..</p>
<p>Things went from bad to worse when unrelated optimizations in <a href="https://dolphin-emu.org/download/dev/master/5.0-17542/">5.0-17542</a> caused <em>more</em> games to start crashing in D3D12.  So <strong><a href="https://github.com/K0bin">K0bin</a></strong> was enlisted to figure out why this optimization that improved <em>all</em> backends would only cause problems in D3D12.</p>
<p>After fixing up D3D12&#39;s validation layers, which hadn&#39;t been touched in a while, <strong><a href="https://github.com/K0bin">K0bin</a></strong> quickly found out there was a slight issue with <code>BindFramebuffer</code> in the D3D12 backend.  It seemed <em>very</em> possible for it to rely on a pipeline configuration that hasn&#39;t been set.  While we had seen a lot of reports of crashes in D3D12, we were never able to figure out an exact cause because of how particular it was to trigger it.  You needed specific games, running under specific settings, using a specific GPU and sometimes even a specific driver version.  </p>
<p>Ironically, by accidentally making the problem occur more often, <strong><a href="https://github.com/K0bin">K0bin</a></strong> made it much easier to track down and fix.  All that was needed was a small change to prevent Dolphin from relying on unset pipeline configurations.  This fixed both the <em>new</em> crashes on D3D12, and the previously unsolved crashes that had been plaguing it for years.</p>
<p>We&#39;re happy to report that D3D12&#39;s stability should finally be on par with the other backends now.</p>
<h4 id="50-17403-add-dynamic-vertex-loaders-for-ubershaders-by-tellowkrinkle"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17403/">5.0-17403 - Add Dynamic Vertex Loaders for Ubershaders</a></strong>  by <strong><a href="https://github.com/tellowkrinkle">tellowkrinkle</a></strong><a href="#50-17403-add-dynamic-vertex-loaders-for-ubershaders-by-tellowkrinkle" title="Permanent link">¶</a></h4>
<p>The last couple of changes have been about achieving maximum performance, but now we go into a <em>different</em> kind of performance.  As mentioned in the last Progress Report, <strong><a href="https://github.com/tellowkrinkle">tellowkrinkle</a></strong> has been working toward smoothing things out with Ubershaders.  Due to various issues across various drivers, Ubershaders haven&#39;t been able to <em>completely</em> remove stuttering, especially in the modern Graphics APIs.</p>
<p>The <a href="https://dolphin-emu.org/blog/2017/07/30/ubershaders/">original Ubershaders</a> were created back when D3D12 and Vulkan were the &#34;next-gen&#34; video backends and most of our users were on D3D11 and OpenGL.  We were aware that the new APIs used &#34;pipelines&#34; but it wasn&#39;t 100% clear the effect they would have on Dolphin yet.  For  <a href="https://dolphin-emu.org/blog/2017/07/30/ubershaders/">Ubershaders</a>, it&#39;s been a problem, to say the least.  <a href="https://dolphin-emu.org/blog/2022/09/13/dolphin-progress-report-july-and-august-2022/#50-16930-reduce-pipeline-compilation-stutter-through-forcing-fbfetch-in-ubershaders-by-tellowkrinkle">We talked about these a bit in the last Progress Report</a> where <strong><a href="https://github.com/tellowkrinkle">tellowkrinkle</a></strong> already had one change dedicated toward reducing pipeline counts.</p>
<p>For a quick rundown, the graphics pipeline is a fundamental building block for rendering on newer graphics APIs. It contain all of the data for a draw, taking vertices and textures all the way to the pixels in the render targets. However, since the pipeline contains all the settings for the draw, the display driver can optimize it before feeding it to the GPU.  Some drivers then optimize those pipelines by combining the hardware vertex loader settings into the actual shader, which essentially makes our Ubershaders not so Uber anymore.  So when the vertex loader on the GameCube changes settings, a whole new shader would need to be compiled with new vertex loader settings, usually resulting in a lengthy stutter.</p>
<p>We did run into this issue with Vulkan when Ubershaders were first implemented, but we were hopeful that API extensions or driver updates would eventually lessen or erase the issue.  That hasn&#39;t happened.</p>
<p><strong><a href="https://github.com/tellowkrinkle">tellowkrinkle</a></strong>&#39;s solution isn&#39;t to make pipeline generation faster, but to simplify our pipelines so there are fewer branches and thus fewer pipelines in total. <strong><a href="https://github.com/tellowkrinkle">tellowkrinkle</a></strong> was able to reduce our pipeline count so much that now <em>nearly every pipeline</em> is able to be precompiled at boot!  And while these changes aren&#39;t able to remove the possibility of shader stuttering on <em>every</em> backend on <em>every</em> graphics card, it brings us much closer to that reality. </p>
<div>
<figure>
<div>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/ubershaders-before.mp4">
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/ubershaders-before_thumb.mp4" type="video/mp4"/>
</video></a></div>
<figcaption>Ubershaders weren&#39;t fixing the problem on Metal before these changes.</figcaption>
</figure>
<figure>
<div>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/ubershaders-after.mp4">
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/ubershaders-after_thumb.mp4" type="video/mp4"/>
</video></a></div>
<figcaption>In newer builds, Ubershaders work as advertised by simplifying things for pipelines.</figcaption>
</figure>
</div>

<p>The Vertex Loader Ubershader, along with some changes leading up to it make a huge difference in shader compilation stuttering on all hardware.</p>
<ul>
<li><strong>Metal</strong>:  macOS users can rejoice, as there are now no known drivers that will suffer from shader generation issues when using Ubershaders.</li>
<li><strong>D3D12</strong>: On NVIDIA and AMD graphics cards, using D3D12 should now provide the same stutter free experience as D3D11 has when using Ubershaders.  Intel&#39;s drivers were not tested, but are likely greatly improved or completely stutter free.</li>
<li><strong>Vulkan</strong>: This is the most complicated case.  On macOS via MoltenVK, shader compilation stuttering is completely eliminated <em>except</em> on Apple Silicon, where there may still be rare pipeline compiles.  On Windows and Linux, the situation is improved but NVIDIA still tends to have a few noticeable compiles here and there.  Wider support of the <code>VK_EXT_rasterization_order_attachment_access</code> extension would help eliminate pipeline compiles across pretty much every driver.  That includes mobile drivers too, such as Adreno and Mali!</li>
<li><strong>D3D11</strong>:  D3D11 does not have pipelines and doesn&#39;t benefit from this change.  It also didn&#39;t suffer from the problems, so there&#39;s that.</li>
<li><strong>OpenGL</strong>:  While it does have <em>proto-pipelines</em> with display lists and command lists, this change only targeted the newer APIs.  OpenGL worked fairly well on most drivers anyway, so there wasn&#39;t <em>too much</em> to gain.</li>
</ul>
<p>Odds are, you probably won&#39;t see shader stuttering anymore <em>even</em> if you&#39;re on one of the configurations listed as not completely fixed.  And if you <em>do</em> see shader stuttering, it&#39;ll be greatly reduced compared to before.</p>
<h4 id="50-17691-add-emulation-of-pointsizelinewidth-in-vertex-shaders-by-tellowkrinkle"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17691/">5.0-17691 - Add Emulation of Pointsize/Linewidth in Vertex Shaders</a></strong>  by <strong><a href="https://github.com/tellowkrinkle">tellowkrinkle</a></strong><a href="#50-17691-add-emulation-of-pointsizelinewidth-in-vertex-shaders-by-tellowkrinkle" title="Permanent link">¶</a></h4>
<p>This is a big one for macOS users, but it will have implications for everyone else sooner or later.  The GameCube/Wii GPU has features called &#34;Pointsize&#34; and &#34;Linewidth&#34; which allows a developer to draw a point or line and give it an arbitrary size without having to use actual vertices or polygons. OpenGL developers may find that this feature <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointSize.xhtml">sounds</a> <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLineWidth.xhtml">familiar</a>, but that is to be expected as the GameCube and Wii&#39;s pointsize and linewidth were based on OpenGL&#39;s! However, the GameCube added enough special sauce that they <a href="https://dolphin-emu.org/blog/2015/01/01/dolphin-progress-report-december-2014/#40-4699-line-widthpoint-size-unification-by-armada651">cannot be accurately emulated with OpenGL&#39;s native pointsize and linewidth</a>. Since newer APIs have nothing like this and neither does D3D11, all of the APIs our backends use do not support this feature natively.</p>
<p>Many games use these features, and without emulation of pointsize and linewidth, any lines will be <em>1</em> pixel wide and any points don&#39;t appear at all!</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/networktrans-broken.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/networktrans-broken_thumb.jpg"/></a>
<figcaption>Without proper Pointsize and Linewidth emulation, most of <a href="https://wiki.dolphin-emu.org/index.php?title=Mega_Man_Network_Transmission">Mega Man Network Transmission</a>&#39;s effects are barely visible.</figcaption>
</figure>
</div>

<p>So, considering our host GPUs can&#39;t <em>natively</em> render this, we had to find a way to emulate it.  Our solution has been the use of Geometry Shaders.  Geometry Shaders are an optional shader stage that can take a primitive in as an input and can output zero or more primitives.  For Dolphin&#39;s purposes, we could use the &#34;Point&#34; or &#34;Line&#34; request as the input and then, based on the other properties the game specifies for that point/line, draw triangles that will create an identical shape.</p>
<p>When Dolphin adopted Geometry Shaders, they were a new and promising feature in graphics tech.  Unfortunately, they were quickly superseded by newer features because <em>Geometry Shaders are slow</em>, so games avoided them.  This put Geometry Shaders in a precarious position that <em>finally</em> reached a breaking point with the Metal Graphics API by Apple - Metal does not support geometry shaders whatsoever.  Even though Apple hardware supports Geometry Shaders as they work under OpenGL, but, it&#39;s not in Metal. For us, this meant we needed to find a new solution if we were going to emulate Pointsize and Linewidth on modern macOS machines.</p>
<p>Originally, <strong><a href="https://github.com/skylersaleh">skylersaleh</a></strong> (who did Dolphin&#39;s port to macOS M1 and now works on <a href="https://github.com/skylersaleh/SkyEmu">skyemu</a>) started an experiment with using tried and true Vertex Shaders.  While this could make <em>wide-lines</em> and <em>thick-points</em>, the original experiment failed because it wasn&#39;t able to get them to render correctly. <strong><a href="https://github.com/pokechu22">pokechu22</a></strong> picked it up but quickly found that this wasn&#39;t a simple fix.</p>
<p>Dolphin as it was couldn&#39;t give the Vertex Shaders all of the information it needed to determine the way to orient line caps.  A way to work around this was to have <em>Dynamic Vertex Loaders</em>, which would be able to determine the information we need directly in the Vertex Shader.  Funnily enough, while <strong><a href="#50-17403-add-dynamic-vertex-loaders-for-ubershaders-by-tellowkrinkle">5.0-17403</a></strong> was designed to make Ubershaders more effective, those same Dynamic Vertex Loaders could be used to finally finish Pointsize/Linewidth with a Vertex Shader!</p>
<p>Support for Geometry Shaders, especially with Metal outright abandoning them, might be on the way out.  So having this option is <em>good</em> now, but might be outright necessary later.  Currently, we still use Geometry Shaders when they&#39;re available, but on GPUs without Geometry Shader support, Dolphin will now use the Vertex Shader implementation instead.  Users can also try it out - it can be enabled in Graphics Settings -&gt; Advanced with &#34;Prefer VS for Point/Line Expansion&#34;.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/networktrans-working.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/networktrans-working_thumb.jpg"/></a>
<figcaption>With working effects, Network Transmission comes to life!</figcaption>
</figure>
</div>

<p>Because the Vertex Shader implementation is slightly faster, we will probably move over to it as the default implementation.  This actually comes into play throughout the <a href="https://wiki.dolphin-emu.org/index.php?title=Metroid_Prime:_Trilogy">Metroid Prime Series</a>, where the linewidth effects can effect overall performance.  If your machine has a driver with incredibly slow Geometry Shader support, this may help things!  However, on most modern GPUs, this is far down on the list of bottlenecks.</p>
<hr/>
<p><em>Note: Our D3D11 Backend does not have Vertex Shader Linewidth/Pointsize for now.  It&#39;s not <em>impossible</em> to accomplish, but due to the inline constant system from D3D12 not existing, it would take a different implementation.</em></p>
<hr/>
<h4 id="50-17836-debugging-add-support-for-conditional-breakpoints-by-smurf3tte-and-trytwo"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17836/">5.0-17836 - Debugging: Add Support for Conditional Breakpoints</a></strong>  by <strong><a href="https://github.com/smurf3tte">smurf3tte</a></strong> and <strong><a href="https://github.com/TryTwo">TryTwo</a></strong><a href="#50-17836-debugging-add-support-for-conditional-breakpoints-by-smurf3tte-and-trytwo" title="Permanent link">¶</a></h4>
<p>For people debugging, modding, TASing, or just in general messing around with a game&#39;s behavior, this is a major enhancement that will make your life easier.  Dolphin has long had support for breakpoints, but the problem was that if it was a frequently used instruction, you&#39;d have no way of telling it only to notify you if the condition you were looking for actually happened.  Instead, debuggers would often rely on third party tools in order to debug more difficult issues.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/conditionalbreakpoints.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/conditionalbreakpoints_thumb.png"/></a>
<figcaption>Conditional Breakpoints make debugging hot functions much easier.</figcaption>
</figure>
</div>

<p>This change adds support for basic logical conditions, but <strong><a href="https://github.com/TryTwo">TryTwo</a></strong> has already started work on callstack based conditions and support for conditional Memory Breakpoints as well.</p>
<h4 id="50-17902-add-gba-tas-window-by-josjuice"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17691/">5.0-17902 - Add GBA TAS Window</a></strong>  by <strong><a href="https://github.com/JosJuice">JosJuice</a></strong><a href="#50-17902-add-gba-tas-window-by-josjuice" title="Permanent link">¶</a></h4>
<p>When Dolphin added support for the <a href="https://dolphin-emu.org/blog/2021/07/21/integrated-gba/">Integrated GBA</a> there was some excitement about TASing titles that require GBAs.  After all, Integrated GBAs worked with Dolphin&#39;s movie code as shown by Netplay Support!</p>
<p>Technically, Integrated GBAs could be controlled using TAS input when things were merged, but there was no built-in support.  Instead, <strong><a href="https://github.com/Bonta">Bonta</a></strong> hooked up the existing GameCube Controller TAS input to the GameCube TAS Input window.  However, as with any major, complex change, this detail was actually overlooked.  When the TAS Input Handling was rewritten, this feature was accidentally removed and suddenly there was no way to control Integrated GBAs through TAS Input.</p>
<p>As the guilty party that accidentally removed support, <strong><a href="https://github.com/JosJuice">JosJuice</a></strong> quickly jumped on the issue to rectify things as soon as they realized what had happened.  But rather than just returning the old normal, <strong><a href="https://github.com/JosJuice">JosJuice</a></strong> greatly improved the situation by making a special TAS Input window for Integrated GBAs with all of the controls now clearly labeled.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/gbatas.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/gbatas_thumb.png"/></a>
<figcaption>Will we see a Four Swords Adventures 4 player TAS someday?  We sure hope so!</figcaption>
</figure>
</div>

<h4 id="50-17907-improve-fpsvps-counting-and-revamp-appearance-by-sam-belliveau"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-17907/">5.0-17907 - Improve FPS/VPS Counting and Revamp Appearance</a></strong>  by <strong><a href="https://github.com/Sam-Belliveau">Sam-Belliveau</a></strong><a href="#50-17907-improve-fpsvps-counting-and-revamp-appearance-by-sam-belliveau" title="Permanent link">¶</a></h4>
<p>Dolphin&#39;s FPS counter has always just been <em>there</em>.  We don&#39;t even know for sure how long we&#39;ve had it - we found it in <a href="https://github.com/dolphin-emu/dolphin/commit/38ff37539d54ac53ff79aeb2f4cdc2be10ddd36a">r488 (1.0-488)</a> from 9 Sept 2008, but it could be even older! It has changed a lot in that time of course. Originally it was an overlay built directly into each graphics <em>plugin</em>, before being moved to the Rasterfont system split between videocommon and the video backend, and finally moving to the shared Dear ImGui form we have today. However, despite being moved and rebuilt several times, how our FPS display calculates frames per second has never changed. Until today.</p>
<p>Progress Report newcomer <strong><a href="https://github.com/Sam-Belliveau">Sam-Belliveau</a></strong> was distracted by how Dolphin&#39;s FPS display constantly flickered above and below 60FPS. It annoyed them so much that he decided he was going to do something about it...  and fell down a rabbit hole. First of all, he added VPS (v-blanks per second)  and emulation speed measures to the performance overlay, so that users in fullscreen and on Android can <em>finally</em> get this essential information.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-newdisplay.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-newdisplay_thumb.png"/></a>
<figcaption>The above is correct. In NTSC territories the GameCube and Wii operate at 59.94fps not 60, requiring us to do some shenanigans for correct emulation on modern displays. What you see in Dolphin&#39;s titlebar is rounded to whole frames.</figcaption>
</figure>
</div>

<p>And he added color to the performance overlay, providing a very glanceable indicator of Dolphin&#39;s performance! The colors are cyan (full speed), green, yellow, orange, then finally red.</p>
<div>
<figure>
<div>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-colours.mp4">
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-colours.mp4" type="video/mp4"/>
</video></a></div>
<figcaption>Red is bad. You probably didn&#39;t need us to tell you that.</figcaption>
</figure>
</div>

<p>But most importantly, he changed how Dolphin&#39;s FPS display is averaged.  Before we explain how he did it, here&#39;s a before and after of the FPS display with a title running at a perfect 60fps (59.94 technically).</p>
<div>
<figure>
<div>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-noneuler.mp4">
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-noneuler.mp4" type="video/mp4"/>
</video></a></div>
<figcaption>With the old formula, the FPS counter was a little unstable, with a variance of about half a frame. Unfortunately, it varied above and below 60fps, causing the most significant digits to constantly change. It was difficult to keep track of performance with this display. </figcaption>
</figure>
<figure>
<div>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-euler.mp4">
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-euler.mp4" type="video/mp4"/>
</video></a></div>
<figcaption>With the new formula, the FPS display no longer flickers the most significant digits and its variance is actually close to Dolphin&#39;s rendering! </figcaption>
</figure>
</div>

<p>Previously, the FPS display used an extremely simple formula: <code>number of frames in the sample / microseconds of the sample / 1,000,000</code>. That&#39;s it. This is an incredibly basic way to calculate frames per second, and it has worked for Dolphin for a very long time. It does the job. However, the downside of this method is that it is &#34;sample and hold&#34;. Between samples Dolphin just shows the previous sample, completely unchanged, which feels unresponsive and could make stutters and other problems either invisible or overly emphasized. To minimize this Dolphin could use a very short sample cycle, but that has the consequence that each sample has little data to work with. If your sample size is only a few frames long, then even a spike lasting a <em>single frame</em> could significantly alter the results of the average, making the FPS display highly unstable. A longer sample time would resolve that, but then we&#39;re back to having it feel unresponsive and hiding stutters and other problems. So Dolphin developers of the past chose a sample duration of 0.25 seconds - this leaned a bit toward frenetic and unstable but kept the FPS display reasonably responsive. With a super simple formula like this, compromises are unavoidable.</p>
<p>The solution to this is to use an exponential moving average on top of a standard moving average - we&#39;ll call this a &#34;Euler Average&#34; for short. Basically, it averages the framerate over the last second (by default) using a <a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/sma">standard moving average</a>, then applies an <a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/ema">exponential moving average</a> on top to reduce jitter. The result of this math is that Dolphin can sample every frame so it is always up to date, it can smooth out sudden spikes and drops for a stable, legible indicator, and it can update the FPS indicator <em>every frame</em> so it is visually pleasing as well!</p>
<p>To show how this works in action, here is a graph showing the two methods against eachother. The data we&#39;re feeding into it is from a Dolphin test with an unlocked framerate, with frame to frame swings as high as <strong>100FPS</strong>. It&#39;s a worst case scenario for an FPS display. How do the old and new FPS formulas handle this awful data?</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/eulerfpsdisplay.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/eulerfpsdisplay_thumb.png"/></a>
<figcaption>Click for detail.</figcaption>
</figure>
</div>

<p>The purpose of an FPS display is to give a glanceable reference of a game&#39;s performance. But the FPS display with the original formula can&#39;t handle data that is this variable. It just goes all over the place; even if you stared at it you would have no idea how fast the game is performing! But the Euler average is able to display a proper average of the framerate even from this garbage data. Of course, no one should encounter frametime variance on this level in actual gameplay unless something has gone <a href="https://dolphin-emu.org/blog/2018/12/04/dolphin-progress-report-november-2018/#dev-diary-putting-a-mac-through-its-paces-by-mayimilae">very very wrong</a>, but even in this worst case scenario our frame rate display is now able to do its job thanks to the new formula!</p>
<p>A consequence of using the Euler Average is that there is a now ramp up. If a game goes from 0FPS to 60FPS in one frame, it will the whole sample window (1 second by default) to resolve to 60. Averaging the current data with prior data prevents sudden spikes and drops from making the FPS display devolve into noise, so it has to catch up to extreme change. To account for this, this change also adds a control to allow the user to change the sample window duration. A longer window will give a smoother and more consistent indicator, and a shorter window will be more frenetic but will be closer to real time and show smaller drops.</p>
<p>This and other new controls necessitated a move for our performance display options. You&#39;ll now find them in Graphics &gt; Advanced under &#34;Performance Statistics&#34;. This is not necessarily their permanent home but it&#39;s a safe place for <strong><a href="https://github.com/Sam-Belliveau">Sam-Belliveau</a></strong> to continue working on this feature.</p>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-settings.png">
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/fps-settings_thumb.png"/></a>
<figcaption></figcaption>
</figure>
</div>

<p>With this, our performance statistics display is better than ever! But <strong><a href="https://github.com/Sam-Belliveau">Sam-Belliveau</a></strong> is not done. Expect this feature to get even better in the coming months!</p>
<h3 id="more-patches-for-dcache-reliant-games"><strong>More Patches for dcache Reliant Games</strong><a href="#more-patches-for-dcache-reliant-games" title="Permanent link">¶</a></h3>
<p>Dolphin doesn&#39;t <em>currently</em> target emulating the CPU Data Cache (dcache) and once it does, odds are that enabling it will make emulation too slow.  For now, we&#39;re relying on patching these games that accidentally rely on the GameCube/Wii&#39;s CPU dcache behaviors.</p>
<p>The past three months, we&#39;ve seen two new patches from <strong><a href="https://github.com/smurf3tte">smurf3tte</a></strong>, who has done the hard work of reverse engineering these games, figuring out <em>why</em> they need dcache emulation, and patching their code to no longer need it!  So if you&#39;re playing <a href="https://wiki.dolphin-emu.org/index.php?title=Dead_to_Rights">Dead to Rights</a> (audio issues) or <a href="https://wiki.dolphin-emu.org/index.php?title=Ten_Pin_Alley_2">Ten Pin Alley 2</a> (crashing before gameplay) in the latest development builds, you have <strong><a href="https://github.com/smurf3tte">smurf3tte</a></strong> to thank!</p>
<p>Note that the patch for <a href="https://wiki.dolphin-emu.org/index.php?title=Ten_Pin_Alley_2">Ten Pin Alley 2</a> is only for the NTSC version of the game.</p>
<h3 id="the-android-gui-refresh"><strong>The Android GUI Refresh</strong><a href="#the-android-gui-refresh" title="Permanent link">¶</a></h3>
<p>There are far too many changes that have gone into this over the past quarter of the year.  <strong><a href="https://github.com/t895">t895</a></strong> has been extremely busy going through the Android GUI and modernizing it.  From redesigning buttons, to making things fit your phone&#39;s theme/shape/size, and even some optimizations that will allow the menus to run more smoothly with fewer hitches.</p>
<div>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-adjustcontrols-before.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-adjustcontrols-before_thumb.png"/></a>
<figcaption></figcaption>
</figure>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-adjustcontrols-after.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-adjustcontrols-after_thumb.png"/></a>
<figcaption></figcaption>
</figure>
<center><p>Everything is at least a little nicer than before!</p></center>
</div>
</div>

<p>One of the biggest keys is that Dolphin now supports Google&#39;s &#34;Material You&#34; design system.  By default, Dolphin uses its own color scheming under &#34;Material 3&#34;, but if you want it to match your system-wide theming better, you can swap over to &#34;Material You&#34; and several other color based options in the theme menu.</p>
<div>
<figure>
<div>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/android-materialdemo.mp4">
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/android-materialdemo.mp4" type="video/mp4"/>
</video></a></div>
<figcaption></figcaption>
</figure>
</div>

<p>In addition to the theming changes, <strong><a href="https://github.com/t895">t895</a></strong> has greatly optimized the cover loading/caching mechanism to prevent the lockups on first load when swapping between GC/Wii/WiiWare tabs.  This should make app usage much smoother overall.  There are tons of minor fixes, especially for those with oddly shaped phones that should prevent things from going off screen or awkwardly resizing.</p>
<p>A bunch of the menus have also been redesigned to make things fit better and look nicer.</p>
<div>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-cheats-before.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-cheats-before_thumb.png"/></a>
<figcaption></figcaption>
</figure>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-cheats-after.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-cheats-after_thumb.png"/></a>
<figcaption></figcaption>
</figure>
<center><p>Some changes are subtle.</p></center>
</div>
</div>


<div>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-gamecard-before.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-gamecard-before_thumb.jpg"/></a>
<figcaption></figcaption>
</figure>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-gamecard-after.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-gamecard-after_thumb.jpg"/></a>
<figcaption></figcaption>
</figure>
<center><p>Others are radically better.</p></center>
</div>
</div>


<div>
<div>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-riivolution-before.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-riivolution-before_thumb.png"/></a>
<figcaption></figcaption>
</figure>
<figure>
<a href="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-riivolution-after.png"><img src="https://dolphin-emu.org/m/user/blog/progress-report/2022-october/androidgui-riivolution-after_thumb.png"/></a>
<figcaption></figcaption>
</figure>
<center><p>But basically every window has been given some needed attention.</p></center>
</div>
</div>


<p>While none of this <em>directly</em> affects emulation, it does make setting up the emulator easier and allows for greater customization.  Those of you that want your phone and its apps to be personalized for you should have a lot of fun with these changes.  For everyone else, these changes will make setting up and adjusting things from within the emulator much smoother.</p>
<h3 id="last-months-contributors"><strong>Last Month&#39;s Contributors...</strong><a href="#last-months-contributors" title="Permanent link">¶</a></h3>
<p>Special thanks to <a href="https://github.com/dolphin-emu/dolphin/graphs/contributors?from=2022-09-01&amp;to=2022-12-01&amp;type=c">all of the contributors</a> that incremented Dolphin from <a href="https://dolphin-emu.org/download/dev/master/5.0-17271/">5.0-17271</a> through to <a href="https://dolphin-emu.org/download/dev/master/5.0-17995/">5.0-17995</a>! </p>


    
    
    

    </div></div>
  </body>
</html>
