<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/vault-now-in-beta">Original</a>
    <h1>Supabase Vault is now in Beta</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>During our last Launch Week we <a href="https://supabase.com/blog/supabase-vault">announced</a> Supabase Vault as our “one more thing”. Today we&#39;re releasing it progressively across the platform.</p>
<p>Vault is a new Postgres extension and accompanying Supabase UI that makes it safe and easy to store encrypted secrets and encrypt other stored data in your database. This foundation opens up a lot of possibilities for Postgres that go beyond what is available in a stock distribution. From a product perspective we&#39;re grouping various features under the “Vault banner”. Let&#39;s explore a few of these features.</p>
<h2 id="secrets-management">Secrets Management</h2>
<p>Practically speaking, the Vault is a table of Secrets and Encryption Keys that are stored using <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">Authenticated Encryption</a> on disk, but available in decrypted form through a Postgres view so that the secrets can be used by applications from SQL. Because the secrets are stored encrypted and authenticated, any backups or replication streams also preserve this encryption in a way that can&#39;t be forged.</p>
<p>We&#39;ve created a dashboard UI for the Vault that makes storing secrets easy. Click a button and type in your secret, optionally create a new key that is referenced by id (or use the existing default), and submit. Your secret is now stored on disk encrypted using the specified key id.</p>
<video width="99%" muted="" playsinline="" controls=""><source src="/images/blog/launch-week-6/vault/vault-hello-compressed.mp4" type="video/mp4" muted="" playsinline=""/></video>
<p>There are two main parts to the Vault UI, Secrets and Encryption Keys:</p>
<ul>
<li><strong>Secrets:</strong> Use the Vault to store Secrets - everything from Environment Variables to API Keys. You can use these Secrets anywhere in your database: Postgres <a href="https://supabase.com/docs/guides/database/functions">Functions</a>, Triggers, and <a href="https://supabase.com/docs/guides/database/webhooks">Webhooks</a>. From a SQL perspective, accessing secrets is as easy as querying a table (or in this case, a view). The underlying secrets tables will be stored in encrypted form.</li>
<li><strong>Encryption Keys:</strong> encryption keys are used to encrypt data inside your database. Fun fact: the Secrets you store in the Vault are encrypted with an Encryption Key which we set up by default and is not accessible to SQL or stored in your database alongside the same data it is used to encrypt. You can create different Encryption Keys for different purposes, for example: one for encrypting user-data, and another for application-data.</li>
</ul>
<h2 id="transparent-column-encryption-tce">Transparent Column Encryption (TCE)</h2>
<p>Our recent <a href="https://supabase.com/blog/transparent-column-encryption-with-postgres">blog post</a> describes TCE in-depth. TCE is one of the safest ways to encrypt your data so that it doesn&#39;t leak into logs and backups, as well as providing your users with row-level authenticated encryption. TCE is the foundational feature of the Vault, but you can use it on your own tables if you choose to if the Vault isn&#39;t sufficient for your needs, for example if you have multiple tables that you wish to have encrypted columns. Any Postgres value that can be cast to <code>text</code> or <code>bytea</code> can use TCE to encrypt the data that is stored to disk.</p>
<h3 id="encrypting-columns">Encrypting columns</h3>
<p>In the “New Column” flow on the Dashboard, you can select that a <code>text</code> or <code>bytea</code> column is encrypted, and select an existing key id or create a new one. This is functionally identical to the Vault above, but you can apply it to any of your existing tables. In a sense the Vault is a pre-created table and UI for you to get started quickly storing secrets, and to be a centralized point for “global” secrets management, but your not stuck with just that, you can encrypt multiple columns in multiple tables, how you want to store your secret data can be entirely up to you.</p>
<p><span><span><img alt="Encrypting columns" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Once you&#39;ve setup an encrypted column, just insert data into the table like you would any other table. If you put in an email address for example, you will see that what is stored is not an email at all, but an encrypted value.</p>
<p><span><span><img alt="Encrypted data" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Decrypted data can be accessed by a special view that is automatically created whenever you create an encrypted column on a table. This view decrypts the data row-by-row as you access it. By default this view is called <code>decrypted_&lt;your-table-name&gt;</code>, so in the example provided, the decryption view for the <code>profiles</code> table is <code>decrypted_profiles</code>. In addition to the existing <code>emails</code> column, there is a new column in the view called <code>decrypted_emails</code> that contains the decrypted email value. It&#39;s that simple!</p>
<p><span><span><img alt="Decrypted data" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<h2 id="deep-dive-on-how-the-vault-works">Deep Dive on How The Vault works</h2>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/QHLPNDrdN2w" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe>
<p>As we mentioned, the Vault uses pgsodium&#39;s Transparent Column Encryption (TCE) to store secrets in an authenticated encrypted form. There are some details around that you may be curious about, what does authenticated mean, and where are encryption keys store? This section explains those details.</p>
<p>The first important feature of TCE is that it uses an <a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data_(AEAD)">Authenticated Encryption with Associated Data</a> encryption algorithm based on libsodium. “Authenticated Encryption” means that in addition to the data being encrypted, it is also “signed” so that it cannot be forged, the decryption function verifies that the signature is valid <strong>before decrypting the value</strong>. “Associated Data” means that in addition to signing the secret, you can include any other columns in your row in the signature computation, “associating” those columns with the secret. This doesn&#39;t encrypt those other columns, but it does ensure that <strong>they are authentic</strong> and cannot be forged because they are included in the secret&#39;s signature. So you know when you restore your database dumps, not only are the secrets safe, but also the “associated” columns are also authentic and unforged.</p>
<p>Another important feature of pgsodium is that the encryption keys are never stored in the database alongside the encrypted data, instead, only a <strong>Key ID</strong> is stored, which refers to a key that is only accessible outside of SQL. Even if an attacker can capture a dump of your entire database, they will see only encrypted data and key ids, <strong>never the raw key itself</strong>. This is an important safety precaution, there would be no point in storing the encryption key in the database alongside the encrypted data, this would be like locking your front door but leaving the key in the lock! Storing the key outside the database fixes this issue.</p>
<p>You might be wondering, ok then where are the keys stored? Supabase creates and manages the root keys from which all key ids are derived in our internal customer backend systems. We keep this key safe and separate from your data, and provide an alternate dashboard endpoint for accessing the key if you want to decrypt your data outside of Supabase.</p>
<h2 id="future-possibilities">Future possibilities</h2>
<p>Privacy is becoming one of the most important features in a modern product. Supabase&#39;s embrace of the pgsodium extension aims to make this simple. Some of the possibilities we are looking into are:</p>
<ul>
<li><strong>End-to-end encryption</strong>: give your users the ability to encrypt their personal data so even you, the developer cannot access it, using the libsodium <a href="https://doc.libsodium.org/secret-key_cryptography/secretstream">encrypted streams</a> API that is exposed by pgsodium. After exchanging keys, parties can stream unlimited amounts of data from peer to peer without being intercepted by any party in between, including Supabase.</li>
<li><strong>Group encryption</strong>: have you ever joined a group on Whatsapp and been frustrated that you can&#39;t read the previous messages? That&#39;s because group encryption is hard. We hope to make that easier using new algorithms like <a href="https://github.com/jedisct1/libsodium-signcryption">signcryption</a> to support multi-party encrypted messages that can be easily encoded into a token format and use to support streaming encryption keys.</li>
<li><strong>Public Key Management:</strong> Public Key Encryption can be hard, but pgsodium makes it easier by exposing all of the public key encryption functions that are supported by libsodium. Making and distributing key pairs is now easy, no need to run arcane GPG scripts or mess with SSL libraries. libsodium contains state of the art public key encryption, and by extension so does pgsodium. These features are available now on the Supabase platform and offer a lot of possibilities to unshackle developers from other confusing and inadequate solutions available today.</li>
</ul>
<h3 id="using-the-vault">Using the Vault</h3>
<p>You&#39;ll see the Vault appear in the Dashboard over the next month. If you want to use Vault today, email <a href="mailto:growth@supabase.com">growth@supabase.com</a> and we&#39;ll enable it on your account. Vault is available for all customers (including the Free-tier).</p>
<h2 id="more-launch-week-6">More Launch Week 6</h2>
<ul>
<li><a href="https://supabase.com/blog/new-supabase-docs-built-with-nextjs">Day 1: New Supabase Docs, built with Next.js</a></li>
<li><a href="https://supabase.com/blog/storage-image-resizing-smart-cdn">Day 2: Supabase Storage v2: Image resizing and Smart CDN</a></li>
<li><a href="https://supabase.com/blog/mfa-auth-via-rls">Day 3: Multi-factor Authentication via Row Level Security Enforcement</a></li>
<li><a href="https://supabase.com/blog/launch-week-6-hackathon">Launch Week 6 Hackathon</a></li>
<li><a href="https://supabase.com/blog/who-we-hire">Who We Hire at Supabase</a></li>
<li><a href="https://supabase.com/blog/postgres-crdt">pg_crdt - an experimental CRDT extension for Postgres</a></li>
</ul></div></article></div>
  </body>
</html>
