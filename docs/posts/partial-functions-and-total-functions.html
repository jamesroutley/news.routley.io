<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.johndcook.com/blog/2021/12/06/partial-functions/">Original</a>
    <h1>Partial functions and total functions</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>I was thinking about writing a post about entire functions and it occurred to me that I should say something about how entire functions are unrelated to total functions. But then I realized they’re not unrelated. I intend to say something about entire functions in a future post.</p>
<p>Update: See <a href="https://www.johndcook.com/blog/2021/12/07/the-ring-of-entire-functions/">The ring of entire functions</a>.</p>
<h2>Partial functions</h2>
<p>A <strong>total function</strong> is a function defined for every element of its domain. This terminology is more common in computer science than in math. A lot of what we call <em>functions</em> in software are actually <strong>partial functions</strong> because they’re not defined everywhere. For example, the square root function <code>sqrt</code> in C takes a argument of type <code>double</code> and returns a value of type <code>double</code>, but it’s not defined for <em>all</em> inputs of type <code>double</code>, only those inputs that are not negative.</p>
<p>Mathematically speaking it makes no sense to refer to a function that is not defined on every point of its domain. A function’s domain is by definition the set of points where it is defined, so a total function is just a function, and a partial function is not even a function.</p>
<p>And yet it is convenient to refer informally to functions that are undefined for some inputs. This is common as dirt in software development, but it occurs in math too.</p>
<h2>Type checking</h2>
<p>The distinction between total functions and partial functions is more subtle than it may seem.</p>
<p>For example, it would be more precise to say that the <code>sqrt</code> function is defined on non-negative numbers of type <code>double</code>. There’s no non-negative floating point type in C, but in principle we could introduce one. Sounds like a good idea. Why hasn’t C done this?</p>
<p>It’s obvious when functions are defined on (some) arguments of type <code>double</code> and return (some) arguments of type <code>double</code>.  It’s not so obvious that functions are defined on more restricted types or return more restrictive types. For example, suppose you want to apply <code>sqrt</code> to a function that you wrote. If your function takes in a <code>double</code> and squares it, then this is fine. It may ostensibly return a <code>double</code> but in fact it returns a non-negative double. But if your function cubes its input then the output may not be compatible with the input to <code>sqrt</code>.</p>
<p>The domain of the square root function is simple, but what about functions that are undefined at more complicated sets. For example, the gamma function is undefined at 0 and at negative integers. The gamma function is undefined at -4, for instance, but it’s defined at -4 + ε for any tiny ε. Imagine how hard it might be to verify that a function returns -4 + ε but not -4.</p>
<p>Or suppose you have a function that computes the real part of complex numbers for which the Riemann zeta function is zero. If you could prove that the program always returns either 1/2 or a negative even integer, you would earn fame and <a href="https://www.claymath.org/millennium-problems/riemann-hypothesis">fortune</a>. This is an extreme example, but it is true that determining the precise domain or range of a function can require proving theorems that are difficult if not impossible.</p>
<h2>Dependent type theory</h2>
<p>We’re at a fork in the road. We either give up on more restrictive types and live with functions that may not be defined for every element in their domain, or we implement far more sophisticated types and type checking. In other words, we get into <strong>dependent type theory</strong>.</p>
<p>If we choose the fork leading to dependent types, there are a lot of new costs and new benefits. The benefits are more obvious than the costs. The benefits include, for example, having a compiler reject code that could pass a negative value into <code>sqrt</code>. But this comes at the expense of making it far more difficult to write compilers. It also restricts the range of programs that can be written or increases the skill requirement of those who can write the needed programs.</p>
<h2>Mathematical formalism</h2>
<p>Mathematicians informally speak of functions not being defined everywhere in their domain even though it would be more accurate to say that the domain excludes certain points. This kind of talk is fine among friends where there’s an implicit understanding of what detail is being left out and the trust that the details will be made more explicit when necessary. In a more hostile environment, like Twitter, pedants will gleefully pounce on such lapses in rigor.</p>
<p>You can make partial functions rigorous by defining them to be <strong>relations</strong> rather than functions. A relation between sets <em>A</em> and <em>B</em> is a subset of their Cartesian product <em>A</em> × <em>B</em>. A function is a relation such that for every <em>a</em> in <em>A</em> there exists a unique pair (<em>a</em>, <em>b</em>) in the relation. A partial function is a relation in which for every <em>a</em> in <em>A</em> there is <em>at most</em> one pair (<em>a</em>, <em>b</em>) in the relation.</p>
<p>A “multi-valued function” is strictly speaking an oxymoron, but more formally it is a also relation, not a function. As with partial functions, the terminology “multi-valued function” is informal. Typically there is a way to formalize multi-valued functions so that they are actual (single-valued) functions with a different codomain, but one may wish to avoid this extra formality when it is not necessary.</p>
			</div></div>
  </body>
</html>
