<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/bilinearlabs/rs-merkle-tree">Original</a>
    <h1>Our modular, high-performance Merkle Tree library for Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/87f601f96f6ecc50aa39d8fe6c8b55c735a4227c94a26ad385fc2490a80950b6/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f62696c696e6561726c6162732f72732d6d65726b6c652d747265652f727573745f6d61696e5f63692e796d6c3f7374796c653d666c61742d737175617265"><img src="https://camo.githubusercontent.com/87f601f96f6ecc50aa39d8fe6c8b55c735a4227c94a26ad385fc2490a80950b6/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f62696c696e6561726c6162732f72732d6d65726b6c652d747265652f727573745f6d61696e5f63692e796d6c3f7374796c653d666c61742d737175617265" alt="GitHub Actions Workflow Status" data-canonical-src="https://img.shields.io/github/actions/workflow/status/bilinearlabs/rs-merkle-tree/rust_main_ci.yml?style=flat-square"/></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/029eb12217c585d44ce36ada3b23ef92c884a0ac5e32d7d8fa5c03e2086fc1d2/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f62696c696e6561726c6162732f72732d6d65726b6c652d747265652f6d61696e3f746f6b656e3d31504948453755375851267374796c653d666c61742d737175617265"><img src="https://camo.githubusercontent.com/029eb12217c585d44ce36ada3b23ef92c884a0ac5e32d7d8fa5c03e2086fc1d2/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f62696c696e6561726c6162732f72732d6d65726b6c652d747265652f6d61696e3f746f6b656e3d31504948453755375851267374796c653d666c61742d737175617265" alt="Codecov (with branch)" data-canonical-src="https://img.shields.io/codecov/c/github/bilinearlabs/rs-merkle-tree/main?token=1PIHE7U7XQ&amp;style=flat-square"/></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0a3bbc12704be5f7e632e52b4ef7499e278b7af04bd95419b8a7c888566e293b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f62696c696e6561726c6162732f72732d6d65726b6c652d747265653f7374796c653d666c61742d737175617265"><img src="https://camo.githubusercontent.com/0a3bbc12704be5f7e632e52b4ef7499e278b7af04bd95419b8a7c888566e293b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f62696c696e6561726c6162732f72732d6d65726b6c652d747265653f7374796c653d666c61742d737175617265" alt="GitHub License" data-canonical-src="https://img.shields.io/github/license/bilinearlabs/rs-merkle-tree?style=flat-square"/></a>
<a href="https://discord.gg/Et8BTnVBZS" rel="nofollow"><img src="https://camo.githubusercontent.com/f04a9f2f7f89d2705e17e4c0c660e2b024246c802639f70557963f9605fe88a3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f446973636f72642d3538363546323f6c6f676f3d646973636f7264266c6f676f436f6c6f723d7768697465267374796c653d666c61742d737175617265" alt="Join our Discord" data-canonical-src="https://img.shields.io/badge/Discord-5865F2?logo=discord&amp;logoColor=white&amp;style=flat-square"/></a></p>
<p dir="auto">Merkle tree implementation in Rust with the following features:</p>
<ul dir="auto">
<li>Fixed depth: All proofs have a constant size equal to the <code>Depth</code>.</li>
<li>Append-only: Leaves are added sequentially starting at index <code>0</code>. Once added, a leaf cannot be modified.</li>
<li>Optimized for Merkle proof retrieval: Intermediate leaves are stored so that Merkle proofs can be fetched from memory without needing to be calculated lazily, resulting in very fast retrieval times.</li>
<li>Configurable storage backends to store the bottom and intermediate leaves up the root.</li>
<li>Configurable hash functions to hash nodes.</li>
<li>Simple and easy to use interface: <code>add_leaves</code>, <code>root</code>, <code>num_leaves</code>, <code>proof</code>.</li>
</ul>
<p dir="auto">Add <code>rs-merkle-tree</code> as a dependency to your Rust <code>Cargo.toml</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
rs-merkle-tree = &#34;0.1.0&#34;"><pre>[<span>dependencies</span>]
<span>rs-merkle-tree</span> = <span><span>&#34;</span>0.1.0<span>&#34;</span></span></pre></div>
<p dir="auto">You can create a Merkle tree, add leaves, get the number of leaves and get the Merkle proof of a given index as follows. This creates a simple merkle tree using keccak256 hashing algorithm, a memory storage and a depth 32.</p>
<div dir="auto" data-snippet-clipboard-copy-content="use rs_merkle_tree::to_node;
use rs_merkle_tree::tree::MerkleTree32;

fn main() {
    let mut tree = MerkleTree32::default();
    tree.add_leaves(&amp;[to_node!(
        &#34;0x532c79f3ea0f4873946d1b14770eaa1c157255a003e73da987b858cc287b0482&#34;
    )])
    .unwrap();

    println!(&#34;root: {:?}&#34;, tree.root().unwrap());
    println!(&#34;num leaves: {:?}&#34;, tree.num_leaves());
    println!(&#34;proof: {:?}&#34;, tree.proof(0).unwrap().proof);
}"><pre><span>use</span> rs_merkle_tree<span>::</span>to_node<span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>tree<span>::</span><span>MerkleTree32</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> tree = <span>MerkleTree32</span><span>::</span><span>default</span><span>(</span><span>)</span><span>;</span>
    tree<span>.</span><span>add_leaves</span><span>(</span><span>&amp;</span><span>[</span><span>to_node</span><span>!</span><span>(</span>
        <span>&#34;0x532c79f3ea0f4873946d1b14770eaa1c157255a003e73da987b858cc287b0482&#34;</span>
    <span>)</span><span>]</span><span>)</span>
    <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>

    <span>println</span><span>!</span><span>(</span><span>&#34;root: {:?}&#34;</span><span>,</span> tree<span>.</span>root<span>(</span><span>)</span><span>.</span>unwrap<span>(</span><span>)</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;num leaves: {:?}&#34;</span><span>,</span> tree<span>.</span>num_leaves<span>(</span><span>)</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;proof: {:?}&#34;</span><span>,</span> tree<span>.</span>proof<span>(</span><span>0</span><span>)</span><span>.</span>unwrap<span>(</span><span>)</span><span>.</span>proof<span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">You can customize your tree by choosing a different store, hash function, and depth as follows. Note that you have to modify the <code>feature</code> for the stores. This avoids importing the stuff you don&#39;t need. See the following examples.</p>
<p dir="auto"><strong>Depth: 32 | Hashing: Keccak | Store: sled</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
rs-merkle-tree = { version = &#34;0.1.0&#34;, features = [&#34;sled_store&#34;] }"><pre>[<span>dependencies</span>]
<span>rs-merkle-tree</span> = { <span>version</span> = <span><span>&#34;</span>0.1.0<span>&#34;</span></span>, <span>features</span> = [<span><span>&#34;</span>sled_store<span>&#34;</span></span>] }</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="use rs_merkle_tree::hasher::Keccak256Hasher;
use rs_merkle_tree::stores::SledStore;
use rs_merkle_tree::tree::MerkleTree;

fn main() {
    let mut tree: MerkleTree&lt;Keccak256Hasher, SledStore, 32&gt; =
        MerkleTree::new(Keccak256Hasher, SledStore::new(&#34;sled.db&#34;, true));
}"><pre><span>use</span> rs_merkle_tree<span>::</span>hasher<span>::</span><span>Keccak256Hasher</span><span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>stores<span>::</span><span>SledStore</span><span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>tree<span>::</span><span>MerkleTree</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> tree<span>:</span> <span>MerkleTree</span><span>&lt;</span><span>Keccak256Hasher</span><span>,</span> <span>SledStore</span><span>,</span> <span>32</span><span>&gt;</span> =
        <span>MerkleTree</span><span>::</span><span>new</span><span>(</span><span>Keccak256Hasher</span><span>,</span> <span>SledStore</span><span>::</span><span>new</span><span>(</span><span>&#34;sled.db&#34;</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto"><strong>Depth: 32 | Hashing: Poseidon | Store: rocksdb</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="rs-merkle-tree = { version = &#34;0.1.0&#34;, features = [&#34;rocksdb_store&#34;] }"><pre><span>rs-merkle-tree</span> = { <span>version</span> = <span><span>&#34;</span>0.1.0<span>&#34;</span></span>, <span>features</span> = [<span><span>&#34;</span>rocksdb_store<span>&#34;</span></span>] }</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="use rs_merkle_tree::hasher::PoseidonHasher;
use rs_merkle_tree::stores::RocksDbStore;
use rs_merkle_tree::tree::MerkleTree;

fn main() {
    let mut tree: MerkleTree&lt;PoseidonHasher, RocksDbStore, 32&gt; =
        MerkleTree::new(PoseidonHasher, RocksDbStore::new(&#34;rocksdb.db&#34;));
}
"><pre><span>use</span> rs_merkle_tree<span>::</span>hasher<span>::</span><span>PoseidonHasher</span><span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>stores<span>::</span><span>RocksDbStore</span><span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>tree<span>::</span><span>MerkleTree</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> tree<span>:</span> <span>MerkleTree</span><span>&lt;</span><span>PoseidonHasher</span><span>,</span> <span>RocksDbStore</span><span>,</span> <span>32</span><span>&gt;</span> =
        <span>MerkleTree</span><span>::</span><span>new</span><span>(</span><span>PoseidonHasher</span><span>,</span> <span>RocksDbStore</span><span>::</span><span>new</span><span>(</span><span>&#34;rocksdb.db&#34;</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto"><strong>Depth: 32 | Hashing: Poseidon | Store: sqlite</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="rs-merkle-tree = { version = &#34;0.1.0&#34;, features = [&#34;sqlite_store&#34;] }"><pre><span>rs-merkle-tree</span> = { <span>version</span> = <span><span>&#34;</span>0.1.0<span>&#34;</span></span>, <span>features</span> = [<span><span>&#34;</span>sqlite_store<span>&#34;</span></span>] }</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="use rs_merkle_tree::hasher::PoseidonHasher;
use rs_merkle_tree::stores::SqliteStore;
use rs_merkle_tree::tree::MerkleTree;

fn main() {
    let mut tree: MerkleTree&lt;PoseidonHasher, SqliteStore, 32&gt; =
        MerkleTree::new(PoseidonHasher, SqliteStore::new(&#34;tree.db&#34;));
}"><pre><span>use</span> rs_merkle_tree<span>::</span>hasher<span>::</span><span>PoseidonHasher</span><span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>stores<span>::</span><span>SqliteStore</span><span>;</span>
<span>use</span> rs_merkle_tree<span>::</span>tree<span>::</span><span>MerkleTree</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> tree<span>:</span> <span>MerkleTree</span><span>&lt;</span><span>PoseidonHasher</span><span>,</span> <span>SqliteStore</span><span>,</span> <span>32</span><span>&gt;</span> =
        <span>MerkleTree</span><span>::</span><span>new</span><span>(</span><span>PoseidonHasher</span><span>,</span> <span>SqliteStore</span><span>::</span><span>new</span><span>(</span><span>&#34;tree.db&#34;</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>

<p dir="auto">The following stores are supported:</p>
<ul dir="auto">
<li><a href="https://github.com/rusqlite/rusqlite">rusqlite</a></li>
<li><a href="https://github.com/rust-rocksdb/rust-rocksdb">rocksdb</a></li>
<li><a href="https://github.com/spacejam/sled">sled</a></li>
</ul>

<p dir="auto">The following hash functions are supported:</p>
<ul dir="auto">
<li><a href="https://github.com/debris/tiny-keccak">keccak256</a></li>
<li><a href="https://github.com/Lightprotocol/light-poseidon/">Poseidon BN254 Circom T3</a></li>
</ul>

<p dir="auto">The following benchmarks measure in a AMD Ryzen 7 7700 8-Core Processor with 64GB of RAM the following:</p>
<ul dir="auto">
<li>Consumed disk size</li>
<li>Leaf insertion throughput in thousands per second.</li>
<li>Merkle proof generation times.</li>
</ul>
<p dir="auto">You can run them with</p>
<div data-snippet-clipboard-copy-content="cargo bench --features=all"><pre><code>cargo bench --features=all
</code></pre></div>
<p dir="auto">And you can generate the following table with this.</p>


<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Store</th>
<th>Depth</th>
<th>Leaves</th>
<th>Size (MiB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>sled</td>
<td>32</td>
<td>1000000</td>
<td>290.00</td>
</tr>
<tr>
<td>sqlite</td>
<td>32</td>
<td>1000000</td>
<td>159.18</td>
</tr>
<tr>
<td>rocksdb</td>
<td>32</td>
<td>1000000</td>
<td>183.27</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Depth</th>
<th>Hash</th>
<th>Store</th>
<th>Throughput (Kelem/s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>32</td>
<td>keccak256</td>
<td>rocksdb</td>
<td>18.280</td>
</tr>
<tr>
<td>32</td>
<td>keccak256</td>
<td>sqlite</td>
<td>22.348</td>
</tr>
<tr>
<td>32</td>
<td>keccak256</td>
<td>sled</td>
<td>43.280</td>
</tr>
<tr>
<td>32</td>
<td>keccak256</td>
<td>memory</td>
<td>86.084</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Depth</th>
<th>Hash</th>
<th>Store</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>32</td>
<td>keccak256</td>
<td>memory</td>
<td>560.990 ns</td>
</tr>
<tr>
<td>32</td>
<td>keccak256</td>
<td>sled</td>
<td>7.878 µs</td>
</tr>
<tr>
<td>32</td>
<td>keccak256</td>
<td>sqlite</td>
<td>14.562 µs</td>
</tr>
<tr>
<td>32</td>
<td>keccak256</td>
<td>rocksdb</td>
<td>34.391 µs</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto"><a href="https://github.com/bilinearlabs/rs-merkle-tree/blob/main/LICENSE">MIT License</a></p>
</article></div></div>
  </body>
</html>
