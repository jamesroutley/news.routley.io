<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.eq8.eu/til/update-millions-of-records-in-rails.html">Original</a>
    <h1>Update millions of records in Rails</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>How to update half a billion entries on a PostgreSQL table with Ruby on Rails &amp; <a href="https://github.com/sidekiq/sidekiq">Sidekiq</a></p>

<h3 id="worker">Worker</h3>

<pre><code># app/workers/update_addresses_worker.rb
class UpdateAddressesWorker
  include Sidekiq::Worker
  sidekiq_options queue: :manual

  def perform(min_id, max_id, batch_size = 1_000)
    Address
      .where(id: min_id..max_id)
      .in_batches(of: batch_size) do |address_batch|
        MyService.new.call(address_batch)
      end
  end
end
</code></pre>

<blockquote>
  <p>note: my queue name is ‚Äú<em>manual</em>‚Äù you can use ‚Äú<em>default</em>‚Äù or whatever you use in your app.</p>
</blockquote>

<h3 id="service">Service</h3>

<p>For simplicity <code>MyService</code> will just downcase <code>city</code> name &amp; <code>state</code> for entire batch of Address objects</p>

<p>In this example I‚Äôm using gem <a href="https://github.com/zdennis/activerecord-import">activerecord-import</a> in order to update/insert multiple records with <em>one SQL query</em> (including validations).</p>

<blockquote>
  <p>Vanilla Rails has <a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert_all">.upsert_all</a> that serves simmilar purpouse.
Reason why I use <code>activerecord-import</code> instead is that the project I work for already uses this gem == well tested solution for our case.</p>
</blockquote>

<pre><code>class MyService
  def call(address_batch)
    addresses = address_batch.map do |address|
      address.city.downcase!
      address.state.downcase!
      address
    end

    # `Model.import` is from activerecord-import gem
    ::Address.import(
      addresses,
      on_duplicate_key_update: {
        conflict_target: %i[id],
        validate: true,
        columns: [:city, :state]
      }
    )
  end
end
</code></pre>

<p>Notice <a href="https://github.com/zdennis/activerecord-import#duplicate-key-update">on_duplicate_key_update</a> options which takes care of updates of <code>city</code> &amp; <code>state</code> (columns) when <code>addresses</code> db row matching the <code>id</code> (conflict_target) already exist.</p>

<h3 id="how-to-schedule-this">How to schedule this</h3>

<p>Once you deploy the worker code to prod run a <code>rails c</code> console in production env.</p>

<p>Now try scheduling the worker in small chunks like this:</p>

<pre><code>Address.in_batches(of: 1_000, start: 300_000_000, finish: 300_010_000) do |address_batch|
   min_id = address_batch.minimum(:id)
   max_id = address_batch.maximum(:id)
   worker_batch_size = 250
   puts &#34;#{min_id} - #{max_id}  [#{worker_batch_size}]&#34;
   UpdateAddressesWorker.perform_async(min_id, max_id, worker_batch_size)
end

# 300_000_000 - 300_002_000  [250]
# 300_002_001 - 300_004_029  [250]
# 300_004_030 - 300_006_567  [250]
# ...
</code></pre>

<h3 id="figure-out-the-best-for-you">Figure out the best for you</h3>

<p>Because we are dealing with several hundred millions of records it‚Äôs not easy to get those numbers right. You need to schedule few thousand record samples and <strong>monitor</strong> how well/bad will your worker perform</p>

<blockquote>
  <p>e.g in Heroku monitor your worker dyno Memory usage, in tool like NewRelic or AppSignal monitor DB Load &amp; I/O Operations, Monitor errors, In Sidekiq Web UI monitor number of jobs in queue and how long the job takes to finish (aim for ‚Äúfinish fast‚Äù jobs - up to 2 minutes was my goal)</p>
</blockquote>

<p>Maybe your worker will consume all the memory and you need to schedule smaller batches. Maybe you need to increase memory on the underlying VM running your Sidekiq workers</p>

<blockquote>
  <p>For example Heroku Standard 1x Dyno has only 512MB, maybe increase it to Standard 2x Dyno (1GB could be enough), or in some cases it make sense to go Performance-M Dyno with 2,5GB. More in <a href="https://devcenter.heroku.com/articles/dyno-types">heroku dynos</a> and <a href="https://judoscale.com/guides/how-many-dynos">common dyno type issues</a></p>
</blockquote>

<p>Maybe your worker will be underutilized and therefore you can increase <code>worker_batch_size</code> or <strong>number of threads for your Sidekiq worker</strong></p>

<blockquote>
  <p>just be mindfull on how many active connections your PosgreSQL DB can handle.
For example Heroku‚Äôs Standard 7 has 500 <a href="https://elements.heroku.com/addons/heroku-postgresql#pricing">Connection Limit</a>. For example 30 dyno with 5 threads == 150 DB connections + you still need connections for rest of the app (webserver, other workers)</p>
</blockquote>

<p>Try tweeking those numbers and for each schedule a sample of couple thousand of records.</p>

<p>Once you got this right you can go wild and increas number of Sidekiq workers (for example have 30, 40, 50 Heroku dynos for your worker)</p>

<p>Recommendation here is not to schedule all 500 M records. But try to schedule 100K see how it goes (monitor), then 1M (monitor), then 10M, 100M, ‚Ä¶</p>

<h3 id="implement-killswitch">Implement Killswitch</h3>

<p>You are enqueuing a LOT of jobs. Be sure you have a way to kill those jobs if something goes wrong.</p>

<h4 id="option-1---separate-worker-for-script-jobs">Option 1 - Separate worker for script jobs</h4>

<p>You don‚Äôt need to add any special killswitch code for exit a job.</p>

<p>We recommend to have separate Sidekiq worker dedicated to script jobs like this.
Benefit is that if something goes wrong you can just scale these worker VMs to 0 (or 0 worker dynos on Heroku) and just delete the enqued jobs from Sidekiq Web UI.</p>

<p><code>cat config/manual_sidekiq.yml</code></p>

<pre><code>:concurrency: &lt;%= (ENV[&#39;MANUAL_MAX_THREADS&#39;] || 1).to_i %&gt;
:queues:
  - [manual, 4]
</code></pre>

<blockquote>
  <p>note: the ‚ÄúMANUAL_MAX_THREADS‚Äù ENV variable, you can use this to scale the number of threads for your Sidekiq worker that would be running this script jobs. For example if you have 30 dynos for this worker you can set this to 5 and you will have 150 threads running in parallel.</p>
</blockquote>

<h4 id="option-2---killswitch-flag">Option 2 - Killswitch flag</h4>

<p>If Option 1 is not possible for you, you can implement a killswitch flag in your worker code.</p>

<p>If you use something like <a href="https://github.com/jnunemaker/flipper">Flipper</a> you can exit a job if a flag is set, etc‚Ä¶</p>

<pre><code># app/workers/update_addresses_worker.rb
class UpdateAddressesWorker
  # ...

  def perform(min_id, max_id, batch_size = 1_000)
    return if Flipper[:killswitch].enabled? # optional
    # ...or `return if ENV[&#39;KILLSWITCH&#39;].present?`
    # ...or just deploy updated worker with `return` on beginning of this method

    #...
</code></pre>

<blockquote>
  <p>e.g. in Heroku when you change ENV variable dyno will reinstantiate . So you can set e.g. <code>KILLSWITCH</code> ENV variable.</p>
</blockquote>

<h3 id="how-long-did-it-take">How long did it take?</h3>

<p>For our setup/task (just update few fields on a table) the process of probing different batch sizes &amp; Sidekiq thread numbers with couple of thousands/millions records took about 5 hours. We ended up with 5 threads on 40 Standard 2x Heroku dynos. Then the actual run of the script with rest of the  half a billion records was finished by the morning (I‚Äôve run it like 11 PM, I‚Äôve checked 7AM next day and all was finished).</p>

<blockquote>
  <p>We use <a href="https://elements.heroku.com/addons/judoscale">Judoscale</a> so the dyno number was back to 0 by the morning.</p>
</blockquote>

<p>Again this is very specific to our setup. Your setup will be different. You need to monitor and adjust accordingly.
Also our DB was not under heavy load during the night. If you have a lot of usage on your DB you need to be more careful.</p>

<h3 id="credits">Credits</h3>

<p>Full credit for this solution goes to  <a href="https://github.com/mbbertino">Matt Bertino</a> who taught me this. He is a true PostgeSQL &amp; Ruby on Rails wizard üßô‚Äç‚ôÇÔ∏è.</p>

<h3 id="source">Source</h3>

<ul>
  <li><a href="https://github.com/zdennis/activerecord-import#introduction">https://github.com/zdennis/activerecord-import#introduction</a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert_all">https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert_all</a></li>
  <li><a href="https://apidock.com/rails/v6.0.0/ActiveRecord/Persistence/ClassMethods/upsert_all">https://apidock.com/rails/v6.0.0/ActiveRecord/Persistence/ClassMethods/upsert_all</a></li>
  <li><a href="https://blog.kiprosh.com/rails-7-adds-new-options-to-upsert_all/">https://blog.kiprosh.com/rails-7-adds-new-options-to-upsert_all/</a></li>
  <li><a href="https://judoscale.com/guides/how-many-dynos">https://judoscale.com/guides/how-many-dynos</a></li>
</ul>

<h3 id="discussion">Discussion</h3>

<ul>
  <li><a href="https://www.reddit.com/r/rubyonrails/comments/12zo2pp/update_millions_of_records_in_rails_fast/">https://www.reddit.com/r/rubyonrails/comments/12zo2pp/update_millions_of_records_in_rails_fast/</a></li>
  <li><a href="https://www.reddit.com/r/ruby/comments/12zmxkb/update_millionsbillions_of_records_in_rails/">https://www.reddit.com/r/ruby/comments/12zmxkb/update_millionsbillions_of_records_in_rails/</a></li>
  <li><a href="https://www.reddit.com/r/rails/comments/12zmw17/update_millionsbillions_of_records_in_rails/">https://www.reddit.com/r/rails/comments/12zmw17/update_millionsbillions_of_records_in_rails/</a></li>
</ul>

  </div></div>
  </body>
</html>
