<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://reverse.put.as/2024/05/24/abusing-go-infrastructure/">Original</a>
    <h1>Abusing Go&#39;s Infrastructure</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p>I apologize if this information is already known, but I couldn’t find any references about it and I wanted to understand what was going on and share with you because I think there is some value doing it.</p><p>In case this wasn’t known, I apologize to the Go team for not talking to them first and jumping the full disclosure gun (I don’t think it’s that severe). I really like Go! Thanks for all your great work.</p><h3 id="the-problem">The problem</h3><p>Last night, I was exploring the contents of Go’s <a href="https://sum.golang.org">checksum database</a>, and I noticed a curious result:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>sqlite</span><span>&gt;</span><span> </span><span>select</span><span> </span><span>path</span><span>,</span><span> </span><span>count</span><span>(</span><span>path</span><span>)</span><span> </span><span>from</span><span> </span><span>modules</span><span> </span><span>group</span><span> </span><span>by</span><span> </span><span>path</span><span> </span><span>order</span><span> </span><span>by</span><span> </span><span>count</span><span>(</span><span>path</span><span>)</span><span> </span><span>desc</span><span>;</span><span>
</span></span></span><span><span><span></span><span>github</span><span>.</span><span>com</span><span>/</span><span>homebrew</span><span>/</span><span>homebrew</span><span>-</span><span>core</span><span>|</span><span>39438</span><span>
</span></span></span><span><span><span></span><span>github</span><span>.</span><span>com</span><span>/</span><span>Homebrew</span><span>/</span><span>homebrew</span><span>-</span><span>core</span><span>|</span><span>30896</span><span>
</span></span></span><span><span><span></span><span>github</span><span>.</span><span>com</span><span>/</span><span>concourse</span><span>/</span><span>concourse</span><span>|</span><span>25372</span><span>
</span></span></span><span><span><span></span><span>github</span><span>.</span><span>com</span><span>/</span><span>openshift</span><span>/</span><span>release</span><span>|</span><span>24065</span><span>
</span></span></span><span><span><span></span><span>github</span><span>.</span><span>com</span><span>/</span><span>cilium</span><span>/</span><span>cilium</span><span>|</span><span>22138</span><span>
</span></span></span></code></pre></div><p>The homebrew/Homebrew case divergence is explained by Go’s <a href="https://go.dev/ref/mod#checksum-database">documentation</a> (thanks to Filippo Valsorda!):</p><blockquote><p>To avoid ambiguity when serving from case-insensitive file systems, the $module and $version elements are case-encoded by replacing every uppercase letter with an exclamation mark followed by the corresponding lower-case letter. This allows modules example.com/M and example.com/m to both be stored on disk, since the former is encoded as example.com/!m.</p></blockquote><p>Anyway, this caught my attention because Homebrew is known to use Ruby, and so I went to check the <a href="https://github.com/homebrew/homebrew-core">repository</a> contents.</p><p>GitHub language stats confirm it:</p><div><figure><picture><source type="image/webp" srcset="/2024/05/24/abusing-go-infrastructure/images/language_hu267d31ab4b55e7f16429a4d30873c6f5_16260_295x0_resize_q80_h2_box_3.webp"/><source type="image/png" srcset="/2024/05/24/abusing-go-infrastructure/images/language.png"/><img loading="lazy" src="https://reverse.put.as/2024/05/24/abusing-go-infrastructure/images/language.png" alt="language stats"/></picture></figure></div><p>This result seems unexpected, since there are no traces of Go and there are more than 70,000 entries in Go’s checksum database. To be sure, I cloned the repository and tried to find any Go-related files such as <code>go.mod</code> or Go source files; however, nothing exists.</p><p>So I posted a tweet (technically a toot on Mastodon), got no replied and moved on.</p><p>While continuing to explore the database, I noticed another unusual case in <code>github.com/Edu4rdSHL/rust-headless-chrome</code>. It’s just a fork of <a href="https://github.com/rust-headless-chrome/rust-headless-chrome">rust-headless-chrome</a>, and there is nothing remarkable about the fork or the original except that they are both Rust repositories, and once again, no connection to Go.</p><p>Now my curiosity is piqued and the evil mode kicks in. It feels like arbitrary data can be pushed to the checksum database without a connection to Go. Why is the data being pushed? And how is it being pushed? I go to bed thinking about this, which is the most dangerous moment for security research. As I try to fall asleep, I come up with tons of ideas, but I’m usually too tired or lazy to take notes, and so, quite frequently, I can’t remember them in the morning. But this one wasn’t forgotten!</p><h3 id="research">Research</h3><p>A new day and a curious mind demands answers. Why, how and, what if are the most dangerous questions in this field. If a Git repository has nothing to do with Go code, how does it appear in the Go checksum database?</p><p>From previous documentation readings, I knew that <code>proxy.golang.org</code> was the default modules proxy, and <code>sum.golang.org</code> for the checksum database. A couple of <code>ripgrep</code> searches in Go source code return nothing interesting, so it was time to read Go’s documentation, which is usually quite good.</p><p>Where to start? <a href="https://go.dev/ref/mod">Go Modules Reference</a> was a great candidate and I finally found the answer to my question:</p><blockquote><p>If the go command consults the checksum database, then the first step is to retrieve the record data through the /lookup endpoint. If the module version is not yet recorded in the log, the checksum database will try to fetch it from the origin server before replying.</p></blockquote><p>Okay, this was easy! If the module doesn’t exist in the checksum database (and proxy), it will be downloaded by the checksum and proxy infrastructure. One of my questions was: how did the checksum database retrieve the modules since they can be anywhere? I couldn’t find anything in the Go code that was responsible for that (which wouldn’t explain at all how Ruby and Rust code ended up in the database).</p><p>So, the next logical step is easy. Can I get the Go checksum server to download arbitrary data?</p><p>According to the <a href="https://go.dev/ref/mod#checksum-database">documentation</a>, the endpoint to try this is <code>$base/lookup/$module@$version</code>:</p><blockquote><p>Returns the log record number for the entry about $module at $version, followed by the data for the record (that is, the go.sum lines for $module at $version) and a signed, encoded tree description that contains the record.</p></blockquote><p>First, let’s test it with a known record to see if and how it works:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ curl https://sum.golang.org/lookup/github.com/homebrew/homebrew-core@v0.0.0-20240524162643-646fe2715a1c
</span></span><span><span><span>26235981</span>
</span></span><span><span>github.com/homebrew/homebrew-core v0.0.0-20240524162643-646fe2715a1c h1:U32osaj3vZGypOtq7tsIHhZAYNOmiShiXJysIFGTqyM<span>=</span>
</span></span><span><span>github.com/homebrew/homebrew-core v0.0.0-20240524162643-646fe2715a1c/go.mod h1:TM9a6pxWZJZZWuMzxESXhb6yaBaH9JAKDM4wpIzJsDE<span>=</span>
</span></span><span><span>
</span></span><span><span>go.sum database tree
</span></span><span><span><span>26238433</span>
</span></span><span><span><span>TQyXJYWJL6Z1OnKk5JXLAb9xfWrtHKjAUXKx5UQCa9Q</span><span>=</span>
</span></span><span><span>
</span></span><span><span>— sum.golang.org Az3grm+I35+HBcG+YvxlX+nzkXah3cWlBac/4EytsG24bEHFLrJNvyz5SphrKAHSS0EeDKJXpnb3cvdUtqVSiaNLVAY<span>=</span>
</span></span></code></pre></div><p>Since the repository doesn’t seem to have any version tag the pseudo-version is used instead. Go <a href="https://go.dev/ref/mod#pseudo-versions">documentation</a> explains the logic behind pseudo-versions.</p><p>The next step is to verify wheter a new Go module repository will be added to the checksum database and proxy if we call the <code>lookup</code> endpoint, as described.</p><p>After creating a simple new Go module and uploading to my GitHub account I have tried to issue the <code>lookup</code> command in two different forms, one not totally according to documentation, the other one also incorrect but trying to follow documentation. Both return errors, although different.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ curl https://sum.golang.org/lookup/github.com/gdbinit/fluxmatter@latest
</span></span><span><span>bad request: version <span>&#34;latest&#34;</span> is not canonical <span>(</span>wanted <span>&#34;&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>$ curl https://sum.golang.org/lookup/github.com/gdbinit/fluxmatter@v0.0.0
</span></span><span><span>not found: github.com/gdbinit/fluxmatter@v0.0.0: invalid version: unknown revision v0.0.0
</span></span></code></pre></div><p>The errors are kind of expected since I haven’t versioned the module and wasn’t using the correct pseudo-version. But we can verify if the new module was fetched as described by the documentation. The easiest way would be to generate the correct pseudo-version and make another query to the checksum database. If the module was indeed downloaded, then the entry would exist and returned as in the <code>homebrew-core</code> test.</p><p>Another way would be to resync my copy of the checksum database and query it for my module:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>sqlite</span><span>&gt;</span><span> </span><span>select</span><span> </span><span>*</span><span> </span><span>from</span><span> </span><span>modules</span><span> </span><span>where</span><span> </span><span>path</span><span> </span><span>=</span><span> </span><span>&#39;github.com/gdbinit/fluxmatter&#39;</span><span>;</span><span>
</span></span></span><span><span><span></span><span>github</span><span>.</span><span>com</span><span>/</span><span>gdbinit</span><span>/</span><span>fluxmatter</span><span>|</span><span>v0</span><span>.</span><span>0</span><span>.</span><span>0</span><span>-</span><span>20240524163826</span><span>-</span><span>a7e64ffd69f2</span><span>|</span><span>2024</span><span>-</span><span>05</span><span>-</span><span>24</span><span>T16</span><span>:</span><span>40</span><span>:</span><span>51</span><span>.</span><span>203837</span><span>Z</span><span>
</span></span></span></code></pre></div><p>Finally we can query the proxy and use the <code>latest</code> query to return the latest known version of a module. And then download the module <code>zip</code> and prove that we just stored our arbitrary data in the Go infrastructure.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ curl https://proxy.golang.org/github.com/gdbinit/fluxmatter/@latest
</span></span><span><span><span>{</span><span>&#34;Version&#34;</span>:<span>&#34;v0.0.0-20240524163826-a7e64ffd69f2&#34;</span>,<span>&#34;Time&#34;</span>:<span>&#34;2024-05-24T16:38:26Z&#34;</span>,<span>&#34;Origin&#34;</span>:<span>{</span><span>&#34;VCS&#34;</span>:<span>&#34;git&#34;</span>,<span>&#34;URL&#34;</span>:<span>&#34;https://github.com/gdbinit/fluxmatter&#34;</span>,<span>&#34;Hash&#34;</span>:<span>&#34;a7e64ffd69f2d0751a52736e832a8d77a21059e7&#34;</span><span>}}</span>
</span></span><span><span>
</span></span><span><span>$ curl -O https://proxy.golang.org/github.com/gdbinit/fluxmatter/@v/v0.0.0-20240524163826-a7e64ffd69f2.zip
</span></span><span><span>$ file v0.0.0-20240524163826-a7e64ffd69f2.zip
</span></span><span><span>v0.0.0-20240524163826-a7e64ffd69f2.zip: Zip archive data, at least v2.0 to extract
</span></span><span><span>
</span></span><span><span>$ unzip -t v0.0.0-20240524163826-a7e64ffd69f2.zip
</span></span><span><span>Archive:  v0.0.0-20240524163826-a7e64ffd69f2.zip
</span></span><span><span>    testing: github.com/gdbinit/fluxmatter@v0.0.0-20240524163826-a7e64ffd69f2/LICENSE   OK
</span></span><span><span>    testing: github.com/gdbinit/fluxmatter@v0.0.0-20240524163826-a7e64ffd69f2/fluxmatter.go   OK
</span></span><span><span>    testing: github.com/gdbinit/fluxmatter@v0.0.0-20240524163826-a7e64ffd69f2/go.mod   OK
</span></span><span><span>No errors detected in compressed data of v0.0.0-20240524163826-a7e64ffd69f2.zip.
</span></span></code></pre></div><p>And voilà, everything works! There’s no need to specify a version in the lookup (at least for the initial seeding); just a lookup query that contains the module path and something like a version.</p><p>Next I tried to do the same with a repository that has no Go code whatsoever, to prove that everything works the same way.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ curl https://sum.golang.org/lookup/github.com/gdbinit/readmem@v0.0.0
</span></span><span><span>not found: github.com/gdbinit/readmem@v0.0.0: invalid version: unknown revision v0.0.0
</span></span><span><span>
</span></span><span><span>sqlite&gt; <span>select</span> * from modules where <span>path</span> <span>=</span> <span>&#39;github.com/gdbinit/readmem&#39;</span><span>;</span>
</span></span><span><span>github.com/gdbinit/readmem<span>|</span>v0.0.0-20131006075740-407cb0a56933<span>|</span>2024-05-24T16:45:35.88456Z
</span></span><span><span>
</span></span><span><span>$ curl https://proxy.golang.org/github.com/gdbinit/readmem/@latest
</span></span><span><span><span>{</span><span>&#34;Version&#34;</span>:<span>&#34;v0.0.0-20131006075740-407cb0a56933&#34;</span>,<span>&#34;Time&#34;</span>:<span>&#34;2013-10-06T07:57:40Z&#34;</span>,<span>&#34;Origin&#34;</span>:<span>{</span><span>&#34;VCS&#34;</span>:<span>&#34;git&#34;</span>,<span>&#34;URL&#34;</span>:<span>&#34;https://github.com/gdbinit/readmem&#34;</span>,<span>&#34;Hash&#34;</span>:<span>&#34;407cb0a569336f98f3772582a31c17aa080caf66&#34;</span><span>}}</span>
</span></span><span><span>
</span></span><span><span>$ curl -O https://proxy.golang.org/github.com/gdbinit/readmem/@v/v0.0.0-20131006075740-407cb0a56933.zip
</span></span><span><span>$ file v0.0.0-20131006075740-407cb0a56933.zip
</span></span><span><span>v0.0.0-20131006075740-407cb0a56933.zip: Zip archive data, at least v2.0 to extract
</span></span><span><span>
</span></span><span><span>$ unzip -t v0.0.0-20131006075740-407cb0a56933.zip
</span></span><span><span>Archive:  v0.0.0-20131006075740-407cb0a56933.zip
</span></span><span><span>    testing: github.com/gdbinit/readmem@v0.0.0-20131006075740-407cb0a56933/Entitlements.plist   OK
</span></span><span><span>    testing: github.com/gdbinit/readmem@v0.0.0-20131006075740-407cb0a56933/README   OK
</span></span><span><span>    testing: github.com/gdbinit/readmem@v0.0.0-20131006075740-407cb0a56933/readmem.xcodeproj/project.pbxproj   OK
</span></span><span><span>    testing: github.com/gdbinit/readmem@v0.0.0-20131006075740-407cb0a56933/readmem/main.c   OK
</span></span><span><span>No errors detected in compressed data of v0.0.0-20131006075740-407cb0a56933.zip.
</span></span></code></pre></div><p>This demonstrates that it’s possible to load into Go public proxy arbitrary data. The experiment was done using GitHub but it should work with other hosting sites.</p><p>One curious statistic is the amount of Go modules stored at GitHub:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>sqlite</span><span>&gt;</span><span> </span><span>select</span><span> </span><span>count</span><span>(</span><span>distinct</span><span> </span><span>path</span><span>)</span><span> </span><span>from</span><span> </span><span>modules</span><span>;</span><span>
</span></span></span><span><span><span></span><span>1591375</span><span>
</span></span></span><span><span><span></span><span>sqlite</span><span>&gt;</span><span> </span><span>select</span><span> </span><span>count</span><span>(</span><span>distinct</span><span> </span><span>path</span><span>)</span><span> </span><span>from</span><span> </span><span>modules</span><span> </span><span>where</span><span> </span><span>path</span><span> </span><span>like</span><span> </span><span>&#39;github.com%&#39;</span><span>;</span><span>
</span></span></span><span><span><span></span><span>1515957</span><span>
</span></span></span></code></pre></div><p>Around 95% of the unique paths present in <code>sum.golang.org</code> are hosted at GitHub. This is a raw statistic, without removing bogus data such as forks and targets that aren’t really Go code. But it still shows the magnitude of GitHub dependency in the Go ecosystem.</p><p>Go authors don’t seem to be completely unaware of this kind of scenario and implemented some restrictions, which are described in <a href="https://go.dev/ref/mod#zip-path-size-constraints">File path and size constraints</a> section. The most relevant one is:</p><blockquote><p>A module zip file may be at most 500 MiB in size. The total uncompressed size of its files is also limited to 500 MiB. go.mod files are limited to 16 MiB. LICENSE files are also limited to 16 MiB. These limits exist to mitigate denial of service attacks on users, proxies, and other parts of the module ecosystem. Repositories that contain more than 500 MiB of files in a module directory tree should tag module versions at commits that only include files needed to build the module’s packages; videos, models, and other large assets are usually not needed for builds.</p></blockquote><p>500MiB is more than enough for considerable abuse and all the others aren’t really a problem.</p><h3 id="abuse-what">Abuse what?</h3><p>For example, it can be used to bypass destination download restrictions on developer machines and in CI/CD servers (assuming that there isn’t a private GOPROXY). Malware can simply store payloads and retrieve them from the proxy when needed. And because we don’t have restrictions regarding the source domain (as long it’s a working VCS), we can load up the payloads from anywhere and make those sources disappear, leaving only a small trace in the checksum database entry.</p><p>A Denial of Service (DoS) attack on <code>proxy.golang.org</code> might be challenging to execute. I have shown that we can request any random Git repository (and probably any of the other supported VCS) to be downloaded by the proxy. For a possible attack, we would need to first gather as many GitHub URLs as possible and then issue as many requests as possible to the <code>lookup</code> API. I have no idea about the server implementation, but I would assume that something similar to a work queue is implemented, so there is a limit to the amount of parallel requests that will be processed. Bandwidth protections could also possibly be triggered from GitHub’s side. There is also a possibility of DoS-ing the storage space. I’m just guessing here :-).</p><p>A command and control (C2) can also be easily implemented on top of this. It’s very easy to find the latest version of any module using the <code>latest</code> query, so there isn’t need to query the checksum database and find all the available versions of our payload. The payload can be a simple file or can be disguised inside the <code>go.mod</code> or any other Go source file for extra stealthiness. A module DGA (Domain Generation Algorithm) can be used to avoid using a single repository for the C2. My original goal was to write a sample C2 to demonstrate this, but there isn’t really much to be done here.</p><p>To download commands from the C2, the implant just needs the following steps:</p><ul><li><p>Make a request to <code>https://proxy.golang.org/module_path/@latest</code>.</p></li><li><p>Parse the JSON result and extract the pseudo-version (or version if used).</p></li><li><p>Make another request to <code>https://proxy.golang.org/module_path/@v/version.zip</code> to download the zip file.</p></li><li><p>Extract the zip contents and parse the commands.</p></li></ul><p>Quite easy in some 300 or less lines of Go code.</p><h3 id="conclusions">Conclusions</h3><p>My questions have been answered, and now I understand how the checksum database process works. So far, it’s not a severe issue in Go infrastructure. It’s something that can be easily abused but also improved. Maybe there are (documented or not) reasons to let non-Go code be uploaded to the proxy and checksum database. Or maybe there is already someone abusing this, and we can go on a treasure hunt through the almost 1.6 million unique repositories (my up-to-date database copy contains almost 22 million entries).</p><p>I still have questions why certain valid non-Go projects are in the database. Are they doing it on purpose? Why? Using Go’s transparent log as safety backup? Any hints about this?</p><p>I had fun with this, and I have a bunch of ideas to further explore. I have a feeling… ;-).</p><p>Have fun,</p></div></article></div></div>
  </body>
</html>
