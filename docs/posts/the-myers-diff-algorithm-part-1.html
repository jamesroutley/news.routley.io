<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">Original</a>
    <h1>The Myers diff algorithm: part 1</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>If you enjoy this article, I have published a book explaining the
  internals of Git through implementation: <a href="https://shop.jcoglan.com/building-git/">Building Git</a>.</p>

<p>—</p>

<p>As a programmer, you probably use a version control system such as <a href="https://git-scm.com/">Git</a>, and
spend an awful lot of your time looking at diffs. You use them to check over
your uncommitted work in progress, to look at what changed in a single commit,
to compare two branches before performing a merge, and so on. Diffs are the
language through which you understand how things have changed in your software.</p>

<p>But as well as being read by people, diffs are used by your version control
system to automate changes. You can email a diff to someone and they can use the
<code>patch</code> or <code>git apply</code> commands to merge it into their working copy. <code>git merge</code>
has to reconcile and merge two or more change histories to produce a single
tree, often reconciling changes within the same file. <code>git add --patch</code> lets you
select individual changes from a working copy file rather than adding the whole
file to the index, and that involves both you the user reading the diffs, and
git selectively applying them to the indexed version of a file. And some version
control systems use the differences between versions as their primary way to
store the project history, rather than storing a snapshot of all the code for
each commit.</p>

<p>So diffs are central to version control, but you might not have thought much
about how they’re generated. Often when you read a diff, it seems obvious to you
which things should be marked as changes. You have an intuitive mental model of
what it means to insert a new function into a file, or to delete a redundant
one, or to rewrite a section. However, there’s an awful lot more to diffing than
meets the eye, and there are many ways to do it that produce different results.</p>

<p>Think for a moment about how you’d calculate a diff, and how you’d write a
function to do it. You might have noticed that diff programs only show you what
has changed, not what has stayed the same. How would you determine which parts
of a file have not changed? Once you’ve found a difference between them, how
would you find the next line in each version where the text matches up again?
It’s more complicated than it looks!</p>

<p>In this series of articles, I’d like to walk you through the default diff
algorithm used by Git. It was developed by Eugene W. Myers, and the <a href="http://www.xmailserver.org/diff2.pdf">original
paper</a> is available online. While the paper is quite short, it is quite
mathematically dense and is focussed on proving that it works. The explanations
here will be less rigorous, but will hopefully be more intuitive, giving a
detailed walk-through of what the algorithm actually does and how it works.</p>

<p>In this first article, we’ll lay out the basic model of what the algorithm is
trying to achieve and go through an example of how it works out the simplest set
of edits to get from one version to another.</p>

<p>To use the example from the paper, say we want to calculate the difference
between two strings:</p>

<ul>
  <li><i>a</i> = <code>ABCABBA</code></li>
  <li><i>b</i> = <code>CBABAC</code></li>
</ul>

<p>By “difference”, we mean a sequence of edits that will convert string <i>a</i>
into string <i>b</i>. One possible such sequence is to simply delete each
character in <i>a</i>, and then insert each character in <i>b</i>, or to use
common diff notation:</p>

<div><div><pre><code><span>- A
- B
- C
- A
- B
- B
- A
</span><span>+ C
+ B
+ A
+ B
+ A
+ C
</span></code></pre></div></div>

<p>However, we wouldn’t consider this a good-quality diff since it doesn’t tell us
very much. Changes to source code typically leave much of a file unmodified and
we really want to see <em>sections</em> of code that were inserted or deleted. A diff
that shows the entire file being removed and replaced with the new version isn’t
much use to us.</p>

<p>A better diff of these two strings would be:</p>

<div><div><pre><code><span>- A
- B
</span>  C
<span>+ B
</span>  A
  B
<span>- B
</span>  A
<span>+ C
</span></code></pre></div></div>

<p>This makes the smallest possible number of changes to <i>a</i> in order to
produce <i>b</i>, so it’s a better visualisation of what really changed. It’s
not the only possible solution, for example these are also valid:</p>

<div><div><pre><code>1.  - A       2.  - A       3.  + C
    - B           + C           - A
      C             B             B
    - A           - C           - C
      B             A             A
    + A             B             B
      B           - B           - B
      A             A             A
    + C           + C           + C
</code></pre></div></div>

<p>However, they are all <em>minimal</em>: they make the smallest number of edits
possible, which in this case is five. What’s interesting about them is they
differ in which sections they consider to be the same between the strings, and
which order they perform edits in. From looking at diffs, you probably have an
intuitive idea that diffs only show the things that changed, but these examples
show that there are many possible interpretations of the difference between two
files.</p>

<p>So, the purpose of diff algorithms is to provide a strategy for generating
diffs, where the diffs have certain desirable properties. We usually want diffs
to be as small as possible, but there are other considerations. For example,
when you change something, you’re probably used to seeing deletions followed by
insertions, not the other way round. That is, you’d rather see solution 2 than
solution 3 above. And, when you change a whole block of code, you’d like to see
the whole chunk being deleted followed by the new code being inserted, rather
than many deletions and insertions interleaved with each other.</p>

<div><div><pre><code>Good:   - one         Bad:    - one
        - two                 + four
        - three               - two
        + four                + five
        + five                + six
        + six                 - three
</code></pre></div></div>

<p>You also probably want to see deleted or inserted code that aligns with your idea
of the code’s structure, for example if you insert a method, you’d like that
method’s <code>end</code> to be considered new, rather than the <code>end</code> of the preceding
method:</p>

<div><div><pre><code>Good:   class Foo                   Bad:    class Foo
          def initialize(name)                def initialize(name)
            @name = name                        @name = name
          end                             +   end
      +                                   +
      +   def inspect                     +   def inspect
      +     @name                         +     @name
      +   end                                 end
        end                                 end
</code></pre></div></div>

<p>Myers’ algorithm is just one such strategy, but it’s fast and it produces diffs
that tend to be of good quality most of the time. It does this by being
<em>greedy</em>, that is trying to consume as many lines that are the same before
making a change (therefore avoiding the “wrong <code>end</code>” problem), and also by
preferring deletions over insertions when given a choice, so that deletions
appear first.</p>

<p>The Myers paper is based on the idea that finding the <em>shortest edit script</em>
(SES) can be modelled as a graph search. Let’s take our two strings, <i>a</i> =
<code>ABCABBA</code> and <i>b</i> = <code>CBABAC</code>, and build a graph of all the ways we can get
from <i>a</i> to <i>b</i>.</p>

<p>The (<i>x</i>, <i>y</i>) co-ordinates in the grid shown below correspond to
steps in the editing process; at (0,0) we have string <i>a</i>, that is, we have
not started editing. Moving rightward (increasing <i>x</i>) corresponds to
deleting a character from <i>a</i>, for example moving to (1,0) means we’ve
deleted the first <code>A</code> from <i>a</i>. Moving downward (increasing <i>y</i>)
corresponds to inserting a character from <i>b</i>, for example if we now move
from (1,0) down to (1,1), we insert the first <code>C</code> from <i>b</i>, and our edited
string is thus <code>CBCABBA</code>. At position (4,3), we have converted <code>ABCA</code> into
<code>CBA</code>, but we still need to convert <code>BBA</code> into <code>BAC</code>.  The bottom-right position
(7,6) corresponds to converting string <i>a</i> fully into string <i>b</i>.</p>

<p>As well as moving rightward and downward, in some positions we can also move
diagonally. This occurs when the two strings have the same character at the
position’s indexes, for example the third character in <i>a</i> and the first
character in <i>b</i> are both <code>C</code>, and so position (2,0) has a diagonal leading
to (3,1). This corresponds to consuming an equal character from both strings,
neither deleting nor inserting anything.</p>

<div><div><pre><code>       A     B     C     A     B     B     A

    o-----o-----o-----o-----o-----o-----o-----o   0
    |     |     | \   |     |     |     |     |
C   |     |     |  \  |     |     |     |     |
    |     |     |   \ |     |     |     |     |
    o-----o-----o-----o-----o-----o-----o-----o   1
    |     | \   |     |     | \   | \   |     |
B   |     |  \  |     |     |  \  |  \  |     |
    |     |   \ |     |     |   \ |   \ |     |
    o-----o-----o-----o-----o-----o-----o-----o   2
    | \   |     |     | \   |     |     | \   |
A   |  \  |     |     |  \  |     |     |  \  |
    |   \ |     |     |   \ |     |     |   \ |
    o-----o-----o-----o-----o-----o-----o-----o   3
    |     | \   |     |     | \   | \   |     |
B   |     |  \  |     |     |  \  |  \  |     |
    |     |   \ |     |     |   \ |   \ |     |
    o-----o-----o-----o-----o-----o-----o-----o   4
    | \   |     |     | \   |     |     | \   |
A   |  \  |     |     |  \  |     |     |  \  |
    |   \ |     |     |   \ |     |     |   \ |
    o-----o-----o-----o-----o-----o-----o-----o   5
    |     |     | \   |     |     |     |     |
C   |     |     |  \  |     |     |     |     |
    |     |     |   \ |     |     |     |     |
    o-----o-----o-----o-----o-----o-----o-----o   6

    0     1     2     3     4     5     6     7
</code></pre></div></div>

<p>The idea behind the Myers algorithm is quite simple: we want to get from (0,0)
to (7,6) (the bottom-right) in as few moves as possible. A “move” is a single
step rightward (a deletion from <i>a</i>) or downward (an insertion from
<i>b</i>). The most number of moves we could take to get from <i>a</i> to
<i>b</i> is 13: the combined length of the two strings.</p>

<p>However, walking diagonal paths is free since they don’t correspond to making
<em>changes</em>, thus we want to maximise the number of diagonal steps we take and
minimise the number of rightward/downward moves. The examples above show that we
can actually get from <i>a</i> to <i>b</i> making only five edits, and Myers
provides a strategy for finding that pathway.</p>

<p>To develop an intuition for how the algorithm works, let’s start exploring the
graph. To try to find the shortest path to the bottom-right position, we’ll
explore every possible path from (0,0) in tandem until we find a path that
reaches the end. I recommend keeping the above grid handy while you follow this.</p>

<p>Let’s start by recording our initial position at (0,0).</p>



<p>We have two options from this position: we can move downward and reach (0,1) or
move rightward and reach (1,0).</p>



<p>Now let’s consider (0,1). If we move downward from here we reach (0,2), but
there is a diagonal from there to (1,3), and from (1,3) to (2,4), and since
diagonal moves are free we can say that moving downward from (0,1) gets
us to (2,4) at the cost of only one move. Therefore we’ll mark the move from
(0,1) to (2,4) as a single step in our walk.</p>

<p>Moving rightward from (0,1) takes us to (1,1) and again there is a diagonal from
there to (2,2). Let’s mark both these moves on our walk.</p>

<div><div><pre><code>0,0 --- 1,0
 |
 |
0,1 --- 2,2
 |
 |
2,4
</code></pre></div></div>

<p>Now let’s consider the other branch we took from (0,0), moving rightward to
(1,0). Moving downward from (1,0) takes us to (1,1), which as we just found out
gets us to (2,2). Moving rightward from (1,0) takes us to (2,0), which has a
diagonal to (3,1). Again, we’ll record both these steps.</p>

<p>I’m recording (2,2) as being visited via (1,0) rather than (0,1) for reasons
that will become clear a little later. For intuition, consider that making a
rightward move first means performing a deletion first, and we generally want
deletions to appear before insertions.</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2
 |
 |
2,4
</code></pre></div></div>

<p>We’ve now fully explored the graph to two moves deep and we can begin on our
third move. Moving downward from (2,4) gets us to (2,5), and from there is a
diagonal to (3,6). Moving rightward from (2,4) takes us to (3,4), where again a
diagonal takes us to (4,5).</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2
 |
 |
2,4 --- 4,5
 |
 |
3,6
</code></pre></div></div>

<p>Next, we consider (2,2). Moving rightward from there is as we’ve seen before: we
move to (3,2), and follow the diagonals from there to (5,4).  Moving downward
introduces a new situation, however: this move gets us to (2,3) and there is no
diagonal from there. Now, if we were doing a general-purpose graph search, we’d
want to record both the result of moving rightward from (2,4) and the result of
moving downward from (2,2), that is:</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2 --- 5,4
 |        \
 |         \
2,4 -       2,3
 |   \
 |    4,5
3,6
</code></pre></div></div>

<p>However, the structure of the particular graphs we’re examining means that it’s
sufficient to just store the <em>best</em> position you can reach after a certain set
of edits. The above record shows us that making two insertions then a deletion
(down twice, and then right) gets us to (4,5), whereas making the deletion
first, and then the two insertions, gets us to (2,3). So, we’ll just keep the
(4,5) result and throw the (2,3) away, indicating (4,5) is the best position
reachable after one deletion and two insertions <em>in any order</em>.</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2 --- 5,4
 |
 |
2,4 --- 4,5
 |
 |
3,6
</code></pre></div></div>

<p>Finally in our depth-2 scan, we visit (3,1). Moving downward from there goes to
(3,2), which leads diagonally to (5,4), and so we’ll again record this as a move
downward from (3,1) rather than rightward from (2,2). Moving rightward from
(3,1) gives (4,1), which has a diagonal to (5,2).</p>

<p>Here’s the completed record after three moves:</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1 --- 5,2
 |       |       |
 |       |       |
0,1     2,2     5,4
 |
 |
2,4 --- 4,5
 |
 |
3,6
</code></pre></div></div>

<p>You’re probably getting the hang of this by now so let’s rattle through the
remaining moves. We can’t move downward from (3,6), and moving rightward from
there gives (4,6), which is also reachable downward from (4,5), so we’ll mark it
as such. Rightward of (4,5) is (5,5).</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1 --- 5,2
 |       |       |
 |       |       |
0,1     2,2     5,4
 |
 |
2,4 --- 4,5 --- 5,5
 |       |
 |       |
3,6     4,6
</code></pre></div></div>

<p>(5,5) is also downward of (5,4) so we’ll mark that, and moving rightward from
(5,4) gives (6,4), with a diagonal leading to (7,5).</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1 --- 5,2
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |
 |               |
2,4 --- 4,5     5,5
 |       |
 |       |
3,6     4,6
</code></pre></div></div>

<p>Downward from (5,2) also leads to (7,5), and moving rightward from (5,2) leads
to (7,3), thus completing the fourth row of the scan.</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1 --- 5,2 --- 7,3
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |
 |               |
2,4 --- 4,5     5,5
 |       |
 |       |
3,6     4,6
</code></pre></div></div>

<p>Now we begin the fifth row. Since we know there are diffs from <i>a</i> to
<i>b</i> requiring only five edits, we expect this row of the scan to find the
bottom-right position, (7,6).</p>

<p>There is nothing downward from (4,6), and rightward of that is (5,6), which is
also downward from (5,5). Rightward of (5,5) is (6,5).</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1 --- 5,2 --- 7,3
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |
 |               |
2,4 --- 4,5     5,5 --- 6,5
 |       |       |
 |       |       |
3,6     4,6     5,6
</code></pre></div></div>

<p>Finally, moving downward from (7,5) gives (7,6) – the final position! This is
certainly better than (6,5), which we reached by going right, right, down, down,
right, and so we replace it in our trace of the moves.</p>

<div><div><pre><code>0,0 --- 1,0 --- 3,1 --- 5,2 --- 7,3
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |       |
 |               |       |
2,4 --- 4,5     5,5     7,6
 |       |       |
 |       |       |
3,6     4,6     5,6
</code></pre></div></div>

<p>So that’s the basic idea the algorithm is based on: given two strings, find the
shortest path through a graph that represents the edit space between the two. We
explore every possible route through the graph breadth-first, and stop as soon
as we reach the final position.</p>

<p>In the next article, we’ll look at how Myers actually represents this process,
and start to look at implementing it in code.</p>


  </div></div>
  </body>
</html>
