<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openfolder.sh/heroku-anti-dx">Original</a>
    <h1>Heroku has been running a second copy of my scheduler instance</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p>
Obligatory <a href="#tldr">TL;DR</a> with spoilers at the end of the post.
</p>
</div>
<h2 id="background">Background</h2>
<p><a href="https://www.musicbutler.io/">MusicButler</a> is the first web-app I ever built. It notifies its users about new music by artists found in their libraries. It‚Äôs also how I learned a lot of what I know about programming and most of what I know about web-development. I believe it played a huge part in how I got to make a career shift to a software developer in my 30s.</p>
<p>Before the dawn of Dockerized apps, one way a layman like me would get an app to production was using Heroku‚Äôs Procfiles. MusicButler went live in August 2018. Today it‚Äôs a nice side-project that I‚Äôm proud to stand behind.</p>
<p>The app bakcend is built on Django and relies heavily on the <a href="https://docs.celeryq.dev/en/stable/">Celery library</a> for carrying out millions of background and scheduled tasks each day. In fact, all Heroku dynos except for the <code>web</code> one are Celery dynos:<a href="#footnote-1YB3" id="ref-1YB3" role="doc-noteref"><sup>1</sup></a></p>
<pre><code>web: daphne musicbutler.asgi:application --port $PORT --bind 0.0.0.0
celerybeat: celery -A musicbutler beat
celerybackgroundworker1: celery -A musicbutler worker -Q regular
celerybackgroundworker2: celery -A musicbutler worker -Q regular
celeryimportantworker: celery -A musicbutler worker -Q important</code></pre>
<p>The dyno of interest here is <code>celerybeat</code>: the Celery<span></span> <span>‚Äú</span>scheduler‚Äù responsible for assigning scheduled tasks to other Celery workers.</p>
<h2 id="april-8-first-duplicate-email-received">April 8: first duplicate email received</h2>
<p>One of the oldest pieces of code in MusicButler is the one that sends out music-drop emails to thousands of users each day, once a day.</p>
<p>I was surprised when I saw that my test user had received two emails titled<span></span> <span>‚Äú</span>New Music for April 8, 2023‚Äù at the same time. The emails were identical. This had never happened before.</p>
<p>Upon checking my email delivery provider dashboard, I confirmed that MusicButler had sent twice its average volume of emails that day. Heroku‚Äôs logs showed that <code>celerybeat</code> had dispatched the scheduled task twice:</p>
<pre><code>celerybeat.1 [2023-04-08 21:35:00,000: INFO/MainProcess] Scheduler: Sending due task send_music_drops (send_music_drops)
celerybeat.1 [2023-04-08 21:35:00,014: INFO/MainProcess] Scheduler: Sending due task send_music_drops (send_music_drops)</code></pre>
<p>Ok. This isn‚Äôt the email provider‚Äôs fault. It‚Äôs mine, or Celery‚Äôs. Probably the former.</p>
<p>I was busy that night so I utilized a Celery companion library called <a href="https://github.com/cameronmaske/celery-once">Celery Once</a> which ensures only one instance of a task can run concurrently.</p>
<h2 id="april-12-first-user-complaint">April 12: First user complaint</h2>
<p>Over the next few days some personal matters came up that steered my attention away. It was not until a long-time user complained about receiving duplicate emails that I realized the issue was still persisting. Apparently Celery Once doesn‚Äôt handle locking for scheduled tasks.</p>
<p>The music drops is one the core features of the app, so I needed to fix it quickly. I had approximately 24 hours until the next batch of emails was due to be sent out.</p>
<p>I could implement the use of a distributed lock myself, or make the email-sending task truly idempotent, but I wanted understand why something was broken in the first place. This code has been running flawlessly <em>for years</em>.</p>
<h2 id="unfortunate-coincidence">Unfortunate coincidence</h2>
<p>Nothing stood out when I ran the service locally. A quick scan of the code didn‚Äôt bring up any suspects either.</p>
<p>I inspected Heroku‚Äôs logs again and saw that it wasn‚Äôt just this specific task that was being dispatched twice, <em>all of them were</em>:</p>
<pre><code>celerybeat.1 [2023-04-12 18:22:00,000: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)
celerybeat.1 [2023-04-12 18:22:00,015: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)</code></pre>
<p>Luckily most of these tasks are truly idempotent so little damage was done there.</p>
<p>Here‚Äôs where a mix of Impostor Syndrome and mandated developer humility sent me looking in the wrong directions.</p>
<p>In the weeks before, I‚Äôve written some new code that was also supposed to be scheduled by <code>celerybeat</code>. Did I muck up something there? since this is Python, you can screw yourself in the foot in a variety of ways. Maybe I‚Äôve imported the scheduler configuration code twice, maybe I inadvertedly put some code in an <code>__init__</code> file, like <a href="https://stackoverflow.com/a/41582354/5013234">this Stack Overflow answer</a> I came across suggests.</p>
<p>I start to delete the new code. At first gradually, and then frantically. With each deployment that failed to mitigate the issue, I was running out of time and nerves.</p>
<h2 id="its-celerys-fault"><span>‚Äú</span>It‚Äôs Celery‚Äôs fault‚Äù</h2>
<p>Using Heroku‚Äôs log drains again, I managed to pinpoint the exact time the issue first manifested. The <code>celerybeat</code> dyno started sending the same tasks twice on April 6, 2023 at 22:16:00 <span>UTC</span>:</p>
<pre><code># once every two minutes
celerybeat.1 [2023-04-06 22:10:00,003: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)
celerybeat.1 [2023-04-06 22:12:00,001: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)
celerybeat.1 [2023-04-06 22:14:00,001: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)
# twice every two minutes
celerybeat.1 [2023-04-06 22:16:00,000: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)
celerybeat.1 [2023-04-06 22:16:00,015: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)</code></pre>
<p>22:16:00 is the exact time a new build of the app was deployed. This was a revelation, but not a very useful one by the time I discovered it: I had already commented out all new code that could <em>remotely</em> be connected to the<span></span> <span>‚Äú</span>bug‚Äù.</p>
<p>So is it Celery then? This awesome library has its fair share of complaints about duplicated task execution ‚Äî most are due to misconfiguration. I scanned dozens of Stack Overflow threads and GitHub issues in Celery‚Äôs repository. Very few were relevant to my case, and none of the fixes were.</p>
<h2 id="april-13-you-didnt-just-do-that-heroku">April 13: You didn‚Äôt just do that, Heroku</h2>
<p>The last thread I read and the one that would lead me to the shocking discovery included a brute-force suggestion: delete Celery‚Äôs <code>celerybeat-schedule</code> file, where <code>celerybeat</code> keeps its schedule.</p>
<p>There‚Äôs no reason this would happen on a Serverless platform like Heroku, I thought to myself. But, at this point nothing makes sense anymore, I also thought to myself.</p>
<p>I decided to do something different just before; I renamed the dyno <code>celerybeat</code> to <code>celerybeatnew</code> in the Procfile and deployed:</p>
<pre><code>web: daphne musicbutler.asgi:application --port $PORT --bind 0.0.0.0
celerybeatnew: celery -A musicbutler beat
celerybackgroundworker1: celery -A musicbutler worker -Q regular
celerybackgroundworker2: celery -A musicbutler worker -Q regular
celeryimportantworker: celery -A musicbutler worker -Q important</code></pre>
<p>After the deployment was over I checked the logs again; now everything became clear:</p>
<pre><code>üëá
celerybeatnew.1 [2023-04-13 19:42:00,000: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)
üëá
celerybeat.1 [2023-04-13 19:42:00,015: INFO/MainProcess] Scheduler: Sending due task refresh_user_library (refresh_user_library)</code></pre>
<p>See, at this point the <code>celerybeat</code> dyno shouldn‚Äôt even exist. It was nowhere to be found on my list of dynos. But here it is, alive, well, and scheduling tasks.</p>
<p>So what happened on that April 6 deployment is that Heroku either spun up two <code>celerybeat</code> dynos instead of one, or just never killed the old one. It‚Äôs not that <code>celerybeat</code> was misbehaving, it‚Äôs just that there were now two of them. It was virtually impossible to get to this conclustion until I changed the dyno‚Äôs name in the Procfile.</p>
<h2 id="herokus-support-lives-up-to-its-name">Heroku‚Äôs support lives up to its name</h2>
<p>I actually know what happened, but not thanks to Heroku‚Äôs support. I contacted them on April 13 and as of April 17, their only response is<span></span> <span>‚Äú</span>we‚Äôre looking into this‚Äù. I haven‚Äôt heard from them since, and the old <code>celerybeat</code> dyno is still up with nothing I can do to stop it.<a href="#footnote-2YB3" id="ref-2YB3" role="doc-noteref"><sup>2</sup></a></p>
<p>In hindsight, it was a good decision to not simply rewrite the task‚Äôs code to utilize locks. That would have prevented <em>new instances</em> of the app from executing tasks twice, but Heroku is running an old, zombie dyno with outdated code. I know this because I removed some tasks from <code>celerybeatnew</code> and witnessed how they‚Äôre still running, courtesy of Heroku‚Äôs on-the-house worker. If Heroku was simply spinning up a <em>new</em> extra dyno with each deployment, these tasks should‚Äôve stopped executing enitrely.</p>
<h2 id="writing-on-the-wall">Writing on the wall</h2>
<p>I‚Äôve been reading on Heroku‚Äôs slow demise on developer communities for years now. Just weeks earlier, I‚Äôd read a <a href="https://twitter.com/dannypostmaa/status/1624689089332281344?lang=en">horror story on Twitter</a> about Heroku just flat-out deleting someone‚Äôs account, including production apps.</p>
<p>And still. I don‚Äôt know what I could‚Äôve done differently here: when I list an internet-taught software developer, a talented <span>OSS</span> team, and a multi-gazillion dollar corporation, my instinct is to look into them in this same order.</p>
<h2 id="next-steps">Next steps</h2>
<h3 id="truly-idempotent-tasks">Truly idempotent tasks</h3>
<p>This could have happened on any platform, and for other reasons. If a task should never ever be executed twice, or concurrently, it shouldn‚Äôt count on a scheduler to prevent that. In fact, I‚Äôve followed Celery‚Äôs <a href="https://docs.celeryq.dev/en/stable/tutorials/task-cookbook.html#ensuring-a-task-is-only-executed-one-at-a-time">own guide</a> on ensuring a task is only executed one at a time. It‚Äôs just that I didn‚Äôt retroactively apply that to a 4 year-old piece of code.</p>
<h3 id="no-more-vendor-lock">No more vendor lock</h3>
<p>In 2018 Heroku was pretty much the only option for a newbie like me to get started with web-development. The landscape is very different now with providers like <a href="https://render.com/">Render</a>, <a href="https://railway.app/">Railway</a>, and more offering a simillar <span>DX</span>.</p>
<p>I‚Äôve just finished deploying a Celery worker on Railway. The exprience was <span>OK</span>. It would cost a bit more than what I currently pay for a Heroku dyno. Railway ivented their own special deployment-file format: <a href="https://nixpacks.com/docs">Nixpacks</a>, and Render utilizes <code>render.yaml</code> files. I won‚Äôt be making the same mistake again though and will Dockerize MusicButler so I can move between vendors less painfully.</p>
<p>When you‚Äôre a solo-developer doing something on the side you need to prioritize your time ruthlessly. I‚Äôve always prioritized new features and user feedback over infra work. Looks like it‚Äôs time to start paying attention to the latter.</p>
<h2 id="tldr">TL;DR</h2>
<ul>
<li>Heroku has been running a 2nd copy of my scheduler instance since April 6, 2023 and I have zero control over it.</li>
<li>All scheduled tasks were carried out twice, causing disturbance to users and unnecessary high load.</li>
<li>Given how Heroku works and how they present their logs, I had no way to detect this early on, or reason to suspect that‚Äôs what happened.</li>
<li>I discovered the root cause April 13 and contacted Heroku. The zombie instance is still running as of April 17 at 18:45 <span>UTC</span>.</li>
</ul>
</div></div>
  </body>
</html>
