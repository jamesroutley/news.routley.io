<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.garyrobinson.net/2014/10/git-in-two-minutes-for-a-solo-developer.html">Original</a>
    <h1>Git In Two Minutes (updated after 8 years)</h1>
    
    <div id="readability-page-1" class="page"><div id="entry-6a00d8341da47953ef01bb079cebe2970d">
   <div>
			
	



	<div>
		<div>
			<p>Inspired by “<a href="http://classic.scottr.org/presentations/git-in-5-minutes/">Git in 5 Minutes</a>”, I decided to take things a step further, and create guide for git that takes even less time to get through. Of course, this is very minimalistic git! But it’s enough be useful for beginning solo developers, and provides a start from which you can grow. As far as I know, this post is the absolute record for minimalistic git guides on the web!  </p>
<p>In two minutes, there isn’t time to worry about a remote server, so this manner of using git is only appropriate for a solo developer who has a regular backup strategy in place for their hard drive. With 2-minute git, plus a backup strategy, you can confidently commit files and know that you can see changes or restore an earlier version if you need to.</p>
<p>Why does this even matter? Well, one of the most annoying and time-consuming experiences a developer can have is to realize that something that used to work no longer does. In such situations, simply being able to see changes and go back to an earlier version can be a huge help. Also, being able to go back gives you freedom to experiment with a new approach — there’s no problem experimenting because you can always go back.</p>
<p>When you have a chance, you should definitely learn about such features as staging and branching, and pushing and pulling to/from remote repositories. But what you’ll learn here will still be useful!</p>
<p>Note: When a filename is mentioned below, you can just as easily use a file path.</p>

<h2>Getting set up to use git</h2>
<p>We’re assuming you’re working in a directory. The first thing you should do is:</p>
<pre>  git init</pre>
<p>which initializes the directory for git use.</p>

<h2>Telling git about your files</h2>
<p>Now you have to tell git which files it should care about. If you have N files, you can do </p>
<pre>  git add &lt;file1&gt;  &lt;file2&gt; … &lt;fileN&gt;</pre>
<p>to add them. Or if you want to add every file in the directory, you can do</p>
<pre>  git add .</pre>
<pre> </pre>
<h2>Committing changes</h2>
<p>Next, we need to commit changes. Any time you want to commit changes to one or more files, do</p>
<pre>  git commit &lt;file1&gt; &lt;file2&gt; … &lt;fileN&gt; -m &#34;This is your commit message&#34;</pre>
<p>Or, to commit all files that have changed since the last commit:</p>
<pre>  git commit -a -m &#34;This is your commit message for all changed files&#34;</pre>
<p>Be sure to make your commit message contain enough of a description that you can figure out what version you want to go back to.</p>

<h2>Viewing history</h2>
<p>Now we need a way to see old versions are available. To see your commit messages along with each version’s “hash” (a number that refers to the version), you can use the following command to show them in a one-version-per-line output. </p>
<pre>  git log --pretty=oneline</pre>
<p>That will give you output that looks like the following, showing each commit’s hash together with its commit message</p>
<pre>  dbe28a0a1eba45d823d309cc3659069fc16297e3 4th version I wanted to commit
  13bbf385e6d1f94c7f11a4cdfa2a7688dfdd84f8 3rd
  a1696f671fb90dc8ea34645a6f851d0ab0152fc2 2nd version
  179e59467039c7a7b81f676297415c8e018542a0 first version</pre>
<p>Note, you can also use</p>
<pre>  git log</pre>
<p>for a much more verbose output, with multiple lines per version, and you can use</p>
<pre>  git log --pretty=oneline -- &lt;filename&gt;</pre>
<p> to view only the changes for a particular file. (Note the space after the second pair of dashes!)</p>

<h2>Restoring an old version</h2>
<p>To restore a file to an earlier version, you need to identify the version you want to restore. To restore the most recently committed version, just do:</p>
<pre>  git checkout HEAD -- &lt;filename&gt;</pre>
<p>To get back an earlier version, just use the first few characters of the hash (enough to uniquely distinguish it):</p>
<pre>  git checkout &lt;hash&gt; -- &lt;filename&gt;</pre>
<p>For example,</p>
<pre>  git checkout 179e59467039 -- myfile</pre>
<p>will revert my file to the contents of the file called myfile that are associated with the 179e59467039c7a7b81f676297415c8e018542a0 hash (in this case, the first committed version of the file).</p>

<h2>Seeing changes</h2>
<p>You usually won’t want to retrieve an old version of a file without first examining the changes it contains! To see a list of the changes between the current file and the most recently committed one, you use the fact that HEAD represents the most recent commit:</p>
<pre>  git diff HEAD -- &lt;filename&gt;</pre>
<p>Alternatively, see a list of differences between the current version of a file and a historical one, you refer to the historical version’s hash:</p>
<pre>  git diff &lt;hash&gt; -- &lt;filename&gt;</pre>
<p>You can also compare two historical versions:</p>
<pre>  git diff &lt;hash1&gt;  &lt;hash2&gt; -- &lt;filename&gt;</pre>
<p>Finally, to see a list of the changes you’ve made since your last commit across all files, simply do:</p>
<pre>  git diff </pre>
<p>Note: all the diff variants shown above put the results into a pager. You can page through using the space bar, and quit with q. If you don’t want to use the pager, add -P, like:</p>
<pre>  git -P diff HEAD -- &lt;filename&gt;</pre>

<h2>Undoing a bad commit</h2><p>
More often than I care to admit, I&#39;ve committed a change and then found that there was an error in either the commit message or in the code itself. I don&#39;t see any need to keep that error for posterity. So here&#39;s how to undo it:
</p><pre>  git reset HEAD^ </pre>

<h2>One more thing – optional – may add another minute</h2>
<p>While you can get a lot of benefit using just the features above, here&#39;s one more thing you&#39;ll find to be useful. If you don&#39;t want to bother with it now, don&#39;t – try it another time.</p>
<p>Sometimes, you&#39;re not sure what files have changed. To find out, you can do:</p>
<pre>  git status </pre>
<p>That&#39;ll generate a list of files and their statuses. For example, a file that hasn&#39;t been &#34;git add&#34;-ed will be listed as untracked; if it&#39;s a file you care about, you should add it.</p>
<p>The reason I consider this command &#34;optional&#34; in a two-minute guide is that it can be a little unwieldy. It can list a lot of files you don&#39;t care about. For instance, if you&#39;re programming in Python, it&#39;ll show the compiled .pyc files that Python generates. And you&#39;ll probably want to do something about that.</p>
<p>To fix it, you need to create a file called .gitignore in your project directory. For instance, if you&#39;re working on a project in Python 2.x, you&#39;ll probably want it to contain (at least):</p>
<pre>  .pyc</pre>
<p>Notice that .gitignore understands the * wildcard. And if you want to hide an entire directory, you append the folder name with a slash. For instance you&#39;re working in Python 3.x, the compiled files go in a directory called __pycache__, so you&#39;ll want the following in your .gitignore:</p>
<pre>  __pycache__/ </pre>

<h2>And that’s it! Just keep this guide handy.</h2>
<p>That’s all you need to know to get started with git, as long as you have a regular backup strategy for your hard drive. If you don’t want to memorize anything, just keep this guide bookmarked and you’ll be able to commit, compare versions, and get back old versions without any trouble!</p>
<p>Remember, this guide is literally as minimalistic as you can possibly get in order to do something useful with git. For powerful features like branching, staging, and sharing with others via a remote server, be sure to move on to <a href="http://classic.scottr.org/presentations/git-in-5-minutes/">Git In Five Minutes</a> and even (?!) longer git guides when you have a chance!</p>

<p>[Update Aug 6, 2022: added the entry for undoing a commit.</p>
<p>Update Jan 2, 2017: added the use of HEAD in restoring file versions.</p>
<p>Update September 7, 2015: added two more ways of seeing changes.</p>
<p>Update September 20, 2015: for some reason the optional section on git status and .gitignore disappeared at some point. So I put it back! Also rewrote the diff section to put the HEAD version first.]</p>
		</div>
		

                        <!-- SIGNATURE -->
                        

		
	</div>

	
   </div>
</div></div>
  </body>
</html>
