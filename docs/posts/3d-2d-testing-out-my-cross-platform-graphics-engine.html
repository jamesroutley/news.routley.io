<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=39907845">Original</a>
    <h1>3D &#43; 2D: Testing out my cross-platform graphics engine</h1>
    
    <div id="readability-page-1" class="page"><div><td colspan="2"></td><td><div><p>I used to work at Adobe on the infrastructure powering big applications like Photoshop and  Acrobat. One of our worst headaches was making these really powerful codebases work on desktop, web, mobile, and the cloud without having to completely rewrite them.  For example, to get Lightroom and Photoshop working on the web we took a winding path through JavaScript, Google’s PNaCl, asm.js, and finally WebAssembly, all while having to rethink our GPU architecture around these devices. We even had to get single-threaded builds working and rebuild the UI around Web Components. Today the web builds work great, but it was a decade-long journey to get there!</p><p>The graphics stack continues to be one of the biggest bottlenecks in portability. One day I realized that WebAssembly (Wasm) actually held the solution to the madness. It’s runnable anywhere, embeddable into anything, and performant enough for real-time graphics. So I quit my job and dove into the adventure of creating a portable, embeddable WASM-based graphics framework from the ground up: high-level enough for app developers to easily make whatever graphics they want, and low-level enough to take full advantage of the GPU and everything else needed for a high-performance application.</p><p>I call it Renderlet to emphasize the embeddable aspect — you can make self-contained graphics modules that do just what you want, connect them together, and make them run <i>on</i> anything or <i>in</i> anything with trivial interop.</p><p>If you think of how Unity made it easy for devs to build cross-platform games, the idea is to do the same thing for all visual applications.</p><p>Somewhere along the way I got into YC as a solo founder (!) but mostly I’ve been heads-down building this thing for the last 6 months. It’s not <i>quite</i> ready for an open alpha release, but it’s close—close enough that I’m ready to write about it, show it off, and start getting feedback. This is the thing I dreamed of as an application developer, and I want to know what you think!</p><p>When Rive open-sourced their 2D vector engine and made a splash on HN a couple weeks ago (<a href="https://news.ycombinator.com/item?id=39766893">https://news.ycombinator.com/item?id=39766893</a>), I was intrigued. Rive’s renderer is built as a higher-level 2D API similar to SVG, whereas the Wander renderer (the open-source runtime part of Renderlet) exposes a lower-level 3D API over the GPU. Could Renderlet use its GPU backend to run the Rive Renderer library, enabling any 3D app to have a 2D vector backend? Yes it can - I implemented it!</p><p>You can see it working here: <a href="https://vimeo.com/929416955" rel="nofollow">https://vimeo.com/929416955</a> and there’s a deep technical dive here: <a href="https://github.com/renderlet/wander/wiki/Using-renderlet-with-rive%E2%80%90renderer">https://github.com/renderlet/wander/wiki/Using-renderlet-wit...</a>. The code for my runtime Wasm Renderer (a.k.a. Wander) is here: <a href="https://github.com/renderlet/wander">https://github.com/renderlet/wander</a>.</p><p>I’ll come back and do a proper Show HN or Launch HN when the compiler is ready for anyone to use and I have the integration working on all platforms, but I hope this is interesting enough to take a look at now. I want to hear what you think of this!</p></div></td></div></div>
  </body>
</html>
