<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thedav.is/post/rusts-poor-composability/">Original</a>
    <h1>Rust&#39;s Poor Composability</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>
            
    
        
            
    
    Apr 05, 2023

        
        
        
            
            
                Â· 3 min
            
        
        
        </p><nav>
            <ul>
                
                <li>
                    <a href="https://thedav.is/tags/rust/">
                        Rust
                    </a>
                </li>
                
                <li>
                    <a href="https://thedav.is/tags/plt/">
                        PLT
                    </a>
                </li>
                
                <li>
                    <a href="https://thedav.is/tags/engineering/">
                        Engineering
                    </a>
                </li>
                
                <li>
                    <a href="https://thedav.is/tags/pet-peeves/">
                        Pet-Peeves
                    </a>
                </li>
                
            </ul>
        </nav>
        
        <hr/>
    
    
    <p>I love Rust. I wish they would spend more time making it actually work for non hello-world use-cases.</p>
<h2 id="iteration">Iteration</h2>
<p>Rust has a nice pretty syntax for iterating:</p>
<pre data-lang="rs"><code data-lang="rs"><span>for</span><span> x </span><span>in &amp;mut</span><span> something </span><span>{
</span><span>    </span><span>*</span><span>x </span><span>= </span><span>(</span><span>*</span><span>x) </span><span>* </span><span>2</span><span>;
</span><span>}
</span></code></pre>
<p>EXCEPT when you need to do <em>anything else</em> to the iterator, then its ugly:</p>
<pre data-lang="rs"><code data-lang="rs"><span>for </span><span>(i, x) </span><span>in</span><span> something</span><span>.</span><span>iter_mut</span><span>()</span><span>.</span><span>filter</span><span>(|| </span><span>{</span><span>...</span><span>}</span><span>)</span><span>.</span><span>enumerate</span><span>() </span><span>{
</span><span>    </span><span>*</span><span>x </span><span>= </span><span>(</span><span>*</span><span>x) </span><span>*</span><span> i
</span><span>}
</span></code></pre>
<p>What&#39;s the point of having the &#39;pretty&#39; syntax if it only works in the simplest of cases?</p>
<p>I <em>hate</em> syntax that only works in hello world examples. It infuriates me, because it means
that this is all just Oz, and that you eventually need to pull back the curtain
and everything you were promised was a lie.</p>
<h2 id="trying">Trying...</h2>
<p>Rust has a great syntax for early return on <code>Err</code> cases.</p>
<pre data-lang="rs"><code data-lang="rs"><span>let</span><span> thing: </span><span>Result</span><span>&lt;A, B&gt; </span><span>=</span><span> x</span><span>.</span><span>foo</span><span>();
</span><span>// Will return early with the error if x.foo() returns Err.
</span><span>let</span><span> thing: A </span><span>=</span><span> x</span><span>.</span><span>foo</span><span>()</span><span>?</span><span>;
</span></code></pre>
<p>BUT when you try to use it with iterators -- which are also amazing, I love using iterators -- IT DOESNT WORK.</p>
<pre data-lang="rs"><code data-lang="rs"><span>// ? in an Iterator method doesnt work!! What the hell!
</span><span>let</span><span> res: </span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt; </span><span>=</span><span> iterator</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>map</span><span>(|</span><span>x</span><span>| x</span><span>.</span><span>foo</span><span>()</span><span>?</span><span>)</span><span>.</span><span>collect</span><span>();
</span></code></pre>
<p>So instead we need to use the ugly for-loop manual collection</p>
<pre data-lang="rs"><code data-lang="rs"><span>let</span><span> res </span><span>= </span><span>vec![];
</span><span>for</span><span> x </span><span>in &amp;</span><span>iterator </span><span>{
</span><span>    res</span><span>.</span><span>push</span><span>(x</span><span>.</span><span>foo</span><span>()</span><span>?</span><span>);
</span><span>}
</span></code></pre>
<p>In my mind, the <code>for</code> loop syntax should be simple syntactic sugar for <code>iterator.iter().for_each(BODY)</code>, not bespoke syntax. The fact this breaks wrecks my mental model. Whats the point of having two completely different iteration syntaxes with different properties?</p>
<p>But this also happens elsewhere, because of this ugly inflexability, we cant do:</p>
<pre data-lang="rs"><code data-lang="rs"><span>let</span><span> z </span><span>=</span><span> x</span><span>.</span><span>foo</span><span>()</span><span>.</span><span>map</span><span>(|</span><span>y</span><span>| y</span><span>.</span><span>bar</span><span>()</span><span>?</span><span>);
</span></code></pre>
<p>we must do</p>
<pre data-lang="rs"><code data-lang="rs"><span>let</span><span> z </span><span>= if </span><span>let </span><span>Some</span><span>(y) </span><span>=</span><span> x</span><span>.</span><span>foo</span><span>() </span><span>{
</span><span>    y</span><span>.</span><span>bar</span><span>()</span><span>?
</span><span>}
</span></code></pre>
<p>Gross. The Rust designers really should have ran <a href="https://peps.python.org/pep-0020/"><code>import this</code></a>.</p>
<blockquote>
<p>There should be one-- and preferably only one --obvious way to do it.</p>
</blockquote>
<p>Again, the absolute lack of composability is astounding. Whats the point of even having iterator methods if you can&#39;t
use them for <em>real world usecases</em>, where code is regularly fallable, so you need to return a <code>Result</code>.</p>

<p>This is basically the same problem as before, but with <code>.await</code> instead of <code>?</code>.
You <em>must</em> use the <code>for</code> loop syntax if you want to use <code>.await</code>, because iterators are not powerful enough
to support real world use-cases.</p>

<p>I have been a fan of Rust for 10 years now (wow!), and I love it. But the teams working on language design need to
<em>SLOW DOWN</em> and focus on ergonomics and composability. Not adding new syntax because some other language has it.
For years now there has been calls for a &#39;fallow year&#39; for Rust, and I think it should happen. Of course, there are
so many people working on Rust, it is infeasable to task everyone on &#39;<strong><em>ergonomics</em></strong>&#39;,
but I think it should be the focus at least.</p>
<p>Niko has <a href="http://smallcultfollowing.com/babysteps/blog/2023/01/20/rust-in-2023-growing-up/">some ideas</a> but they
still seem so lofty compared to basic ergonomic capabilities.</p>
<p>There is some work on keyword generics that looks horrendous, but maybe would solve this problem. I hope they can work on it.</p>
<p>TODO: reference <code>registers of Rust</code> -- https://without.boats/blog/the-registers-of-rust/
TODO: Find the keyword generics work, link to it.</p>


        </div></div>
  </body>
</html>
