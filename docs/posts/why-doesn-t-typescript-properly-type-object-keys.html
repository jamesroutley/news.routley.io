<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexharri.com/blog/typescript-structural-typing">Original</a>
    <h1>Why doesn&#39;t TypeScript properly type Object.keys?</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><div><main><p>If you&#39;ve written TypeScript for a while, you&#39;ve probably run into this:</p>
<div><div><div><div><pre><p><span>interface</span><span> </span><span>Options</span><span> </span><span>{</span><span></span></p><p><span>  hostName</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span>  port</span><span>:</span><span> </span><span>number</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>function</span><span> </span><span>validateOptions</span><span> </span><span>(</span><span>options</span><span>:</span><span> </span><span>Options</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>options</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>key </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>options</span><span>[</span><span>key</span><span>]</span><span> </span><span>==</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><div><div><div data-type="error"><p><span></span>Expression of type &#39;string&#39; can&#39;t be used to index type &#39;Options&#39;.</p></div></div></div><p><span>      </span><span>throw</span><span> </span><span>new</span><span> </span><span>Error</span><span>(</span><span>`</span><span>Missing option </span><span>${</span><span>key</span><span>}</span><span>`</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>This error seems nonsensical. We&#39;re using the keys of <code>options</code> to access <code>options</code>. Why doesn&#39;t TypeScript just figure this out?</p>
<p>We can somewhat trivially circumvent this by casting <code>Object.keys(options)</code> to <code>(keyof typeof options)[]</code>.</p>
<div><div><div><div><pre><p><span>const</span><span> keys </span><span>=</span><span> </span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>options</span><span>)</span><span> </span><span>as</span><span> </span><span>(</span><span>keyof</span><span> </span><span>typeof</span><span> options</span><span>)</span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>keys</span><span>.</span><span>forEach</span><span>(</span><span>key </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>options</span><span>[</span><span>key</span><span>]</span><span> </span><span>==</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>throw</span><span> </span><span>new</span><span> </span><span>Error</span><span>(</span><span>`</span><span>Missing option </span><span>${</span><span>key</span><span>}</span><span>`</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span>)</span><span>;</span><span></span></p></pre></div></div></div></div>
<p>But why is this a problem in the first place?</p>
<p>If we visit the type definition for <code>Object.keys</code>, we see the following:</p>
<div><div><div><div><pre><p><span></span><span>interface</span><span> </span><span>Object</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>keys</span><span>(</span><span>o</span><span>:</span><span> object</span><span>)</span><span>:</span><span> </span><span>string</span><span>[</span><span>]</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>The type definition is very simple. Accepts <code>object</code> and returns <code>string[]</code>.</p>
<p>Making this method accept a generic parameter of <code>T</code> and return <code>(keyof T)[]</code> is very easy.</p>
<div><div><div><div><pre><p><span>class</span><span> </span><span>Object</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>keys</span><span>&lt;</span><span>T</span><span> </span><span>extends</span><span> object</span><span>&gt;</span><span>(</span><span>o</span><span>:</span><span> </span><span>T</span><span>)</span><span>:</span><span> </span><span>(</span><span>keyof</span><span> </span><span>T</span><span>)</span><span>[</span><span>]</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>If <code>Object.keys</code> were defined like this, we wouldn&#39;t have run into the type error.</p>
<p>It seems like a no brainer to define <code>Object.keys</code> like this, but TypeScript has a good reason for not doing so. The reason has to do with TypeScript&#39;s <a target="_blank" href="https://en.wikipedia.org/wiki/Structural_type_system">structural type system</a>.</p>
<h2>Structural typing in TypeScript</h2>
<p>TypeScript complains when properties are missing or of the wrong type.</p>
<div><div><div><div><pre><p><span>function</span><span> </span><span>saveUser</span><span>(</span><span>user</span><span>:</span><span> </span><span>{</span><span> name</span><span>:</span><span> </span><span>string</span><span>,</span><span> age</span><span>:</span><span> </span><span>number</span><span> </span><span>}</span><span>)</span><span> </span><span>{</span><span>}</span><span></span></p><p><span></span><span>const</span><span> user1 </span><span>=</span><span> </span><span>{</span><span> name</span><span>:</span><span> </span><span>&#34;Alex&#34;</span><span>,</span><span> age</span><span>:</span><span> </span><span>25</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>saveUser</span><span>(</span><span>user1</span><span>)</span><span>;</span><span> </span><span></span></p><p><span></span><span>const</span><span> user2 </span><span>=</span><span> </span><span>{</span><span> name</span><span>:</span><span> </span><span>&#34;Sarah&#34;</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>saveUser</span><span>(</span><span>user2</span><span>)</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>Property &#39;age&#39; is missing in type { name: string }.</p></div></div></div><p><span></span><span>const</span><span> user3 </span><span>=</span><span> </span><span>{</span><span> name</span><span>:</span><span> </span><span>&#34;John&#34;</span><span>,</span><span> age</span><span>:</span><span> </span><span>&#39;34&#39;</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>saveUser</span><span>(</span><span>user3</span><span>)</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>Types of property &#39;age&#39; are incompatible.</p><p><span> <!-- --> </span>Type &#39;string&#39; is not assignable to type &#39;number&#39;.</p></div></div></div></pre></div></div></div></div>
<p>However, TypeScript does <em>not</em> complain if we provide extraneous properties.</p>
<div><div><div><div><pre><p><span>function</span><span> </span><span>saveUser</span><span>(</span><span>user</span><span>:</span><span> </span><span>{</span><span> name</span><span>:</span><span> </span><span>string</span><span>,</span><span> age</span><span>:</span><span> </span><span>number</span><span> </span><span>}</span><span>)</span><span> </span><span>{</span><span>}</span><span></span></p><p><span></span><span>const</span><span> user </span><span>=</span><span> </span><span>{</span><span> name</span><span>:</span><span> </span><span>&#34;Alex&#34;</span><span>,</span><span> age</span><span>:</span><span> </span><span>25</span><span>,</span><span> city</span><span>:</span><span> </span><span>&#34;Reykjavík&#34;</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>saveUser</span><span>(</span><span>user</span><span>)</span><span>;</span><span> </span><span></span></p></pre></div></div></div></div>
<p>This is the intended behavior in structural type systems. Type <code>A</code> is assignable to <code>B</code> if <code>A</code> is a superset of <code>B</code> (i.e. <code>A</code> contains every property in <code>B</code>).</p>
<p>However, if <code>A</code> is a <em>proper</em> superset of <code>B</code> (i.e. <code>A</code> has <em>more</em> properties than <code>B</code>), then</p>
<ul>
<li><code>A</code> is assignable to <code>B</code>, but</li>
<li><code>B</code> is not assignable to <code>A</code>.</li>
</ul>
<p>Note: <!-- -->In addition to needing to be a superset, property-wise, the types of the properties also matter.</p>
<p>This is all quite abstract, so let&#39;s take a look at a concrete example.</p>
<div><div><div><div><pre><p><span>type</span><span> </span><span>A</span><span> </span><span>=</span><span> </span><span>{</span><span> foo</span><span>:</span><span> </span><span>number</span><span>,</span><span> bar</span><span>:</span><span> </span><span>number</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>type</span><span> </span><span>B</span><span> </span><span>=</span><span> </span><span>{</span><span> foo</span><span>:</span><span> </span><span>number</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>const</span><span> a1</span><span>:</span><span> </span><span>A</span><span> </span><span>=</span><span> </span><span>{</span><span> foo</span><span>:</span><span> </span><span>1</span><span>,</span><span> bar</span><span>:</span><span> </span><span>2</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>const</span><span> b1</span><span>:</span><span> </span><span>B</span><span> </span><span>=</span><span> </span><span>{</span><span> foo</span><span>:</span><span> </span><span>3</span><span> </span><span>}</span><span>;</span><span></span></p><p><span></span><span>const</span><span> b2</span><span>:</span><span> </span><span>B</span><span> </span><span>=</span><span> a1</span><span>;</span><span></span></p><p><span></span><span>const</span><span> a2</span><span>:</span><span> </span><span>A</span><span> </span><span>=</span><span> b1</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>Property &#39;bar&#39; is missing in type &#39;B&#39; but required in type &#39;A&#39;.</p></div></div></div></pre></div></div></div></div>
<p>They key takeaway is that when we have an object of type <code>T</code>, all we know about that object is that it contains <em>at least</em> the properties in <code>T</code>.</p>
<p>We do <strong>not</strong> know whether we have <em>exactly</em> <code>T</code>, which is why <code>Object.keys</code> is typed the way it is. Let&#39;s take an example.</p>
<h3>Unsafe usage of <code>Object.keys</code></h3>
<p>Say that we&#39;re creating an endpoint for a web service that creates a new user. We have an existing <code>User</code> interface that looks like so:</p>
<div><div><div><div><pre><p><span>interface</span><span> </span><span>User</span><span> </span><span>{</span><span></span></p><p><span>  name</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span>  password</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>Before we save a user to the database, we want to ensure that the user object is valid.</p>
<ul>
<li><code>name</code> must be non-empty.</li>
<li><code>password</code> must be at least 6 characters.</li>
</ul>
<p>So we create a <code>validators</code> object that contains a validation function for each property in <code>User</code>:</p>
<div><div><div><div><pre><p><span>const</span><span> validators </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>name</span><span>:</span><span> </span><span>(</span><span>name</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>=&gt;</span><span> name</span><span>.</span><span>length</span><span> </span><span>&lt;</span><span> </span><span>1</span><span></span></p><p><span>    </span><span>?</span><span> </span><span>&#34;Name must not be empty&#34;</span><span></span></p><p><span>    </span><span>:</span><span> </span><span>&#34;&#34;</span><span>,</span><span></span></p><p><span>  </span><span>password</span><span>:</span><span> </span><span>(</span><span>password</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>=&gt;</span><span> password</span><span>.</span><span>length</span><span> </span><span>&lt;</span><span> </span><span>6</span><span></span></p><p><span>    </span><span>?</span><span> </span><span>&#34;Password must be at least 6 characters&#34;</span><span></span></p><p><span>    </span><span>:</span><span> </span><span>&#34;&#34;</span><span>,</span><span></span></p><p><span></span><span>}</span><span>;</span><span></span></p></pre></div></div></div></div>
<p>We then create a <code>validateUser</code> function to run a <code>User</code> object through these validators:</p>
<div><div><div><div><pre><p><span>function</span><span> </span><span>validateUser</span><span>(</span><span>user</span><span>:</span><span> </span><span>User</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>Since we want to validate each property in <code>user</code>, we can iterate through the properties in <code>user</code> using <code>Object.keys</code>:</p>
<div><div><div><div><pre><p><span>function</span><span> </span><span>validateUser</span><span>(</span><span>user</span><span>:</span><span> </span><span>User</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> error </span><span>=</span><span> </span><span>&#34;&#34;</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> key </span><span>of</span><span> </span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>user</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> validate </span><span>=</span><span> validators</span><span>[</span><span>key</span><span>]</span><span>;</span><span></span></p><p><span>    error </span><span>||=</span><span> </span><span>validate</span><span>(</span><span>user</span><span>[</span><span>key</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> error</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>Note: <!-- -->There are type errors in this code block which I&#39;m hiding for now. We&#39;ll get to them later.</p>
<p>The problem with this approach is that the <code>user</code> object might contain properties not present in <code>validators</code>.</p>
<div><div><div><div><pre><p><span>interface</span><span> </span><span>User</span><span> </span><span>{</span><span></span></p><p><span>  name</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span>  password</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>function</span><span> </span><span>validateUser</span><span>(</span><span>user</span><span>:</span><span> </span><span>User</span><span>)</span><span> </span><span>{</span><span>}</span><span></span></p><p><span></span><span>const</span><span> user </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>  name</span><span>:</span><span> </span><span>&#39;Alex&#39;</span><span>,</span><span></span></p><p><span>  password</span><span>:</span><span> </span><span>&#39;1234&#39;</span><span>,</span><span></span></p><p><span></span><span>}</span><span>;</span><span></span></p><p><span></span><span>validateUser</span><span>(</span><span>user</span><span>)</span><span>;</span><span> </span><span></span></p></pre></div></div></div></div>
<p>Even though <code>User</code> does not specify an <code>email</code> property, this is not a type error because structural typing allows extraneous properties to be provided.</p>
<p>At runtime, the <code>email</code> property will cause <code>validator</code> to be <code>undefined</code> and throw an error when invoked.</p>
<div><div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>const</span><span> key </span><span>of</span><span> </span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>user</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> validate </span><span>=</span><span> validators</span><span>[</span><span>key</span><span>]</span><span>;</span><span></span></p><p><span>  error </span><span>||=</span><span> </span><span>validate</span><span>(</span><span>user</span><span>[</span><span>key</span><span>]</span><span>)</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>TypeError: &#39;validate&#39; is not a function.</p></div></div></div><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>Luckily for us, TypeScript emitted type errors before this code had a chance to run.</p>
<div><div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>const</span><span> key </span><span>of</span><span> </span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>user</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> validate </span><span>=</span><span> validators</span><span>[</span><span>key</span><span>]</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>Expression of type &#39;string&#39; can&#39;t be used to index type &#39;{ name: ..., password: ... }&#39;.</p></div></div></div><p><span>  error </span><span>||=</span><span> </span><span>validate</span><span>(</span><span>user</span><span>[</span><span>key</span><span>]</span><span>)</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>Expression of type &#39;string&#39; can&#39;t be used to index type &#39;User&#39;.</p></div></div></div><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>We now have our answer for why <code>Object.keys</code> is typed the way it is. It forces us to acknowledge that objects may contain properties that the type system is not aware of.</p>
<p>With our newfound knowledge of structural typing and its pitfalls, let&#39;s take a look at how we can effectively use structural typing to our benefit.</p>
<h3>Making use of structural typing</h3>
<p>Structural typing provides a lot of flexibility. It allows interfaces to declare exactly the properties which they need. I want to demonstrate this by walking through an example.</p>
<p>Imagine that we&#39;ve written a function that parses a <code>KeyboardEvent</code> and returns the shortcut to trigger.</p>
<div><div><div><div><pre><p><span>function</span><span> </span><span>getKeyboardShortcut</span><span>(</span><span>e</span><span>:</span><span> </span><span>KeyboardEvent</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>e</span><span>.</span><span>key</span><span> </span><span>===</span><span> </span><span>&#34;s&#34;</span><span> </span><span>&amp;&amp;</span><span> e</span><span>.</span><span>metaKey</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>&#34;save&#34;</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>e</span><span>.</span><span>key</span><span> </span><span>===</span><span> </span><span>&#34;o&#34;</span><span> </span><span>&amp;&amp;</span><span> e</span><span>.</span><span>metaKey</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>&#34;open&#34;</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>null</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>To make sure that the code works as expected, we write some unit tests:</p>
<div><div><div><div><pre><p><span>expect</span><span>(</span><span>getKeyboardShortcut</span><span>(</span><span>{</span><span> key</span><span>:</span><span> </span><span>&#34;s&#34;</span><span>,</span><span> metaKey</span><span>:</span><span> </span><span>true</span><span> </span><span>}</span><span>)</span><span>)</span><span></span></p><p><span>  </span><span>.</span><span>toEqual</span><span>(</span><span>&#34;save&#34;</span><span>)</span><span>;</span><span></span></p><p><span></span><span>expect</span><span>(</span><span>getKeyboardShortcut</span><span>(</span><span>{</span><span> key</span><span>:</span><span> </span><span>&#34;o&#34;</span><span>,</span><span> metaKey</span><span>:</span><span> </span><span>true</span><span> </span><span>}</span><span>)</span><span>)</span><span></span></p><p><span>  </span><span>.</span><span>toEqual</span><span>(</span><span>&#34;open&#34;</span><span>)</span><span>;</span><span></span></p><p><span></span><span>expect</span><span>(</span><span>getKeyboardShortcut</span><span>(</span><span>{</span><span> key</span><span>:</span><span> </span><span>&#34;s&#34;</span><span>,</span><span> metaKey</span><span>:</span><span> </span><span>false</span><span> </span><span>}</span><span>)</span><span>)</span><span></span></p><p><span>  </span><span>.</span><span>toEqual</span><span>(</span><span>null</span><span>)</span><span>;</span><span></span></p></pre></div></div></div></div>
<p>Looks good, but TypeScript complains:</p>
<div><div><div><div><pre><p><span>getKeyboardShortcut</span><span>(</span><span>{</span><span> key</span><span>:</span><span> </span><span>&#34;s&#34;</span><span>,</span><span> metaKey</span><span>:</span><span> </span><span>true</span><span> </span><span>}</span><span>)</span><span>;</span><span></span></p><div><div><div data-type="error"><p><span></span>Type &#39;{ key: string; metaKey: true; }&#39; is missing the following properties from type &#39;KeyboardEvent&#39;: altKey, charCode, code, ctrlKey, and 37 more.</p></div></div></div></pre></div></div></div></div>
<p>Ugh. Specifying all 37 additional properties would be super noisy, so that&#39;s out of the question.</p>
<p>We could resolve this by casting the argument to <code>KeyboardEvent</code>:</p>
<div><div><div><div><pre><p><span>getKeyboardShortcut</span><span>(</span><span>{</span><span> key</span><span>:</span><span> </span><span>&#34;s&#34;</span><span>,</span><span> metaKey</span><span>:</span><span> </span><span>true</span><span> </span><span>}</span><span> </span><span>as</span><span> </span><span>KeyboardEvent</span><span>)</span><span>;</span><span></span></p></pre></div></div></div></div>
<p>But that could mask other type errors that may be occuring.</p>
<p>Instead, we can update <code>getKeyboardShortcut</code> to only declare the properties it needs from the event.</p>
<div><div><div><div><pre><p><span>interface</span><span> </span><span>KeyboardShortcutEvent</span><span> </span><span>{</span><span></span></p><p><span>  key</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span>  metaKey</span><span>:</span><span> </span><span>boolean</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>function</span><span> </span><span>getKeyboardShortcut</span><span>(</span><span>e</span><span>:</span><span> </span><span>KeyboardShortcutEvent</span><span>)</span><span> </span><span>{</span><span>}</span><span></span></p></pre></div></div></div></div>
<p>The test code now only needs to satisfy this more minimal interface, which makes it less noisy.</p>
<p>Our function is also less coupled to the global <code>KeyboardEvent</code> type and can be used in more contexts. It&#39;s much more flexible now.</p>
<p>This is possible because of structural typing. A <code>KeyboardEvent</code> is assignable to <code>KeyboardShortcutEvent</code> because it is a superset, even though <code>KeyboardEvent</code> has 37 unrelated properties.</p>
<div><div><div><div><pre><p><span>window</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;keydown&#34;</span><span>,</span><span> </span><span>(</span><span>e</span><span>:</span><span> </span><span>KeyboardEvent</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> shortcut </span><span>=</span><span> </span><span>getKeyboardShortcut</span><span>(</span><span>e</span><span>)</span><span>;</span><span> </span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>shortcut</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>execShortcut</span><span>(</span><span>shortcut</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span>)</span><span>;</span><span></span></p></pre></div></div></div></div>
<p>This idea is explored in this fantastic post by Evan Martin: <a target="_blank" href="https://neugierig.org/software/blog/2019/11/interface-pattern.html">Interfaces generally belong with users</a>. I highly recommend giving it a read! It changed how I write and think about TypeScript code.</p></main></div></div></div>
  </body>
</html>
