<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/zerotech-studio/zack">Original</a>
    <h1>Zack: A Simple Backtesting Engine in Zig</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Welcome to Zack! This project is a lightweight yet powerful backtesting engine for trading strategies, written entirely in Zig ‚ö°. It allows you to test your trading ideas against historical market data to see how they might have performed.</p>

<p dir="auto">Zack simulates the process of trading based on a predefined strategy using historical OHLCV (Open, High, Low, Close, Volume) data. It processes data bar-by-bar, generates trading signals, simulates order execution, manages a virtual portfolio, and reports the performance.</p>

<p dir="auto">Zig offers several advantages for this kind of application:</p>
<ul dir="auto">
<li><strong>Performance:</strong> Zig compiles to fast, efficient machine code, crucial for processing potentially large datasets quickly.</li>
<li><strong>Memory Control:</strong> Manual memory management allows for fine-tuned optimization and avoids hidden overhead.</li>
<li><strong>Simplicity:</strong> Zig&#39;s focus on simplicity and explicitness makes the codebase easier to understand and maintain (no hidden control flow!).</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">‚öôÔ∏è How it Works: The Engine Flow</h2><a id="user-content-Ô∏è-how-it-works-the-engine-flow" aria-label="Permalink: ‚öôÔ∏è How it Works: The Engine Flow" href="#Ô∏è-how-it-works-the-engine-flow"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The backtesting process is driven by an event loop within the <code>BacktestEngine</code>. Here&#39;s a breakdown of the core components and their interactions:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Initialization:</strong></p>
<ul dir="auto">
<li>The <code>main</code> function loads configuration (<code>config/config.json</code>, <code>config/&lt;strategy_name&gt;.json</code>) and CSV data (<code>data/&lt;data_file&gt;.csv</code>) using <code>AppContext</code>.</li>
<li>It then initializes the <code>BacktestEngine</code>, which in turn sets up all other components.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>The Event Loop (<code>BacktestEngine.run</code>):</strong>
The engine iterates through the historical data bar by bar. For each <code>current_bar</code>:</p>
<ul dir="auto">
<li><strong>Data Handling (<code>DataHandler</code>):</strong> Provides the <code>current_bar</code> (parsed from the CSV data). It uses <code>Bar.parse</code> to convert CSV rows into structured <code>Bar</code> objects.</li>
<li><strong>Portfolio Update (<code>Portfolio</code>):</strong> The portfolio calculates its current market value based on the <code>current_bar.close</code> price and any open <code>Position</code>. It records the total equity at this point in time (<code>EquityPoint</code>).</li>
<li><strong>Lookahead:</strong> The engine fetches the <code>next_bar</code> from the <code>DataHandler</code>. This is crucial for simulating execution delays.</li>
<li><strong>Strategy Signal (<code>BuyAndHoldStrategy</code>):</strong> The current strategy (<code>BuyAndHoldStrategy</code> in this case) receives the <code>current_bar</code> data and the portfolio&#39;s state (e.g., <code>has_position</code>). It decides if a trading signal (<code>Signal</code>) should be generated based on its rules (e.g., <code>bar.open &gt;= buyAt</code>).
<div dir="auto" data-snippet-clipboard-copy-content="// Inside strategy.generateSignal
if (!has_position and bar.open &gt;= @as(f64, @floatFromInt(self.config.buyAt))) {
    return Signal{ .type = .Long }; // Generate Buy signal
}"><pre><span>// Inside strategy.generateSignal</span>
<span>if</span> (<span>!</span><span>has_position</span> <span>and</span> <span>bar</span>.<span>open</span> <span>&gt;=</span> <span>@as</span>(<span>f64</span>, <span>@floatFromInt</span>(<span>self</span>.<span>config</span>.<span>buyAt</span>))) {
    <span>return</span> <span>Signal</span>{ .<span>type</span> <span>=</span> <span>.Long</span> }; <span>// Generate Buy signal</span>
}</pre></div>
</li>
<li><strong>Order Generation (<code>Portfolio</code>):</strong> If a <code>Signal</code> is received, the <code>Portfolio</code> determines the details of the <code>Order</code> (e.g., <code>MarketBuy</code>, quantity). It might use the <code>current_bar</code>&#39;s price for approximate sizing.
<div dir="auto" data-snippet-clipboard-copy-content="// Inside portfolio.handleSignal
const quantity_to_buy = cash_to_use / current_bar.close;
return Order{ .type = .MarketBuy, .quantity = quantity_to_buy };"><pre><span>// Inside portfolio.handleSignal</span>
<span>const</span> <span>quantity_to_buy</span> <span>=</span> <span>cash_to_use</span> <span>/</span> <span>current_bar</span>.<span>close</span>;
<span>return</span> <span>Order</span>{ .<span>type</span> <span>=</span> <span>.MarketBuy</span>, .<span>quantity</span> <span>=</span> <span>quantity_to_buy</span> };</pre></div>
</li>
<li><strong>Execution Simulation (<code>ExecutionHandler</code>):</strong> The <code>Order</code> is sent to the <code>ExecutionHandler</code>. <strong>Crucially</strong>, it uses the <code>next_bar.open</code> price to simulate the fill, modeling the delay between deciding to trade and the order actually executing in the next period. It also calculates commission.
<div dir="auto" data-snippet-clipboard-copy-content="// Inside execution_handler.executeOrder
const fill_price = next_bar.open; // Fill at NEXT bar&#39;s open
const commission = COMMISSION_PER_TRADE;
return Fill{ /* ...details... */ };"><pre><span>// Inside execution_handler.executeOrder</span>
<span>const</span> <span>fill_price</span> <span>=</span> <span>next_bar</span>.<span>open</span>; <span>// Fill at NEXT bar&#39;s open</span>
<span>const</span> <span>commission</span> <span>=</span> <span>COMMISSION_PER_TRADE</span>;
<span>return</span> <span>Fill</span>{ <span>/*</span> <span>...</span><span>details</span><span>...</span> <span>*/</span> };</pre></div>
</li>
<li><strong>Portfolio Update (<code>Portfolio</code>):</strong> The resulting <code>Fill</code> event is sent back to the <code>Portfolio</code>, which updates its <code>current_cash</code>, <code>position</code>, and <code>current_holdings_value</code>.
<div dir="auto" data-snippet-clipboard-copy-content="// Inside portfolio.handleFill
self.current_cash -= cost;
self.position = Position{ .entry_price = fill.fill_price, /*...*/ };"><pre><span>// Inside portfolio.handleFill</span>
<span>self</span>.<span>current_cash</span> <span>-=</span> <span>cost</span>;
<span>self</span>.<span>position</span> <span>=</span> <span>Position</span>{ .<span>entry_price</span> <span>=</span> <span>fill</span>.<span>fill_price</span>, <span>/*</span><span>...</span><span>*/</span> };</pre></div>
</li>
<li><strong>Loop:</strong> The process repeats with the <code>next_bar</code> becoming the <code>current_bar</code>.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Results:</strong> After processing all bars, the <code>BacktestEngine.logResults</code> function prints a summary of the performance.</p>
</li>
</ol>
<div dir="auto"><h2 tabindex="-1" dir="auto">üéØ Current Strategy: Buy and Hold</h2><a id="user-content--current-strategy-buy-and-hold" aria-label="Permalink: üéØ Current Strategy: Buy and Hold" href="#-current-strategy-buy-and-hold"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The engine currently implements a simple &#34;Buy and Hold&#34; strategy (<code>src/engine/strategy.zig</code>).</p>
<ul dir="auto">
<li><strong>Logic:</strong> It generates a single &#34;Buy&#34; (<code>Long</code>) signal when the <code>open</code> price of a bar crosses above a predefined threshold (<code>buyAt</code>), but <em>only if</em> the portfolio does not already hold a position. It never generates a sell signal; the position is held until the end of the backtest.</li>
<li><strong>Configuration:</strong> The <code>buyAt</code> threshold is set in the strategy&#39;s configuration file (e.g., <code>config/buy-and-hold.json</code>):

</li>
</ul>

<p dir="auto">The main simulation parameters are set in <code>config/config.json</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{
  &#34;budget&#34;: 10000,         // Initial capital for the simulation
  &#34;strategy&#34;: &#34;buy-and-hold.json&#34;, // Which strategy config file to load from config/
  &#34;data&#34;: &#34;btc.csv&#34;        // Which data file to load from data/
}"><pre>{
  <span>&#34;budget&#34;</span>: <span>10000</span>,         <span>// Initial capital for the simulation</span>
  <span>&#34;strategy&#34;</span>: <span><span>&#34;</span>buy-and-hold.json<span>&#34;</span></span>, <span>// Which strategy config file to load from config/</span>
  <span>&#34;data&#34;</span>: <span><span>&#34;</span>btc.csv<span>&#34;</span></span>        <span>// Which data file to load from data/</span>
}</pre></div>

<p dir="auto">The engine expects OHLCV data in CSV format in the <code>data/</code> directory:</p>
<div data-snippet-clipboard-copy-content="timestamp,open,high,low,close,volume
2024-01-01T00:00:00Z,42000.00,42100.00,41900.00,42050.00,100.50
2024-01-01T01:00:00Z,42050.00,42200.00,42000.00,42150.00,120.75
..."><pre lang="csv"><code>timestamp,open,high,low,close,volume
2024-01-01T00:00:00Z,42000.00,42100.00,41900.00,42050.00,100.50
2024-01-01T01:00:00Z,42050.00,42200.00,42000.00,42150.00,120.75
...
</code></pre></div>
<ul dir="auto">
<li><code>timestamp</code>: ISO 8601 format (currently treated as a string).</li>
<li><code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>: Floating-point numbers.</li>
</ul>

<div data-snippet-clipboard-copy-content=".
‚îú‚îÄ‚îÄ build.zig        # Zig build script
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ config.json         # Main configuration
‚îÇ   ‚îî‚îÄ‚îÄ buy-and-hold.json   # Strategy-specific parameters
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ btc.csv             # Sample OHLCV data
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.zig            # Application entry point
‚îÇ   ‚îú‚îÄ‚îÄ csv/                # CSV parser utility
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ csv-parser.zig
‚îÇ   ‚îú‚îÄ‚îÄ engine/             # Core backtesting engine components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common.zig          # Shared structs (Bar, Signal, Order, Fill, Position)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data_handler.zig    # Loads and provides Bars
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strategy.zig        # Strategy logic (BuyAndHoldStrategy)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio.zig       # Manages cash, position, equity
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ execution_handler.zig # Simulates order fills
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backtest_engine.zig # Orchestrates the simulation loop
‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Utility functions
‚îÇ       ‚îú‚îÄ‚îÄ load-config.zig   # JSON config loading
‚îÇ       ‚îî‚îÄ‚îÄ logger.zig        # Simple logging utility
‚îî‚îÄ‚îÄ README.md       # This file"><pre><code>.
‚îú‚îÄ‚îÄ build.zig        # Zig build script
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ config.json         # Main configuration
‚îÇ   ‚îî‚îÄ‚îÄ buy-and-hold.json   # Strategy-specific parameters
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ btc.csv             # Sample OHLCV data
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.zig            # Application entry point
‚îÇ   ‚îú‚îÄ‚îÄ csv/                # CSV parser utility
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ csv-parser.zig
‚îÇ   ‚îú‚îÄ‚îÄ engine/             # Core backtesting engine components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common.zig          # Shared structs (Bar, Signal, Order, Fill, Position)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data_handler.zig    # Loads and provides Bars
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strategy.zig        # Strategy logic (BuyAndHoldStrategy)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio.zig       # Manages cash, position, equity
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ execution_handler.zig # Simulates order fills
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backtest_engine.zig # Orchestrates the simulation loop
‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Utility functions
‚îÇ       ‚îú‚îÄ‚îÄ load-config.zig   # JSON config loading
‚îÇ       ‚îî‚îÄ‚îÄ logger.zig        # Simple logging utility
‚îî‚îÄ‚îÄ README.md       # This file
</code></pre></div>

<ol dir="auto">
<li>
<p dir="auto">Ensure you have Zig installed (see <a href="https://ziglang.org/learn/getting-started/" rel="nofollow">ziglang.org</a>).</p>
</li>
<li>
<p dir="auto">Clone the repository.</p>
</li>
<li>
<p dir="auto">Run the simulation using the Zig build system:</p>

<p dir="auto">Alternatively, run the main file directly:</p>

</li>
</ol>

<p dir="auto">Running the engine with the default configuration and sample <code>btc.csv</code> data produces output similar to this:</p>
<div data-snippet-clipboard-copy-content="‚ÑπÔ∏è [INFO] ‚öôÔ∏è Configuration Loaded:
‚ÑπÔ∏è [INFO]   Budget:   10000
‚ÑπÔ∏è [INFO]   Strategy: buy-and-hold.json
‚ÑπÔ∏è [INFO]   Data File:btc.csv
‚ÑπÔ∏è [INFO] üìà Strategy Settings:
‚ÑπÔ∏è [INFO]   Buy At Threshold: 1000

--- Starting Backtest Run ---
PORTFOLIO: Received LONG signal, generating MarketBuy order for ~0.23547619047619048 units.
EXECUTION: Executing MarketBuy order for 0.23547619047619048 units @ 42050 (Commission: 1)
PORTFOLIO: Handled MarketBuy fill. Cash: 9.99999999999909, Position Qty: 0.23547619047619048, Entry: 42050
--- Backtest Run Finished ---

‚ÑπÔ∏è [INFO]
üìä Backtest Results:
‚ÑπÔ∏è [INFO]   Initial Capital: 10000.00
‚ÑπÔ∏è [INFO]   Final Equity:    10443.75
‚ÑπÔ∏è [INFO]   Total Return:    4.44%
‚ÑπÔ∏è [INFO]   Ending Position: 0.2355 units @ entry 42050.00
‚ÑπÔ∏è [INFO]   (More detailed performance metrics TBD)

Application finished successfully.
"><pre><code>‚ÑπÔ∏è [INFO] ‚öôÔ∏è Configuration Loaded:
‚ÑπÔ∏è [INFO]   Budget:   10000
‚ÑπÔ∏è [INFO]   Strategy: buy-and-hold.json
‚ÑπÔ∏è [INFO]   Data File:btc.csv
‚ÑπÔ∏è [INFO] üìà Strategy Settings:
‚ÑπÔ∏è [INFO]   Buy At Threshold: 1000

--- Starting Backtest Run ---
PORTFOLIO: Received LONG signal, generating MarketBuy order for ~0.23547619047619048 units.
EXECUTION: Executing MarketBuy order for 0.23547619047619048 units @ 42050 (Commission: 1)
PORTFOLIO: Handled MarketBuy fill. Cash: 9.99999999999909, Position Qty: 0.23547619047619048, Entry: 42050
--- Backtest Run Finished ---

‚ÑπÔ∏è [INFO]
üìä Backtest Results:
‚ÑπÔ∏è [INFO]   Initial Capital: 10000.00
‚ÑπÔ∏è [INFO]   Final Equity:    10443.75
‚ÑπÔ∏è [INFO]   Total Return:    4.44%
‚ÑπÔ∏è [INFO]   Ending Position: 0.2355 units @ entry 42050.00
‚ÑπÔ∏è [INFO]   (More detailed performance metrics TBD)

Application finished successfully.

</code></pre></div>
<p dir="auto"><em>(Note: Exact float values might differ slightly)</em></p>
<p dir="auto"><strong>Key Observations from Output:</strong></p>
<ul dir="auto">
<li>The <code>Long</code> signal is generated based on the <em>first</em> bar (<code>open</code>=42000 &gt;= <code>buyAt</code>=1000).</li>
<li>The <code>MarketBuy</code> order is executed at the <code>open</code> price of the <em>second</em> bar (42050), as expected due to the one-bar delay simulation.</li>
<li>The final equity reflects the initial capital minus the buy cost plus the value of the holding at the final bar&#39;s close price.</li>
</ul>

<ul dir="auto">
<li>Implement more sophisticated performance metrics (Sharpe Ratio, Max Drawdown, etc.).</li>
<li>Implement more strategies.</li>
<li>Implement technical indicators.</li>
<li>Add comprehensive unit tests for all engine components.</li>
</ul>
<p dir="auto">Contributions and suggestions are welcome!</p>
</article></div></div>
  </body>
</html>
