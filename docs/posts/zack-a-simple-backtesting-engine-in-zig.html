<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/zerotech-studio/zack">Original</a>
    <h1>Zack: A Simple Backtesting Engine in Zig</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Welcome to Zack! This project is a lightweight yet powerful backtesting engine for trading strategies, written entirely in Zig âš¡. It allows you to test your trading ideas against historical market data to see how they might have performed.</p>

<p dir="auto">Zack simulates the process of trading based on a predefined strategy using historical OHLCV (Open, High, Low, Close, Volume) data. It processes data bar-by-bar, generates trading signals, simulates order execution, manages a virtual portfolio, and reports the performance.</p>

<p dir="auto">Zig offers several advantages for this kind of application:</p>
<ul dir="auto">
<li><strong>Performance:</strong> Zig compiles to fast, efficient machine code, crucial for processing potentially large datasets quickly.</li>
<li><strong>Memory Control:</strong> Manual memory management allows for fine-tuned optimization and avoids hidden overhead.</li>
<li><strong>Simplicity:</strong> Zig&#39;s focus on simplicity and explicitness makes the codebase easier to understand and maintain (no hidden control flow!).</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">âš™ï¸ How it Works: The Engine Flow</h2><a id="user-content-ï¸-how-it-works-the-engine-flow" aria-label="Permalink: âš™ï¸ How it Works: The Engine Flow" href="#ï¸-how-it-works-the-engine-flow"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The backtesting process is driven by an event loop within the <code>BacktestEngine</code>. Here&#39;s a breakdown of the core components and their interactions:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Initialization:</strong></p>
<ul dir="auto">
<li>The <code>main</code> function loads configuration (<code>config/config.json</code>, <code>config/&lt;strategy_name&gt;.json</code>) and CSV data (<code>data/&lt;data_file&gt;.csv</code>) using <code>AppContext</code>.</li>
<li>It then initializes the <code>BacktestEngine</code>, which in turn sets up all other components.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>The Event Loop (<code>BacktestEngine.run</code>):</strong>
The engine iterates through the historical data bar by bar. For each <code>current_bar</code>:</p>
<ul dir="auto">
<li><strong>Data Handling (<code>DataHandler</code>):</strong> Provides the <code>current_bar</code> (parsed from the CSV data). It uses <code>Bar.parse</code> to convert CSV rows into structured <code>Bar</code> objects.</li>
<li><strong>Portfolio Update (<code>Portfolio</code>):</strong> The portfolio calculates its current market value based on the <code>current_bar.close</code> price and any open <code>Position</code>. It records the total equity at this point in time (<code>EquityPoint</code>).</li>
<li><strong>Lookahead:</strong> The engine fetches the <code>next_bar</code> from the <code>DataHandler</code>. This is crucial for simulating execution delays.</li>
<li><strong>Strategy Signal (<code>BuyAndHoldStrategy</code>):</strong> The current strategy (<code>BuyAndHoldStrategy</code> in this case) receives the <code>current_bar</code> data and the portfolio&#39;s state (e.g., <code>has_position</code>). It decides if a trading signal (<code>Signal</code>) should be generated based on its rules (e.g., <code>bar.open &gt;= buyAt</code>).
<div dir="auto" data-snippet-clipboard-copy-content="// Inside strategy.generateSignal
if (!has_position and bar.open &gt;= @as(f64, @floatFromInt(self.config.buyAt))) {
    return Signal{ .type = .Long }; // Generate Buy signal
}"><pre><span>// Inside strategy.generateSignal</span>
<span>if</span> (<span>!</span><span>has_position</span> <span>and</span> <span>bar</span>.<span>open</span> <span>&gt;=</span> <span>@as</span>(<span>f64</span>, <span>@floatFromInt</span>(<span>self</span>.<span>config</span>.<span>buyAt</span>))) {
    <span>return</span> <span>Signal</span>{ .<span>type</span> <span>=</span> <span>.Long</span> }; <span>// Generate Buy signal</span>
}</pre></div>
</li>
<li><strong>Order Generation (<code>Portfolio</code>):</strong> If a <code>Signal</code> is received, the <code>Portfolio</code> determines the details of the <code>Order</code> (e.g., <code>MarketBuy</code>, quantity). It might use the <code>current_bar</code>&#39;s price for approximate sizing.
<div dir="auto" data-snippet-clipboard-copy-content="// Inside portfolio.handleSignal
const quantity_to_buy = cash_to_use / current_bar.close;
return Order{ .type = .MarketBuy, .quantity = quantity_to_buy };"><pre><span>// Inside portfolio.handleSignal</span>
<span>const</span> <span>quantity_to_buy</span> <span>=</span> <span>cash_to_use</span> <span>/</span> <span>current_bar</span>.<span>close</span>;
<span>return</span> <span>Order</span>{ .<span>type</span> <span>=</span> <span>.MarketBuy</span>, .<span>quantity</span> <span>=</span> <span>quantity_to_buy</span> };</pre></div>
</li>
<li><strong>Execution Simulation (<code>ExecutionHandler</code>):</strong> The <code>Order</code> is sent to the <code>ExecutionHandler</code>. <strong>Crucially</strong>, it uses the <code>next_bar.open</code> price to simulate the fill, modeling the delay between deciding to trade and the order actually executing in the next period. It also calculates commission.
<div dir="auto" data-snippet-clipboard-copy-content="// Inside execution_handler.executeOrder
const fill_price = next_bar.open; // Fill at NEXT bar&#39;s open
const commission = COMMISSION_PER_TRADE;
return Fill{ /* ...details... */ };"><pre><span>// Inside execution_handler.executeOrder</span>
<span>const</span> <span>fill_price</span> <span>=</span> <span>next_bar</span>.<span>open</span>; <span>// Fill at NEXT bar&#39;s open</span>
<span>const</span> <span>commission</span> <span>=</span> <span>COMMISSION_PER_TRADE</span>;
<span>return</span> <span>Fill</span>{ <span>/*</span> <span>...</span><span>details</span><span>...</span> <span>*/</span> };</pre></div>
</li>
<li><strong>Portfolio Update (<code>Portfolio</code>):</strong> The resulting <code>Fill</code> event is sent back to the <code>Portfolio</code>, which updates its <code>current_cash</code>, <code>position</code>, and <code>current_holdings_value</code>.
<div dir="auto" data-snippet-clipboard-copy-content="// Inside portfolio.handleFill
self.current_cash -= cost;
self.position = Position{ .entry_price = fill.fill_price, /*...*/ };"><pre><span>// Inside portfolio.handleFill</span>
<span>self</span>.<span>current_cash</span> <span>-=</span> <span>cost</span>;
<span>self</span>.<span>position</span> <span>=</span> <span>Position</span>{ .<span>entry_price</span> <span>=</span> <span>fill</span>.<span>fill_price</span>, <span>/*</span><span>...</span><span>*/</span> };</pre></div>
</li>
<li><strong>Loop:</strong> The process repeats with the <code>next_bar</code> becoming the <code>current_bar</code>.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Results:</strong> After processing all bars, the <code>BacktestEngine.logResults</code> function prints a summary of the performance.</p>
</li>
</ol>
<div dir="auto"><h2 tabindex="-1" dir="auto">ğŸ¯ Current Strategy: Buy and Hold</h2><a id="user-content--current-strategy-buy-and-hold" aria-label="Permalink: ğŸ¯ Current Strategy: Buy and Hold" href="#-current-strategy-buy-and-hold"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The engine currently implements a simple &#34;Buy and Hold&#34; strategy (<code>src/engine/strategy.zig</code>).</p>
<ul dir="auto">
<li><strong>Logic:</strong> It generates a single &#34;Buy&#34; (<code>Long</code>) signal when the <code>open</code> price of a bar crosses above a predefined threshold (<code>buyAt</code>), but <em>only if</em> the portfolio does not already hold a position. It never generates a sell signal; the position is held until the end of the backtest.</li>
<li><strong>Configuration:</strong> The <code>buyAt</code> threshold is set in the strategy&#39;s configuration file (e.g., <code>config/buy-and-hold.json</code>):

</li>
</ul>

<p dir="auto">The main simulation parameters are set in <code>config/config.json</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{
  &#34;budget&#34;: 10000,         // Initial capital for the simulation
  &#34;strategy&#34;: &#34;buy-and-hold.json&#34;, // Which strategy config file to load from config/
  &#34;data&#34;: &#34;btc.csv&#34;        // Which data file to load from data/
}"><pre>{
  <span>&#34;budget&#34;</span>: <span>10000</span>,         <span>// Initial capital for the simulation</span>
  <span>&#34;strategy&#34;</span>: <span><span>&#34;</span>buy-and-hold.json<span>&#34;</span></span>, <span>// Which strategy config file to load from config/</span>
  <span>&#34;data&#34;</span>: <span><span>&#34;</span>btc.csv<span>&#34;</span></span>        <span>// Which data file to load from data/</span>
}</pre></div>

<p dir="auto">The engine expects OHLCV data in CSV format in the <code>data/</code> directory:</p>
<div data-snippet-clipboard-copy-content="timestamp,open,high,low,close,volume
2024-01-01T00:00:00Z,42000.00,42100.00,41900.00,42050.00,100.50
2024-01-01T01:00:00Z,42050.00,42200.00,42000.00,42150.00,120.75
..."><pre lang="csv"><code>timestamp,open,high,low,close,volume
2024-01-01T00:00:00Z,42000.00,42100.00,41900.00,42050.00,100.50
2024-01-01T01:00:00Z,42050.00,42200.00,42000.00,42150.00,120.75
...
</code></pre></div>
<ul dir="auto">
<li><code>timestamp</code>: ISO 8601 format (currently treated as a string).</li>
<li><code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>: Floating-point numbers.</li>
</ul>

<div data-snippet-clipboard-copy-content=".
â”œâ”€â”€ build.zig        # Zig build script
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ config.json         # Main configuration
â”‚   â””â”€â”€ buy-and-hold.json   # Strategy-specific parameters
â”œâ”€â”€ data/
â”‚   â””â”€â”€ btc.csv             # Sample OHLCV data
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.zig            # Application entry point
â”‚   â”œâ”€â”€ csv/                # CSV parser utility
â”‚   â”‚   â””â”€â”€ csv-parser.zig
â”‚   â”œâ”€â”€ engine/             # Core backtesting engine components
â”‚   â”‚   â”œâ”€â”€ common.zig          # Shared structs (Bar, Signal, Order, Fill, Position)
â”‚   â”‚   â”œâ”€â”€ data_handler.zig    # Loads and provides Bars
â”‚   â”‚   â”œâ”€â”€ strategy.zig        # Strategy logic (BuyAndHoldStrategy)
â”‚   â”‚   â”œâ”€â”€ portfolio.zig       # Manages cash, position, equity
â”‚   â”‚   â”œâ”€â”€ execution_handler.zig # Simulates order fills
â”‚   â”‚   â””â”€â”€ backtest_engine.zig # Orchestrates the simulation loop
â”‚   â””â”€â”€ utils/              # Utility functions
â”‚       â”œâ”€â”€ load-config.zig   # JSON config loading
â”‚       â””â”€â”€ logger.zig        # Simple logging utility
â””â”€â”€ README.md       # This file"><pre><code>.
â”œâ”€â”€ build.zig        # Zig build script
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ config.json         # Main configuration
â”‚   â””â”€â”€ buy-and-hold.json   # Strategy-specific parameters
â”œâ”€â”€ data/
â”‚   â””â”€â”€ btc.csv             # Sample OHLCV data
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.zig            # Application entry point
â”‚   â”œâ”€â”€ csv/                # CSV parser utility
â”‚   â”‚   â””â”€â”€ csv-parser.zig
â”‚   â”œâ”€â”€ engine/             # Core backtesting engine components
â”‚   â”‚   â”œâ”€â”€ common.zig          # Shared structs (Bar, Signal, Order, Fill, Position)
â”‚   â”‚   â”œâ”€â”€ data_handler.zig    # Loads and provides Bars
â”‚   â”‚   â”œâ”€â”€ strategy.zig        # Strategy logic (BuyAndHoldStrategy)
â”‚   â”‚   â”œâ”€â”€ portfolio.zig       # Manages cash, position, equity
â”‚   â”‚   â”œâ”€â”€ execution_handler.zig # Simulates order fills
â”‚   â”‚   â””â”€â”€ backtest_engine.zig # Orchestrates the simulation loop
â”‚   â””â”€â”€ utils/              # Utility functions
â”‚       â”œâ”€â”€ load-config.zig   # JSON config loading
â”‚       â””â”€â”€ logger.zig        # Simple logging utility
â””â”€â”€ README.md       # This file
</code></pre></div>

<ol dir="auto">
<li>
<p dir="auto">Ensure you have Zig installed (see <a href="https://ziglang.org/learn/getting-started/" rel="nofollow">ziglang.org</a>).</p>
</li>
<li>
<p dir="auto">Clone the repository.</p>
</li>
<li>
<p dir="auto">Run the simulation using the Zig build system:</p>

<p dir="auto">Alternatively, run the main file directly:</p>

</li>
</ol>

<p dir="auto">Running the engine with the default configuration and sample <code>btc.csv</code> data produces output similar to this:</p>
<div data-snippet-clipboard-copy-content="â„¹ï¸ [INFO] âš™ï¸ Configuration Loaded:
â„¹ï¸ [INFO]   Budget:   10000
â„¹ï¸ [INFO]   Strategy: buy-and-hold.json
â„¹ï¸ [INFO]   Data File:btc.csv
â„¹ï¸ [INFO] ğŸ“ˆ Strategy Settings:
â„¹ï¸ [INFO]   Buy At Threshold: 1000

--- Starting Backtest Run ---
PORTFOLIO: Received LONG signal, generating MarketBuy order for ~0.23547619047619048 units.
EXECUTION: Executing MarketBuy order for 0.23547619047619048 units @ 42050 (Commission: 1)
PORTFOLIO: Handled MarketBuy fill. Cash: 9.99999999999909, Position Qty: 0.23547619047619048, Entry: 42050
--- Backtest Run Finished ---

â„¹ï¸ [INFO]
ğŸ“Š Backtest Results:
â„¹ï¸ [INFO]   Initial Capital: 10000.00
â„¹ï¸ [INFO]   Final Equity:    10443.75
â„¹ï¸ [INFO]   Total Return:    4.44%
â„¹ï¸ [INFO]   Ending Position: 0.2355 units @ entry 42050.00
â„¹ï¸ [INFO]   (More detailed performance metrics TBD)

Application finished successfully.
"><pre><code>â„¹ï¸ [INFO] âš™ï¸ Configuration Loaded:
â„¹ï¸ [INFO]   Budget:   10000
â„¹ï¸ [INFO]   Strategy: buy-and-hold.json
â„¹ï¸ [INFO]   Data File:btc.csv
â„¹ï¸ [INFO] ğŸ“ˆ Strategy Settings:
â„¹ï¸ [INFO]   Buy At Threshold: 1000

--- Starting Backtest Run ---
PORTFOLIO: Received LONG signal, generating MarketBuy order for ~0.23547619047619048 units.
EXECUTION: Executing MarketBuy order for 0.23547619047619048 units @ 42050 (Commission: 1)
PORTFOLIO: Handled MarketBuy fill. Cash: 9.99999999999909, Position Qty: 0.23547619047619048, Entry: 42050
--- Backtest Run Finished ---

â„¹ï¸ [INFO]
ğŸ“Š Backtest Results:
â„¹ï¸ [INFO]   Initial Capital: 10000.00
â„¹ï¸ [INFO]   Final Equity:    10443.75
â„¹ï¸ [INFO]   Total Return:    4.44%
â„¹ï¸ [INFO]   Ending Position: 0.2355 units @ entry 42050.00
â„¹ï¸ [INFO]   (More detailed performance metrics TBD)

Application finished successfully.

</code></pre></div>
<p dir="auto"><em>(Note: Exact float values might differ slightly)</em></p>
<p dir="auto"><strong>Key Observations from Output:</strong></p>
<ul dir="auto">
<li>The <code>Long</code> signal is generated based on the <em>first</em> bar (<code>open</code>=42000 &gt;= <code>buyAt</code>=1000).</li>
<li>The <code>MarketBuy</code> order is executed at the <code>open</code> price of the <em>second</em> bar (42050), as expected due to the one-bar delay simulation.</li>
<li>The final equity reflects the initial capital minus the buy cost plus the value of the holding at the final bar&#39;s close price.</li>
</ul>

<ul dir="auto">
<li>Implement more sophisticated performance metrics (Sharpe Ratio, Max Drawdown, etc.).</li>
<li>Implement more strategies.</li>
<li>Implement technical indicators.</li>
<li>Add comprehensive unit tests for all engine components.</li>
</ul>
<p dir="auto">Contributions and suggestions are welcome!</p>
</article></div></div>
  </body>
</html>
