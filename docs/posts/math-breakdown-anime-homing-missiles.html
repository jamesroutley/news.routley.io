<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.littlepolygon.com/posts/missile/">Original</a>
    <h1>Math breakdown: Anime homing missiles</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>I designed and prototyped the missile attack! The math was clever and I want to show-off!</p>
<p>Let‚Äôs talk about <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">cubic bezier curves</a>, <a href="https://en.wikipedia.org/wiki/Perlin_noise">perlin noise</a>, and <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf">rotation minimizing frames</a>.</p>
<p><img src="https://media.giphy.com/media/o5hiXadU2BbJ6skNDP/giphy.gif" alt="Missile Circus!"/></p>
<p><span>
<p><em>Doing <a href="https://en.wikipedia.org/wiki/Ichir%C5%8D_Itano#Itano_Circus">Ichir≈ç Itano</a> proud.</em></p>
</span></p><p>I‚Äôll keep this article a little lighter on code. I really want to focus instead of the geometry. Many people are intimidated by math, but keep in mind that you don‚Äôt need to understand everything to use it.</p>
<p>Even if this is retreading topics you‚Äôve already mastered, hopefully my own solution shows you some new ways you can combine these techniques creatively.</p>
<p>Broadly speaking, there‚Äôs two flavors of movement code.  <strong>Iterative Code</strong> updates an object position incrementally one frame at a time, in a process college-professors call <em>integration</em>.  A common example of this <a href="https://en.wikipedia.org/wiki/Euler_method">Euler‚Äôs Method</a> where we compute the velocity of the object and then nudge the position in that direction over a timestep:</p>
<div><pre tabindex="0"><code data-lang="cs"><span><span><span>void</span> Update( <span>float</span> DeltaTime ) {
</span></span><span><span>	Vector3 Velocity = CalculateVelocity();
</span></span><span><span>	Vector3 Position = GetPosition();
</span></span><span><span>	SetPosition( Position + DeltaTime * Velocity );
</span></span><span><span>}
</span></span></code></pre></div><p><span>
<p><em>Delta is just ‚Äòmath speak‚Äô for ‚Äúchange in‚Äù as in ‚Äúthe change in time this Update()‚Äù.</em></p>
</span></p><p>This is the natural way to write character control, in which the player input varies every frame, or complex physics simulations where there is no known realtime analytical solution.</p>
<p>Alternatively, if you know the whole motion ahead of time, you can use <strong>Closed-Form Code</strong> where you plot the whole path from intial conditions (math heads call it a <em>parametric curve</em>), and <em>sample</em> the current time. A good example of this is the well-known <strong>Cubic Bezier Curve</strong>:</p>
<div><pre tabindex="0"><code data-lang="cs"><span><span>Vector3 CalcBezierPos( Vector3 P0, Vector3 P1, Vector3 P2, Vector3 P3, <span>float</span> t ) {
</span></span><span><span>	<span>float</span> t_ = <span>1</span> - t;
</span></span><span><span>	<span>return</span>
</span></span><span><span>		(t_ * t_ * t_)    * P1 + 
</span></span><span><span>		(<span>3</span> * t_ * t_ * t) * P2 +
</span></span><span><span>		(<span>3</span> * t_ * t * t)  * P3 + 
</span></span><span><span>		(t * t * t)       * P4 ;
</span></span><span><span>}
</span></span></code></pre></div><p><img src="https://blog.littlepolygon.com/posts/missile/bezier.png" alt="Bezier Curve"/></p>
<p>If you‚Äôve every used any vector graphics tool you probably recognize this. Beziers are <em>cubic polynomials</em> which is a fancy way of saying the simplest path with four degrees of freedom: the endpoints P0 and P3 and the ‚Äúcontrol points‚Äù P1 and P2 which affect the orientation and curvature.</p>
<p>The input <em>t</em> is called the <em>input parameter</em> and is a ratio on the range 0-1.  So e.g. t=0.333 is about a third of the way through.  To move a point, we simply take the elapsed time since the start of the motion, divided by the duration.</p>
<div><pre tabindex="0"><code data-lang="cs"><span><span><span>float</span> StartTime;
</span></span><span><span><span>float</span> Duration;
</span></span><span><span>
</span></span><span><span><span>void</span> Update() {
</span></span><span><span>	<span>float</span> CurrentTime = Time.time;
</span></span><span><span>	<span>float</span> Elapsed = CurrentTime - StartTime;
</span></span><span><span>	<span>if</span>( Elapsed &gt;= Duration )
</span></span><span><span>		SetPosition( P3 ); <span>// we&#39;re at the end</span>
</span></span><span><span>	<span>else</span>
</span></span><span><span>		SetPosition( CalcBezierPos( P0, P1, P2, P3, Elapsed / Duration ) );
</span></span><span><span>}
</span></span></code></pre></div><p>In addition to the position, we can also use the bezier parameters to calculate the <em>derivative at t</em>, which is the rate of change.  This vector is useful because we says it‚Äôs <em>tangent to the curve</em>, i.e. it points in the direction of the motion. To convert this to speed, divide by the duration.</p>
<div><pre tabindex="0"><code data-lang="cs"><span><span>Vector3 CalcBezierDeriv( Vector3 P0, Vector3 P1, Vector3 P2, Vector3 P3, <span>float</span> t ) {
</span></span><span><span>	<span>float</span> t_ = <span>1</span> - t;
</span></span><span><span>	<span>return</span>  (
</span></span><span><span>		( <span>3</span> * t_ * t_ ) * ( P1 - P0 ) + 
</span></span><span><span>		( <span>6</span> * t_ * t ) * ( P2 - P1 ) + 
</span></span><span><span>		( <span>3</span> * t * t ) * ( P3 - P2 ) ;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>float</span> Velocity = CalcBezierDeriv( P0, P1, P2, P3, Elapsed / Duration ) / Duration;
</span></span></code></pre></div><p><img src="https://blog.littlepolygon.com/posts/missile/deriv.png" alt="Derivative"/></p>
<p><span>
<p><em>Speed = Meters Per Second = ( Meters Per T ) / ( Seconds Per T ) = Deriv / Duration</em></p>
</span></p><p>Because I know where the homing missile path starts (the launcher muzzle), and where it ends (the painted target), I chose to use a bezier curve as the base for the homing missile path.</p>
<p><img src="https://blog.littlepolygon.com/posts/missile/firing_solution.png" alt="Firing Solution"/></p>
<p><span>
<p><em>P1 is placed in front of the shooter, and P2 is projected out from the target surface.</em></p>
</span></p><p>Using a closed form kept things simple, because I didn‚Äôt have to solve a complicated ‚Äúsimulation‚Äù that hits the right point, and I can fine-tune the exact time between when you fire and when it hits, which is a more intuitive than second-order physics units.</p>
<p><img src="https://media.giphy.com/media/Oy6MvbtJHND2DUpwoo/giphy.gif" alt="First Pass Effect"/></p>
<p><span>
<p><em>This was a <a href="https://youtu.be/FcxsgZxqnEg">perfectly cromulent</a> effect, if a bit bland. We can do better.</em></p>
</span></p><!--

# Easing the Input #

When I picture about missiles firing, I imagine them starting a slow, and then speeding-up, not just mechanically moving at constant speed. We can get this effect by *easing* the input, by first passing it through a function. I started with a basic parabola f(x)=x¬≤

```cs
float EasingFunction( float x ) {
	return x * x;
}

SetPosition( CalcBezierPos( P0, P1, P2, P3, EasingFunction( Elapsed / Duration ) ) );
```

![Easing Figure](easing.png)

<span style="text-align: center;">

*The only restriction on f is that f(0)=0 and f(1)=1.*

</span>


This gave me the speedup I wanted, but as a downside caused the missiles to be completely stationary when fired, whereas I wanted them to at least start with *some speed*. I recouped that by Lerp()ing the parabola with the unmodified input to get an "in between" curve. 

```cs
float EasingFunction( float x ) {
	return Mathf.Lerp( x, x * x, 0.5 );
}
```

![Footage with Easing](https://media.giphy.com/media/ovK9Nnd4gpWkkpGxlH/giphy.gif)

<span style="text-align: center;">

*0.5 was just a guess, but it looked good.*

</span>


-->
<p>With a solid foundation, it‚Äôs time to start adding juice. Missile storm attacks in anime take erratic paths with more dynamism. We can simulate this by adding noise.</p>
<p>A common go-to for FX artists is <em>Perlin Noise</em>, a kind-of pseudorandom oscillation ‚Äì it‚Äôs erratic, but also smooth. The code‚Äôs a little too long to post here, but it‚Äôs not hard to find samples online.</p>
<p><img src="https://blog.littlepolygon.com/posts/missile/perlin.png" alt="Perlin Figure"/></p>
<p><span>
<p><em>Search for ‚Äú<a href="https://github.com/WardBenjamin/SimplexNoise/blob/master/SimplexNoise/Noise.cs">Simplex Noise</a>‚Äù (the name of a common optimized variant).</em></p>
</span></p><p>An obvious problem here is that I need the offset to be zero at endpoints, so the missile lines up with the muzzle and the target. I achieved this by multiplying it by an <em>envelope</em> which is zero at the ends and one in the middle.</p>
<p><img src="https://blog.littlepolygon.com/posts/missile/envelope.png" alt="Envelope Figure"/></p>
<p>How do we turn a noise function into a 3D curve-deformed offset?  We compute two independent noise values and use them as the X and Y components of a offset vector transformed by a rotation-frame that‚Äôs aligned to the bezier‚Äôs derivative (what a mouthful!).</p>
<div><pre tabindex="0"><code data-lang="cs"><span><span>Vector3 LocalOffset;
</span></span><span><span><span>float</span> NoiseFreq = <span>2f</span>; <span>// tuning value for wiggle frequency</span>
</span></span><span><span><span>float</span> NoiseAmp = <span>8</span>;   <span>// tuning value for wiggle size</span>
</span></span><span><span><span>float</span> Envelope = <span>1</span> - (<span>1</span> - <span>2</span> * t) * (<span>1</span> - <span>2</span> * t);
</span></span><span><span>LocalOffset.x = NoiseAmp * Envelope * Noise( NoiseSeedX, NoiseFreq * Elapsed );
</span></span><span><span>LocalOffset.y = NoiseAmp * Envelope * Noise( NoiseSeedY, NoiseFreq * Elapsed );
</span></span><span><span>LocalOffset.z = <span>0</span>;
</span></span><span><span>Quaternion Frame = Quaternion.LookRotation( CalcBezierDeriv( P0, P1, P2, P3, t ) );
</span></span><span><span>SetPosition( CalcBezierPos( P0, P1, P2, P3, t ) + Frame * LocalOffset );
</span></span></code></pre></div><p><img src="https://blog.littlepolygon.com/posts/missile/frame.png" alt="Rotation Frame"/></p>
<p><span>
<p><em>TL;DR We‚Äôre wiggling along the red and green arrows.</em></p>
</span></p><p>This <em>almost</em> worked, but I saw some glitches. Vertically-Locked rotation frames calculated this way are <em>aligned</em> to the derivative, but twist a lot ‚Äì especially when the path is vertical. Instead, we want so-called <em>Rotation Minimizing Frames</em> which have no instantaneous twist, just minimal swings between directions.</p>
<p><img src="https://blog.littlepolygon.com/posts/missile/twist.png" alt="Twist Comparison"/></p>
<p><span>
<p><em>(A) Vertically-Locked Frames (B) Rotation Minimizing Frames</em></p>
</span></p><p>The method of computing minizing frames is mathematically complex in general, but luckily a paper was published in 2006 which described a <em>shockingly simple</em> method for ‚Äúnudging‚Äù a frame forward without twisting called the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf">Double Reflection Method</a>. We don‚Äôt need to understand the derivation, we can just know that it‚Äôs cheap and it works.</p>
<p><img src="https://blog.littlepolygon.com/posts/missile/double_ref.png" alt="Double Reflection"/></p>
<p><span>
<p><em>Shoutout to <a href="https://twitter.com/JasperRLZ">Jasper St. Pierre</a> for showing me this mathy-ass math.</em></p>
</span></p><div><pre tabindex="0"><code data-lang="cs"><span><span>Quaternion Frame; <span>// Initialize to Quaternion.LookDirection( P1 - P0 );</span>
</span></span><span><span>
</span></span><span><span><span>void</span> UpdateFrame( <span>float</span> t ) {
</span></span><span><span>	<span>// starting &#34;normal&#34; and &#34;tangent&#34;</span>
</span></span><span><span>	<span>var</span> n0 = Frame * Vector3.up;
</span></span><span><span>	<span>var</span> t0 = Frame * Vector3.forward;
</span></span><span><span>
</span></span><span><span>	<span>// target &#34;tangent&#34;</span>
</span></span><span><span>	<span>var</span> t1 = CalcBezierDeriv( P0, P1, P2, P3, t ).normalized;
</span></span><span><span>
</span></span><span><span>	<span>// first reflection</span>
</span></span><span><span>	<span>var</span> v1 = CalcBezierPos( P0, P1, P2, P3, t ) - GetPosition(); 
</span></span><span><span>	<span>var</span> c1 = v1.sqrMagnitude;
</span></span><span><span>	<span>var</span> n0_l = n0 - (<span>2</span> / c1) * Vector3.Dot(v1, n0) * v1;
</span></span><span><span>	<span>var</span> t0_l = t0 - (<span>2</span> / c1) * Vector3.Dot(v1, t0) * v1;
</span></span><span><span>
</span></span><span><span>	<span>// second reflection</span>
</span></span><span><span>	<span>var</span> v2 = t1 - t0_l;
</span></span><span><span>	<span>var</span> c2 = v2.sqrMagnitude;
</span></span><span><span>	<span>var</span> n1 = n0_l - (<span>2</span> / c2) * Vector3.Dot(v2, n0_l) * v2;
</span></span><span><span>
</span></span><span><span>	<span>// build rotation with target normal for &#34;up&#34;</span>
</span></span><span><span>	Frame = Quaternion.LookRotation( t1, n1 );
</span></span><span><span>}
</span></span></code></pre></div><p><img src="https://blog.littlepolygon.com/posts/missile/final.gif" alt="Final Missile Path"/></p>
<p><span>
<p><em>Et Voil√†!</em></p>
</span></p><p>Thanks for reading! I promise I‚Äôll do an art post next to give everyone a break from code üôè</p>
        </div></div>
  </body>
</html>
