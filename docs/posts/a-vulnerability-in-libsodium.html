<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://00f.net/2025/12/30/libsodium-vulnerability/">Original</a>
    <h1>A Vulnerability in Libsodium</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/BlogPosting" role="article">
  
  
  <div itemprop="articleBody">
    <p>Libsodium is now 13 years old!</p>

<p>I started that project to pursue Dan Bernstein’s desire to make cryptography simple to use. That meant exposing a limited set of high-level functions and parameters, providing a simple API, and writing documentation for users, not cryptographers. Libsodium’s goal was to expose APIs to perform operations, not low-level functions. Users shouldn’t even have to know or care about what algorithms are used internally. This is how I’ve always viewed libsodium.</p>

<p>Never breaking the APIs is also something I’m obsessed with. APIs may not be great, and if I could start over from scratch, I would have made them very different, but as a developer, the best APIs are not the most beautifully designed ones, but the ones that you don’t have to worry about because they don’t change and upgrades don’t require any changes in your application either. Libsodium started from the NaCl API, and still adheres to it.</p>

<p>These APIs exposed high-level functions, but also some lower-level functions that high-level functions wrap or depend on. Over the years, people started using these low-level functions directly. Libsodium started to be used as a toolkit of algorithms and low-level primitives.</p>

<p>That made me sad, especially since it is clearly documented that only APIs from builds with <code>--enable-minimal</code> are guaranteed to be tested and stable. But after all, it makes sense. When building custom protocols, having a single portable library with a consistent interface for different functions is far better than importing multiple dependencies, each with their own APIs and sometimes incompatibilities between them.</p>

<p>That’s a lot of code to maintain. It includes features and target platforms I don’t use but try to support for the community. I also maintain a large number of other open source projects.</p>

<p>Still, the security track record of libsodium is pretty good, with zero CVEs in 13 years even though it has gotten a lot of scrutiny.</p>

<p>However, while recently experimenting with adding support for batch signatures, I noticed inconsistent results with code originally written in Zig. The culprit was a check that was present in a function in Zig, but that I forgot to add in libsodium.</p>

<h2 id="the-bug">The bug</h2>

<p>The function <code>crypto_core_ed25519_is_valid_point()</code>, a low-level function used to check if a given elliptic curve point is valid, was supposed to reject points that aren’t in the main cryptographic group, but some points were slipping through.</p>

<h2 id="why-does-this-matter">Why does this matter?</h2>

<p>Edwards25519 is like a special mathematical playground where cryptographic operations happen.</p>

<p>It is used internally for Ed25519 signatures, and includes multiple subgroups of different sizes (order):</p>

<ul>
  <li>Order 1: just the identity (0, 1)</li>
  <li>Order 2: identity + point (0, -1)</li>
  <li>Order 4: 4 points</li>
  <li>Order 8: 8 points</li>
  <li>Order L: the “main subgroup” (L = ~2^252 points) where all operations are expected to happen</li>
  <li>Order 2L, 4L, 8L: very large, but not prime order subgroups</li>
</ul>

<p>The validation function was designed to reject points not in the main subgroup. It properly rejected points in the small-order subgroups, but not points in the mixed-order subgroups.</p>

<h2 id="what-went-wrong-technically">What went wrong technically?</h2>

<p>To check if a point is in the main subgroup (the one of order L), the function multiplies it by L. If the order is L, multiplying any point by L gives the identity point (the mathematical equivalent of zero). So, the code does the multiplication and checks that we ended up with the identity point.</p>

<p>Points are represented by coordinates. In the internal representation used here, there are three coordinates: X, Y, and Z. The identity point is represented internally with coordinates where X = 0 and Y = Z. Z can be anything depending on previous operations; it doesn’t have to be 1.</p>

<p>The old code only checked X = 0. It forgot to verify Y = Z. This meant some invalid points (where X = 0 but Y ≠ Z after the multiplication) were incorrectly accepted as valid.</p>

<p>Concretely: take any main-subgroup point Q (for example, the output of <code>crypto_core_ed25519_random</code>) and add the order-2 point (0, -1), or equivalently negate both coordinates. Every such Q + (0, -1) would have passed validation before the fix, even though it’s not in the main subgroup.</p>

<h2 id="the-fix">The fix</h2>

<p><a href="https://github.com/jedisct1/libsodium/commit/f2da4cd8cb26599a0285a6ab0c02948e361a674a">The fix</a> is trivial and adds the missing check:</p>

<div><div><pre><code><span>// OLD:</span>
<span>return</span> <span>fe25519_iszero</span><span>(</span><span>pl</span><span>.</span><span>X</span><span>);</span>
</code></pre></div></div>

<div><div><pre><code><span>// NEW:</span>
<span>fe25519_sub</span><span>(</span><span>t</span><span>,</span> <span>pl</span><span>.</span><span>Y</span><span>,</span> <span>pl</span><span>.</span><span>Z</span><span>);</span>
<span>return</span> <span>fe25519_iszero</span><span>(</span><span>pl</span><span>.</span><span>X</span><span>)</span> <span>&amp;</span> <span>fe25519_iszero</span><span>(</span><span>t</span><span>);</span>
</code></pre></div></div>

<p>Now it properly verifies both conditions: X must be zero and Y must equal Z.</p>

<h2 id="who-is-affected">Who is affected?</h2>

<p>You may be affected if you:</p>

<ul>
  <li>Use a point release &lt;= <code>1.0.20</code> or a version of <code>libsodium</code> released before December 30, 2025.</li>
  <li>Use <code>crypto_core_ed25519_is_valid_point()</code> to validate points from untrusted sources</li>
  <li>Implement custom cryptography using arithmetic over the Edwards25519 curve</li>
</ul>

<p>But don’t panic. Most users are not affected.</p>

<p>None of the high-level APIs (<code>crypto_sign_*</code>) are affected; they don’t even use or need that function. Scalar multiplication using <code>crypto_scalarmult_ed25519</code> won’t leak anything even if the public key is not on the main subgroup. And public keys created with the regular <code>crypto_sign_keypair</code> and <code>crypto_sign_seed_keypair</code> functions are guaranteed to be on the correct subgroup.</p>

<h2 id="recommendation">Recommendation</h2>

<p>Support for the Ristretto255 group was added to libsodium in 2019 specifically to solve cofactor-related issues. With Ristretto255, if a point decodes, it’s safe. No further validation is required.</p>

<p>If you implement custom cryptographic schemes doing arithmetic over a finite field group, using Ristretto255 is recommended. It’s easier to use, and as a bonus, low-level operations will run faster than over Edwards25519.</p>

<p>If you can’t update libsodium and need an application-level workaround, use the following function:</p>

<div><div><pre><code><span>int</span> <span>is_on_main_subgroup</span><span>(</span><span>const</span> <span>unsigned</span> <span>char</span> <span>p</span><span>[</span><span>crypto_core_ed25519_BYTES</span><span>])</span>
<span>{</span>
    <span>/* l - 1 (group order minus 1) */</span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>char</span> <span>L_1</span><span>[</span><span>crypto_core_ed25519_SCALARBYTES</span><span>]</span> <span>=</span> <span>{</span>
        <span>0xec</span><span>,</span> <span>0xd3</span><span>,</span> <span>0xf5</span><span>,</span> <span>0x5c</span><span>,</span> <span>0x1a</span><span>,</span> <span>0x63</span><span>,</span> <span>0x12</span><span>,</span> <span>0x58</span><span>,</span>
        <span>0xd6</span><span>,</span> <span>0x9c</span><span>,</span> <span>0xf7</span><span>,</span> <span>0xa2</span><span>,</span> <span>0xde</span><span>,</span> <span>0xf9</span><span>,</span> <span>0xde</span><span>,</span> <span>0x14</span><span>,</span>
        <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span>
        <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x10</span>
    <span>};</span>
    <span>/* Identity point encoding: (x=0, y=1) */</span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>char</span> <span>ID</span><span>[</span><span>crypto_core_ed25519_BYTES</span><span>]</span> <span>=</span> <span>{</span>
        <span>0x01</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span>
        <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span>
        <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span>
        <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span>
    <span>};</span>
    <span>unsigned</span> <span>char</span> <span>t</span><span>[</span><span>crypto_core_ed25519_BYTES</span><span>];</span>
    <span>unsigned</span> <span>char</span> <span>r</span><span>[</span><span>crypto_core_ed25519_BYTES</span><span>];</span>
    <span>if</span> <span>(</span><span>crypto_scalarmult_ed25519_noclamp</span><span>(</span><span>t</span><span>,</span> <span>L_1</span><span>,</span> <span>p</span><span>)</span> <span>!=</span> <span>0</span> <span>||</span>
        <span>crypto_core_ed25519_add</span><span>(</span><span>r</span><span>,</span> <span>t</span><span>,</span> <span>p</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>sodium_memcmp</span><span>(</span><span>r</span><span>,</span> <span>ID</span><span>,</span> <span>sizeof</span> <span>ID</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h2 id="fixed-packages">Fixed packages</h2>

<p>This issue was fixed immediately after discovery. All <code>stable</code> packages released after December 30, 2025 include the fix:</p>

<ul>
  <li><a href="https://download.libsodium.org/libsodium/releases/">official tarballs</a></li>
  <li>binaries for Visual Studio</li>
  <li>binaries for MingW</li>
  <li>NuGet packages for all architectures including Android</li>
  <li><code>swift-sodium</code> xcframework (but <code>swift-sodium</code> doesn’t expose low-level functions anyway)</li>
  <li>rust <code>libsodium-sys-stable</code></li>
  <li><code>libsodium.js</code></li>
</ul>

<p>A new point release is also going to be tagged.</p>

<p>If <code>libsodium</code> is useful to you, please keep in mind that it is maintained by one person, for free, in time I could spend with my family or on other projects. The best way to help the project would be to consider <a href="https://opencollective.com/libsodium/contribute">sponsoring it</a>, which helps me dedicate more time to improving it and making it great for everyone, for many more years to come.</p>

  </div>
  
  <!-- JSON-LD for Blog Post -->
  
</article></div>
  </body>
</html>
