<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kubamartin.com/posts/introduction-to-the-jujutsu-vcs/">Original</a>
    <h1>Jujutsu VCS Introduction and Patterns</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p><a href="https://github.com/jj-vcs/jj">Jujutsu</a> (jj), a new version control system written in Rust, has popped up on my radar a few times over the past year. Looked interesting based on a cursory look, but being actually pretty satisfied with Git, and not having major problems with it, I haven’t checked it out.</p><p>That is, until last week, when I finally decided to give it a go! I dived into a couple blog posts for a few of hours, and surprisingly (noting that we’re talking about a VCS) I found myself enjoying it a lot, seeing the consistent design, and overall simplicity it managed to achieve. This post is meant to give you a feel for what’s special about jj, and also describe a few patterns that have been working well for me, and which really are the reason I’m enjoying it.</p><p>Before we dive in, one last thing you should take note of, is that most people use jj with its Git backend. You can use jj with your existing Git repos and reap its benefits in a way that is completely transparent to others you’re collaborating with. Effectively, you can treat it like a Git frontend.</p><h2 id="undo">Undo</h2><p>Before I get to the meat, something that will surely be very useful for any of your experimentation with jj, and something I would’ve loved to have had in Git when I was learning it - you can undo any jj operation using <code>jj undo</code>, and view an operation log using <code>jj operation log</code>.</p><h2 id="changes">Changes</h2><p>Changes are the core primitive you’ll be working with in jj. In Git you had commits, in jj you have changes. A jj change is, however, <em>mutable</em>. A change can be modified. It’s ID, however, is immutable and randomly generated - it stays constant while you iterate on the change. A change refers to a <em>revision</em> (otherwise called a snapshot) which for our purposes is always a Git commit. As you keep working on and modifying a change, the commit SHA it refers to will change.</p><p>So to recap - immutable change IDs, mutable changes, mutable revision IDs (Git SHAs), immutable underlying revisions (snapshots - commits). Changes may eventually be marked as immutable - by default this happens (more or less) when they become part of the main branch or a Git tag.</p><p>While in Git you generally organize your commits in branches, and a commit that’s not part of a branch is scarily called a “detached HEAD”, in jj it’s completely normal to work on changes that are not on branches. <code>jj log</code> is the main command to view the history and tree of changes, and will default to showing you a very reasonable set of changes that should be relevant to you right now - that is (more or less) any local mutable changes, as well as some additional changes for context (like the tip of your main branch).</p><p>Changes in jj <em>can</em> be marked with bookmarks (what jj calls branches), but you’d generally do that only for the purpose of pushing to a remote Git server, like GitHub, not local organization.</p><p>Let’s see a sample of a <code>jj log</code> invocation:</p><pre><span></span><span>@</span>  <span></span><span>w</span><span>twtpovp</span><span> </span><span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="94f9f1d4ffe1f6f5f9f5e6e0fdfabaf7fbf9">[email protected]</a></span><span> </span><span>2025-01-29 23:46:57</span><span> </span><span>6</span><span>dae3649</span><span></span>
│  <span></span><span>(empty)</span><span> </span><span>(no description set)</span><span></span>
<span></span><span>◆</span>  <span></span><span>n</span><span>zvlmkly</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="503d35103b2532313d312224393e7e333f3d">[email protected]</a></span> <span>2025-01-29 23:33:23</span> <span>main</span> <span></span><span>e</span><span>04f25b9</span>
│  add &#39;0000&#39;
│ ○    <span></span><span>u</span><span>knznrnn</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="b2dfd7f2d9c7d0d3dfd3c0c6dbdc9cd1dddf">[email protected]</a></span> <span>2025-01-29 23:43:20</span> <span></span><span>2</span><span>70fa7f9</span>
│ ├─╮  <span>(empty)</span> a merge
│ │ ○  <span></span><span>v</span><span>sosyttm</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="caa7af8aa1bfa8aba7abb8bea3a4e4a9a5a7">[email protected]</a></span> <span>2025-01-29 23:37:52</span> <span>branch-2</span> <span></span><span>35</span><span>8031f0</span>
│ │ │  add &#39;1111&#39;
│ ○ │  <span></span><span>r</span><span>plvonvm</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="a1ccc4e1cad4c3c0ccc0d3d5c8cf8fc2cecc">[email protected]</a></span> <span>2025-01-29 23:37:10</span> <span>branch-1</span> <span></span><span>12</span><span>608854</span>
│ │ │  add &#39;dddd&#39;
│ ○ │  <span></span><span>m</span><span>oquvotw</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="e48981a48f918685898596908d8aca878b89">[email protected]</a></span> <span>2025-01-29 23:36:43</span> <span></span><span>b</span><span>49e6156</span>
├─╯ │  add &#39;cccc&#39;
<span></span><span>◆</span>   │  <span></span><span>p</span><span>lnpvmqs</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="640901240f110605090516100d0a4a070b09">[email protected]</a></span> <span>2025-01-29 23:30:48</span> <span></span><span>3f</span><span>373f8e</span>
├───╯  add &#39;bbbb&#39;
<span></span><span>◆</span>  <span></span><span>l</span><span>ummnokp</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="630e0623081601020e0211170a0d4d000c0e">[email protected]</a></span> <span>2025-01-29 23:30:32</span> <span></span><span>10</span><span>604a80</span>
│  add &#39;aaaa&#39;
~
</pre><p>Quick tip: you can use <a href="https://github.com/theZiz/aha">aha</a> to convert colorized shell output to HTML.</p><p>The IDs on the left side are change IDs, while on the right size you have revisions (commit SHAs). Unique prefixes of those IDs are marked in color, and you can use those prefixes instead of the full form when referring to changes. A change can be reffered to in jj commands by its ID, the underlying commit SHA, or any bookmark referring to it.</p><p>There is one more, slightly crazy, thing about jj changes. Git has a special feature called the Git index to hold any as of yet uncommitted changes (where you <code>git add</code>, and then <code>git commit</code> them). In jj any files you modify are always in the scope of a change. Any modifications you make automatically become part of the current change, which is called the working copy. In the <code>jj log</code> output, this working copy is indicated by the <code>@</code> symbol. You create a new working change using <code>jj new</code> (by default as a child of the current change), and give it a description using <code>jj describe</code> (it starts out having an empty message). You can use <code>jj status</code> to get the metadata of the current change.</p><p>This much said, here’s a quick demo of changing a file as part of a new change.</p><p>Editing a file in a jj repo</p><p><code>jj</code> on its own is an alias for <code>jj log</code>.</p><div><p>Most jj commands default to operating on the current working change, but let you operate on an arbitrary change (or set of changes!) via the <code>--revision / -r</code> flag.</p></div><h3 id="pattern-git-stash">Pattern: git stash</h3><p>This whole thing about the working copy being a Change may sound weird, but it brings with it an important feature - you can operate on the working copy like on any other change. Personally, I’m a frequent user of <code>git stash</code>. When I’m working on something, I often want to pause for a moment and work on / try something else, only to later come back to what I was working on (while leaving that other experiment as yet another stash).</p><p>In jj, I can just <code>jj new @-</code>, which will start a new change from the parent of my current working copy - leaving my working copy as a normal change with all its file modifications “committed”, so I can later come back to it via <code>jj edit</code>.</p><div><p>The <code>-</code> after the <code>@</code> means &#34;go one level up&#34;. It&#39;s basically &#34;take the working copy change, and go to its parent&#34;. We&#39;ll come back to this briefly later, but suffice it to say that there&#39;s a whole sensible expression language here, and <code>@--</code> is similarly valid to refer to your grandparent change.</p></div><h2 id="editing-changes-in-weird-places">Editing Changes in Weird Places</h2><p>Another cool thing about changes is that you can freely edit any mutable change. <code>jj edit &lt;id&gt;</code> lets you “check out” and edit a given change. You can also squish a new change right after another (between it and its children). You can then keep modifying files in the context of that change, and any descendants will automatically be rebased on top of it (with their underlying commit SHAs likely changing, but change IDs staying the same). That sounds a bit scary if you’re used to Git (and dealing with conflicts in the middle of a rebase) but fear not, it’s actually pretty seamless, and we’ll come back to it later.</p><p>You can pass <code>-A</code> and <code>-B</code> to <code>jj new</code> to indicate that you want to squish a new change after, or before, another change.</p><p>With this, when I notice a mistake in a change 3 levels back, I can just <code>jj edit &lt;that-change-id&gt;</code> (with my working copy remaining there for me to come back to), make a fix, which will auto-rebase all following changes (including my original working change), and then <code>jj edit</code> to go back to my original working change.</p><p>Editing previous changes with automatic rebase</p><p>Occasionally you also need to rebase (move) a set of changes onto some change x, you can do that by using <code>jj rebase -s &lt;change-id-to-rebase&gt; -d &lt;destination-change&gt;</code>. The <code>-s</code> will bring all descendants along with the rebased change, and there are other variations of this command for different scenarios. E.g. <code>jj rebase -b &lt;branch&gt; -d &lt;destination-change&gt;</code> will rebase the entire given branch onto a change, and with no arguments it just defaults to <code>-b @</code>, so the current branch. In other words, to rebase the current branch onto main, it’s enough to run <code>jj rebase -d main</code>.</p><h3 id="pattern-squishing-a-fix-before-the-current-change">Pattern: Squishing a Fix Before the Current Change</h3><p>You noticed a mistake in your last change, don’t want to fix it as part of this one, and instead want to squish a fix right before it, but you have already done some “uncommitted” work? Just do <code>jj new -B @</code>. The <code>-B</code> means it’s squished before the current working change (referred to via <code>@</code>), and after the previous one (its parent). After you make the fix, you can go back to the original working change via <code>jj edit @+</code> (<code>+</code> is the opposite of <code>-</code>). You could also make the fix in the original working change and run <code>jj split --interactive</code> to use your favorite diff ui to select what to push down to a separate change placed right before the current one.</p><h2 id="bookmarks">Bookmarks</h2><p>In jj, instead of branches we have bookmarks. You create them using <code>jj bookmark create &lt;name&gt;</code> (abbreviated to <code>jj b c &lt;name&gt;</code>). You update a bookmark to point the current change using <code>jj bookmark set &lt;name&gt;</code>. You track remote bookmarks (which will create local corresponding bookmarks that update on <code>jj git fetch</code>) by doing <code>jj bookmark track &lt;name&gt;</code>.</p><p>When you add changes on top of a change that a bookmark is attached to, the bookmark won’t automatically move to your new change (like it would with a branch in Git), you have to <code>jj bookmark set</code> it manually. You can push bookmarks attached to the current change via <code>jj git push</code>. <code>jj git fetch</code> will fetch updates to bookmarks from your remote (so generally updates to branches).</p><h3 id="pattern-stacked-prs">Pattern: Stacked PRs</h3><p>A common use case with services like GitHub is to split up a big change into multiple PRs, let’s say Multipart 1, Multipart 2 and Multipart 3 (from branches multipart-1, multipart-2, and multipart-3 respectively). Each of them is based on the previous one, so you effectively have the following graph, with bookmark pointers on the way:</p><pre><span></span><span>@</span>  <span></span><span>vq</span><span>noywln</span><span> </span><span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="8fe2eacfe4faedeee2eefdfbe6e1a1ece0e2">[email protected]</a></span><span> </span><span>2025-01-30 18:57:23</span><span> </span><span>50</span><span>e48038</span><span></span>
│  <span></span><span>(empty)</span><span> </span><span>(no description set)</span><span></span>
<span></span><span>◆</span>  <span></span><span>sz</span><span>myonyt</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="016c64416a7463606c607375686f2f626e6c">[email protected]</a></span> <span>2025-01-30 18:47:38</span> <span>main</span> <span></span><span>a7</span><span>9e03bf</span>
│  another change on main
│ ○  <span></span><span>y</span><span>otmyvom</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="7b161e3b100e191a161a090f121555181416">[email protected]</a></span> <span>2025-01-30 18:57:16</span> <span>multipart-3</span> <span></span><span>58</span><span>11d6f6</span>
│ │  add &#39;hhhh&#39;
│ ○  <span></span><span>z</span><span>zxlmyqq</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="86ebe3c6edf3e4e7ebe7f4f2efe8a8e5e9eb">[email protected]</a></span> <span>2025-01-30 18:57:16</span> <span>multipart-2</span> <span></span><span>4</span><span>ca0376a</span>
│ │  add &#39;gggg&#39;
│ ○  <span></span><span>sk</span><span>noxoxv</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="412c24012a3423202c203335282f6f222e2c">[email protected]</a></span> <span>2025-01-30 18:57:16</span> <span></span><span>7</span><span>9356f49</span>
│ │  add &#39;eeee&#39; and &#39;ffff&#39;
│ ○  <span></span><span>vt</span><span>rtywkl</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="1c71795c77697e7d717d6e687572327f7371">[email protected]</a></span> <span>2025-01-30 18:51:08</span> <span>multipart-1</span> <span></span><span>5e</span><span>dec115</span>
│ │  add &#39;cccc&#39; and &#39;dddd&#39; (broken)
│ ○  <span></span><span>ss</span><span>vuqlmr</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="701d15301b0512111d110204191e5e131f1d">[email protected]</a></span> <span>2025-01-30 18:27:29</span> <span></span><span>a5</span><span>9123a7</span>
├─╯  add &#39;aaaa&#39; and &#39;bbbb&#39;
<span></span><span>◆</span>  <span></span><span>n</span><span>nlnvpml</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="375a52775c4255565a5645435e591954585a">[email protected]</a></span> <span>2025-01-30 18:27:03</span> <span></span><span>d</span><span>ee7ba99</span>
│  initial
~
</pre><p>Now let’s say Multipart 1 got reviewed and you need to fix something. In Git, once you add a commit to it (or modify an existing one), you would have to manually rebase all the other branches. Annoying!</p><p>How does jj help us here? We can just run <code>jj edit vt</code> (<code>vt</code> is a unique prefix of the broken change id), or <code>jj new -A vt</code>, make the fix, and run <code>jj git push -b &#34;glob:multipart-*&#34;</code>. Everything will be automatically rebased, and all the bookmarks will be updated and pushed. Effortless!</p><p>Making fixes in stacked PRs</p><h2 id="merges">Merges</h2><p>Merges in jj are pretty boring - in a good way. You just create a change with multiple parents. E.g. <code>jj new x y z</code> will create a change with three parents.</p><h2 id="conflicts">Conflicts</h2><p>One topic I haven’t mentioned yet, and is surely by now giving you an unsettling feeling deep inside about all I’ve said before, are conflicts. With all this rebasing, that’s <strong>got</strong> to become a pain, right? Well, it doesn’t!</p><p>As opposed to Git, where conflicts kind of break your workflow, in the sense that you have to resolve them prior to doing anything else, jj handles conflicts in a first-class manner. A change can just “be conflicted”. You can switch away from a conflicted change, you can create a new change on top of an existing conflicted change (and that will in turn also start out conflicted), you can edit a conflicted change, you can do anything. <code>jj status</code> and <code>jj log</code> will mention the conflict, but it won’t block you.</p><pre><span>~&gt;</span> <span>jj</span><span></span> <span>log</span>
<span></span><span>@</span>    <span></span><span>u</span><span>uxrrmuw</span><span> </span><span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="8ce1e9cce7f9eeede1edfef8e5e2a2efe3e1">[email protected]</a></span><span> </span><span>2025-01-30 19:54:21</span><span> </span><span>d</span><span>7f2700a</span><span> </span><span>conflict</span><span></span>
├─╮  <span>merge</span>
│ ○  <span></span><span>q</span><span>lrwtlny</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="e9848ca9829c8b8884889b9d8087c78a8684">[email protected]</a></span> <span>2025-01-30 19:44:09</span> <span></span><span>c</span><span>ae28ccf</span>
│ │  add &#39;cccc&#39;
○ │  <span></span><span>r</span><span>qtrswmw</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="ed8088ad86988f8c808c9f998483c38e8280">[email protected]</a></span> <span>2025-01-30 19:43:59</span> <span></span><span>5</span><span>6d6ab4a</span>
├─╯  add &#39;bbbb&#39;
○  <span></span><span>k</span><span>nklsqnp</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="a5c8c0e5ced0c7c4c8c4d7d1cccb8bc6cac8">[email protected]</a></span> <span>2025-01-30 19:43:59</span> <span></span><span>1</span><span>0b01706</span>
│  add &#39;aaaa&#39;
<span></span><span>◆</span>  <span></span><span>z</span><span>zzzzzzz</span> <span>root()</span> <span></span><span>0</span><span>0000000</span>
<span>~&gt;</span> <span>jj</span><span></span> <span>status</span>
Working copy changes:
<span>A typescript</span>
<span>There are unresolved conflicts at these paths:</span>
file.txt    <span>2-sided conflict</span>
Working copy : <span></span><span>u</span><span>uxrrmuw</span><span> </span><span>d</span><span>7f2700a</span><span> </span><span>(conflict)</span><span> merge</span>
Parent commit: <span></span><span>r</span><span>qtrswmw</span> <span></span><span>5</span><span>6d6ab4a</span> add &#39;bbbb&#39;
Parent commit: <span></span><span>q</span><span>lrwtlny</span> <span></span><span>c</span><span>ae28ccf</span> add &#39;cccc&#39;
</pre><p>The conflict will be represented in the code via conflict markers:</p><pre>aaaa
&lt;&lt;&lt;&lt;&lt;&lt;&lt; Conflict 1 of 1
%%%%%%% Changes from base to side #1
+bbbb
+++++++ Contents of side #2
cccc
&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conflict 1 of 1 ends
</pre><p>and you can either manually resolve this conflict by editing the code itself, or use <code>jj resolve</code> to bring up your favorite three-way-merge tool (e.g. I’ve configured my jj to bring up a visual conflict resolver in Goland) and resolve it there.</p><p>Once you fix the conflict in a change, all descendants of this change will also cease being conflicted. You could leave a change conflicted and only resolve the conflict in a follow-up child change - that is a completely valid and supported approach.</p><p>Merge conflict resolution</p><h3 id="pattern-working-on-two-things-at-the-same-time">Pattern: Working on Two Things at the Same Time</h3><p>I’ve mentioned stacked PRs, but another situation you might have is working on two independent things in parallel. Let’s say on bookmarks <code>thing-1</code> and <code>thing-2</code>.</p><p>In order to have both things simultaneosuly active in your codebase, you can create a development change via <code>jj new thing-1 thing-2 -m &#34;dev&#34;</code>, that will be a merge between both of them, but will stay local and you’ll never push it (<code>-m</code> just lets you give a description to a change when creating it, without a separate <code>jj describe</code> invocation). You will however <code>jj edit</code> this development change to do your work.</p><pre><span></span><span>@</span>    <span></span><span>zv</span><span>tqnnxv</span><span> </span><span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="b1dcd4f1dac4d3d0dcd0c3c5d8df9fd2dedc">[email protected]</a></span><span> </span><span>2025-01-30 22:42:29</span><span> </span><span>5</span><span>28d6811</span><span></span>
├─╮  <span>dev</span>
│ ○  <span></span><span>zm</span><span>smpynx</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="c6aba386adb3a4a7aba7b4b2afa8e8a5a9ab">[email protected]</a></span> <span>2025-01-30 22:36:26</span> <span>thing-2</span> <span></span><span>2</span><span>55cea26</span>
│ │  changes to file2
○ │  <span></span><span>v</span><span>nxwrykm</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="056860456e706764686477716c6b2b666a68">[email protected]</a></span> <span>2025-01-30 22:35:43</span> <span>thing-1</span> <span></span><span>d</span><span>bcec585</span>
├─╯  changes to file1
○  <span></span><span>p</span><span>uxnvzsm</span> <span><a href="https://kubamartin.com/cdn-cgi/l/email-protection" data-cfemail="98f5fdd8f3edfaf9f5f9eaecf1f6b6fbf7f5">[email protected]</a></span> <span>2025-01-30 22:34:43</span> <span></span><span>0b</span><span>98fe5b</span>
│  initial
<span></span><span>◆</span>  <span></span><span>zz</span><span>zzzzzz</span> <span>root()</span> <span></span><span>00</span><span>000000</span>
</pre><p>Then, whenever you want to move some modifications into one of the branches, you can use <code>jj squash --into &lt;target-change-id&gt; &lt;files&gt;</code> to move all modifications to a set of files down into one of the branches. There’s also <code>--interactive</code> where you can use a diff tool to choose modifications to squash into another change, and finally there’s a <a href="https://jj-vcs.github.io/jj/latest/cli-reference/#jj-absorb">newer <code>jj absorb</code> command</a> which can automate this process in certain scenarios.</p><div><p>Editing files in a merged dev-change and</p></div><p>In conclusion, you can keep working in a local-only merge-change of your branches, and selectively push down any modifications to the relevant branch (This setup would’ve seemed pretty scary before jj, right? I hope it’s a bit less scary now.), and then push just those branches themselves to the remote.</p><h2 id="revset-expressions">Revset Expressions</h2><p>jj commands operate on revisions or sets of revisions (revsets). You can refer to those directly, or use a special expression language to describe them. You’ve seen me refer to a change previously via <code>@-</code>. That was a very simple expression that evaluated to the parent.</p><p>There is, however, much more. There are functions - like <code>parents(x)</code> to get the parents of a change - and operators - like <code>x+</code> to refer to the child of x, or <code>x::</code> for all descendants of x including x.</p><p><code>jj log</code> accepts a revset expression, so you can use it to experiment with them. The default revset it displays is also configurable. Overall, the expression language is powerful and consistent, with simple things being generally easy, and harder things being (presumably, I’ve honestly spent too little time with it) possible.</p><p>See <a href="https://v5.chriskrycho.com/essays/jj-init/#revisions-and-revsets">this article</a> for a much more extensive exploration of the jj expression language, and the <a href="https://jj-vcs.github.io/jj/latest/revsets/">jj docs</a> themselves.</p><h3 id="pattern-partial-stashes">Pattern: Partial Stashes</h3><p>Another kind of stash I occasionally like to do is partial, where I temporarily roll back changes to a set of files to verify the before-after (e.g. confirm that a passing test was failing before).</p><p>In jj the split command works well for this. Just <code>jj split --parallel modifiedFile.txt</code> will move the file into a parallel change. You can do whatever you want to do, and later run <code>jj squash --from parallel_change_id</code> to get the file modifications back into the current change.</p><p>Partial stash using <code>jj split --parallel</code></p><h2 id="setting-up-jj-with-an-existing-git-repo">Setting Up jj with an Existing Git Repo</h2><p>It’s trivial to start using jj with an existing git repo, though I’d advise cloning it fresh into a new directory.</p><p>In a directory where you already have a git repo, you can just run <code>jj git init --colocate</code>. Your <code>.git</code> directory will stay in place, and jj will keep it updated, so e.g. your editor won’t be confused what’s happening. It integrates fairly well, with e.g. the working change - even though it’s backed by a commit - being presented as the git index, so your editor can still show files “modified in this change”.</p><h2 id="should-you-switch">Should You Switch?</h2><p>The cost of switching is low, as it integrates seamlessly with your existing workflow. It frankly also takes a day tops to get used to, and there’s something to be said for using <em>nice</em> things. Sure, you can make excellent tea in any food-safe kettle, but if you have a nice tea kettle, you’ll enjoy it every time you make tea. I use my vcs quite a lot, so why not make that pleasant too?</p><h2 id="conclusion">Conclusion</h2><p>I hope the above gave you an intuition for what Jujutsu, the VCS, is all about, and ideally even encouraged you to take a look at it.</p><p>If you’d like to do some more readings about jj, I’ve used the below articles and guides when learning it, and a lot of what I wrote above is inspired by parts of them. Check them out!</p><ul><li><a href="https://v5.chriskrycho.com/essays/jj-init">https://v5.chriskrycho.com/essays/jj-init</a></li><li><a href="https://neugierig.org/software/blog/2024/12/jujutsu.html">https://neugierig.org/software/blog/2024/12/jujutsu.html</a></li><li><a href="https://tonyfinn.com/blog/jj/">https://tonyfinn.com/blog/jj/</a></li><li><a href="https://steveklabnik.github.io/jujutsu-tutorial/">https://steveklabnik.github.io/jujutsu-tutorial/</a></li><li><a href="https://v5.chriskrycho.com/journal/jujutsu-megamerges-and-jj-absorb/">https://v5.chriskrycho.com/journal/jujutsu-megamerges-and-jj-absorb/</a></li></ul><p>Finally, I of course recommend just reading the docs: <a href="https://jj-vcs.github.io/jj/latest/">https://jj-vcs.github.io/jj/latest/</a></p></div></article></div></div>
  </body>
</html>
