<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.daily.co/blog/building-voice-agents-with-nvidia-open-models/">Original</a>
    <h1>Building voice agents with Nvidia open models</h1>
    
    <div id="readability-page-1" class="page"><div>
        <h2 id="how-to-build-ultra-low-latency-voice-agents-with-nvidia-cache-aware-streaming-asr">How to Build Ultra-low-latency Voice Agents With NVIDIA Cache-aware Streaming ASR</h2><p><em>This post accompanies the launch of </em><a href="https://huggingface.co/nvidia/nemotron-speech-streaming-en-0.6b"><em><u>NVIDIA Nemotron Speech ASR</u></em></a> on Hugging Face. Read the full model announcement <a href="https://huggingface.co/blog/nvidia/nemotron-speech-asr-scaling-voice-agents" rel="noreferrer">here</a>.</p><p>In this post, we’ll build a voice agent using three NVIDIA open models:</p><ul><li><a href="https://huggingface.co/nvidia/nemotron-speech-streaming-en-0.6b"><u>The new Nemotron Speech ASR model</u></a></li><li><a href="https://build.nvidia.com/nvidia/nemotron-3-nano-30b-a3b/modelcard"><u>Nemotron 3 Nano LLM</u></a></li><li>A preview checkpoint of the upcoming <a href="https://huggingface.co/nvidia/magpie_tts_multilingual_357m"><u>NVIDIA Magpie text-to-speech model</u></a></li></ul><p>This voice agent leverages the new streaming ASR model, Pipecat’s low-latency voice agent building blocks, and some fun code experiments to optimize all three models for very fast response times.</p><figure><iframe width="200" height="113" src="https://www.youtube.com/embed/8Fkz2PC54BI?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="" title="Building Ultra-Fast Voice Agents"></iframe></figure><p>All the code for the post is <a href="https://github.com/pipecat-ai/nemotron-january-2026/" rel="noreferrer">here in this GitHub repository</a>.</p><figure><img src="https://www.daily.co/blog/content/images/2026/01/Screenshot-2026-01-05-at-3.55.09---PM.png" alt="" loading="lazy" width="2000" height="1451" srcset="https://www.daily.co/blog/content/images/size/w600/2026/01/Screenshot-2026-01-05-at-3.55.09---PM.png 600w, https://www.daily.co/blog/content/images/size/w1000/2026/01/Screenshot-2026-01-05-at-3.55.09---PM.png 1000w, https://www.daily.co/blog/content/images/size/w1600/2026/01/Screenshot-2026-01-05-at-3.55.09---PM.png 1600w, https://www.daily.co/blog/content/images/2026/01/Screenshot-2026-01-05-at-3.55.09---PM.png 2184w" sizes="(min-width: 720px) 720px"/></figure><p>You can clone the repo and run this voice agent:</p><ul><li>Scalably for multi-user workloads on the Modal cloud platform.</li><li>On an NVIDIA DGX Spark or RTX 5090 for single-user, local development and experimentation.</li></ul><p>Feel free to just jump over to the code. Or read on for technical notes about building fast voice agents and the NVIDIA open models.</p><p>Voice agent deployments are growing by leaps and bounds across a wide range of use cases. For example, we’re seeing voice agents used at scale today in:</p><ul><li>Customer support</li><li>Answering the phone for small businesses (for example, restaurants)</li><li>User research</li><li>Outbound phone calls to prepare patients for healthcare appointments</li><li>Validation workflows for loan applications</li><li>And many, many other scenarios</li></ul><p>Both startups and large, established companies are building voice agents that are successful in real-world deployments. The best voice agents today achieve very high “task completed” success metrics and customer satisfaction scores.</p><h2 id="voice-ai-architecture">Voice AI architecture</h2><p>As is the case with everything in AI, voice agent technology is evolving rapidly. Today, there are two ways to build voice agents.</p><ol><li>Most production voice agents use specialized models together in a pipeline – a speech-to-text model, a text-mode LLM, and a text-to-speech model.</li><li>Voice agent developers are beginning to experiment with new <em>speech-to-speech</em> models that take voice input directly and output audio instead of text.</li></ol><figure><img src="https://www.daily.co/blog/content/images/2026/01/image-voice-ai-architecture-3.png" alt="" loading="lazy" width="1920" height="1080" srcset="https://www.daily.co/blog/content/images/size/w600/2026/01/image-voice-ai-architecture-3.png 600w, https://www.daily.co/blog/content/images/size/w1000/2026/01/image-voice-ai-architecture-3.png 1000w, https://www.daily.co/blog/content/images/size/w1600/2026/01/image-voice-ai-architecture-3.png 1600w, https://www.daily.co/blog/content/images/2026/01/image-voice-ai-architecture-3.png 1920w" sizes="(min-width: 720px) 720px"/><figcaption><span>On the left, a block diagram of a voice agent that uses a “pipeline” of specialized AI models. On the right, a voice agent built with a speech-to-speech LLM.</span></figcaption></figure><p>Using three specialized models is currently the best approach for enterprise use cases that require the highest degree of model intelligence and flexibility. But speech-to-speech models are an exciting development and will be a big part of the future of voice AI.</p><p>Whether we use a pipeline or a unified speech-to-speech model, voice agents are doing more and more sophisticated tasks. This means that, increasingly, production voice agents are actually multi-agent systems. Inside an agent, sub-agents handle asynchronous tasks, manage the conversation context, and allow code re-use between text and voice agents.</p><figure><img src="https://www.daily.co/blog/content/images/2026/01/image-multi-agent-diagram-2.png" alt="" loading="lazy" width="1920" height="1080" srcset="https://www.daily.co/blog/content/images/size/w600/2026/01/image-multi-agent-diagram-2.png 600w, https://www.daily.co/blog/content/images/size/w1000/2026/01/image-multi-agent-diagram-2.png 1000w, https://www.daily.co/blog/content/images/size/w1600/2026/01/image-multi-agent-diagram-2.png 1600w, https://www.daily.co/blog/content/images/2026/01/image-multi-agent-diagram-2.png 1920w" sizes="(min-width: 720px) 720px"/><figcaption><span>A voice agent that is a multi-agent system under the covers. This agent uses tool calls to start long-running tasks that stream structured data into the context of the voice conversation.</span></figcaption></figure><p>For a deep dive into voice agent architectures, models, and infrastructure, see the <a href="https://voiceaiandvoiceagents.com/"><u>Voice AI &amp; Voice Agents Illustrated Primer</u></a>.</p><h2 id="open-source-models">Open source models</h2><p>Open models have not been widely used for production voice agents.</p><p>Voice agents are among the most demanding AI use cases. Voice agents perform long conversations. They must operate on noisy input audio and respond very quickly. Enterprise voice agent use cases require highly accurate instruction following and function calling. People interacting with voice agents have very high expectations for naturalness and “human-like” qualities of voice audio. In all of these areas, proprietary AI models have performed better than open models.</p><p>However, this is changing. Nemotron Speech ASR is both fast and accurate. On our benchmarks it performs comparably with or better than commercial speech-to-text models used today in production voice agents. Nemotron 3 Nano is the best-performing LLM in its class on our long-context, multi-turn conversation benchmarks.</p><p>Using open models allows us to configure and customize our models and inference stacks for the specific needs of our voice agents in ways that we can’t do with proprietary models. We can optimize for latency, fine-tune on our own data, host inference within our VPCs to satisfy data privacy and regulatory requirements, and implement observability that allows us to deliver the highest levels of reliability, scalability, and consistency.</p><p>We expect open models to be used in a larger and larger proportion of voice agent deployments over time. There are various flavors of “open” model licenses. NVIDIA has made the Nemotron Speech ASR and Nemotron 3 Nano available under the <a href="https://www.nvidia.com/en-us/agreements/enterprise-software/nvidia-nemotron-open-model-license/" rel="noreferrer">NVIDIA Permissive Open-Model License</a>, which allows for unrestricted commercial use and the creation of derivative works.</p>
<!--kg-card-begin: html-->
<p><img src="https://www.daily.co/blog/content/images/2026/01/image-ultra-fast-voice-agent.png" alt="The models we are using in this open source voice agent.
"/>
</p>

<!--kg-card-end: html-->
<h2 id="fast-streaming-transcription">Fast, streaming transcription</h2><p>The Nemotron Speech ASR model is designed specifically for use cases that demand very low latency transcription, such as voice agents.</p><p>The headline number here is that Nemotron Speech ASR consistently delivers final transcripts in under 24ms!</p><p>ASR (Automatic Speech Recognition) is the general term for machine learning models that process speech input, then output text and other information about that speech. Previous generations of ASR models were generally designed for batch processing rather than realtime transcription. For example, the latency of the Whisper model is 600-800ms, and most commercial speech-to-text models today have latencies in the 200-400ms range.</p><table>
<thead>
<tr>
<th>Model</th>
<th>Openness</th>
<th>Deployment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parakeet</td>
<td>open weights, open training data, open source inference</td>
<td>local in-cluster</td>
</tr>
<tr>
<td>Widely used commercial ASR</td>
<td>proprietary</td>
<td>cloud</td>
</tr>
<tr>
<td>Whisper Large V3</td>
<td>open weights, open source inference</td>
<td>local in-cluster</td>
</tr>
</tbody>
</table>
<p>For more about the cache-aware architecture that enables this impressively low latency, see the <a href="https://huggingface.co/blog/nvidia/nemotron-speech-asr-scaling-voice-agents" rel="noreferrer">NVIDIA post announcing the new model</a>.</p><p>The model is also very accurate. The industry standard for measuring ASR model accuracy is <em>word error rate.</em> Nemotron Speech ASR has a word error rate on all of our benchmarks roughly equivalent to the best commercial ASR models, and substantially better than previous generation open models like Whisper.</p><p>To integrate Nemotron Speech ASR into Pipecat, we created a <a href="https://github.com/pipecat-ai/nemotron-january-2026/blob/main/src/nemotron_speech/server.py" rel="noreferrer">WebSocket server</a> that performs the transcription inference and a <a href="https://github.com/pipecat-ai/nemotron-january-2026/blob/main/pipecat_bots/nvidia_stt.py" rel="noreferrer">client-side Pipecat service</a> that can be used in any Pipecat agent.</p><figure><img src="https://www.daily.co/blog/content/images/2026/01/image-ASR-Server.png" alt="" loading="lazy" width="1920" height="1080" srcset="https://www.daily.co/blog/content/images/size/w600/2026/01/image-ASR-Server.png 600w, https://www.daily.co/blog/content/images/size/w1000/2026/01/image-ASR-Server.png 1000w, https://www.daily.co/blog/content/images/size/w1600/2026/01/image-ASR-Server.png 1600w, https://www.daily.co/blog/content/images/2026/01/image-ASR-Server.png 1920w" sizes="(min-width: 720px) 720px"/><figcaption><span>ASR server architecture showing a streaming transcription pipeline. Audio enters through a WebSocket handler, flows to an audio accumulator, then to a mel-spectrogram preprocessor, followed by a streaming encoder. The encoded output is decoded using a greedy decoder to produce transcript output. A reset signal can be sent from the WebSocket handler directly to the decoder.</span></figcaption></figure><h2 id="running-turn-detection-in-parallel-with-transcription">Running turn detection in parallel with transcription</h2><p>The Nemotron Speech ASR model can be configured with four different context sizes, each of which have different latency/accuracy trade-offs. The context sizes are 80ms, 160ms, 560ms, and 1.2s. We use the 160ms context size, because this aligns with how we perform turn detection.</p><p>Turn detection means determining when the user has stopped speaking and the voice agent should respond. Accurate turn detection is critical to natural conversation. We’re using the open source <a href="https://github.com/pipecat-ai/smart-turn" rel="noreferrer">Pipecat Smart Turn model</a> in this voice agent. The Smart Turn model operates on input audio and runs in parallel with the Nemotron Speech ASR transcription.</p><p>We trigger both turn detection and transcript finalization any time we see a 200ms pause in the user’s speech. This gives us 200ms of “non-speech” trailing context after the user’s speech has finished. The Nemotron Speech ASR model actually needs a bit more trailing silence than this, to properly finalize the last words in the user speech. The padding calculation is:</p><pre><code>nemotron_final_padding = (right_context + 1) * shift_frames * hop_samples
    = (1 + 1) * 16 * 160
    = 5120 samples = 320ms
</code></pre>
<p>Our WebSocket transcription server receives 200ms of “non-speech” trailing audio data from the Pipecat service, and adds 120ms of synthetic silence to enable immediate finalization of the transcript. This works nicely.</p><figure><img src="https://www.daily.co/blog/content/images/2026/01/image-voice-activity-detection-timing.png" alt="" loading="lazy" width="1920" height="1080" srcset="https://www.daily.co/blog/content/images/size/w600/2026/01/image-voice-activity-detection-timing.png 600w, https://www.daily.co/blog/content/images/size/w1000/2026/01/image-voice-activity-detection-timing.png 1000w, https://www.daily.co/blog/content/images/size/w1600/2026/01/image-voice-activity-detection-timing.png 1600w, https://www.daily.co/blog/content/images/2026/01/image-voice-activity-detection-timing.png 1920w" sizes="(min-width: 720px) 720px"/></figure><h2 id="nemotron-3-nano">Nemotron 3 Nano</h2><p>Nemotron 3 Nano is a new 30 billion parameter open source LLM from NVIDIA. Nemotron 3 Nano is the best performing model in its size class on our multi-turn conversation benchmarks.</p>
<!--kg-card-begin: html-->

<table>
<thead>
  <tr>
    <th>Model</th>
    <th>Tool Use</th>
    <th>Instruction</th>
    <th>KB Ground</th>
    <th>Pass Rate</th>
    <th>Median Rate</th>
    <th>TTFB Med</th>
    <th>TTFB P95</th>
    <th>TTFB Max</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>gpt-5.1</td>
    <td>300/300</td>
    <td>300/300</td>
    <td>300/300</td>
    <td>100.0%</td>
    <td>100.0%</td>
    <td>916ms</td>
    <td>2011ms</td>
    <td>5216ms</td>
  </tr>
  <tr>
    <td>gemini-3-flash-preview</td>
    <td>300/300</td>
    <td>300/300</td>
    <td>300/300</td>
    <td>100.0%</td>
    <td>100.0%</td>
    <td>1193ms</td>
    <td>1635ms</td>
    <td>6653ms</td>
  </tr>
  <tr>
    <td>claude-sonnet-4-5</td>
    <td>300/300</td>
    <td>300/300</td>
    <td>300/300</td>
    <td>100.0%</td>
    <td>100.0%</td>
    <td>2234ms</td>
    <td>3062ms</td>
    <td>5438ms</td>
  </tr>
  <tr>
    <td>gpt-4.1</td>
    <td>283/300</td>
    <td>273/300</td>
    <td>298/300</td>
    <td>94.9%</td>
    <td>97.8%</td>
    <td>683ms</td>
    <td>1052ms</td>
    <td>3860ms</td>
  </tr>
  <tr>
    <td>gemini-2.5-flash</td>
    <td>275/300</td>
    <td>268/300</td>
    <td>300/300</td>
    <td>93.7%</td>
    <td>94.4%</td>
    <td>594ms</td>
    <td>1349ms</td>
    <td>2104ms</td>
  </tr>
  <tr>
    <td>gpt-5-mini</td>
    <td>271/300</td>
    <td>272/300</td>
    <td>289/300</td>
    <td>92.4%</td>
    <td>95.6%</td>
    <td>6339ms</td>
    <td>17845ms</td>
    <td>27028ms</td>
  </tr>
  <tr>
    <td>gpt-4o-mini</td>
    <td>271/300</td>
    <td>262/300</td>
    <td>293/300</td>
    <td>91.8%</td>
    <td>92.2%</td>
    <td>760ms</td>
    <td>1322ms</td>
    <td>3256ms</td>
  </tr>
  <tr>
    <td>nemotron-3-nano-30b-a3b*</td>
    <td>287/304</td>
    <td>286/304</td>
    <td>298/304</td>
    <td>91.4%</td>
    <td>93.3%</td>
    <td>171ms</td>
    <td>199ms</td>
    <td>255ms</td>
  </tr>
  <tr>
    <td>gpt-4o</td>
    <td>278/300</td>
    <td>249/300</td>
    <td>294/300</td>
    <td>91.2%</td>
    <td>95.6%</td>
    <td>625ms</td>
    <td>1222ms</td>
    <td>13378ms</td>
  </tr>
  <tr>
    <td>gpt-oss-120b (groq)</td>
    <td>272/300</td>
    <td>270/300</td>
    <td>298/300</td>
    <td>89.3%</td>
    <td>90.0%</td>
    <td>98ms</td>
    <td>226ms</td>
    <td>2117ms</td>
  </tr>
  <tr>
    <td>gpt-5.2</td>
    <td>224/300</td>
    <td>228/300</td>
    <td>250/300</td>
    <td>78.0%</td>
    <td>92.2%</td>
    <td>819ms</td>
    <td>1483ms</td>
    <td>1825ms</td>
  </tr>
  <tr>
    <td>claude-haiku-4-5</td>
    <td>221/300</td>
    <td>172/300</td>
    <td>299/300</td>
    <td>76.9%</td>
    <td>75.6%</td>
    <td>732ms</td>
    <td>1334ms</td>
    <td>4654ms</td>
  </tr>
</tbody>
</table><p>

[*] Nemotron 3 Nano hosted locally in-cluster on Blackwell GPUs
</p><!--kg-card-end: html-->
<p>Like Nemotron Speech ASR, Nemotron 3 Nano is part of a new generation of open models that are designed specifically for speed and inference efficiency. See <a href="https://research.nvidia.com/labs/nemotron/Nemotron-3/"><u>this resource from NVIDIA research</u></a> for an overview of the Nemotron 3 hybrid Mamba-Transformer MoE architecture and links to technical papers.</p><p>A 30B parameter model is small enough to run <em>very</em> fast on high-end hardware, and can be quantized to run well on GPUs that many developers have at home!</p><table>
<thead>
<tr>
<th>Model variant</th>
<th>Deployment</th>
<th>Resident memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nemotron-3-Nano BF16</td>
<td>full weights, Modal Cloud or DGX Spark</td>
<td>72GB</td>
</tr>
<tr>
<td>Nemotron-3-Nano Q8</td>
<td>8-bit quantization, faster operation on DGX Spark</td>
<td>32GB</td>
</tr>
<tr>
<td>Nemotron-3-Nano Q4</td>
<td>4-bit quantization, RTX 5090</td>
<td>24GB</td>
</tr>
</tbody>
</table>
<p>One note on which LLMs are generally used today for production voice agents: in general, voice agents for applications like customer support need the most “intelligent” models we have available. Voice agent use cases are demanding. A customer support AI agent must do highly accurate instruction following and function calling tasks throughout a long, open-ended, unpredictable human conversation. A 30B parameter model – even one as good as Nemotron 3 Nano – is generally best suited for specialized voice tasks like a home assistant or software voice UI interface.</p><p>NVIDIA has announced that two larger Nemotron 3 models are coming soon. If the performance of these larger models relative to their size is similar to Nemotron 3 Nano’s performance, we expect these models to be terrific intelligence engines for voice agents.</p><p>In the meantime, Nemotron 3 Nano is the best-performing LLM that I can run on hardware I have at home. I’ve been using this model for a wide variety of “local” voice agent tasks and development experiments on both an <a href="https://www.nvidia.com/en-us/products/workstations/dgx-spark/" rel="noreferrer">NVIDIA DGX Spark</a> and on my desktop computer with an <a href="https://www.nvidia.com/en-us/geforce/graphics-cards/50-series/rtx-5090/" rel="noreferrer">RTX 5090</a>.</p><p>You can use Nemotron 3 in reasoning or non-reasoning mode. We usually turn off reasoning for the fast-response core voice agent loop. </p><p>For details on using Nemotron 3 Nano in the cloud and building local containers with the latest CUDA, vLLM and llama.cpp support for this new model, see the <a href="https://github.com/pipecat-ai/nemotron-january-2026/" rel="noreferrer">GitHub repository</a> accompanying this post. There are a couple of inference tooling patches (relating to the reasoning output format in vLLM and to llama.cpp KV caching) that you might find useful if you’re experimenting with this model.</p><h2 id="magpie-streaming-server">Magpie streaming server</h2><p>Magpie is <a href="https://developer.nvidia.com/blog/enhancing-multilingual-human-like-speech-and-voice-cloning-with-nvidia-riva-tts/"><u>a family of text-to-speech</u></a> models from NVIDIA. In our voice agent project, we’re using an experimental preview checkpoint of an upcoming open source version of Magpie.</p><p>Kudos to NVIDIA for releasing this early look at a Magpie model designed, like Nemotron Speech ASR, for streaming, low-latency use cases! We’ve been having a lot of fun experimenting with this preview, doing things that are only possible with open source weights and inference code.</p><p>You can use this Magpie model in batch mode by sending an HTTP request with a chunk of text. This batch mode inference delivers audio for a single sentence in about 600ms on the DGX Spark and 300ms on the RTX 5090. But for voice agents, we like to stream all tokens as much as we can, and because Magpie is open source, we can hack together a hybrid streaming mode that optimizes for initial audio chunk latency! This hybrid streaming approach improves average initial response latency 3x.</p><h3 id="tts-ttfb-comparison-batch-%E2%86%92-streaming">TTS TTFB Comparison: Batch → Streaming</h3>
<table>
<thead>
<tr>
<th>Hardware</th>
<th>P50 Improvement</th>
<th>Mean Improvement</th>
<th>P90 Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTX 5090</td>
<td>90 ms  (1.9x)</td>
<td>204 ms (3.0x)</td>
<td>430 ms  (5.2x)</td>
</tr>
<tr>
<td>DGX Spark</td>
<td>236 ms (2.3x)</td>
<td>415 ms (3.3x)</td>
<td>836 ms  (4.6x)</td>
</tr>
</tbody>
</table>
<h3 id="details">Details</h3>
<h5 id="rtx-5090">RTX 5090</h5>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Min</th>
<th>Max</th>
<th>P50</th>
<th>P90</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>Batch</td>
<td>106 ms</td>
<td>630 ms</td>
<td>191 ms</td>
<td>533 ms</td>
<td>305 ms</td>
</tr>
<tr>
<td>Pipeline</td>
<td>99 ms</td>
<td>103 ms</td>
<td>101 ms</td>
<td>103 ms</td>
<td>101 ms</td>
</tr>
</tbody>
</table>
<h5 id="dgx-spark">DGX Spark</h5>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Min</th>
<th>Max</th>
<th>P50</th>
<th>P90</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>Batch</td>
<td>193 ms</td>
<td>1440 ms</td>
<td>422 ms</td>
<td>1067 ms</td>
<td>595 ms</td>
</tr>
<tr>
<td>Pipeline</td>
<td>15 ms</td>
<td>276 ms</td>
<td>186 ms</td>
<td>231 ms</td>
<td>180 ms</td>
</tr>
</tbody>
</table>
<p>There’s definitely a quality trade-off with our simple streaming implementation. Try the agent yourself, or listen carefully to the conversation in the video at the beginning of this blog post. You can usually hear a slight disfluency where we “stitch” together the streaming chunks at the beginning of the model response.</p><p>To do better, we’d need to retrain part of the model and use a slightly more sophisticated inference approach. Fortunately, this is on the NVIDIA road map.</p><p>We integrated this model into Pipecat by creating a WebSocket server for streaming inference, and a client-side Pipecat service. (This is the same approach we used with Nemotron Speech ASR). </p><h2 id="putting-the-models-together-and-measuring-latency">Putting the models together and measuring latency</h2><p>These Nemotron and upcoming Magpie models are completely open: open weights, open source training data sets, and open source inference tooling. Working with open models in production feels like a super-power. We can do things like:</p><ul><li>Read the inference code to understand the context requirements of the ASR model, so that we can optimize the interactions between our Pipecat pipeline components and text-to-speech audio buffer handling. (See our description of this above, in the section <strong>Fast, streaming transcription</strong>.</li><li>Fix issues with inference tooling support in new models and on whatever platforms we’re running on. See the code and README.md in the <a href="https://github.com/pipecat-ai/nemotron-january-2026/" rel="noreferrer">GitHub repo</a> for the small patches we made for vLLM and llama.cpp, and the Docker container build with full MX4FP support for both of those inference servers on DGX Spark and RTX 5090.</li><li>Build a semi-streaming inference server for a preview model checkpoint.</li></ul><p>Often when we’re building voice agents, our primary concern is to engineer the agent to respond quickly in a real-world conversation. The difference between good latency and an agent too slow to use in production is often a combination of several optimizations, each one cutting peak latencies by 100 or 200ms. Working with open models gives us control over how we prioritize for latency compared to throughput, how we design streaming and chunking of inference results, how to use models together optimally, and many other small things that add up (or subtract down) to fast response times.</p><p>It’s useful to measure voice-to-voice latency – the time between the user’s voice stopping and the bot’s voice response starting – in two places: on the server-side and at the client.</p><p>We can easily automate the server-side latency measurement. Our bot outputs a log line with a voice-to-voice latency metric for each turn.</p><pre><code>2026-01-01 22:43:26.208 | INFO     | v2v_metrics:process_frame:54 - V2VMetrics: ServerVoiceToVoice TTFB: 465ms
</code></pre>
<p>We also output log lines with time-to-first-byte for each of our models, and several other log lines that are useful for understanding exactly where we’re “spending our latency budget.” The Pipecat Playground shows graphs of these metrics, which is useful during development and testing. Here’s a test session with our bot running on an RTX 5090.</p>
<!--kg-card-begin: html-->
<p><img src="https://www.daily.co/blog/content/images/2026/01/image-pipecat-playground-screenshot-800px.png"/>
</p>
<!--kg-card-end: html-->
<p><strong>RTX 5090</strong></p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Min</th>
<th>P50</th>
<th>P90</th>
<th>Max</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASR</td>
<td>13ms</td>
<td>19ms</td>
<td>23ms</td>
<td>70ms</td>
</tr>
<tr>
<td>LLM</td>
<td>71ms</td>
<td>171ms</td>
<td>199ms</td>
<td>255ms</td>
</tr>
<tr>
<td>TTS</td>
<td>99ms</td>
<td>108ms</td>
<td>113ms</td>
<td>146ms</td>
</tr>
<tr>
<td>V2V</td>
<td>415ms</td>
<td>508ms</td>
<td>544ms</td>
<td>639ms</td>
</tr>
</tbody>
</table>
<p><strong>DGX Spark</strong></p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Min</th>
<th>P50</th>
<th>P90</th>
<th>Max</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASR</td>
<td>24ms</td>
<td>27ms</td>
<td>69ms</td>
<td>122ms</td>
</tr>
<tr>
<td>LLM</td>
<td>343ms</td>
<td>750ms</td>
<td>915ms</td>
<td>1669ms</td>
</tr>
<tr>
<td>TTS</td>
<td>158ms</td>
<td>185ms</td>
<td>204ms</td>
<td>1171ms</td>
</tr>
<tr>
<td>V2V</td>
<td>759ms</td>
<td>1180ms</td>
<td>1359ms</td>
<td>2981ms</td>
</tr>
</tbody>
</table>
<p>It’s also critical to measure the voice-to-voice latency as actually perceived by the user. This is harder to do automatically, especially for telephone call voice agents. The best approach to measuring client-side voice-to-voice latency is to record a call, load the audio file into an audio editor, and measure the gap between the end of the user’s speech waveform and the start of the bot speech waveform. You can’t cheat this measurement, or forget to include an important processing component! We do this periodically in both development and testing, as a sanity check. Here I’m measuring latency in the Descript editor of one turn in the conversation we recorded for the video at the top of this post.</p>
<!--kg-card-begin: html-->
<p><img src="https://www.daily.co/blog/content/images/2026/01/Screenshot-2026-01-03-at-2.55.10---PM.png"/>
</p>
<!--kg-card-end: html-->
<p>You will typically see client-side voice-to-voice latency numbers about 250ms higher than server-side numbers for a WebRTC voice agent. This is time spent in audio processing at the operating system level, encoding and decoding, and network transport. Usually, this delta is a bit worse for telephone call agents: 300-600ms of extra latency in the telephony path that you don’t have much way to optimize. (Though there are some basic things you should do, such as make sure your voice agent is hosted in the same region as your telephony providers servers.) For more on latency, see the <a href="https://voiceaiandvoiceagents.com/#core-tech"><u>Voice AI and Voice Agents Illustrated Guide</u></a>.</p><h2 id="an-inference-optimization-for-local-voice-agents">An inference optimization for local voice agents</h2><p>We have one more trick up our sleeve when we’re running voice agents locally on a single GPU.</p><p>When we run voice agents in production in the cloud, we run each AI model on a dedicated GPU. We stream tokens from each model as fast as we can, and send them down the Pipecat pipeline as they arrive. </p><p>But when we’re running locally, all the models are sharing one GPU. In this context, we can engineer much faster voice-to-voice responses if we carefully schedule inference. In our voice agent for this project, we’re doing two things:</p><ol><li>We run the Smart Turn model on the CPU so that we can dedicate the GPU to transcription when user speech is arriving. The Smart Turn model runs <em>faster</em> on GPU, but it runs <em>fast enough</em> on CPU, and dividing up the workload this way gives us the best possible performance between the two models.</li><li>We interleave small segments of LLM and TTS inference so that GPU resources are dedicated to one model at a time. This significantly reduces time-to-first-token for each model. First we generate a few small chunks of LLM tokens, then TTS audio, then LLM again, then TTS, etc. We generate a smaller segment for the very first response, so we can start audio playout as quickly as possible. We designed this interleaved chunking approach to work in concert with the hybrid Magpie streaming hack described above.</li></ol><p>Here’s a sequence diagram showing the interleaved LLM and TTS inference. The three vertical lines in the diagram represent, from left to right:</p><ol><li>Tokens arriving in small batches to the Pipecat LLM service in the agent and being pushed down the pipeline.</li><li>The Pipecat TTS service, managing the frames from the LLM service, dividing the stream on sentence boundaries, and making inference requests to the Magpie WebSocket server running in our local Docker container.</li><li>The Magpie WebSocket server doing inference and sending back audio.</li></ol><p>We wrote a custom WebSocket inference server for Magpie, so we control the Pipecat-to-Magpie protocol completely. We’re using <a href="https://github.com/ggerganov/llama.cpp/tree/master/examples/server">llama-server</a> code from the <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> project for LLM inference. Traditional inference stacks aren’t really designed to do this specific kind of chunking, so our code sets a max tokens count (<code>n_predict</code> in llama.cpp), runs repeated small inference chunks, and does some of the buffer management client-side. This could be done more efficiently, using the llama.cpp primitives directly. Writing a perfectly optimized inference server for this interleaved design would be a fun weekend project, and is something that almost anyone with a little bit of programming experience and a willingness to go down some rabbit holes could work together with Claude Code to implement.</p>
<figure><img src="https://www.daily.co/blog/content/images/2026/01/image-Streaming-LLM_TTS-Timing-Diagram.png" alt="" loading="lazy" width="1920" height="4285" srcset="https://www.daily.co/blog/content/images/size/w600/2026/01/image-Streaming-LLM_TTS-Timing-Diagram.png 600w, https://www.daily.co/blog/content/images/size/w1000/2026/01/image-Streaming-LLM_TTS-Timing-Diagram.png 1000w, https://www.daily.co/blog/content/images/size/w1600/2026/01/image-Streaming-LLM_TTS-Timing-Diagram.png 1600w, https://www.daily.co/blog/content/images/2026/01/image-Streaming-LLM_TTS-Timing-Diagram.png 1920w" sizes="(min-width: 720px) 720px"/></figure><p>For enterprise-scale, production use, deploy this agent to the Modal GPU cloud. There are instructions in the <a href="https://github.com/pipecat-ai/nemotron-january-2026/" rel="noreferrer">GitHub Readme.md</a>. Modal is a serverless GPU platform that makes it easy to deploy AI models for development or production use.</p><p>For local development, the <a href="https://github.com/pipecat-ai/nemotron-january-2026/" rel="noreferrer">GitHub repo</a> has a Dockerfile for DGX Spark (arm64 + Blackwell GB10 CUDA 13.1) and RTX 5090 (x86_64 + Blackwell CUDA 13.0)</p><p>If you’re interested in building voice agents, here are some resources you might be interested in:</p><ul><li><a href="https://voiceaiandvoiceagents.com/"><u>Voice AI &amp; Voice Agents Illustrated Primer</u></a></li><li>YouTube recordings of the <a href="https://www.youtube.com/playlist?list=PLzU2zoMTQIHjMPZ-OnpC3ozZs3bp3kIUs"><u>community voice agents course sessions</u></a> from last year</li><li>The <a href="https://discord.com/invite/pipecat"><u>Pipecat Discord</u></a>, where lots of knowledgeable voice agent developers hang out.</li></ul>
      </div></div>
  </body>
</html>
