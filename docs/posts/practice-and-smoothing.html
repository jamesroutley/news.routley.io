<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abstract.properties/practice-and-smoothing.html">Original</a>
    <h1>Practice and smoothing</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>I&#39;ve been thinking a lot about <em>practice</em>.</p>
<p>It&#39;s just so important in every aspect of life. Practice is necessary for both growth and maintenance. And the most
important part of practice is the preparation work to make execution smooth.</p>
<p>I want to build tools to help software development itself become smoother, but first I want to talk about practice
itself.</p>
<figure>
<img alt="The first 5 measures of Prelude No. 2 from Bach&#39;s Well Tempered Clavier, with some pencil writing on it" srcset="/opengraph/bach-wtc-prelude-2.860w.jpeg 860w, /opengraph/bach-wtc-prelude-2.1200w.jpeg 1200w, /opengraph/bach-wtc-prelude-2.1720w.jpeg 1720w"/>
<figcaption>Prelude 2 from Bach&#39;s Well Tempered Clavier: not my writing, but something I&#39;ve been practicing</figcaption>
</figure>
<p>I&#39;ve been working to improve my piano playing over the past few years.</p>
<p>I first just tried to play (and struggle) through the songs I wanted to learn—tonal,
romantic, and expressive pieces like <a href="https://www.youtube.com/watch?v=1qoPDQzXVmk">this Rachmaninoff prelude</a>, <a href="https://www.youtube.com/watch?v=oPHSHZssOLs">Ravel&#39;s dance
for a dead pricess</a>, or <a href="https://www.youtube.com/watch?v=107Iwx5RKSM">Chopin&#39;s
nocturne</a>.</p>
<p>These pieces are difficult and beautiful—and I want to be able to play them well.</p>
<p>But just practicing by playing over and over again wasn&#39;t working. I wasn&#39;t making much progress. I was trying too hard
to make the notes sing, and would get my fingers tangled or end up stuttering since my speed of playing was faster than
my speed of reading.</p>
<p>I was more focused on <em>performing</em> rather than <em>practicing</em>. I was getting ahead of myself, and skipping out on the
work to make it smooth.</p>
<a id="the-work-to-make-it-smooth" href="#the-work-to-make-it-smooth"><h2>The work to make it smooth</h2></a>
<p>Whether it&#39;s cooking, exercising, playing the piano, or even making software—it&#39;s more important to do the &#34;extra&#34; work
up-front to make the execution smooth.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Mise_en_place">Mise en place</a> makes the act of cooking and cleanup
smooth.</li>
<li>Hydrating, stretching, and putting together an achievable plan of what to do makes exercise smooth.</li>
<li>Making a clear plan for how each hand moves while playing the notes and rests makes playing piano smooth.</li>
<li>Doing the work to have a quick change/verify feedback loop makes programming smooth.</li>
</ul>
<p>Practice is all about doing the work to make things smoother.</p>

<p>The time taken to smooth execution out is more important than the act itself.</p>
<p>For the piano, I realized that I needed to spend more time practicing reading chunks of notes as chord progressions,
practicing fingering while playing through runs, and practicing reading rhythmic patterns.</p>
<p>So I started playing through all sorts of music—not just the songs I liked—and stopping when I made a mistake so I
could think through the challenges in fingering, chord progressions, and rhythm. And as a result, my playing has gotten
much better!</p>
<p>By stopping to analyze more, I&#39;ve ended up stopping less while playing.</p>
<p>There&#39;s still and endless amount of work to put in, and I still can&#39;t play those songs, but that&#39;s why it&#39;s a practice
and not a performance. It&#39;s something which will always keep on going.</p>
<a id="smooth-software" href="#smooth-software"><h2>Smooth software</h2></a>
<p>I&#39;ve just started my second week at the Recurse Center and have been reflecting on what it means to practice making
software.</p>
<p>If practice is about doing the work to make execution smoother, what can be done to make the act of programming itself
smoother?</p>
<p>I think programming is mostly discovery. And most of that discovery happens best through the scientific method: a hypothesis-verification loop.</p>
<p>Most software is complicated, poorly documented, and contain never-ending surprises. I find the best way to work through
these challenges is to go establish very rapid hypothesis-verification loops:</p>
<ul>
<li>Is this function needed? Delete it and try running the program.</li>
<li>Working on a component that needs to look good on a wide variety of widths? Build an isolated page where the
component is rendered at various sizes.</li>
<li>Is this code crashing because a certain sequence of operations is occurring? Add some log lines at each point and
check.</li>
<li>Need to change a function so it handles certain inputs? Write unit tests that verifies the inputs and expected
outputs.</li>
</ul>
<p>I want to build tools to help software development itself become smoother.</p>

<p>When I think about smooth feeling traits of software, I think of things that are snappy, immediately
responsive to changes, visual (leveraging spatial information), and easy to play with.</p>
<p>Things that are <em>extremely interactive</em>.</p>
<p>Honestly, the most popular <em>extremely interactive</em> tool is a spreadsheet: after setting up some formulas, changing the
numbers automatically updates everything.</p>
<p>After talking to some folks at the Recurse Center about spreadsheets and interactivity, I was pointed to a whole bunch
of things that have a bit of overlap with this idea:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=PUv66718DII">Inventing on Principle</a>, which shows some very playful and
extremely interactive development tools</li>
<li><a href="https://svelte.dev/blog/svelte-3-rethinking-reactivity">Svelte&#39;s reactive model</a>, which creates a language that embraces mutability in order to build more easily interactive applications</li>
<li><a href="https://www.geoffreylitt.com/wildcard/">Wildcard</a>, a fascinating tool that allows modifying documents through a
sort-of-spreadsheet interface</li>
<li><a href="https://opensource.janestreet.com/incremental/">Incremental</a>, Jane Street&#39;s approach to apply the
[https://www.umut-acar.org/self-adjusting-computation](Self-adjusting computation) technique to build extremely interactive computations</li>
</ul>
<a id="a-smoother-environment" href="#a-smoother-environment"><h2>A smoother environment</h2></a>
<p>I want to make something a bit like what&#39;s shown in that Inventing on Principle talk: A development environment where
code is placed next to interactive UI and the distinction between &#34;running&#34; and &#34;modifying&#34; code is seamless.</p>
<p>Like, imagine an environment where development-time, debug-time, and test-time were the same:</p>
<ul>
<li>A visual chart showing the input/output graph could be placed next to a function describing its effects, like a visual comment</li>
<li>When writing UI components, interactive instances of those components showing common edge case sizes &amp; inputs could be
placed next to the code</li>
<li>Unit tests could show as little red/greed dots in a UI that updated when the code was changed</li>
<li>When debugging an application, local state could be viewed (and interacted with) using UI special-built for it</li>
</ul>
<p>Right now, all of these acts are done using different tools which make jumping between bumpy and awkward.</p>
<p>I&#39;m gonna try to build something that lets you do these things all together.</p>


                </div></div>
  </body>
</html>
