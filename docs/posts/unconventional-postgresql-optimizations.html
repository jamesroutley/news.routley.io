<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hakibenita.com/postgresql-unconventional-optimizations">Original</a>
    <h1>Unconventional PostgreSQL Optimizations</h1>
    
    <div id="readability-page-1" class="page"><article data-progress-indicator="">
        <hr/>
<p>When it comes to database optimization, developers often reach for the same old tools: rewrite the query slightly differently, slap an index on a column, denormalize, analyze, vacuum, cluster, repeat. Conventional techniques are effective, but sometimes being creative can really pay off!</p>
<p><strong>In this article, I present unconventional optimization techniques in PostgreSQL.</strong></p>

<details open="">
    <summary>Table of Contents</summary>

</details>
<hr/>
<h2 id="eliminate-full-table-scans-based-on-check-constraints"><a href="#eliminate-full-table-scans-based-on-check-constraints">Eliminate Full Table Scans Based on Check Constraints</a></h2>
<p>Imagine you have this table of users:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>users</span><span> </span><span>(</span>
<span>    </span><span>id</span><span> </span><span>INT</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>,</span>
<span>    </span><span>username</span><span> </span><span>TEXT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span>
<span>    </span><span>plan</span><span> </span><span>TEXT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span>
<span>    </span><span>CONSTRAINT</span><span> </span><span>plan_check</span><span> </span><span>CHECK</span><span> </span><span>(</span><span>plan</span><span> </span><span>IN</span><span> </span><span>(</span><span>&#39;free&#39;</span><span>,</span><span> </span><span>&#39;pro&#39;</span><span>))</span>
<span>);</span>
<span>CREATE</span><span> </span><span>TABLE</span>
</pre></div>


<p>For each user you keep their name and which payment plan they&#39;re on. There are only two plans, &#34;free&#34; and &#34;pro&#34;, so you add a check constraint.</p>
<p>Generate some data and analyze the table:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>users</span>
<span>SELECT</span><span> </span><span>n</span><span>,</span><span> </span><span>uuidv4</span><span>(),</span><span> </span><span>(</span><span>ARRAY</span><span>[</span><span>&#39;free&#39;</span><span>,</span><span> </span><span>&#39;pro&#39;</span><span>])[</span><span>ceil</span><span>(</span><span>random</span><span>()</span><span>*</span><span>2</span><span>)]</span>
<span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>1</span><span>,</span><span> </span><span>100</span><span>_000</span><span>)</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>n</span><span>);</span>
<span>INSERT</span><span> </span><span>0</span><span> </span><span>100000</span>

<span>db</span><span>=#</span><span> </span><span>ANALYZE</span><span> </span><span>users</span><span>;</span>
<span>ANALYZE</span>
</pre></div>


<p>You now have 100K users in the system.</p>
<h3 id="honest-mistakes"><a href="#honest-mistakes">Honest Mistakes</a></h3>
<p>Now you want to let your analysts access this table in their reporting tool of choice. You give one of the analysts permission, and this is the first query they write:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>users</span><span> </span><span>WHERE</span><span> </span><span>plan</span><span> </span><span>=</span><span> </span><span>&#39;Pro&#39;</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>username</span><span> </span><span>│</span><span> </span><span>plan</span>
<span>────┼──────────┼──────</span>
<span>(</span><span>0</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>The query returned no results, and the analyst is baffled. How come there are no users on the &#34;Pro&#34; plan?</p>
<p>The name of the plan is &#34;pro&#34; and not &#34;Pro&#34; (with a capital &#34;P&#34;) as the analyst wrote it. This is an honest mistake really, anyone can make such a mistake! But what is the <em>cost</em> of this mistake?</p>
<p>Examine the execution plan of a query for a non-existing value:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>ANALYZE</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>users</span><span> </span><span>WHERE</span><span> </span><span>plan</span><span> </span><span>=</span><span> </span><span>&#39;Pro&#39;</span><span>;</span>
<span>                </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>──────────────────────────────────────────────────────────────────</span>
<span><span> </span><span>Seq</span><span> </span><span>Scan</span><span> </span><span>on</span><span> </span><span>users</span><span>  </span><span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>2185</span><span>.</span><span>00</span><span> </span><span>rows</span><span>=</span><span>1</span><span> </span><span>width</span><span>=</span><span>45</span><span>)</span>
</span><span>                    </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>7</span><span>.</span><span>406</span><span>..</span><span>7</span><span>.</span><span>407</span><span> </span><span>rows</span><span>=</span><span>0</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span>   </span><span>Filter</span><span>:</span><span> </span><span>(</span><span>plan</span><span> </span><span>=</span><span> </span><span>&#39;Pro&#39;</span><span>::</span><span>text</span><span>)</span>
<span>   </span><span>Rows</span><span> </span><span>Removed</span><span> </span><span>by</span><span> </span><span>Filter</span><span>:</span><span> </span><span>100000</span>
<span>   </span><span>Buffers</span><span>:</span><span> </span><span>shared</span><span> </span><span>hit</span><span>=</span><span>935</span>
<span> </span><span>Planning</span><span>:</span>
<span>   </span><span>Buffers</span><span>:</span><span> </span><span>shared</span><span> </span><span>hit</span><span>=</span><span>29</span><span> </span><span>read</span><span>=</span><span>2</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>4</span><span>.</span><span>564</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>7</span><span>.</span><span>436</span><span> </span><span>ms</span>
</pre></div>


<p>PostgreSQL scanned the entire table! However, there&#39;s a check constraint on the field - no row can ever have the value &#34;Pro&#34;, the database makes sure of that! So if this condition always evaluates to false, why is PostgreSQL scanning the table?</p>
<h3 id="using-constraint_exclusion"><a href="#using-constraint_exclusion">Using <code>constraint_exclusion</code></a></h3>
<p>PostgreSQL is smart enough to skip a table scan when the query contains a condition that always evaluates to false, but not by default! To instruct PostgreSQL to look at constraints when generating a plan, you need to set the parameter <a href="https://www.postgresql.org/docs/18/runtime-config-query.html#GUC-CONSTRAINT-EXCLUSION" rel="noopener"><code>constraint_exclusion</code></a>:</p>
<div><pre><span></span><span><span>db</span><span>=#</span><span> </span><span>SET</span><span> </span><span>constraint_exclusion</span><span> </span><span>to</span><span> </span><span>&#39;on&#39;</span><span>;</span>
</span><span>SET</span>

<span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>ANALYZE</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>users</span><span> </span><span>WHERE</span><span> </span><span>plan</span><span> </span><span>=</span><span> </span><span>&#39;Pro&#39;</span><span>;</span>
<span>                                      </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>───────────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>Result</span><span>  </span><span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>0</span><span>.</span><span>00</span><span> </span><span>rows</span><span>=</span><span>0</span><span> </span><span>width</span><span>=</span><span>0</span><span>)</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>0</span><span>.</span><span>000</span><span>..</span><span>0</span><span>.</span><span>001</span><span> </span><span>rows</span><span>=</span><span>0</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span><span>   </span><span>One</span><span>-</span><span>Time</span><span> </span><span>Filter</span><span>:</span><span> </span><span>false</span>
</span><span> </span><span>Planning</span><span>:</span>
<span>   </span><span>Buffers</span><span>:</span><span> </span><span>shared</span><span> </span><span>hit</span><span>=</span><span>5</span><span> </span><span>read</span><span>=</span><span>4</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>5</span><span>.</span><span>760</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>008</span><span> </span><span>ms</span>
<span>(</span><span>6</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>Nice! After turning <code>constraint_exclusion</code> on, PostgreSQL figured out based on the check constraint that the condition won&#39;t return any rows, and skipped the scan entirely.</p>
<h3 id="when-constraint_exclusion-makes-sense"><a href="#when-constraint_exclusion-makes-sense">When <code>constraint_exclusion</code> Makes Sense</a></h3>
<p>So who are you <code>constraint_exclusion</code> and why are you not on by default?</p>
<blockquote>
<p>Currently, constraint exclusion is enabled by default only for cases that are often used to implement table partitioning via inheritance trees. Turning it on for all tables imposes extra planning overhead that is quite noticeable on simple queries, and most often will yield no benefit for simple queries.</p>
</blockquote>
<p>The parameter <code>constraint_exclusion</code> is set to &#34;partition&#34; by default, where it&#39;s used to eliminate entire partitions when querying against a partitioned table - this is known as <a href="https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITION-PRUNING" rel="noopener">&#34;partition pruning&#34;</a>.</p>
<p>The documentation states that for simple queries the cost of evaluating all relevant conditions against all the relevant constraints might outweigh the benefit - you might end up spending more time planning than actually executing the query. It makes sense that queries executed by a system are less likely to query for invalid values or apply conditions that go against constraints. However, this is not the case for ad-hoc queries in reporting tools...</p>
<p>In BI and reporting environments users can issue complicated queries that are often crafted by hand. In this type of environment, it&#39;s not unlikely that they&#39;ll make mistakes, just like our analyst did before. Setting <code>constraint_exclusion</code> to &#34;on&#34; in reporting and data warehouse environments where users can issue ad-hoc queries can potentially save time and resources by eliminating unnecessary full table scans.</p>
<hr/>
<h2 id="optimize-for-lower-cardinality-with-function-based-index"><a href="#optimize-for-lower-cardinality-with-function-based-index">Optimize for Lower Cardinality With Function Based Index</a></h2>
<p>Imagine you have a sales table that looks like this:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>sale</span><span> </span><span>(</span>
<span>    </span><span>id</span><span> </span><span>INT</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>,</span>
<span>    </span><span>sold_at</span><span> </span><span>TIMESTAMPTZ</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span>
<span>    </span><span>charged</span><span> </span><span>INT</span><span> </span><span>NOT</span><span> </span><span>NULL</span>
<span>);</span>
<span>CREATE</span><span> </span><span>TABLE</span>
</pre></div>


<p>You keep track of when the sale was made and how much was charged. Create 10 million sales and analyze the table:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>sale</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>sold_at</span><span>,</span><span> </span><span>charged</span><span>)</span>
<span>SELECT</span>
<span>    </span><span>n</span><span> </span><span>AS</span><span> </span><span>id</span><span>,</span>
<span>    </span><span>&#39;2025-01-01 UTC&#39;</span><span>::</span><span>timestamptz</span><span> </span><span>+</span><span> </span><span>(</span><span>interval</span><span> </span><span>&#39;5 seconds&#39;</span><span>)</span><span> </span><span>*</span><span> </span><span>n</span><span> </span><span>AS</span><span> </span><span>sold_at</span><span>,</span>
<span>    </span><span>ceil</span><span>(</span><span>random</span><span>()</span><span> </span><span>*</span><span> </span><span>100</span><span>)</span><span> </span><span>AS</span><span> </span><span>charged</span>
<span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>1</span><span>,</span><span> </span><span>10</span><span>_000_000</span><span>)</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>n</span><span>);</span>
<span>INSERT</span><span> </span><span>0</span><span> </span><span>10000000</span>

<span>db</span><span>=#</span><span> </span><span>ANALYZE</span><span> </span><span>sale</span><span>;</span>
<span>ANALYZE</span>
</pre></div>


<h3 id="slapping-a-b-tree-on-it"><a href="#slapping-a-b-tree-on-it">Slapping a B-Tree on it</a></h3>
<p>Your analysts often produce daily sales reports and their queries can look roughly like this:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>ON</span><span>,</span><span> </span><span>BUFFERS</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>),</span><span> </span><span>SUM</span><span>(</span><span>charged</span><span>)</span>
<span>FROM</span><span> </span><span>sale</span>
<span>WHERE</span><span> </span><span>&#39;2025-01-01 UTC&#39;</span><span> </span><span>&lt;=</span><span> </span><span>sold_at</span><span> </span><span>AND</span><span> </span><span>sold_at</span><span> </span><span>&lt;</span><span> </span><span>&#39;2025-02-01 UTC&#39;</span>
<span>GROUP</span><span> </span><span>BY</span><span> </span><span>1</span><span>;</span>
<span>                                </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>──────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>HashAggregate</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>626</span><span>.</span><span>074</span><span>..</span><span>626</span><span>.</span><span>310</span><span> </span><span>rows</span><span>=</span><span>32</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span>   </span><span>Group</span><span> </span><span>Key</span><span>:</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>sold_at</span><span>)</span>
<span>   </span><span>Batches</span><span>:</span><span> </span><span>1</span><span>  </span><span>Memory</span><span> </span><span>Usage</span><span>:</span><span> </span><span>2081</span><span>kB</span>
<span><span>   </span><span>-&gt;</span><span>  </span><span>Seq</span><span> </span><span>Scan</span><span> </span><span>on</span><span> </span><span>sale</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>6</span><span>.</span><span>428</span><span>..</span><span>578</span><span>.</span><span>135</span><span> </span><span>rows</span><span>=</span><span>535679</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
</span><span>         </span><span>Filter</span><span>:</span><span> </span><span>((</span><span>&#39;2025-01-01 02:00:00+02&#39;</span><span>::</span><span>timestamp</span><span> </span><span>with</span><span> </span><span>time</span><span> </span><span>zone</span><span> </span><span>&lt;=</span><span> </span><span>sold_at</span><span>)</span>
<span>                  </span><span>AND</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>&lt;</span><span> </span><span>&#39;2025-02-01 02:00:00+02&#39;</span><span>::</span><span>timestamp</span><span> </span><span>with</span><span> </span><span>time</span><span> </span><span>zone</span><span>))</span>
<span>         </span><span>Rows</span><span> </span><span>Removed</span><span> </span><span>by</span><span> </span><span>Filter</span><span>:</span><span> </span><span>9464321</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>115</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>627</span><span>.</span><span>119</span><span> </span><span>ms</span>
</pre></div>


<p>PostgreSQL scanned the entire table and the query completed in ~627ms. Your analysts are a bit spoiled and ~600ms is too slow for them, so you do what you always do in these cases and <em>&#34;slap a B-Tree index on it&#34;</em>:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>sale_sold_at_ix</span><span> </span><span>ON</span><span> </span><span>sale</span><span>(</span><span>sold_at</span><span>);</span>
<span>CREATE</span><span> </span><span>INDEX</span>
</pre></div>


<p>Execute the query with the index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>ON</span><span>,</span><span> </span><span>BUFFERS</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>),</span><span> </span><span>SUM</span><span>(</span><span>charged</span><span>)</span>
<span>FROM</span><span> </span><span>sale</span>
<span>WHERE</span><span> </span><span>&#39;2025-01-01 UTC&#39;</span><span> </span><span>&lt;=</span><span> </span><span>sold_at</span><span> </span><span>AND</span><span> </span><span>sold_at</span><span> </span><span>&lt;</span><span> </span><span>&#39;2025-02-01 UTC&#39;</span>
<span>GROUP</span><span> </span><span>BY</span><span> </span><span>1</span><span>;</span>
<span>                                    </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>───────────────────────────────────────────────────────────────────────────────────────────────────</span>
<span>HashAggregate</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>186</span><span>.</span><span>970</span><span>..</span><span>187</span><span>.</span><span>212</span><span> </span><span>rows</span><span>=</span><span>32</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span>  </span><span>Group</span><span> </span><span>Key</span><span>:</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>sold_at</span><span>)</span>
<span>  </span><span>Batches</span><span>:</span><span> </span><span>1</span><span>  </span><span>Memory</span><span> </span><span>Usage</span><span>:</span><span> </span><span>2081</span><span>kB</span>
<span><span>  </span><span>-&gt;</span><span>  </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>sale_sold_at_ix</span><span> </span><span>on</span><span> </span><span>sale</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>0</span><span>.</span><span>038</span><span>..</span><span>137</span><span>.</span><span>067</span><span> </span><span>rows</span><span>=</span><span>535679</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
</span><span>        </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>((</span><span>sold_at</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2025-01-01 02:00:00+02&#39;</span><span>::</span><span>timestamp</span><span> </span><span>with</span><span> </span><span>time</span><span> </span><span>zone</span><span>)</span>
<span>                     </span><span>AND</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>&lt;</span><span> </span><span>&#39;2025-02-01 02:00:00+02&#39;</span><span>::</span><span>timestamp</span><span> </span><span>with</span><span> </span><span>time</span><span> </span><span>zone</span><span>))</span>
<span>        </span><span>Index</span><span> </span><span>Searches</span><span>:</span><span> </span><span>1</span>
<span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>261</span><span> </span><span>ms</span>
<span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>187</span><span>.</span><span>363</span><span> </span><span>ms</span>
</pre></div>


<p>Execution time reduced from ~627ms to 187ms and the analysts are happy, but at what cost?</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>\</span><span>di</span><span>+</span><span> </span><span>sale_sold_at_ix</span>
<span>List</span><span> </span><span>of</span><span> </span><span>indexes</span>
<span>─</span><span>[</span><span> </span><span>RECORD</span><span> </span><span>1</span><span> </span><span>]</span><span>─┬────────────────</span>
<span>Schema</span><span>        </span><span>│</span><span> </span><span>public</span>
<span>Name</span><span>          </span><span>│</span><span> </span><span>sale_sold_at_ix</span>
<span>Type</span><span>          </span><span>│</span><span> </span><span>index</span>
<span>Owner</span><span>         </span><span>│</span><span> </span><span>haki</span>
<span>Table</span><span>         </span><span>│</span><span> </span><span>sale</span>
<span>Persistence</span><span>   </span><span>│</span><span> </span><span>permanent</span>
<span>Access</span><span> </span><span>method</span><span> </span><span>│</span><span> </span><span>btree</span>
<span><span>Size</span><span>          </span><span>│</span><span> </span><span>214</span><span> </span><span>MB</span>
</span><span>Description</span><span>   </span><span>│</span><span> </span><span>¤</span>
</pre></div>


<p>The index is 214 MB! That&#39;s almost half the size of the entire table. So the analysts are happy, but you? Not so much...</p>
<p>Slapping a B-Tree index is very common, but DBAs and developers often ignore the storage cost and the maintenance burden that comes with it. Using simple measures, we can potentially save some space and money.</p>
<h3 id="rethinking-the-problem"><a href="#rethinking-the-problem">Rethinking the Problem</a></h3>
<p>Let&#39;s step back and re-think what we were trying to optimize. Analysts wanted to produce <em>daily</em> reports, but we provided them with an index that can produce results at a millisecond precision. By indexing the date and the time, we gave the analysts a lot more than what they asked for!</p>
<p>What if instead of indexing the entire datetime, we index just the date, without the time?</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>sale_sold_at_date_ix</span><span> </span><span>ON</span><span> </span><span>sale</span><span>((</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>))::</span><span>date</span><span>);</span>
<span>CREATE</span><span> </span><span>INDEX</span>
</pre></div>


<p>This creates a <a href="https://www.postgresql.org/docs/current/indexes-expressional.html" rel="noopener">function-based index</a> on the date part of the sale date. We make sure to <a href="https://blog.danielsosebee.com/sql-dos-and-donts#be-aware-of-timezones">set the time zone before we truncate the date</a> to match the one used by the analysts in their reports.</p>
<p>First, check the size of the indexes:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>\</span><span>di</span><span>+</span><span> </span><span>sale_sold_at_</span><span>*</span>
<span>                  </span><span>List</span><span> </span><span>of</span><span> </span><span>indexes</span>
<span>         </span><span>Name</span><span>         </span><span>│</span><span> </span><span>Table</span><span> </span><span>│</span><span> </span><span>Access</span><span> </span><span>method</span><span> </span><span>│</span><span>  </span><span>Size</span>
<span>──────────────────────┼───────┼───────────────┼────────</span>
<span> </span><span>sale_sold_at_date_ix</span><span> </span><span>│</span><span> </span><span>sale</span><span>  </span><span>│</span><span> </span><span>btree</span><span>         </span><span>│</span><span> </span><span>66</span><span> </span><span>MB</span>
<span> </span><span>sale_sold_at_ix</span><span>      </span><span>│</span><span> </span><span>sale</span><span>  </span><span>│</span><span> </span><span>btree</span><span>         </span><span>│</span><span> </span><span>214</span><span> </span><span>MB</span>
</pre></div>


<p>The function-based index is just 66MB, that&#39;s more than 3 times smaller than the full index. While a <code>date</code> is smaller than a <code>timestamptz</code> -- 4 bytes vs. 8 bytes -- this is actually not where the majority of the savings come from. The function-based index has <em>fewer distinct values</em>, so PostgreSQL can optimize its size using <a href="https://blog.danielsosebee.com/postgresql-unused-index-size#activating-b-tree-index-deduplication">deduplication</a>.</p>
<p>To check if we can make better use of the smaller index, we start by dropping the full index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>DROP</span><span> </span><span>INDEX</span><span> </span><span>sale_sold_at_ix</span><span>;</span>
<span>DROP</span><span> </span><span>INDEX</span>
</pre></div>


<p>To allow our query to use the function-based index we make some adjustments to the query (we&#39;ll tackle that later!):</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>ON</span><span>,</span><span> </span><span>BUFFERS</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>),</span><span> </span><span>SUM</span><span>(</span><span>charged</span><span>)</span>
<span>FROM</span><span> </span><span>sale</span>
<span>WHERE</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>)::</span><span>date</span><span> </span><span>BETWEEN</span><span> </span><span>&#39;2025-01-01&#39;</span><span> </span><span>AND</span><span> </span><span>&#39;2025-01-31&#39;</span>
<span>GROUP</span><span> </span><span>BY</span><span> </span><span>1</span><span>;</span>

<span>                                                                  </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>GroupAggregate</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>6</span><span>.</span><span>499</span><span>..</span><span>145</span><span>.</span><span>889</span><span> </span><span>rows</span><span>=</span><span>31</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span>   </span><span>Group</span><span> </span><span>Key</span><span>:</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>))</span>
<span><span>   </span><span>-&gt;</span><span>  </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>sale_sold_at_date_ix</span><span> </span><span>on</span><span> </span><span>sale</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>0</span><span>.</span><span>015</span><span>..</span><span>119</span><span>.</span><span>832</span><span> </span><span>rows</span><span>=</span><span>535679</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
</span><span>         </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>((</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>))::</span><span>date</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2025-01-01 00:00:00&#39;</span><span>::</span><span>timestamp</span><span> </span><span>without</span><span> </span><span>time</span><span> </span><span>zone</span><span>)</span>
<span>                  </span><span>AND</span><span> </span><span>(</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>))::</span><span>date</span><span> </span><span>&lt;</span><span> </span><span>&#39;2025-02-01 00:00:00&#39;</span><span>::</span><span>timestamp</span><span> </span><span>without</span><span> </span><span>time</span><span> </span><span>zone</span><span>))</span>
<span>         </span><span>Index</span><span> </span><span>Searches</span><span>:</span><span> </span><span>1</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>151</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>145</span><span>.</span><span>913</span><span> </span><span>ms</span>
</pre></div>


<p>The index was used and the query completed in just 145ms, that&#39;s ~20ms faster then using the full index, and x4.5 time faster than the full table scan.</p>
<h3 id="the-discipline-problem"><a href="#the-discipline-problem">The Discipline Problem</a></h3>
<p>Using a function based index can be fragile. If we make even the slightest adjustment to the expression, the database won&#39;t be able to use the index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>)::</span><span>date</span><span>,</span><span> </span><span>SUM</span><span>(</span><span>charged</span><span>)</span>
<span>FROM</span><span> </span><span>sale</span>
<span><span>WHERE</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>)::</span><span>date</span><span> </span><span>BETWEEN</span><span> </span><span>&#39;2025-01-01&#39;</span><span> </span><span>AND</span><span> </span><span>&#39;2025-01-31&#39;</span>
</span><span>GROUP</span><span> </span><span>BY</span><span> </span><span>1</span><span>;</span>
<span>                                </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>────────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>HashAggregate</span>
<span>   </span><span>Group</span><span> </span><span>Key</span><span>:</span><span> </span><span>((</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>))::</span><span>date</span>
<span><span>   </span><span>-&gt;</span><span>  </span><span>Seq</span><span> </span><span>Scan</span><span> </span><span>on</span><span> </span><span>sale</span>
</span><span>         </span><span>Filter</span><span>:</span><span> </span><span>((((</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>))::</span><span>date</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2025-01-01&#39;</span><span>::</span><span>date</span><span>)</span>
<span>         </span><span>AND</span><span> </span><span>(((</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>))::</span><span>date</span><span> </span><span>&lt;=</span><span> </span><span>&#39;2025-01-31&#39;</span><span>::</span><span>date</span><span>))</span>
</pre></div>


<p>The query is the same as the previous, but we changed the expression from using <code>date_trunc</code> to using <code>::date</code>, so the database was unable to use the function-based index.</p>
<p>Using the exact same expression requires a certain level of discipline that doesn&#39;t realistically exist in any organization. It&#39;s borderline naive to expect this to be useful this way - we need to come up with a way to force the use of this exact expression.</p>
<p>The old way of doing this involved a view:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>VIEW</span><span> </span><span>v_sale</span><span> </span><span>AS</span>
<span>SELECT</span><span> </span><span>*</span><span>,</span><span> </span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>)::</span><span>date</span><span> </span><span>AS</span><span> </span><span>sold_at_date</span>
<span>FROM</span><span> </span><span>sale</span><span>;</span>
<span>CREATE</span><span> </span><span>VIEW</span>
</pre></div>


<p>The view adds a new calculated column called &#34;sold_at_date&#34; that uses the exact same expression we used to define the function-based index. Using the view, we can guarantee that we allow the database to use the index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>sold_at_date</span><span>,</span><span> </span><span>SUM</span><span>(</span><span>charged</span><span>)</span>
<span><span>FROM</span><span> </span><span>v_sale</span>
</span><span>WHERE</span><span> </span><span>sold_at_date</span><span> </span><span>BETWEEN</span><span> </span><span>&#39;2025-01-01&#39;</span><span> </span><span>AND</span><span> </span><span>&#39;2025-01-31&#39;</span>
<span>GROUP</span><span> </span><span>BY</span><span> </span><span>1</span><span>;</span>
<span>                                          </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>──────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>GroupAggregate</span>
<span>   </span><span>Group</span><span> </span><span>Key</span><span>:</span><span> </span><span>(</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sale</span><span>.</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>)))::</span><span>date</span>
<span><span>   </span><span>-&gt;</span><span>  </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>sale_sold_at_date_ix</span><span> </span><span>on</span><span> </span><span>sale</span>
</span><span>         </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>(((</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>)))::</span><span>date</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2025-01-01&#39;</span><span>::</span><span>date</span><span>)</span>
<span>         </span><span>AND</span><span> </span><span>((</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>)))::</span><span>date</span><span> </span><span>&lt;=</span><span> </span><span>&#39;2025-01-31&#39;</span><span>::</span><span>date</span><span>))</span>
</pre></div>


<p>The index is used and the query is fast! Cool, but...</p>
<p>Views are definitely a viable solution here, but they suffer from the same discipline problem - the analysts can still use the table directly (and they will!). We can revoke access from the table or do some magic tricks with <code>search_path</code> to fool them into using the view, but there is an easier way.</p>
<h3 id="using-virtual-generated-columns"><a href="#using-virtual-generated-columns">Using Virtual Generated Columns</a></h3>
<p>Starting at version 14, PostgreSQL supports <a href="https://www.postgresql.org/docs/current/ddl-generated-columns.html" rel="noopener">generated columns</a> - these are columns that are automatically populated with an expression when we insert the row. Sounds exactly like what we need but there is a caveat - the result of the expression is materialized - this means additional storage, which is what we were trying to save in the first place!</p>
<p>Lucky for us, starting with version 18, PostgreSQL supports <em>virtual</em> generated columns. A virtual column looks like a regular column, but it&#39;s actually an expression that&#39;s being evaluated every time it is accessed. Basically, what we tried to achieve before with a view!</p>
<p>First, add a virtual generated column to the table with the same expression we indexed:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>sale</span><span> </span><span>ADD</span><span> </span><span>sold_at_date</span><span> </span><span>DATE</span>
<span>GENERATED</span><span> </span><span>ALWAYS</span><span> </span><span>AS</span><span> </span><span>(</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>,</span><span> </span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>));</span>
<span>ALTER</span><span> </span><span>TABLE</span>
</pre></div>


<p>Next, execute the query using the virtual generated column:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>ON</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>,</span><span> </span><span>BUFFERS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>sold_at_date</span><span>,</span><span> </span><span>SUM</span><span>(</span><span>charged</span><span>)</span>
<span>FROM</span><span> </span><span>sale</span>
<span>WHERE</span><span> </span><span>sold_at_date</span><span> </span><span>BETWEEN</span><span> </span><span>&#39;2025-01-01&#39;</span><span> </span><span>AND</span><span> </span><span>&#39;2025-01-31&#39;</span>
<span>GROUP</span><span> </span><span>BY</span><span> </span><span>1</span><span>;</span>
<span>                                          </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>──────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>GroupAggregate</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>7</span><span>.</span><span>047</span><span>..</span><span>162</span><span>.</span><span>965</span><span> </span><span>rows</span><span>=</span><span>31</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span>   </span><span>Group</span><span> </span><span>Key</span><span>:</span><span> </span><span>(</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>)))::</span><span>date</span>
<span><span>   </span><span>-&gt;</span><span>  </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>sale_sold_at_date_ix</span><span> </span><span>on</span><span> </span><span>sale</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>0</span><span>.</span><span>015</span><span>..</span><span>134</span><span>.</span><span>795</span><span> </span><span>rows</span><span>=</span><span>535679</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
</span><span>         </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>(((</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>)))::</span><span>date</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2025-01-01&#39;</span><span>::</span><span>date</span><span>)</span>
<span>         </span><span>AND</span><span> </span><span>((</span><span>date_trunc</span><span>(</span><span>&#39;day&#39;</span><span>::</span><span>text</span><span>,</span><span> </span><span>(</span><span>sold_at</span><span> </span><span>AT</span><span> </span><span>TIME</span><span> </span><span>ZONE</span><span> </span><span>&#39;UTC&#39;</span><span>::</span><span>text</span><span>)))::</span><span>date</span><span> </span><span>&lt;=</span><span> </span><span>&#39;2025-01-31&#39;</span><span>::</span><span>date</span><span>))</span>
<span>         </span><span>Index</span><span> </span><span>Searches</span><span>:</span><span> </span><span>1</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>128</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>162</span><span>.</span><span>989</span><span> </span><span>ms</span>
</pre></div>


<p>Using the virtual generated column we can make sure the expression used in the query is the exact same expression we indexed. PostgreSQL is then able to use the index, and the query is fast.</p>
<p>There are several advantages to this approach:</p>
<ol>
<li>
<p><strong>Smaller index</strong>: fewer distinct values means the database can use deduplication to make the index smaller.</p>
</li>
<li>
<p><strong>Faster query</strong>: the small and specific index requires less resources so the query is faster.</p>
</li>
<li>
<p><strong>No discipline</strong>: using the generated column is straight forward and the index is guaranteed to be useable.</p>
</li>
<li>
<p><strong>No ambiguity</strong>: making sure anyone on the team uses the same exact expression is prone to errors and discrepancies, <a href="https://blog.danielsosebee.com/p/sql-dos-and-donts#be-aware-of-timezones">especially when time zones are involved</a>. Using a virtual generated column eliminates this ambiguity.</p>
</li>
</ol>
<h3 id="indexing-virtual-generated-columns"><a href="#indexing-virtual-generated-columns">Indexing Virtual Generated Columns</a></h3>
<p>The next logical step would be to create the index directly on the virtual column. Unfortunately, as of writing this article, PostgreSQL 18 does not support indexes on virtual generated columns:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>sale_sold_at_date_ix</span><span> </span><span>ON</span><span> </span><span>sale</span><span>(</span><span>sold_at_date</span><span>);</span>
<span>ERROR</span><span>:</span><span>  </span><span>indexes</span><span> </span><span>on</span><span> </span><span>virtual</span><span> </span><span>generated</span><span> </span><span>columns</span><span> </span><span>are</span><span> </span><span>not</span><span> </span><span>supported</span>
</pre></div>


<p>Hopefully <a href="https://www.postgresql.org/message-id/CACJufxGao-cypdNhifHAdt8jHfK6-HX=tRBovBkgRuxw063GaA@mail.gmail.com" rel="noopener">indexes on virtual generated columns</a> will make it to PostgreSQL 19.</p>
<hr/>
<h2 id="enforce-uniqueness-with-hash-index"><a href="#enforce-uniqueness-with-hash-index">Enforce Uniqueness with Hash Index</a></h2>
<p>Imagine you have a system that extracts information from URLs. You create a table to keep track:</p>
<div><pre><span></span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>urls</span><span> </span><span>(</span>
<span>    </span><span>id</span><span> </span><span>INT</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>,</span>
<span>    </span><span>url</span><span> </span><span>TEXT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span>
<span>    </span><span>data</span><span> </span><span>JSON</span>
<span>);</span>
</pre></div>


<p>Create some entries:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span>
<span>SELECT</span><span> </span><span>n</span><span>,</span><span> </span><span>&#39;https://&#39;</span><span> </span><span>||</span><span> </span><span>uuidv4</span><span>()</span><span> </span><span>||</span><span> </span><span>&#39;.com/ &#39;</span><span> </span><span>||</span><span> </span><span>uuidv4</span><span>()</span><span> </span><span>||</span><span> </span><span>&#39;?p=&#39;</span><span> </span><span>||</span><span> </span><span>uuidv4</span><span>()</span>
<span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>1</span><span>,</span><span> </span><span>1</span><span>_000_000</span><span>)</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>n</span><span>);</span>
<span>INSERT</span><span> </span><span>0</span><span> </span><span>1000000</span>
</pre></div>


<p>Processing web pages can be resource intensive, time consuming and expensive, so you want to make sure you don&#39;t process the same page more than once.</p>
<h3 id="slap-a-unique-b-tree-on-it"><a href="#slap-a-unique-b-tree-on-it">Slap a Unique B-Tree on it</a></h3>
<p>To make sure URLs are not processed more than once you add a unique constraint on the <code>url</code> column:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>UNIQUE</span><span> </span><span>INDEX</span><span> </span><span>urls_url_unique_ix</span><span> </span><span>ON</span><span> </span><span>urls</span><span>(</span><span>url</span><span>);</span>
</pre></div>


<p>You can now rest assured that you don&#39;t process the exact URL more than once:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_001</span><span>,</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>);</span>
<span>INSERT</span><span> </span><span>0</span><span> </span><span>1</span>

<span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_002</span><span>,</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>);</span>
<span>ERROR</span><span>:</span><span>  </span><span>duplicate</span><span> </span><span>key</span><span> </span><span>value</span><span> </span><span>violates</span><span> </span><span>unique</span><span> </span><span>constraint</span><span> </span><span>&#34;urls_url_unique_ix&#34;</span>
<span>DETAIL</span><span>:</span><span>  </span><span>Key</span><span> </span><span>(</span><span>url</span><span>)</span><span>=</span><span>(</span><span>https</span><span>:</span><span>//</span><span>hakibenita</span><span>.</span><span>com</span><span>)</span><span> </span><span>already</span><span> </span><span>exists</span><span>.</span>
</pre></div>


<p>The unique constraint is enforced using a unique B-Tree index, so you also get the nice perk of being able to search for a specific URL very quickly:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>ON</span><span>,</span><span> </span><span>BUFFERS</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>urls</span><span> </span><span>WHERE</span><span> </span><span>url</span><span> </span><span>=</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>;</span>
<span>                                        </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>──────────────────────────────────────────────────────────────────────────────────────────</span>
<span><span> </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>urls_url_unique_ix</span><span> </span><span>on</span><span> </span><span>urls</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>0</span><span>.</span><span>018</span><span>..</span><span>0</span><span>.</span><span>018</span><span> </span><span>rows</span><span>=</span><span>1</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
</span><span>   </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>(</span><span>url</span><span> </span><span>=</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>::</span><span>text</span><span>)</span>
<span>   </span><span>Index</span><span> </span><span>Searches</span><span>:</span><span> </span><span>1</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>173</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>046</span><span> </span><span>ms</span>
</pre></div>


<p>Web pages these days can have pretty big URLs. Some web apps even go as far as storing the entire application state in the URL. This is great for users, but not so great if you need to store these URLs.</p>
<p>Check the size of the table and the B-Tree index used to enforce the unique constraint:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>\</span><span>dt</span><span>+</span><span> </span><span>urls</span>
<span>List</span><span> </span><span>of</span><span> </span><span>tables</span>
<span>─</span><span>[</span><span> </span><span>RECORD</span><span> </span><span>1</span><span> </span><span>]</span><span>─┬──────────</span>
<span>Schema</span><span>        </span><span>│</span><span> </span><span>public</span>
<span>Name</span><span>          </span><span>│</span><span> </span><span>urls</span>
<span>Type</span><span>          </span><span>│</span><span> </span><span>table</span>
<span>Owner</span><span>         </span><span>│</span><span> </span><span>haki</span>
<span>Persistence</span><span>   </span><span>│</span><span> </span><span>permanent</span>
<span>Access</span><span> </span><span>method</span><span> </span><span>│</span><span> </span><span>heap</span>
<span><span>Size</span><span>          </span><span>│</span><span> </span><span>160</span><span> </span><span>MB</span>
</span><span>Description</span><span>   </span><span>│</span><span> </span><span>¤</span>

<span>db</span><span>=#</span><span> </span><span>\</span><span>di</span><span>+</span><span> </span><span>urls_url_unique_ix</span>
<span>List</span><span> </span><span>of</span><span> </span><span>indexes</span>
<span>─</span><span>[</span><span> </span><span>RECORD</span><span> </span><span>1</span><span> </span><span>]</span><span>─┬───────────────────</span>
<span>Schema</span><span>        </span><span>│</span><span> </span><span>public</span>
<span>Name</span><span>          </span><span>│</span><span> </span><span>urls_url_unique_ix</span>
<span>Type</span><span>          </span><span>│</span><span> </span><span>index</span>
<span>Owner</span><span>         </span><span>│</span><span> </span><span>haki</span>
<span>Table</span><span>         </span><span>│</span><span> </span><span>urls</span>
<span>Persistence</span><span>   </span><span>│</span><span> </span><span>permanent</span>
<span>Access</span><span> </span><span>method</span><span> </span><span>│</span><span> </span><span>btree</span>
<span><span>Size</span><span>          </span><span>│</span><span> </span><span>154</span><span> </span><span>MB</span>
</span><span>Description</span><span>   </span><span>│</span><span> </span><span>¤</span>
</pre></div>


<p>The size of the table is 160MB and the size of the index is a staggering 154MB!</p>
<h3 id="unique-hash-index"><a href="#unique-hash-index">Unique Hash Index</a></h3>
<p>A B-Tree index stores the indexed values themselves in the leaf blocks, so when indexing large values, the B-Tree index can get very large.</p>
<p>PostgreSQL offers another type of index called a <a href="https://www.postgresql.org/docs/current/hash-index.html" rel="noopener">Hash index</a>. This type of index does not store the actual values. Instead, it stores the hash values which can be much smaller. <a href="https://blog.danielsosebee.com/postgresql-hash-index">I wrote about Hash indexes</a> in the past so I wont repeat myself. I would just say that indexing large values with very few repetition is where the Hash index truly shines!</p>
<p>A Hash index sounds like a reasonable way to enforce a unique constraint, so let&#39;s try to create a unique hash index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>UNIQUE</span><span> </span><span>INDEX</span><span> </span><span>urls_url_unique_hash</span><span> </span><span>ON</span><span> </span><span>urls</span><span> </span><span>USING</span><span> </span><span>HASH</span><span>(</span><span>url</span><span>);</span>
<span>ERROR</span><span>:</span><span>  </span><span>access</span><span> </span><span>method</span><span> </span><span>&#34;hash&#34;</span><span> </span><span>does</span><span> </span><span>not</span><span> </span><span>support</span><span> </span><span>unique</span><span> </span><span>indexes</span>
</pre></div>


<p>Oh no! PostgreSQL does not support unique hash indexes, but this doesn&#39;t mean we can&#39;t still enforce uniqueness using a Hash index...</p>
<h3 id="enforcing-uniqueness-using-a-hash-index"><a href="#enforcing-uniqueness-using-a-hash-index">Enforcing Uniqueness Using a Hash Index</a></h3>
<p>PostgreSQL offers a special type of constraint called an <a href="https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-EXCLUSION" rel="noopener">exclusion constraint</a>. This lesser-known and not-so-widely-used constraint is often mentioned in combination with a GIN or GiST index as a way to <a href="https://www.postgresql.org/docs/18/rangetypes.html#RANGETYPES-CONSTRAINT" rel="noopener">prevent overlapping ranges</a>. However, using an exclusion constraint we can effectively enforce uniqueness using a Hash index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>urls</span><span> </span><span>ADD</span><span> </span><span>CONSTRAINT</span><span> </span><span>urls_url_unique_hash</span><span> </span><span>EXCLUDE</span><span> </span><span>USING</span><span> </span><span>HASH</span><span> </span><span>(</span><span>url</span><span> </span><span>WITH</span><span> </span><span>=</span><span>);</span>
<span>ALTER</span><span> </span><span>TABLE</span>
</pre></div>


<p>This adds an exclusion constraint on the table that prevents two rows with the same URL - this guarantees uniqueness. The exclusion constraint is enforced using a Hash index - this means we effectively enforce uniqueness with a Hash index!</p>
<p>First, verify that uniqueness is indeed enforced:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_002</span><span>,</span><span> </span><span>&#39;https://hakbenita.com/postgresql-hash-index&#39;</span><span>);</span>
<span>INSERT</span><span> </span><span>0</span><span> </span><span>1</span>

<span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_003</span><span>,</span><span> </span><span>&#39;https://hakbenita.com/postgresql-hash-index&#39;</span><span>);</span>
<span><span>ERROR</span><span>:</span><span>  </span><span>conflicting</span><span> </span><span>key</span><span> </span><span>value</span><span> </span><span>violates</span><span> </span><span>exclusion</span><span> </span><span>constraint</span><span> </span><span>&#34;urls_url_unique_hash&#34;</span>
</span><span>DETAIL</span><span>:</span><span>  </span><span>Key</span><span> </span><span>(</span><span>url</span><span>)</span><span>=</span><span>(</span><span>https</span><span>:</span><span>//</span><span>hakbenita</span><span>.</span><span>com</span><span>/</span><span>postgresql</span><span>-</span><span>hash</span><span>-</span><span>index</span><span>)</span><span> </span><span>conflicts</span><span> </span><span>with</span>
<span>existing</span><span> </span><span>key</span><span> </span><span>(</span><span>url</span><span>)</span><span>=</span><span>(</span><span>https</span><span>:</span><span>//</span><span>hakbenita</span><span>.</span><span>com</span><span>/</span><span>postgresql</span><span>-</span><span>hash</span><span>-</span><span>index</span><span>).</span>
</pre></div>


<p>Attempting to add a row with a URL that already exists failed with an exclusion constraint violation. Good.</p>
<p>Next, can this Hash index be useful for queries that filter for specific urls?</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>EXPLAIN</span><span> </span><span>(</span><span>ANALYZE</span><span> </span><span>ON</span><span>,</span><span> </span><span>BUFFERS</span><span> </span><span>OFF</span><span>,</span><span> </span><span>COSTS</span><span> </span><span>OFF</span><span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>urls</span><span> </span><span>WHERE</span><span> </span><span>url</span><span> </span><span>=</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>;</span>
<span>                                         </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>────────────────────────────────────────────────────────────────────────────────────────────</span>
<span> </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>urls_url_unique_hash</span><span> </span><span>on</span><span> </span><span>urls</span><span> </span><span>(</span><span>actual</span><span> </span><span>time</span><span>=</span><span>0</span><span>.</span><span>010</span><span>..</span><span>0</span><span>.</span><span>011</span><span> </span><span>rows</span><span>=</span><span>1</span><span>.</span><span>00</span><span> </span><span>loops</span><span>=</span><span>1</span><span>)</span>
<span>   </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>(</span><span>url</span><span> </span><span>=</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>::</span><span>text</span><span>)</span>
<span>   </span><span>Index</span><span> </span><span>Searches</span><span>:</span><span> </span><span>1</span>
<span> </span><span>Planning</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>178</span><span> </span><span>ms</span>
<span> </span><span>Execution</span><span> </span><span>Time</span><span>:</span><span> </span><span>0</span><span>.</span><span>022</span><span> </span><span>ms</span>
</pre></div>


<p>Yes it can, and in this case it&#39;s even faster than using the B-Tree index (0.022ms vs 0.046ms).</p>
<p>Finally, compare the size of the B-Tree and the Hash index:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>\</span><span>di</span><span>+</span><span> </span><span>urls_url_</span><span>*</span>
<span>                </span><span>List</span><span> </span><span>of</span><span> </span><span>indexes</span>
<span>        </span><span>Name</span><span>         </span><span>│</span><span> </span><span>Access</span><span> </span><span>method</span><span> </span><span>│</span><span>  </span><span>Size</span>
<span>─────────────────────┼───────────────┼────────</span>
<span>urls_url_unique_hash</span><span> </span><span>│</span><span> </span><span>hash</span><span>          </span><span>│</span><span> </span><span>32</span><span> </span><span>MB</span>
<span>urls_url_unique_ix</span><span>   </span><span>│</span><span> </span><span>btree</span><span>         </span><span>│</span><span> </span><span>154</span><span> </span><span>MB</span>
</pre></div>


<p>Amazing! The Hash index is x5 smaller than the corresponding B-Tree index. Instead of storing those large URLs in the B-Tree leaf blocks, the Hash index stores only the hash values which results in a significantly smaller index.</p>
<h3 id="limitation-of-unique-exclusion-constraints"><a href="#limitation-of-unique-exclusion-constraints">Limitation of &#34;Unique&#34; Exclusion Constraints</a></h3>
<p>Using an exclusion constraint to enforce uniqueness with a Hash index can potentially save storage and make queries faster. However, there are a few caveats to consider with this approach:</p>
<p>⚠️ <strong>Column cannot be referenced by foreign keys</strong></p>
<p>PostgreSQL requires that a foreign key reference a unique constraint. Since we can&#39;t define a unique hash constraint, we can&#39;t point a foreign key to it:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>foo</span><span> </span><span>(</span><span>url</span><span> </span><span>TEXT</span><span> </span><span>REFERENCES</span><span> </span><span>urls</span><span>(</span><span>url</span><span>));</span>
<span>ERROR</span><span>:</span><span>  </span><span>there</span><span> </span><span>is</span><span> </span><span>no</span><span> </span><span>unique</span><span> </span><span>constraint</span><span> </span><span>matching</span><span> </span><span>given</span><span> </span><span>keys</span><span> </span><span>for</span><span> </span><span>referenced</span><span> </span><span>table</span><span> </span><span>&#34;urls&#34;</span>
</pre></div>


<p>⚠️ <strong>Limitations on <code>INSERT ... ON CONFLICT</code></strong></p>
<p>The <code>ON CONFLICT</code> clause in an <code>INSERT</code> command is common and very useful for syncing data. Unfortunately, using exclusion constraints with this clause can have some rough edges.</p>
<p>Attempting to use an exclusion constraint with a list of fields in an <code>ON CONFLICT ... DO NOTHING</code> clause can fail:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_004</span><span>,</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>)</span>
<span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>url</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span><span>;</span>
</span><span>ERROR</span><span>:</span><span>  </span><span>there</span><span> </span><span>is</span><span> </span><span>no</span><span> </span><span>unique</span><span> </span><span>or</span><span> </span><span>exclusion</span><span> </span><span>constraint</span><span> </span><span>matching</span><span> </span><span>the</span><span> </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>specification</span>
</pre></div>


<p>The message suggests that it should be possible to use an exclusion, and it is, but using the <code>ON CONFLICT ON CONSTRAINT</code> clause instead:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_004</span><span>,</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>)</span>
<span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>ON</span><span> </span><span>CONSTRAINT</span><span> </span><span>urls_url_unique_hash</span><span> </span><span>DO</span><span> </span><span>NOTHING</span><span>;</span>
</span><span>INSERT</span><span> </span><span>0</span><span> </span><span>0</span>
</pre></div>


<p>Trying the same with <code>ON CONFLICT ... DO UPDATE</code> is not possible at all, even when using <code>ON CONFLICT ON CONSTRAINT</code>:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>1</span><span>_000_004</span><span>,</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>)</span>
<span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>ON</span><span> </span><span>CONSTRAINT</span><span> </span><span>urls_url_unique_hash</span><span> </span><span>DO</span><span> </span><span>UPDATE</span><span> </span><span>SET</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>EXCLUDED</span><span>.</span><span>id</span><span>;</span>
<span><span>ERROR</span><span>:</span><span>  </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>DO</span><span> </span><span>UPDATE</span><span> </span><span>not</span><span> </span><span>supported</span><span> </span><span>with</span><span> </span><span>exclusion</span><span> </span><span>constraints</span>
</span></pre></div>


<p>I&#39;m not a big fan of using the constraint names in SQL, so to overcome both limitations I&#39;de use <code>MERGE</code> instead:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>MERGE</span><span> </span><span>INTO</span><span> </span><span>urls</span><span> </span><span>t</span>
<span>USING</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>1000004</span><span>,</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>s</span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span>
<span>ON</span><span> </span><span>t</span><span>.</span><span>url</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>url</span>
<span>WHEN</span><span> </span><span>MATCHED</span><span> </span><span>THEN</span><span> </span><span>UPDATE</span><span> </span><span>SET</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>id</span>
<span>WHEN</span><span> </span><span>NOT</span><span> </span><span>MATCHED</span><span> </span><span>THEN</span><span> </span><span>INSERT</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>url</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>s</span><span>.</span><span>id</span><span>,</span><span> </span><span>s</span><span>.</span><span>url</span><span>);</span>
<span>MERGE</span><span> </span><span>1</span>
</pre></div>


<p>Finally, check the execution plan to verify that the statement is capable of using the Hash index:</p>
<div><pre><span></span><span>                                  </span><span>QUERY</span><span> </span><span>PLAN</span>
<span>────────────────────────────────────────────────────────────────────────────────────────────</span>
<span>Merge</span><span> </span><span>on</span><span> </span><span>urls</span><span> </span><span>t</span><span>  </span><span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>8</span><span>.</span><span>04</span><span> </span><span>rows</span><span>=</span><span>0</span><span> </span><span>width</span><span>=</span><span>0</span><span>)</span>
<span>  </span><span>-&gt;</span><span>  </span><span>Nested</span><span> </span><span>Loop</span><span> </span><span>Left</span><span> </span><span>Join</span><span>  </span><span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>8</span><span>.</span><span>04</span><span> </span><span>rows</span><span>=</span><span>1</span><span> </span><span>width</span><span>=</span><span>6</span><span>)</span>
<span>      </span><span>-&gt;</span><span>  </span><span>Result</span><span>  </span><span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>0</span><span>.</span><span>01</span><span> </span><span>rows</span><span>=</span><span>1</span><span> </span><span>width</span><span>=</span><span>0</span><span>)</span>
<span><span>      </span><span>-&gt;</span><span>  </span><span>Index</span><span> </span><span>Scan</span><span> </span><span>using</span><span> </span><span>urls_url_unique_hash</span><span> </span><span>on</span><span> </span><span>urls</span><span> </span><span>t</span><span>  </span><span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>8</span><span>.</span><span>02</span><span> </span><span>rows</span><span>=</span><span>1</span><span> </span><span>width</span><span>=</span><span>6</span><span>)</span>
</span><span>          </span><span>Index</span><span> </span><span>Cond</span><span>:</span><span> </span><span>(</span><span>url</span><span> </span><span>=</span><span> </span><span>&#39;https://hakibenita.com&#39;</span><span>::</span><span>text</span><span>)</span>
</pre></div>


<p>It can, and it did!</p>
<p>Despite these minor limitations and inconveniences, a Hash index is a good candidate for enforcing uniqueness of large values that don&#39;t need to be referenced by foreign keys.</p>
    </article></div>
  </body>
</html>
