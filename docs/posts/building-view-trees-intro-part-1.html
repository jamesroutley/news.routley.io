<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-1/">Original</a>
    <h1>Building view-trees: Intro [Part 1]</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>When I was at Etsy, we built a server-side component library called
View Trees, but also called <code>neu</code> (because this was quicker to type).</p>
<p>This is referenced in this <a rel="nofollow noreferrer" href="https://www.etsy.com/codeascraft/mobius-adopting-jsx-while-prioritizing-user-experience">Code As Craft</a> blog post, which is about
extending/updating the framework to output server-rendered JSX components.</p>
<p>After futzing around with <a rel="nofollow noreferrer" href="https://vuejs.org/">Vue</a> in present-me, and then reading more about
similar-to-neu approaches for doing client-side interaction (like <a rel="nofollow noreferrer" href="https://htmx.org/">htmx</a>,
and others) based on server side rendering I wanted to revisit this library,
but from a Go perspective.</p>
<hr/>
<p>This is going to be a series of posts describing an iterative approach to
building this out, aming to explain why things look and the way they do through
specific problems and solutions to them.</p>
<p><strong>Things to keep in mind</strong></p>
<ul>
<li>In Go, we have built-in templates with the <a rel="nofollow noreferrer" href="https://pkg.go.dev/html/template"><code>html/template</code></a>
package, and a standard way of compiling and rendering templates.
We&#39;re not introducing a new templating language. And want to leverage
the way folks already write their templates, but give them different
ways to compose them (not inclusion, not inheritence).</li>
<li>There are standard HTTP handlers in the <code>net/http</code> package, try
to integrate with that using middleware (and other standard patterns)
and not introduce any http routing or anything else.</li>
<li>We want to make the interfaces small, and the composition simple and obvious.</li>
<li>Errors are recoverable!</li>
</ul>
<h2 id="how-does-go-do-templates">How does go do templates?</h2>
<p>The idiomatic way to render HTML templates is to write some data
to a buffer via <code>tpl.Execute</code>:</p>
<pre data-lang="go"><code data-lang="go"><span>import </span><span>&#34;html/template&#34;
</span><span>
</span><span>contents </span><span>:= </span><span>`&lt;div&gt;Hi, </span><span>{{ .Name }}</span><span>&lt;/div&gt;`
</span><span>tpl </span><span>:= </span><span>template.Must(template.New(</span><span>&#34;hi&#34;</span><span>).Parse(contents))
</span><span>
</span><span>var </span><span>bs bytes.</span><span>Buffer
</span><span>err </span><span>:= </span><span>tpl.Execute(</span><span>&amp;</span><span>bs, </span><span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>{</span><span>&#34;Name&#34;</span><span>: </span><span>&#34;Stan&#34;</span><span>})
</span></code></pre>
<p>The above snippet is an extremely simplified version of what you would
do. Idiomatically, one would expect template compilation from external
files that are embedded into your binary and compiled and a named type
for the template data, error handling, and maybe writing to
an <code>http.ResponseWriter</code>.</p>

<pre data-lang="go"><code data-lang="go"><span>html, err </span><span>:= </span><span>Render(PersonView(Person{Name: </span><span>&#34;Stan&#34;</span><span>}))
</span></code></pre>
<p>Conceptually, what we have is piece of data, let&#39;s say a <code>Person</code> struct,
and an html view of that that knows how to take that data and render
it into HTML. We can, of course, just make a function that does this
for the use case above.</p>
<p>But what we want is something like this:</p>
<ul>
<li>A <code>Render</code> function that render&#39;s a view.</li>
<li>A view that is parameterized by a struct.</li>
<li>Outputting valid HTML.</li>
</ul>
<p>The larger semantic difference is we are lifting the way we desribe
our data inputs and views into being first-class &#34;objects&#34; (structs
that can possibly have behaviors and guarantees) so we can leverage
the language to do composition, parameterization, polymorphism,
etc... so we can do things like components :)</p>
<hr/>
<h3 id="next">Next:</h3>
<ul>
<li><a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-2">The basics</a></li>
</ul>

        </section></div>
  </body>
</html>
