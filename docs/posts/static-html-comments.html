<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sive.rs/shc">Original</a>
    <h1>Static HTML Comments</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
<header>


<small>2022-10-08</small>
</header>

<p>
	If you have a static HTML website, but you want to include comments, here’s an interesting way to do it using PostgreSQL’s NOTIFY and LISTEN.
</p><p>
	The big idea is to <strong>write the comments as static HTML, only when comments change</strong>, instead of doing a database query to display them every time.
	This prevents the “hug of death” if you get a burst of traffic.
</p><p>
	I’ve been doing it this way for over six years, and it works great.
	Here’s the recipe, using Ruby as the glue, though you could use any scripting language.
</p>
<ol><li>
	PostgreSQL database table for comments
</li><li>
	Ruby receives form posts, inserts into database
</li><li>
	When comments change, PostgreSQL trigger sends NOTIFY
</li><li>
	Ruby runs PostgreSQL LISTEN, exporting updated comments to HTML
</li><li>
	JavaScript on static page includes HTML
</li></ol>

<h2>
	PostgreSQL database table for comments
</h2>
<div>
<pre><code>create table comments (
  id integer primary key generated by default as identity,
  uri text,
  created_at date default current_date,
  name text,
  email text,
  comment text
);
create index on comments(uri);
</code></pre><p><small><a href="https://sive.rs/code/comments-table.sql">download code</a></small>
</p></div>

<h2>
	Ruby receives form posts, inserts into database
</h2>

<p>
	Put this on any HTML page where you want comments:
</p>
<div>
<pre><code>&lt;section id=&#34;comments&#34;&gt;&lt;/section&gt;
&lt;script src=&#34;/comments.js&#34;&gt;&lt;/script&gt;
</code></pre><p><small><a href="https://sive.rs/code/comments.html.txt">download code</a></small>
</p></div>

<p>
	Put this next code in your Nginx config, to send /comments to localhost.
</p>
<div>
<pre><code>location = /comments {
  proxy_pass http://127.0.0.1:4567;
}
</code></pre><p><small><a href="https://sive.rs/code/comments.nginx.conf">download code</a></small>
</p></div>

<p>
	Ruby Sinatra receives form posts.
</p>
<div>
<pre><code>require &#39;pg&#39;
require &#39;sinatra&#39;
DB = PG::Connection.new(dbname: &#39;test&#39;, user: &#39;tester&#39;)

post &#39;/comments&#39; do
  DB.exec_params(&#34;insert into comments
    (uri, name, email, comment)
    values ($1, $2, $3, $4)&#34;,
    [params[:uri], params[:name], params[:email], params[:comment]])
  redirect to(request.env[&#39;HTTP_REFERER&#39;])
end
</code></pre><p><small><a href="https://sive.rs/code/comments-route.rb">download code</a></small>
</p></div>

<p>
	Run that in a terminal on the server, and it should default to listen on port 4567.
</p>

<h2>
	When comments change, PostgreSQL trigger sends NOTIFY
</h2>
<div>
<pre><code>create function comments_changed() returns trigger as $$
begin
  perform pg_notify(&#39;comments_changed&#39;, new.uri);
  return new;
end;
$$ language plpgsql;
create trigger comments_changed after insert or update on comments
for each row execute procedure comments_changed();
</code></pre><p><small><a href="https://sive.rs/code/comments_changed.sql">download code</a></small>
</p></div>

<p>
	Load that function into the PostgreSQL database that has your comments table.
</p><p>
	It sends the listener (below) a notification that comments for <strong>this URI</strong> have changed.
	Then the listener will re-output comments just for this URI, instead of all.
</p>

<h2>
	Ruby runs PostgreSQL LISTEN, exporting updated comments to HTML
</h2>
<p>
	Make a directory in your web root called /commentcache/, to hold the static comments.
</p><p>
	Then keep this Ruby script running in a terminal to listen for database changes, and write the updated comments to disk as HTML.
</p>
<div>
<pre><code>require &#39;pg&#39;
DB = PG::Connection.new(dbname: &#39;test&#39;, user: &#39;tester&#39;)
BASEDIR = &#39;/var/www/htdocs/commentcache/&#39; # directory in your web root

# a single comment list entry, used in ol map, below
def li(row)
  &#39;&lt;li&gt;&lt;cite&gt;%s (%s)&lt;/cite&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/li&gt;&#39; %
    [row[&#39;name&#39;], row[&#39;created_at&#39;], row[&#39;comment&#39;]]
end

# top-level map of database rows into HTML list
def ol(rows)
  rows.inject(&#39;&#39;) {|html, row| html += li(row) ; html}
end

# write comments to disk for this URI
def save_comments(uri)
  rows = DB.exec_params(&#34;select name, created_at, comment
    from comments where uri = $1 order by id&#34;, [uri]).to_a
  File.open(BASEDIR + uri, &#39;w&#39;) do |f|
    f.puts ol(rows)
  end
end

# first write them all
DB.exec(&#34;select distinct(uri) from comments&#34;).each do |r|
  save_comments(r[&#39;uri&#39;])
end

# listen for changes. re-write when changed
DB.exec(&#39;listen comments_changed&#39;)
while true do
  DB.wait_for_notify do |event, pid, uri|
    save_comments(uri)
  end
end
</code></pre><p><small><a href="https://sive.rs/code/comments-listen.rb">download code</a></small>
</p></div>

<h2>
	JavaScript on static page includes current HTML when viewed
</h2>
<p>
	Use JavaScript to show the form to post a comment, and load the list of comments from the /commentcache/ path.
</p>
<div>
<pre><code>function showForm(uri) {
  document.getElementById(&#39;comments&#39;).innerHTML = `
&lt;header&gt;&lt;h1&gt;Comments:&lt;/h1&gt;&lt;/header&gt;
&lt;form method=&#34;post&#34; action=&#34;/comments&#34;&gt;
&lt;input type=&#34;hidden&#34; name=&#34;uri&#34; value=&#34;${uri}&#34;&gt;
&lt;label for=&#34;name&#34;&gt;Your Name&lt;/label&gt;
&lt;input type=&#34;text&#34; name=&#34;name&#34; id=&#34;name&#34; required&gt;
&lt;label for=&#34;email&#34;&gt;Your Email&lt;/label&gt;
&lt;input type=&#34;email&#34; name=&#34;email&#34; id=&#34;email&#34; required&gt;
&lt;label for=&#34;comment&#34;&gt;Comment&lt;/label&gt;
&lt;textarea name=&#34;comment&#34; id=&#34;comment&#34; cols=&#34;80&#34; rows=&#34;10&#34; required&gt;&lt;/textarea&gt;
&lt;input type=&#34;submit&#34; value=&#34;post comment&#34;&gt;
&lt;/form&gt;
&lt;ol id=&#34;commentlist&#34;&gt;&lt;/ol&gt;`;
}

function getComments(uri) {
  try {
    const xhr = new XMLHttpRequest();
    xhr.open(&#39;get&#39;, &#39;/commentcache/&#39; + uri);
    xhr.send(null);
    xhr.onload = function() {
      if (xhr.status === 200) {
        document.getElementById(&#39;commentlist&#39;).innerHTML = xhr.responseText;
      }
    };
  } catch(e) { }
}

// /blog/topic/page.html uri = &#39;blog_topic_page.html&#39; for filesystem
const uri = location.pathname.substring(1).replace(/\//g, &#39;_&#39;);
showForm(uri);
getComments(uri);
</code></pre><p><small><a href="https://sive.rs/code/comments.js">download code</a></small>
</p></div>

<p>
	That’s all.
	I’ve simplified it a bit from my real usage, where I have constraints and checks that would have distracted from the core point of this example.
</p><p>
	There are other ways to do it.
	The NOTIFY and LISTEN isn’t necessary.
	The Ruby Sinatra route that receives the posted comment could just write the HTML to disk immediately.
	But I have other scripts that delete and update comments, and I like how <strong>the combination of NOTIFY trigger and LISTEN script always keeps them updated</strong> on disk.
</p><p>
	Another interesting approach would be to write the comments into each HTML file directly, instead of in a separate file, so you wouldn’t need JavaScript at all.
</p>

<h2>
	Optional upgrade: NOTIFY on delete
</h2>
<p>
	I simplified the PostgreSQL trigger for the example, but with a few more lines of code, you can use the same trigger to notify of deleted comments, too.
	The value of a deleted row is in “old”, whereas inserted and updated is in “new”, so we have to make a uri variable, and an if/then/else to know which to use.
</p>
<div>
<pre><code>create or replace function comments_changed() returns trigger as $$
declare
  uri text;
begin
  if tg_op = &#39;DELETE&#39; then
    uri = old.uri;
  else
    uri = new.uri;
  end if;
  perform pg_notify(&#39;comments_changed&#39;, uri);
  return old;
end;
$$ language plpgsql;
create trigger comments_changed after insert or update or delete on comments
for each row execute procedure comments_changed();
</code></pre><p><small><a href="https://sive.rs/code/comments_changed2.sql">download code</a></small>
</p></div>



</article>


</div></div>
  </body>
</html>
