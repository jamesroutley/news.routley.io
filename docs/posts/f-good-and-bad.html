<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielbmarkham.com/f-good-and-bad/">Original</a>
    <h1>F# Good and Bad</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body">
        <p>I like F# because it&#39;s the best programming <em>training</em> language I&#39;ve found. There are probably better, and as NET evolves F# is getting shakier and more byzantine, but it still works great for making me think about and become a better programmer, no matter what language I use in everyday work.</p><p>That means that when I step away from the language and come back, I learn something about <em>the way I think</em>. I can also see this in others; people grasp to turn their thoughts into code. It&#39;s fascinating to watch the struggle, both in myself and others.</p><p>My net has been out, but it came back up yesterday. To relax I decided to start on the <a href="https://adventofcode.com/2021">Advent of Code 2021</a>. It&#39;s a website that gives you a couple of problems for each day in December up to Christmas Day. You can solve them any way you want. Because of that it&#39;s become a central place in December for coders all over the world to play at solving sample problems. Think of it as <a href="https://en.wikipedia.org/wiki/Sudoku">Sudoku</a> for nerds. I&#39;m not sure there&#39;s anything you get out of it aside from the dopamine hit of hey, that&#39;s pretty neat. I explained it to my SO and she shook her head sadly. Most folks do not get it.</p><p>Today I dropped by the <a href="https://old.reddit.com/r/fsharp/">Reddit F# forum</a> and sure enough, there were some posts with programmers struggling. I found the advice given both good and bad at the same time, and that inner conflict fascinated me. </p><figure><img src="https://danielbmarkham.com/content/images/2021/12/cat-consultant.jpg" alt="" srcset="https://danielbmarkham.com/content/images/size/w600/2021/12/cat-consultant.jpg 600w, https://danielbmarkham.com/content/images/2021/12/cat-consultant.jpg 625w"/></figure><h2 id="questions-that-have-opposite-answers-and-why-">Questions That Have Opposite Answers (and why)</h2><h3 id="have-i-typed-this-code-in-right">Have I typed this code in right?</h3><p>In any programming language, there are a lot of different ways to do the same thing. Do you want to use Int32.Parse(num) or (int)num? Do you want to pass an unmodified single-argument function into a lambda or just collapse it all, e.g. <code>List.map (fun d -&gt; Int32.Parse(d))</code> or <code>List.map int</code>?</p><p>F# is cool ecause these questions of code collapse go on and on. Eventually you end up in <a href="https://en.wikipedia.org/wiki/Tacit_programming">point-free world</a>, where foo|&gt;bar|&gt;baz and so on. So really this is a question of what should you clean up, when should you clean up, and why should you clean up?</p><p>I&#39;ve found that this is best done once you have pure functional code. Mutability and options confuse and muddy up everything. You can most always get rid of them. Once you do, you&#39;ll have a hell of a fun time collapsing all of this down to a point-free masterpiece. (To me it&#39;s a better feeling that doing AOC because you&#39;re working on real-world problems). This advice is right, and you&#39;re welcome to learn and use these kinds of simplicities any time you&#39;d like. This advice is wrong; you probably shouldn&#39;t be shining up the wheels on the fire truck when there&#39;s a house on fire. The advice is good and bad.</p><h3 id="you-want-your-f-code-to-be-the-performant-code-and-use-oo-languages-like-c-code-for-your-real-work-right">You want your F# code to be the performant code and use OO languages like C# code for your real work, right?</h3><p>Microsoft is responsible for this bullshit. They wanted a way to advertise F# to their existing codebase, and somehow when they cranked the marketing sausage-making machine, &#34;F# is great for specialized problems!&#34; came out. We do &#34;special&#34; problems: performant, scientific, integral calculus. That kind of thing.</p><p>This is good advice because if you want performant code, go pure functional and then you get distributed processing and scaling for free. Object-oriented code tends to hide what you&#39;re doing behind abstractions for other types of problems that the library creators had in mind when they made the library. With F# (and other functional languages) you&#39;re on your own. This should &#34;make&#34; you code a different way. (Sadly, it does not, and mixing up programming language paradigms is the end of Western Civilization, but that&#39;s a topic for another day).</p><p>This is bad advice because unless you know the rest of the story, you really don&#39;t get anything than you had before, only now you&#39;ve scattered your solution into even more buckets and languages.</p><h3 id="you-want-to-use-ide-tools-here">You want to use $IDE/TOOLS here</h3><p>Programming, the language, the tools, the community, the rest of it – it&#39;s an environment where you either become a better coder over time or a worse one. Have a lot of bugs? Do a lot of code maintenance (not cleanup) that doesn&#39;t involve new features? You&#39;re going down the wrong path. The rest of that doesn&#39;t matter. At all. You can code everything you want in Visual Sumerian or Reverse Klingon– for all I care.</p><p>It&#39;s good because good tools matter. It&#39;s bad because you gotta struggle through this yourself. If one set of stuff worked for everybody, robots would be doing your job. Robots are not doing your job.</p><h3 id="i-m-using-aoc-and-f-to-learn-x">I&#39;m using AOC and F# to learn $X</h3><p>Yay! None of this applies to you. Learning means taking a deep dive along one topic. Making useful stuff means looking at end value and then taking the simplest, most maintainable path to delivering that value. These two concepts are <a href="https://en.wikipedia.org/wiki/Mutually_orthogonal_Latin_squares">mutually orthogonal</a>, although focusing on one of them can make the other better.</p><h2 id="okay-wise-guy-what-s-your-answer">Okay, Wise Guy, What&#39;s Your Answer?</h2><p>My code sucks and I wouldn&#39;t post it in a forum. I&#39;d be afraid others would copy it.</p><p>Here&#39;s some from Day 2:</p><pre><code>let countOnesInABitPosition (n:int) (stringList:string list)=stringList|&gt;List.sumBy(fun x-&gt;if checkIfOneIsAtIndex x n then 1 else 0);;
let countZeroesInABitPosition (n:int) (stringList:string list)=stringList|&gt;List.sumBy(fun x-&gt;if checkIfOneIsAtIndex x n then 0 else 1);;
let mostPopularBitForAPosition (n:int) (stringList:string list) = 
  if (countOnesInABitPosition n stringList)&gt;(countZeroesInABitPosition n stringList) then 1 else 0;;
let leastPopularBitForAPosition (n:int) (stringList:string list) = 
  if (countOnesInABitPosition n stringList)&gt;(countZeroesInABitPosition n stringList) then 0 else 1;;
let getMostPopBits(stringList: string list):int [] =
  stringList.[0].ToCharArray()|&gt;Array.mapi(fun i x-&gt;(mostPopularBitForAPosition i stringList ));;
</code></pre><p>I could go on for a <strong>very</strong> long time about all of the problems here. We&#39;ve got strong typing where it&#39;s not needed, huge functions with single-variable lambdas that aren&#39;t collapsed. My critique goes on and on. I suck at writing really cool code when I&#39;m cold and I first sit down with my tools to code. As I&#39;ve gotten older the problem has just gotten worse. This has taught me more about teaching and understanding programming than decades of actually teaching programming has.</p><figure><img src="https://danielbmarkham.com/content/images/2021/12/cable-porn-example.jpeg" alt="" srcset="https://danielbmarkham.com/content/images/size/w600/2021/12/cable-porn-example.jpeg 600w, https://danielbmarkham.com/content/images/2021/12/cable-porn-example.jpeg 720w" sizes="(min-width: 720px) 720px"/></figure><p><strong><em>The point here is about how to get to the goal of excellent code, not what your excellent code looks like.</em></strong></p><p>This is my main problem with coding advice, including my own: it confuses the two domains in the mind of the person trying to learn. Learn something or solve something. If you&#39;re learning, it doesn&#39;t matter whether you end up doing anything useful or not. Most times not. If you&#39;re solving, none of this bullshit matters at all. Instead you&#39;ve got to get good and making the benefit force itself out of the tech in the simplest, most maintainable fashion possible.</p><p>In that manner, when I look at code like mine above, I&#39;ve put in all of this bad-code noise so that I can understand and organize the solution to the problem. <a href="https://danielbmarkham.com/incremental-strong-typing/">It passes the acceptance tests and only those tests. [1] Nothing outside is affected</a>. If I come back in a month and can read the code, if a new person to F# can read the code? I&#39;m rocking the problem-solving domain.</p><p>Compare that code to the main code to <a href="https://github.com/DanielBMarkham/SuperCompilerDemo2/blob/master/Microservice1/Library.fs#L46-L63">a compiler framework I created a few years ago</a>: [2]</p><figure><pre><code>  let runInternally:RunInternallyFunction=
    (fun (argv,incomingsStreamsFromOS)-&gt;
    getConfig argv
    |&gt; getIncomingStream
    |&gt; processIncomingData
    |&gt; translateIncomingDataToBusinessData
    |&gt; validateBusinessDataWithItself
    |&gt; processBusinessData
    |&gt; createOutgoingStreams
    |&gt; returnTransformedDataToCaller)</code></pre><figcaption>I can make a small change here, compose things a bit differently, and as a result either run this code as a microservice, a monolith, part of an event store, a massively-distribued app, handle the back-end of a web app, or use DI to test it in a stand-alone fashion. Is good! This is where any programmer should want to be.</figcaption></figure><p>There&#39;s nothing here to fix. It&#39;s appropriately-typed, it&#39;s point-free, tacit, and composable. It&#39;s pure functional code and it reads well in English. This is the kind of code I tend to post (and read) online. I love code like this. I love writing it and I love reading how others code this way.</p><p>Here&#39;s a <a href="https://github.com/DanielBMarkham/easyam/blob/master/easyam/Program.fs#L180-L202">middle-of-the-road example from an analysis compiler I was developing back in 2016</a>:</p><figure><pre><code>

    [&lt;EntryPoint&gt;]
    let main argv = 
        try
            let opts = loadConfigFromCommandLine argv
            commandLinePrintWhileEnter opts.configBase (opts.printThis)
            let outputDirectories = doStuff opts
            commandLinePrintWhileExit opts.configBase
            0
        with
            | :? UserNeedsHelp as hex -&gt;
                defaultBaseOptions.printThis
                0
            | ex -&gt;
                System.Console.WriteLine (&#34;Program terminated abnormally &#34; + ex.Message)
                System.Console.WriteLine (ex.StackTrace)
                if ex.InnerException = null
                    then
                        0 
                    else
                        System.Console.WriteLine(&#34;---   Inner Exception   ---&#34;)
                        System.Console.WriteLine (ex.InnerException.Message)
                        System.Console.WriteLine (ex.InnerException.StackTrace)
                        0 </code></pre><figcaption>(I used the &#34;main&#34; loop of the program to provide context that most coders would understand)</figcaption></figure><p>This is also noisy. There&#39;s assignments, big-honking catch-all try/with blocks. Hell, there&#39;s even printfs in there. That&#39;s the thing you never do!</p><p>The first example was a complete mess of code. The second example is code that I consider, for lack of a better word, beautiful. This last example looks confused to me. I can see what&#39;s going on, but all of those blocks and printfs, along with other factors, make me leery of praising this too much. I can see I&#39;m going to have to come back here.</p><p><em>All of these code examples pass their acceptance tests</em>. None of these are broken from the standpoint of the outside caller or end-user. So if you want to talk style or idiomatic code, the middle one is coded in the most popular way. The other two are not.</p><p>But none of this is right or wrong. The code passes its tests, end of story. What we&#39;re looking at here in the difference in coding constructs represents <strong>how the mind of the programmer is beginning to understand the actual problem to be solved.</strong> The Advent of Code example has all kinds of huge variable names and step-by-step coding because inside my mind I&#39;m thrashing through just what the hell this guy is wanting me to solve, not how to program in F#. I already know that. By the same token, the second example represents a domain where I know exactly what the business problem is. I don&#39;t expect to have to think about this again. </p><p>The &#34;coolness&#34; of the functional code represents the inner programming process. You can&#39;t evaluate it on its own. The AOC code I might flail around for a while getting to work. I might have to come back and modify it. I have plenty of confidence in my ability to code well. What I&#39;m not so sure about is whether or not I&#39;m understanding what I&#39;m supposed to be doing. It&#39;s all context. On the other end, the framework code represents a problem domain I feel I have mastered. It&#39;s good words and I can understand them, but it tells me nothing really about what I&#39;m doing. It&#39;s context-free. It&#39;s not cool-looking code because I know how to code well. It&#39;s cool-looking code because I&#39;m done with analysis.</p><p>The last example represents a problem where I&#39;m both the PO and the coder. In this case I&#39;m both deciding the general problem to solve and bouncing back-and-forth between understanding the problem better and changing where I want to go. It&#39;s a story for another day, but none of this has anything to do with how to code in F#. I don&#39;t code poorly or wonderfully based on how much F# I know. It flows in the opposite direction: F# shows me how much of the problem I know. In this way, great F#/Pure FP coding help can actually be detrimental to being a good programmer. You&#39;re becoming excellent at covering up the one thing the code is supposed to tell you: just what the hell you&#39;re supposed to be doing here.</p><figure><img src="https://danielbmarkham.com/content/images/2021/12/dog-typing-on-a-computer.gif" alt=""/><figcaption>The trick to programming is to realize there is no programming. There is only dog.</figcaption></figure><p>And there&#39;s the problem and the reason for this essay: the more I clean up, the more I&#39;m moving away from being able to maintain. Similarly, if I over-clean too early I end up with bugs I don&#39;t understand. I&#39;m optimizing along the wrong path.</p><p>On the flip side, if my code passes the tests and I&#39;m not going to ever look at it again? <a href="https://danielbmarkham.com/for-the-love-of-all-thats-holy-use-ccl-to-control-complexity-in-your-systems/">All of that noise collapses down into magic piping.</a>[3] The universe is pleased. F# (the way I use it) forces me on the journey from solving problems to writing better code. I end up doing that over and over again. That both makes me a better programmer and somebody who can solve problems faster.</p><p>We&#39;re teaching and showing off how to program cool at the expense of teaching people how to actually be a programmer. That&#39;s fucked up. You shouldn&#39;t do one without the other. The topics don&#39;t split up in that way.</p><p><a href="https://danielbmarkham.com/is-programming-hard-how-long-is-a-piece-of-string/">Code stupid</a>. [4]<a href="https://danielbmarkham.com/code-budgets/"> Clean smart</a>.[5] <a href="https://danielbmarkham.com/good-enough-programming/">Always write code you can walk away from</a>.[6]</p><p>Out.</p><hr/><ol><li>I come from a C++/C#/Java OOP background. As I got into pure functional programming, I struggled for a long time about the role of types and Domain Driven Design. I eventually settled on this conclusion [insert long discussion here]: Outside a pure function, only use types that have direct business value to that function, ie, microservices should implement true business features and only true business features. I began covering this topic in my essay <a href="https://danielbmarkham.com/incremental-strong-typing/">&#34;Incremental Strong Typing&#34;</a></li><li>Following this line of reasoning, I realized that strong types could (and should) exist outside of the microservices that implement them. It&#39;s called acceptance tests. I covered this in my essay <a href="https://danielbmarkham.com/honest-microservices/">&#34;Writing Honest Microservices&#34;</a> Writing code this way, your microservices become pure functions, the OS handles resources and continuation issues, data is passed as untyped text, and strong types that live outside the code make sure that the entire thing holds together (instead of turning into 3,000-microservice mess) It&#39;s a compiler, it&#39;s just a compiler that works across the entire OS/Net stack. I covered this in <a href="https://danielbmarkham.com/outlines-of-a-supercompiler-in-f/">my essay introducing supercompilers</a>. See the <a href="https://darklang.com/">DarkLang project</a> and few other folks who are making a go of this.</li><li>Even with this understanding, we coders tend to make things more complex and less understandable than we need to. Everybody says &#34;keep unneeded complexity out of your solutions&#34;, but what does that really mean?<a href="https://danielbmarkham.com/for-the-love-of-all-thats-holy-use-ccl-to-control-complexity-in-your-systems/"> I introduce a static code analysis technique that directly measures complexity using CCL in this essay</a>.</li><li>Coding is really wild because in many cases it can be as gnarly and complex as we want. When we ask if coding is hard, it&#39;s meaningless without all these other ideas (mentioned above) for context. I cover this in <a href="https://danielbmarkham.com/is-programming-hard-how-long-is-a-piece-of-string/">&#34;Is Programming Hard?&#34;</a></li><li>I talk about &#34;cleaning up&#34; the code as you understand the problem more, but how does this work in teams? It sounds too woolly, too belly-button gazing. Well hell, if you&#39;re impervious to any of the rest of this advice, just use <a href="https://danielbmarkham.com/code-budgets/">Code Budgets. That concept alone will proundly change how you write and deliver solutions.</a></li><li>The most unanticipated aspect of re-evaluating how we code was realizing that there was no criteria for what made good code. No wonder there&#39;s so much coding crap in the world. What&#39;s the goal of programming, anyway? Aside from making the PO happy, what are we really trying to do? I argue that if you&#39;re not writing code you can walk away from, by definition you&#39;re part of the problem, not part of the solution, in my essay &#34;Good Enough Programming&#34;</li></ol><figure><img src="https://danielbmarkham.com/content/images/2021/12/image.png" alt="" srcset="https://danielbmarkham.com/content/images/size/w600/2021/12/image.png 600w, https://danielbmarkham.com/content/images/2021/12/image.png 640w"/></figure><p><a href="https://leanpub.com/u/DanielBMarkham">Also, there are books. This blog is not to sell anything,  but I would be remiss if I didn&#39;t point out that all of this assembles into something bigger and more important. I don&#39;t want you to buy the book. I want to get into a discussion about programming with people who are willing to commit to it. If that&#39;s your thing, check out the books.</a></p><!--kg-card-begin: html--><div>
	<div>
        <a href="https://danielbmarkham.com/podcast/rss"><img src="https://cdn.danielbmarkham.com/assets/apple-podcast-icon.jpg"/></a></div></div><!--kg-card-end: html--><figure><a href="https://danielbmarkham.com/podcast/rss"><img src="https://danielbmarkham.com/content/images/2021/10/daniels-contact-vcard-barcode.png" alt=""/></a></figure><figure><a href="https://danielbmarkham.com/podcast/rss"><img src="https://danielbmarkham.com/content/images/2021/10/Daniel-Signature-12.png" alt="" srcset="https://danielbmarkham.com/content/images/size/w600/2021/10/Daniel-Signature-12.png 600w, https://danielbmarkham.com/content/images/size/w1000/2021/10/Daniel-Signature-12.png 1000w, https://danielbmarkham.com/content/images/size/w1600/2021/10/Daniel-Signature-12.png 1600w, https://danielbmarkham.com/content/images/2021/10/Daniel-Signature-12.png 2000w" sizes="(min-width: 720px) 720px"/></a></figure></div></div>
  </body>
</html>
