<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abc.decontextualize.com/more-than-you-wanted-to-know/">Original</a>
    <h1>More than you wanted to know about how Game Boy cartridges work</h1>
    
    <div id="readability-page-1" class="page"><div>
<header id="title-block-header">

</header>

<p>By <a href="https://www.decontextualize.com/">Allison Parrish</a></p>
<p>I set out a while ago to make a Game Boy cartridge from scratch. This
is not a novel goal; bootleg Game Boy cartridges have existed almost as
long as the Game Boy itself has, and there are <a href="https://bennvenn.myshopify.com/products/mbc3000-rtc-gbc-cart-v4">many</a>
<a href="https://shop.insidegadgets.com/">third-party cartridges</a> <a href="https://ferrantecrafts.com/collections/game-boy-cartridges">now
available for purchase</a>, or that have <a href="https://github.com/MouseBiteLabs/Game-Boy-MBC5-Cartridge">copyleft
designs</a>.</p>
<p>But I wanted to know how Game Boy cartridges work. I was also excited
to use the <a href="https://www.raspberrypi.com/news/what-is-pio/">PIO
functionality of the RP2040 microcontroller</a>. Now, after a few years
(!) of research and design, <a href="https://abc.decontextualize.com/">I
have made my design for a bootleg Game Boy cartridge</a> available for
everyone to use. In this post, I‚Äôm going to take you through everything
I learned along the way.</p>
<p>I will be quick to note that this document doesn‚Äôt contain any new
research! Instead, it‚Äôs my attempt to gather together information
relevant to making custom Game Boy cartridges in one place, and present
that information in a way that is easy to digest for people who start
off with about the same level of knowledge I started with when I first
dipped my toes into the Game Boy cartridge pool.</p>
<p>Please <a href="mailto:allison@decontextualize.com">let me know</a>
if you find any errors or have questions!</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>I‚Äôm going to assume that you have some knowledge of how digital
memory works, e.g., that you know what a ‚Äúbyte‚Äù is and broadly how
processors address memory. (If you don‚Äôt have this knowledge but you‚Äôre
curious and want to get up to speed, I recommend <a href="https://www.allaboutcircuits.com/textbook/digital/chpt-15/digital-memory-terms-concepts/">Sebastian
Lague‚Äôs ‚ÄúExploring How Computers Work‚Äù</a> series, or <a href="https://www.allaboutcircuits.com/textbook/digital/chpt-15/digital-memory-terms-concepts/">this
chapter on Digital Memory Terms and Concepts</a> from All About
Circuits.) I‚Äôm also going to assume that you have enough knowledge of
computer internals to know what a microprocessor is, and how a
microprocessor might communicate with other electronic components. You
should have some understanding of <a href="https://learn.sparkfun.com/tutorials/hexadecimal/all">hexadecimal</a>
and <a href="https://learn.sparkfun.com/tutorials/binary/all">binary</a>
numbers. However, you <em>don‚Äôt</em> need to know anything in particular
about electronics or electronic components.</p>
<p>Rodrigo Copetti‚Äôs <a href="https://www.copetti.org/writings/consoles/game-boy/">Game Boy/Game
Boy Color Architecture: A Practical Analysis</a> is a good general
overview of the Game Boy hardware, and is also worth a read, to
familiarize yourself with Game Boy components and terminology.</p>
<h2 id="conventions-notations-and-caveats">Conventions, notations and
caveats</h2>
<p>In this document, I‚Äôll write hexadecimal numbers with a preceding
<code>0x</code> (e.g., <code>0xABCD</code>) and binary numbers with a
preceding <code>0b</code> (e.g., <code>0b10100101</code>). If the name
of a pin or connection is preceded by an underscore (<code>_</code>),
that means that the pin is <em>active low</em> (i.e., the functionality
indicated by the pin is active when the pin is at zero volts).</p>
<p>You‚Äôll find the occasional paragraph marked with ‚Äúüí°‚Äù in the margin.
These are technical asides: snippets of facts and explanations that I
wanted to include, but aren‚Äôt necessary to understand the overall
content of the document. Feel free to skip!</p>
<p>Also, please note that when I‚Äôm describing what some IC ‚Äúdoes‚Äù in
this document, I‚Äôm attempting to describe its <em>behavior</em>, not how
it works <em>internally</em>. There have been some impressive efforts
(e.g., <a href="https://www.righto.com/2020/05/reverse-engineering-audio-chip-in.html">the
audio amplifier chip</a>, <a href="https://github.com/Gekkio/gb-research">CPU and MBC1</a>, <a href="https://github.com/msinger/dmg-schematics">DMG SoC</a>) to examine
the actual silicon of some common Game Boy components, but a lot of what
is known about the Game Boy still comes from developer documentation and
empirical observation.</p>
<p>When I discuss technical specifics of the ‚ÄúGame Boy CPU‚Äù in this
document, I‚Äôm referring specifically to the system-on-chip (SoC) of the
original Game Boy (commonly referred to as the ‚ÄúDMG‚Äù). While there are
many technical differences between the Game Boy-compatible platforms
(DMG, Game Boy Pocket, Game Boy Color, and the backwards compatibility
mode of the Game Boy Advance and Game Boy Advance SP), they all interact
with cartridges in a similar way. The broad outlines of what I describe
in this document should be applicable to all of these platforms.</p>

<p>First, let‚Äôs discuss the reason we‚Äôre even doing any of this in the
first place, because it might not be obvious. Why bother to do weird
stuff with the Game Boy anyway?</p>
<p>I don‚Äôt think it‚Äôs unfair to characterize a lot of retro gaming
enthusiasm as being rooted in nostalgia. And, y‚Äôknow, there‚Äôs nothing
wrong with nostalgia! But I never owned a Game Boy as a kid (my
formative scene was BBS doors and DOS shareware), and though I love
hearing others‚Äô memories of (e.g.) <a href="https://everest-pipkin.com/#projects/soft_corruptor/index.html">meeting
MissingNo after bedtime</a>, I have no such memories of my own. I‚Äôm
interested in the Game Boy for a number of other reasons, such as:</p>
<ul>
<li>The Game Boy is a relatively powerful machine for its time, but it
still has a very simple design that is easy to learn and understand.
It‚Äôs not too difficult for a programmer or hardware designer to form a
more or less complete understanding of the Game Boy‚Äôs functioning that
they can keep in their head all at once.</li>
<li>The Game Boy is portable and power-efficient.</li>
<li>You don‚Äôt need to circumvent copy protection or region lockout
hardware to write custom software for the Game Boy, since the Game Boy
has none.</li>
<li>The Game Boy is <em>incredibly</em> well documented. There is
seemingly no end to community-produced technical documentation about the
Game Boy, including detailed hardware schematics.</li>
<li>The Game Boy has a very extensive software library, including not
just the familiar games released during its original commercial run, but
a host of independently-produced games created in the meantime. And new
Game Boy games are still being released today.</li>
<li>There are <em>many</em> actively maintained open source toolchains
for Game Boy software development, including <a href="https://github.com/gbdk-2020/gbdk-2020">a C toolchain</a>, a
number of different assemblers (including my fave <a href="https://rgbds.gbdev.io/">RGBDS</a>), and a <a href="https://www.gbstudio.dev/">visual scripting programming
environment</a>. If you want to develop software for the Game Boy, you
have a lot of choices.</li>
<li>There are probably more than <a href="https://www.nintendo.co.jp/ir/en/finance/hard_soft/index.html">100
million Game Boys out there in the world somewhere</a>. But even if you
can‚Äôt get your hands on an original console, the Game Boy is easy and
cheap to emulate to a fair degree of accuracy, even on meager hardware.
There are also <a href="https://www.analogue.co/pockethttps://www.analogue.co/pocket">multiple</a>
<a href="https://funnyplaying.com/products/fpgbc-kit">FPGA
implementations</a> of the Game Boy SoC that are (mostly) compatible
with original game cartridges.</li>
</ul>
<p>In short: the Game Boy, as a platform, is simple, capable,
extensible, and low-cost. If the Game Boy didn‚Äôt already exist, someone
would have to invent it (as a fantasy console, probably).</p>

<p>So let‚Äôs start talking about Game Boy cartridges.</p>
<p>Here in the 2020s, the boundary between ‚Äúsoftware‚Äù and ‚Äúhardware‚Äù is
pretty clear cut. Generally, when you buy a computer (or video game
console, or some other computer-like device), that device has an
<em>operating system</em>, which you can use to load software from
non-volatile storage (like an SSD, or a SD card) into RAM, and then run
that software. Sometimes software requires the use of particular
peripheral, but the process of <em>loading</em> and <em>running</em>
software is more or less totally decoupled from hardware. The program is
the same regardless of where you loaded it from. (Even Nintendo Switch
‚Äúcartridges‚Äù are essentially just SD cards.)</p>
<p>But in the late 1980s and early 1990s, the distinction between
software and hardware was a bit more blurry, especially when we‚Äôre
talking about video game consoles and home computers. The Game Boy has a
tiny chunk of built-in ROM that serves as a bootloader, but it has no
real ‚Äúoperating system.‚Äù In fact, it has no built-in rewritable
non-volatile storage of any kind. Consequently, you can‚Äôt just ‚Äúload‚Äù
software ‚Äúonto‚Äù the Game Boy. If you‚Äôre a game developer in the
1980s/1990s and you want to distribute a Game Boy game, you have to ship
what amounts to a hardware peripheral‚Äîa cartridge‚Äîthat provides the
<em>actual memory ICs</em> that the Game Boy will use to run the game.
(This is somewhat analogous to shipping a PlayStation 5 game not as a
physical Blu-ray disc but as the disc <em>and</em> the drive needed to
read it.)</p>
<p>So in a sense, the Game Boy on its own is <em>incomplete</em>. It
needs a cartridge in order to function. A benefit of this arrangement is
that it‚Äôs fairly easy to introduce custom hardware on a cartridge that
extends the Game Boy‚Äôs functionality (like <a href="https://en.wikipedia.org/wiki/Kirby_Tilt_%27n%27_Tumble">an
accelerometer</a> or <a href="https://en.wikipedia.org/wiki/Pok%C3%A9mon_Gold_and_Silver">a
real-time clock</a>). The main drawback of the arrangement is that
you‚Äôre not just shipping bits; you‚Äôre shipping a little piece of
computer hardware. And if your hardware doesn‚Äôt work properly, the Game
Boy just‚Ä¶ won‚Äôt do anything.</p>
<h2 id="living-on-the-cartridge-edge">Living on the (cartridge)
edge</h2>
<p>Here‚Äôs a photograph of the PCB of a Tetris cartridge, which is about
as simple as a Game Boy cartridge can get:</p>
<figure>
<img src="https://todaythings.substack.com/p/tetris-pcb.jpg" alt="Photograph of the Tetris PCB, with one large IC in the upper right-hand corner"/>
<figcaption aria-hidden="true">Photograph of the Tetris PCB, with one
large IC in the upper right-hand corner</figcaption>
</figure>
<p>The exposed gold strips at the bottom of the cartridge are called the
‚Äúedge connector.‚Äù They‚Äôre what plug into the cartridge slot on the Game
Boy itself. The IC in the upper right-hand corner is a ROM IC, which is
connected to the cartridge edge with conductive traces.</p>
<p>The cartridge edge (and the cartridge socket on the Game Boy) has
thirty-two pins, as illustrated in the following diagram:</p>
<figure>
<img src="https://todaythings.substack.com/p/cart-edge.png" alt="Cartridge edge diagram"/>
<figcaption aria-hidden="true">Cartridge edge diagram</figcaption>
</figure>
<p>The Game Boy delivers five volts to the cartridge via the power pin;
the ground pin connects to the Game Boy‚Äôs ground. A few of the other
pins are not relevant to our purposes here (<code>CLK</code>,
<code>_RST</code> and <code>AIN</code>), so we shall set aside their
mysteries for the time being. The remaining 27 pins can be categorized
like so:</p>
<ul>
<li>Flow control pins: <code>_WR</code>, <code>_RD</code>,
<code>_CS</code> (‚Äúwrite,‚Äù ‚Äúread,‚Äù ‚Äúchip select‚Äù)</li>
<li>The address bus: <code>A0</code>‚Äì<code>A15</code> (16 bits)</li>
<li>The data bus: <code>D0</code>‚Äì<code>D7</code> (8 bits)</li>
</ul>
<p>In the simplest possible scenario, here‚Äôs what happens between the
Game Boy and the cartridge. When the program running on the Game Boy
wants to read data from the cartridge ROM, the Game Boy sets the
<code>_WR</code> pin high, and the <code>_RD</code> pin low, and writes
the address of the byte that it wants to read onto the address bus. The
ROM chip, recognizing that the <code>_WR</code> pin is low, looks up the
appropriate byte for that address, and then writes the value of that
byte to the data bus. (The whole process begins when you turn the Game
Boy on: the Game Boy is hard-coded to read its first instruction from
memory address <code>0x0100</code>, which corresponds to a location on
the cartridge ROM chip.)</p>
<figure>
<img src="https://todaythings.substack.com/p/simple_scenario.svg" alt="The simplest possible scenario"/>
<figcaption aria-hidden="true">The simplest possible
scenario</figcaption>
</figure>
<h2 id="get-on-the-bus">Get on the bus</h2>
<p>When I use the word ‚Äúbus,‚Äù what I mean is ‚Äúa group of pins that
multiple pieces of hardware are connected to‚Äù (usually intended to
transmit data). When I say that a component ‚Äúwrites‚Äù a value to the bus,
what I mean is that the component applies either a low voltage or a high
voltage to the pins of the bus, following the digits of the binary
representation of that value. For example, if the Game Boy wants the
value of the byte at address <code>0x4567</code>, it would set each of
the address pins to be either high (5v) or low (ground), based on the
binary representation of that address, starting from the least
significant bit. The binary representation of <code>0x4567</code> is
<code>0b0100010101100111</code>, so <code>A0</code> would be 1,
<code>A1</code> would be 1, <code>A2</code> would be 1, <code>A4</code>
would be zero, etc. On the address bus this would look like:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><code>A15</code></th>
<th><code>A14</code></th>
<th><code>A13</code></th>
<th><code>A12</code></th>
<th><code>A11</code></th>
<th><code>A10</code></th>
<th><code>A9</code></th>
<th><code>A8</code></th>
<th><code>A7</code></th>
<th><code>A6</code></th>
<th><code>A5</code></th>
<th><code>A4</code></th>
<th><code>A3</code></th>
<th><code>A2</code></th>
<th><code>A1</code></th>
<th><code>A0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0v</td>
<td>5v</td>
<td>0v</td>
<td>0v</td>
<td>0v</td>
<td>5v</td>
<td>0v</td>
<td>5v</td>
<td>0v</td>
<td>5v</td>
<td>5v</td>
<td>0v</td>
<td>0v</td>
<td>5v</td>
<td>5v</td>
<td>5v</td>
</tr>
</tbody>
</table>
<p>When the ROM chip writes the value of a byte to the data bus, it
likewise sets the values of the pins according to the binary
representation of that value. So, e.g., the value <code>0xAB</code> in
binary is <code>0b10101011</code>. On the data bus this would look
like:</p>
<table>
<thead>
<tr>
<th><code>D7</code></th>
<th><code>D6</code></th>
<th><code>D5</code></th>
<th><code>D4</code></th>
<th><code>D3</code></th>
<th><code>D2</code></th>
<th><code>D1</code></th>
<th><code>D0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>5v</td>
<td>0v</td>
<td>5v</td>
<td>0v</td>
<td>5v</td>
<td>0v</td>
<td>5v</td>
<td>5v</td>
</tr>
</tbody>
</table>
<p>For the purposes of this document, ‚Äúhigh‚Äù and ‚Äúlow‚Äù mean the same
thing as 1 and 0 (respectively). When I say that a component is
‚Äúdriving‚Äù a bus, what I mean is that the component in question is the
component that is currently applying voltage (0v or 5v) to that bus.</p>
<p>By the way, this kind of bus‚Äîwhere there is one pin for each bit of
the data value and address value‚Äîis called a <em>parallel bus</em>.
There‚Äôs another kind of bus, called a <em>serial bus</em>, where data
and addresses are transmitted one bit at a time, and there is an on-wire
protocol for determining which bits are addresses and which bits are
data. The benefit of a parallel bus is that it can be very fast, since
it can transmit multiple bits per clock cycle. Additionally, memory ICs
designed for a parallel bus can be less sophisticated electronically
than their serial counterparts, because no extra logic is needed to
serialize/deserialize data and addresses. The drawback of a parallel bus
is that it‚Äôs difficult to scale, both in terms of speed and bandwidth.
The Game Boy‚Äôs 16-bit/8-bit bus running at 4MHz is easy, but getting
(say) a working a 64-bit bus running at a couple gigahertz requires <a href="https://www.youtube.com/watch?v=Z7508zeyNIM">some esoteric
engineering</a>.</p>
<h2 id="memories-and-warfare">Memories and warfare</h2>
<p>Okay. So far we know about the <code>_WR</code> flow control pin, the
address bus, and the data bus. And we know that the Game Boy can read
data from the ROM chip on the cartridge by setting and reading values
from these pins. This is a good start!</p>
<p>Now, if the Game Boy only had <em>one</em> memory chip, then we could
stop the explanation there. But the situation in reality is more
complicated. The image below shows the main board of a Game Boy DMG,
showing the <em>other</em> memory ICs that the Game Boy CPU is connected
to. (The cartridge edge connector is what the cartridge plugs into.)</p>
<figure>
<img src="https://todaythings.substack.com/p/dmg-pcb-overlay.jpg" alt="DMG main board, with CPU, video RAM, internal RAM, and the cartridge edge connector labeled"/>
<figcaption aria-hidden="true">DMG main board, with CPU, video RAM,
internal RAM, and the cartridge edge connector labeled</figcaption>
</figure>
<p>In fact, the Game Boy can have up to <em>four</em> memory ICs
connected to it:</p>
<ul>
<li>Internal RAM (‚Äúwork ram‚Äù)</li>
<li>Video RAM</li>
<li>ROM on the cartridge (read-only memory; on a bootleg cart, this is
often an <a href="https://en.wikipedia.org/wiki/EEPROM">EEPROM</a> or a
parallel flash chip)</li>
<li>RAM on the cartridge (typically used to store saved games; some
cartridges have this, others don‚Äôt)</li>
</ul>
<p>We‚Äôre going to exclude video RAM from our discussion, because it‚Äôs
actually connected to a totally different address and data bus from the
other chips. In fact, video RAM is typically integrated directly into
the Game Boy system-on-a-chip (SoC)‚Äîin every model after the DMG at
least‚Äîso it doesn‚Äôt have its own physical IC! (We‚Äôre also going to gloss
over the tiny chunk of ‚Äúhigh RAM‚Äù at the top of the Game Boy‚Äôs memory
map, as it isn‚Äôt especially relevant to how Game Boy cartridges
function.)</p>
<p>That leaves us with up to three different memory ICs (ROM, internal
RAM, cartridge RAM). And <em>all of these ICs share the same address bus
and data bus</em>. (In the image above, the pins of the CPU nearest the
bottom of the image are the pins for <code>A0</code>‚Äì<code>A15</code>
and <code>D0</code>‚Äì<code>D7</code>, from left to right. If you were to
follow the traces connected to these pins, you‚Äôd find that they‚Äôre
attached to both the internal RAM and the cartridge edge connector.)</p>
<figure>
<img src="https://todaythings.substack.com/p/bus_diagram.svg" alt="diagram of bus connections"/>
<figcaption aria-hidden="true">diagram of bus connections</figcaption>
</figure>
<p>Sharing is good, but the problem here is that we only want
<em>one</em> chip writing to the data bus at once, and we want each chip
to <em>ignore</em> any data on the bus unless that data is intended for
<em>that chip in particular</em>. For example, if the Game Boy wants to
store a value in the cartridge RAM, we don‚Äôt want the internal work RAM
to <em>also</em> store that value. If the Game Boy wants to read a value
from its internal memory, we don‚Äôt want the ROM chip to <em>also</em>
put data on the data bus at the same time.</p>
<p>When two ICs are both trying to write to a bus at the same time, it‚Äôs
called <em>bus contention</em>. The word ‚Äúcontention‚Äù is a bit
misleading, since ‚Äúcontention‚Äù to me implies, like, a point of
disagreement in a genteel debate. But when one chip is trying to hold a
data pin low, and another chip is trying to hold a pin high, what
they‚Äôre doing is making a short circuit‚Äîa direct path from power to
ground. When this happens on the Game Boy bus, everything stops working,
and all of your chips start to get hot to the touch from all the heat
generated by the short circuit. Feels less like ‚Äúbus contention‚Äù to me
and more like <em>bus warfare</em>. No one wins!</p>
<p>We could imagine a world where each one of these chips had separate
buses, which would, for sure, simplify some things. But it would also
mean that the Game Boy‚Äôs CPU would need not 24 pins for its buses (16
bits address, 8 bits data) but 72 pins (24 <span>√ó</span> 3)‚Äîagain, excluding the video RAM. I guess
this would have seemed like a big mess to Nintendo‚Äôs engineers at the
time: routing the main board PCB would have been much less
straightforward, and the CPU chip itself would need to be much
larger‚Äîneither of which are desirable for a portable device with limited
space for components. (Although it turns out that the Game Boy Color SoC
<em>does</em> technically split its external bus into two distinct
buses: one for the cartridge edge, and another for the internal RAM
chip. So I guess the Nintendo engineers changed their minds!)</p>
<h2 id="a-quick-note-on-nomenclature">A quick note on nomenclature</h2>
<p>Each of these memory ICs and on-chip bits of memory have names that
they‚Äôre commonly known as in the lingo of the Game Boy biz. They
are:</p>
<ul>
<li><strong>WRAM</strong> (‚Äúwork RAM‚Äù): the internal RAM IC on the Game
Boy PCB, connected to the same bus as the cartridge ROM and cartridge
RAM, used as a general scratchpad</li>
<li><strong>SRAM</strong> (‚Äústatic RAM‚Äù?): the RAM IC on the cartridge
(if any)</li>
<li><strong>VRAM</strong> (‚Äúvideo RAM‚Äù): the other RAM IC on the Game
Boy PCB, accessed through a separate bus and used for tile data and tile
maps</li>
<li><strong>HRAM</strong> (‚Äúhigh RAM‚Äù): a small chunk of memory located
on the Game Boy SoC</li>
</ul>
<p>I find this nomenclature a little bit misleading, because ‚Äú<a href="https://en.wikipedia.org/wiki/Static_random-access_memory">static
RAM</a>‚Äù is a term that names a particular <em>variety</em> of RAM, not
a <em>use</em> of RAM. The on-cartridge RAM IC is typically a static RAM
chip, but so are both the internal work RAM IC and the video RAM IC. To
avoid confusion, I‚Äôm going to continue to use the terms ‚Äúon-cartridge
RAM‚Äù and ‚Äúinternal RAM‚Äù in this document. But I wanted you to be aware
that in the world of Game Boy development and documentation, you may
encounter the terms ‚ÄúSRAM‚Äù and ‚ÄúWRAM‚Äù to refer to these
(respectively).</p>
<h2 id="chip-select">Chip select</h2>
<p>If we want everyone to be able share the address and data buses
without violent hostilities breaking out, there needs to be some way for
the Game Boy to indicate which chip should be active for the current
read or write operation. Like other parallel RAM chips, the RAM ICs used
in the Game Boy DMG (and Pocket) have a pair of ‚Äúchip select‚Äù or ‚Äúchip
enable‚Äù pins that are designed to facilitate this. When the RAM IC‚Äôs
<code>_CS1</code> pin is held low, the chip in question is free to read
from and write to the data bus, based on the address bus value; when
it‚Äôs held high, the chip goes inactive, and can neither read from nor
write to the data bus. The <code>CS2</code> pin has the opposite
polarity of the chip select pin: when it‚Äôs high, the chip is enabled,
and when it‚Äôs low, the chip is disabled.</p>
<p>The <code>_CS1</code> pin is sometimes called <code>_CS</code> (or
<code>_CE</code>) in some datasheets and schematics, and there are also
some parallel RAM ICs that don‚Äôt have a <code>CS2</code>, meaning that
the IC is active only when the singular <code>_CS</code> pin is low. ROM
ICs and parallel flash ICs also often only have a <code>_CS</code>
pin.</p>
<p>The <code>_CS1</code> pin is sometimes called <code>_CS</code> (or
<code>_CE</code>) in some datasheets and schematics, and there are also
some parallel RAM ICs that don‚Äôt have a <code>CS2</code>, meaning that
the IC is active only when the singular <code>_CS</code> pin is low. ROM
ICs and parallel flash ICs also often only have a <code>_CS</code>
pin.</p>
<p>Here‚Äôs a truth table showing the relationship between the
<code>_CS1</code> and <code>CS2</code> pins:</p>
<table>
<thead>
<tr>
<th><code>_CS1</code></th>
<th><code>CS2</code></th>
<th>RAM state</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>X</td>
<td>disabled</td>
</tr>
<tr>
<td>X</td>
<td>0</td>
<td>disabled</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>enabled</td>
</tr>
</tbody>
</table>
<p>(<code>X</code> as a value in a table like this means that the state
of the pin doesn‚Äôt matter. In this case, if <code>_CS1</code> is high,
it doesn‚Äôt matter if CS2 is low or high‚Äîthe RAM chip will be disabled
either way.)</p>
<p>This seems like it could help solve our bus contention problem! The
Game Boy CPU can use the <code>_CS1</code>, <code>CS2</code> and
<code>_CS</code> pins of the connected memory chips to selectively
activate and deactivate memory ICs, depending on which one it needs to
access, thereby guaranteeing that only one of the ICs can drive the data
bus at any time. And this is, in fact, how it works on the Game Boy!
However, instead of having separate chip select connections for each IC,
the Game Boy engineers decided to implement this system by re-purposing
a few pins from the address bus. Specifically, the Game Boy uses the top
three pins of the address bus (<code>A15</code>, <code>A14</code>,
<code>A13</code>), along with the CPU‚Äôs <code>_CS</code> pin, to
select/deselect the various memory ICs. (The remaining address
pins‚Äî<code>A12</code> down to <code>A0</code>‚Äîare connected to
<em>all</em> of the memory chips.)</p>
<p>Here‚Äôs how it works! (Specifically, this is how it works on the Game
Boy Pocket, but the other variants are similar.) I‚Äôm only going to talk
about the cartridge ROM and the interal RAM ICs for the time being‚Äîwe‚Äôll
talk about cartridge RAM a bit later.</p>
<ul>
<li>The <code>A15</code> pin from the address bus is connected directly
to the ROM‚Äôs chip select pin, meaning that the cartridge ROM chip is
active when the top bit of the address is a binary <code>0</code>.</li>
<li>When the internal RAM (or the cartridge RAM) is being accessed, the
<code>_CS</code> pin goes low (active).</li>
<li>The CPU‚Äôs <code>_CS</code> pin is connected to the internal RAM‚Äôs
<code>_CS1</code> pin.</li>
<li>The <code>A14</code> pin is connected to the internal RAM‚Äôs
<code>CS2</code> pin.</li>
</ul>
<figure>
<img src="https://todaythings.substack.com/p/rom_ram_diagram.svg" alt="diagram of chip selection connections"/>
<figcaption aria-hidden="true">diagram of chip selection
connections</figcaption>
</figure>
<p>Here‚Äôs a table summarizing the setup:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>CPU <code>_CS</code></th>
<th><code>A15</code></th>
<th><code>A14</code></th>
<th>Cartridge ROM status</th>
<th>Internal RAM status</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>0</td>
<td>X</td>
<td>active</td>
<td>inactive</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>inactive</td>
<td>active</td>
</tr>
</tbody>
</table>
<p>One thing that you might notice about this arrangement is that the
ROM chip is active when <code>A15</code> is low, regardless of the state
of <code>A14</code>. This means that the ROM chip can use
<code>A14</code> as a regular address line, meaning that there are 15
bits of usable space on the bus to address locations in the ROM. This
equates to 32KB (<span>2<sup>15</sup></span> is
32KB), which is the largest that a Game Boy ROM can be without needing
additional hardware on the cart to swap memory banks. (The Tetris ROM is
32KB, for instance, and you can see from the photo above that the
cartridge is pretty bare bones.)</p>
<p>I expect that astute readers are asking themselves the following
questions at this point:</p>
<ul>
<li>Using the same math as we just used for ROM, I count 14 bits of
available address space for internal RAM, which is 16KB. But I know for
a fact that the Game Boy‚Äôs internal RAM chip only has a capacity of 8KB.
What gives?</li>
<li>If the Game Boy can only address 32KB of ROM, how come I have all
these ROMs that are like 2MB that seem to work just fine?</li>
<li>Where does the cartridge RAM chip fit into all of this??</li>
</ul>
<p>In order to answer these questions, we need to talk about: memory
bank controllers.</p>

<p>Before we do that, though, I want to discuss how all of this looks
from the <em>programmer‚Äôs</em> perspective.</p>
<p>It has been my experience that most documentation about the Game Boy
is written with either emulator developers or game developers in mind,
rather than people that are hacking on the hardware. So almost all
explanations you‚Äôll find out there of how Game Boy memory works are
written not in terms of the Game Boy‚Äôs electronics‚Äîi.e., which pins are
high or low‚Äîbut in terms of <em>addresses</em>. For this reason, any
Game Boy software developers who are reading this might be saying things
like ‚Äúbut I thought that you access ROM through addresses
<code>0x0000</code>‚Äì<code>0x7FFF</code>! What does that have to do with
all of this pins-going-high-and-low nonsense?‚Äù The answer lies in what
these addresses look like when they‚Äôre encoded in binary. The address
<code>0x0000</code>, as you might expect, looks like this on the address
bus.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><code>A15</code></th>
<th><code>A14</code></th>
<th><code>A13</code></th>
<th><code>A12</code></th>
<th><code>A11</code></th>
<th><code>A10</code></th>
<th><code>A9</code></th>
<th><code>A8</code></th>
<th><code>A7</code></th>
<th><code>A6</code></th>
<th><code>A5</code></th>
<th><code>A4</code></th>
<th><code>A3</code></th>
<th><code>A2</code></th>
<th><code>A1</code></th>
<th><code>A0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Whereas the address <code>0x7FFF</code> looks like this:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><code>A15</code></th>
<th><code>A14</code></th>
<th><code>A13</code></th>
<th><code>A12</code></th>
<th><code>A11</code></th>
<th><code>A10</code></th>
<th><code>A9</code></th>
<th><code>A8</code></th>
<th><code>A7</code></th>
<th><code>A6</code></th>
<th><code>A5</code></th>
<th><code>A4</code></th>
<th><code>A3</code></th>
<th><code>A2</code></th>
<th><code>A1</code></th>
<th><code>A0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>You‚Äôll notice that in both cases‚Äîand, therefore, in the case of
<em>any</em> number between <code>0x0000</code> and
<code>0x7FFF</code>‚Äîbit 15 of the address is zero, which means that the
Game Boy will be holding <code>A15</code> low. Since <code>A15</code> is
connected to the ROM‚Äôs chip select pin, only the ROM chip will be
active! Neat. Likewise with internal RAM and cartridge RAM: certain
combinations of address pins will activate one of those ICs and
deactivate the others, so that any data bus access will be handled by
the IC in question. (We‚Äôll discuss these in more detail in a bit.)</p>
<p>Game Boy hardware hackers know that there is an intricate ballet of
IC activation and deactivation happening behind the scenes, controlled
by the state of the address pins. But these details are hidden from the
<em>programmer</em>, who instead sees a flat 16-bit address space, from
<code>0x0000</code> to <code>0xFFFF</code>, where certain address ranges
appear to be ‚Äúmapped‚Äù to certain kinds of memory (or other
functionality, as we‚Äôll discover below when we discuss the MBC
protocol).</p>
<p>Because of this arrangement, Game Boy documentation usually includes
something called a <a href="https://gbdev.io/pandocs/Memory_Map.html">‚Äúmemory map‚Äù</a>, that
(among other things) shows which address ranges cause which memory ICs
to be active. Here‚Äôs a very simplified memory map that shows all of the
address ranges that we‚Äôll discuss in this document:</p>
<table>
<thead>
<tr>
<th>Range</th>
<th>What IC is active in this range</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x0000</code>‚Äì<code>0x7FFF</code></td>
<td>Cartridge ROM</td>
</tr>
<tr>
<td><code>0xA000</code>‚Äì<code>0xBFFF</code></td>
<td>Cartridge RAM</td>
</tr>
<tr>
<td><code>0xC000</code>-<code>0xDFFF</code></td>
<td>Internal RAM</td>
</tr>
</tbody>
</table>
<p>Later in this document, when I‚Äôm referring to the ‚Äúmemory map‚Äù or the
‚Äúaddress space,‚Äù this is what I‚Äôm referring to.</p>

<p>A memory bank controller (MBC) is a kind of IC commonly found on Game
Boy cartridges that makes it possible for software on that cartridge to
(a) access more than 32KB of ROM memory and/or (b) use extra RAM
(potentially battery-backed, so that will retain its values between
power cycles, so you can store saved games). MBCs are also used for
integrating peripheral devices like real-time clocks and accelerometers
into a cartridge. We‚Äôll talk more about this a bit later.</p>
<p>Nintendo produced a number of MBC chips over the course of the Game
Boy‚Äôs commercial run, each with slightly different functionality. (A few
other companies produced their own chips with MBC-like functionality as
well, notably <a href="https://gbdev.io/pandocs/HuC3.html">Hudson
Soft</a>.) You can read more about <a href="https://gbdev.io/pandocs/MBCs.html">the functional details of all
of these MBCs in Pan Docs</a> and, to a lesser extent, the comments on
the C/PIO implementations <a href="https://git.sr.ht/~aparrish/abc-firmware">in the firmware
repository for my own bootleg flash cart</a>.</p>
<p>For the purposes of this document, however, I‚Äôm going to focus on the
<a href="https://gbdev.io/pandocs/MBC5.html">MBC5</a>, which, aside from
being used in <a href="https://gbhwdb.gekkio.fi/cartridges/mbc5.html">a
large number of games</a>, is also easiest to explain and has the fewest
weird edge cases.</p>
<p>The MBC5 does a few things. First, the MBC5 makes it possible to use
<em>switched memory banks</em> on both the ROM chip and the on-cartridge
RAM chip. Using banks, games using the MBC5 chip can access up to 8MB of
ROM and 128kB of on-cartridge RAM. Secondly, the MBC5 makes it possible
for software running on the Game Boy to <em>disable</em> the
on-cartridge RAM chip entirely, so that its contents can be neither read
nor changed. (This is helpful as an extra security measure, to prevent
the data in the on-cartridge RAM from being corrupted. Again, more on
this later!)</p>
<p>To keep things simple, <strong>I‚Äôm only going to talk about the
MBC5‚Äôs ability to handle ROMs up to 4MB</strong> (i.e., 256 banks of
16KB), since very very few commercially-released games actually use more
than 4MB, and explaining that extra bit of bank count makes my diagrams
less pretty. After you‚Äôve read my explanation, I recommend checking out
<a href="https://gbdev.io/pandocs/MBC5.html">the documentation of MBC5
in Pan Docs</a> for more information about how the MBC5 supports 8MB
ROMs.</p>
<p>Here‚Äôs a photograph of a typical cart PCB that uses the MBC5 chip
(specifically, <a href="https://en.wikipedia.org/wiki/Super_Mario_Bros._Deluxe">Super
Mario Bros.¬†Deluxe</a>), to help orient you as we discuss the individual
components below:</p>
<figure>
<img src="https://todaythings.substack.com/p/cart-overlay.jpg" alt="labelled photograph of the Super Mario Bros Deluxe PCB"/>
<figcaption aria-hidden="true">labelled photograph of the Super Mario
Bros Deluxe PCB</figcaption>
</figure>
<p>Let‚Äôs talk about ROM bank switching first.</p>
<h2 id="roms-and-banks">ROMs and banks</h2>
<p>I mentioned just now that MBC5 ROMs can store up to eight megabytes
of data. However, the Game Boy itself can only address 64kB of memory.
(It has a 16 bit address bus; <span>2<sup>16</sup></span> is 64kB.) And, in fact, since
the Game Boy uses one whole bit of its address space to tell the ROM
chip whether it should be on or off, there are actually only
<em>fifteen</em> bits of addresses available to access data in the ROM
(<span>2<sup>15</sup></span> is 32kB). So what
gives?</p>
<p>Here‚Äôs what gives. A ROM chip on a cart with an MBC5 might have (up
to) 23 address pins (<span>2<sup>23</sup></span> is
8MB). However, only the bottom fourteen
(<code>A0</code>‚Äì<code>A13</code>) of those pins are directly connected
to the Game Boy‚Äôs address bus. The ROM chip gets values for the rest of
its address pins <em>from the MBC5 chip</em>. Here‚Äôs a simplified
diagram of the situation, showing only the components and connections
relevant to ROM bank switching. (In the diagram, boxes are components;
ovals label connections between those components.)</p>
<figure>
<img src="https://todaythings.substack.com/p/mbc5_rom_diagram.svg" alt="Diagram of the MBC5 and how it‚Äôs connected to other cart components"/>
<figcaption aria-hidden="true">Diagram of the MBC5 and how it‚Äôs
connected to other cart components</figcaption>
</figure>
<p>Okay, I know I said that this was a <em>simplified</em> diagram of
the situation. I hope it will be a useful visual aid as we progress
through this section, but I admit that, at first glance, it‚Äôs pretty
damn complicated. The key thing to pay attention for now to is <em>where
the ROM chip is getting its address from</em>. The Game Boy only sets
the bottom fourteen bits of the address. The rest of the address is set
by the MBC5 IC.</p>
<table>
<thead>
<tr>
<th>ROM Address pins</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A22</code>‚Äì<code>A14</code></td>
<td>MBC5</td>
</tr>
<tr>
<td><code>A13</code>‚Äì<code>A0</code></td>
<td>CPU</td>
</tr>
</tbody>
</table>
<p>This means that the Game Boy can only actually affect the lower
fourteen pins of the address bus. Effectively, the Game Boy can only
address and access 16kB of the ROM at any one time (<span>2<sup>14</sup></span> is 16kB). But <em>which</em>
16kB of the ROM depends on what value the MBC5 puts on those upper
address lines (i.e., the ROM chip‚Äôs <code>A14</code> through
<code>A22</code> pins). If all of those address lines are set to zero,
then the Game Boy‚Äôs address space corresponds with the 16kB starting at
address <code>0x000000</code> in the ROM chip. If, say, those address
lines are set to 19 (hexadecimal <code>0x13</code>, binary
<code>0b10011</code>), then the Game Boy would see the 16kB starting at
<code>0x4C000</code> (binary <code>0b00001001100000000000000</code>,
including leading zeros to show all 23 possible bits of the
address).</p>
<p>This is the essence of memory banking: the Game Boy accesses a fixed
address range, but different parts of the ROM data are made visible in
that address range, by setting the ROM address pins out-of-band.</p>
<h2 id="the-mbc-protocol">The MBC protocol</h2>
<p>The only question is‚Ä¶ <em>how</em> does Game Boy software tell the
MBC5 chip <em>what value</em> to put on those upper pins? Remember that
the only means that the Game Boy has to communicate with the cartridge
are what we mentioned above: the flow control pins (<code>_RD</code>,
<code>_WR</code> and <code>_CS</code>), the 16-bit address bus, and the
8-bit data bus. Somehow we need to repurpose these pins to not just
access data from a memory IC, but also to communicate instructions from
the Game Boy and the MBC5 chip about which memory bank should be
active.</p>
<p>I think the solution that the engineers of the time came up with for
this is pretty clever. You‚Äôll notice in the diagram above that the MBC5
chip is connected to address pins <code>A13</code> through
<code>A15</code>. It‚Äôs also connected to all eight bits of the data bus,
and the <code>_WR</code> pin. This is so the MBC5 chip can watch what‚Äôs
happening on those pins, and pick out pre-arranged patterns of access
(combinations of address values and data values) that tell it what value
to put on the upper address lines of the ROM chip. This is a kind of
simple ‚Äúprotocol‚Äù built into the MBC5 hardware.</p>
<p>The protocol works like this. Whenever pin <code>A13</code> is high,
and pins <code>A14</code> and <code>A15</code> are low, <em>and</em> the
<code>_WR</code> pin is low, the MBC5 copies whatever value is on the
data bus into a small internal memory. From then on, whenever the Game
Boy tries to read data (<code>_WR</code> pin is high), <em>and</em>
<code>A15</code> is low, <code>A14</code> is high, and <code>A13</code>
is low, the MBC5 copies the value from its internal memory onto the
ROM‚Äôs upper address bits. If <code>A15</code> and <code>A14</code> are
low, then the MBC5 puts all zeroes onto the upper address bits.</p>
<p>Here‚Äôs a table that summarizes this information:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><code>A15</code>, <code>A14</code>, <code>A13</code></th>
<th><code>_WR</code></th>
<th>Address range</th>
<th>MBC5 action</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>0</td>
<td><code>0x2000</code>‚Äì<code>0x3FFF</code></td>
<td>read value from data bus, store in memory</td>
</tr>
<tr>
<td>010</td>
<td>1</td>
<td><code>0x4000</code>‚Äì<code>0x7FFF</code></td>
<td>write previously stored value to ROM
<code>A14</code>‚Äì<code>A22</code></td>
</tr>
<tr>
<td>00x</td>
<td>1</td>
<td><code>0x0000</code>‚Äì<code>0x3FFF</code></td>
<td>set ROM <code>A14</code>‚Äì<code>A22</code> to all zeros</td>
</tr>
</tbody>
</table>
<p>It all comes together like this:</p>
<ul>
<li>Writing a value to the data bus when <code>A15</code> is low (i.e.,
the ROM chip is active) and the address bus contains any value with a 1
in bit 13 (i.e., <code>0x2000</code>‚Äì<code>0x3FFF</code>) sets a ROM
bank number, which the MBC5 chip remembers for later.</li>
<li>Reading the data bus when <code>A15</code> is low and the address
bus contains any value with a 1 in bit 14 (i.e.,
<code>0x4000</code>‚Äì<code>0x7FFF</code>) will access the portion of the
ROM beginning at the value of the ROM bank, multiplied by 16kB.</li>
<li>Reading the data bus when both <code>A15</code> and <code>A14</code>
are low (regardless of the state of <code>A13</code>) accesses the 16kB
of the ROM beginning at <code>0x0000</code> and ending at
<code>0x3FFF</code> (i.e., the first 16kB of the ROM).</li>
</ul>
<p>From the programmer‚Äôs perspective, the first 16kB of address space
(<code>0x0000</code> through <code>0x3FFF</code>) is fixed to the first
16kB of the ROM, but‚Äîby using this little protocol‚Äîyou can instruct the
MBC5 to make <em>any</em> part of the ROM available in the next 16kB of
address space (<code>0x4000</code>‚Äì<code>0x7FFF</code>).</p>
<h2 id="lets-pause-for-questions">Let‚Äôs pause for questions</h2>
<p>‚ÄúHey, wait a second,‚Äù I hear one of you saying. ‚ÄúIf the write pin is
low, that means that the Game Boy is trying to write a value! If I
<em>write</em> a byte to an address like <code>0x2000</code>, which is
right smack in the middle of the ROM address space, shouldn‚Äôt that,
like, write the value to ROM?‚Äù Yes! This is exactly what <em>would</em>
happen, except that ROM stands for ‚Äúread-only memory.‚Äù You can‚Äôt write
to it (unless you‚Äôre using an EEPROM IC, like a flash memory chip‚Äîwe‚Äôll
talk about how that works later on in the document). What makes this
little protocol so clever, in my opinion, is that it re-purposes the
(otherwise useless) <code>_WR</code>-high ROM address space as a way to
communicate information to the memory bank controller.</p>
<p>‚ÄúOkay fine, hotshot,‚Äù you retort. ‚ÄúHow about this? Why not make the
<em>entire</em> first 32kB of the address range swappable, instead of
having one 16kB chunk always fixed to the same place in ROM? Or break it
up into differently sized chunks, like four banks of 8KB a piece?‚Äù Yeah,
they could have done it that way if they wanted to! The <a href="https://www.smspower.org/Development/Mappers">bank switching
system on the Game Gear/Sega Master System</a> (which also has a 16 bit
address bus) gives the programmer access to <em>three</em> 16kB banks,
each of which can be mapped to arbitrary 16kB-aligned offsets in the
ROM. There are also <a href="https://gbdev.io/pandocs/MBC6.html">exotic
Game Boy cartridge MBCs</a> that split up the memory map in different
ways, allowing access to several swappable 8kB ROM banks. The Intel 8086
processor <a href="https://en.wikipedia.org/wiki/Intel_8086#Segmentation">has its own
weirdo method for swapping different bits of memory into the memory
map</a>. So it‚Äôs not inevitable that the MBC5 would be designed to work
the way that it does. That‚Äôs just the way the engineers decided it
should work.</p>
<p>‚ÄúOne last question. In all of the rows in the table up there,
<code>A15</code> is low (0). So why is <code>A15</code> even connected
to the MBC, if its state isn‚Äôt being used as part of any functionality?‚Äù
Also a good question! Let‚Äôs talk about that next.</p>
<h2 id="cartridge-ram">Cartridge RAM</h2>
<p>It‚Äôs finally time to talk about on-cartridge RAM!</p>
<p>As previously mentioned, many Game Boy cartridges have a RAM chip on
them. Most games use the on-cartridge RAM to store saved games: when
connected to a battery, the RAM chip will retain its values even after
the Game Boy is turned off, and the game can read those values when the
player starts the Game Boy back up again. Technically, though, a Game
Boy programmer can use the on-cart RAM for any purpose that they would
use the internal RAM. <a href="https://gbdev.gg8.se/wiki/articles/Tricky-to-emulate_games"><em>Super
Mario Land 2</em> uses it to hold level maps</a>; <a href="https://github.com/pret/pokered/blob/663b0612a7275da838585d8719bdf075c60a8abb/home/uncompress.asm#L26">Pok√©mon
Red and Blue use it as a temporary scratchpad for decompressing sprite
data</a>.</p>
<p>Every commercial cartridge with RAM (that I‚Äôve seen?) uses an MBC to
mediate access to the RAM. The cartridge RAM IC‚Äôs <code>_CS1</code> (or
<code>_CS</code>) pin is connected to the MBC‚Äînot the address bus or
flow control pins‚Äîwhich then activates and deactivates the chip under
certain conditions (which we‚Äôll discuss below). However, address pins
<code>A0</code> through <code>A12</code> from the address bus
<em>are</em> connected directly to cartridge RAM, as is the data
bus.</p>
<p>Here‚Äôs a diagram of the general situation, showing only the
connections that are relevant to cartridge RAM:</p>
<figure>
<img src="https://todaythings.substack.com/p/mbc5_ram_diagram.svg" alt="diagram of connections between the Game Boy CPU, the MBC, and on-cartridge RAM"/>
<figcaption aria-hidden="true">diagram of connections between the Game
Boy CPU, the MBC, and on-cartridge RAM</figcaption>
</figure>
<p>You may have noticed that there‚Äôs a similarity between how the top
address lines of the on-cartridge RAM are connected to the MBC, and how
the top address lines of the ROM are connected to the MBC. That‚Äôs
because the MBC makes it possible to do bank switching on the cartridge
RAM as well, using a method that is very similar to how ROM bank
switching is accomplished. We‚Äôll discuss this a bit later on.</p>
<p>You may have noticed that there‚Äôs a similarity between how the top
address lines of the on-cartridge RAM are connected to the MBC, and how
the top address lines of the ROM are connected to the MBC. That‚Äôs
because the MBC makes it possible to do bank switching on the cartridge
RAM as well, using a method that is very similar to how ROM bank
switching is accomplished. We‚Äôll discuss this a bit later on.</p>
<p>Now, it would be possible, technically, to connect the on-cartridge
RAM <em>directly</em> to the address bus and data bus, in the same way
that the cartridge ROM and the internal RAM are, instead of using the
MBC as a go-between. For example, the engineers at Nintendo could have
added another flow control pin specifically to enable/disable the
on-cartridge RAM IC, in addition to the <code>_CS</code> flow control
pin that we discussed earlier in the context of the Game Boy‚Äôs internal
RAM. Instead, the task of determining whether or not the cartridge RAM
chip should be enabled is delegated to the the MBC chip. It does this by
setting the cartridge RAM‚Äôs <code>_CS1</code> pin high or low, depending
on certain conditions.</p>
<h3 id="the-right-address-range">The right address range</h3>
<p>The first condition that has to be met for the cartridge RAM chip to
be active is that the access <em>needs to be in the correct memory
range</em>. In particular, the part of the memory map that is
conventionally assigned to the on-cartridge RAM is
<code>0xA000</code>‚Äì<code>0xBFFF</code>. It so happens that every
address in this range begins with <code>0b101</code> (i.e.,
<code>A15</code> is high, <code>A14</code> is low, and <code>A13</code>
is high). So one of the things that the MBC does is check
<code>A15</code>, <code>A14</code> and <code>A13</code> to see if their
values match <code>0b101</code>. If there‚Äôs a match, <em>and</em> the
memory is unlocked (see below), the MBC lowers the cartridge RAM‚Äôs
<code>_CS1</code> pin so it can read from and write to the data bus.</p>
<p>Here‚Äôs a table summarizing what we know so far about what states of
<code>A15</code>, <code>A14</code> and <code>A13</code> are meant to
correspond to which memory chips being active (again, leaving out video
RAM, which is its own thing):</p>
<table>
<thead>
<tr>
<th><code>A15</code>, <code>A14</code>, <code>A13</code></th>
<th>Active chip</th>
<th>Address range</th>
</tr>
</thead>
<tbody>
<tr>
<td>00x</td>
<td>ROM</td>
<td><code>0x0000</code>‚Äì<code>0x7FFF</code></td>
</tr>
<tr>
<td>101</td>
<td>Cartridge RAM</td>
<td><code>0xA000</code>‚Äì<code>0xBFFF</code></td>
</tr>
<tr>
<td>110</td>
<td>Internal RAM</td>
<td><code>0xC000</code>-<code>0xDFFF</code></td>
</tr>
</tbody>
</table>
<p>You can see that the Nintendo engineers figured out a way to nicely
divide the memory map into distinct regions for each memory IC, using
just three address pins. You can also see that this arrangement leads to
both the cartridge RAM and the internal RAM having 8KB of addressable
space, rather than the 32KB reserved for the ROM‚Äîwhich makes sense,
since the internal RAM IC of (pre-Color) Game Boys is an 8KB chip, and
most Game Boy games that shipped with on-cartridge RAM also used an 8KB
RAM IC.</p>
<h3 id="locking-and-unlocking-ram">Locking and unlocking RAM</h3>
<p>There is a wrinkle, however. As I alluded to previously, the MBC5 has
an internal bit that stores whether or not cartridge RAM access is
<em>locked</em> or <em>unlocked</em>. Even if the current memory access
is in the correct address range, the MBC5 will keep the cartridge RAM‚Äôs
<code>_CS1</code> pin high (i.e., disabled) if that internal bit
indicates that cartridge RAM access is in the ‚Äúlocked‚Äù state. The MBC5‚Äôs
locked/unlock bit defaults to locked when the Game Boy starts up, and
the programmer can change it using another little bit of the MBC5
protocol.</p>
<p>In particular, the MBC5 waits for any access where the
<code>_WR</code> pin is low, and <code>A15</code>, <code>A14</code> and
<code>A13</code> are also all low (this corresponds to addresses
<code>0x0000</code>‚Äì<code>0x1FFF</code>). Then it checks the data bus.
If the data bus has <code>0b1010</code> (hexadecimal <code>0xA</code>)
in its least significant four bits, the MBC5 changes the value of its
the locked/unlocked bit to <em>unlocked</em>. If the data bus has
<em>any other value</em>, then the MBC5 changes the bit to
<em>locked</em>. (All of this is part of the MBC5 protocol.)</p>
<p>In table form:</p>
<table>
<thead>
<tr>
<th><code>A15</code>, <code>A14</code>, <code>A13</code></th>
<th><code>_WR</code></th>
<th>Data bus</th>
<th>Resulting lock state</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>0</td>
<td>XXXX1010</td>
<td>unlocked</td>
</tr>
<tr>
<td>000</td>
<td>0</td>
<td>(anything other than XXXX1010)</td>
<td>locked</td>
</tr>
</tbody>
</table>
<p>And here‚Äôs a table that shows the value of the MBC5‚Äôs connection to
the <code>_CS1</code> pin of the cartridge RAM, according to the
locked/unlocked bit and the current state of <code>A15</code>,
<code>A14</code> and <code>A13</code>:</p>
<table>
<thead>
<tr>
<th><code>A15</code>, <code>A14</code>, <code>A13</code></th>
<th>Lock state</th>
<th><code>_CS1</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>0</td>
<td>0 (cartridge RAM enabled)</td>
</tr>
<tr>
<td>XXX</td>
<td>1</td>
<td>1 (cartridge RAM disabled)</td>
</tr>
<tr>
<td>(anything other than 101)</td>
<td>X</td>
<td>1 (cartridge RAM disabled)</td>
</tr>
</tbody>
</table>
<p>The question arises: why bother with this lock/unlock business at
all? I‚Äôve looked at a bunch of disassembled commercial game ROMs from
the Game Boy‚Äôs heyday, and it looks like most games keep the cartridge
RAM chip locked most of the time, and unlock it just long enough for one
operation (e.g., storing a save file) before locking it again. The
concern seems to be around save game integrity. If the cartridge RAM
chip is enabled when there‚Äôs a power fluctuation‚Äîe.g., when the Game Boy
is being turned on or off, or if the player removes the cartridge from
the Game Boy when it‚Äôs turned on, or, I dunno, gamma rays or
something‚Äîthe contents of the chip could easily be corrupted. Better
safe than sorry.</p>
<h3 id="banking-ram">Banking RAM</h3>
<p>The window in the memory map allocated to cartridge RAM is just 8kB
(<code>0xA000</code>‚Äî<code>0xBFFF</code>), but some RAM chips shipped on
commercial cartridges had up to 128kB of actual storage space. The MBC5
makes it possible to access all of that storage space, by providing a
way for the programmer to change which 8kB window of the actual RAM
storage is accessible in the memory map. This is bank switching, but
this time for the cartridge RAM.</p>
<p>The way that the MBC5 does this is broadly similar to ROM bank
switching, discussed above. Only address pins
<code>A0</code>‚Äì<code>A12</code> are directly connected to the cartridge
RAM chip. Any of the RAM chip‚Äôs address pins higher than that are
connected to the MBC5 instead. Here‚Äôs the diagram showing the
connections between the Game Boy, the MBC5 and the on-cartridge RAM chip
again, to refresh your memory:</p>
<figure>
<img src="https://todaythings.substack.com/p/mbc5_ram_diagram.svg" alt="MBC5 RAM banking diagram"/>
<figcaption aria-hidden="true">MBC5 RAM banking diagram</figcaption>
</figure>
<p>The biggest difference between cartridge RAM bank switching and ROM
bank switching is that RAM banks are only 8kB, not 16kB, and
correspondingly the number of address pins directly connected to the RAM
chip is fewer (thirteen instead of fourteen; <span>2<sup>13</sup></span> is 8kB). Another important
difference is that there is no fixed cartridge RAM bank. The entire
range is swapped out when you change banks.</p>
<p>As with ROM bank switching, there‚Äôs a protocol for telling the MBC5
which values it should put on the RAM‚Äôs top four address pins
(<code>A13</code>‚Äì<code>A16</code>). Whenever the <code>_WR</code> pin
is low, and the values of <code>A15</code>, <code>A14</code> and
<code>A13</code> are <code>0b010</code> (corresponding to addresses
<code>0x4000</code>‚Äì<code>0x5FFF</code>), the MBC5 chip takes whatever
value is on the data bus and copies it to the RAM‚Äôs top four address
pins. For example, writing the value <code>0x7</code> (binary
<code>0b0111</code>) to address <code>0x4000</code> will switch to RAM
bank seven, which is the part of the RAM chip‚Äôs storage beginning at
offset <span>7‚ÄÖ√ó‚ÄÖ8<em>k</em><em>B</em></span> =
<code>0x0E000</code>. Here‚Äôs a summary table:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><code>A15</code>, <code>A14</code>, <code>A13</code></th>
<th><code>_WR</code></th>
<th>Address range</th>
<th>MBC5 action</th>
</tr>
</thead>
<tbody>
<tr>
<td>010</td>
<td>0</td>
<td><code>0x4000</code>‚Äì<code>0x5FFF</code></td>
<td>read value from data bus, store in memory</td>
</tr>
<tr>
<td>101</td>
<td>X</td>
<td><code>0xA000</code>‚Äì<code>0xBFFF</code></td>
<td>write previously stored value to RAM
<code>A13</code>‚Äì<code>A16</code></td>
</tr>
</tbody>
</table>
<p>It should be noted that comparatively few commercially-released games
actually use cartridge RAM bank switching! Most games shipped with an
8KB RAM chip on the cartridge, which can be exhaustively addressed
without needing to switch banks.</p>
<h2 id="mbc5-summary">MBC5 summary</h2>
<p>At this point, we can put together a table that summarizes the MBC5
protocol (at least for ROMs up to 4MB):</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><code>A15</code>, <code>A14</code>, <code>A13</code></th>
<th><code>_WR</code></th>
<th>Memory range</th>
<th>MBC5 action</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>0</td>
<td><code>0x0000</code>-<code>0x1FFF</code></td>
<td>clear locked bit if data bus equals <code>0xA</code>
(<code>0b1010</code>); set locked bit otherwise</td>
</tr>
<tr>
<td>00X</td>
<td>1</td>
<td><code>0x0000</code>-<code>0x3FFF</code></td>
<td>set ROM <code>A14</code>‚Äì<code>A22</code> to all zeros</td>
</tr>
<tr>
<td>001</td>
<td>0</td>
<td><code>0x2000</code>‚Äì<code>0x3FFF</code></td>
<td>store value on data bus as ROM bank number</td>
</tr>
<tr>
<td>01X</td>
<td>1</td>
<td><code>0x4000</code>‚Äì<code>0x7FFF</code></td>
<td>write ROM bank number to ROM <code>A14</code>‚Äì<code>A22</code></td>
</tr>
<tr>
<td>010</td>
<td>0</td>
<td><code>0x4000</code>-<code>0x5FFF</code></td>
<td>store value on data bus as RAM bank number</td>
</tr>
<tr>
<td>101</td>
<td>X</td>
<td><code>0xA000</code>‚Äì<code>0xBFFF</code></td>
<td>write RAM bank number to RAM <code>A13</code>‚Äì<code>A16</code>; if
locked bit is clear, set <code>_CS</code> to 0</td>
</tr>
</tbody>
</table>
<p>Here‚Äôs a diagram of the relevant connections, this time including
components for both RAM and ROM:</p>
<figure>
<img src="https://todaythings.substack.com/p/mbc5_diagram.svg" alt="the whole shebang"/>
<figcaption aria-hidden="true">the whole shebang</figcaption>
</figure>
<p>If you‚Äôre programming in assembly language, communicating with the
MBC5 is fairly straightforward. All you need to do is read and write
from the aforementioned addresses:</p>
<pre><code>    ; enable cartridge RAM
    ld a, $0A
    ld [$0000], a  ; technically, any address from $0000 to $1FFF will work!

    ; set ROM bank visible from $4000 to $7FFF
    ld a, 4
    ld [$2000], a  ; often commercial ROMs use $2100, but any address from $2000 to $3FFF will work

    ; set RAM bank visible from $A000 to $BFFF
    ld a, 2
    ld [$4000], a  ; any address from $4000 to $5FFF will work

    ; disable cartridge RAM
    ld a, 0  ; or you could do &#39;xor a&#39; to save a byte and a cycle
    ld [$0000], 0  ; any address from $0000 to $1FFF will work; any value other than $A will work</code></pre>

<p>There are a few more things that we need to discuss about the
components of a Game Boy cartridge that don‚Äôt fit into the discussion of
the MBC chip. Let‚Äôs dig into these below!</p>
<h2 id="keeping-the-ram-safe">Keeping the RAM safe</h2>
<p>If you take another look at the <a href="https://todaythings.substack.com/p/cart-overlay.jpg">labeled
photograph of a typical cartridge</a> that we discussed above, there are
two components that we haven‚Äôt discussed yet: the battery and the reset
IC. We‚Äôll talk about the two of these together.</p>
<p>In the previous section, we discussed the on-cartridge RAM chip in
some detail. To be a bit more specific, the kind of RAM chip you‚Äôll find
on most commercially-released cartridges is a <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">static
RAM</a> (SRAM) IC with a parallel interface. Game Boy games generally
use the on-cartridge SRAM to store saved games, high score lists, and
other information that needs to be persistent between power cycles.
Parallel static RAM is, in a lot of ways, a perfect way to store data
persistently: it‚Äôs fast, and because you can connect it directly to the
address and data buses, the programmer can access it like any other kind
of memory.</p>
<p>With <a href="https://gbdev.io/pandocs/MBC7.html">a few
exceptions</a>, nearly every Game Boy game that stored save game data
used parallel SRAM, which is part of what makes supporting Game Boy
saved games in emulators and bootleg hardware relatively
straightforward. The situation is <a href="https://problemkaputt.de/gbatek.htm#gbacartbackupids">much more
complex with the Game Boy Advance</a>: while some GBA cartridges have
on-board SRAM, others use FRAM, Flash, or EEPROM, all of which have
different software interfaces.</p>
<p>The biggest problem with SRAM is, of course, that it is
<em>volatile</em> storage: the IC needs continuous power in order to
retain its contents. When the Game Boy is powered on, this is no
problem, as the on-cartridge SRAM can get power from the Game Boy
itself. When you turn the Game Boy off, however, an alternative power
source is needed. Fortunately, most SRAM chips can retain their contents
using very little power‚Äîtypically on the order of microwatts. Game Boy
cartridges supply those microwatts with an on-board lithium button-cell
battery, which is generally able to keep the data in the SRAM safe for
10+ years.</p>
<p>The tricky part of battery-backed SRAM is managing the moment when
the SRAM switches over from Game Boy power to on-cartridge battery
power. When the Game Boy power goes off, there are two things we need to
make happen quickly and simultaneously:</p>
<ul>
<li>Change the SRAM‚Äôs power source from the Game Boy to the
battery;</li>
<li>Disable the SRAM chip (by, e.g., holding its <code>_CS1</code> pin
high and/or its <code>CS2</code> pin low)</li>
</ul>
<p>Why does the SRAM chip need to be disabled? While the Game Boy is off
(or, generally, while the cartridge is not connected to anything), the
pins on the cartridge edge are ‚Äúfloating‚Äù: because nothing is actively
setting the value of the pins, the SRAM chip might interpret random
electrical fluctuations on the pins as 0s or 1s. This could could
corrupt the data on the chip, which in turn might zap all of the
monsters you‚Äôve pocketed.</p>
<p>To handle these two tasks, Game Boy cartridges usually have a
(somewhat confusingly named) ‚Äúreset IC.‚Äù Here‚Äôs a ) simplified diagram
that shows the reset IC and its relevant connections:</p>
<figure>
<img src="https://todaythings.substack.com/p/reset_ic_diagram.svg" alt="Reset IC connection diagram"/>
<figcaption aria-hidden="true">Reset IC connection diagram</figcaption>
</figure>
<p>The reset IC is connected to two power sources: the Game Boy‚Äôs 5V
power output, and the battery‚Äôs power output (typically 3V). The reset
IC is also connected to SRAM IC‚Äôs <code>_CS</code> pin. When the reset
IC is getting 5V from the Game Boy (i.e., when the cartridge is plugged
in and the Game Boy is on), the reset IC sends the Game Boy‚Äôs 5V power
to the SRAM chip. In this state, the reset IC also ‚Äúforwards‚Äù the value
of the MBC5‚Äôs <code>_CS</code> pin to the cartridge RAM‚Äôs
<code>_CS</code> pin. By ‚Äúforward,‚Äù I mean that whenever the MBC sets
the <code>_CS</code> pin low, the reset IC sets its own <code>_CS</code>
output low; whenever the MBC sets the <code>_CS</code> pin high, the
reset IC sets its own output high.</p>
<p>But when the reset IC detects that the Game Boy‚Äôs voltage has gone
below a particular threshold (i.e., when the Game Boy is turned off, or
the cartridge is otherwise not powered externally), the reset IC
instantly switches the SRAM‚Äôs power source from the Game Boy to the
on-cartridge battery. Simultaneously, it disables the SRAM chip by
setting its chip select pin as appropriate (now ignoring the value from
the MBC). When the Game Boy‚Äôs voltage goes <em>above</em> that threshold
(i.e., when the Game Boy is powered on again), the reset IC switches the
SRAM‚Äôs power source from the battery to the Game Boy, and resumes
‚Äúforwarding‚Äù whatever value the MBC puts on its <code>_CS</code> output
pin to the SRAM chip.</p>
<p>In practice, the situation is a bit more complicated than this, but I
hope you understand the basic gist. If you want more detailed
information about the precise interactions between the reset ICs, MBCs,
and SRAM chips that are on actual Game Boy cartridges, I recommend <a href="https://github.com/MouseBiteLabs/Game-Boy-MBC5-Cartridge/tree/main/Technical#battery-management-and-data-retention-considerations">Bucket
Mouse‚Äôs very detailed and friendly documentation</a> on the topic.</p>
<h2 id="on-cartridge-peripherals">On-cartridge peripherals</h2>
<p>Cartridges often contain custom electronics to provide useful
features beyond just data storage, and the way that software interacts
with these custom electronics is often entangled with MBC chips and the
MBC protocol. I‚Äôm going to discuss two examples: haptic feedback in
rumble-enabled Game Boy games, and the <a href="https://gbdev.io/pandocs/MBC3.html">real-time clock in MBC3</a>.
These are well-documented and fairly easy to explain examples, and we‚Äôll
also return to these examples in the next section when we‚Äôre discussing
how to make your own Game Boy cartridge. If you want to dig into some of
the more esoteric on-cartridge peripherals, I recommend Pan Docs on <a href="https://gbdev.io/pandocs/MBC7.html">MBC7</a> (provides an
integration with an accelerometer, used with <em>Kirby Tilt ‚Äòn‚Äô
Tumble</em>) and the <a href="https://gbdev.io/pandocs/Gameboy_Camera.html">Game Boy
Camera</a>.</p>
<h3 id="rumble">Rumble</h3>
<p><a href="https://www.youtube.com/watch?v=HUTfZTs3mBk">A number of
commercial Game Boy games shipped with a ‚Äúrumble‚Äù feature.</a> These
games have a small vibration motor inside of the cartridge housing,
which the software can control in order to give haptic feedback during
gameplay. Probably the most well-known of these is <em>Pok√©mon
Pinball</em>; you can take a look at the <a href="https://gbhwdb.gekkio.fi/cartridges/DMG-VPHE-0/gekkio-1.html">cartridge
and PCB</a> on the <a href="https://gbhwdb.gekkio.fi/">Game Boy Hardware
Database</a>. Rumble cartridges were designed in a very clever way,
which made it easy for software to activate the motor without having to
include any extra control hardware on the cartridge beyond what the MBC5
chip already provides.</p>
<p>Remember that the MBC5 chip has pins that are intended to connect
directly to the upper address pins of the on-cartridge RAM chip, and
that the state of these pins can be controlled by writing a value to the
data bus when the address bus has a value anywhere between
<code>0x4000</code> and <code>0x5FFF</code> (i.e., <code>A15</code> is
low, <code>A14</code> is high, and <code>A13</code> is low). Cartridges
with rumble, however, do things a little bit different. On these carts,
the pin that would normally go from the MBC5 to the RAM chip‚Äôs
<code>A16</code> pin is instead connected <em>to the vibration
motor</em> (via a small motor driver, which powers the motor from an
included AAA battery that is also connected to the cartridge). Here‚Äôs a
diagram of the setup, showing only the relevant parts:</p>
<figure>
<img src="https://todaythings.substack.com/p/rumble_diagram.svg" alt="diagram of relevant connections for controlling the rumble motor"/>
<figcaption aria-hidden="true">diagram of relevant connections for
controlling the rumble motor</figcaption>
</figure>
<p>From the programmer‚Äôs perspective, the result of this configuration
is that setting bit 3 of the RAM bank number turns the motor on, and
clearing that bit turns the motor off again. (<a href="https://github.com/pret/pokepinball/blob/d6a41233a062792831e9b952675c7dd326d6c991/home.asm#L355">Here‚Äôs
what I believe to be the relevant bit of code in the <em>Pok√©mon
Pinball</em> disassembly.</a>) This doesn‚Äôt <em>actually</em> change the
RAM bank number; it just causes the MBC5 to change the state of its
output pin that is connected to the motor. Simple and effective!</p>
<p>The diagram above suggests that three address lines are connected
between the MBC5 and the cartridge SRAM IC, which implies that some
commercial games with rumble used up to 64KB of SRAM (three pins = eight
banks; eight times eight kilobytes = 64KB). I‚Äôm not actually sure if any
commercial games with rumble made use of that much SRAM, or in fact if
any rumble-enabled games made use of cartridge RAM banking at all.
<em>Pok√©mon Pinball</em>, for example, only has 8KB of on-cartridge RAM,
meaning that it‚Äôs impossible to switch RAM banks, and consequently the
<code>A13</code>‚Äì<code>A16</code> output pins from the MBC5 chip on that
PCB are simply not connected to anything. There were a number of other
rumble-enabled cartridges that <a href="https://iceboy.a-singer.de/db/cart_CGB-VGRP-0_iceboy_1.html">had
no on-cartridge RAM at all</a>.</p>
<h3 id="real-time-clock-on-the-mbc3">Real-time clock on the MBC3</h3>
<p>There were a handful of commercially-released cartridge for the Game
Boy that had real-time clock functionality. In the context of
electronics, a ‚Äúreal-time clock‚Äù (RTC) is a device for keeping track of
how much time has passed while the system itself has been powered off.
(Often RTC functionality is provided by a discrete IC, accompanied by a
crystal oscillator and a small battery.) You‚Äôll find RTC functionality
in the smash-hit Acclaim Software classic, <a href="https://en.wikipedia.org/wiki/Mary-Kate_and_Ashley:_Pocket_Planner"><em>Mary
Kate and Ashley: Pocket Planner</em></a>, and also in gen 2 Pok√©mon
games, which is the reason that you can only catch Ariados at night (<a href="https://bulbapedia.bulbagarden.net/wiki/Time#Generation_II">among
other things</a>).</p>
<p>Instead of integrating a third-party RTC IC on their cartridges,
Nintendo opted to implement the RTC functionality directly into the
silicon of one of their memory bank controller chips: the <a href="https://gbdev.io/pandocs/MBC3.html">MBC3</a>.</p>
<p>In terms of bank switching, the MBC3 works very similarly to the
MBC5. But what‚Äôs interesting about the MBC3 is how it <em>extended the
MBC protocol</em> to make it possible for Game Boy software to access
the RTC functionality baked into the chip. I‚Äôm skipping over a few
details for the sake of simplicity, so don‚Äôt use this section as an
authoritative guide to how to interact with or implement a Game Boy
cartridge RTC system‚ÄîI‚Äôm just trying to get across the gist. In
particular, you should check <a href="https://gbdev.io/pandocs/MBC3.html">Pan Docs</a> for the
nitty-gritty, including the process of ‚Äúlatching‚Äù and the ‚Äúday counter
carry bit.‚Äù</p>
<p>The MBC3‚Äôs RTC has five data fields: the current second, the current
minute, the current hour, the lower eight bits of the current day, and
the upper bit of the current day. The MBC3 treats each of these fields
<em>as their own RAM bank</em>, like so:</p>
<ul>
<li>Bank <code>0x8</code>: seconds</li>
<li>Bank <code>0x9</code>: minutes</li>
<li>Bank <code>0xA</code>: hours</li>
<li>Bank <code>0xB</code>: day count (lower eight bits)</li>
<li>Bank <code>0xC</code>: day count (ninth bit)</li>
</ul>
<p>To read one of these values, the programmer first needs to switch to
the corresponding RAM bank. The MBC3 uses the same system for RAM bank
switching as the MBC5: you write the desired bank number to the data bus
with any address on the address bus whose top bits are
<code>0b010</code> (i.e., <code>0x4000</code>‚Äì<code>0x5FFF</code>). If
the bank number is <code>0x8</code> or greater, the MBC3 makes no
changes to the cartridge RAM address lines under its control; instead,
it saves that bank number for later. When the range of a subsequent
memory access is in the cartridge RAM address range
(<code>0xA000</code>‚Äì<code>0xBFFF</code>), the MBC3 checks the current
RAM bank number; if it‚Äôs <code>0x8</code> or greater, it <em>disables
the cartridge RAM chip</em> then drives the data bus with the current
value of the RTC variable in question.</p>
<p>Here‚Äôs a diagram showing the connections relevant for the MBC3 RTC
data. (Note that the MBC3 also does bank switching for the cartridge RAM
and ROM chips in manner similar to the MBC5. I‚Äôm omitting the
corresponding components from this diagram so we can visualize the RTC
functionality a bit better.)</p>
<figure>
<img src="https://todaythings.substack.com/p/mbc3_rtc_diagram.svg" alt="Diagram of relevant connections between Game Boy CPU, MBC3 and cartridge RAM"/>
<figcaption aria-hidden="true">Diagram of relevant connections between
Game Boy CPU, MBC3 and cartridge RAM</figcaption>
</figure>
<p>This process might seem bizarre to programmers who are not used to
working with Game Boy memory bank controllers, because the MBC3 drives
the data bus with the value of the RTC variable <em>regardless of what‚Äôs
happening with the lower bits of the address bus</em>. To the
programmer, this makes it look like <em>the entire memory range</em>
from <code>0xA000</code>‚Äì<code>0xBFFF</code> is filled with exactly the
same value!</p>
<p>The situation for writing values to an MBC3 RTC variable is similar.
First, the programmer switches to the RAM bank number corresponding to
the variable they want to change (with a write to
<code>0x4000</code>‚Äì<code>0x5FFF</code>). On a subsequent access, the
programmer drives the data bus with the new value for the variable, with
a value between <code>0xA000</code> and <code>0xBFFF</code> on the
address bus. The MBC3, seeing the appropriate pin values on its address
pins, and seeing that the current bank number is associated with an RTC
variable, deactivates the SRAM chip and takes whatever value is on the
data bus and stores it in the corresponding RTC variable. Again, the
lower bits of the address bus don‚Äôt matter: writing to
<code>0xBDEF</code> will update the value just as well as writing to
<code>0xA000</code>.</p>
<p>‚ÄúThis is all very barbaric,‚Äù some of you might say. ‚ÄúWhy not do
something sensible, like have the RTC seconds at <code>0xA000</code>,
minutes at <code>0xA001</code>, hours at <code>0xA002</code>, etc.?‚Äù But
then some of you pause and think for a second. How would the MBC3 know
the difference between <code>0xA000</code> and <code>0xA001</code>? It
would need to be connected to the A0 address pin! And to know the
difference between <code>0xA000</code> and <code>0xA002</code>, it would
need to be connected to the A1 address pin. Before you know it, your MBC
is connected to almost half the damn address bus! Nintendo certainly
<em>could have</em> implemented it this way, but I guess they thought it
would be overly complicated, at least from a hardware standpoint.</p>
<p>There‚Äôs a particular strategy at play here, which is the use of
extensions or variations on the MBC protocol to make on-cartridge
peripherals accessible in the <code>0xA000</code>‚Äì<code>0xBFFF</code>
range of the Game Boy‚Äôs memory map. We see this strategy in use not just
on the MBC3, but also the <a href="https://gbdev.io/pandocs/MBC6.html">MBC6</a>, <a href="https://gbdev.io/pandocs/MBC7.html">MBC7</a>, <a href="https://gbdev.io/pandocs/HuC1.html">HuC1</a> and <a href="https://gbdev.io/pandocs/HuC3.html">HuC-3</a>. However, there‚Äôs
nothing preventing the custom cartridge designer from deploying their
own strategies to communicate between Game Boy software and weird stuff
on their cartridges, as we‚Äôll see in a bit.</p>

<p>To summarize, here‚Äôs what we‚Äôve learned so far:</p>
<ul>
<li>The Game Boy CPU connects to many different memory ICs, and these
ICs‚Äô ability to read and write from the data bus choreographed through a
combination of address pins and flow control pins.</li>
<li>On-chip custom ICs, called ‚Äúmemory bank controllers,‚Äù make it
possible to switch different segments of memory into the Game Boy‚Äôs
memory map by changing the upper address lines of on-cartridge memory
chips (ROM and RAM).</li>
<li>Software communicates with MBCs using a kind of ‚Äúprotocol‚Äù
consisting of patterns of memory access.</li>
<li>The MBC and other on-cartridge components are charged with the
important responsibility of maintaining the integrity of on-cartridge
battery-backed RAM, both through software (RAM locking) and hardware
(the reset IC).</li>
<li>Hardware peripherals can be included on cartridges, and their
functioning is often tangled up with the MBC chip or MBC protocols.</li>
</ul>
<p>So what if you wanted to make a Game Boy cartridge <em>from
scratch</em>? What exactly would you need to do? I‚Äôm assuming a few
goals for our custom cartridge. Our cartridge should:</p>
<ul>
<li>Prefer off-the-shelf parts whenever possible (i.e., avoid using
parts harvested from commercial cartridges);</li>
<li>Be <em>rewritable</em> (i.e., it should use something like flash
memory instead of a ROM chip, so that we can write ROMs to it multiple
times);</li>
<li>Support a reasonably large subset of the Game Boy library, not
including software that uses on-cartridge peripherals (i.e., it should
support multiple RAM and ROM banks, and potentially multiple MBCs)</li>
</ul>
<p>Note that this section is not a tutorial on how to make a cartridge
from scratch. Instead, think of it as an anthology of strategies to help
you overcome potential stumbling blocks on the road to making a
cartridge from scratch, along with facts that might be non-obvious to
people who are approaching the problem for the first time. In
particular, we‚Äôre not going to discuss things like PCB layout, or
specific components, or the technical details of programming an MBC
emulator. For information on those topics, I would invite you to learn
from <a href="https://abc.decontextualize.com/">the bootleg cartridge I
designed</a>, including the documentation in the <a href="https://git.sr.ht/~aparrish/abc-pcb/">ABC PCB</a> repository and
the <a href="https://git.sr.ht/~aparrish/abc-firmware/">ABC firmware</a>
repository.</p>
<p>Also note that we‚Äôre going to focus on cartridges that use parallel
flash to store ROM data, and that are intended to be used with a
cartridge flasher. I wish I could talk authoritatively about cartridges
that read ROMs from external media, like an SD card (e.g., the <a href="https://www.ezflash.cn/product/ezflash-junior/">EZ-Flash Jr</a>),
but I‚Äôve never done that before. I‚Äôd recommend the source code and
documentation of the <a href="https://github.com/shilga/rp2040-gameboy-cartridge-firmware">Croco
Cart</a> as a good place to start learning about that kind of
cartridge!</p>
<h2 id="the-simple-case-32kb">The simple case: 32KB</h2>
<p>Let‚Äôs go back to the ‚Äúsimplest possible scenario‚Äù diagram from a few
sections ago, which describes cartridges like <em>Tetris</em> that have
no on-cartridge RAM, no peripherals, and no more than 32KB of ROM (i.e.,
no need for ROM bank switching):</p>
<figure>
<img src="https://todaythings.substack.com/p/simple_scenario.svg" alt="the simplest possible scenario"/>
<figcaption aria-hidden="true">the simplest possible
scenario</figcaption>
</figure>
<p>Creating a custom cartridge that only supports 32K ROMs is actually
fairly straightforward, and Game Boy hobbyists have been <a href="https://store.kitsch-bent.com/collections/cartridges-programmers/products/game-boy-prom-cartridge">making</a>
<a href="https://ferrantecrafts.com/products/game-boy-flash-cartridge-32kb">cartridges</a>
<a href="https://shop.insidegadgets.com/product/gameboy-32kb-mini-flash-cart-fits-in-a-gba-cartridge-for-gba-gba-sp/">like
this</a> for ages. The simplest possible scenario is simple enough that
you can fairly easily make a Game Boy cartridge just by soldering a 5v
parallel flash IC to the cartridge edge, like I did with my first custom
cartridge:</p>
<figure>
<img src="https://todaythings.substack.com/p/ab7565c23f97746f.jpeg" alt="Game Boy cartridge with the legs of a DIP parallel flash IC soldered to a cartridge edge breakout"/>
<figcaption aria-hidden="true">Game Boy cartridge with the legs of a DIP
parallel flash IC soldered to a cartridge edge breakout</figcaption>
</figure>
<p>The reason this works is that memory IC design is fairly well
standardized, and the Game Boy was designed to connect to off-the-shelf
memory ICs that follow this standard (as long as the voltages, timing
parameters, and bus width match up with the Game Boy‚Äôs requirements).
You connect pin <code>A0</code> of the Game Boy‚Äôs address bus to pin
<code>A0</code> of the memory IC, pin <code>A1</code> of the Game Boy‚Äôs
address bus to pin <code>A1</code> of the memory IC, and so forth,
including the data bus and (if it‚Äôs a ROM chip) connecting
<code>A15</code> of the address bus to the chip‚Äôs <code>_RD</code> pin,
so that the ROM chip is only active when the access is in the
appropriate address range (as discussed at length above).</p>
<h2 id="using-flash-memory">Using flash memory</h2>
<p>Commercial Game Boy cartridges used custom fabricated read-only
memory ICs to store their code and assets (<a href="https://en.wikipedia.org/wiki/Read-only_memory#Solid-state_ROM">mask
ROM</a>), which cannot be re-programmed. If you want a Game Boy
cartridge that you <em>can</em> reprogram, you need to use a memory IC
whose contents can be erased and then re-written, and that retains the
new data until the next time you change it. We‚Äôve already looked at one
such memory IC‚Äîbattery-backed SRAM‚Äîbut this is not a popular solution
for this use case, presumably because the game data would vanish when
the on-cartridge battery runs out, which would be a bummer. (Though
insideGadgets has some tantalizing if impractical prototypes with <a href="https://www.youtube.com/watch?v=4FXGxrEVXZE">SRAM</a> and <a href="https://www.youtube.com/watch?v=AtBa5Mm-50Y">FRAM</a>.)</p>
<h3 id="the-flash-ic">The flash IC</h3>
<p>Instead, most third-party reprogrammable cartridges use parallel
(NOR) <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>, a kind of <a href="https://en.wikipedia.org/wiki/EEPROM">electrically erasable
programmable read-only memory (EEPROM)</a>. Below you‚Äôll find the pinout
diagram of the parallel flash memory IC that I used in my 32KB
cartridge. (A ‚Äúpinout‚Äù is a diagram of the chip that shows the names of
each of the IC‚Äôs pin, which you can then use as a way to look up what
that pin does. This diagram is from the memory IC‚Äôs datasheet.) Even if
you‚Äôve never looked at a pinout of an IC before, some of this should
look familiar, just based on what you‚Äôve learned from this document so
far! You can recognize the address pins, at least (<code>A0</code>,
<code>A1</code>, <code>A2</code>‚Ä¶). There are a few variations in how
I‚Äôve been referring to typical memory IC pins in this document and how
the pinout labels those pins, namely:</p>
<ul>
<li><code>VSS</code> is ground, <code>VDD</code> is positive voltage (5V
in this case)</li>
<li>Pins <code>DQ0</code>, <code>DQ1</code>, <code>DQ2</code> (etc.) in
the pinout are data pins (which we‚Äôve been calling <code>D0</code>,
<code>D1</code>, <code>D2</code>‚Ä¶)</li>
<li><code>WE#</code> is the same thing as <code>_WR</code>,
<code>OE#</code> (‚Äúoutput enable‚Äù) is the same as <code>_RD</code>, and
<code>CE#</code> (‚Äúchip enable‚Äù) is the same as <code>_CS</code></li>
</ul>
<figure>
<img src="https://todaythings.substack.com/p/sst39sf-pinout.png" alt="pinout diagram for Microchip SST39SF-series flash memory ICs"/>
<figcaption aria-hidden="true">pinout diagram for Microchip
SST39SF-series flash memory ICs</figcaption>
</figure>
<p>You can use this diagram to better understand how I did the wiring in
my custom 32KB cartridge (shown above).</p>
<p>Note that this particular flash chip can actually store more than
32KB! Because I didn‚Äôt want to go through the hassle of supporting ROMs
greater than 32KB on my hand-soldered cart, I soldered all of the unused
address pins (<code>A16</code>, <code>A17</code>, <code>A18</code>) to
ground‚Äîessentially locking those address pins to zero.</p>
<h3 id="the-flash-protocol">The flash protocol</h3>
<p>So how does the Game Boy actually interact with a parallel flash IC?
For read operations, parallel flash ICs work pretty much exactly like
their mask ROM or SRAM counterparts. You set the address pins to the
address of the value that you want to read, set <code>_WR</code> high,
<code>_CS</code> low, and <code>_RD</code> low, and then read the value
of the byte off of the data bus.</p>
<p><em>Writing</em> data to the flash memory IC is a different matter
entirely, because <a href="https://en.wikipedia.org/wiki/Flash_memory#Limitations">flash
memory is a bit tricky</a>. You <em>can</em> change the value of
individual bits in a flash memory chip, but the update process can
<em>only</em> change a bit from 1 to 0. If you want to change a 0 to a
1, you have to <em>erase</em> not just that bit but the <em>entire
sector</em> of memory in which the bit is located. (Sectors are usually
4KB to 64KB.) The erase operation changes <em>all</em> bits in the
sector to 1.</p>
<p>This means that, unlike as is the case with an SRAM chip, you
<em>can‚Äôt</em> update a byte stored in a flash memory IC simply by
setting the address of the byte on the address bus and the desired value
on the data bus‚Äîat least, not in a practical way. You first have to
erase the sector that the byte is in, then rewrite the sector with the
updated value for that byte. Or you could simply erase the
<em>entire</em> chip, and then rewrite the chip with an updated version
of the data that had been on there previously. It‚Äôs kind of a
hassle!</p>
<p>It is possible to introduce a layer of abstraction between the flash
memory IC and the programmer that makes working with the flash memory
more like working with regular files. A <a href="https://en.wikipedia.org/wiki/Flash_memory_controller">flash
memory controller</a> is a solution that lives in hardware; <a href="https://github.com/littlefs-project/littlefs">littlefs</a> is a
software solution that is especially appropriate for microcontrollers.
Unfortunately, the Game Boy needs to be able to directly address the
memory byte-by-byte, without a go-between, so we can‚Äôt use memory
controllers or filesystems as drop-in solutions. We gotta wrangle that
data the old fashioned way.</p>
<p>So there are at least three different operations we need to do to
work with flash memory: read, write and erase. To facilitate these
operations, flash memory ICs typically define a protocol for issuing
<em>commands</em> that instruct the internal logic circuitry of the IC
to perform those operations. The programmer issues these commands by
setting the address bus and data bus to sequences of pre-determined
values, in a particular order. (It‚Äôs a little bit like how an MBC works,
actually!)</p>
<p>Each flash memory vendor has a slightly different protocol for these
operations. To discover how to write and erase data on whatever flash IC
you‚Äôre working with, you need to consult the datasheet. For example, <a href="https://ww1.microchip.com/downloads/aemDocuments/documents/MPD/ProductDocuments/DataSheets/SST39SF010A-SST39SF020A-SST39SF040-Data-Sheet-DS20005022.pdf">according
to the SST39SF series datasheet</a>, the sequence of bus actions
necessary to erase the entire chip consists of these steps:</p>
<ul>
<li>Write <code>0x5555</code> to the address bus and <code>0xAA</code>
to the data bus</li>
<li>Write <code>0x2AAA</code> to the address bus and <code>0x55</code>
to the data bus</li>
<li>Write <code>0x5555</code> to the address bus and <code>0x80</code>
to the data bus</li>
<li>Write <code>0x5555</code> to the address bus and <code>0xAA</code>
to the data bus</li>
<li>Write <code>0x2AAA</code> to the address bus and <code>0x55</code>
to the data bus</li>
<li>Write <code>0x5555</code> to the address bus and <code>0x10</code>
to the data bus</li>
</ul>
<p>Whereas the sequence for setting the value of an individual byte
looks like this:</p>
<ul>
<li>Write <code>0x5555</code> to the address bus and <code>0xAA</code>
to the data bus</li>
<li>Write <code>0x2AAA</code> to the address bus and <code>0x55</code>
to the data bus</li>
<li>Write <code>0x5555</code> to the address bus and <code>0x80</code>
to the data bus</li>
<li>Set the address bus to the address of the byte you want to set, and
write the desired value of the byte to the data bus</li>
</ul>
<p>An important thing to note is that <em>the flash IC only matches the
state of (some subset subset of) the lowest bits of its address pins
when checking for commands</em>. The SST39SF chips, for example, only
look at <code>A0</code>‚Äì<code>A14</code> (i.e., addresses
<code>0x0000</code> through <code>0x7FFF</code>). The values on the
flash IC‚Äôs address pins above this range (<code>A15</code>,
<code>A16</code>, <code>A17</code>‚Ä¶) don‚Äôt matter, for the purposes of
determining whether a command is being issued. However, they <em>do</em>
matter in the last step of the byte-writing sequence, where the state of
all the address pins determines the memory location of the byte
written.</p>
<p>There are many other operations you can perform on a flash memory IC
using this protocol (including handy things like getting the chip‚Äôs
manufacturer ID, or its sector map), but if all you want to do is copy
over a ROM, you really just need the erase operation and the write-byte
operation.</p>
<p>So here‚Äôs where we are. We know that we can connect a flash memory IC
to a cartridge edge so that the memory IC‚Äôs address bus, data bus and
flow control pins align with their equivalents on the Game Boy. But then
we need some way to actually <em>send data</em> to that cartridge, by
issuing the necessary bus commands in accordance with the manufacturer‚Äôs
pre-defined protocol. And if we want to put our own software on the
cartridge, we‚Äôll probably want to be able to copy a file from a computer
to the flash memory IC on the cartridge. Basically, we need the magical
device seen in this diagram:</p>
<figure>
<img src="https://todaythings.substack.com/p/flasher_diagram.svg" alt="Files to computer to device to cartridge"/>
<figcaption aria-hidden="true">Files to computer to device to
cartridge</figcaption>
</figure>
<p>‚ÄúBut where, oh where, might one find such a fantastical device,‚Äù I
hear you lament. ‚ÄúSurely it cannot exist, not in this sinful, fallen
world.‚Äù Ah, my friend. You musn‚Äôt despair! This magical device does
exist, and it‚Äôs called a cartridge flasher. We‚Äôll talk about cartridge
flashers in the next section!</p>
<p>Observant readers may notice that the address bus values of the flash
memory commands are in ranges that are recognized by the MBC5 protocol.
E.g., the address <code>0x5555</code> is in the range
<code>0x4000</code>‚Äì<code>0x5FFF</code>, which is the range for updating
the RAM bank. The address <code>0x2AAA</code> is in the range
<code>0x2000</code>‚Äì<code>0x3FFF</code>, which is the range for updating
the ROM bank. Eventually, we want our bootleg cart to emulate memory
bank controllers like the MBC5, so the question then arises: how the
cartridge can distinguish between bus operations intended for the flash
chip and bus operations intended for the MBC? We‚Äôll discuss this when
the time comes!</p>
<h2 id="cartridge-flashers">Cartridge flashers</h2>
<p>A cartridge flasher is a device that has a connection to a computer
on one end, and a connection to a Game Boy cartridge on the other. The
purpose of the device is to make it possible to write a file from the
computer to the memory ICs on the cartridge. (Usually, cartridge
flashers also work as cartridge <em>dumpers</em>, i.e., they can read
data from the cartridge and copy it to the computer, which can save that
data as a file; they can also usually read and write from the
on-cartridge RAM chip.) There are a number of cartridge flashers out
there (<a href="https://bennvenn.myshopify.com/collections/game-cart-to-pc-interface/products/usb-gb-c-cart-dumper-the-joey-jr">BennVenn‚Äôs
Joey Jr</a>, <a href="https://funnyplaying.com/products/portable-cart-flasher-burnmaster">FunnyPlaying‚Äôs
BurnMaster</a>, the <a href="https://github.com/sanni/cartreader">Open
Source Cartridge Reader</a>, etc.). But here‚Äôs a photo of my trusty <a href="https://www.gbxcart.com/">GBxCartRW</a>, which is the cartridge
flasher that I recommend. (The GBxCartRW is at the top of my photo. One
of my flash cartridges is plugged into it.)</p>
<figure>
<img src="https://todaythings.substack.com/p/gbxcartrw.jpg" alt="GBxCartRW in 3D printed/acrylic shell, with bootleg cartridge inserted"/>
<figcaption aria-hidden="true">GBxCartRW in 3D printed/acrylic shell,
with bootleg cartridge inserted</figcaption>
</figure>
<p>Typically, a cartridge flasher has a USB port, which connects to the
computer; the computer can then send data over the USB connection to a
microcontroller on the cart. That microcontroller is connected, in turn,
to a cartridge slot connector, which you plug your cartridge into. The
microcontroller is what actually sets the flow control pins, the address
bus and the data bus in order to read data from the cartridge and write
data to the cartridge.</p>
<p><a href="https://github.com/lesserkuma/FlashGBX">FlashGBX</a> is
software that you run on your computer in order to control the
GBxCartRW. You can see <a href="https://github.com/lesserkuma/FlashGBX/tree/master/FlashGBX/config">configuration
files for every supported flash cartridge</a> in the FlashGBX source
code repository, which include information on which commands to send to
the flash memory IC on that particular cartridge (including <a href="https://github.com/lesserkuma/FlashGBX/blob/master/FlashGBX/config/fc_DMG_SST39SF020_AUDIO.txt">the
configuration file for a cartridge</a> that uses one of the SST39SF
series chips that we talked about earlier).</p>
<p>The FlashGBX source code also includes <a href="https://github.com/lesserkuma/FlashGBX/blob/37ca12a4f162b7efb0e03854a17b391d3a6266ce/FlashGBX/Mapper.py#L471">code
for sending commands to MBC chips on the cartridge</a>, so that the
cartridge flasher can (e.g.) change the active ROM bank, in order to
write ROMs larger than 32KB. Using a combination of the MBC protocol and
the flash memory protocol, the cartridge flasher can read cartridge
contents and write whatever data you want to the cartridge. Magic!</p>
<h2 id="emulating-an-mbc">Emulating an MBC</h2>
<p>Speaking of which, how <em>do</em> we support ROMs bigger than 32KB
on our bootleg cartridge? Well, we‚Äôll do it the same way that Nintendo
did it: with a memory bank controller. More specifically, we need to add
something to the cart that ‚Äúspeaks‚Äù the MBC protocol, and can wrangle
the upper address lines of the on-cartridge flash and RAM chips so that
the correct slices of memory are available on the data bus when needed.
Basically, we need something that <a href="https://todaythings.substack.com/p/mbc5_diagram.svg">can do
everything that the MBC5 is doing in this diagram</a>.</p>
<figure>
<img src="https://todaythings.substack.com/p/desoldered-mbc5.jpg" alt="A cartridge next to its MBC5 chip, which I desoldered specifically to create images with visual interest for this document"/>
<figcaption aria-hidden="true">A cartridge next to its MBC5 chip, which
I desoldered specifically to create images with visual interest for this
document</figcaption>
</figure>
<p>There are a handful of ways to do this! The simplest way is to
sidestep the problem altogether and just <em>harvest an MBC IC from an
existing cartridge</em>. And this isn‚Äôt a terrible strategy, especially
if you have a cartridge whose MBC chip works fine but whose cartridge
edge, ROM or SRAM are inoperative. Some Game Boy cartridges are
collectors items, but millions of others are <a href="https://www.j4u.co.jp/collections/game-boy-cartridges?_=pf&amp;sort=price-ascending&amp;pf_st_stock_status=true">available
for cheap</a> and are ripe for the picking. <a href="https://github.com/MouseBiteLabs/Game-Boy-MBC5-Cartridge">Bucket
Mouse‚Äôs flash carts</a> all use MBCs and reset ICs harvested from
original cartridges, and insideGadgets‚Äô <a href="https://shop.insidegadgets.com/product/gameboy-2mb-32kb-fram-mbc3-with-rtc-flash-cart/">RTC
cartridges</a> have harvested MBC3 chips.</p>
<p>But let‚Äôs say you don‚Äôt want to sacrifice a commercial cartridge to
the bootleg gods in order to satisfy your dark urges. While it‚Äôs
possible to implement a subset of MBC behavior using discrete logic ICs,
most flash cartridges out there use some kind of <a href="https://en.wikipedia.org/wiki/Programmable_logic_device">programmable
logic device</a>. Programmable logic devices are, essentially, a way to
compactly implement complex configurations of logic gates on one chip,
without the expense of manufacturing custom silicon. Generally,
programmable logic devices are programmed in a <a href="https://en.wikipedia.org/wiki/Hardware_description_language">hardware
description language</a>, such as Verilog or VHDL. I believe that <a href="https://shop.insidegadgets.com/product/gameboy-2mb-32kb-fram-flash-cart-ultra-low-power/">insideGadgets‚Äô
MBC5-compatible cartridges</a> use small CPLD chips to implement MBC5
behavior; <a href="https://bennvenn.myshopify.com/products/mbc3000-rtc-gbc-cart-v4">BennVenn‚Äôs
MBC3000</a> appears to use a CPLD chip as well. The <a href="https://www.ezflash.cn/product/ezflash-junior/">EZ-Flash
Junior</a> has a big ol‚Äô FPGA chip on it.</p>
<p>Still another way to do implement MBC behaior is to put a
microcontroller on the cartridge, and program the microcontroller to
respond to signals on the address and data bus and react appropriately.
This is <a href="https://abc.decontextualize.com/">the approach that I
took with my own bootleg cartridge</a>, as well as the approach used on
<a href="https://github.com/shilga/rp2350-gameboy-cartridge-firmware">Shilga‚Äôs
very cool Croco Cartridge</a> and <a href="https://emeryth.net/stm32-game-boy-cartridge/">this Game Boy
cartridge that uses an STM32 chip</a>.</p>
<p>Deciding on which strategy to use really comes down to what your
goals are. Harvested chips have few problems with compatibility, but to
produce them at scale, you need to be able to source a bunch of old
cartridges at low cost. FPGAs and CPLDs have a high ceiling in terms of
speed and accuracy, at potentially higher cost and complexity than other
solutions. I think microcontrollers are the most flexible strategy, but
it‚Äôs difficult to make a microcontroller-based cart that is both highly
accurate and doesn‚Äôt guzzle all your milliamps.</p>
<h2 id="mbc-protocol-vs.-flash-protocol">MBC protocol vs.¬†flash
protocol</h2>
<p>At this point, there is a little problem that we need to discuss. It
has to do with conflicts between what we need to put on the address and
data buses to control the MBC, and what we need to put on the buses in
order to control the flash IC. I want to spend a bit of time talking
about this problem, because when I first started out I found it
difficult to wrap my head around.</p>
<p>Regardless of whether we‚Äôre using a harvested MBC, an FPGA, or a
microcontroller (or something else entirely), we need to implement a way
for the cartridge flasher to read and write data beyond the first 32KB
on the flash IC. The easiest way to do this is to use the machinery that
we <em>already have</em> on the cart for dealing with this problem: the
MBC itself. Let‚Äôs look at an example scenario to see how this would
work, and potential complications that might arise.</p>
<h3 id="an-example-scenario">An example scenario</h3>
<p>Here‚Äôs an outline of the steps that a cart flasher might follow in
order to write data to the cartridge flash memory:</p>
<ul>
<li>Load up some source file on the computer that the cartridge flasher
is connected to. We‚Äôll call this <code>coolgame.gb</code>.</li>
<li>Erase the flash chip entirely by sending the appropriate flash
memory command.</li>
<li>Copy the first 16KB of <code>coolgame.gb</code>, byte-by-byte, to
the memory range <code>0x0000</code>‚Äì<code>0x3FFF</code> on the Game
Boy‚Äôs address bus, using the flash IC‚Äôs byte program command.</li>
<li>For each remaining chunk of 16KB in <code>coolgame.gb</code>:
<ul>
<li>Use the MBC protocol to switch banks so that the next empty bank is
visible at <code>0x4000</code>‚Äì<code>0x7FFF</code> on the Game Boy‚Äôs
address bus;</li>
<li>Copy the next 16KB of <code>coolgame.gb</code>, byte-by-byte, to the
memory range <code>0x4000</code>‚Äì<code>0x7FFF</code> on the Game Boy‚Äôs
address bus, using the flash IC‚Äôs byte program command.</li>
</ul></li>
</ul>
<p>(There are other ways of going about this that are potentially
faster, but let‚Äôs stick with the simplest scenario for now.)</p>
<figure>
<img src="https://todaythings.substack.com/p/cool-game.jpg" alt="Cool Game for the Game Boy (artist‚Äôs interpretation)"/>
<figcaption aria-hidden="true">Cool Game for the Game Boy (artist‚Äôs
interpretation)</figcaption>
</figure>
<p>Let‚Äôs look at this sequence of events in terms of what values the
cartridge flasher is putting on the address and data pins of the
cartridge. Say that the cartridge flasher was writing the byte at file
position <code>0x8123</code> in <code>coolgame.gb</code>, whose value
happens to be <code>0x45</code>. To write to this position in the
cartridge‚Äôs flash memory, the flasher first needs to switch ROM banks‚Äîin
this case, to bank 2. Then the flasher would use the flash IC‚Äôs ‚Äúwrite
byte‚Äù command to write <code>0x45</code> to position
<code>0x4123</code>. We end up with the byte <code>0x45</code> at
address <code>0x8123</code> in the flash IC‚Äôs memory, which matches the
byte‚Äôs address in <code>coolgame.gb</code>.</p>
<p>If you‚Äôre having trouble following, let‚Äôs break it down a bit.
Remember that each bank is 16KB in size, or <code>0x4000</code> bytes.
In terms of the banks‚Äô absolute addresses on the flash IC, bank 0 is
<code>0x0000</code>‚Äì<code>0x3FFF</code>, bank 1 is
<code>0x4000</code>‚Äì<code>0x7FFF</code>, bank 2 is
<code>0x8000</code>‚Äì<code>0xBFFF</code>, bank 3 is
<code>0xC000</code>‚Äì<code>0xFFFF</code>, and so forth. Switching to bank
2 causes the MBC to adjust the upper address pins of the ROM so that the
range <code>0x4000</code>‚Äì<code>0x7FFF</code> on the Game Boy‚Äôs address
bus <em>actually</em> points to the absolute address
<code>0x8000</code>‚Äì<code>0xBFFF</code> in the flash, so writing a value
to <code>0x4123</code> on the Game Boy‚Äôs address bus <em>actually</em>
writes to the flash IC‚Äôs absolute address <code>0x8123</code>. We‚Äôre
using the MBC to change the flash IC‚Äôs address pins behind the flash
IC‚Äôs back, but still using the flash IC protocol to write the actual
data.</p>
<p>Here‚Äôs what would happen on the data and address buses in this
scenario, assuming that we‚Äôd already erased the flash IC. In this
scenario (which, we shall see, doesn‚Äôt actually do what we want it to
do), imagine that the flasher holds the <code>_WR</code> pin low during
each write, and the <code>_WR</code> pin on the cartridge is connected
to both the <code>_WR</code> pin of the MBC and the <code>_WR</code> pin
of the flash IC.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Step</th>
<th>Memory bus value</th>
<th>Data bus value</th>
<th>How the MBC interprets it</th>
<th>How the flash IC interprets it</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong><code>0x2000</code></strong></td>
<td><code>0x2</code></td>
<td>switch to ROM bank <code>0x2</code></td>
<td>None</td>
</tr>
<tr>
<td>2</td>
<td><code>0x5555</code></td>
<td><code>0xAA</code></td>
<td>switch to RAM bank <code>0xAA</code></td>
<td>Flash byte-program sequence, step 1</td>
</tr>
<tr>
<td>3</td>
<td><strong><code>0x2AAA</code></strong></td>
<td><code>0x55</code></td>
<td>switch to ROM bank <code>0x55</code></td>
<td>Flash byte-program sequence, step 2</td>
</tr>
<tr>
<td>4</td>
<td><code>0x5555</code></td>
<td><code>0x80</code></td>
<td>switch to RAM bank <code>0x80</code></td>
<td>Flash byte-program sequence, step 3</td>
</tr>
<tr>
<td>5</td>
<td><code>0x4123</code></td>
<td><code>0x45</code></td>
<td>hold upper flash address pins so that Game Boy address
<code>0x4000</code>‚Äì<code>0x7FFF</code> points to the bank 2 area of the
flash IC</td>
<td>Flash byte-program sequence, step 4 (our address and byte
value)</td>
</tr>
</tbody>
</table>
<p>If you take a look in the bolded address values in the table above,
you should be able to see the problem. The MBC5 protocol dictates that
any write between <code>0x2000</code> and <code>0x3FFF</code> should
change the current ROM bank. However, the flash protocol dictates that
you need to write to <code>0x2AAA</code> as part of the byte-program
sequence‚Ä¶ which has the side-effect of telling the MBC5 to set the ROM
bank! Because of this overlap, it seems like we simply won‚Äôt be able to
<em>both</em> switch banks using the MBC5 <em>and</em> issue the
sequence that the flash chip requires to program a byte value‚Äîunless we
only care about writing to ROM bank <code>0x55</code> (which would be
weird). How can we fix this?</p>
<p>Note that the required write to <code>0x5555</code> <em>also</em>
conflicts with the MBC protocol! In this case, however, because we‚Äôre
writing to the flash IC, we don‚Äôt necessarily care about spurious RAM
bank changes. If we need to read or write from RAM later, we‚Äôll just
have to remember to reset the RAM bank to a known good value.</p>
<h3 id="flash-and-the-mbc-living-together-in-harmony">Flash and the MBC,
living together in harmony</h3>
<p>There are two ways to solve this problem. The first is easy: just
<em>pick a flash memory IC whose commands don‚Äôt conflict with the MBC
protocol</em>. The <a href="https://www.infineon.com/dgdl/Infineon-S29GL064S_64-MBIT_(8_MBYTE)_3.0_V_FLASH_MEMORY-DataSheet-v09_00-EN.pdf?fileId=8ac78c8c7d0d8da4017d0ed12bd84d2d&amp;utm_source=cypress&amp;utm_medium=referral&amp;utm_campaign=202110_globe_en_all_integration-files">flash
IC that I use on my bootleg cartridge</a> uses <code>0xAAA</code> and
<code>0x555</code> as command address values, instead of
<code>0x5555</code> and <code>0x2AAA</code>, meaning that the worst a
flash command can do is lock the on-cartridge RAM.</p>
<p>The second way is to <em>use separate pins</em> for the flash chip‚Äôs
<code>_WR</code> input and the MBC‚Äôs <code>_WR</code> input, so that we
can send commands to the two ICs separately. It so happens that there is
a pin on the Game Boy cartridge edge that was <a href="https://gbdev.io/pandocs/Audio.html?highlight=vin#architecture">never
used for any commercial games</a>: the <code>AIN</code> (or
<code>AUDIO</code>, or <code>VIN</code>) pin, which is right next to the
ground pin. Some flash cartridges repurpose this as a ‚Äúsubstitute‚Äù
<code>_WR</code> pin. On such cartridges, the flash IC‚Äôs
<code>_WR</code> pin is connected to the MBC‚Äôs <code>_WR</code> pin (as
normal), but the flash IC‚Äôs <code>_WR</code> pin is connected to
<code>AIN</code>. This means that the flasher can lower <code>AIN</code>
for commands that are meant for the flash IC, but lower <code>_WR</code>
pin for commands that are meant for the MBC. Conflict resolved! Here‚Äôs a
diagram of what the situation looks like, including only the relevant
elements:</p>
<figure>
<img src="https://todaythings.substack.com/p/ain_diagram.svg" alt="Diagram showing the cart flasher, MBC and flash IC, along with the write and audio pins connecting them"/>
<figcaption aria-hidden="true">Diagram showing the cart flasher, MBC and
flash IC, along with the write and audio pins connecting
them</figcaption>
</figure>
<p>I don‚Äôt know who came up with this solution originally, but it‚Äôs very
clever! Essentially, we have <em>two</em> <code>_WR</code> pins: one for
the MBC (and on-cartridge RAM, if any) and one for the flash IC. As long
as the cartridge flasher is careful to never lower both pins at the same
time, the flash IC will never see the MBC commands, and the MBC will
never see the flash commands. Even if you‚Äôre using a flash chip whose
commands <em>don‚Äôt</em> conflict with the MBC, it still might be a good
idea to use this setup, just as an extra bit of protection against
accidentally writing incorrect values to flash memory. FlashGBX has
support for this strategy built in.</p>
<h2 id="cartridge-ram-and-data-persistence">Cartridge RAM and data
persistence</h2>
<p>Blessedly, parallel SRAM ICs have none of the data access
complications of parallel flash: you just set the address bus and
read/write to the data bus. No protocol required. It‚Äôs even possible to
purchase <a href="https://www.issi.com/WW/pdf/62WV1288ALL.pdf">parallel
SRAM that is more or less functionally equivalent</a> to the SRAM ICs
found on commercial Game Boy cartridges back in the day. Provided that
your solution for emulating an MBC also supports all of the cartridge
RAM-related portions of MBC functionality (locking/unlocking RAM,
restricting access to particular address ranges, and bank switching for
games that need it), the way you wire up your on-cartridge SRAM IC will
look very similar to how it‚Äôs wired up on a stock cartridge.</p>
<p>Complications arise, however, when we start thinking about how to
ensure that the data on the cartridge RAM is persistent between play
sessions. We‚Äôll talk about two strategies for doing this, both with
benefits and drawbacks.</p>
<h3 id="sram-plus-battery">SRAM plus battery</h3>
<p>The first strategy is to do as Nintendo did: use an on-cartridge
battery. The main benefit of this solution is that SRAM is relatively
cheap, and little button cell batteries are relatively cheap, and you
can get impressively long retention times with this combination, even if
SRAM is technically volatile memory. One drawback is that button cell
batteries are fairly large, and so they take up space on the cartridge
PCB that might otherwise be put to better use.</p>
<p>But the real trouble here, right off the bat, is making sure that the
SRAM switches cleanly between Game Boy power and battery power, without
risk of memory corruption. (We discussed this problem earlier in the
section on MBC5 and Cartridge RAM.) Ideally, we‚Äôd be able to buy an
off-the-shelf IC that works exactly like the reset ICs found on the
original cartridges: it switches between power sources based on voltage
levels, forwards an incoming <code>_CS</code> signal to the SRAM chip
when above that threshold, then holds the SRAM‚Äôs <code>_CS</code> pin
high when below that threshold. (Or equivalent functionality.)</p>
<figure>
<img src="https://todaythings.substack.com/p/tps3613.jpg" alt="The TPS3613, a 10-MSOP chip that costs like five damn dollars"/>
<figcaption aria-hidden="true">The TPS3613, a 10-MSOP chip that costs
like five damn dollars</figcaption>
</figure>
<p>From what I can gather, there used to be a wide variety of ICs on the
market that were designed especially for supporting battery-backed SRAM,
and had exactly the functionality I just described. Nowadays, though,
demand has waned and the least expensive single-chip solution out there
is Texas Instruments‚Äô <a href="https://www.ti.com/product/TPS3613-01">TPS3613</a>‚Äîand even that
IC (as of this writing) costs an eye-watering US$4.45 at single unit
prices (!). It would be possible to design a circuit with discrete parts
(a voltage detection IC and a MOSFET or two, say) that would serve the
same purpose and maybe be cheaper. But I think it‚Äôs better to be safe
than sorry when it comes to save game data and battery life, so I opted
to use this IC in my own cart design. (It <em>is</em>, by some margin,
the most expensive part in my BOM. Oh well!)</p>
<p>I will once again <a href="https://github.com/MouseBiteLabs/Game-Boy-MBC5-Cartridge/tree/main/Technical#battery-management-and-data-retention-considerations">direct
you to Bucket Mouse‚Äôs excellent explanation of battery-backed SRAM on
Game Boy cartridges</a> for a more in-depth discussion, including
information on which reset ICs are worth harvesting from original
carts.</p>
<h3 id="ferroelectric-ram-fram">Ferroelectric RAM (FRAM)</h3>
<p>The second strategy for persistent data storage is to do as Nintendid
not: use some kind of non-volatile memory for saved games. The popular
choice here is parallel <a href="https://en.wikipedia.org/wiki/Ferroelectric_RAM">ferroelectric
RAM</a> (or FRAM), as featured on <a href="https://shop.insidegadgets.com/product/gameboy-2mb-32kb-fram-flash-cart-ultra-low-power/">various
insideGadgets cartridges</a>, FunnyPlaying‚Äôs <a href="https://funnyplaying.com/products/midnighttrace-gb-gbc-flash-cart-v2">Midnight
Trace</a>, etc. The interface of parallel FRAM ICs is exactly like the
interface to parallel SRAM ICs (aside from <a href="https://www.insidegadgets.com/2018/09/08/building-a-2mb-mbc5-gameboy-cart-part-5-using-32kb-fram-and-adding-mbc1-2mb-rom-support/">some
potential timing issues, depending on the IC in question</a>), and in
fact many FRAM ICs are sold as pin-compatible drop-in SRAM replacements.
FRAM retains its contents for decades without external power, so there‚Äôs
no need for a battery or a reset IC to switch power sources.</p>
<p>The main disadvantage of FRAM, and it‚Äôs a big one, is cost. As of
this writing, you can get a 256Kbit (32KB) parallel SRAM chip for under
US$1.50; a parallel FRAM chip with similar capacity costs around US$12.
At those prices, you‚Äôre coming out ahead with SRAM, even with the added
cost of the button cell and the TPS3613. Still, FRAM might give you the
peace of mind that you need when it comes to the security of your
pikachus.</p>
<p>Flash cartridges with SD cards, like the EZ-Flash Jr, use a third
strategy, which is to copy the contents of the on-cartridge SRAM to the
SD card, and then copy that data back into the SRAM when the cartridge
starts back up. The benefit of this is, of course, that the saved game
data is right there, safe and sound on your SD card. The drawback is
that writing data to an SD card is typically very <em>slow</em>‚Äîmuch
slower than the speed at which the Game Boy writes to RAM‚Äîso SD
card-based cartridges can‚Äôt keep up with SRAM changes in real-time. The
EZ-Flash Jr cartridge solves this problem with an on-cartridge button
that the you have to press after they save their game. The button
initiates the process of copying the SRAM contents to the cartridge. You
just have to make sure that you wait a few seconds for the copy to
complete before turning your Game Boy off.</p>
<h2 id="power-problems">Power problems</h2>
<p>Like many other gadgets and gizmos released in the late 1980s and
early 1990s, the Game Boy runs on 5V. Consequently, Game Boy cartridges
run on 5V as well. Nowadays, however, most small electronics run at
lower voltages internally‚Äîtypically 3.3V, but sometimes even lower. So
folks who make Game Boy cartridges from scratch have a choice to make
when sourcing their parts: you can either find 5V components (like 5V
flash memory and 5V SRAM)‚Äîwhich are becoming more rare and more
expensive‚Äîor you can do some electronics gymnastics to convert the Game
Boy‚Äôs 5V power and signals to a lower voltage, so you can use lower
voltage components instead. In this section, we‚Äôre going to dive into
what‚Äôs involved in implementing the second strategy.</p>
<p>If you want to use lower voltage components on your cartridge, you
need two things:</p>
<ul>
<li>A <a href="https://www.digikey.com/en/maker/tutorials/2020/what-is-a-voltage-regulator">voltage
regulator</a> to convert the Game Boy‚Äôs 5V power source to whatever
voltage that can safely power your components;</li>
<li>A <a href="https://www.digikey.com/en/blog/logic-level-shifting-basicshttps://www.digikey.com/en/blog/logic-level-shifting-basics">logic
level translator</a> (or level shifter) to convert the Game Boy‚Äôs 5V
logic signals (i.e., the values on the data bus and address bus) to a
voltage that won‚Äôt fry your components‚Äô inputs.</li>
</ul>
<p>This diagram shows the general relationship of components when you
have both of these in place:</p>
<figure>
<img src="https://todaythings.substack.com/p/voltage_diagram.svg" alt="Diagram showing voltage regulator and level shifter between the Game Boy CPU and 3.3V components"/>
<figcaption aria-hidden="true">Diagram showing voltage regulator and
level shifter between the Game Boy CPU and 3.3V components</figcaption>
</figure>
<p>Let‚Äôs discuss voltage regulation and level translation in turn.</p>
<h3 id="voltage-regulation">Voltage regulation</h3>
<p>Broadly, there are two strategies for converting a high voltage power
source to a lower voltage power source: burn off the excess voltage as
heat with a <a href="https://en.wikipedia.org/wiki/Linear_regulator">linear
regulator</a>, or use a <a href="https://en.wikipedia.org/wiki/Buck_converter">buck converter</a>,
which switches the higher voltage power source on and off very fast, so
that the resulting voltage averages out to the desired lower voltage.
(That‚Äôs very simplified explanation of a buck converter, but you get the
gist.)</p>
<p>Both approaches have benefits and drawbacks. Linear regulator
circuits are easy to design and inexpensive, but linear regulators
themselves are not very efficient: in the case of a 5V to 3.3V
conversion, at least 34% of the energy that flows through the regulator
goes to waste‚Äîwhich can result in reduced battery life for the system as
a whole. Buck converters are much more energy efficient, but they‚Äôre
more complicated to design and more expensive (partially because of the
increased number of components needed). A poorly designed buck converter
circuit can also potentially introduce unwanted noise into the Game
Boy‚Äôs electronics.</p>
<p>From the photos on the site, I‚Äôd bet that <a href="https://bennvenn.myshopify.com/products/mbc3000-rtc-gbc-cart-v4?variant=40095079202919">BennVenn‚Äôs
MBC3000</a> uses a linear regulator. On the other hand, the <a href="https://www.ezflash.cn/product/ezflash-junior/">EZ-Flash Jr</a>
has <em>two</em> buck converters‚Äîone at 3.3V and another at
1.2V‚Äîpresumably because there are both 1.2V and 3.3V components on the
cartridge. I opted for a buck converter in <a href="https://git.sr.ht/~aparrish/abc-pcb">my own design</a>.</p>
<p>I am not a paid endorser but if you‚Äôre working on a buck converter
circuit, I highly recommend <a href="https://www.ti.com/tool/WEBENCH-CIRCUIT-DESIGNER">TI‚Äôs WEBENCH
circuit designer</a> tool. It‚Äôll give you some confidence while you pick
out that inductor.</p>
<h3 id="level-translation">Level translation</h3>
<p>Level translation can also be tricky! The chief potential trouble
with level translators is that their ability to produce clean output
degrades as the speed of signal changes on the input increases. The Game
Boy isn‚Äôt an especially fast processor, but the signals on the data and
address pins can reach 4MHz, which means that some voltage translation
solutions (like using a simple voltage divider) are probably not going
to cut it.</p>
<p>Also, some level translators require external control of the
direction of translation (i.e., whether the translator is transmitting
data from high to low, or low to high), and external control of whether
or not the level translator should be active at all. This means that the
cartridge needs to incorporate some kind of logic that can make these
determinations‚Äîwhich, as we‚Äôve seen in this document, need to take into
account a number of different factors (e.g., the address range, whether
the cartridge RAM is locked or not, etc.). The task is complicated
enough that you might need to include discrete logic ICs or a
microcontroller in your cartridge design just for the purpose of
controlling the level translator.</p>
<p>The good news is that there are a number of off-the-shelf level
translators that get the job done with a minimum amount of fuss. I‚Äôve
used <a href="https://www.nexperia.com/product/74ALVC164245DGG">Nexperia‚Äôs
74ALVC164245DDG</a> with some success on my own cartridge designs. I‚Äôve
seen folks use <a href="https://www.ti.com/product/TXB0108">TI‚Äôs
TXB0108</a> for this purpose as well, which has an automatic direction
sensing feature that obviates the need for all of the direction logic
that I mentioned above.</p>
<p>The bad news is that level translation ICs aren‚Äôt super cheap: TI‚Äôs
non-bulk list price for one TXB0108 is (as of this writing) US$1.14,
which means that implementing level translation for your cartridge‚Äôs
address and data bus can adds a non-trivial amount to the cost of your
cartridge‚Äôs bill of materials.</p>
<p>When I priced it out recently, it didn‚Äôt seem like there was a
meaningful difference in the cost between using all 5V parts (which tend
to be more expensive) versus using 3.3V parts along with a voltage
regulator and level translator. Eventually I elected to use 3.3V parts,
which makes my cartridge design more complicated, but also makes it (I
think!) more future-proof.</p>
<h2 id="strategies-for-on-cartridge-components">Strategies for
on-cartridge components</h2>
<p>One of the exciting possibilities open to cartridge makers is the
ability to include weird hardware components on the cartridge, in order
do to things with the Game Boy that Nintendo never envisioned. A few
examples of custom cartridges that do this:</p>
<ul>
<li>orangeglo‚Äôs <a href="https://orangegb.com/orangefm/https://orangegb.com/orangefm/">Orange
FM cartridge</a></li>
<li><a href="https://shop.insidegadgets.com/product/bulb-gbc-game/">BULB!</a>
game with a cart incorporating an LED</li>
<li><a href="https://github.com/Staacks/wifi-game-boy-cartridge">Game
Boy cartridge with WiFi</a></li>
<li>John Sutley‚Äôs <a href="https://github.com/JohnSutley/Worlds-Worst-Digital-Dash">World‚Äôs
Worst Dash</a></li>
<li>Peter Sobot‚Äôs <a href="https://github.com/psobot/musicboy/">Music
Boy</a> cartridge</li>
<li>Anders Granlund‚Äôs <a href="https://www.happydaze.se/wolf/">Wolf</a>
(custom cartridge with ‚Äúco-processor‚Äù for playing Wolfenstein 3D on the
Game Boy Color)</li>
</ul>
<p>I made a little <a href="https://friend.camp/deck/@aparrish/113795525210183686">light
theremin</a> with my own cart design, just as a quick experiment! It was
fun.</p>
<p>A cartridge that integrates hardware components like this needs to
have some way for the software on the Game Boy to communicate with the
hardware. As you might expect, there are multiple ways to do this!
Simple one-bit, one-way communication (e.g., to blink an LED, or to
start/stop a rumble motor, as we discussed earlier) may just require
connecting the hardware to a particular address pin on the hardware
side, and then accessing an address that changes the value of that pin
on the software side. The ‚ÄúSystems of Levers‚Äù channel on YouTube <a href="https://www.youtube.com/watch?v=MybHQxDk70g">has a very clear
tutorial about how to do exactly this</a> which I highly recommend as a
starting point.</p>
<p>More sophisticated communication scenarios might involve designating
a particular address or address range in the memory map for writing data
(Game Boy to cartridge) and another address range for reading data
(cartridge to Game Boy). In this scenario, you‚Äôd need some logic
(microcontroller, PLD, discrete logic, etc.) on the cartridge that
detects that matching pattern of address values, and drives the data bus
or reads from the data bus accordingly, taking care to ensure that no
other components will be writing to the data bus at the same time.</p>
<p>In the ‚Äúon-cartridge peripherals‚Äù section above, we saw a few
examples of how commercial cartridges handled this: they used the MBC as
a proxy, so that reads and writes in the cartridge RAM memory range
(<code>0xA000</code>‚Äì<code>0xBFFF</code>) are redirected to the
peripheral hardware under certain conditions. My own cartridge uses this
same address range to allow the cartridge software to communicate with a
microcontroller on the cart, in order to facilitate multicart
functionality; the <a href="https://github.com/shilga/rp2040-gameboy-cartridge-firmware/">Croco
Cartridge</a> also uses this address range (although in the case of the
Croco Cartridge, the microcontroller is also serving the role of the
on-cartridge RAM, which means that this memory range is essentially
mapped to <em>both</em> the Game Boy‚Äôs memory and the memory of the
microcontroller on the cartridge‚Äîvery slick).</p>
<p>The Game Boy WiFi cartridge I mentioned above uses a different
strategy altogether. <a href="https://github.com/Staacks/wifi-game-boy-cartridge/blob/master/pcb/wifi-gb-cart-schematic-preview.png">There‚Äôs
a number of discrete logic ICs on the board</a> connected to the address
bus that signal the on-board microcontroller when a particular addresses
are being accessed. When the address is <code>0x7FFF</code>, the Game
Boy software is sending data to the microcontroller; when the address is
<code>0x7FFE</code>, the microcontroller is sending data to the Game
Boy. Using this convention, the on-cartridge microcontroller and the
Game Boy software can take turns driving the data bus to exchange
information.</p>

<p>So here‚Äôs what we now know about making a cartridge from scratch:</p>
<ul>
<li>Parallel flash is a good match for the task of storing Game Boy ROMs
on a cartridge, since the pinouts of parallel flash ICs are similar to
the ROM chips on original cartridges</li>
<li>Once the flash IC is on the cartridge PCB, you need some way to get
data on there, which is why we have cartridge flashers</li>
<li>Hardware ‚Äúemulation‚Äù of an MBC IC can be implemented in various
ways, including FPGAs and microcontrollers</li>
<li>For storing persistent data, you have your choice between
battery-backed SRAM or FRAM, both of which kind of suck (for different
reasons)</li>
<li>Potential sources of trouble include flash/MBC protocol conflicts
and the need for voltage translation between the Game Boy and
on-cartridge components</li>
</ul>
<p>Thank you for reading! I hope I delivered on the promise of giving
you more than you wanted to know on the topic of Game Boy cartridges.
However, if your knowledge somehow remains below the threshold of your
desire, here are some other resources that might finally get you over
the top:</p>
<ul>
<li>If you want to study schematics of commercial cartridges, Martin
Refseth‚Äôs <a href="https://github.com/HDR/NintendoPCBs">reproduction
cartridge PCBs</a> are as close as you‚Äôre going to get!</li>
<li>Also check out <a href="https://github.com/MouseBiteLabs/Game-Boy-Cartridges?tab=readme-ov-file">Bucket
Mouse‚Äôs Game Boy Cartridge PCBs</a> (adapted to use flash memory).</li>
<li>System of Levers‚Äô <a href="https://www.youtube.com/watch?v=s0Kcg5_z0rI">How Game Boy Memory
Addresses Work</a> is very clear and slightly higher-level explanation
that has significant overlap with the content of this document. The
channel also has a series of excellent hands-on examples of adding
hardware peripherals to the Game Boy: <a href="https://www.youtube.com/watch?v=MybHQxDk70g">How to control an LED
with the Game Boy</a> and <a href="https://www.youtube.com/watch?v=hFOe_I2B8kg">how to read a button
with the Game Boy</a>.</li>
<li><a href="https://b13rg.icecdn.tech/Gameboy-Bank-Switching/">Gameboy
DMG ROM and RAM Bank Switching</a> is a helpful and clear narrative
explanation of how memory banking on the Game Boy works, from the
programmer‚Äôs perspective</li>
<li><a href="https://iceboy.a-singer.de/doc/mem_patterns.html">Very
helpful timing diagrams</a> of Game Boy memory access patterns</li>
<li>And of course, <a href="https://gbdev.io/pandocs/">Pan Docs</a> and
gekkio‚Äôs <a href="https://gekkio.fi/files/gb-docs/gbctr.pdf">Game Boy:
Complete Technical Reference</a>.</li>
</ul>

<p>The contents of this website are published under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC
BY-NC-SA</a> license. Use of the contents of this website as part of a
dataset to train a machine learning model is allowed, under the terms of
this license. (For example, a model that includes this website as part
of its dataset must explicitly credit me among its contributors, and
must be distributed under the same license as the website itself. Also,
any model making use of this website in its data set must not be used
for commercial purposes.)</p>
</div></div>
  </body>
</html>
