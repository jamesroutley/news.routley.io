<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/linux/KernelBindBugIn6016">Original</a>
    <h1>Sometimes it actually is a kernel bug: bind() in Linux 6.0.16</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Sometimes it actually is a kernel bug: bind() in Linux 6.0.16</h2>

	<p><small>January 11, 2023</small></p>
</div><div><p>There&#39;s a common saying and rule of thumb in programming (possibly
originating in the C world) that it&#39;s never a compiler bug, it&#39;s
going to be a bug in your code even if it looks crazy or impossible.
Like all aphorisms it&#39;s not completely true, because compilers have
bugs, but it&#39;s almost always the case that you haven&#39;t actually
found a compiler bug and it&#39;s something else. You can say a similar
thing about weird system issues (not) being the fault of a kernel
bug, and so that&#39;s what I thought when the development version of
Go started failing a self test when I built it on my Fedora 37
office desktop:</p>

<blockquote><pre>--- FAIL: TestTCPListener (0.00s)
    listen_test.go:72: skipping tcp  test
    listen_test.go:72: skipping tcp 0.0.0.0 test
    listen_test.go:72: skipping tcp ::ffff:0.0.0.0 test
    listen_test.go:72: skipping tcp :: test
    listen_test.go:90: tcp 127.0.0.1 should fail
</pre>
</blockquote>

<p>Where <a href="https://go.googlesource.com/go/+/refs/heads/master/src/net/listen_test.go#61">this test in net/listen_test.go</a>
is failing is when it attempts to listen twice on the same localhost
IPv4 address and port. It first binds to and listens on 127.0.0.1
port 0 (that port causes the kernel to assign a free ephemeral port
for it), extracts the actual assigned port, and then attempts to
bind to 127.0.0.1 on the same port a second time.</p>

<p>(The Go networking API bundles the binding and listening together
in one Listen() API, but the socket API itself has them as two
operations; you <code>bind()</code> a socket to some address, then <code>listen()</code>
on it.)</p>

<p>This obviously should fail, except the development version of Go
was claiming that it didn&#39;t. Aft first I thought this had to be a
Go change, but soon I found that even older versions of Go didn&#39;t
pass this test (when I knew they had when I&#39;d built them), and also
that this test passed on my Fedora 36 home desktop. Which I noticed
was running Fedora&#39;s 6.0.15 kernel, while my office machine was
running 6.0.16. That certainly looked like a kernel bug, and indeed
I was able to reproduce it in Python (which is when I eventually
realized this was an issue with bind() instead of listen()).</p>

<p>The Python version allows me to see more about what&#39;s going on:</p>

<blockquote><pre>&gt;&gt;&gt; from socket import *
&gt;&gt;&gt; s1 = socket(AF_INET, SOCK_STREAM)
&gt;&gt;&gt; s2 = socket(AF_INET, SOCK_STREAM)
&gt;&gt;&gt; s1.bind((&#39;127.0.0.1&#39;, 0))
&gt;&gt;&gt; s2.bind((&#39;127.0.0.1&#39;, s1.getsockname()[1]))
&gt;&gt;&gt; s1.getsockname()
(&#39;127.0.0.1&#39;, 54785)
&gt;&gt;&gt; s2.getsockname()
(&#39;0.0.0.0&#39;, 0)
</pre>
</blockquote>

<p>Rather than binding the second socket or failing with an error, the
kernel has effectively left it unbound (the s2.getsockname() result
here is the same as when the socket is newly created (<a href="https://utcc.utoronto.ca/~cks/space/blog/unix/BindingOutgoingSockets">&#39;0.0.0.0&#39;
is usually known as INADDR_ANY</a>).
Replacing <code>SOCK_STREAM</code> with <code>SOCK_DGRAM</code> causes things to fail
with &#39;address already in use&#39; (errno 98), so this issue seems
specific to TCP.</p>

<p>This kernel error is in Fedora 37&#39;s 6.0.16 and 6.0.18, but is gone
in the Rawhide 6.2.0-rc2 and isn&#39;t present in the Fedora 6.0.15.
I don&#39;t know if it&#39;s in any version of 6.1, but I&#39;ll probably find
out soon when Fedora updates to it. Interested parties can try it
for themselves, and it&#39;s been filed as <a href="https://bugzilla.redhat.com/show_bug.cgi?id=2159802">Fedora bug #2159802</a>.</p>

<p>(This elaborates on <a href="https://mastodon.social/@cks/109666477877960733">a Fediverse thread</a>. I looked at
<a href="https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.0.16">the 6.0.16 changelog</a>,
but nothing jumped out at me.)</p>
</div></div>
  </body>
</html>
