<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://faultlore.com/blah/abi-puns/">Original</a>
    <h1>Pair Your Compilers at the ABI Café</h1>
    
    <div id="readability-page-1" class="page"><article>

    
    <header>
    
    <p>May 5th, 2024</p>
<nav id="TOC"><ul>
<li><a href="#last-time-on-ffi-bugs">1 Last Time On FFI Bugs</a><ul></ul></li>
<li><a href="#the-limits-of-abi-cafe-10">2 The Limits of abi-cafe 1.0</a><ul></ul></li>
<li><a href="#why-is-abi-cafe">3 Why is abi-cafe</a><ul></ul></li>
<li><a href="#what-does-it-mean-for-compilers-to-agree">4 What Does It Mean For Compilers To Agree?</a><ul>
<li><a href="#the-base-case-primitives">4.1 The Base Case: Primitives</a><ul>
<li><a href="#an-aside-picking-values-for-primitives">4.1.1 An Aside: Picking Values For Primitives</a><ul></ul></li>
<li><a href="#an-aside-primitive-semantic-checking">4.1.2 An Aside: Primitive Semantic Checking</a><ul></ul></li></ul></li>
<li><a href="#the-inductive-case-composite-types">4.2 The Inductive Case: Composite Types</a><ul></ul></li>
<li><a href="#tagged-unions-i-guess-alright">4.3 Tagged Unions: I Guess Alright?</a><ul></ul></li>
<li><a href="#untagged-unions-fuck-ok">4.4 Untagged Unions: FUCK OK</a><ul></ul></li>
<li><a href="#real-puns-real-pain">4.5 REAL PUNS: REAL PAIN</a><ul>
<li><a href="#transparent-primitives-ok">4.5.1 Transparent Primitives: Ok!</a><ul></ul></li>
<li><a href="#option-optimization-uhhh">4.5.2 Option Optimization: Uhhh</a><ul></ul></li>
<li><a href="#crimes-crimes-crimes">4.5.3 CRIMES CRIMES CRIMES</a><ul></ul></li></ul></li></ul></li>
<li><a href="#the-heart-of-abi-cafe-20-kdl-script">5 The Heart Of abi-cafe 2.0: kdl-script</a><ul></ul></li></ul></nav></header>
<p><img src="https://faultlore.com/blah/abi-puns/maid-cafe.png" alt="a very nervous maid in a burning cafe"/></p>
<blockquote>
<p>Not sure if your compilers have matching ABIs? Then put them through the ultimate compatibility crucible and pair them up on a shift at The ABI Café! Find out if your one true pairing fastcalls for each other or are just another slowburn disaster. (Maid outfits optional but recommended.)</p>
</blockquote>
<p>I’m pretty sure I’ve tried to write some version of this article like 5 times over several years, but finally I got the right motivation, and I need to get some of this out of my head.</p>

<p>When last we left our heroine, <a href="https://faultlore.com/blah/c-isnt-a-language/">she was sobbing uncontrollably about the absolutely disastrous state of affairs that is FFI, and how the best we’ve come up with is “everyone pretends to be C, even though C has the worst and wobbliest ABIs of all time”</a>.</p>
<p>In that article I briefly discussed my own attempts at this, <a href="https://github.com/Gankra/abi-cafe">a tool called “abi-checker” which I’ve since renamed to abi-cafe</a>.</p>
<p>To recap, abi-cafe was created in a feverish mania as I became increasingly obsessed with the disaster that was C’s technically-nonstandard-but-also-literally-used-in-standards <code>__int128</code>. Like sure there’s the whole <a href="https://thephd.dev/to-save-c-we-must-save-abi-fixing-c-function-abi">intmax_t debacle</a>, but that’s <em>understandable</em>. The truly unforgivable thing was that <em>clang and gcc couldn’t reliably pass <code>__int128</code> between each other</em>. This of course meant that if Rust’s i128 wished to interoperate with them… <strong>it would always be wrong, because there was no correct answer</strong>.</p>
<p>Actually I’m telling this story a bit backward. <a href="https://github.com/rust-lang/rust/issues/54341">Initially we definitely knew that Rust and Clang disagreed in at least one case on at least platform</a>. Discussion of this issue was stalled out because people weren’t sure of the scope and nature of the problem. Which cases were broken? Who was right or wrong and needed to be fixed? What needed to be fixed? Did <code>__int128</code> FFI work right on <em>any</em> platforms?</p>
<p>So I made abi-cafe, which let me describe a function signature in the abstract and generate code for the caller and callee, in Rust or C, and compile and link them together. Notably the generated code had both sides “report” the values they saw with callbacks, so the test harness could just run them and compare what each side reported.</p>
<p>I like this approach because it requires no actual knowledge of what the ABI “should” be and gets you very concrete error reports.</p>
<p>abi-cafe quickly helped me reproduce the <code>__int128</code> issue between rustc and clang. I was also able to generate tons of different ways of passing it, so I quickly understood in what ways they diverged! Then on a lark I added support for gcc, and tested gcc_calls_clang and clang_calls_gcc to establish a baseline of “here’s it working” and… it… didn’t!? In fact all 3 compilers disagreed on x64 Linux!</p>
<p>This work quickly resulted in two important and clear conclusions:</p>
<ul>
<li>
<p>Remember how I said <code>__int128</code> was technically-nonstandard-but-also-literally-used-in-standards? Well those standards are the registers for Aarch64 (ARM64)! Specifically some low-level APIs for saving/restoring NEON (SIMD) registers are defined in terms of the <code>__int128</code> type, and so <em>absolutely everyone</em> agrees on the ABI of that type. As such, <a href="https://github.com/rust-lang/libc/pull/2719">I was able to mark <code>__int128</code> FFI as safe/correct on that architecture</a>!</p>
</li>
<li>
<p>It was clear that the <code>__int128</code> bug was rooted in LLVM, and that clang and rustc were inheriting the issue. Clang half-worked around it, while rustc just did whatever LLVM said. As a result, everyone disagreed! I am pleased to report that after much hand-wringing the issue has been resolved in LLVM, and that the latest rustc and clang releases interoperate with each other and gcc perfectly! <a href="https://blog.rust-lang.org/2024/03/30/i128-layout-update.html">I highly recommend the <em>excellent</em> article about this on Rust’s blog</a>.</p>
</li>
</ul>
<p><strong>Congrats to everyone who worked on this, you’re the real MVPs!!!</strong></p>

<p>In the intervening time, <a href="https://github.com/bjorn3/rustc_codegen_cranelift/issues/1234">abi-cafe was also used by the developers of rustc’s cranelift codegen backend to find at least one bug</a>, which was super cool!</p>
<p>They suggested some more features it could have for checking more ABIs and I was in absolute agreement, but also at a bit of a loss for how to do them.</p>
<p>If you dig into <a href="https://github.com/Gankra/abi-cafe/tree/aaa685a0ee09e438b294b48a33998d0ab95fb988">the current main branch of abi-cafe</a> you will see… A Big Fucking Mess. I had a specific problem to solve, and I wanted to fuck around with some ideas I had, and well, the whole thing was stuck in a bit of a local optima.</p>
<p>Most fundamentally, there were limits to <a href="https://github.com/Gankra/abi-cafe/blob/aaa685a0ee09e438b294b48a33998d0ab95fb988/tests/normal/structs.ron">the format for specifying a test</a> that prevented enums, unions, and more complex type puns from being expressed.</p>
<p>As a result I’ve been at vaguely toying with the idea of <a href="https://github.com/Gankra/abi-cafe/pull/20">abi-cafe 2.0</a> for quite a while, occasionally working through the theory and implementation of it, but needless to say it was all a bit exhausting and overwhelming, especially without the original motivation driving it forward.</p>
<p>But! My most recent burst of motivation has finally borne fruit, and I’ve finally gotten the full pipeline just barely working enough to compile and test rustc against itself with actual tagged unions! At this point I just need to fill in the C implementation and polish up some TODOs, although <a href="https://github.com/Gankra/abi-cafe/pull/20#pullrequestreview-2039521441">one of those TODOs in particular</a> weighs heavily on my mind, and is the reason I wrote this article.</p>
<p>Or rather I was trying to explain the problem and solution I think I’ve worked out for the TODO, but, it’s so deep in the weeds that I accidentally wrote this entire article while trying to do so.</p>
<p>So… buckle up, we’ve got a lot of context to give!</p>
<p>And also keep in mind everything about abi-cafe 2.0 is EXTREMELY work-in-progress, and I only just barely got it kinda working, so, there’s still a fair bit of work to do!</p>

<p>Ok so if the previous sections didn’t make it clear enough, I’ll just say it outright: <a href="https://faultlore.com/blah/c-isnt-a-language/">ABIs are fucking Fake</a>. Like, yes, they’re real. Lots of very important things rely on them. But they’re overwhelmingly unspecified and doomed to be “whatever the fuck some random compiler does”. People are constantly reverse-engineering them, often buggily. Other people get very mad you’re relying on them, often fruitlessly.</p>
<p>There are some specs, but they often don’t match the implementation, or are too vague to actually use. Also most importantly, the specs are often language-specific. This is fine and all for gcc and clang trying to interoperate, but Swift and Rust don’t have a type called “long long” and they somehow “do” C ABIs, so there’s absolutely Shenanigans happening even with well-regarded compilers.
Cross-language FFI is definitionally <em>all</em> type puns, because the two languages don’t even have the same type systems or semantics!</p>
<p>When you explain this situation to people, they often get really upset, and invariably suggest that there should be some sort of abstract DSL for specifying ABIs, so that all the compilers can share and interoperate and everything will be great.</p>
<p>Listen, if this is you: Do it. It sounds impossible but I would love to have it. ABIs are so complicated and so variable and the inputs and outputs sound hellish but anything would be better than what we have now.</p>
<p>So anyway I’m a coward and abi-cafe is specifically <em>not</em> that. It has absolutely no idea how any ABI is implemented. It believes in the Existence of ABIs, and knows how to make things that Might survive a crossing through the blind eternities of a function call, and it knows how to check that the trip was a success.</p>
<p>So if you do ever write that ABI DSL, abi-cafe will pair wonderfully with it as a way to test that a compiler that uses it continues to produce the same results (or better).</p>

<p>Earlier I mentioned that abi-cafe works by having both sides “report” the values they saw with callbacks. But what does that mean, and how do we determine that the values are “right”?</p>
<p>To investigate this question, we’re going to look at a bunch of examples of code/types we want to have interoperate between Rust and C(++), with little split code sections like this:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code>some_rust                 | some_c
some_more_rust            | some_more_c</code></pre></div>
<h2 id="the-base-case-primitives"><a href="#the-base-case-primitives">§</a>4.1 The Base Case: Primitives</h2>
<p>Primitives like integers and floats are the indivisible atoms of a language. Let’s start with a type pun so boring, many would balk at the suggestion that it even is one:</p>


<p>I think we can all agree that these have to work or nothing will. That said, there’s <a href="https://faultlore.com/blah/rust-layouts-and-abis/#the-anatomy-of-a-type">a ton of things to get right, as discussed in a previous article on ABIs</a>. Things can definitely go wrong here, as we saw with the whole <code>__int128</code> debacle!</p>
<p>Currently abi-cafe asks both languages to copy a primitive’s bytes into a buffer to prove they knows its value. If both sides agree, well, clearly the value was passed properly! This is a pretty good heuristic for the platforms and languages I care about, because finding a primitive’s location (and size) in memory is basically the only challenge.</p>
<p>So for instance, if we were interested in checking i32 interop we’d generate code like this, with Rust being the “caller” that produces the values and C being the “callee” that receives them. We then use some API for reporting values (sending their bytes to the test harness). For the purposes of the article, we’ll call that API <code>write_val</code>:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>fn </span>run_tests() {                  |  void test1(int32_t x, int32_t y) {
    <span>let </span>x: i32 = <span>0x0403_0201</span>;     |      write_val(<span>&amp;</span>x);
    write_val(<span>&amp;</span>x);                |      write_val(<span>&amp;</span>y);
                                  |  }
    <span>let </span>y: i32 = <span>0x1413_1211</span>;     |
    write_val(<span>&amp;</span>y);                |
                                  |
    test1(x, y);                  |
}                                 |</code></pre></div>
<p>If the harness sees both sides reported two values, and the bytes of each value are the same on both sides, then we’re pretty confident the two i32s were passed properly here! <a href="https://github.com/Gankra/abi-cafe/blob/aaa685a0ee09e438b294b48a33998d0ab95fb988/src/procgen.rs">Generate a lot more cases to stress all the weird corners or register allocation and alignment</a> and suddenly you’re pretty confident the two languages interoperate <em>completely</em>.</p>
<p>⚠️ Something subtle but important here is that we’re relying on both sides agreeing on the order to report the values in. We can guarantee this in abi-cafe because we’re generating both sides from an abstract definition. In fact the test harness can theoretically know exactly what the write_val results should be before even running the test (although this requires assuming/knowing ABI details and we want to avoid that). This will become a harder problem with more subtle implications as we go on.</p>
<h3 id="an-aside-picking-values-for-primitives"><a href="#an-aside-picking-values-for-primitives">§</a>4.1.1 An Aside: Picking Values For Primitives</h3>
<p>You may have noticed I picked kind of weird example values there: <code>0x0403_0201</code> and <code>0x1413_1211</code>. I call these “graffiti values” because each byte has been tagged with metadata of where it’s supposed to be. If we break up each value into its bytes, we get a nice little sequence:</p>

<div><pre><code>x = [<span>04</span>, <span>03</span>, <span>02</span>, <span>01</span>]
y = [<span>14</span>, <span>13</span>, <span>12</span>, <span>11</span>]</code></pre></div>
<p>The idea here is that the high nibble of the byte is tagged with the index of the value (x = 0, y = 1), and the low nibble is indexed with the tag of the byte. The are several benefits to this system!</p>
<p>First off, basically every byte is unique up to multiples of 16, so it’s hard to “get lucky” when there’s an ABI error, as opposed to if there was lots of 0x0000 or 0xFFFF. I initially was providing “distinct” values manually and I quickly determined that no we should just let the computer do that.</p>
<p>Second, when there <em>is</em> an error, it’s often relatively easy to see what went wrong. For instance, let’s say the test harness reports and error and shows us the following:</p>
<div><pre><code>gcc_calls_rustc mismatch on test1 arg1:

gcc:   [13, 12, 11, 10]
rustc: [11, 10, 24, 23]
</code></pre></div>
<p>The gcc value looks normal: all the high nibbles are equal, and they appear in the order your expect. The rustc value is definitely messed up though: we can see that half of its bytes are from arg1, but the other half are from arg2! Also we <em>didn’t</em> get an error on arg0. Together these facts point to rustc expecting the value to be more aligned (and therefore padded).</p>
<p>We don’t know which compiler is <em>right</em> here, but we know they <em>disagree</em>, and can now do the social work that is getting people to agree on the ABI (or just concede that gcc is the boss and change rustc to match).</p>
<h3 id="an-aside-primitive-semantic-checking"><a href="#an-aside-primitive-semantic-checking">§</a>4.1.2 An Aside: Primitive Semantic Checking</h3>
<p>The above implementation is <em>technically</em> missing an opportunity to check that the languages agree on the <em>semantics</em> of the values. Even if they find the same bytes they could theoretically diverge on things like signedness, endianess, twos complement, which values of bool are “true” vs “false”, and so on.</p>
<p>I haven’t implemented this and I’m not sure I ever will, but one way to approach this would be to introduce a challenge-response protocol to the process. For instance, if you have one side add a number to the value, and require the other side to subtract it back out, then you’re pretty confident they agree on at least endianess (and I’m sure you could come up with challenges for any other properties you care about):</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>fn </span>run_tests() {                    |  void test1(int32_t x, int32_t y) {
    <span>let </span><span>mut </span>x: i32 = <span>0x0403_0201</span>;   |      x -= <span>0x1234_5678</span>; 
    write_val(<span>&amp;</span>x);                  |      write_val(<span>&amp;</span>x);      
    x += <span>0x1234_5678</span>;               |
                                    |      y -= <span>0xABCD_EF12</span>;
    <span>let </span><span>mut </span>y: i32 = <span>0x1413_1211</span>;   |      write_val(<span>&amp;</span>y);
    write_val(<span>&amp;</span>y);                  |  }
    y += <span>0xABCD_EF12</span>;               |
                                    |
    test1(x, y);                    |
}                                   |</code></pre></div>
<h2 id="the-inductive-case-composite-types"><a href="#the-inductive-case-composite-types">§</a>4.2 The Inductive Case: Composite Types</h2>
<p>Structs like this require us to think a little bit harder about what it means for two languages to agree on values:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>#[repr(C)]                </span>|  <span>struct </span>Simple {
<span>struct </span>Simple {           |      uint8_t flags;
    flags: u8;            |      uint32_t val;
    val: u32;             |  };
}                         |</code></pre></div>
<p>We <em>can’t</em> just copy the bytes of the entire structs, because they’re liable to contain <em>padding</em> which is <em>allowed</em> to differ between the two sides of the boundary. The only parts we can and should care about are the primitive fields that form the “leaves” of a (potentially nested) composite type.</p>
<p>We already know how to analyze those, so the only thing we need to introduce here is an understanding of how to access each subfield, and a new kind of delimiter for “end of function argument” for easier bookkeeping and error reporting. So we add an <code>end_arg()</code> callback and generate this kind of code:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>fn </span>run_tests() {                  |  void test1(Simple x, Simple y) {
    <span>let </span>x = Simple {              |      write_val(<span>&amp;</span>x.flags); 
      flags: <span>true</span>,                |      write_val(<span>&amp;</span>x.val); 
      val: <span>0x1413_1211</span>,           |      end_arg();
    };                            | 
    write_val(<span>&amp;</span>x.flags);          |      write_val(<span>&amp;</span>y.flags); 
    write_val(<span>&amp;</span>x.val);            |      write_val(<span>&amp;</span>y.val); 
    end_arg();                    |      end_arg(); 
                                  |  }
    <span>let </span>y = Simple {              |
      flags: <span>false</span>,               |
      val: <span>0x3433_3231</span>,           |
    };                            |
    write_val(<span>&amp;</span>x.flags);          |
    write_val(<span>&amp;</span>x.flags);          |
    end_arg();                    |
                                  |
    test1(x, y);                  |
}                                 |</code></pre></div>
<p>⚠️ Once again we find ourselves relying on ordering, but once again this is fine because the test harness that generates the code gets to pick a “canonical” ordering, and both sides agree on the <em>number</em> of primitive fields to report. There are two ways of looking at what we’re doing: </p>
<ul>
<li>
<p>We’re essentially generating a fully inlined <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">implementation of <code>#[derive(Debug)]</code></a> for each function argument, and then checking that both sides produced the same printout. Just visiting every field, how hard could that be?</p>
</li>
<li>
<p>We’re generating an <a href="https://en.wikipedia.org/wiki/Tree_traversal">in-order tree traversal</a> of the primitives in a composite type.</p>
</li>
</ul>
<p>What tree am I talking about? Well, look at this:</p>

<div><pre><code>arg0: MyType {
    some_val: MyInnerType {
        count: u32,
        down: u64,
        engaged: bool,
    }
    some_other_vals: MyArray(
        [Vec3 {
            x: f32,
            y: f32,
        }; <span>2</span>]
    )
}</code></pre></div>
<p>That right there is a damn tree, as demonstrated through hasty paint diagrams:</p>
<p><img src="https://faultlore.com/blah/abi-puns/tree.png" alt="hasty diagram of how the fields form a tree"/></p>
<p>Consider this some <strong>Really Fucking Important</strong> Foreshadowing.</p>
<h2 id="tagged-unions-i-guess-alright"><a href="#tagged-unions-i-guess-alright">§</a>4.3 Tagged Unions: I Guess Alright?</h2>
<p>It’s time for me to bring up my favourite Rust RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">2195-really-tagged-unions</a>, wherein I let you put <code>repr(C)</code> and <code>repr(u8)</code> on Rust tagged unions to get a guaranteed C(++)-compatible layout. Here we show the more pleasant C++ layout:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>#[repr(u8)]               </span>|  <span>enum </span>class TaggedUnion_Tag: uint8_t {
<span>enum </span>TaggedUnion {        |      Val1, Val2, Val3, Empty1, Empty2
    Val1(u32),            |  };
    Val2(u32),            |
    Val3(u32, bool)       |  <span>union </span>TaggedUnion {  
    Empty1,               |      <span>struct </span>{
    Empty2,               |          TaggedUnion_Tag tag;
}                         |          uint32_t val0;
                          |      } Val1;
                          |      <span>struct </span>{
                          |          TaggedUnion_Tag tag;
                          |          uint32_t val0;
                          |      } Val2;
                          |      <span>struct </span>{
                          |          TaggedUnion_Tag tag;
                          |          uint32_t val0;
                          |          bool val1;
                          |      } Val3;
                          |      <span>struct </span>{
                          |          TaggedUnion_Tag tag;
                          |      } Empty1;
                          |      <span>struct </span>{
                          |          TaggedUnion_Tag tag;
                          |      } Empty2;
                          |  };</code></pre></div>
<p>This is absolutely a real thing, and cbindgen knows how to generate it, and <a href="https://searchfox.org/mozilla-central/source/__GENERATED__/gfx/webrender_bindings/webrender_ffi_generated.h#3365">FireFox uses it in production</a> (I don’t think I can stable-link that file’s contents, search for “union RasterSpace”).</p>
<p>This case poses a few problems.</p>
<p>The first problem is a totally artificial limitation of abi-cafe 1.0: because I opted for describing function signatures with <em>example values</em>, any type with cases that won’t show up in every value is fundamentally inexpressible. If I give the value <code>TaggedUnion::Val1(u32(100))</code>, that fundamentally fails to describe Val2 and Empty. This limitation is the crux of why abi-cafe 2.0 had to be basically a complete rewrite. I need a proper type system to describe the shape of a type independently from its values!</p>
<p>The second problem is that “selecting” a value is now a much more dramatic problem. Before the only decision worth making was what number to put in an integer. <em>Now</em> we need to pick which case is “interesting”, and that can change the number and types of fields to report. But that’s ok, because both sides will agree! You can totally <code>#[derive(Debug)]</code> on a Rust tagged union, so we know we can report the fields of each case properly with a bit of elbow grease.</p>
<p>The last problem is that “reporting” all the values is suddenly less well defined. Previously we hand-waived the matter of “semantics” and said that if both sides agree on the primitives, we’re all good. But here Val1 and Val2 are indistinguishable by that metric. Empty1 and Empty2 are even worse, with no values to report at all!</p>
<p>In this case we kind of get lucky, because the C-compatible layout forces the value of the tag to become defined as a u8, so we can introduce that as a “field” that needs to be reported whenever you report a tagged union’s values. If we were testing Rust’s own ABI we would have to make up a numbering system for the tags.</p>
<p>None of this is a dealbreaker, but it’s certainly a lot more annoying work. Probably we end up with something like:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>fn </span>run_tests() {
    <span>let </span>x = TaggedUnion::Val3(<span>16</span>, <span>true</span>);
    <span>match </span><span>&amp;</span>x {
        TaggedUnion::Val1(val0) =&gt; {
            write_val(<span>0u8</span>);
            write_val(val0);
        }
        TaggedUnion::Val2(val0) =&gt; {
            write_val(<span>1u8</span>);
            write_val(val0);
        }
        TaggedUnion::Val3(val0, val1) =&gt; {
            write_val(<span>2u8</span>);
            write_val(val0);
            write_val(val1);
        }
        TaggedUnion::Empty1 =&gt; {
            write_val(<span>3u8</span>);
        }
        TaggedUnion::Empty2 =&gt; {
            write_val(<span>4u8</span>);
        }
    }
    end_arg();

    test1(x);
}</code></pre></div>
<h2 id="untagged-unions-fuck-ok"><a href="#untagged-unions-fuck-ok">§</a>4.4 Untagged Unions: FUCK OK</h2>
<p>Hey we just did tagged unions so c-like untagged unions are probably the same and… well. They’re not! All of our foreshadowing has come to roost! Let’s review:</p>
<blockquote>
<p>We’re essentially generating a fully inlined <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">implementation of <code>#[derive(Debug)]</code></a> for each function argument.</p>
</blockquote>
<blockquote>
<p>You can totally <code>#[derive(Debug)]</code> on a Rust tagged union, so we know we can report the fields of each case properly with a bit of elbow grease.</p>
</blockquote>
<p>You know what you can’t <code>#[derive(Debug)]</code> on? A c-like untagged union. Just absolutely not, no way. There’s no way for the receiver of the value to know which case you should be in, and trying to report all the cases would generate random padding-like garbage.</p>
<p>But we’re not doomed! We can cheat with more foreshadowing!</p>
<blockquote>
<p>In fact the test harness can theoretically know exactly what the write_val results should be before even running the test (although this requires assuming/knowing ABI details and we want to avoid that). This will become a harder problem with more subtle implications as we go on.</p>
</blockquote>
<p>The subtle implications, they are here! We don’t <em>need</em> to generate proper match statements for untagged unions, because the test harness generating the code already <em>knows</em> which case every single value is. So for tagged unions, instead of actually generating a full match it <em>could</em> generate this:</p>

<div><pre><code><span>let </span>TaggedUnion::Val1(val0) = <span>&amp;</span>arg0 <span>else </span>{
    <span>panic!</span>(<span>&#34;arg0 was supposed to be Val1, but wasn&#39;t!&#34;</span>);
}
write_val(<span>0u8</span>);
write_val(val0);</code></pre></div>
<p>Which for an untagged union becomes this even simpler expression:</p>


<p>Ok so we’re still trucking, but now we definitely need a central system that knows the values of everything, and can’t just pick them on the fly when generating the caller. How to express this in code is a bit brain-melty, but we can appeal to our last bit of foreshadowing:</p>
<blockquote>
<p>We’re generating an <a href="https://en.wikipedia.org/wiki/Tree_traversal">in-order tree traversal</a> of the primitives in a composite.</p>
</blockquote>
<p>We’re <em>still</em> doing this but at some of the nodes we have to pick only one of the branches to take (the enum variant to select). There’s lots of ways to encode tree-traversals, like numbering the branches of each node, and creating a sequence of the branches to follow. I’m sure we can figure something out.</p>
<h2 id="real-puns-real-pain"><a href="#real-puns-real-pain">§</a>4.5 REAL PUNS: REAL PAIN</h2>
<p>Now to really fuck my whole life up with overly ambitious ideas. It’s time for foreshadowing part two: fuck your life for real!</p>
<blockquote>
<p><em>Now</em> we need to pick which case is “interesting”, and that can change the number and types of fields to report. But that’s ok, because both sides will agree!</p>
</blockquote>
<blockquote>
<p>There’s lots of ways to encode tree-traversals, like numbering the branches of each node, and creating a sequence of the branches to follow. I’m sure we can figure something out.</p>
</blockquote>
<p><strong>WHAT IF THE TWO LANGUAGES DIDN’T AGREE ON THE NUMBER AND STRUCTURE OF THE FIELDS?</strong></p>
<p>Let’s start off really simple, and work our way up to the real warcrimes.</p>
<h3 id="transparent-primitives-ok"><a href="#transparent-primitives-ok">§</a>4.5.1 Transparent Primitives: Ok!</h3>
<p>A cute little feature of Rust is <code>repr(transparent)</code>, which lets you wrap primitive types in a new type so you can get stronger type checking on “these are the array indices for this specific kind of data structure” or “these are meters”, but <em>critically</em> you can keep them 100% abi-compatible with a bare primitive:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>#[repr(transparent)]      </span>|  #define Meters uint32_t
<span>struct </span>Meters(u32);       |  </code></pre></div>
<p>For example, 32-bit x86 Linux has a C ABI where a primitive and a struct wrapping a primitive get passed differently, so this attribute is significant, and we definitely want to test that it works right!</p>
<p>But suddenly we have introduced a non-trivial divergence in the structure of our types. In Rust there is an extra layer of composite to peel away, while in C the primitive is right there.</p>
<p>In our nice naive world of “just report the primitives in order” this is actually totally fine, we don’t <em>care</em> about how many composites are in the way. But…</p>
<blockquote>
<p>There’s lots of ways to encode tree-traversals, like numbering the branches of each node, and creating a sequence of the branches to follow. I’m sure we can figure something out.</p>
</blockquote>
<p>This is now a bit harder to think about, eh? One of the trees has an extra node in it. Thankfully it has to be a node with one child, so you can imagine a few ways to handle this automatically, but the cracks are really starting to form!</p>
<h3 id="option-optimization-uhhh"><a href="#option-optimization-uhhh">§</a>4.5.2 Option Optimization: Uhhh</h3>
<p>Here’s another fan favourite: the guaranteed Optional reference optimization in Rust:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>enum </span><span>Option</span>&lt;T&gt; {          |  uint64_t* 
    <span>Some</span>(T)               |
    <span>None</span>,                 |
}                         |
                          |
<span>Option</span>::&lt;<span>&amp;</span>u64&gt;            |</code></pre></div>
<p>Not only is <code>Option&lt;&amp;T&gt;</code> guaranteed to be the same size and layout as a pointer, but it’s even guaranteed that <code>None</code> will be <code>null</code>, and that it will be ABI compatible with C pointers.
Also note: this enum doesn’t have a <code>repr</code> annotation on it, this is a for reals native Rust enum layout. </p>
<p>In the <code>Some</code> case things are easy enough, but in the <code>None</code> case… what are we supposed to do? I’m not sure how to handle this other than absolutely special-casing the fuck out of it! Alas!</p>
<h3 id="crimes-crimes-crimes"><a href="#crimes-crimes-crimes">§</a>4.5.3 CRIMES CRIMES CRIMES</h3>
<p>Look I know I just finished explaining <code>repr(transparent)</code> and <em>also</em> how <code>__int128</code> is a nightmare <em>buuuut</em> maybe you think you can get away with this hot garbage:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>#[repr(C)]     
</span><span>struct </span>SyntheticU128 {    |  __uint128
    high: u64,            |
    low: u64,             |  
}                         |</code></pre></div>
<p>Sure would be nice to be able to test on which platforms and in which situations that kind of thing would work, but oh god now the “trees” we want consistent traversals for are becoming an absolute mess.</p>
<p>Hey you know what, why not fuck me up with this:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>#[repr(C)]                </span>|  <span>struct </span>AltPair {
<span>struct </span>Pair {             |      uint32_t y;
    x: u32,               |      uint32_t z;
    y: u32,               |  };
}                         |
                          |  <span>struct </span>AltTriple {
<span>#[repr(C)]                </span>|      uint32_t x;
<span>struct </span>Triple {           |      AltPair pair;
    pair: Pair,           |  };
    z: u32,               |
}                         |</code></pre></div>
<p>Or this:</p>

<div><p><a href="#" title="This example is not tested">ⓘ</a></p><pre><code><span>struct </span>Vec3 {             |  <span>struct </span>Vec3 {
    x: f32,               |      float vals[<span>3</span>]; 
    y: f32,               |  };
    z: f32,               |
}                         |</code></pre></div>
<p>I wanna be able to test all these!!!</p>
<p>Trying to build a system that can properly synchronize all these different type puns into a single coherent “traversal” where the values can be properly compares is the big “TODO” that got me to write this article.</p>
<p>There is a certain <em>intuition</em> to how you can synchronize the trees properly, and boy howdy this article was supposed to elucidate that intuition, but it’s so long and I’ve absolutely fried my brain writing this much, so I think I’m gonna just mention where I’m at and wrap it up for now.</p>

<p>Ok so abi-cafe 1.0 fell over by the time we got to tagged unions, because we needed a way to talk about the structure of types in a way that single values couldn’t. The code for ABI backends (generating Rust and C code) for the definitions was also already an unmaintainable mess, so I wanted to have more of an agnostic framework that handles a lot of the details, so that the backends could focus on just the specifics of their languages.</p>
<p>This is a type system and a compiler. I’m describing a normal compiler. I fear and loathe normal compilers, even though I keep making and working on them.</p>
<p>One of the biggest hurdles for me was good parsing and error handling. We all know the old gag: you take a compilers course in university, and they spend 90% of the course talking about LR(1) grammars and then frantically at the end go “uhh oh and you should make the compiler actually do things”. Except also everything they teach you about parsers is bad and wrong too.</p>
<p>Then I got shown <a href="https://kdl.dev/">KDL</a>, whose canonical implementation is written in Rust and which looks <em>a lot</em> like Rust code:</p>
<div><pre><code>package {
  name &#34;my-pkg&#34;
  version &#34;1.2.3&#34;

  dependencies {
    // Nodes can have standalone values as well as
    // key/value pairs.
    lodash &#34;^3.2.1&#34; optional=true alias=&#34;underscore&#34;
  }

  numbers {
    x 123
    y 456
  }
}
</code></pre></div>
<p><a href="https://github.com/Gankra/kdl-script">Wouldn’t it be funny if I made a programming language where every program was a valid KDL document</a>? And thus kdl-script was born!</p>
<div><pre><code>@derive &#34;Display&#34;
struct &#34;Point&#34; {
    x &#34;f64&#34;
    y &#34;f64&#34;
}

fn &#34;main&#34; {
    outputs { _ &#34;f64&#34;; }

    let &#34;pt1&#34; &#34;Point&#34; {
        x 1.0
        y 2.0
    }
    let &#34;pt2&#34; &#34;Point&#34; {
        x 10.0
        y 20.0
    }
    
    let &#34;sum&#34; &#34;add:&#34; &#34;pt1&#34; &#34;pt2&#34;
    print &#34;sum&#34;

    return &#34;+:&#34; &#34;sum.x&#34; &#34;sum.y&#34;
}

fn &#34;add&#34; {
    inputs { a &#34;Point&#34;; b &#34;Point&#34;; }
    outputs { _ &#34;Point&#34;; }

    return &#34;Point&#34; {
        x &#34;+:&#34; &#34;a.x&#34; &#34;b.x&#34;
        y &#34;+:&#34; &#34;a.y&#34; &#34;b.y&#34;
    }
}
</code></pre></div>
<p>Well, ok that’s the shitpost version with actual function bodies. kdl-script for its true purpose ends up looking more like this:</p>
<div><pre><code>// Types
struct &#34;Simple&#34; {
    a &#34;i32&#34;
}

alias &#34;Simple2&#34; &#34;Simple&#34;

struct &#34;Complex&#34; {
    elems &#34;[Simple;10]&#34;
    val &#34;Simple2&#34;
    opaque &#34;ptr&#34;
    flag &#34;bool&#34;
}


enum &#34;ErrorCode&#34; {
    Ok 0
    FileNotFound 1
    Bad -3
}

tagged &#34;MyResult&#34; {
    Ok { _ &#34;[u32;3]&#34;; }
    Err { _ &#34;ErrorCode&#34;; }
}

tagged &#34;MyDeepResult&#34; {
    Ok { _ &#34;MyResult&#34;; }
    FileNotFound { x &#34;bool&#34;; y &#34;Simple&#34;; }
}


// Function signatures we want to test

fn &#34;func1&#34; {
    inputs { a &#34;Complex&#34;; b &#34;Simple&#34;; }
    outputs { out &#34;i32&#34;; }
}

fn &#34;enumtime&#34; {
    inputs {
        a &#34;&amp;MyResult&#34;
        b &#34;MyDeepResult&#34;
        c &#34;[&amp;ErrorCode;4]&#34;
    }
}
</code></pre></div>
<p>It’s all signatures, no bodies. Because at the end of the day, generating the bodies is the problem of abi-cafe’s ABI backends. And I’m happy to report, the kdl-script compiler works, and I’ve got  the rust backend fully implemented! </p>
<p>…except for maybe some overzealous outparam support that I don’t really care about anymore. Oh and the whole “complex type pun tree traversal” thing this whole article is all about.</p>
<p>Oh right I haven’t even shown the feature of kdl-script that makes complex puns a possibility: <a href="https://github.com/Gankra/kdl-script/blob/main/README.md#pun-types">pun types</a>!</p>
<div><pre><code>pun &#34;MetersU32&#34; {
    lang &#34;rust&#34; {        
        @ &#34;#[repr(transparent)]&#34;
        struct &#34;MetersU32&#34; {
            a &#34;u32&#34;
        }
    }

    lang &#34;c&#34; &#34;cpp&#34; {
        alias &#34;MetersU32&#34; &#34;u32&#34;
    }
}
</code></pre></div>
<p>kdl-script has a first-class notion of basically “a type wrapped in an ifdef switch statement”. This allows us to declare a single function signature, but make different languages/compilers interpret in different ways.</p>
<p>I fucking love it, but it’s an absolute nightmare to think about because IT MAKES THE TREES DIFFERENT SHAPES.</p>
<p>BUT I SWEAR, YOU CAN MAKE IT MAKE SENSE.</p>
<p>TRUST ME.</p>
<p>OK I NEED. TO GO. TO BED. I HAVE BEEN WRITING THIS ALL DAY. HAVE A GOOD NIGHT.</p>

    </article></div>
  </body>
</html>
