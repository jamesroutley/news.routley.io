<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.daveliepmann.com/articles/idiomatic-clojure-errors.html">Original</a>
    <h1>Idiomatic Errors in Clojure</h1>
    
    <div id="readability-page-1" class="page"><article><p><a href="https://www.daveliepmann.com/articles">&lt; Writings</a></p>

<section>
  <h2>Throw an Exception</h2>  
  <p>It’s idiomatic Clojure to handle an error by throwing a native exception. After all, Clojure is hosted by nature.</p>
  <p><code><pre>(when-not (blah blah)
  (throw (IllegalArgumentException. &#34;foo can’t baz&#34;)))</pre></code></p>
  <p>or</p>  
  <p><code><pre>(throw (js/Error. &#34;Oops!&#34;))</pre></code></p>
  <p>Let’s not overcomplicate this. Interop is idiomatic.</p></section>


<section>  
  <h2>Throw <code>ex-info</code></h2>
  <p>Except…native exception classes aren’t always a joy to work with. Selecting the right one is a hassle. They complicate cross-platform code. Worst of all, they can’t carry data! So throw an <code>ex-info</code> instead, and shove whatever keyvals you need in it.</p>
  <p><code><pre>(throw (ex-info &#34;Foo is borked&#34; (select-keys foo […])))</pre></code></p>
  <p>Use the <a href="https://github.com/clojure/clojure/commit/1f11ca3ef9cd0585abfbe4a9e7609be8b255123f">data-conveying</a> tools native to Clojure and move on.</p></section>


<section>
  <h2>Return an error map</h2>
  <p>Sometimes throwing an exception doesn’t feel right. Maybe it feels too much like a <code>GOTO</code>, maybe you want to explicitly keep the control flow local. So return an error map, like:</p>
  <p><code><pre>{:ok false :foo …}</pre></code></p>
  <p>or</p>
  <p><code><pre>{:failure :fail.baz/missing-foo, :bar :baz, …}</pre></code></p>
  <p>Lightweight tricks like this are idiomatic in a dynamic lisp.</p>  
  <p>You’ll want some utilities on hand to take advantage of this approach. For instance, imagine <code>some-&gt;</code> threading, but bailing from the happy path not on <code>nil</code> but when a map contains a <code>:failure</code> key. To handle the result, you’ll want an <code>if-let</code> analogue. These aren’t difficult for an intermediate Clojurian to write from scratch, and preferences vary on implementation details like naming. A lightweight version fits in a <a href="https://gist.github.com/daveliepmann/fc2d9f93d51e6bdba0e7e28b1a2a6b26">gist</a>; for a more involved approach see <a href="https://github.com/Reefersleep/thread-until">thread-until</a>.</p>
  <p>When is this useful? I preferred it when building a pipeline to process a large number of items at a time. It didn’t make sense, if #22,051 in a sequence of 30,000 items failed, to pull the emergency brake and stop the whole train. An error map felt right because, being data, it could be passed around until I was ready to handle it. It was a small, convenient step up from returning <code>nil</code>.</p>
  <p>Sean Corfield <a href="https://clojurians.slack.com/archives/C053AK3F9/p1709274483420439?thread_ts=1709273639.901569&amp;cid=C053AK3F9">described</a> how he uses this technique:</p>
  <blockquote><ul>
      <li>if something is <strong>unexpected</strong> and the immediate code cannot handle it, throw an exception</li>
      <li>if something is <strong>expected</strong> then return either <code>nil</code> or some <code>{:ok false :message &#34;...&#34;}</code> value (and <code>{:ok true :value ...}</code> for success)</li></ul></blockquote>
  <p>We can do this because Clojure isn’t bound by Java’s type system straitjacket. As Doug Crockford <a href="https://www.crockford.com/image/howjsworks.pdf">pointed out</a>:</p>
  <blockquote>The Java language encourages misuse of exceptions as a way to get around problems in its type system. A Java method can only return a single type of result, so exceptions are used as an alternate channel to return the ordinary results that the type system does not allow.</blockquote>
  <p>(A similar point is made in this <a href="https://archive.clojure.org/design-wiki/display/design/Error%2BHandling.html">archived Clojure design document</a>.)</p></section>


<section>
  <h2>Structure your <code>ex-info</code>s</h2>
  <p>Maybe those anything-goes <code>ex-info</code> and error maps make you feel groundless. Those who crave an ontological bedrock are free to impose order with something like Cognitect’s <a href="https://github.com/cognitect-labs/anomalies">anomalies</a> lib. It categorizes failures with an <code>::anom/category</code> key holding a value like <code>::anom/not-found</code>. Its implementation is like a ghost — a great example of how little engineering it takes to make your own.</p>
  <p>Self-imposed standardization is a good idea when using a dynamic language, and quite idiomatic.</p>


  <section>
    <h2>Flowing errors</h2>
    <p>Some developers crave something like error maps but more concrete. Particulars vary but the goal is usually to rearrange control flow to show the happy path while smoothly handling errors.</p>
    <p>We have Ivan Grishaev’s <a href="https://github.com/igrishaev/pact">pact</a>, fmnoise’s monad-rejecting <a href="https://github.com/fmnoise/flow">flow</a>, Adam Bard’s monad-embracing <a href="https://github.com/adambard/failjure">failjure</a>, Druids’ railway-oriented (and secretly-monadic) <a href="https://github.com/druids/rop">rop</a>, lazy-cat’s pair-centric <a href="https://github.com/lazy-cat-io/tenet">tenet</a>, Shantanu Kumar’s casually-monadic <a href="https://github.com/kumarshantanu/promenade">promenade</a>…there is no shortage of implementations.</p>

    <p>I find it helps to visualize these libs populating a spectrum of “Either Monad-ness”. Boring old error maps (or even <code>nil</code>) would be on one far end.</p>
    
    <p>Maybe you’re drawn to one of these, maybe they don’t make sense for what you’re working on. Regardless, I’m glad Clojure makes it easy to grow your own custom error handling, and that the community shares so many of theirs. DIY is idiomatic.</p></section>


  <section><h2>Ceci n&#39;est pas une Error</h2>
    <p>There’s a footgun to avoid when catching and throwing errors in JVM Clojure.</p>
    <p>Java distinguishes between two <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Throwable.html">Throwable</a> kinds: <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Exception.html">Exceptions</a> which are intended to be caught, and <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Error.html">Errors</a>, which indicate ”serious problems that a reasonable application should not try to catch“. Few recommendations are disrespected more often in Clojureland. The Clojure idiom here is muddy.</p>
    
    <p>It’s common to see <code>(catch Throwable)</code> sprinkled liberally across a Clojure codebase. Doing so is generally harmless but occasionally makes failures unnecessarily more difficult to debug and recover from (for <a href="https://github.com/taoensso/carmine/issues/301">example</a>).</p>

    <p>Catching <code>Throwable</code> is hard to untangle from casual misuse of <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/AssertionError.html">AssertionError</a>, which is thrown by <code>assert</code> and <code>:pre</code>/<code>:post</code> conditions. Many Clojurians use these tools as if they threw <code>IllegalArgumentException</code>. Just as with catching <code>Throwable</code>, this doesn’t often present an immediate problem. Trouble arises in the mismatch between its <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html">intended use case</a>, “an informal design-by-contract style of programming”, and the off-label use so often seen in Clojure.</p>
    
    <p>Alex Miller summarized the issue on <a href="https://clojurians.slack.com/archives/C03S1KBA2/p1646924206922289">Clojurians Slack</a>:</p>
    <blockquote><p>Assertions are designed so that they can be turned off in production to remove the cost of the assertion. They are designed to catch logically impossible situations that can only occur if the program is wrong. They should not be used to detect invalid input (like a bad web request, bad user input, etc). You can use them in production, but the AssertionErrors are, by definition, not designed to be caught.</p></blockquote>

    <p>The root of the issue is that programmers reasonably want some way to assert (in the colloquial sense of the word) properties of values, and it’s reasonable to sometimes recover from those failed assertions. That makes it a natural use case for Exceptions, not Errors. One can sidestep some of this confusion by writing a trivial Exception-throwing alternative to <code>assert</code>.</p>
    <p>Doing the same for pre- and post-conditions involves a bit more effort. Because Clojure doesn’t automatically enforce constraints (whether types or something more expressive) on function arguments the way Java does, those who want to guard against sloppy callers must do so explicitly. Two popular solutions are clojure.spec and Metosin’s malli.</p>
    <p>Unfortunately, regardless of how you solve it in your own code, disciplined throwing and catching of <code>Error</code> is hard to enforce on your dependencies.</p></section>
  </section>


<section>
  <h2>Closing thoughts</h2>
  <p>The idiomatic Clojure approach to error-handling is that there isn’t one. There’s a whole bunch.</p>
  <p>Native exceptions, <code>ex-info</code>, ad-hoc keys, carefully prescribed keys, error maps, chaining Either values – all of these are good idiomatic Clojure. Each is useful in a particular context. They can even coexist in the same project. But – and this is important – there’s no escaping the choice. Sartre was right, we are condemned to be free. Like a good lisp, Clojure leaves it up to you.</p></section>


<p>— <em>Dave Liepmann</em>, 05 November 2024</p></article></div>
  </body>
</html>
