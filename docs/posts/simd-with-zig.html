<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/SIMD-With-Zig/">Original</a>
    <h1>SIMD with Zig</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>To find the index of the first instance of a character within a body of [ASCII] text, you might write something like:</p>

<pre><code><span>fn</span> <span>indexOf</span><span>(</span>haystack<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span> needle<span>:</span> <span><span>u8</span></span><span>)</span> <span><span>?</span><span>usize</span></span> <span>{</span></code></pre>

<p>Or use the <code>std.mem.indexOfScalar</code> function from the standard library, which is essentially the same implementation. This implementation loops through the input and checks each character, one by one, to see if it&#39;s equal to our target.</p>

<p>With SIMD, we can leverage CPU instructions to check multiple characters of our input in parallel. Let&#39;s do that in Zig.</p>

<p>To keep this simple for now, let&#39;s pretend that our input is always exactly 8 characters long (we&#39;ll look at dynamic input lengths after, but 8 characters means we can illustrate the full content of our vectors).</p>

<p>As an example, say we have &#34;Hello Jo&#34; and we want the first index of &#34;o&#34; (which is 4). Our first step is to create a vector (think of it as an array) of 8 elements, each containing the value &#34;o&#34;:</p>

<pre><code><span>const</span> vector_len <span>=</span> <span>8</span><span>;</span></code></pre>

<p>Our <code>@as</code> cast is a very Zig-specicific thing. <code>&#39;o&#39;</code> on its own is a <code>comptime_int</code>. If we try to use that, we&#39;ll get an error message: <em>expected integer, float, bool, or pointer for the vector element type</em>. So we coerce the type to a <code>u8</code>. The more important part of the above code is the <code>@splat</code> builtin, which creates a vector of length <code>vector_len</code> with each element containing the specified value. If we were to print <code>vector_needles</code>, we&#39;d see &#39;o&#39; eight times (the ASCII value of &#39;o&#39; is 111):</p>

<pre><code>{ 111, 111, 111, 111, 111, 111, 111, 111 }</code></pre>

<p>The next step is to take our input and also convert that into a vector. Because we&#39;ve said that, for the time being, our input will be limited to 8 characters, this is easy:</p>

<pre><code><span>const</span> haystack <span>=</span> <span>&#34;Hello Jo&#34;</span><span>;</span></code></pre>

<p>The <code>@Vector</code> builtin returns a type, and because our <code>haystack</code> is 8 characters long, the same as our <code>vector_len</code> we can store our full haystack into this new vector. If we were to print <code>vector_haystack</code>, we&#39;d get:</p>

<pre><code>{ 72, 101, 108, 108, 111, 32, 74, 111 }</code></pre>

<p>We now have two vectors, each containing eight u8 (byte) values. Our first SIMD operation will be to compare the two using the equality operator (<code>==</code>):</p>

<pre><code><span>const</span> matches <span>=</span> vector_haystack <span>==</span> vector_needles<span>;</span></code></pre>

<p>This line of code is powerful largely because it&#39;s simple. Vectors can be subjected to any arithmetic or bitwise operations.</p>

<p>This results in a new vector of type <code>@Vector(vector_len, bool)</code>, and its content will be:</p>

<pre><code>{ false, false, false, false, true, false, false, true }</code></pre>

<p>If you look at this closely, you&#39;ll note that we&#39;re getting close to our answer. The first <code>true</code> occurs at index 4, which is the correct answer. We&#39;ve compared our haystack with our needle and gotten the result for each index in parallel. But we still need to extract the index from the above. We could loop through <code>matches</code>, but then we&#39;d be back at iterating and comparing one value at a time.</p>

<p>A quick solution to the above problem is to use <code>std.simd.firstTrue</code>, which will give us <code>4</code>:</p>

<pre><code><span>const</span> vector_len <span>=</span> <span>8</span><span>;</span></code></pre>

<p>But how does <code>firstTrue</code> work? Let&#39;s build our own simple implementation:</p>

<p>The first thing that we&#39;ll do is check if we have <strong>any</strong> matches. This is possibly a step that we can avoid, but it&#39;ll help us get the ball rolling:</p>

<pre><code><span>if</span> <span>(</span><span>!</span><span>@reduce</span><span>(</span><span>.</span>Or<span>,</span> matches<span>)</span><span>)</span> <span>{</span></code></pre>

<p>The <code>@reduce</code> builtin  takes a vector, applies the operation, and returns a scalar (a single value). Here we&#39;re applying the <code>std.builtin.ReduceOp.Or</code> operation on our matches. If any of the values are <code>true</code>, this will return <code>true</code>. If all values are <code>false</code>, this will return <code>false</code>. Other possible operations are: <code>.And</code>, <code>.Or</code>, <code>.Xor</code>, <code>.Min</code>, <code>.Max</code>, <code>.Add</code> and <code>.Mul</code> (some operations are only available for some types of vectors, for example <code>.Add</code> doesn&#39;t make sense for a vector of booleans).</p>

<p>If we get past this check, we know that we have at least 1 match (i.e. a <code>true</code>) in our vector. How do we get its index? Admittedly, it&#39;s a bit more complicated than you might think. We&#39;ll need to use the <code>@select</code> builtin. <code>@select</code> is a bit like a parallel if statement, but if we were to write it using normal code, it might look like:</p>

<pre><code><span>fn</span> <span>select</span><span>(</span><span>comptime</span> T<span>:</span> <span><span>type</span></span><span>,</span> pred<span>:</span> <span><span>[</span><span>8</span><span>]</span><span>bool</span></span><span>,</span> a<span>:</span> <span><span>[</span><span>8</span><span>]</span>T</span><span>,</span> b<span>:</span> <span><span>[</span><span>8</span><span>]</span>T</span><span>)</span> <span><span>[</span><span>8</span><span>]</span>T</span> <span>{</span></code></pre>

<p>It always takes a vector of booleans, and based on the true/false values within this vector, it will select values from either input source <code>a</code> (when <code>true</code>) or input source <code>b</code> (when <code>false</code>).</p>

<p>How does <code>@select</code> help us? First we&#39;ll create two new vectors. These will act as our input source <code>a</code> and input source <code>b</code>. The first is a vector that contains the index of each index. Huh? Let&#39;s let the code explain:</p>

<pre><code><span>const</span> indexes <span>=</span> std<span>.</span>simd<span>.</span><span>iota</span><span>(</span><span>u8</span><span>,</span> vector_len<span>)</span><span>;</span></code></pre>

<p>If we print it out, we get:</p>

<pre><code>{ 0, 1, 2, 3, 4, 5, 6, 7 }</code></pre>

<p>It&#39;s ok if it isn&#39;t immediately obvious how that helps. Our next vector will be even weirder:</p>

<pre><code><span>const</span> nulls <span>=</span> <span>@splat</span><span>(</span>vector_len<span>,</span> <span>@as</span><span>(</span><span>u8</span><span>,</span> <span>255</span><span>)</span><span>)</span><span>;</span></code></pre>

<p>We&#39;ve seen <code>@splat</code> already, so we know the output to this is:</p>

<pre><code>{ 255, 255, 255, 255, 255, 255, 255, 255 }</code></pre>

<p> We now have 3 vectors, and we know a little bit about <code>@select</code>. Let&#39;s look at those 3 vectors side by side, and see if any pattern emerges:</p>

<pre><code>{ false, false, false, false, true, false, false, true }</code></pre>

<p>I still don&#39;t really see any pattern here. But what if pass this into <code>@select</code>:</p>

<pre><code><span>const</span> result <span>=</span> <span>@select</span><span>(</span><span>u8</span><span>,</span> matches<span>,</span> indexes<span>,</span> nulls<span>)</span><span>;</span></code></pre>

<p>This results in:</p>

<pre><code>{ 255, 255, 255, 255, 4, 255, 255, 7 }</code></pre>

<p>We&#39;ll revisit <code>@select</code> in a second, but I see something I want to keep exploring: the smallest value in this vector is what we&#39;re after. We want to extract the <code>4</code> and we already know that <code>@reduce</code> is our tool for turning a vector into a scalar. We also briefly mentioned that one of the operations is <code>.Min</code>. Putting that together, we end up with:</p>

<pre><code><span>const</span> index <span>=</span> <span>@reduce</span><span>(</span><span>.</span>Min<span>,</span> result<span>)</span><span>;</span></code></pre>

<p>Which returns <code>4</code>, our final and correct answer.</p>

<p>There&#39;s a few things we still want to explore, but first let&#39;s go back and look at <code>@select</code>. We had a vector of booleans and we wanted to get the first index which was <code>true</code>. The first thing we did was create another vector that just contains the indexes. On its own, that didn&#39;t help. What we needed was a vector with indexes when our match was true, and some invalid value when our match was false. Only this way could we use <code>@reduce</code> (as it would, &#34;ignore&#34; invalid values from non-matches). For our invalid value, we used <code>255</code>. We couldn&#39;t use <code>null</code> (vectors operate on numbers and booleans only) and we couldn&#39;t use a negative number since we relied on the <code>.Min</code> operator to extract our first (valid) index. Since we&#39;re limiting ourselves to a <code>vector_len</code> of 8, we could have used any value &gt; 8. If our vector was larger, say, 512, we could simply use 513 or any other larger value (we&#39;d have to change the type of our nulls vector from u8 to u16 or something, but it would all still work fine).</p>

<p><code>@select</code> gave us a vector that we could <code>@reduce</code> to get our desired result. But it wasn&#39;t immediately obvious, to me at least, how to get there. When I think about &#34;finding the index of the first true&#34;, I think about iterating one value at a time and discarding any non-matches. This isn&#39;t a suitable mindset when working with vectors. We couldn&#39;t discard individual elements - we had to transform them in a way that would let us use a reduce operation.</p>

<h3>Vector Length</h3>
<p>There are two details we need to figure out. The first is: what happens when our input isn&#39;t the same size as our vector length? This is easy to solve: we process the input one <code>vector_len</code> at a time.</p>

<pre><code><span>fn</span> <span>firstIndexOf</span><span>(</span>haystack<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span> needle<span>:</span> <span><span>u8</span></span><span>)</span> <span><span>?</span><span>usize</span></span> <span>{</span></code></pre>

<p>Every iteration of the loop examines <code>vector_len</code> characters at a time. If there&#39;s no match within one iteration, we move to the next <code>vector_len</code>. It&#39;s possible that our input is less than <code>vector_len</code>, either originally, or eventually as we iterate through it. When this happens, we fallback to using the standard linearly search.</p>

<p>The second question we must answer is: what vector length should we use? So far, we&#39;ve been using <code>8</code>, but would larger vectors run faster? One option is to use <code>std.simd.suggestVectorSize</code> which returns a <code>?usize</code>. This function attempts to return the maximum supported vector length of the system, or null if SIMD operations aren&#39;t supported. But using the largest possible vector length won&#39;t <em>always</em> be ideal. You need to consider your input length. Using a vector length of 512 with inputs that are small (say 128-2048) will result in the fallback to <code>std.mem.indexOfScalar</code> being executed often. One solution to this problem is to use different vector lengths based on the input length. On the flip side, if you&#39;re dealing with large inputs (megabytes and beyond), a large vector size would be ideal as you&#39;ll spend comparatively little time dealing with small parts of the input.</p>

<h3>Conclusion</h3>
<p>SIMD requires a different way to think about variables and how they are processed. It&#39;s also an optimization technique that&#39;s up to the developer; there&#39;s no compiler or runtime help. You need to benchmark, test and tweak in order to figure out what works best. Benchmarking is particularly important because, unless you&#39;re dealing with large data or very hot code, there&#39;s a good chance that effort won&#39;t yield measurable benefits.</p>

<p>Having said that, Zig exposes a pretty concise API: a few builtins (<code>@splat</code>, <code>@select</code>, <code>@Vector</code> and <code>@reduce</code>) along with functions in <code>std.simd</code>. Once you understand these functions and how they can work together, experimentation is straightforward.</p>
</article></div>
  </body>
</html>
