<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://angg.twu.net/miniforth-article.html">Original</a>
    <h1>Bootstrapping a Forth in 40 lines of Lua code</h1>
    
    <div id="readability-page-1" class="page">
<h3>Bootstrapping a Forth in 40 lines of Lua code</h3>

<small>
<blockquote>


<p>Author: Eduardo Ochs
    
</p>

    

<p><strong>Abstract:</strong> The core of a conventional Forth system is
    composed of two main programs: an <i>outer interpreter</i>, that
    interprets textual scripts, and an <i>inner interpreter</i>, that
    runs bytecodes; the outer interpreter switches between an “immediate mode”, where words as executed as soon as they are read,
    and a “compile mode”, where the words being read are assembled
    into bytecodes to define new words.</p>

    

<p>In Forth all variables are accessible from all parts of the
    system. Several important words use that to affect the parsing:
    they read parts of the input text themselves, process that
    somehow, and advance the input pointer - and with that they
    effectively implement other languages, with arbitrary syntax, on
    top of the basic language of the outer interpreter.</p>

    

<p>Due mostly to cultural reasons, Forths tend to be built
    starting from very low-level pieces: first the inner interpreter,
    in Assembly or C, then the basic libraries and the outer
    interpreter, in Forth bytecodes, or - rarely - in C. We take
    another approach. If we consider that Lua is more accessible to us
    than C or Assembly - and thus for us Lua is “more basic” - then
    it is more natural to start from the outer interpreter, and the
    dictionary only has to have the definition for one word, one that
    means “interpret everything that follows, up to a given
    delimiter, as Lua code, and execute that”. An outer interpreter
    like that fits in less than 40 lines of Lua code, and it can be
    used to bootstrap a whole Forth-like language.</p>

    
</blockquote>
</small>


<strong>Quick index:</strong>
<ul>
<li><a name=".forth-via-examples"></a><a href="#forth-via-examples">1. Forth via examples</a>
</li><li><a name=".bootstrapping"></a><a href="#bootstrapping">2. Bootstrapping miniforth</a>
</li><li><a name=".modes"></a><a href="#modes">3. Modes</a>
</li><li><a name=".virtual-modes"></a><a href="#virtual-modes">4. Virtual Modes</a>
</li><li><a name=".polynomials"></a><a href="#polynomials">5. A Bytecode for Polynomials</a>
</li><li><a name=".propositional-calculus"></a><a href="#propositional-calculus">6. A Bytecode Language for Propositional Calculus</a>
</li><li><a name=".metalua"></a><a href="#metalua">7. (Meta)Lua on Miniforth</a>
</li><li><a name=".why-forth"></a><a href="#why-forth">8. Why Forth?</a>
</li><li><a name=".thanks"></a><a href="#thanks">Thanks</a>
</li><li><a name=".related-work"></a><a href="#related-work">Related work</a>
</li><li><a name=".bibliography"></a><a href="#bibliography">Bibliography</a>
</li></ul>




<hr size="1"/>





<p>The real point of this article is to propose a certain way of
implementing a Forth virtual machine; let&#39;s call this new way “mode-based”. The main loop of a mode-based Forth is just this:</p>

  <div>
<pre>while mode ~= &#34;stop&#34; do modes[mode]() end</pre></div>




<p>In our mode-based Forth, that is implemented in Lua, and that we
will refer to as “miniforth”, new modes can be added dynamically
very easily. We will start with a virtual machine that “knows” only
one mode - “interpret”, that corresponds to (less than) half of the
&#34;outer interpreter&#34; of traditional Forths - and with a dictionary that
initially contains  just one word, that means “read the
rest of the line and interpret that as Lua code”; that minimal virtual
machine fits in 40 lines of Lua, and is enough to bootstrap the whole
system.</p>



<p>But, “Why Forth?”, the reader will ask - “Forth is old and
weird, why shouldn&#39;t we stick to modern civilized languages, and
ignore Forth? What do you still like in Forth?” - My feeling here is
that Forth is one of the two quintessential extensible languages, the
other one being Lisp. Lisp is very easy to extend and to modify, but
only within certain limits: its syntax, given by ‘read’, is hard to
change(1). If we want to implement a little language (as in
[Bentley]) with a free-from syntax on top of Lisp, and we know
Forth, we might wonder that maybe the right tool for that would have
to have characteristics from both Lisp and Forth. And this is where
Lua comes in - as a base language for building extensible languages.</p>





<a name="forth-via-examples"></a><a href="#.forth-via-examples"><h2>1. Forth via examples</h2>
</a>



<p><i>(Disclaimer: I&#39;m using the term &#34;Forth&#34; in a loose sense
through this article. I will say more about this in the last
section.)</i></p>



<p>Any “normal” Forth has an interactive interface where the user
types a line, then hits the “return” key, and then the Forth
executes that line, word by word, and displays some output; our
miniforth does not have an interactive interface, but most ideas still
carry on. Here&#39;s a very simple program; the normal text is the user
input, and the parts with a darker background are the output from the
Forth system. Note that “words” are sequences on non-whitespace
characters, delimited by whitespace.</p>

<a name="program-1"></a>
<div>
<pre>5 DUP * . <span>25 ok</span>

  ( program 1 )
</pre></div>




<p>The program above can be “read aloud” as this: “Put 5 on the
stack; run ‘<code>DUP</code>’, i.e., duplicate the element on the top of the
stack; multiply the two elements on the top of the stack, replacing
them by their product; print the element at the top of the stack and
remove it from the stack.”</p>



<p>Here&#39;s a program that defines two new functions (“words”, in the
Forth jargon):</p>

<a name="program-2"></a>
<div>
<pre>: SQUARE DUP * ; <span>ok</span>
: CUBE DUP SQUARE * ; <span>ok</span>
5 CUBE . <span>125 ok</span>

  ( program 2 )
</pre></div>




<p>It can be read aloud as this:

</p>



<p>The words <code>SQUARE</code> and <code>CUBE</code> are represented in the memory
as some kind of bytecode; different Forths use different kinds of
bytecodes. Here we are more interested in “indirect threaded”
Forths (see [Ertl]) that store the dictionary in a separate region
of the memory. Some possible representations would be like in figures
1, 2, and 3; in these box diagrams all numbers are in hexadecimal, and
we are assuming a big-endian machine for simplicity. Figure 4 shows
the “bytecode” representation that we will use in miniforth. It is
not exactly a bytecode, as the memory cells can hold arbitrary Lua
objects, not just bytes - but we will call it a “bytecode” anyway,
by abuse of language.</p>

  <a name="figure-1"></a>        

<p><img src="http://angg.twu.net/miniforth/bytecodediag_1.png" alt="alt"/>
</p>

  <a name="figure-2"></a>        

<p><img src="http://angg.twu.net/miniforth/bytecodediag_2.png" alt="alt"/>
</p>

  <a name="figure-3"></a>        

<p><img src="http://angg.twu.net/miniforth/bytecodediag_3.png" alt="alt"/>
</p>

  <a name="figure-4"></a>        

<p><img src="http://angg.twu.net/miniforth/bytecodediag_4.png" alt="alt"/>
</p>



<p>Here&#39;s a trace of what happens when we run <code>CUBE</code> (from Program
2 and Figure 4) in miniforth:</p>

<a name="figure-5"></a>
<div>
<pre>RS={ 5 }    mode=head    DS={ 5 }      head=&#34;DOCOL&#34;
RS={ 7 }    mode=forth   DS={ 5 }      instr=&#34;DUP&#34;
RS={ 8 }    mode=forth   DS={ 5 5 }    instr=1
RS={ 8 1 }  mode=head    DS={ 5 5 }    head=&#34;DOCOL&#34;
RS={ 8 3 }  mode=forth   DS={ 5 5 }    instr=&#34;DUP&#34;
RS={ 8 4 }  mode=forth   DS={ 5 5 5 }  instr=&#34;*&#34;
RS={ 8 5 }  mode=forth   DS={ 5 25 }   instr=&#34;EXIT&#34;
RS={ 9 }    mode=forth   DS={ 5 25 }   instr=&#34;*&#34;
RS={ 10 }   mode=forth   DS={ 125 }    instr=&#34;EXIT&#34;

  Figure 5: a trace of CUBE (Program 2, Figure 4)
</pre></div>




<p>Note that we don&#39;t have a separate variable for the instruction
pointer (IP); we use the top of the return stack (RS) as IP.</p>



<p>The rightmost part of our traces always describe what is going to
be executed, while the rest describes the current state. So, in the
sixth line we have RS = { 8, 4 }, and we are going to execute the
instruction in <code>memory[4]</code>, i.e., “<code>*</code>”, in mode
&#34;forth&#34;.</p>





<a name="bootstrapping"></a><a href="#.bootstrapping"><h2>2. Bootstrapping miniforth</h2>
</a>



<p>Program 3a is all that we need to bootstrap miniforth. It defines
the main loop (“<code>run</code>”), one mode (“<code>interpret</code>”), the
dictionary (“<code>_F</code>”), and one word in the dictionary: “<code>%L</code>”, meaning “evaluate the rest of the current line as Lua code”.</p>


<a name="program-3a"></a>
<div>
<pre>-- Global variables that hold the input:
subj = &#34;5 DUP * .&#34;      -- what we are interpreting (example)
pos  = 1                -- where are are (1 = &#34;at the beginning&#34;)

-- Low-level functions to read things from &#34;pos&#34; and advance &#34;pos&#34;.
-- Note: the &#34;pat&#34; argument in &#34;parsebypattern&#34; is a pattern with
-- one &#34;real&#34; capture and then an empty capture.
parsebypattern = function (pat)
    local capture, newpos = string.match(subj, pat, pos)
    if newpos then pos = newpos; return capture end
  end
parsespaces     = function () return parsebypattern(&#34;^([ \t]*)()&#34;) end
parseword       = function () return parsebypattern(&#34;^([^ \t\n]+)()&#34;) end
parsenewline    = function () return parsebypattern(&#34;^(\n)()&#34;) end
parserestofline = function () return parsebypattern(&#34;^([^\n]*)()&#34;) end
parsewordornewline = function () return parseword() or parsenewline() end

-- A &#34;word&#34; is a sequence of one or more non-whitespace characters.
-- The outer interpreter reads one word at a time and executes it.
-- Note that `getwordornewline() or &#34;&#34;&#39; returns a word, or a newline, or &#34;&#34;.
getword          = function () parsespaces(); return parseword() end
getwordornewline = function () parsespaces(); return parsewordornewline() end

-- The dictionary.
-- Entries whose values are functions are primitives.
_F = {}
_F[&#34;%L&#34;] = function () eval(parserestofline()) end

-- The &#34;processor&#34;. It can be in any of several &#34;modes&#34;.
-- Its initial behavior is to run modes[mode]() - i.e.,
-- modes.interpret() - until `mode&#39; becomes &#34;stop&#34;.
mode  = &#34;interpret&#34;
modes = {}
run = function () while mode ~= &#34;stop&#34; do modes[mode]() end end

-- Initially the processor knows only this mode, &#34;interpret&#34;...
-- Note that &#34;word&#34; is a global variable.
interpretprimitive = function ()
    if type(_F[word]) == &#34;function&#34; then _F[word](); return true end
  end
interpretnonprimitive = function () return false end   -- stub
interpretnumber       = function () return false end   -- stub
p_s_i = function () end  -- print state, for &#34;interpret&#34; (stub)
modes.interpret = function ()
    word = getwordornewline() or &#34;&#34;
    p_s_i()
    local _ = interpretprimitive() or
              interpretnonprimitive() or
              interpretnumber() or
              error(&#34;Can&#39;t interpret: &#34;..word)
  end

  -- ( Program 3a: the core of miniforth )
</pre></div>






<p>Program 3b is a first program in miniforth. It starts with only “<code>%L</code>” defined and it defines several new words: what to do on
end-of-line, on end-of-text, and “<code>[L</code>”, that evaluates blocks
of Lua code that may span more than one line; then it creates a data
stack and defines the words “<code>DUP</code>”, “<code>*</code>”, “<code>5</code>”, and “<code>.</code>”, that operate on it.</p>

<a name="program-3b"></a>
<div>
<pre>-- Our first program in MiniForth.
-- It defines a meaning for newlines (they are no-ops; go ahead),
-- for &#34;&#34; (&#34;at end-of-text, change the mode to &#39;stop&#39;&#34;),
-- and for &#34;[L&#34; - read everything until a &#34;L]&#34;, and interpret
-- what is between the &#34;[L&#34; and the &#34;L] as Lua code, with eval.
-- Then it creates a data stack (&#34;DS&#34;) and four words - &#34;5&#34;, &#34;DUP&#34;,
-- &#34;*&#34;, &#34;.&#34; - that operate on it.
--
subj = [=[
%L _F[&#34;\n&#34;] = function () end
%L _F[&#34;&#34;]   = function () mode = &#34;stop&#34; end
%L _F[&#34;[L&#34;] = function () eval(parsebypattern(&#34;^(.-)%sL]()&#34;)) end
[L
  DS = { n = 0 }
  push = function (stack, x) stack.n = stack.n + 1; stack[stack.n] = x end
  pop  = function (stack) local x = stack[stack.n]; stack[stack.n] = nil;
                          stack.n = stack.n - 1; return x end
  _F[&#34;5&#34;]   = function () push(DS, 5) end
  _F[&#34;DUP&#34;] = function () push(DS, DS[DS.n]) end
  _F[&#34;*&#34;]   = function () push(DS, pop(DS) * pop(DS)) end
  _F[&#34;.&#34;]   = function () io.write(&#34; &#34;..pop(DS)) end
L]
]=]

-- Now run it. There&#39;s no visible output.
pos = 1
mode = &#34;interpret&#34;
run()

-- At this point the dictionary (_F) has eight words.

   -- ( Program 3b: a first program in miniforth )
</pre></div>




<p>After running Program 3b the system is already powerful enough to
run simple Forth programs like, for example,</p>






<p>Note that to “run” that what we need to do is:</p>

<div>
<pre>subj = &#34;5 DUP * .&#34;; pos = 1; mode = &#34;interpret&#34;; run()</pre></div>




<p>It is as if we were setting the memory (here the “<code>subj</code>”)
and the registers of a primitive machine by hand, and then pressing
its “run” button; clearly, that could be made better, but here we
have other priorities.</p>



<p>The Programs 3a and 3b don&#39;t have support for non-primitives; this
will have to be added later. Look at Figure 4; non-primitives, like
“<code>SQUARE</code>”, are represented in the bytecode as numbers -
addresses of heads in the <code>memory[]</code> - and we have not
introduced neither the <code>memory</code> yet, nor the states “<code>head</code>”
or “<code>forth</code>”.</p>



<p>Note that the names of non-primitives do not appear in the <code>memory</code>, only in the dictionary, <code>_F</code>. For convenience in such
memory diagrams we will draw the names of non-primitives below their
corresponding heads; in Figure 4 <code>_F[&#34;SQUARE&#34;] = 1</code> and <code>_F[&#34;CUBE&#34;] = 5</code>.</p>









<a name="modes"></a><a href="#.modes"><h2>3. Modes</h2>
</a>



<p>When the inner interpret runs - i.e., when the mode is &#34;head&#34; or
&#34;forth&#34;; see Figure 5 -, at each step the processor reads the contents
of the memory at IP and processes it. When the outer interpreter runs,
at each step it reads a word from <code>subj</code> starting at <code>pos</code>, and
processes it. There&#39;s a parallel between these behaviors...</p>



<p>I have never seen any references to &#34;modes&#34; in the literature about
Forth. In the usual descriptions of inner interpreters for Forth the
&#34;head&#34; mode is not something separate; it is just a transitory state
that is part of the semantics of executing a Forth word. And the
&#34;interpret&#34; and &#34;compile&#34; modes also do not exist - the outer
interpreter is implemented as a Forth word containing a loop; it reads
one word at a time, and depending on the value of a variable, <code>STATE</code>, it either &#34;interprets&#34; or &#34;compiles&#34; that word. So, in a
sense, &#34;interpret&#34; and &#34;compile&#34; are &#34;virtual modes&#34;...</p>



<p>Let me explain how I arrived at this idea of &#34;modes&#34; - and what I
was trying to do that led me there.</p>



<p>Some words interfere in the variables of the outer interpreter. For
example, &#34;:&#34; reads the word the <code>pos</code> is pointing at - for example,
&#34;SQUARE&#34; -, adds a definition for that word (&#34;SQUARE&#34;) to the
dictionary, and advances <code>pos</code>; when the control returns to <code>modes.interpret()</code> the variable <code>pos</code> is pointing to the position
after <code>SQUARE</code> - and <code>modes.interpret()</code> never tries to process
the word <code>SQUARE</code>. Obviously, this can be used to implement new
languages, with arbitrary syntax, on top of Forth.</p>



<p>Some words interfere on the variables of the inner interpreter -
they modify the return stack. Let&#39;s use a more colorful terminology:
we will speak of words that “eat text” and of words that “eat
bytecode”. As we have seen, “<code>:</code>” is a word that eats text;
numerical literals are implemented in Forth code using a word, <code>LIT</code>, that eats bytecode. In the program below,</p>

<a name="program-4"></a>
<div>
<pre>: DOZENS 12 * ; <span>ok</span>
5 DOZENS . <span>60 ok</span>

  ( Program 4 )
</pre></div>




<p>the word <code>DOZENS</code> is represented in bytecode in miniforth as:</p>

<a name="figure-6"></a>
<div>
<pre>memory = {&#34;DOCOL&#34;, &#34;LIT&#34;, 12, &#34;*&#34;, &#34;EXIT&#34;}
       -- 1        2      3   4    5
       -- DOZENS

  Figure 6: the bytecode for DOZENS (Program 4)
</pre></div>




<p>When the <code>LIT</code> in <code>DOZENS</code> executes it reads the 12 that
comes after it, and places it on the data stack; then it changes the
return stack so that in the next step of the main loop the IP will be
4, not 3. Here is a trace of its execution; note that there is a new
mode, &#34;lit&#34;. The effect of &#34;executing&#34; the 12 in <code>memory[3]</code> in
mode &#34;lit&#34; is to put the 12 in DS.</p>

<a name="figure-7"></a>
<div>
<pre>RS={ 1 }  mode=head   DS={ 5 }     head=&#34;DOCOL&#34;
RS={ 2 }  mode=forth  DS={ 5 }     instr=&#34;LIT&#34;
RS={ 3 }  mode=lit    DS={ 5 }     data=12
RS={ 4 }  mode=forth  DS={ 5 12 }  instr=&#34;*&#34;
RS={ 5 }  mode=forth  DS={ 60 }    instr=&#34;EXIT&#34;

  Figure 7: the trace for 5 DOZENS (Program 4, Figure 6)
</pre></div>




<p>The code in Lua for the primitive <code>LIT</code> and for the mode <code>lit</code> can be synthesized from the trace. By analyzing what happens
between steps 2 and 3 and 3 and 4, we see that <code>LIT</code> and <code>lit</code>
must be:</p>

<div>
<pre>_F[&#34;LIT&#34;] = function () mode = &#34;lit&#34; end
modes.lit = function ()
    push(DS, memory[RS[RS.n]])
    RS[RS.n] = RS[RS.n] + 1
    mode = &#34;forth&#34;
  end
</pre></div>




<p>so from this point on we will consider that the traces give enough
information, and we will not show the corresponding code.</p>



<p>Note that different modes read what they will execute from
different places: <code>head</code>, <code>forth</code> and <code>lit</code> read from <code>memory[RS[RS.n]]</code> (they eat bytecode); <code>interpret</code> and <code>compile</code> read from <code>subj</code>, starting at <code>pos</code> (they eat text).
Our focus here will be on modes and words that eat bytecode.</p>









<a name="virtual-modes"></a><a href="#.virtual-modes"><h2>4. Virtual Modes</h2>
</a>



<p>How can we create words that eat bytecode, like <code>LIT</code>, in Forth?
In the program in Figure 8 the word <code>TESTLITS</code> call first <code>LIT</code>,
then <code>VLIT</code>; <code>VLIT</code> should behave similarly to <code>LIT</code>, but <code>LIT</code> is a primitive and <code>VLIT</code> is not.</p>

<a name="figure-8"></a>
<div>
<pre>memory = {&#34;DOCOL&#34;, &#34;R&gt;P&#34;, &#34;PCELL&#34;, &#34;P&gt;R&#34;, &#34;EXIT&#34;,
      --  1        2      3        4      5
      --  VLIT &lt;---------------\
      --                      |
          &#34;DOCOL&#34;, &#34;LIT&#34;, 123, 1, 234, &#34;EXIT&#34;,}
      --  6        7      8    9  10   11
      --  TESTLITS

  Figure 8: a word (TESTLITS) that uses both LIT and VLIT
</pre></div>


<a name="figure-9"></a>
<div>
<pre>t=0  RS={ 6 }     mode=head    PS={  }    DS={  }         head=&#34;DOCOL&#34;
t=1  RS={ 7 }     mode=forth   PS={  }    DS={  }         instr=&#34;LIT&#34;
t=2  RS={ 8 }     mode=lit     PS={  }    DS={  }         data=123
t=3  RS={ 9 }     mode=forth   PS={  }    DS={ 123 }      instr=1
t=4  RS={ 10 1 }  mode=head    PS={  }    DS={ 123 }      head=&#34;DOCOL&#34;
t=5  RS={ 10 2 }  mode=forth   PS={  }    DS={ 123 }      instr=&#34;R&gt;P&#34;
t=6  RS={ 3 }     mode=forth   PS={ 10 }  DS={ 123 }      instr=&#34;PCELL&#34;
t=7  RS={ 4 }     mode=pcell   PS={ 10 }  DS={ 123 }      pdata=234
t=8  RS={ 4 }     mode=forth   PS={ 11 }  DS={ 123 234 }  instr=&#34;P&gt;R&#34;
t=9  RS={ 11 5 }  mode=forth   PS={  }    DS={ 123 234 }  instr=&#34;EXIT&#34;
t=10 RS={ 11 }    mode=forth   PS={  }    DS={ 123 234 }  instr=&#34;EXIT&#34;

  Figure 9: a trace of TESTLITS (Figure 8)
</pre></div>




<p>Figures 8 and 9 contain a full solution, so start by ignoring the
cells 2, 3, and 4 of the memory, and the lines t=5 to t=8 of the
trace. From t=5 to t=9 what we need to do is</p>

<div>
<pre>push(DS, memory[RS[RS.n - 1]])
RS[RS.n - 1] = RS[RS.n - 1] + 1
</pre></div>




<p>where the -1 is a magic number: roughly, the number of “call
frames” in the stack between the call to <code>VLIT</code> and the code that
will read its literal data, negated. In other situations this could be
-2, -3... One way to get rid of that magic number is to create a new
stack - the “parsing stack” (“<code>PS</code>”) - and to have “parsing words” that parse bytecode from the position that the top of
<code>PS</code> points to; then a word like <code>VLIT</code> becomes a variation of a
word, <code>PCELL</code>, that reads a cell from <code>memory[PS[PS.n]]</code> and
advances <code>PS[PS.n]</code>. The code for <code>VLIT</code> in Figure 8 shows
how that is done - we wrap <code>PCELL</code> as “<code>R&gt;P PCELL P&gt;R</code>” -
and from the trace in Figure 9 we can infer how to define these
words.</p>





<p>Note that the transition from t=2 to t=3 corresponds to the
transition from t=4 to t=10; the mode being <code>&#34;lit&#34;</code> corresponds to
having the address of the head of <code>VLIT</code> at the top of <code>RS</code>, and
the mode being <code>&#34;head&#34;</code>; using this idea we can implement virtual
modes in Forth. Better yet: it all becomes a bit simpler if we regard
the mode as being an invisible element that is always above the top of
<code>RS</code>. So, an imaginary mode <code>&#34;vlit&#34;</code> would be translated, or
expanded, into a 1 (the head of <code>VLIT</code>), plus a mode <code>&#34;head&#34;</code>;
or another word, similar to <code>VLIT</code>, would just switch the mode to
<code>&#34;vlit&#34;</code>, and the action of that word would be to expand it into
the head of <code>VLIT</code>, plus the mode <code>&#34;head&#34;</code>.</p>





<a name="polynomials"></a><a href="#.polynomials"><h2>5. A Bytecode for Polynomials</h2>
</a>



<p>A polynomial with fixed numerical coefficients can be represented
in memory as first the number of these coefficients, then the value of
each of them; for example, <i>P</i>(x) = 2x^3 + 3x^2 + 4x + 5.5 is
represented as { ..., 4, 2, 3, 4, 5.5, ... }. We will call this
representation - number of coefficients, then coefficients - the “data of the polynomial”. Let&#39;s start with a primitive, <code>PPOLY</code>,
that works like <code>PCELL</code>, in the sense that it reads the data of the
polynomial from the memory, starting at the position <code>PS[PS.n]</code>, and advancing <code>PS[PS.n]</code> at each step. This <code>PPOLY</code> takes a value from the top of the data stack - it will be 10 in
our examples - and replaces it by the result of applying <i>P</i> on it
- <i>P</i>(10), which is 2345.5.</p>



<p>By defining <code>POLY</code> from <code>PPOLY</code>, as we defined <code>VLIT</code> from
<code>PCELL</code> in Figure 8,</p>






<p>we get a word that eats bytecode; a call to <code>POLY</code> should be
followed by data of a polynomial, just like <code>LIT</code> is followed by a
number. And we can also do something else: we can create new heads,
<code>DOPOLY</code> and <code>DOADDR</code>, and represent polynomials as two heads
followed by the data of the polynomial. The program in Figure 10, that
tests this idea, has the trace in Figure 11.</p>

<a name="figure-10"></a>
<div>
<pre>memory = {&#34;DOPOLY&#34;, &#34;DOADDR&#34;, 4, 2, 3, 4, 5.5,
      --  1         2         3  4  5  6   7
      --  P(X)      &amp;P(X)
      --  ^---------------------\
      --                        |
          &#34;DOCOL&#34;,   &#34;LIT&#34;, 10, 1, &#34;EXIT&#34;}
      --  8          9      10  11 12
      --  TESTDOPOLY

  ( Figure 10: put 10 on the stack, call P(X) )
</pre></div>


<a name="figure-11"></a>
<div>
<pre>RS={ 8 }         mode=head    PS={  }   DS={  }        head=&#34;DOCOL&#34;
RS={ 9 }         mode=forth   PS={  }   DS={  }        instr=&#34;LIT&#34;
RS={ 10 }        mode=lit     PS={  }   DS={  }        data=10
RS={ 11 }        mode=forth   PS={  }   DS={ 10 }      instr=1
RS={ 12 1 }      mode=head    PS={  }   DS={ 10 }      head=&#34;DOPOLY&#34;
RS={ 12 forth }  mode=ppolyn  PS={ 3 }  DS={ 10 }      n=4
RS={ 12 forth }  mode=ppolyc  PS={ 4 }  DS={ 10 }      n=4 acc=0 coef=2
RS={ 12 forth }  mode=ppolyc  PS={ 5 }  DS={ 10 }      n=3 acc=2 coef=3
RS={ 12 forth }  mode=ppolyc  PS={ 6 }  DS={ 10 }      n=2 acc=23 coef=4
RS={ 12 forth }  mode=ppolyc  PS={ 7 }  DS={ 10 }      n=1 acc=234 coef=5.5
RS={ 12 forth }  mode=ppolye  PS={ 8 }  DS={ 10 }      acc=2345.5
RS={ 12 }        mode=forth   PS={ 8 }  DS={ 2345.5 }  instr=&#34;EXIT&#34;

  (Figure 11: a trace for the program in Figure 10)
</pre></div>




<p>The trace above does not show what <code>&amp;P(X)</code> does; the effect of
running <code>&amp;P(X)</code> is to put the address of the beginning of data of
the polynomial, namely, 3, into the data stack. Note how a polynomial
- that in most other languages would be a piece of passive data - in
Forth is represented as two programs, <code>P(X)</code> and <code>&amp;P(X)</code>, that
share their data. Compare that with the situation of closures in Lua -
two closures created by the same mother function, and referring to
variables that were local to that mother function, share upvalues.</p>





<a name="propositional-calculus"></a><a href="#.propositional-calculus"><h2>6. A Bytecode Language for Propositional Calculus</h2>
</a>



<p>Here is another example. Let&#39;s write “<code>=&gt;</code>” for “implies”, and “<code>&amp;</code>” for “and”. Then this,</p>

<a name="figure-12a"></a>
<div>
<pre>(Q=&gt;R)=&gt;((P&amp;Q)=&gt;(P&amp;R))

  ( Figure 12a: a proposition. )
</pre></div>




<p>is a “formula”, or a “proposition”, in Propositional
Calculus; incidentally, it is a tautology, i.e., always true.</p>



<p>In some situations, for example, if we want to find a proof for
that proposition, or if we want to evaluate its truth value for some
assignment of truth values to P, Q, and R, we need to refer to
subformulas of that formula. If we represent it in bytecode using
Polish Notation (not Reverse Polish Notation! Can you see why?) then
this becomes trivial:</p>

<a name="figure-12b"></a>
<div>
<pre>memory = { &#34;=&gt;&#34;, &#34;=&gt;&#34;, &#34;Q&#34;, &#34;R&#34;, &#34;=&gt;&#34;, &#34;&amp;&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;&amp;&#34;, &#34;P&#34;, &#34;R&#34; }
      --   1     2     3    4    5     6    7    8    9    10   11
   ( Figure 12b: the proposition in Figure 11 in Polish Notation. )
</pre></div>




<p>Subformulas can now be referred to by numbers - the position in the
memory where they start. We can write a word to parse a proposition
starting at some position in the memory; if that position contains a
binary connective like “<code>=&gt;</code>” or “<code>&amp;</code>”, then that
word calls itself two times to parse the subformulas at the &#34;left&#34; and
at the &#34;right&#34; of the connective. If the word memoizes the resulting
structure by storing it in a table <code>formulas</code>, then re-parsing the
formula that starts at the position, say, 6, becomes very quick: the
result is <code>formulas[6]</code>, and the pointer should be advanced to
<code>formulas[6].next</code>. Figure 13 shows the contents of that table
after parsing the formula that starts at <code>memory[1]</code>.</p>

<a name="figure-13"></a>
<div>
<pre>1:  { addr=1, cc=&#34;=&gt;&#34;, l=2,  r=5,  next=12, name=&#34;((Q=&gt;R)=&gt;((P&amp;Q)=&gt;(P&amp;R)))&#34; }
 2: { addr=2, cc=&#34;=&gt;&#34;, l=3,  r=4,  next=5,  name=&#34;(Q=&gt;R)&#34; }
 3: { addr=3,                      next=4,  name=&#34;Q&#34; }
 4: { addr=4,                      next=5,  name=&#34;R&#34; }
 5: { addr=5, cc=&#34;=&gt;&#34;, l=6,  r=9,  next=12, name=&#34;((P&amp;Q)=&gt;(P&amp;R))&#34; }
 6: { addr=6, cc=&#34;&amp;&#34;,  l=7,  r=8,  next=9,  name=&#34;(P&amp;Q)&#34; }
 7: { addr=7,                      next=8,  name=&#34;P&#34; }
 8: { addr=8,                      next=9,  name=&#34;Q&#34; }
 9: { addr=9, cc=&#34;&amp;&#34;,  l=10, r=11, next=12, name=&#34;(P&amp;R)&#34; }
10: { addr=10,                     next=11, name=&#34;P&#34; }
11: { addr=11,                     next=12, name=&#34;R&#34; }

  ( Figure 13: the table &#34;formulas&#34; (for Figure 12b). )
</pre></div>













<a name="metalua"></a><a href="#.metalua"><h2>7. (Meta)Lua on Miniforth</h2>
</a>



<p>The parser for the language for Propositional Calculus in the last
section had to be recursive, but it didn&#39;t need backtracking to work.
Here is a language that is evidently useful - even if at this context
it looks like an academic exercise - and whose parser needs a bit of
backtracking, or at least lookahead. Consider the following program in
Lua:</p>

<a name="figure-14"></a>
<div>
<pre>foo = function ()
    local storage
    return function () return storage end,
           function (x)   storage = x end
  end

  -- ( Figure 14 )
</pre></div>




<p>It can be represented in bytecode in miniforth as:</p>

<a name="figure-15"></a>
<div>
<pre>memory = {
  &#34;foo&#34;, &#34;=&#34;, &#34;function&#34;, &#34;(&#34;, &#34;)&#34;,
      &#34;local&#34;, &#34;storage&#34;,
      &#34;return&#34;, &#34;function&#34;, &#34;(&#34;, &#34;)&#34;, &#34;return&#34;, &#34;storage&#34;, &#34;end&#34;, &#34;,&#34;,
                &#34;function&#34;, &#34;(&#34;, &#34;x&#34;, &#34;)&#34;, &#34;storage&#34;, &#34;=&#34;, &#34;x&#34;, &#34;end&#34;,
    &#34;end&#34;,
  &#34;&lt;eof&gt;&#34; }

  -- ( Figure 15 )
</pre></div>




<p>One way of “executing” this bytecode made of string tokens could
be to produce in another region of the memory a representation in Lua
of the bytecode language that the Lua VM executes; another would be to
convert that to another sequence of string tokens - like what MetaLua
([Fleutot]) does. Anyway, there&#39;s nothing special with our choice
of Lua here - Lua just happens to be a simple language that we can
suppose that the reader knows well, but it could have been any
language. And as these parsers and transformers would be written in
Lua, they would be easy to modify.</p>




<a name="why-forth"></a><a href="#.why-forth"><h2>8. Why Forth?</h2>
</a>







<p><i>Caveat lector:</i> there is no single definition for what is “Forth”... around 1994 the community had a big split, with some people
working to create an ANSI Standard for Forth, and the creator of the
language and some other people going in another direction, and not
only creating new Forths that went against ideas of the Standard, but
also stating that ANS Forth “was not Forth”. I can only write this
section clearly and make it brief if I choose a <i>very</i> biased
terminology; and also, I&#39;m not going to be historically precise,
either - I will simplify and distort the story a bit to get my points
across. You have been warned!</p>





<p>Forth was very popular in certain circles at a time when computers
were much less powerful than those of today. Some of the reasons for
that popularity were easy to quantify: compactness of programs, speed,
proximity to machine code, simplicity of the core of the language -
i.e., of the inner and the outer interpreters. None of these things
matter so much anymore: computers got bigger and faster, their
assembly languages became much more complex, and we&#39;ve learned to take
for granted several concepts and facilities - <code>malloc</code> and <code>free</code>, high-level data structures, BNF - and now we feel that it is
&#34;simpler&#34; to send characters through stdout than poking bytes at the
video memory. Our notion of simplicity has changed.</p>



<p>Int the mid-90s came the ANS-Forth Standard, and with it a way to
write Forth source that would run without changes in Forths with
different memory models, on different CPU architectures. At about the
same time the creator of the language, Chuck Moore, started to
distance himself from the rest of the community, to work on Forths
that were more and more minimalistic, and on specialized processors
that ran Forth natively.</p>



<p>My experience with (non-Chuck-Moore-) Forth systems written before
and after the ANS Standard was that in the pre-ANS ones the format of
the bytecode was stated clearly, and users were expected to understand
it; in Forths written after the Standard the bytecode was not
something so mundane anymore - it became a technical detail, hidden
under abstractions.</p>



<p>Old Forths were fun to use. When I was a teenager I spent hundreds
of evenings playing with Forths on an IBM-PC - first FIG-Forth and
MVP-Forth, then HS-Forth, a commercial Forth whose memory model (8086
machine code, dictionary and Forth definitions in different memory
segments, indirect-threaded, no primitives, multiple heads) inspired
some of the ideas in this paper. At one point I spent some weeks
writing a program that constructed a &#34;shadow image&#34; of the Forth
segment, with a letter or a number for each byte in a head, a &#34;.&#34; for
each byte in a Forth instruction, &#34;_&#34;s and &#34;$&#34;s for bytes in literal
numbers and strings, &#34;&lt;&#34;s and &#34;&gt;&#34;s for the bytes that were
addresses in backward or forward jumps (i.e., the two bytes following
each call to <code>BRANCH</code> or <code>0BRANCH</code>) - and spaces for the unknown
bytes, as I didn&#39;t have the source for the whole core system, and some
words were tricky to decompile... Then I printed the result, in five
pages, each with a grid of 64x64 characters, and addresses at the
borders; that gave me a map of all the bytes in words in the core
system that were not defined in assembly language.</p>



<p>I&#39;ve met many people over the years who have been Forth enthusiasts
in the past, and we often end up discussing what made Forth so
thrilling to use at that time - and what we can do to adapt its ideas
to the computers of today. My personal impression is that Forth&#39;s main
points were not the ones that I listed at the beginning of this
section, and that I said that were easy to quantify; rather, what was
most important was that nothing was hidden, there were no complex data
structures around with “don&#39;t-look-at-this” parts (think on garbage
collection in Lua, for example, and Lua&#39;s tables - beginners need to
be convinced to see these things abstractly, as the concrete details
of the implementation are hard), and <i>everything</i> - code, data,
dictionaries, stacks - were just linear sequences of bytes, that could
be read and modified directly if we wished to. We had total freedom,
defining new words was quick, and experiments were quick to make; that
gave us a sense of power that was totally different from, say, the one
that a Python user feels today because he has huge libraries at his
fingertips.</p>



<p>A Forth-like language built on top of Lua should be easier to
integrate with the rest of the system than a &#34;real&#34; Forth written in
C. Also, it&#39;s much easier to add new syntaxes and bytecode languages
to a mode-based Forth than to a conventional one. And we are not
forced to store only numbers in the memory; we can store also strings
- I&#39;ve used strings for primitives and heads here because this makes
programs more readable -, or any other Lua objects, if we need to.</p>



<p>I do not intend to claim that miniforth is compact - in terms of
memory usage -, or efficient, or useful for practical applications.
But the natural ways for doing things in Forth were different from the
ways that are natural in today&#39;s systems; and I believe that miniforth
can be used to give to people glimpses into interesting ways of
thinking that have practically disappeared, and that have become hard
to communicate.</p>








<a name="thanks"></a><a href="#.thanks"><h3>Thanks</h3>
</a>



<p>To Marc Simpson and Yuri Takhteyev for helpful discussions. </p>

<a name="related-work"></a><a href="#.related-work"><h3>Related work</h3>
</a>



<p>After a draft of this article had been written Marc Simpson engaged
in a long series of discussions with me about Forths, Lisp, SmallTalk,
several approaches to minimality, etc, and at one point, over the
course of one hectic weekend in december, 2007, he implemented a <i>usable</i> (rather than just experimental) dialect of Forth - based
mainly on Frank Sergeant&#39;s Pygmy Forth and Chuck Moore&#39;s cmForth, and
borrowing some ideas from this article - on top of Ruby (“RubyForth”), and later ported his system to Python and C. A port of it
to Lua is underway.</p>





<a name="bibliography"></a><a href="#.bibliography"><h3>Bibliography</h3>
</a>



<p>Jon Bentley: <i>More Programming Pearls</i>, Addison-Wesley, 1990
(chapter 9: <i>Little Languages</i>).</p>



<p>James T. Callahan: HS-Forth (program and manual). Harvard
Softworks, 1986-1993.</p>



<p>Anton Ertl: <i>Threaded Code</i>. Retrieved from: <a href="http://www.complang.tuwien.ac.at/forth/threaded-code.html">http://www.complang.tuwien.ac.at/forth/threaded-code.html</a>.</p>



<p>Brad Rodriguez: <i>A BNF Parser in Forth</i>. From: <a href="http://www.zetetics.com/bj/papers/bnfparse.htm">http://www.zetetics.com/bj/papers/bnfparse.htm</a>.</p>



<p>Fabien Fleutot: <i>MetaLua</i>. At: <a href="http://metalua.luaforge.net/">http://metalua.luaforge.net/</a>.</p>



<p>Kein-Hong Man: <a href="http://luaforge.net/docman/view.php/83/98/ANoFrillsIntroToLua51VMInstructions.pdf">A No-Frills Introduction to Lua 5.1 VM Instructions</a>.</p>





</div>
  </body>
</html>
