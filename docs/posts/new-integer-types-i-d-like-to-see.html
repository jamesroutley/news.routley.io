<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.foonathan.net/2022/09/new-integer-types/">Original</a>
    <h1>New integer types I’d like to see</h1>
    
    <div id="readability-page-1" class="page"><div id="content">





<article>
    <header>
        
        <section>
            
            
        </section>
    </header>
<a id="content"></a>
    <p>(Most) C++ implementations provide at least 8, 16, 32, and 64-bit signed and unsigned integer types.
There are annoying implicit conversions, discussions about undefined behavior on overflow (some think it’s too much UB, others think it’s not enough),
but for the most part they do the job well.
Newer languages like Rust copied that design, but fixed the conversions and overflow behavior.</p>
<p>Still, I think there is room for innovation here.
Let me talk about three new families of integer types I’d like to see.</p>
    <a id="more"></a>
    
    
<h2 id="symmetric-signed-integers">Symmetric signed integers</h2>
<p>The de-facto representation of signed integers on modern hardware is two’s complement.
There positive values have the most significant bit set to zero, while it is set for negative values.
To get the absolute value of a negative number, flip all bits and add one.</p>
<p>For example, on an 8-bit integer, 42 is 0b0&#39;0101010: sign bit zero, the rest representing 42 in binary.
On the other hand, -42 is 0b1&#39;1010110: if you flip all bits you get 0b0&#39;0101001, add one and you’re back at 0b0&#39;0101010, which is 42.
Crucially, 0b1&#39;1111111 is -1 and more negative values go down to 0b1&#39;0000000, which is -128.</p>
<p>Notice something interesting about the last value?
If you do the conversion, flipping gives you 0b0&#39;1111111, and the addition of one results in 0b1&#39;0000000 – overflowing into the sign bit!</p>
<p>This means there absolute value of the smallest value is bigger than the absolute value of the biggest value 0b0&#39;1111111 or 127;
there are more negative values than positive values, because the positive half where the sign bit isn’t set also contain the number zero.</p>
<p>I really don’t like this asymmetry – it leads to annoying edge cases in all sort of integer APIs.</p>
<p>For starters, <code>abs(x)</code> for integers <code>x</code> isn’t a total function: <code>abs(INT_MIN)</code> isn’t representable.
Likewise, <code>x * (-1)</code> isn’t total either: <code>INT_MIN * (-1)</code> overflows.
It gets even funnier when you consider division: surely <code>x / y</code> cannot overflow as it division makes things smaller, right?
Wrong, <code>INT_MIN / (-1)</code> overflows (and <a href="https://twitter.com/foonathan/status/1572652798667542528">raises a division by zero (!) error on x86</a>).
Furthermore, <code>INT_MIN % (-1)</code> is <a href="https://twitter.com/foonathan/status/1560217266200973312">also UB</a>.</p>
<p>So here’s my wish: a signed integer where <code>INT_MIN == -INT_MAX</code>, by moving the minimal value one higher.</p>
<p>First, you’re not losing anything useful: I’d argue the extra negative number isn’t important in most use cases.
After all, if you had an extra number, wouldn’t it make more sense to have an additional positive number instead of a negative number?</p>
<p>Second, you’re getting symmetry back. All the operations mentioned above are now symmetric and can’t overflow.
This makes them a lot easier to reason about.</p>
<p>Third, you’re getting an unused bit pattern 0b1&#39;0000000, the old <code>INT_MIN</code>, which you can interpret however you like.
While you in principle could turn it into some sort of negative zero for extra symmetry, please don’t (just use one’s complement or sign magnitude instead).
Instead we should copy a different feature from floating point arithmetic: not-a-number or NaN.
Let’s call it <code>INT_NAN = 0b1&#39;0000000</code>.</p>
<p>Just like floating point’s NaN, <code>INT_NAN</code> isn’t a valid integer value.
In an ideal world, it would also be sticky on arithmetic, so <code>INT_NAN ¤ x == INT_NAN</code>, but that requires hardware support for efficiency.
Instead, let’s just say arithmetic on <code>INT_NAN</code> is undefined behavior; sanitizers can then insert assertions in debug mode.</p>
<p>Why do I want <code>INT_NAN</code> and thus add an additional precondition to every integer arithmetic?</p>
<p>Because I really like sentinel values.</p>
<p>For example, with <code>INT_NAN</code>, it is possible to have <code>sizeof(std::optional&lt;int&gt;) == int</code>:
instead of having to store an additional boolean to keep track of the existence of an optional, we can just store <code>INT_NAN</code> instead.
Likewise, a closed hash table needs some way to distinguish between empty and non-empty entries.
Having a sentinel value removes the need for additional meta data.</p>
<p>Now you might not like it that we’re picking a sentinel value here.
What if you want to store <code>INT_NAN</code> in an <code>std::optional&lt;int&gt;</code>?</p>
<p>Well, <code>INT_NAN</code> isn’t a number, so why do you want to store it in an <code>int</code>?
Only if you need some sort of sentinel value on your own.
This is similar to <a href="https://anniecherkaev.com/the-secret-life-of-nan">NaN boxing</a> of floating point values – you lose the ability to store (most) NaNs, but gain more efficient storage.
However, unlike floating point arithmetic where e.g. <code>0/0</code> can result in NaN, under my model, no arithmetic operation on integers can result in <code>INT_NAN</code> as overflow is undefined behavior.
So you really need to get out of your way by assigning <code>INT_NAN</code> to introduce integer NaN’s in your code.</p>
<blockquote>
<p>You might not like that I suggest arithmetic on <code>INT_NAN</code> should be UB if you’ve been burned by aggressive compiler optimizations in the past.
However, UB in the standard by itself is not a bad thing;
UB literally means that the standard poses no requirements on the behavior, which gives the compiler the most freedom.
They can assume it does not happen and optimize accordingly, but they can also insert debug assertions (either catching all, or rough checks with false negatives), or give it well-defined behavior.
Most mainstream compilers do the first interpretation by default, but for example <a href="https://www.youtube.com/watch?v=sCDsMc61iWM&amp;list=PLbxut1xyrkCZ-9d_03G0KBU4uh782J1eN">I’m currently working on a C interpreter</a>, where it will panic on all instances on UB.</p>
</blockquote>
<h2 id="unsigned-integers-with-one-bit-missing">Unsigned integers with one bit missing</h2>
<p>Using unsigned integer types in C++ is controversial, to say the least.
An argument in favor is the ability to express in the type system in the type system when something cannot be negative.
An argument against is the fact that subtraction easily results in big values due to integer overflow at zero.</p>
<blockquote>
<p>Unrelated, but “integer underflow” is not a thing. Exceeding the minimal value of an integer is still integer overflow.
<a href="https://en.wikipedia.org/wiki/Arithmetic_underflow">Underflow</a> occurs when you have a number that is too close to zero to be represented as a floating point.</p>
</blockquote>
<p>As a proponent of unsigned integer types, I can’t argue against the annoying overflow on subtraction.
It <em>can</em> cause all sorts of nasty bugs from buffer overflow to out of memory errors.
Switching to a signed integer makes sense here as a very negative value makes it really obvious that an error occurred,
and that is also the position many people take and use signed for everything.
This is a shame, since you lose the ability to express yourself in the type system.</p>
<p>Since you apparently don’t need the extra bit of storage space in many situations, I’d like to have something that is logically a 63 bit unsigned integers as opposed to a 64 bit one.
In assembly, it is represented the same way a 64 bit <em>signed</em> integer would.
However, it is undefined behavior if it ever stores a negative value.
This is similar to <code>bool</code>: it is logically a single bit but physically represented as a byte.</p>
<p>This sounds just like a signed integer with extra steps and more UB, so why bother?</p>
<p>First, compared to <code>int</code>, it automatically comes with a precondition that it cannot be negative.
Second, fewer overflow checks are necessary in debug mode.
Since we’re having a wide range of invalid values, we can just check the value whenever we do a store operation and not after every single arithmetic operation.
Sure, we could overflow in an intermediate expression and then undo the overflow in subsequent arithmetic,
but it is a nice trade-off between performance and safety.</p>
<blockquote>
<p>Again, this sort of lax debug check is not possible if the standard were to require program termination on overflow.</p>
</blockquote>
<p>In fact, those unsigned integer types are exactly equivalent to using the corresponding signed integer type and asserting that it is non-negative whenever necessary.
It is just built into the type system and implemented by the compiler, instead of a programmer written precondition.</p>
<h2 id="distinct-bit-vectors-vs-integer-type">Distinct bit vectors vs integer type</h2>
<p>I’ve recently worked on a compiler for a language that makes a distinction between signed integer types, unsigned integer types, and bit integer types.
The first two families support only arithmetic operations while only the last one support bit operations.
I was skeptical at first but come to really like the distinction.</p>
<p>I always found it weird how we treat an integer type both as a number and do arithmetic on it while also modifying individual bits.
When you’re doing math, you rarely need to modify individual digits!
This is especially true with signed integers, where the sign bit messes everything up and leads to implementation-defined or undefined behavior on shift operations.</p>
<p>Sure, distinguishing the two makes writing optimizations like shift instead of division or bitwise and instead of modulo more annoying to write,
and some fancy bit hacks require more casts, but it also makes it really obvious what’s going on:
you’re starting to treat an integer as a sequence of bits for some performance benefit, which requires some sort of documentation.</p>
<blockquote>
<p>When I mentioned the shift optimizations, I’m not talking about replacing <code>x / 2</code> by <code>x &gt;&gt; 1</code> – the compiler is going to do that.
I’m talking about things like <code>hash % hash_table_size</code>, where <code>hash_table_size</code> is always a power of two, but the compiler can’t know that.</p>
</blockquote>
<p>While we’re at it: why do we reserve so many tokens for bit operations?
How often do you actually need <code>|</code>, <code>&amp;</code> or <code>~</code> to warrant an entire character that can’t be used for anything else?
Not to mention that they have the <a href="https://softwareengineering.stackexchange.com/questions/194635/why-do-bitwise-operators-have-lower-priority-than-comparisons">wrong precedence in C</a>, and aren’t really useful on their own:
you often want <code>is_bit_set(x, n)</code>, <code>extract_bits(x, low, high)</code> or other higher-level operations built on top of the bitwise operations.
I’d like to see the operations delegated to (built-in) standard library functions, so we can re-use the operators for something else like <a href="https://www.foonathan.net/2022/09/new-integer-types/wg21.link/P2011">pipelines</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>There are a <a href="https://github.com/carbon-language/carbon-lang">lot</a> <a href="https://github.com/hsutter/cppfront">of</a> <a href="https://www.val-lang.dev/">new</a> languages popping up in the C++ space recently, I’d love to see some of them experiment in such a fundamental area.</p>
<p>Symmetric signed integers make so many fundamental APIs nicer, and a 63 bit unsigned <code>size_t</code> can combine the best of the signed/unsigned world for containers.
Sure, you still want the real unsigned types in situations where you want the extra bit since it doubles the range, but I think it would be fine to not have the true <code>INT_MIN</code> except for interop with C.
Distinct bit vectors can make code more expressive, but the casts can also get really annoying.
I’d still like to see someone try.</p>

    <blockquote>
        <p>If you&#39;ve liked this blog post, consider <a href="https://paypal.me/foonathan">donating</a> or otherwise <a href="https://jonathanmueller.dev/support-me/" target="_blank">supporting me</a>.</p>
    </blockquote>
    

</article>


    </div></div>
  </body>
</html>
