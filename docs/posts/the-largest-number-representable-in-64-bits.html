<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tromp.github.io/blog/2026/01/28/largest-number-revised">Original</a>
    <h1>The largest number representable in 64 bits</h1>
    
    <div id="readability-page-1" class="page"><div>
  	<p>This post is a rewrite of my earlier blog post from
<a href="https://tromp.github.io/blog/2023/11/24/largest-number">Nov 2023</a>
with many new insights and updates.</p>

<div><div><pre><code>┬─┬ ┬─┬──────────                                  ┬─┬─┬ ┬─┬────────────
└─┤ │ │ ──┬──────                                  └─┤ │ │ │ ──┬────────
  │ │ │ ┬─┼──────                                    └─┤ │ │ ──┼─┬──────
  │ │ │ └─┤ ┬─┬──                                      │ │ │ ┬─┼─┼──────
  │ │ │   │ ┼─┼─┬                                      │ │ │ └─┤ │ ┬─┬──
  │ │ │   │ │ ├─┘                                      │ │ │   └─┤ ┼─┼─┬
  │ │ │   │ ├─┘                                        │ │ │     │ │ ├─┘
  │ │ │   ├─┘                                          │ │ │     │ ├─┘  
  │ │ ├───┘                                            │ │ │     ├─┘    
  │ ├─┘                                                │ │ ├─────┘      
  └─┘                                                  │ ├─┘            
                                                       └─┘              
</code></pre></div></div>
<p>Most people believe 2<sup>64</sup>-1 = 18446744073709551615, or
0xFFFFFFFFFFFFFFFF in hexadecimal, to be the largest number
representable in 64 bits. In English, it’s quite the mouthful: eighteen
quintillion four hundred forty-six quadrillion seven hundred forty-four
trillion seventy-three billion seven hundred nine million five hundred
fifty-one thousand six hundred fifteen.</p>

<p>That is indeed the maximum possible value of 64 bit unsigned integers,
available as data type uint64_t in C or u64 in Rust. 
Floating point data types can represent much larger values, courtesy of their base 2 exponent.
The 64-bit double <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">floating
point format</a> has a largest (finite) representable value of 2<sup>1024</sup>(1-2<sup>-53</sup>) ~ 1.8*10<sup>308</sup>.</p>

<p>What if we allow representations beyond plain data types?
Since we want representations to remain computable, the most general
kind of representation would be a program in some programming language.
But the program must be small enough to fit in 64 bits.</p>

<h2 id="the-largest-number-programmable-in-64-bits">The largest number programmable in 64 bits</h2>

<p>The smallest possible valid C program is “main(){}”,
consisting of 8 ASCII characters.
<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> is a 7-bit
character encoding standard representing 128 unique characters,
but all modern computers use 8-bit bytes to store either plain ASCII
or <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, a Unicode character encoding that’s backward compatible with
ASCII.  So we’ll consider the above all-scaffold do-nothing program to
be the only valid 64-bit C program.</p>

<p>Plenty other languages require no such scaffolding. For instance,
Linux features the arbitrary precision calculator
<a href="https://en.wikipedia.org/wiki/Bc_(programming_language)">bc</a>. It happily
computes the 954242 digit number 9^999999 = 35908462…48888889, making
it programmable in 8 bytes. So is the much larger 9^9^9^99 =
9^(9^(9^99)) with over 10^10^953 digits, which bc is less happy to
compute. If bc supported the symbol ! for computing factorials, then
9!!!!!!! would represent a much larger number still.</p>

<p>Allowing such primitives feels a bit like cheating though. Would we allow a
language that has the <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackerman function</a>
predefined, letting the 8 byte expression ack(9,9) represent a truly huge number?</p>

<h2 id="ackerman-considered-unhelpful">Ackerman considered unhelpful</h2>

<p>As it turns out, the question is moot.
One can blow way past ack(9,9) in under 64 bits in a language with no built
in primitive whatsoever. A language with no basic arithmetic; not even numbers themselves.
A language in which all those must be defined from scratch.</p>

<p>But let’s first look at another primitives-lacking language, one that has been particularly
well studied for producing largest possible outputs. That is the language of
<a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machines</a>.</p>

<h2 id="busy-beaver">Busy Beaver</h2>

<p>The famous <a href="https://en.wikipedia.org/wiki/Busy_beaver">Busy Beaver</a>
 function, <a href="https://archive.org/details/bstj41-3-877/mode/2up">introduced</a> by
<a href="https://en.wikipedia.org/wiki/Tibor_Rad%C3%B3">Tibor Radó</a> in 1962, which we’ll
denote BB(n), is defined as the maximal number of steps taken by
an n-state Turing Machine (TM) with a binary tape alphabet,
starting from an all 0 tape, before halting.</p>

<p>Here we have a discrepancy between how the size of a TM is measured, in states,
versus how program size is measured, in bits.
Fortunately there is a straightforward binary encoding of n-state TMs,
which is entirely determined by its transition function.
For each of the n states that the machine’s finite control can be in,
and each of its 2 tape symbols that could be scanned by its tape head,
the transition function specifies what new symbol to write in the scanned tape cell (1 bit),
whether to move the tape head left or right (1 bit),
and what new state (or special halt state) to transition to (⌈log2(n+1)⌉ bits).
This encoding takes 6*2*(2+3) = 60 bits for a a 6-state TM,
and 7*2*(2+3) = 70 bits for a a 7-state TM.</p>

<p>We’re also stretching the meaning of “representable” a bit,
since BB considers the runtime of the machine instead of its output.
Besides the above BB (that Radó called S), Radó did define another
function called Σ that considers the output of the machine as a number in unary,
namely the number of 1s in the final tape contents. But BB has received
more attention as it allows one to determine from BB(n) all halting n-state machines.
For 6-states and up though, there is no discernable difference in magnitude between the two functions
so we could have just as easily used Σ.</p>

<p>So the largest number TM programmable in 64 bits is BB(6).</p>

<h2 id="how-large-is-bb6">How large is BB(6)?</h2>

<p>Unfortunately, we may never know. While all BB(n) have been determined (and even
formally proven) for n≤5, there are some 6-state TMs whose halting behaviour are
closely related to very hard mathematical problems.
Most of these so-called <a href="https://wiki.bbchallenge.org/wiki/Cryptids">cryptids</a>
are likely not to halt, with some,
like <a href="https://wiki.bbchallenge.org/wiki/Lucy%27s_Moonlight">Lucy’s Moonlight</a>,
likely to halt but unlikely to beat the current champion.
The current 6-state champion shows that
<a href="https://wiki.bbchallenge.org/wiki/BB(6)">BB(6) &gt; 2↑↑2↑↑2↑↑10 </a>.
Here, m↑↑n is <a href="https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation">Knuth’s up-arrow notation</a>
for an exponential tower of n m’s, so that for example 2↑↑3 = 2<sup>2<sup>2</sup></sup>.
Large as this number is, it’s still very small compared to
ack(9,9) = 2↑<sup>7</sup>12 - 3 = 2↑↑↑↑↑↑↑12 - 3.</p>

<p>It is known however that
<a href="https://wiki.bbchallenge.org/wiki/BB(7)">BB(7) &gt; 2↑<sup>11</sup>2↑<sup>11</sup>3 &gt; ack(9,9) </a>.
Several leading BB researchers believe that BB(7) is even larger than the famous
<a href="https://en.wikipedia.org/wiki/Graham%27s_number">Graham’s Number</a>, which iterates
the function mapping n to 3↑<sup>n</sup>3 64 times starting from n=3.
This appears to me a rather bold belief, considering that the smallest known Graham exceeding TM has
<a href="https://wiki.bbchallenge.org/wiki/Champions">14 states</a>, twice as many.
So I offered a $1000 bet that a proof of BB(7) &gt; Graham’s Number won’t be found within 10 years,
which BB researcher <a href="https://www.sligocki.com/about/">Shawn Ligocki</a> was happy to accept.</p>

<p>Meanwhile, Graham’s Number is easily surpassed within 64 bits, by moving beyond Turing machines
into the language of</p>

<h2 id="lambda-calculus">Lambda Calculus</h2>

<p>Alonzo Church conceived the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">λ-calculus</a>
in about 1928 as a formal logic system for expressing
computation based on function abstraction and application using variable binding and substitution.</p>

<p>The Graham beating lambda term originates in a Code Golf challenge asking for the
“Shortest terminating program whose output size exceeds Graham’s number”,
<a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/219734#219734">answered</a>
by user <a href="https://codegolf.stackexchange.com/users/101119/patcail">Patcail</a> and
<a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/263884#263884">further optimized</a> by user
<a href="https://codegolf.stackexchange.com/users/98257/2014melo03">2014MELO03</a>.
The following 49 bit program</p>

<div><div><pre><code>01 00 01 10 10 00 01 10 01 10 00 00 01 01 10 110 00 00 01 110 01 110 10
</code></pre></div></div>

<p>is the <a href="https://tromp.github.io/cl/cl.html">Binary Lambda Calculus</a> <a href="https://gist.github.com/tromp/86b3184f852f65bfb814e3ab0987d861#lambda-encoding">encoding</a> of the term</p>
<div><div><pre><code>(λ 1 1) (λ 1 (1 (λ λ 1 2 (λ λ 2 (2 1)))))
</code></pre></div></div>
<p>where λ (lambda) denotes an anonymous function, and number i is the variable bound by the i-th nested λ.
This is known as <a href="https://en.wikipedia.org/wiki/De_Bruijn_notation">De Bruijn notation</a>, a
way to avoid naming variables. A more conventional notation using variable names would be</p>
<div><div><pre><code>(λJ.J J) (λy.y (y (λg λm. m g (λf.λx.f (f x)))))
</code></pre></div></div>
<p>The top left of this post shows a <a href="https://tromp.github.io/cl/diagrams.html">graphical representation</a> of the term.
The last 16 bits of the program, making up almost a third of its size, encodes
the term λf λx. f (f x), which takes arguments f and x in turn, and iterates f twice on x.
In its generalized form, the function λf λx. f<sup>n</sup> x, 
called Church numeral n, is the most common way of representing numbers in the λ-calculus.
The encoding of Church numeral n is 0000(01110)<sup>n</sup>10, of size 5n+6 bits.</p>

<p>The program, which we’ll name after its discoverer, can be expressed more legibly as</p>

<div><div><pre><code>Melo = let { 2 = λf λx. f (f x); H = λg λm. m g 2; J = λy. y (y H) } in J J
</code></pre></div></div>

<p>Melo evaluates to a Church numeral, “Melo’s Number”, that comfortably exceeds Graham’s Number.</p>

<h2 id="proof-of-exceeding-grahams-number">Proof of exceeding Graham’s Number</h2>

<h3 id="lemma-1-j-j--26-hh-2-where-hh-denotes-h-h">Lemma 1. J J = 2↑↑6 HH 2, where HH denotes H H</h3>

<h3 id="proof">Proof:</h3>
<p>J J = J (J H) = J (H HH) = H HH (H HH H)
    = H HH H        HH 2
    = H HH 2        HH 2
    = 2 HH 2        HH 2
    = HH (HH 2)     HH 2
    = HH 2 H 2      HH 2
    = 2 H 2 H 2     HH 2
    = H (H 2) H 2   HH 2
    = H (H 2) 2 2   HH 2
    = 2 (H 2) 2 2   HH 2
    = H 2 (H 2 2) 2 HH 2
    = H 2 2 2 2 2   HH 2
    = 2 2 2 2 2 2   HH 2
    = 2↑↑6          HH 2</p>

<h3 id="lemma-2-for-kn--2-k-h-2-n--3k1n">Lemma 2. For k,n ≥ 2, k H 2 n &gt; 3↑<sup>k</sup>(1+n)</h3>

<h3 id="proof-1">Proof:</h3>
<p>By induction on k.  First note that H2 n = H 2 n = n 2 2 = 2^2^n</p>

<p>Base:   2 H 2 n = H H2 n = n H2 2 = 2↑↑(1+2n) &gt; 3↑<sup>2</sup>(1+n)
        already at n=2, since 2↑↑5 = 2^2^16 &gt; 3^27 = 3↑↑3
Step: k+1 H 2 n = H (k H 2) n = n (k H 2) 2 &gt; 3↑<sup>k</sup>(1+ 3↑<sup>k</sup>(1+ …
3↑<sup>k</sup>(1+2)…))
                                            &gt; 3↑<sup>k+1</sup>(1+n)</p>

<h3 id="lemma-3-for-n--2-hh-hh-n--3n3">Lemma 3. For n ≥ 2, HH (HH n) &gt; 3↑<sup>n</sup>3</h3>

<h3 id="proof-2">Proof</h3>
<p>By induction on n</p>

<p>Base: Lemma 1’s proof shows HH (HH 2) = 2↑↑6 &gt; 3{2&lt;/sup&gt;3
Step: HH (HH 1+n) = HH 1+n H 2 = 1+n H 2 H 2 = H (n H 2) H 2 =
H (n H 2) 2 2 = 2 (n H 2) 2 2 = n H 2 (n H 2 2) 2 &gt;<sup>Lm2</sup>
3↑<sup>n</sup>(1+3↑<sup>n</sup>(1+2)) 2 &gt; 3↑<sup>n+1</sup>3.</p>

<h3 id="theorem-j-j--grahams-number-g64-where-gn--n-n---3n3-4">Theorem: J J &gt; Graham’s Number G(64), where G(n) = n (\n -&gt; 3↑<sup>n</sup>3) 4</h3>

<h3 id="proof-3">Proof:</h3>
<p>J J =<sup>Lm1</sup> 2↑↑6 HH 2 &gt;<sup>Lm3</sup> (2↑↑6 / 2 - 1) (\n -&gt; 3↑<sup>n</sup>3)
3↑<sup>2</sup>3</p>
<blockquote>
  <p>(2↑↑6 / 2 - 1) (\n -&gt; 3↑<sup>n</sup>3) 4 = G(2↑↑6 / 2 - 1) &gt; G(64)</p>
</blockquote>

<h2 id="leaving-melos-number-in-the-dust">Leaving Melo’s Number in the dust</h2>

<p>With 15 bits to spare, opportunities for vastly boosting Melo abound.
Discord users 50_ft_lock and Sam found the following term that extends Melo’s H with an extra argument:</p>
<div><div><pre><code>w218 = let { 2 = λf λx. f (f x); A = λa λb λc. c a b 2; T = λy. y (y A) } in T T T
</code></pre></div></div>
<p>which desugars to lambda term</p>
<div><div><pre><code>(λT.T T T) (λy.y (y (λa λb λc. c a b (λf.λx.f (f x)))))
</code></pre></div></div>
<p>in conventional notation, or</p>
<div><div><pre><code>(λ 1 1 1) (λ 1 (1 (λ λ λ 1 3 2 (λ λ 2 (2 1)))))
</code></pre></div></div>
<p>in de Bruijn notation, with 61-bit encoding</p>
<div><div><pre><code>01 00 01 01 10 10 10 00 01 10 01 10 00 00 00 01 01 01 10 1110 110 00 00 01 110 01 110 10
</code></pre></div></div>

<h3 id="lemma-4-t-t-t--218-a-2-2-2-2-2-2-2-2-2-2">Lemma 4. T T T = 2↑↑18 A 2 2 2 2 2 2 2 2 2 2</h3>

<h3 id="proof-let-aa-denote-a-a">Proof: Let AA denote A A</h3>
<div><div><pre><code>  T T                                                            T
= T (T A)                                                        T
= T (A AA)                                                       T
= A AA (A AA A) T
= T AA                                                  (A AA A) 2
= AA (AA A) (A AA A)                                             2
= A AA A A                                              (AA A) 2 2
= A AA A 2                                              (AA A) 2 2
= 2 AA A                                              2 (AA A) 2 2
= AA (AA A) 2                                           (AA A) 2 2
= 2 A (AA A)                                          2 (AA A) 2 2
= A (A (AA A)) 2 (AA A)                                        2 2
= AA A (A (AA A))                                          2 2 2 2
= A (AA A) A A                                           2 2 2 2 2
= A (AA A) A 2                                           2 2 2 2 2
= 2 (AA A) A                                           2 2 2 2 2 2
= AA A (AA A A)                                        2 2 2 2 2 2
= AA A A                                         A A 2 2 2 2 2 2 2
= A A A 2                                        A A 2 2 2 2 2 2 2
= 2 A A                                        2 A A 2 2 2 2 2 2 2
= A AA 2 A                                         A 2 2 2 2 2 2 2
= A AA 2 2                                         A 2 2 2 2 2 2 2
= 2 AA 2                                         2 A 2 2 2 2 2 2 2
= AA (AA 2) 2                                      A 2 2 2 2 2 2 2
= 2 A (AA 2)                                     2 A 2 2 2 2 2 2 2
= A (A (AA 2)) 2 A                                   2 2 2 2 2 2 2
= A (A (AA 2)) 2 2                                   2 2 2 2 2 2 2
= 2 (A (AA 2)) 2                                   2 2 2 2 2 2 2 2
= A (AA 2) (A (AA 2) 2) 2                            2 2 2 2 2 2 2
= 2 (AA 2) (A (AA 2) 2) 2                            2 2 2 2 2 2 2
= AA 2 (AA 2 (A (AA 2) 2))                         2 2 2 2 2 2 2 2
= AA 2 (A (AA 2) 2)                          A 2 2 2 2 2 2 2 2 2 2
= A (AA 2) 2 A                           2 2 A 2 2 2 2 2 2 2 2 2 2
= A (AA 2) 2 2                           2 2 A 2 2 2 2 2 2 2 2 2 2
= 2 (AA 2) 2                           2 2 2 A 2 2 2 2 2 2 2 2 2 2
= AA 2 (AA 2 2)                        2 2 2 A 2 2 2 2 2 2 2 2 2 2
= AA 2 2                         A 2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= 2 A 2                        2 A 2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A (A 2) 2 A                      2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A (A 2) 2 2                      2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= 2 (A 2) 2 2                      2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A 2 (A 2 2) 2                    2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= 2 2 (A 2 2) 2                    2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= 4 (A 2 2) 2                      2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A 2 2 (A 2 2 (A 2 2 (A 2 2 2)))  2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A 2 2 (A 2 2 (A 2 2 2))    2 2 2 2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A 2 2 (A 2 2 2)      2 2 2 2 2 2 2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= A 2 2 2        2 2 2 2 2 2 2 2 2 2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= 2 2 2 2        2 2 2 2 2 2 2 2 2 2 2 2 2 2 A 2 2 2 2 2 2 2 2 2 2
= 2↑↑18 A 2 2 2 2 2 2 2 2 2 2
</code></pre></div></div>

<p>These 2↑↑18 iterations of A also let us relate its magnitude to the so-called
<a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy">Fast-growing hierarchy</a>,
a family that assigns, to each ordinal α, a function [α] (diverting from the usual f<sub>α</sub>
notation for improved legibility) from natural numbers to natural numbers.
We’ll treat all numbers as Church Numerals, so we can write n f instead of the
usual f<sup>n</sup> and write f n instead of f(n) as normally done in λ-calculus.</p>

<p>Readers unfamiliar with
<a href="https://en.wikipedia.org/wiki/Ordinal_number">ordinal</a>
<a href="https://en.wikipedia.org/wiki/Ordinal_arithmetic">arithmetic</a>,
may want to skip the next section.</p>

<p>The following FGH definition differs slightly from the standard one,
which has the slightly slower growing [0] n = n+1 and [α+1] n = n [α] n.
This allows Lemma 5 to be exact rather than a mere lower bound.</p>

<h3 id="definition-of-fast-growing-hierarchy">Definition of Fast Growing Hierarchy</h3>

<ol>
  <li>[0] n = 2 n = n<sup>2</sup></li>
  <li>[α+1] n = n 2 [α] 2 = A 2 [α] n</li>
  <li>[ω<sup>i+1</sup>(α+1)] n = [ω<sup>i+1</sup>α+ω<sup>i</sup> n] 2</li>
</ol>

<h3 id="lemma-5-for-k0-n2--k1-a-2-ωk-α-n--ωk-α1-n">Lemma 5. For k≥0, n&gt;=2, : k+1 A 2 [ω<sup>k</sup> α] n = [ω<sup>k</sup> (α+1)] n</h3>

<h3 id="proof-4">Proof:</h3>
<p>Base k=0:
0+1 A 2 [ω<sup>0</sup> α] n = A 2 [α] n = n 2 [α] 2 = [α+1] n</p>

<p>Step k&gt;0:
k+1 A 2 [ω<sup>k</sup> α] n = A (k A 2) [ω<sup>k</sup> α] n = n (k A 2) [ω<sup>k</sup> α] 2 = [ω<sup>k</sup> α + ω<sup>k-1</sup> n] 2 = [ω<sup>k</sup> (α+1)] n</p>

<p>Lemma 5 gives w218 = (2↑↑18 A 2 [0] 2) 2 2 2 2 2 2 2 = 2^2^2^2^2^2^2^([ω<sup>2↑↑18-1</sup>] 2).
In comparison, Graham’s and Melo’s Numbers are known to be much smaller at around [ω+1] 64 and [ω+1] (2↑↑6)
respectively.</p>

<h2 id="a-functional-busy-beaver">A Functional Busy Beaver</h2>

<p>The λ-calculus analogue to BB is:</p>

<p>BBλ(n) = the maximum beta normal form size of any closed lambda term of size n</p>

<p>which appears in the Online Encyclopedia of Integer Sequences (OEIS) as
<a href="https://oeis.org/A333479">functional Busy Beaver function</a>
Besides being simpler than BB, it has the advantage of using the standard unit of information theory,
bits, rather than states.</p>

<p>The much more fine-grained use of bits allows the first 36 values of BBλ 
to be currently known, versus only 5 values of BB.</p>

<p>Since both are Church numerals, term Melo implies that BBλ(49) ≥ 5(Melo’s Number)+6,
while w218 implies that BBλ(61) ≥ 5(2^2^2^2^2^2^2^([ω<sup>2↑↑18-1</sup>] 2))+6.</p>

<h2 id="bb-compared-bit-by-bit-to-bbλ">BB compared bit-by-bit to BBλ</h2>

<p>The growth rates of the two BB functions may be compared by how quickly they are known
to exceed certain large number milestones, that correspond to well known ordinals in the
Fast Growing Hierarchy.</p>

<p>For Graham’s Number, at ordinal ω+1, we saw earlier that Melo’s 49 bits compares with 14 states,
which take 14*2*(2+4) = 168 bits to encode. If I lose my bet, then the comparison
becomes rather closer at 49 vs 70 bits.</p>

<p>For <a href="https://en.wikipedia.org/wiki/Goodstein%27s_theorem">Goodstein’s function</a> at ordinal ε<sub>0</sub>,
<a href="https://github.com/tromp/AIT/blob/master/fast_growing_and_conjectures/BBE0.lam">111
bits</a>
compares with <a href="https://wiki.bbchallenge.org/wiki/Champions">51 states</a> taking 51*2*(2+6) = 816 bits.</p>

<p>For the limit of Bashicu Matrix System (BMS), at (presumed) ordinal PTO(Z<sub>2</sub>),
<a href="https://github.com/tromp/AIT/blob/master/fast_growing_and_conjectures/bms.lam">331 bits</a>
compares with <a href="https://morphett.info/turing/turing.html">150 states</a> taking 150*2*(2+8) = 3000 bits.</p>

<p>Finally, for Loader’s Number, at (presumed) ordinal PTO(Z<sub>ω</sub>),
<a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/274634#274634">1850
bits</a>
compares with <a href="https://github.com/CatsAreFluffy/metamath-turing-machines/tree/master">1015 states
</a> taking 
1015*2*(2+10) = 24360 bits.</p>

<p>One reason for TMs taking many more bits to achieve comparable growth,
especially at the larger milestones, is the extremely poor programmability of TMs.
The λ-calculus, despite its similar bare bones nature, doesn’t share this drawback.
Modern high level pure functional languages like <a href="https://www.haskell.org/">Haskell</a>
are essentially just syntactically sugared λ-calculus,
with programmer friendly features like <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic Data Types</a>
translating directly through <a href="https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding">Scott encodings</a>.
The <a href="https://bruijn.marvinborner.de/">bruijn programming language</a> is an even
thinner layer of syntactic sugar for the pure untyped lambda calculus, whose
extensive <a href="https://bruijn.marvinborner.de/std/">standard library</a> contains many
datatypes and functions.
It is this excellent programmability of the λ-calculus that facilitated the construction 
of highly optimized programs for BMS and Loader’s.</p>

<p>Because programming a Turing machine is so impossibly tedious,
that people have resorted to implementing higher level languages like
<a href="https://github.com/sorear/metamath-turing-machines">Not-Quite-Laconic</a>
for writing nontrivial programs such as the TM that halts only upon
finding an inconstency in ZFC. The above 1015 state TM for exceeding Loader’s Number
even includes a λ-calculus interpreter written in NQL!</p>

<p>In his paper <a href="https://scottaaronson.com/papers/bb.pdf">The Busy Beaver Frontier</a>,
<a href="https://scottaaronson.com/">Scott Aaronson</a> tries to answer the question</p>
<h2 id="but-why-turing-machines">But why Turing machines?</h2>

<p>“For all their historic importance, haven’t Turing machines been completely superseded
by better alternatives—whether stylized assembly languages or various codegolf languages or Lisp?
As we’ll see, there is a reason why Turing machines were a slightly unfortunate choice
for the Busy Beaver game: namely, the loss incurred when we encode a state transition table
by a string of bits or vice versa.
But Turing machines also turn out to have a massive advantage that compensates for this.”</p>

<h3 id="interesting-behaviour-at-small-sizes">Interesting behaviour at small sizes</h3>

<p>“Namely, because Turing machines have no “syntax” to speak of, but only graph structure,
we immediately start seeing interesting behavior even with machines of only 3, 4, or 5 states,
which are feasible to enumerate.”</p>

<p>The number of uniquely behaving TMs with “only” 5 states is
4^10 * <a href="https://oeis.org/A107668">632700</a> = 663434035200 , which is more than
the number of closed lambda terms of size at most 52 bits (513217604750).
The latter certainly exhibit no less interesting behaviour, so TMs hold no advantage here.</p>

<h3 id="ancient-and-fixed-computational-model">Ancient and fixed computational model</h3>

<p>“And there’s a second advantage. Precisely because the Turing machine model is so ancient and fixed,
whatever emergent behavior we find in the Busy Beaver game, there can be no suspicion that
we “cheated” by changing the model until we got the results we wanted.”</p>

<p>The λ-calculus is just slightly more ancient and is arguably more fixed.
There is no choice of tape alphabet size, no choice of whether the tape head needs
to move in every transition, no choice of halting and output
convention, and no choice in number of tapes or tape heads.</p>

<p>The λ-calculus can neither be suspected of being designed toward fast growth,
so again TMs hold no advantage here.</p>

<p>The only remaining advantage of BB over BBλ is the many decades of research behind
and publications about it.</p>

<h2 id="a-universal-busy-beaver">A Universal Busy Beaver</h2>

<p>Is BBλ then an ideal Busy Beaver function? Not quite.
It’s still lacking one desirable property, namely universality.</p>

<p>This property mirrors a notion of optimality for shortest description lengths, where it’s known
as the <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity#Invariance_theorem">Invariance theorem</a>:</p>

<p>Given any description language L, L<sub>opt</sub>
  is at least as efficient as L, with at most constant additive overhead.</p>

<p>In the realm of beavers, this means we require of an optimal Busy Beaver BB<sub>opt</sub> that
it surpass any Busy Beaver function bb (based on self-delimiting programs) with at most constant lag:</p>

<p>for some constant c depending on bb, and for all n: BB<sub>opt</sub>(n+c) ≥ bb(n)</p>

<p>While BBλ is not universal, the closely related</p>

<p><a href="https://oeis.org/A361211">BBλ2</a>(n) = the maximum output size of self-delimiting BLC programs of size n</p>

<p>achieves universality by giving λ-calculus terms access to pure binary data. BLC programs
consist of an encoded lambda term, followed by arbitrary binary data, that the term is applied to.</p>

<p>Since (λ_. t) applied to any (standard lambda representation of) binary data equals t,
BBλ champions provide lower bounds for BBλ2: for all n, BBλ2(2+n) ≥ BBλ(n).</p>

<h2 id="in-conclusion">In conclusion</h2>

<p>The largest number (currently known to be) representable in 64 bits is w218,
which lower bounds both BBλ(61) and BBλ2(63).</p>

	</div></div>
  </body>
</html>
