<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html">Original</a>
    <h1>The sad state of property-based testing libraries</h1>
    
    <div id="readability-page-1" class="page"><div>

<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#the-history-of-property-based-testing" id="toc-the-history-of-property-based-testing">The history of
property-based testing</a></li>
<li><a href="#a-survey-of-property-based-testing-libraries" id="toc-a-survey-of-property-based-testing-libraries">A survey of
property-based testing libraries</a></li>
<li><a href="#analysis" id="toc-analysis">Analysis</a>
<ul>
<li><a href="#why-are-property-based-testing-libraries-in-such-a-sad-state" id="toc-why-are-property-based-testing-libraries-in-such-a-sad-state">Why
are property-based testing libraries in such a sad state?</a>
<ul>
<li><a href="#stateful-and-parallel-testing-isnt-as-useful-as-pure-testing" id="toc-stateful-and-parallel-testing-isnt-as-useful-as-pure-testing">Stateful
and parallel testing isn’t as useful as pure testing</a></li>
<li><a href="#stateful-modelling-requires-training" id="toc-stateful-modelling-requires-training">Stateful modelling
requires training</a></li>
<li><a href="#closed-source-helps-industry-adoption" id="toc-closed-source-helps-industry-adoption">Closed source helps
industry adoption</a></li>
</ul></li>
<li><a href="#what-can-we-do-about-it" id="toc-what-can-we-do-about-it">What can we do about it?</a></li>
</ul></li>
<li><a href="#synthesis" id="toc-synthesis">Synthesis</a>
<ul>
<li><a href="#pure-property-based-testing-recap" id="toc-pure-property-based-testing-recap">Pure property-based testing
recap</a></li>
<li><a href="#stateful-property-based-testing" id="toc-stateful-property-based-testing">Stateful property-based
testing</a>
<ul>
<li><a href="#example-counter" id="toc-example-counter">Example:
counter</a></li>
<li><a href="#stateful-library-implementation" id="toc-stateful-library-implementation">Stateful library
implementation</a></li>
<li><a href="#example-circular-buffer" id="toc-example-circular-buffer">Example: circular buffer</a></li>
<li><a href="#example-jug-puzzle-from-die-hard-3" id="toc-example-jug-puzzle-from-die-hard-3">Example: jug puzzle from Die
Hard 3</a></li>
</ul></li>
<li><a href="#parallel-property-based-testing" id="toc-parallel-property-based-testing">Parallel property-based
testing</a>
<ul>
<li><a href="#parallel-library-implementation" id="toc-parallel-library-implementation">Parallel library
implementation</a></li>
<li><a href="#example-parallel-counter" id="toc-example-parallel-counter">Example: parallel counter</a></li>
<li><a href="#example-process-registry" id="toc-example-process-registry">Example: process registry</a></li>
</ul></li>
<li><a href="#integration-testing-with-contract-tested-fakes" id="toc-integration-testing-with-contract-tested-fakes">Integration
testing with contract tested fakes</a>
<ul>
<li><a href="#example-queue-again" id="toc-example-queue-again">Example:
queue (again)</a></li>
<li><a href="#example-file-system" id="toc-example-file-system">Example:
file system</a></li>
<li><a href="#example-bigger-system-of-components" id="toc-example-bigger-system-of-components">Example: bigger system of
components</a></li>
</ul></li>
</ul></li>
<li><a href="#conclusion-and-future-work" id="toc-conclusion-and-future-work">Conclusion and future work</a></li>
<li><a href="#acknowledgments" id="toc-acknowledgments">Acknowledgments</a></li>
</ul>
</nav>
<p>Posted on Jul  2, 2024</p>
<p>Property-based testing is a rare example of academic research that
has made it to the mainstream in less than 30 years. Under the slogan
“don’t write tests, generate them” property-based testing has gained
support from a diverse group of programming language communities. In
fact, the Wikipedia page of the original property-basted testing Haskell
library, <a href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>, lists 57
reimplementations in other languages.</p>
<p>In this post I’d like to survey the most popular property-based
testing implementations and compare them with what used to be the
state-of-the-art fifteen years ago (2009). As the title already gives
away, most of the libraries do not offer their users the most advanced
property-based testing features. In order to best explain what’s missing
and why I think we ended up in this situation, let me start by telling
the brief history of property-based testing.</p>
<section id="the-history-of-property-based-testing">
<h2><a href="#the-history-of-property-based-testing" title="The history of property-based testing">The history of
property-based testing</a></h2>
<p>In Gothenburg, Sweden’s second most populated city, there’s a
university called Chalmers. At the computer science department of
Chalmers there are several research groups, two of which are
particularly relevant to our story – the <em>Functional Programming</em>
group and <em>Programming Logic</em> group. I’ll let you guess what the
former group’s main interest is. The latter group’s mostly concerned
with a branch of functional programming where the type system is
sufficiently expressive that it allows for formal specifications of
programs, sometimes called dependently typed programming or type theory.
Agda is an example of a Haskell-like dependently typed programming
language, that also happens to be mainly developed by the Programming
Logic group. Given the overlap of interest and proximity, researchers at
the department are sometimes part of both groups or at least visit each
others research seminars from time to time.</p>
<p>John Hughes is a long-time member of the Functional Programming
group, who’s also well aware of the research on dependently typed
programming going on in the Programming Logic group. One day in the late
nineties, after having worked hard on finishing something important on
time, John found himself having a week “off”. So, just for fun, he
started experimenting with the idea of testing if a program respects a
formal specification.</p>
<p>Typically in dependently typed programming you use the types to write
the specification and then the program that implements that type is the
formal proof that the program is correct. For example, let’s say you’ve
implemented a list sorting function, the specification typically then is
that the output of the sorting function is ordered, i.e. for any index
<span><em>i</em></span> in your output list the
element at that index must be smaller or equal to the element at index
<span><em>i</em> + 1</span>. Formally proving that a
program is correct with respect to a specification is often as much work
as writing the program in the first place, so merely testing it can
often be a sweet spot where you get some confidence that the
specification is correct, without having to do the proving work. For
example in the sorting example you can simply generate a random input
list and then compare the output of your sorting function with the one
in the standard library (which is likely to be correct). As programs get
more complicated the ratio of effort saved by merely testing, as opposed
to proving, increases. In fact for bigger programs the effort involved
in proving correctness is simply too high for it to be practical (this
is an active area of research). Given all this, I hope that you can
start to see why this idea excited John.</p>
<p>While John was working on this idea, Koen Claessen, another member of
the Functional Programming group, <a href="https://youtu.be/x4BNj7mVTkw?t=289">stuck his head</a> into John’s
office and asked what he was doing. Koen got excited as well and came
back the next day with his improved version of John’s code. There was
some things that Koen hadn’t thought about, so John iterated on his code
and so it went back and forth for a week until the first implementation
of property-based testing was written and not long afterwards they
published the paper <a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf"><em>QuickCheck:
A Lightweight Tool for Random Testing of Haskell Programs</em></a> (ICFP
2000). I think it’s worth stressing the <em>lightweight tool</em> part
from the paper’s title, the complete source code for the <a href="https://github.com/Rewbert/quickcheck-v1">first version</a> of the
library is included in the appendix of the paper and it’s about 300
lines of code.</p>
<p>Haskell and dependently typed programming languages, like Agda, are
pure functional programming languages, meaning that it’s possible at the
type-level to distinguish whether a function has side-effects or not.
Proofs about functions in Agda, and similar languages, are almost always
only dealing with pure functions. Probably as a result of this, the
first version of QuickCheck can only test pure functions. This
shortcoming was rectified in the follow up paper <a href="https://www.cse.chalmers.se/~rjmh/Papers/QuickCheckST.ps"><em>Testing
monadic code with QuickCheck</em></a> (2002) by the same authors. It’s
an important extension as it allows us to reason about functions that
use mutable state, file I/O and networking, etc. It also lays the
foundation for being able to test concurrent programs, as we shall see
below.</p>
<p>Around the same time as the second paper was published (2002), John
was applying for a major grant at the Swedish Strategic Research
Foundation. A part of the application process involved pitching in front
of a panel of people from industry. Some person from <a href="https://en.wikipedia.org/wiki/Ericsson">Ericsson</a> was on the
panel and they were interested in QuickCheck. There was also a serial
entrepreneur on the panel and she encouraged John to start a company,
and the Ericsson person agreed to be a first customer, and so Quviq AB
was founded in 2006<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> by John and Thomas Arts (perhaps
somewhat surprisingly, Koen was never involved in the company).</p>
<p>The first project at Ericsson that Quviq helped out testing was
written in Erlang. Unlike Haskell, Erlang is not a pure functional
programming language and on top of that there’s concurrency everywhere.
So even the second, monadic, version of QuickCheck didn’t turn out to be
ergonomic enough for the job. This is what motivated the closed source
Quviq QuickCheck version written in Erlang, first mentioned in the paper
<a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=b268715b8c0bcebe53db857aa2d7a95fbb5c5dbf"><em>Testing
telecoms software with Quviq QuickCheck</em></a> (2006). The main
features of the closed source version that, as we shall see, are still
not found in many open source versions are:</p>
<ol type="1">
<li>Sequential <em>stateful</em> property-based testing using a state
machine model;</li>
<li><em>Parallel</em> testing with race condition detection by reusing
the sequential state machine model.</li>
</ol>
<p>We shall describe how these features work in detail later. For now
let’s just note that <em>stateful</em> testing in its current form was
first mentioned in <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c"><em>QuickCheck
testing for fun and profit</em></a> (2007). This paper also mentions
that it took John four iterations to get the stateful testing design
right, so while the 2006 paper already does mention stateful testing
it’s likely containing one of those earlier iteration of it.</p>
<p>While the 2007 paper also mentions <em>parallel</em> testing via
traces and interleavings, it’s vague on details. It’s only later in <a href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf"><em>Finding
Race Conditions in Erlang with QuickCheck and PULSE</em></a> (ICFP 2009)
that parallel testing is described in detail including a reference to <a href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf"><em>Linearizability:
a correctness condition for concurrent objects</em></a> by Herlihy and
Wing (1990) which is the main technique behind it.</p>
<p>I’d like to stress that no Quviq QuickCheck library code is ever
shared in any of these papers, they only contain the library APIs (which
are public) and test examples implemented using said APIs.</p>
<p>After that most papers are experience reports of applying Quviq
QuickCheck at different companies, e.g. <em>Testing A Database for Race
Conditions with QuickCheck</em> (2011), <a href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014), <em>Testing AUTOSAR
software with QuickCheck</em> (2015), <em>Mysteries of Dropbox:
Property-Based Testing of a Distributed Synchronization Service</em>
(2016).</p>
<p>Sometimes various minor extensions to stateful and parallel testings
are needed in order to test some particular piece of software, e.g. C
FFI bindings in the case of AUTOSAR or eventual consistency in the case
of Dropbox, but by and large the stateful and parallel testing features
remain the same.</p>
</section>
<section id="a-survey-of-property-based-testing-libraries">
<h2><a href="#a-survey-of-property-based-testing-libraries" title="A survey of property-based testing libraries">A survey of
property-based testing libraries</a></h2>
<p>As we’ve seen above, the current state-of-the-art when it comes to
property-based testing is <em>stateful</em> testing via a state machine
model and reusing the same sequential state machine model combined with
linearisability to achieve <em>parallel</em> testing.</p>
<p>Next let’s survey the most commonly used property-based testing
libraries to see how well supported these two testing features are. Let
me be clear up front that I’ve not used all of these libraries. My
understanding comes from reading the documentation, issue tracker and
sometimes source code.</p>
<p>To my best knowledge, as of June 2024, the following table summarises
the situation. Please open an <a href="https://github.com/stevana/stateful-pbt-with-fakes/issues">issue</a>,
PR, or get in <a href="https://stevana.github.io/about.html">touch</a>
if you see a mistake or an important omission.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Library</th>
<th>Language</th>
<th>Stateful</th>
<th>Parallel</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Eris</td>
<td>PHP</td>
<td>☐</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>FsCheck</td>
<td>F#</td>
<td>☒</td>
<td>☐</td>
<td>Has experimental <a href="https://fscheck.github.io/FsCheck//StatefulTestingNew.html">stateful
testing</a>. An <a href="https://github.com/fscheck/FsCheck/issues/214">issue</a> to add
parallel support has been open since 2016.</td>
</tr>
<tr>
<td>Gopter</td>
<td>Go</td>
<td>☒</td>
<td>☐</td>
<td>The README says “No parallel commands …
yet?” and there’s an open <a href="https://github.com/leanovate/gopter/issues/20">issue</a> from
2017.</td>
</tr>
<tr>
<td>Hedgehog</td>
<td>Haskell</td>
<td>☒</td>
<td>☒</td>
<td>Has parallel support, but the
implementation has <a href="https://github.com/hedgehogqa/haskell-hedgehog/issues/104">issues</a>.</td>
</tr>
<tr>
<td>Hypothesis</td>
<td>Python</td>
<td>☒</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>PropEr</td>
<td>Erlang</td>
<td>☒</td>
<td>☒</td>
<td>First open source library to support
both?</td>
</tr>
<tr>
<td>QuickCheck</td>
<td>Haskell</td>
<td>☐</td>
<td>☐</td>
<td>There’s an open <a href="https://github.com/nick8325/quickcheck/issues/139">issue</a> to
add stateful testing since 2016.</td>
</tr>
<tr>
<td>QuickTheories</td>
<td>Java</td>
<td>☒</td>
<td>☐</td>
<td>Has <a href="https://github.com/quicktheories/QuickTheories/issues/42">experimental</a>
for stateful testing, there’s also some parallel testing, but it’s
inefficient and restrictive compared to QuviQ’s Erlang version of
QuickCheck. From the <a href="https://github.com/quicktheories/QuickTheories/blob/a963eded0604ab9fe1950611a64807851d790c1c/core/src/main/java/org/quicktheories/core/stateful/Parallel.java#L35">source
code</a>: “Supplied commands will first be run in sequence and compared
against the model, then run concurrently. All possible valid end states
of the system will be calculated, then the actual end state compared to
this. As the number of possible end states increases rapidly with the
number of commands, command lists should usually be constrained to 10 or
less.”</td>
</tr>
<tr>
<td>Rapid</td>
<td>Go</td>
<td>☒</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>RapidCheck</td>
<td>C++</td>
<td>☒</td>
<td>☐</td>
<td>There’s an open <a href="https://github.com/emil-e/rapidcheck/issues/47">issue</a> to add
parallel support from 2015.</td>
</tr>
<tr>
<td>ScalaCheck</td>
<td>Scala</td>
<td>☒</td>
<td>☐</td>
<td>Has some support for parallel testing, but
it’s limited as can be witnessed by the fact that the two <a href="https://github.com/typelevel/scalacheck/tree/19af6eb656ba759980664e29ec6ae3e063021685/examples">examples</a>
of testing LevelDB and Redis both are sequential
(<code>threadCount = 1</code>).</td>
</tr>
<tr>
<td>SwiftCheck</td>
<td>Swift</td>
<td>☐</td>
<td>☐</td>
<td>There’s an open <a href="https://github.com/typelift/SwiftCheck/issues/149">issue</a> to
add stateful testing from 2016.</td>
</tr>
<tr>
<td>fast-check</td>
<td>TypeScript</td>
<td>☒</td>
<td>☐</td>
<td>Has <a href="https://fast-check.dev/docs/advanced/race-conditions/">some
support</a> for race condition checking, but it seems different from
Quviq QuickCheck’s parallel testing. In particular it doesn’t seem to
reuse the sequential state machine model nor use linearisability.</td>
</tr>
<tr>
<td>jetCheck</td>
<td>Java</td>
<td>☒</td>
<td>☐</td>
<td>From the source code “Represents an action
with potential side effects, for single-threaded property-based testing
of stateful systems.”.</td>
</tr>
<tr>
<td>jqwik</td>
<td>Java</td>
<td>☒</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>jsverify</td>
<td>JavaScript</td>
<td>☐</td>
<td>☐</td>
<td>There’s an open <a href="https://github.com/jsverify/jsverify/issues/148">issue</a> to add
stateful testing from 2015.</td>
</tr>
<tr>
<td>lua-quickcheck</td>
<td>Lua</td>
<td>☒</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>propcheck</td>
<td>Elixir</td>
<td>☒</td>
<td>☐</td>
<td>There’s an open <a href="https://github.com/alfert/propcheck/issues/148">issue</a> to add
parallel testing from 2020.</td>
</tr>
<tr>
<td>proptest</td>
<td>Rust</td>
<td>☐</td>
<td>☐</td>
<td>See proptest-state-machine.</td>
</tr>
<tr>
<td>proptest-state-machine</td>
<td>Rust</td>
<td>☒</td>
<td>☐</td>
<td>Documentation says “Currently, only
sequential strategy is supported, but a concurrent strategy is planned
to be added at later point.”.</td>
</tr>
<tr>
<td>qcheck-stm</td>
<td>OCaml</td>
<td>☒</td>
<td>☒</td>
<td></td>
</tr>
<tr>
<td>quickcheck</td>
<td>Prolog</td>
<td>☐</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>quickcheck</td>
<td>Rust</td>
<td>☐</td>
<td>☐</td>
<td>Issue to add stateful testing has been <a href="https://github.com/BurntSushi/quickcheck/issues/134">closed</a>.</td>
</tr>
<tr>
<td>quickcheck-state-machine</td>
<td>Haskell</td>
<td>☒</td>
<td>☒</td>
<td>Second open source library with parallel
testing support? (I was <a href="https://github.com/nick8325/quickcheck/issues/139#issuecomment-272439099">involved</a>
in the development.)</td>
</tr>
<tr>
<td>rackcheck</td>
<td>Racket</td>
<td>☐</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>rantly</td>
<td>Ruby</td>
<td>☐</td>
<td>☐</td>
<td></td>
</tr>
<tr>
<td>test.check</td>
<td>Clojure</td>
<td>☐</td>
<td>☐</td>
<td>Someone has implemented stateful testing
in a blog <a href="http://blog.guillermowinkler.com/blog/2015/04/12/verifying-state-machine-behavior-using-test-dot-check/">post</a>
though.</td>
</tr>
<tr>
<td>theft</td>
<td>C</td>
<td>☐</td>
<td>☐</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="analysis">
<h2><a href="#analysis" title="Analysis">Analysis</a></h2>
<p>By now I hope that I’ve managed to convince you that most
property-based testing libraries do not implement what used to be the
state-of-the-art fifteen years ago.</p>
<p>Many libraries lack stateful testing via state machines and most lack
parallel testing support. Often users of the libraries have opened
tickets asking for these features, but the tickets have stayed open for
years without any progress. Furthermore it’s not clear to me whether all
libraries that support stateful testing can be generalised to parallel
testing without a substantial redesign of their APIs. I don’t think
there’s a single example of a library to which parallel testing was
added later, rather than designed for from the start.</p>
<section id="why-are-property-based-testing-libraries-in-such-a-sad-state">
<h3><a href="#why-are-property-based-testing-libraries-in-such-a-sad-state" title="Why are property-based testing libraries in such a sad state?">Why
are property-based testing libraries in such a sad state?</a></h3>
<p>Here are three reasons I’ve heard from John:</p>
<ol type="1">
<li><p>The stateful and parallel testing features are not as useful as
testing pure functions. This is what John told me when I asked him why
these features haven’t taken off in the context of Haskell (BobKonf
2017);</p></li>
<li><p>The state machine models that one needs to write for the stateful
and parallel testing require a different way of thinking compared to
normal testing. One can’t merely give these tools to new users without
also giving them proper training, John said in an <a href="https://youtu.be/x4BNj7mVTkw?t=898">interview</a>;</p></li>
<li><p>Open source didn’t work, a closed source product and associated
services <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c">helps</a>
adoption:</p>
<blockquote>
<p>“Thomas Arts and I have founded a start-up, Quviq AB, to develop and
market Quviq QuickCheck. Interestingly, this is the second
implementation of QuickCheck for Erlang. The first was presented at the
Erlang User Conference in 2003, and made available on the web. Despite
enthusiasm at the conference, it was never adopted in industry. We tried
to give away the technology, and it didn’t work! So now we are selling
it, with considerably more success. Of course, Quviq QuickCheck is no
longer the same product that was offered in 2003—it has been improved in
many ways, adapted in the light of customers’ experience, extended to be
simpler to apply to customers’ problems, and is available together with
training courses and consultancy. That is, we are putting a great deal
of work into helping customers adopt the technology. It was naive to
expect that simply putting source code on the web would suffice to make
that happen, and it would also be unreasonable to expect funding
agencies to pay for all the work involved. In that light, starting a
company is a natural way for a researcher to make an impact on
industrial practice—and so far, at least, it seems to be
succeeding.”</p>
</blockquote></li>
</ol>
<p>A cynic might argue that there’s a conflict of interest between doing
research and education on one hand and running a company that sells
licenses, training and consulting on the other.</p>
<p>Let me be clear that I’ve the utmost respect for John, and I believe
what he says to be true and I believe he acts with the best intentions.
Having said that let me try to address John’s points.</p>
<section id="stateful-and-parallel-testing-isnt-as-useful-as-pure-testing">
<h4><a href="#stateful-and-parallel-testing-isnt-as-useful-as-pure-testing" title="Stateful and parallel testing isn’t as useful as pure testing">Stateful
and parallel testing isn’t as useful as pure testing</a></h4>
<p>I think many people will agree that separating pure from
side-effectful code is good practice in any programming language, and I
do agree with John that you can get far by merely property-based testing
those pure fragments.</p>
<p>However, I also think that stateful and parallel testing is almost
equally important for many non-trivial software systems. Most systems in
industry will have some database, stateful protocol or use concurrent
data structures, which all benefit from the stateful and parallel
testing features.</p>
</section>
<section id="stateful-modelling-requires-training">
<h4><a href="#stateful-modelling-requires-training" title="Stateful modelling requires training">Stateful modelling requires
training</a></h4>
<p>Regarding formal specification requiring a special way of thinking
and therefor training, I believe this is a correct assessment. However I
also believe that this is already true for property-based testing of
pure functions. A non-trained user of pure property-based testing will
likely test less interesting properties than someone who’s trained.</p>
<p>Given that John has written <a href="https://research.chalmers.se/publication/517894/file/517894_Fulltext.pdf">papers</a>
and given <a href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">talks</a> on the
topic of making property-based testing of pure functions more accessible
to programmers, one might wonder why we cannot do the same for stateful
and parallel testing?</p>
<p>The experience reports, that we’ve mentioned above, usually contain
some novelty (which warrants publishing a new paper) rather than general
advice which can be done with the vanilla stateful and parallel testing
features. Furthermore they require buying a Quviq license in order to
reproduce the results, a show stopper for many people.</p>
<p>I think it’s also worth stressing that stateful specifications are
not necessarily always more difficult than specifications for pure
functions. For example, to model a key-value store one can get quite far
with the model being a list of key-value pairs. In fact a simple model
like that managed to find a 17 step (shrunk) counterexample in LevelDB
to a known <a href="https://github.com/google/leveldb/issues/50">issue</a>, within
mere minutes. It took weeks for Google to provide a fix, and then after
running the property again on the fixed code a new 31 step
counterexample was found within minutes. Turns out there was a bug in
the background compaction process. The compaction process improves read
performance and reclaims disk space, which is important for a key-value
store, but interestingly it’s not explicitly part of the model. Joseph W
Norton gave a <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/strangeloop/lambdajam2013/master/slides/Norton-QuickCheck.html">talk</a>
at LambdaJam 2013 about it.</p>
</section>
<section id="closed-source-helps-industry-adoption">
<h4><a href="#closed-source-helps-industry-adoption" title="Closed source helps industry adoption">Closed source helps
industry adoption</a></h4>
<p>Regarding keeping the source closed helping with adoption, I think
this is perhaps the most controversial point that John makes.</p>
<p>If we try to see it from John’s perspective, how else would an
academic get funding to work on tooling (which typically isn’t
recognised as doing research), or feedback from industry? Surely, one
cannot expect research funding agencies to pay for this?</p>
<p>On the other hand one could ask why there isn’t a requirement that
published research should be reproducible using open source tools (or at
least tools that are freely available to the public and other
researchers)? Trying to replicate the results from the Quviq QuickCheck
papers (from 2006 and onward) without buying a Quviq QuickCheck license,
is almost impossible without a lot of reverse engineering work.</p>
<p>I suppose one could argue that one could have built a business around
an open source tool, only charging for the training and consulting, but
given how broken open source is today, unless you are a big company
(which takes more than it gives back), it’s definitely not clear that it
would have worked (and it was probably even worse back in 2006).</p>
<p>Even if John is right and that keeping it closed source has helped
adoption in industry, I think it’s by now fair to say it has not helped
open source adoption. Or perhaps another way to look at it, it’s
unlikely that a company that pays for a license in Erlang would then go
and port the library in another language.</p>
</section>
</section>
<section id="what-can-we-do-about-it">
<h3><a href="#what-can-we-do-about-it" title="What can we do about it?">What can we do about it?</a></h3>
<p>I think there’s at least two things worth trying.</p>
<ol type="1">
<li><p>Provide a short open source implementation of stateful and
parallel property-based testing, analogous to the original ~300 lines of
code QuickCheck implementation.</p>
<p>Perhaps part of the original QuickCheck library’s success in
spreading to so many other languages can be attributed to the fact that
its small implementation and that it is part of the original
paper?</p></li>
<li><p>Try to make the formal specification part easier, so that we
don’t need to train developers (as much).</p>
<p>Perhaps we can avoid state machines as basis for specifications and
instead reuse concepts that programmers are already familiar with from
their current testing activities, e.g. mocking and test doubles more
generally?</p></li>
</ol>
</section>
</section>
<section id="synthesis">
<h2><a href="#synthesis" title="Synthesis">Synthesis</a></h2>
<p>In order to test the above hypothesis, I’d like to spend the rest of
this post as follows:</p>
<ol type="1">
<li><p>Show how one can implement stateful and parallel property-based
testing in about 400 lines of code (similar to the size of the original
QuickCheck implementation);</p></li>
<li><p>Make specifications simpler by using in-memory reference
implementations similar to mocks, more accurately called <a href="https://martinfowler.com/bliki/TestDouble.html">fakes</a>, rather
than state machines.</p></li>
</ol>
<p>Before we get started with stateful testing, let’s first recap how
property-based testing of pure functions works.</p>
<section id="pure-property-based-testing-recap">
<h3><a href="#pure-property-based-testing-recap" title="Pure property-based testing recap">Pure property-based testing
recap</a></h3>
<p>It’s considered good practice to test new functions or functionality,
to make sure it does what we want. For example, imagine we’ve written a
linked-list reversal function called <code>reverse</code>, then it might
be sensible to test it against a couple of lists such as the empty list
and, say, the three element list <code>[1, 2, 3]</code>.</p>
<p>How does one choose which example inputs to test against though?
Typically one wants to choose corner cases, such as the empty list, that
perhaps were overlooked during the implementation. It’s difficult to
think of corner cases that you might have overlooked (because if you can
then you probably wouldn’t have overlooked them in the first place)!
This is where generating random inputs, a key feature of property-based
testing, comes in. The idea being that random inputs will eventually hit
corner cases.</p>
<p>When we manually pick inputs for our tests, like
<code>[1, 2, 3]</code>, we know what the output should be and so we can
make the appropriate assertion,
i.e. <code>reverse [1, 2, 3] == [3, 2, 1]</code>. When we generate
random inputs we don’t always know what the output should be. This is
where writing properties that relate the output to the input somehow
comes in. For example, while we don’t know what the output of reversing
an arbitrary list is, we do know that reversing it twice will give back
the input. This is how we can express this property in QuickCheck:</p>
<pre><code>&gt;&gt;&gt; quickCheck (\(xs :: [Int]) -&gt; reverse (reverse xs) == xs)
+++ OK, passed 100 tests.</code></pre>
<p>By default 100 tests get generated, but that can be adjusted:</p>
<pre><code>&gt;&gt;&gt; quickCheck (withMaxSuccess 5 (\(xs :: [Int]) -&gt; reverse (reverse xs) == xs))
+++ OK, passed 5 tests.</code></pre>
<p>We can see what test get generated using
<code>verboseCheck</code>:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> verboseCheck (withMaxSuccess <span>5</span> (\(<span>xs ::</span> [<span>Int</span>]) <span>-&gt;</span> <span>reverse</span> (<span>reverse</span> xs) <span>==</span> xs))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>Passed</span><span>:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>Passed</span><span>:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>[<span>1</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span>Passed</span><span>:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>[<span>-</span><span>2</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span>Passed</span><span>:</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>[<span>2</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span>Passed</span><span>:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>[<span>-</span><span>4</span>,<span>-</span><span>2</span>,<span>-</span><span>2</span>,<span>3</span>]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span>+++</span> <span>OK</span>, passed <span>5</span> tests<span>.</span></span></code></pre></div>
<p>Or by using <code>sample</code> on the appropriate
<code>Gen</code>erator. In this case we are generating lists of
integers, hence the <code>Gen [Int]</code> type annotation:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> sample (<span>arbitrary ::</span> <span>Gen</span> [<span>Int</span>])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>[<span>-</span><span>2</span>,<span>2</span>,<span>3</span>,<span>-</span><span>2</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>[<span>-</span><span>4</span>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>[<span>4</span>,<span>6</span>,<span>-</span><span>2</span>,<span>-</span><span>6</span>,<span>-</span><span>1</span>]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>[<span>1</span>,<span>7</span>,<span>5</span>,<span>-</span><span>8</span>,<span>1</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>[<span>-</span><span>11</span>,<span>4</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>[<span>3</span>,<span>-</span><span>1</span>,<span>11</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>[<span>-</span><span>3</span>,<span>17</span>,<span>-</span><span>14</span>,<span>-</span><span>1</span>,<span>17</span>,<span>18</span>,<span>-</span><span>8</span>,<span>-</span><span>9</span>,<span>-</span><span>13</span>,<span>-</span><span>7</span>]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>[<span>6</span>,<span>19</span>,<span>6</span>,<span>9</span>,<span>-</span><span>15</span>,<span>-</span><span>6</span>,<span>-</span><span>19</span>]</span></code></pre></div>
<p>The list and integer generators are provided by the library and I
hope you agree that these seem like sensible arbitrary lists to use in
our tests.</p>
<p>Next let’s have a look at when a property fails. For example this is
what happens if we try to test that the output of reversing a list is
the input list:</p>
<pre><code>&gt;&gt;&gt; quickCheck (\(xs :: [Int]) -&gt; reverse xs == xs)
*** Failed! Falsified (after 3 tests and 2 shrinks):
[0,1]</code></pre>
<p>We see that after 3 tests a test case was generated that failed, the
input got shrunk twice and the minimal counterexample
<code>[0, 1]</code> is presented. Notice that we do need a list that is
at least of length two, because any shorter list will reverse to
itself.</p>
<p>As pointed out earlier, coming up with these properties is not easy.
There are however a few patterns that come up over and over again. With
<code>reverse</code> we saw an example of an involutory function, i.e.
<code>f (f x) == x</code>, here are a few other examples:</p>
<ul>
<li>Inverses,
e.g. <code>\(i :: Input) -&gt; deserialise (serialise i) == i</code>;</li>
<li>Idempotency,
e.g. <code>\(xs :: [Int]) -&gt; sort (sort xs) == sort xs</code>;</li>
<li>Associativity,
e.g. <code>\(i j k :: Int) -&gt; (i + j) + k == i + (j + k)</code>;</li>
<li>Axioms of abstract data types, e.g.
<code>\(x :: Int)(xs :: [Int]) -&gt; member x (insert x xs) &amp;&amp; not (member x (remove x xs))</code>;</li>
<li>Metamorphic properties, e.g.
<code>\(g :: Graph)(m n :: Node) -&gt; shortestPath g m n == shortestPath g n m</code>.</li>
</ul>
<p>Readers familiar with discrete math might recognise some of the
above.</p>
</section>
<section id="stateful-property-based-testing">
<h3><a href="#stateful-property-based-testing" title="Stateful property-based testing">Stateful property-based
testing</a></h3>
<p>In the pure property-based testing case, that we just looked at, the
picture of the test setup looks a bit like this:</p>
<pre><code>         +-----+
      i  |     |  o
    -----&gt;  f  +----&gt;
         |     |
         +-----+</code></pre>
<p>Where <code>i</code> is the input we generate, <code>f</code> is the
function we are applying the generated input to produce the output
<code>o</code>. In the case of the <code>reverse</code> example, from
before, <code>i</code> and <code>o</code> are of type list of integers
(<code>[Int]</code>), <code>f</code> is <code>reverse . reverse</code>
and the property that we check for every generated input is that input
is equal to the output.</p>
<p>Next let’s contrast this picture with how the test setup looks when
we are testing a stateful component. A simple example of a stateful
component is a counter with an <code>incr</code>ement operation which
increment the counter and returns the old count.</p>
<p>Unlike in the pure case, the same input will not give the same
output. For example the first time we do <code>incr</code> we get back
<code>0</code> (if we start counting from zero) while the second time we
do <code>incr</code> we get <code>1</code>. A database or a file system
are two other examples of stateful components, where the history of
previous inputs affects the output of the next input.</p>
<p>In the stateful case, the picture looks more like this:</p>
<pre><code>    +------+     +------+     +------+
    |      | i1  |      | i2  |      |
    |  s0  +-----&gt;  s1  +-----&gt;  s2  | ...
    |      |     |      |     |      |
    +------+     +--+---+     +--+---+
                    |            |
                    | o1         | o2
                    v            v

    ---------------------------------&gt; time</code></pre>
<p>Where <code>s</code> is the state, <code>i</code> is an input
(e.g. <code>incr</code>) and <code>o</code> is an output. Notice how the
state evolves over time and depends on the history of inputs.</p>
<p>In the pure case each test case is a single input, in the stateful
case we need a sequence of inputs in order to test how the system
changes over time. In the pure case our properties were relations on the
input and output, i.e. <code>R : i -&gt; o -&gt; Bool</code>. In the
stateful case our properties would need to be generalised to
<code>R&#39; : [i] -&gt; [o] -&gt; Bool</code> to account for how the state
changes over time. Writing such properties is cumbersome, an alternative
is to account for the state explicitly by means of some kind of
model.</p>
<p>This is where our in-memory reference implementation, or fake, comes
in. We’ll use a function of type <code>m -&gt; i -&gt; (m, o)</code>,
i.e. from the old model and an input compute the next model and the
output. From this we can derive a property that for each input checks if
the outputs of the stateful component agrees with the output of the
fake:</p>
<pre><code>         +------+     +------+     +------+
         |      | i1  |      | i2  |      |
 real:   |  s0  +-----&gt;  s1  +-----&gt;  s2  | ...
         |      |     |      |     |      |
         +------+     +--++--+     +--++--+
                         ||           ||
                         ||o1         || o2
                         ||           ||
         +------+     +--++--+     +--++--+
         |      | i1  |      | i2  |      |
 fake:   |  m0  +-----&gt;  m1  +-----&gt;  m2  | ...
         |      |     |      |     |      |
         +------+     +------+     +------+

         ---------------------------------&gt; time</code></pre>
<p>In case the outputs disagree we shrink the sequence of inputs and try
to present the smallest counterexample, as in the pure case.</p>
<p>Let’s make things more concrete with some actual code that we can
run.</p>
<section id="example-counter">
<h4><a href="#example-counter" title="Example: counter">Example:
counter</a></h4>
<p>All examples, in the rest of this post, will have three parts:</p>
<ol type="1">
<li>The software under test;</li>
<li>The model that the software under test gets tested against;</li>
<li>The generated tests and output from running them.</li>
</ol>
<p>The first part is independent of the stateful testing library we are
building. The second part is hooking up the first part to the library by
implementing an interface (type class). We’ll look at the definition of
the type class after the example. The final part is how to write the
actual property and interpret the output from running them.</p>
<section id="software-under-test">
<h5><a href="#software-under-test" title="Software under test">Software
under test</a></h5>
<p>This is how you can implement a counter using a global mutable
variable in Haskell:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>gLOBAL_COUNTER ::</span> <span>IORef</span> <span>Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>gLOBAL_COUNTER <span>=</span> unsafePerformIO (newIORef <span>0</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>{-# NOINLINE gLOBAL_COUNTER #-}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>incr ::</span> <span>IO</span> ()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>incr <span>=</span> <span>do</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  n <span>&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span>+</span> <span>1</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span>get ::</span> <span>IO</span> <span>Int</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>get <span>=</span> readIORef gLOBAL_COUNTER</span></code></pre></div>
<p>Notice that here <code>incr</code> doesn’t return the old value, like
above, and instead we have a separate operation <code>get</code> which
returns the current value of the counter.</p>
</section>
<section id="model">
<h5><a href="#model" title="Model">Model</a></h5>
<p>To model our counter we’ll use an integer.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Counter</span> <span>=</span> <span>Counter</span> <span>Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Show</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>-- We&#39;ll come back to the definition of the `StateModel` type class after this</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span>-- example.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>StateModel</span> <span>Counter</span> <span>where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span>-- We start counting from zero.</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>  initialState ::</span> <span>Counter</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  initialState <span>=</span> <span>Counter</span> <span>0</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span>-- The commands correspond to the names of the functions that operate on the</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span>-- global counter.</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Command</span> <span>Counter</span> r</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>Incr</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Get</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Show</span>, <span>Functor</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span>-- The responses correspond to the return types of each function. By</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  <span>-- convention we&#39;ll add a underscore suffix to a response of the corresponding</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  <span>-- command.</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Response</span> <span>Counter</span> r</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>Incr_</span> ()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Get_</span> <span>Int</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Eq</span>, <span>Show</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  <span>-- The state machine takes a command and the model of the counter and returns</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>  <span>-- a new model and a response. We&#39;ll come back to the role of the `Either` later.</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span>  runFake ::</span> <span>Command</span> <span>Counter</span> r <span>-&gt;</span> <span>Counter</span> <span>-&gt;</span> <span>Either</span> <span>Void</span> (<span>Counter</span>, <span>Response</span> <span>Counter</span> r)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  runFake <span>Incr</span>  (<span>Counter</span> n) <span>=</span> <span>return</span> (<span>Counter</span> (n <span>+</span> <span>1</span>), <span>Incr_</span> ())</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  runFake <span>Get</span> m<span>@</span>(<span>Counter</span> n) <span>=</span> <span>return</span> (m, <span>Get_</span> n)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  <span>-- We also need to explain which part of the counter API each command</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  <span>-- corresponds to.</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span>  runReal ::</span> <span>Command</span> <span>Counter</span> r <span>-&gt;</span> <span>IO</span> (<span>Response</span> <span>Counter</span> r)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>  runReal <span>Get</span>  <span>=</span> <span>Get_</span>  <span>&lt;$&gt;</span> get</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>  runReal <span>Incr</span> <span>=</span> <span>Incr_</span> <span>&lt;$&gt;</span> incr</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>  <span>-- We&#39;ll generate increments and reads of the counter with equal probability.</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  <span>-- Notice that we only need to explain how to generate a single command, the</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>  <span>-- library will use this to generate sequences of commands as we&#39;ll see later.</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a><span>  generateCommand ::</span> <span>Counter</span> <span>-&gt;</span> <span>Gen</span> (<span>Command</span> <span>Counter</span> r)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>  generateCommand _s <span>=</span> elements [<span>Incr</span>, <span>Get</span>]</span></code></pre></div>
<p>A common complaint is that the model (<code>Counter</code> and
<code>runFake</code>) is as big as the implementation itself. This is
true, because it’s an example. In reality the model will often be many
orders of magnitude smaller. This is due to the fact that the model,
unlike the real implementation, doesn’t need to persisting to disk,
communicating over the network, or perform various time or space
optimisations. Recall the LevelDB example from above.</p>
</section>
<section id="tests">
<h5><a href="#tests" title="Tests">Tests</a></h5>
<p>The tests, or property, can now be written as follows.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>prop_counter ::</span> <span>Commands</span> <span>Counter</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>prop_counter cmds <span>=</span> monadicIO <span>$</span> <span>do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  run reset</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  assert <span>True</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span>reset ::</span> <span>IO</span> ()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>reset <span>=</span> writeIORef gLOBAL_COUNTER <span>0</span></span></code></pre></div>
<p>To run them, we can load the module and type
<code>quickCheck prop_counter</code> in the REPL, which gives us an
output like:</p>
<pre><code>+++ OK, passed 100 tests:
89% Get
85% Incr

Commands (2151 in total):
52.02% Get
47.98% Incr</code></pre>
<p>Where the first group of percentages tell us the proportion of tests
that contained the get and increment command respectively, and the
second group of percentages tell us the proportion of get and increment
commands out of all commands generated. Note that the first group
doesn’t add up to 100%, because most tests will contain both commands,
whereas the second group does. The reason the second group is almost
50-50 is because in the generator we generate both commands with equal
probability.</p>
<p>Another thing to note is that we need to <code>reset</code> the
counter between tests, otherwise the global counter will have the value
from the last test while the model always starts from zero and we get a
mismatch.</p>
<p>To make things a bit more interesting, let’s introduce a bug into our
counter and see if the tests can find it. Let’s make it so that if the
counter has the value of 42, then it won’t increment properly.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>incr42Bug ::</span> <span>IO</span> ()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>incr42Bug <span>=</span> <span>do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  n <span>&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span>let</span> n&#39; <span>=</span> <span>if</span> n <span>==</span> <span>42</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>           <span>then</span> n <span>-- </span><span>BUG</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>           <span>else</span> n <span>+</span> <span>1</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER n&#39;</span></code></pre></div>
<p>We also need to change the <code>runReal</code> function to use our
buggy increment as follows.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>- runReal Incr = Incr_ &lt;$&gt; incr</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>+ runReal Incr = Incr_ &lt;$&gt; incr42Bug</span></span></code></pre></div>
<p>When we run the property now, we’ll see something like the following
output.</p>
<pre><code>*** Failed! Assertion failed (after 66 tests and 29 shrinks):
    Commands [Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Get]
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Get --&gt; Get_ 42

    Expected: Get_ 43
    Got: Get_ 42</code></pre>
<p>Notice that this is indeed the smallest counterexample and how it
took 66 randomly generated test cases to find the sequence of inputs
that triggered the bug and then 29 shrink steps for QuickCheck to
minimise it.</p>
</section>
</section>
<section id="stateful-library-implementation">
<h4><a href="#stateful-library-implementation" title="Stateful library implementation">Stateful library
implementation</a></h4>
<p>In the example above we implemented the <code>StateModel</code>
interface (or type class), next we’ll have a look at the definition of
this interface and the testing functionality we can derive by
programming against the interface.</p>
<section id="stateful-testing-interface">
<h5><a href="#stateful-testing-interface" title="Stateful testing interface">Stateful testing interface</a></h5>
<p>Let me give you the full definition of the interface and then I’ll
explain it in words afterwards.</p>

<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>      ) <span>=&gt;</span> <span>StateModel</span> state <span>where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span>-- If we think of the system under test as a black box, then commands are the</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span>-- inputs and responses the outputs to the black box.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Command</span><span>  state ::</span> <span>Type</span> <span>-&gt;</span> <span>Type</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Response</span><span> state ::</span> <span>Type</span> <span>-&gt;</span> <span>Type</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span>-- Sometimes a command needs to refer to a previous response, e.g. when a file</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span>-- is opened we get a handle which is later refered to when writing or reading</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span>-- form the file. File handles, and similar constructs, are called references</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span>-- and can be part of commands and responses.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Reference</span><span> state ::</span> <span>Type</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Reference</span> state <span>=</span> <span>Void</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span>-- Not all commands are valid in all states. Pre-conditions allow the user to</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span>-- specify when a command is safe to execute, for example we cannot write or</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  <span>-- read to or from an unopened file. The `PreconditionFailure` data type</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span>-- allows the user to create custom pre-condition failures. By default now</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span>-- pre-condition failures are allowed, thus the `Void` (empty) type.</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>PreconditionFailure</span><span> state ::</span> <span>Type</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>PreconditionFailure</span> state <span>=</span> <span>Void</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span>  generateCommand ::</span> state <span>-&gt;</span> <span>Gen</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)))</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span>  shrinkCommand ::</span> state <span>-&gt;</span> <span>Command</span> state (<span>Var</span> (<span>Reference</span> state))</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>                <span>-&gt;</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))]</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _state _cmd <span>=</span> []</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span>  initialState ::</span> state</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span>  runFake ::</span> <span>Command</span> state (<span>Var</span> (<span>Reference</span> state)) <span>-&gt;</span> state</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>          <span>-&gt;</span> <span>Either</span> (<span>PreconditionFailure</span> state)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>                    (state, <span>Response</span> state (<span>Var</span> (<span>Reference</span> state)))</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span>  runReal ::</span> <span>Command</span> state (<span>Reference</span> state)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>          <span>-&gt;</span> <span>CommandMonad</span> state (<span>Response</span> state (<span>Reference</span> state))</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a><span>  monitoring ::</span> (state, state)</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>             <span>-&gt;</span> <span>Command</span> state (<span>Reference</span> state)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>             <span>-&gt;</span> <span>Response</span> state (<span>Reference</span> state)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>             <span>-&gt;</span> <span>Property</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>  monitoring _states _cmd _resp <span>=</span> <span>id</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a><span>  commandName ::</span> (<span>Show</span> (<span>Command</span> state ref), <span>Show</span> ref)</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>              <span>=&gt;</span> <span>Command</span> state ref <span>-&gt;</span> <span>String</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>  commandName <span>=</span> <span>head</span> <span>.</span> <span>words</span> <span>.</span> <span>show</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>  <span>-- Most often the result of executing a command against the system under test</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>  <span>-- will live in the IO monad, but sometimes it can be useful to be able a</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>  <span>-- choose another monad.</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>CommandMonad</span><span> state ::</span> <span>Type</span> <span>-&gt;</span> <span>Type</span></span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>CommandMonad</span> state <span>=</span> <span>IO</span></span></code></pre></div>
<p>The interface is parametrised by a <code>state</code> type that the
user needs to define before instantiating the interface. In the counter
example <code>state</code> is
<code>newtype Counter = Counter Int</code>. The user needs to provide an
<code>initialState :: state</code> from which we’ll start generating
commands and executing the model, in the counter case this is
<code>Counter 0</code>.</p>
<p>As part of the instantiating the user also needs to specify a type of
<code>Command</code>s and <code>Response</code>s, these were the
<code>Incr</code> and <code>Get</code> operations of the counter and
their response types respectively.</p>
<p>In addition there’s also three optional types, that we’ve not needed
in the counter example. The first is references, these are used to refer
to previously created resources. For example if we open a file handle on
a POSIX-like file system, then later commands need to be able to refer
to that file handle when wanting to write or read from it. The second
datatype is <code>PreconditionFailure</code>, which is used to give a
nice error message when a command is executed in a disallowed state. For
example if we try to read from a file handle that has been closed. The
third data type is <code>CommandMonad</code> which let’s us use a
different monad than <code>IO</code> for executing our commands in.
After we’ve finished with the interface definition we’ll come back to
more examples where we’ll use these optional types, hopefully these
examples will help make things more concrete.</p>
<p>We’ve already seen that the user needs to provide a way to generate
single command, the only thing worth mentioning is that in case our
commands contain references then during generation we only deal with
<code>Var</code>s of references, where
<code>data Var a = Var Int</code>. The reason for this is that we cannot
generate, for example, real file handles (only the operating system
can), so instead we generate “symbolic” references which are just
<code>Int</code>s. Think of these as placeholders for which real
references will be substituted in once the real references are created
during execution.</p>
<p>Shrinking of individual commands is optional and disabled by default,
but as we’ve seen this doesn’t exclude the sequence of commands to be
shrunk. We’ll shall see shortly how that is done in detail.</p>
<p>Next up we got <code>runFake</code> and <code>runReal</code> which
executes a command against the <code>state</code> model and the real
system respectively. Notice how <code>runFake</code> can fail with a
<code>PreconditionFailure</code>, whereas <code>runReal</code> is always
expected to succeed (because if a command fails the precondition check,
then it won’t get generated and hence never reach <code>runReal</code>).
Another difference is that <code>runFake</code> uses symbolic
references, while <code>runReal</code> deals with real references. We’ll
shortly see how this substitution of references works.</p>
<p>Lastly we have two optional functions related to keeping statistics
of generated test cases, which is useful for coverage reporting among
other things. We’ll come back to how these can be used as we look at
more examples after we’ve defined our stateful property-based testing
library.</p>
</section>
<section id="generating-and-shrinking">
<h5><a href="#generating-and-shrinking" title="Generating and shrinking">Generating and shrinking</a></h5>
<p>Once we have our interface we can start writing functions against the
interface. These functions are what the user gets once they implement
the interface. In this section we’ll have a look at generation of
sequences of <code>Commands</code>, which will be the inputs for our
tests, and how to shrink said inputs to produce a minimal
counterexample.</p>
<p>Let’s start by defining <code>Commands</code>, notice that they use
symbolic references (i.e. <code>Var (Reference state)</code>):</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Commands</span> state <span>=</span> <span>Commands</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  {<span> unCommands ::</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))] }</span></code></pre></div>
<p>As mentioned above, when we generate commands we cannot generate real
references, e.g. file handles, thus <code>Var (Reference state)</code>
is used which is isomorphic to just an <code>Int</code>.</p>
<p>Sometimes it’s convenient to split up <code>runFake</code> into two
parts, the first checks if the command is allowed in the current state,
i.e. the precondition holds:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>precondition ::</span> <span>StateModel</span> state</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>             <span>=&gt;</span> state <span>-&gt;</span> <span>Command</span> state (<span>Var</span> (<span>Reference</span> state)) <span>-&gt;</span> <span>Bool</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>precondition s cmd <span>=</span> <span>case</span> runFake cmd s <span>of</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span>Left</span> _  <span>-&gt;</span> <span>False</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span>Right</span> _ <span>-&gt;</span> <span>True</span></span></code></pre></div>
<p>And the second part advances the state:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>nextState ::</span> <span>StateModel</span> state</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>          <span>=&gt;</span> state <span>-&gt;</span> <span>Command</span> state (<span>Var</span> (<span>Reference</span> state)) <span>-&gt;</span> state</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>nextState s cmd <span>=</span> <span>case</span> runFake cmd s <span>of</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span>Right</span> (s&#39;, _) <span>-&gt;</span> s&#39;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span>Left</span> _err <span>-&gt;</span> <span>error</span> <span>&#34;nextState: impossible, we checked for success in precondition&#34;</span></span></code></pre></div>
<p>We assume that we’ll only ever look at the <code>nextState</code>
when the <code>precondition</code> holds.</p>
<p>Using these two functions we can implement QuickCheck’s
<code>Arbitrary</code> type class for <code>Commands</code> which let’s
us generate and shrink <code>Commands</code>:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>StateModel</span> state <span>=&gt;</span> <span>Arbitrary</span> (<span>Commands</span> state) <span>where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span>  arbitrary ::</span> <span>Gen</span> (<span>Commands</span> state)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  arbitrary <span>=</span> <span>Commands</span> <span>&lt;$&gt;</span> genCommands initialState</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span>      genCommands ::</span> <span>StateModel</span> state</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>                  <span>=&gt;</span> state <span>-&gt;</span> <span>Gen</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))]</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>      genCommands s <span>=</span> sized <span>$</span> \n <span>-&gt;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span>let</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>          w <span>=</span> n <span>`div`</span> <span>2</span> <span>+</span> <span>1</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span>in</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>          frequency</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>            [ (<span>1</span>, <span>return</span> [])</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>            , (w, <span>do</span> mcmd <span>&lt;-</span> generateCommand s <span>`suchThatMaybe`</span> precondition s</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>                     <span>case</span> mcmd <span>of</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>                       <span>Nothing</span>  <span>-&gt;</span> <span>return</span> []</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>                       <span>Just</span> cmd <span>-&gt;</span> (cmd <span>:</span>) <span>&lt;$&gt;</span> genCommands (nextState s cmd))</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span>  shrink ::</span> <span>Commands</span> state <span>-&gt;</span> [<span>Commands</span> state]</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  shrink <span>=</span> pruneShrinks <span>.</span> possibleShrinks</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span>      possibleShrinks ::</span> <span>Commands</span> state <span>-&gt;</span> [<span>Commands</span> state]</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>      possibleShrinks <span>=</span> <span>map</span> (<span>Commands</span> <span>.</span> <span>map</span> <span>fst</span>) <span>.</span> shrinkList shrinker</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>                      <span>.</span> withStates initialState <span>.</span> unCommands</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span>where</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>          shrinker (cmd, s) <span>=</span> [ (cmd&#39;, s) <span>|</span> cmd&#39; <span>&lt;-</span> shrinkCommand s cmd ]</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span>          withStates ::</span> <span>StateModel</span> state</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>                     <span>=&gt;</span> state <span>-&gt;</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>                     <span>-&gt;</span> [(<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)), state)]</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>          withStates s0 <span>=</span> go s0 []</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>            <span>where</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>              go _s acc []           <span>=</span> <span>reverse</span> acc</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>              go  s acc (cmd <span>:</span> cmds) <span>=</span> go (nextState s cmd) ((cmd, s) <span>:</span> acc) cmds</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span>      pruneShrinks ::</span> [<span>Commands</span> state] <span>-&gt;</span> [<span>Commands</span> state]</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>      pruneShrinks <span>=</span> coerce <span>.</span> <span>filter</span> (<span>not</span> <span>.</span> <span>null</span>)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>                   <span>.</span> <span>map</span> (go initialState Set.empty [] <span>.</span> unCommands)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        <span>where</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>          go _s _vars acc [] <span>=</span> <span>reverse</span> acc</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>          go  s  vars acc (cmd <span>:</span> cmds)</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>            <span>|</span> <span>not</span> (scopeCheck vars cmd) <span>=</span> go s vars acc cmds</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>            <span>|</span> <span>otherwise</span> <span>=</span> <span>case</span> runFake cmd s <span>of</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>                <span>Left</span> _preconditionFailure <span>-&gt;</span> go s vars acc cmds</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>                <span>Right</span> (s&#39;, resp) <span>-&gt;</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>                  <span>let</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>                    returnedVars <span>=</span> Set.fromList (toList resp)</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>                    vars&#39; <span>=</span> returnedVars <span>`Set.union`</span> vars</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>                  <span>in</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>                    go s&#39; vars&#39; (cmd <span>:</span> acc) cmds</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a><span>scopeCheck ::</span> <span>Foldable</span> (<span>Command</span> state)</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>           <span>=&gt;</span> <span>Set</span> (<span>Var</span> a) <span>-&gt;</span> <span>Command</span> state (<span>Var</span> a) <span>-&gt;</span> <span>Bool</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>scopeCheck varsInScope cmd <span>=</span> usedVars <span>`Set.isSubsetOf`</span> varsInScope</span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>    usedVars <span>=</span> Set.fromList (toList cmd)</span></code></pre></div>
<p>Notice how after shrinking we prune away all commands that don’t pass
the precondition or that are out of scope with respect to symbolic
references.</p>
<p>The intuition here is that as we remove commands from the originally
generated <code>Commands</code> (which all pass their preconditions), we
might have broken some preconditions and pruning simply removes the
commands which we made invalid in the process of shrinking. Similarly we
can have a command that creates a reference that later commands then
depend on, if we during shrinking remove the command that created the
reference then we must also remove the commands that depend on the
reference.</p>
</section>
<section id="running-and-assertion-checking">
<h5><a href="#running-and-assertion-checking" title="Running and assertion checking">Running and assertion
checking</a></h5>
<p>Once we’ve generated <code>Commands</code> we need to execute them
against the model and the real system using <code>runFake</code> and
<code>runReal</code>. In the process of doing so <code>runReal</code>
will produce <code>Reference</code>s that later commands might use, so
we also need to substitute symbolic references for real references.
This, together with coverage statistics bookkeeping, is done in the
<code>runCommands</code> function:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>runCommands ::</span> <span>forall</span> state<span>.</span> <span>StateModel</span> state</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>            <span>=&gt;</span> <span>Commands</span> state <span>-&gt;</span> <span>PropertyM</span> (<span>CommandMonad</span> state) ()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>runCommands (<span>Commands</span> cmds0) <span>=</span> go initialState emptyEnv cmds0</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span>    go ::</span> state <span>-&gt;</span> <span>Env</span> state <span>-&gt;</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>       <span>-&gt;</span> <span>PropertyM</span> (<span>CommandMonad</span> state) ()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    go _state _env [] <span>=</span> <span>return</span> ()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    go  state  env (cmd <span>:</span> cmds) <span>=</span> <span>do</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>      <span>case</span> runFake cmd state <span>of</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> err <span>-&gt;</span> <span>do</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>          monitor (counterexample (<span>&#34;Preconditon failed: &#34;</span> <span>++</span> <span>show</span> err))</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>          assert <span>False</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> (state&#39;, resp) <span>-&gt;</span> <span>do</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>          <span>let</span> name <span>=</span> commandName cmd</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>          monitor (tabulate <span>&#34;Commands&#34;</span> [name] <span>.</span> classify <span>True</span> name)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>          <span>-- Here we substitute all symbolic references for real ones:</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>          <span>let</span> ccmd <span>=</span> <span>fmap</span> (lookupEnv env) cmd</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>          cresp <span>&lt;-</span> run (runReal ccmd)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>          monitor (counterexample (<span>show</span> cmd <span>++</span> <span>&#34; --&gt; &#34;</span> <span>++</span> <span>show</span> cresp))</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>          monitor (monitoring (state, state&#39;) ccmd cresp)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>          <span>-- Here we collect all references from the response and store it in</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>          <span>-- our environment, so that subsequence commands can be substituted.</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>          <span>let</span> refs   <span>=</span> toList cresp</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>              env&#39;   <span>=</span> extendEnv env (<span>zip</span> [sizeEnv env<span>..</span>] refs)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>              cresp&#39; <span>=</span> <span>fmap</span> (lookupEnv env&#39;) resp</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>              ok     <span>=</span> cresp <span>==</span> cresp&#39;</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>          unless ok <span>$</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            monitor (counterexample (<span>&#34;Expected: &#34;</span> <span>++</span> <span>show</span> cresp&#39; <span>++</span> <span>&#34;\nGot: &#34;</span> <span>++</span> <span>show</span> cresp))</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>          <span>-- And finally here&#39;s where we assert that the model and the real</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>          <span>-- implementation agree.</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>          assert ok</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>          go state&#39; env&#39; cmds</span></code></pre></div>
<p>Where <code>Env</code> is defined as follows.</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Env</span> state <span>=</span> <span>Env</span> {<span> unEnv ::</span> <span>IntMap</span> (<span>Reference</span> state) }</span></code></pre></div>
<p>That’s all the pieces we need to implement that <code>Counter</code>
example that we saw above, plus some new constructs to deal with
precondition failures and references.</p>
<p>Next let’s have a look at an example where we need preconditions and
references.</p>
</section>
</section>
<section id="example-circular-buffer">
<h4><a href="#example-circular-buffer" title="Example: circular buffer">Example: circular buffer</a></h4>
<p>This example is taken from John’s paper <a href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014).</p>
<section id="software-under-test-1">
<h5><a href="#software-under-test-1" title="Software under test">Software under test</a></h5>
<p>The implementation is written in C and uses two indices which keep
track of the front and back of the queue, this allows us to implement
the queue in a circular fashion. I’ve copied the C code straight from
the paper. In order to test it from Haskell, we’ll use Haskell’s foreign
function interface.</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>typedef</span> <span>struct</span> queue <span>{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span>int</span> <span>*</span>buf<span>;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span>int</span> inp<span>,</span> outp<span>,</span> size<span>;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span>}</span> Queue<span>;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>Queue <span>*</span>new<span>(</span><span>int</span> n<span>)</span> <span>{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span>int</span> <span>*</span>buff <span>=</span> malloc<span>(</span>n<span>*</span><span>sizeof</span><span>(</span><span>int</span><span>));</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  Queue q <span>=</span> <span>{</span>buff<span>,</span><span>0</span><span>,</span><span>0</span><span>,</span>n<span>};</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  Queue <span>*</span>qptr <span>=</span> malloc<span>(</span><span>sizeof</span><span>(</span>Queue<span>));</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span>*</span>qptr <span>=</span> q<span>;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span>return</span> qptr<span>;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span>void</span> put<span>(</span>Queue <span>*</span>q<span>,</span> <span>int</span> n<span>)</span> <span>{</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  q<span>-&gt;</span>buf<span>[</span>q<span>-&gt;</span>inp<span>]</span> <span>=</span> n<span>;</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  q<span>-&gt;</span>inp <span>=</span> <span>(</span>q<span>-&gt;</span>inp <span>+</span> <span>1</span><span>)</span> <span>%</span> q<span>-&gt;</span>size<span>;</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span>int</span> get<span>(</span>Queue <span>*</span>q<span>)</span> <span>{</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>  <span>int</span> ans <span>=</span> q<span>-&gt;</span>buf<span>[</span>q<span>-&gt;</span>outp<span>];</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>  q<span>-&gt;</span>outp <span>=</span> <span>(</span>q<span>-&gt;</span>outp <span>+</span> <span>1</span><span>)</span> <span>%</span> q<span>-&gt;</span>size<span>;</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ans<span>;</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span>int</span> size<span>(</span>Queue <span>*</span>q<span>)</span> <span>{</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>(</span>q<span>-&gt;</span>inp <span>-</span> q<span>-&gt;</span>outp<span>)</span> <span>%</span> q<span>-&gt;</span>size<span>;</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Notice that the C code doesn’t do any error checking, e.g. if we
<code>get</code> from an empty queue then we’ll get back uninitialised
memory.</p>
</section>
<section id="model-1">
<h5><a href="#model-1" title="Model">Model</a></h5>
<p>The circular buffer implementation is efficient, because it reuses
the allocated memory as we go around in circles, but it’s not obviously
correct.</p>
<p>To model queues we’ll use a more straight forward non-circular
implementation. This is less efficient (doesn’t matter as it’s merely
used during testing), but hopefully more obviously correct.</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>FQueue</span> <span>=</span> <span>FQueue</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  {<span> fqElems ::</span> [<span>Int</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  ,<span> fqSize  ::</span> <span>Int</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>In the <code>Counter</code> example above we only had one counter, so
the model was merely a single integer. In this example, because of
<code>new</code> returning a queue, we need to be able to model
arbitrary many queues. We can do this using symbolic references
(<code>data Var a = Var Int</code>) as follows:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>State</span> <span>=</span> <span>Map</span> (<span>Var</span> <span>Queue</span>) <span>FQueue</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span>emptyState ::</span> <span>State</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>emptyState <span>=</span> Map.empty</span></code></pre></div>
<p>Where <code>Queue</code> is the Haskell data type that corresponds to
the C <code>Queue</code> and the <code>Var a</code> data type is
provided by the library and is a symbolic reference to <code>a</code>
(just an <code>Int</code>eger). The idea being that in the model we
don’t have access to real <code>Queue</code>s, merely symbolic
references to them. This might seem a bit strange, but I hope that it
will become more clear when we model <code>new</code>.</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>FakeOp</span> a <span>=</span> <span>State</span> <span>-&gt;</span> <span>Either</span> <span>Err</span> (<span>State</span>, a)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span>fNew ::</span> <span>Int</span> <span>-&gt;</span> <span>FakeOp</span> (<span>Var</span> <span>Queue</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>fNew sz s <span>=</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span>let</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    v  <span>=</span> <span>Var</span> (Map.size s)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    s&#39; <span>=</span> Map.insert v (<span>FQueue</span> [] sz) s</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span>in</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> (s&#39;, v)</span></code></pre></div>
<p>As we have access to the state when defining our model, we can create
new unique symbolic references by simply counting how many symbolic
references we’ve created previously (using <code>Map.size</code>)<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>As we said before, in the C code we don’t do any error checking. In
the model we do check that, for example, the queue is non-empty before
we <code>fGet</code> an item. These are our preconditions.</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Err</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>QueueDoesNotExist</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>QueueIsEmpty</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Show</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span>fPut ::</span> <span>Var</span> <span>Queue</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>FakeOp</span> ()</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>fPut q i s</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span>|</span> q <span>`Map.notMember`</span> s <span>=</span> <span>Left</span> <span>QueueDoesNotExist</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span> <span>=</span> <span>return</span> (Map.adjust (\fq <span>-&gt;</span> fq { fqElems <span>=</span> fqElems fq <span>++</span> [i] }) q s, ())</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span>fGet ::</span> <span>Var</span> <span>Queue</span> <span>-&gt;</span> <span>FakeOp</span> <span>Int</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>fGet q s</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span>|</span> q <span>`Map.notMember`</span> s <span>=</span> <span>Left</span> <span>QueueDoesNotExist</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span> <span>=</span> <span>case</span> fqElems (s <span>Map.!</span> q) <span>of</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>      []     <span>-&gt;</span> <span>Left</span> <span>QueueIsEmpty</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>      i <span>:</span> is <span>-&gt;</span> <span>return</span> (Map.adjust (\fq <span>-&gt;</span> fq { fqElems <span>=</span> is }) q s, i)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span>fSize ::</span> <span>Var</span> <span>Queue</span> <span>-&gt;</span> <span>FakeOp</span> <span>Int</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>fSize q s</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>  <span>|</span> q <span>`Map.notMember`</span> s <span>=</span> <span>Left</span> <span>QueueDoesNotExist</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span>           <span>=</span> <span>return</span> (s, <span>length</span> (fqElems (s <span>Map.!</span> q)))</span></code></pre></div>
<p>Recall that we won’t generate a get operation unless the precondition
holds in the state that we are currently in, i.e. we will never generate
gets if the queue is empty and thus we’ll never execute the C code for
<code>get</code> which gives back uninitialised memory.</p>
<p>Having defined our model the interface implementation is almost
mechanical.</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>StateModel</span> <span>State</span> <span>where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  initialState <span>=</span> Map.empty</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Reference</span> <span>State</span> <span>=</span> <span>Queue</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>PreconditionFailure</span> <span>State</span> <span>=</span> <span>Err</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Command</span> <span>State</span> q</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>New</span> <span>Int</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Put</span> q <span>Int</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Get</span> q</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Size</span> q</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Show</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Response</span> <span>State</span> q</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>New_</span> q</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Put_</span> ()</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Get_</span> <span>Int</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Size_</span> <span>Int</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Eq</span>, <span>Show</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>  generateCommand s</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span>|</span> Map.null s <span>=</span> <span>New</span> <span>.</span> getPositive <span>&lt;$&gt;</span> arbitrary</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>otherwise</span>  <span>=</span> oneof</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>      [ <span>New</span> <span>.</span> getPositive <span>&lt;$&gt;</span> arbitrary</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>      , <span>Put</span>  <span>&lt;$&gt;</span> arbitraryQueue <span>&lt;*&gt;</span> arbitrary</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>      , <span>Get</span>  <span>&lt;$&gt;</span> arbitraryQueue</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a><span>      arbitraryQueue ::</span> <span>Gen</span> (<span>Var</span> <span>Queue</span>)</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>      arbitraryQueue <span>=</span> elements (Map.keys s)</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _s (<span>New</span> i)   <span>=</span> [ <span>New</span> i&#39;   <span>|</span> <span>Positive</span> i&#39; <span>&lt;-</span> shrink (<span>Positive</span> i) ]</span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _s (<span>Put</span> q i) <span>=</span> [ <span>Put</span> q i&#39; <span>|</span> i&#39; <span>&lt;-</span> shrink i ]</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _s _cmd <span>=</span> []</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>  runFake (<span>New</span> sz)  s <span>=</span> <span>fmap</span> <span>New_</span>  <span>&lt;$&gt;</span> fNew sz s</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>  runFake (<span>Put</span> q i) s <span>=</span> <span>fmap</span> <span>Put_</span>  <span>&lt;$&gt;</span> fPut q i s</span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>  runFake (<span>Get</span> q)   s <span>=</span> <span>fmap</span> <span>Get_</span>  <span>&lt;$&gt;</span> fGet q s</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>  runFake (<span>Size</span> q)  s <span>=</span> <span>fmap</span> <span>Size_</span> <span>&lt;$&gt;</span> fSize q s</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>  <span>-- Here `new`, `put`, `get` and `size` are FFI wrappers for their respective C</span></span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>  <span>-- functions.</span></span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>  runReal (<span>New</span> sz)  <span>=</span> <span>New_</span>  <span>&lt;$&gt;</span> new sz</span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>  runReal (<span>Put</span> q i) <span>=</span> <span>Put_</span>  <span>&lt;$&gt;</span> put q i</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>  runReal (<span>Get</span> q)   <span>=</span> <span>Get_</span>  <span>&lt;$&gt;</span> get q</span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>  runReal (<span>Size</span> q)  <span>=</span> <span>Size_</span> <span>&lt;$&gt;</span> size q</span></code></pre></div>
<p>The only new thing worth paying attention to is the <code>q</code> in
<code>Command</code> and <code>Response</code>, which is parametrised so
that it works for both symbolic and real references. The
<code>Functor</code> instance lets us do substitution, while
<code>Foldable</code> lets us extract all new references from a
response, so that we can substitute them in later
<code>Command</code>s.</p>
</section>
<section id="testing">
<h5><a href="#testing" title="Testing">Testing</a></h5>
<p>Having implemented the interface, we can write our property as
follows.</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span>prop_queue ::</span> <span>Commands</span> <span>State</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>prop_queue cmds <span>=</span> monadicIO <span>$</span> <span>do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  assert <span>True</span></span></code></pre></div>
<p>When we run it, using <code>quickCheck prop_queue</code>, we get the
following error.</p>
<pre><code>   *** Failed! Assertion failed (after 7 tests and 5 shrinks):
    Commands {unCommands = [New 1,Put (Var 0) 0,Put (Var 0) 1,Get (Var 0)]}
    New 1 --&gt; New_ (Queue 0x00000000016e9010)
    Put (Var 0) 0 --&gt; Put_ ()
    Put (Var 0) 1 --&gt; Put_ ()
    Get (Var 0) --&gt; Get_ 1
    Expected: Get_ 0
    Got: Get_ 1</code></pre>
<p>So we create a new queue of size <code>1</code>, put two items
(<code>0</code> and <code>1</code>) into it, and finally we read a value
from the queue and this is where the assertion fails. Or model returns
<code>0</code>, because it’s a FIFO queue, but the C code returns
<code>1</code>. The reason for this is that in the C code there’s no
error checking, so writing a value to a full queue simply overwrites the
oldest value. So there’s actually nothing wrong with the implementation,
but rather the model is wrong. We’ve forgotten a precondition:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a> data Err</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>   = QueueDoesNotExist</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>   | QueueIsEmpty</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span>+  | QueueIsFull</span></span></code></pre></div>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>fPut :: Var Queue -&gt; Int -&gt; State -&gt; Either Err (State, ())</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>fPut q i s</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  | q `Map.notMember` s = Left QueueDoesNotExist</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span>+ | length (fqElems (s Map.! q)) &gt;= fqSize (s Map.! q) = Left QueueIsFull</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  | otherwise = return (Map.adjust (\fq -&gt; fq { fqElems = fqElems fq ++ [i] }) q s, ())</span></code></pre></div>
<p>We can add the counterexample that we got as a regression test to our
test suite as follows:</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span>unit_queueFull ::</span> <span>IO</span> ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>unit_queueFull <span>=</span> quickCheck (withMaxSuccess <span>1</span> (expectFailure (prop_queue cmds)))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    cmds <span>=</span> <span>Commands</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>      [ <span>New</span> <span>1</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>      , <span>Put</span> (<span>Var</span> <span>0</span>) <span>1</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>      , <span>Put</span> (<span>Var</span> <span>0</span>) <span>0</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>      , <span>Get</span> (<span>Var</span> <span>0</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>Notice that we can basically copy-paste <code>cmds</code> from
QuickCheck’s output, but I’ve done some formatting here to make it more
readable.</p>
<p>After fixing the precondition for <code>fPut</code>,
<code>unit_queueFull</code> fails as follows:</p>
<pre><code>+++ OK, failed as expected. Assertion failed (after 1 test):
New 1 --&gt; New_ (Queue 0x00000000006f6d20)
Put (Var 0) 1 --&gt; Put_ ()
Preconditon failed: QueueIsFull</code></pre>
<p>When we rerun <code>quickCheck prop_queue</code> we will not generate
this example again, because all preconditions need to hold, and the
property passes:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
+++ OK, passed 100 tests:
95% New
86% Put
67% Get

Commands (2497 in total):
44.13% New
41.25% Put
14.62% Get</code></pre>
<p>However as we can see in the output there’s no coverage for
<code>Size</code>! The reason for this is because we’ve forgot to add it
to our generator:</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  generateCommand s</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    | Map.null s = New . getPositive &lt;$&gt; arbitrary</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    | otherwise  = oneof</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>      [ New . getPositive &lt;$&gt; arbitrary</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>      , Put  &lt;$&gt; arbitraryQueue &lt;*&gt; arbitrary</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>      , Get  &lt;$&gt; arbitraryQueue</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span>+     , Size &lt;$&gt; arbitraryQueue</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>After adding it and rerunning the property, we get the following
error:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
*** Failed! Assertion failed (after 25 tests and 8 shrinks):
Commands {unCommands = [New 1,Put (Var 0) 0,Size (Var 0)]}
New 1 --&gt; New_ (Queue 0x0000000001444220)
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ 0
Expected: Size_ 1
Got: Size_ 0</code></pre>
<p>Size should return how many items are in the queue, so after we put
one item into a queue we expect it to return <code>1</code>, but in the
above counterexample it returns <code>0</code>.</p>
<p>To understand why this happens we have to look at how
<code>put</code> and <code>size</code> are implemented:</p>
<div id="cb39"><pre><code><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span>void</span> put<span>(</span>Queue <span>*</span>q<span>,</span> <span>int</span> n<span>)</span> <span>{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  q<span>-&gt;</span>buf<span>[</span>q<span>-&gt;</span>inp<span>]</span> <span>=</span> n<span>;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  q<span>-&gt;</span>inp <span>=</span> <span>(</span>q<span>-&gt;</span>inp <span>+</span> <span>1</span><span>)</span> <span>%</span> q<span>-&gt;</span>size<span>;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span>int</span> size<span>(</span>Queue <span>*</span>q<span>)</span> <span>{</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>(</span>q<span>-&gt;</span>inp <span>-</span> q<span>-&gt;</span>outp<span>)</span> <span>%</span> q<span>-&gt;</span>size<span>;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>In <code>put</code> when we do
<code>q-&gt;inp = (q-&gt;inp + 1) % q-&gt;size</code> we get
<code>q-&gt;inp = (0 + 1) % 1 == 0</code> and then when we calculate the
<code>size</code> we get <code>(0 - 0) % 1 == 0</code>. One way to fix
this is to make <code>q-&gt;size</code> be <code>n + 1</code> rather
than <code>n</code> where <code>n</code> is the size parameter of
<code>new</code>, that way <code>put</code> will do
<code>q-&gt;inp = (0 + 1) % 2 == 1</code> instead and size will be
<code>1 - 0 % 2 == 1</code> which is correct. Here’s the diff:</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>  Queue *new(int n) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span>-   int *buff = malloc(n*sizeof(int));</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span>-   Queue q = {buff,0,0,n};</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span>+   int *buff = malloc((n + 1)*sizeof(int));</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span>+   Queue q = {buff,0,0,n + 1};</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    Queue *qptr = malloc(sizeof(Queue));</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    *qptr = q;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    return qptr;</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As before, we can add a regression test for the size issue as
follows:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span>unit_queueSize ::</span> <span>IO</span> ()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>unit_queueSize <span>=</span> quickCheck (withMaxSuccess <span>1</span> (prop_queue cmds))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    cmds <span>=</span> <span>Commands</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>      [ <span>New</span> <span>1</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>      , <span>Put</span> (<span>Var</span> <span>0</span>) <span>0</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>      , <span>Size</span> (<span>Var</span> <span>0</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>After the change to <code>new</code> this test passes, but if we
rerun the property we get the following error:</p>
<pre><code>*** Failed! Assertion failed (after 38 tests and 12 shrinks):
Commands {unCommands = [New 1,Put (Var 0) 0,Get (Var 0),Put (Var 0) 0,Size (Var 0)]}
New 1 --&gt; New_ (Queue 0x00007fd47c00a920)
Put (Var 0) 0 --&gt; Put_ ()
Get (Var 0) --&gt; Get_ 0
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ (-1)
Expected: Size_ 1
Got: Size_ (-1)</code></pre>
<p>After the second <code>put</code> we’ll have
<code>q-&gt;inp = (1 + 1) % 2 == 0</code> while
<code>q-&gt;outp = 1</code> due to the <code>get</code> and so when we
call <code>size</code> we get <code>0 - 1 % 2 == -1</code>. Taking the
absolute value:</p>
<div id="cb43"><pre><code><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  int size(Queue *q) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span>-   return (q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span>+   return abs(q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Makes this test case pass, and in fact it also makes the property
pass:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
+++ OK, passed 100 tests:
93% New
79% Put
74% Size
59% Get

Commands (2340 in total):
32.09% New
29.06% Size
28.25% Put
10.60% Get</code></pre>
<p>John says that at this point most programmers would probably be happy
and believe that their implementation works, but if we rerun it again
(or increase the amount of tests generated), we get:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
*** Failed! Assertion failed (after 56 tests and 19 shrinks):
Commands {unCommands = [New 2,Put (Var 0) 0,Put (Var 0) 0,Get (Var 0),Put (Var 0) 0,Size (Var 0)]}
New 2 --&gt; New_ (Queue 0x00007fbf4c006490)
Put (Var 0) 0 --&gt; Put_ ()
Put (Var 0) 0 --&gt; Put_ ()
Get (Var 0) --&gt; Get_ 0
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ 1
Expected: Size_ 2
Got: Size_ 1</code></pre>
<p>We can see that all queues of size <code>1</code> now work, because
this test starts by creating a queue of size <code>2</code>, so we’ve
made progress. But taking the absolute value isn’t the correct way to
calculate the size (even though it works for queues of size
<code>1</code>), the following is the correct way to do it:</p>
<div id="cb46"><pre><code><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>  int size(Queue *q) {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span>-   return abs(q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span>+   return (q-&gt;inp - q-&gt;outp + q-&gt;size) % q-&gt;size;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>With this final tweak, the property passes. I hope that this somewhat
long example gives you a feel for how property-based testing drives the
development and debugging of the code.</p>
</section>
</section>
<section id="example-jug-puzzle-from-die-hard-3">
<h4><a href="#example-jug-puzzle-from-die-hard-3" title="Example: jug puzzle from Die Hard 3">Example: jug puzzle from Die
Hard 3</a></h4>
<p>In the movie Die Hard 3 there’s a <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg">scene</a> where Bruce
Willis and Samuel L. Jackson have to solve a puzzle in order to stop a
bomb from going off. The puzzle is: given a 3L and a 5L jug, how can you
measure exactly 4L?</p>
<p>I first saw this example solved using TLA+ and I wanted to include it
here because it shows that we don’t necessarily need a real
implementation, merely running the model/fake can be useful.</p>
<p>The main idea is to model the two jugs and all actions we can do with
them and then throw an exception when the big jug contains 4L. This will
fail the test and output the shrunk sequence of actions that resulted in
the failure, giving us the solution to the puzzle.</p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Model</span> <span>=</span> <span>Model</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  {<span> bigJug   ::</span> <span>Int</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  ,<span> smallJug ::</span> <span>Int</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Show</span>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>StateModel</span> <span>Model</span> <span>where</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  initialState <span>=</span> <span>Model</span> <span>0</span> <span>0</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Reference</span> <span>Model</span> <span>=</span> <span>Void</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Command</span> <span>Model</span> r</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>FillBig</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>FillSmall</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>EmptyBig</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>EmptySmall</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>SmallIntoBig</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>BigIntoSmall</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Show</span>, <span>Enum</span>, <span>Bounded</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Response</span> <span>Model</span> r <span>=</span> <span>Done</span> <span>|</span> <span>BigJugIs4</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Eq</span>, <span>Show</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a><span>  generateCommand ::</span> <span>Model</span> <span>-&gt;</span> <span>Gen</span> (<span>Command</span> <span>Model</span> r)</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>  generateCommand _s <span>=</span> elements [<span>minBound</span> <span>..</span>]</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a><span>  runFake ::</span> <span>Command</span> <span>Model</span> r <span>-&gt;</span> <span>Model</span> <span>-&gt;</span> <span>Either</span> void (<span>Model</span>, <span>Response</span> <span>Model</span> r)</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>  runFake <span>FillBig</span>      s <span>=</span> done s { bigJug   <span>=</span> <span>5</span> }</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>  runFake <span>FillSmall</span>    s <span>=</span> done s { smallJug <span>=</span> <span>3</span> }</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>  runFake <span>EmptyBig</span>     s <span>=</span> done s { bigJug   <span>=</span> <span>0</span> }</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>  runFake <span>EmptySmall</span>   s <span>=</span> done s { smallJug <span>=</span> <span>0</span> }</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>  runFake <span>SmallIntoBig</span> (<span>Model</span> big small) <span>=</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    <span>let</span> big&#39; <span>=</span> <span>min</span> <span>5</span> (big <span>+</span> small) <span>in</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>    done (<span>Model</span> { bigJug <span>=</span> big&#39;</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>                , smallJug <span>=</span> small <span>-</span> (big&#39; <span>-</span> big) })</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>  runFake <span>BigIntoSmall</span> (<span>Model</span> big small) <span>=</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>    <span>let</span> small&#39; <span>=</span> <span>min</span> <span>3</span> (big <span>+</span> small) <span>in</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>    done (<span>Model</span> { bigJug <span>=</span> big <span>-</span> (small&#39; <span>-</span> small)</span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>                , smallJug <span>=</span> small&#39;</span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a><span>  runReal ::</span> <span>Command</span> <span>Model</span> <span>Void</span> <span>-&gt;</span> <span>IO</span> (<span>Response</span> <span>Model</span> (<span>Reference</span> <span>Model</span>))</span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>  runReal _cmd <span>=</span> <span>return</span> <span>Done</span></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a><span>  monitoring ::</span> (<span>Model</span>, <span>Model</span>) <span>-&gt;</span> <span>Command</span> <span>Model</span> <span>Void</span> <span>-&gt;</span> <span>Response</span> <span>Model</span> <span>Void</span></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a>             <span>-&gt;</span> <span>Property</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>  monitoring (_s, s&#39;) _cmd _resp <span>=</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>    counterexample <span>$</span> <span>&#34;\n    State: &#34;</span> <span>++</span> <span>show</span> s&#39; <span>++</span> <span>&#34;\n&#34;</span></span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a><span>done ::</span> <span>Model</span> <span>-&gt;</span> <span>Either</span> void (<span>Model</span>, <span>Response</span> <span>Model</span> ref)</span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a>done s&#39; <span>|</span> bigJug s&#39; <span>==</span> <span>4</span> <span>=</span> <span>return</span> (s&#39;, <span>BigJugIs4</span>)</span>
<span id="cb47-53"><a href="#cb47-53" aria-hidden="true" tabindex="-1"></a>        <span>|</span> <span>otherwise</span>      <span>=</span> <span>return</span> (s&#39;, <span>Done</span>)</span>
<span id="cb47-54"><a href="#cb47-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-55"><a href="#cb47-55" aria-hidden="true" tabindex="-1"></a><span>prop_dieHard ::</span> <span>Commands</span> <span>Model</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb47-56"><a href="#cb47-56" aria-hidden="true" tabindex="-1"></a>prop_dieHard cmds <span>=</span> withMaxSuccess <span>10000</span> <span>$</span> monadicIO <span>$</span> <span>do</span></span>
<span id="cb47-57"><a href="#cb47-57" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb47-58"><a href="#cb47-58" aria-hidden="true" tabindex="-1"></a>  assert <span>True</span></span></code></pre></div>
<p>When we run <code>quickcheck prop_dieHard</code> we get the following
output:</p>
<pre><code>   +++ OK, failed as expected. Assertion failed (after 199 tests and 11 shrinks):
    Commands [FillBig,BigIntoSmall,EmptySmall,BigIntoSmall,FillBig,BigIntoSmall]
    FillBig --&gt; Done

        State: Model {bigJug = 5, smallJug = 0}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 2, smallJug = 3}

    EmptySmall --&gt; Done

        State: Model {bigJug = 2, smallJug = 0}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 0, smallJug = 2}

    FillBig --&gt; Done

        State: Model {bigJug = 5, smallJug = 2}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 4, smallJug = 3}

    Expected: BigJugIs4
    Got: Done</code></pre>
<p>Notice how the trace shows the intermediate states, making it easy to
verify that it’s indeed a correct solution to the puzzle<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
</section>
</section>
<section id="parallel-property-based-testing">
<h3><a href="#parallel-property-based-testing" title="Parallel property-based testing">Parallel property-based
testing</a></h3>
<p>Let’s now turn our focus to parallel property-based testing.</p>
<p>Debugging buggy concurrent code is not fun. The main reason for this
is that the threads interleave in different ways between executions,
making it hard to reproduce the bug and hard to verify that a bug fix
actually worked.</p>
<p>Ideally we’d like to make working with concurrent code as pleasant as
the sequential stateful case and without the user having to write any
additional test code. In order to explain how we can achieve this, we
need to first understand how we can test concurrent code in a
reproducible way.</p>
<p>Recall our <code>Counter</code> that we looked at in the sequential
testing case. Here we’ll be using a slight generalisation where the
<code>incr</code> takes an integer parameter which specifies by how much
we want to increment (instead of always incrementing by
<code>1</code>).</p>
<p>When we interact with the counter sequentially, i.e. one command at
the time, then it appears to count correctly:</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> incr <span>1</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> incr <span>2</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> get</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span>3</span></span></code></pre></div>
<p>If we instead concurrently issue the <code>incr</code>ements, we see
something strange:</p>
<div id="cb50"><pre><code><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a> <span>&gt;</span> forM_ [<span>0</span><span>..</span><span>100000</span>] <span>$</span> \i <span>-&gt;</span> <span>do</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a> <span>&gt;</span>   c <span>&lt;-</span> newCounter</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a> <span>&gt;</span>   concurrently_ (incr c <span>1</span>) (incr c <span>2</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a> <span>&gt;</span>   x <span>&lt;-</span> get c</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a> <span>&gt;</span>   <span>if</span> x <span>==</span> <span>3</span> <span>then</span> <span>return</span> () <span>else</span> <span>error</span> (<span>&#34;i = &#34;</span> <span>++</span> <span>show</span> i <span>++</span> <span>&#34;, x = &#34;</span> <span>++</span> <span>show</span> x)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a> <span>***</span> <span>Exception</span><span>:</span> i <span>=</span> <span>29768</span>, x <span>=</span> <span>1</span></span></code></pre></div>
<p>After 29768 iterations we get back <code>1</code> rather than the
expected <code>3</code>! The reason for this is because there’s a race
condition in the implementation of <code>incr</code>:</p>
<div id="cb51"><pre><code><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a> incr i <span>=</span> <span>do</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>   j <span>&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>   writeIORef gLOBAL_COUNTER (i <span>+</span> j)</span></code></pre></div>
<p>Because we first read the old value and <em>then</em> write the new
incremented value in an non-atomic way, it’s possible that if two
threads do this at the same time they overwrite each others increment.
For example, consider the interleaving:</p>
<pre><code>   thread 1, incr 1     |  thread 2, incr 2
   ---------------------+------------------
    0 &lt;- readIORef      |
                        | 0 &lt;- readIORef
                        | writeIORef (2 + 0)
    writeIORef (1 + 0)  |
                        |
                        v
                       time</code></pre>
<p>If we read from the counter after the two increments are done we get
<code>1</code> instead of the expected <code>3</code>. The fix to this
problem is to do an atomic update using <code>atomicModifyIORef&#39;</code>,
instead of first reading and then writing to the <code>IORef</code>.</p>
<p>The concurrent test that we just wrote is not only specific to the
counter example but also only uses three fixed commands, the two
concurrent <code>incr</code>ements followed by a <code>get</code>. While
it was enough to find this race condition, in general we’d like to try
arbitrary combinations of commands and possibly involving more than two
threads.</p>
<p>The key concept we need in order to accomplish that is that of
<em>concurrent history</em>, which is perhaps easiest to explain in
terms of a more familiar concept: a sequence diagram.</p>
<p>Consider the following sequence diagram:</p>
<p><img src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/sequence-diagram.svg" width="60%"/></p>
<p>Here we see that the first and second thread concurrently increment,
the first thread then reads the counter concurrently with the second
thread’s increment that’s still going on. The second thread’s increment
finishes and a third thread does a read which is concurrent with the
first thread’s read.</p>
<p>We can abstract away the arrows and merely focus on the intervals of
the commands:</p>
<p><img src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/history-from-sequence-diagram.svg" width="60%"/></p>
<p>If we rotate the intervals we get the concurrent history:</p>
<p><img src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter.svg" width="60%"/></p>
<p>Note that the execution of some commands overlap in time, this is
what’s meant by concurrent and arguably it’s easier to see the overlap
here than in the original sequence diagram.</p>
<p>We’ve also abstracted away the counter, it’s a black box from the
perspective of the threads. The only thing we know for sure is when we
invoked the operation and when it returned, which is what our interval
captures. We also know that the effect of the operation must have
happened sometime within that interval.</p>
<p>One such concurrent history can have different interleavings,
depending on when exactly the effect of the commands happen. Here are
two possible interleavings, where the red cross symbolises when the
effect happened (i.e. when exactly the counter update its state).</p>
<p>The first corresponds to the sequential history
<code>&lt; incr 1, get, incr 2, get &gt;</code>:</p>
<p><img src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter_get_1_3.svg" width="60%"/></p>
<p>and the other interleaving corresponds to the sequential history
<code>&lt; incr 1, incr 2, get, get &gt;</code>:</p>
<p><img src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter_get_3_3.svg" width="60%"/></p>
<p>One last thing we’ve left out from the concurrent history so far is
the responses. In this example, the only interesting responses are those
of the <code>get</code>s.</p>
<p>Let’s say that the <code>get</code>s returned <code>1</code> and
<code>3</code> respectively. Is this a correct concurrent outcome? Yes,
according to linearisability it’s enough to find a single interleaving
for which the sequential state machine model can explain the outcome and
in this case the first interleaving above
<code>&lt; incr 1, get, incr 2, get &gt;</code> does that.</p>
<p>What if the <code>get</code>s both returned <code>3</code>? That’s
also correct and witnessed by the second interleaving
<code>&lt; incr 1, incr 2, get, get &gt;</code>. When we can find a
sequential interleaving that supports the outcome of a concurrent
execution we say that the concurrent history linearises.</p>
<p>If the <code>get</code> on the third thread returned <code>1</code>
or <code>2</code> however, then it would be a non-linearisable outcome.
We can see visually that that <code>get</code> happens after both
<code>incr</code>, so no matter where we choose to place the red crosses
on the <code>incr</code>s the effects will happen before that
<code>get</code> so it must return <code>3</code>. Is it even possible
that <code>1</code> or <code>2</code> are returned? It’s, imagine if
<code>incr</code> is implemented by first reading the current value then
storing the incremented value, in that case there can be a race where
the <code>incr</code>s overwrite each other.</p>
<p>So to summarise, we execute commands concurrently using several
threads and gather a concurrent history of the execution. We then try to
find a sequential interleaving (a choice of where the red crosses in the
diagrams should be) which respects the a sequential state machine model
specification. If we find a single one that does, then we say that the
history linearises and that the concurrent execution is correct, if we
cannot find a sequential interleaving that respects the model then the
history doesn’t linearise and we have found a problem.</p>
<section id="parallel-library-implementation">
<h4><a href="#parallel-library-implementation" title="Parallel library implementation">Parallel library
implementation</a></h4>
<p>Let’s try to implement the above. We’ll split up the implementation
in three parts. First, we’ll show how to generate and shrink parallel
commands, these will be different than the sequential commands as we
have more than one thread that does the execution. Second, we’ll have a
look at how to execute the generated parallel commands to produce a
concurrent history. Finally, we’ll implement linearisability checking by
trying to find an interleaving of the concurrent history which respects
the sequential model.</p>
<section id="parallel-program-generation-and-shrinking">
<h5><a href="#parallel-program-generation-and-shrinking" title="Parallel program generation and shrinking">Parallel program
generation and shrinking</a></h5>
<p>First we need define what a parallel program is:</p>
<div id="cb53"><pre><code><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>ParallelCommands</span> state <span>=</span> <span>ParallelCommands</span> [<span>Fork</span> state]</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Fork</span> state <span>=</span> <span>Fork</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))]</span></code></pre></div>
<p>The idea is that the commands inside <code>Fork</code>s get executed
in parallel, this list will only be between one and three commands long,
i.e. capturing single, double or triple threaded execution. The amount
of <code>Fork</code>s themselves vary with the size of the test case,
just like when we were doing the sequential testing.</p>
<p>Depending on the order in which the commands in the
<code>Fork</code>s get executed, we can potentially get different
models. For example
<code>Fork [Write &#34;a&#34; &#34;foo&#34;, Write &#34;a&#34; &#34;bar&#34;]</code>, depending on which
branch of the <code>Fork</code> gets executed first we might end up with
either <code>&#34;foo&#34;</code> or <code>&#34;bar&#34;</code> being written to
<code>&#34;a&#34;</code>.</p>
<p>Because of this, we have generalised generation and shrinking to work
on a set of states rather than just a single state:</p>
<div id="cb54"><pre><code><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span>class</span> (<span>StateModel</span> state, <span>Ord</span> state) <span>=&gt;</span> <span>ParallelModel</span> state <span>where</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span>  generateCommandParallel ::</span> [state] <span>-&gt;</span> <span>Gen</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)))</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  generateCommandParallel ss <span>=</span> <span>do</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    s <span>&lt;-</span> elements ss</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    generateCommand s</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span>  shrinkCommandParallel ::</span> [state] <span>-&gt;</span> <span>Command</span> state (<span>Var</span> (<span>Reference</span> state))</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                        <span>-&gt;</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))]</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  shrinkCommandParallel ss cmd <span>=</span> shrinkCommand (<span>maximum</span> ss) cmd</span></code></pre></div>
<p>Notice that the default implementation for generation, which should
be good enough for most examples, picks an arbitrary state and reuses
the generation function from the sequential case. Similar shrinking
picks the biggest state (determined by the <code>Ord</code> instance) as
the default implementation. The user is able to override these defaults,
in case generation or shrinking depends on some more specific state.</p>
<p>We can now write a generator for parallel programs.</p>
<div id="cb55"><pre><code><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span>  arbitrary ::</span> <span>Gen</span> (<span>ParallelCommands</span> state)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  arbitrary <span>=</span> <span>ParallelCommands</span> <span>&lt;$&gt;</span> go [initialState]</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span>      go ::</span> [state] <span>-&gt;</span> <span>Gen</span> [<span>Fork</span> state]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>      go ss <span>=</span> sized <span>$</span> \n <span>-&gt;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span>let</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>          w <span>=</span> n <span>`div`</span> <span>2</span> <span>+</span> <span>1</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span>in</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>          frequency</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>            [ (<span>1</span>, <span>return</span> [])</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>            , (w, <span>do</span> k <span>&lt;-</span> frequency [ (<span>50</span>, <span>return</span> <span>1</span>) <span>-- 50% single threaded</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>                                    , (<span>30</span>, <span>return</span> <span>2</span>) <span>-- 30% double threaded</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>                                    , (<span>20</span>, <span>return</span> <span>3</span>) <span>-- 20% triple threaded</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>                                    ]</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>                     mCmds <span>&lt;-</span> vectorOf k (generateCommandParallel ss)</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>                                <span>`suchThatMaybe`</span> (parallelSafe ss <span>.</span> <span>Fork</span>)</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>                     <span>case</span> mCmds <span>of</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>                       <span>Nothing</span>   <span>-&gt;</span> <span>return</span> []</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>                       <span>Just</span> cmds <span>-&gt;</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>                         (<span>Fork</span> cmds <span>:</span>) <span>&lt;$&gt;</span> go (nextStates ss cmds))</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>            ]</span></code></pre></div>
<p>Where <code>nextStates</code> gives all potential next states and is
defined as follows.</p>
<div id="cb56"><pre><code><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span>nextStates ::</span> (<span>StateModel</span> state, <span>Ord</span> state)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>           <span>=&gt;</span> [state] <span>-&gt;</span> [<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))] <span>-&gt;</span> [state]</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>nextStates ss cmds <span>=</span> nubOrd [ foldl&#39; nextState s cmds <span>|</span> s <span>&lt;-</span> ss ]</span></code></pre></div>
<p>The other helper function that we need for generation is
<code>parallelSafe</code>, which requires a bit of background.</p>
<p>In the sequential case a precondition is a contract that needs to be
fulfilled by the client before the command is issued. In the parallel
case there are multiple clients, so it could be the case that one client
unknowingly breaks another clients precondition. For example
<code>Fork [Write &#34;a&#34; &#34;foo&#34;, Delete &#34;a&#34;]</code>, where the precondition
for both commands is that <code>&#34;a&#34;</code> exists. If
<code>Delete</code> gets executed first then it would break
<code>Write</code>’s precondition.</p>
<p>The solution to the precondition problem is to check that they hold
in all possible interleavings of a <code>Fork</code>, which is what
<code>parallelSafe</code> does:</p>
<div id="cb57"><pre><code><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span>parallelSafe ::</span> <span>ParallelModel</span> state <span>=&gt;</span> [state] <span>-&gt;</span> <span>Fork</span> state <span>-&gt;</span> <span>Bool</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>parallelSafe ss (<span>Fork</span> cmds0) <span>=</span> <span>and</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  [ preconditionsHold s cmds <span>|</span> s <span>&lt;-</span> toList ss, cmds <span>&lt;-</span> permutations cmds0 ]</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    preconditionsHold s0 <span>=</span> <span>all</span> (go s0) <span>.</span> permutations</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>      <span>where</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        go _s [] <span>=</span> <span>True</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        go  s (cmd <span>:</span> cmds)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>          <span>|</span> precondition s cmd <span>=</span> go (nextState s cmd) cmds</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>          <span>|</span> <span>otherwise</span>          <span>=</span> <span>False</span></span></code></pre></div>
<p>While shrinking we also use <code>parallelSafe</code>:</p>
<div id="cb58"><pre><code><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span>  shrink ::</span> <span>ParallelCommands</span> state <span>-&gt;</span> [<span>ParallelCommands</span> state]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  shrink <span>=</span> pruneShrinks <span>.</span> possibleShrinks</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span>      possibleShrinks ::</span> <span>ParallelCommands</span> state <span>-&gt;</span> [<span>ParallelCommands</span> state]</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>      possibleShrinks</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span>=</span> <span>map</span> (coerce <span>.</span> <span>map</span> (<span>map</span> <span>fst</span>))</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        <span>.</span> shrinkList (shrinkList shrinker) <span>.</span> withParStates <span>.</span> unParallelCommands</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>        <span>where</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span>          withParStates ::</span> (<span>StateModel</span> state, <span>Ord</span> state)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>                        <span>=&gt;</span> [<span>Fork</span> state]</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>                        <span>-&gt;</span> [[(<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)), [state])]]</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>          withParStates <span>=</span> go [initialState] [] <span>.</span> coerce</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>            <span>where</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>              go _ss acc []             <span>=</span> <span>reverse</span> acc</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>              go  ss acc (cmds <span>:</span> cmdss) <span>=</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>                go (nextStates ss cmds) (<span>map</span> (\cmd <span>-&gt;</span> (cmd, ss)) cmds <span>:</span> acc) cmdss</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a><span>          shrinker ::</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)), [state])</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>                   <span>-&gt;</span> [(<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)), [state])]</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>          shrinker (cmd, ss) <span>=</span> [ (cmd&#39;, ss) <span>|</span> cmd&#39; <span>&lt;-</span> shrinkCommandParallel ss cmd ]</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a><span>      pruneShrinks ::</span> [<span>ParallelCommands</span> state] <span>-&gt;</span> [<span>ParallelCommands</span> state]</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>      pruneShrinks <span>=</span> coerce <span>.</span> <span>filter</span> (<span>not</span> <span>.</span> <span>null</span>)</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>                   <span>.</span> <span>map</span> (go [initialState] Set.empty [] <span>.</span> unParallelCommands)</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>        <span>where</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a><span>          go ::</span> [state] <span>-&gt;</span> <span>Set</span> (<span>Var</span> (<span>Reference</span> state)) <span>-&gt;</span> [<span>Fork</span> state] <span>-&gt;</span> [<span>Fork</span> state] <span>-&gt;</span> [<span>Fork</span> state]</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>          go _ss _vars acc [] <span>=</span> <span>reverse</span> acc</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>          go  ss  vars acc (fork<span>@</span>(<span>Fork</span> cmds) <span>:</span> forks)</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>            <span>|</span> <span>all</span> (scopeCheck vars) cmds</span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>            , parallelSafe ss fork <span>=</span></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>              <span>let</span></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>                ss&#39;   <span>=</span> nextStates ss cmds</span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>                vars&#39; <span>=</span> getReturnedVars (<span>head</span> ss) vars cmds <span>-- </span><span>NOTE</span><span>: head is safe</span></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>              <span>in</span></span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>                go ss&#39; vars&#39; (fork <span>:</span> acc) forks</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>            <span>|</span> <span>otherwise</span>            <span>=</span> go ss vars acc forks</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>          <span>-- It doesn&#39;t matter which of the possible states we start in, as all</span></span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a>          <span>-- commands in a fork pass their preconditions in all states. It also</span></span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a>          <span>-- doesn&#39;t matter in which interleaving we gather the responses, as</span></span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a>          <span>-- all we do is collect the `Var`s that get returned into an unordered</span></span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a>          <span>-- `Set`.</span></span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a>          getReturnedVars _s vars [] <span>=</span> vars</span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a>          getReturnedVars s vars (cmd <span>:</span> cmds) <span>=</span> <span>case</span> runFake cmd s <span>of</span></span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a>            <span>Left</span> _preconditionFailed <span>-&gt;</span></span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>              <span>error</span> <span>&#34;getReturnedVars: impossible, parallelSafe checks that all preconditions hold&#34;</span></span>
<span id="cb58-47"><a href="#cb58-47" aria-hidden="true" tabindex="-1"></a>            <span>Right</span> (_s&#39;, resp) <span>-&gt;</span></span>
<span id="cb58-48"><a href="#cb58-48" aria-hidden="true" tabindex="-1"></a>              getReturnedVars s (vars <span>`Set.union`</span> Set.fromList (toList resp)) cmds</span></code></pre></div>
<p>In addition we also check that shrinking doesn’t create any scoping
issues, i.e. if we remove a command which creates a symbolic variable we
also need to remove any fork that contains a command which uses said
symbolic variable.</p>
<p>Another option is to skip the scope checking and instead require the
user to explicitly require preconditions which ensure the scope<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
</section>
<section id="parallel-running">
<h5><a href="#parallel-running" title="Parallel running">Parallel
running</a></h5>
<p>One final difference between the sequential and the parallel case is
that because of the use of threads to achieve parallel execution, and
the fact we can only spawn threads of things of type <code>IO</code>, we
also need to be able to interpret our <code>CommandMonad</code> into
<code>IO</code>, which is what <code>runCommandMonad</code> (which is
also part of the <code>ParallelModel</code> type class) does.</p>
<div id="cb59"><pre><code><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>  <span>-- If another command monad is used we need to provide a way run it inside the</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span>-- IO monad. This is only needed for parallel testing, because IO is the only</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span>-- monad we can execute on different threads.</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span>  runCommandMonad ::</span> proxy state <span>-&gt;</span> <span>CommandMonad</span> state a <span>-&gt;</span> <span>IO</span> a</span></code></pre></div>
<p>We can now implement parallel execution of commands as follows:</p>
<div id="cb60"><pre><code><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>History</span> state <span>=</span> <span>History</span> [<span>Event</span> state]</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span>deriving</span> stock <span>instance</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>   (<span>Show</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))),</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span>Show</span> (<span>Response</span> state (<span>Reference</span> state))) <span>=&gt;</span> <span>Show</span> (<span>History</span> state)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Event</span> state</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Invoke</span> <span>Pid</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)))</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Ok</span>     <span>Pid</span> (<span>Response</span> state (<span>Reference</span> state))</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span>deriving</span> stock <span>instance</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>  (<span>Show</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state))),</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>   <span>Show</span> (<span>Response</span> state (<span>Reference</span> state))) <span>=&gt;</span> <span>Show</span> (<span>Event</span> state)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Pid</span> <span>=</span> <span>Pid</span> <span>Int</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> stock (<span>Eq</span>, <span>Ord</span>, <span>Show</span>)</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> <span>Enum</span></span></code></pre></div>
<div id="cb61"><pre><code><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span>runParallelCommands ::</span> <span>forall</span> state<span>.</span> <span>ParallelModel</span> state</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>                    <span>=&gt;</span> <span>ParallelCommands</span> state <span>-&gt;</span> <span>PropertyM</span> <span>IO</span> ()</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>runParallelCommands cmds0<span>@</span>(<span>ParallelCommands</span> forks0) <span>=</span> <span>do</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  forM_ (parallelCommands cmds0) <span>$</span> \cmd <span>-&gt;</span> <span>do</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span>let</span> name <span>=</span> commandName cmd</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    monitor (tabulate <span>&#34;Commands&#34;</span> [name] <span>.</span> classify <span>True</span> name)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  monitor (tabulate <span>&#34;Concurrency&#34;</span> (<span>map</span> (<span>show</span> <span>.</span> <span>length</span> <span>.</span> unFork) forks0))</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  q   <span>&lt;-</span> liftIO newTQueueIO</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  c   <span>&lt;-</span> liftIO newAtomicCounter</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  env <span>&lt;-</span> liftIO (runForks q c emptyEnv forks0)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  hist <span>&lt;-</span> <span>History</span> <span>&lt;$&gt;</span> liftIO (atomically (flushTQueue q))</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>  <span>let</span> ok <span>=</span> linearisable env (interleavings hist)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  unless ok (monitor (counterexample (<span>show</span> hist)))</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  assert ok</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a><span>    runForks ::</span> <span>TQueue</span> (<span>Event</span> state) <span>-&gt;</span> <span>AtomicCounter</span> <span>-&gt;</span> <span>Env</span> state <span>-&gt;</span> [<span>Fork</span> state]</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>             <span>-&gt;</span> <span>IO</span> (<span>Env</span> state)</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    runForks _q _c env [] <span>=</span> <span>return</span> env</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    runForks  q  c env (<span>Fork</span> cmds <span>:</span> forks) <span>=</span> <span>do</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>      envs <span>&lt;-</span> liftIO <span>$</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>        mapConcurrently (runParallelReal q c env) (<span>zip</span> [<span>Pid</span> <span>0</span><span>..</span>] cmds)</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>      <span>let</span> env&#39; <span>=</span> combineEnvs (env <span>:</span> envs)</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>      runForks q c env&#39; forks</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a><span>    runParallelReal ::</span> <span>TQueue</span> (<span>Event</span> state) <span>-&gt;</span> <span>AtomicCounter</span> <span>-&gt;</span> <span>Env</span> state</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>                    <span>-&gt;</span> (<span>Pid</span>, <span>Command</span> state (<span>Var</span> (<span>Reference</span> state))) <span>-&gt;</span> <span>IO</span> (<span>Env</span> state)</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>    runParallelReal q c env (pid, cmd) <span>=</span> <span>do</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>      atomically (writeTQueue q (<span>Invoke</span> pid cmd))</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>      eResp <span>&lt;-</span> try (runCommandMonad (<span>Proxy</span><span> ::</span> <span>Proxy</span> state) (runReal (<span>fmap</span> (lookupEnv env) cmd)))</span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>      <span>case</span> eResp <span>of</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> (<span>err ::</span> <span>SomeException</span>) <span>-&gt;</span></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>          <span>error</span> (<span>&#34;runParallelReal: &#34;</span> <span>++</span> displayException err)</span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> resp <span>-&gt;</span> <span>do</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>          <span>-- </span><span>NOTE</span><span>: It&#39;s important that we extend the environment before writing `Ok`</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>          <span>-- to the history, otherwise we might get scope issues.</span></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>          env&#39; <span>&lt;-</span> extendEnvParallel env c (toList resp)</span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>          atomically (writeTQueue q (<span>Ok</span> pid resp))</span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>          <span>return</span> env&#39;</span></code></pre></div>
<p>Extending the environment in the parallel case requires an atomic
counter in order to avoid more than one thread adding the same
variable:</p>
<div id="cb62"><pre><code><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>AtomicCounter</span> <span>=</span> <span>AtomicCounter</span> (<span>IORef</span> <span>Int</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span>newAtomicCounter ::</span> <span>IO</span> <span>AtomicCounter</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>newAtomicCounter <span>=</span> <span>AtomicCounter</span> <span>&lt;$&gt;</span> newIORef <span>0</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span>-- Returns old value.</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span>incrAtomicCounter ::</span> <span>AtomicCounter</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> <span>Int</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>incrAtomicCounter (<span>AtomicCounter</span> ioRef) n <span>=</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>  atomicModifyIORef&#39; ioRef (\old <span>-&gt;</span> (old <span>+</span> n, old))</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span>extendEnvParallel ::</span> <span>Env</span> state <span>-&gt;</span> <span>AtomicCounter</span> <span>-&gt;</span> [<span>Reference</span> state] <span>-&gt;</span> <span>IO</span> (<span>Env</span> state)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>extendEnvParallel env c refs <span>=</span> <span>do</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>  i <span>&lt;-</span> incrAtomicCounter c (<span>length</span> refs)</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (extendEnv env (<span>zip</span> [i<span>..</span>] refs))</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a><span>combineEnvs ::</span> [<span>Env</span> state] <span>-&gt;</span> <span>Env</span> state</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>combineEnvs <span>=</span> <span>Env</span> <span>.</span> IntMap.unions <span>.</span> <span>map</span> unEnv</span></code></pre></div>
<p>Hopefully the execution part is clear, next let’s have a look at how
we check the result of an execution.</p>
</section>
<section id="linearisability-checking">
<h5><a href="#linearisability-checking" title="Linearisability checking">Linearisability checking</a></h5>
<p>Recall from our parallel counter example in the introduction to
parallel testing that it’s enough to find <em>any</em> possible
interleaving which respects the sequential model. So let’s start by
enumerating all possible interleavings using a <a href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Tree.html"><code>Rose</code>
tree</a> data structure:</p>
<div id="cb63"><pre><code><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Op</span> state <span>=</span> <span>Op</span> (<span>Command</span> state (<span>Var</span> (<span>Reference</span> state)))</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                   (<span>Response</span> state (<span>Reference</span> state))</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span>interleavings ::</span> <span>History</span> state <span>-&gt;</span> <span>Forest</span> (<span>Op</span> state)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>interleavings (<span>History</span> [])  <span>=</span> []</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>interleavings (<span>History</span> evs0) <span>=</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  [ <span>Node</span> (<span>Op</span> cmd resp) (interleavings (<span>History</span> evs&#39;))</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>  <span>|</span> (tid, cmd)   <span>&lt;-</span> takeInvocations evs0</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>  , (resp, evs&#39;) <span>&lt;-</span> findResponse tid</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                      (filter1 (<span>not</span> <span>.</span> matchInvocation tid) evs0)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span>    takeInvocations ::</span> [<span>Event</span> state] <span>-&gt;</span> [(<span>Pid</span>, <span>Command</span> state (<span>Var</span> (<span>Reference</span> state)))]</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>    takeInvocations []                         <span>=</span> []</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>    takeInvocations ((<span>Invoke</span> pid cmd)   <span>:</span> evs) <span>=</span> (pid, cmd) <span>:</span> takeInvocations evs</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    takeInvocations ((<span>Ok</span>    _pid _resp) <span>:</span> _)   <span>=</span> []</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span>    findResponse ::</span> <span>Pid</span> <span>-&gt;</span> [<span>Event</span> state] <span>-&gt;</span> [(<span>Response</span> state (<span>Reference</span> state), [<span>Event</span> state])]</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    findResponse _pid []                                   <span>=</span> []</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    findResponse  pid ((<span>Ok</span> pid&#39; resp) <span>:</span> evs) <span>|</span> pid <span>==</span> pid&#39; <span>=</span> [(resp, evs)]</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>    findResponse  pid (ev             <span>:</span> evs)               <span>=</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>      [ (resp, ev <span>:</span> evs&#39;) <span>|</span> (resp, evs&#39;) <span>&lt;-</span> findResponse pid evs ]</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a><span>    matchInvocation ::</span> <span>Pid</span> <span>-&gt;</span> <span>Event</span> state <span>-&gt;</span> <span>Bool</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>    matchInvocation pid (<span>Invoke</span> pid&#39; _cmd) <span>=</span> pid <span>==</span> pid&#39;</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>    matchInvocation _   _                  <span>=</span> <span>False</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a><span>    filter1 ::</span> (a <span>-&gt;</span> <span>Bool</span>) <span>-&gt;</span> [a] <span>-&gt;</span> [a]</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>    filter1 _ []                   <span>=</span> []</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>    filter1 p (x <span>:</span> xs) <span>|</span> p x       <span>=</span> x <span>:</span> filter1 p xs</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>                       <span>|</span> <span>otherwise</span> <span>=</span> xs</span></code></pre></div>
<p>We can then check if there is a path through this rose tree which
agrees with the sequential model:</p>
<div id="cb64"><pre><code><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span>linearisable ::</span> <span>forall</span> state<span>.</span> <span>StateModel</span> state</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>             <span>=&gt;</span> <span>Env</span> state <span>-&gt;</span> <span>Forest</span> (<span>Op</span> state) <span>-&gt;</span> <span>Bool</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>linearisable env <span>=</span> any&#39; (go initialState)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span>    go ::</span> state <span>-&gt;</span> <span>Tree</span> (<span>Op</span> state) <span>-&gt;</span> <span>Bool</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    go s (<span>Node</span> (<span>Op</span> cmd cresp) ts) <span>=</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>      <span>case</span> runFake cmd s <span>of</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> _preconditionFailure <span>-&gt;</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>          <span>error</span> <span>&#34;linearisable: impossible, all precondtions are satisifed during generation&#34;</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> (s&#39;, resp) <span>-&gt;</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>          cresp <span>==</span> <span>fmap</span> (lookupEnv env) resp <span>&amp;&amp;</span> any&#39; (go s&#39;) ts</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span>    any&#39; ::</span> (a <span>-&gt;</span> <span>Bool</span>) <span>-&gt;</span> [a] <span>-&gt;</span> <span>Bool</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    any&#39; _p [] <span>=</span> <span>True</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    any&#39;  p xs <span>=</span> <span>any</span> p xs</span></code></pre></div>
</section>
</section>
<section id="example-parallel-counter">
<h4><a href="#example-parallel-counter" title="Example: parallel counter">Example: parallel counter</a></h4>
<p>Having defined the <code>ParallelModel</code> interface (which
depends on the <code>StateModel</code> interface from the sequential
testing) and programmed our parallel generation, shrinking and parallel
execution and linearisability checking against this interface, we
basically get parallel testing for free by reusing the sequential
model.</p>
<section id="testing-1">
<h5><a href="#testing-1" title="Testing">Testing</a></h5>
<p>This is the only new code we need to add to enable parallel testing
of our <code>Counter</code> example<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> from before:</p>
<div id="cb65"><pre><code><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>ParallelModel</span> <span>Counter</span> <span>where</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span>-- The command monad is IO, so we don&#39;t need to do anything here.</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  runCommandMonad _ <span>=</span> <span>id</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span>prop_parallelCounter ::</span> <span>ParallelCommands</span> <span>Counter</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>prop_parallelCounter cmds <span>=</span> monadicIO <span>$</span> <span>do</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span>10</span> <span>$</span> <span>do</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    run reset</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    runParallelCommands cmds</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  assert <span>True</span></span></code></pre></div>
<p>If we run the above property with <code>runReal</code></p>
<div id="cb66"><pre><code><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>  runReal <span>Incr</span> <span>=</span> <span>Incr_</span> <span>&lt;$&gt;</span> incrRaceCondition</span></code></pre></div>
<p>being implemented using an increment with a race condition:</p>
<div id="cb67"><pre><code><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span>incrRaceCondition ::</span> <span>IO</span> ()</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>incrRaceCondition <span>=</span> <span>do</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  n <span>&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span>+</span> <span>1</span>)</span></code></pre></div>
<p>then a failure is found:</p>
<pre><code> Assertion failed (after 36 tests and 1 shrink):
      ParallelCommands [Fork [Incr,Incr],Fork [Incr],Fork [Get,Get,Get],
                        Fork [Incr],Fork [Get,Get],Fork [Get,Get],
                        Fork [Incr],Fork [Get,Get,Incr],Fork [Incr],
                        Fork [Get,Get,Get],Fork [Incr,Incr],
                        Fork [Incr,Get],Fork [Incr,Incr],Fork [Get],
                        Fork [Incr]]</code></pre>
<p>However, shrinking didn’t work well. The reason for this is that
QuickCheck tries a smaller test case (which still has the race
condition), but because of a different interleaving of threads the race
doesn’t get triggered and so QuickCheck thinks it found the minimal test
case (because the smaller test case, that the shrinker picked,
passes).</p>
<p>The proper solution to this problem is to use a deterministic thread
scheduler, this is what they do the parallel testing <a href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf">paper</a>.
A simpler workaround is to introduce a small sleep after each read or
write to shared memory, this will make it more likely that the same
interleaving happens when we shrink the test:</p>
<div id="cb69"><pre><code><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span>incrRaceCondition ::</span> <span>IO</span> ()</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>incrRaceCondition <span>=</span> <span>do</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  n <span>&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  threadDelay <span>100</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span>+</span> <span>1</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  threadDelay <span>100</span></span></code></pre></div>
<p>With this change we get the minimal test case that triggers the race
condition:</p>
<pre><code>Assertion failed (after 6 tests and 4 shrinks):
      ParallelCommands [Fork [Incr,Incr],Fork [Get]]</code></pre>
<p>We can avoid having to sprinkle sleeps around our interaction with
shared state by creating a module with the same operations as on shared
memory where the sleep is already included:</p>
<div id="cb71"><pre><code><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span>module</span> <span>SleepyIORef</span> (<span>module</span> <span>SleepyIORef</span>, <span>IORef</span>) <span>where</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Control.Concurrent</span> (threadDelay)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.IORef</span> (<span>IORef</span>)</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>qualified</span> <span>Data.IORef</span> <span>as</span> <span>IORef</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span>readIORef ::</span> <span>IORef</span> a <span>-&gt;</span> <span>IO</span> a</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>readIORef ref <span>=</span> <span>do</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>  threadDelay <span>1000</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>  IORef.readIORef ref</span></code></pre></div>
<p>That way if we find a race, we can change the import from
<code>import Data.IORef</code> to <code>import SleepyIORef</code> and
rerun the tests and get better shrinking. This situation is not ideal,
but save us the trouble of having to re-implement a scheduler. It’s
worth stressing that the race is found in the unmodified code and the
introduction of sleep is only needed to make the counterexample
smaller.</p>
</section>
</section>
<section id="example-process-registry">
<h4><a href="#example-process-registry" title="Example: process registry">Example: process registry</a></h4>
<p>For a slightly more complicated example containing race conditions,
let’s have a look at an implementation of the Erlang process registry<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<section id="software-under-test-2">
<h5><a href="#software-under-test-2" title="Software under test">Software under test</a></h5>
<p>The idea behind Erlang’s process registry is that you can spawn
threads, register the <code>ThreadId</code> to some name of type string,
and then lookup the thread by name rather than its thread id. Threads
can also be unregistered and killed.</p>
<p>This is useful if threads die and get restarted and register the same
name, then other threads can easily find the thread id of the new thread
using the registry.</p>
<div id="cb72"><pre><code><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span>{-# NOINLINE registry #-}</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span>registry ::</span> <span>IORef</span> [(<span>String</span>,<span>ThreadId</span>)]</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>registry <span>=</span> unsafePerformIO (newIORef [])</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span>alive ::</span> <span>ThreadId</span> <span>-&gt;</span> <span>IO</span> <span>Bool</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>alive tid <span>=</span> <span>do</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  s <span>&lt;-</span> threadStatus tid</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>$</span> s <span>/=</span> <span>ThreadFinished</span> <span>&amp;&amp;</span> s <span>/=</span> <span>ThreadDied</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span>spawn ::</span> <span>IO</span> <span>ThreadId</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>spawn <span>=</span> forkIO (threadDelay <span>100000000</span>)</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span>whereis ::</span> <span>String</span> <span>-&gt;</span> <span>IO</span> (<span>Maybe</span> <span>ThreadId</span>)</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>whereis name <span>=</span> <span>do</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  reg <span>&lt;-</span> readRegistry</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>$</span> <span>lookup</span> name reg</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a><span>register ::</span> <span>String</span> <span>-&gt;</span> <span>ThreadId</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>register name tid <span>=</span> <span>do</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>  ok <span>&lt;-</span> alive tid</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>  reg <span>&lt;-</span> readRegistry</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>  <span>if</span> ok <span>&amp;&amp;</span> name <span>`notElem`</span> <span>map</span> <span>fst</span> reg <span>&amp;&amp;</span> tid <span>`notElem`</span> <span>map</span> <span>snd</span> reg</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    <span>then</span> <span>do</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef registry <span>$</span> \reg&#39; <span>-&gt;</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>           <span>if</span> name <span>`notElem`</span> <span>map</span> <span>fst</span> reg&#39; <span>&amp;&amp;</span> tid <span>`notElem`</span> <span>map</span> <span>snd</span> reg&#39;</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>             <span>then</span> ((name,tid)<span>:</span>reg&#39;,())</span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>             <span>else</span> (reg&#39;,badarg)</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    <span>else</span> badarg</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a><span>unregister ::</span> <span>String</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>unregister name <span>=</span> <span>do</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  reg <span>&lt;-</span> readRegistry</span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  <span>if</span> name <span>`elem`</span> <span>map</span> <span>fst</span> reg</span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>    <span>then</span> atomicModifyIORef registry <span>$</span> \reg&#39; <span>-&gt;</span></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>           (<span>filter</span> ((<span>/=</span>name)<span>.</span><span>fst</span>) reg&#39;,</span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a>            ())</span>
<span id="cb72-37"><a href="#cb72-37" aria-hidden="true" tabindex="-1"></a>    <span>else</span> badarg</span>
<span id="cb72-38"><a href="#cb72-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-39"><a href="#cb72-39" aria-hidden="true" tabindex="-1"></a><span>readRegistry ::</span> <span>IO</span> [(<span>String</span>, <span>ThreadId</span>)]</span>
<span id="cb72-40"><a href="#cb72-40" aria-hidden="true" tabindex="-1"></a>readRegistry <span>=</span> <span>do</span></span>
<span id="cb72-41"><a href="#cb72-41" aria-hidden="true" tabindex="-1"></a>  reg <span>&lt;-</span> readIORef registry</span>
<span id="cb72-42"><a href="#cb72-42" aria-hidden="true" tabindex="-1"></a>  garbage <span>&lt;-</span> filterM (<span>fmap</span> <span>not</span><span>.</span>alive) (<span>map</span> <span>snd</span> reg)</span>
<span id="cb72-43"><a href="#cb72-43" aria-hidden="true" tabindex="-1"></a>  atomicModifyIORef&#39; registry <span>$</span> \reg&#39; <span>-&gt;</span></span>
<span id="cb72-44"><a href="#cb72-44" aria-hidden="true" tabindex="-1"></a>    <span>let</span> reg&#39;&#39; <span>=</span> <span>filter</span> ((<span>`notElem`</span> garbage)<span>.</span><span>snd</span>) reg&#39; <span>in</span> (reg&#39;&#39;,reg&#39;&#39;)</span>
<span id="cb72-45"><a href="#cb72-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-46"><a href="#cb72-46" aria-hidden="true" tabindex="-1"></a><span>badarg ::</span> a</span>
<span id="cb72-47"><a href="#cb72-47" aria-hidden="true" tabindex="-1"></a>badarg <span>=</span> <span>error</span> <span>&#34;bad argument&#34;</span></span>
<span id="cb72-48"><a href="#cb72-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-49"><a href="#cb72-49" aria-hidden="true" tabindex="-1"></a><span>kill ::</span> <span>ThreadId</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb72-50"><a href="#cb72-50" aria-hidden="true" tabindex="-1"></a>kill tid <span>=</span> <span>do</span></span>
<span id="cb72-51"><a href="#cb72-51" aria-hidden="true" tabindex="-1"></a>  killThread tid</span>
<span id="cb72-52"><a href="#cb72-52" aria-hidden="true" tabindex="-1"></a>  waitUntilDead <span>1000</span></span>
<span id="cb72-53"><a href="#cb72-53" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb72-54"><a href="#cb72-54" aria-hidden="true" tabindex="-1"></a><span>    waitUntilDead ::</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb72-55"><a href="#cb72-55" aria-hidden="true" tabindex="-1"></a>    waitUntilDead <span>0</span> <span>=</span> <span>error</span> <span>&#34;kill: thread didn&#39;t die&#34;</span></span>
<span id="cb72-56"><a href="#cb72-56" aria-hidden="true" tabindex="-1"></a>    waitUntilDead n <span>=</span> <span>do</span></span>
<span id="cb72-57"><a href="#cb72-57" aria-hidden="true" tabindex="-1"></a>      b <span>&lt;-</span> alive tid</span>
<span id="cb72-58"><a href="#cb72-58" aria-hidden="true" tabindex="-1"></a>      <span>if</span> b</span>
<span id="cb72-59"><a href="#cb72-59" aria-hidden="true" tabindex="-1"></a>      <span>then</span> <span>do</span></span>
<span id="cb72-60"><a href="#cb72-60" aria-hidden="true" tabindex="-1"></a>        threadDelay <span>1000</span></span>
<span id="cb72-61"><a href="#cb72-61" aria-hidden="true" tabindex="-1"></a>        waitUntilDead (n <span>-</span> <span>1</span>)</span>
<span id="cb72-62"><a href="#cb72-62" aria-hidden="true" tabindex="-1"></a>      <span>else</span> <span>return</span> ()</span></code></pre></div>
</section>
<section id="model-2">
<h5><a href="#model-2" title="Model">Model</a></h5>
<p>The model of the process registry contains three things that we
haven’t seen before. The first thing to note is that
<code>Register</code> and <code>Unregister</code> might fail, so we use
an <code>Either ErrorCall</code> in their respective responses and a
function called <code>abstractError</code> to make the error from the
model and the error from the real implementation match up. It’s called
abstract, because it abstracts away details from the real
implementation, and it’s a useful technique to know as it can be applied
to other settings.</p>
<p>The second thing to notice is the use of <code>monitoring</code> to
keep statistics of how often <code>Register</code> and
<code>Unregister</code> actually do fail, this is useful coverage
information that ensures that our generators and or pre-conditions are
not too restrictive.</p>
<div id="cb73"><pre><code><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>RegState</span> <span>=</span> <span>RegState</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  {<span> tids   ::</span> [<span>Var</span> <span>ThreadId</span>]</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  ,<span> regs   ::</span> [(<span>String</span>, <span>Var</span> (<span>ThreadId</span>))]</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  ,<span> killed ::</span> [<span>Var</span> <span>ThreadId</span>]</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Ord</span>, <span>Show</span>)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>StateModel</span> <span>RegState</span> <span>where</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span>  initialState ::</span> <span>RegState</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  initialState <span>=</span> <span>RegState</span> [] [] []</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Reference</span> <span>RegState</span> <span>=</span> <span>ThreadId</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Command</span> <span>RegState</span> tid</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>Spawn</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>WhereIs</span> <span>String</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Register</span> <span>String</span> tid</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Unregister</span> <span>String</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Kill</span> tid</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Show</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>  <span>data</span> <span>Response</span> <span>RegState</span> tid</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>Spawn_</span> tid</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>WhereIs_</span> (<span>NonFoldable</span> (<span>Maybe</span> tid))</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Register_</span> (<span>Either</span> <span>ErrorCall</span> ())</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Unregister_</span> (<span>Either</span> <span>ErrorCall</span> ())</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>Kill_</span> ()</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>    <span>deriving</span> (<span>Eq</span>, <span>Show</span>, <span>Functor</span>, <span>Foldable</span>)</span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a><span>  generateCommand ::</span> <span>RegState</span> <span>-&gt;</span> <span>Gen</span> (<span>Command</span> <span>RegState</span> (<span>Var</span> <span>ThreadId</span>))</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a>  generateCommand s <span>=</span> oneof <span>$</span></span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>    [ <span>return</span> <span>Spawn</span> ] <span>++</span></span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>    [ <span>Register</span> <span>&lt;$&gt;</span> arbitraryName <span>&lt;*&gt;</span> elements (tids s) <span>|</span> <span>not</span> (<span>null</span> (tids s)) ] <span>++</span></span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>    [ <span>Unregister</span> <span>&lt;$&gt;</span> arbitraryName</span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>    , <span>WhereIs</span> <span>&lt;$&gt;</span> arbitraryName</span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>    ] <span>++</span></span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>    [ <span>Kill</span> <span>&lt;$&gt;</span> elements (tids s) <span>|</span> <span>not</span> (<span>null</span> (tids s)) ]</span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a><span>      arbitraryName ::</span> <span>Gen</span> <span>String</span></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a>      arbitraryName <span>=</span> elements allNames</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a><span>  runFake ::</span> <span>Command</span> <span>RegState</span> (<span>Var</span> <span>ThreadId</span>)<span>-&gt;</span> <span>RegState</span></span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>          <span>-&gt;</span> <span>Either</span> void (<span>RegState</span>, <span>Response</span> <span>RegState</span> (<span>Var</span> <span>ThreadId</span>))</span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a>  runFake <span>Spawn</span>               s <span>=</span> <span>let</span> tid <span>=</span> <span>Var</span> (<span>length</span> (tids s)) <span>in</span></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a>                                  <span>return</span> (s { tids <span>=</span> tids s <span>++</span> [tid] }, <span>Spawn_</span> tid)</span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a>  runFake (<span>WhereIs</span> name)      s <span>=</span> <span>return</span> (s, <span>WhereIs_</span> (<span>NonFoldable</span> (<span>lookup</span> name (regs s))))</span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a>  runFake (<span>Register</span> name tid) s</span>
<span id="cb73-49"><a href="#cb73-49" aria-hidden="true" tabindex="-1"></a>    <span>|</span> tid <span>`elem`</span> tids s</span>
<span id="cb73-50"><a href="#cb73-50" aria-hidden="true" tabindex="-1"></a>    , name <span>`notElem`</span> <span>map</span> <span>fst</span> (regs s)</span>
<span id="cb73-51"><a href="#cb73-51" aria-hidden="true" tabindex="-1"></a>    , tid <span>`notElem`</span> <span>map</span> <span>snd</span> (regs s)</span>
<span id="cb73-52"><a href="#cb73-52" aria-hidden="true" tabindex="-1"></a>    , tid <span>`notElem`</span> killed s</span>
<span id="cb73-53"><a href="#cb73-53" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>return</span> (s { regs <span>=</span> (name, tid) <span>:</span> regs s }, <span>Register_</span> (<span>Right</span> ()))</span>
<span id="cb73-54"><a href="#cb73-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-55"><a href="#cb73-55" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>otherwise</span></span>
<span id="cb73-56"><a href="#cb73-56" aria-hidden="true" tabindex="-1"></a>    <span>=</span> <span>return</span> (s, <span>Register_</span> (<span>Left</span> (<span>ErrorCall</span> <span>&#34;bad argument&#34;</span>)))</span>
<span id="cb73-57"><a href="#cb73-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-58"><a href="#cb73-58" aria-hidden="true" tabindex="-1"></a>  runFake (<span>Unregister</span> name)   s</span>
<span id="cb73-59"><a href="#cb73-59" aria-hidden="true" tabindex="-1"></a>    <span>|</span> name <span>`elem`</span> <span>map</span> <span>fst</span> (regs s) <span>=</span></span>
<span id="cb73-60"><a href="#cb73-60" aria-hidden="true" tabindex="-1"></a>        <span>return</span> (s { regs <span>=</span> remove name (regs s) }, <span>Unregister_</span> (<span>Right</span> ()))</span>
<span id="cb73-61"><a href="#cb73-61" aria-hidden="true" tabindex="-1"></a>    <span>|</span> <span>otherwise</span> <span>=</span> <span>return</span> (s, <span>Unregister_</span> (<span>Left</span> (<span>ErrorCall</span> <span>&#34;bad argument&#34;</span>)))</span>
<span id="cb73-62"><a href="#cb73-62" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb73-63"><a href="#cb73-63" aria-hidden="true" tabindex="-1"></a>      remove x <span>=</span> <span>filter</span> ((<span>/=</span> x) <span>.</span> <span>fst</span>)</span>
<span id="cb73-64"><a href="#cb73-64" aria-hidden="true" tabindex="-1"></a>  runFake (<span>Kill</span> tid) s <span>=</span> <span>return</span> (s { killed <span>=</span> tid <span>:</span> killed s</span>
<span id="cb73-65"><a href="#cb73-65" aria-hidden="true" tabindex="-1"></a>                                   , regs   <span>=</span> remove tid (regs s)}, <span>Kill_</span> ())</span>
<span id="cb73-66"><a href="#cb73-66" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb73-67"><a href="#cb73-67" aria-hidden="true" tabindex="-1"></a>      remove x <span>=</span> <span>filter</span> ((<span>/=</span> x) <span>.</span> <span>snd</span>)</span>
<span id="cb73-68"><a href="#cb73-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-69"><a href="#cb73-69" aria-hidden="true" tabindex="-1"></a><span>  runReal ::</span> <span>Command</span> <span>RegState</span> <span>ThreadId</span> <span>-&gt;</span> <span>IO</span> (<span>Response</span> <span>RegState</span> <span>ThreadId</span>)</span>
<span id="cb73-70"><a href="#cb73-70" aria-hidden="true" tabindex="-1"></a>  runReal <span>Spawn</span>               <span>=</span> <span>Spawn_</span>      <span>&lt;$&gt;</span> spawn</span>
<span id="cb73-71"><a href="#cb73-71" aria-hidden="true" tabindex="-1"></a>  runReal (<span>WhereIs</span> name)      <span>=</span> <span>WhereIs_</span> <span>.</span> <span>NonFoldable</span> <span>&lt;$&gt;</span> whereis name</span>
<span id="cb73-72"><a href="#cb73-72" aria-hidden="true" tabindex="-1"></a>  runReal (<span>Register</span> name tid) <span>=</span> <span>Register_</span>   <span>&lt;$&gt;</span> <span>fmap</span> (left abstractError) (try (register name tid))</span>
<span id="cb73-73"><a href="#cb73-73" aria-hidden="true" tabindex="-1"></a>  runReal (<span>Unregister</span> name)   <span>=</span> <span>Unregister_</span> <span>&lt;$&gt;</span> <span>fmap</span> (left abstractError) (try (unregister name))</span>
<span id="cb73-74"><a href="#cb73-74" aria-hidden="true" tabindex="-1"></a>  runReal (<span>Kill</span> tid)          <span>=</span> <span>Kill_</span>       <span>&lt;$&gt;</span> kill tid</span>
<span id="cb73-75"><a href="#cb73-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-76"><a href="#cb73-76" aria-hidden="true" tabindex="-1"></a><span>  monitoring ::</span> (<span>RegState</span>, <span>RegState</span>) <span>-&gt;</span> <span>Command</span> <span>RegState</span> <span>ThreadId</span></span>
<span id="cb73-77"><a href="#cb73-77" aria-hidden="true" tabindex="-1"></a>             <span>-&gt;</span> <span>Response</span> <span>RegState</span> <span>ThreadId</span> <span>-&gt;</span> <span>Property</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb73-78"><a href="#cb73-78" aria-hidden="true" tabindex="-1"></a>  monitoring (_s, s&#39;) cmd resp <span>=</span></span>
<span id="cb73-79"><a href="#cb73-79" aria-hidden="true" tabindex="-1"></a>    <span>let</span></span>
<span id="cb73-80"><a href="#cb73-80" aria-hidden="true" tabindex="-1"></a>      aux tag <span>=</span> classify <span>True</span> (<span>show</span> tag)</span>
<span id="cb73-81"><a href="#cb73-81" aria-hidden="true" tabindex="-1"></a>              <span>.</span> counterexample (<span>&#34;\n    State: &#34;</span> <span>++</span> <span>show</span> s&#39; <span>++</span> <span>&#34;\n&#34;</span>)</span>
<span id="cb73-82"><a href="#cb73-82" aria-hidden="true" tabindex="-1"></a>    <span>in</span></span>
<span id="cb73-83"><a href="#cb73-83" aria-hidden="true" tabindex="-1"></a>      <span>case</span> (cmd, resp) <span>of</span></span>
<span id="cb73-84"><a href="#cb73-84" aria-hidden="true" tabindex="-1"></a>        (<span>Register</span>   {}, <span>Register_</span>   (<span>Left</span> _))  <span>-&gt;</span> aux <span>RegisterFailed</span></span>
<span id="cb73-85"><a href="#cb73-85" aria-hidden="true" tabindex="-1"></a>        (<span>Register</span>   {}, <span>Register_</span>   (<span>Right</span> _)) <span>-&gt;</span> aux <span>RegisterSucceeded</span></span>
<span id="cb73-86"><a href="#cb73-86" aria-hidden="true" tabindex="-1"></a>        (<span>Unregister</span> {}, <span>Unregister_</span> (<span>Left</span> _))  <span>-&gt;</span> aux <span>UnregisterFailed</span></span>
<span id="cb73-87"><a href="#cb73-87" aria-hidden="true" tabindex="-1"></a>        (<span>Unregister</span> {}, <span>Unregister_</span> (<span>Right</span> _)) <span>-&gt;</span> aux <span>UnregisterSucceeded</span></span>
<span id="cb73-88"><a href="#cb73-88" aria-hidden="true" tabindex="-1"></a>        _otherwise <span>-&gt;</span> counterexample <span>$</span> <span>&#34;\n    State: &#34;</span> <span>++</span> <span>show</span> s&#39; <span>++</span> <span>&#34;\n&#34;</span></span>
<span id="cb73-89"><a href="#cb73-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-90"><a href="#cb73-90" aria-hidden="true" tabindex="-1"></a><span>-- Throws away the location information from the error, so that it matches up</span></span>
<span id="cb73-91"><a href="#cb73-91" aria-hidden="true" tabindex="-1"></a><span>-- with the fake.</span></span>
<span id="cb73-92"><a href="#cb73-92" aria-hidden="true" tabindex="-1"></a><span>abstractError ::</span> <span>ErrorCall</span> <span>-&gt;</span> <span>ErrorCall</span></span>
<span id="cb73-93"><a href="#cb73-93" aria-hidden="true" tabindex="-1"></a>abstractError (<span>ErrorCallWithLocation</span> msg _loc) <span>=</span> <span>ErrorCall</span> msg</span>
<span id="cb73-94"><a href="#cb73-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-95"><a href="#cb73-95" aria-hidden="true" tabindex="-1"></a><span>allNames ::</span> [<span>String</span>]</span>
<span id="cb73-96"><a href="#cb73-96" aria-hidden="true" tabindex="-1"></a>allNames <span>=</span> [<span>&#34;a&#34;</span>, <span>&#34;b&#34;</span>, <span>&#34;c&#34;</span>, <span>&#34;d&#34;</span>, <span>&#34;e&#34;</span>]</span>
<span id="cb73-97"><a href="#cb73-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-98"><a href="#cb73-98" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Tag</span> <span>=</span> <span>RegisterFailed</span> <span>|</span> <span>RegisterSucceeded</span> <span>|</span> <span>UnregisterFailed</span> <span>|</span> <span>UnregisterSucceeded</span></span>
<span id="cb73-99"><a href="#cb73-99" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>Show</span></span></code></pre></div>
<p>The last new thing to note here is that <code>WhereIs_</code> returns
the thread id that we wanted to look up, but thread ids also happen to
be references. The way we implemented extending the environment with new
references is that we call <code>Data.Foldable.toList</code> on all
responses, which gives us all references from the responses. In the
<code>Spawn_</code> case this does the right thing, since spawn returns
a reference to the newly spawned thread id, but in this case the thread
id from <code>WhereIs_</code> is not a new reference (it’s merely a
reference to the thread id we wanted to look up), so we shouldn’t extend
the environment with the reference that <code>WhereIs_</code> returns.
We solve this problem with wrapping the response of
<code>WhereIs_</code> in <code>NonFoldable</code> which has a
<code>toList</code> which doesn’t return anything.</p>
<div id="cb74"><pre><code><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>NonFoldable</span> a <span>=</span> <span>NonFoldable</span> a</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> stock (<span>Eq</span>, <span>Show</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Functor</span> <span>NonFoldable</span> <span>where</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>  <span>fmap</span> f (<span>NonFoldable</span> x) <span>=</span> <span>NonFoldable</span> (f x)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Foldable</span> <span>NonFoldable</span> <span>where</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>  <span>foldMap</span> _f (<span>NonFoldable</span> _x) <span>=</span> <span>mempty</span></span></code></pre></div>
</section>
<section id="testing-2">
<h5><a href="#testing-2" title="Testing">Testing</a></h5>
<p>We can now write our sequential testing property as we’ve done
earlier for the other examples.</p>
<div id="cb75"><pre><code><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span>prop_registry ::</span> <span>Commands</span> <span>RegState</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>prop_registry cmds <span>=</span> monadicIO <span>$</span> <span>do</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>  void (run cleanUp)</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  assert <span>True</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span>cleanUp ::</span> <span>IO</span> [<span>Either</span> <span>ErrorCall</span> ()]</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>cleanUp <span>=</span> <span>sequence</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>  [ try (unregister name)<span> ::</span> <span>IO</span> (<span>Either</span> <span>ErrorCall</span> ())</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>  <span>|</span> name <span>&lt;-</span> allNames</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>This property passes and we can see, thanks to our
<code>monitoring</code>, that we got good coverage of failing commands
as well:</p>
<pre><code>  +++ OK, passed 100 tests:
  83% Spawn
  82% WhereIs
  79% Unregister
  78% UnregisterFailed
  70% Kill
  70% Register
  62% RegisterFailed
  59% RegisterSucceeded
  29% UnregisterSucceeded</code></pre>
<p>To make sure everything works as expected, let’s introduce a bug on
purpose:</p>
<div id="cb77"><pre><code><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>  register :: String -&gt; ThreadId -&gt; IO ()</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  register name tid = do</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    ok &lt;- alive tid</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    reg &lt;- readRegistry</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    if ok &amp;&amp; name `notElem` map fst reg &amp;&amp; tid `notElem` map snd reg</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>      then atomicModifyIORef&#39; registry $ \reg&#39; -&gt;</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>             if name `notElem` map fst reg&#39; &amp;&amp; tid `notElem` map snd reg&#39;</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span>-              then ((name,tid):reg&#39;,())</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a><span>+              then ([(name,tid)],())</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>               else (reg&#39;,badarg)</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>      else badarg</span></code></pre></div>
<p>If we rerun the tests with this bug in place, we get test failures
like the following:</p>
<pre><code>     *** Failed! Assertion failed (after 30 tests and 7 shrinks):
      Commands {unCommands = [Spawn,Spawn,Register &#34;e&#34; (Var 1),Register &#34;d&#34; (Var 0),Unregister &#34;e&#34;]}
      Spawn --&gt; Spawn_ (ThreadId 154)

          State: RegState {tids = [Var 0], regs = [], killed = []}

      Spawn --&gt; Spawn_ (ThreadId 155)

          State: RegState {tids = [Var 0,Var 1], regs = [], killed = []}

      Register &#34;e&#34; (Var 1) --&gt; Register_ (Right ())

          State: RegState {tids = [Var 0,Var 1], regs = [(&#34;e&#34;,Var 1)], killed = []}

      Register &#34;d&#34; (Var 0) --&gt; Register_ (Right ())

          State: RegState {tids = [Var 0,Var 1], regs = [(&#34;d&#34;,Var 0),(&#34;e&#34;,Var 1)], killed = []}

      Unregister &#34;e&#34; --&gt; Unregister_ (Left bad argument)

          State: RegState {tids = [Var 0,Var 1], regs = [(&#34;d&#34;,Var 0)], killed = []}

      Expected: Unregister_ (Right ())
      Got: Unregister_ (Left bad argument)</code></pre>
<p>As we can see, unregister fails when it in fact should succeed. We’ve
registered <code>&#34;e&#34;</code> so we should be allowed to unregister it,
but the real implementation has, due to the bug, forgot that the
registration happened.</p>
<p>Let’s move on to the parallel tests, all we need to add is:</p>
<div id="cb79"><pre><code><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>ParallelModel</span> <span>RegState</span> <span>where</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  runCommandMonad _ <span>=</span> <span>id</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span>prop_parallelRegistry ::</span> <span>ParallelCommands</span> <span>RegState</span> <span>-&gt;</span> <span>Property</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>prop_parallelRegistry cmds <span>=</span> monadicIO <span>$</span> <span>do</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span>10</span> <span>$</span> <span>do</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    void (run cleanUp)</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    runParallelCommands cmds</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>  assert <span>True</span></span></code></pre></div>
<p>When we run the tests we get rather long counterexamples:</p>
<pre><code>      *** Failed! (after 24 tests and 7 shrinks):
      Exception:
        bad argument
        CallStack (from HasCallStack):
          error, called at src/Example/Registry/Real.hs:69:10 in stateful-pbt-with-fakes-0.0.0-inplace:Example.Registry.Real
      ParallelCommands [Fork [Spawn,WhereIs &#34;a&#34;],Fork [Spawn],
                        Fork [Register &#34;c&#34; (Var 1),Spawn],Fork [Register &#34;e&#34; (Var 2),Register &#34;a&#34; (Var 2)]]</code></pre>
<p>If we replace our shared memory operations with version that do a bit
of sleep beforehand:</p>
<div id="cb81"><pre><code><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span>- import Data.IORef</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span>+ import SleepyIORef</span></span></code></pre></div>
<p>We get better shrinking results:</p>
<pre><code>      *** Failed! (after 5 tests and 5 shrinks):
      Exception:
        bad argument
        CallStack (from HasCallStack):
          error, called at src/Example/Registry/Real.hs:69:10 in stateful-pbt-with-fakes-0.0.0-inplace:Example.Registry.Real
      ParallelCommands [Fork [Spawn],Fork [Register &#34;b&#34; (Var 0),Register &#34;c&#34; (Var 0)]]</code></pre>
<p>Here we see clearly that there’s some problem in
<code>Register</code>, as that’s the only thing that happens in
parallel. If we look at the implementation of <code>register</code> it’s
obvious where the race condition is, for example we are using
<code>atomicModifyIORef</code> to update the registry. The problem is
that we call <code>readRegistry</code> to check if a name has already
been registered and then call <code>atomicModifyIORef</code>, so the
race can be if another thread sneaks in between those two calls.</p>
<p>We can fix this problem by adding a global lock around
<code>register</code>:</p>
<div id="cb83"><pre><code><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span>{-# NOINLINE lock #-}</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span>lock ::</span> <span>MVar</span> ()</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>lock <span>=</span> unsafePerformIO (newMVar ())</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span>registerNoRace ::</span> <span>String</span> <span>-&gt;</span> <span>ThreadId</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>registerNoRace name tid <span>=</span> withMVar lock <span>$</span> \_ <span>-&gt;</span> register name tid</span></code></pre></div>
<p>When rerunning the tests with this fixed version of
<code>registry</code>, we get:</p>
<pre><code>      *** Failed! Assertion failed (after 30 tests and 13 shrinks):
      ParallelCommands [Fork [Spawn],Fork [Spawn],Fork [Spawn],
                        Fork [Register &#34;d&#34; (Var 2)],Fork [Unregister &#34;d&#34;,Unregister &#34;d&#34;]]</code></pre>
<p>Which seems to suggest that we have a similar problem with
<code>unregister</code>, which is indeed the case. After applying the
same fix to <code>unregister</code>, we get:</p>
<pre><code>      *** Failed! Assertion failed (after 15 tests and 4 shrinks):
      ParallelCommands [Fork [Spawn],Fork [Register &#34;d&#34; (Var 0)],
                        Fork [Kill (Var 0),Register &#34;e&#34; (Var 0)]]</code></pre>
<p>Killing a thread will unregister it, so we get a similar problem
again. If we take the lock before calling <code>kill</code>, then the
parallel tests finally pass.</p>
<p>These race conditions are essentially variants on the parallel
counter bug, but I hope you agree that they’re not as obvious in the
process registry case. I also hope that by now it’s clear that as a user
we get these parallel tests basically without doing any extra work. All
the heavy lifting is done by the library by reusing the sequential
model, and this code can be written once and then reused for all our
parallel testing examples!</p>
</section>
</section>
</section>
<section id="integration-testing-with-contract-tested-fakes">
<h3><a href="#integration-testing-with-contract-tested-fakes" title="Integration testing with contract tested fakes">Integration
testing with contract tested fakes</a></h3>
<p>Throughout this post we’ve used in-memory models, or fakes, as
reference implementations to test against. The use of fakes diverges
from the original work on Quviq’s Erlang QuickCheck, where a more
traditional state machine specification is used with
post-conditions.</p>
<p>As far as I know, Edsko de Vries’ <a href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/">post</a>
(2019) was the first to propose the use of fakes instead of state
machine specifications with post-conditions. Edsko also showed how one
can implement fake-based specifications on top of a library that uses
state machine specifications<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<p>Using fakes instead of state machine specifications with
post-conditions is easier for programmers unfamiliar with formal
specifications, because most programmers are already familiar with mocks
and fakes are <a href="https://martinfowler.com/bliki/TestDouble.html">similar</a> to
mocks.</p>
<p>There are other advantages to using fakes, for example we can use
this fake in integration tests with components that depend on the
software that we tested with the fake.</p>
<p>Imagine a situation where we have two components with the first
depending on the second:</p>
<pre><code>   +--------+              +---------+
   |        |  depends on  |         |
   | Real A +-------------&gt;|  Real B |
   |        |              |         |
   +--------+              +---------+</code></pre>
<p>If we want to integration test component <span><em>A</em></span> and <span><em>B</em></span> then we first need to start or
enable component <span><em>B</em></span> and then
start testing component <span><em>A</em></span>. In
a larger system there can be many dependencies and integration tests can
get slow and flaky due to the infrastructure for starting up the
dependencies.</p>
<p>With fakes we can get fast and deterministic integration tests by
depending on the fake of the dependency instead of the real
dependency:</p>
<pre><code>   +--------+              +---------+
   |        |  depends on  |         |
   | Real A +-------------&gt;|  Fake B |
   |        |              |         |
   +--------+              +---------+</code></pre>
<p>One of the problems with integration testing against fakes is that
the fake can be wrong. The standard solution to solve that problem is to
<a href="https://martinfowler.com/bliki/ContractTest.html">contract
test</a> the fake to make sure that it is faithful to the software it’s
supposed to be a fake of. We don’t have this problem, because our
stateful and parallel property-based tests assure that the fake is
faithful:</p>
<pre><code>   +--------+                  +---------+
   |        |  tested against  |         |
   | Real B +-----------------&gt;|  Fake B |
   |        | (contract test)  |         |
   +--------+                  +---------+</code></pre>
<p>In this, final, section we’ll look at examples of how integration
testing against fakes works. Hopefully this shows how the testing
methodology that we’ve explored in this post can be scaled to a bigger
system of components.</p>
<section id="example-queue-again">
<h4><a href="#example-queue-again" title="Example: queue (again)">Example: queue (again)</a></h4>
<p>As our first example of integration testing, let’s recall our queue
example from the section on stateful testing. We can introduce an
interface for it as follows:</p>
<div id="cb89"><pre><code><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>IQueue</span> q <span>=</span> <span>IQueue</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  {<span> iNew  ::</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> q</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  ,<span> iPut  ::</span> q <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  ,<span> iGet  ::</span> q <span>-&gt;</span> <span>IO</span> <span>Int</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  ,<span> iSize ::</span> q <span>-&gt;</span> <span>IO</span> <span>Int</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The real implementation can instantiate this interface in a
straightforward way:</p>
<div id="cb90"><pre><code><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span>real ::</span> <span>IQueue</span> <span>Queue</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>real <span>=</span> <span>IQueue</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>  { iNew  <span>=</span> new</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>  , iPut  <span>=</span> put</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>  , iGet  <span>=</span> get</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>  , iSize <span>=</span> size</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The interesting part is that our fake can also instantiate the same
interface by storing the state in a mutable reference
(<code>IORef</code>) as follows.</p>
<div id="cb91"><pre><code><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span>fake ::</span> <span>IO</span> (<span>IQueue</span> (<span>Var</span> <span>Queue</span>))</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>fake <span>=</span> <span>do</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  ref <span>&lt;-</span> newIORef emptyState</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>IQueue</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    { iNew  <span>=</span> \n   <span>-&gt;</span> updateIORef ref (fNew n)</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    , iPut  <span>=</span> \q i <span>-&gt;</span> updateIORef ref (fPut q i)</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    , iGet  <span>=</span> \q   <span>-&gt;</span> updateIORef ref (fGet q)</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    , iSize <span>=</span> \q   <span>-&gt;</span> updateIORef ref (fSize q)</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span>    updateIORef ::</span> <span>IORef</span> <span>State</span> <span>-&gt;</span> <span>FakeOp</span> a <span>-&gt;</span> <span>IO</span> a</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    updateIORef ref op <span>=</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef&#39; ref (\fs <span>-&gt;</span> assoc fs (op fs)) <span>&gt;&gt;=</span> \<span>case</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> err <span>-&gt;</span> throwIO err</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> x  <span>-&gt;</span> <span>return</span> x</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>      <span>where</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        assoc fs  (<span>Left</span> err)       <span>=</span> (fs,  <span>Left</span> err)</span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        assoc _fs (<span>Right</span> (fs&#39;, x)) <span>=</span> (fs&#39;, <span>Right</span> x)</span></code></pre></div>
<p>We can now write components or services <em>against</em> this
interface:</p>
<div id="cb92"><pre><code><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span>prog ::</span> <span>IQueue</span> q <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>prog iq <span>=</span> <span>do</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>  q <span>&lt;-</span> iNew iq <span>3</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span>0</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span>1</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span>2</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>  x <span>&lt;-</span> iGet iq q</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>  assert (x <span>==</span> <span>0</span>) (<span>return</span> ())</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>  sz <span>&lt;-</span> iSize iq q</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>  assert (sz <span>==</span> <span>2</span>) (<span>return</span> ())</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a><span>test ::</span> <span>IO</span> ()</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>test <span>=</span> prog <span>=&lt;&lt;</span> fake</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a><span>deploy ::</span> <span>IO</span> ()</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>deploy <span>=</span> prog real</span></code></pre></div>
<p>When we integration test our new component we can use the
<code>fake</code> instance to make the tests fast and deterministic,
while when we deploy we use the <code>real</code> instance and because
of our stateful property-based tests we know that the fake is faithful
to the real implementation.</p>
</section>
<section id="example-file-system">
<h4><a href="#example-file-system" title="Example: file system">Example:
file system</a></h4>
<p>The next example is a file system, first used by Edsko in the <a href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/">post</a>
that also introduced using fakes as models.</p>
<p>The interface is parametrised by a file handle. We can create
directories, open files to get a hold of a file handle, file handles can
then be read from and written to, and finally closed:</p>
<div id="cb93"><pre><code><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>IFileSystem</span> h <span>=</span> <span>IFileSystem</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>  {<span> iMkDir ::</span> <span>Dir</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  ,<span> iOpen  ::</span> <span>File</span> <span>-&gt;</span> <span>IO</span> h</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>  ,<span> iWrite ::</span> h <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>  ,<span> iClose ::</span> h <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>  ,<span> iRead  ::</span> <span>File</span> <span>-&gt;</span> <span>IO</span> <span>String</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The real implementation of this interface uses the real file system.
In order to isolate the tests all operations will be relative to some
<code>root</code> directory:</p>
<div id="cb94"><pre><code><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span>root ::</span> <span>FilePath</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>root <span>=</span> <span>&#34;/tmp/qc-test&#34;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span>rMkDir ::</span> <span>Dir</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>rMkDir d <span>=</span> createDirectory (dirFP root d)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span>rOpen ::</span> <span>File</span> <span>-&gt;</span> <span>IO</span> <span>Handle</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>rOpen f <span>=</span> openFile (fileFP root f) <span>AppendMode</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a><span>rWrite ::</span> <span>Handle</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>rWrite h s <span>=</span> hPutStr h s</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a><span>rClose ::</span> <span>Handle</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>rClose h <span>=</span> hClose h</span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a><span>rRead ::</span> <span>File</span> <span>-&gt;</span> <span>IO</span> <span>String</span></span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>rRead f <span>=</span> <span>readFile</span> (fileFP root f)</span></code></pre></div>
<div id="cb95"><pre><code><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span>real ::</span> <span>IFileSystem</span> <span>Handle</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>real <span>=</span> <span>IFileSystem</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>  { iMkDir <span>=</span> rMkDir</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>  , iOpen  <span>=</span> rOpen</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>  , iWrite <span>=</span> rWrite</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  , iClose <span>=</span> rClose</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  , iRead  <span>=</span> rRead</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The fake implementation of the interface is, as usual, implemented
using an in-memory data structure:</p>
<div id="cb96"><pre><code><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>FHandle</span> <span>=</span> <span>Var</span> <span>Handle</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>FakeFS</span> <span>=</span> <span>F</span> {</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span>    dirs  ::</span> <span>Set</span> <span>Dir</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>  ,<span> files ::</span> <span>Map</span> <span>File</span> <span>String</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>  ,<span> open  ::</span> <span>Map</span> <span>FHandle</span> <span>File</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>  ,<span> next  ::</span> <span>FHandle</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>Show</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a><span>emptyFakeFS ::</span> <span>FakeFS</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>emptyFakeFS <span>=</span> <span>F</span> (Set.singleton (<span>Dir</span> [])) Map.empty Map.empty (<span>Var</span> <span>0</span>)</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>FakeOp</span> a <span>=</span> <span>FakeFS</span> <span>-&gt;</span> (<span>Either</span> <span>PrecondFail</span> a, <span>FakeFS</span>)</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a><span>fMkDir ::</span> <span>Dir</span> <span>-&gt;</span> <span>FakeOp</span> ()</span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>fMkDir d m<span>@</span>(<span>F</span> ds fs hs n)</span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a>  <span>|</span> d        <span>`Set.member`</span>    ds <span>=</span> (<span>Left</span> <span>AlreadyExists</span>, m)</span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>  <span>|</span> parent d <span>`Set.notMember`</span> ds <span>=</span> (<span>Left</span> <span>DoesNotExist</span>, m)</span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span>                   <span>=</span> (<span>Right</span> (), <span>F</span> (Set.insert d ds) fs hs n)</span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true" tabindex="-1"></a><span>fOpen ::</span> <span>File</span> <span>-&gt;</span> <span>FakeOp</span> <span>FHandle</span></span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true" tabindex="-1"></a>fOpen f m<span>@</span>(<span>F</span> ds fs hs n<span>@</span>(<span>Var</span> n_))</span>
<span id="cb96-24"><a href="#cb96-24" aria-hidden="true" tabindex="-1"></a>  <span>|</span> alreadyOpen   <span>=</span> (<span>Left</span> <span>Busy</span>, m)</span>
<span id="cb96-25"><a href="#cb96-25" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>not</span> dirExists <span>=</span> (<span>Left</span> <span>DoesNotExist</span>, m)</span>
<span id="cb96-26"><a href="#cb96-26" aria-hidden="true" tabindex="-1"></a>  <span>|</span> fileExists    <span>=</span> (<span>Right</span> n, <span>F</span> ds fs hs&#39; n&#39;)</span>
<span id="cb96-27"><a href="#cb96-27" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span>     <span>=</span> (<span>Right</span> n, <span>F</span> ds (Map.insert f <span>&#34;&#34;</span> fs) hs&#39; n&#39;)</span>
<span id="cb96-28"><a href="#cb96-28" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb96-29"><a href="#cb96-29" aria-hidden="true" tabindex="-1"></a>    hs&#39; <span>=</span> Map.insert n f hs</span>
<span id="cb96-30"><a href="#cb96-30" aria-hidden="true" tabindex="-1"></a>    n&#39;  <span>=</span> <span>Var</span> (<span>succ</span> n_)</span>
<span id="cb96-31"><a href="#cb96-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-32"><a href="#cb96-32" aria-hidden="true" tabindex="-1"></a>    fileExists  <span>=</span>         f <span>`Map.member`</span> fs</span>
<span id="cb96-33"><a href="#cb96-33" aria-hidden="true" tabindex="-1"></a>    dirExists   <span>=</span> fileDir f <span>`Set.member`</span> ds</span>
<span id="cb96-34"><a href="#cb96-34" aria-hidden="true" tabindex="-1"></a>    alreadyOpen <span>=</span> f <span>`List.elem`</span> Map.elems hs</span>
<span id="cb96-35"><a href="#cb96-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-36"><a href="#cb96-36" aria-hidden="true" tabindex="-1"></a><span>fWrite ::</span> <span>FHandle</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>FakeOp</span> ()</span>
<span id="cb96-37"><a href="#cb96-37" aria-hidden="true" tabindex="-1"></a>fWrite h s m<span>@</span>(<span>F</span> ds fs hs n)</span>
<span id="cb96-38"><a href="#cb96-38" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Just</span> f <span>&lt;-</span> Map.lookup h hs <span>=</span> (<span>Right</span> (), <span>F</span> ds (Map.adjust (<span>++</span> s) f fs) hs n)</span>
<span id="cb96-39"><a href="#cb96-39" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span>                 <span>=</span> (<span>Left</span> <span>HandleClosed</span>, m)</span>
<span id="cb96-40"><a href="#cb96-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-41"><a href="#cb96-41" aria-hidden="true" tabindex="-1"></a><span>fClose ::</span> <span>FHandle</span> <span>-&gt;</span> <span>FakeOp</span> ()</span>
<span id="cb96-42"><a href="#cb96-42" aria-hidden="true" tabindex="-1"></a>fClose h (<span>F</span> ds fs hs n) <span>=</span> (<span>Right</span> (), <span>F</span> ds fs (Map.delete h hs) n)</span>
<span id="cb96-43"><a href="#cb96-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-44"><a href="#cb96-44" aria-hidden="true" tabindex="-1"></a><span>fRead ::</span> <span>File</span> <span>-&gt;</span> <span>FakeOp</span> <span>String</span></span>
<span id="cb96-45"><a href="#cb96-45" aria-hidden="true" tabindex="-1"></a>fRead f m<span>@</span>(<span>F</span> _ fs hs _)</span>
<span id="cb96-46"><a href="#cb96-46" aria-hidden="true" tabindex="-1"></a>  <span>|</span> alreadyOpen               <span>=</span> (<span>Left</span> <span>Busy</span>         , m)</span>
<span id="cb96-47"><a href="#cb96-47" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Just</span> s <span>&lt;-</span> Map.lookup f fs <span>=</span> (<span>Right</span> s           , m)</span>
<span id="cb96-48"><a href="#cb96-48" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span>                 <span>=</span> (<span>Left</span> <span>DoesNotExist</span> , m)</span>
<span id="cb96-49"><a href="#cb96-49" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb96-50"><a href="#cb96-50" aria-hidden="true" tabindex="-1"></a>    alreadyOpen <span>=</span> f <span>`List.elem`</span> Map.elems hs</span></code></pre></div>
<div id="cb97"><pre><code><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span>fake ::</span> <span>IO</span> (<span>IFileSystem</span> <span>FHandle</span>)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>fake <span>=</span> <span>do</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  ref <span>&lt;-</span> newIORef emptyFakeFS</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>IFileSystem</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    { iMkDir <span>=</span> \d   <span>-&gt;</span> updateIORef ref (fMkDir d)</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    , iOpen  <span>=</span> \f   <span>-&gt;</span> updateIORef ref (fOpen f)</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    , iWrite <span>=</span> \h s <span>-&gt;</span> updateIORef ref (fWrite h s)</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    , iClose <span>=</span> \h   <span>-&gt;</span> updateIORef ref (fClose h)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>    , iRead  <span>=</span> \f   <span>-&gt;</span> updateIORef ref (fRead f)</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a><span>    updateIORef ::</span> <span>IORef</span> <span>FakeFS</span> <span>-&gt;</span> <span>FakeOp</span> a <span>-&gt;</span> <span>IO</span> a</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    updateIORef ref op <span>=</span></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef&#39; ref (\fs <span>-&gt;</span> swap (op fs)) <span>&gt;&gt;=</span> \<span>case</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> err <span>-&gt;</span> throwIO err</span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> x  <span>-&gt;</span> <span>return</span> x</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>      <span>where</span></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>        swap (x, y) <span>=</span> (y, x)</span></code></pre></div>
<p>Assuming we’ve tested that the fake file system is faithful to the
real one, we can depend on the interface in all components of our system
that need the file system:</p>
<div id="cb98"><pre><code><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span>prog ::</span> <span>IFileSystem</span> h <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>prog ifs <span>=</span> <span>do</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  <span>let</span> d <span>=</span> <span>Dir</span> [<span>&#34;foo&#34;</span>]</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>  iMkDir ifs d</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>  <span>let</span> f <span>=</span> <span>File</span> d <span>&#34;bar&#34;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>  h <span>&lt;-</span> iOpen ifs f</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>  iWrite ifs h <span>&#34;baz&#34;</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>  iClose ifs h</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>  <span>putStrLn</span> <span>=&lt;&lt;</span> iRead ifs f</span></code></pre></div>
<p>We can then use the fake file system when we integration test and
thus get fast and deterministic tests, and then use the real file system
when we deploy.</p>
<div id="cb99"><pre><code><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span>test ::</span> <span>IO</span> ()</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>test <span>=</span> prog <span>=&lt;&lt;</span> fake</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span>deploy ::</span> <span>IO</span> ()</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>deploy <span>=</span> prog real</span></code></pre></div>
<p>Because of the fact that we know that the fake is faithful to the
real file system implementation, we can be relatively sure that swapping
in the real file system instead of the fake one when deploying will not
introduce bugs. If it does introduce a bug then we have a mismatch
between the fake and the real implementation and we need to investigate
how it slipped through our stateful property-based <a href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/src/Example/FileSystem/Test.hs">tests</a>.</p>
<p>Note that <code>prog</code> is just a silly example, in a real system
the component that uses the file system can be more complex, for example
in the system that Edsko worked on the component that depended on the
file system is a database. In such cases it makes sense to write a whole
new stateful and parallel property-based test suite using database
commands and responses, it’s those tests that do the integration testing
between the database and the fake file system, while the stateful and
parallel property-based tests of the file system alone do the contract
tests that ensure that the file system fake is faithful to the real file
system. The picture looks like this, where “DB” is the database and “FS”
is the file system:</p>
<pre><code>   +---------+              +----------+
   |         |  depends on  |          |
   | Real DB +-------------&gt;|  Fake FS |
   |         |              |          |
   +----+----+              +----------+
        |
        | tested against
        v
   +---------+
   |         |
   | Fake DB |
   |         |
   +---------+</code></pre>
</section>
<section id="example-bigger-system-of-components">
<h4><a href="#example-bigger-system-of-components" title="Example: bigger system of components">Example: bigger system of
components</a></h4>
<p>The examples given above, a queue and a file system, might not seems
necessary to fake<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a> so to finish of let’s sketch how the
same technique scales to a bigger system of components or services.</p>
<p>Imagine we have three components or services, where component
<em>A</em> depends on component <em>B</em> which depends on component
<em>C</em>:</p>
<pre><code>  +---+      +---+      +---+
  |   |      |   |      |   |
  | A +-----&gt;| B +-----&gt;| C |
  |   |      |   |      |   |
  +---+      +---+      +---+</code></pre>
<p>Following the pattern that we did for the queue and file system
example, we’d define three interfaces:</p>
<div id="cb102"><pre><code><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>IA</span> <span>=</span> <span>...</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>IB</span> <span>=</span> <span>...</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>IC</span> <span>=</span> <span>...</span></span></code></pre></div>
<p>And the dependencies are made clear when we instantiate the
interfaces:</p>
<div id="cb103"><pre><code><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span>iC ::</span> <span>IO</span> <span>IC</span>       <span>-- C has no dependencies.</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span>iB ::</span> <span>IC</span> <span>-&gt;</span> <span>IO</span> <span>IB</span> <span>-- B depends on C.</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span>iA ::</span> <span>IB</span> <span>-&gt;</span> <span>IO</span> <span>IA</span> <span>-- A depends on B.</span></span></code></pre></div>
<p>The testing strategy is then as follows:</p>
<ol type="1">
<li>Stateful and parallel test C, this gives us a fake of C which is
contract tested;</li>
<li>Use C fake when integration testing B;</li>
<li>Use B fake (which uses the C fake) when testing A.</li>
</ol>
<p>Hopefully it should be clear that this strategy scales to more
components or services<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
</section>
</section>
</section>
<section id="conclusion-and-future-work">
<h2><a href="#conclusion-and-future-work" title="Conclusion and future work">Conclusion and future work</a></h2>
<p>We’ve seen how stateful and parallel property-based testing can be
implemented in about 400 lines of code, which is comparable to the 300
lines of code of the first version of QuickCheck (which didn’t have
shrinking). We’ve also had a look at several examples of how we can use
fakes as models and how to test bigger systems in a compositional manner
by reusing the fakes.</p>
<p>I hope that this is enough material to get people curious and
experimenting in their favorite programming languages<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a>.
Feel free to get <a href="https://stevana.github.io/about.html">in
touch</a> or open an <a href="https://github.com/stevana/stateful-pbt-with-fakes">issue</a> in
case there’s anything I can help with. Who knows, together, we might
even be able to slightly improve the state of property-based testing
libraries!</p>
</section>
<section id="acknowledgments">
<h2><a href="#acknowledgments" title="Acknowledgments">Acknowledgments</a></h2>
<p>I’d like to thank Daniel Gustafsson for helping implement the
<code>quickcheck-state-machine</code> library with me seven years ago,
discussing a fix for parallel commands generation <a href="https://github.com/stevana/quickcheck-state-machine/issues/51">issue</a>
that I found while writing this post, and for proofreading.</p>
<p>I also want to thank Larry Diehl for proofreading and making several
suggestions on how to improve the text and make it more readable.</p>
</section>

</div></div>
  </body>
</html>
