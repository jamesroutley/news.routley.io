<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/MegaManSec/SSH-Snake">Original</a>
    <h1>SSH-Snake: Automated SSH-Based Network Traversal</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">SSH-Snake is a powerful tool designed to perform automatic network traversal using SSH private keys discovered on systems, with the objective of creating a comprehensive map of a network and its dependencies, identifying to what extent a network can be compromised using SSH and SSH private keys starting from a particular system.</p>
<p dir="auto">SSH-Snake can automatically reveal the relationship between systems which are connected via SSH, which would normally take a tremendous amount of time and effort to perform manually.</p>
<p dir="auto">In other words, SSH-Snake performs the following tasks automatically and recursively:</p>
<ol dir="auto">
<li>On the current system, find any SSH private keys,</li>
<li>On the current system, find any hosts or destinations (<code>user@host</code>) that the private keys may be accepted,</li>
<li>Attempt to SSH into all of the destinations using all of the private keys discovered,</li>
<li>If a destination is successfully connected to, repeats steps #1 - #4 on the connected-to system.</li>
</ol>
<p dir="auto">It&#39;s completely self-replicating and self-propagating -- and completely fileless. In many ways, SSH-Snake is actually a <a href="https://en.wikipedia.org/wiki/Computer_worm" rel="nofollow">worm</a>: It replicates itself and spreads itself from one system to another as far as it can.</p>
<p dir="auto">Instead of manually jumping between systems with SSH keys like it&#39;s a Super Mario game, let SSH-Snake do the work for you.</p>
<p dir="auto">An in-depth look at how this script actually works, technical details, interesting discoveries, design decisions, benchmarking, and lessons learnt, check out <a href="https://joshua.hu/ssh-snake-ssh-network-traversal-discover-ssh-private-keys-network-graph" rel="nofollow">this blog post</a>.</p>

<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener noreferrer" href="https://github.com/MegaManSec/SSH-Snake/blob/main/tools/SSH-Snake-Screenshot.png"><img src="https://github.com/MegaManSec/SSH-Snake/raw/main/tools/SSH-Snake-Screenshot.png" alt=""/></a>A reduced screenshot from the output of SSH-Snake in a very small network.</th>
</tr>
</thead>
</table>
<hr/>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener noreferrer" href="https://github.com/MegaManSec/SSH-Snake/blob/main/tools/SSH-Snake-CytoScape.svg"><img src="https://github.com/MegaManSec/SSH-Snake/raw/main/tools/SSH-Snake-CytoScape.svg" alt="A graph visualizing the relation between systems using SSH"/></a>The blue nodes indicate the <em>destination</em> can connect to itself (user@host&lt;--&gt;user@host). The red edges indicate that the connection is bi-directional (user1@host1&lt;--&gt;user2@host2).</th>
</tr>
</thead>
</table>
<hr/>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener noreferrer" href="https://github.com/MegaManSec/SSH-Snake/blob/main/tools/SSH-Snake-Gephi.svg"><img src="https://github.com/MegaManSec/SSH-Snake/raw/main/tools/SSH-Snake-Gephi.svg" alt="A graph visualizing the relation between systems using SSH"/></a>The green nodes indicate a <em>host</em> (without a username) that can connect to itself (host1&lt;--&gt;host1). The green edges indicate that the connection is bi-directional (host1&lt;--&gt;host2). The gray host in the top right corner is the host that the script was initially executed on.</th>
</tr>
</thead>
</table>
<hr/>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener noreferrer" href="https://github.com/MegaManSec/SSH-Snake/blob/main/tools/SSH-Snake-dot-circo.png"><img src="https://github.com/MegaManSec/SSH-Snake/raw/main/tools/SSH-Snake-dot-circo.png" alt="A graph visualizing the relation between systems using SSH"/></a>The blue nodes indicate the <em>destination</em> can connect to itself (user@host&lt;--&gt;user@host). The red edges indicate that the connection is bi-directional (user1@host1&lt;--&gt;user2@host2).</th>
</tr>
</thead>
</table>

<p dir="auto">SSH-Snake can either be downloaded or piped into bash:</p>
<div dir="auto" data-snippet-clipboard-copy-content="wget https://raw.githubusercontent.com/MegaManSec/SSH-Snake/main/Snake.nocomments.sh
stdbuf -o0 bash ./Snake.nocomments.sh"><pre>wget https://raw.githubusercontent.com/MegaManSec/SSH-Snake/main/Snake.nocomments.sh
stdbuf -o0 bash ./Snake.nocomments.sh</pre></div>
<p dir="auto">or</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl https://raw.githubusercontent.com/MegaManSec/SSH-Snake/main/Snake.nocomments.sh | stdbuf -o0 bash"><pre>curl https://raw.githubusercontent.com/MegaManSec/SSH-Snake/main/Snake.nocomments.sh <span>|</span> stdbuf -o0 bash</pre></div>

<p dir="auto">SSH-Snake seamlessly emulates what a human adversary would do to discover SSH private keys and destinations where they can be used to connect to. Written entirely in Bash, it operates with a minimal set of dependencies commonly available on major Linux systems: <code>bash</code>, <code>ssh</code>, <code>getconf</code>, <code>coreutils</code>, <code>getent</code>, <code>awk</code>, <code>sort</code>, <code>grep</code>, <code>tr</code>, <code>find</code>, and <code>cat</code>. Likewise, <code>sudo</code>, <code>hostname</code>, <code>ip</code>, and <code>xargs</code> may also be used, but they are not required (and the script gracefully handles cases where they are not present). If a system is discovered without any of the required packages, it gracefully fails, alerting the user that the scan could not continue on that particular system (and backtracks, continuing from the previous system.)</p>
<p dir="auto">SSH-Snake is completely fileless: after the user runs the script, it is passed to destinations&#39; bash via stdin and bash arguments (via SSH). No material evidence of the script exists on any of the systems scanned: the only evidence of the script running is in the process tree, and the substantial amount of invalid SSH attempts which will inevitably occur.</p>
<p dir="auto">SSH-Snake takes a <a href="https://en.wikipedia.org/wiki/Depth-first_search" rel="nofollow">depth-first approach</a> to discovery: once it connects to one system, it tries to connect further from that system before backtracking.</p>
<p dir="auto">The name SSH-Snake comes from the fact that the output of the script looks like a snake slithering up and down the network. However unlike the game Snake, SSH-Snake will not die when it bites its own tail (connects to a systems it has already scanned or is currently scanning): it will simply print how it connected there as normal, but return and not re-scan the destination (in order to avoid infinite recursion).</p>

<ul dir="auto">
<li>Recursively SSH from one system to another using local SSH private keys,</li>
<li>Fileless traversal and propogation/replication of the SSH-Snake script using only stdin and bash arguments to remote systems,</li>
<li>Automatic elevation of privileges to root using sudo if possible,</li>
<li>Discover SSH private key files from <code>.bash_history</code> entries,</li>
<li>Discover SSH private keys from commonly used files and folders,</li>
<li>Exfiltration SSH private keys as output of the script,</li>
<li>Configurable custom command execution on each system,</li>
<li>Plug-and-play modular system to discover private keys and systems,</li>
<li>Detect hosts from IP ranges, last logins, known hosts, SSH config files, and more,</li>
<li>Ability to detect when a system has already been scanned or is in the process of being scanned such that a network like A-&gt;B-&gt;C is able to also discover C-&gt;A but does not regress to A-&gt;B-&gt;C-A-&gt;B-&gt;C-&gt;A-&gt;B-&gt;....,</li>
<li>Ability to generate graphical visulizations of a network from the output of the script,</li>
<li>... and more.</li>
</ul>

<p dir="auto">SSH-Snake comes with some general settings that can be configured. These settings are documented in <a href="https://github.com/MegaManSec/SSH-Snake/blob/main/SETTINGS.md#general-settings">SETTINGS.md#general-settings</a>.</p>
<p dir="auto">SSH-Snake also comes with a variety configurable/plug-and-play strategies (functions) which can be used to discover SSH private keys on a system and discover hosts and destinations to attempt to connect to. Sane defaults have been provided, however if you want to perform a scan as thoroughly as possible, then enabling more discovery techniques can help. If a scan is taking a long time, disabling some discovery techniques can help. With the exception of one strategy (<code>find_ssh_keys</code>), each of the strategies can be toggled off/on. These are documented in <a href="https://github.com/MegaManSec/SSH-Snake/blob/main/SETTINGS.md#configurable-discovery-strategies">SETTINGS.md#configurable-discovery-strategies</a>.</p>

<p dir="auto">The raw output of SSH-Snake contains a mix of infomation about discovered private keys, destinations, and error messages.</p>
<p dir="auto">A detailed explanation on the full output of SSH-Snake can be found in <a href="https://github.com/MegaManSec/SSH-Snake/blob/main/OUTPUT.md">OUTPUT.md</a>.</p>

<p dir="auto">The output of SSH-Snake can be used to create graphs/visualizations of the network that the script traverses.</p>
<p dir="auto">A detailed explanation on how to create and interpret images/visualizations from the output of SSH-Snake can be found in <a href="https://github.com/MegaManSec/SSH-Snake/blob/main/GRAPHICS.md">GRAPHICS.md</a>.</p>

<p dir="auto">In addition to the ability to create visualizations of the network that SSH-Snake traverses, three other tools are provided. Namely:</p>
<ol dir="auto">
<li><code>forward-lookup-host.py</code>: Given a source host or destination, determine all of the systems that can be accessed either directly or indirectly (i.e. through a tertiary system).</li>
<li><code>reverse-lookup-host.py</code>: Given a destination host or destination, determine all of the systems that can either directly or indirectly access it.</li>
<li><code>shortest-path-create-chain.py</code>: Given host or destination A and B, determine the shortest path connecting the two.</li>
</ol>
<p dir="auto">The third tool also generates a command that can be used to connect from destination A to destination B. For example:</p>
<div data-snippet-clipboard-copy-content="$ python3 tools/shortest-path-create-chain.py --file output.log --src &#39;jrogers@10.2.3.4&#39; --dest &#39;root@10.25.49.1&#39;

Shortest path from jrogers@10.2.3.4 to root@10.25.49.1: jrogers@10.2.3.4-&gt;user@10.44.39.21-&gt;user@10.19.29.54-&gt;root@10.25.49.1

[..]

ssh -i &#34;/home/jrogers/.ssh/key&#34; user@10.44.39.21 &#39;sudo ssh -i &#34;/root/.ssh/id_rsa&#34; user@10.19.29.54 &#39;ssh -i &#34;/tmp/key&#34; root@10.25.49.1&#39;&#39;"><pre><code>$ python3 tools/shortest-path-create-chain.py --file output.log --src &#39;jrogers@10.2.3.4&#39; --dest &#39;root@10.25.49.1&#39;

Shortest path from jrogers@10.2.3.4 to root@10.25.49.1: jrogers@10.2.3.4-&gt;user@10.44.39.21-&gt;user@10.19.29.54-&gt;root@10.25.49.1

[..]

ssh -i &#34;/home/jrogers/.ssh/key&#34; user@10.44.39.21 &#39;sudo ssh -i &#34;/root/.ssh/id_rsa&#34; user@10.19.29.54 &#39;ssh -i &#34;/tmp/key&#34; root@10.25.49.1&#39;&#39;
</code></pre></div>

<p dir="auto">Since the script is quite large, loading the script into a here-document (which it does automatically) <a href="https://joshua.hu/more-fun-with-bash-ssh-and-ssh-keygen-version-differences" rel="nofollow">causes bash to write to a temporary file</a> (as it is greater than 65535-bytes).</p>
<p dir="auto">To cut down on the size such that it remains 100% fileless, Snake.nocomments.sh has a version with all comments, unnecessary white-spaces, and blank lines removed. This cuts the file&#39;s size down such that the temporary file is not created by bash.</p>

<p dir="auto">If you encounter any bugs or issues related to the script, please report them as a GitHub issue. Please include your configuration setings.</p>
<p dir="auto">I am particually interested in any interesting <code>[line]</code> outputs associated with errors that haven&#39;t been caught by the script.</p>

<ul dir="auto">
<li>
<p dir="auto">IPv4 Only: Like all of the best programs, the script does not support IPv6. I can&#39;t imagine there will be support for this anytime soon.</p>
</li>
<li>
<p dir="auto">Port 22 Only: There is a general assumption that SSH is running on port 22.</p>
</li>
<li>
<p dir="auto">GNU coreutils: The script relies heavily on GNU coreutils. I have not determined how much (if any) GNU-ism is used in the script.</p>
</li>
<li>
<p dir="auto"><code>find ... -readable ...</code> is used in the script in multiple places. The <code>-readable</code> flag is not supported on all versions of <code>find(1)</code>.</p>
</li>
<li>
<p dir="auto">The script does not currently look for SSH agent sockets.</p>
</li>
</ul>
</article>
          </div></div>
  </body>
</html>
