<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/dispatches/xaes-256-gcm-11/">Original</a>
    <h1>I want XAES-256-GCM/11</h1>
    
    <div id="readability-page-1" class="page"><article>
        <span>
            <time datetime="2023-07-06">06 Jul 2023</time>
        </span>
        
        <section>
            <!--kg-card-begin: markdown--><p>In 2023, the way to use AES is AES-GCM. Anything else is very unlikely to make sense. We might not like that, we might wish OCB hadn’t been patented, but with hardware support in most processors these days GCM is both faster than the alternatives, ubiquitous, and just tolerable to implement.</p>
<p>Still, I don’t want to use AES-GCM, I want to use XAES-256-GCM/11, which has a number of nice properties and only the annoying defect of not existing.</p>
<p>The problem with AES-GCM is that its nonce is a little too small to comfortably select at random. At 96 bit, the probability of a <a href="https://en.wikipedia.org/wiki/Birthday_attack?ref=words.filippo.io">birthday bound</a> collision becomes uncomfortable (2<sup>-32</sup>) after a few billion messages (2<sup>32</sup>), and <a href="https://eprint.iacr.org/2016/475?ref=words.filippo.io">the consequences of a collision are catastrophic</a>. Some applications know they will never encrypt that many messages under a single key, but those numbers are a little too low and the consequences too dire to make that assumption at the API level, so we’re forced to delegate nonce management to the user.</p>
<p>ChaCha20Poly1305 has the same issue, which is why the <em>extended-nonce</em> construction XChaCha20Poly1305 exists. It resolves the issue by taking a 192-bit nonce, and “hashing” it along with the key into a fresh key. The key is 256 bits, so there is no need to ever worry about collisions there. (More on that later.) You should <em>always</em> use the X variant unless the nonce is fully implicit, like when it’s always zero (like in age), a record counter (like in TLS), or a chunk number (like in STREAM). You can also make nice APIs for the X variant that generate the nonce at random from the system CSPRNG (and we are thinking about how to best do that in the Go standard library).</p>
<p>XChaCha20Poly1305 uses ChaCha20 itself to do the hashing to avoid introducing a new primitive, but this would work just as well using SHA-256 or HKDF to derive a regular key and nonce for ChaCha20Poly1305 from a key and a larger nonce. This means you could do the same for AES-GCM, and some schemes do in fact do just that. Regrettably, we don’t have a name for it, so you can’t just say to people “you should <em>always</em> use the X variant” or make a nice interoperable API for it.</p>
<p>Anyway, that’s the X in my <s>pony</s> XAES-256-GCM/11.</p>
<p>I don’t care if it uses HKDF, or SHA-256, or the AES function: I want a well-defined scheme that takes a key and 192 bits of nonce and hashes them into a derived key and 96 bits of nonce for use with AES-GCM.</p>
<p>Even with AES-128, the combined 224 bits of space for key and nonce are juuuust enough not to worry about collisions in the derived values. Still, this hints to the second part of the <s>pony</s> problem with AES-GCM: while <a href="https://words.filippo.io/dispatches/post-quantum-age/#128-bits-are-enough">actually enough for post-quantum cryptography</a>, 128-bit keys are still too tight for <em>multi-user security</em>. If for example an application encrypts 2<sup>48</sup> messages under different 128-bit keys, and all messages start with the same few bytes, an attacker can build a lookup table, try and lookup the ciphertext of 2<sup>64</sup> keys, and <a href="https://www.wolframalpha.com/input?i=log2%281+-+%281+-+2%5E48+%2F+2%5E128%29+%5E+%282%5E64%29%29&amp;ref=words.filippo.io">have a 2<sup>-16</sup> chance</a> to decrypt one message. Not good.</p>
<p>Multi-user attacks can be mitigated by many things—they require fixed nonces and partially known plaintext—but the only way to avoid that complexity escaping the AEAD abstraction and leaking into the rest of the protocol is to use 256-bit keys. For AES-GCM, that means using AES-256. Too bad that AES-256 is slower than AES-128, not because of its bigger key size, but because it was specified with more rounds, presumably under the assumption that users of bigger keys would also want more security margin against cryptanalysis. AES is an iterated cipher, where four core operations are performed multiple times in sequence: AES-128 performs them ten times, while AES-256 performs them fourteen times. AES-256 doesn’t <em>have to be</em> slower than AES-128, it was just defined to be slower. That’s regrettable, because it applies an artificial performance tax on the use of longer keys, which are desirable for reasons that have nothing to do with the risk of AES cryptanalysis.</p>
<p>Picking the “right” number of rounds is hard, and it’s kind of an open secret in the community that there is no rigorous and scientific way to do it. “<em><a href="https://eprint.iacr.org/2019/1492?ref=words.filippo.io">Too much crypto</a></em>” by Aumasson is all about this, and suggests eleven rounds for AES-256. I started this aiming for ten, which would have been exactly as fast as AES-128, but AES-256 does need more margin than AES-128 in some rare cases for <em>reasons</em> and I guess it’d be silly to introduce a different abstraction-leaking edge case while trying to remove two, so AES-256/11 it is.</p>
<p>Summing up, I would like to provide to my users the extended-nonce 256-bit reduced-rounds XAES-256-GCM/11 (or XAES-256/11-GCM?) AEAD. It has infinitely randomizable nonces, a comfortable margin of multi-user security, and nearly the same performance as AES-128-GCM. It would also be a true drop-in replacement for XChaCha20Poly1305. Only issue is that it doesn’t exist.</p>
<p>(I guess it would also not be FIPS 140 compliant. We could make a FIPS version that’s slower but equivalent by using HKDF to derive the key, and the full-rounds AES-256.)</p>
<p><strong>Edit 2023-07-06</strong>: Soatok has <a href="https://soatok.blog/2022/12/21/extending-the-aes-gcm-nonce-without-nightmare-fuel/?ref=words.filippo.io">previously suggested an extended-nonce AES-GCM construction</a>. His AES-XGCM uses CBC-MAC for key derivation, which might be a good pick as both primitive-parsimonious and potentially FIPS 140 compliant. @NohatCoder@mastodon.gamedev.place on Mastodon suggests that since we&#39;re KDF&#39;ing, we might as well generate all the subkeys directly, solving the AES-256-specific issues that require the extra rounds (see ). I&#39;m a bit wary to diverge too much from the well-established primitives, since at that point might as well use something novel (such as <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-aegis-aead/?ref=words.filippo.io">AEGIS</a>, like Soatok says). The point here is that I&#39;d like a thin construction that&#39;s easy to get confidence for if you already trust AES-GCM.</p>
<p>If for some reason you&#39;re curious about what other ponies I want, you might want to follow me <a href="https://bsky.app/profile/filippo.abyssdomain.expert?ref=words.filippo.io">on Bluesky</a> or <a href="https://abyssdomain.expert/@filippo?ref=words.filippo.io">on Mastodon</a>.</p>
<h2 id="the-picture">The picture</h2>
<p>Cats! Amongst Roman ruins! What else do you need in life? (Better AEAD modes I guess.)</p>
<p><img src="https://words.filippo.io/content/images/2023/07/news---1.jpeg" alt="A calico cat sleeps in the foreground, another cat is sitting down a step behind it, and behind them and a rail is a archaeological site with trees and columns. Further back, buildings." loading="lazy"/></p>
<p>My awesome clients—<a href="https://www.sigsum.org/?ref=words.filippo.io">Sigsum</a>, <a href="https://protocol.ai/?ref=words.filippo.io">Protocol Labs</a>, <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a>, <a href="https://interchain.io/?ref=words.filippo.io">Interchain</a>, <a href="https://smallstep.com/?ref=words.filippo.io">Smallstep</a>, and <a href="https://tailscale.com/?ref=words.filippo.io">Tailscale</a>—are funding all this work and through our retainer contracts they get face time about its direction, as well as unlimited access to advice.</p>
<p>Here are a few words from some of them!</p>
<p>Protocol Labs — <a href="https://cryptonet.org/?ref=words.filippo.io">Cryptonet</a> is hosting <a href="https://lu.ma/tm8v78rl?ref=words.filippo.io">Proof of Space days</a> in Paris on July 20-21, a gathering of cryptographers, Web3 researchers and engineers to share knowledge on <a href="http://proofofspace.org/?ref=words.filippo.io">Proof of Space</a>. We’ll have talks and workshops to collaborate, share ideas and onboard new researchers into this exciting field. You’ll also have a chance to meet us (we’re currently looking for a senior cryptography engineer), <a href="https://lu.ma/tm8v78rl?ref=words.filippo.io">register and join us</a>!</p>
<p>Latacora — <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a> bootstraps security practices for startups. Instead of wasting your time trying to hire a security person who is good at everything from Android security to AWS IAM strategies to SOC2 and apparently has the time to answer all your security questionnaires plus never gets sick or takes a day off, you hire us. We provide a crack team of professionals prepped with processes and power tools, coupling individual security capabilities with strategic program management and tactical project management.</p>


<!--kg-card-end: markdown-->
        </section>
    </article></div>
  </body>
</html>
