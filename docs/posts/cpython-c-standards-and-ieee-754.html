<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/886516/d835ee6026544345/">Original</a>
    <h1>CPython, C standards, and IEEE 754</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 0 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>

<p>
Perhaps February was &#34;compiler modernization&#34; month.  The Linux kernel
recently <a href="https://lwn.net/Articles/885941/">decided to move to the C11 standard</a>
for its code; Python has just undergone a similar process for
determining which flavor of C to use for building its
CPython reference implementation.  A calculation in the CPython interpreter
went awry when built with a pre-release version of the upcoming <a href="https://gcc.gnu.org/gcc-12/changes.html">GCC 12</a>; that
regression led down a path that ended up with the adoption of C11 for CPython as well.
</p>

<p>
A <a href="https://bugs.python.org/issue46640">bug</a> that was fixed in
early February started the ball rolling for Python.  Victor Stinner
encountered a <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104389">GCC
regression</a> that caused CPython not to get the expected <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> floating-point
NaN (not a number) value in a calculation. An <a href="https://lwn.net/Articles/808595/">LWN article</a> sheds some light on NaNs (and how
they are used in Python) for those who need a bit more background.
The calculation was using the
<tt>HUGE_VAL</tt> constant, which is defined as an ISO C constant with a
value of positive infinity; the code set the value of the internal
<tt>Py_NAN</tt> constant used by the interpreter to
<tt>HUGE_VAL*0</tt>, which should, indeed, evaluate to a NaN.  Multiplying
infinity by any number is defined to be a NaN for IEEE 754.
</p>

<p>
During his investigation of the problem, Stinner found that instead of the
calculation, Python could simply use the <tt>NAN</tt> constant defined in
<tt>&lt;math.h&gt;</tt>—as long as a <a href="https://en.wikipedia.org/wiki/C99">C99</a> version of the header file
was used. 
As part of the bug discussion, Petr Viktorin said that <a href="https://www.python.org/dev/peps/pep-0007/">PEP 7</a>
(&#34;<span>Style Guide for C Code</span>&#34;) should be updated to reflect the
need for the C99 header file.  So Stinner duly created a <a href="https://github.com/python/peps/pull/2309">pull request</a> for a
change to the PEP, but Guido van Rossum <a href="https://github.com/python/peps/pull/2309#issuecomment-1031686346">said</a>
that a change of that nature should be discussed on the python-dev mailing list.
</p>

<p>
That led Stinner to <a href="https://lwn.net/ml/python-dev/CABqyc3zc8VDoaqjXNu3LeHrwm+LQi+2szmgMVOQSwuAFbKGXhA@mail.gmail.com/">post</a>
a message to discuss the change on February 7.  As it turns out, there are actually two
bugs fixed by Stinner that require parts of the C99 math API; <a href="https://bugs.python.org/issue45440">bug 45440</a> reported a
problem with the CPython <tt>Py_IS_INFINITY()</tt> macro; the fix for that also involved
using the C99 <tt>&lt;math.h&gt;</tt>.  As Stinner noted, C99 is
now 23 years old, and support for it in compilers is widespread; GCC,
Clang, and Microsoft Visual C (MSVC) all support the needed features.
</p>

<h4>Floating point</h4>

<p>
Mark Dickinson <a href="https://lwn.net/ml/python-dev/CAAu3qLVsUqTQ8tG_0qk7N-9TfQg8caBTUhYgmUHvbcPsm0L2jw@mail.gmail.com/">pointed
out</a> that the existence of the <tt>NAN</tt> constant is not required by
C99 directly; it is only present if IEEE 754 floating
point is enabled as well.  He thought that it made sense for CPython to
require IEEE 754, but wondered whether Python, the language,
should also require it.  Stinner <a href="https://lwn.net/ml/python-dev/CABqyc3xmtguK6ho9cpicB4hiDoDJPFPvKwN6_m8MKTD8d2g69Q@mail.gmail.com/">said</a>
that all modern computers support IEEE 754; even embedded devices
without a floating-point unit (FPU) typically support it in
software. &#34;<span>Nowadays, outside museums, it&#39;s hard to find computers
which don&#39;t 
implement IEEE 754.</span>&#34;
</p>

<p>
Stinner was in favor of requiring IEEE 754 for CPython; Gregory P. Smith <a href="https://lwn.net/ml/python-dev/CAGE7PNK7-2akx=ah7S90EJFFj9s5bN-C=tkATLsDvESEnfk_7g@mail.gmail.com/">agreed</a>.
Brett Cannon <a href="https://lwn.net/ml/python-dev/CAP1=2W4LRJ=xjrOHgqDK=0k=JXNQEq_i4DrqXSbx6fAfCULcRw@mail.gmail.com/">wondered</a>
if there was even any ability to test with systems that lacked the support:
</p><blockquote>
Do we have a buildbot that has a CPU or OS that can&#39;t handle IEEE-754? What
are the chances we will get one? If the answers are &#34;none&#34; and &#34;slim&#34;, then
it seems reasonable to require NaN and IEEE-754.  
</blockquote>


<p>
Stinner <a href="https://lwn.net/ml/python-dev/CABqyc3yRXuxkKRmTEhzAXgk=19KfB3jwUjP8NeX9E10or_K_fA@mail.gmail.com/">reported</a>
that all of the buildbot machines supported IEEE 754, so the path was clear to
require it.  In terms of the Python <i>language</i>, Christopher Barker <a href="https://lwn.net/ml/python-dev/CALn7ch8X=SmvxeqfJ2f6hZpGnR5OZ5v219ERdrTHJHXKs_LVOw@mail.gmail.com/">said</a>
that IEEE 754 support should not be required for all implementations
of Python, but that
it should be recommended. Steve 
Dower <a href="https://lwn.net/ml/python-dev/1da3cf44-9849-033f-e164-7ee299cc0092@python.org/">agreed</a>
that leaving it up to Python implementations made sense: &#34;<span>Otherwise,
we would prevent _by specification_ using Python as a 
scripting language for things where floats may not even be
relevant.</span>&#34;  He said that making it a requirement would inhibit
adoption: &#34;<span>The more &#39;it&#39;s-only-Python-if-it-has-X&#39;
restrictions we have, the less appealing we become.</span>&#34;
</p>

<h4>Which C?</h4>

<p>
Switching to C99 makes sense if the compilers being used to build CPython
support it, Cannon <a href="https://lwn.net/ml/python-dev/CAP1=2W5o4kHsHiAiVCqJ3K8cDF-g-aX2TwcT7-vzQayvGdt__w@mail.gmail.com/">said</a>.
Viktorin <a href="https://lwn.net/ml/python-dev/83bdf9e7-fd69-30ae-a039-b96b05c50725@gmail.com/">asked</a>
about MSVC&#39;s support for all of C99; he did not find any documentation saying that
it did, so it might be better to consider <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11</a>,
which is 
supported. &#34;<span>Do we need to support a subset like &#39;C99 except the
features that were 
removed in C11&#39;?</span>&#34;  Dower, who works on Python at Microsoft,  <a href="https://lwn.net/ml/python-dev/1bab5f03-d515-4f72-6e07-560f3b203de0@python.org/">said</a>
that he had not found an answer to the C99 question either:
</p><blockquote>
All the C99 library is supposedly supported, but there are (big?) gaps in
the compiler support. Possibly these are features that were removed in C11?
I don&#39;t know what is on that list.
<p>
[...] Personally, I see no reason to &#34;require&#34; C99 as a whole. We have a style
guide already, and can list the additional compiler features that we allow
along with guidance on updating existing code and ensuring compatibility.
</p><p>
I don&#39;t see much risk requiring the C99 standard library, though. It&#39;s the
compiler features that seem to have less coverage.
</p></blockquote>


<p>
Stinner <a href="https://lwn.net/ml/python-dev/CABqyc3z61ih3t2D=Fj-hq_8YwU6=KT0M_OXs6iAtG6xmzPJLUw@mail.gmail.com/">suggested</a>
tying the wording to what was supported in MSVC, but H. Vetinari <a href="https://lwn.net/ml/python-dev/164437798249.14323.13770502320970033989@mail.python.org/">thought</a>
a better formulation might be &#34;<span>&#39;C99 without the things that became
optional in C11&#39;, or perhaps 
&#39;C11 without optional features&#39;</span>&#34;. That led Viktorin to <a href="https://lwn.net/ml/python-dev/51a8b0d4-31e5-a338-2779-6ca6acf2cd9f@gmail.com/">wonder</a>
why C11 would not make a better target: &#34;<span>[...] the main thing keeping
us from C99 is MSVC support, and 
since that compiler apparently skipped C99, should we skip it as well?</span>&#34;
</p>

<p>
Cannon <a href="https://lwn.net/ml/python-dev/CAP1=2W7t+BRnacZX_P5V8+mD7Bc=9Dj3xKfteES6wcQkZ+K=Cg@mail.gmail.com/">said</a>
that he found a <a href="https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29#Optional_features">list
of optional C11 features</a>, none of which were really needed; if the &#34;C11
without optional features&#34;
flavor is widely supported, as it would seem 
that it is, &#34;<span>I think that&#39;s a fine target to have</span>&#34;.
Meanwhile, both <a href="https://lwn.net/ml/python-dev/CAEfz+TwgP+h6XJrhQEyrYmrObTL-Yp+whOSeEqQme3Gb_2YWJQ@mail.gmail.com/">Inada
Naoki</a> and <a href="https://lwn.net/ml/python-dev/24d692ac-3879-18d7-e240-30d4f5aef5bf@gmail.com/">Viktorin</a>
were excited about using C11&#39;s <a href="https://en.wikipedia.org/wiki/Union_type#Anonymous_union">anonymous
union</a> feature in CPython.
</p>

<p>
Viktorin also said that in order to keep the CPython public header files
compatible with C++, anonymous unions could not be used in them, though
Inada <a href="https://lwn.net/ml/python-dev/CAEfz+Tx1NR3fxDKzSCJP+GF2hhgdH2=pmywMY5e7ibJoZmeSDQ@mail.gmail.com/">said</a>
that <a href="https://en.cppreference.com/w/cpp/language/union">C++ does
support them</a>,  &#34;<span>with some reasonable limitations</span>&#34;.   While
CPython aims to be compatible with C++ at the API level, it is hard to
completely specify what that means—or even which version of the C standard
is supported—as Smith <a href="https://lwn.net/ml/python-dev/CAGE7PN+y938qSrXFhdddgJk=hGfsAed9mqOzideYCSNEbDLw3A@mail.gmail.com/">pointed
out</a>:
</p><blockquote>
We&#39;re likely overspecifying in any document we create about what we require
because the only definition any of us are actually capable of making for
what we require is &#34;does it compile with this compiler on this platform? If
yes, then we appear to 
support it. can we guarantee that? only with buildbots or other CI
[continuous integration]&#34; - We&#39;re
generally not versed in specific language standards (aside from compiler
folks, who is?), and compilers don&#39;t comply strictly with all the shapes of
those anyways for either 
practical or hysterical reasons. So no matter what we claim to aspire to,
reality is always murkier.  A document about requirements is primarily
useful to give guidance to what we expect to be aligned with and what is or
isn&#39;t allowed to be used in 
new code.  Our code itself always has the final say. 
</blockquote>


<p>
The final result was a <a href="https://github.com/python/peps/commit/e846b706bbfd4653b850edc64e71b6889c724819">rather
small patch</a> to PEP 7 to say that CPython 3.11 and beyond use
C11 without the optional features (and that the public C API should be
compatible with C++).  In addition, <a href="https://bugs.python.org/issue46656">bug 46656</a> and a
February 25 <a href="https://lwn.net/ml/python-dev/CABqyc3xZBmWm_VgHNB17SPzpO93BTm3=J+1xb583f0VoN9C6tA@mail.gmail.com/">post</a>
from Stinner document the changes to the floating-point requirements; interestingly, they
do not mention IEEE 754, just a requirement for a floating-point NaN.  While it
may have seemed like a bit of a yak-shaving exercise along the way, the GCC
regression eventually led to a better understanding of which flavor of C is
supported for building CPython—along with moving to a flavor from this
century.  All in all, a good &#34;days&#34; work.
</p></div></div>
  </body>
</html>
