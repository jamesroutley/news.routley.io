<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://mywiki.wooledge.org/BashPitfalls">Original</a>
    <h1>Bash Pitfalls</h1>
    
    <div id="readability-page-1" class="page"><div dir="ltr" id="content" lang="en">
<p>This page is a compilation of common mistakes made by bash users. Each example is flawed in some way. <span id="line-6"></span><span id="line-7"></span></p> <h2 id="for_f_in_.24.28ls_.2A.mp3.29">1. for f in $(ls *.mp3)</h2>
<p>One of the most common mistakes <a href="http://mywiki.wooledge.org/BASH">BASH</a> programmers make is to write a loop like this: <span id="line-13"></span><span id="line-14"></span></p><pre><span id="line-1"></span>for f in $(ls *.mp3); do    # Wrong!
<span id="line-2"></span>    some command $f         # Wrong!
<span id="line-3"></span>done
<span id="line-4"></span>
<span id="line-5"></span>for f in $(ls)              # Wrong!
<span id="line-6"></span>for f in `ls`               # Wrong!
<span id="line-7"></span>
<span id="line-8"></span>for f in $(find . -type f)  # Wrong!
<span id="line-9"></span>for f in `find . -type f`   # Wrong!
<span id="line-10"></span>
<span id="line-11"></span>files=($(find . -type f))   # Wrong!
<span id="line-12"></span>for f in ${files[@]}        # Wrong!</pre><p>Yes, it would be great if you could just treat the output of <tt>ls</tt> or <tt>find</tt> as a list of filenames and iterate over it.  But you <strong>cannot</strong>.  This entire approach is fatally flawed, and there is no trick that can make it work.  You must use an entirely different approach. <span id="line-29"></span><span id="line-30"></span></p><p>There are at least 6 problems with this: <span id="line-31"></span><span id="line-32"></span></p><ol type="1"><li><p>If a filename contains whitespace (or any character in the current value of <tt>$IFS</tt>), it undergoes <a href="http://mywiki.wooledge.org/WordSplitting">WordSplitting</a>.  Assuming we have a file named <tt>01 - Don&#39;t Eat the Yellow Snow.mp3</tt> in the current directory, the <tt>for</tt> loop will iterate over each word in the resulting file name: <em>01</em>, <em>-</em>, <em>Don&#39;t</em>, <em>Eat</em>, etc. <span id="line-33"></span></p></li><li><p>If a filename contains <a href="http://mywiki.wooledge.org/glob">glob</a> characters, it undergoes filename expansion (&#34;<a href="http://mywiki.wooledge.org/glob">globbing</a>&#34;).  If <tt>ls</tt> produces any output containing a <strong>*</strong> character, the word containing it will become recognized as a pattern and substituted with a list of all filenames that match it. <span id="line-34"></span></p></li><li><p>If the command substitution returns multiple filenames, there is no way to tell where the first one ends and the second one begins.  Pathnames may contain <em>any</em> character except NUL.  Yes, this includes newlines. <span id="line-35"></span></p></li><li><p>The <tt>ls</tt> utility may mangle filenames.  Depending on which platform you&#39;re on, which arguments you used (or didn&#39;t use), and whether its standard output is pointing to a terminal or not, <tt>ls</tt> may randomly decide to replace certain characters in a filename with &#34;?&#34;, or simply not print them at all. <a href="http://mywiki.wooledge.org/ParsingLs">Never try to parse the output of ls</a>. <tt>ls</tt> is just plain unnecessary. It&#39;s an external command whose output is intended specifically to be read by a human, not parsed by a script. <span id="line-36"></span></p></li><li><p>The <a href="http://mywiki.wooledge.org/CommandSubstitution">CommandSubstitution</a> strips <em>all</em> trailing newline characters from its output.  That may seem desirable since <tt>ls</tt> adds a newline, but if the last filename in the list ends with a newline, <tt>`...`</tt> or <tt>$()</tt> will remove <em>that</em> one also. <span id="line-37"></span></p></li><li><p>In the <tt>ls</tt> examples, if the first filename starts with a hyphen, it may lead to <a href="http://mywiki.wooledge.org/BashPitfalls#pf3">pitfall #3</a>. <span id="line-38"></span><span id="line-39"></span></p></li></ol><p>You can&#39;t simply double-quote the substitution either: <span id="line-40"></span><span id="line-41"></span></p><pre><span id="line-1-1"></span>for f in &#34;$(ls *.mp3)&#34;; do     # Wrong!</pre><p>This causes the entire output of <tt>ls</tt> to be treated as a single word. Instead of iterating over each file name, the loop will only execute <em>once</em>, assigning to <tt>f</tt> a string with all the filenames rammed together. <span id="line-45"></span><span id="line-46"></span></p><p>Nor can you simply change <a href="http://mywiki.wooledge.org/IFS">IFS</a> to a newline.  Filenames can also contain newlines. <span id="line-47"></span><span id="line-48"></span></p><p>Another variation on this theme is abusing word splitting and a <tt>for</tt> loop to (incorrectly) read lines of a file.  For example: <span id="line-49"></span><span id="line-50"></span></p><pre><span id="line-1-2"></span>IFS=$&#39;\n&#39;
<span id="line-2-1"></span>for line in $(cat file); do ...     # Wrong!</pre><p><a href="http://mywiki.wooledge.org/DontReadLinesWithFor">This doesn&#39;t work</a>!  Especially if those lines are filenames.  Bash (or any other Bourne family shell) just doesn&#39;t work this way. <span id="line-55"></span><span id="line-56"></span></p><p><strong>So, what&#39;s the right way to do it?</strong> <span id="line-57"></span><span id="line-58"></span></p><p>There are several ways, primarily depending on whether you need a recursive expansion or not. <span id="line-59"></span><span id="line-60"></span></p><p>If you don&#39;t need recursion, you can use a simple <a href="http://mywiki.wooledge.org/glob">glob</a>.  Instead of <tt>ls</tt>: <span id="line-61"></span><span id="line-62"></span></p><pre><span id="line-1-3"></span>for file in ./*.mp3; do    # Better! and...
<span id="line-2-2"></span>    some command &#34;$file&#34;   # ...always double-quote expansions!
<span id="line-3-1"></span>done</pre><p>POSIX shells such as Bash have the globbing feature specifically for this purpose -- to allow the shell to expand patterns into a list of matching filenames. There is no need to interpret the results of an external utility. Because globbing is the very last expansion step, each match of the <tt>./*.mp3</tt> pattern correctly expands to a separate word, and isn&#39;t subject to the effects of an unquoted expansion. <span id="line-68"></span><span id="line-69"></span></p><p><em>Question:</em> What happens if there are no *.mp3-files in the current directory? Then the for loop is executed once, with file=&#34;./*.mp3&#34;, which is not the expected behavior! The workaround is to test whether there is a matching file: <span id="line-70"></span><span id="line-71"></span></p><pre><span id="line-1-4"></span># POSIX
<span id="line-2-3"></span>for file in ./*.mp3; do
<span id="line-3-2"></span>    [ -e &#34;$file&#34; ] || continue
<span id="line-4-1"></span>    some command &#34;$file&#34;
<span id="line-5-1"></span>done</pre><p>Another solution is to use Bash&#39;s <tt>shopt -s nullglob</tt> feature, though this should only be done after reading the documentation and carefully considering the effect of this setting on all other globs in the script. <span id="line-79"></span><span id="line-80"></span></p><p>If you need recursion, the standard solution is <tt>find</tt>.  When <a href="http://mywiki.wooledge.org/UsingFind">using find</a>, be sure you use it properly.  For POSIX sh portability, use the <tt>-exec</tt> option: <span id="line-81"></span><span id="line-82"></span></p><pre><span id="line-1-5"></span>find . -type f -name &#39;*.mp3&#39; -exec some command {} \;
<span id="line-2-4"></span>
<span id="line-3-3"></span># Or, if the command accepts multiple input filenames:
<span id="line-4-2"></span>
<span id="line-5-2"></span>find . -type f -name &#39;*.mp3&#39; -exec some command {} +</pre><p>If you&#39;re using bash, then you have two additional options.  One is to use GNU or BSD <tt>find</tt>&#39;s <tt>-print0</tt> option, together with bash&#39;s <tt>read -d &#39;&#39;</tt> option and a <a href="http://mywiki.wooledge.org/ProcessSubstitution">ProcessSubstitution</a>: <span id="line-90"></span><span id="line-91"></span></p><pre><span id="line-1-6"></span>while IFS= read -r -d &#39;&#39; file; do
<span id="line-2-5"></span>  some command &#34;$file&#34;
<span id="line-3-4"></span>done &lt; &lt;(find . -type f -name &#39;*.mp3&#39; -print0)</pre><p>The advantage here is that &#34;some command&#34; (indeed, the entire <tt>while</tt> loop body) is executed in the current shell.  You can set variables and have them <a href="http://mywiki.wooledge.org/BashFAQ/024">persist after the loop ends</a>. <span id="line-97"></span><span id="line-98"></span></p><p>The other option, available in <a href="http://mywiki.wooledge.org/BashFAQ/061">Bash 4.0 and higher</a>, is <tt>globstar</tt>, which permits a glob to be expanded recursively: <span id="line-99"></span><span id="line-100"></span></p><pre><span id="line-1-7"></span>shopt -s globstar
<span id="line-2-6"></span>for file in ./**/*.mp3; do
<span id="line-3-5"></span>  some command &#34;$file&#34;
<span id="line-4-3"></span>done</pre><p>Note the double quotes around <tt>$file</tt> in the examples above. This leads to our second pitfall: <span id="line-107"></span><span id="line-108"></span></p><h2 id="cp_.24file_.24target">2. cp $file $target</h2>
<p>What&#39;s wrong with the command shown above? Well, nothing, <strong>if</strong> you happen to know in advance that <tt>$file</tt> and <tt>$target</tt> have no white space (and you&#39;ve not modified <tt>$IFS</tt>, and you can guarantee the code won&#39;t be called in a context where <tt>$IFS</tt> may have been modified) or <a href="http://mywiki.wooledge.org/glob">wildcards</a> in them. However, the results of the expansions are still subject to <a href="http://mywiki.wooledge.org/WordSplitting">WordSplitting</a> and <a href="http://mywiki.wooledge.org/glob">pathname expansion</a>. Always double-quote parameter expansions. <span id="line-112"></span><span id="line-113"></span></p><pre><span id="line-1-8"></span>cp -- &#34;$file&#34; &#34;$target&#34;</pre><p>Without the double quotes, you&#39;ll get a command like <tt>cp 01 - Don&#39;t Eat the Yellow Snow.mp3 /mnt/usb</tt>, which will result in errors like <tt>cp: cannot stat `01&#39;: No such file or directory</tt>. If <tt>$file</tt> has wildcards in it (<strong>*</strong> or <strong>?</strong> or <strong>[</strong>), they will be <a href="http://mywiki.wooledge.org/glob">expanded</a> if there are files that match them. With the double quotes, all&#39;s well, unless &#34;$file&#34; happens to start with a <tt>-</tt>, in which case <tt>cp</tt> thinks you&#39;re trying to feed it command line options (See <a href="http://mywiki.wooledge.org/BashPitfalls#pf3">pitfall #3</a> below.) <span id="line-117"></span><span id="line-118"></span></p><p>Even in the somewhat uncommon circumstance that you can guarantee the variable contents, it is conventional and good practice to <a href="http://mywiki.wooledge.org/Quotes">quote</a> parameter expansions, especially if they contain file names. Experienced script writers will always use <a href="http://mywiki.wooledge.org/Quotes">quotes</a> except perhaps for a small number of cases in which it is <em>absolutely</em> obvious from the immediate code context that a parameter contains a guaranteed safe value. Experts will most likely consider the <tt>cp</tt> command in the title always wrong. You should too. <span id="line-119"></span><span id="line-120"></span></p><h2 id="Filenames_with_leading_dashes">3. Filenames with leading dashes</h2>
<p>Filenames with leading dashes can cause many problems. Globs like <tt>*.mp3</tt> are sorted into an expanded list (according to your current <a href="http://mywiki.wooledge.org/locale">locale</a>), and <tt>-</tt> sorts before letters in most locales. The list is then passed to some command, which may incorrectly interpret the <tt>-filename</tt> as an option. There are two major solutions to this. <span id="line-124"></span><span id="line-125"></span></p><p>One solution is to insert <tt>--</tt> between the command (like <tt>cp</tt>) and its arguments. That tells it to stop scanning for options, and all is well: <span id="line-126"></span><span id="line-127"></span></p><pre><span id="line-1-9"></span>cp -- &#34;$file&#34; &#34;$target&#34;</pre><p>There are potential problems with this approach. You have to be sure to insert <tt>--</tt> for <em>every</em> usage of the parameter in a context where it might possibly be interpreted as an option -- which is easy to miss and may involve a lot of redundancy. <span id="line-131"></span><span id="line-132"></span></p><p>Most well-written option parsing libraries understand this, and the programs that use them correctly should inherit that feature for free. However, still be aware that it is ultimately up to the application to recognize <em>end of options</em>. Some programs that manually parse options, or do it incorrectly, or use poor 3rd-party libraries may not recognize it. Standard utilities <em>should</em>, with a few exceptions that are specified by POSIX. <tt>echo</tt> is one example. <span id="line-133"></span><span id="line-134"></span></p><p>Another option is to ensure that your filenames always begin with a directory by using relative or absolute pathnames. <span id="line-135"></span><span id="line-136"></span></p><pre><span id="line-1-10"></span>for i in ./*.mp3; do
<span id="line-2-7"></span>    cp &#34;$i&#34; /target
<span id="line-3-6"></span>    ...
<span id="line-4-4"></span>done</pre><p>In this case, even if we have a file whose name begins with <tt>-</tt>, the glob will ensure that the variable always contains something like <tt>./-foo.mp3</tt>, which is perfectly safe as far as <tt>cp</tt> is concerned. <span id="line-143"></span><span id="line-144"></span></p><p>Finally, if you can guarantee that all results will have the same prefix, and are only using the variable a few times within a loop body, you can simply concatenate the prefix with the expansion. This gives a theoretical savings in generating and storing a few extra characters for each word. <span id="line-145"></span><span id="line-146"></span></p><pre><span id="line-1-11"></span>for i in *.mp3; do
<span id="line-2-8"></span>    cp &#34;./$i&#34; /target
<span id="line-3-7"></span>    ...
<span id="line-4-5"></span>done</pre><h2 id="A.5B_.24foo_.3D_.22bar.22_.5D">4. [ $foo = &#34;bar&#34; ]</h2>
<p>This is very similar to the issue in pitfall #2, but I repeat it because it&#39;s <em>so</em> important. In the example above, the <a href="http://mywiki.wooledge.org/Quotes">quotes</a> are in the wrong place. You do <em>not</em> need to quote a string literal in bash (unless it contains metacharacters or pattern characters). But you <em>should</em> quote your variables if you aren&#39;t sure whether they could contain white space or wildcards. <span id="line-156"></span><span id="line-157"></span></p><p>This example can break for several reasons: <span id="line-158"></span><span id="line-159"></span></p><ul><li><p>If a variable referenced in <tt>[</tt> doesn&#39;t exist, or is blank, then the <tt>[</tt> command would end up looking like: <span id="line-160"></span></p></li><li><span id="line-161"></span><span id="line-162"></span><pre><span id="line-1-12"></span>[ = &#34;bar&#34; ] # Wrong!</pre><span id="line-163"></span></li><li><p>...and will throw the error: <tt>unary operator expected</tt>. (The <tt>=</tt> operator is <em>binary</em>, not unary, so the <tt>[</tt> command is rather shocked to see it there.) <span id="line-164"></span><span id="line-165"></span></p></li><li><p>If the variable contains internal whitespace, then it gets <a href="http://mywiki.wooledge.org/WordSplitting">split into separate words</a> before the <tt>[</tt> command sees it. Thus: <span id="line-166"></span></p></li><li><span id="line-167"></span><span id="line-168"></span><pre><span id="line-1-13"></span>[ multiple words here = &#34;bar&#34; ]</pre><span id="line-169"></span></li><li><p>While that may look OK to you, it&#39;s a syntax error as far as <tt>[</tt> is concerned. The correct way to write this is: <span id="line-170"></span></p></li><li><span id="line-171"></span><span id="line-172"></span><span id="line-173"></span><pre><span id="line-1-14"></span># POSIX
<span id="line-2-9"></span>[ &#34;$foo&#34; = bar ] # Right!</pre><span id="line-174"></span></li><li><p>This works fine on POSIX-conformant implementations even if <tt>$foo</tt> begins with a <tt>-</tt>, because POSIX <tt>[</tt> determines its action depending on the number of arguments passed to it. Only very ancient shells have a problem with this, and you shouldn&#39;t worry about them when writing new code (see the <tt>x&#34;$foo&#34;</tt> workaround below). <span id="line-175"></span><span id="line-176"></span></p></li></ul><p>In Bash and many other ksh-like shells, there is a superior alternative which uses the <a href="http://mywiki.wooledge.org/BashFAQ/031">[[ keyword</a>. <span id="line-177"></span><span id="line-178"></span></p><pre><span id="line-1-15"></span># Bash / Ksh
<span id="line-2-10"></span>[[ $foo == bar ]] # Right!</pre><p>You don&#39;t need to quote variable references on the left-hand side of <tt>=</tt> in <tt>[[ ]]</tt> because they don&#39;t undergo word splitting or <a href="http://mywiki.wooledge.org/glob">globbing</a>, and even blank variables will be handled correctly. On the other hand, quoting them won&#39;t hurt anything either. Unlike <tt>[</tt> and <tt>test</tt>, you may also use the identical <tt>==</tt>. Do note however that comparisons using <tt>[[</tt> perform pattern matching against the string on the right hand side, not just a plain string comparison. To make the string on the right literal, you must quote it if any characters that have special meaning in pattern matching contexts are used. <span id="line-183"></span><span id="line-184"></span></p><pre><span id="line-1-16"></span># Bash / Ksh
<span id="line-2-11"></span>match=b*r
<span id="line-3-8"></span>[[ $foo == &#34;$match&#34; ]] # Good! Unquoted would also match against the pattern b*r.</pre><p>You may have seen code like this: <span id="line-190"></span><span id="line-191"></span></p><pre><span id="line-1-17"></span># POSIX / Bourne
<span id="line-2-12"></span>[ x&#34;$foo&#34; = xbar ] # Ok, but usually unnecessary.</pre><p>The <tt>x&#34;$foo&#34;</tt> hack is required for code that must run on <em>very</em> ancient shells which lack <a href="http://mywiki.wooledge.org/BashFAQ/031">[[</a>, and have a more primitive <tt>[</tt>, which gets confused if <tt>$foo</tt> begins with a <tt>-</tt>. On said older systems, <tt>[</tt> still doesn&#39;t care whether the token on the right hand side of the <tt>=</tt> begins with a <tt>-</tt>. It just uses it literally. It&#39;s just the left-hand side that needs extra caution. <span id="line-196"></span><span id="line-197"></span></p><p>Note that shells that require this workaround are not POSIX-conforming. Even the Heirloom Bourne shell doesn&#39;t require this (probably the non-POSIX Bourne shell clone that&#39;s still most widely in use as a system shell). Such extreme portability is rarely a requirement and makes your code less readable (and uglier). <span id="line-198"></span><span id="line-199"></span></p><h2 id="cd_.24.28dirname_.22.24f.22.29">5. cd $(dirname &#34;$f&#34;)</h2>
<p>This is yet another <a href="http://mywiki.wooledge.org/Quotes">quoting</a> error. As with a variable expansion, the result of a <a href="http://mywiki.wooledge.org/CommandSubstitution">CommandSubstitution</a> undergoes <a href="http://mywiki.wooledge.org/WordSplitting">WordSplitting</a> and <a href="http://mywiki.wooledge.org/glob">pathname expansion</a>. So you should quote it: <span id="line-203"></span><span id="line-204"></span></p><pre><span id="line-1-18"></span>cd -P -- &#34;$(dirname -- &#34;$f&#34;)&#34;</pre><p>What&#39;s not obvious here is how the <a href="http://mywiki.wooledge.org/Quotes">quotes</a> nest. A C programmer reading this would expect the first and second double-quotes to be grouped together; and then the third and fourth. But that&#39;s not the case in Bash. Bash treats the double-quotes <em>inside</em> the command substitution as one pair, and the double-quotes <em>outside</em> the substitution as another pair. <span id="line-208"></span><span id="line-209"></span></p><p>Another way of writing this: the parser treats the command substitution as a &#34;nesting level&#34;, and the quotes inside it are separate from the quotes outside it. <span id="line-210"></span><span id="line-211"></span></p><h2 id="A.5B_.22.24foo.22_.3D_bar_.26.26_.22.24bar.22_.3D_foo_.5D">6. [ &#34;$foo&#34; = bar &amp;&amp; &#34;$bar&#34; = foo ]</h2>
<p>You can&#39;t use <tt>&amp;&amp;</tt> inside the <a href="http://mywiki.wooledge.org/BashFAQ/031">old test (or [) command</a>. The Bash parser sees <tt>&amp;&amp;</tt> outside of <tt>[[ ]]</tt> or <tt>(( ))</tt> and breaks your command into <em>two</em> commands, before and after the <tt>&amp;&amp;</tt>. Use one of these instead: <span id="line-215"></span><span id="line-216"></span></p><pre><span id="line-1-19"></span>[ bar = &#34;$foo&#34; ] &amp;&amp; [ foo = &#34;$bar&#34; ] # Right! (POSIX)
<span id="line-2-13"></span>[[ $foo = bar &amp;&amp; $bar = foo ]]       # Also right! (Bash / Ksh)</pre><p>(Note that we reversed the constant and the variable inside <tt>[</tt> for the legacy reasons discussed in pitfall #4. We could also have reversed the <tt>[[</tt> case, but the expansions would require quoting to prevent interpretation as a pattern.) The same thing applies to <tt>||</tt>. Either use <tt>[[</tt> instead, or use two <tt>[</tt> commands. <span id="line-221"></span><span id="line-222"></span></p><p>Avoid this: <span id="line-223"></span><span id="line-224"></span></p><pre><span id="line-1-20"></span>[ bar = &#34;$foo&#34; -a foo = &#34;$bar&#34; ] # Not portable.</pre><p>The binary <tt>-a</tt> and <tt>-o</tt>, and <tt>(</tt> / <tt>)</tt> (grouping) operators are XSI extensions to the POSIX standard. All are marked as obsolescent in POSIX-2008. They should not be used in new code. One of the practical problems with <tt>[ A = B -a C = D ]</tt> (or <tt>-o</tt>) is that <a href="http://www.opengroup.org/onlinepubs/9699919799/utilities/test.html">POSIX does not specify</a> the results of a <tt>test</tt> or <tt>[</tt> command with more than 4 arguments. It probably works in most shells, but you can&#39;t count on it. If you have to write for POSIX shells, then you should use two <tt>test</tt> or <tt>[</tt> commands separated by a <tt>&amp;&amp;</tt> operator instead. <span id="line-228"></span><span id="line-229"></span></p><h2 id="A.5B.5B_.24foo_.3E_7_.5D.5D">7. [[ $foo &gt; 7 ]]</h2>
<p>There are multiple issues here. First, the <a href="http://mywiki.wooledge.org/BashFAQ/031">[[ command</a> should <em>not</em> be used solely for evaluating <a href="http://mywiki.wooledge.org/ArithmeticExpression">arithmetic expressions</a>. It should be used for test expressions involving one of the supported test operators. Though technically you <em>can</em> do math using some of <tt>[[</tt>&#39;s operators, it only makes sense to do so in conjunction with one of the non-math test operators somewhere in the expression. If you just want to do a numeric comparison (or any other shell arithmetic), it is much better to just use <tt>(( ))</tt> instead: <span id="line-233"></span><span id="line-234"></span></p><pre><span id="line-1-21"></span># Bash / Ksh
<span id="line-2-14"></span>((foo &gt; 7))     # Right!
<span id="line-3-9"></span>[[ foo -gt 7 ]] # Works, but is uncommon. Use ((...)) instead.</pre><p>If you use the <tt>&gt;</tt> operator inside <tt>[[ ]]</tt>, it&#39;s treated as a string comparison (test for collation order by locale), <em>not</em> an integer comparison. This may work sometimes, but it will fail when you least expect it. If you use <tt>&gt;</tt> inside <tt>[ ]</tt>, it&#39;s even worse: it&#39;s an output redirection. You&#39;ll get a file named <tt>7</tt> in your directory, and the test will succeed as long as <tt>$foo</tt> is not empty. <span id="line-240"></span><span id="line-241"></span></p><p>If strict POSIX-conformance is a requirement, and <tt>((</tt> is not available, then the correct alternative using <tt>[</tt> is <span id="line-242"></span><span id="line-243"></span></p><pre><span id="line-1-22"></span># POSIX
<span id="line-2-15"></span>[ &#34;$foo&#34; -gt 7 ]       # Also right!
<span id="line-3-10"></span>[ &#34;$((foo &gt; 7))&#34; -ne 0 ] # POSIX-compatible equivalent to ((, for more general math operations.</pre><p>If the contents of <tt>$foo</tt> is not sanitised and its contents is not under your control (if for instance it&#39;s coming from an external source), then all but <tt>[ &#34;$foo&#34; -gt 7 ]</tt> constitute an arbitrary command injection vulnerability as the contents of <tt>$foo</tt> is interpreted as an arithmetic expression (and for instance, the <tt>a[$(reboot)]</tt> arithmetic expression would run the <tt>reboot</tt> command when evaluated). The <tt>[</tt> builtin requires the operands be <em>decimal</em> integers, so it not affected. But it&#39;s critical that <tt>$foo</tt> be quoted, or you&#39;d still get a command injection vulnerability (for instance with values such as <tt>-v a[$(reboot)] -o 8</tt>). <span id="line-250"></span><span id="line-251"></span></p><p>If the input to any arithmetic context (including <tt>((</tt>, <tt>let</tt>, array indices), or <tt>[[ ... ]]</tt> test expressions involving numeric comparisons can&#39;t be guaranteed then you must <em>always</em> <a href="http://mywiki.wooledge.org/BashFAQ/054">validate your input before evaluating the expression</a>. <span id="line-252"></span><span id="line-253"></span></p><pre><span id="line-1-23"></span># POSIX
<span id="line-2-16"></span>case $foo in
<span id="line-3-11"></span>    (&#34;&#34; | *[!0123456789]*)
<span id="line-4-6"></span>        printf &#39;$foo is not a sequence of decimal digits: &#34;%s&#34;\n&#39; &#34;$foo&#34; &gt;&amp;2
<span id="line-5-3"></span>        exit 1
<span id="line-6-1"></span>        ;;
<span id="line-7-1"></span>    *)
<span id="line-8-1"></span>        [ &#34;$foo&#34; -gt 7 ]
<span id="line-9-1"></span>esac</pre><p>Note that as <tt>[</tt>/<tt>test</tt>&#39;s arithmetic operator expect <em>decimal</em> integers, 010 for instance would be interpreted as the number 10, not 8 expressed in octal. In <tt>bash</tt>, <tt>[ 010 -gt 8 ]</tt> would return true, while <tt>[[ 010 -gt 8 ]]</tt> and <tt>(( 010 &gt; 8 ))</tt> would return false. <span id="line-266"></span><span id="line-267"></span></p><h2 id="grep_foo_bar_.7C_while_read_-r.3B_do_.28.28count.2B-.2B-.29.29.3B_done">8. grep foo bar | while read -r; do ((count++)); done</h2>
<p>The code above looks OK at first glance, doesn&#39;t it? Sure, it&#39;s just a poor implementation of <tt>grep -c</tt>, but it&#39;s intended as a simplistic example. Changes to <tt>count</tt> won&#39;t propagate outside the <tt>while</tt> loop because each command in a pipeline is executed in a separate <a href="http://mywiki.wooledge.org/SubShell">SubShell</a>. This surprises almost every Bash beginner at some point. <span id="line-271"></span><span id="line-272"></span></p><p>POSIX doesn&#39;t specify whether or not the last element of a pipeline is evaluated in a subshell. Some shells such as ksh93 and Bash &gt;= 4.2 with <tt>shopt -s lastpipe</tt> enabled will run the <tt>while</tt> loop in this example in the original shell process, allowing any side-effects within to take effect. Therefore, portable scripts must be written in such a way as to not depend upon either behavior. <span id="line-273"></span><span id="line-274"></span></p><p>For workarounds for this and similar issues, please see <a href="http://mywiki.wooledge.org/BashFAQ/024">Bash FAQ #24</a>. It&#39;s a bit too long to fit here. <span id="line-275"></span><span id="line-276"></span></p><h2 id="if_.5Bgrep_foo_myfile.5D">9. if [grep foo myfile]</h2>
<p>Many beginners have an incorrect intuition about <tt>if</tt> statements brought about by seeing the very common pattern of an <tt>if</tt> keyword followed immediately by a <tt>[</tt> or <tt>[[</tt>. This convinces people that the <tt>[</tt> is somehow part of the <tt>if</tt> statement&#39;s syntax, just like parentheses used in C&#39;s <tt>if</tt> statement. <span id="line-280"></span><span id="line-281"></span></p><p>This is <em>not</em> the case! <tt>if</tt> takes a <em>command</em>. <tt>[</tt> is a command, not a syntax marker for the <tt>if</tt> statement. It&#39;s equivalent to the <tt>test</tt> command, except that the final argument must be a <tt>]</tt>. For example: <span id="line-282"></span><span id="line-283"></span></p><pre><span id="line-1-24"></span># POSIX
<span id="line-2-17"></span>if [ false ]; then echo &#34;HELP&#34;; fi
<span id="line-3-12"></span>if test false; then echo &#34;HELP&#34;; fi</pre><p>are equivalent -- both checking that the argument &#34;false&#34; is non-empty. In both cases HELP will always be printed, to the surprise of programmers from other languages guessing about shell syntax. <span id="line-289"></span><span id="line-290"></span></p><p>The syntax of an <tt>if</tt> statement is: <span id="line-291"></span><span id="line-292"></span></p><pre><span id="line-1-25"></span>if COMMANDS
<span id="line-2-18"></span>then &lt;COMMANDS&gt;
<span id="line-3-13"></span>elif &lt;COMMANDS&gt; # optional
<span id="line-4-7"></span>then &lt;COMMANDS&gt;
<span id="line-5-4"></span>else &lt;COMMANDS&gt; # optional
<span id="line-6-2"></span>fi # required</pre><p>Once again, <tt>[</tt> is a command. It takes arguments like any other regular <em>simple command</em>. <tt>if</tt> is a <em>compound command</em> which contains other commands -- and <strong>there is no [</strong> in its syntax! <span id="line-301"></span><span id="line-302"></span></p><p>While bash has a builtin command <tt>[</tt> and thus <tt>knows</tt> about <tt>[</tt> it has nothing special to do with <tt>]</tt>. Bash only passes <tt>]</tt> as argument to the <tt>[</tt> command, which requires <tt>]</tt> to be the last argument only to make scripts look better. <span id="line-303"></span><span id="line-304"></span></p><p>There may be zero or more optional <tt>elif</tt> sections, and one optional <tt>else</tt> section. <span id="line-305"></span><span id="line-306"></span></p><p>The <tt>if</tt> compound command is made up of two or more sections containing <em>lists</em> of commands, each delimited by a <tt>then</tt>, <tt>elif</tt>, or <tt>else</tt> keyword, and is terminated by the <tt>fi</tt> keyword. The exit status of the final command of the first section and each subsequent <tt>elif</tt> section determines whether each corresponding <tt>then</tt> section is evaluated. Another <tt>elif</tt> is evaluated until one of the <tt>then</tt> sections is executed. If no <tt>then</tt> section is evaluated, then the <tt>else</tt> branch is taken, or if no <tt>else</tt> is given, the <tt>if</tt> block is complete and the overall <tt>if</tt> command returns 0 (true). <span id="line-307"></span><span id="line-308"></span></p><p>If you want to make a decision based on the output of a <tt>grep</tt> command, you do <em>not</em> want to enclose it in parentheses, brackets, backticks, or <em>any other</em> syntax! Just use <tt>grep</tt> as the <tt>COMMANDS</tt> after the <tt>if</tt>, like this: <span id="line-309"></span><span id="line-310"></span></p><pre><span id="line-1-26"></span>if grep -q fooregex myfile; then
<span id="line-2-19"></span>...
<span id="line-3-14"></span>fi</pre><p>If the <tt>grep</tt> matches a line from <tt>myfile</tt>, then the exit code will be 0 (true), and the <tt>then</tt> part will be executed. Otherwise, if there are no matches, <tt>grep</tt> will return non-zero and the overall <tt>if</tt> command will be zero. <span id="line-316"></span><span id="line-317"></span></p><p><strong>See also:</strong> <span id="line-318"></span><span id="line-319"></span></p><ul><li><p><a href="http://mywiki.wooledge.org/BashGuide/TestsAndConditionals">BashGuide/TestsAndConditionals</a> <span id="line-320"></span></p></li><li><p><a href="http://wiki.bash-hackers.org/syntax/ccmd/if_clause">http://wiki.bash-hackers.org/syntax/ccmd/if_clause</a> <span id="line-321"></span><span id="line-322"></span></p></li></ul><h2 id="if_.5Bbar.3D.22.24foo.22.5D.3B_then_...">10. if [bar=&#34;$foo&#34;]; then ...</h2>
<pre><span id="line-1-27"></span>[bar=&#34;$foo&#34;]     # Wrong!
<span id="line-2-20"></span>[ bar=&#34;$foo&#34; ]   # Still wrong!
<span id="line-3-15"></span>[bar = &#34;$foo&#34;]   # Also wrong!
<span id="line-4-8"></span>[[bar=&#34;$foo&#34;]]   # Wrong again!
<span id="line-5-5"></span>[[ bar=&#34;$foo&#34; ]] # Guess what?  Wrong!
<span id="line-6-3"></span>[[bar = &#34;$foo&#34;]] # Do I really need to say it....</pre><p>As explained in the previous example, <tt>[</tt> is a command (which can be proven with <tt>type -t [</tt> or <tt>whence -v [</tt>). Just like with any other simple command, Bash expects the command to be followed by a space, then the first argument, then another space, etc. You can&#39;t just run things all together without putting the spaces in! Here are the correct ways: <span id="line-335"></span><span id="line-336"></span></p><pre><span id="line-1-28"></span>if [ bar = &#34;$foo&#34; ]; then ...
<span id="line-2-21"></span>
<span id="line-3-16"></span>if [[ bar = &#34;$foo&#34; ]]; then ...</pre><p>In the first form, <tt>[</tt> is the command name, and <tt>bar</tt>, <tt>=</tt>, the expansion of <tt>&#34;$foo&#34;</tt>, and <tt>]</tt> are separate <a href="http://mywiki.wooledge.org/Arguments">arguments</a> to it. There must be whitespace between each pair of arguments, so the shell knows where each argument begins and ends.  The second form is similar, except that <tt>[[</tt> is a special keyword, which is terminated by the <tt>]]</tt>.  For more details on the difference between the two, see <a href="http://mywiki.wooledge.org/BashFAQ/031">Bash FAQ 31</a>. <span id="line-343"></span><span id="line-344"></span></p><h2 id="if_.5B_.5B_a_.3D_b_.5D_.26.26_.5B_c_.3D_d_.5D_.5D.3B_then_...">11. if [ [ a = b ] &amp;&amp; [ c = d ] ]; then ...</h2>
<p>Here we go again. <tt>[</tt> is a <em>command</em>. It is not a syntactic marker that sits between <tt>if</tt> and some sort of C-like &#34;condition&#34;. Nor is it used for grouping. You cannot take C-like <tt>if</tt> commands and translate them into Bash commands just by replacing parentheses with square brackets! <span id="line-348"></span><span id="line-349"></span></p><p>If you want to express a compound conditional, do this: <span id="line-350"></span><span id="line-351"></span></p><pre><span id="line-1-29"></span>if [ a = b ] &amp;&amp; [ c = d ]; then ...</pre><p>Note that here we have two <em>commands</em> after the <tt>if</tt>, joined by an <tt>&amp;&amp;</tt> (logical AND, shortcut evaluation) operator. It&#39;s precisely the same as: <span id="line-355"></span><span id="line-356"></span></p><pre><span id="line-1-30"></span>if test a = b &amp;&amp; test c = d; then ...</pre><p>If the first <tt>test</tt> command returns false, the body of the <tt>if</tt> statement is not entered. If it returns true, then the second <tt>test</tt> command is run; and if that also one returns true, then the body of the <tt>if</tt> statement <em>will</em> be entered.  (C programmers are already familiar with <tt>&amp;&amp;</tt>.  Bash uses the same <em>short-circuit evaluation</em>.  Likewise <tt>||</tt> does short-circuit evaluation for the <em>OR</em> operation.) <span id="line-360"></span><span id="line-361"></span></p><p>The <a href="http://mywiki.wooledge.org/BashFAQ/031">[[ keyword</a> <em>does</em> permit the use of <tt>&amp;&amp;</tt>, so it could also be written this way: <span id="line-362"></span><span id="line-363"></span></p><pre><span id="line-1-31"></span>if [[ a = b &amp;&amp; c = d ]]; then ...</pre><p>See <a href="http://mywiki.wooledge.org/BashPitfalls#pf6">pitfall #6</a> for a pitfall related to <em>tests</em> combined with conditional operators. <span id="line-367"></span><span id="line-368"></span></p><h2 id="read_.24foo">12. read $foo</h2>
<p>You don&#39;t use a <tt>$</tt> before the variable name in a <tt>read</tt> command.  If you want to put data into the variable named <tt>foo</tt>, you do it like this: <span id="line-372"></span><span id="line-373"></span></p><ul><li><span id="line-374"></span><span id="line-375"></span><pre><span id="line-1-32"></span> read foo</pre><span id="line-376"></span><span id="line-377"></span></li></ul><p>Or more safely: <span id="line-378"></span><span id="line-379"></span></p><ul><li><span id="line-380"></span><span id="line-381"></span><pre><span id="line-1-33"></span> IFS= read -r foo</pre><span id="line-382"></span><span id="line-383"></span></li></ul><p><tt>read $foo</tt> would read a line of input and put it in the variable(s) whose name(s) are in <tt>$foo</tt>.  This might be useful if you actually intended <tt>foo</tt> to be a <a href="http://mywiki.wooledge.org/BashFAQ/006">reference</a> to some other variable; but in the majority of cases, this is simply a bug. <span id="line-384"></span><span id="line-385"></span></p><h2 id="cat_file_.7C_sed_s.2Ffoo.2Fbar.2F_.3E_file">13. cat file | sed s/foo/bar/ &gt; file</h2>
<p>You <strong>cannot</strong> read from a file and write to it in the same pipeline. Depending on what your pipeline does, the file may be clobbered (to 0 bytes, or possibly to a number of bytes equal to the size of your operating system&#39;s pipeline buffer), or it may grow until it fills the available disk space, or reaches your operating system&#39;s file size limitation, or your quota, etc. <span id="line-389"></span><span id="line-390"></span></p><p>If you want to make a change to a file safely, other than appending to the end of it, use a text editor. <span id="line-391"></span><span id="line-392"></span></p><ul><li><span id="line-393"></span><span id="line-394"></span><pre><span id="line-1-34"></span> printf %s\\n &#39;,s/foo/bar/g&#39; w q | ed -s file</pre><span id="line-395"></span><span id="line-396"></span></li></ul><p>If you are doing something that cannot be done with a text editor there <em>must</em> be a temporary file created at some point(*). For example, the following is completely portable: <span id="line-397"></span><span id="line-398"></span></p><ul><li><span id="line-399"></span><span id="line-400"></span><pre><span id="line-1-35"></span> sed &#39;s/foo/bar/g&#39; file &gt; tmpfile &amp;&amp; mv tmpfile file</pre><span id="line-401"></span><span id="line-402"></span></li></ul><p>The following will <em>only</em> work on GNU sed 4.x: <span id="line-403"></span><span id="line-404"></span></p><ul><li><span id="line-405"></span><span id="line-406"></span><pre><span id="line-1-36"></span> sed -i &#39;s/foo/bar/g&#39; file(s)</pre><span id="line-407"></span><span id="line-408"></span></li></ul><p>Note that this also creates a temporary file, and does the same sort of renaming trickery -- it just handles it transparently. <span id="line-409"></span><span id="line-410"></span></p><p>And the following equivalent command requires perl 5.x: <span id="line-411"></span><span id="line-412"></span></p><ul><li><span id="line-413"></span><span id="line-414"></span><pre><span id="line-1-37"></span> perl -pi -e &#39;s/foo/bar/g&#39; file(s)</pre><span id="line-415"></span><span id="line-416"></span></li></ul><p>For more details on replacing contents of files, please see <a href="http://mywiki.wooledge.org/BashFAQ/021">Bash FAQ #21</a>. <span id="line-417"></span><span id="line-418"></span></p><p>(*) <tt>sponge</tt> from <a href="http://packages.debian.org/sid/moreutils">moreutils</a> uses this example in its manual: <span id="line-419"></span><span id="line-420"></span></p><ul><li><span id="line-421"></span><span id="line-422"></span><pre><span id="line-1-38"></span> sed &#39;...&#39; file | grep &#39;...&#39; | sponge file</pre><span id="line-423"></span><span id="line-424"></span></li></ul><p>Rather than using a temporary file plus an atomic <tt>mv</tt>, this version &#34;soaks up&#34; (the actual description in the manual!) all the data, before opening and writing to the <tt>file</tt>.  This version will cause data loss if the program or system crashes during the write operation, because there&#39;s no copy of the original file on disk at that point. <span id="line-425"></span><span id="line-426"></span></p><p>Using a temporary file + <tt>mv</tt> still incurs a slight risk of data loss in case of a system crash / power loss; to be 100% certain that either the old or the new file will survive a power loss, you must use <tt>sync</tt> before the <tt>mv</tt>. <span id="line-427"></span><span id="line-428"></span></p><h2 id="echo_.24foo">14. echo $foo</h2>
<p>This relatively innocent-looking command causes <em>massive</em> confusion. Because the <tt>$foo</tt> isn&#39;t <a href="http://mywiki.wooledge.org/Quotes">quoted</a>, it will not only be subject to <a href="http://mywiki.wooledge.org/WordSplitting">WordSplitting</a>, but also file <a href="http://mywiki.wooledge.org/glob">globbing</a>. This misleads Bash programmers into thinking their variables <em>contain</em> the wrong values, when in fact the variables are OK -- it&#39;s just the word splitting or filename expansion that&#39;s messing up their view of what&#39;s happening. <span id="line-432"></span><span id="line-433"></span></p><ul><li><span id="line-434"></span><span id="line-435"></span><span id="line-436"></span><pre><span id="line-1-39"></span> msg=&#34;Please enter a file name of the form *.zip&#34;
<span id="line-2-22"></span> echo $msg</pre><span id="line-437"></span><span id="line-438"></span></li></ul><p>This message is split into words and any globs are expanded, such as the *.zip. What will your users think when they see this message: <span id="line-439"></span><span id="line-440"></span></p><ul><li><span id="line-441"></span><span id="line-442"></span><pre><span id="line-1-40"></span> Please enter a file name of the form freenfss.zip lw35nfss.zip</pre><span id="line-443"></span><span id="line-444"></span></li></ul><p>To demonstrate: <span id="line-445"></span><span id="line-446"></span></p><ul><li><span id="line-447"></span><span id="line-448"></span><span id="line-449"></span><span id="line-450"></span><pre><span id="line-1-41"></span> var=&#34;*.zip&#34;   # var contains an asterisk, a period, and the word &#34;zip&#34;
<span id="line-2-23"></span> echo &#34;$var&#34;   # writes *.zip
<span id="line-3-17"></span> echo $var     # writes the list of files which end with .zip</pre><span id="line-451"></span><span id="line-452"></span></li></ul><p>In fact, the <tt>echo</tt> command cannot be used with absolute safety here. If the variable contains <tt>-n</tt> for example, <tt>echo</tt> will consider that an option, rather than data to be printed. The only absolutely <em>sure</em> way to print the value of a variable is using <tt>printf</tt>: <span id="line-453"></span><span id="line-454"></span></p><ul><li><span id="line-455"></span><span id="line-456"></span><pre><span id="line-1-42"></span> printf &#34;%s\n&#34; &#34;$foo&#34;</pre><span id="line-457"></span><span id="line-458"></span></li></ul><h2 id="A.24foo.3Dbar">15. $foo=bar</h2>
<p>No, you don&#39;t assign a variable by putting a <tt>$</tt> in front of the variable name. This isn&#39;t perl. <span id="line-462"></span><span id="line-463"></span></p><h2 id="foo_.3D_bar">16. foo = bar</h2>
<p>No, you can&#39;t put spaces around the <tt>=</tt> when assigning to a variable. This isn&#39;t C. When you write <tt>foo = bar</tt> the shell splits it into three words. The first word, <tt>foo</tt>, is taken as the command name. The second and third become the arguments to that command. <span id="line-467"></span><span id="line-468"></span></p><p>Likewise, the following are also wrong: <span id="line-469"></span><span id="line-470"></span></p><ul><li><span id="line-471"></span><span id="line-472"></span><span id="line-473"></span><span id="line-474"></span><span id="line-475"></span><span id="line-476"></span><span id="line-477"></span><pre><span id="line-1-43"></span> foo= bar    # WRONG!
<span id="line-2-24"></span> foo =bar    # WRONG!
<span id="line-3-18"></span> $foo = bar; # COMPLETELY WRONG!
<span id="line-4-9"></span>
<span id="line-5-6"></span> foo=bar     # Right.
<span id="line-6-4"></span> foo=&#34;bar&#34;   # More Right.</pre><span id="line-478"></span><span id="line-479"></span></li></ul><h2 id="echo_.3C.3CEOF">17. echo &lt;&lt;EOF</h2>
<p>A here document is a useful tool for embedding large blocks of textual data in a script. It causes a redirection of the lines of text in the script to the standard input of a command. Unfortunately, <tt>echo</tt> is not a command which reads from stdin. <span id="line-483"></span><span id="line-484"></span></p><ul><li><span id="line-485"></span><span id="line-486"></span><span id="line-487"></span><span id="line-488"></span><span id="line-489"></span><span id="line-490"></span><span id="line-491"></span><span id="line-492"></span><span id="line-493"></span><span id="line-494"></span><span id="line-495"></span><span id="line-496"></span><span id="line-497"></span><span id="line-498"></span><span id="line-499"></span><span id="line-500"></span><pre><span id="line-1-44"></span>  # This is wrong:
<span id="line-2-25"></span>  echo &lt;&lt;EOF
<span id="line-3-19"></span>  Hello world
<span id="line-4-10"></span>  How&#39;s it going?
<span id="line-5-7"></span>  EOF
<span id="line-6-5"></span>
<span id="line-7-2"></span>  # This is what you were trying to do:
<span id="line-8-2"></span>  cat &lt;&lt;EOF
<span id="line-9-2"></span>  Hello world
<span id="line-10-1"></span>  How&#39;s it going?
<span id="line-11-1"></span>  EOF
<span id="line-12-1"></span>
<span id="line-13"></span>  # Or, use quotes which can span multiple lines (efficient, echo is built-in):
<span id="line-14"></span>  echo &#34;Hello world
<span id="line-15"></span>  How&#39;s it going?&#34;</pre><span id="line-501"></span><span id="line-502"></span></li></ul><p>Using quotes like that is fine -- it works great, in all shells -- but it doesn&#39;t let you just drop a block of lines into the script.  There&#39;s syntactic markup on the first and last line.  If you want to have your lines untouched by shell syntax, and don&#39;t want to spawn a <tt>cat</tt> command, here&#39;s another alternative: <span id="line-503"></span><span id="line-504"></span></p><ul><li><span id="line-505"></span><span id="line-506"></span><span id="line-507"></span><span id="line-508"></span><span id="line-509"></span><span id="line-510"></span><pre><span id="line-1-45"></span>  # Or use printf (also efficient, printf is built-in):
<span id="line-2-26"></span>  printf %s &#34;\
<span id="line-3-20"></span>  Hello world
<span id="line-4-11"></span>  How&#39;s it going?
<span id="line-5-8"></span>  &#34;</pre><span id="line-511"></span><span id="line-512"></span></li></ul><p>In the <tt>printf</tt> example, the <tt>\</tt> on the first line prevents an extra newline at the beginning of the text block.  There&#39;s a literal newline at the end (because the final quote is on a new line).  The lack of <tt>\n</tt> in the printf format argument prevents <tt>printf</tt> adding an extra newline at the end.  The <tt>\</tt> trick won&#39;t work in single quotes.  If you need/want single quotes around the block of text, you have two choices, both of which necessitate shell syntax &#34;contaminating&#34; your data: <span id="line-513"></span><span id="line-514"></span></p><ul><li><span id="line-515"></span><span id="line-516"></span><span id="line-517"></span><span id="line-518"></span><span id="line-519"></span><span id="line-520"></span><span id="line-521"></span><pre><span id="line-1-46"></span>  printf %s \
<span id="line-2-27"></span>  &#39;Hello world
<span id="line-3-21"></span>  &#39;
<span id="line-4-12"></span>
<span id="line-5-9"></span>  printf %s &#39;Hello world
<span id="line-6-6"></span>  &#39;</pre><span id="line-522"></span><span id="line-523"></span></li></ul><h2 id="su_-c_.27some_command.27">18. su -c &#39;some command&#39;</h2>
<p>This syntax is <em>almost</em> correct. The problem is, on many platforms, <tt>su</tt> takes a <tt>-c</tt> argument, but it&#39;s not the one you want. For example, on OpenBSD: <span id="line-527"></span><span id="line-528"></span></p><ul><li><span id="line-529"></span><span id="line-530"></span><span id="line-531"></span><pre><span id="line-1-47"></span> $ su -c &#39;echo hello&#39;
<span id="line-2-28"></span> su: only the superuser may specify a login class</pre><span id="line-532"></span><span id="line-533"></span></li></ul><p>You want to pass <tt>-c &#39;some command&#39;</tt> to a shell, which means you need a username before the <tt>-c</tt>. <span id="line-534"></span><span id="line-535"></span></p><ul><li><span id="line-536"></span><span id="line-537"></span><pre><span id="line-1-48"></span> su root -c &#39;some command&#39; # Now it&#39;s right.</pre><span id="line-538"></span><span id="line-539"></span></li></ul><p><tt>su</tt> assumes a username of root when you omit one, but this falls on its face when you want to pass a command to the shell afterward. You must supply the username in this case. <span id="line-540"></span><span id="line-541"></span></p><h2 id="cd_.2Ffoo.3B_bar">19. cd /foo; bar</h2>
<p>If you don&#39;t check for errors from the <tt>cd</tt> command, you might end up executing <tt>bar</tt> in the wrong place. This could be a major disaster, if for example <tt>bar</tt> happens to be <tt>rm -f *</tt>. <span id="line-545"></span><span id="line-546"></span></p><p>You must <strong>always</strong> check for errors from a <tt>cd</tt> command. The simplest way to do that is: <span id="line-547"></span><span id="line-548"></span></p><ul><li><span id="line-549"></span><span id="line-550"></span><pre><span id="line-1-49"></span> cd /foo &amp;&amp; bar</pre><span id="line-551"></span><span id="line-552"></span></li></ul><p>If there&#39;s more than just one command after the <tt>cd</tt>, you might prefer this: <span id="line-553"></span><span id="line-554"></span></p><ul><li><span id="line-555"></span><span id="line-556"></span><span id="line-557"></span><span id="line-558"></span><span id="line-559"></span><pre><span id="line-1-50"></span> cd /foo || exit 1
<span id="line-2-29"></span> bar
<span id="line-3-22"></span> baz
<span id="line-4-13"></span> bat ... # Lots of commands.</pre><span id="line-560"></span><span id="line-561"></span></li></ul><p><tt>cd</tt> will report the failure to change directories, with a stderr message such as &#34;bash: cd: /foo: No such file or directory&#34;. If you want to add your own message in stdout, however, you could use command grouping: <span id="line-562"></span><span id="line-563"></span></p><ul><li><span id="line-564"></span><span id="line-565"></span><span id="line-566"></span><span id="line-567"></span><pre><span id="line-1-51"></span> cd /net || { echo &gt;&amp;2 &#34;Can&#39;t read /net. Make sure you&#39;ve logged in to the Samba network, and try again.&#34;; exit 1; }
<span id="line-2-30"></span> do_stuff
<span id="line-3-23"></span> more_stuff</pre><span id="line-568"></span><span id="line-569"></span></li></ul><p>Note there&#39;s a required space between <tt>{</tt> and <tt>echo</tt>, and a required <tt>;</tt> before the closing <tt>}</tt>.  You could also write a <tt>die</tt> function, if you prefer. <span id="line-570"></span><span id="line-571"></span></p><p>Some people also like to enable <a href="http://mywiki.wooledge.org/BashFAQ/105">set -e</a> to make their scripts abort on <em>any</em> command that returns non-zero, but this can be <a href="http://mywiki.wooledge.org/BashFAQ/105">rather tricky to use correctly</a> (since many common commands may return a non-zero for a warning condition, which you may not want to treat as fatal). <span id="line-572"></span><span id="line-573"></span></p><p>By the way, if you&#39;re changing directories a lot in a Bash script, be sure to read the Bash help on <tt>pushd</tt>, <tt>popd</tt>, and <tt>dirs</tt>. Perhaps all that code you wrote to manage <tt>cd</tt>&#39;s and <tt>pwd</tt>&#39;s is completely unnecessary. <span id="line-574"></span><span id="line-575"></span></p><p>Speaking of which, compare this: <span id="line-576"></span><span id="line-577"></span></p><ul><li><span id="line-578"></span><span id="line-579"></span><span id="line-580"></span><span id="line-581"></span><span id="line-582"></span><span id="line-583"></span><pre><span id="line-1-52"></span> find ... -type d -print0 | while IFS= read -r -d &#39;&#39; subdir; do
<span id="line-2-31"></span>   here=$PWD
<span id="line-3-24"></span>   cd &#34;$subdir&#34; &amp;&amp; whatever &amp;&amp; ...
<span id="line-4-14"></span>   cd &#34;$here&#34;
<span id="line-5-10"></span> done</pre><span id="line-584"></span><span id="line-585"></span></li></ul><p>With this: <span id="line-586"></span><span id="line-587"></span></p><ul><li><span id="line-588"></span><span id="line-589"></span><span id="line-590"></span><span id="line-591"></span><pre><span id="line-1-53"></span> find ... -type d -print0 | while IFS= read -r -d &#39;&#39; subdir; do
<span id="line-2-32"></span>   (cd &#34;$subdir&#34; || exit; whatever; ...)
<span id="line-3-25"></span> done</pre><span id="line-592"></span><span id="line-593"></span></li></ul><p>Forcing a <a href="http://mywiki.wooledge.org/SubShell">SubShell</a> here causes the <tt>cd</tt> to occur only in the subshell; for the next iteration of the loop, we&#39;re back to our normal location, regardless of whether the <tt>cd</tt> succeeded or failed.  We don&#39;t have to change back manually, and we aren&#39;t stuck in a neverending string of <tt>... &amp;&amp; ...</tt> logic preventing the use of other conditionals.  The subshell version is simpler and cleaner (albeit a tiny bit slower). <span id="line-594"></span><span id="line-595"></span></p><p>Another approach is to <tt>cd</tt> unconditionally to where we&#39;re supposed to be, at the start of each loop iteration: <span id="line-596"></span><span id="line-597"></span></p><ul><li><span id="line-598"></span><span id="line-599"></span><span id="line-600"></span><span id="line-601"></span><span id="line-602"></span><span id="line-603"></span><span id="line-604"></span><span id="line-605"></span><pre><span id="line-1-54"></span> here=$PWD
<span id="line-2-33"></span> find ... -type d -print0 | while IFS= read -r -d &#39;&#39; subdir; do
<span id="line-3-26"></span>    cd &#34;$here&#34; || continue
<span id="line-4-15"></span>    cd &#34;$subdir&#34; || continue
<span id="line-5-11"></span>    whatever
<span id="line-6-7"></span>    ...
<span id="line-7-3"></span> done</pre><span id="line-606"></span><span id="line-607"></span></li></ul><p>At least this way, we can <tt>continue</tt> to the next loop iteration and don&#39;t have to string an indefinite series of <tt>&amp;&amp;</tt> together to ensure that we reach the <tt>cd</tt> at the end of the loop body. <span id="line-608"></span><span id="line-609"></span></p><h2 id="A.5B_bar_.3D.3D_.22.24foo.22_.5D">20. [ bar == &#34;$foo&#34; ]</h2>
<p>The <tt>==</tt> operator is not valid for the POSIX <tt>[</tt> command. Use <tt>=</tt> or the <a href="http://mywiki.wooledge.org/BashFAQ/031">[[ keyword</a> instead. <span id="line-613"></span><span id="line-614"></span></p><ul><li><span id="line-615"></span><span id="line-616"></span><span id="line-617"></span><pre><span id="line-1-55"></span> [ bar = &#34;$foo&#34; ] &amp;&amp; echo yes
<span id="line-2-34"></span> [[ bar == $foo ]] &amp;&amp; echo yes</pre><span id="line-618"></span><span id="line-619"></span></li></ul><p>In Bash, <tt>[ &#34;$x&#34; == y ]</tt> is accepted as an extension, which often leads Bash programmers to think it&#39;s the correct syntax.  It&#39;s not; it&#39;s a <a href="http://mywiki.wooledge.org/Bashism">Bashism</a>.  If you&#39;re going to use Bashisms, you might as well just use <tt>[[</tt> instead. <span id="line-620"></span><span id="line-621"></span></p><h2 id="for_i_in_.7B1..10.7D.3B_do_..2Fsomething_.26.3B_done">21. for i in {1..10}; do ./something &amp;; done</h2>
<p>You <em>cannot</em> put a <tt>;</tt> immediately after an <tt>&amp;</tt>. Just remove the extraneous <tt>;</tt> entirely. <span id="line-625"></span><span id="line-626"></span></p><ul><li><span id="line-627"></span><span id="line-628"></span><pre><span id="line-1-56"></span> for i in {1..10}; do ./something &amp; done</pre><span id="line-629"></span><span id="line-630"></span></li></ul><p>Or: <span id="line-631"></span><span id="line-632"></span></p><ul><li><span id="line-633"></span><span id="line-634"></span><span id="line-635"></span><span id="line-636"></span><pre><span id="line-1-57"></span> for i in {1..10}; do
<span id="line-2-35"></span>   ./something &amp;
<span id="line-3-27"></span> done</pre><span id="line-637"></span><span id="line-638"></span></li></ul><p><tt>&amp;</tt> already functions as a command terminator, just like <tt>;</tt> does. And you cannot mix the two. <span id="line-639"></span><span id="line-640"></span></p><p>In general, a <tt>;</tt> can be replaced by a newline, but not all newlines can be replaced by <tt>;</tt>. <span id="line-641"></span><span id="line-642"></span></p><h2 id="cmd1_.26.26_cmd2_.7C.7C_cmd3">22. cmd1 &amp;&amp; cmd2 || cmd3</h2>
<p>Some people try to use <tt>&amp;&amp;</tt> and <tt>||</tt> as a shortcut syntax for <tt>if ... then ... else ... fi</tt>, perhaps because they think they are being clever. For instance, <span id="line-646"></span><span id="line-647"></span></p><ul><li><span id="line-648"></span><span id="line-649"></span><span id="line-650"></span><pre><span id="line-1-58"></span> # WRONG!
<span id="line-2-36"></span> [[ -s $errorlog ]] &amp;&amp; echo &#34;Uh oh, there were some errors.&#34; || echo &#34;Successful.&#34;</pre><span id="line-651"></span><span id="line-652"></span></li></ul><p>However, this construct is <em>not</em> completely equivalent to <tt>if ... fi</tt> in the general case.  The command that comes after the <tt>&amp;&amp;</tt> also generates an exit status, and if that exit status isn&#39;t &#34;true&#34; (0), then the command that comes after the <tt>||</tt> will <em>also</em> be invoked. For example: <span id="line-653"></span><span id="line-654"></span></p><ul><li><span id="line-655"></span><span id="line-656"></span><span id="line-657"></span><span id="line-658"></span><pre><span id="line-1-59"></span> i=0
<span id="line-2-37"></span> true &amp;&amp; ((i++)) || ((i--))  # WRONG!
<span id="line-3-28"></span> echo &#34;$i&#34;                   # Prints 0</pre><span id="line-659"></span><span id="line-660"></span></li></ul><p>What happened here? It looks like <tt>i</tt> should be 1, but it ends up 0. Why? Because both the <tt>i++</tt> <em>and</em> the <tt>i--</tt> were executed. The <tt>((i++))</tt> command has an exit status, and that exit status is derived from a C-like evaluation of the expression inside the parentheses. That expression&#39;s value happens to be 0 (the initial value of <tt>i</tt>), and in C, an expression with an integer value of 0 is considered <em>false</em>. So <tt>((i++))</tt> (when <tt>i</tt> is 0) has an exit status of 1 (false), and therefore the <tt>((i--))</tt> command is executed as well. <span id="line-661"></span><span id="line-662"></span></p><p>Another clever person thinks that we can fix it by using the pre-increment operator, since the exit status from <tt>++i</tt> (with <tt>i</tt> initially 0) is true: <span id="line-663"></span><span id="line-664"></span></p><ul><li><span id="line-665"></span><span id="line-666"></span><span id="line-667"></span><span id="line-668"></span><pre><span id="line-1-60"></span> i=0
<span id="line-2-38"></span> true &amp;&amp; (( ++i )) || (( --i ))  # STILL WRONG!
<span id="line-3-29"></span> echo &#34;$i&#34;                       # Prints 1 by dumb luck</pre><span id="line-669"></span><span id="line-670"></span></li></ul><p>But that&#39;s missing the point of the example. It just <em>happens</em> to work by <em>coincidence</em>, and you <em>cannot</em> rely on <tt>x &amp;&amp; y || z</tt> if <tt>y</tt> has <strong>any</strong> chance of failure! (This example still fails if we initialize <tt>i</tt> to -1 instead of 0.) <span id="line-671"></span><span id="line-672"></span></p><p>If you need safety, or if you simply aren&#39;t sure how this works, or if <em>anything</em> in the preceding paragraphs wasn&#39;t completely clear, please just use the simple <tt>if ... fi</tt> syntax in your programs. <span id="line-673"></span><span id="line-674"></span></p><ul><li><span id="line-675"></span><span id="line-676"></span><span id="line-677"></span><span id="line-678"></span><span id="line-679"></span><span id="line-680"></span><span id="line-681"></span><span id="line-682"></span><pre><span id="line-1-61"></span> i=0
<span id="line-2-39"></span> if true; then
<span id="line-3-30"></span>   ((i++))
<span id="line-4-16"></span> else
<span id="line-5-12"></span>   ((i--))
<span id="line-6-8"></span> fi
<span id="line-7-4"></span> echo &#34;$i&#34;    # Prints 1</pre><span id="line-683"></span><span id="line-684"></span></li></ul><p>This section also applies to Bourne shell, here is the code that illustrates it: <span id="line-685"></span><span id="line-686"></span></p><ul><li><span id="line-687"></span><span id="line-688"></span><span id="line-689"></span><pre><span id="line-1-62"></span> # WRONG!
<span id="line-2-40"></span> true &amp;&amp; { echo true; false; } || { echo false; true; }</pre><span id="line-690"></span><span id="line-691"></span></li></ul><p>Output is two lines &#34;true&#34; and &#34;false&#34;, instead the single line &#34;true&#34;. <span id="line-692"></span><span id="line-693"></span></p><h2 id="echo_.22Hello_World.21.22">23. echo &#34;Hello World!&#34;</h2>
<p>The problem here is that, in an interactive Bash shell (in versions prior to 4.3), you&#39;ll see an error like: <span id="line-697"></span><span id="line-698"></span></p><ul><li><span id="line-699"></span><span id="line-700"></span><pre><span id="line-1-63"></span> bash: !&#34;: event not found</pre><span id="line-701"></span><span id="line-702"></span></li></ul><p>This is because, in the default settings for an interactive shell, Bash performs csh-style history expansion using the exclamation point. This is <strong>not</strong> a problem in shell scripts; only in interactive shells. <span id="line-703"></span><span id="line-704"></span></p><p>Unfortunately, the obvious attempt to &#34;fix&#34; this won&#39;t work: <span id="line-705"></span><span id="line-706"></span></p><ul><li><span id="line-707"></span><span id="line-708"></span><span id="line-709"></span><pre><span id="line-1-64"></span> $ echo &#34;hi\!&#34;
<span id="line-2-41"></span> hi\!</pre><span id="line-710"></span><span id="line-711"></span></li></ul><p>The easiest solution is unsetting the <tt>histexpand</tt> option: this can be done with <tt>set +H</tt> or <tt>set +o histexpand</tt> <span id="line-712"></span><span id="line-713"></span></p><ul><li><p>Question: Why is playing with <tt>histexpand</tt> more apropriate than single quotes? <span id="line-714"></span></p><ul><li><p><em>I personally ran into this issue when I was manipulating song files, using commands like</em> <span id="line-715"></span><span id="line-716"></span><span id="line-717"></span><span id="line-718"></span></p><pre><span id="line-1-65"></span>mp3info -t &#34;Don&#39;t Let It Show&#34; ...
<span id="line-2-42"></span>mp3info -t &#34;Ah! Leah!&#34; ...</pre><span id="line-719"></span><p><em>Using single quotes is extremely inconvenient because of all the songs with apostrophes in their titles. Using double quotes ran into the history expansion issue. (And imagine a file that has both in its name. The quoting would be atrocious.) Since I never actually </em>use<em> history expansion, my personal preference was to turn it off in <tt>~/.bashrc</tt>.</em> -- <a href="http://mywiki.wooledge.org/GreyCat">GreyCat</a> <span id="line-720"></span><span id="line-721"></span></p></li></ul></li></ul><p>These solutions will work: <span id="line-722"></span><span id="line-723"></span></p><ul><li><span id="line-724"></span><span id="line-725"></span><pre><span id="line-1-66"></span> echo &#39;Hello World!&#39;</pre><span id="line-726"></span><span id="line-727"></span></li></ul><p>or <span id="line-728"></span><span id="line-729"></span></p><ul><li><span id="line-730"></span><span id="line-731"></span><pre><span id="line-1-67"></span> echo &#34;Hello World&#34;!</pre><span id="line-732"></span><span id="line-733"></span></li></ul><p>or <span id="line-734"></span><span id="line-735"></span></p><ul><li><span id="line-736"></span><span id="line-737"></span><span id="line-738"></span><pre><span id="line-1-68"></span> set +H
<span id="line-2-43"></span> echo &#34;Hello World!&#34;</pre><span id="line-739"></span><span id="line-740"></span></li></ul><p>or <span id="line-741"></span><span id="line-742"></span></p><ul><li><span id="line-743"></span><span id="line-744"></span><pre><span id="line-1-69"></span> histchars=</pre><span id="line-745"></span><span id="line-746"></span></li></ul><p>Many people simply choose to put <tt>set +H</tt> or <tt>set +o histexpand</tt> in their <tt>~/.bashrc</tt> to deactivate history expansion permanently. This is a personal preference, though, and you should choose whatever works best for you. <span id="line-747"></span><span id="line-748"></span></p><p>Another solution is: <span id="line-749"></span><span id="line-750"></span></p><ul><li><span id="line-751"></span><span id="line-752"></span><span id="line-753"></span><pre><span id="line-1-70"></span> exmark=&#39;!&#39;
<span id="line-2-44"></span> echo &#34;Hello, world$exmark&#34;</pre><span id="line-754"></span><span id="line-755"></span></li></ul><p>In Bash 4.3 and newer, a double quote following <tt>!</tt> no longer triggers history expansion, but history expansion is still performed within double quotes, so while <tt>echo &#34;Hello World!&#34;</tt> is OK, these will still be a problem: <span id="line-756"></span><span id="line-757"></span></p><ul><li><span id="line-758"></span><span id="line-759"></span><span id="line-760"></span><pre><span id="line-1-71"></span> echo &#34;Hello, World!(and the rest of the Universe)&#34;
<span id="line-2-45"></span> echo &#34;foo!&#39;bar&#39;&#34;</pre><span id="line-761"></span><span id="line-762"></span></li></ul><h2 id="for_arg_in_.24.2A">24. for arg in $*</h2>
<p>Bash (like all Bourne shells) has a special syntax for referring to the list of positional parameters one at a time, and <tt>$*</tt> isn&#39;t it. Neither is <tt>$@</tt>. Both of those expand to the list of words in your script&#39;s parameters, not to each parameter as a separate word. <span id="line-766"></span><span id="line-767"></span></p><p>The correct syntax is: <span id="line-768"></span><span id="line-769"></span></p><ul><li><span id="line-770"></span><span id="line-771"></span><span id="line-772"></span><span id="line-773"></span><span id="line-774"></span><pre><span id="line-1-72"></span> for arg in &#34;$@&#34;
<span id="line-2-46"></span>
<span id="line-3-31"></span> # Or simply:
<span id="line-4-17"></span> for arg</pre><span id="line-775"></span><span id="line-776"></span></li></ul><p>Since looping over the positional parameters is such a common thing to do in scripts, <tt>for arg</tt> defaults to <tt>for arg in &#34;$@&#34;</tt>. The double-quoted <tt>&#34;$@&#34;</tt> is special magic that causes each parameter to be used as a single word (or a single loop iteration). It&#39;s what you should be using at least 99% of the time. <span id="line-777"></span><span id="line-778"></span></p><p>Here&#39;s an example: <span id="line-779"></span><span id="line-780"></span></p><ul><li><span id="line-781"></span><span id="line-782"></span><span id="line-783"></span><span id="line-784"></span><span id="line-785"></span><span id="line-786"></span><span id="line-787"></span><span id="line-788"></span><span id="line-789"></span><span id="line-790"></span><span id="line-791"></span><pre><span id="line-1-73"></span> # Incorrect version
<span id="line-2-47"></span> for x in $*; do
<span id="line-3-32"></span>   echo &#34;parameter: &#39;$x&#39;&#34;
<span id="line-4-18"></span> done
<span id="line-5-13"></span>
<span id="line-6-9"></span> $ ./myscript &#39;arg 1&#39; arg2 arg3
<span id="line-7-5"></span> parameter: &#39;arg&#39;
<span id="line-8-3"></span> parameter: &#39;1&#39;
<span id="line-9-3"></span> parameter: &#39;arg2&#39;
<span id="line-10-2"></span> parameter: &#39;arg3&#39;</pre><span id="line-792"></span><span id="line-793"></span></li></ul><p>It should have been written: <span id="line-794"></span><span id="line-795"></span></p><ul><li><span id="line-796"></span><span id="line-797"></span><span id="line-798"></span><span id="line-799"></span><span id="line-800"></span><span id="line-801"></span><span id="line-802"></span><span id="line-803"></span><span id="line-804"></span><span id="line-805"></span><span id="line-806"></span><span id="line-807"></span><span id="line-808"></span><span id="line-809"></span><pre><span id="line-1-74"></span> # Correct version
<span id="line-2-48"></span> for x in &#34;$@&#34;; do
<span id="line-3-33"></span>   echo &#34;parameter: &#39;$x&#39;&#34;
<span id="line-4-19"></span> done
<span id="line-5-14"></span># or better:
<span id="line-6-10"></span> for x do
<span id="line-7-6"></span>   echo &#34;parameter: &#39;$x&#39;&#34;
<span id="line-8-4"></span> done
<span id="line-9-4"></span>
<span id="line-10-3"></span> $ ./myscript &#39;arg 1&#39; arg2 arg3
<span id="line-11-2"></span> parameter: &#39;arg 1&#39;
<span id="line-12-2"></span> parameter: &#39;arg2&#39;
<span id="line-13-1"></span> parameter: &#39;arg3&#39;</pre><span id="line-810"></span><span id="line-811"></span></li></ul><h2 id="function_foo.28.29">25. function foo()</h2>
<p>This works in some shells, but not in others. You should <em>never</em> combine the keyword <tt>function</tt> with the parentheses <tt>()</tt> when defining a function. <span id="line-815"></span><span id="line-816"></span></p><p>Bash (at least some versions) will allow you to mix the two. Most of the shells won&#39;t accept that (zsh 4.x and perhaps above will - for example). Some shells will accept <tt>function foo</tt>, but for maximum portability, you should always use: <span id="line-817"></span><span id="line-818"></span></p><ul><li><span id="line-819"></span><span id="line-820"></span><span id="line-821"></span><span id="line-822"></span><pre><span id="line-1-75"></span> foo() {
<span id="line-2-49"></span>  ...
<span id="line-3-34"></span> }</pre><span id="line-823"></span><span id="line-824"></span></li></ul><h2 id="echo_.22.2BAH4.22">26. echo &#34;~&#34;</h2>
<p>Tilde expansion only applies when &#39;~&#39; is unquoted. In this example echo writes &#39;~&#39; to stdout, rather than the path of the user&#39;s home directory. <span id="line-828"></span><span id="line-829"></span></p><p>Quoting path parameters that are expressed relative to a user&#39;s home directory should be done using $HOME rather than &#39;~&#39;. For instance consider the situation where $HOME is &#34;/home/my photos&#34;. <span id="line-830"></span><span id="line-831"></span></p><ul><li><span id="line-832"></span><span id="line-833"></span><span id="line-834"></span><span id="line-835"></span><span id="line-836"></span><pre><span id="line-1-76"></span> &#34;~/dir with spaces&#34; # expands to &#34;~/dir with spaces&#34;
<span id="line-2-50"></span> ~&#34;/dir with spaces&#34; # expands to &#34;~/dir with spaces&#34;
<span id="line-3-35"></span> ~/&#34;dir with spaces&#34; # expands to &#34;/home/my photos/dir with spaces&#34;
<span id="line-4-20"></span> &#34;$HOME/dir with spaces&#34; # expands to &#34;/home/my photos/dir with spaces&#34;</pre><span id="line-837"></span><span id="line-838"></span></li></ul><h2 id="local_var.3D.24.28cmd.29">27. local var=$(cmd)</h2>
<p>When declaring a local variable in a function, the <tt>local</tt> acts as a command in its own right. This can sometimes interact oddly with the rest of the line -- for example, if you wanted to capture the exit status (<tt>$?</tt>) of the <a href="http://mywiki.wooledge.org/CommandSubstitution">CommandSubstitution</a>, you can&#39;t do it. <tt>local</tt>&#39;s exit status masks it. <span id="line-842"></span><span id="line-843"></span></p><p>Another problem with this syntax is that in some shells (like bash), <tt>local var=$(cmd)</tt> is treated as an <em>assignment</em>, meaning the right hand side is given special treatment, just like <tt>var=$(cmd)</tt>; while in other shells (like dash), <tt>local var=$(cmd)</tt> is <strong>not</strong> treated as an assignment, and the right hand side will undergo <a href="http://mywiki.wooledge.org/WordSplitting">word splitting</a> (because it isn&#39;t quoted). <span id="line-844"></span><span id="line-845"></span></p><p>Quoting the right hand side will work around the word splitting issue, but not the exit status masking issue.  For both reasons, it&#39;s best to use separate commands for this: <span id="line-846"></span><span id="line-847"></span></p><ul><li><span id="line-848"></span><span id="line-849"></span><span id="line-850"></span><span id="line-851"></span><pre><span id="line-1-77"></span> local var
<span id="line-2-51"></span> var=$(cmd)
<span id="line-3-36"></span> rc=$?</pre><span id="line-852"></span><span id="line-853"></span></li></ul><p>Both issues are also true of <tt>export</tt>. <span id="line-854"></span><span id="line-855"></span></p><p>The next pitfall describes another issue with this syntax: <span id="line-856"></span><span id="line-857"></span></p><h2 id="export_foo.3D.2BAH4-.2Fbar">28. export foo=~/bar</h2>
<p><a href="http://mywiki.wooledge.org/TildeExpansion">Tilde expansion</a> (with or without a username) is only guaranteed to occur when the tilde appears at the beginning of a <a href="http://mywiki.wooledge.org/Arguments">word</a>, either by itself or followed by a slash.  It is also guaranteed to occur when the tilde appears immediately after the <tt>=</tt> in an assignment. <span id="line-861"></span><span id="line-862"></span></p><p>However, the <tt>export</tt> and <tt>local</tt> commands do <strong>not</strong> necessarily constitute an assignment.  In some shells (like Bash), <tt>export foo=~/bar</tt> will undergo tilde expansion; in others (like dash), it will not. <span id="line-863"></span><span id="line-864"></span></p><ul><li><span id="line-865"></span><span id="line-866"></span><span id="line-867"></span><pre><span id="line-1-78"></span> foo=~/bar; export foo    # Right!
<span id="line-2-52"></span> export foo=&#34;$HOME/bar&#34;   # Right!</pre><span id="line-868"></span><span id="line-869"></span></li></ul><p>Using parameter expansion instead of tilde expansion lets use further improve it to: <span id="line-870"></span><span id="line-871"></span></p><p>. <span id="line-872"></span><span id="line-873"></span></p><pre><span id="line-1-79"></span> export foo=&#34;${HOME%/}/bar&#34; # Better!</pre><p>Which yields <tt>/bar</tt> instead of <tt>//bar</tt> when <tt>$HOME</tt> is <tt>/</tt> (which used to be common for the <tt>root</tt> user at least) which is better as on some systems, paths that start with a double-slash have a special meaning. <span id="line-876"></span><span id="line-877"></span></p><h2 id="sed_.27s.2F.24foo.2Fgood_bye.2F.27">29. sed &#39;s/$foo/good bye/&#39;</h2>
<p>In <a href="http://mywiki.wooledge.org/Quotes">single quotes</a>, bash parameter expansions like <tt>$foo</tt> do not get expanded.  That is the purpose of single quotes, to protect characters like <tt>$</tt> from the shell. <span id="line-881"></span><span id="line-882"></span></p><p>Change the quotes to double quotes: <span id="line-883"></span><span id="line-884"></span></p><ul><li><span id="line-885"></span><span id="line-886"></span><pre><span id="line-1-80"></span> foo=&#34;hello&#34;; sed &#34;s/$foo/good bye/&#34;</pre><span id="line-887"></span><span id="line-888"></span></li></ul><p>But keep in mind, if you use double quotes you might need to use more escapes.  See the <a href="http://mywiki.wooledge.org/Quotes">Quotes</a> page. <span id="line-889"></span><span id="line-890"></span></p><h2 id="tr_.5BA-Z.5D_.5Ba-z.5D">30. tr [A-Z] [a-z]</h2>
<p>There are (at least) three things wrong here.  The first problem is that <tt>[A-Z]</tt> and <tt>[a-z]</tt> are seen as <a href="http://mywiki.wooledge.org/glob">glob</a>s by the shell.  If you don&#39;t have any single-lettered filenames in your current directory, it&#39;ll seem like the command is correct; but if you do, things will go wrong.  Probably at 0300 hours on a weekend. <span id="line-894"></span><span id="line-895"></span></p><p>The second problem is that this is not really the correct notation for <tt>tr</tt>.  What this actually does is translate &#39;[&#39; into &#39;[&#39;; anything in the range A-Z into a-z; and &#39;]&#39; into &#39;]&#39;.  So you don&#39;t even need those brackets, and the first problem goes away. <span id="line-896"></span><span id="line-897"></span></p><p>The third problem is that depending on the <a href="http://mywiki.wooledge.org/locale">locale</a>, A-Z or a-z may not give you the 26 ASCII characters you were expecting.  In fact, in some locales z is in the middle of the alphabet!  The solution to this depends on what you want to happen: <span id="line-898"></span><span id="line-899"></span></p><ul><li><span id="line-900"></span><span id="line-901"></span><span id="line-902"></span><span id="line-903"></span><span id="line-904"></span><span id="line-905"></span><pre><span id="line-1-81"></span> # Use this if you want to change the case of the 26 latin letters
<span id="line-2-53"></span> LC_COLLATE=C tr A-Z a-z
<span id="line-3-37"></span>
<span id="line-4-21"></span> # Use this if you want the case conversion to depend upon the locale, which might be more like what a user is expecting
<span id="line-5-15"></span> tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;</pre><span id="line-906"></span><span id="line-907"></span></li></ul><p>The quotes are required on the second command, to avoid <a href="http://mywiki.wooledge.org/glob">globbing</a>. <span id="line-908"></span><span id="line-909"></span></p><h2 id="ps_ax_.7C_grep_gedit">31. ps ax | grep gedit</h2>
<p>The fundamental problem here is that the name of a running process is inherently unreliable.  There could be more than one legitimate gedit process.  There could be something else disguising itself as gedit (changing the reported name of an executed command is trivial).  For <em>real</em> answers to this, see <a href="http://mywiki.wooledge.org/ProcessManagement">ProcessManagement</a>. <span id="line-913"></span><span id="line-914"></span></p><p>The following is the quick and dirty stuff. <span id="line-915"></span><span id="line-916"></span></p><p>Searching for the PID of (for example) gedit, many people start with <span id="line-917"></span><span id="line-918"></span></p><pre><span id="line-1-82"></span>$ ps ax | grep gedit
<span id="line-2-54"></span>10530 ?        S      6:23 gedit
<span id="line-3-38"></span>32118 pts/0    R+     0:00 grep gedit</pre><p>which, depending on a <a href="http://mywiki.wooledge.org/RaceCondition">RaceCondition</a>, often yields grep itself as a result.  To filter grep out: <span id="line-924"></span><span id="line-925"></span></p><pre><span id="line-1-83"></span>ps ax | grep -v grep | grep gedit   # will work, but ugly</pre><p>An alternative to this is to use: <span id="line-929"></span><span id="line-930"></span></p><pre><span id="line-1-84"></span>ps ax | grep &#39;[g]edit&#39;              # quote to avoid shell GLOB</pre><p>This will ignore the grep itself in the process table as that is [g]edit and grep is looking for gedit once evaluated. <span id="line-934"></span><span id="line-935"></span></p><p>On GNU/Linux, the parameter -C can be used instead to filter by commandname: <span id="line-936"></span><span id="line-937"></span></p><pre><span id="line-1-85"></span>$ ps -C gedit
<span id="line-2-55"></span>  PID TTY          TIME CMD
<span id="line-3-39"></span>10530 ?        00:06:23 gedit</pre><p>But why bother when you could just use pgrep instead? <span id="line-943"></span><span id="line-944"></span></p><pre><span id="line-1-86"></span>$ pgrep gedit
<span id="line-2-56"></span>10530</pre><p>Now in a second step the PID is often extracted by awk or cut: <span id="line-949"></span><span id="line-950"></span></p><pre><span id="line-1-87"></span>$ ps -C gedit | awk &#39;{print $1}&#39; | tail -n1</pre><p>but even that can be handled by some of the trillions of parameters for ps: <span id="line-954"></span><span id="line-955"></span></p><pre><span id="line-1-88"></span>$ ps -C gedit -opid=
<span id="line-2-57"></span>10530</pre><p>If you&#39;re stuck in 1992 and aren&#39;t using pgrep, you could use the ancient, obsolete, deprecated pidof (GNU/Linux only) instead: <span id="line-960"></span><span id="line-961"></span></p><pre><span id="line-1-89"></span>$ pidof gedit
<span id="line-2-58"></span>10530</pre><p>and if you need the PID to kill the process, <em>pkill</em> might be interesting for you. Note however that, for example, <tt>pgrep/pkill ssh</tt> would also find processes named sshd, and you wouldn&#39;t want to kill those. <span id="line-966"></span><span id="line-967"></span></p><p>Unfortunately some programs aren&#39;t started with their name, for example firefox is often started as firefox-bin, which you would need to find out with - well - <strong>ps ax | grep firefox</strong>. <img alt=":)" height="16" src="http://mywiki.wooledge.org/moin_static1911/modernized/img/smile.png" title=":)" width="16"/> Or, you can stick with pgrep by adding some parameters: <span id="line-968"></span><span id="line-969"></span></p><pre><span id="line-1-90"></span>$ pgrep -fl firefox
<span id="line-2-59"></span>3128 /usr/lib/firefox/firefox
<span id="line-3-40"></span>7120 /usr/lib/firefox/plugin-container /usr/lib/flashplugin-installer/libflashplayer.so -greomni /usr/lib/firefox/omni.ja 3128 true plugin</pre><p>Please read <a href="http://mywiki.wooledge.org/ProcessManagement">ProcessManagement</a>.  Seriously. <span id="line-975"></span><span id="line-976"></span></p><h2 id="printf_.22.24foo.22">32. printf &#34;$foo&#34;</h2>
<p>This isn&#39;t wrong because of <a href="http://mywiki.wooledge.org/Quotes">quotes</a>, but because of a <em>format string exploit</em>.  If <tt>$foo</tt> is not strictly under your control, then any <tt>\</tt> or <tt>%</tt> characters in the variable may cause undesired behavior. <span id="line-980"></span><span id="line-981"></span></p><p>Always supply your own format string: <span id="line-982"></span><span id="line-983"></span></p><pre><span id="line-1-91"></span>printf %s &#34;$foo&#34;
<span id="line-2-60"></span>printf &#39;%s\n&#39; &#34;$foo&#34;</pre><h2 id="for_i_in_.7B1...24n.7D">33. for i in {1..$n}</h2>
<p>The <a href="http://mywiki.wooledge.org/BashParser">BashParser</a> performs <a href="http://mywiki.wooledge.org/BraceExpansion">BraceExpansion</a> <em>before</em> any other expansions or substitutions.  So the brace expansion code sees the literal <tt>$n</tt>, which is not numeric, and therefore it doesn&#39;t expand the curly braces into a list of numbers.  This makes it nearly impossible to use brace expansion to create lists whose size is only known at run-time. <span id="line-991"></span><span id="line-992"></span></p><p>Do this instead: <span id="line-993"></span><span id="line-994"></span></p><pre><span id="line-1-92"></span>for ((i=1; i&lt;=n; i++)); do
<span id="line-2-61"></span>...
<span id="line-3-41"></span>done</pre><p>In the case of simple iteration over integers, an arithmetic <tt>for</tt> loop should almost always be preferred over brace expansion to begin with, because brace expansion pre-expands every argument which can be slower and unnecessarily consumes memory. <span id="line-1000"></span><span id="line-1001"></span></p><h2 id="if_.5B.5B_.24foo_.3D_.24bar_.5D.5D_.28depending_on_intent.29">34. if [[ $foo = $bar ]] (depending on intent)</h2>
<p>When the right-hand side of an <tt>=</tt> operator inside <a href="http://mywiki.wooledge.org/BashFAQ/031">[[</a> is not quoted, bash does <a href="http://mywiki.wooledge.org/glob">pattern matching</a> against it, instead of treating it as a string.  So, in the code above, if <tt>bar</tt> contains <tt>*</tt>, the result will <em>always</em> be true.  If you want to check for equality of strings, the right-hand side should be quoted: <span id="line-1005"></span><span id="line-1006"></span></p><pre><span id="line-1-93"></span>if [[ $foo = &#34;$bar&#34; ]]</pre><p>If you want to do pattern matching, it might be wise to choose variable names that indicate the right-hand side contains a pattern.  Or use comments. <span id="line-1010"></span><span id="line-1011"></span></p><p>It&#39;s also worth pointing out that if you quote the right-hand side of <tt>=~</tt> it <em>also</em> forces a simple string comparison, rather than a regular expression matching.  This leads us to: <span id="line-1012"></span><span id="line-1013"></span></p><h2 id="if_.5B.5B_.24foo_.3D.2BAH4_.27some_RE.27_.5D.5D">35. if [[ $foo =~ &#39;some RE&#39; ]]</h2>
<p>The quotes around the right-hand side of the <tt>=~</tt> operator cause it to become a string, rather than a <a href="http://mywiki.wooledge.org/RegularExpression">RegularExpression</a>.  If you want to use a long or complicated regular expression and avoid lots of backslash escaping, put it in a variable: <span id="line-1017"></span><span id="line-1018"></span></p><pre><span id="line-1-94"></span>re=&#39;some RE&#39;
<span id="line-2-62"></span>if [[ $foo =~ $re ]]</pre><p>This also works around the difference in how <tt>=~</tt> works across different versions of bash.  Using a variable avoids some nasty and subtle problems. <span id="line-1023"></span><span id="line-1024"></span></p><p>The same problem occurs with <a href="http://mywiki.wooledge.org/glob">pattern matching</a> inside <tt>[[</tt>: <span id="line-1025"></span><span id="line-1026"></span></p><pre><span id="line-1-95"></span>[[ $foo = &#34;*.glob&#34; ]]      # Wrong! *.glob is treated as a literal string.
<span id="line-2-63"></span>[[ $foo = *.glob ]]        # Correct. *.glob is treated as a glob-style pattern.</pre><h2 id="A.5B_-n_.24foo_.5D_or_.5B_-z_.24foo_.5D">36. [ -n $foo ] or [ -z $foo ]</h2>
<p>When using the <tt>[</tt> command, you <strong>must</strong> <a href="http://mywiki.wooledge.org/Quotes">quote</a> each substitution that you give it.  Otherwise, <tt>$foo</tt> could expand to 0 words, or 42 words, or any number of words that isn&#39;t 1, which breaks the syntax. <span id="line-1034"></span><span id="line-1035"></span></p><pre><span id="line-1-96"></span>[ -n &#34;$foo&#34; ]
<span id="line-2-64"></span>[ -z &#34;$foo&#34; ]
<span id="line-3-42"></span>[ -n &#34;$(some command with a &#34;$file&#34; in it)&#34; ]
<span id="line-4-22"></span>
<span id="line-5-16"></span># [[ doesn&#39;t perform word-splitting or glob expansion, so you could also use:
<span id="line-6-11"></span>[[ -n $foo ]]
<span id="line-7-7"></span>[[ -z $foo ]]</pre><h2 id="A.5B.5B_-e_.22.24broken_symlink.22_.5D.5D_returns_1_even_though_.24broken_symlink_exists">37. [[ -e &#34;$broken_symlink&#34; ]] returns 1 even though $broken_symlink exists</h2>
<p>Test follows symlinks, therefore if a symlink is broken, i.e. it points to a file that doesn&#39;t exists or is in a directory you don&#39;t have access to, test -e returns 1 for it even though it exists. <span id="line-1048"></span><span id="line-1049"></span></p><p>In order to work around it (and prepare against it) you should use: <span id="line-1050"></span><span id="line-1051"></span></p><pre><span id="line-1-97"></span># bash/ksh/zsh
<span id="line-2-65"></span>[[ -e &#34;$broken_symlink&#34; || -L &#34;$broken_symlink&#34; ]]
<span id="line-3-43"></span>
<span id="line-4-23"></span># POSIX sh+test
<span id="line-5-17"></span>[ -e &#34;$broken_symlink&#34; ] || [ -L &#34;$broken_symlink&#34; ]</pre><h2 id="ed_file_.3C.3C.3C.22g.2Fd.2BAFw.7B0.2C3.2BAFw.7D.2Fs.2F.2Fe.2Fg.22_fails">38. ed file &lt;&lt;&lt;&#34;g/d\{0,3\}/s//e/g&#34; fails</h2>
<p>The problem caused because ed doesn&#39;t accept 0 for \{0,3\}. <span id="line-1062"></span><span id="line-1063"></span></p><p>You can check that the following do work: <span id="line-1064"></span><span id="line-1065"></span></p><pre><span id="line-1-98"></span>ed file &lt;&lt;&lt;&#34;g/d\{1,3\}/s//e/g&#34;</pre><p>Note that this happens even though POSIX states that BRE (which is the Regular Expression flavor used by ed) <a href="http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_06">should accept 0 as the minimum number of occurrences (see section 5)</a>. <span id="line-1069"></span><span id="line-1070"></span></p><h2 id="expr_sub-string_fails_for_.22match.22">39. expr sub-string fails for &#34;match&#34;</h2>
<p>This works reasonably well <span id="line-1074"></span><span id="line-1075"></span></p><hr/><p> <span id="line-1076"></span>most of the time <span id="line-1077"></span><span id="line-1078"></span></p><pre><span id="line-1-99"></span>word=abcde
<span id="line-2-66"></span>expr &#34;$word&#34; : &#34;.\(.*\)&#34;
<span id="line-3-44"></span>bcde</pre><p>But WILL fail for the word &#34;match&#34; <span id="line-1084"></span><span id="line-1085"></span></p><pre><span id="line-1-100"></span>word=match
<span id="line-2-67"></span>expr &#34;$word&#34; : &#34;.\(.*\)&#34;</pre><p>The problem is &#34;match&#34; is a keyword. Solution (GNU only) is prefix with a &#39;+&#39; <span id="line-1090"></span><span id="line-1091"></span></p><pre><span id="line-1-101"></span>word=match
<span id="line-2-68"></span>expr + &#34;$word&#34; : &#34;.\(.*\)&#34;
<span id="line-3-45"></span>atch</pre><p>Or, y&#39;know, stop using <tt>expr</tt>.  You can do everything <tt>expr</tt> does by using <a href="http://mywiki.wooledge.org/BashFAQ/073">Parameter Expansion</a>.  What&#39;s that thing up there trying to do?  Remove the first letter of a word?  That can be done in POSIX shells using PE or Substring Expansion: <span id="line-1097"></span><span id="line-1098"></span></p><pre><span id="line-1-102"></span>$ word=match
<span id="line-2-69"></span>$ echo &#34;${word#?}&#34;    # PE
<span id="line-3-46"></span>atch
<span id="line-4-24"></span>$ echo &#34;${word:1}&#34;    # SE
<span id="line-5-18"></span>atch</pre><p>Seriously, there&#39;s no excuse for using <tt>expr</tt> unless you&#39;re on Solaris with its non-POSIX-conforming <tt>/bin/sh</tt>.  It&#39;s an external process, so it&#39;s much slower than in-process string manipulation.  And since nobody uses it, nobody understands what it&#39;s doing, so your code is obfuscated and hard to maintain. <span id="line-1106"></span><span id="line-1107"></span></p><h2 id="On_UTF-8_and_Byte-Order_Marks_.28BOM.29">40. On UTF-8 and Byte-Order Marks (BOM)</h2>
<p><strong>In general:</strong> Unix UTF-8 text does not use BOM. The encoding of plain text is determined by the locale or by mime types or other metadata. While the presence of a BOM would not normally damage a UTF-8 document meant only for reading by humans, it is problematic (often syntactically illegal) in any text file meant to be interpreted by automated processes such as scripts, source code, configuration files, and so on. Files starting with BOM should be considered equally foreign as those with MS-DOS linebreaks. <span id="line-1111"></span><span id="line-1112"></span></p><p><strong>In shell scripting:</strong> &#39;Where UTF-8 is used transparently in 8-bit environments, the use of a BOM will interfere with any protocol or file format that expects specific ASCII characters at the beginning, such as the use of &#34;#!&#34; of at the beginning of Unix shell scripts.&#39; <a href="http://unicode.org/faq/utf_bom.html#bom5">http://unicode.org/faq/utf_bom.html#bom5</a> <span id="line-1113"></span><span id="line-1114"></span></p><h2 id="content.3D.24.28.3Cfile.29">41. content=$(&lt;file)</h2>
<p>There isn&#39;t anything wrong with this expression, but you should be aware that command substitutions (all forms: <tt>`...`</tt>, <tt>$(...)</tt>, <tt>$(&lt;file)</tt>, <tt>`&lt;file`</tt>, and <tt>${ ...; }</tt> (ksh)) remove any trailing newlines. This is often inconsequential or even desirable, but if you must preserve the literal output including any possible trailing newlines, it gets tricky because you have no way of knowing whether the output had them or how many. One ugly but usable workaround is to add a postfix inside the command substitution and remove it on the outside: <span id="line-1118"></span><span id="line-1119"></span></p><pre><span id="line-1-103"></span>absolute_dir_path_x=$(readlink -fn -- &#34;$dir_path&#34;; printf x)
<span id="line-2-70"></span>absolute_dir_path=${absolute_dir_path_x%x}</pre><p>A less portable but arguably prettier solution is to use <tt>read</tt> with an empty delimiter. <span id="line-1124"></span><span id="line-1125"></span></p><pre><span id="line-1-104"></span># Ksh (or bash 4.2+ with lastpipe enabled)
<span id="line-2-71"></span>readlink -fn -- &#34;$dir_path&#34; | IFS= read -rd &#39;&#39; absolute_dir_path</pre><p>The downside to this method is that the <tt>read</tt> will always return false unless the command outputs a NUL byte causing only part of the stream to be read. The only way to get the exit status of the command is through <tt>PIPESTATUS</tt>. You could also intentionally output a NUL byte to force <tt>read</tt> to return true, and use <tt>pipefail</tt>. <span id="line-1130"></span><span id="line-1131"></span></p><pre><span id="line-1-105"></span>set -o pipefail
<span id="line-2-72"></span>{ readlink -fn -- &#34;$dir_path&#34; &amp;&amp; printf &#39;\0&#39;; } | IFS= read -rd &#39;&#39; absolute_dir_path
<span id="line-3-47"></span>set +o pipefail</pre><p>This is somewhat of a portability mess, as Bash supports both <tt>pipefail</tt> and <tt>PIPESTATUS</tt>, ksh93 supports <tt>pipefail</tt> only, and only recent versions of mksh support <tt>pipefail</tt>, while earlier versions supported <tt>PIPESTATUS</tt> only. Additionally, a bleeding-edge ksh93 version is required in order for <tt>read</tt> to stop at the NUL byte. <span id="line-1137"></span><span id="line-1138"></span></p><h2 id="for_file_in_..2F.2A_.3B_do_if_.5B.5B_.24file_.21.3D_.2A..2A_.5D.5D">42. for file in ./* ; do if [[ $file != *.* ]]</h2>
<p>One way to prevent programs from interpreting filenames passed to them as options is to use pathnames (see <a href="http://mywiki.wooledge.org/BashPitfalls#pf3">pitfall #3</a> above). For files under the current directory, names may be prefixed with a relative pathname <tt>./</tt>. <span id="line-1142"></span><span id="line-1143"></span></p><p>In the case of a pattern like <tt>*.*</tt> however, problems can arise because it matches a string of the form <tt>./filename</tt>. In a simple case, you can just use the glob directly to generate the desired matches. If however a separate pattern-matching step is required (e.g. the results have been preprocessed and stored in an array, and need to be filtered), it could be solved by taking the prefix into account in the pattern: <tt>[[ $file != ./*.* ]]</tt>, or by stripping the pattern from the match. <span id="line-1144"></span><span id="line-1145"></span></p><pre><span id="line-1-106"></span># Bash
<span id="line-2-73"></span>shopt -s nullglob
<span id="line-3-48"></span>for path in ./*; do
<span id="line-4-25"></span>    [[ ${path##*/} != *.* ]] &amp;&amp; rm &#34;$path&#34;
<span id="line-5-19"></span>done
<span id="line-6-12"></span>
<span id="line-7-8"></span># Or even better
<span id="line-8-5"></span>for file in *; do
<span id="line-9-5"></span>    [[ $file != *.* ]] &amp;&amp; rm &#34;./$file&#34;
<span id="line-10-4"></span>done
<span id="line-11-3"></span>
<span id="line-12-3"></span># Or better still
<span id="line-13-2"></span>for file in *.*; do
<span id="line-14-1"></span>    rm &#34;./$file&#34;
<span id="line-15-1"></span>done</pre><p>Another possibility is to signal the <em>end of options</em> with a <tt>--</tt> argument. (Again, covered in <a href="http://mywiki.wooledge.org/BashPitfalls#pf3">#pf3</a>). <span id="line-1163"></span><span id="line-1164"></span></p><pre><span id="line-1-107"></span>shopt -s nullglob
<span id="line-2-74"></span>for file in *; do
<span id="line-3-49"></span>    [[ $file != *.* ]] &amp;&amp; rm -- &#34;$file&#34;
<span id="line-4-26"></span>done</pre><h2 id="somecmd_2.3E.261_.3E.3Elogfile">43. somecmd 2&gt;&amp;1 &gt;&gt;logfile</h2>
<p>This is by far the most common mistake involving redirections, typically performed by someone wanting to direct both stdout and stderr to a file or pipe will try this and not understand why stderr is still showing up on their terminal. If you&#39;re perplexed by this, you probably don&#39;t understand how <a href="http://wiki.bash-hackers.org/howto/redirection_tutorial">redirections</a> or possibly <a href="http://mywiki.wooledge.org/FileDescriptor">file descriptors</a> work to begin with. Redirections are evaluated left-to-right before the command is executed. This semantically incorrect code essentially means: &#34;first redirect standard error to where standard out is currently pointing (the tty), then redirect standard out to logfile&#34;. This is backwards. Standard error is already going to the tty. Use the following instead: <span id="line-1174"></span><span id="line-1175"></span></p><pre><span id="line-1-108"></span>somecmd &gt;&gt;logfile 2&gt;&amp;1</pre><p>See <a href="http://mywiki.wooledge.org/BashFAQ/055">a more in-depth explanation</a>, <a href="http://wiki.bash-hackers.org/scripting/copydescriptor">Copy descriptor explained</a>, and <a href="http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection">BashGuide - redirection</a>. <span id="line-1179"></span><span id="line-1180"></span></p><h2 id="cmd.3B_.28.28_.21_.24.3F_.29.29_.7C.7C_die">44. cmd; (( ! $? )) || die</h2>
<p><tt>$?</tt> is only required if you need to retrieve the exact status of the previous command. If you only need to test for success or failure (any non-zero status), just test the command directly. e.g.: <span id="line-1184"></span><span id="line-1185"></span></p><pre><span id="line-1-109"></span>if cmd; then
<span id="line-2-75"></span>    ...
<span id="line-3-50"></span>fi</pre><p>Checking an exit status against a list of alternatives might follow a pattern like this: <span id="line-1191"></span><span id="line-1192"></span></p><pre><span id="line-1-110"></span>cmd
<span id="line-2-76"></span>status=$?
<span id="line-3-51"></span>case $status in
<span id="line-4-27"></span>    0)
<span id="line-5-20"></span>        echo success &gt;&amp;2
<span id="line-6-13"></span>        ;;
<span id="line-7-9"></span>    1)
<span id="line-8-6"></span>        echo &#39;Must supply a parameter, exiting.&#39; &gt;&amp;2
<span id="line-9-6"></span>        exit 1
<span id="line-10-5"></span>        ;;
<span id="line-11-4"></span>    *)
<span id="line-12-4"></span>        echo &#34;Unknown error $status, exiting.&#34; &gt;&amp;2
<span id="line-13-3"></span>        exit &#34;$status&#34;
<span id="line-14-2"></span>esac</pre><h2 id="y.3D.24.28.28_array.5B.24x.5D_.29.29">45. y=$(( array[$x] ))</h2>
<p>The code given to an arithmetic expansion or compound command undergoes an initial pass of expansions and substitutions to generate the text to be parsed and evaluated as an <a href="http://mywiki.wooledge.org/ArithmeticExpression">arithmetic expression</a>. <em>This must be handled carefully.</em> <span id="line-1212"></span><span id="line-1213"></span></p><p>For example, this expression is stitched together by expanding one code fragment into another. <span id="line-1214"></span><span id="line-1215"></span></p><pre><span id="line-1-111"></span>$ x=&#39;$(date &gt;&amp;2)&#39;        # redirection is just so we can see everything happen
<span id="line-2-77"></span>$ y=$((array[&#34;$x&#34;]))       # Quotes don&#39;t help. The array doesn&#39;t even have to exist
<span id="line-3-52"></span>Mon Jun  2 10:49:08 EDT 2014</pre><p>Next, the expanded string is passed to the arithmetic processor, which will need to get a reference to the array variable in the shell&#39;s internal symbol table using a lookup function to resolve variable&#39;s &#34;name&#34;. This name resolver takes a string - <tt>array[$(date &gt;&amp;2)]</tt> - consisting of the name, including the index and all literal code within brackets, just like e.g. <tt>read</tt> or <tt>printf -v</tt> do with variable names passed as arguments. The variable resolver performs expansions, <em>including command substitution</em>, to resolve the index. <span id="line-1222"></span><span id="line-1223"></span></p><p><small>(For numeric indexed arrays, the lookup function next evaluates the expanded text of the index as an arithmetic expression. Consequently, mutually recursive variable lookups and arithmetic expansions can occur to any depth (up to Bash&#39;s defined limit), any of which can produce unintended side-effects.)</small> <span id="line-1224"></span><span id="line-1225"></span></p><p>Most of the time, there is no need to use any kind of expansion within an arithmetic expansion. Use variable names directly in the expression (no <tt>$</tt>) wherever possible (i.e. except for positional parameters and POSIX &#34;special variables&#34;). Validate variables before using them and assure no expansion generates anything but a numeric literal - most issues are automatically avoided. <span id="line-1226"></span><span id="line-1227"></span></p><p>Escape any expansions to pass them into the expression without expanding them first: <span id="line-1228"></span><span id="line-1229"></span></p><pre><span id="line-1-112"></span># Typical task reading some columns into an associative array.
<span id="line-2-78"></span>typeset -A arr
<span id="line-3-53"></span>printf -v offset &#39;%(%s)T&#39; -1
<span id="line-4-28"></span>
<span id="line-5-21"></span>while IFS=&#39; &#39; read -r x y; do
<span id="line-6-14"></span>    [[ $x $y == +([0-9]) +([0-9]) ]] # validate input (see next pitfall)
<span id="line-7-10"></span>    (( arr[\$(date -d &#34;@$x&#34; +%F)] = y - offset )) # Escaped substitution passes the entire expression literally.
<span id="line-8-7"></span>done</pre><p>Another option is to use <tt>let</tt> with single-quoted arguments. <tt>((expr))</tt> is equivalent to <tt>let &#34;expr&#34;</tt> (double-quoted args). <span id="line-1240"></span><span id="line-1241"></span></p><h2 id="read_num.3B_echo_.24.28.28num.2B-1.29.29">46. read num; echo $((num+1))</h2>
<p>Always validate your input (see <a href="http://mywiki.wooledge.org/BashFAQ/054">BashFAQ/054</a>) before using num in an arithmetic context as it allows code injection. <span id="line-1245"></span><span id="line-1246"></span></p><pre><span id="line-1-113"></span>$ echo &#39;a[$(echo injection &gt;&amp;2)]&#39; | bash -c &#39;read num; echo $((num+1))&#39;
<span id="line-2-79"></span>injection
<span id="line-3-54"></span>1</pre><h2 id="IFS.3D.2C_read_-ra_fields_.3C.3C.3C_.22.24csv_line.22">47. IFS=, read -ra fields &lt;&lt;&lt; &#34;$csv_line&#34;</h2>
<p>Unbelievable as it may seem, POSIX requires the treatment of <a href="http://mywiki.wooledge.org/IFS">IFS</a> as a field <em>terminator</em>, rather than a field <em>separator</em>.  What this means in our example is that if there&#39;s an empty field at the end of the input line, it will be discarded: <span id="line-1255"></span><span id="line-1256"></span></p><pre><span id="line-1-114"></span>$ IFS=, read -ra fields &lt;&lt;&lt; &#34;a,b,&#34;
<span id="line-2-80"></span>$ declare -p fields
<span id="line-3-55"></span>declare -a fields=&#39;([0]=&#34;a&#34; [1]=&#34;b&#34;)&#39;</pre><p>Where did the empty field go?  It was eaten for historical reasons (&#34;because it&#39;s always been that way&#34;).  This behavior is not unique to bash; all conformant shells do it.  A non-empty field is properly scanned: <span id="line-1262"></span><span id="line-1263"></span></p><pre><span id="line-1-115"></span>$ IFS=, read -ra fields &lt;&lt;&lt; &#34;a,b,c&#34;
<span id="line-2-81"></span>$ declare -p fields
<span id="line-3-56"></span>declare -a fields=&#39;([0]=&#34;a&#34; [1]=&#34;b&#34; [2]=&#34;c&#34;)&#39;</pre><p>So, how do we work around this nonsense?  As it turns out, appending an IFS character to the end of the input string will force the scanning to work.  If there was a trailing empty field, the extra IFS character &#34;terminates&#34; it so that it gets scanned.  If there was a trailing non-empty field, the IFS character creates a new, empty field that gets dropped. <span id="line-1269"></span><span id="line-1270"></span></p><pre><span id="line-1-116"></span>$ input=&#34;a,b,&#34;
<span id="line-2-82"></span>$ IFS=, read -ra fields &lt;&lt;&lt; &#34;$input,&#34;
<span id="line-3-57"></span>$ declare -p fields
<span id="line-4-29"></span>declare -a fields=&#39;([0]=&#34;a&#34; [1]=&#34;b&#34; [2]=&#34;&#34;)&#39;</pre><h2 id="export_CDPATH.3D.:.2BAH4-.2FmyProject">48. export CDPATH=.:~/myProject</h2>
<p>Do not export CDPATH. <span id="line-1280"></span><span id="line-1281"></span></p><p>Setting CDPATH in .bashrc is not an issue, but exporting it will cause any bash or sh script you run, that happen to use <tt>cd</tt>, to potentially change behaviour. <span id="line-1282"></span><span id="line-1283"></span></p><p>There are two problems. A script that does the following: <span id="line-1284"></span><span id="line-1285"></span></p><pre><span id="line-1-117"></span>cd some/dir || exit
<span id="line-2-83"></span>cmd to be run in some/dir</pre><p>may change directory to <tt>~/myProject/some/dir</tt> instead of <tt>./some/dir</tt>, depending on what directories exist at the time. So the <tt>cd</tt> may succeed and take the script to the wrong directory, with potentially harmful effects of the following commands which now run in a different directory than intended. <span id="line-1290"></span><span id="line-1291"></span></p><p>The second problem is when <tt>cd</tt> is run in a context where the output is captured: <span id="line-1292"></span><span id="line-1293"></span></p><pre><span id="line-1-118"></span>output=$(cd some/dir &amp;&amp; some command)</pre><p>As a side-effect when CDPATH is set, <tt>cd</tt> will output something like <tt>/home/user/some/dir</tt> to stdout to indicate that it found a directory through CDPATH, which in turn will end up in the output variable along with the intended output of <tt>some command</tt>. <span id="line-1297"></span><span id="line-1298"></span></p><p>A script can make itself immune to a CDPATH inherited from the environment by always prepending <tt>./</tt> to relative paths, or run <tt>unset CDPATH</tt> at the start of the script, but don&#39;t assume every scripter has taken this pitfall into account, so don&#39;t export CDPATH. <span id="line-1299"></span><span id="line-1300"></span></p><h2 id="OIFS.3D.22.24IFS.22.3B_....3B_IFS.3D.22.24OIFS.22">49. OIFS=&#34;$IFS&#34;; ...; IFS=&#34;$OIFS&#34;</h2>
<p>Directly assigning a variable&#39;s value to a temporary variable isn&#39;t alone enough to restore its state. The assignment will always result in a <em>set</em> but <em>empty</em> temporary variable even if the initial variable was unset. This is a particular problem for IFS because an <em>empty</em> IFS has a completely different meaning from an <em>unset</em> IFS, and setting IFS to a temporary value for a command or two is a common requirement. <span id="line-1304"></span><span id="line-1305"></span></p><p>An easy workaround is to designate a prefix to distinguish set from unset vars, then strip it when finished. <span id="line-1306"></span><span id="line-1307"></span></p><pre><span id="line-1-119"></span>oIFS=${IFS+_${IFS}}
<span id="line-2-84"></span>IFS=/; echo &#34;${array[*]}&#34;
<span id="line-3-58"></span>${oIFS:+&#39;false&#39;} unset -v IFS || IFS=${oIFS#_}</pre><p>A local variable is usually preferable when possible. <span id="line-1313"></span><span id="line-1314"></span></p><pre><span id="line-1-120"></span>f() {
<span id="line-2-85"></span>  local IFS
<span id="line-3-59"></span>  IFS=/; echo &#34;${array[*]}&#34;
<span id="line-4-30"></span>}
<span id="line-5-22"></span>f</pre><p>Subshells are another possibility. <span id="line-1322"></span><span id="line-1323"></span></p><pre><span id="line-1-121"></span>( IFS=/; echo &#34;${array[*]}&#34; )</pre><h2 id="hosts.3D.28_.24.28aws_....29_.29">50. hosts=( $(aws ...) )</h2>
<p>It is not safe to populate an array with a raw <tt>$(...)</tt> <a href="http://mywiki.wooledge.org/CommandSubstitution">CommandSubstitution</a>.  The output of the command undergoes word splitting (on <em>all</em> whitespace, even ones that are inside quotes) and then <a href="http://mywiki.wooledge.org/glob">globbing</a>.  If there&#39;s a word like <tt>*</tt> or <tt>eh?</tt> or <tt>[abc]</tt> in the result, it will be expanded based on filenames in the current working directory. <span id="line-1330"></span><span id="line-1331"></span></p><p>To select a replacement, you need to know whether the command writes its output on a single line, or multiple lines.  If it&#39;s a single line: <span id="line-1332"></span><span id="line-1333"></span></p><pre><span id="line-1-122"></span>read -ra hosts &lt; &lt;(aws ...)</pre><p>If it&#39;s multiple lines (and you&#39;re targeting bash 4.0 or later): <span id="line-1337"></span><span id="line-1338"></span></p><pre><span id="line-1-123"></span>readarray -t hosts &lt; &lt;(aws ...)</pre><p>If it&#39;s multiple lines (and you want compatibility with bash 3.x, <em>or</em> want your command&#39;s exit status to be reflected in success or failure of the <tt>read</tt> operation without depending on behavior only available in bash 4.4 and newer): <span id="line-1342"></span><span id="line-1343"></span></p><pre><span id="line-1-124"></span>IFS=$&#39;\n&#39; read -r -d &#39;&#39; -a hosts &lt; &lt;(aws ... &amp;&amp; printf &#39;\0&#39;)</pre><p>This will prevent globbing.  It still won&#39;t help you if you needed to avoid splitting on quoted whitespace, but unfortunately <em>nothing</em> bash can do handles that case.  For generalized CSV (comma-separated value) file handling, you really need to switch to a language that has a dedicated CSV input library. <span id="line-1347"></span><span id="line-1348"></span></p><h2 id="Non-atomic_writes_with_xargs_-P">51. Non-atomic writes with xargs -P</h2>
<p>GNU <tt>xargs</tt> supports running multiple jobs in parallel. <tt>-P n</tt> where <strong>n</strong> is the number of jobs to run in parallel. <span id="line-1352"></span><span id="line-1353"></span></p><pre><span id="line-1-125"></span>seq 100 | xargs -n1 -P10 echo &#34;$a&#34; | grep 5
<span id="line-2-86"></span>seq 100 | xargs -n1 -P10 echo &#34;$a&#34; &gt; myoutput.txt</pre><p>This will work fine for many situations but has a deceptive flaw: If <tt>$a</tt> contains more than 8192 characters (the limit depends on platform and version), the <tt>echo</tt> may not be atomic (it may be split into multiple <tt>write()</tt> calls), and there is a risk that two lines will be mixed. <span id="line-1358"></span><span id="line-1359"></span></p><pre><span id="line-1-126"></span>$ perl -e &#39;print &#34;a&#34;x10000, &#34;\n&#34;&#39; &gt; foo
<span id="line-2-87"></span>$ strace -e write bash -c &#39;read -r foo &lt; foo; echo &#34;$foo&#34;&#39; &gt;/dev/null
<span id="line-3-60"></span>write(1, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 8192) = 8192
<span id="line-4-31"></span>write(1, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 1809) = 1809
<span id="line-5-23"></span>+++ exited with 0 +++</pre><p>Obviously the same issue arises if there are multiple calls to <tt>echo</tt> or <tt>printf</tt>: <span id="line-1367"></span><span id="line-1368"></span></p><pre><span id="line-1-127"></span>slowprint() {
<span id="line-2-88"></span>  printf &#39;Start-%s &#39; &#34;$1&#34;
<span id="line-3-61"></span>  sleep &#34;$1&#34;
<span id="line-4-32"></span>  printf &#39;%s-End\n&#39; &#34;$1&#34;
<span id="line-5-24"></span>}
<span id="line-6-15"></span>export -f slowprint
<span id="line-7-11"></span>seq 10 | xargs -n1 -I {} -P4 bash -c &#34;slowprint {}&#34;
<span id="line-8-8"></span># Compare to no parallelization
<span id="line-9-7"></span>seq 10 | xargs -n1 -I {} bash -c &#34;slowprint {}&#34;
<span id="line-10-6"></span># Be sure to see the warnings in the next Pitfall!</pre><p>Outputs from the parallel jobs are mixed together, because each job consists of two (or more) separate <tt>write()</tt> calls. <span id="line-1381"></span><span id="line-1382"></span></p><p>If you need the outputs unmixed, it is therefore recommended to use a tool that guarantees output will be serialized (such as GNU Parallel). <span id="line-1383"></span><span id="line-1384"></span></p><p>For further details see <a href="https://gist.github.com/ole-tange/88ae153797748b3618e2433377e2870a">a demonstration of the mixing problem</a>. <span id="line-1385"></span><span id="line-1386"></span></p><h2 id="find_._-exec_sh_-c_.27echo_.7B.7D.27_.2BAFw.3B">52. find . -exec sh -c &#39;echo {}&#39; \;</h2>
<p>This command contains a <a href="http://mywiki.wooledge.org/CodeInjection">CodeInjection</a> vulnerability.  The filename that is found by <tt>find</tt> is injected into a shell command and parsed by <tt>sh</tt>.  If the filename contains shell metacharacters like <tt>;</tt> or <tt>$( ... )</tt> then the filename may be <em>executed as code</em> by `sh&#39;. <span id="line-1390"></span><span id="line-1391"></span></p><p>The &#34;slowprint&#34; example in the previous Pitfall would have been a <a href="http://mywiki.wooledge.org/CodeInjection">CodeInjection</a> bug if the input weren&#39;t guaranteed to be integers. <span id="line-1392"></span><span id="line-1393"></span></p><p>To be more precise, <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html#tag_20_47">POSIX find</a> does not specify whether an argument which contains <em>more than</em> just <tt>{}</tt> is expanded.  GNU <tt>find</tt> allows this <a href="http://mywiki.wooledge.org/CodeInjection">CodeInjection</a> to occur.  Other implementations choose a safer path: <span id="line-1394"></span><span id="line-1395"></span></p><pre><span id="line-1-128"></span># uname -a
<span id="line-2-89"></span>HP-UX imadev B.10.20 A 9000/785 2008897791 two-user license
<span id="line-3-62"></span># find /dev/null -exec sh -c &#39;echo {}&#39; \;
<span id="line-4-33"></span>{}</pre><p>The correct approach is to <em>separate</em> the filename argument from the script argument: <span id="line-1402"></span><span id="line-1403"></span></p><pre><span id="line-1-129"></span>find . -exec sh -c &#39;echo &#34;$1&#34;&#39; x {} \;</pre><h2 id="sudo_mycmd_.3E_.2Fmyfile">53. sudo mycmd &gt; /myfile</h2>
<p><a href="http://mywiki.wooledge.org/Redirection">Redirection</a> is done <em>before</em> the command is executed.  Usually that doesn&#39;t matter, but with <tt>sudo</tt> we have a command being executed as a different user than the redirection. <span id="line-1410"></span><span id="line-1411"></span></p><p>If the redirection must be executed with <tt>sudo</tt>-granted privileges, then you need a wrapper: <span id="line-1412"></span><span id="line-1413"></span></p><pre><span id="line-1-130"></span>sudo sh -c &#39;mycmd &gt; /myfile&#39;</pre><p>Instead of a wrapper you can use <tt>tee</tt>: <span id="line-1417"></span><span id="line-1418"></span></p><pre><span id="line-1-131"></span>mycmd | sudo tee /myfile &gt;/dev/null</pre><p>This may be easier to write if <tt>mycmd</tt> has a lot of quoting. <span id="line-1422"></span><span id="line-1423"></span></p><h2 id="sudo_ls_.2Ffoo.2F.2A">54. sudo ls /foo/*</h2>
<p>This is very similar to the previous pitfall.  <a href="http://mywiki.wooledge.org/glob">Globbing</a> is also done <em>before</em> the command is executed.  If the directory isn&#39;t readable by your normal user privileges, then you may need the globbing to be done in a shell that has the <tt>sudo</tt>-granted privileges: <span id="line-1427"></span><span id="line-1428"></span></p><pre><span id="line-1-132"></span>sudo sh -c &#39;ls /foo/*&#39;</pre><h2 id="myprogram_2.3E.26-">55. myprogram 2&gt;&amp;-</h2>
<p><strong>Do not</strong> close stdin, stdout or stderr as a &#34;shorthand&#34; for redirecting to <tt>/dev/null</tt>.  Write it out correctly. <span id="line-1435"></span><span id="line-1436"></span></p><pre><span id="line-1-133"></span>myprogram 2&gt;/dev/null</pre><p>Why?  Consider what happens when your program tries to write an error message to stderr.  If stderr has been redirected to <tt>/dev/null</tt>, the write succeeds, and your program is free to carry on, secure in the knowledge that it has diligently reported the error condition. <span id="line-1440"></span><span id="line-1441"></span></p><p>But if stderr has been <em>closed</em>, then the write will fail.  At that point, your program may do something unpredictable.  It may carry on and ignore the failure, or it may immediately exit, considering the execution environment so broken that it cannot safely continue.  Or whatever else the programmer decided the program should do when its world has become a dystopian hell. <span id="line-1442"></span><span id="line-1443"></span></p><p>All programs are assured that stdin, stdout and stderr will <em>exist</em> and will be readable/writable in an appropriate and reasonable manner.  By closing one of them, you have violated your promise to this program.  This is not acceptable. <span id="line-1444"></span><span id="line-1445"></span></p><p>Of course, an even better solution would be to actually log the errors somewhere, so you can go back and read them and figure out what&#39;s wrong. <span id="line-1446"></span><span id="line-1447"></span></p><h2 id="Using_xargs_without_-0">56. Using xargs without -0</h2>
<p><tt>xargs</tt> splits on whitespace. This is unfortunate because whitespace is allowed in filenames and commonly used by GUI users. <tt>xargs</tt> also treats <tt>&#39;</tt> and <tt>&#34;</tt> specially, which can also lead to problems: <span id="line-1451"></span><span id="line-1452"></span></p><pre><span id="line-1-134"></span>touch Dad\&#39;s\ \&#34;famous\&#34;\ 1\&#39;\ pizza.txt
<span id="line-2-90"></span>touch Dad\&#39;s\ 12\&#34;\ records.txt
<span id="line-3-63"></span>touch 2\&#34;x1\&#39;\ wood.txt
<span id="line-4-34"></span>touch 2\&#34;x4\&#34;\ wood.txt</pre><p>Here <tt>xargs</tt> warns: <span id="line-1459"></span><span id="line-1460"></span></p><pre><span id="line-1-135"></span># Do not do this
<span id="line-2-91"></span>$ find . -type f | xargs wc
<span id="line-3-64"></span>xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option</pre><p>Here <tt>xargs</tt> does not warn at all: <span id="line-1466"></span><span id="line-1467"></span></p><pre><span id="line-1-136"></span># Do not do this
<span id="line-2-92"></span>echo * | xargs wc
<span id="line-3-65"></span>find *famous* -type f | xargs wc
<span id="line-4-35"></span>find *4* -type f | xargs wc</pre><p>Instead use <tt>xargs -0</tt>: <span id="line-1474"></span><span id="line-1475"></span></p><pre><span id="line-1-137"></span># Do this instead
<span id="line-2-93"></span>printf &#39;%s\0&#39; * | xargs -0 wc
<span id="line-3-66"></span>find . -type f -name &#39;*famous*&#39; -print0 | xargs -0 wc
<span id="line-4-36"></span>find . -type f -name &#39;*4*&#39; -exec wc {} +</pre><p>If using <tt>-0</tt> is not simple, an alternative is to use GNU Parallel, which splits on \n. And while \n is also allowed in filenames they never occur unless your users are malicious. In any case: <strong>If</strong> you use <tt>xargs</tt> without <tt>-0</tt> put a comment in your code explaining why that is safe in your particular situation. <span id="line-1482"></span><span id="line-1483"></span></p><h2 id="unset_a.5B0.5D">57. unset a[0]</h2>
<p>When passing an <a href="http://mywiki.wooledge.org/BashFAQ/005">indexed array element</a> to <tt>unset</tt>, it needs to be quoted.  Otherwise, it may be treated as a <a href="http://mywiki.wooledge.org/glob">glob</a>, and expanded against the files in the current directory.  If there happens to be a file named <tt>a0</tt> then the glob is expanded to <tt>a0</tt> and you end up executing <tt>unset a0</tt>. <span id="line-1487"></span><span id="line-1488"></span></p><pre><span id="line-1-138"></span>unset &#39;a[0]&#39;     # Always quote indexed array elements when unsetting.</pre><h2 id="month.3D.24.28date_.2B-.25m.29.3B_day.3D.24.28date_.2B-.25d.29">58. month=$(date +%m); day=$(date +%d)</h2>
<p>Calling <tt>date</tt> multiple times is a bad idea.  Imagine what happens if the first call occurs a millisecond before midnight on April 30, and the second call occurs a millisecond after midnight on May 1.  You would end up with month=04 and day=01. <span id="line-1495"></span><span id="line-1496"></span></p><p>It&#39;s better to call date <em>one</em> time, retrieving all of the fields you want in a single invocation. <span id="line-1497"></span><span id="line-1498"></span></p><p>A common idiom for that: <span id="line-1499"></span><span id="line-1500"></span></p><pre><span id="line-1-139"></span>eval &#34;$(date +&#39;month=%m day=%d year=%Y dayname=&#34;%A&#34; monthname=&#34;%B&#34;&#39;)&#34;</pre><p>Or with bash&#39;s (4.2 or above) <tt>printf</tt> builtin: <span id="line-1504"></span><span id="line-1505"></span></p><pre><span id="line-1-140"></span>printf -v d &#39;%(month=%m day=%d year=%Y dayname=&#34;%A&#34; monthname=&#34;%B&#34;)T&#39;
<span id="line-2-94"></span>eval &#34;$d&#34;</pre><p>Remember things like month or day names are locale-dependent, hence the quotes around <tt>%A</tt> or <tt>%B</tt> to avoid problems in locales where day or month names contain spaces or other special characters for the shell. <span id="line-1510"></span><span id="line-1511"></span></p><p>Or, you may retrieve a timestamp in epoch format (seconds since the start of 1970), and then use that to generate human-readable date/time fields as needed. <span id="line-1512"></span><span id="line-1513"></span></p><pre><span id="line-1-141"></span># Requires bash 4.2 or above
<span id="line-2-95"></span>printf -v now &#39;%(%s)T&#39; -1        # Or now=$EPOCHSECONDS in bash 5.0
<span id="line-3-67"></span>                                 # -1 may be omitted in 4.3 or above
<span id="line-4-37"></span>printf -v month &#39;%(%m)T&#39; &#34;$now&#34;
<span id="line-5-25"></span>printf -v day &#39;%(%d)T&#39; &#34;$now&#34;</pre><p>If your system&#39;s <tt>strftime()</tt> doesn&#39;t support <tt>%s</tt>, you can get the epoch time with: <span id="line-1521"></span><span id="line-1522"></span></p><pre><span id="line-1-142"></span>now=$(awk &#39;BEGIN{srand(); print srand()}&#39;)</pre><h2 id="i.3D.24.28.28_10.23.24i_.29.29">59. i=$(( 10#$i ))</h2>
<p>Forced base 10 interpretation only works with signless numbers.  As long as <tt>$i</tt> contains a string of digits with no leading <tt>-</tt> or <tt>+</tt>, everything is fine.  But if <tt>$i</tt> might be negative, this conversion could fail, either noisily (with an error message), or even worse, silently (simply yielding the wrong result). <span id="line-1529"></span><span id="line-1530"></span></p><p>If there&#39;s any chance <tt>$i</tt> could be negative, use this instead: <span id="line-1531"></span><span id="line-1532"></span></p><pre><span id="line-1-143"></span>i=$(( ${i%%[!+-]*}10#${i#[-+]} ))</pre><p>For explanations, please see <a href="http://mywiki.wooledge.org/ArithmeticExpression">ArithmeticExpression</a>. <span id="line-1536"></span><span id="line-1537"></span></p><h2 id="set_-euo_pipefail">60. set -euo pipefail</h2>
<p>There are many pitfalls to enabling these options at the start of a script. <span id="line-1540"></span><span id="line-1541"></span></p><h3 id="errexit">60.1. errexit</h3>
<p>errexit (set -e) tries to abort the script when an error occurs, which sounds <span id="line-1544"></span>like a good idea at first, but it has very intricate rules regarding when to <span id="line-1545"></span>abort on error or not. Some of the main problems with errexit are <span id="line-1546"></span><span id="line-1547"></span></p><ul><li><p>It&#39;s not actually possible for the shell to detect errors. All it has to go on is a command&#39;s exit status. When commands fail, they normally return a non-zero exit status, but many commands also use the exit status to convey a true/false value. Examples of such commands are <tt>test</tt>, <tt>[</tt>, <tt>[[ ... ]]</tt>, <tt>((...))</tt>, and <tt>grep</tt>. <span id="line-1548"></span></p></li><li><p>When a command you test with <tt>if</tt> or <tt>&amp;&amp;</tt> or <tt>||</tt> is a function, set -e ignores <span id="line-1549"></span>non-zero exit statuses of commands in that function. Consider a function like <span id="line-1550"></span><span id="line-1551"></span><span id="line-1552"></span><span id="line-1553"></span><span id="line-1554"></span><span id="line-1555"></span><span id="line-1556"></span></p><pre><span id="line-1-144"></span># WRONG
<span id="line-2-96"></span>cleanup() {
<span id="line-3-68"></span>  cd &#34;$1&#34;
<span id="line-4-38"></span>  rm -f ./*
<span id="line-5-26"></span>}</pre><span id="line-1557"></span><span id="line-1558"></span><p>If that <tt>cd</tt> command fails, you definitely don&#39;t want that <tt>rm</tt> command to run, <span id="line-1559"></span>and with a simple use of the function when errexit is enabled, that happens to <span id="line-1560"></span>be the case: <span id="line-1561"></span><span id="line-1562"></span><span id="line-1563"></span><span id="line-1564"></span><span id="line-1565"></span><span id="line-1566"></span><span id="line-1567"></span><span id="line-1568"></span><span id="line-1569"></span><span id="line-1570"></span></p><pre><span id="line-1-145"></span>set -e
<span id="line-2-97"></span>cleanup() {
<span id="line-3-69"></span>  cd &#34;$1&#34;
<span id="line-4-39"></span>  printf &#39;Oops!\n&#39;
<span id="line-5-27"></span>}
<span id="line-6-16"></span>cleanup /no/longer/there
<span id="line-7-12"></span># scriptname: cd: /no/longer/there: No such file or directory</pre><span id="line-1571"></span><span id="line-1572"></span>But then later you decide to add a custom error message <span id="line-1573"></span><span id="line-1574"></span><span id="line-1575"></span><span id="line-1576"></span><span id="line-1577"></span><span id="line-1578"></span><span id="line-1579"></span><span id="line-1580"></span><span id="line-1581"></span><pre><span id="line-1-146"></span>cleanup /no/longer/there || {
<span id="line-2-98"></span>  printf &gt;&amp;2 &#39;Cleanup failed\n&#39;
<span id="line-3-70"></span>  exit 1
<span id="line-4-40"></span>}
<span id="line-5-28"></span># scriptname: cd: /no/longer/there: No such file or directory
<span id="line-6-17"></span># Oops!</pre><span id="line-1582"></span><span id="line-1583"></span><p><tt>cd</tt> is being run in a context where it&#39;s tested, even though it&#39;s not at all  <span id="line-1584"></span>apparent inside the function definition where the line is located. The correct  <span id="line-1585"></span>way, with or without errexit, is to explicitly check if <tt>cd</tt> failed or not <span id="line-1586"></span><span id="line-1587"></span><span id="line-1588"></span><span id="line-1589"></span><span id="line-1590"></span><span id="line-1591"></span><span id="line-1592"></span><span id="line-1593"></span></p><pre><span id="line-1-147"></span># Right
<span id="line-2-99"></span>cleanup() {
<span id="line-3-71"></span>  cd &#34;$1&#34; || return
<span id="line-4-41"></span>  rm -f ./*
<span id="line-5-29"></span>}</pre><span id="line-1594"></span><span id="line-1595"></span></li><li>Command substitution disables errexit. Consider the following example function <span id="line-1596"></span>that mimics a realpath command: <span id="line-1597"></span><span id="line-1598"></span><span id="line-1599"></span><span id="line-1600"></span><span id="line-1601"></span><span id="line-1602"></span><span id="line-1603"></span><span id="line-1604"></span><span id="line-1605"></span><pre><span id="line-1-148"></span>set -e
<span id="line-2-100"></span>realdir() {
<span id="line-3-72"></span>  cd &#34;$1&#34;
<span id="line-4-42"></span>  pwd -P
<span id="line-5-30"></span>}
<span id="line-6-18"></span>realdir /no/such/dir
<span id="line-7-13"></span># scriptname: cd: /no/such/dir</pre><span id="line-1606"></span><span id="line-1607"></span><p>It aborted on the failing <tt>cd</tt> command, but if you try to capture its output,  <span id="line-1608"></span>then <tt>cd</tt>&#39;s failure is ignored <span id="line-1609"></span><span id="line-1610"></span><span id="line-1611"></span><span id="line-1612"></span><span id="line-1613"></span><span id="line-1614"></span><span id="line-1615"></span></p><pre><span id="line-1-149"></span>dir=$(realdir /no/such/dir)
<span id="line-2-101"></span># scriptname: cd: /no/such/dir
<span id="line-3-73"></span>printf &#39;dir is &lt;%s&gt;\n&#39; &#34;$dir&#34;
<span id="line-4-43"></span># dir is &lt;/home/user&gt;</pre><span id="line-1616"></span><span id="line-1617"></span><p>The correct way is again to explicitly check if <tt>cd</tt> failed or not, regardless <span id="line-1618"></span>of whether you use errexit <span id="line-1619"></span><span id="line-1620"></span><span id="line-1621"></span><span id="line-1622"></span><span id="line-1623"></span><span id="line-1624"></span><span id="line-1625"></span><span id="line-1626"></span></p><pre><span id="line-1-150"></span># Right
<span id="line-2-102"></span>realdir() {
<span id="line-3-74"></span>  cd &#34;$1&#34; || return
<span id="line-4-44"></span>  pwd -P
<span id="line-5-31"></span>}</pre><span id="line-1627"></span><span id="line-1628"></span></li></ul><p>See <span id="line-1629"></span><a href="http://mywiki.wooledge.org/BashFAQ/105">Why doesn&#39;t set -e (or set -o errexit, or trap ERR) do what I expected?</a>. <span id="line-1630"></span><span id="line-1631"></span></p><h3 id="pipefail">60.2. pipefail</h3>
<p>Normally, the exit status of a pipeline is the exit status of the last <span id="line-1634"></span>command of that pipeline. With pipefail, if any part of the pipeline returns <span id="line-1635"></span>non-zero, the whole pipeline returns non-zero. This may sound like a good idea, <span id="line-1636"></span>but it&#39;s actually normal for commands earlier in a pipeline to exit non-zero <span id="line-1637"></span>without it being an error. Consider the following example <span id="line-1638"></span><span id="line-1639"></span></p><pre><span id="line-1-151"></span>if some_command | grep -q foo; then
<span id="line-2-103"></span>   printf &#39;foo found\n&#39;
<span id="line-3-75"></span>else
<span id="line-4-45"></span>   printf &#39;foo not found\n&#39;
<span id="line-5-32"></span>fi</pre><p>If pipefail is enabled, the above will sometimes claim &#34;foo not found&#34; even when <span id="line-1648"></span>foo was found. <span id="line-1649"></span><span id="line-1650"></span></p><p><tt>grep -q foo</tt> returns 0 to indicate that at least one line matches the pattern, <span id="line-1651"></span>else it returns 1 to indicate that no lines matched the pattern. Since <tt>-q</tt> <span id="line-1652"></span>(quiet) causes grep to not output the matching lines, it doesn&#39;t actually need <span id="line-1653"></span>to read the whole stream; it&#39;s enough to find at least one line that matches the <span id="line-1654"></span>pattern. A typical grep implementation will thus exit with status 0 as soon as <span id="line-1655"></span>it found the first matching line. <span id="line-1656"></span><span id="line-1657"></span></p><p>The <tt>some_command</tt> on the other end of the pipeline will not know that. It only <span id="line-1658"></span>sees its end of the pipe, it does not see what is on the other end. When it <span id="line-1659"></span>tries to write the next chunk of data to the pipe, and the pipe is closed in the <span id="line-1660"></span>other end, the system will send <tt>some_command</tt> a SIGPIPE signal to tell it that <span id="line-1661"></span>it can no longer write to the pipe. The default action to take when SIGPIPE is <span id="line-1662"></span>received is to exit with a non-zero status. This means that the whole pipeline <span id="line-1663"></span>returns non-zero, and the <tt>else</tt> branch is executed, even though it successfully <span id="line-1664"></span>found a matching line. <span id="line-1665"></span><span id="line-1666"></span></p><p>If you know that each part of a pipeline beyond the first will consume all their <span id="line-1667"></span>input, pipefail is safe and often a good choice, but it should not be enabled <span id="line-1668"></span>globally, only enabled for pipelines where it makes sense, and disabled <span id="line-1669"></span>afterwards. <span id="line-1670"></span><span id="line-1671"></span></p><h3 id="nounset">60.3. nounset</h3>
<p>nounset (set -u) is the least bad of the three options, but has its fair share <span id="line-1674"></span>of gotchas too. If the goal is to catch typoed variable names, <span id="line-1675"></span><a href="https://shellcheck.net">shellcheck</a> does a better job at detecting those. <span id="line-1676"></span><span id="line-1677"></span></p><p>See <span id="line-1678"></span><a href="http://mywiki.wooledge.org/BashFAQ/112">What are the advantages and disadvantages of using set -u (or set -o nounset)?</a> <span id="line-1679"></span><span id="line-1680"></span></p><h2 id="A.5B.5B_-v_hash.5B.24key.5D_.5D.5D">61. [[ -v hash[$key] ]]</h2>
<p>Here, <tt>hash</tt> is an <a href="http://mywiki.wooledge.org/BashFAQ/006">associative array</a>.  This construct fails because <tt>$key</tt> is expanded before the array subscript evaluation, and then the whole array plus expanded index is evaluated in a second pass.  It will appear to work for simple keys, but it will fail for keys containing quotes, closing square brackets, etc.  Even worse, it introduces a <a href="http://mywiki.wooledge.org/CodeInjection">CodeInjection</a> if the <tt>$key</tt> contains <a href="http://mywiki.wooledge.org/CommandSubstitution">CommandSubstitution</a> syntax. <span id="line-1683"></span><span id="line-1684"></span></p><p>The same problem applies to the <tt>test</tt> and <tt>[</tt> commands, as well as any use of an associative array element in an arithmetic context. <span id="line-1685"></span><span id="line-1686"></span></p><p>Newer versions of bash (5.0 and higher) have a <tt>assoc_expand_once</tt> option which will suppress the multiple evaluations.  Another choice is to single-quote the entire argument: <span id="line-1687"></span><span id="line-1688"></span></p><pre><span id="line-1-152"></span>[[ -v &#39;hash[$key]&#39; ]]</pre><p>This has the advantage of working in older versions of bash as well as newer versions. <span id="line-1693"></span><span id="line-1694"></span></p><h2 id="A.28.28_hash.5B.24key.5D.2B-.2B-_.29.29">62. (( hash[$key]++ ))</h2>
<p>Surprise!  <a href="http://mywiki.wooledge.org/BashFAQ/006">Associative arrays</a> are even <em>more</em> broken in math contexts.  The single-quoting trick from the previous pitfall isn&#39;t enough to fix this, either. <span id="line-1697"></span><span id="line-1698"></span></p><pre><span id="line-1-153"></span>$ declare -A hash
<span id="line-2-104"></span>$ key=\&#39;\]
<span id="line-3-76"></span>$ hash[$key]=17
<span id="line-4-46"></span>$ (( hash[$key]++ ))
<span id="line-5-33"></span>bash: ((: hash[&#39;]]++ : bad array subscript (error token is &#34;hash[&#39;]]++ &#34;)
<span id="line-6-19"></span>$ (( &#39;hash[$key]++&#39; ))
<span id="line-7-14"></span>bash: ((: &#39;hash[&#39;]]++&#39; : syntax error: operand expected (error token is &#34;&#39;hash[&#39;]]++&#39; &#34;)</pre><p><a href="https://lists.gnu.org/archive/html/bug-bash/2021-02/msg00189.html">According to Chet Ramey</a>, the single quotes don&#39;t work here because the contents of a math context are treated as though they are double-quoted, and therefore the single quotes have no special meaning.  However, backslash still has special meaning, and may be used to quote the index: <span id="line-1709"></span><span id="line-1710"></span></p><pre><span id="line-1-154"></span>(( hash[\$key]++ ))    # Safe</pre><p>Another safe way to modify an element of an associative array in a calculation is to make a temporary copy of the value in a regular (string) variable. <span id="line-1715"></span><span id="line-1716"></span></p><pre><span id="line-1-155"></span>tmp=${hash[$key]}
<span id="line-2-105"></span>((tmp++))              # Safe
<span id="line-3-77"></span>hash[$key]=$tmp</pre><p>Using an associative array element&#39;s value as an input in a calculation seems to be safe as long as you use the full <tt>${hash[$key]}</tt> expansion syntax, rather than the shortened <tt>hash[$key]</tt> form. <span id="line-1723"></span><span id="line-1724"></span></p><pre><span id="line-1-156"></span>$ x=$(( hash[$key] + 4 ))
<span id="line-2-106"></span>bash: hash[&#39;]] + 4 : bad array subscript (error token is &#34;hash[&#39;]] + 4 &#34;)
<span id="line-3-78"></span>$ x=$(( &#39;hash[$key]&#39; + 4 ))
<span id="line-4-47"></span>bash: &#39;hash[&#39;]]&#39; + 4 : syntax error: operand expected (error token is &#34;&#39;hash[&#39;]]&#39; + 4 &#34;)
<span id="line-5-34"></span>$ x=$(( ${hash[$key]} + 4 ))
<span id="line-6-20"></span>$ </pre><p>Although of course this is subject to the same caveats as using any other parameter expansion (e.g. <tt>$i</tt>) in a math context.  See <a href="http://mywiki.wooledge.org/BashPitfalls#pf45">Pitfall 45</a> for details. <span id="line-1734"></span><span id="line-1735"></span></p><h2 id="while_..._done_.3C.3C.3C_.22.24.28foo.29.22">63. while ... done &lt;&lt;&lt; &#34;$(foo)&#34;</h2>
<p>Let&#39;s start with the correct answer first, and then explain why the wrong answer is wrong.  Here&#39;s what you should be doing instead: <span id="line-1739"></span><span id="line-1740"></span></p><pre><span id="line-1-157"></span>while ... done &lt; &lt;(foo)</pre><p>Or, if you don&#39;t actually need the <tt>while</tt> loop to run in the current shell process, you can use an ordinary pipeline: <span id="line-1745"></span><span id="line-1746"></span></p><pre><span id="line-1-158"></span>foo | while ... done</pre><p>When using the <tt>&lt; &lt;(foo)</tt> (<a href="http://mywiki.wooledge.org/ProcessSubstitution">ProcessSubstitution</a>) version, what happens is pretty simple.  Depending on your operating system, either a named pipe is created, or a <tt>/dev/fd/*</tt> entry is used to similar effect.  The <tt>while</tt> loop&#39;s standard input is redirected from that source.  Then, a background subshell is launched, in which the writer command <tt>foo</tt> is executed.  The output of <tt>foo</tt> goes into the pipe (or pipe-analogue), and the <tt>while</tt> loop reads from it.  It&#39;s all very simple.  There&#39;s nothing to worry about. <span id="line-1751"></span><span id="line-1752"></span></p><p>With the <tt>&lt;&lt;&lt; &#34;$(foo)&#34;</tt> variant, there are a few additional steps involved, and some of them are undesirable.  For starters, the entire output of <tt>foo</tt> has to be collected first.  There is no simultaneous execution, as there is with the pipeline or the process substitution.  Second, due to the way <tt>$(...)</tt> works, there are <em>three</em> modifications to the input stream.  All NUL bytes are discarded, either silently, or with a warning, depending on the version of bash.  All trailing newlines are removed.  Finally, a newline character is added to the end of the input.  All of the modified input is written into a temporary file, and then the temporary file is opened for reading by the <tt>while</tt> loop. <span id="line-1753"></span><span id="line-1754"></span></p><hr/><p> <span id="line-1755"></span><a href="http://mywiki.wooledge.org/CategoryShell">CategoryShell</a> <a href="http://mywiki.wooledge.org/CategoryBashguide">CategoryBashguide</a> <span id="line-1756"></span><span id="bottom"></span></p></div></div>
  </body>
</html>
