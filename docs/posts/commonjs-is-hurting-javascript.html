<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://deno.com/blog/commonjs-is-hurting-javascript">Original</a>
    <h1>CommonJS Is Hurting JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div><p>JavaScript, the undisputed king of web development, is being sabotaged — not by
a rival language or a revolutionary new technology, but by its own baggage from
the past. This insidious saboteur is none other than
<a href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener noreferrer">CommonJS</a>, the antique module system
that we’ve tolerated for far too long.</p>
<h2 id="the-rise-of-commonjs"><a aria-hidden="true" tabindex="-1" href="#the-rise-of-commonjs"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The rise of CommonJS</h2><p>About 15 years after its invention, JavaScript started expanding beyond the
browser to the server. Bigger projects were being built with the language and
JavaScript needed a better way to handle a lot of source code. It needed
modularization.</p>
<p>In 2009, Mozilla developer Kevin Dangoor made a call to arms. In
<a href="https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/" rel="noopener noreferrer">“What Server Side JavaScript needs”</a>,
he laid out a lot of what the nascent field of server side JS was missing,
including a module system.</p>
<blockquote>
<p>JavaScript needs a standard way to include other modules and for those modules
to live in discreet namespaces. There are easy ways to do namespaces, but
there’s no standard programmatic way to load a module (once!). This is really
important, because server side apps can include a lot of code and will likely
mix and match parts that meet those standard interfaces.</p>
<p>— Kevin Dangoor,
<a href="https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/" rel="noopener noreferrer">What Server Side JavaScript needs (2009)</a></p>
</blockquote>
<p>Within a week, 224 people had joined the then-called
<a href="https://groups.google.com/g/commonjs" rel="noopener noreferrer">ServerJS google group</a>, including npm
founder Issac Schlueter, and Node.js creator Ryan Dahl (here’s where he
introduces
<a href="https://groups.google.com/g/commonjs/c/tFO0rDFYAmg/m/0kDHteaMRB8J" rel="noopener noreferrer">Node</a> to the
group). This mailing list would go on to spec out the first versions of
CommonJS, the module system that became part of Node.</p>
<p>The proposed CommonJS syntax (<code>require()</code>, <code>module.exports</code>, etc.) do not look
like client-side JavaScript. This was by design. Dangoor’s intention to distance
CommonJS from browser JavaScript was made clear from his message in the
<a href="https://groups.google.com/g/commonjs/c/2srwZSa4X7U/m/6i87PTIY7igJ?pli=1" rel="noopener noreferrer">CommonJS Google Group in 2009</a>:</p>
<blockquote>
<p>I really think that the needs of server side code are different enough than
the needs of client side code that we’re better off drawing from Python and
Ruby than from Dojo and jQuery.</p>
</blockquote>
<p>Beyond Node.js several other early server-side JavaScript runtimes adopted
CommonJS, like Flusspferd, GPSEE, Narwhal, Persevere, RingoJS, Sproutcore, and
v8cgi (most built by the core CommonJS group).</p>
<p>But as Node.js became the de-facto server-side JavaScript runtime with CommonJS
as its main module system, the wider CommonJS standardization efforts lost
steam. There were fewer needs for standards when there was only one main
runtime: Node.js implementation <em>became</em> the standard.</p>
<blockquote>
<p>In retrospect, it seems to me like the goal of CommonJS was (or at least,
should have been) to discover Node, and enable what we’ve built here. Some
mistakes were made, because hindsight doesn’t go in the direction you’d like
it to, but overall, I think the whole CommonJS project can be considered a
success.</p>
<p>— Issac Schlueter, comment on
<a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15503151" rel="noopener noreferrer">Breaking the CommonJS standardization impasse</a>
(2013)</p>
</blockquote>
<p>Despite being the default module system, CommonJS have some core problems:</p>
<ul>
<li><strong>module loading is synchronous</strong>. Each module is loaded and executed one by
one, in the order that they are required.</li>
<li><strong>difficult to tree-shake</strong>, which can remove unused modules and minimize
bundle size.</li>
<li><strong>not browser native</strong>. You need bundlers and transpilers to make all of this
code work client-side. With CommonJS, you are stuck with either
<a href="https://deno.com/blog/you-dont-need-a-build-step" rel="noopener noreferrer">big build steps</a> or writing separate code
for client and server.</li>
</ul>
<p>By 2013, the CommonJS group was starting to wind down. But by that year, The
TC39 committee that oversaw updates to the core JavaScript language were already
working on a successor to CommonJS modules: ECMAScript modules.</p>
<h2 id="ecmascript-modules-are-web-first"><a aria-hidden="true" tabindex="-1" href="#ecmascript-modules-are-web-first"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ECMAScript Modules are web-first</h2><p>With <a href="https://262.ecma-international.org/6.0/" rel="noopener noreferrer">the ES6 language spec</a>, the TC39
committee finally introduced a module system built right into the JavaScript
language. The goal is to build a single module loader system that is suitable
for the web, which includes asynchronous module loading, compatibility with
browsers, static analysis, and tree shaking.</p>
<p><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener noreferrer">ES modules assume they’ll fetch data over a
network rather than in a filesystem</a>,
delivering better performance and user experiences.</p>
<p>Now that a module loading system is built right into the language, everyone will
agree to use that so we can focus our energy on higher level, more important
problems, right?</p>
<p><img src="https://deno.com/blog/commonjs-is-hurting-javascript/anakin-meme.jpeg" alt="Anakin Padme 4 panel meme about ESM vs. CommonJS" title=""/></p>
<p>…right?</p>
<h2 id="node-decides-to-support-both-cjs-and-esm"><a aria-hidden="true" tabindex="-1" href="#node-decides-to-support-both-cjs-and-esm"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Node decides to support both CJS and ESM</h2><blockquote>
<p>ES Modules and Common JS go together like old bay seasoning and vanilla ice
cream</p>
<p>— Myles Borins, from a talk on
<a href="https://www.youtube.com/watch?v=W5CXzo4TZVU" rel="noopener noreferrer">Modules Modules Modules</a></p>
</blockquote>
<p>(I’m from Maryland so this sounds great to me.)</p>
<p>Borins was one of the developers on the Node ‘modules team’ tasked with
implementing ES modules in Node. Despite successfully adding ESM to Node, the
team couldn’t come to a clear consensus on interoperability between ESM and CJS.
Yet Node couldn’t rip out CJS since its so deeply embedded. This meant that the
interoperability problem was pushed to package authors.</p>
<p>Here’s a snippet of a module’s <code>package.json</code> needed to support both ESM and
CJS:</p>
<p><a href="https://twitter.com/wesbos/status/1610385221324619780" rel="noopener noreferrer"><img src="https://deno.com/blog/commonjs-is-hurting-javascript/package-json-exports.jpeg" alt="Publishing a module to support esm and cjs" title=""/></a>
<em><a href="https://twitter.com/wesbos/status/1610385221324619780" rel="noopener noreferrer">“publishing packages that work in esm and cjs is such a nightmare” — Wes Bos</a></em></p>
<p><a href="https://frontside.com/blog/2023-04-27-deno-is-the-easiest-way-to-author-npm-packages/" rel="noopener noreferrer">Other module authors have found success supporting CommonJS and ESM</a>
using <a href="https://github.com/denoland/dnt" rel="noopener noreferrer">dnt</a>. Simply write your module in
TypeScript and this build tool will transform it to Node.js, emit
ESM/CommonJS/TypeScript declaration files, and a <code>package.json</code>.</p>
<p>It’s clear that supporting CommonJS in 2023 has become too big of a problem to
ignore. It’s time we bury CommonJS and transition into an all ESM future.</p>
<h2 id="so-long-and-thanks-for-all-the-requires"><a aria-hidden="true" tabindex="-1" href="#so-long-and-thanks-for-all-the-requires"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>So long and thanks for all the <code>require</code>s</h2><blockquote>
<p>We envision a future where after installing a module, developers will be able
to run the code in Node.js or the Browser without requiring a build step.</p>
<p>— Myles Borins,
<a href="https://medium.com/the-node-js-collection/the-current-state-of-implementation-and-planning-for-esmodules-a4ecb2aac07a" rel="noopener noreferrer">The Current State of Implementation and Planning for ESModules</a>
(2017)</p>
</blockquote>
<p>In 2009, CommonJS was exactly what JavaScript needed. The group took a tough
problem and forced through a solution that continues to be used millions of
times a day.</p>
<p>But with ESM as the standard and the focus shifting towards cloud primitives —
the edge, browsers, and serverless compute — and CommonJS simply doesn’t cut it.
ESM is a better solution for developers, as they can write browser-compliant
code — and for users who get a better end experience.</p>
<p><em>Don’t miss any updates —
<a href="https://twitter.com/deno_land" rel="noopener noreferrer">follow us on Twitter</a>.</em></p>
</div></div>
  </body>
</html>
