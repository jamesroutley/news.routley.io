<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jackevans.bearblog.dev/refactoring-python-with-tree-sitter-jedi/">Original</a>
    <h1>Refactoring Python with Tree-sitter and Jedi</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
<i>
<time datetime="2024-09-24T14:56Z">
24 Sep, 2024
</time>
</i>
</p>
<p>I was toying around with a refactor the other day that would have taken me ages by hand as it involved 100s of files.</p>
<p>I wanted to rename every instance of a <code>pytest</code> fixture from <code>database</code> -&gt; <code>db</code> across my entire repo (silly I know). Unfortunately this isn&#39;t something my editor of choice can magically refactor.</p>
<hr/>
<p>Here&#39;s how my test files looked before:</p>
<div><pre><span></span><span>@pytest</span><span>.</span><span>fixture</span><span>()</span>
<span>def</span> <span>test_a</span><span>(</span><span>database</span><span>):</span> <span>...</span>

<span>def</span> <span>test_b</span><span>(</span><span>database</span><span>):</span> <span>...</span>

<span>def</span> <span>test_c</span><span>(</span><span>database</span><span>,</span> <span>x</span><span>):</span> <span>...</span>

<span>def</span> <span>test_d</span><span>(</span><span>x</span><span>,</span> <span>database</span><span>):</span> <span>...</span>

<span>def</span> <span>test_e</span><span>(</span><span>x</span><span>,</span> <span>database</span><span>,</span> <span>y</span><span>):</span> <span>...</span>
</pre></div>
<p>After the refactor, this is how they look:</p>
<div><pre><span></span><span>@pytest</span><span>.</span><span>fixture</span><span>()</span>
<span>def</span> <span>test_a</span><span>(</span><span>db</span><span>):</span> <span>...</span>

<span>def</span> <span>test_b</span><span>(</span><span>db</span><span>):</span> <span>...</span>

<span>def</span> <span>test_c</span><span>(</span><span>db</span><span>,</span> <span>x</span><span>):</span> <span>...</span>

<span>def</span> <span>test_d</span><span>(</span><span>x</span><span>,</span> <span>db</span><span>):</span> <span>...</span>

<span>def</span> <span>test_e</span><span>(</span><span>x</span><span>,</span> <span>db</span><span>,</span> <span>y</span><span>):</span> <span>...</span>
</pre></div>
<p>After struggling to achieve what I wanted with the tools I&#39;d typically reach for (<code>grep</code> + <code>sed</code>) I decided to try something a bit fancier.</p>
<h2 id="parsing-nodes-with-tree-sitter">Parsing nodes with Tree-Sitter</h2><p>The first thing to do is to find all row/column of each <code>database</code> identifier:</p>
<div><pre><span></span><span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>

<span>import</span> <span>tree_sitter_python</span> <span>as</span> <span>tspython</span>
<span>from</span> <span>tree_sitter</span> <span>import</span> <span>Language</span><span>,</span> <span>Parser</span>

<span>PY_LANGUAGE</span> <span>=</span> <span>Language</span><span>(</span><span>tspython</span><span>.</span><span>language</span><span>())</span>

<span>parser</span> <span>=</span> <span>Parser</span><span>(</span><span>PY_LANGUAGE</span><span>)</span>


<span>def</span> <span>parse_func</span><span>(</span><span>node</span><span>):</span>
    <span>for</span> <span>child</span> <span>in</span> <span>node</span><span>.</span><span>children</span><span>:</span>
        <span>if</span> <span>child</span><span>.</span><span>type</span> <span>==</span> <span>&#34;parameters&#34;</span><span>:</span>
            <span>for</span> <span>sub_child</span> <span>in</span> <span>child</span><span>.</span><span>children</span><span>:</span>
                <span>if</span> <span>sub_child</span><span>.</span><span>type</span> <span>==</span> <span>&#34;identifier&#34;</span> <span>and</span> <span>sub_child</span><span>.</span><span>text</span> <span>==</span> <span>b</span><span>&#34;database&#34;</span><span>:</span>
                    <span>yield</span> <span>sub_child</span><span>.</span><span>start_point</span>


<span>def</span> <span>parse_file</span><span>(</span><span>path</span><span>):</span>
    <span>tree</span> <span>=</span> <span>parser</span><span>.</span><span>parse</span><span>(</span><span>path</span><span>.</span><span>read_bytes</span><span>())</span>
    <span>for</span> <span>child</span> <span>in</span> <span>tree</span><span>.</span><span>root_node</span><span>.</span><span>children</span><span>:</span>
        <span>if</span> <span>child</span><span>.</span><span>type</span> <span>==</span> <span>&#34;function_definition&#34;</span><span>:</span>
            <span>yield from</span> <span>parse_func</span><span>(</span><span>child</span><span>)</span>


<span>def</span> <span>process_file</span><span>(</span><span>path</span><span>):</span>
    <span>for</span> <span>match</span> <span>in</span> <span>parse_file</span><span>(</span><span>path</span><span>):</span>
        <span>print</span><span>(</span><span>match</span><span>)</span>
</pre></div>
<p>This prints the location of all the instances of <code>def test_</code> functions.</p>
<div><pre><span></span>Point(row=7, column=11)
Point(row=10, column=11)
Point(row=13, column=14)
Point(row=16, column=14)
</pre></div>
<h2 id="handling-decorated-functions">Handling decorated functions</h2><p>The above code doesn&#39;t include support decorated functions, for example:</p>
<div><pre><span></span><span>@pytest</span><span>.</span><span>fixture</span><span>()</span>
<span>def</span> <span>test_a</span><span>(</span><span>database</span><span>):</span> <span>...</span>
</pre></div>
<p>Decorators requires a bit more effort to handle correctly:</p>
<div><pre><span></span><span>def</span> <span>parse_file</span><span>(</span><span>path</span><span>):</span>
    <span>tree</span> <span>=</span> <span>parser</span><span>.</span><span>parse</span><span>(</span><span>path</span><span>.</span><span>read_bytes</span><span>())</span>
    <span>for</span> <span>child</span> <span>in</span> <span>tree</span><span>.</span><span>root_node</span><span>.</span><span>children</span><span>:</span>
        <span>if</span> <span>child</span><span>.</span><span>type</span> <span>==</span> <span>&#34;function_definition&#34;</span><span>:</span>
            <span>yield from</span> <span>parse_func</span><span>(</span><span>child</span><span>)</span>
        <span>elif</span> <span>child</span><span>.</span><span>type</span> <span>==</span> <span>&#34;decorated_definition&#34;</span><span>:</span>
            <span>for</span> <span>sub_child</span> <span>in</span> <span>child</span><span>.</span><span>children</span><span>:</span>
                <span>if</span> <span>sub_child</span><span>.</span><span>type</span> <span>==</span> <span>&#34;function_definition&#34;</span><span>:</span>
                    <span>yield from</span> <span>parse_func</span><span>(</span><span>sub_child</span><span>)</span>
</pre></div>
<h2 id="renaming-with-jedi">Renaming with Jedi</h2><p>Now for each row/col I can use Jedi to rename the identifier:</p>
<div><pre><span></span><span>def</span> <span>process_file</span><span>(</span><span>path</span><span>):</span>
    <span>for</span> <span>match</span> <span>in</span> <span>parse_file</span><span>(</span><span>path</span><span>):</span>
        <span>script</span> <span>=</span> <span>Script</span><span>(</span><span>code</span><span>=</span><span>path</span><span>.</span><span>read_text</span><span>(),</span> <span>path</span><span>=</span><span>str</span><span>(</span><span>path</span><span>))</span>
        <span>result</span> <span>=</span> <span>script</span><span>.</span><span>rename</span><span>(</span><span>line</span><span>=</span><span>match</span><span>.</span><span>row</span> <span>+</span> <span>1</span><span>,</span> <span>column</span><span>=</span><span>match</span><span>.</span><span>column</span><span>,</span> <span>new_name</span><span>=</span><span>&#34;db&#34;</span><span>)</span>
        <span>result</span><span>.</span><span>apply</span><span>()</span>
</pre></div>
<h2 id="conclusion">Conclusion</h2><p>Ironically I ended up not merging this change, but was a fun learning exercise. I found both <code>jedi</code> and <code>tree-sitter</code> relatively easy to learn, I&#39;ll certainly be keeping them in my toolbelt for situations where <code>grep</code> + <code>sed</code> don&#39;t quite cut it.</p>
<p>I do wish <code>tree-sitter</code> had a mechanism to directly manipulate the AST. I was unable to simply rename/delete nodes and then write the AST back to disk. Instead I had to use <code>Jedi</code> or manually edit the source (and then deal with nasty off-set re-parsing logic).</p>
<p><strong>Note</strong> The astute amongst you will notice that this script does a lot of re-parsing. I could probably optimise this further, but for a quick project wide refactor I found this to be plenty fast enough.</p>
<p>Here&#39;s a video of it in action:</p>
<iframe title="vimeo-player" src="https://player.vimeo.com/video/1012433612?h=d26e967634" width="640" height="360" frameborder="0" allowfullscreen=""></iframe>
<p>
<a href="https://jackevans.bearblog.dev/blog/?q=python">#python</a>
</p>


</div></div>
  </body>
</html>
