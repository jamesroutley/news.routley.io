<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://luisdva.github.io/rstats/problematic-spreadsheets/">Original</a>
    <h1>Formatted spreadsheets can still work in R</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <section itemprop="text">
        
        <p>This recent <a href="https://jeremy-selva.netlify.app/blog/2024-02-15-tackling-formatted-cell-data/" target="_blank">post</a> by <a href="https://github.com/JauntyJJS" target="_blank">Jeremy Selva</a> shows a nice workflow for working with problematic formatted spreadsheets in R.</p>

<p>I’ve worked on this topic before, so I when I saw the post I had to meddle. I suggested using functions from the <code>unheadr</code> package to address some of these issues. They didn’t work because of assumptions I hard-coded into the package, but these are fixed now. These fixes are part of unheadr v0.4.0. To demonstrate the functions and also to celebrate 20k downloads (🥳), here is my take (with the benefit of hindsight) on tackling this troublesome spreadsheet. <em>ALL CREDIT TO JEREMY FOR COMING UP WITH THE EXAMPLE AND WORKFLOW</em>.</p>

<p>The spreadsheet/workbook in question can be downloaded from Jeremy’s GitHub <a href="https://raw.githubusercontent.com/JauntyJJS/jaunty-blogdown/main/content/blog/2024-02-15-Tackling-Formatted-Cell-Data/sample_excel.xlsx">here</a>.</p>

<p>For context, I’m reproducing the images from the original post about the issues with the data, which are good examples of:</p>
<h2 id="-things-we-shouldnt-do-but-which-happen-anyway-in-spreadsheets">😢 Things we shouldn’t do but which happen anyway in spreadsheets:</h2>

<h3 id="1-a-date-variable-with-different-cell-formats-plus-whatever-strange-thing-excel-does-to-dates">1. A date variable with different cell formats, plus whatever strange thing Excel does to dates.</h3>

<figure>
    <a href="https://luisdva.github.io/assets/images/date_forms.png"><img src="https://luisdva.github.io/assets/images/date_forms.png"/></a>
        <figcaption>oh</figcaption>
</figure>

<h3 id="2-meaningful-formatting">2. Meaningful formatting</h3>

<p>Using text color (and nothing else) to indicate units.</p>

<figure>
    <a href="https://luisdva.github.io/assets/images/colour_weights.png"><img src="https://luisdva.github.io/assets/images/colour_weights.png"/></a>
        <figcaption>lovely</figcaption>
</figure>

<h3 id="3-numeric-variables-with-some-cells-formatted-as-text">3. Numeric variables with some cells formatted as text.</h3>

<figure>
    <a href="https://luisdva.github.io/assets/images/green_triangles.png"><img src="https://luisdva.github.io/assets/images/green_triangles.png"/></a>
        <figcaption></figcaption>
</figure>

<p>These issues vary in how hard they are to address in downstream analyses, but as they accumulate we are more tempted to give up and work with the file directly in Excel (or Calc).</p>

<hr/>

<p>Here’s my take, which can be a complement to the stricter approach in Jeremy’s post.</p>

<p>First, read the spreasheet with <code>readxl</code>. Out of caution, we can read everything as text initially.</p>

<figure><pre><code data-lang="r"><span># load some useful packages</span><span>
</span><span>library</span><span>(</span><span>readxl</span><span>)</span><span>    </span><span># CRAN v1.4.3 </span><span>
</span><span>library</span><span>(</span><span>lubridate</span><span>)</span><span> </span><span># CRAN v1.9.3 </span><span>
</span><span>library</span><span>(</span><span>janitor</span><span>)</span><span>   </span><span># CRAN v2.2.0 </span><span>
</span><span>library</span><span>(</span><span>readr</span><span>)</span><span>     </span><span># CRAN v2.1.5 </span><span>
</span><span>library</span><span>(</span><span>dplyr</span><span>)</span><span>     </span><span># CRAN v1.1.4</span><span>
</span><span>library</span><span>(</span><span>tidyxl</span><span>)</span><span>    </span><span># CRAN v1.0.10 </span><span>
</span><span>library</span><span>(</span><span>stringr</span><span>)</span><span>   </span><span># CRAN v1.5.1</span><span>
</span><span>library</span><span>(</span><span>tidyr</span><span>)</span><span>     </span><span># CRAN v1.3.1 </span><span>
</span><span>library</span><span>(</span><span>unheadr</span><span>)</span><span>   </span><span># CRAN v0.4.0 </span><span>

</span><span>samp</span><span> </span><span>&lt;-</span><span> </span><span>read_excel</span><span>(</span><span>&#34;sample_excel.xlsx&#34;</span><span>,</span><span> </span><span>col_types</span><span> </span><span>=</span><span> </span><span>&#34;text&#34;</span><span>)</span></code></pre></figure>

<p>Next, <code>type_convert()</code> from <code>readr</code> does a good job of parsing variables in a data frame, and has good heuristics to interpret numeric variables even when these had problematic combinations of cell formatting in the spreadsheet.</p>

<figure><pre><code data-lang="r"><span>samp</span><span> </span><span>&lt;-</span><span> </span><span>readr</span><span>::</span><span>type_convert</span><span>(</span><span>samp</span><span>)</span></code></pre></figure>

<figure><pre><code data-lang="text">── Column specification ────────────────────────────────────────────────────────────
cols(
  id = col_character(),
  date_issue = col_character(),
  `colour_weight 
Black in pounds
Green in kilograms` = col_double(),
  text_integer_issue = col_double(),
  text_numeric_issue = col_double(),
  numeric_integer_issue = col_double(),
  one_or_zero_issue = col_double()
)</code></pre></figure>

<p>To fix the awkward date, <code>lubridate</code> can handle the dates that were imported more or less properly, and the <code>excel_numeric_to_date()</code> function from <code>janitor</code> was purpose-built to transform the dates stored as weird numbers. Afterwards we put the two together.</p>

<figure><pre><code data-lang="r"><span>samp</span><span>$</span><span>newdate</span><span> </span><span>&lt;-</span><span> </span><span>lubridate</span><span>::</span><span>parse_date_time</span><span>(</span><span>samp</span><span>$</span><span>date_issue</span><span>,</span><span>
  </span><span>orders</span><span> </span><span>=</span><span> </span><span>c</span><span>(</span><span>&#34;ymd&#34;</span><span>,</span><span> </span><span>&#34;dmy&#34;</span><span>)</span><span>
</span><span>)</span><span>
</span><span>samp</span><span>$</span><span>xldate</span><span> </span><span>&lt;-</span><span> </span><span>excel_numeric_to_date</span><span>(</span><span>as.numeric</span><span>(</span><span>as.character</span><span>(</span><span>samp</span><span>$</span><span>date_issue</span><span>)),</span><span>
  </span><span>date_system</span><span> </span><span>=</span><span> </span><span>&#34;modern&#34;</span><span>
</span><span>)</span><span>
</span><span>samp</span><span> </span><span>&lt;-</span><span> </span><span>samp</span><span> </span><span>%&gt;%</span><span>
  </span><span>mutate</span><span>(</span><span>date_fixed</span><span> </span><span>=</span><span> </span><span>coalesce</span><span>(</span><span>newdate</span><span>,</span><span> </span><span>xldate</span><span>))</span><span> </span><span>%&gt;%</span><span>
  </span><span>select</span><span>(</span><span>-</span><span>newdate</span><span>,</span><span> </span><span>-</span><span>xldate</span><span>,</span><span> </span><span>-</span><span>date_issue</span><span>)</span></code></pre></figure>

<figure><pre><code data-lang="text">&gt; samp %&gt;% select(date_fixed)
# A tibble: 1,053 × 1
   date_fixed         
   &lt;dttm&gt;             
 1 2017-11-11 00:00:00
 2 2017-10-18 00:00:00
 3 2017-10-09 00:00:00
 4 NA                 
 5 1971-01-08 00:00:00
 6 1985-11-29 00:00:00
 7 1955-02-12 00:00:00
 8 1982-05-01 00:00:00
 9 1969-04-20 00:00:00
10 1962-11-21 00:00:00
# ℹ 1,043 more rows
# ℹ Use `print(n = ...)` to see more rows</code></pre></figure>

<p>Lastly, there’s the issue of units of measurment for a variable encoded as text formatting. In this case the text color indicates the units. This information is lost when reading only the cell values with <code>readxl</code>, but we can embed the color code from each cell as a text annotation using the <code>annotate_mf</code> functions from  <code>unheadr</code>.</p>

<figure><pre><code data-lang="text">&gt; annotate_mf_all(&#34;sample_excel.xlsx&#34;)
Error in annotate_mf_all(&#34;sample_excel.xlsx&#34;) :                                   
  Check spreadsheet for blank cells in seemingly empty rows</code></pre></figure>

<p>If we run <code>annotate_mf_all()</code> with the path to the spreadsheet, we’ll get an error message. Apparently there are formatted cells outside of the data rectangle, which is what <code>readxl</code> focuses on during the data import.</p>

<p>We can use tidyxl to unravel the problem, looking at the tail end of the output, we see some blank-formatted cells in rows 1054 and 1055, even though our samp data frame only has 1053 rows. These formatted cells create “ghost” rows that trip up the functions from <code>unheadr</code>.</p>

<figure><pre><code data-lang="text">&gt; nrow(samp)
[1] 1053</code></pre></figure>

<figure><pre><code data-lang="r"><span>spsheetcells</span><span> </span><span>&lt;-</span><span> </span><span>tidyxl</span><span>::</span><span>xlsx_cells</span><span>(</span><span>&#34;sample_excel.xlsx&#34;</span><span>)</span><span>
</span><span>spsheetcells</span><span> </span><span>%&gt;%</span><span>
  </span><span>select</span><span>(</span><span>row</span><span>,</span><span> </span><span>is_blank</span><span>,</span><span> </span><span>data_type</span><span>)</span><span> </span><span>%&gt;%</span><span>
  </span><span>tail</span><span>(</span><span>10</span><span>)</span></code></pre></figure>

<figure><pre><code data-lang="text"># A tibble: 10 × 3
     row is_blank data_type
   &lt;int&gt; &lt;lgl&gt;    &lt;chr&gt;    
 1  1053 FALSE    numeric  
 2  1054 FALSE    character
 3  1054 FALSE    character
 4  1054 FALSE    numeric  
 5  1054 FALSE    numeric  
 6  1054 FALSE    numeric  
 7  1054 FALSE    numeric  
 8  1054 FALSE    numeric  
 9  1055 TRUE     blank    
10  1056 TRUE     blank  </code></pre></figure>

<p>After opening the file directly in a spreadsheet program and deleting the problem rows altogether (I saved this as a new file called sample_excel_cln.xlsx), the <code>annotate_mf_all()</code> function is able to translate the colorful text into a text annotation of the hex8 code for each color.</p>

<figure><pre><code data-lang="r"><span>samp_format</span><span> </span><span>&lt;-</span><span> </span><span>annotate_mf_all</span><span>(</span><span>&#34;sample_excel_cln.xlsx&#34;</span><span>)</span></code></pre></figure>

<p>Let’s have a look</p>

<figure><pre><code data-lang="r"><span>samp_format</span><span>[,</span><span> </span><span>3</span><span>]</span></code></pre></figure>

<figure><pre><code data-lang="text">&gt; samp_format[, 3]
# A tibble: 1,053 × 1
   `colour_weight \nBlack in pounds\nGreen in kilograms`
   &lt;chr&gt;                                                
 1 (color-FF00B050) 92                                  
 2 (color-FF000000) 194                                 
 3 (color-FF00B050) 61                                  
 4 (color-FF000000) 165                                 
 5 (color-FF000000) 148                                 
 6 (color-FF00B050) 86                                  
 7 (color-FF00B050) 84                                  
 8 (color-FF000000) 182                                 
 9 (color-FF00B050) 80                                  
10 (color-FF00B050) 78                                  
# ℹ 1,043 more rows
# ℹ Use `print(n = ...)` to see more rows</code></pre></figure>

<p>If we drop the FF from the color codes (it’s shorthand for 100% opacity), recent versions of R Studio will preview a color right in the editor, so now we know which values are green and which are black.</p>

<p>“FF00B050” is <span>green</span> and “FF000000” is <span>black</span></p>

<p>Let’s separate color code and weight value into their own columns:</p>

<figure><pre><code data-lang="r"><span>samp_format</span><span> </span><span>&lt;-</span><span> </span><span>samp_format</span><span> </span><span>%&gt;%</span><span>
  </span><span>separate</span><span>(</span><span>`colour_weight
Black in pounds
Green in kilograms`</span><span>,</span><span> </span><span>into</span><span> </span><span>=</span><span> </span><span>c</span><span>(</span><span>&#34;hex8code&#34;</span><span>,</span><span> </span><span>&#34;weight&#34;</span><span>),</span><span> </span><span>sep</span><span> </span><span>=</span><span> </span><span>&#34; &#34;</span><span>)</span><span> </span><span>%&gt;%</span><span>
  </span><span>mutate</span><span>(</span><span>weight</span><span> </span><span>=</span><span> </span><span>parse_number</span><span>(</span><span>weight</span><span>))</span></code></pre></figure>

<figure><pre><code data-lang="text">&gt; samp_format %&gt;% select(id, hex8code, weight)
# A tibble: 1,053 × 3
   id                      hex8code         weight
   &lt;chr&gt;                   &lt;chr&gt;             &lt;dbl&gt;
 1 (color-FF000000) ID0001 (color-FF00B050)     92
 2 (color-FF000000) ID0002 (color-FF000000)    194
 3 (color-FF000000) ID0003 (color-FF00B050)     61
 4 (color-FF000000) ID0004 (color-FF000000)    165
 5 (color-FF000000) ID0005 (color-FF000000)    148
 6 (color-FF000000) ID0006 (color-FF00B050)     86
 7 (color-FF000000) ID0007 (color-FF00B050)     84
 8 (color-FF000000) ID0008 (color-FF000000)    182
 9 (color-FF000000) ID0009 (color-FF00B050)     80
10 (color-FF000000) ID0010 (color-FF00B050)     78
# ℹ 1,043 more rows
# ℹ Use `print(n = ...)` to see more rows</code></pre></figure>

<p>Now we can conditionally convert pounds to kilograms, then remove the color annotation from the <code>id</code> variable, which we’ll use to merge this object with the dataframe we were working on initially.</p>

<figure><pre><code data-lang="r"><span>samp_format</span><span> </span><span>&lt;-</span><span>
  </span><span>samp_format</span><span> </span><span>%&gt;%</span><span>
  </span><span>mutate</span><span>(</span><span>weight</span><span> </span><span>=</span><span> </span><span>round</span><span>(</span><span>if_else</span><span>(</span><span>str_detect</span><span>(</span><span>hex8code</span><span>,</span><span> </span><span>&#34;00B050&#34;</span><span>),</span><span>
    </span><span>weight</span><span>,</span><span> </span><span>weight</span><span> </span><span>*</span><span> </span><span>0.453</span><span>
  </span><span>),</span><span> </span><span>0</span><span>))</span><span> </span><span>%&gt;%</span><span>
  </span><span>mutate</span><span>(</span><span>id</span><span> </span><span>=</span><span> </span><span>str_remove_all</span><span>(</span><span>id</span><span>,</span><span> </span><span>&#34;^[^\\s]+ &#34;</span><span>))</span><span> </span><span>%&gt;%</span><span> </span><span># regex!</span><span>
  </span><span>select</span><span>(</span><span>id</span><span>,</span><span> </span><span>weight</span><span>)</span></code></pre></figure>

<figure><pre><code data-lang="text">&gt; samp_format
# A tibble: 1,053 × 2
   id     weight
   &lt;chr&gt;   &lt;dbl&gt;
 1 ID0001     92
 2 ID0002     88
 3 ID0003     61
 4 ID0004     75
 5 ID0005     67
 6 ID0006     86
 7 ID0007     84
 8 ID0008     82
 9 ID0009     80
10 ID0010     78
# ℹ 1,043 more rows
# ℹ Use `print(n = ...)` to see more rows</code></pre></figure>

<p>After joining the two objects, some minor cleanup of the names leaves us with nice and usable data.</p>

<figure><pre><code data-lang="r"><span>sampjnd</span><span> </span><span>&lt;-</span><span> </span><span>left_join</span><span>(</span><span>samp</span><span>,</span><span> </span><span>samp_format</span><span>)</span><span> </span><span>%&gt;%</span><span> </span><span>clean_names</span><span>()</span><span>
</span><span>sampjnd</span><span> </span><span>&lt;-</span><span>
  </span><span>sampjnd</span><span> </span><span>%&gt;%</span><span> </span><span>select</span><span>(</span><span>id</span><span>,</span><span>
    </span><span>date</span><span> </span><span>=</span><span> </span><span>date_fixed</span><span>,</span><span> </span><span>weight_kg</span><span> </span><span>=</span><span> </span><span>weight</span><span>,</span><span> </span><span>text_integer_issue</span><span>,</span><span> </span><span>text_numeric_issue</span><span>,</span><span> </span><span>numeric_integer_issue</span><span>,</span><span>
    </span><span>one_or_zero_issue</span><span>
  </span><span>)</span><span>
</span><span>names</span><span>(</span><span>sampjnd</span><span>)</span><span> </span><span>&lt;-</span><span> </span><span>str_remove</span><span>(</span><span>names</span><span>(</span><span>sampjnd</span><span>),</span><span> </span><span>&#34;_issue$&#34;</span><span>)</span></code></pre></figure>

<figure><pre><code data-lang="text">&gt; sampjnd
# A tibble: 1,053 × 7
   id     date                weight_kg text_integer text_numeric numeric_integer
   &lt;chr&gt;  &lt;dttm&gt;                  &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;
 1 ID0001 2017-11-11 00:00:00        92           74         1.6                1
 2 ID0002 2017-10-18 00:00:00        88           54         0.14              55
 3 ID0003 2017-10-09 00:00:00        61           53         0.96               9
 4 ID0004 NA                         75           64         0.02               2
 5 ID0005 1971-01-08 00:00:00        67           48         0.23               3
 6 ID0006 1985-11-29 00:00:00        86           33         0.01               7
 7 ID0007 1955-02-12 00:00:00        84           35         0.26               1
 8 ID0008 1982-05-01 00:00:00        82           53         0.07               3
 9 ID0009 1969-04-20 00:00:00        80          187         0.06              75
10 ID0010 1962-11-21 00:00:00        78          141         0.01              23
# ℹ 1,043 more rows
# ℹ 1 more variable: one_or_zero &lt;dbl&gt;
# ℹ Use `print(n = ...)` to see more rows</code></pre></figure>

<p>If it’s not too late, following good practices for <a href="https://www.tandfonline.com/doi/full/10.1080/00031305.2017.1375989" target="_blank">Data organization in spreadsheets</a> will avoid a lot of pain. Otherwise, tools like the ones shown here can be useful.</p>

<p>All feedback welcome and again thanks to Jeremy Selva for the idea and GitHub issue that sparked all of this.</p>

<hr/>

<p><strong>Further reading</strong>:</p>
<ul>
  <li>Jenny Bryan’s <a href="https://github.com/jennybc/2016-06_spreadsheets">Spreadhseet Resources</a></li>
  <li><a href="https://luisdva.github.io/pls-don%27t-do-this/">Please don’t do this</a>: Three common bad practices in sharing tables and spreadsheets and how to avoid them</li>
</ul>

        
      </section>

      

      


      
  

    </div></div>
  </body>
</html>
