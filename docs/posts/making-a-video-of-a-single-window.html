<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tratt.net/laurie/blog/2022/making_a_video_of_a_single_window.html">Original</a>
    <h1>Making a Video of a Single Window</h1>
    
    <div id="readability-page-1" class="page"><div id="article-body"><p>



I recently wanted to send someone a video of a program doing some interesting
things in a single X11 window. Recording the whole desktop is easy (some readers may remember my post
on <a href="https://tratt.net/laurie/essays/entries/automatic_video_editing.html">Aeschylus</a>
which does just that) but it will include irrelevant (and possibly unwanted)
parts of the screen, leading to unnecessarily large files.
I couldn&#39;t immediately find
a tool which did what I wanted on OpenBSD  but through a combination of <a href="https://cgit.freedesktop.org/xorg/app/xwininfo">xwininfo</a>, <a href="https://ffmpeg.org/">FFmpeg</a>, and <a href="https://tratt.net/laurie/src/hk/">hk</a> I
was able to put together exactly what I needed in short order. Even better,
I was able to easily post-process the video to shrink its file size, speed it up,
and contort it to the dimension requirements of various platforms. Here&#39;s a
video straight out of the little script I put together:

</p><video controls="">
<source src="/laurie/blog/extra/2022/making_a_video_of_a_single_window/xterm1.mp4" type="video/mp4"/>
</video>
<p>In this post I&#39;m going to quickly go through what I did. I hope you get two
things from this. First, FFmpeg, hk, and xwininfo are great examples of tools
whose power can be magnified by combining them with other tools.
Second, I&#39;m not presenting an end product as much as I am presenting example
recipes which you can alter and adjust to fit your circumstances.


</p><h2>Selecting the right portion of the screen</h2>
<p>The first problem is automatically determining what portion of the screen I
want to capture. Fortunately, xwininfo does exactly what I want: when I run it,
the cursor changes to a &#34;+&#34;; and, when I click on a window, it outputs information
to stdout about that window. Here&#39;s what happens when I click on the editor
window I&#39;m typing this post into:

</p><pre>$ xwininfo
xwininfo: Please select the window about which you
          would like information by clicking the
          mouse in that window.

xwininfo: Window id: 0x2800006 &#34;making_a_video_of_a_single_window.incomplete + (~/web/tratt.net/templates/laurie/blog/2022) - NVIM — Neovim&#34;

  Absolute upper-left X:  309
  Absolute upper-left Y:  104
  Relative upper-left X:  5
  Relative upper-left Y:  29
  Width: 3000
  Height: 2400
  Depth: 24
  Visual: 0x57c
  Visual Class: TrueColor
  Border width: 0
  Class: InputOutput
  Colormap: 0x2800005 (installed)
  Bit Gravity State: NorthWestGravity
  Window Gravity State: NorthWestGravity
  Backing Store State: NotUseful
  Save Under State: no
  Map State: IsViewable
  Override Redirect State: no
  Corners:  +309+104  -531+104  -531-56  +309-56
  -geometry 1500x1200+309-56
</pre><p>

What I need to extract are:

</p><ol>
<li>the window&#39;s width and height,
</li><li>and the coordinates of the window&#39;s top-left corner (where <code>0,0</code> is the top-left of the screen).
</li></ol><p>

Let&#39;s assume I&#39;ve put xwininfo&#39;s output into <code>/tmp/t</code>. I can then
easily extract all four pieces of information we need:

</p><pre>$ grep Width /tmp/t \
    | cut -d &#34;:&#34; -f 2 \
    | tr -d &#34; &#34;
3000
$ grep Height /tmp/t \
    | cut -d &#34;:&#34; -f 2 \
    | tr -d &#34; &#34;
2400
$ grep &#34;Absolute upper-left X&#34; /tmp/t \
    | cut -d &#34;:&#34; -f 2 \
    | tr -d &#34; &#34;
309
$ grep &#34;Absolute upper-left Y&#34; /tmp/t \
    | cut -d &#34;:&#34; -f 2 \
    | tr -d &#34; &#34;
104
</pre>
<p><code>grep</code> obtains the single line we&#39;re interested in, <code>cut</code>
selects the text after the colon (&#34;:&#34;), and <code>tr</code> removes the
leading characters that <code>cut</code> leaves behind.

</p><p>Rather than continually copy those numbers around by hand, I&#39;ll put them
into variables so we can easily reference them in the rest of the post:

</p><pre>width=`grep Width /tmp/t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
height=`grep Height /tmp/t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
top_x=`grep &#34;Absolute upper-left X&#34; /tmp/t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
top_y=`grep &#34;Absolute upper-left Y&#34; /tmp/t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
</pre>
<h2>Starting and stopping FFmpeg</h2><p>

Now that we know what portion of the screen we want to capture, I can start
FFmpeg recording:

</p><pre>ffmpeg \
  -f x11grab \
  -framerate 30 \
  -video_size ${width}x${height} \
  -i +${top_x},${top_y} \
  -c:v libx264rgb \
  -preset ultrafast \
  -crf 0 \
  output.nut
</pre><p>

I always record to a lossless format, specifically the NUT format, which is
best thought of as FFmpeg&#39;s &#34;native&#34; format — since I&#39;ve been using that,
I&#39;ve had none of the problems I encountered with other formats. I do as little processing
as I can get away when recording (<code>-preset ultrafast</code> does minimal
compression, otherwise the resulting files can become unwieldy), because it&#39;s
easy to do heavy processing as a subsequent step. How many frames per
second one prefers is a personal choice, though in the above example I&#39;ve
gone for a neutral 30 .

</p><p>When I&#39;m finished recording, pressing &#34;q&#34; in the terminal running FFmpeg
causes it to stop recording. However, this is a bit annoying,
because I have to change keyboard focus from the window I&#39;m recording to the one running FFmpeg.
If those two windows overlap (bearing in mind that FFmpeg is capturing a fixed portion
of the screen), the result of FFmpeg&#39;s voluminous terminal
output suddenly heaving into view is discombobulating:

<video controls="">
<source src="/laurie/blog/extra/2022/making_a_video_of_a_single_window/xterm_overlap.mp4" type="video/mp4"/>
</video>
</p><p>What I really want to do is run FFmpeg in the background and stop it when I
press a keyboard shortcut. This is a perfect use-case for <a href="https://tratt.net/laurie/src/hk">hk</a>, which waits until a specific key combination has
pressed and then executes an arbitrary shell command:

</p><pre>ffmpeg \
  -f x11grab \
  -framerate 30 \
  -video_size ${width}x${height} \
  -i +${top_x},${top_y} \
  -c:v libx264rgb \
  -preset ultrafast \
  -crf 0 \
  output.nut &amp;
ffmpeg_pid=$!
hk Shift+F4 kill -SIGINT $ffmpeg_pid
wait $ffmpeg_pid
</pre><p>

I first run FFmpeg in the background (with &#34;&amp;&#34;). I
then tell hk to wait for <code>Shift+F4</code> to be pressed, at which
point hk will run <code>kill</code>, which sends <code>SIGINT</code> to the FFmpeg process (whose PID
is stored in the <code>$!</code> shell variable). When FFmpeg receives
the <code>SIGINT</code> signal it will stop recording and finish writing
to <code>output.nut</code>.

</p><p>Although we don&#39;t need this feature quite yet, if I want to execute commands on
<code>output.nut</code>, there is no guarantee that ffmpeg will have
finished writing to it when hk terminates — indeed, it&#39;s likely that hk
will terminate first. It&#39;s thus safest to <code>wait</code> 
until the FFmpeg process has definitely terminated.


</p><h2>Post processing</h2>
<p>At this point, I have a <code>.nut</code> file which has captured
exactly the portion of the screen we want. However, many people are scared by
<code>.nut</code> files, and because I did only minimal compression,
the <code>.nut</code> file can be alarmingly large.

</p><p>I thus want to convert the <code>.nut</code> file to a more widely recognised
<code>.mp4</code> file, and heavily compress the video while doing so:

</p><pre>ffmpeg \
  -i output.nut \
  -vf &#34;pad=ceil(iw/2)*2:ceil(ih/2)*2&#34; \
  -c:v libx264 \
  -pix_fmt yuv420p \
  -preset veryslow \
  -crf 10 \
  output.mp4
</pre><p>

I&#39;ve chosen FFmpeg&#39;s highest compression level (<code>-preset veryslow</code>).
Since I&#39;m also willing to sacrifice a little bit of visual quality in order to get better
compression, I&#39;ve specified <code>-crf</code>. Roughly speaking, <code>-crf 0</code> means &#34;lossless&#34; and every
increase of that number by 3 doubles the lossiness. <code>-crf 10</code> is below the
threshold where I can see any real differences in the video.
<code>pix_fmt</code> is a slightly irritating detail that I don&#39;t want to go
into: suffice it to say that some programs (e.g. Firefox and some versions of
VLC) won&#39;t play the resulting mp4 if I don&#39;t use this option. However, using
<code>-pix_fmt</code> in this way means we need a video with dimensions
divisible by two, hence the <code>pad</code> video filter (<code>-vf</code>).
Unfortunately, video encoding is full of these sorts of bizarre details.

</p><p>On a few tests, the command above leads to a <code>.mp4</code> file that&#39;s
at least 5x smaller, and often 10x or more smaller, than the <code>.nut</code>
input.

</p><p>If you actually try recording yourself typing, you&#39;ll probably find that,
like me, you type much slower than you expected. In my case, the
original videos I recorded would be frustratingly slow for other people,
so the videos you&#39;ve seen above have been sped up by 2x.
Compare the original recording:

<video controls="">
<source src="/laurie/blog/extra/2022/making_a_video_of_a_single_window/xterm1_orig_speed.mp4" type="video/mp4"/>
</video>

with the 2x-faster version:

<video controls="">
<source src="/laurie/blog/extra/2022/making_a_video_of_a_single_window/xterm1.mp4" type="video/mp4"/>
</video>

Speeding the video up simply requires the FFmpeg&#39;s <code>setpts</code> filter:

</p><pre>ffmpeg \
  -i output.nut \
  -vf &#34;\
    setpts=0.5*PTS[v]; \
    [v]pad=ceil(iw/2)*2:ceil(ih/2)*2&#34; \
  -c:v libx264 \
  -pix_fmt yuv420p \
  -preset veryslow \
  -crf 10 \
  output.mp4
</pre><p>

What happens if I want to upload the video to a site where videos can&#39;t exceed
a certain width or height? I don&#39;t want to scale the video up if it&#39;s smaller
than that and I always want to maintain the aspect ratio. Let&#39;s say I want a
maximum height of 1920 and a maximum width of 1200:

</p><pre>ffmpeg \
  -i output.nut \
  -vf &#34; \
    setpts=0.5*PTS[v]; \
    [v]scale=&#39;min(1920,iw)&#39;:min&#39;(1200,ih)&#39;: \
       force_original_aspect_ratio=decrease[v]; \
    [v]pad=ceil(iw/2)*2:ceil(ih/2)*2 &#34; \
  -preset veryslow \
  -crf 12 \
  -c:v libx264 \
  -pix_fmt yuv420p \
  output_capped.mp4
</pre><p>

That means that I can record a huge window (e.g. a browser window at 3366x2468)
and automatically scale it down to the largest possible resolution that
preserves the aspect ratio (in this case to 1638x1200):

</p><video controls="">
<source src="/laurie/blog/extra/2022/making_a_video_of_a_single_window/firefox_scaled.mp4" type="video/mp4"/>
</video>
<h2>An example combination</h2><p>

One can put all the bits above together in various different ways, but at the
moment I&#39;ve bundled them into this simple script:

</p><pre>#! /bin/sh

if [[ $# -ne 1 ]]; then
    echo &#34;video_single_window &lt;base_file_name&gt;&#34; &gt; /dev/stderr
    exit 1
fi

t=`mktemp`
xwininfo &gt; $t
width=`grep Width $t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
height=`grep Height $t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
top_x=`grep &#34;Absolute upper-left X&#34; $t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`
top_y=`grep &#34;Absolute upper-left Y&#34; $t | cut -d &#34;:&#34; -f 2 | tr -d &#34; &#34;`

ffmpeg \
  -f x11grab \
  -framerate 30 \
  -video_size ${width}x${height} \
  -i +${top_x},${top_y} \
  -c:v libx264rgb \
  -preset ultrafast \
  -crf 0 \
  $1.nut &amp;
ffmpeg_pid=$!
hk Shift+F4 kill -SIGINT $ffmpeg_pid
wait $ffmpeg_pid

ffmpeg \
  -i $1.nut \
  -c:v libx264 \
  -pix_fmt yuv420p \
  -vf &#34; \
    setpts=0.5*PTS[v]; \
    [v]pad=ceil(iw/2)*2:ceil(ih/2)*2&#34; \
  -preset veryslow \
  -crf 10 \
  $1.mp4

ffmpeg \
  -i $1.nut \
  -vf &#34; \
    setpts=0.5*PTS[v]; \
    [v]scale=&#39;min(1920,iw)&#39;:min&#39;(1200,ih)&#39;: \
       force_original_aspect_ratio=decrease[v]; \
    [v]pad=ceil(iw/2)*2:ceil(ih/2)*2&#34; \
  -preset veryslow \
  -crf 10 \
  -c:v libx264 \
  -pix_fmt yuv420p \
  $1_scaled.mp4

rm $t
</pre><p>

In essence after running <code>video_single_window base</code> I end up with
three files: <code>base.nut</code> (the &#34;raw&#34; recording), <code>base.mp4</code>
(a compressed MP4), and <code>base_scaled.mp4</code> (a compressed and possibly
scaled-down MP4).

</p><p>One of the best bits about the simplicity of this script is
how easy it is to create variants. For example, I created a variant with
a different hotkey, which allowed me to record <code>video_single_window
base</code> running (at normal speed, so you can see FFmpeg at its real speed;
the recording FFmpeg is <code>kill</code>ed at about 16 seconds in):

<video controls="">
<source src="/laurie/blog/extra/2022/making_a_video_of_a_single_window/meta1_orig_speed.mp4" type="video/mp4"/>
</video>

I&#39;ve long been impressed by FFmpeg&#39;s versatility, but co-opting xwininfo and
hk leads to a surprisingly powerful toolbox!

</p><p><b>Acknowledgements</b>: thanks to
<a href="https://www.eddbarrett.co.uk/">Edd Barrett</a> and
<a href="https://lukasdiekmann.uk/">Lukas Diekmann</a>
for comments.

</p>



<h3>Footnotes</h3>
<table>
<tbody><tr><td><a name="71930952">[1]</a></td><td>
I could perhaps have ported <a href="https://github.com/MaartenBaert/ssr">ssr</a>, but it was too much fun to
do things myself!
</td></tr>
<tr><td><a name="82644452">[2]</a></td><td>
For the sort of desktop videos I do, 30fps is overkill: I regularly use 10 or
12 fps, and no-one has ever noticed or complained.
</td></tr>
<tr><td><a name="18057354">[3]</a></td><td>
Until I&#39;d fully understood how zombie processes come to be zombies
(with much debugging in <a href="https://tratt.net/laurie/src/extsmail">extsmail</a>), I did not
realise how unsatisfactory, and potentially unsafe, the Unix PID system and
<code>wait</code> are. That said, I&#39;ve never seen &#34;PID reuse&#34; problems manifest
in real life, even though they clearly <em>could</em>. Since there&#39;s no
alternative, carrying on is on the only possibility!
</td></tr></tbody></table>


<h3>Comments</h3>



</div></div>
  </body>
</html>
