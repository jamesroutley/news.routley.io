<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cppstories.com/2020/07/lambdas5ex.html/">Original</a>
    <h1>Curious C&#43;&#43; Lambda Examples: Recursion, constexpr, Containers C&#43;&#43;23 included</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p><img src="https://www.cppstories.com/2020/images/lambdas5ex.png" alt=""/></p>  
          
        <p>In this blog post I’ll show you a couple of interesting examples with lambda expressions. Do you know how to write a recursive lambda? Store them in a container? Or invoke at compile time?</p>
<p>See in the article.</p>
<p>Updated in August 2022: Added C++23 improvements.</p>
<h2 id="1-recursive-lambda-with-stdfunction">
1. Recursive Lambda with <code>std::function</code> 
  
<a href="#1-recursive-lambda-with-stdfunction" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>Writing a recursive function is relatively straightforward: inside a function definition, you can call the same function by its name. How about lambdas?</p>
<div><pre><code data-lang="cpp"><span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>auto</span> <span>factorial</span> <span>=</span> <span>[](</span><span>int</span> <span>n</span><span>)</span> <span>{</span>
        <span>return</span> <span>n</span> <span>&gt;</span> <span>1</span> <span>?</span> <span>n</span> <span>*</span> <span>factorial</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>:</span> <span>1</span><span>;</span>
    <span>};</span>
    <span>return</span> <span>factorial</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div><p>This, unfortunately, doesn’t compile…</p>
<p>How can we fix this?</p>
<p>One way is to use <code>std::function</code>:</p>
<div><pre><code data-lang="cpp"><span>#include</span> <span>&lt;functional&gt;</span><span>
</span><span></span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>const</span> <span>std</span><span>::</span><span>function</span><span>&lt;</span><span>int</span><span>(</span><span>int</span><span>)</span><span>&gt;</span> <span>factorial</span> <span>=</span> <span>[</span><span>&amp;</span><span>factorial</span><span>](</span><span>int</span> <span>n</span><span>)</span> <span>{</span>
        <span>return</span> <span>n</span> <span>&gt;</span> <span>1</span> <span>?</span> <span>n</span> <span>*</span> <span>factorial</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>:</span> <span>1</span><span>;</span>
    <span>};</span>
    <span>return</span> <span>factorial</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div><p>This time we need to capture <code>factorial</code> and then we can refer to it inside the lambda body.</p>
<p>And since C++14 we can also leverage generic lambdas and write the following code:</p>
<div><pre><code data-lang="cpp"><span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>const</span> <span>auto</span> <span>factorial</span> <span>=</span> <span>[](</span><span>int</span> <span>n</span><span>)</span> <span>{</span>
        <span>const</span> <span>auto</span> <span>fact_impl</span> <span>=</span> <span>[](</span><span>int</span> <span>n</span><span>,</span> <span>const</span> <span>auto</span><span>&amp;</span> <span>impl</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span>
            <span>return</span> <span>n</span> <span>&gt;</span> <span>1</span> <span>?</span> <span>n</span> <span>*</span> <span>impl</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>,</span> <span>impl</span><span>)</span> <span>:</span> <span>1</span><span>;</span>
        <span>};</span>
        <span>return</span> <span>fact_impl</span><span>(</span><span>n</span><span>,</span> <span>fact_impl</span><span>);</span>
    <span>};</span>
    <span>return</span> <span>factorial</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div><p>This time it’s even more complicated (but doesn’t require heavy use of <code>std::function</code>). It uses internal lambda for the main computation and then it’s passed as a generic argument.</p>
<p>But I wonder: have you ever used recursive lambdas? Or it’s better to rely on recursive functions (which seems to be far more comfortable to use and write).</p>
<h2 id="11-recursive-lambdas-in-c23">
1.1 Recursive Lambdas in C++23 
  
<a href="#11-recursive-lambdas-in-c23" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>As you can see creating a recursive lambda requires some tricks in C++11 or C++14. Fortunately it will change in C++23! Thanks to a powerful feature called “deducing <code>this</code>” we have a way to access the lambda object from its call operator.</p>
<p>Have a look:</p>
<div><pre><code data-lang="cpp"><span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>auto</span> <span>factorial23</span> <span>=</span> <span>[](</span><span>this</span> <span>auto</span><span>&amp;&amp;</span> <span>self</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>1</span><span>)</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>return</span> <span>n</span> <span>*</span> <span>self</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>);</span>
    <span>};</span>
   
    <span>return</span> <span>factorial23</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div><p>Run at <a href="https://godbolt.org/z/jdah3aGYd">Compiler Explorer</a></p>
<p>The main idea is that each member function (including the call operator of a lambda object), can get explicit <code>this</code> parameter. The compiler passes this argument anyway, so C++23 just added a way to expose it and allow to manipulate. The argument is always passed as the first one and in our cases it’s called <code>self</code>. Notice the keyword <code>this auto</code> to indicate that this is <code>this</code> :)</p>
<p>We can also write an alternative version:</p>
<div><pre><code data-lang="cpp"><span>auto</span> <span>factorial23_2</span> <span>=</span> <span>[](</span><span>this</span> <span>auto</span><span>&amp;&amp;</span> <span>self</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>-&gt;</span> <span>int</span><span>{</span>
    <span>if</span> <span>(</span><span>n</span> <span>&gt;</span> <span>1</span><span>)</span>          
        <span>return</span> <span>n</span> <span>*</span> <span>self</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>);</span>
    <span>return</span> <span>1</span><span>;</span>
<span>};</span>
</code></pre></div><p>But this time the compiler needs some help with return type deduction - that’s why I added <code>-&gt; int</code>.</p>
<p>Read more in the following article at the MSVC Team blog: <a href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23’s Deducing this: what it is, why it is, how to use it - C++ Team Blog</a>.</p>
<h2 id="2-constexpr-lambdas">
2. <code>constexpr</code> Lambdas 
  
<a href="#2-constexpr-lambdas" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>But that’s not all with recursion… :)</p>
<p>Since C++17 we can write lambdas that have the call operator defined as <code>constexpr</code>. We can use this property and expand the recursive example into:</p>
<div><pre><code data-lang="cpp"><span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>constexpr</span> <span>auto</span> <span>factorial</span> <span>=</span> <span>[](</span><span>int</span> <span>n</span><span>)</span> <span>{</span>
        <span>constexpr</span> <span>auto</span> <span>fact_impl</span> <span>=</span> <span>[](</span><span>int</span> <span>n</span><span>,</span> <span>const</span> <span>auto</span><span>&amp;</span> <span>impl</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span>
            <span>return</span> <span>n</span> <span>&gt;</span> <span>1</span> <span>?</span> <span>n</span> <span>*</span> <span>impl</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>,</span> <span>impl</span><span>)</span> <span>:</span> <span>1</span><span>;</span>
        <span>};</span>
        <span>return</span> <span>fact_impl</span><span>(</span><span>n</span><span>,</span> <span>fact_impl</span><span>);</span>
    <span>};</span>
    <span>static_assert</span><span>(</span><span>factorial</span><span>(</span><span>5</span><span>)</span> <span>==</span> <span>120</span><span>);</span>
<span>}</span>
</code></pre></div><p>And in C++20 you can even apply <code>consteval</code> to mark lambdas which can be evaluated only at compile time.</p>
<p>Plus in C++23 you can apply <code>constexpr</code> or <code>consteval</code> along with passing <code>this</code>:</p>
<div><pre><code data-lang="cpp"><span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>constexpr</span> <span>auto</span> <span>factorial23</span> <span>=</span> <span>[](</span><span>this</span> <span>auto</span><span>&amp;&amp;</span> <span>self</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>1</span><span>)</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>return</span> <span>n</span> <span>*</span> <span>self</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>);</span>
    <span>};</span>
    <span>static_assert</span><span>(</span><span>factorial23</span><span>(</span><span>5</span><span>)</span> <span>==</span> <span>120</span><span>);</span>
<span>}</span>
</code></pre></div><p>See here <a href="https://godbolt.org/z/xMa54KPxj">@Compiler Explorer</a>.</p>
<h2 id="3-storing-lambdas-in-a-container">
3. Storing Lambdas in a Container 
  
<a href="#3-storing-lambdas-in-a-container" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>This might be a bit cheating… but we can theoretically store lambdas in a container.</p>
<p>While closure types have default constructors deleted (unless it’s stateless lambda in C++20), we can do a little hack and store all lambdas as <code>std::function</code> objects. For example:</p>
<div><pre><code data-lang="cpp"><span>#include</span> <span>&lt;functional&gt;</span><span>
</span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span><span>#include</span> <span>&lt;vector&gt;</span><span>
</span><span></span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>function</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>(</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span><span>)</span><span>&gt;&gt;</span> <span>vecFilters</span><span>;</span>
    
    <span>vecFilters</span><span>.</span><span>emplace_back</span><span>([](</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>x</span><span>)</span> <span>{</span> 
        <span>return</span> <span>x</span> <span>+</span> <span>&#34; Amazing&#34;</span><span>;</span> 
    <span>});</span>
    <span>vecFilters</span><span>.</span><span>emplace_back</span><span>([](</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>x</span><span>)</span> <span>{</span> 
        <span>return</span> <span>x</span> <span>+</span> <span>&#34; Modern&#34;</span><span>;</span> 
    <span>});</span>
    <span>vecFilters</span><span>.</span><span>emplace_back</span><span>([](</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>x</span><span>)</span> <span>{</span> 
        <span>return</span> <span>x</span> <span>+</span> <span>&#34; C++&#34;</span><span>;</span> 
    <span>});</span>
    <span>vecFilters</span><span>.</span><span>emplace_back</span><span>([](</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>x</span><span>)</span> <span>{</span> 
        <span>return</span> <span>x</span> <span>+</span> <span>&#34; World!&#34;</span><span>;</span> 
    <span>});</span>
    
    <span>const</span> <span>std</span><span>::</span><span>string</span> <span>str</span> <span>=</span> <span>&#34;Hello&#34;</span><span>;</span>
    <span>auto</span> <span>temp</span> <span>=</span> <span>str</span><span>;</span>
    
    <span>for</span> <span>(</span><span>auto</span> <span>&amp;</span><span>entryFunc</span> <span>:</span> <span>vecFilters</span><span>)</span>  
        <span>temp</span> <span>=</span> <span>entryFunc</span><span>(</span><span>temp</span><span>);</span>
    
    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>temp</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="4generic-lambdas-and-help-with-deduction">
4.Generic lambdas and Help with Deduction 
  
<a href="#4generic-lambdas-and-help-with-deduction" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>C++14 brought an important addition to lambdas: generic lambda arguments. Here’s one example that shows why is it useful:</p>
<div><pre><code data-lang="cpp"><span>#include</span> <span>&lt;algorithm&gt;</span><span>
</span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span><span>#include</span> <span>&lt;map&gt;</span><span>
</span><span>#include</span> <span>&lt;string&gt;</span><span>
</span><span></span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>const</span> <span>std</span><span>::</span><span>map</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>,</span> <span>int</span><span>&gt;</span> <span>numbers</span> <span>{</span> 
        <span>{</span> <span>&#34;one&#34;</span><span>,</span> <span>1</span> <span>},</span> <span>{</span><span>&#34;two&#34;</span><span>,</span> <span>2</span> <span>},</span> <span>{</span> <span>&#34;three&#34;</span><span>,</span> <span>3</span> <span>}</span>
    <span>};</span>
    
    <span>std</span><span>::</span><span>for_each</span><span>(</span><span>std</span><span>::</span><span>begin</span><span>(</span><span>numbers</span><span>),</span> <span>std</span><span>::</span><span>end</span><span>(</span><span>numbers</span><span>),</span> 
         <span>[](</span><span>const</span> <span>std</span><span>::</span><span>pair</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>,</span> <span>int</span><span>&gt;&amp;</span> <span>entry</span><span>)</span> <span>{</span>
             <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>entry</span><span>.</span><span>first</span> <span>&lt;&lt;</span> <span>&#34; = &#34;</span> <span>&lt;&lt;</span> <span>entry</span><span>.</span><span>second</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
         <span>}</span>
    <span>);</span>
<span>}</span>
</code></pre></div><p>Do you know what’s the mistake here? Is the argument type appropriately specified in the inner lambda for <code>for_each</code>?</p>
<p>I specified: <code>const std::pair&lt;std::string, int&gt;&amp; entry</code>.</p>
<p>But it’s wrong as the type of the key/value pair inside a map is:</p>
<p><code>std::pair&lt;const std::string, int&gt;</code></p>
<p>That’s why the compiler has to create unwanted temporary copies and then pass them to my lambda.</p>
<p>We can quickly fix this by using a generic lambda from C++14.</p>
<div><pre><code data-lang="cpp"><span>std</span><span>::</span><span>for_each</span><span>(</span><span>std</span><span>::</span><span>begin</span><span>(</span><span>numbers</span><span>),</span> <span>std</span><span>::</span><span>end</span><span>(</span><span>numbers</span><span>),</span> 
    <span>[](</span><span>const</span> <span>auto</span><span>&amp;</span> <span>entry</span><span>)</span> <span>{</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>entry</span><span>.</span><span>first</span> <span>&lt;&lt;</span> <span>&#34; = &#34;</span> <span>&lt;&lt;</span> <span>entry</span><span>.</span><span>second</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
    <span>}</span>
<span>);</span>
</code></pre></div><p>Now the types match, and no additional copies are created.</p>
<h2 id="5-returning-a-lambda">
5. Returning a lambda 
  
<a href="#5-returning-a-lambda" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>If you want to return a lambda from a function (for example for partial function application, currying), then it’s not straightforward because you don’t know the exact type of the closure object.</p>
<p>In C++11 one way was to use <code>std::function</code>:</p>
<div><pre><code data-lang="cpp"><span>#include</span> <span>&lt;functional&gt;</span><span>
</span><span></span>
<span>std</span><span>::</span><span>function</span><span>&lt;</span><span>int</span><span>(</span><span>int</span><span>)</span><span>&gt;</span> <span>CreateAddLambda</span><span>(</span><span>int</span> <span>y</span><span>)</span> <span>{</span>
    <span>return</span> <span>[</span><span>y</span><span>](</span><span>int</span> <span>x</span><span>)</span> <span>{</span> <span>return</span> <span>x</span> <span>+</span> <span>y</span><span>;</span> <span>};</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>auto</span> <span>tenPlus</span> <span>=</span> <span>CreateAddLambda</span><span>(</span><span>10</span><span>);</span>
    <span>return</span> <span>tenPlus</span><span>(</span><span>32</span><span>);</span>
<span>}</span>
</code></pre></div><p>Run <a href="https://godbolt.org/z/KM3KqzWP7">@Compiler Explorer</a>.</p>
<p>Since C++14, we can leverage the auto type deduction for return types and just write:</p>
<div><pre><code data-lang="cpp"><span>auto</span> <span>CreateAddLambda</span><span>(</span><span>int</span> <span>y</span><span>)</span> <span>{</span>
    <span>return</span> <span>[</span><span>y</span><span>](</span><span>int</span> <span>x</span><span>)</span> <span>{</span> <span>return</span> <span>x</span> <span>+</span> <span>y</span><span>;</span> <span>};</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>auto</span> <span>tenPlus</span> <span>=</span> <span>CreateAddLambda</span><span>(</span><span>10</span><span>);</span>
    <span>return</span> <span>tenPlus</span><span>(</span><span>32</span><span>);</span>
<span>}</span>
</code></pre></div><p>Run <a href="https://godbolt.org/z/7hvoTnb6T">@Compiler Explorer</a>.</p>
<p>The above code is far simpler and cheaper as we don’t need to use <code>std::function</code> (and even include <code>&lt;functional&gt;</code>).</p>
<p>Side note: Thanks to the <a href="https://www.reddit.com/r/cpp/comments/wk5gs4/comment/ijp29mr">r/cpp comment</a> about the wrong capture of <code>[&amp;y]</code>.</p>
<h2 id="summary">
Summary 
  
<a href="#summary" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>In this quick article, I showed you five interesting lambda examples. They might not be common, but shows flexibility and sometimes even complexity of the closure types.</p>
<p>Do you use lambdas in such contexts?
Or maybe you have even more complicated examples?
Share your experience in comments below the article.</p>
<h2 id="if-you-want-to-know-more">
If You Want to Know More 
  
<a href="#if-you-want-to-know-more" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>Most of the examples from this article comes from a book: <strong>“C++ Lambda Story”</strong>. Get the book here:</p>


<p>
<a href="https://leanpub.com/cpplambda"><img src="https://www.cppstories.com/images/cpplambdabook_small.png" height="140px"/></a></p>

<p>You can also become my Patron and get the book (and other extra content) for free:</p>
<p><a href="https://www.patreon.com/cppstories?utm_source=blog">Become a Patreon</a></p>
<p>Or see more benefits: <a href="https://www.cppstories.com/p/extra-patreon-content/">Premium Content - C++ Stories</a>.</p>

      </div></div>
  </body>
</html>
