<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.perl.org/users/psc/2022/05/what-happened-to-perl-7.html">Original</a>
    <h1>What Happened to Perl 7? (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
                            <p>With Perl 5.36.0 just around the corner, we thought that this is a good time to clarify plans for the future of the Perl programming language. We realised that the future was hammered out in a number of steps, across several months. This meant that there hasn&#39;t been a single statement we could refer people to. This post is to fill that gap.</p>

                            <p>Two years ago Perl 7 was announced. A key idea for Perl 7 was to significantly reduce the boilerplate needed at the top of your code, by enabling a lot of widely used modules / pragmas, but this would have come at the price of breaking some backwards compatibility. This would have meant that some existing code wouldn&#39;t have worked without modification.</p>

<p>This prompted a lot of heated discussions: some thought this was a great idea, and some thought it a terrible idea to throw away one of Perl&#39;s key strengths. Ultimately this led to a discussion about who had the right to make this decision, now that Larry is no longer involved in Perl (and hasn&#39;t been for about 20 years). The end result of all those discussions was a <a href="https://github.com/Perl/perl5/blob/blead/pod/perlgov.pod">new governance structure</a>.</p>

<p>The <a href="https://lists.perl.org/list/perl5-porters.html">Perl 5 Porters</a> (&#34;p5p&#34;) mailing list is still where the future of Perl is discussed, and we aim to build consensus, but where that&#39;s not possible, the three-person <a href="https://github.com/Perl/perl5/blob/blead/pod/perlgov.pod#the-steering-council">Perl Steering Council</a> (PSC) has ultimate decision making authority on the future of Perl. The PSC is elected annually by the <a href="https://github.com/Perl/perl5/blob/blead/pod/perlgov.pod#the-core-team">core team</a> (the subset of p5p who have contributed most to Perl &#34;recently&#34;). The trigger for an election is the annual release of Perl, so the next election will happen after 5.36.0 is released.</p>

<p>The first PSC was elected in late 2020, and one of our first tasks was to create a plan for the future of Perl, and to put that in motion. A lot of discussion and iteration followed, but the strategy we agreed is:</p>

<ol>
<li>Existing sensibly-written Perl 5 code should continue to run under future releases of Perl. Sometimes this won&#39;t be possible, for example if a security bug requires a change that breaks backward compatibility.</li>
<li>We want to drive the language forwards, increasing the rate at which new features are introduced. This resulted in the introduction of the <a href="https://github.com/Perl/RFCs/blob/main/docs/process.md">RFC process</a>, which anyone can use to propose language changes. </li>
<li>We want to make it easy for people to use these new features, and want to do what we can to encourage their adoption.</li>
</ol>

<p>At the heart of this strategy are feature guards and version bundles.</p>

<h2>Features</h2>

<p>If a new language feature isn&#39;t backwards compatible, then it is protected with a feature guard. For example, Perl 5.010 introduced the <code>say</code> keyword. But it couldn&#39;t be enabled by default, as someone might have a say function in their code, which it would conflict with. So if you want to use say, you have to request it using the <a href="https://perldoc.perl.org/feature">feature pragma</a>:</p>

<pre>    use feature &#39;say&#39;;
    say &#34;hello, world&#34;;
</pre>

<h2>Unguarded features</h2>

<p>Not all new language features have a guard. If new syntax is introduced which would result in a syntax error in all previous versions of Perl, then it doesn&#39;t need a guard. For example, 5.36.0 introduces new syntax which lets you process N items at a time from a list:</p>

<pre>    foreach my ($key, $value) (%hash) {
    …
    }
</pre>

<p>This new syntax doesn&#39;t have a feature guard, so it&#39;s available to use at line 0 (i.e. before you <code>use v5.36</code>).</p>

<h2>Experimental features</h2>

<p>Sometimes a feature will be marked as experimental, which means that we&#39;re not sure whether it&#39;s in the final form, and we&#39;d like people to play with it and give feedback. The experimental status means that we reserve the right to change everything about it in a subsequent release, or even to remove it. If you use such a feature, you&#39;ll get a warning, which you can suppress with an extra line of code:</p>

<pre>    use feature &#39;try&#39;;
    no warnings &#34;experimental::try&#34;;
</pre>

<p>In general you shouldn&#39;t use experimental features in production code.</p>

<h2>Version bundles</h2>

<p>A lot of features have been added since 5.10.0, and a bunch more have been added in 5.36.0. That can mean that you end up putting a lot of <code>use …</code> lines at the top of all your code. Instead, you can enable all the stable (i.e. non-experimental) features provided in Perl 5.36.0 that weren&#39;t included in the original Perl 5 release, with just put this one line at the top of your code:</p>

<pre>    use v5.36;
</pre>

<p>This does three things:</p>

<ol>
<li>it tells the perl interpreter (and human readers), that your code requires perl 5.36.0 or later to run;</li>
<li>it enables all additional non-experimental features provided by Perl;</li>
<li>it uses a number of additional pragmas that have been accepted as good practice.</li>
</ol>

<p>That one line is equivalent to:</p>

<pre>    require v5.36;
    use strict;
    use warnings;
    use feature &#39;say&#39;;
    use feature &#39;state&#39;;
    use feature &#39;current_sub&#39;;
    use feature &#39;fc&#39;;
    use feature &#39;lexical_subs&#39;;
    use feature &#39;signatures&#39;;
    use feature &#39;isa&#39;;
    use feature &#39;bareword_filehandles&#39;;
    use feature &#39;bitwise&#39;;
    use feature &#39;evalbytes&#39;;
    use feature &#39;postderef_qq&#39;;
    use feature &#39;unicode_eval&#39;;
    use feature &#39;unicode_strings&#39;;
    no feature &#39;indirect&#39;;
    no feature &#39;multidimensional&#39;;
</pre>

<p>Code that starts with <code>use v5.36</code> will run against future versions of Perl – all versions of Perl know about the version bundles of previous versions of Perl.</p>

<p>Version bundles have two main benefits:</p>

<ul>
<li>they greatly reduce the boilerplate you have to write at the top of your code, and</li>
<li>they document what version of Perl your code was written to. Version bundles have been supported since 5.10.0, but not widely understood or used. With the release of 5.36 we hope to change that.</li>
</ul>

<p>We have a lot more proposals in the pipeline, including the introduction of richer OO syntax. We expect 5.38 to include another swathe of new features.</p>

<h2>What about Perl 7?</h2>

<p>For now, our plan is to continue introducing new features and to resolve all existing experimental features, so they&#39;re either dropped, or become non-experimental features (and so are included in the version bundle).</p>

<p>The downside with this is that people often can&#39;t remember which version of Perl introduced which feature(s).</p>

<p>At some point in the future, the PSC may decide that the set of features, taken together, represent a big enough step forward to justify a new baseline for Perl. If that happens, then the version will be bumped to 7.0.</p>

<p>If this happens, Perl 7 will still be backwards compatible with Perl 5 by default – you&#39;ll have to put <code>use v7;</code> at the top of your code to use all the new features.</p>

<p>Think of <code>use v7</code> like Modern::Perl and similar modules.</p>

<p>Annual releases would continue, so it would then be followed by 7.2, 7.4, etc. We have a lot of good ideas in the works, and if we can keep up the momentum of the last year, then things look promising. And in the meantime we&#39;ll continue with 5.XX releases.</p>

<h2>Why not Perl 7 instead of 5.36?</h2>

<p>Some people, hoping to see Perl 7 sooner rather than later, have asked, &#34;Why wasn&#39;t this latest release of Perl released as Perl 7? It&#39;s got a bunch of new stuff, after all!&#34; The answer to this question depends on who you ask, but for the PSC, we can agree on something like this:</p>

<p>Changing the version number can serve two jobs. One is to indicate to a potential upgrader that there may be backward incompatibilities. We have generally decided against doing this, rejecting the original Perl 7 plan. The other job is to alert casual observers that the new release is a significant milestone, and that folks who wouldn&#39;t otherwise give much thought to the upgrade should take this time to re-evaluate the tool&#39;s fitness. That&#39;s the value we imagine getting out of a &#34;Perl 7&#34; release: it tells people to come look, because they might realize they&#39;d like to start doing some more work in Perl.</p>

<p>This is not a tactic we&#39;d like to invoke lightly. If we announce &#34;Perl 7! A whole new Perl!&#34; and the upgrades are modest and not likely to sway anybody who isn&#39;t already keen, it doesn&#39;t only fail, but also sours the tactic for next time. A future Perl 8 will be viewed as likely to be another modest upgrade. We want to reserve the big bump for changes that we think will reward people who take the time to look into it. Perl 7 can&#39;t be crying wolf.</p>

                        </div></div>
  </body>
</html>
