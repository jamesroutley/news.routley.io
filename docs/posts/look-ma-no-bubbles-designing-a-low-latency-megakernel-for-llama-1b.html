<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hazyresearch.stanford.edu/blog/2025-05-27-no-bubbles">Original</a>
    <h1>Look Ma, No Bubbles: Designing a Low-Latency Megakernel for Llama-1B</h1>
    
    <div id="readability-page-1" class="page"><div><p>There are some applications that benefit from running LLMs really, really fast. This low-latency regime encompasses applications like chatbots and human-in-the-loop workflows, where users care a lot about seeing responses come back immediately.</p>
<p>Given the importance of these low-latency workloads, we wanted to explore just how fast we can run open-source models on modern GPUs. To really stress-test existing systems, we consider an aggressive low-latency scenario where we generate a single sequence with Llama-3.2-1B. This workload is strongly memory bound – our performance is dominated by how fast we can load model weights from GPU global memory.</p>
<p>It turns out that popular LLM inference engines – vLLM and SGLang – are only able to use at most 50% of available GPU bandwidth when running this workload on an H100. The root of the problem, which we&#39;ll describe more below, is that existing systems break down a model forward pass into around <strong>a hundred separate kernels</strong> that each implement a few operations (e.g. RMS norm, attention, an MLP layer + activation, rotary). Each kernel comes with a setup and teardown period and during this time no useful work gets done – for instance, the all-important task of loading model weights is stalled.</p>
<div><p><img src="https://hazyresearch.stanford.edu/static/posts/2025-05-27-no-bubbles/result.png" alt="Performance comparison graph"/></p><p><em>Figure 1: Speed! Results generated with a 32-token prompt and 128 generated tokens, with no speculation</em></p></div>
<p>In this post, we show how we can bypass this problem by merging the entire Llama-1B forward pass into a single &#34;megakernel&#34; that eliminates kernel boundaries altogether. Doing this achieves brr – on an H100, we use 78% of memory bandwidth and outperform existing systems by over 1.5x. (To our knowledge, this is the lowest-latency forward pass for Llama-1B in bfloat16!) In the rest of this post, we&#39;ll walk through how and why one would do this. Specifically:</p>
<ul>
<li>First, we&#39;ll talk about how small kernels lead to AI systems that underutilize the GPU&#39;s full bandwidth.</li>
<li>Second, we&#39;ll describe three important points about how we built our megakernel: how we fused lots of kernels together, how we share hardware resources across them to minimize overhead, and how we synchronize them efficiently.</li>
</ul>
<p>If you&#39;re interested in learning more of the details or using these ideas yourself, we&#39;re <a href="https://github.com/HazyResearch/Megakernels">open-sourcing all of our code here</a>.</p>
<h2>Separate Kernels Kill the Vibe</h2>
<p>In general, the way one runs code on a GPU is by launching a &#34;kernel&#34; – a small program that does a well-defined operation (e.g. RMS norm, MLP). Today, all AI workloads run as long sequences of relatively small kernels. To get an initial sense, let&#39;s look at the operations in the Llama-1B transformer block, and some example kernel boundaries of how they might be divided up (Figure 2).</p>
<div><p><img src="https://hazyresearch.stanford.edu/static/posts/2025-05-27-no-bubbles/kernel_boundaries.png" alt="Kernel boundaries diagram"/></p><p><em>Figure 2: An example set of kernel boundaries for the Llama-1B transformer block. Red boxes delineate the work done by individual kernels.</em></p></div>
<p>As we described earlier, decoding a single sequence with Llama-1B is a purely memory-bound workload: our performance depends on being able to <strong>always</strong> be loading weights from GPU global memory. So, why are existing approaches so far from using the full bandwidth of the GPU?</p>
<p>When we dug into it, we noticed a key problem was that the current kernel-based approach to running models introduces stalls that prevent us from constantly loading memory:</p>
<ul>
<li>First: GPU kernels are launched with a strict ordering, so that a thread block in one kernel can&#39;t start until all thread blocks in previous kernels have completely finished. Consequently, every time we start a kernel, we have to wait for all the straggler thread blocks from the prior one to finish. For example, if a kernel runs 512 thread blocks (like our Llama-1B down projection), but we only have 148 streaming multiprocessors (like on a B200), we end up with 80 empty SM&#39;s at the end.</li>
<li>Second, as we&#39;ve <a href="https://hazyresearch.stanford.edu/blog/2025-03-04-thundermla">previously highlighted</a>, each kernel launch and teardown incurs costs. In principle, NVIDIA&#39;s CUDA graphs can help hide costs, but by our measurements they still leave a lot on the table. For a simple dummy kernel (which dumps a start time, sleeps, and dumps an end time) on an H100, we find that running on a CUDA stream incurs a launch cost of about 2.1 microseconds, and with CUDA graphs the launch cost only decreases to around 1.3 microseconds – time spent with the GPU doing no useful work! We&#39;d like to have the GPU spend all of its time doing useful work.</li>
<li>Finally, even after we start the next kernel, we still have to wait to load weights and activations before any compute can start. These latencies leave the GPU sitting idle for thousands of cycles! Ideally, we&#39;d start loading the next weights while the previous computations and stores are happening. NVIDIA has also built a mechanism for this called <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#programmatic-dependent-launch-and-synchronization">Programmatic Dependent Launch</a> (PDL), which allows the next kernel to start preparing while the previous kernel is running, but we found it still introduces unnecessary stalls because the PDL synchronization mechanism (cudaGridDependencySynchronize) is very coarse. For example, it means we have to wait for all queries, keys, and values to complete in order to start attention, as opposed to starting heads as soon as they are ready. We&#39;ll later show another specific case of where this is useful in Llama-1B.</li>
</ul>
<p>Taken together, these form the &#34;memory pipeline bubbles&#34; our title references – and they represent a key reason that we&#39;re <strong>not always loading from memory</strong>.  For short operations, these pauses add up, wasting a huge chunk of potential bandwidth. In part, this is because Llama-1B (actually 1.24B parameters) in batch size 1 is just so... small: if each operation is really fast, then the time spent in-between them really starts to matter.</p>
<p>To illustrate the magnitude of the problem: for single-sequence generation in 16-bit precision on a single H100, the <strong>memory limit</strong> is 3.35TB/s / 2.48GB = ~1350 forward passes per second. But with 7 kernel launches per layer, and 16 layers, even with an optimistic 5 us of stalling per kernel (counting stragglers, kernel launch, and memory latencies), generation would run at just ~770 forward passes per second. In practice, it&#39;s often worse. On low-latency workloads, GPUs spend only a fraction of their time actually doing any useful work!</p>
<p>So while CUDA does provide some existing features (e.g. graphs, streams, PDL) to partially solve these problems, we wanted to see if a different approach could solve all of these problems, where we just fuse the entire model forward pass into a single kernel.</p>
<h2>How to Megakernel</h2>
<p>Next, we&#39;ll show you how we fused a whole Llama forward pass into a single kernel, and our methods for resolving three key problems:</p>
<ol>
<li>Fusing dozens of operations is hard to do from scratch. We need a mechanism for executing these operations within the megakernel.</li>
<li>In order to overlap multiple operations on the same hardware, we need to prevent contention over limited resources, such as shared memory.</li>
<li>The GPU synchronizes after each kernel in the traditional kernel model. Without kernels, we have to synchronize the GPU all by ourselves!</li>
</ol>
<p>Let&#39;s start with the first issue:</p>
<h4>Issue 1/3: Fusing Lots of Operations</h4>
<p>Traditional kernel fusion generally merges just two or three operations together. In contrast, we need to fuse about a hundred. Consequently, we need to have a sensible abstraction for how we can actually program a megakernel.</p>
<p>Our approach is built on an on-GPU interpreter – essentially a more sophisticated version of our infrastructure underlying <a href="https://hazyresearch.stanford.edu/blog/2025-03-04-thundermla">ThunderMLA</a>. Our interpreter is designed such that each streaming multiprocessor (SM) within the GPU receives a sequence of <strong>instructions</strong> (each implemented using the same CUDA template) and executes them. We <strong>schedule</strong> each SM&#39;s instruction sequence ahead of time on the Python side, and notably we can reuse each schedule for hundreds of forward passes!</p>
<p>For our end-to-end Llama forwards pass megakernel, we define the following set of instructions:</p>
<ul>
<li>A fused RMS norm &amp; QKV &amp; RoPE instruction.</li>
<li>An attention computation instruction.</li>
<li>An attention reduction instruction (for ThunderGQA on long sequences).</li>
<li>An O-projection + residual instruction.</li>
<li>A fused RMS norm &amp; up-gate &amp; SiLU instruction.</li>
<li>A down-projection + residual instruction.</li>
<li>An RMS norm &amp; language modeling head instruction, for computing the final token logits.</li>
</ul>
<p>We implement each of these instructions using a common <a href="https://github.com/HazyResearch/Megakernels/blob/main/util/mk_init/sources/src/%7B%7BPROJECT_NAME_LOWER%7D%7D.cu">CUDA template</a> (with load, store, compute boilerplate functions), facilitating interoperability within our interpreter framework.</p>
<h4>Issue 2/3: <span>S</span><span>h</span><span>a</span><span>r</span><span>i</span><span>n</span><span>g</span> Shared Memory to Eliminate Memory Bubbles</h4>
<p>The instruction-and-interpreter structure lets us cleanly organize our megakernel. However, we haven&#39;t yet addressed the key issue: making sure that model weights are always being loaded in order to maximize memory bandwidth utilization.</p>
<p>The reason why a megakernel lets us solve this problem is that we can pipeline memory loads across instructions: our interpreter will start loading the model weights for an instruction as soon as it can, even if a previous instruction is still finishing up (e.g. storing out its results to global memory). It&#39;s this tight transitioning between instructions that minimizes the memory bubbles that would otherwise appear if we launched multiple kernels.</p>
<p>However, there&#39;s a catch: loading the weights from global memory for the next instruction doesn&#39;t do you much good if you have no place to put the data you loaded! More precisely, all of our weight matrices are loaded from GPU global memory into our SM&#39;s &#34;shared memory&#34; – NVIDIA&#39;s term for the fast memory on each SM. Shared memory is a scarce resource on each SM, and we can&#39;t start a load for a new instruction if a previous instruction is using all of it. This necessitates a way to keep track of which instruction is using which piece of shared memory and quickly transition shared memory to the next instruction when the current instruction is done with it.</p>
<p>We accomplish this by <strong>paging</strong> shared memory. We first divide the first 213kB of shared memory on an H100 into 13 16KiB pages, and use remaining shared memory for special purposes, like storing instruction parameters. To use one of these pages, instructions have to explicitly request and release them from the interpreter. The interpreter automatically passes released pages to the next instruction, allowing them to start issuing memory loads as early as shared memory becomes available.</p>
<h4>Issue 3/3: Synchronization</h4>
<p><img src="https://hazyresearch.stanford.edu/static/posts/2025-05-27-no-bubbles/thanos.png" alt="Thanos illustration"/></p>
<p>While megakernels let us minimize pipeline bubbles, they also introduce a new problem: synchronization. The performance limitation with the normal many-kernel execution model is that no thread blocks in a kernel can start until all thread blocks in previous kernels are finished. However, it&#39;s precisely this property that makes it easy to manage data dependencies. When a kernel launches, CUDA guarantees that all of the kernel&#39;s input tensors have already been produced and are safe to read from immediately.</p>
<p>With megakernels, we have no such guarantees: when an SM starts to execute a new instruction, its inputs might not be ready! To address this, we explicitly synchronize the instructions inside of our megakernel. We accomplish this with a simple counter system. Before the megakernel launches, we initialize an array of counters (i.e. integers) in GPU global memory with a starting value of zero. Whenever an instruction completes, it increments one of these counters. Similarly, whenever a new instruction starts, it must wait for some of these counters to reach a target value, indicating that all of its dependencies have finished.</p>
<p>One optimization this enables is in the big multi-layer perceptrons (MLPs) in Llama-1B.</p>
<ul>
<li>In a naive implementation using PDL, one must await completing the whole hidden state before beginning the down projection matrix multiply.</li>
<li>We instead produce and consume the intermediate state in four chunks, each with their own counter. This way, an instruction for the down projection only needs to wait for its input chunk to finish.</li>
</ul>
<h2>Putting It All Together</h2>
<p>To our knowledge, our H100 megakernel represents the first time anyone has run the forward pass for a 16-bit 1B+ parameter language model in under one millisecond on a GPU. Our B200 implementation pushes this even further to under 680 microseconds per forward pass!</p>
<p>As shown in Figure 1, our megakernel outperforms vLLM and SGLang baselines (which use CUDA graphs and torch compilation):</p>
<ul>
<li>On an H100, our megakernel runs almost 2.5x faster than vLLM and over 1.5x faster than SGLang.</li>
<li>On a B200, the gap with vLLM rises to over 3.5x, and we remain more than 1.5x faster than SGLang, too.</li>
</ul>
<p>We&#39;re still actually quite a ways off from the theoretical limit on a B200, which is around ~3,000 forward passes per second. Part of this gap is because this theoretical limit is based purely on memory bandwidth – but we still have to wait to load activations. And although these activations are small (and don&#39;t cost a lot of bandwidth), there are still latencies in loading them that we can&#39;t hide. A breakdown of the runtime of our current B200 forward pass (total runtime 600 microseconds):</p>
<ul>
<li>250 microseconds are spent storing activations, awaiting consistency, and loading them. This is about 20% higher than a simple model would suggest: since each instruction has a dependence on the last one, we need to pay two load latencies (check ready, and then load activations) and two store latencies (store activations, then mark ready) per instruction. Using ~500 nanoseconds latency per load / store, this would impose about 200 microseconds of overhead. (We suspect some of the remaining 50 microseconds comes from time spent processing atomics in global memory.)</li>
<li>200 microseconds are spent actually running RMS norm and matrix-vector computations. 95% of this portion is devoted to matrix-vector. On Blackwell, we find that using the tensor cores is marginally helpful for this; on Hopper, we find it better to simply run on the CUDA cores. This difference comes from the fact that both GPUs have relatively similar CUDA core performance, but Blackwell tensor cores are much faster.</li>
<li>30 microseconds are spent awaiting weights from global memory (pipelining works!) Of these, 40% are spent in the LM head, which is the best-pipelined part of the whole megakernel due to its homogeneity and huge size.</li>
<li>40 microseconds are spent on low-level synchronization overhead across warps. A key issue here is that CUDA&#39;s asynchronous barriers are relatively slow, even when they&#39;re already in the &#34;pass&#34; state, requiring about 60 nanoseconds each time.</li>
<li>80 microseconds are on setup and various other overheads (e.g. passing instruction barriers, marking pages as complete, etc.)</li>
</ul>
<p>We think there&#39;s probably more to do on each of these, but that&#39;ll have to wait for a future update!</p>
<h2>The Megakernel Cinematic Universe</h2>
<p>In this blog, we focus narrowly on designing a megakernel for low-latency, batch-size one LLM inference. However, we believe that the ability to more precisely control GPU execution with megakernels can more generally be applied to accelerate a much broader set of AI workloads. Stay tuned!</p>
<div><p><img src="https://hazyresearch.stanford.edu/static/posts/2025-05-27-no-bubbles/sonic.png" alt="Sonic illustration"/></p><p><strong>The Main Message of this Blog Post</strong></p></div>
<p>If you&#39;d like to learn more, please reach out to Ben or Jordan! Please include a tribute of at least five pictures of kittens in your email.</p>
<ul>
<li>Ben: <a href="mailto:bfs@stanford.edu">bfs@stanford.edu</a></li>
<li>Jordan: <a href="mailto:jbj@stanford.edu">jbj@stanford.edu</a></li>
</ul>
<p>And many, many thanks to Together AI for generously providing us with B200s and H100s to do this work, which would not have been possible without them!</p>
<p>See also: <a href="https://hazyresearch.stanford.edu/blog/2025-03-04-thundermla"><strong>pretty big kernels</strong></a> | <a href="https://hazyresearch.stanford.edu/blog/2024-05-12-tk"><strong>regular kernels</strong></a></p></div></div>
  </body>
</html>
