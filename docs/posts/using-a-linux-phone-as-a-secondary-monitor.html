<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tuxphones.com/howto-linux-as-second-wireless-display-for-linux/">Original</a>
    <h1>Using a Linux phone as a secondary monitor</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
    <article>

        <header>


            




            <div>
                <section>
                    <ul>
                        <li>
                            <a href="https://tuxphones.com/author/r/">
                                <img src="https://tuxphones.com/content/images/size/w100/2019/08/pp.jpeg" alt="Raffaele T."/>
                            </a>
                        </li>
                    </ul>
                    <div>
                        
                        <p><time datetime="2022-05-16">May 16, 2022</time>
                            <span><span>•</span> 7 min read</span>
                        </p>
                    </div>
                </section>
            </div>

            <figure>
                <img srcset="/content/images/size/w300/2022/05/linux-phone-tablet-as-virtual-display-monitor-sidecar2.jpg 300w,
                            /content/images/size/w600/2022/05/linux-phone-tablet-as-virtual-display-monitor-sidecar2.jpg 600w,
                            /content/images/size/w1000/2022/05/linux-phone-tablet-as-virtual-display-monitor-sidecar2.jpg 1000w,
                            /content/images/size/w2000/2022/05/linux-phone-tablet-as-virtual-display-monitor-sidecar2.jpg 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://tuxphones.com/content/images/size/w2000/2022/05/linux-phone-tablet-as-virtual-display-monitor-sidecar2.jpg" alt="Using a Linux phone as a secondary monitor"/>
            </figure>
        </header>

        <section>
            <p>As a software developer on the go, one of the very first use cases that I started investigating after installing Linux on my first tablet was that of using a portable device as a secondary display for another Linux machine. Ideally, this would happen wirelessly (or wired, if that involved lower power consumption), with unnoticeable delay, and - why not - even including real-time touchscreen input. </p><p>The journey, however, took longer than planned. Existing solutions, like VNC, tend to be strangely laggy, and others, like Miracast, are so deeply enclosed in proprietary protocols that they do not scale well to a bug-free experience on all devices. The first solution to this problem, at an even less stable stage than currently, was my <a href="https://twitter.com/tuxphones/status/1487841914149904397">most shared post ever</a> on Twitter, so I decided to write a post on how this was done.</p><blockquote>why is everyone liking my hacks </blockquote><p>To start, let us split this problem in even smaller bits. Namely, components are:</p><ul><li><strong>Virtual display handling</strong>: creating a fake video output. On Xorg, some GPU-specific hacks exist (probably Intel-only) vs Wayland (mutter)</li><li><strong>Video capturing</strong>: we assume that the windowing system grants enough permissions to capture the screen</li><li><strong>Video streaming</strong>: This, of course, needs to be fast. So real-time stream compressing and decoding is necessary.</li><li><strong>Network</strong>: This one is easy, at least on our side. By replacing most known network overhead (e.g. not relying on central Wi-Fi APs, getting rid of TCP packets, ...) and transmitting bare-bones UDP packets from point to point, we achieve significant gains in performance. In fact, even dropping wireless entirely and using Ethernet over USB (which e.g. postmarketOS supports) could further reduce latency.</li><li><strong>Display / decoding</strong> on host machine: as we said, needing <em>fast</em> video decoding is not obvious in the hellish landscape of fragmented ARM SoCs, and their many video decoders, some running over proprietary wrappers (e.g. Adreno), some over hacky adaptions of Android userspace (e.g. <em>hybris</em>), some supporting a ridiculously small subset of features in mainline (e.g. old Nvidia Tegras), and some not supported at all. Furthermore, with most ports using Android drivers, this needs to be reproducible on myriad of kernels also <em>without</em> mainline kernel!</li><li><strong>(Optional) input device handling:</strong> to get and transmit touchscreen events smoothly on the receiving screen, and map them as a real touch input on the host device. A little spoiler: I did not get here yet, and will not any time soon.</li></ul><p>Decent reliability, easy reproducibility (even on downstream kernels) and acceptable latency are required. </p><p>The off-shelf solutions for streaming existing desktops (but not a virtual desktop) with are endless, and they include <a href="https://deskreen.com/lang-de">Deskreen</a> (which communicates over WebRTC), or more simply an almost hidden feature in VLC that enables streaming and transcoding of the desktop, simple VNC,  and a myriad of open-source (X11, often semi-abandoned) and proprietary streaming apps. However, not all devices have a hardware HDMI port, and bringing a fake hardware adapter to trick the GPU into enabling a second video sink is chaotic to say the least. The alternative, at this point, is to use a Mutter-based desktop, or any other window manager with some sort of built-in interface for creating virtual screens in software.</p><p>After a few failed attempts, with latency in the range of <em>seconds</em>, I am starting to see some light. By getting rid of as many layers as possible, minimizing the overhead, and just trying the simplest hacks for raw streaming, performance is getting surprisingly acceptable: at 5Mbps bandwidth, this means over 10 FPS, and latency is probably around 200ms over good connections.</p><figure><img src="https://tuxphones.com/content/images/2022/05/Screenshot-from-2022-05-15-20-18-17.png" alt="" loading="lazy" width="1102" height="762" srcset="https://tuxphones.com/content/images/size/w600/2022/05/Screenshot-from-2022-05-15-20-18-17.png 600w, https://tuxphones.com/content/images/size/w1000/2022/05/Screenshot-from-2022-05-15-20-18-17.png 1000w, https://tuxphones.com/content/images/2022/05/Screenshot-from-2022-05-15-20-18-17.png 1102w" sizes="(min-width: 720px) 720px"/><figcaption>One real monitor, four impostors ඞ. The sky is the limit!</figcaption></figure><h2 id="prerequisites">Prerequisites</h2><ul><li>In particular, this solution requires the Mutter window manager (40+), so GNOME, Elementary, Budgie or other Mutter-based desktops. This clean D-Bus API is also an unified solution for virtual monitors between Wayland and Xorg. Theoretically, virtual monitors have also been supported by other window managers like <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=KWin-September-Wayland">KDE</a> and <a href="https://github.com/swaywm/sway/pull/5216">Sway</a> for a while, so adapting this solution should be relatively easy.</li><li>You will also need a PipeWire enabled stack, so a very modern distribution such as Fedora 35+ or Arch Linux.<em> </em>In theory, you can use PipeWire for video also on a system using the now-legacy PulseAudio for handling sound</li><li>Wi-Fi, working USB Ethernet, or any other network with acceptable latency</li><li>Finally, hardware video acceleration on the receiver side is a must. Plain CPU video decoding will either lag behind the stream, or consume a lot of power in the process, or both.</li></ul><h2 id="current-sthack">Current st(h)ack</h2><p>I created a Python script based on an older Mutter API demo script. This was modified to have bare-bones streaming, and requires the following D-Bus and command line interfaces:</p><ul><li>Mutter: to create a virtual display</li><li>PipeWire: to manage the stream</li><li>GStreamer: to compress/send/receive video between the two devices.</li></ul><p>In particular, two commands are used. On the sender:</p><ul><li><code>pipewiresrc path=%u ! </code>		This starts the stream from PipeWire</li><li><code>%s videoconvert ! </code>				...and transcodes to x264 video stream</li><li><code>x264enc tune=zerolatency bitrate=5000 speed-preset=superfast !</code></li><li><code>rtph264pay !</code>							 ...encapsulates the stream</li><li><code>udpsink host=... port=...</code>	...and transmits it to the host via &#34;raw&#34; UDP</li></ul><p>On the receiver: </p><ul><li><code>DISPLAY=:0 </code> is optional, but allows invoking the script e.g. from headless sessions such as SSH. The display identifier may clearly differ (:1, :2, etc.)</li><li><code>gst-launch-1.0 udpsrc port=... caps=&#34;application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)H264&#34; !</code> This receives the UDP stream</li><li><code>rtph264depay ! avdec_h264 ! videoconvert !</code> 	...decodes it,</li><li><code>autovideosink sync=false</code> 										...and starts an auto-detected compatible video sink</li></ul><p>Remember to install <em>gstreamer1.0-tools</em> or the equivalent package on the receiver.</p><figure><iframe width="200" height="150" src="https://www.youtube.com/embed/lr_3IoACqg4?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><figcaption>A demo of the solution presented here: 1280x720 virtual monitor on a Purism Librem 5. This video was done on a deliberately &#34;slow&#34; configuration (using an external, far away 20Mbps router, rather than point-to-point connectivity)</figcaption></figure><h2 id="how-to-test-pre-alpha">How to test (pre-alpha)</h2><p>Again, this is just the earliest working experiment. However, if you are not worried about this script probably <em>not</em> working in your case, here is the testing procedure:</p><ul><li>Download the script linked at the end of this post,</li><li>Establish a network connection, point to point (aka: &#34;computer to phone&#34;) if possible to minimize the switching and routing delay of far away access points. </li><li>Get the (local) destination IP address of the <u>receiver</u> via <code>ifconfig</code>, or an equivalent, and run the command on the <u>sender</u>:</li><li>Copy the &#34;receiving command&#34; from the console, and execute it on the receiving device, e.g. through SSH. You may need to adapt or remove the <em>DISPLAY=:0 </em>variable.</li></ul><h2 id="results">Results</h2><p>This solution, which should minimize overhead to reasonable levels, depends highly on the decoding capabilities of the receiving devices:</p><ul><li>On<em> CutiePi Tablet </em>(Raspberry Pi CM4), using open-source drivers, this tool worked perfectly</li><li>On a mainline Linux phone (Purism Librem 5), the virtual monitor experience was equally solid</li><li>On an Intel i5 tablet, this solution also worked flawlessly</li><li>However, on some older Qualcomm devices (tested on Snapdragon 820) this was seemingly <em>much </em>slower and glitchy. This is possibly due to the mainline Linux drivers for the Qualcomm Venus (V4L2) video decoder being immature, although replacing <code>avdec_h264</code> with <code>v4l2h264dec</code> in the command above should enable Venus-based decoding.  (– thanks <a href="https://emainline.gitlab.io/about.html">Yassine</a> for the suggestion)</li><li>On a Linux device with <em>no</em> video decoding or hardware acceleration, this will be inevitably slow</li></ul><figure><blockquote><p lang="en" dir="ltr">Found a way to have almost zero-latency, wireless video streaming on a virtual secondary screen, i.e.: using a mainline Linux tablet (with working GPU) as a portable second screen for your Linux desktop. </p>— TuxPhones (@tuxphones) <a href="https://twitter.com/tuxphones/status/1487841914149904397?ref_src=twsrc%5Etfw">January 30, 2022</a></blockquote>

<figcaption>Testing the virtual display script on an 8&#34; CutiePi Tablet (1280x720 virtual screen) in point-to-point mode</figcaption></figure><h2 id="generalizing">Generalizing</h2><p>Needless to say, the priority would be to find ways to generalize this procedure to a wider share of Linux devices:</p><ul><li><strong>KDE</strong>: This should already be possible at the moment. PipeWire and screencasting APIs are indeed present, and <em>Kwin</em> should support creation of virtual outputs to some extent</li><li><strong>Sway</strong>: there is <a href="https://github.com/any1/wayvnc/issues/7">an issue for this</a>, and it may become possible in the future</li><li> To <strong>X11-based desktops</strong>:  This is much simpler, although messier, than on Wayland. Creating virtual screens is supported, for example, by <a href="https://wiki.archlinux.org/title/Intel_GVT-g">Intel GPU drivers</a>, and screen capturing on this virtual sink is possible also without Mutter. </li><li>To (possibly?) <strong>even lower overhead:</strong> Using network via USB, rather than Wi-Fi as in the demo seen above. Removing or replace the x264 codec for a faster alternative, reducing the latency of encoding and decoding the stream at the price of possibly higher bandwidth and power consumption;</li><li>To Linux devices <strong>without GPU drivers and/or video acceleration </strong>(e.g. many Android phones with basic Linux support)<strong>: </strong>replacing x264 with a raw stream <em>might</em> work better for CPU rendering, but it will remain a relatively painful and power-consuming experience;</li><li>To <strong>many virtual screens:</strong> This works already as simply as launching several instances of the script on the transmitter, each pointing to a different target IPs and port. Provided that the wireless bandwidth is enough, and the higher power consumption is not a concern.</li></ul><h2 id="conclusion">Conclusion</h2><p>The road to a universal, usable solution is still long, but this is the first footprint of a working solution for the majority of devices and distributions. For the moment, a 100-line Python proof of concept is linked below.</p><figure><a href="https://gitlab.com/tuxphones/side-displays"><div><p>TuxPhones / Side Displays · GitLab</p><p>Secondary wireless screen experiments</p><p><img src="https://gitlab.com/assets/favicon-72a2cad5025aa931d6ea56c3201d1f18e68a8cd39788c7c80d5b2b82aa5143ef.png" alt=""/><span>GitLab</span></p></div><p><img src="https://gitlab.com/assets/twitter_card-570ddb06edf56a2312253c5872489847a0f385112ddbcd71ccfa1570febab5d2.jpg" alt=""/></p></a></figure>
        </section>

        
        <section>


        </section>
        

    </article>
</div></div>
  </body>
</html>
