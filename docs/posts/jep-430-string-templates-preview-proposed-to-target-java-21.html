<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.org/jeps/430">Original</a>
    <h1>JEP 430: String Templates (Preview) Proposed to Target Java 21</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="Summary">Summary</h2>
<p>Enhance the Java programming language with <em>string templates</em>. String templates complement Java&#39;s existing string literals and text blocks by coupling literal text with embedded expressions and processors to produce specialized results.  This is a <a href="http://openjdk.java.net/jeps/12">preview language feature and API</a>.</p>
<h2 id="Goals">Goals</h2>
<ul>
<li>
<p>Simplify the writing of Java programs by making it easy to express strings that include values computed at run time.</p>
</li>
<li>
<p>Enhance the readability of expressions that mix text and expressions, whether the text fits on a single source line (like string literals) or span several source lines (like text blocks).</p>
</li>
<li>
<p>Improve the security of Java programs that compose strings from user-provided values and pass them to other systems (e.g., building queries for databases) by supporting validation and transformation of both the template and the values of its embedded expressions.</p>
</li>
<li>
<p>Retain flexibility by allowing Java libraries to define the formatting syntax used in string templates.</p>
</li>
<li>
<p>Simplify the use of APIs that accept strings written in non-Java languages (e.g., SQL, XML, and JSON).</p>
</li>
<li>
<p>Enable the creation of non-String expressions derived from combining literal text and embedded expressions, without having to transit through a temporary string representation.</p>
</li>
</ul>
<h2 id="Non-Goals">Non-Goals</h2>
<ul>
<li>
<p>It is not a goal to introduce syntactic sugar for Java&#39;s string concatenation operator
(<code>+</code>), since that would circumvent the goal of validation.</p>
</li>
<li>
<p>It is not a goal to deprecate or remove the <code>StringBuilder</code> and <code>StringBuffer</code> classes, which have traditionally been used for complex or programmatic string composition.</p>
</li>
</ul>
<h2 id="Motivation">Motivation</h2>
<p>Developers routinely compose strings from a combination of literal text and expressions. Java provides several mechanisms for string composition, though unfortunately all have drawbacks.</p>
<ul>
<li>
<p>String concatenation with the <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-15.html#jls-15.18.1"><code>+</code> operator</a> produces hard-to-read code:</p>
<pre><code>String s = x + &#34; plus &#34; + y + &#34; equals &#34; + (x + y);</code></pre>
</li>
<li>
<p><code>StringBuilder</code> is verbose:</p>
<pre><code>String s = new StringBuilder()
               .append(x)
               .append(&#34; plus &#34;)
               .append(y)
               .append(&#34; equals &#34;)
               .append(x + y)
               .toString();</code></pre>
</li>
<li>
<p><code>String::format</code> and <code>String::formatted</code> separate the format string from the parameters, inviting arity and type mismatches:</p>
<pre><code>String s = String.format(&#34;%2$d plus %1$d equals %3$d&#34;, x, y, x + y);
  String t = &#34;%2$d plus %1$d equals %3$d&#34;.formatted(x, y, x + y);</code></pre>
</li>
<li>
<p><code>java.text.MessageFormat</code> requires too much ceremony and uses an unfamiliar syntax in the
format string:</p>
<pre><code>MessageFormat mf = new MessageFormat(&#34;{0} plus {1} equals {2}&#34;);
  String s = mf.format(x, y, x + y);</code></pre>
</li>
</ul>
<h3 id="String-interpolation">String interpolation</h3>
<p>Many programming languages offer <em>string interpolation</em> as an alternative to string concatenation. Typically, this takes the form of a string literal that contains embedded expressions as well as literal text. Embedding expressions <em>in situ</em> means that readers can easily discern the intended result. At run time, the embedded expressions are replaced with their (stringified) values — the values are said to be <em>interpolated</em> into the string. Here are some examples of interpolation in other languages:</p>
<pre><code>JavaScript     `${x} plus ${y} equals ${x + y}`
C#             $&#34;{x} plus {y} equals {x + y}&#34;
Visual Basic   $&#34;{x} plus {y} equals {x + y}&#34;
Scala          f&#34;$x%d plus $y%d equals ${x + y}%d&#34;
Python         f&#34;{x} plus {y} equals {x + y}&#34;
Ruby           &#34;#{x} plus #{y} equals #{x + y}&#34;
Groovy         &#34;$x plus $y equals ${x + y}&#34;
Kotlin         &#34;$x plus $y equals ${x + y}&#34;
Swift          &#34;\(x) plus \(y) equals \(x + y)&#34;</code></pre>
<p>Some of these languages enable interpolation for all string literals while others require interpolation to be enabled when desired, for example by prefixing the literal&#39;s opening delimiter with <code>$</code> or <code>f</code>. The syntax of embedded expressions also varies but often involves characters such as <code>$</code> or <code>{ }</code>, which means that those characters cannot appear literally unless they are escaped.</p>
<p>Not only is interpolation more convenient than concatenation when writing code, it also offers greater clarity when reading code. The clarity is especially striking with larger strings. For example, in JavaScript:</p>
<pre><code>const title = &#34;My Web Page&#34;;
const text  = &#34;Hello, world&#34;;

var html = `&lt;html&gt;
              &lt;head&gt;
                &lt;title&gt;${title}&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
                &lt;p&gt;${text}&lt;/p&gt;
              &lt;/body&gt;
            &lt;/html&gt;`;</code></pre>
<h3 id="String-interpolation-is-dangerous">String interpolation is dangerous</h3>
<p>Unfortunately, the convenience of interpolation has a downside: It is easy to construct strings that will be interpreted by other systems but which are dangerously incorrect in those systems.</p>
<p>Strings that hold SQL statements, HTML/XML documents, JSON snippets, shell scripts, and natural-language text all need to be validated and sanitized according to domain-specific rules. Since the Java programming language cannot possibly enforce all such rules, it is up to developers using interpolation to validate and sanitize. Typically, this means remembering to wrap embedded expressions in calls to <code>escape</code> or <code>validate</code> methods, and relying on IDEs or <a href="https://checkerframework.org/manual/">static analysis tools</a> to help to validate the literal text.</p>
<p>Interpolation is especially dangerous for SQL statements because it can lead to <a href="https://en.wikipedia.org/wiki/SQL_injection">injection attacks</a>. For example, consider this hypothetical Java code with the embedded expression <code>${name}</code>:</p>
<pre><code>String query = &#34;SELECT * FROM Person p WHERE p.last_name = &#39;${name}&#39;&#34;;
ResultSet rs = connection.createStatement().executeQuery(query);</code></pre>
<p>If <code>name</code> had the troublesome value</p>
<pre><code>Smith&#39; OR p.last_name &lt;&gt; &#39;Smith</code></pre>
<p>then the query string would be</p>
<pre><code>SELECT * FROM Person p WHERE p.last_name = &#39;Smith&#39; OR p.last_name &lt;&gt; &#39;Smith&#39;</code></pre>
<p>and the code would select all rows, potentially exposing confidential information. Composing a query string with simple-minded interpolation is just as unsafe as composing it with traditional concatenation:</p>
<pre><code>String query = &#34;SELECT * FROM Person p WHERE p.last_name = &#39;&#34; + name + &#34;&#39;&#34;;</code></pre>
<h3 id="Can-we-do-better?">Can we do better?</h3>
<p>For Java, we would like to have a string composition feature that achieves the clarity of interpolation but achieves a safer result out-of-the-box, perhaps trading off a small amount of convenience to gain a large amount of safety.</p>
<p>For example, when composing SQL statements any quotes in the values of embedded expressions must be escaped, and the string overall must have balanced quotes. Given the troublesome value of <code>name</code> shown above, the query that should be composed is a safe one:</p>
<pre><code>SELECT * FROM Person p WHERE p.last_name = &#39;\&#39;Smith\&#39; OR p.last_name &lt;&gt; \&#39;Smith\&#39;&#39;</code></pre>
<p>Almost every use of string interpolation involves structuring the string to fit some kind of template: A SQL statement usually follows the template <code>SELECT ... FROM ... WHERE ...</code>, an HTML document follows <code>&lt;html&gt; ... &lt;/html&gt;</code>, and even a message in a natural language follows a template that intersperses dynamic values (e.g., a username) amongst literal text. Each kind of template has rules for validation and transformation, such as &#34;escape all quotes&#34; for SQL statements, &#34;allow only legal character entities&#34; for HTML documents, and &#34;localize to the language configured in the OS&#34; for natural-language messages.</p>
<p>Ideally a string&#39;s template could be expressed directly in the code, as if annotating the string, and the Java runtime would apply template-specific rules to the string automatically. The result would be SQL statements with escaped quotes, HTML documents with no illegal entities, and boilerplate-free message localization. Composing a string from a template would relieve developers of having to laboriously escape each embedded expression, call <code>validate()</code> on the whole string, or use <code>java.util.ResourceBundle</code> to look up a localized string.</p>
<p>For another example, a developer might construct a string denoting a JSON document and then feed it to a JSON parser in order to obtain a strongly-typed <code>JSONObject</code>:</p>
<pre><code>String name    = &#34;Joan Smith&#34;;
String phone   = &#34;555-123-4567&#34;;
String address = &#34;1 Maple Drive, Anytown&#34;;
String json = &#34;&#34;&#34;
    {
        &#34;name&#34;:    &#34;%s&#34;,
        &#34;phone&#34;:   &#34;%s&#34;,
        &#34;address&#34;: &#34;%s&#34;
    }
    &#34;&#34;&#34;.formatted(name, phone, address);

JSONObject doc = JSON.parse(json);
... doc.entrySet().stream().map(...) ...</code></pre>
<p>Ideally the JSON structure of the string could be expressed directly in the code, and the Java runtime would transform the string into a <code>JSONObject</code> automatically. The manual detour through the parser would not be necessary.</p>
<p>In summary, we could improve the readability and reliability of almost every Java program if we had a first-class, template-based mechanism for composing strings. Such a feature would offer the benefits of interpolation, as seen in other programming languages, but would be less prone to introducing security vulnerabilities. It would also reduce the ceremony of working with libraries that take complex input as strings.</p>
<h2 id="Description">Description</h2>
<p>A <em>template expression</em> is a new kind of expression in the Java programming language. A template expression can perform string interpolation, but is also programmable in a way that helps developers compose strings safely and efficiently. In addition, a template expression is not limited to composing strings — it can turn structured text into any kind of object, according to domain-specific rules.</p>
<p>Syntactically, a template expression resembles a string literal with a prefix. There is a template expression on the second line of this code:</p>
<pre><code>String name = &#34;Joan&#34;;
String info = STR.&#34;My name is \{name}&#34;;
assert info.equals(&#34;My name is Joan&#34;);   // true</code></pre>
<p>The template expression <code>STR.&#34;My name is \{name}&#34;</code> consists of:</p>
<ol>
<li>A <em>template processor</em> (<code>STR</code>);</li>
<li>A dot character (U+002E), as seen in other kinds of expressions; and</li>
<li>A <em>template</em> (<code>&#34;My name is \{name}&#34;</code>) which contains an <em>embedded expression</em> (<code>\{name}</code>).</li>
</ol>
<p>When a template expression is evaluated at run time, its template processor combines the literal text in the template with the values of the embedded expressions in order to produce a result. The result of the template processor, and thus the result of evaluating the template expression, is often a <code>String</code> — though not always.</p>
<h3 id="The-STR-template-processor">The <code>STR</code> template processor</h3>
<p><code>STR</code> is a template processor defined in the Java library. It performs string interpolation by replacing each embedded expression in the template with the (stringified) value of that expression. The result of evaluating a template expression which uses <code>STR</code> is a <code>String</code>; e.g., <code>&#34;My name is Joan&#34;</code>.</p>
<p>In everyday conversation, developers are likely to use the term &#34;template&#34; when referring to either the whole or part of a template expression. This informal usage is reasonable as long as the template processor of a particular template expression is not mixed up with the processor argument of the same template expression.</p>
<p><code>STR</code> is a <code>public</code> <code>static</code> <code>final</code> field that is automatically imported in every Java source file.</p>
<p>Here are more examples of template expressions that use the <code>STR</code> template processor. The symbol <code>|</code> in the left margin means that the line shows the value of the previous statement, similar to <a href="https://docs.oracle.com/en/java/javase/18/docs/specs/man/jshell.html">jshell</a>.</p>
<pre><code>// Embedded expressions can be strings
String firstName = &#34;Bill&#34;;
String lastName  = &#34;Duck&#34;;
String fullName  = STR.&#34;\{firstName} \{lastName}&#34;;
| &#34;Bill Duck&#34;
String sortName  = STR.&#34;\{lastName}, \{firstName}&#34;;
| &#34;Duck, Bill&#34;

// Embedded expressions can perform arithmetic
int x = 10, y = 20;
String s = STR.&#34;\{x} + \{y} = \{x + y}&#34;;
| &#34;10 + 20 = 30&#34;

// Embedded expressions can invoke methods and access fields
String s = STR.&#34;You have a \{getOfferType()} waiting for you!&#34;;
| &#34;You have a gift waiting for you!&#34;
String t = STR.&#34;Access at \{req.date} \{req.time} from \{req.ipAddress}&#34;;
| &#34;Access at 2022-03-25 15:34 from 8.8.8.8&#34;</code></pre>
<p>To aid refactoring, double-quote characters can be used inside embedded expressions without escaping them as <code>\&#34;</code>. This means that an embedded expression can appear in a template expression exactly as it would appear outside the template expression, easing the switch from <code>+</code> to template expressions. For example:</p>
<pre><code>String filePath = &#34;tmp.dat&#34;;
File   file     = new File(filePath);
String old = &#34;The file &#34; + filePath + &#34; &#34; + file.exists() ? &#34;does&#34; : &#34;does not&#34; + &#34; exist&#34;;
String msg = STR.&#34;The file \{filePath} \{file.exists() ? &#34;does&#34; : &#34;does not&#34;} exist&#34;;
| &#34;The file tmp.dat does exist&#34; or &#34;The file tmp.dat does not exist&#34;</code></pre>
<p>To aid readability, an embedded expression can be spread over multiple lines in the source file. (This does not introduce newlines into the result.) The value of the embedded expression is interpolated into the result at the position of the <code>\</code> of the embedded expression; the template is then considered to continue on the same line as the <code>\</code>. For example:</p>
<pre><code>String time = STR.&#34;The time is \{
    // The java.time.format package is very useful
    DateTimeFormatter
      .ofPattern(&#34;HH:mm:ss&#34;)
      .format(LocalTime.now())
} right now&#34;;
| &#34;The time is 12:34:56 right now&#34;</code></pre>
<p>A template expression may have one or more embedded expressions and there is no limit to how many. The embedded expressions are evaluated from left to right, just like the arguments in a method invocation expression. For example:</p>
<pre><code>// Embedded expressions can be postfix increment expressions
int index = 0;
String data = STR.&#34;\{index++}, \{index++}, \{index++}, \{index++}&#34;;
| &#34;0, 1, 2, 3&#34;</code></pre>
<p>Any Java expression can be used as an embedded expression — even a template expression. For example:</p>
<pre><code>// Embedded expression is a (nested) template expression
String[] fruit = { &#34;apples&#34;, &#34;oranges&#34;, &#34;peaches&#34; };
String s = STR.&#34;\{fruit[0]}, \{STR.&#34;\{fruit[1]}, \{fruit[2]}&#34;}&#34;;
| &#34;apples, oranges, peaches&#34;</code></pre>
<p>Here, the template expression <code>STR.&#34;\{fruit[1]}, \{fruit[2]}&#34;</code> is embedded in the template of another template expression. This code is difficult to read due to the abundance of <code>&#34;</code>, <code>\</code>, and <code>{ }</code> characters, so it would be better to format it for easier readability:</p>
<pre><code>String s = STR.&#34;\{fruit[0]}, \{
    STR.&#34;\{fruit[1]}, \{fruit[2]}&#34;
}&#34;;</code></pre>
<p>Alternatively, since the embedded expression has no side effects, it could be refactored into a separate template expression:</p>
<pre><code>String tmp = STR.&#34;\{fruit[1]}, \{fruit[2]}&#34;;
String s = STR.&#34;\{fruit[0]}, \{tmp}&#34;;</code></pre>
<h3 id="Multi-line-template-expressions">Multi-line template expressions</h3>
<p>The template of a template expression can span multiple lines of source code, using a syntax similar to that of <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.6">text blocks</a>. (We saw an embedded expression spanning multiple lines above, but the template which contained the embedded expression was logically one line.)</p>
<p>Here are examples of template expressions denoting HTML text, JSON text, and a zone form, all spread over multiple lines:</p>
<pre><code>String title = &#34;My Web Page&#34;;
String text  = &#34;Hello, world&#34;;
String html = STR.&#34;&#34;&#34;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;\{title}&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;\{text}&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
        &#34;&#34;&#34;;
| &#34;&#34;&#34;
| &lt;html&gt;
|   &lt;head&gt;
|     &lt;title&gt;My Web Page&lt;/title&gt;
|   &lt;/head&gt;
|   &lt;body&gt;
|     &lt;p&gt;Hello, world&lt;/p&gt;
|   &lt;/body&gt;
| &lt;/html&gt;
| &#34;&#34;&#34;

String name    = &#34;Joan Smith&#34;;
String phone   = &#34;555-123-4567&#34;;
String address = &#34;1 Maple Drive, Anytown&#34;;
String json = STR.&#34;&#34;&#34;
    {
        &#34;name&#34;:    &#34;\{name}&#34;,
        &#34;phone&#34;:   &#34;\{phone}&#34;,
        &#34;address&#34;: &#34;\{address}&#34;
    }
    &#34;&#34;&#34;;
| &#34;&#34;&#34;
| {
|     &#34;name&#34;:    &#34;Joan Smith&#34;,
|     &#34;phone&#34;:   &#34;555-123-4567&#34;,
|     &#34;address&#34;: &#34;1 Maple Drive, Anytown&#34;
| }
| &#34;&#34;&#34;

record Rectangle(String name, double width, double height) {
    double area() {
        return width * height;
    }
}
Rectangle[] zone = new Rectangle[] {
        new Rectangle(&#34;Alfa&#34;, 17.8, 31.4),
        new Rectangle(&#34;Bravo&#34;, 9.6, 12.4),
        new Rectangle(&#34;Charlie&#34;, 7.1, 11.23),
    };
String form = STR.&#34;&#34;&#34;
        Description  Width  Height  Area
        \{zone[0].name}  \{zone[0].width}  \{zone[0].height}     \{zone[0].area()}
        \{zone[1].name}  \{zone[1].width}  \{zone[1].height}     \{zone[1].area()}
        \{zone[2].name}  \{zone[2].width}  \{zone[2].height}     \{zone[2].area()}
        Total \{zone[0].area() + zone[1].area() + zone[2].area()}
          &#34;&#34;&#34;;
| &#34;&#34;&#34;
| Description  Width  Height  Area
| Alfa  17.8  31.4     558.92
| Bravo  9.6  12.4     119.03999999999999
| Charlie  7.1  11.23     79.733
| Total 757.693
| &#34;&#34;&#34;
| &#34;&#34;&#34;</code></pre>
<h3 id="The-FMT-template-processor">The <code>FMT</code> template processor</h3>
<p><code>FMT</code> is another template processor defined in the Java library. <code>FMT</code> is like <code>STR</code> in that it performs interpolation, but it also interprets format specifiers which appear to the left of embedded expressions. The format specifiers are the same as those defined in <code>java.util.Formatter</code>. Here is the zone form example, tidied up by format specifiers in the template:</p>
<pre><code>record Rectangle(String name, double width, double height) {
    double area() {
        return width * height;
    }
}
Rectangle[] zone = new Rectangle[] {
        new Rectangle(&#34;Alfa&#34;, 17.8, 31.4),
        new Rectangle(&#34;Bravo&#34;, 9.6, 12.4),
        new Rectangle(&#34;Charlie&#34;, 7.1, 11.23),
    };
String form = FMT.&#34;&#34;&#34;
        Description     Width    Height     Area
        %-12s\{zone[0].name}  %7.2f\{zone[0].width}  %7.2f\{zone[0].height}     %7.2f\{zone[0].area()}
        %-12s\{zone[1].name}  %7.2f\{zone[1].width}  %7.2f\{zone[1].height}     %7.2f\{zone[1].area()}
        %-12s\{zone[2].name}  %7.2f\{zone[2].width}  %7.2f\{zone[2].height}     %7.2f\{zone[2].area()}
        \{&#34; &#34;.repeat(28)} Total %7.2f\{zone[0].area() + zone[1].area() + zone[2].area()}
          &#34;&#34;&#34;;
| &#34;&#34;&#34;
| Description     Width    Height     Area
| Alfa            17.80    31.40      558.92
| Bravo            9.60    12.40      119.04
| Charlie          7.10    11.23       79.73
|                              Total  757.69
| &#34;&#34;&#34;</code></pre>
<h3 id="Template-expressions">Template expressions</h3>
<p>The template expression <code>STR.&#34;...&#34;</code> is a shortcut for invoking the <code>process</code> method of the <code>STR</code> template processor. That is, the now-familiar example:</p>
<pre><code>String name = &#34;Joan&#34;;
String info = STR.&#34;My name is \{name}&#34;;</code></pre>
<p>is a shortcut for:</p>
<pre><code>String name = &#34;Joan&#34;;
StringTemplate st = RAW.&#34;My name is \{name}&#34;;
String info = STR.process(st);</code></pre>
<p>The design of template expressions deliberately makes it impossible to go directly from a string literal or text block with embedded expressions to a <code>String</code> with the expressions&#39; values interpolated. This prevents dangerously incorrect strings from spreading through the program. The string literal is processed by a template processor, which has explicit responsibility for safely interpolating and validating a result, <code>String</code> or otherwise. Thus if a developer forgets to use a template processor such as <code>STR</code>, <code>RAW</code> or <code>FMT</code> then a compile-time error occurs:</p>
<pre><code>String name = &#34;Joan&#34;;
String info = &#34;My name is \{name}&#34;;
| error: processor missing from template expression</code></pre>
<p>When the unprocessed template is required, the standard <code>RAW</code> template processor can be use to produce a <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> object.</p>
<pre><code>String name = &#34;Joan&#34;;
StringTemplate st = RAW.&#34;My name is \{name}&#34;;</code></pre>
<h3 id="Syntax-and-semantics">Syntax and semantics</h3>
<p>The four kinds of template in a template expression are shown by its grammar, which starts at <code>TemplateExpression</code>:</p>
<pre><code>TemplateExpression:
  TemplateProcessor . TemplateArgument

TemplateProcessor:
  Expression

TemplateArgument:
  Template
  StringLiteral
  TextBlock

Template:
  StringTemplate
  TextBlockTemplate

StringTemplate:
  Resembles a StringLiteral but has one or more embedded expressions,
    and can be spread over multiple lines of source code

TextBlockTemplate:
  Resembles a TextBlock but has one or more embedded expressions</code></pre>
<p>The Java compiler scans the term <code>&#34;...&#34;</code> and determines whether to parse it as a <code>StringLiteral</code> or a <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> based on the presence of embedded expressions. The compiler similarly scans the term <code>&#34;&#34;&#34;...&#34;&#34;&#34;</code> and determines whether to parse it as a <code>TextBlock</code> or a <code>TextBlockTemplate</code>. We refer uniformly to the <code>...</code> portion of these terms as the <em>content</em> of a <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.5-200">string literal</a>, string template, <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.6-300">text block</a>, or text block template.</p>
<p>We strongly encourage IDEs to visually distinguish a string template from a string literal, and a text block template from a text block. Within the content of a string template or text block template, IDEs should visually distinguish an embedded expression from literal text.</p>
<p>The Java programming language distinguishes string literals from string templates, and text blocks from text block templates, primarily because the type of a string template or text block template is not the familiar <code>String</code>. The type of a string template or text block template is <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a>, which is an interface, and <code>String</code> does not implement <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a>.  When the template of a template expression is a string literal or a text block, therefore, the Java compiler automatically transforms the <code>String</code> denoted by the template into a <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> with no embedded expressions.</p>
<p>At run time, a template expression is evaluated as follows:</p>
<ol>
<li>The expression to the left of the dot is evaluated to obtain an instance of <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a>,</li>
<li>The expression to the right of the dot is evaluated to obtain an instance of
<a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> (which, if the expression was a <code>String</code> will have been
automatically transformed to an instance of <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a>)</li>
<li>The <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> instance is passed to the <code>process</code> method of the <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> instance, which composes a result.</li>
</ol>
<p>The type of a template expression is, thus, the return type of the <code>process</code> method of the <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> instance.</p>
<p>The <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> and <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> APIs, along with related APIs, are declared in the new package <a href="https://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/package-summary.html"><code>java.lang.template</code></a>.</p>
<h3 id="String-literals-inside-template-expressions">String literals inside template expressions</h3>
<p>The ability to use a string literal or a text block as a template improves the flexibility of template expressions. Developers can write template expressions that initially have placeholder text in a string literal, such as</p>
<pre><code>String s = STR.&#34;Welcome to your account&#34;;
| &#34;Welcome to your account&#34;</code></pre>
<p>and gradually embed expressions into the text to create a string template without changing any delimiters or inserting any special prefixes:</p>
<pre><code>String s = STR.&#34;Welcome, \{user.firstName()}, to your account \{user.accountNumber()}&#34;;
| &#34;Welcome, Lisa, to your account 12345&#34;</code></pre>
<h3 id="User-defined-template-processors">User-defined template processors</h3>
<p>Earlier we saw the template processors <code>STR</code> and <code>FMT</code>, which make it look as if a template processor is an object accessed via a field. That is useful shorthand, but it is more accurate to say that a template processor is a object which provides the functional interface <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a>. In particular, the object&#39;s class implements the single abstract method of <code>ValidatingProcessor</code>, <code>process</code>, which takes a <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> and returns an object. A field such as <code>STR</code> merely stores an instance of such a class. (The actual class whose instance is stored in <code>STR</code> has an <code>process</code> method that performs a stateless interpolation for which a singleton instance is suitable, hence the upper-case field name.)</p>
<p>Developers can easily create template processors for use in template expressions. However, before discussing how to create a template processor, it is necessary to discuss the class <code>StringTemplate</code>.</p>
<p>An instance of <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> represents the string template or text block template that appears as the template in a template expression. Consider this code:</p>
<pre><code>int x = 10, y = 20;
StringTemplate st = RAW.&#34;\{x} plus \{y} equals \{x + y}&#34;;
String s = st.toString();
| StringTemplate{ fragments = [ &#34;&#34;, &#34; plus &#34;, &#34; equals &#34;, &#34;&#34; ], values = [10, 20, 30] }</code></pre>
<p>The result is, perhaps, a surprise. Where is the interpolation of <code>10</code>, <code>20</code>, and <code>30</code> into the text <code>&#34; plus &#34;</code> and <code>&#34; equals &#34;</code>? Recall that one of the goals of template expressions is to provide secure string composition. Having <code>StringTemplate::toString</code> simply concatenate <code>&#34;10&#34;</code>, <code>&#34; plus &#34;</code>, <code>&#34;20&#34;</code>, <code>&#34; equals &#34;</code>, and <code>&#34;30&#34;</code> into a <code>String</code> would circumvent that goal. Instead, the <code>toString</code> method renders the two useful parts of a <code>StringTemplate</code>:</p>
<ul>
<li>The text <em>fragments</em>, <code>&#34;&#34;, &#34; plus &#34;, &#34; equals &#34;, &#34;&#34;</code>, and</li>
<li>The <em>values</em>, <code>10</code>, <code>20</code>, <code>30</code>.</li>
</ul>
<p>The <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> class exposes these parts directly:</p>
<ul>
<li>
<p><code>StringTemplate::fragments</code> returns a list of the text fragments coming before and after the embedded expressions in the string template or text block template:</p>
<pre><code>int x = 10, y = 20;
  StringTemplate st = RAW.&#34;\{x} plus \{y} equals \{x + y}&#34;;
  List&lt;String&gt; fragments = st.fragments();
  String result = String.join(&#34;\\{}&#34;, fragments);
  | &#34;\{} plus \{} equals \{}&#34;</code></pre>
</li>
<li>
<p><code>StringTemplate::values</code> returns a list of the values produced by evaluating the embedded expressions in the order they appear in the source code. In the current example, this is equivalent to <code>List.of(x, y, x + y)</code>.</p>
<pre><code>int x = 10, y = 20;
  StringTemplate st = RAW.&#34;\{x} plus \{y} equals \{x + y}&#34;;
  List&lt;Object&gt; values = st.values();
  | [10, 20, 30]</code></pre>
</li>
</ul>
<p>The <code>fragments()</code> of a <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a> are constant across all evaluations of a template expression, while <code>values()</code> is computed fresh for each evaluation. For example:</p>
<pre><code>int y = 20;
for (int x = 0; x &lt; 3; x++) {
    StringTemplate st = RAW.&#34;\{x} plus \{y} equals \{x + y}&#34;;
    System.out.println(st);
}
| [&#34;Adding &#34;, &#34; and &#34;, &#34; yields &#34;, &#34;&#34;](0, 20, 20)
| [&#34;Adding &#34;, &#34; and &#34;, &#34; yields &#34;, &#34;&#34;](1, 20, 21)
| [&#34;Adding &#34;, &#34; and &#34;, &#34; yields &#34;, &#34;&#34;](2, 20, 22)</code></pre>
<p>Using <code>fragments()</code> and <code>values()</code>, it is straightforward to write an interpolating template processor. For brevity, the following example does not show code that implements <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/TemplateProcessor.html"><code>TemplateProcessor</code></a> directly; rather, it implements a useful subinterface of <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/TemplateProcessor.html"><code>TemplateProcessor</code></a>, namely <a href="https://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringProcessor.html"><code>StringProcessor</code></a>, that returns a <code>String</code>.</p>
<pre><code>StringProcessor INTER = (StringTemplate st) -&gt; {
    String placeHolder = &#34;•&#34;;
    String stencil = String.join(placeHolder, st.fragments());
    for (Object value : st.values()) {
        String v = String.valueOf(value);
        stencil = stencil.replaceFirst(placeHolder, v);
    }
    return stencil;
};

int x = 10, y = 20;
String s = INTER.&#34;\{x} plus \{y} equals \{x + y}&#34;;
| 10 plus 20 equals 30</code></pre>
<p>A template processor always executes at run time, never at compile time. It is not possible for a template processor to perform compile-time processing on the template. Moreover, it is not possible for a template processor to obtain, from a <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringTemplate.html"><code>StringTemplate</code></a>,the exact characters which appear in a template in source code; only the values of the embedded expressions are available, not the embedded expressions themselves.</p>
<h3 id="Efficient-template-processors">Efficient template processors</h3>
<p>We can make the interpolating template processor shown earlier more efficient by building up a result from fragments and values, taking advantage of the fact that every template represents an alternating sequence of fragments and values:</p>
<pre><code>StringProcessor INTER = (StringTemplate st) -&gt; {
    StringBuilder sb = new StringBuilder();
    Iterator&lt;String&gt; fragIter = st.fragments().iterator();
    for (Object value : st.values()) {
        sb.append(fragIter.next());
        sb.append(value);
    }
    sb.append(fragIter.next());
    return sb.toString();
};

int x = 10, y = 20;
String s = INTER.&#34;\{x} plus \{y} equals \{x + y}&#34;;
| 10 and 20 equals 30</code></pre>
<p>The auxiliary method <code>StringTemplate::interpolate</code> does the same thing as the code above, successively concatenating fragments and values, thus:</p>
<pre><code>StringProcessor INTER = StringTemplate::interpolate;</code></pre>
<p>Given that the values of embedded expressions are usually unpredictable, it is generally not worthwhile for a template processor to intern the <code>String</code> that it produces. For example, <code>STR</code> does not intern its result. However, it is straightforward to create an interning, interpolating template processor if needed:</p>
<pre><code>StringProcessor INTERN = st -&gt; st.interpolate().intern();</code></pre>
<h3 id="Run-time-validation">Run-time validation</h3>
<p>All the examples so far have created template processors that implement the <a href="https://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringProcessor.html"><code>StringProcessor</code></a> interface. Such template processors always return a <code>String</code> and perform no validation at run time, so template expressions which use them will always evaluate successfully.</p>
<p>In contrast, a template processor that implements the <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> interface is fully general: It may return objects of any type, not just <code>String</code>, and it may validate the string template and the values of embedded expressions, throwing a checked or unchecked exception if validation fails. By throwing a checked exception, the template processor forces developers who use it in template expressions to handle invalid string composition with a <code>try-catch</code> statement.</p>
<p>The relationship between <a href="https://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/StringProcessor.html"><code>StringProcessor</code></a> and <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> is as follows:</p>
<pre><code>public interface ValidatingProcessor&lt;R, E extends Throwable&gt; {
    R process(StringTemplate stringTemplate) throws E;
}

public interface TemplateProcessor&lt;R&gt; extends ValidatingProcessor&lt;R, RuntimeException&gt; {}

public interface StringProcessor extends TemplateProcessor&lt;String&gt; {}</code></pre>
<p>Note that the second type parameter of <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a>, <code>E</code>, is the type of the exception thrown by the <code>process</code> method. A non-validating template processor will usually be declared to supply <code>RuntimeException</code> as the type argument for <code>E</code>. This allows developers to use the processor in template expressions without <code>try-catch</code> statements. For convenience, <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> has a subinterface, <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/TemplateProcessor.html"><code>TemplateProcessor</code></a>, which already supplies <code>RuntimeException</code> as the type argument.</p>
<p>Here is an example of a template processor, <code>JSON</code>. It implements
<code>TemplateProcessor&lt;JSONObject&gt;</code> and therefore returns instances of <code>JSONObject</code>. It uses
the auxiliary method <code>StringTemplate::interpolate</code>, shown earlier.</p>
<pre><code>TemplateProcessor&lt;JSONObject&gt; JSON = (StringTemplate st) -&gt; new JSONObject(st.interpolate());

String name    = &#34;Joan Smith&#34;;
String phone   = &#34;555-123-4567&#34;;
String address = &#34;1 Maple Drive, Anytown&#34;;
JSONObject doc = JSON.&#34;&#34;&#34;
    {
        &#34;name&#34;:    &#34;\{name}&#34;,
        &#34;phone&#34;:   &#34;\{phone}&#34;,
        &#34;address&#34;: &#34;\{address}&#34;
    };
    &#34;&#34;&#34;;</code></pre>
<p>A developer who uses the <code>JSON</code> template processor never sees the <code>String</code> produced by <code>st.interpolate()</code>. Moreover, since the text block template is constant, a more advanced template processor could compile the template into a <code>JSONObject</code> with placeholder values, cache that result, and then at each evaluation inject the field values into a fresh deep copy of that cached <code>JSONObject</code>. There would be no intermediate <code>String</code> anywhere.</p>
<p>A template processor that throws checked exceptions must implement <a href="http://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/lang/template/ValidatingProcessor.html"><code>ValidatingProcessor</code></a> directly. For example, here is a template processor that expects a JSON document to be surrounded by <code>{ }</code>, throwing a checked exception at run time otherwise:</p>
<pre><code>class JSONException extends Exception {}

ValidatingProcessor&lt;JSONObject, JSONException&gt; JSON_VALIDATE = (StringTemplate st) -&gt; {
    String stripped = st.interpolate().strip();
    if (!stripped.startsWith(&#34;{&#34;) || !stripped.endsWith(&#34;}&#34;)) {
        throws new JSONException(&#34;Missing brace&#34;);
    }
    return new JSONObject(stripped);
};

String name    = &#34;Joan Smith&#34;;
String phone   = &#34;555-123-4567&#34;;
String address = &#34;1 Maple Drive, Anytown&#34;;
try {
    JSONObject doc = JSON_VALIDATE.&#34;&#34;&#34;
        {
            &#34;name&#34;:    &#34;\{name}&#34;,
            &#34;phone&#34;:   &#34;\{phone}&#34;,
            &#34;address&#34;: &#34;\{address}&#34;
        };
        &#34;&#34;&#34;;
} catch (JSONException ex) {
    ...
}</code></pre>
<h3 id="Safely-composing-and-executing-database-queries">Safely composing and executing database queries</h3>
<p>The template processor below, <code>QueryProcessor</code>, first creates a query string from a string template. It then creates a <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.sql/java/sql/PreparedStatement.html"><code>PreparedStatement</code></a> from that query string and sets its parameters to the values of the embedded expressions. Finally, the processor executes the <code>PreparedStatement</code> to obtain a <code>ResultSet</code>.</p>
<pre><code>record QueryProcessor(Connection conn)
  implements ValidatingProcessor&lt;ResultSet, SQLException&gt; {
    public ResultSet process(StringTemplate st) throws SQLException {
        // 1. Replace StringTemplate placeholders with PreparedStatement placeholders
        String query = String.join(&#34;?&#34;, st.fragments());

        // 2. Create the PreparedStatement on the connection
        PreparedStatement ps = conn.prepareStatement(query);

        // 3. Set parameters of the PreparedStatement
        int index = 1;
        for (Object value : st.values()) {
            switch (value) {
                case Integer i -&gt; ps.setInt(index++, i);
                case Float f   -&gt; ps.setFloat(index++, f);
                case Double d  -&gt; ps.setDouble(index++, d);
                case Boolean b -&gt; ps.setBoolean(index++, b);
                default        -&gt; ps.setString(index++, String.valueOf(value));
            }
        }

        // 4. Execute the PreparedStatement, returning a ResultSet
        return ps.executeQuery();
    }
}</code></pre>
<p>If we instantiate the <code>QueryProcessor</code> for a specific <code>Connection</code>:</p>
<pre><code>ValidatingProcessor&lt;ResultSet, SQLException&gt; DB = new QueryProcessor(...);</code></pre>
<p>then instead of the unsafe, injection-attack-prone code</p>
<pre><code>String query = &#34;SELECT * FROM Person p WHERE p.last_name = &#39;&#34; + name + &#34;&#39;&#34;;
ResultSet rs = conn.createStatement().executeQuery(query);</code></pre>
<p>we can write the more secure and more readable code</p>
<pre><code>ResultSet rs = DB.&#34;SELECT * FROM Person p WHERE p.last_name = \{name}&#34;;</code></pre>
<h3 id="Localized-formatter-processors">Localized formatter processors</h3>
<p><code>FMT</code>, shown earlier, is an instance of the format-aware template processor class <a href="https://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/util/FormatProcessor.html"><code>java.util.FormatProcessor</code></a>. That processor uses the default locale, but it is straightforward to create a variant for a different locale. For example, this code creates a format-aware template processor for the Thai locale, and stores it in the <code>THAI</code> variable:</p>
<pre><code>Locale thaiLocale = Locale.forLanguageTag(&#34;th-TH-u-nu-thai&#34;);
FormatProcessor THAI = new FormatProcessor(thaiLocale);
for (int i = 1; i &lt;= 10000; i *= 10) {
    String s = THAI.&#34;This answer is %5d\{i}&#34;;
    System.out.println(s);
}
| This answer is     ๑
| This answer is    ๑๐
| This answer is   ๑๐๐
| This answer is  ๑๐๐๐
| This answer is ๑๐๐๐๐</code></pre>
<h3 id="Simplifying-message-localization">Simplifying message localization</h3>
<p>Here is a template processor that simplifies working with resource bundles. For a given locale, it maps a string to a corresponding property in a resource bundle:</p>
<pre><code>record LocalizationProcessor(Locale locale) implements StringProcessor {
    public String process(StringTemplate st) {
        ResourceBundle resource = ResourceBundle.getBundle(&#34;resources&#34;, locale);
        String stencil = String.join(&#34;_&#34;, st.fragments());
        String msgFormat = resource.getString(stencil.replace(&#39; &#39;, &#39;.&#39;));
        return MessageFormat.format(msgFormat, st.values().toArray());
    }
}</code></pre>
<p>Assuming there is a property-file resource bundle for each locale:</p>
<pre><code># resources_en_CA.properties file
no.suitable._.found.for._(_)=\
    no suitable {0} found for {1}({2})

# resources_zh_CN.properties file
no.suitable._.found.for._(_)=\
    \u5BF9\u4E8E{1}({2}), \u627E\u4E0D\u5230\u5408\u9002\u7684{0}

# resources_jp.properties file
no.suitable._.found.for._(_)=\
    {1}\u306B\u9069\u5207\u306A{0}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093({2})</code></pre>
<p>then a program can compose a localized string based upon the property:</p>
<pre><code>var userLocale = new Locale(&#34;en&#34;, &#34;CA&#34;);
var LOCALIZE = new LocalizationProcessor(userLocale);
...
var symbolKind = &#34;field&#34;, name = &#34;tax&#34;, type = &#34;double&#34;;
System.out.println(LOCALIZE.&#34;no suitable \{symbolKind} found for \{name}(\{type})&#34;);</code></pre>
<p>and the template processor will map the string to the corresponding property in the locale-appropriate resource bundle:</p>
<pre><code>no suitable field found for tax(double)</code></pre>
<p>If the program instead performed</p>
<pre><code>var userLocale = new Locale(&#34;zh&#34;, &#34;CN&#34;);</code></pre>
<p>then the output would be:</p>
<pre><code>对于tax(double), 找不到合适的field</code></pre>
<p>Finally, if the program instead performed</p>
<pre><code>var userLocale = new Locale(&#34;jp&#34;);</code></pre>
<p>then the output would be:</p>
<pre><code>taxに適切なfieldが見つかりません(double)</code></pre>
<h2 id="Alternatives">Alternatives</h2>
<ul>
<li>
<p>When a string template appears without a template processor then we could simply perform basic interpolation. However, this choice would violate the safety goal. It would be too tempting to construct SQL queries using interpolation, for example, and this would in the aggregate reduce the safety of Java programs. Always requiring a template processor ensures that the developer at least recognizes the possibility of domain-specific rules in a string template.</p>
</li>
<li>
<p>The syntax of a template expression — with the template processor appearing first — is not strictly necessary. It would be possible to denote the template processor as an argument to <code>StringTemplate::process</code>. For example:</p>
<pre><code>String s = &#34;The answer is %5d\{i}&#34;.process(FMT);</code></pre>
<p>Having the template processor appear first is preferable because the result of evaluating the template expression is <em>entirely</em> dependent on the operation of the template processor.</p>
</li>
<li>
<p>For the syntax of embedded expressions we considered using <code>${...}</code>, but that would require a tag on string templates (either a prefix or a delimiter other than <code>&#34;</code>) to avoid conflicts with legacy code. We also considered <code>\[...]</code> and <code>\(...)</code>, but <code>[ ]</code> and <code>( )</code> are likely to appear in embedded expressions; <code>{ }</code> is less likely to appear, so visually determining the start and end of embedded expressions will be easier.</p>
</li>
<li>
<p>It would be possible to bake format specifiers into string templates, as done in C#:</p>
<pre><code>var date = DateTime.Now;
Console.WriteLine($&#34;The time is {date:HH:mm}&#34;);</code></pre>
<p>but this would require changes to the Java Language Specification any time a
new format specifier is introduced.</p>
</li>
</ul>
<h2 id="Risks-and-Assumptions">Risks and Assumptions</h2>
<p>The implementation of <code>java.util.FormatProcessor</code> depends strongly upon <a href="https://cr.openjdk.java.net/~jlaskey/templates/docs/api/java.base/java/util/Formatter.html"><code>java.util.Formatter</code></a>, which may require a significant rewrite.</p>
</div></div>
  </body>
</html>
