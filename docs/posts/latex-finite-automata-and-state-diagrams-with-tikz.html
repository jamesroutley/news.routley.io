<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hayesall.com/blog/latex-automata/">Original</a>
    <h1>LaTeX Finite Automata and State Diagrams with Tikz</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div id="content">
        <p>When I was TA’ing for Automata Theory, the in-browser finite-state machine creators I found tended to feel either a bit restricted or unable to generate high-quality automata images. Lo and behold, LaTeX already had a package which produced diagrams from a description.</p>

<p>This short guide includes some examples for creating finite state automata using LaTeX and <code>tikz</code>. For something more in-depth, the <a href="https://www.bu.edu/math/files/2013/08/tikzpgfmanual.pdf#section.19">TikZ and PGF Manual</a> chapter is a great reference.</p>

<h2 id="finite-automata">Finite Automata</h2>

<p><code>tikz</code> is a great package for drawing both deterministic and nondeterministic Finite Automata. The <code>arrows</code>, <code>automata</code>, and <code>positioning</code> libraries used in conjunction provide all we should need.</p>

<div><div><pre><code><span>\usepackage</span><span>{</span>tikz<span>}</span>
<span>\usetikzlibrary</span><span>{</span>arrows,automata,positioning<span>}</span>
</code></pre></div></div>

<p>Let’s start with four examples that illustrate some of the languages regular languages can represent. The empty set can be recognized by many machines, but the final state is always an empty set.</p>

<p>
$$ \emptyset = \Big( Q = \{ s_0\}, \Sigma = \{ 0, 1\}, \delta = \begin{bmatrix}s_0, s_0\end{bmatrix}, q_0 = s_0, F = \{ \} \Big) $$
</p>

<div>
  <p><img src="https://hayesall.com/images/blog/latex-automata/empty.png"/>
  </p>
  <div>
  <div><pre><code><span>% { }</span>
<span>\begin{tikzpicture}</span>[shorten &gt;=1pt,node distance=2cm,on grid,auto]
  <span>\tikzstyle</span><span>{</span>every state<span>}</span>=[fill=<span>{</span>rgb:black,1;white,10<span>}</span>]

  <span>\node</span><span>[state,initial]</span> (s<span>_</span>0)  <span>{$</span><span>s</span><span>_</span><span>0</span><span>$}</span>;

  <span>\path</span><span>[-&gt;]</span>
  (s<span>_</span>0) edge  [loop above]  <span>{</span>0,1<span>}</span> ( );
<span>\end{tikzpicture}</span>
  </code></pre>
  </div>
  </div>
</div>

<hr/>

<p>The natural opposite of a machine that accepts nothing is a machine which accepts everything. By the same logic as before, all automata where Q equals F will recognize this language.</p>

<p>
$$ \{ 0, 1\}^* = \Big( Q = \{ s_0 \}, \Sigma = \{ 0, 1 \}, \delta = \begin{bmatrix} s_0, s_0 \end{bmatrix}, q_0 = s_0, F = \{ s_0 \} \Big)$$
</p>

<div>
  <p><img src="https://hayesall.com/images/blog/latex-automata/01star.png"/>
  </p>
  <div>
  <div><pre><code><span>% {0,1}*</span>
<span>\begin{tikzpicture}</span>[shorten &gt;=1pt,node distance=2cm,on grid,auto]
  <span>\tikzstyle</span><span>{</span>every state<span>}</span>=[fill=<span>{</span>rgb:black,1;white,10<span>}</span>]

  <span>\node</span><span>[state,initial,accepting]</span> (s<span>_</span>0)  <span>{$</span><span>s</span><span>_</span><span>0</span><span>$}</span>;

  <span>\path</span><span>[-&gt;]</span>
  (s<span>_</span>0) edge  [loop above]  <span>{</span>0,1<span>}</span> ( );
<span>\end{tikzpicture}</span>
  </code></pre>
  </div>
  </div>
</div>

<hr/>

<h2 id="positioning-nodes-on-the-grid">Positioning Nodes on the Grid</h2>

<p>Now that we’ve seen the two languages which can be expressed with a single state, we turn our focus to those which require two or more states.</p>

<p>The next two languages represent <code>ε</code> and <code>{0,1}+</code>. Respectively these correspond to “the language of strings containing nothing” and “the language of strings containing something”. From these images it is also worth noticing that they are inverses of one another.</p>

<p>These examples use a position parameter to show that <code>s_1</code> should be positioned to the <code>right of=s_0</code>.</p>

<p>
$$ \{ \epsilon \} = \Big( Q = \{ s_0, s_1 \}, \Sigma = \{ 0, 1\}, \delta = \begin{bmatrix} s_1, s_1 \\ s_1, s_1\end{bmatrix}, q_0 = s_0, F = \{ s_0 \} \Big)$$
</p>

<div>
  <p><img src="https://hayesall.com/images/blog/latex-automata/epsilon.png"/>
  </p>
  <div>
  <div><pre><code><span>% { \epsilon }</span>
<span>\begin{tikzpicture}</span>[shorten &gt;=1pt,node distance=2cm,on grid,auto]
  <span>\tikzstyle</span><span>{</span>every state<span>}</span>=[fill=<span>{</span>rgb:black,1;white,10<span>}</span>]

  <span>\node</span><span>[state,initial,accepting]</span>  (s<span>_</span>0)                 <span>{$</span><span>s</span><span>_</span><span>0</span><span>$}</span>;
  <span>\node</span><span>[state]</span>                    (s<span>_</span>1) [right of=s<span>_</span>0]  <span>{$</span><span>s</span><span>_</span><span>1</span><span>$}</span>;

  <span>\path</span><span>[-&gt;]</span>
  (s<span>_</span>0) edge                node <span>{</span>0,1<span>}</span>  (s<span>_</span>1)
  (s<span>_</span>1) edge  [loop above]  node <span>{</span>0,1<span>}</span>  ();
<span>\end{tikzpicture}</span>
</code></pre>
</div>
</div>
</div>

<hr/>

<p>
$$ \{ 0, 1 \}^+ = \Big( Q = \{ s_0, s_1 \}, \Sigma = \{ 0, 1 \}, \delta = \begin{bmatrix} s_1, s_1 \\ s_1, s_1 \end{bmatrix}, q_0 = s_0, F = \{ s_1 \} \Big)$$
</p>

<div>
  <p><img src="https://hayesall.com/images/blog/latex-automata/01plus.png"/>
  </p>
  <div>
  <div><pre><code><span>% { 0,1 }+</span>
<span>\begin{tikzpicture}</span>[shorten &gt;=1pt,node distance=2cm,on grid,auto]
  <span>\tikzpicture</span><span>{</span>every state<span>}</span>=[fill=<span>{</span>rgb:black,1;white,10<span>}</span>]

  <span>\node</span><span>[state,initial,accepting]</span>  (s<span>_</span>0)                 <span>{$</span><span>s</span><span>_</span><span>0</span><span>$}</span>;
  <span>\node</span><span>[state]</span>                    (s<span>_</span>1) [right of=s<span>_</span>0]  <span>{$</span><span>s</span><span>_</span><span>1</span><span>$}</span>;

  <span>\path</span><span>[-&gt;]</span>
  (s<span>_</span>0) edge                node <span>{</span>0,1<span>}</span>  (s<span>_</span>1)
  (s<span>_</span>1) edge  [loop above]  node <span>{</span>0,1<span>}</span>  ();
<span>\end{tikzpicture}</span>
</code></pre>
</div>
  </div>
</div>

<hr/>

<h2 id="arcs-as-edges">Arcs as Edges</h2>

<p>As automata grow more complicated, it’s beneficial to have control over placement of both the nodes and the edges.</p>

<p>This example (Figure 1.4 from <em>Sipser (3rd Edition)</em>) uses <code>right of=</code> for positioning the nodes, but edges on the path all either loop above a node or bend left.</p>

<p><img src="https://hayesall.com/images/blog/latex-automata/three_state.png"/></p>

<div><div><pre><code><span>\begin{tikzpicture}</span>[shorten &gt;=1pt,node distance=2cm,on grid,auto]
  <span>\tikzstyle</span><span>{</span>every state<span>}</span>=[fill=<span>{</span>rgb:black,1;white,10<span>}</span>]

    <span>\node</span><span>[state,initial]</span>   (q<span>_</span>1)                    <span>{$</span><span>q</span><span>_</span><span>1</span><span>$}</span>;
    <span>\node</span><span>[state,accepting]</span> (q<span>_</span>2)  [right of=q<span>_</span>1]    <span>{$</span><span>q</span><span>_</span><span>2</span><span>$}</span>;
    <span>\node</span><span>[state]</span>           (q<span>_</span>3)  [right of=q<span>_</span>2]    <span>{$</span><span>q</span><span>_</span><span>3</span><span>$}</span>;

    <span>\path</span><span>[-&gt;]</span>
    (q<span>_</span>1) edge [loop above] node <span>{</span>0<span>}</span>    (   )
          edge [bend left]  node <span>{</span>1<span>}</span>    (q<span>_</span>2)
    (q<span>_</span>2) edge [bend left]  node <span>{</span>0<span>}</span>    (q<span>_</span>3)
          edge [loop above] node <span>{</span>1<span>}</span>    (   )
    (q<span>_</span>3) edge [bend left]  node <span>{</span>0,1<span>}</span>  (q<span>_</span>2);
<span>\end{tikzpicture}</span>
</code></pre></div></div>

<p>Finally, this example (Figure 1.12 From <em>Sipser (3rd Edition)</em>) puts together all of the pieces seen so far: positioning nodes on the grid, loops, and directed edges.</p>

<p><img src="https://hayesall.com/images/blog/latex-automata/begin_end_same_letter.png"/></p>

<div><div><pre><code><span>\begin{tikzpicture}</span>[shorten &gt;=1pt,node distance=2cm,auto]
  <span>\tikzstyle</span><span>{</span>every state<span>}</span>=[fill=<span>{</span>rgb:black,1;white,10<span>}</span>]

  <span>\node</span><span>[state,initial]</span>   (s)                      <span>{$</span><span>s</span><span>$}</span>;
  <span>\node</span><span>[state,accepting]</span> (q<span>_</span>1) [below left of=s]  <span>{$</span><span>q</span><span>_</span><span>1</span><span>$}</span>;
  <span>\node</span><span>[state]</span>           (q<span>_</span>2) [below of=q<span>_</span>1]     <span>{$</span><span>q</span><span>_</span><span>2</span><span>$}</span>;
  <span>\node</span><span>[state,accepting]</span> (r<span>_</span>1) [below right of=s] <span>{$</span><span>r</span><span>_</span><span>1</span><span>$}</span>;
  <span>\node</span><span>[state]</span>           (r<span>_</span>2) [below of=r<span>_</span>1]     <span>{$</span><span>r</span><span>_</span><span>2</span><span>$}</span>;

  <span>\path</span><span>[-&gt;]</span>
  (s)   edge              node <span>{</span>a<span>}</span> (q<span>_</span>1)
        edge              node <span>{</span>b<span>}</span> (r<span>_</span>1)
  (q<span>_</span>1) edge [loop left]  node <span>{</span>a<span>}</span> (   )
        edge [bend left]  node <span>{</span>b<span>}</span> (q<span>_</span>2)
  (q<span>_</span>2) edge [loop left]  node <span>{</span>b<span>}</span> (   )
        edge [bend left]  node <span>{</span>a<span>}</span> (q<span>_</span>1)
  (r<span>_</span>1) edge [loop right] node <span>{</span>b<span>}</span> (   )
        edge [bend left]  node <span>{</span>a<span>}</span> (r<span>_</span>2)
  (r<span>_</span>2) edge [loop right] node <span>{</span>a<span>}</span> (   )
        edge [bend left]  node <span>{</span>b<span>}</span> (r<span>_</span>1);
<span>\end{tikzpicture}</span>
</code></pre></div></div>

        <hr/>
        <!-- /.footer -->
        
      </div><!-- /.content -->
    </div></div>
  </body>
</html>
