<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2025-12_aoc-2025-day-4-csharp">Original</a>
    <h1>Advent of Code 2025 Day 4 in C#</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://hamy.xyz/blog/disclosures">(disclosures)</a></p><div><p>We&#39;re back for another day of Advent of Code using C#.</p>
<h2 id="part-1">Part 1</h2>
<p>Notes:</p>
<pre><code>/*
Part 1: 
* Grid of paper @, . nothing
* Find all locations of paper where it can be retrieved (fewer than 4 papers in 8 adjancent squares)

SubProblems: 
* A: Hold grid
    * 1: Loop over lines, building 2d grid
        * Grab line - @ is paper, . is nothing
        * Put in the thing
* B: Figuring out if paper is reachable
    * 1: Helper that takes in grid, location, and counts
        * Counts adjacent squares to see if okay
*/
</code></pre>
<p>I wanted to try and do an approach without for loops - more similar to smth I would build in F#. I&#39;ve been pretty pleasantly surprised with how easy it is to chain things, especially with some helper methods for Pipe and Tap. (These didn&#39;t end up in the final solution but they are VERY useful for adding debug lines in chains).</p>
<pre><code>public static class PipeExtensions
{
    public static TOut Pipe&lt;TIn, TOut&gt;(this TIn value, Func&lt;TIn, TOut&gt; func) =&gt; func(value);

    public static T Tap&lt;T&gt;(this T value, Action&lt;T&gt; action)
    {
        action(value);
        return value;
    }
}
</code></pre>
<p>While it is a bit wordier than other languages might be, I quite like the chainability and I find the lack of meaningful whitespace to help a lot as I can reformat many of the chains to be more readable to me.</p>
<p>One thing that is a bit annoying is the opening <code>{</code> on a new line. I feel that adds a lot of loc for little readability and prob could be removed.</p>
<pre><code>public static int Day4Part1(string[] lines)
{
    var grid = BuildGrid(lines);
    return YieldGridSpaces(grid)
        .Count(gridSpaceCoord =&gt; 
            gridSpaceCoord.GridSpace.Match(
                paper =&gt; isPaperReachable(grid, gridSpaceCoord.Coord),
                empty =&gt; false
            ));
}

public static GridSpace[][] BuildGrid(string[] lines)
{
    return lines
        .Select(l =&gt; 
            l.Select&lt;char, GridSpace&gt;(CharToGridSpace).ToArray()
        ).ToArray();
}

public static IEnumerable&lt;GridSpaceCoord&gt; YieldGridSpaces(GridSpace[][] grid)
{
    return grid.SelectMany((row, y) =&gt; 
        row.Select((gridSpace, x) =&gt; 
            new GridSpaceCoord(
                GridSpace: gridSpace,
                Coord: new Coordinate(X: x, Y: y)
            ))
    );
}

public static GridSpace CharToGridSpace(char c)
{
    switch(c)
    {
        case &#39;@&#39;: return new PaperSpace();
        case &#39;.&#39;: return new EmptySpace();
        default: throw new InvalidDataException($&#34;Got unexpected character: {c}&#34;);
    }
}

public static bool isValidCoordinate(GridSpace[][] grid, Coordinate coord)
{
    return !(coord.Y &lt; 0 || coord.Y &gt;= grid.Length || coord.X &lt; 0 || coord.X &gt;= grid[0].Length);
}

public static GridSpace GetGridSpaceAtCoordinate(GridSpace[][] grid, Coordinate coord)
{
    return grid[coord.Y][coord.X];
}

public static Coordinate[] GetSurroundingCoordinates(Coordinate coord)
{
    return [
        coord with { Y = coord.Y - 1}, // bottom
        coord with { Y = coord.Y - 1, X = coord.X - 1},
        coord with { X = coord.X - 1}, // left
        coord with { Y = coord.Y + 1, X = coord.X - 1},
        coord with { Y = coord.Y + 1}, // top
        coord with { Y = coord.Y + 1, X = coord.X + 1},
        coord with { X = coord.X + 1}, // right
        coord with { Y = coord.Y - 1, X = coord.X + 1},
    ];
}

public static bool isPaperReachable(GridSpace[][] grid, Coordinate coord)
{
    if(!isValidCoordinate(grid, coord))
    {
        throw new InvalidDataException($&#34;Got unreachable coordinate! {coord}&#34;);
    }

    return GetSurroundingCoordinates(coord)
        .Select(surroundingCoord =&gt; 
            isValidCoordinate(grid, surroundingCoord) 
            &amp;&amp; GetGridSpaceAtCoordinate(grid, surroundingCoord).Match(paper =&gt; true, empty =&gt; false))
        .Count(isPaper =&gt; isPaper) &lt; 4;
}
</code></pre>
<h2 id="part-2">Part 2</h2>
<p>Notes:</p>
<pre><code>Part 2: 
* Same as part 1 except now a paper can be removed from the grid

Solutions: 
* A: Run algorithm over grid, take note of the ones that can be removed
    * Remove them at each juncture
    * Run again til no paper removed
</code></pre>
<p>I realized that a recursive solution would probably make the most sense because I&#39;m avoiding loops and want to pass new state on to the next calculation. Interestingly, I&#39;ve been finding the recursive logic easier to reason ab these days than when I used F# heavily and F# is generally better geared towards those solutions.</p>
<p>Just goes to show that you can build similar things / logic constructs in many languages.</p>
<p>One area I really don&#39;t like ab C# right now is its lack of native unions. OneOf is decent but the type system just does not narrow as ergonomically as you&#39;d want it to - I basically have an As cast in there to get this working as I want which is a runtime error waiting to happen.</p>
<pre><code>public static int Day4Part2(string[] lines)
{
    var grid = BuildGrid(lines);
    return Day4Part2Recurse(grid);
}

private static int Day4Part2Recurse(GridSpace[][] grid)
{
    var paperSpacesFound = YieldGridSpaces(grid)
        .Select(gridSpaceCoord =&gt; 
            gridSpaceCoord.GridSpace.Match&lt;Option&lt;Coordinate&gt;&gt;(
                paper =&gt; isPaperReachable(grid, gridSpaceCoord.Coord)
                    ? new Some&lt;Coordinate&gt;(gridSpaceCoord.Coord)
                    : new None(),
                empty =&gt; new None()
            ))
        .Where(opt =&gt; opt.IsT0)
        .Select(opt =&gt; opt.AsT0.Value)
        .ToArray();
    if(paperSpacesFound.Length == 0)
        return 0;

    return paperSpacesFound.Length 
        + (DeletePaper(grid, paperSpacesFound)
        .Pipe(Day4Part2Recurse));
}

public static GridSpace[][] DeletePaper(GridSpace[][] grid, Coordinate[] coordsToDelete)
{
    var coordsToDeleteIdSet = new HashSet&lt;string&gt;(coordsToDelete.Select(c =&gt; $&#34;{c.X}_{c.Y}&#34;).ToList());

    return grid.Select((row, y) =&gt; 
        row.Select((space, x) =&gt; coordsToDeleteIdSet.Contains($&#34;{x}_{y}&#34;)
            ? new EmptySpace()
            : space)
            .ToArray()
    ).ToArray();
}
</code></pre>
<h2 id="next">Next</h2>
<p>Overall I&#39;ve been pretty pleased with C#&#39;s ergonomics. If we just got native unions that the type system could narrow and exhaustively pattern match, I think this lang would be an A+.</p>
<p><a href="https://hamy.xyz/blog/haminions">HAMINIONs Members</a> get access to the full source code (<a href="https://github.com/HAMY-LABS/hamy-labs-code-examples/tree/main/csharp/2025-12_csharp-aoc">Github Repo</a>) and that of dozens of other example projects.</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/tags/advent-of-code">See my previous Advent of Code submissions</a></li>
</ul>
</div></div>
  </body>
</html>
