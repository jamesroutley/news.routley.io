<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bryanbraun.com/2025/09/28/some-thoughts-on-scaling-code-review/">Original</a>
    <h1>Some thoughts on scaling code review</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>AI code-writing tools make it possible for more people to write code than ever before. On my current team, I’ve seen PRs opened by engineers, designers, marketers, managers, and product people. There’s something special about empowering more people to build and fix things. That empowering feeling is a big reason I got involved in web-dev in the first place.</p>

<p>But we also have to care about codebase quality. AI-generated code isn’t always the best, and bad code has a tendency to multiply (especially as AIs use existing code patterns to suggest new code). Manual code review is effective, but I don’t want to spend all my time reviewing AI generated-code. AI scales code generation. How do we scale code review?</p>

<p>Here are some things I’ve seen work:</p>

<h2 id="strong-universal-linting-and-formatting-standards">Strong, universal, linting and formatting standards</h2>

<p>Humans should not be checking for code formatting or linting issues. All major languages have tooling for this, so it’s one of the easiest things to set up and automate. I recommend running it on CI for all opened PRs, and having it run during local development (whether that be through watch tasks, pre-push hooks, or solid editor integration). I also recommend making your default rules pretty restrictive. It’s basically free consistency, so take advantage of it. Most tooling allows you to make one-off exceptions if needed (ideally, with a comment explaining <em>why</em> it’s needed).</p>

<h2 id="make-a-bunch-of-custom-linting-rules">Make a bunch of custom linting rules</h2>

<p>Out-of-the-box linting can only get you so far. That’s where custom lint rules come in. Most modern linters support custom rules, and other tools go even further (see <a href="https://danger.systems/">danger</a>, for example).</p>

<p>In my recent onboarding experience, I was super-impressed to find a library of custom lint rules, acting as living documentation of the patterns we were moving away from. Are you trying to migrate away from Moment.js? Write a custom lint rule for that. Are there special global objects that you don’t want to be abused? Write a custom lint rule for that. It’s not that hard to do (especially with a bit of AI help).</p>

<h2 id="a-process-for-burning-down-bad-patterns">A process for burning-down bad patterns</h2>

<p>It’s not realistic to always have 100% compliance with your linting and coding standards. New patterns ought to be adopted as your needs change, and incremental adoption is usually less risky than doing it all at once. Ideally, your standards are clearly defined, and your codebase is always progressing towards them. How do we automate that? Here’s a few ideas:</p>

<p><strong>1: Have linters and formatters run only on changed files (instead of ALL files).</strong></p>

<p>This allows you to fail CI builds for new violations while ignoring violations in untouched files—great if you want to automate “leaving each file better than you found it.” In the JS world, you can do this with tools like <code>pretty-quick</code> or <code>eslint-plugin-diff</code>, but you shouldn’t <em>need</em> special packages. Most CLI linters can take an argument for a “files list”, and you can generate a list of changed files with git commands.</p>

<p><strong>2: When introducing a rule, create exceptions for all pre-existing violations, plus an explanatory comment.</strong></p>

<p>For example:</p>

<div><div><pre><code><span>// eslint-disable-next-line complexity - pre-existing violation, should be fixable</span>
<span>function</span> <span>processPayment</span><span>(</span><span>user</span><span>,</span> <span>order</span><span>)</span> <span>{</span>
<span>...</span>
</code></pre></div></div>

<p>This is great for codebases that already have universal linting and build failures for any violations. I like comments on linting exceptions because they help explain whether an exception is valid, or technical debt. You can <a href="https://eslint-community.github.io/eslint-plugin-eslint-comments/rules/require-description.html">make these comments required</a>.</p>

<p><strong>3: A racheting system</strong></p>

<p>A <a href="https://en.wikipedia.org/wiki/Ratchet_(device)">rachet</a> allows motion in one direction but prevents motion in the other. As such, we can set up systems that only allow the number of bad patterns to decrease. For example, the JavaScript ecosystem includes tools like <a href="https://www.notion.com/blog/how-we-evolved-our-code-notions-ratcheting-system-using-custom-eslint-rules">eslint-seatbelt</a>, <a href="https://github.com/phenomnomnominal/betterer">betterer</a>, and <a href="https://github.com/diffjam/diffjam">diffjam</a>, each of which uses a racheting process to gradually drive towards compliance.</p>

<h2 id="excellent-rules-for-ai-agents">Excellent rules for AI agents</h2>

<p>An ounce of prevention is worth a pound of cure, and we can prevent bad code from being written in the first place with a set of excellent rules for AI agents. All the major coding agents support this (see <a href="https://www.anthropic.com/engineering/claude-code-best-practices#a-create-claudemd-files">Claude</a>, <a href="https://cursor.com/docs/context/rules">Cursor</a>, <a href="https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions">Copilot</a>).</p>

<p>Well-written rules make a huge difference. When I joined ClassDojo, I could hardly believe how much “better” the coding AIs were. It wasn’t the AIs themselves (I was using the same models and editors on my own proejcts). It was the rules.</p>

<p>If you don’t have any rules in your project, create some (AI can help with this, but start small!). Then, anytime you get weird output from an AI, consider adding or adjusting the rules. Give engineers collective ownership over these rules with permission to adjust them as needed. This can be a powerful system for preventing undesirable patterns (especially ones outside the scope of linting).</p>

<h2 id="ai-code-review">AI Code Review</h2>

<p>Use AI to do a first-pass code-review. I’ve seen this done with <a href="https://docs.cursor.com/en/bugbot">Cursor’s bugbot</a> and the <a href="https://github.com/anthropics/claude-code-action">Claude Code action</a>, but I’m sure that other tools and services exist. I don’t see these as a substitute for human review. They aren’t perfect, but I’ve found them to be good at calling out things you may have overlooked (unused code, hardcoded values, etc).</p>

<h2 id="conclusion">Conclusion</h2>

<p>Any time you find yourself giving feedback, ask yourself if the feedback can be integrated into your systems. Over time, these systems should improve and the burden of code reviews can become progressively lighter. One reason senior engineers still matter is because they have the instincts and the agency to design and maintain these systems. They are the most qualified people to shepherd our codebases into a brave new world.</p>

  </article></div>
  </body>
</html>
