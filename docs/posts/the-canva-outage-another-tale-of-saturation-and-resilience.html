<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/">Original</a>
    <h1>The Canva outage: another tale of saturation and resilience</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Today’s <a href="https://www.canva.dev/blog/engineering/canva-incident-report-api-gateway-outage/">public incident writeup</a> comes courtesy of <a href="https://www.linkedin.com/in/brendanhumphreys/">Brendan Humphries</a>, the CTO of <a href="https://www.canva.com/">Canva</a>. Like <a href="https://surfingcomplexity.blog/2024/12/14/quick-takes-on-the-recent-openai-public-incident-write-up/">so</a> <a href="https://surfingcomplexity.blog/2024/11/28/quick-takes-on-the-latest-cloudflare-public-incident-write-up/">many</a> <a href="https://surfingcomplexity.blog/2024/07/06/quick-takes-on-rogers-network-outage-executive-summary/">other</a> <a href="https://surfingcomplexity.blog/2021/02/08/slacks-jan-2021-outage-a-tale-of-saturation/">incidents</a> that came before, this is another tale of <em>saturation</em>, where the failure mode involves overload. There’s a lot of great detail in Humpries’s write-up, and I recommend you read it directly in addition to this post.</p>



<h2>What happened at Canva</h2>



<h3>Trigger: deploying a new version of a page</h3>



<p>The trigger for this incident was Canva deploying a new version of their editor page. It’s notable <strong><em>that there was nothing wrong with this new version.</em></strong> The incident wasn’t triggered by a bug in the code in the new version, or even by some unexpected emergent behavior in the code of this version. No, while the incident was triggered by a deploy, the changes from the previous version are immaterial to this outage. Rather, <em><strong>it was the system behavior that emerged from clients downloading the new version that led to the outage</strong></em>. Specifically, it was clients downloading the new javascript files from the CDN that set the ball in motion.</p>



<h3>A stale traffic rule</h3>



<p>Canva uses <a href="https://www.cloudflare.com/">Cloudflare</a> as their CDN. Being a CDN, Cloudflare has datacenters <a href="https://www.cloudflare.com/network/">all over the world</a>., which are interconnected by a <a href="https://blog.cloudflare.com/cloudflare-backbone-internet-fast-lane">private backbone</a>. Now, I’m not a networking person, but my basic understanding of private backbones is that CDNs lease fibre-optic lines from telecom companies and use these leased lines to ensure that they have dedicated network connectivity and bandwidth between their sites.</p>



<p>Unfortunately for Canva, there was a previously unknown issue on Cloudflare’s side: Cloudflare Wasn’t using their dedicated fibre-optic lines to route traffic between their Northern Virginia and Singapore datacenters. That traffic was instead, unintentionally, going over the public internet.</p>



<blockquote>
<p>[A] stale rule in Cloudflare’s traffic management system [that] was sending user IPv6 traffic over public transit between Ashburn and Singapore instead of its default route over the private backbone.</p>
</blockquote>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png"><img data-attachment-id="5661" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/iad-sin/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png" data-orig-size="2732,2048" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="iad-sin" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=1024" width="1024" height="767" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=2046 2046w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/iad-sin.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Traffic between Northern Virginia (IAD) and Singapore (SIN) was incorrectly routed over the public network</figcaption></figure>



<p>The routes that this traffic took suffered from considerable packet loss. For Canva users in Asia, this meant that they experienced massive increases in latency when their web browsers attempted to fetch the javascript static assets from the CDN.</p>



<p>A stale rule like this is the kind of issue that the safety researcher James Reason calls a <em>latent pathogen</em>. It’s a problem that remains unnoticed until it emerges as a contributor to an incident.</p>



<h3>High latency synchronizes the callers</h3>



<blockquote>
<p>Normally, an increase in errors would cause our canary system to abort a deployment. However, in this case, no errors were recorded because requests didn’t complete. As a result, over 270,000+ user requests for the JavaScript file waited on the same cache stream. This created a backlog of requests from users in Southeast Asia.</p>
</blockquote>



<p>The first client attempts to fetch the new Javascript files from the CDN, but the files aren’t there yet, the CDN must fetch the files from the origin. Because of the added latency, this takes a long time.</p>



<p>During this time, other clients connect, and attempt to fetch the javascript from the CDN. But the CDN has not yet been populated with the files from the origin, that transfer is still in progress.</p>



<p>As Cloudflare notes in <a href="https://blog.cloudflare.com/introducing-concurrent-streaming-acceleration/">this blog post</a>, when all subsequent clients request access to a file that is in the process of being populated in the cache, they must wait until the file has been cached before they can download the file. Except that Cloudflare has implemented functionality called <em>Concurrent Streaming Acceleration</em> which permits multiple clients to simultaneously download a file that is still in the process of being downloaded from the origin server.</p>



<p>The resulting behavior is that the CDN now behaves effectively as a <em>barrier</em>, with all of the clients slowly but simultaneously downloading the assets. With a traditional barrier, the processes who are waiting can proceed once all processes have entered in the barrier. This isn’t quite the same, as the clients who are waiting can all proceed once the CDN completes downloading the asset from the origin.</p>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png"><img data-attachment-id="5665" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/waiting/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png" data-orig-size="2732,2048" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="waiting" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=1024" width="1024" height="767" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=2046 2046w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/waiting.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<h3>The transfer completes, the herd thunders</h3>



<blockquote>
<p>At 9:07 AM UTC, the asset fetch completed, and all 270,000+ pending requests were completed simultaneously. </p>
</blockquote>



<p>20 minutes after Canva deployed the new Javascript assets to the origin server, the clients completed fetching them. The next action the clients take is to call Canva’s API service. </p>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png"><img data-attachment-id="5675" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/thundering-herd/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png" data-orig-size="2732,2048" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="thundering-herd" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=1024" width="1024" height="767" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=2046 2046w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/thundering-herd.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<blockquote>
<p>With the JavaScript file now accessible, client devices resumed loading the editor, including the previously blocked object panel. The object panel loaded simultaneously across all waiting devices, resulting in a thundering herd of 1.5 million requests per second to the API Gateway — 3x the typical peak load.</p>
</blockquote>



<p>There’s one more issue that made this situation even worse: a known performance issue in the API gateway that was slated to be fixed.</p>



<h3>A problematic call pattern to a library reduces service throughput</h3>



<blockquote>
<p>The API Gateways use an event loop model, where code running on event loop threads must not perform any blocking operations. </p>
</blockquote>



<p>Two common threading models for request-response services are <em>thread-per-request</em> and <em>async</em>. For services that are I/O-bound (i.e., most of the time servicing each request is spent waiting for I/O operations to complete, typically networking operations), the async model has the potential to achieve better throughput. That’s because the concurrency of the thread-per-request model is limited by the number of operating-system threads. The async model services multiple requests per thread, and so it doesn’t suffer from the thread bottleneck. Canva’s API gateway implements the <em>async</em> model using the popular <a href="https://netty.io/">Netty</a> library.</p>



<p>One of the drawbacks of the async model is the risk associated with the active thread getting <em>blocked</em>, because this can result in a significant performance penalty. The async model multiplexes multiple requests across an individual thread, and none of those requests can make progress when that thread is blocked. Programmers writing code in a service that uses the async model need to take care to minimize the number of blocking calls.</p>



<blockquote>
<p>Prior to this incident, we’d made changes to our telemetry library code, inadvertently introducing a performance regression. The change caused certain metrics to be re-registered each time a new value was recorded. This re-registration occurred under a lock within a third-party library.</p>
</blockquote>



<p>In Canva’s case, the API gateway logic was making calls to a third-party telemetry library. They were calling the library in such a way that it took a lock, which is a blocking call. This reduced the effective throughput that the API gateway could handle.</p>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png"><img data-attachment-id="5672" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/telemetry-lib/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png" data-orig-size="2732,2048" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="telemetry-lib" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=1024" loading="lazy" width="1024" height="767" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=2046 2046w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/telemetry-lib.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Calls to the library led to excessive thread locking </figcaption></figure>



<blockquote>
<p>Although the issue had already been identified and a fix had entered our release process the day of the incident, we’d underestimated the impact of the bug and didn’t expedite deploying the fix. This meant it wasn’t deployed before the incident occurred.</p>
</blockquote>



<p>Ironically, they were aware of this problematic call pattern, and they were planning on deploying a fix the day of the incident(!).</p>



<p>As an aside, it’s worth noting the role of telemetry logic behavior in the <a href="https://surfingcomplexity.blog/2024/12/14/quick-takes-on-the-recent-openai-public-incident-write-up/">recent OpenAI incident</a>, and in the locking behavior of tracing library in a <a href="https://surfingcomplexity.blog/2024/08/01/reproducing-a-java-21-virtual-threads-deadlock-scenario-with-tla/">complex performance issue that Netflix experienced</a>. Observability giveth reliability, and observability taketh reliability away.</p>



<p>Canva is now in a situation where the API gateway is receiving much more traffic than it was provisioned to handle, is also suffering from a performance regression that reduces its ability to handle traffic even more. </p>



<p>Now let’s look at how the system behaved under these conditions.</p>



<h2>The load balancer turns into an overload balancer</h2>



<blockquote>
<p>Because the API Gateway tasks were failing to handle the requests in a timely manner, the load balancers started opening new connections to the already overloaded tasks, further increasing memory pressure.</p>
</blockquote>



<p>A load balancer sits in front of a service and distributes the incoming requests across the units of compute. Canva runs atop <a href="https://aws.amazon.com/ecs/">ECS</a>, so the individual units are called <em>tasks</em>, and the group is called a <em>cluster</em> (you can think of these as being equivalent to <em>pods</em> and <em>replicasets </em>in Kubernetes-land).</p>



<p>The load balancer will only send requests to a task that is healthy. If a task is unhealthy, then it stops being considered as a candidate target destination for the load balancer. This yields good results if the overall cluster is provisioned to handle the load: the traffic gets redirected away from the unhealthy tasks and onto the healthy ones.</p>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png"><img data-attachment-id="5681" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/lb-healthy/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png" data-orig-size="2732,2048" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="lb-healthy" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=1024" loading="lazy" width="1024" height="767" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=2046 2046w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-healthy.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Load balancer only sells traffic to the healthy tasks</figcaption></figure>



<p>But now consider the scenario where all of the tasks are operating close to capacity. As tasks go unhealthy, the load balancer will redistribute the load to the remaining “healthy” tasks, which increases the likelihood those tasks gets pushed into an unhealthy state. </p>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png"><img data-attachment-id="5682" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/lb-unhealthy/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png" data-orig-size="2732,2048" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="lb-unhealthy" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=1024" loading="lazy" width="1024" height="767" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=2046 2046w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/lb-unhealthy.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Redirecting traffic to the almost-overloaded healthy nodes will push them over</figcaption></figure>







<p>This is a classic example of a positive feedback loop: the more tasks go unhealthy, the more traffic the healthy nodes received, the more likely those tasks will go unhealthy as well.</p>



<h3>Autoscaling can’t keep pace</h3>



<p>So, now the system is saturated, and the load balancer is effectively making things worse. Instead of shedding load, it’s concentrating load on the tasks that aren’t overloaded yet.</p>



<p>Now, this is the cloud, and the cloud is <em>elastic</em>, and we have a wonderful automation system called the <em>autoscaler</em> that can help us in situations of overload by automating provisioning new capacity.</p>



<p>Only, there’s a problem here, and that’s that the autoscaler simply can’t scale up fast enough. And the reason it can’t scale up fast enough is because of another automation system that’s intended to help in times of overload: Linux’s OOM killer.</p>



<blockquote>
<p>The growth of off-heap memory caused the Linux Out Of Memory Killer to terminate all of the running containers in the first 2 minutes, causing a cascading failure across all API Gateway tasks. This outpaced our autoscaling capability, ultimately leading to all requests to canva.com failing.</p>
</blockquote>



<p>Operating systems need access to free memory in order to function properly. When all of the memory is consumed by running processes, the operating system runs into trouble. To guard against this, Linux has a feature called the <a href="https://linuxhandbook.com/oom-killer/">OOM killer</a> which will automatically terminate a process when the operating system is running too low on memory. This frees up memory, enabling the OS to keep functioning. </p>



<p>So, you have the autoscaler which is adding new tasks, and the OOM killer which is quickly destroying existing tasks that have become overloaded.</p>



<p>It’s notable that Humphries uses the term <em>outpaced</em>. This sort of scenario is a common failure mode in complex system failures, where the system gets into a state where it can’t keep up. This phenomenon is called <em>decompensation</em>. Here’s resilience engineering pioneer <a href="https://www.profound-deming.com/profound-podcast/s4-e24-dr-david-woods-resilience-and-complexity-part-one">David Woods describing decompensation on John Willis’s <em>Profound</em> Podcast</a>:</p>



<blockquote>
<p>And lag is really saturation in time. That’s what we call decompensation, right? I can’t keep pace, right? Events are moving forward faster. Trouble is building and compounding faster than I, than the team, than the response system can decide on and deploy actions to affect. So I can’t keep pace. – David Woods</p>
</blockquote>



<h2>Adapting the system to bring it back up</h2>



<p>At this point, the API gateway cluster is completely overwhelmed. From the timeline:</p>



<blockquote>
<p>9:07 AM UTC – Network issue resolved, but the backlog of queued requests result in a spike of 1.5 million requests per second to the API gateway.</p>
</blockquote>



<p>When your system is suffering from overload, there are basically two strategies: </p>



<ol>
<li>increase the capacity</li>



<li>reduce the load</li>
</ol>



<p>Wisely, the Canva engineers pursued both strategies in parallel.</p>



<h3>Max capacity, but it still isn’t enough</h3>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png"><img data-attachment-id="5689" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/image-370/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png" data-orig-size="340,350" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png?w=291" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png?w=340" loading="lazy" width="340" height="350" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png?w=340" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png 340w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png?w=146 146w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-3.png?w=291 291w" sizes="(max-width: 340px) 100vw, 340px"/></a><figcaption>Montgomery Scott, my nominee for patron saint of resilience engineering</figcaption></figure>



<blockquote>
<p> We attempted to work around this issue by significantly increasing the desired task count manually. Unfortunately, it didn’t mitigate the issue of tasks being quickly terminated.</p>
</blockquote>



<p>The engineers tried to increase capacity manually, but even with the manual scaling, the load was too much: the OOM killer was taking the tasks down too quickly for the system to get back to a healthy state.</p>



<h3>Load shedding, human operator edition</h3>



<p>The engineers had to improvise a load shedding solution in the moment. The approach they took was to block traffic the CDN layer, using Cloudflare.</p>



<blockquote>
<p> At 9:29 AM UTC, we added a temporary Cloudflare firewall rule to block all traffic at the CDN. This prevented any traffic reaching the API Gateway, allowing new tasks to start up without being overwhelmed with incoming requests. We later redirected canva.com to our status page to make it clear to users that we were experiencing an incident.</p>
</blockquote>



<p>It’s worth noting here that while Cloudflare contributed to this incident with the stale rule, the fact that they could dynamically configure Cloudflare firewall rules meant that Cloudflare also contributed to the mitigation of this incident.</p>



<h3>Ramping the traffic back up</h3>



<p>Here they turned off all of their traffic to give their system a chance to go back to healthy. But a healthy system under zero load behaves differently from a healthy system under typical load. If you just go back from zero to typical, there’s a risk that you push the system back into an unhealthy state. (One common problem is that autoscaling will have scaled down multiple services due when there’s no load).</p>



<blockquote>
<p>Once the number of healthy API Gateway tasks stabilized to a level we were comfortable with, we incrementally restored traffic to canva.com. Starting with Australian users under strict rate limits, we gradually increased the traffic flow to ensure stability before scaling further.</p>
</blockquote>



<p>The Canva engineers had the good judgment to ramp up the traffic incrementally rather than turn it back on all at once. They started restoring at <em>9:45 AM UTC</em>, and were back to taking full traffic at <em>10:04 AM</em>.</p>



<h2>Some general observations</h2>



<h3>All functional requirements met</h3>



<p>I always like to call out situations where, from a <em>functional</em> point of view, everything was actually working fine. In this case, even though there was a stale rule in the Cloudflare traffic management system, and there was a performance regression in the API gateway, everything was working correctly from a functional perspective: packets were still being routed between Singapore and Northern Virginia, and the API gateway was still returning the proper responses for individual requests before it got overloaded. </p>



<p>Rather, these two issues were both <em>performance</em> problems. Performance problems are much harder to spot, and the worst are the ones that you don’t notice until you’re under heavy load. </p>



<p>The irony is that, as an organization gets better at catching functional bugs before they hit production, more and more of the production incidents they face will be related to these more difficult-to-detect-early performance issues. </p>



<h3>Automated systems made the problem worse</h3>



<p>There were a number of automated systems in play whose behavior made this incident more difficult to deal with.</p>



<p>The <a href="https://blog.cloudflare.com/introducing-concurrent-streaming-acceleration/">Concurrent Streaming Acceleration</a> functionality synchronized the requests from the clients. The OOM killer reduced the time it took for a task to be seen as unhealthy by the load balancer, and the load balancer in turn increased the rate at which tasks went unhealthy. </p>



<p>None of these systems were designed to handle this sort of situation, so they could not automatically change their behavior.</p>



<h3>The human operators changed the way the system behaved</h3>



<p>It was up to the incident responders to adapt the behavior of the system, to change the way it functioned in order to get it back to a healthy state. They were able to leverage an existing resource, Cloudflare’s firewall functionality, to accomplish this. Based on the description of the action items, I suspect they had never used Cloudflare’s firewall to do this type of load shedding before. But it worked! They successfully adapted the system behavior.</p>



<blockquote>
<p>We’re building a detailed internal runbook to make sure we can granularly reroute, block, and then progressively scale up traffic. We’ll use this runbook to quickly mitigate any similar incidents in the future.</p>
</blockquote>



<p>This is a classic example of <em>resilience</em>, of acting to reconfigure the behavior of your system when it enters a state that it wasn’t originally designed to handle. </p>



<p>As I’ve <a href="https://surfingcomplexity.blog/2021/05/31/transgressing-the-boundaries-rasmussen-and-woods/">written about previously</a>, Woods talks about the idea of a <em>competence envelope</em>. The competence envelope is sort of a conceptual space of the types of inputs that your system can handle. Incidents occur when your system is pushed to operate outside of its competence envelope, such as when it gets more load than it is provisioned to handle:</p>



<p>The competence envelope is a good way to think about the difference between <em>robustness</em> and <em>resilience</em>. You can think of robustness as describing the competence envelope itself: a more robust system may have a larger competence envelope, it is designed to handle a broader range of problems. </p>



<p>However, every system has a finite competence envelope. The difference between a <em>resilient</em> and a <em>brittle</em> system is how that system behaves when it is pushed just outside of its competence envelope.</p>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png"><img data-attachment-id="5702" data-permalink="https://surfingcomplexity.blog/2024/12/21/the-canva-outage-another-tale-of-saturation-and-resilience/competence-envelope-2/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png" data-orig-size="2220,1169" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="competence-envelope" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=300" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=1024" loading="lazy" width="1024" height="539" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=1024" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=1024 1024w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=2048 2048w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=150 150w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=300 300w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/competence-envelope-1.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Incidents happen when the system is pushed outside of its competence envelope</figcaption></figure>



<p>A <em>resilient</em> system can change the way it behaves when pushed outside of the competence envelope due to an incident in order to extend the competence envelope so that it can handle the incident. That’s why we say it has <em><strong>adaptive capacity</strong>. </em>On the other hand, a <em>brittle</em> system is one that cannot adapt effectively when it exceeds its competence envelope. A system can be very robust, but also brittle: it may be able to handle a very wide range of problems, but when it faces a scenario it wasn’t designed to handle, it can fall over hard. </p>



<p>The sort of adaptation that resilience demands requires human operators: our automation simply doesn’t have a sophisticated enough model of the world to be able to handle situations like the one that Canva found itself in. </p>



<p>In general, action items after an incident focus on expanding the competence envelope: making changes to the system to handle the scenario that just happened. <a href="https://www.adaptivecapacitylabs.com/">Improving adaptive capacity</a> involves different kind of work than improving system robustness.</p>



<p>We need to build in the ability to reconfigure our systems in advance, without knowing exactly what sorts of changes we’ll need to make. The Canva engineers had some powerful operational knobs at their disposal through the Cloudflare firewall configuration. This allowed them to make changes. The more powerful and generic these sorts of dynamic configuration features are, the more room for maneuver we have. Of course, dynamic configuration is also dangerous, and is itself a contributor to incidents. Too often we focus solely on the dangers of such functionality in creating incidents, without seeing its ability to help us reconfigure the system to mitigate incidents.</p>



<p>Finally, these sorts of operator interfaces are of no use if the responders aren’t familiar with them. Ultimately, the more your responders know about the system, the better position they’ll be in to implement these adaptations. Changing an unhealthy system is dangerous: no matter how bad things are, you can always accidentally make things worse. The more knowledge about the system you can bring to bear during an incident, the better position you’ll be in to adaptive your system to extend that competence envelope.</p>
	</div></div>
  </body>
</html>
