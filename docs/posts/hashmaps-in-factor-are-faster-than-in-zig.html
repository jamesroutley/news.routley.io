<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://re.factorcode.org/2023/11/factor-is-faster-than-zig.html">Original</a>
    <h1>Hashmaps in Factor are faster than in Zig</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Recently, I was looking at the <a href="https://ziglang.org">Zig programming language</a>.
As I often do, I started implementing a few typical things in new languages to learn them. Well, one of them was super slow and Zig is supposed to be super
fast, so I was trying to understand where the disconnect was and compare it to
<a href="https://factorcode.org">Factor</a>!</p>
<p>I was able to reduce the issue to a small test case and it turns out that there
is a behavioral issue in their <a href="https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig">implementation of
HashMap</a> that
makes their <a href="https://github.com/ziglang/zig/issues/17851">HashMaps get slow over
time</a>. The test case performs
these steps:</p>
<ul>
<li>creates a <code>HashMap</code> of 2 million items</li>
<li>decrements the map values, removing an item every third loop</li>
<li>inserts a replacement new item to maintain 2 million items in the <code>HashMap</code></li>
<li>for a total of 250 million actions, then</li>
<li>deletes the remaining items from the <code>HashMap</code></li>
</ul>
<p>We record the total time each block of 1 million actions takes:</p>
<p>
<img src="https://re.factorcode.org/images/2023-11-09-zig-hashmap-bug.png" alt="" width="531" height="386"/>
</p>
<p>Something is very wrong!</p>
<h3 id="zig">Zig</h3>
<p>This is the simple test case implemented in Zig using the <code>std.HashMap</code>:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span><span>std</span><span> </span><span>=</span><span> </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>!</span><span>void</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span><span>map</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>AutoHashMap</span><span>(</span><span>u64</span><span>,</span><span> </span><span>u64</span><span>).</span><span>init</span><span>(</span><span>std</span><span>.</span><span>heap</span><span>.</span><span>page_allocator</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span><span>map</span><span>.</span><span>deinit</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span><span>list</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>ArrayList</span><span>(</span><span>u64</span><span>).</span><span>init</span><span>(</span><span>std</span><span>.</span><span>heap</span><span>.</span><span>page_allocator</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span><span>list</span><span>.</span><span>deinit</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span><span>prng</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>rand</span><span>.</span><span>DefaultPrng</span><span>.</span><span>init</span><span>(</span><span>0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span><span>random</span><span> </span><span>=</span><span> </span><span>prng</span><span>.</span><span>random</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>time</span><span>.</span><span>milliTimestamp</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span><span>i</span><span>:</span><span> </span><span>u64</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>while</span><span> </span><span>(</span><span>i</span><span> </span><span>&lt;</span><span> </span><span>2_000_000</span><span>)</span><span> </span><span>:</span><span> </span><span>(</span><span>i</span><span> </span><span>+=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>try</span><span> </span><span>map</span><span>.</span><span>put</span><span>(</span><span>i</span><span>,</span><span> </span><span>3</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>try</span><span> </span><span>list</span><span>.</span><span>append</span><span>(</span><span>i</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>while</span><span> </span><span>(</span><span>i</span><span> </span><span>&lt;</span><span> </span><span>250_000_000</span><span>)</span><span> </span><span>:</span><span> </span><span>(</span><span>i</span><span> </span><span>+=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>var</span><span> </span><span>index</span><span> </span><span>=</span><span> </span><span>random</span><span>.</span><span>uintLessThan</span><span>(</span><span>usize</span><span>,</span><span> </span><span>list</span><span>.</span><span>items</span><span>.</span><span>len</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>var</span><span> </span><span>j</span><span> </span><span>=</span><span> </span><span>list</span><span>.</span><span>items</span><span>[</span><span>index</span><span>];</span><span>
</span></span></span><span><span><span>        </span><span>var</span><span> </span><span>k</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>get</span><span>(</span><span>j</span><span>).</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>(</span><span>k</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>_</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>remove</span><span>(</span><span>j</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>try</span><span> </span><span>map</span><span>.</span><span>put</span><span>(</span><span>i</span><span>,</span><span> </span><span>3</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>list</span><span>.</span><span>items</span><span>[</span><span>index</span><span>]</span><span> </span><span>=</span><span> </span><span>i</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>try</span><span> </span><span>map</span><span>.</span><span>put</span><span>(</span><span>j</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>(</span><span>i</span><span> </span><span>%</span><span> </span><span>1_000_000</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>var</span><span> </span><span>end</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>time</span><span>.</span><span>milliTimestamp</span><span>();</span><span>
</span></span></span><span><span><span>            </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;{} block took {} ms</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>.{</span><span> </span><span>i</span><span>,</span><span> </span><span>end</span><span> </span><span>-</span><span> </span><span>start</span><span> </span><span>});</span><span>
</span></span></span><span><span><span>            </span><span>start</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>time</span><span>.</span><span>milliTimestamp</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>while</span><span> </span><span>(</span><span>list</span><span>.</span><span>items</span><span>.</span><span>len</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>var</span><span> </span><span>j</span><span> </span><span>=</span><span> </span><span>list</span><span>.</span><span>pop</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>_</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>remove</span><span>(</span><span>j</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>We can run it using <code>ReleaseFast</code> to get the best performance and see
that, over time, it gets super slow – so slow that it isn’t even able to
really finish the test case:</p>
<pre tabindex="0"><code>$ zig version
0.11.0

$ zig run -O ReleaseFast maptest.zig
2000000 block took 156 ms
3000000 block took 122 ms
4000000 block took 127 ms
5000000 block took 133 ms
6000000 block took 138 ms
7000000 block took 141 ms
8000000 block took 143 ms
9000000 block took 145 ms
10000000 block took 147 ms
11000000 block took 148 ms
12000000 block took 151 ms
13000000 block took 153 ms
14000000 block took 155 ms
15000000 block took 157 ms
16000000 block took 159 ms
17000000 block took 164 ms
18000000 block took 167 ms
19000000 block took 171 ms
20000000 block took 173 ms
21000000 block took 180 ms
22000000 block took 186 ms
23000000 block took 190 ms
24000000 block took 195 ms
25000000 block took 205 ms
26000000 block took 213 ms
27000000 block took 221 ms
28000000 block took 234 ms
29000000 block took 247 ms
30000000 block took 264 ms
31000000 block took 282 ms
32000000 block took 301 ms
33000000 block took 320 ms
34000000 block took 346 ms
35000000 block took 377 ms
36000000 block took 409 ms
37000000 block took 448 ms
38000000 block took 502 ms
39000000 block took 550 ms
40000000 block took 614 ms
41000000 block took 694 ms
42000000 block took 767 ms
43000000 block took 853 ms
44000000 block took 961 ms
45000000 block took 1088 ms
46000000 block took 1250 ms
47000000 block took 1420 ms
48000000 block took 1612 ms
49000000 block took 1826 ms
50000000 block took 2056 ms
51000000 block took 2320 ms
52000000 block took 2688 ms
53000000 block took 3015 ms
54000000 block took 3467 ms
55000000 block took 3971 ms
56000000 block took 4618 ms
57000000 block took 5377 ms
58000000 block took 6172 ms
59000000 block took 7094 ms
60000000 block took 8173 ms
61000000 block took 9469 ms
62000000 block took 11083 ms
63000000 block took 12737 ms
64000000 block took 14000 ms
65000000 block took 16243 ms
66000000 block took 17912 ms
67000000 block took 20452 ms
68000000 block took 24356 ms
...
</code></pre><p>We can switch the example above to use <code>std.ArrayHashMap</code> which does not have
this problem, although it is a bit slower with each block taking roughly 250
milliseconds.</p>
<h3 id="factor">Factor</h3>
<p>We can compare that to a simple implementation in Factor:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>USING:</span> <span>assocs</span> <span>calendar</span> <span>formatting</span> <span>io</span> <span>kernel</span> <span>math</span> <span>random</span>
</span></span><span><span><span>sequences</span> <span>;
</span></span></span><span><span><span></span>
</span></span><span><span><span>::</span> <span>maptest</span> <span>( -- )
</span></span></span><span><span><span></span>    H{ } <span>clone </span>:&gt; m
</span></span><span><span>    V{ } <span>clone </span>:&gt; l
</span></span><span><span>
</span></span><span><span>    now :&gt; start!
</span></span><span><span>    <span>0 </span>  :&gt; i!
</span></span><span><span>
</span></span><span><span>    [ i <span>2,000,000 </span><span>&lt; </span>] [
</span></span><span><span>        <span>3 </span>i m <span>set-at
</span></span></span><span><span><span></span>        i l <span>push
</span></span></span><span><span><span></span>        i <span>1 </span><span>+ </span>i!
</span></span><span><span>    ] <span>while
</span></span></span><span><span><span></span>
</span></span><span><span>    [ i <span>250,000,000 </span><span>&lt; </span>] [
</span></span><span><span>        l <span>length </span>random :&gt; j
</span></span><span><span>        j l <span>nth </span>:&gt; k
</span></span><span><span>        k m <span>at </span><span>1 </span><span>- </span>[
</span></span><span><span>            k m <span>delete-at
</span></span></span><span><span><span></span>            <span>3 </span>i m <span>set-at
</span></span></span><span><span><span></span>            i j l <span>set-nth
</span></span></span><span><span><span></span>        ] [
</span></span><span><span>            k m <span>set-at
</span></span></span><span><span><span></span>        ] <span>if-zero
</span></span></span><span><span><span></span>
</span></span><span><span>        i <span>1,000,000 </span><span>mod zero? </span>[
</span></span><span><span>            i now <span>start </span>time- duration&gt;milliseconds
</span></span><span><span>            <span>&#34;%d block took %d ms\n&#34;</span> printf <span>flush
</span></span></span><span><span><span></span>            now start!
</span></span><span><span>        ] <span>when
</span></span></span><span><span><span></span>        i <span>1 </span><span>+ </span>i!
</span></span><span><span>    ] <span>while
</span></span></span><span><span><span></span>
</span></span><span><span>    [ l <span>empty? </span>] [
</span></span><span><span>        l <span>pop </span>m <span>delete-at
</span></span></span><span><span><span></span>    ] <span>until </span><span>;
</span></span></span></code></pre></div><p>We can run it in Factor and see how long it takes. There are notably some long
delays in the first few blocks which I’d like to understand better – possibly
due to excessive rehashing or some allocation pattern with the Factor garbage
collector – and then it quickly reaches a steady state where each block takes
about 250 milliseconds.</p>
<pre tabindex="0"><code>$ factor maptest.factor
2000000 block took 855 ms
3000000 block took 198 ms
4000000 block took 205 ms
5000000 block took 3579 ms
6000000 block took 4438 ms
7000000 block took 3624 ms
8000000 block took 2996 ms
9000000 block took 232 ms
10000000 block took 243 ms
11000000 block took 248 ms
12000000 block took 298 ms
13000000 block took 233 ms
14000000 block took 238 ms
15000000 block took 298 ms
16000000 block took 233 ms
17000000 block took 521 ms
18000000 block took 231 ms
19000000 block took 236 ms
20000000 block took 280 ms
21000000 block took 235 ms
22000000 block took 235 ms
23000000 block took 281 ms
24000000 block took 231 ms
25000000 block took 236 ms
26000000 block took 294 ms
27000000 block took 231 ms
28000000 block took 236 ms
29000000 block took 506 ms
30000000 block took 234 ms
31000000 block took 237 ms
32000000 block took 277 ms
33000000 block took 232 ms
34000000 block took 239 ms
35000000 block took 279 ms
36000000 block took 235 ms
37000000 block took 239 ms
38000000 block took 275 ms
39000000 block took 234 ms
40000000 block took 514 ms
41000000 block took 231 ms
42000000 block took 236 ms
43000000 block took 282 ms
44000000 block took 235 ms
45000000 block took 235 ms
46000000 block took 282 ms
47000000 block took 231 ms
48000000 block took 233 ms
49000000 block took 280 ms
50000000 block took 234 ms
51000000 block took 238 ms
52000000 block took 507 ms
53000000 block took 231 ms
54000000 block took 236 ms
55000000 block took 276 ms
56000000 block took 231 ms
57000000 block took 238 ms
58000000 block took 278 ms
59000000 block took 234 ms
60000000 block took 235 ms
61000000 block took 278 ms
62000000 block took 237 ms
63000000 block took 239 ms
64000000 block took 510 ms
65000000 block took 234 ms
66000000 block took 284 ms
...
</code></pre><p>Not bad!</p>
<h3 id="whats-the-bug">What’s the Bug?</h3>
<p>So, Zig <em>could</em> be super fast, but the default <code>std.HashMap</code> implementation
uses tombstone buckets to mark slots as being deleted, and over time these
tombstone buckets create fragmentation in the HashMap, which causes their
linear probing to trend towards the worst case examination of every bucket in
the HashMap when looking for a key.</p>
<p>We can implement a <code>rehash()</code> method on the HashMap that performs an in-place
rehashing of all the elements, without allocations. Ideally, this would be done
when the number of filled and deleted slots reaches some capacity threshold.
But, for now, we can just run <code>map.rehash()</code> once per block, and see how that
improves performance:</p>
<div><pre tabindex="0"><code data-lang="diff"><span><span><span>diff --git a/lib/std/hash_map.zig b/lib/std/hash_map.zig
</span></span></span><span><span><span>index 8a3d78283..7192ba733 100644
</span></span></span><span><span><span></span><span>--- a/lib/std/hash_map.zig
</span></span></span><span><span><span></span><span>+++ b/lib/std/hash_map.zig
</span></span></span><span><span><span></span><span>@@ -681,6 +681,11 @@ pub fn HashMap(
</span></span></span><span><span><span></span>             self.unmanaged = .{};
</span></span><span><span>             return result;
</span></span><span><span>         }
</span></span><span><span><span>+
</span></span></span><span><span><span>+         /// Rehash the map, in-place
</span></span></span><span><span><span>+         pub fn rehash(self: *Self) void {
</span></span></span><span><span><span>+             self.unmanaged.rehash(self.ctx);
</span></span></span><span><span><span>+         }
</span></span></span><span><span><span></span>     };
</span></span><span><span> }
</span></span><span><span> 
</span></span><span><span><span>@@ -1505,6 +1510,92 @@ pub fn HashMapUnmanaged(
</span></span></span><span><span><span></span>             return result;
</span></span><span><span>         }
</span></span><span><span> 
</span></span><span><span><span>+       /// Rehash the map, in-place
</span></span></span><span><span><span>+       pub fn rehash(self: *Self, ctx: anytype) void {
</span></span></span><span><span><span>+             const mask = self.capacity() - 1;
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+             var metadata = self.metadata.?;
</span></span></span><span><span><span>+             var keys_ptr = self.keys();
</span></span></span><span><span><span>+             var values_ptr = self.values();
</span></span></span><span><span><span>+             var curr: Size = 0;
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+             // While we are re-hashing every slot, we will use the
</span></span></span><span><span><span>+             // fingerprint to mark used buckets as being used and either free
</span></span></span><span><span><span>+             // (needing to be rehashed) or tombstone (already rehashed).
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+             while (curr &lt; self.capacity()) : (curr += 1) {
</span></span></span><span><span><span>+                 metadata[curr].fingerprint = Metadata.free;
</span></span></span><span><span><span>+             }
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+             // Now iterate over all the buckets, rehashing them
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+             curr = 0;
</span></span></span><span><span><span>+             while (curr &lt; self.capacity()) {
</span></span></span><span><span><span>+                 if (!metadata[curr].isUsed()) {
</span></span></span><span><span><span>+                     assert(metadata[curr].isFree());
</span></span></span><span><span><span>+                     curr += 1;
</span></span></span><span><span><span>+                     continue;
</span></span></span><span><span><span>+                 }
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                 var hash = ctx.hash(keys_ptr[curr]);
</span></span></span><span><span><span>+                 var fingerprint = Metadata.takeFingerprint(hash);
</span></span></span><span><span><span>+                 var idx = @as(usize, @truncate(hash &amp; mask));
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                 // For each bucket, rehash to an index:
</span></span></span><span><span><span>+                 // 1) before the cursor, probed into a free slot, or
</span></span></span><span><span><span>+                 // 2) equal to the cursor, no need to move, or
</span></span></span><span><span><span>+                 // 3) ahead of the cursor, probing over already rehashed
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                 while ((idx &lt; curr and metadata[idx].isUsed()) or
</span></span></span><span><span><span>+                     (idx &gt; curr and metadata[idx].fingerprint == Metadata.tombstone))
</span></span></span><span><span><span>+                 {
</span></span></span><span><span><span>+                     idx = (idx + 1) &amp; mask;
</span></span></span><span><span><span>+                 }
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                 if (idx &lt; curr) {
</span></span></span><span><span><span>+                     assert(metadata[idx].isFree());
</span></span></span><span><span><span>+                     metadata[idx].fingerprint = fingerprint;
</span></span></span><span><span><span>+                     metadata[idx].used = 1;
</span></span></span><span><span><span>+                     keys_ptr[idx] = keys_ptr[curr];
</span></span></span><span><span><span>+                     values_ptr[idx] = values_ptr[curr];
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                     metadata[curr].used = 0;
</span></span></span><span><span><span>+                     assert(metadata[curr].isFree());
</span></span></span><span><span><span>+                     keys_ptr[curr] = undefined;
</span></span></span><span><span><span>+                     values_ptr[curr] = undefined;
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                     curr += 1;
</span></span></span><span><span><span>+                 } else if (idx == curr) {
</span></span></span><span><span><span>+                     metadata[idx].fingerprint = fingerprint;
</span></span></span><span><span><span>+                     curr += 1;
</span></span></span><span><span><span>+                 } else {
</span></span></span><span><span><span>+                     assert(metadata[idx].fingerprint != Metadata.tombstone);
</span></span></span><span><span><span>+                     metadata[idx].fingerprint = Metadata.tombstone;
</span></span></span><span><span><span>+                     if (metadata[idx].isUsed()) {
</span></span></span><span><span><span>+                         var tmpkey = keys_ptr[idx];
</span></span></span><span><span><span>+                         var tmpvalue = values_ptr[idx];
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                         keys_ptr[idx] = keys_ptr[curr];
</span></span></span><span><span><span>+                         values_ptr[idx] = values_ptr[curr];
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                         keys_ptr[curr] = tmpkey;
</span></span></span><span><span><span>+                         values_ptr[curr] = tmpvalue;
</span></span></span><span><span><span>+                     } else {
</span></span></span><span><span><span>+                         metadata[idx].used = 1;
</span></span></span><span><span><span>+                         keys_ptr[idx] = keys_ptr[curr];
</span></span></span><span><span><span>+                         values_ptr[idx] = values_ptr[curr];
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                         metadata[curr].fingerprint = Metadata.free;
</span></span></span><span><span><span>+                         metadata[curr].used = 0;
</span></span></span><span><span><span>+                         keys_ptr[curr] = undefined;
</span></span></span><span><span><span>+                         values_ptr[curr] = undefined;
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+                         curr += 1;
</span></span></span><span><span><span>+                     }
</span></span></span><span><span><span>+                 }
</span></span></span><span><span><span>+             }
</span></span></span><span><span><span>+         }
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>oid {
</span></span><span><span>             @setCold(true);
</span></span><span><span>             const new_cap = @max(new_capacity, minimal_capacity);
</span></span><span><span><span>@@ -2218,3 +2309,35 @@ test &#34;std.hash_map repeat fetchRemove&#34; {
</span></span></span><span><span><span></span>     try testing.expect(map.get(2) != null);
</span></span><span><span>     try testing.expect(map.get(3) != null);
</span></span><span><span> }
</span></span><span><span><span>+
</span></span></span><span><span><span>+test &#34;std.hash_map rehash&#34; {
</span></span></span><span><span><span>+    var map = AutoHashMap(u32, u32).init(std.testing.allocator);
</span></span></span><span><span><span>+    defer map.deinit();
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    var prng = std.rand.DefaultPrng.init(0);
</span></span></span><span><span><span>+    const random = prng.random();
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    const count = 6 * random.intRangeLessThan(u32, 100_000, 500_000);
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    var i: u32 = 0;
</span></span></span><span><span><span>+    while (i &lt; count) : (i += 1) {
</span></span></span><span><span><span>+        try map.put(i, i);
</span></span></span><span><span><span>+        if (i % 3 == 0) {
</span></span></span><span><span><span>+            try expectEqual(map.remove(i), true);
</span></span></span><span><span><span>+        }
</span></span></span><span><span><span>+    }
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    map.rehash();
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    try expectEqual(map.count(), count * 2 / 3);
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    i = 0;
</span></span></span><span><span><span>+    while (i &lt; count) : (i += 1) {
</span></span></span><span><span><span>+        if (i % 3 == 0) {
</span></span></span><span><span><span>+            try expectEqual(map.get(i), null);
</span></span></span><span><span><span>+        } else {
</span></span></span><span><span><span>+            try expectEqual(map.get(i).?, i);
</span></span></span><span><span><span>+        }
</span></span></span><span><span><span>+    }
</span></span></span><span><span><span>+}
</span></span></span></code></pre></div><p>We can apply that diff to <code>lib/std/hash_map.zig</code> and try again, now taking
about 165 milliseconds per block including the time for <code>map.rehash()</code>:</p>
<pre tabindex="0"><code>$ zig run -O ReleaseFast maptest.zig --zig-lib-dir ~/Dev/zig/lib
2000000 block took 155 ms
3000000 block took 147 ms
4000000 block took 154 ms
5000000 block took 160 ms
6000000 block took 163 ms
7000000 block took 164 ms
8000000 block took 165 ms
9000000 block took 166 ms
10000000 block took 166 ms
11000000 block took 165 ms
12000000 block took 166 ms
13000000 block took 165 ms
14000000 block took 166 ms
15000000 block took 172 ms
16000000 block took 165 ms
17000000 block took 167 ms
18000000 block took 165 ms
19000000 block took 167 ms
20000000 block took 169 ms
21000000 block took 168 ms
22000000 block took 167 ms
23000000 block took 166 ms
24000000 block took 167 ms
25000000 block took 167 ms
26000000 block took 165 ms
27000000 block took 166 ms
28000000 block took 166 ms
29000000 block took 165 ms
30000000 block took 165 ms
31000000 block took 165 ms
32000000 block took 166 ms
33000000 block took 165 ms
34000000 block took 167 ms
35000000 block took 170 ms
36000000 block took 165 ms
37000000 block took 166 ms
38000000 block took 166 ms
39000000 block took 164 ms
40000000 block took 165 ms
41000000 block took 167 ms
42000000 block took 166 ms
43000000 block took 167 ms
44000000 block took 169 ms
45000000 block took 166 ms
46000000 block took 165 ms
47000000 block took 166 ms
48000000 block took 166 ms
49000000 block took 166 ms
50000000 block took 166 ms
51000000 block took 166 ms
52000000 block took 164 ms
53000000 block took 165 ms
54000000 block took 167 ms
55000000 block took 165 ms
56000000 block took 166 ms
57000000 block took 166 ms
58000000 block took 165 ms
59000000 block took 166 ms
60000000 block took 169 ms
61000000 block took 165 ms
62000000 block took 165 ms
63000000 block took 166 ms
64000000 block took 166 ms
65000000 block took 165 ms
66000000 block took 166 ms
67000000 block took 176 ms
68000000 block took 166 ms
...
</code></pre><p>Well now, Zig is fast and everything is right again with the world – and
Factor takes only about 50% more time than Zig’s <code>std.HashMap</code> with
<code>rehash()</code> and about the same as <code>std.ArrayHashMap</code>, which is pretty
good for a dynamic language.</p>
<p>I submitted a <a href="https://github.com/ziglang/zig/pull/17890">pull request adding a rehash() method to
HashMap</a> and hopefully it gets into
the upcoming Zig 0.12 release and maybe for Zig 0.13 they can adjust it to
automatically rehash when it gets sufficiently fragmented, consider using
quadratic probing instead of linear probing, or perhaps switch to using a
completely different HashMap algorithm like <a href="https://engineering.fb.com/2019/04/25/developer-tools/f14/">Facebook’s F14 hash
table</a>, which
doesn’t have this issue.</p>
<p>Maybe we should consider some of these improvements for Factor as well!</p>
<p>Open source is fun!</p>

</div></div>
  </body>
</html>
