<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://artemis.sh/2022/03/28/oxide-hubris-on-pinetime.html">Original</a>
    <h1>Oxide on My Wrist: Hubris on PineTime was the best worst idea</h1>
    
    <div id="readability-page-1" class="page"><article>
            <header>
                
                <time datetime="2022-03-28 00:00:00 +0000">2022-03-28</time>
            </header>
            <p><a href="https://artemis.sh/2022/03/14/propolis-oxide-at-home-pt1.html">In my last Oxide-related post</a> I got Oxide’s Propolis software running and said I might try and get their sled agent up and running next. Anyways that didn’t happen. Instead I ended up reading datasheets, writing rust codegen, spending 16 gigs of ram for an hour to build docs for a crate that’s just a glorified bundle of pointers, dreaming about serial data transfer, and uploading code to my smart watch over the slowest debug link I’ve ever had the displeasure of using. *<em>Record Scratch</em>* You’re probably wondering how I got in this situation. Well, it all started when I learned the nRF52832 microcontroller has a memory protection unit.</p>

<p>So yeah, I ported Oxide’s embedded kernel, <a href="http://github.com/oxidecomputer/hubris/">Hubris</a>, to my <a href="https://www.pine64.org/pinetime/">PineTime</a> smart watch, and now I’m going to tell you about it. If you’re not into embedded dev much, stick around for a bit! It’s not all scary, but don’t feel bad if you have to bail as the tail end of this post descends into technical madness. If you are into embedded dev though, well, have I got a treat for you. Before I get into the how, I’m going to talk a bit about what Hubris is, why a smart watch is actually a good place to apply it, and some thoughts on things I like and things I don’t. Then I’ll tell you the tale of how I got it running on my hardware in particular. But first, a demo!</p>

<center>
  <video controls="" poster="/assets/images/2022-03-28-oxide-hubris-on-pinetime/twister.jpg">
    <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/twister.webm" type="video/webm"/>
    <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/twister.mp4" type="video/mp4"/>
    <a href="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/twister.mp4">demoscene twister doing a wiggle</a>
  </video>
</center>

<p>(twister math based on <a href="https://www.lexaloffle.com/bbs/?tid=3050">this pico8 demo by visy</a>)</p>

<p>Also, <a href="https://github.com/faithanalog/hubris/tree/pinetime">if you’re just interested in the code, here’s my fork</a>. The GPIO and SPI code are in a pretty good place, though I’m missing a couple hardware configuration options in both. Have fun!</p>

<h2 id="hubris-what">Hubris: what?</h2>

<p>I’m not the authority on the topic here, and if you want an explanation from someone who wrote the dang thing you should <a href="https://talks.osfc.io/osfc2021/talk/JTWYEH/">watch Cliff Biffle’s talk about it</a> or <a href="http://cliffle.com/blog/on-hubris-and-humility/">read the transcript</a>.</p>

<p>Let me give you the basics though, so you have some grounding. Hubris is a kernel for embedded devices that uses a hardware feature a lot of people have forgotten about: the Memory Protection Unit. This piece of hardware in many ARM and RISC-V chips allows the kernel to lock down whether various segments of memory are readable, writable, and executable. Then the kernel can execute a task in that limited context. And by the way, since all IO is memory mapped on these systems, memory protection and IO protection are the same thing. If you can’t access a peripheral’s address space, you can’t access that peripheral!</p>

<p>But hey, what’s the big deal right? We’re all used to this in operating systems like Linux, Windows, macOS, and so on. Well, in the embedded world, it may shock you to learn that most people are just out there shoving a bunch of tasks onto a chip with a kernel that doesn’t bother with this. Those tasks can absolutely stomp on each other’s memory, do whatever IO they want, set your cat on fire, it’s a free for all in there. Some other kernels provide MPU functionality, but pickings are slim.</p>

<p>Hubris says “that’s bad, actually”. The result is an architecture where tasks can only interact through message-passing. Hardware interaction is encapsulated in tasks too, which helps debugging a ton. For example, you can know with certainty that if something is toggling a GPIO pin, it’s the GPIO task. You can add debugging hooks into that task to trace what’s sending messages to it, and now you have a complete high level view of everything doing GPIO. You can enforce mutexes so that two tasks can’t both simultaneously ask the SPI task to do a data transmission at the same time. It’s fantastic.</p>

<p>Since Hubris is written in rust, it can also get the borrow checker in on the fun. Hubris extends the concept of borrow checking with a something called “Leases”. When a task sends a message to another task, it can include a Lease to some range of memory. As the recipient of a lease, you can’t access that memory directly, but you <em>can</em> ask the kernel to read or write that memory on your behalf. The kernel checks to make sure you’ve got a valid lease, and copies memory between your address space and the lease sender’s address space. Since rust’s borrow checker made sure the sender had the rights to hand out the lease in the first place, the whole thing is memory safe.</p>

<p>Oh yeah also they have a debugger called Humility, which knocked my programmer socks off. If you’ve got a debug link to your device you can use Humility to do things like get a list of running tasks, get a backtrace of a failing task, check out ringbuffer logs, mess around with GPIO/SPI/i2c. You can go even more extreme by asking it for your tasks’ memory spaces, and then start mucking around reading or writing bytes directly in memory.</p>

<p>Look at this backtrace I got debugging my demo code:</p>

<div><div><pre><code>vi@navi ~/p/hubris (pinetime) [1]&gt; cargo xtask humility app/demo-pinetime/app.toml -- tasks -sl lcd
    Finished dev [optimized + debuginfo] target(s) in 3.34s
     Running `target/debug/xtask humility app/demo-pinetime/app.toml -- tasks -sl lcd`
humility: attached via OpenOCD
system time = 129006
ID TASK                 GEN PRI STATE
 3 lcd                   61   3 FAULT: PANIC (was: ready)
   |
   +---&gt;  0x20002208 0x00008cb2 userlib::sys_panic_stub
                     @ /hubris//sys/userlib/src/lib.rs:989
          0x20002210 0x00008cb8 userlib::sys_panic
                     @ /hubris//sys/userlib/src/lib.rs:981
          0x20002210 0x00008cc0 rust_begin_unwind
                     @ /hubris//sys/userlib/src/lib.rs:1444
          0x20002218 0x000086ce core::panicking::panic_fmt
                     @ /rustc/ac2d9fc509e36d1b32513744adf58c34bcc4f43c//library/core/src/panicking.rs:88
          0x20002220 0x0000898a core::panicking::panic
                     @ /rustc/ac2d9fc509e36d1b32513744adf58c34bcc4f43c//library/core/src/panicking.rs:39
          0x20002380 0x000084f6 main
                     @ /hubris//task/pinetime-lcd/src/main.rs:113

</code></pre></div></div>

<p>If this seems like a boring ol’ stack trace, yeah, that’s what’s so exciting! Boring ol’ stack traces are typically not this easy to get ahold of in the embedded world, and I’ll admit I’ve stuck to printf debugging in the past rather than deal with the other debugging tools available. This is so easy that even I don’t have an excuse anymore.</p>

<h3 id="oops-hubris-on-a-smart-watch-is-actually-practical">Oops, Hubris on a smart watch is actually practical</h3>

<p>I fully expected everything I did with Oxide software to be fun, but otherwise impractical for hobbyist projects at home. Hubris is different.</p>

<p>See, on a smart watch, you want to be able to load a bunch of apps onto your watch without worrying if the timer app you just installed is actually counting its way down to nuking your EEPROM, putting you into a bootloop, and texting your ex. At the extreme end, a particularly unlucky piece of code could soft-brick your watch until you unglue the back (breaking the watertight seal), plug a programmer into the debug port, and reprogram it. But even if it never gets that bad, it’s just nice to not have to treat any extra piece of software as a land mine.</p>

<p>Enter, Hubris. Tasks isolated from each other? Done. Tasks isolated from hardware? yup! That’s all the foundation you need to start building a robust watch operating system. Get yourself some dedicated tasks for stuff like input, graphics compositing, bluetooth, and baby you’ve got a stew going!</p>

<h3 id="but-should-you-use-it-yet">But should you use it yet?</h3>

<p>It depends how adventurous you are, and how much you’re willing to do without support. To quote Hubris’ <code>CONTRIBUTING.md</code>:</p>

<blockquote>
  <p>However, Hubris is not done, or even ready. It’s probably not a good fit for your use case, because it’s not yet a good fit for <em>our</em> use case!</p>

  <p>… snip …</p>

  <p>and so, we thought it was important to explain where we’re currently at, and
manage your expectations.</p>
  <ul>
    <li>We are a small company.</li>
    <li>Our current goal is to get our first generation products finished and in
customers’ hands.</li>
    <li>We’re writing Hubris in support of that goal, not as its own thing. Hubris has
a total of zero full time engineers – we’re all working on the products, and
tool development is a side effect.</li>
    <li>For expediency, we’re developing our server firmware and Hubris in the same
repo. We will probably split this up later to make it more obvious how to use
Hubris from other applications. But, for now, we’re primarily focused on
getting <em>our</em> firmware ready, because, again, we need to finish our computers.</li>
    <li>These points together mean that we may not have enough bandwidth to review and
integrate outside PRs right now. This will change in the future.</li>
  </ul>
</blockquote>

<p>So, you shouldn’t expect support, and you shouldn’t expect someone to be available to walk you through things personally.</p>

<p>On the other hand, everything I did in this post, and everything I learned along the way, came almost entirely from reading the existing docs (they’re good!) and the source code (it’s good too! and commented!). I got some helpful hints along the way from Oxide folks on twitter, but I went out of my way to figure out as much as possible on my own to see if it was possible. If you’re comfortable with that, and you’re fine with using an early stage project that’s still being molded into its final form, I’m happy to report there’s nothing stopping you from using Hubris right now!</p>

<h3 id="the-downside-to-hardware-isolation">The downside to hardware isolation.</h3>

<p><img src="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/one-cost-abstraction.jpg" alt="Teen comix edit. Panel 1 says zero cost abstractions but a person approaches. The person approaching wears a shirt that says Kernel Mem copy. The original person from panel 1 now wears a shirt that says one cost abstractions."/></p>

<p>Leases are great, but they’ve got overhead:</p>

<ul>
  <li>You’ve got to round trip through the kernel for memory accesses</li>
  <li>The kernel has to file its taxes to make sure you’re allowed to access the lease in question</li>
  <li>The kernel has to copy memory between the two tasks’ memory spaces</li>
</ul>

<p>The first two points here are somewhat mitigated by the <code>LeaseBufReader</code>/<code>LeaseBufWriter</code> wrappers that buffer read/writes and batch the kernel calls, but this just trades CPU time for RAM, something microcontrollers famously don’t have very much of.</p>

<p>And of course, the message passing itself trips through the kernel and has a cost, and the SPI task has its own taxes it needs to file to work generically.</p>

<p>I ran into this head first when working on my graphics demo. My display is connected over a 8MHz link and uses 16-bit color, so in theory I should be able to update half the screen at 16fps, if my code did nothing else. In reality, I was getting somewhere from 1-4fps with my LCD task talking to the SPI task, sending six write messages per row of pixels. I could reduce this overhead by buffering more pixels before handing them over to the SPI task, but now I’m spending more ram, and the memcopy isn’t free either. None of this even accounts for all the GPIO messages that are sent to the GPIO task during this from both the SPI task and my LCD code.</p>

<p>The easy solution to this is to give the LCD task direct access to the low level hardware peripheral rather than isolating it, but there’s more than just the LCD on that SPI bus; there’s some flash memory on there too. I’m left with a choice:</p>

<ul>
  <li>Consume more ram, cut down overhead a bit, still have slower LCD access, but keep hardware isolation</li>
  <li>Cut the generic SPI middletask out of the equation, and roll LCD and Flash access into a single monolithic task that Does Both Directly For Some Reason.</li>
  <li>Deal with the low bandwidth and keep things as they are now.</li>
</ul>

<p>The second option here is probably what I’ll do if I keep working on this project, because LCD speed is more important than a clean separation of concerns when you’re dealing with real time user interactions. Compare these two videos of writing a solid block of color to the screen, first through the SPI task, and second with direct SPI hardware access:</p>

<p>The second video is a bit flickery, so fair warning.</p>

<video controls="">
  <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/slow-refresh.webm" type="video/webm"/>
  <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/slow-refresh.mp4" type="video/mp4"/>
  <a href="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/slow-refresh.mp4">Screen updates are slow with SPI task</a>
</video>
<video controls="">
  <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/fast-refresh.webm" type="video/webm"/>
  <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/fast-refresh.mp4" type="video/mp4"/>
  <a href="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/fast-refresh.mp4">Screen updates are fast without the SPI task</a>
</video>

<p>It sucks that this is a compromise I have to make. I have some weird ideas to partially mitigate the issue by creating a DMA-compatibly memory buffer in my LCD task and shoving a pointer to that through the SPI task and into the DMA SPI hardware, but I’m pretty sure this violates memory safety, and the only thing it would mitigate is the Lease overhead. Even if this worked, I’d still be stuck with large pixel buffers I don’t want or need.</p>

<p>I’m certain this is a challenge the Hubris folks are aware of (hey, if you’re reading and I’m missing something obvious, let me know and I’ll update the post). I’m interested to see what their solutions to this look like, or if they’re just using faster chips than me.</p>

<h2 id="intermission">Intermission</h2>

<p>Good gods I sure am writing a lot of words. I’ve been working on this for the past two weeks and it turns out I’ve got a lot to say! From this point on I’ll be talking about how I got to where I am now, the random bullshit I ran into, and how I solved it. If you’re curious about what porting Hubris to a new chip family looks like, this is for you. I also recommend checking out the <a href="https://github.com/faithanalog/hubris/commits/pinetime">commit history</a> to see how I got here framed in code. I’ve left the commit history messy so you can see all the trials and missteps along the way.</p>

<h2 id="so-you-want-to-port-hubris-to-a-new-chip">So you want to port Hubris to a new chip</h2>

<p>I came into this knowing absolutely nothing about Hubris, and I’m going to give this to you from that perspective, so you can see this project with fresh eyes the way I did. The first thing I did was run the first command in the README that looked vaguely useful.</p>

<div><div><pre><code>cargo xtask dist app/demo-stm32f4-discovery/app.toml
</code></pre></div></div>

<p>stm32 is a family of arm microcontrollers that I recognize, so I started there. This command built a bunch of stuff in the <code>drv/</code> and <code>task/</code> folder, and generated a binary ready to flash onto a chip. <code>drv/</code> and <code>task/</code> have a bunch of drivers and application-level tasks respectively, but what’s in the <code>app.toml</code>? Well, <a href="https://github.com/faithanalog/hubris/blob/b9e837dc69feda844f65a6d620acc65724495761/app/demo-stm32f4-discovery/app.toml">here’s a link to see for your self</a>. Among other things we’ve got</p>

<ul>
  <li>The chip and board the app is intended to run on.</li>
  <li>The memory layout of the app.</li>
  <li>What tasks the app wants to include.</li>
  <li>Some runtime configuration switches.</li>
</ul>

<p>A lot of the tasks I can tell I don’t need. Ping and pong look like test heartbeat apps and usart serial isn’t going to do me much good right now so I guess that’s out. Eventually we get down to three tasks that we do actually want running: <code>hiffy</code>, <code>jefe</code>, and <code>idle</code>.</p>

<p>Hiffy is the “HIF Interpreter”. I’ll let <code>task/hiffy/src/main.rs</code> do the talking:</p>

<div><div><pre><code>//! HIF is the Hubris/Humility Interchange Format, a simple stack-based
//! machine that allows for some dynamic programmability of Hubris.  In
//! particular, this task provides a HIF interpreter to allow for Humility
//! commands like `humility i2c`, `humility pmbus` and `humility jefe`.  The
//! debugger places HIF in [`HIFFY_TEXT`], and then indicates that text is
//! present by incrementing [`HIFFY_KICK`].  This task executes the specified
//! HIF, with the return stack located in [`HIFFY_RSTACK`].
</code></pre></div></div>

<p>Then, according to <code>task/jefe/README.mkdn</code>, <code>jefe</code> is “the supervisory task for the demo application, which handles last-ditch error reporting, task restarting, and the like.”.</p>

<p>Finally, <code>idle</code> is scheduled when nothing else needs to run. Its sole purpose is to do nothing. Gods I wish that were me.</p>

<h2 id="bringing-up-the-kernel">Bringing up the kernel</h2>

<p>The PineTime uses an nRF52832 microprocessor, a lil baby 64MHz ARM chip with bluetooth. Hubris doesn’t have any support for it in the upstream repo so I added my own support. How did I do that? Well I woke up one morning, put on some <a href="https://youtu.be/TGan48YE9Us">lofi beats to write embedded software to</a>, and over the next few hours I</p>

<ul>
  <li>copied the <code>app/demo-stm32f4-discovery/</code> folder to <code>app/demo-pinetime/</code>.</li>
  <li>renamed everything inside to pinetime.</li>
  <li>added <code>app/demo-pinetime</code> to the <code>workspace.members</code> of the top level <code>Cargo.toml</code></li>
  <li>copied the <code>chips/stm32f4.toml</code> file to <code>chips/nRF52832.toml</code>, leaving the values there alone for now.</li>
  <li>adjusted the flash/ram addresses in <code>app.toml</code> according to the nRF52832 datasheet.</li>
  <li>commented out tasks so I only had <code>jefe</code>, <code>hiffy</code>, and <code>idle</code>.</li>
  <li>adjusted the imports in the <code>app/demo-pinetime/</code> to import the nRF52832 hardware crates instead of the stm stuff.</li>
  <li>messed around with the <a href="https://openocd.org/">openocd</a> config file until it worked with my BusPirate.</li>
  <li>flashed <code>target/demo-pinetime/dist/final.bin</code> to the watch.</li>
  <li>it worked???</li>
</ul>

<p><img src="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/hubris-works.png" alt="screenshot of the humility debugger connecting to hubris"/></p>

<p>It’s incredible what you can do when you’re working with code that’s designed to be portable. The most important bit of this was the memory address adjustments. Chip datasheets will tell you the memory layout of your chip and your compiler and linker would really like to know this information. Here’s a screenshot from the nRF docs:</p>

<p><img src="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/nrf-memory.png" alt="memory map of the nRF52832 showing flash at address zero and ram at address 20000000 hexadecimal"/></p>

<p>And then, here’s the corresponding bits in the <code>app.toml</code>:</p>

<div><div><pre><code>vi@navi ~/p/hubris (pinetime)&gt; cat app/demo-pinetime/app.toml
# bla bla bla
[outputs.flash]
address = 0x0000_0000
size = 0x0008_0000
read = true
execute = true

[outputs.ram]
address = 0x2000_0000
size = 0x0001_0000
read = true
write = true
execute = true
# bla bla bla
</code></pre></div></div>

<p>Neat right?</p>

<p>By the way, don’t use a BusPirate for flashing chips if you have something better. I love this thing and it’s a great little multi-tool but it took, no exaggeration, 15 minutes to finish uploading the firmware. I actually did it manually instead of using GDB because I was convinced GDB was just bugging out on me but in retrospect I just never gave it enough time to finish the upload. I have since purchased some proper flashing hardware and I’ll be very happy when it gets here.</p>

<p>Anyway, now I had a kernel doing fuck-all on a smart watch and I was incredibly full of myself. I went to twitter to claim victory like I had just cut off the hydra’s head, utterly clueless to the fate I’d just consigned myself to. See, I wasn’t content to just run a kernel. I wanted to drive the display, which means I needed to talk to the display controller. For that I needed to implement an SPI task, and in turn that lead to a GPIO task. At this point my yak stack was looking pretty tall, but the only thing to do was start shearing.</p>

<h2 id="gpio">GPIO</h2>

<p>Continuing the pattern of copy-pasting code and hammering it into submission, I copied the <code>drv/stm32xx-sys</code>, <code>drv/stm32xx-sys-api</code>, and <code>drv/stm32xx-gpio-common</code> folders, renaming the prefix to <code>nrf52832</code>. I also added these to the root-level <code>Cargo.toml</code>’s workspace just like with the app folder. For the rest of this post I’m going to leave that bit out, but basically, any time you’ve got a new <code>Cargo.toml</code> in a subdirectory you probably need to add its folder to the workspace.</p>

<p>The <code>stm32xx-sys</code> task handles GPIO and <a href="https://wiki.st.com/stm32mpu/wiki/RCC_internal_peripheral">RCC</a> configuration. These used to be separate but were <a href="https://github.com/oxidecomputer/hubris/commit/125b963ff26662a8c03dc326eb39e8dfc11ecae0">merged into a single task to reduce memory usage</a>, since every additional task costs some extra memory overhead. I didn’t know that at the time, but I did know my chip’s spec sheet doesn’t mention a direct corollary to the RCC, so I renamed my <code>-sys</code> folders back to <code>-gpio</code> and deleted all the references to RCC in the code.</p>

<p><img src="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/porting.png" alt="A chat log where I say if you don&#39;t know what the code does you simply don&#39;t need it."/></p>

<p>The stm32 chips also have more GPIO configuration options than my nRF52832, and multiple GPIO banks. We don’t have to deal with that on the nRF chip so I cleared all that out too and reworked the API a bit to match.</p>

<h3 id="the-status-quo-of-bare-metal-rust-like-really-bare-metal">The status quo of bare metal rust. Like, really bare metal</h3>

<p>If you’ve worked with something like Arduino before you’re accustomed to having some reasonably efficient abstraction over the hardware that’s stable across different CPUs. These abstractions save you from looking up chip-specific tutorials or spec sheets to do something basic. That’s true in rust too if you use the Hardware Abstraction Layer (hal) crates, but with hubris we don’t have that luxury, because those crates assume they’re working without any sort of memory protection or CPU privilege system in place. Instead, we go a layer deeper and use Peripheral Access (pac) crates. These are auto-generated from individual chip descriptions and give a type-safe way to access chip registers with niceties like enums for multi-choice options. Here’s an example from the GPIO:</p>

<div><div><pre><code>use nrf52832_pac as device;

// GPIO port 0 register set
let p0 = unsafe { &amp;*device::P0::ptr() };

// Configure pin 2 as an output with pullup resistor
self.p0.pin_cnf[2].write(|w| {
  w
    .dir().variant(device::p0::pin_cnf::DIR_A::OUTPUT)
    .pull().variant(device::p0::pin_cnf::PULL_A::PULLUP)
});
</code></pre></div></div>

<p>These writers let you modify multiple fields in the same 32-bit hardware register without having to juggle a bunch of integer constants and bitwise operations. It’s pretty nice actually! The downside is these crates get pretty large, and some of them don’t even have proper docs on docs.rs. See this incredibly broken set of <a href="https://docs.rs/stm32h7/latest/stm32h7/">stm32h7</a> docs for example. It’s not that there’s anything complicated about the build itself, it’s just that it consumes so much resources the docs.rs backend is killing off the docs mid-build. I built the docs for this crate in particular on the big chonker I used for my last post on Propolis, and it took 16 gigs of ram and an hour real-time. The nRF52832 pac crate is fine on docs.rs, but you may have to build docs locally depending on what chip you’re working with.</p>

<p>Anyways, on with the show.</p>

<h3 id="but-wait-theres-codegen">But wait there’s codegen</h3>

<p>The final piece to get this all compiling was the <code>.idol</code> file, something I hadn’t noticed up until this point. These files describe the message passing API surface of a task, so any time you make changes to that API you’ve got to update the <code>.idol</code>  file too. Once again I duplicated the stm32’s sys idol file to a gpio idol file for my chip, and here’s a sample of what that looks like:</p>

<div><div><pre><code>Interface(
    name: &#34;GPIO&#34;,
    ops: {
        &#34;gpio_configure_raw&#34;: (
            args: {
                &#34;pin&#34;: &#34;u8&#34;,
                &#34;config&#34;: &#34;u32&#34;,
            },
            reply: Result(
                ok: &#34;()&#34;,
                err: CLike(&#34;GpioError&#34;),
            ),
            idempotent: true,
        ),
        &#34;gpio_configure_gourmet&#34;: (
            args: {
                &#34;pin&#34;: &#34;u8&#34;,
                &#34;mode&#34;: (
                    type: &#34;Mode&#34;,
                    recv: FromPrimitive(&#34;u8&#34;),
                ),
                &#34;output_type&#34;: (
                    type: &#34;OutputType&#34;,
                    recv: FromPrimitive(&#34;u8&#34;),
                ),
                &#34;pull&#34;: (
                    type: &#34;Pull&#34;,
                    recv: FromPrimitive(&#34;u8&#34;),
                ),
            },
            reply: Result(
                ok: &#34;()&#34;,
                err: CLike(&#34;GpioError&#34;),
            ),
            idempotent: true,
        ),
    }
)
</code></pre></div></div>

<p>The <code>nrf52832-gpio</code> crate uses this at compile time to generate the server trait for you to implement, and the <code>nrf52832-gpio-api</code> crate generates a corresponding client stub to plumb the inner workings of talking to that server. All a server has to do is implement the appropriate trait and provide a <code>main</code> function that pumps the message queue. Clients just import the api crate and call the api like a function, with the inter-task communication hidden away when you don’t want to think about it.</p>

<p>Once I updated my idol file and pointed my <code>build.rs</code> files at it, I had a working GPIO task! All I had to do was add it to my <code>app.toml</code> and I was good to go. Or, so I thought. I had actually missed something very important, but to figure that out I had to try and use my GPIO for something.</p>

<h2 id="starting-the-lcd-task">Starting the LCD task</h2>

<p>With a GPIO task up and running, I had enough to actually make my watch do something visible. The LCD backlight is just controlled by some GPIO pins, so I whipped up a quick LCD task to make it blink.</p>

<p>To do this, I copied <code>task/pong</code> over to <code>task/pinetime-lcd</code> and stripped out everything from the main loop except for what looked like some sleep code (it was!). I also replaced the <code>USER_LEDS</code> task slot with <code>GPIO</code>, imported the GPIO api, and sprinkled in some GPIO control of the backlight pin.</p>

<div><div><pre><code>#![no_std]
#![no_main]
use userlib::*;
use drv_nrf52832_gpio_api as gpio_api;
task_slot!(GPIO, gpio);
#[export_name = &#34;main&#34;]
pub fn main() -&gt; ! {
    const TIMER_NOTIFICATION: u32 = 1;
    const INTERVAL: u64 = 3000;
    const BACKLIGHT_HIGH = 23;

    // Get handle to talk to the gpio task
    let gpio = gpio_api::GPIO::from(GPIO.get_task_id());

    // Configure pin for output
    gpio.gpio_configure_output(BACKLIGHT_HIGH, gpio_api::OutputType::PushPull, gpio_api::Pull::None).unwrap();


    let mut msg = [0; 16];
    let mut deadline = INTERVAL;
    sys_set_timer(Some(deadline), TIMER_NOTIFICATION);
    loop {
        let msginfo = sys_recv_open(&amp;mut msg, TIMER_NOTIFICATION);

        // Toggle backlight
        gpio.gpio_toggle(1 &lt;&lt; BACKLIGHT_HIGH).unwrap();

        if msginfo.sender == TaskId::KERNEL {
            deadline += INTERVAL;
            sys_set_timer(Some(deadline), TIMER_NOTIFICATION);
        }
    }
}
</code></pre></div></div>

<p>Then it was the song and dance of updating my <code>Cargo.toml</code> and my <code>app.toml</code>. Here we get to see task slots for the first time! I’ll give you the abridged version from the <code>app.toml</code>:</p>

<div><div><pre><code>[tasks.gpio]
# all the gpio config

[tasks.lcd]
# all the lcd config, but then
task-slots = [&#34;gpio&#34;]
</code></pre></div></div>

<p>So to recap,</p>

<ul>
  <li>The rust code declares a task slot with <code>task_slot!(GPIO, gpio);</code></li>
  <li>In our <code>app.toml</code>, we declare a <code>gpio</code> task</li>
  <li>we fill the LCD task’s <code>gpio</code> slot with that GPIO task.</li>
  <li>At run time, the task slot provides the GPIO task’s ID, and the rust code uses that to build a client struct to talk to GPIO.</li>
</ul>

<p>Excellent, surely this works right? Well, uh, no. And … this <code>GEN</code>eration number in <code>humility tasks</code> seems to keep going up. I think my GPIO task is crashing, and my <code>.unwrap()</code>s are taking the LCD down with it.</p>

<div><div><pre><code>vi@navi ~/p/hubris (pinetime)&gt; cargo xtask humility app/demo-pinetime/app.toml tasks
    Finished dev [optimized + debuginfo] target(s) in 3.41s
     Running `target/debug/xtask humility app/demo-pinetime/app.toml tasks`
humility: attached via OpenOCD
system time = 183050
ID TASK                 GEN PRI STATE
 0 jefe                   0   0 recv, notif: bit0
 1 gpio              315251   1 recv
 2 lcd               318758   3 not started
 3 hiffy                  0   3 ready
 4 idle                   0   5 ready
</code></pre></div></div>

<h3 id="trust-no-one-not-even-yourself">Trust no one, not even yourself</h3>

<p>This, my friends, is the memory protection unit in action. There’s one little detail I didn’t mention in the GPIO section earlier, because I had forgotten it myself: we need to give our GPIO task access to the memory space of the GPIO peripheral. If we don’t, the MPU shows up and unalives our little GPIO task with no feelings of remorse.</p>

<p>Finally, we learn that this is what that <code>chips/</code> folder is for. Every entry in our <code>chips/nRF52832.toml</code> defines the address and size of some memory block, and gives that block a name we can use to let tasks use it. So for GPIO, I added this to my chips file:</p>

<div><div><pre><code>[gpio]
address = 0x5000_0000
size = 0x1000
</code></pre></div></div>

<p>And in my <code>app.toml</code>, I added</p>

<div><div><pre><code>[tasks.gpio]
# The name of the memory range doesn&#39;t have to be the same as the task name, but in this case it is.
uses = [&#34;gpio&#34;]
</code></pre></div></div>

<p>With that, we have a glorious blinky screen!</p>

<video controls="">
  <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/blink.webm" type="video/webm"/>
  <source src="/assets/images/2022-03-28-oxide-hubris-on-pinetime/blink.mp4" type="video/mp4"/>
  <a href="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/blink.mp4">blinking screen</a>
</video>

<h2 id="spis-sappin-my-sanity">SPI’s sappin’ my sanity</h2>

<p>The next thing to do is to actually turn the screen on and get some pixel data on there, and for that we need SPI. SPI is a serial protocol whereby one host device (our microcontroller) is connected to several client devices (our LCD, also some SPI flash memory) over three shared lines carrying bidirectional data and a clock signal. Each client device also has a dedicated chip-select signal which is pulled low to tell that device it’s being addressed and pulled high to tell it to ignore whatever’s going on on the line. Our display is connected over a SPI link, and our microcontroller has dedicated SPI hardware to use that link efficiently. We just need to write some code to use the SPI hardware.</p>

<p>Once again, I copied the stm32 SPI driver and started chopping away at the parts I didn’t need, since the nRF has much simpler SPI hardware with less configuration involved. It’s got two ways to use the SPI, Direct Memory Access (DMA) and the simpler register-driven variant. DMA is more efficient because we can point the SPI hardware at a large chunk of memory, tell it to go to town on that memory, and then yield to other tasks for a bit. The downside is, it’s more complicated to use. In the interest of Getting Something Working I used the simpler SPI interface that need us to feed in bytes one at a time as they’re transmitted.</p>

<p>Here’s where things got complicated though, not because of the SPI hardware, but the configuration around it. Our <code>app.toml</code> provides task configuration sections that our tasks can read at build time. The SPI driver I copied converts this configuration to a struct with all the device and mux configuration. This involves walking the toml data, validating that it is indeed a satisfiable configuration, and generating rust code to represent that configuration. I’ve never actually done rust codegen until now, but it’s not too dissimilar from something like Haskell codegen, so that part didn’t scare me off too bad.</p>

<p>What did cause me a headache though was this cursed error report:</p>

<div><div><pre><code>error: failed to run custom build command for `drv-nrf52832-spi-server v0.1.0 (/sd/vi/home/p/hubris/drv/nrf52832-spi-server)`

Caused by:
  process didn&#39;t exit successfully: `/sd/vi/home/p/hubris/target/release/build/drv-nrf52832-spi-server-b7d1371bb53586d5/build-script-build` (exit status: 1)
  --- stdout
  --- toml for $HUBRIS_TASK_CONFIG ---
  [spi]
  global_config = &#34;spi1&#34;

  cargo:rerun-if-env-changed=HUBRIS_TASK_CONFIG

  --- stderr
  Error: environment variable not found

  Stack backtrace:
     0: anyhow::error::&lt;impl core::convert::From&lt;E&gt; for anyhow::Error&gt;::from
               at /home/vi/.cargo/registry/src/github.com-1285ae84e5963aae/anyhow-1.0.44/src/error.rs:530:25
     1: &lt;core::result::Result&lt;T,F&gt; as core::ops::try_trait::FromResidual&lt;core::result::Result&lt;core::convert::Infallible,E&gt;&gt;&gt;::from_residual
               at /rustc/ac2d9fc509e36d1b32513744adf58c34bcc4f43c/library/core/src/result.rs:1915:27
     2: build_util::toml_from_env
               at /sd/vi/home/p/hubris/build/util/src/lib.rs:60:18
     3: build_util::config
               at /sd/vi/home/p/hubris/build/util/src/lib.rs:51:5
     4: build_script_build::main
               at ./build.rs:17:25
</code></pre></div></div>

<p>Huh? The failing line is simply <code>let global_config = build_util::config::&lt;GlobalConfig&gt;()?;</code>.</p>

<p>A couple hours later and I finally found the culprit. The original app I copied didn’t have any SPI, and when I was looking at the other ones that did I missed a config section down at the bottom with keys like <code>[config.spi.spi1]</code>. That <code>global_config</code> setting tells the build system what key actually holds the SPI configuration details, and if that key isn’t actually present you get the cryptic error message above about missing environment variables.</p>

<p>Eventually though I did get SPI up and running, and you can see a sample of the config for that below. I’m pretty happy with where the implementation is now after a few more days of refactoring and refining it down, but it could stand for doing a DMA version at some point.</p>

<div><div><pre><code>[config]

[config.spi.spi0]
controller = 0

[config.spi.spi0.mux_options.lcd]
miso_pin = 4
mosi_pin = 3
sck_pin = 2

[config.spi.spi0.devices.lcd]
mux = &#34;lcd&#34;
cs = 25
frequency = &#34;M8&#34;
spi_mode = 3
</code></pre></div></div>

<h2 id="pixels-pixels-pixels-pixels-pixels">Pixels pixels pixels pixels pixels</h2>

<p>With SPI working I could start getting pixels on the screen. This is a simple case of “read the datasheet and do what it says”. The display controller in here is also very similar to the ones they have on the TI-84+CSE, <a href="https://artemis.sh/2014/10/09/ti84cse-half-resolution-mode.html">something I have a history of working with</a>, so I was right at home with it. No interlacing on this one though sadly, so I can’t do the half-resolution hack to squeeze more performance out of it. Commands are sent by holding the command pin low and sending the 8-bit command code over the serial bus, and then command data comes after with the command pin held high. I’m using 16-bit color, but it can accept 12-bit color to save bandwidth. The downside is you’ve got to worry about byte alignment, and that’s a pain.</p>

<p>Eventually I got a funky lil guy on my screen surrounded by undefined RAM data:</p>

<p><img src="https://artemis.sh/assets/images/2022-03-28-oxide-hubris-on-pinetime/lil-friend.jpg" alt="A lil face o some noise"/></p>

<p>A bit more effort and a detour into demoscene research and I got that neat twister you saw at the top of the screen!</p>

<h3 id="spi-is-dead-long-live-spi">SPI is dead, long live SPI.</h3>

<p>Remember how I mentioned earlier that SPI access from the LCD task is way faster? Well, I wanted to animate my twister and that’s when I ran into troubles, because screen updates were taking agonizingly long. It wasn’t so much an animation as it was a slideshow. As a result I was forced to cut the SPI task I worked so hard on out of the equation and give the SPI hardware address space over to my LCD task instead. This gave me the smooth animation I was looking for, but it was kind of disappointing to have to do. oh well!</p>

<h2 id="theres-a-long-way-to-go">There’s a long way to go</h2>

<p>Getting this project from where it is now to a fully functional smartwatch OS would be quite the endeavor. We’d need to bring up i2c to talk to the touch screen and other sensors, get the SPI flash working, implement a proper graphics stack. We’d need to write apps for the darn thing, or even have a watch face of any sort. We’d need to optimize everything for battery consumption as much as possible. All of this, and I haven’t even mentioned bluetooth, which would require finding a good bluetooth stack written in rust, or making one.</p>

<p>That’s far more than I care to do myself, though it might be possible to nerdsnipe me into helping if others want to work on it too. No promises.</p>

<p>Still, I hope you learned something, or just found this interesting. I know I sure have!</p>

        </article></div>
  </body>
</html>
