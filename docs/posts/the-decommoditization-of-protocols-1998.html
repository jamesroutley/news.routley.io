<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.levien.com/free/decommoditizing.html">Original</a>
    <h1>The Decommoditization of Protocols (1998)</h1>
    
    <div id="readability-page-1" class="page"><div>

<p> One of the most interesting things about Microsoft&#39;s <a href="http://www.scripting.com/misc/halloweenMemo.html">Halloween
Memo</a> is the concept of &#34;de-commoditizing&#34; protocols. This short
essay attempts to explain what this means, and what its effects on
free software are. I argue that decommoditized protocols are a very
effective weapon against free software in the short term, but in the
long term will help free software become more fulfilling to users. </p>

<p> I use the term &#34;protocol&#34; in a rather inclusive sense,
encompassing APIs, file formats, etc., not just the narrow sense of
networking protocols - in short, anything that software modules need
to be able to work with each other. </p>

<h2>
Background: free software and proprietary software
</h2>

<p> Decommoditized protocols are a marker for some fundamental
differences between free software and proprietary software, and the
philosophy that goes into them. </p>

<p> In an ideal world, software would be created to fulfill user
needs, and would be designed to be maximally usable. However, real
software gets created for somewhat different aims, sometimes in line
with these user needs, sometimes less so. </p>

<p> Proprietary software is created to make money for its authors. To
a first approximation, the best way to make money is to create a
highly usable product, so that users will be willing to pay for it.
However, at least two other factors come into play: </p>

<ul>

<li>Barriers to competition

</li><li>Network effects

</li></ul>

<p> For proprietary software to be profitable, it must create a
proprietary advantage. Thus, simple software that just gets the job
done has one serious disadvantage: a competitor can duplicate it.
Given the extremely low marginal cost of software, this inevitably
drives the price to near-zero. Thus, all truly profitable software has
built-in barriers to competition. </p>

<p> And the most effective way of creating those barriers is to
exploit network effects. Software doesn&#39;t exist in isolation - it&#39;s
constantly interworking with other modules, loading and storing files
in file formats, calling APIs, and communicating over the network. In
most cases the usefulness of the software depends more on how well it
interworks with other stuff than its own intrinsic merits. For
example, even if a new word processor comes along that&#39;s better than
Word, many people would be reluctant to switch because there are so
many existing documents in Word format. </p>

<p> Free software, by contrast, is written for lots of different
reasons, including a simple desire for the software on the part of the
author, education, and being part of the free software community.
However, getting the job done expediently is almost always an
overriding concern. Thus, free software tends not to be much more
complex than necessary, and making use of existing modules and
protocols is often more appealing than reinventing things from
scratch. </p>

<h2>
How to decommoditize a protocol
</h2>

<p> There are six things you can do: </p>

<ul>

<li>Make it more complex

</li><li>Incompletely specify it

</li><li>Fail to document it

</li><li>Change it rapidly

</li><li>Use encumbered intellectual property

</li><li>Add value (i.e. solve more problems, better performance)

</li></ul>

<p> Of these, only the last really makes the software more useful to
users. </p>

<h2>
Examples of commodity protocols
</h2>

<p> The very best commodity protocols solve hard problems, but make
it look simple. Two examples stand out: TCP/IP and HTTP/1.0. Neither
of these protocols is perfect. However, their commodity nature greatly
helped them take a foothold. </p>

<h3>
TCP/IP
</h3>

<p> TCP/IP is the foundation of the Internet. The protocol dates back
to the early days of the ARPANet, and has existed in its present form
since September 1981 (the date of <a href="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc791.txt">RFC
791</a> and <a href="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc793.txt">RFC
793</a>). This protocol violates all of the first five
principles of de-commoditization. </p>

<ul>

<li>It is simple. Together, the two RFCs span 130 simply formatted
pages, appendices and all. This is nothing short of astonishing,
considering how difficult a problem internetworking is considered to
be.

</li><li>It is completely specified. IETF protocols in general are well
known for specifying &#34;bits on the wire&#34;, and these protocols exemplify
IETF practice. There are no complicated options or variants. As a
consequence, TCP/IP implementations tend to work together very well.
(actually, you need to add a link layer to get a complete TCP/IP
implementation. However, <a href="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1055.txt">RFC
1055</a> describes such a link layer (SLIP) in six pages.

</li><li>It is well documented. The RFCs are a model of clarity, thanks in
large part to <a href="http://www.isoc.org/postel/">Jon Postel</a>.

</li><li>It is stable and mature. The protocol has been
in use since 1981, and has scaled by many orders of magnitude. Old
implementations <i>still work</i> on the modern Internet.

</li><li>It is unencumbered. No patents, copyrights, nor trademarks are
infringed by a working TCP/IP implementation.

</li></ul>

<p> To say that TCP/IP has been enormously successful would be an
understatement. </p>

<h3>
HTTP/1.0
</h3>

<p> Another example of a commodity protocol is version 1.0 of HTTP.
Like TCP/IP, it solves a hard problem (people had been trying to
implement global hypertexts for at least three decades before the Web
hit), but is very simple. Indeed, a working <a href="http://www.w3.org/Protocols/HTTP/HTTP2.html">HTTP/1.0</a> server
is a weekend hack, and doing a simpleminded client is pretty easy too.
</p>

<p> After the success of HTTP/1.0, however, the pressure to make the
standard more complex became too great to resist. As a consequence,
the <a href="http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-rev-05.txt">HTTP/1.1
spec</a> is about 167 pages long, and is still in the process of
revision at the time of this writing. A lot of what&#39;s in HTTP/1.1 is
good stuff (like pipelining), but a lot is also needless complexity. </p>

<h2>
Examples of de-commoditized protocols
</h2>

<h3>
The Microsoft Win32 API
</h3>

<p> Perhaps the most classic example of a decommoditized protocol is
the set of API&#39;s, DLL&#39;s, and other stuff comprising the Microsoft
Win32 environment. This protocol is extraordinarily complex,
incompletely specified (indeed, there are numerous inconsistencies
between Microsoft&#39;s own implementations), poorly documented, and
subject to rapid change. </p>

<p> As a consequence, the <a href="http://www.winehq.com/">Wine</a>
project (an attempt to implement the Win32 API within Linux) has found
it very rough going. But they will get there. </p>

<h3>
RealAudio
</h3>

<p> <a href="http://www.real.com">Real Networks</a> is a classic
example of a company that was able to leverage a proprietary protocol
into a successful business. Real has been upgrading the protocol
continuously, improving quality and compression. They&#39;ve used <a href="http://patent.womplex.ibm.com/details?pn=US05793980__">patents</a>,
undocumented protocols, rapid change, and added value to protect their
product. It&#39;s also a classic example of the network effect - the more
market share the clients have, the more motivation there is to provide
content in RealAudio form, and vice versa.
</p>

<h2>
How the IETF resists de-commoditization
</h2>

<p> <a href="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc2026.txt">IETF
process</a> actively resists de-commoditization in a number of ways.
Most importantly, they require two or more interoperable
implementations. This requirement puts a lot of pressure on the
proposed standard to be both simple and completely specified. </p>

<p> The process resists de-commoditization in a number of other
important ways, as well. It encourages the use of unencumbered
technology when an unencumbered alternative exists. The entire process
is conducted entirely in the open, with free availability of all
documents. And perhaps most importantly, there is a strong tradition
of standardizing technically excellent commodity protocols. </p>

<h2>
Unix<sup><a href="https://www.levien.com/free/unixtm.html#fuckin-idiots">TM</a></sup> in the &#39;80s: a case study of how de-commoditization can kill you
</h2>

<p> Back in the &#39;80s, many technically oriented people were hoping
that Unix would catch on in the PC marketplace. It was widely
recognized as a powerful and mature system, with many important
features such as networking, multitasking, and protected memory
(the last of which is <i>still</i> not completely implemented in MacOS
and Win9x). Of course, it required a lot more resources to run than
the &#34;toy&#34; PC&#39;s of the day were capable of, but it was also clear that
PC&#39;s were getting more powerful by the month. </p>

<p> None of this happened in the &#39;80s, though. I argue that
de-commoditization was a major culprit. All of the Unix vendors wished
for <i>their</i> brand of Unix to have a proprietary edge over the
others. Thus, it was to their advantage to add &#34;features&#34; that didn&#39;t
exist on other Unices. The goal was to lock developers into one
vendor&#39;s brand. If they were successful, the the resulting software
just wouldn&#39;t work well on other systems. </p>

<p> Unix vendors did ok during this time, but were never able to
compete effectively against PC operating systems. It was not until the
advent of Linux that Unix really started taking off in the PC world. I
believe that the success of Linux is due in large part to its
wholeheartedly embracing the essential commodity nature of
Unix. Indeed, Linux has fairly few features that were not present in
Unices of the &#39;80s.  The appeal of Linux is that it implements these
features extraordinarily well, and with an eye towards compatibility.
</p>

<h2>
Complexity
</h2>

<p> The design of software is a constant struggle against complexity.
On the one hand, the world is complex, and many difficult problems
inherently require complex solutions. On the other hand, it&#39;s quite
easy to add gratuitious complexity. The key difference is how much of
the problem the complex software solves (i.e. how much complexity is
exported to the other side of the protocol). </p>

<p> One example of this sometimes subtle distinction is the comparison
of <a href="http://developer.apple.com/fonts/WhitePapers/GXvsOTLayout.html">GX
vs. OpenType layout</a> by Dave Opstad. Dave points out that for an
application to support, say, Tibetan using OpenType, it still has to
do a lot of the work. In the GX model, it&#39;s done for you in the
operating system. Thus, even though OpenType and GX are roughly
comparable in complexity, <i>from the point of view of the
application</i> GX is &#34;simpler&#34;. Thus, overall complexity needs
to be weighed against how much of the problem is solved. </p>

<p> For a proprietary software organization that has just implemented
a complex piece of software, it is tempting to assign a zero cost to
the complexity. However, this would be quite wrong. Aside from the
simple issue of higher maintenance costs, having more complex
protocols makes the software far less agile, i.e. it is much more
difficult to adapt it to changing market conditions. </p>

<h2>
Conclusion
</h2>

<p> In spite of the strong financial incentives and remarkable market
successes of de-commoditized protocols, I believe that the future lies
with commodity protocols. Users are becoming frustrated with the
complexity, lack of consistency, poor documentation, and lack of
choice that de-commoditized systems suffer from. Conversely, systems
based entirely on commodity protocols have had their own share of
remarkable successes. </p>

<p> The fact that commodity protocols are simpler and more completely
specified than proprietary ones gives free software developers an
edge. Given the disadvantages that free software developers work under
(lack of funding being the most obvious), this edge is critically
important if free software is to realize its current promise as a
viable alternative to proprietary software as a tool for ordinary
people to get their work done. </p>

<p> <i>Thanks to the Gimp developers on #gimp for feedback on earlier
drafts.</i> </p>

</div></div>
  </body>
</html>
