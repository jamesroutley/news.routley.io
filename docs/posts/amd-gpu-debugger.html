<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thegeeko.me/blog/amd-gpu-debugging/">Original</a>
    <h1>AMD GPU Debugger</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-gjtny2mx=""> <div data-astro-cid-gjtny2mx="">    <a href="https://bytes.zone/" data-astro-cid-cjjlykpo=""> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-cjjlykpo=""> <path d="M2.5 6.5H9.5C11.1569 6.5 12.5 7.84315 12.5 9.5V9.5C12.5 11.1569 11.1569 12.5 9.5 12.5H7.5M2.5 6.5L5.5 9.5M2.5 6.5L5.5 3.5" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-cjjlykpo=""></path> </svg>
index
</a>        <p>I’ve always wondered why we don’t have a GPU debugger similar to the one used for CPUs. A tool that allows pausing execution and examining the current state. This capability feels essential, especially since the GPU’s concurrent execution model is much harder to reason about. After searching for solutions, I came across rocgdb, a debugger for AMD’s ROCm environment. Unfortunately, its scope is limited to that environment. Still, this shows it’s technically possible. I then found a helpful <a href="https://martty.github.io/posts/radbg_part_1/">series of blog posts</a> by <a href="https://martty.github.io/about/">Marcell Kiss</a>, detailing how he achieved this, which inspired me to try to recreate the process myself.</p>

<p>The best place to start learning about this is <a href="https://docs.mesa3d.org/drivers/radv.html">RADV</a>. By tracing what it does, we can find how to do it. Our goal here is to run the most basic shader <code>nop 0</code> without using Vulkan, aka RADV in our case.</p>
<p>First of all, we need to open the DRM file to establish a connection with the KMD, using a simple open(“/dev/dri/cardX”), then we find that it’s calling <code>amdgpu_device_initialize</code>, which is a function defined in <code>libdrm</code>, which is a library that acts as middleware between user mode drivers(UMD) like <code>RADV</code> and and kernel mode drivers(KMD) like amdgpu driver, and then when we try to do some actual work we have to create a context which can be achieved by calling <code>amdgpu_cs_ctx_create</code> from <code>libdrm</code> again, next up we need to allocate 2 buffers one of them for our code and the other for writing our commands into, we do this by calling a couple of functions, here’s how I do it:</p>
<pre tabindex="0" data-language="c"><code><span><span>void</span><span> bo_alloc</span><span>(</span><span>amdgpu_t</span><span>*</span><span> dev</span><span>,</span><span> size_t</span><span> size</span><span>,</span><span> u32 domain</span><span>,</span><span> bool</span><span> uncached</span><span>,</span><span> amdgpubo_t</span><span>*</span><span> bo) {</span></span>
<span><span> s32    ret         </span><span>=</span><span> -</span><span>1</span><span>;</span></span>
<span><span> u32    alignment   </span><span>=</span><span> 0</span><span>;</span></span>
<span><span> u32    flags       </span><span>=</span><span> 0</span><span>;</span></span>
<span><span> size_t</span><span> actual_size </span><span>=</span><span> 0</span><span>;</span></span>
<span></span>
<span><span> amdgpu_bo_handle bo_handle </span><span>=</span><span> NULL</span><span>;</span></span>
<span><span> amdgpu_va_handle va_handle </span><span>=</span><span> NULL</span><span>;</span></span>
<span><span> u64              va_addr   </span><span>=</span><span> 0</span><span>;</span></span>
<span><span> void*</span><span>            host_addr </span><span>=</span><span> NULL</span><span>;</span></span></code></pre>
<p>Here we’re choosing the domain and assigning flags based on the params, some buffers we will need uncached, as we will see:</p>
<pre tabindex="0" data-language="c"><code><span><span> if</span><span> (</span></span>
<span><span>   domain </span><span>!=</span><span> AMDGPU_GEM_DOMAIN_GWS </span><span>&amp;&amp;</span><span> domain </span><span>!=</span><span> AMDGPU_GEM_DOMAIN_GDS </span><span>&amp;&amp;</span></span>
<span><span>   domain </span><span>!=</span><span> AMDGPU_GEM_DOMAIN_OA) {</span></span>
<span><span>  actual_size </span><span>=</span><span> (size </span><span>+</span><span> 4096</span><span> -</span><span> 1</span><span>) </span><span>&amp;</span><span> 0x</span><span>FFFFFFFFFFFFF000</span><span>ULL</span><span>;</span></span>
<span><span>  alignment   </span><span>=</span><span> 4096</span><span>;</span></span>
<span><span>  flags       </span><span>=</span><span> AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED </span><span>|</span><span> AMDGPU_GEM_CREATE_VRAM_CLEARED </span><span>|</span></span>
<span><span>          AMDGPU_GEM_CREATE_VM_ALWAYS_VALID;</span></span>
<span><span>  flags </span><span>|=</span></span>
<span><span>    uncached </span><span>?</span><span> (domain </span><span>==</span><span> AMDGPU_GEM_DOMAIN_GTT) </span><span>*</span><span> AMDGPU_GEM_CREATE_CPU_GTT_USWC </span><span>:</span><span> 0</span><span>;</span></span>
<span><span> } </span><span>else</span><span> {</span></span>
<span><span>  actual_size </span><span>=</span><span> size;</span></span>
<span><span>  alignment   </span><span>=</span><span> 1</span><span>;</span></span>
<span><span>  flags       </span><span>=</span><span> AMDGPU_GEM_CREATE_NO_CPU_ACCESS;</span></span>
<span><span> }</span></span>
<span></span>
<span><span> struct</span><span> amdgpu_bo_alloc_request req </span><span>=</span><span> {</span></span>
<span><span>  .alloc_size     </span><span>=</span><span> actual_size</span><span>,</span></span>
<span><span>  .phys_alignment </span><span>=</span><span> alignment</span><span>,</span></span>
<span><span>  .preferred_heap </span><span>=</span><span> domain</span><span>,</span></span>
<span><span>  .flags          </span><span>=</span><span> flags</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> // memory aquired!!</span></span>
<span><span> ret </span><span>=</span><span> amdgpu_bo_alloc</span><span>(dev</span><span>-&gt;</span><span>dev_handle</span><span>,</span><span> &amp;</span><span>req</span><span>,</span><span> &amp;</span><span>bo_handle);</span></span>
<span><span> HDB_ASSERT</span><span>(</span><span>!</span><span>ret</span><span>,</span><span> &#34;can&#39;t allocate bo&#34;</span><span>);</span></span></code></pre>
<p>Now we have the memory, we need to map it. I opt to map anything that can be CPU-mapped for ease of use. We have to map the memory to both the GPU and the CPU virtual space. The KMD creates the page table when we open the DRM file, as shown <a href="https://elixir.bootlin.com/linux/v6.18/source/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c#L1425">here</a>.</p>
<p>So map it to the GPU VM and, if possible, to the CPU VM as well. Here, at this point, there’s a libdrm function that does all of this setup for us and maps the memory, but I found that even when specifying <code>AMDGPU_VM_MTYPE_UC</code>, it doesn’t always tag the page as uncached, not quite sure if it’s a
bug in my code or something in <code>libdrm</code> anyways, the function is <code>amdgpu_bo_va_op</code>, I opted to do it manually here and issue the IOCTL call myself:</p>
<pre tabindex="0" data-language="c"><code><span><span> u32 kms_handle </span><span>=</span><span> 0</span><span>;</span></span>
<span><span> amdgpu_bo_export</span><span>(bo_handle</span><span>,</span><span> amdgpu_bo_handle_type_kms</span><span>,</span><span> &amp;</span><span>kms_handle);</span></span>
<span></span>
<span><span> ret </span><span>=</span><span> amdgpu_va_range_alloc</span><span>(</span></span>
<span><span>   dev</span><span>-&gt;</span><span>dev_handle</span><span>,</span></span>
<span><span>   amdgpu_gpu_va_range_general</span><span>,</span></span>
<span><span>   actual_size</span><span>,</span></span>
<span><span>   4096</span><span>,</span></span>
<span><span>   0</span><span>,</span></span>
<span><span>   &amp;</span><span>va_addr</span><span>,</span></span>
<span><span>   &amp;</span><span>va_handle</span><span>,</span></span>
<span><span>   0</span><span>);</span></span>
<span><span> HDB_ASSERT</span><span>(</span><span>!</span><span>ret</span><span>,</span><span> &#34;can&#39;t allocate VA&#34;</span><span>);</span></span>
<span></span>
<span><span> u64 map_flags </span><span>=</span></span>
<span><span>   AMDGPU_VM_PAGE_EXECUTABLE </span><span>|</span><span> AMDGPU_VM_PAGE_READABLE </span><span>|</span><span> AMDGPU_VM_PAGE_WRITEABLE;</span></span>
<span><span> map_flags </span><span>|=</span><span> uncached </span><span>?</span><span> AMDGPU_VM_MTYPE_UC </span><span>|</span><span> AMDGPU_VM_PAGE_NOALLOC </span><span>:</span><span> 0</span><span>;</span></span>
<span></span>
<span><span> struct</span><span> drm_amdgpu_gem_va va </span><span>=</span><span> {</span></span>
<span><span>  .handle       </span><span>=</span><span> kms_handle</span><span>,</span></span>
<span><span>  .operation    </span><span>=</span><span> AMDGPU_VA_OP_MAP</span><span>,</span></span>
<span><span>  .flags        </span><span>=</span><span> map_flags</span><span>,</span></span>
<span><span>  .va_address   </span><span>=</span><span> va_addr</span><span>,</span></span>
<span><span>  .offset_in_bo </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .map_size     </span><span>=</span><span> actual_size</span><span>,</span></span>
<span></span>
<span><span> };</span></span>
<span></span>
<span><span> ret </span><span>=</span><span> drm_ioctl_write_read</span><span>(dev</span><span>-&gt;</span><span>drm_fd</span><span>,</span><span> DRM_AMDGPU_GEM_VA</span><span>,</span><span> &amp;</span><span>va</span><span>,</span><span> sizeof</span><span>(va));</span></span>
<span><span> HDB_ASSERT</span><span>(</span><span>!</span><span>ret</span><span>,</span><span> &#34;can&#39;t map bo in GPU space&#34;</span><span>);</span></span>
<span><span> // ret = amdgpu_bo_va_op(bo_handle, 0, actual_size, va_addr, map_flags,</span></span>
<span><span> // AMDGPU_VA_OP_MAP);</span></span>
<span></span>
<span><span> if</span><span> (flags </span><span>&amp;</span><span> AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED) {</span></span>
<span><span>  ret </span><span>=</span><span> amdgpu_bo_cpu_map(bo_handle</span><span>,</span><span> &amp;</span><span>host_addr)</span><span>;</span></span>
<span><span>  HDB_ASSERT(</span><span>!</span><span>ret</span><span>,</span><span> &#34;can&#39;t map bo in CPU space&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span>  // AMDGPU_GEM_CREATE_VRAM_CLEARED doesn&#39;t really memset the memory to 0 anyways for</span></span>
<span><span>  // debug I&#39;ll just do it manually for now</span></span>
<span><span>  memset(host_addr</span><span>,</span><span> 0x</span><span>0</span><span>,</span><span> actual_size)</span><span>;</span></span>
<span><span> }</span></span>
<span></span>
<span><span> *</span><span>bo </span><span>=</span><span> (</span><span>amdgpubo_t</span><span>){</span></span>
<span><span>  .bo_handle </span><span>=</span><span> bo_handle</span><span>,</span></span>
<span><span>  .va_handle </span><span>=</span><span> va_handle</span><span>,</span></span>
<span><span>  .va_addr   </span><span>=</span><span> va_addr</span><span>,</span></span>
<span><span>  .size      </span><span>=</span><span> actual_size</span><span>,</span></span>
<span><span>  .host_addr </span><span>=</span><span> host_addr</span><span>,</span></span>
<span><span> };</span></span>
<span><span>}</span></span></code></pre>
<p>Now we have the context and 2 buffers. Next, fill those buffers and send our commands to the KMD, which will then forward them to the Command Processor (CP) in the GPU for processing.</p>
<p>Let’s compile our code. We can use clang assembler for that, like this:</p>
<pre tabindex="0" data-language="c"><code><span><span># https:</span><span>//gitlab.freedesktop.org/martty/radbg-poc/-/blob/master/ll-as.sh</span></span>
<span><span>clang </span><span>-</span><span>c </span><span>-</span><span>x assembler </span><span>-</span><span>target amdgcn</span><span>-</span><span>amd</span><span>-</span><span>amdhsa </span><span>-</span><span>mcpu</span><span>=</span><span>gfx1100 </span><span>-</span><span>o </span><span>asm</span><span>.o </span><span>&#34;$1&#34;</span></span>
<span><span>objdump </span><span>-</span><span>h </span><span>asm</span><span>.o </span><span>|</span><span> grep .text </span><span>|</span><span> awk </span><span>&#39;{print &#34;dd if=&#39;</span><span>asm</span><span>.o</span><span>&#39; of=&#39;</span><span>asmc.bin</span><span>&#39; bs=1 count=$[0x&#34; $3 &#34;] skip=$[0x&#34; $6 &#34;] status=none&#34;}&#39;</span><span> |</span><span> bash</span></span>
<span><span>#rm </span><span>asm</span><span>.o</span></span></code></pre>
<p>The bash script compiles the code, and then we’re only interested in the actual machine code, so we use objdump to figure out the offset and the size of the section and copy it to a new file called asmc.bin, then we can just load the file and write its bytes to the CPU-mapped address of the code buffer.</p>
<p>Next up, filling in the commands. This was extremely confusing for me because it’s not well documented.
It was mostly learning how <code>RADV</code> does things and trying to do similar things. Also, shout-out to the folks on the Graphics Programming Discord server for helping me, especially Picoduck. The commands are encoded in a special format called <code>PM4 Packets</code>, which has multiple types. We only care about <code>Type 3</code>: each packet has an opcode and the number of bytes it contains.</p>
<p>The first thing we need to do is program the GPU registers, then dispatch the shader. Some of those registers are <code>rsrc[1-3]</code>; those registers are responsible for a number of configurations, pgm_[lo/hi], which hold the pointer to the code buffer and <code>num_thread_[x/y/z]</code>; those are responsible for the number of threads inside a work group. All of those are set using the <code>set shader register</code> packets, and here is how to encode them:</p>
<p><span>It’s worth mentioning that we can set multiple registers in 1 packet if they’re consecutive.</span></p>
<pre tabindex="0" data-language="c"><code><span><span>void</span><span> pkt3_set_sh_reg</span><span>(</span><span>pkt3_packets_t</span><span>*</span><span> packets</span><span>,</span><span> u32 reg</span><span>,</span><span> u32 value) {</span></span>
<span><span> HDB_ASSERT(</span></span>
<span><span>   reg </span><span>&gt;=</span><span> SI_SH_REG_OFFSET </span><span>&amp;&amp;</span><span> reg </span><span>&lt;</span><span> SI_SH_REG_END</span><span>,</span></span>
<span><span>   &#34;can&#39;t set register outside sh registers span&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> // packet header</span></span>
<span><span> da_append(packets</span><span>,</span><span> PKT3(PKT3_SET_SH_REG</span><span>,</span><span> 1</span><span>,</span><span> 0</span><span>))</span><span>;</span></span>
<span><span> // offset of the register</span></span>
<span><span> da_append(packets</span><span>,</span><span> (reg </span><span>-</span><span> SI_SH_REG_OFFSET) </span><span>/</span><span> 4</span><span>)</span><span>;</span></span>
<span><span> da_append(packets</span><span>,</span><span> value)</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Then we append the dispatch command:</p>
<pre tabindex="0" data-language="c"><code><span><span>// we&#39;re going for 1 thread since we want the simplest case here.</span></span>
<span></span>
<span><span>da_append</span><span>(</span><span>&amp;</span><span>pkt3_packets</span><span>,</span><span> PKT3</span><span>(PKT3_DISPATCH_DIRECT</span><span>,</span><span> 3</span><span>,</span><span> 0</span><span>) </span><span>|</span><span> PKT3_SHADER_TYPE_S</span><span>(</span><span>1</span><span>));</span></span>
<span><span>da_append</span><span>(</span><span>&amp;</span><span>pkt3_packets</span><span>,</span><span> 1</span><span>u</span><span>);</span></span>
<span><span>da_append</span><span>(</span><span>&amp;</span><span>pkt3_packets</span><span>,</span><span> 1</span><span>u</span><span>);</span></span>
<span><span>da_append</span><span>(</span><span>&amp;</span><span>pkt3_packets</span><span>,</span><span> 1</span><span>u</span><span>);</span></span>
<span><span>da_append</span><span>(</span><span>&amp;</span><span>pkt3_packets</span><span>,</span><span> dispatch_initiator);</span></span></code></pre>
<p>Now we want to write those commands into our buffer and send them to the KMD:</p>
<pre tabindex="0" data-language="c"><code><span><span>void</span><span> dev_submit</span><span>(</span></span>
<span><span>  amdgpu_t</span><span>*</span><span>         dev</span><span>,</span></span>
<span><span>  pkt3_packets_t</span><span>*</span><span>   packets</span><span>,</span></span>
<span><span>  amdgpu_bo_handle</span><span>*</span><span> buffers</span><span>,</span></span>
<span><span>  u32               buffers_count</span><span>,</span></span>
<span><span>  amdgpu_submit_t</span><span>*</span><span>  submit</span></span>
<span><span>) {</span></span>
<span><span> s32        ret </span><span>=</span><span> -</span><span>1</span><span>;</span></span>
<span><span> amdgpubo_t</span><span> ib  </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span></span>
<span><span> bo_alloc(dev</span><span>,</span><span> pkt3_size(packets)</span><span>,</span><span> AMDGPU_GEM_DOMAIN_GTT</span><span>,</span><span> false</span><span>,</span><span> &amp;</span><span>ib)</span><span>;</span></span>
<span><span> bo_upload(</span><span>&amp;</span><span>ib</span><span>,</span><span> packets</span><span>-&gt;</span><span>data</span><span>,</span><span> pkt3_size(packets))</span><span>;</span></span>
<span></span>
<span><span> amdgpu_bo_handle</span><span>*</span><span> bo_handles </span><span>=</span><span> // +1 for the indirect buffer</span></span>
<span><span>   (amdgpu_bo_handle</span><span>*</span><span>)</span><span>malloc(</span><span>sizeof</span><span>(amdgpu_bo_handle) </span><span>*</span><span> (buffers_count </span><span>+</span><span> 1</span><span>))</span><span>;</span></span>
<span></span>
<span><span> bo_handles[</span><span>0</span><span>] </span><span>=</span><span> ib</span><span>.</span><span>bo_handle;</span></span>
<span><span> for_range(i</span><span>,</span><span> 0</span><span>,</span><span> buffers_count)</span><span> {</span></span>
<span><span>  bo_handles[i </span><span>+</span><span> 1</span><span>] </span><span>=</span><span> buffers[i];</span></span>
<span><span> }</span></span>
<span></span>
<span><span> amdgpu_bo_list_handle bo_list </span><span>=</span><span> NULL</span><span>;</span></span>
<span><span> ret </span><span>=</span></span>
<span><span>   amdgpu_bo_list_create(</span><span>dev</span><span>-&gt;</span><span>dev_handle</span><span>,</span><span> buffers_count </span><span>+</span><span> 1</span><span>,</span><span> bo_handles</span><span>,</span><span> NULL</span><span>,</span><span> &amp;</span><span>bo_list)</span><span>;</span></span>
<span><span> HDB_ASSERT(</span><span>!</span><span>ret</span><span>,</span><span> &#34;can&#39;t create a bo list&#34;</span><span>)</span><span>;</span></span>
<span><span> free(bo_handles)</span><span>;</span></span>
<span></span>
<span><span> struct</span><span> amdgpu_cs_ib_info ib_info </span><span>=</span><span> {</span></span>
<span><span>  .flags         </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .ib_mc_address </span><span>=</span><span> ib</span><span>.</span><span>va_addr</span><span>,</span></span>
<span><span>  .size          </span><span>=</span><span> packets</span><span>-&gt;</span><span>count</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> struct</span><span> amdgpu_cs_request req </span><span>=</span><span> {</span></span>
<span><span>  .flags                  </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .ip_type                </span><span>=</span><span> AMDGPU_HW_IP_COMPUTE</span><span>,</span></span>
<span><span>  .ip_instance            </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .ring                   </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .resources              </span><span>=</span><span> bo_list</span><span>,</span></span>
<span><span>  .number_of_dependencies </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .dependencies           </span><span>=</span><span> NULL</span><span>,</span></span>
<span><span>  .number_of_ibs          </span><span>=</span><span> 1</span><span>,</span></span>
<span><span>  .ibs                    </span><span>=</span><span> &amp;</span><span>ib_info</span><span>,</span></span>
<span><span>  .seq_no                 </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>  .fence_info             </span><span>=</span><span> { </span><span>0</span><span> }</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> ret </span><span>=</span><span> amdgpu_cs_submit(</span><span>dev</span><span>-&gt;</span><span>ctx_handle</span><span>,</span><span> 0</span><span>,</span><span> &amp;</span><span>req</span><span>,</span><span> 1</span><span>)</span><span>;</span></span>
<span><span> HDB_ASSERT(</span><span>!</span><span>ret</span><span>,</span><span> &#34;can&#39;t submit indirect buffer request&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> *</span><span>submit </span><span>=</span><span> (</span><span>amdgpu_submit_t</span><span>){</span></span>
<span><span>    .ib </span><span>=</span><span> ib</span><span>,</span></span>
<span><span>    .bo_list </span><span>=</span><span> bo_list</span><span>,</span></span>
<span><span>    .fence </span><span>=</span><span> {</span></span>
<span><span>      .context </span><span>=</span><span> dev</span><span>-&gt;</span><span>ctx_handle</span><span>,</span></span>
<span><span>      .ip_type </span><span>=</span><span> AMDGPU_HW_IP_COMPUTE</span><span>,</span></span>
<span><span>      .ip_instance </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>      .ring </span><span>=</span><span> 0</span><span>,</span></span>
<span><span>      .fence </span><span>=</span><span> req</span><span>.</span><span>seq_no</span><span>,</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>  };</span></span>
<span><span>}</span></span></code></pre>
<p><span>Here is a good point to make a more complex shader that outputs something. For example, writing 1 to a buffer.</span></p>
<p>No GPU hangs ?! nothing happened ?! cool, cool, now we have a shader that runs on the GPU, what’s next? Let’s try to hang the GPU by pausing the execution, aka make the GPU trap.</p>

<p>The RDNA3’s ISA manual does mention 2 registers, <code>TBA, TMA</code>; here’s how they describe them respectively:</p>
<blockquote>
<p>Holds the pointer to the current trap handler program address. Per-VMID register. Bit [63] indicates if the trap
handler is present (1) or not (0) and is not considered part of the address
(bit[62] is replicated into address bit[63]).  Accessed via S_SENDMSG_RTN.</p>
</blockquote>
<blockquote>
<p>Temporary register for shader operations. For example, it can hold a pointer to memory used by the trap handler.</p>
</blockquote>
<p><span>You can configure the GPU to enter the trap handler when encountering certain exceptions listed in the RDNA3 ISA manual.</span></p>
<p>We know from <a href="https://martty.github.io/about/">Marcell Kiss’s</a> blog posts that we need to compile a trap handler, which is a normal shader the GPU switches to when encountering a <code>s_trap</code>. The TBA register has a special bit that indicates whether the trap handler is enabled.</p>
<p>Since these are privileged registers, we cannot write to them from user space. To bridge this gap for debugging, we can utilize the debugfs interface. Luckily, we have <a href="https://umr.readthedocs.io/en/main/intro.html">UMR</a>, which uses that debugfs interface, and it’s open source; we copy AMD’s homework here which is great.</p>

<p>The amdgpu KMD has a couple of files in debugfs under <code>/sys/kernel/debug/dri/{PCI address}</code>; one of them is <code>regs2</code>, which is an interface to a <a href="https://elixir.bootlin.com/linux/v6.18/source/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c#L369"><code>amdgpu_debugfs_regs2_write</code></a> in the kernel that writes to the registers. It works by simply opening the file, seeking the register’s offset, and then writing; it also performs some synchronisation and writes the value correctly. We need to provide more parameters about the register before writing to the file, tho and do that by using an ioctl call. Here are the ioctl arguments:</p>
<pre tabindex="0" data-language="c"><code><span><span>typedef</span><span> struct</span><span> amdgpu_debugfs_regs2_iocdata_v2 {</span></span>
<span><span> __u32 use_srbm</span><span>,</span><span> use_grbm</span><span>,</span><span> pg_lock;</span></span>
<span><span> struct</span><span> {</span></span>
<span><span>  __u32 se</span><span>,</span><span> sh</span><span>,</span><span> instance;</span></span>
<span><span> } grbm;</span></span>
<span><span> struct</span><span> {</span></span>
<span><span>  __u32 me</span><span>,</span><span> pipe</span><span>,</span><span> queue</span><span>,</span><span> vmid;</span></span>
<span><span> } srbm;</span></span>
<span><span> __u32 xcc_id;</span></span>
<span><span>} </span><span>regs2_ioc_data_t</span><span>;</span></span></code></pre>
<p>The 2 structs are because there are 2 types of registers, GRBM and SRBM, each of which is banked by different constructs; you can learn more about some of them here in <a href="https://docs.kernel.org/gpu/amdgpu/driver-core.html#gfx-compute-and-sdma-overall-behaviour">the Linux kernel documentation</a>.</p>
<p>Turns out our registers here are SBRM registers and banked by VMIDs, meaning each VMID has its own TBA and TMA registers. Cool, now we need to figure out the VMID of our process. As far as I understand, VMIDs are a way for the GPU to identify a specific process context, including the page table base address, so the address translation unit can translate a virtual memory address. The context is created when we open the DRM file. They get assigned dynamically at dispatch time, which is a problem for us; we want to write to those registers before dispatch.</p>
<p>We can obtain the VMID of the dispatched process by querying the <code>HW_ID2</code> register with s_getreg_b32. I do a hack here, by enabling the trap handler in every VMID, and there are 16 of them, the first being special, and used by the KMD and the last 8 allocated to the amdkfd driver. We loop over the remaining VMIDs and write to those registers. This can cause issues to other processes using other VMIDs by enabling trap handlers in them and writing the virtual address of our trap handler, which is only valid within our virtual memory address space. It’s relatively safe tho since most other processes won’t cause a trap<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>.</p>
<p>Now we can write to TMA and TBA, here’s the code:</p>
<pre tabindex="0" data-language="c"><code><span><span>void</span><span> dev_op_reg32</span><span>(</span></span>
<span><span>  amdgpu_t</span><span>*</span><span> dev</span><span>,</span><span> gc_11_reg_t</span><span> reg</span><span>,</span><span> regs2_ioc_data_t</span><span> ioc_data</span><span>,</span><span> reg_32_op_t</span><span> op</span><span>,</span><span> u32</span><span>*</span><span> value) {</span></span>
<span><span> s32 ret </span><span>=</span><span> 0</span><span>;</span></span>
<span></span>
<span><span> reg_info_t</span><span> reg_info     </span><span>=</span><span> gc_11_regs_infos[reg];</span></span>
<span><span> uint64_t</span><span>   reg_offset   </span><span>=</span><span> gc_11_regs_offsets[reg];</span></span>
<span><span> uint64_t</span><span>   base_offset  </span><span>=</span><span> dev</span><span>-&gt;</span><span>gc_regs_base_addr[</span><span>reg_info</span><span>.</span><span>soc_index];</span></span>
<span><span> uint64_t</span><span>   total_offset </span><span>=</span><span> (reg_offset </span><span>+</span><span> base_offset);</span></span>
<span></span>
<span><span> // seems like we&#39;re multiplying by 4 here because the registers database in UMRs</span></span>
<span><span> // source has them in indexes rather than bytes.</span></span>
<span><span> total_offset </span><span>*=</span><span> (</span><span>reg_info</span><span>.</span><span>type </span><span>==</span><span> REG_MMIO) </span><span>?</span><span> 4</span><span> :</span><span> 1</span><span>;</span></span>
<span></span>
<span><span> ret </span><span>=</span><span> hdb_ioctl(</span><span>dev</span><span>-&gt;</span><span>regs2_fd</span><span>,</span><span> AMDGPU_DEBUGFS_REGS2_IOC_SET_STATE_V2</span><span>,</span><span> &amp;</span><span>ioc_data)</span><span>;</span></span>
<span><span> HDB_ASSERT(</span><span>!</span><span>ret</span><span>,</span><span> &#34;Failed to set registers state&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> size_t</span><span> size </span><span>=</span><span> lseek(</span><span>dev</span><span>-&gt;</span><span>regs2_fd</span><span>,</span><span> total_offset</span><span>,</span><span> SEEK_SET)</span><span>;</span></span>
<span><span> HDB_ASSERT(size </span><span>==</span><span> total_offset</span><span>,</span><span> &#34;Failed to seek register address&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> switch</span><span> (op) {</span></span>
<span><span> case</span><span> REG_OP_READ </span><span>:</span><span> size </span><span>=</span><span> read</span><span>(dev</span><span>-&gt;</span><span>regs2_fd</span><span>,</span><span> value</span><span>,</span><span> 4</span><span>); </span><span>break</span><span>;</span></span>
<span><span> case</span><span> REG_OP_WRITE</span><span>:</span><span> size </span><span>=</span><span> write</span><span>(dev</span><span>-&gt;</span><span>regs2_fd</span><span>,</span><span> value</span><span>,</span><span> 4</span><span>); </span><span>break</span><span>;</span></span>
<span><span> default</span><span>          :</span><span> HDB_ASSERT</span><span>(</span><span>false</span><span>,</span><span> &#34;unsupported op&#34;</span><span>);</span></span>
<span><span> }</span></span>
<span></span>
<span><span> HDB_ASSERT(size </span><span>==</span><span> 4</span><span>,</span><span> &#34;Failed to write/read the values to/from the register&#34;</span><span>)</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>And here’s how we write to <code>TMA</code> and <code>TBA</code>:
<span>If you noticed, I’m using bitfields. I use them because working with them is much easier than macros, and while the byte order is not guaranteed by the C spec, it’s guaranteed by System V ABI, which Linux adheres to.</span></p>
<pre tabindex="0" data-language="c"><code><span><span>void</span><span> dev_setup_trap_handler</span><span>(</span><span>amdgpu_t</span><span>*</span><span> dev</span><span>,</span><span> u64 tba</span><span>,</span><span> u64 tma) {</span></span>
<span><span> reg_sq_shader_tma_lo_t</span><span> tma_lo </span><span>=</span><span> { .raw </span><span>=</span><span> (u32)(tma) };</span></span>
<span><span> reg_sq_shader_tma_hi_t</span><span> tma_hi </span><span>=</span><span> { .raw </span><span>=</span><span> (u32)(tma </span><span>&gt;&gt;</span><span> 32</span><span>) };</span></span>
<span></span>
<span><span> reg_sq_shader_tba_lo_t</span><span> tba_lo </span><span>=</span><span> { .raw </span><span>=</span><span> (u32)(tba </span><span>&gt;&gt;</span><span> 8</span><span>) };</span></span>
<span><span> reg_sq_shader_tba_hi_t</span><span> tba_hi </span><span>=</span><span> { .raw </span><span>=</span><span> (u32)(tba </span><span>&gt;&gt;</span><span> 40</span><span>) };</span></span>
<span></span>
<span><span> tba_hi</span><span>.</span><span>trap_en </span><span>=</span><span> 1</span><span>;</span></span>
<span></span>
<span><span> regs2_ioc_data_t</span><span> ioc_data </span><span>=</span><span> {</span></span>
<span><span>  .use_srbm </span><span>=</span><span> 1</span><span>,</span></span>
<span><span>  .xcc_id   </span><span>=</span><span> -</span><span>1</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> // NOTE(hadi):</span></span>
<span><span> // vmid&#39;s get assigned when code starts executing before hand we don&#39;t know which vmid</span></span>
<span><span> // will get assigned to our process so we just set all of them</span></span>
<span><span> for_range(i</span><span>,</span><span> 1</span><span>,</span><span> 9</span><span>)</span><span> {</span></span>
<span><span>  ioc_data</span><span>.</span><span>srbm</span><span>.</span><span>vmid </span><span>=</span><span> i;</span></span>
<span><span>  dev_op_reg32(dev</span><span>,</span><span> REG_SQ_SHADER_TBA_LO</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_WRITE</span><span>,</span><span> &amp;</span><span>tba_lo</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span>  dev_op_reg32(dev</span><span>,</span><span> REG_SQ_SHADER_TBA_HI</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_WRITE</span><span>,</span><span> &amp;</span><span>tba_hi</span><span>.</span><span>raw)</span><span>;</span></span>
<span></span>
<span><span>  dev_op_reg32(dev</span><span>,</span><span> REG_SQ_SHADER_TMA_LO</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_WRITE</span><span>,</span><span> &amp;</span><span>tma_lo</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span>  dev_op_reg32(dev</span><span>,</span><span> REG_SQ_SHADER_TMA_HI</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_WRITE</span><span>,</span><span> &amp;</span><span>tma_hi</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> }</span></span>
<span><span>}</span></span></code></pre>
<p>Anyway, now that we can write to those registers, if we enable the trap handler correctly, the GPU should hang when we launch our shader if we added <code>s_trap</code> instruction to it, or we enabled the <code>TRAP_ON_START</code> bit in rsrc3<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup> register.</p>
<p>Now, let’s try to write a trap handler.</p>

<p><span>If you wrote a different shader that outputs to a buffer, u can try writing to that shader from the trap handler, which is nice to make sure it’s actually being run.</span></p>
<p>We need 2 things: our trap handler and some scratch memory to use when needed, which we will store the address of in the TMA register.</p>
<p>The trap handler is just a normal program running in privileged state, meaning we have access to special registers like TTMP[0-15]. When we enter a trap handler, we need to first ensure that the state of the GPU registers is saved, just as the kernel does for CPU processes when context-switching, by saving a copy of the stable registers and the program counter, etc. The problem, tho, is that we don’t have a stable ABI for GPUs, or at least not one I’m aware of, and compilers use all the registers they can, so we need to save everything.</p>
<p>AMD GPUs’ Command Processors (CPs) have context-switching functionality, and the amdkfd driver does implement some <a href="https://elixir.bootlin.com/linux/v6.18/source/drivers/gpu/drm/amd/amdkfd/cwsr_trap_handler_gfx10.asm">context-switching shaders</a>. The problem is they’re not documented, and we have to figure them out from the amdkfd driver source and from other parts of the driver stack that interact with it, which is a pain in the ass. I kinda did a workaround here since I didn’t find luck understanding how it works, and some other reasons I’ll discuss later in the post.</p>
<p>The workaround here is to use only TTMP registers and a combination of specific instructions to copy the values of some registers, allowing us to use more instructions to copy the remaining registers. The main idea is to make use of the <code>global_store_addtid_b32</code> instruction, which adds the index of the current thread within the wave to the writing address, aka</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><msub><mi>D</mi><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub><mo>∗</mo><mn>4</mn><mo>+</mo><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ID_{thread} * 4 + address</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>I</span><span><span>D</span><span><span><span><span><span><span></span><span><span><span>t</span><span>h</span><span>re</span><span>a</span><span>d</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>∗</span><span></span></span><span><span></span><span>4</span><span></span><span>+</span><span></span></span><span><span></span><span>a</span><span>dd</span><span>ress</span></span></span></span></span></p><p>This allows us to write a unique value per thread using only TTMP registers, which are unique per wave, not per thread<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>, so we can save the context of a single wave.</p>
<p>The problem is that if we have more than 1 wave, they will overlap, and we will have a race condition.</p>
<p>Here is the code:</p>
<pre tabindex="0" data-language="asm"><code><span><span>start</span><span>:</span></span>
<span><span> ;; save the STATUS word into ttmp8</span></span>
<span><span> s_getreg_b32 ttmp8, hwreg(HW_REG_STATUS)</span></span>
<span></span>
<span><span> ;; save exec into ttmp[2:3]</span></span>
<span><span> s_mov_b64 ttmp[</span><span>2</span><span>:</span><span>3</span><span>], exec</span></span>
<span></span>
<span><span> ;; getting the address of our tma buffer</span></span>
<span><span> s_sendmsg_rtn_b64 ttmp[</span><span>4</span><span>:</span><span>5</span><span>], sendmsg(MSG_RTN_GET_TMA)</span></span>
<span><span> s_waitcnt lgkmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> ;; save vcc</span></span>
<span><span> s_mov_b64 ttmp[</span><span>6</span><span>:</span><span>7</span><span>], vcc</span></span>
<span></span>
<span><span> ;; enable all threads so they can write their vgpr registers</span></span>
<span><span> s_mov_b64 exec, -</span><span>1</span></span>
<span></span>
<span><span> ;; FIXME(hadi): this assumes only 1 wave is running</span></span>
<span><span> global_store_addtid_b32 v0, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET        glc slc dlc</span></span>
<span><span> global_store_addtid_b32 v1, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>256</span><span>  glc slc dlc</span></span>
<span><span> global_store_addtid_b32 v2, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>512</span><span>  glc slc dlc</span></span>
<span><span> global_store_addtid_b32 v3, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>768</span><span>  glc slc dlc</span></span>
<span><span> global_store_addtid_b32 v4, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>1024</span><span> glc slc dlc</span></span>
<span><span> global_store_addtid_b32 v5, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>1280</span><span> glc slc dlc</span></span>
<span><span> global_store_addtid_b32 v6, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>1536</span><span> glc slc dlc</span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> ;; only first thread is supposed to write sgprs of the wave</span></span>
<span><span> s_mov_b64 exec, </span><span>1</span></span>
<span><span> v_mov_b32 v1, s0</span></span>
<span><span> v_mov_b32 v2, s1</span></span>
<span><span> v_mov_b32 v3, s2</span></span>
<span><span> v_mov_b32 v4, s3</span></span>
<span><span> v_mov_b32 v5, s4</span></span>
<span><span> v_mov_b32 v0, </span><span>0</span></span>
<span><span> global_store_b32 v0, v1, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_SREG_OFFSET glc slc dlc</span></span>
<span><span> global_store_b32 v0, v2, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_SREG_OFFSET + </span><span>4</span><span> glc slc dlc</span></span>
<span><span> global_store_b32 v0, v3, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_SREG_OFFSET + </span><span>8</span><span> glc slc dlc</span></span>
<span><span> global_store_b32 v0, v4, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_SREG_OFFSET + </span><span>12</span><span> glc slc dlc</span></span>
<span><span> global_store_b32 v0, v5, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_SREG_OFFSET + </span><span>16</span><span> glc slc dlc</span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> ;; enable all threads</span></span>
<span><span> s_mov_b64 exec, -</span><span>1</span></span></code></pre>
<p>Now that we have those values in memory, we need to tell the CPU: Hey, we got the data, and pause the GPU’s execution until the CPU issues a command. Also, notice we can just modify those from the CPU.</p>
<p>Before we tell the CPU, we need to write some values that might help the CPU. Here are they:</p>
<pre tabindex="0" data-language="asm"><code><span><span> ;; IDs to identify which parts of the hardware we are running on exactly</span></span>
<span><span> s_getreg_b32 ttmp10, hwreg(HW_REG_HW_ID1)</span></span>
<span><span> s_getreg_b32 ttmp11, hwreg(HW_REG_HW_ID2)</span></span>
<span><span> v_mov_b32 v3, ttmp10</span></span>
<span><span> v_mov_b32 v4, ttmp11</span></span>
<span><span> global_store_dwordx2 v1, v[</span><span>3</span><span>:</span><span>4</span><span>], ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_DATA_OFFSET glc slc dlc</span></span>
<span></span>
<span><span> ;; the original vcc mask</span></span>
<span><span> v_mov_b32 v3, ttmp6</span></span>
<span><span> v_mov_b32 v4, ttmp7</span></span>
<span><span> global_store_dwordx2 v1, v[</span><span>3</span><span>:</span><span>4</span><span>], ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>2048</span><span> glc slc dlc</span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> ;; the original exec mask</span></span>
<span><span> v_mov_b32 v3, ttmp2</span></span>
<span><span> v_mov_b32 v4, ttmp3</span></span>
<span><span> global_store_dwordx2 v1, v[</span><span>3</span><span>:</span><span>4</span><span>], ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>2056</span><span> glc slc dlc</span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> ;; the program counter</span></span>
<span><span> v_mov_b32 v3, ttmp0</span></span>
<span><span> v_mov_b32 v4, ttmp1</span></span>
<span><span> v_and_b32 v4, v4, </span><span>0xffff</span></span>
<span><span> global_store_dwordx2 v1, v[</span><span>3</span><span>:</span><span>4</span><span>], ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>16</span><span> glc slc dlc</span></span>
<span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span></code></pre>
<p>Now the GPU should just wait for the CPU, and here’s the spin code it’s implemented as described by Marcell Kiss <a href="https://martty.github.io/posts/radbg_part_4/#busier-waiting">here</a>:</p>
<pre tabindex="0" data-language="asm"><code><span><span>SPIN</span><span>:</span></span>
<span><span> global_load_dword v1, v2, ttmp[</span><span>4</span><span>:</span><span>5</span><span>] glc slc dlc</span></span>
<span></span>
<span><span>SPIN1</span><span>:</span></span>
<span><span> // I found the bit range of </span><span>10</span><span> to </span><span>15</span><span> using trial </span><span>and</span><span> error </span><span>in</span><span> the</span></span>
<span><span> // isa manual specifies that it&#39;s a </span><span>6</span><span>-bit number but the offset </span><span>10</span></span>
<span><span> // is just trial </span><span>and</span><span> error</span></span>
<span><span>  s_getreg_b32 ttmp13, hwreg(HW_REG_IB_STS, </span><span>10</span><span>, </span><span>15</span><span>)</span></span>
<span><span> s_and_b32 ttmp13, ttmp13, ttmp13</span></span>
<span><span> s_cbranch_scc1 SPIN1</span></span>
<span></span>
<span><span> v_readfirstlane_b32 ttmp13, v1</span></span>
<span><span> s_and_b32 ttmp13, ttmp13, ttmp13</span></span>
<span><span> s_cbranch_scc0 SPIN</span></span>
<span></span>
<span><span>CLEAR</span><span>:</span></span>
<span><span> v_mov_b32 v2, </span><span>0</span></span>
<span><span> v_mov_b32 v1, </span><span>0</span></span>
<span><span> global_store_dword v1, v2, ttmp[</span><span>4</span><span>:</span><span>5</span><span>] glc slc dlc</span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span></code></pre>
<p>The main loop in the CPU is like enable trap handler, then dispatch shader, then wait for the GPU to write some specific value in a specific address to signal all data is there, then examine and display, and tell the GPU all clear, go ahead.</p>
<p>Now that our uncached buffers are in play, we just keep looping and checking whether the GPU has written the register values. When it does, the first thing we do is halt the wave by writing into the <code>SQ_CMD</code> register to allow us to do whatever with the wave without causing any issues, tho if we halt for too long, the GPU CP will reset the command queue and kill the process, but we can change that behaviour by adjusting <a href="https://www.kernel.org/doc/html/v4.20/gpu/amdgpu.html#module-parameters">lockup_timeout</a> parameter of the amdgpu kernel module:</p>
<pre tabindex="0" data-language="c"><code><span><span>reg_sq_wave_hw_id1_t</span><span> hw1 </span><span>=</span><span> { .raw </span><span>=</span><span> tma[</span><span>2</span><span>] };</span></span>
<span><span>reg_sq_wave_hw_id2_t</span><span> hw2 </span><span>=</span><span> { .raw </span><span>=</span><span> tma[</span><span>3</span><span>] };</span></span>
<span></span>
<span><span>reg_sq_cmd_t</span><span> halt_cmd </span><span>=</span><span> {</span></span>
<span><span> .cmd  </span><span>=</span><span> 1</span><span>,</span></span>
<span><span> .mode </span><span>=</span><span> 1</span><span>,</span></span>
<span><span> .data </span><span>=</span><span> 1</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>regs2_ioc_data_t</span><span> ioc_data </span><span>=</span><span> {</span></span>
<span><span> .use_srbm </span><span>=</span><span> false</span><span>,</span></span>
<span><span> .use_grbm </span><span>=</span><span> true</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>dev_op_reg32</span><span>(</span><span>&amp;</span><span>amdgpu</span><span>,</span><span> REG_SQ_CMD</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_WRITE</span><span>,</span><span> &amp;</span><span>halt_cmd.raw);</span></span>
<span><span>gpu_is_halted </span><span>=</span><span> true</span><span>;</span></span></code></pre>
<p>From here on, we can do whatever with the data we have. All the data we need to build a proper debugger. We will come back to what to do with the data in a bit; let’s assume we did what was needed for now.</p>
<p>Now that we’re done with the CPU, we need to write to the first byte in our TMA buffer, since the trap handler checks for that, then resume the wave, and the trap handler should pick it up. We can resume by writing to the <code>SQ_CMD</code> register again:</p>
<pre tabindex="0" data-language="c"><code><span><span>halt_cmd.mode </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>dev_op_reg32</span><span>(</span><span>&amp;</span><span>amdgpu</span><span>,</span><span> REG_SQ_CMD</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_WRITE</span><span>,</span><span> &amp;</span><span>halt_cmd.raw);</span></span>
<span><span>gpu_is_halted </span><span>=</span><span> false</span><span>;</span></span></code></pre>
<p>Then the GPU should continue. We need to restore everything and return the program counter to the original address. Based on whether it’s a hardware trap or not, the program counter may point to the instruction before or the instruction itself. The ISA manual and Marcell Kiss’s posts explain that well, so refer to them.</p>
<pre tabindex="0" data-language="asm"><code><span><span>RETURN</span><span>:</span></span>
<span><span> ;; extract the trap ID from ttmp1</span></span>
<span><span> s_and_b32 ttmp9, ttmp1, PC_HI_TRAP_ID_MASK</span></span>
<span><span> s_lshr_b32 ttmp9, ttmp9, PC_HI_TRAP_ID_SHIFT</span></span>
<span></span>
<span><span> ;; if the trapID == 0, then this is a hardware trap,</span></span>
<span><span> ;; we don&#39;t need to fix up the return address</span></span>
<span><span> s_cmpk_eq_u32 ttmp9, </span><span>0</span></span>
<span><span> s_cbranch_scc1 RETURN_FROM_NON_S_TRAP</span></span>
<span></span>
<span><span> ;; restore PC</span></span>
<span><span> ;; add 4 to the faulting address, with carry</span></span>
<span><span> s_add_u32 ttmp0, ttmp0, </span><span>4</span></span>
<span><span> s_addc_u32 ttmp1, ttmp1, </span><span>0</span></span>
<span></span>
<span><span>RETURN_FROM_NON_S_TRAP</span><span>:</span></span>
<span><span> s_load_dwordx4 s[</span><span>0</span><span>:</span><span>3</span><span>], ttmp[</span><span>4</span><span>:</span><span>5</span><span>], TMA_SREG_OFFSET glc dlc</span></span>
<span><span> s_load_dword s4, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], TMA_SREG_OFFSET + </span><span>16</span><span> glc dlc</span></span>
<span><span> s_waitcnt lgkmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> s_mov_b64 exec, -</span><span>1</span></span>
<span><span> global_load_addtid_b32 v0, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET        glc slc dlc</span></span>
<span><span> global_load_addtid_b32 v1, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>256</span><span>  glc slc dlc</span></span>
<span><span> global_load_addtid_b32 v2, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>512</span><span>  glc slc dlc</span></span>
<span><span> global_load_addtid_b32 v3, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>768</span><span>  glc slc dlc</span></span>
<span><span> global_load_addtid_b32 v4, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>1024</span><span> glc slc dlc</span></span>
<span><span> global_load_addtid_b32 v5, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>1280</span><span> glc slc dlc</span></span>
<span><span> global_load_addtid_b32 v6, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>offset</span><span>:</span><span>TMA_VREG_OFFSET + </span><span>1536</span><span> glc slc dlc</span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>)</span></span>
<span></span>
<span><span> ;; mask off non-address high bits from ttmp1</span></span>
<span><span> s_and_b32 ttmp1, ttmp1, </span><span>0xffff</span></span>
<span></span>
<span><span> ;; restore exec</span></span>
<span><span> s_load_b64 vcc, ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>2048</span><span> glc dlc</span></span>
<span><span> s_load_b64 ttmp[</span><span>2</span><span>:</span><span>3</span><span>], ttmp[</span><span>4</span><span>:</span><span>5</span><span>], </span><span>2056</span><span> glc dlc</span></span>
<span><span> s_waitcnt lgkmcnt(</span><span>0</span><span>)</span></span>
<span><span> s_mov_b64 exec, ttmp[</span><span>2</span><span>:</span><span>3</span><span>]</span></span>
<span></span>
<span><span> ;; restore STATUS.EXECZ, not writable by s_setreg_b32</span></span>
<span><span> s_and_b64 exec, exec, exec</span></span>
<span></span>
<span><span> ;; restore STATUS.VCCZ, not writable by s_setreg_b32</span></span>
<span><span> s_and_b64 vcc, vcc, vcc</span></span>
<span></span>
<span><span> ;; restore STATUS.SCC</span></span>
<span><span> s_setreg_b32 hwreg(HW_REG_STATUS, </span><span>0</span><span>, </span><span>1</span><span>), ttmp8</span></span>
<span></span>
<span><span> s_waitcnt vmcnt(</span><span>0</span><span>) lgkmcnt(</span><span>0</span><span>) expcnt(</span><span>0</span><span>)  </span><span>; Full pipeline flush</span></span>
<span><span> ;; return from trap handler and restore STATUS.PRIV</span></span>
<span><span> s_rfe_b64 [ttmp0, ttmp1]</span></span></code></pre>

<p>Now we can run compiled code directly, but we don’t want people to compile their code manually, then extract the text section, and give it to us. The plan is to take SPIR-V code, compile it correctly, then run it, or, even better, integrate with RADV and let RADV give us more information to work with.</p>
<p>My main plan was making like fork RADV and then add then make report for us the vulkan calls and then we can have a better view on the GPU work know the buffers/textures it’s using etc, This seems like a lot more work tho so I’ll keep it in mind but not doing that for now unless someone is willing to pay me for that ;).</p>
<p>For now, let’s just use RADV’s compiler <code>ACO</code>. Luckily, RADV has a <code>null_winsys</code> mode, aka it will not do actual work or open DRM files, just a fake Vulkan device, which is perfect for our case here, since we care about nothing other than just compiling code. We can enable it by setting the env var <code>RADV_FORCE_FAMILY</code>, then we just call what we need like this:</p>
<pre tabindex="0" data-language="c"><code><span><span>int32_t</span><span> hdb_compile_spirv_to_bin</span><span>(</span></span>
<span><span>  const</span><span> void*</span><span> spirv_binary</span><span>,</span></span>
<span><span>  size_t</span><span> size</span><span>,</span></span>
<span><span>  hdb_shader_stage_t</span><span> stage</span><span>,</span></span>
<span><span>  hdb_shader_t</span><span>*</span><span> shader</span></span>
<span><span>) {</span></span>
<span><span> setenv(</span><span>&#34;RADV_FORCE_FAMILY&#34;</span><span>,</span><span> &#34;navi31&#34;</span><span>,</span><span> 1</span><span>)</span><span>;</span></span>
<span><span> //  setenv(&#34;RADV_DEBUG&#34;, &#34;nocache,noopt&#34;, 1);</span></span>
<span><span> setenv(</span><span>&#34;ACO_DEBUG&#34;</span><span>,</span><span> &#34;nocache,noopt&#34;</span><span>,</span><span> 1</span><span>)</span><span>;</span></span>
<span></span>
<span><span> VkInstanceCreateInfo i_cinfo </span><span>=</span><span> {</span></span>
<span><span>  .sType </span><span>=</span><span> VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span>,</span></span>
<span><span>  .pApplicationInfo </span><span>=</span></span>
<span><span>    &amp;</span><span>(VkApplicationInfo){</span></span>
<span><span>      .sType              </span><span>=</span><span> VK_STRUCTURE_TYPE_APPLICATION_INFO</span><span>,</span></span>
<span><span>      .pApplicationName   </span><span>=</span><span> &#34;HDB Shader Compiler&#34;</span><span>,</span></span>
<span><span>      .applicationVersion </span><span>=</span><span> 1</span><span>,</span></span>
<span><span>      .pEngineName        </span><span>=</span><span> &#34;HDB&#34;</span><span>,</span></span>
<span><span>      .engineVersion      </span><span>=</span><span> 1</span><span>,</span></span>
<span><span>      .apiVersion         </span><span>=</span><span> VK_API_VERSION_1_4</span><span>,</span></span>
<span><span>    }</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> VkInstance vk_instance </span><span>=</span><span> {};</span></span>
<span><span> radv_CreateInstance(</span><span>&amp;</span><span>i_cinfo</span><span>,</span><span> NULL</span><span>,</span><span> &amp;</span><span>vk_instance)</span><span>;</span></span>
<span></span>
<span><span> struct</span><span> radv_instance</span><span>*</span><span> instance </span><span>=</span><span> radv_instance_from_handle(vk_instance)</span><span>;</span></span>
<span><span> instance</span><span>-&gt;</span><span>debug_flags </span><span>|=</span></span>
<span><span>   RADV_DEBUG_NIR_DEBUG_INFO </span><span>|</span><span> RADV_DEBUG_NO_CACHE </span><span>|</span><span> RADV_DEBUG_INFO;</span></span>
<span></span>
<span><span> uint32_t</span><span>         n       </span><span>=</span><span> 1</span><span>;</span></span>
<span><span> VkPhysicalDevice vk_pdev </span><span>=</span><span> {};</span></span>
<span><span> instance</span><span>-&gt;</span><span>vk</span><span>.</span><span>dispatch_table.</span><span>EnumeratePhysicalDevices</span><span>(</span><span>vk_instance</span><span>,</span><span> &amp;</span><span>n</span><span>,</span><span> &amp;</span><span>vk_pdev</span><span>);</span></span>
<span></span>
<span><span> struct</span><span> radv_physical_device</span><span>*</span><span> pdev </span><span>=</span><span> radv_physical_device_from_handle(vk_pdev)</span><span>;</span></span>
<span><span> pdev</span><span>-&gt;</span><span>use_llvm                    </span><span>=</span><span> false</span><span>;</span></span>
<span></span>
<span><span> VkDeviceCreateInfo d_cinfo </span><span>=</span><span> { VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO };</span></span>
<span><span> VkDevice vk_dev </span><span>=</span><span> {};</span></span>
<span><span> pdev</span><span>-&gt;</span><span>vk</span><span>.</span><span>dispatch_table.</span><span>CreateDevice</span><span>(</span><span>vk_pdev</span><span>,</span><span> &amp;</span><span>d_cinfo</span><span>,</span><span> NULL</span><span>,</span><span> &amp;</span><span>vk_dev</span><span>);</span></span>
<span></span>
<span><span> struct</span><span> radv_device</span><span>*</span><span> dev </span><span>=</span><span> radv_device_from_handle(vk_dev)</span><span>;</span></span>
<span></span>
<span><span> struct</span><span> radv_shader_stage radv_stage </span><span>=</span><span> {</span></span>
<span><span>  .</span><span>spirv</span><span>.</span><span>data </span><span>=</span><span> spirv_binary</span><span>,</span></span>
<span><span>  .</span><span>spirv</span><span>.</span><span>size </span><span>=</span><span> size</span><span>,</span></span>
<span><span>  .entrypoint </span><span>=</span><span> &#34;main&#34;</span><span>,</span></span>
<span><span>  .stage      </span><span>=</span><span> MESA_SHADER_COMPUTE</span><span>,</span></span>
<span><span>  .layout </span><span>=</span><span> {</span></span>
<span><span>   .push_constant_size </span><span>=</span><span> 16</span><span>,</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  .key </span><span>=</span><span> {</span></span>
<span><span>   .optimisations_disabled </span><span>=</span><span> true</span><span>,</span></span>
<span><span>  }</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> struct</span><span> radv_shader_binary</span><span>*</span><span> cs_bin </span><span>=</span><span> NULL</span><span>;</span></span>
<span><span> struct</span><span> radv_shader</span><span>*</span><span>        cs_shader </span><span>=</span></span>
<span><span>   radv_compile_cs(dev</span><span>,</span><span> NULL</span><span>,</span><span> &amp;</span><span>radv_stage</span><span>,</span><span> true</span><span>,</span><span> true</span><span>,</span><span> false</span><span>,</span><span> true</span><span>,</span><span> &amp;</span><span>cs_bin)</span><span>;</span></span>
<span></span>
<span><span> *</span><span>shader </span><span>=</span><span> (</span><span>hdb_shader_t</span><span>){</span></span>
<span><span>  .bin              </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>code</span><span>,</span></span>
<span><span>  .bin_size         </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>code_size</span><span>,</span></span>
<span><span>  .rsrc1            </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>config</span><span>.</span><span>rsrc1</span><span>,</span></span>
<span><span>  .rsrc2            </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>config</span><span>.</span><span>rsrc2</span><span>,</span></span>
<span><span>  .rsrc3            </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>config</span><span>.</span><span>rsrc3</span><span>,</span></span>
<span><span>  .debug_info       </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>debug_info</span><span>,</span></span>
<span><span>  .debug_info_count </span><span>=</span><span> cs_shader</span><span>-&gt;</span><span>debug_info_count</span><span>,</span></span>
<span><span> };</span></span>
<span></span>
<span><span> return</span><span> 0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Now that we have a well-structured loop and communication between the GPU and the CPU, we can run SPIR-V binaries to some extent. Let’s see how we can make it an actual debugger.</p>

<p>We talked earlier about CPs natively supporting context-switching, this appears to be compute spcific feature,
which prevents from implementing it for other types of shaders, tho, it appears that mesh shaders and raytracing
shaders are just compute shaders under the hood, which will allow us to use that functionality. For now debugging
one wave feels enough, also we can moify the wave parameters to debug some specific indices.</p>
<p>Here’s some of the features</p>
<h2 id="breakpoints-and-stepping">Breakpoints and Stepping</h2>
<p>For stepping, we can use 2 bits: one in <code>RSRC1</code> and the other in <code>RSRC3</code>. They’re <code>DEBUG_MODE</code> and <code>TRAP_ON_START</code>, respectively. The former enters the trap handler after each instruction, and the latter enters before the first instruction. This means we can automatically enable instruction-level stepping.</p>
<p>Regarding breakpoints, I haven’t implemented them, but they’re rather simple to implement here by us having the base address of the code buffer and knowing the size of each instruction; we can calculate the program counter location ahead and have a list of them available to the GPU, and we can do a binary search on the trap handler.</p>
<h2 id="source-code-line-mapping">Source Code Line Mapping</h2>
<p>The ACO shader compiler does generate instruction-level source code mapping, which is good enough for our purposes here. By taking the offset<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup> of the current program counter and indexing into the code buffer, we can retrieve the current instruction and disassemble it, as well as find the source code mapping from the debug info.</p>
<h2 id="address-watching-aka-watchpoints">Address Watching aka Watchpoints</h2>
<p>We can implement this by marking the GPU page as protected. On a GPU fault, we enter the trap handler, check whether it’s within the range of our buffers and textures, and then act accordingly. Also, looking at the registers, we can find these:</p>
<pre tabindex="0" data-language="c"><code><span><span>typedef</span><span> union</span><span> {</span></span>
<span><span> struct</span><span> {</span></span>
<span><span>  uint32_t</span><span> addr: </span><span>16</span><span>;</span></span>
<span><span> };</span></span>
<span><span> uint32_t</span><span> raw;</span></span>
<span><span>} </span><span>reg_sq_watch0_addr_h_t</span><span>;</span></span>
<span></span>
<span><span>typedef</span><span> union</span><span> {</span></span>
<span><span> struct</span><span> {</span></span>
<span><span>  uint32_t</span><span> __reserved_0 : </span><span>6</span><span>;</span></span>
<span><span>  uint32_t</span><span> addr: </span><span>26</span><span>;</span></span>
<span><span> };</span></span>
<span><span> uint32_t</span><span> raw;</span></span>
<span><span>} </span><span>reg_sq_watch0_addr_l_t</span><span>;</span></span></code></pre>
<p>which suggests that the hardware already supports this natively, so we don’t even need to do that dance. It needs more investigation on my part, tho, since I didn’t implement this.</p>
<h2 id="variables-types-and-names">Variables Types and Names</h2>
<p>This needs some serious plumbing, since we need to make NIR(Mesa’s intermediate representation) optimisation passes propagate debug info correctly. I already started on this <a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/37705">here</a>. Then we need to make ACO track variables and store the information.</p>
<h2 id="vulkan-integration">Vulkan Integration</h2>
<p>This requires ditching our simple UMD we made earlier and using RADV, which is what should happen eventually, then we have our custom driver maybe pause on before a specific frame, or get triggered by a key, and then ask before each dispatch if to attach to it or not, or something similar, since we have a full proper Vulkan implementation we already have all the information we would need like buffers, textures, push constants, types, variable names, .. etc, that would be a much better and more pleasant debugger to use.</p>
<hr/>
<p>Finally, here’s some live footage:</p>

    <figure>
      <iframe src="https://www.youtube.com/embed/HDMC9GhaLyc" title="YouTube video player" loading="lazy" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
    </figure>
    

<p>Here is an incomplete user-mode page walking code for gfx11, aka rx7900xtx</p>
<pre tabindex="0" data-language="c"><code><span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span> u64 valid         : </span><span>1</span><span>;</span><span>  // 0</span></span>
<span><span> u64 system        : </span><span>1</span><span>;</span><span>  // 1</span></span>
<span><span> u64 coherent      : </span><span>1</span><span>;</span><span>  // 2</span></span>
<span><span> u64 __reserved_0  : </span><span>3</span><span>;</span><span>  // 5</span></span>
<span><span> u64 pte_base_addr : </span><span>42</span><span>;</span><span> // 47</span></span>
<span><span> u64 pa_rsvd       : </span><span>4</span><span>;</span><span>  // 51</span></span>
<span><span> u64 __reserved_1  : </span><span>2</span><span>;</span><span>  // 53</span></span>
<span><span> u64 mall_reuse    : </span><span>2</span><span>;</span><span>  // 55</span></span>
<span><span> u64 tfs_addr      : </span><span>1</span><span>;</span><span>  // 56</span></span>
<span><span> u64 __reserved_2  : </span><span>1</span><span>;</span><span>  // 57</span></span>
<span><span> u64 frag_size     : </span><span>5</span><span>;</span><span>  // 62</span></span>
<span><span> u64 pte           : </span><span>1</span><span>;</span><span>  // 63</span></span>
<span><span>} </span><span>pde_t</span><span>;</span></span>
<span></span>
<span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span> u64 valid          : </span><span>1</span><span>;</span><span> // = pte_entry &amp; 1;</span></span>
<span><span> u64 system         : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 1) &amp; 1;</span></span>
<span><span> u64 coherent       : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 2) &amp; 1;</span></span>
<span><span> u64 tmz            : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 3) &amp; 1;</span></span>
<span><span> u64 execute        : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 4) &amp; 1;</span></span>
<span><span> u64 read           : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 5) &amp; 1;</span></span>
<span><span> u64 write          : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 6) &amp; 1;</span></span>
<span><span> u64 fragment       : </span><span>5</span><span>;</span><span> // = (pte_entry &gt;&gt; 7) &amp; 0x1F;</span></span>
<span><span> u64 page_base_addr : </span><span>36</span><span>;</span></span>
<span><span> u64 mtype          : </span><span>2</span><span>;</span><span> // = (pte_entry &gt;&gt; 48) &amp; 3;</span></span>
<span><span> u64 prt            : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 51) &amp; 1;</span></span>
<span><span> u64 software       : </span><span>2</span><span>;</span><span> // = (pte_entry &gt;&gt; 52) &amp; 3;</span></span>
<span><span> u64 pde            : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 54) &amp; 1;</span></span>
<span><span> u64 __reserved_0   : </span><span>1</span><span>;</span></span>
<span><span> u64 further        : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 56) &amp; 1;</span></span>
<span><span> u64 gcr            : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 57) &amp; 1;</span></span>
<span><span> u64 llc_noalloc    : </span><span>1</span><span>;</span><span> // = (pte_entry &gt;&gt; 58) &amp; 1;</span></span>
<span><span>} </span><span>pte_t</span><span>;</span></span>
<span></span>
<span><span>static</span><span> inline</span><span> pde_t</span><span> decode_pde</span><span>(u64 pde_raw) {</span></span>
<span><span> pde_t</span><span> pde         </span><span>=</span><span> *</span><span>((</span><span>pde_t</span><span>*</span><span>)(</span><span>&amp;</span><span>pde_raw));</span></span>
<span><span> pde</span><span>.</span><span>pte_base_addr </span><span>=</span><span> (u64)</span><span>pde</span><span>.</span><span>pte_base_addr </span><span>&lt;&lt;</span><span> 6</span><span>;</span></span>
<span><span> return</span><span> pde;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>static</span><span> inline</span><span> pte_t</span><span> decode_pte</span><span>(u64 pde_raw) {</span></span>
<span><span> pte_t</span><span> pte          </span><span>=</span><span> *</span><span>((</span><span>pte_t</span><span>*</span><span>)(</span><span>&amp;</span><span>pde_raw));</span></span>
<span><span> pte</span><span>.</span><span>page_base_addr </span><span>=</span><span> (u64)</span><span>pte</span><span>.</span><span>page_base_addr </span><span>&lt;&lt;</span><span> 12</span><span>;</span></span>
<span><span> return</span><span> pte;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>static</span><span> inline</span><span> u64 </span><span>log2_range_round_up</span><span>(u64 s</span><span>,</span><span> u64 e) {</span></span>
<span><span> u64 x </span><span>=</span><span> e </span><span>-</span><span> s </span><span>-</span><span> 1</span><span>;</span></span>
<span><span> return</span><span> (x </span><span>==</span><span> 0</span><span> ||</span><span> x </span><span>==</span><span> 1</span><span>) </span><span>?</span><span> 1</span><span> :</span><span> 64</span><span> -</span><span> __builtin_clzll(x)</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>void</span><span> dev_linear_vram</span><span>(</span><span>amdgpu_t</span><span>*</span><span> dev</span><span>,</span><span> u64 phy_addr</span><span>,</span><span> size_t</span><span> size</span><span>,</span><span> void*</span><span> buf) {</span></span>
<span><span> HDB_ASSERT(</span><span>!</span><span>((phy_addr </span><span>&amp;</span><span> 3</span><span>) </span><span>||</span><span> (size </span><span>&amp;</span><span> 3</span><span>))</span><span>,</span><span> &#34;Must be page aligned address and size&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> size_t</span><span> offset </span><span>=</span><span> lseek(</span><span>dev</span><span>-&gt;</span><span>vram_fd</span><span>,</span><span> phy_addr</span><span>,</span><span> SEEK_SET)</span><span>;</span></span>
<span><span> HDB_ASSERT(offset </span><span>==</span><span> phy_addr</span><span>,</span><span> &#34;Couldn&#39;t seek to the requested addr&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> offset </span><span>=</span><span> read(</span><span>dev</span><span>-&gt;</span><span>vram_fd</span><span>,</span><span> buf</span><span>,</span><span> size)</span><span>;</span></span>
<span><span> HDB_ASSERT(offset </span><span>==</span><span> size</span><span>,</span><span> &#34;Couldn&#39;t read the full requested size&#34;</span><span>)</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>void</span><span> dev_decode</span><span>(</span><span>amdgpu_t</span><span>*</span><span> dev</span><span>,</span><span> u32 vmid</span><span>,</span><span> u64 va_addr) {</span></span>
<span><span> reg_gcmc_vm_fb_location_base_t</span><span> fb_base_reg   </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcmc_vm_fb_location_top_t</span><span>  fb_top_reg    </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcmc_vm_fb_offset_t</span><span>        fb_offset_reg </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span></span>
<span><span> regs2_ioc_data_t</span><span> ioc_data </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> dev_op_reg32(</span></span>
<span><span>   dev</span><span>,</span><span> REG_GCMC_VM_FB_LOCATION_BASE</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>fb_base_reg</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> REG_GCMC_VM_FB_LOCATION_TOP</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>fb_top_reg</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> REG_GCMC_VM_FB_OFFSET</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>fb_offset_reg</span><span>.</span><span>raw)</span><span>;</span></span>
<span></span>
<span><span> u64 fb_offset </span><span>=</span><span> (u64)</span><span>fb_offset_reg</span><span>.</span><span>fb_offset;</span></span>
<span></span>
<span><span> // TODO(hadi): add zfb mode support</span></span>
<span><span> bool</span><span> zfb </span><span>=</span><span> fb_top_reg</span><span>.</span><span>fb_top </span><span>+</span><span> 1</span><span> &lt;</span><span> fb_base_reg</span><span>.</span><span>fb_base;</span></span>
<span><span> HDB_ASSERT(</span><span>!</span><span>zfb</span><span>,</span><span> &#34;ZFB mode is not implemented yet!&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> // printf(</span></span>
<span><span> //   &#34;fb base: 0x%x\nfb_top: 0x%x\nfb_offset: 0x%x\n&#34;,</span></span>
<span><span> //   fb_base_reg.raw,</span></span>
<span><span> //   fb_top_reg.raw,</span></span>
<span><span> //   fb_offset_reg.raw);</span></span>
<span></span>
<span><span> gc_11_reg_t</span><span> pt_start_lo_id </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> gc_11_reg_t</span><span> pt_start_hi_id </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> gc_11_reg_t</span><span> pt_end_lo_id   </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> gc_11_reg_t</span><span> pt_end_hi_id   </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> gc_11_reg_t</span><span> pt_base_hi_id  </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> gc_11_reg_t</span><span> pt_base_lo_id  </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> gc_11_reg_t</span><span> ctx_cntl_id    </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span></span>
<span><span> switch</span><span> (vmid) {</span></span>
<span><span> case</span><span> 0</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT0_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 1</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT1_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT1_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT1_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT1_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT1_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT1_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT1_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 2</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT2_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT2_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT2_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT2_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT2_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT2_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT2_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 3</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT3_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT3_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT3_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT3_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT3_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT3_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT3_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 4</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT4_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT4_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT4_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT4_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT4_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT4_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT4_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 5</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT5_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT5_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT5_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT5_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT5_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT5_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT5_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 6</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT6_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT6_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT6_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT6_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT6_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT6_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT6_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 7</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT7_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 8</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT8_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT8_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT8_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT8_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT7_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 9</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT9_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT9_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT9_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT9_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT7_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT7_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 10</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT10_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT10_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT10_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT10_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT10_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT10_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT10_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 11</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT11_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT11_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT11_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT11_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT11_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT11_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT11_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 12</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT12_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT12_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT12_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT12_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT12_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT12_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT12_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 13</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT13_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT13_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT13_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT13_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT13_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT13_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT13_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 14</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT14_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT14_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT14_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT14_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT14_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT14_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT14_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> case</span><span> 15</span><span>:</span></span>
<span><span>  pt_start_lo_id </span><span>=</span><span> REG_GCVM_CONTEXT15_PAGE_TABLE_START_ADDR_LO32;</span></span>
<span><span>  pt_start_hi_id </span><span>=</span><span> REG_GCVM_CONTEXT15_PAGE_TABLE_START_ADDR_HI32;</span></span>
<span><span>  pt_end_lo_id   </span><span>=</span><span> REG_GCVM_CONTEXT15_PAGE_TABLE_END_ADDR_LO32;</span></span>
<span><span>  pt_end_hi_id   </span><span>=</span><span> REG_GCVM_CONTEXT15_PAGE_TABLE_END_ADDR_HI32;</span></span>
<span><span>  pt_base_lo_id  </span><span>=</span><span> REG_GCVM_CONTEXT15_PAGE_TABLE_BASE_ADDR_LO32;</span></span>
<span><span>  pt_base_hi_id  </span><span>=</span><span> REG_GCVM_CONTEXT15_PAGE_TABLE_BASE_ADDR_HI32;</span></span>
<span><span>  ctx_cntl_id    </span><span>=</span><span> REG_GCVM_CONTEXT15_CNTL;</span></span>
<span><span>  break</span><span>;</span></span>
<span><span> default</span><span>:</span><span> HDB_ASSERT</span><span>(</span><span>false</span><span>,</span><span> &#34;Out of range VMID 0-15 trying to access </span><span>%u</span><span>&#34;</span><span>,</span><span> vmid);</span></span>
<span><span> }</span></span>
<span></span>
<span><span> // all the types of the contexts are the same so will just use 0 but pass the correct</span></span>
<span><span> // register enum to the read function</span></span>
<span><span> reg_gcvm_context0_page_table_start_addr_lo32_t</span><span> pt_start_lo </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcvm_context0_page_table_start_addr_hi32_t</span><span> pt_start_hi </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcvm_context0_page_table_end_addr_lo32_t</span><span>   pt_end_lo   </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcvm_context0_page_table_end_addr_hi32_t</span><span>   pt_end_hi   </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcvm_context0_page_table_base_addr_lo32_t</span><span>  pt_base_lo  </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcvm_context0_page_table_base_addr_hi32_t</span><span>  pt_base_hi  </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> reg_gcvm_context0_cntl_t</span><span>                       ctx_cntl    </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> pt_start_lo_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>pt_start_lo</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> pt_start_hi_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>pt_start_hi</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> pt_end_lo_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>pt_end_lo</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> pt_end_hi_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>pt_end_hi</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> pt_base_lo_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>pt_base_lo</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> pt_base_hi_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>pt_base_hi</span><span>.</span><span>raw)</span><span>;</span></span>
<span><span> dev_op_reg32(dev</span><span>,</span><span> ctx_cntl_id</span><span>,</span><span> ioc_data</span><span>,</span><span> REG_OP_READ</span><span>,</span><span> &amp;</span><span>ctx_cntl</span><span>.</span><span>raw)</span><span>;</span></span>
<span></span>
<span><span> u64 pt_start_addr </span><span>=</span><span> ((u64)</span><span>pt_start_lo</span><span>.</span><span>raw </span><span>&lt;&lt;</span><span> 12</span><span>) </span><span>|</span><span> ((u64)</span><span>pt_start_hi</span><span>.</span><span>raw </span><span>&lt;&lt;</span><span> 44</span><span>);</span></span>
<span><span> u64 pt_end_addr   </span><span>=</span><span> ((u64)</span><span>pt_end_lo</span><span>.</span><span>raw </span><span>&lt;&lt;</span><span> 12</span><span>) </span><span>|</span><span> ((u64)</span><span>pt_end_hi</span><span>.</span><span>raw </span><span>&lt;&lt;</span><span> 44</span><span>);</span></span>
<span><span> u64 pt_base_addr  </span><span>=</span><span> ((u64)</span><span>pt_base_lo</span><span>.</span><span>raw </span><span>&lt;&lt;</span><span> 0</span><span>) </span><span>|</span><span> ((u64)</span><span>pt_base_hi</span><span>.</span><span>raw </span><span>&lt;&lt;</span><span> 32</span><span>);</span></span>
<span><span> u32 pt_depth      </span><span>=</span><span> ctx_cntl</span><span>.</span><span>page_table_depth;</span></span>
<span><span> u32 ptb_size      </span><span>=</span><span> ctx_cntl</span><span>.</span><span>page_table_block_size;</span></span>
<span></span>
<span><span> HDB_ASSERT(pt_base_addr </span><span>!=</span><span> 0x</span><span>ffffffffffffffff</span><span>ull</span><span>,</span><span> &#34;Invalid page table base addr&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> printf(</span></span>
<span><span>   &#34;\tPage Table Start: 0x</span><span>%lx</span><span>\n\tPage Table End: 0x</span><span>%lx</span><span>\n\tPage Table Base: &#34;</span></span>
<span><span>   &#34;0x</span><span>%lx</span><span>\n\tPage Table Depth: </span><span>%u</span><span>\n\tBlock Size: </span><span>%u</span><span>\n&#34;</span><span>,</span></span>
<span><span>   pt_start_addr</span><span>,</span></span>
<span><span>   pt_end_addr</span><span>,</span></span>
<span><span>   pt_base_addr</span><span>,</span></span>
<span><span>   pt_depth</span><span>,</span></span>
<span><span>   ptb_size)</span><span>;</span></span>
<span></span>
<span><span> // decode base PDB</span></span>
<span><span> pde_t</span><span> pde </span><span>=</span><span> decode_pde(pt_base_addr)</span><span>;</span></span>
<span><span> pt_base_addr </span><span>-=</span><span> fb_offset </span><span>*</span><span> !</span><span>pde</span><span>.</span><span>system;</span><span> // substract only on vram</span></span>
<span></span>
<span><span> u64 pt_last_byte_addr </span><span>=</span><span> pt_end_addr </span><span>+</span><span> 0x</span><span>fff</span><span>;</span><span> // 0xfff is 1 page</span></span>
<span><span> HDB_ASSERT(</span></span>
<span><span>   pt_start_addr </span><span>&lt;=</span><span> va_addr </span><span>||</span><span> va_addr </span><span>&lt;</span><span> pt_last_byte_addr</span><span>,</span></span>
<span><span>   &#34;Invalid virtual address outside the range of the root page table of this vm&#34;</span><span>)</span><span>;</span></span>
<span></span>
<span><span> va_addr </span><span>-=</span><span> pt_start_addr;</span></span>
<span><span> //</span></span>
<span><span> // Size of the first PDB depends on the total coverage of the</span></span>
<span><span> // page table and the PAGE_TABLE_BLOCK_SIZE.</span></span>
<span><span> // Entire table takes ceil(log2(total_vm_size)) bits</span></span>
<span><span> // All PDBs except the first one take 9 bits each</span></span>
<span><span> // The PTB covers at least 2 MiB (21 bits)</span></span>
<span><span> // And PAGE_TABLE_BLOCK_SIZE is log2(num 2MiB ranges PTB covers)</span></span>
<span><span> // As such, the formula for the size of the first PDB is:</span></span>
<span><span> //                       PDB1, PDB0, etc.      PTB covers at least 2 MiB</span></span>
<span><span> //                                        Block size can make it cover more</span></span>
<span><span> //   total_vm_bits - (9 * num_middle_pdbs) - (page_table_block_size + 21)</span></span>
<span><span> //</span></span>
<span><span> // we need the total range range here not the last byte addr like above</span></span>
<span><span> u32 total_vaddr_bits </span><span>=</span><span> log2_range_round_up(pt_start_addr</span><span>,</span><span> pt_end_addr </span><span>+</span><span> 0x</span><span>1000</span><span>)</span><span>;</span></span>
<span></span>
<span><span> u32 total_pdb_bits </span><span>=</span><span> total_vaddr_bits;</span></span>
<span><span> // substract everything from the va_addr to leave just the pdb bits</span></span>
<span><span> total_pdb_bits </span><span>-=</span><span> 9</span><span> *</span><span> (pt_depth </span><span>-</span><span> 1</span><span>);</span><span> // middle PDBs each is 9 bits</span></span>
<span><span> total_pdb_bits </span><span>-=</span><span> (ptb_size </span><span>+</span><span> 21</span><span>);</span><span>    // at least 2mb(21) bits + ptb_size</span></span>
<span></span>
<span><span> // u64 va_mask = (1ull &lt;&lt; total_pdb_bits) - 1;</span></span>
<span><span> // va_mask &lt;&lt;= (total_vaddr_bits - total_pdb_bits);</span></span>
<span></span>
<span><span> // pde_t pdes[8]  = { 0 };</span></span>
<span><span> // u32   curr_pde = 0;</span></span>
<span><span> // u64   pde_addr = 0;</span></span>
<span><span> // u64  loop_pde = pt_base_addr;</span></span>
<span></span>
<span><span> if</span><span> (pt_depth </span><span>==</span><span> 0</span><span>) { </span><span>HDB_ASSERT(</span><span>false</span><span>,</span><span> &#34;DEPTH = 0 is not implemented yet&#34;</span><span>)</span><span>; }</span></span>
<span></span>
<span><span> pde_t</span><span> curr_pde    </span><span>=</span><span> pde;</span></span>
<span><span> u64   entry_bits  </span><span>=</span><span> 0</span><span>;</span></span>
<span><span> s32   curr_depth  </span><span>=</span><span> pt_depth;</span></span>
<span><span> bool</span><span>  pde0_is_pte </span><span>=</span><span> false</span><span>;</span></span>
<span><span> // walk all middle PDEs</span></span>
<span><span> while</span><span> (curr_depth </span><span>&gt;</span><span> 0</span><span>) {</span></span>
<span><span>  // printf(&#34;pde(%u):0x%lx \n&#34;, curr_depth, curr_pde.pte_base_addr);</span></span>
<span><span>  u64 next_entry_addr </span><span>=</span><span> 0</span><span>;</span></span>
<span></span>
<span><span>  u32 shift_amount </span><span>=</span><span> total_vaddr_bits;</span></span>
<span><span>  shift_amount </span><span>-=</span><span> total_pdb_bits;</span></span>
<span><span>  // for each pdb shift 9 more</span></span>
<span><span>  shift_amount </span><span>-=</span><span> ((pt_depth </span><span>-</span><span> curr_depth) </span><span>*</span><span> 9</span><span>);</span></span>
<span></span>
<span><span>  // shift address and mask out unused bits</span></span>
<span><span>  u64 next_pde_idx </span><span>=</span><span> va_addr </span><span>&gt;&gt;</span><span> shift_amount;</span></span>
<span><span>  next_pde_idx </span><span>&amp;=</span><span> 0x</span><span>1ff</span><span>;</span></span>
<span></span>
<span><span>  // if on vram we need to apply this offset</span></span>
<span><span>  if</span><span> (</span><span>!</span><span>curr_pde</span><span>.</span><span>system) </span><span>curr_pde</span><span>.</span><span>pte_base_addr </span><span>-=</span><span> fb_offset;</span></span>
<span></span>
<span><span>  next_entry_addr </span><span>=</span><span> curr_pde</span><span>.</span><span>pte_base_addr </span><span>+</span><span> next_pde_idx </span><span>*</span><span> 8</span><span>;</span></span>
<span><span>  curr_depth</span><span>--</span><span>;</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>!</span><span>curr_pde</span><span>.</span><span>system) {</span></span>
<span><span>   dev_linear_vram(dev</span><span>,</span><span> next_entry_addr</span><span>,</span><span> 8</span><span>,</span><span> &amp;</span><span>entry_bits)</span><span>;</span></span>
<span><span>   curr_pde </span><span>=</span><span> decode_pde(entry_bits)</span><span>;</span></span>
<span><span>   printf(</span></span>
<span><span>     &#34;\tPage Dir Entry(</span><span>%u</span><span>):\n\t  Addr:0x</span><span>%lx</span><span>\n\t  Base: 0x</span><span>%lx</span><span>\n\n\t        ↓\n\n&#34;</span><span>,</span></span>
<span><span>     curr_depth</span><span>,</span></span>
<span><span>     next_entry_addr</span><span>,</span></span>
<span><span>     curr_pde</span><span>.</span><span>pte_base_addr)</span><span>;</span></span>
<span><span>  } </span><span>else</span><span> {</span></span>
<span><span>   HDB_ASSERT(</span><span>false</span><span>,</span><span> &#34;GTT physical memory access is not implemented yet&#34;</span><span>)</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>!</span><span>curr_pde</span><span>.</span><span>valid) { </span><span>break</span><span>; }</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>curr_pde</span><span>.</span><span>pte) {</span></span>
<span><span>   // PDB0 can act as a pte</span></span>
<span><span>   // also I&#39;m making an assumption here that UMRs code doesn&#39;t make</span></span>
<span><span>   // that the the PDB0 as PTE path can&#39;t have the further bit set</span></span>
<span><span>   pde0_is_pte </span><span>=</span><span> true</span><span>;</span></span>
<span><span>   break</span><span>;</span></span>
<span><span>  }</span></span>
<span><span> }</span></span>
<span></span>
<span><span> if</span><span> (pde0_is_pte) { </span><span>HDB_ASSERT(</span><span>false</span><span>,</span><span> &#34;PDE0 as PTE is not implemented yet&#34;</span><span>)</span><span>; }</span></span>
<span></span>
<span><span> // page_table_block_size is the number of 2MiB regions covered by a PTB</span></span>
<span><span> // If we set it to 0, then PTB cover 2 MiB</span></span>
<span><span> // If it&#39;s 9 PTB cover 1024 MiB</span></span>
<span><span> // pde0_block_fragment_size tells us how many 4 KiB regions each PTE covers</span></span>
<span><span> // If it&#39;s 0 PTEs cover 4 KiB</span></span>
<span><span> // If it&#39;s 9 PTEs cover 2 MiB</span></span>
<span><span> // So the number of PTEs in a PTB is 2^(9+ptbs-pbfs)</span></span>
<span><span> //</span></span>
<span><span> // size here is actually the log_2 of the size</span></span>
<span><span> u32 pte_page_size  </span><span>=</span><span> curr_pde</span><span>.</span><span>frag_size;</span></span>
<span><span> u32 ptes_per_ptb   </span><span>=</span><span> 9</span><span> +</span><span> ptb_size </span><span>-</span><span> pte_page_size;</span></span>
<span><span> u64 pte_index_mask </span><span>=</span><span> (</span><span>1</span><span>ul</span><span> &lt;&lt;</span><span> ptes_per_ptb) </span><span>-</span><span> 1</span><span>;</span></span>
<span></span>
<span><span> u32 pte_bits_count   </span><span>=</span><span> pte_page_size </span><span>+</span><span> 12</span><span>;</span></span>
<span><span> u64 page_offset_mask </span><span>=</span><span> (</span><span>1</span><span>ul</span><span> &lt;&lt;</span><span> pte_bits_count) </span><span>-</span><span> 1</span><span>;</span><span> // minimum of 12</span></span>
<span></span>
<span><span> u64 pte_index </span><span>=</span><span> (va_addr </span><span>&gt;&gt;</span><span> pte_bits_count) </span><span>&amp;</span><span> pte_index_mask;</span></span>
<span><span> u64 pte_addr  </span><span>=</span><span> curr_pde</span><span>.</span><span>pte_base_addr </span><span>+</span><span> pte_index </span><span>*</span><span> 8</span><span>;</span></span>
<span></span>
<span><span> pte_t</span><span> pte </span><span>=</span><span> { </span><span>0</span><span> };</span></span>
<span><span> if</span><span> (</span><span>!</span><span>curr_pde</span><span>.</span><span>system) {</span></span>
<span><span>  dev_linear_vram(dev</span><span>,</span><span> pte_addr</span><span>,</span><span> 8</span><span>,</span><span> &amp;</span><span>entry_bits)</span><span>;</span></span>
<span><span>  pte </span><span>=</span><span> decode_pte(entry_bits)</span><span>;</span></span>
<span></span>
<span><span>  printf(</span><span>&#34;\tPage Table Entry: 0x</span><span>%lx</span><span>\n&#34;</span><span>,</span><span> pte</span><span>.</span><span>page_base_addr)</span><span>;</span></span>
<span><span> } </span><span>else</span><span> {</span></span>
<span><span>  HDB_ASSERT(</span><span>false</span><span>,</span><span> &#34;GTT physical memory access is not implemented yet&#34;</span><span>)</span><span>;</span></span>
<span><span> }</span></span>
<span></span>
<span><span> if</span><span> (</span><span>pte</span><span>.</span><span>further) { </span><span>HDB_ASSERT(</span><span>false</span><span>,</span><span> &#34;PTE as PDE walking is not implemented yet&#34;</span><span>)</span><span>; }</span></span>
<span><span> if</span><span> (</span><span>!</span><span>pte</span><span>.</span><span>system) </span><span>pte</span><span>.</span><span>page_base_addr </span><span>-=</span><span> fb_offset;</span></span>
<span></span>
<span><span> u64 offset_in_page </span><span>=</span><span> va_addr </span><span>&amp;</span><span> page_offset_mask;</span></span>
<span><span> u64 physical_addr  </span><span>=</span><span> pte</span><span>.</span><span>page_base_addr </span><span>+</span><span> offset_in_page;</span></span>
<span><span> printf(</span><span>&#34;\tFinal Physical Address: 0x</span><span>%lx</span><span>\n&#34;</span><span>,</span><span> physical_addr)</span><span>;</span></span>
<span><span>}</span></span></code></pre>
  </div> </div></div>
  </body>
</html>
