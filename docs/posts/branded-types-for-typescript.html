<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.carlos-menezes.com/post/branded-types">Original</a>
    <h1>Branded types for TypeScript</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="contents">Contents</h2>
<ul>
<li><span><a data-accent-color="blue" href="#introduction" node="[object Object]">Introduction</a></span></li>
<li><span><a data-accent-color="blue" href="#issue" node="[object Object]">Issue</a></span></li>
<li><span><a data-accent-color="blue" href="#solution" node="[object Object]">Solution</a></span></li>
</ul>

<p><span>Branded types in TypeScript enable the creation of new types by affixing a type tag to an existing underlying type. This tag, commonly referred to as the &#34;brand&#34;, distinguishes values of the branded type from others sharing the same underlying type. Acting as a compile-time validator, the brand ensures that values are utilized correctly within their intended contexts.</span></p>
<p><span>Imagine a scenario where a function generates a hash from a string input. Without the use of branded types, the function signature lacks specificity regarding the nature of the returned string, potentially leading to confusion or misuse in the codebase.</span></p><pre><p><code><span>const</span><span> generateHash </span><span>=</span><span> </span><span>(</span><span>input</span><span>:</span><span> </span><span>string</span><span>)</span><span>:</span><span> </span><span>string</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>  </span><span>return</span><span> </span><span>&#34;hashed_&#34;</span><span> </span><span>+</span><span> input</span><span>;</span><span> </span><span>// For demonstration, appending &#34;hashed_&#34; to input</span><span>
</span><span></span><span>}</span><span>;</span><span>
</span>
<span></span><span>// Ideally, we only want to pass hashes to this function</span><span>
</span><span></span><span>const</span><span> compareHash </span><span>=</span><span> </span><span>(</span><span>hash</span><span>:</span><span> </span><span>string</span><span>,</span><span> input</span><span>:</span><span> </span><span>string</span><span>)</span><span>:</span><span> </span><span>boolean</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>  </span><span>return</span><span> </span><span>true</span><span>;</span><span>
</span><span></span><span>}</span><span>;</span><span>
</span>
<span></span><span>// Example usage</span><span>
</span><span></span><span>const</span><span> userInput </span><span>=</span><span> </span><span>&#34;secretData&#34;</span><span>;</span><span>
</span><span></span><span>const</span><span> hash </span><span>=</span><span> </span><span>generateHash</span><span>(</span><span>userInput</span><span>)</span><span>;</span><span>
</span>
<span></span><span>// Without branded types, there&#39;s no indication that the returned string is a hash.</span><span>
</span><span></span><span>// Developers may erroneously treat it as a regular string because there&#39;s no immediate context attached to it, leading to misuse, e.g.</span><span>
</span><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>hash</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span><span>;</span><span>
</span>
<span></span><span>// Notice the parameters are in incorrect order</span><span>
</span><span></span><span>const</span><span> matches </span><span>=</span><span> </span><span>compareHash</span><span>(</span><span>userInput</span><span>,</span><span> hash</span><span>)</span><span>;</span></code></p></pre>

<p><span>It&#39;s fairly easy to enhance the clarity and safety of the code above by introducing a Branded type. This Branded type ensures that the returned string from the <code>generateHash</code> function is explicitly marked as a hash, preventing potential misuse or confusion in the codebase.</span></p><pre><p><code><span>// By declaring a unique symbol, we create a distinct marker in TypeScript.</span><span>
</span><span></span><span>declare</span><span> </span><span>const</span><span> __brand</span><span>:</span><span> unique </span><span>symbol</span><span>;</span><span>
</span>
<span></span><span>// Define a Branded type that combines a base type with a brand</span><span>
</span><span></span><span>type</span><span> </span><span>Branded</span><span>&lt;</span><span>Type</span><span>,</span><span> </span><span>Brand</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Type</span><span> </span><span>&amp;</span><span> </span><span>{</span><span>
</span><span>  </span><span>readonly</span><span> </span><span>[</span><span>__brand</span><span>]</span><span>:</span><span> </span><span>Brand</span><span>;</span><span>
</span><span></span><span>}</span><span>;</span></code></p></pre>
<p><span>The <code>__brand</code> is enclosed in square brackets to denote that it is a computed property with a key that is dynamically determined at compile time. This property is defined using a unique symbol, <code>__brand</code>, ensuring that it is unique across the codebase. Unique symbols are opaque and don&#39;t have a runtime value; they&#39;re simply used as identifiers to prevent accidental collisions.</span>
<span>With the <code>Branded</code> type defined, the <code>generateHash</code> function can be modified to return a value of type <code>Branded&lt;string, &#39;Hash&#39;&gt;</code>. In practice, the returned string will be both a string and carry the specific brand <code>&#39;Hash&#39;</code>, making its intended purpose clear.</span></p><pre><p><code><span>type</span><span> </span><span>Hash</span><span> </span><span>=</span><span> </span><span>Branded</span><span>&lt;</span><span>string</span><span>,</span><span> </span><span>&#34;Hash&#34;</span><span>&gt;</span><span>;</span><span>
</span>
<span></span><span>const</span><span> generateHash </span><span>=</span><span> </span><span>(</span><span>input</span><span>:</span><span> </span><span>string</span><span>)</span><span>:</span><span> </span><span>Hash</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>  </span><span>return</span><span> </span><span>(</span><span>&#34;hashed_&#34;</span><span> </span><span>+</span><span> input</span><span>)</span><span> </span><span>as</span><span> </span><span>Hash</span><span>;</span><span>
</span><span></span><span>}</span><span>;</span><span>
</span>
<span></span><span>const</span><span> compareHash </span><span>=</span><span> </span><span>(</span><span>hash</span><span>:</span><span> </span><span>Hash</span><span>,</span><span> input</span><span>:</span><span> </span><span>string</span><span>)</span><span>:</span><span> </span><span>boolean</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>  </span><span>return</span><span> </span><span>true</span><span>;</span><span>
</span><span></span><span>}</span><span>;</span><span>
</span>
<span></span><span>const</span><span> userInput </span><span>=</span><span> </span><span>&#34;secretData&#34;</span><span>;</span><span>
</span><span></span><span>const</span><span> hash </span><span>=</span><span> </span><span>generateHash</span><span>(</span><span>userInput</span><span>)</span><span>;</span><span> </span><span>// hash is of type Hash</span><span>
</span>
<span></span><span>// This won&#39;t compile!</span><span>
</span><span></span><span>// Argument of type &#39;string&#39; is not assignable to parameter of type &#39;Hash&#39;.</span><span>
</span><span></span><span>//Type &#39;string&#39; is not assignable to type &#39;{ readonly [__brand]: &#34;Hash&#34;; }&#39;.(2345)</span><span>
</span><span></span><span>const</span><span> _matches </span><span>=</span><span> </span><span>compareHash</span><span>(</span><span>userInput</span><span>,</span><span> hash</span><span>)</span><span>;</span><span>
</span>
<span></span><span>// This, however, compiles!</span><span>
</span><span></span><span>const</span><span> matches </span><span>=</span><span> </span><span>compareHash</span><span>(</span><span>hash</span><span>,</span><span> userInput</span><span>)</span><span>;</span></code></p></pre>
<p><span>By changing the type of the <code>hash</code> parameter in <code>compareHash</code>, it&#39;s possible to eliminate cases where the order of arguments is incorrect. <strong>A runtime bug is now a compile time bug.</strong></span></p></div></div>
  </body>
</html>
