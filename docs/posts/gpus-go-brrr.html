<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hazyresearch.stanford.edu/blog/2024-05-12-tk">Original</a>
    <h1>GPUs Go Brrr</h1>
    
    <div id="readability-page-1" class="page"><div><p>AI uses an <a href="https://www.semianalysis.com/p/gpt-4-architecture-infrastructure">awful</a> <a href="https://www.instagram.com/p/C2QARHJR1sZ">lot</a> <a href="https://www.semianalysis.com/p/google-gemini-eats-the-world-gemini">of</a> <a href="https://arxiv.org/pdf/2202.05924">compute</a>.</p>
<p>In the last few years we’ve focused a great deal of our work on making AI use less compute (e.g. <a href="https://www.together.ai/blog/based">Based</a>, <a href="https://hazyresearch.stanford.edu/blog/2023-12-11-truly-subquadratic">Monarch Mixer</a>, <a href="https://hazyresearch.stanford.edu/blog/2023-01-20-h3">H3</a>, <a href="https://hazyresearch.stanford.edu/blog/2023-06-08-hyena-safari">Hyena</a>, <a href="https://hazyresearch.stanford.edu/blog/2022-06-11-simplifying-s4">S4</a>, among others) and run more efficiently on the compute that we have (e.g. <a href="https://hazyresearch.stanford.edu/blog/2023-01-12-flashattention-long-sequences">FlashAttention</a>, <a href="https://hazyresearch.stanford.edu/blog/2023-07-17-flash2">FlashAttention-2</a>, <a href="https://hazyresearch.stanford.edu/blog/2023-11-13-flashfftconv">FlashFFTConv</a>). Lately, reflecting on these questions has prompted us to take a step back, and ask two questions:</p>
<ul>
<li>What does the hardware actually want?</li>
<li>And how can we give that to it?</li>
</ul>
<p>This post is a mixture of practice and philosophy. On the practical side, we’re going to talk about what we’ve learned about making GPUs go brr -- and release an embedded DSL, <a href="https://github.com/HazyResearch/ThunderKittens">ThunderKittens</a>, that we’ve built to help us write some particularly speedy kernels (which we are also <a href="https://github.com/HazyResearch/ThunderKittens/tree/main/examples">releasing</a>). On the philosophical side, we’ll briefly talk about how what we’ve learned has changed the way we think about AI compute.</p>
<h2>What&#39;s in an H100?</h2>
<p>For this post, we’re going to focus on the NVIDIA H100 for two reasons. First, it represents an awful lot of new compute going online. Second, we think the trends it implies are going to continue in future generations, and probably from other manufacturers, too. But bear in mind (and we will repeat in case you forget) that most of this post applies in some form to other GPUs, too.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/brr.png"/><figcaption><p>Figure 1: brr</p></figcaption></figure>
<p>Advance apologies for restating the data sheet, but the details of the hardware are important for the discussion to come. An H100 SXM GPU contains, for our purposes:</p>
<ul>
<li>80 GB of HBM3 with 3 TB/s of bandwidth. (A bit less bandwidth in practice.)</li>
<li>50 MB of L2 cache with 12 TB/s of bandwidth, split across the GPU into two 25MB sections connected by a crossbar. (The crossbar sucks.)</li>
<li>132 streaming multiprocessors (SM’s), where each has:<!-- -->
<ul>
<li>up to 227 KB of shared memory within a 256 KB L1 cache. (Together, these have about 33 TB/s of bandwidth.)</li>
<li>a tensor memory accelerator (TMA) -- a new chunk of hardware in Hopper that can do asynchronous address generation and fetch memory. It also does other things like facilitate the on-chip memory network (distributed shared memory) but we’re not going to focus on this much, today.</li>
<li>4 quadrants, where each quadrant has:<!-- -->
<ul>
<li>A warp scheduler</li>
<li>512 vector registers (each containing 32 4-byte words)</li>
<li>A tensor core for matrix multiplies</li>
<li>A bunch of built-in instructions like sums, multiplies, that operate in parallel on these vector registers.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>There’s a lot of other stuff, too (memory controllers, instruction caches, etc) but we don’t care about any of that right now.</p>
<p>All of the compute happens in the SM’s. <em>Most</em> of it happens in the registers.</p>
<p><em>Great, how do I make it go brr?</em></p>
<p>Keep the tensor core fed. That’s it.</p>
<p><em>Wait, really?</em></p>
<p>Yes. That’s the game.</p>
<p>An H100 GPU has 989 TFLOPs of half-precision matrix multiply compute, and ~60 TFLOPs of “everything else”. So, every cycle the tensor core is in use, you’re getting at least 94% utilization of the hardware. And every cycle the tensor core is not in use, you’re getting no more than 6% utilization of the hardware. Put another way:</p>
<p>% utilization H100 = % tensor cores active cycles +/- 6%.</p>
<p>Now it turns out that keeping the tensor core fed is easier said than done. We’ve discovered a number of quirks to the hardware that are important to keeping the matrix multiplies rolling. Much of this also applies to non-H100 GPUs, but the H100 is particularly tricky to keep fed so we focus on it here. (The RTX 4090, by comparison, is very easy to work with as illustrated in figure 2.)</p>
<ul>
<li>WGMMA instructions are necessary but also really irritating to use.</li>
<li>Shared memory is not actually that fast and also requires great care.</li>
<li>Address generation is expensive.</li>
<li>Occupancy remains helpful, and registers are generally the key resource.</li>
</ul>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/spirits.png"/><figcaption><p>Figure 2: NVIDIA GPUs (H100 and 4090) and their spirit animals (canadian goose and golden retriever puppy).</p></figcaption></figure>
<p>Let’s go through each of these in order.</p>
<h3>WGMMA Instructions</h3>
<p>The H100 has a new set of instructions called “warp group matrix multiply accumulate” (<code>wgmma.mma_async</code> in PTX, or <code>HGMMA</code>/<code>IGMMA</code>/<code>QGMMA</code>/<code>BGMMA</code> in SASS). To understand what makes them special, we need to look briefly at how you used to have to use tensor cores. The tensor core instructions available on previous GPUs were <code>wmma.mma.sync</code> and <code>mma.sync</code> instructions. With these instructions a warp of 32 threads on a single quadrant of an SM would synchronously feed their chunk of the data into the tensor core and await the result. Only then could they move on.</p>
<p>Not so with <code>wgmma.mma_async</code> instructions. Here, 128 consecutive threads -- split across all quadrants of the SM -- collaboratively synchronize, and asynchronously launch a matrix multiply directly from shared memory (and optionally also registers.) These warps can then go do other things with their registers while the matrix multiply happens, and await the result whenever they want.</p>
<p>In our microbenchmarks, we found that these instructions are necessary to extract the full compute of the H100. Without them, the GPU seems to top out around 63% of its peak utilization; we suspect this is because the tensor cores want a deep hardware pipeline to keep them fed, even from local resources.</p>
<p>Unfortunately, the memory layouts for these instructions <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n16">are</a> <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-shared-memory-layout">quite</a> <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-shared-memory-layout-swizzling-modes">complicated</a>. The unswizzled shared memory layouts suffer from very poor coalescing, and so they require substantial additional bandwidth from L2. The swizzled memory layouts are flat-out incorrectly documented, which took considerable time for us to figure out. They’re also brittle, in that they appear to only work for specific matrix shapes and do not play well with other parts of the wgmma.mma_async instructions. For example, the hardware can transpose sub-matrices on its way to the tensor cores -- but only if the layout is not swizzled.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/lies.png"/><figcaption><p>Figure 3: NVIDIA’s <span><em>lies</em></span>. This is an extraordinarily misleading representation of the actual 128b swizzled wgmma layout. This diagram cost us three weeks of life that we will not get back, hence the public shaming.</p></figcaption></figure>
<p>We’ve also found that unswizzled wgmma layouts have both poor memory coalescing as well as bank conflicts. On kernels such as flash attention, TMA and the L2 cache are both fast enough so as to hide these problems reasonably well. But to make the full use of the hardware, memory request must be coalesced and bank conflicts avoided, and then controlling layouts very carefully becomes critical.</p>
<p>Despite these pains, these instructions really are necessary to make full use of the H100. Without them, you’ve already lost 37% of the potential performance of the GPU!</p>
<h3>Shared memory</h3>
<p>Shared memory appears to have a single-access latency of around <a href="https://chipsandcheese.com/2023/07/02/nvidias-h100-funny-l2-and-tons-of-bandwidth/">30 cycles</a> (this matches our observations, too). That doesn’t sound like much, but in that time the SM’s tensor cores could have done almost two full 32x32 square matrix multiplies.</p>
<p>In previous work (like Flash Attention), we’ve focused more on the HBM-SRAM bottleneck. And indeed: this really used to be the bottleneck! But as HBM has gotten faster and the tensor cores continue to grow out of proportion with the rest of the chip, even relatively small latencies like those from shared memory have also become important to either remove or hide.</p>
<p>Shared memory can be tricky to work with because it is “banked” into 32 separate stores of memory. If one is not careful, this can lead to something called “bank conflicts”, where the same memory bank is being asked to simultaneously provide multiple different pieces of memory. This leads to requests being serialized, and in our experience this can disproportionately slow down a kernel -- and the register layouts required by wgmma and mma instructions would naively suffer from these bank conflicts. The solution is to rearrange shared memory with various “swizzling” patterns so as to avoid these conflicts, but it is an important detail to get right.</p>
<p>More generally, we have found it very valuable to avoid movement between registers and shared memory when possible, and otherwise to use the built-in hardware (wgmma and TMA instructions) to do data movement asynchronously when possible. Synchronous movement using the actual warps is a worst-case fallback with the greatest generality.</p>
<h3>Address Generation</h3>
<p>One interesting quirk of the H100 is that the tensor cores and memory are both fast enough that merely producing the memory addresses to fetch takes a substantial fraction of the resources of the chip. (This is even more the case when complicated interleaved or swizzling patterns are added in.)</p>
<p>NVIDIA appears to understand this, as they have bestowed on us the Tensor Memory Accelerator (or TMA, as it likes to be called). TMA allows you to specify a multi-dimensional tensor layout in global and shared memory, tell it to asynchronously fetch a subtile of that tensor, and trip a barrier when it’s done. This saves all of the address generation costs, and additionally makes it much easier to construct pipelines.</p>
<p>We have found TMA to be, like wgmma.mma_async, completely indispensable in achieving the full potential of the H100. (Probably moreso than wgmma, in our experience.) It saves register resources and instruction dispatches, and also has useful features such as the ability to perform reductions onto global memory asynchronously, too -- this is particularly useful in complex backwards kernels. As with wgmma, the main quirk of it is that its swizzling modes are a bit difficult to decipher without some reverse engineering, but we had substantially less pain on this point.</p>
<h3>Occupancy</h3>
<p>For those newer to CUDA, occupancy refers to the number of co-scheduled threads on the exact same execution hardware. Each cycle, the warp scheduler on that quadrant of the SM will try to issue an instruction to a warp of threads that are ready for an instruction. NVIDIA uses this model because it can enable the hardware to be more easily kept full. For example, while one warp of threads is waiting for a matrix multiply, another can receive an instruction to use the fast exponential hardware.</p>
<p>In some ways, the H100 is less reliant on occupancy than previous generations of the hardware. The asynchronous features of the chip mean that even a single instruction stream can keep many parts of the hardware busy -- fetching memory, running matrix multiplies, doing shared memory reductions, and still simultaneously running math on the registers.</p>
<p>But occupancy is very good at hiding both sins and sync’s. A perfectly designed pipeline might run reasonably fast even without any additional occupancy, but our observations suggest that NVIDIA really has designed their GPUs with occupancy in mind. And there are enough synchronizations -- and enough ways to make mistakes -- that finding ways to increase occupancy has, in our experience, usually yielded good returns at increasing the realized utilization of the hardware.</p>
<p>Finally, while occupancy is merely useful on the H100, we have found it to be increasingly important on the A100 and RTX 4090, respectively, likely because they rely increasingly on synchronous instruction dispatches, relative to the H100.</p>
<h2>ThunderKittens</h2>
<p>Based on the above, we asked ourselves how we might make it easier to write the kinds of kernels we care about while still extracting the full capabilities of the hardware. Motivated by a continuing proliferation of new architectures within the lab (and the fact that Flash Attention is like 1200 lines of code), we ended up designing a DSL embedded within CUDA -- at first for our own internal use.</p>
<p>But then we decided it was useful enough that, with love in our hearts, we cleaned it up and have released it for you. ThunderKittens is that embedded DSL. It is named ThunderKittens because we think kittens are cute, and also we think it is funny to make you type <code>kittens::</code> in your code.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/tk.png"/><figcaption><p>Figure 4: A ThunderKitten. Look at her big eyes! Are you not be entranced!?!?</p></figcaption></figure>
<p>It is meant to be as simple as possible, and contains four templated types:</p>
<ul>
<li>Register tiles -- 2D tensors on the register file.</li>
<li>Register vectors -- 1D tensors on the register file.</li>
<li>Shared tiles -- 2D tensors in shared memory.</li>
<li>Shared vectors -- 1D tensors in shared memory.</li>
</ul>
<p>Tiles are parameterized by a height, width, and layout. Register vectors are parameterized by a length and a layout, and shared vectors just by a length. (They don’t generally suffer from bank conflicts.)</p>
<p>We also give operations to manipulate them, either at the warp level or at the level of a collaborative group of warps. Examples include:</p>
<ul>
<li>Initializers -- zero out a shared vector, for example.</li>
<li>Unary ops, like exp</li>
<li>Binary ops, like mul</li>
<li>Row / column ops, like a row_sum</li>
</ul>
<p>Since ThunderKittens is embedded within CUDA (contrasting libraries like Triton which we also love very much and rely on heavily), the abstractions fail gracefully. If it’s missing something, just extend it to do what you want!</p>
<p>To show an example of these primitives in action, consider Tri’s lovely flash attention -- a beautiful algorithm, but <a href="https://github.com/Dao-AILab/flash-attention/blob/main/csrc/flash_attn/src/flash_fwd_kernel.h">complicated</a> to implement in practice, even on top of NVIDIA’s wonderful Cutlass library.</p>
<p>Here&#39;s a simple forward flash attention kernel for an RTX 4090, written in ThunderKittens.</p>

<p>Altogether, this is about 60 lines of CUDA sitting at 75% hardware utilization -- and while it is fairly dense, most of the complexity is in the algorithm, rather than in swizzling patterns or register layouts. And what of all of the complexity of TMA, WGMMA, swizzling modes, and descriptors? Here’s a FlashAttention-2 forward pass for the H100, written with ThunderKittens.</p>

<p>So how does it do?</p>
<p>This kernel is just 100 lines, and it actually outperforms FlashAttention-2 on the H100 by about 30%. ThunderKittens takes care of wrapping up the layouts and instructions, and gives you a mini-pytorch to play with on the GPU.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/attn.png"/><figcaption><p>Figure 5: FA2 (via Pytorch) versus TK for a wide range of configs on the H100 SXM.</p></figcaption></figure>
<p>We also release kernels for Based linear attention and other forthcoming architectures, too. Our Based linear attention kernel runs at 215 TFLOPs (or more than 300 TFLOPs when the recompute inherent in the algorithm is considered). And while linear attention is of course theoretically more efficient, historically, they have been dramatically less efficient on real hardware. So we feel this could open up a broad range of high-throughput applications -- more to come on this point later.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/based.png"/><figcaption><p>Figure 6: Linear attention can be quite quick with TK!</p></figcaption></figure>
<p>If this seems up your alley, feel free to play with it!</p>
<h2>Tiles Seem Like a Good Idea</h2>
<p>In our view, what has made ThunderKittens work well for us is that it does not try to do everything. CUDA is indeed far more expressive than ThunderKittens. ThunderKittens is small and dumb and simple.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2024-05-12-tk/theydontknow.png"/><figcaption><p>Figure 7: the main message of this blog post.</p></figcaption></figure>
<p>But ThunderKittens has good abstractions -- small tiles -- that match where both AI and hardware are going. ThunderKittens doesn’t support any dimension less than 16. But in our view, this doesn’t really matter, since the hardware doesn’t particularly want to, either. And we ask: if your matrix multiply is smaller than 16x16, are you sure what you’re doing is AI?</p>
<p>From a philosophical point of view, we think a frame shift is in order. A “register” certainly shouldn’t be a 32-bit word like on the CPUs of old. And a 1024-bit wide vector register, as CUDA uses, is certainly a step in the right direction. But to us a “register” is a 16x16 tile of data. We think AI wants this -- after all this time, it’s still just matrix multiplies, reductions, and reshapes. And we think the hardware wants this, too -- small matrix multiplies are just begging for hardware support beyond just the systolic mma.</p>
<p>In fact, more broadly we believe we should really reorient our ideas of AI around what maps well onto the hardware. How big should a recurrent state be? As big can fit onto an SM. How dense should the compute be? No less so than what the hardware demands. An important future direction of this work for us is to use our learnings about the hardware to help us design the AI to match.</p>
<h2>Tiles Seem Pretty General</h2>
<p>Coming soon -- ThunderKittens on AMD hardware!</p></div></div>
  </body>
</html>
