<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rjp.io/blog/2025-06-07-reflections-on-sudoku">Original</a>
    <h1>Reflections on Sudoku, or the Impossibility of Systematizing Thought</h1>
    
    <div id="readability-page-1" class="page"><article>
        

<section>
<p><em>I reflect on the Entscheidungsproblem how it relates to Sudoku solvers. It&#39;s a little weird.</em>.</p>
<p>The other day, to no one&#39;s surprise, I was fumbling over a programming problem.
This wasn&#39;t anything satisfyingly algorithmic, but more the thing where you&#39;re
evaluating a million questions on &#34;how should I structure this system?&#34;. While
I&#39;m no design purist, I like to at least make an attempt at sketching out the
problem space and think through options before I just start coding something. My
rule of thumb for this is, let&#39;s call it the &#34;10% rule&#34; - make sure I try to
think hard about a problem for 10% of the time before I start playing around
with code. Writing code helps clarify many things but it&#39;s also easy to get
stuck in local minima<label for="sn-1-d1d7bfa3"></label><span>I have the same problem when writing text, like this blog post. Put me in front of an editor and I&#39;ll pointlessly recraft sentences instead of getting the thing finished. </span>. This rule helps keep me from getting lost too early,
but I often think about whether I could do better.</p>
<p>I&#39;d like to say I have a systematic process I apply here. I don&#39;t. I think
over one idea, then another, <a href="https://rjp.io/blog/charlie-its-always-sunny.jpg">writing down my thoughts</a>,
but it&#39;s always hard to feel like you&#39;re making a lot of progress.
It&#39;s honestly frustrating. I often wish I could &#34;systematize&#34; it somehow,
applying some rigorous method and march towards the solution. Could I become one of <em>those
magic people</em> who just sit down in front of a problem and watch it decompose in front
of them?</p>
<p>Over time I&#39;ve accepted that is impossible. There is no person, no process,
which can systematize thought. Millions of math problems
elude <a href="https://terrytao.wordpress.com/">Terence Tao</a> despite his brilliance.</p>
<p>Now I see these differences in aptitude as having different sets of
mental tools at your disposal. The more tools you have, the better tools you
have, and the better you are at applying them, then the better you get at
certain problems. Maybe your background makes you better or more interested in
different tools. But we can all learn new tools, and get better at the ones we
have.</p>
<p>This is all kind of murky and unsatisfying though. Wouldn&#39;t it be nice if you
just had a general method you could apply to solve everything? What happens if
you <em>think</em> you have a method to solve all problems?</p>
<h2>The Sudoku Affair</h2>
<p>A few months ago I read Zach Tellman&#39;s fascinating article on the <a href="https://explaining.software/archive/the-sudoku-affair/">Sudoku
Affair</a>, in which he revisited Peter Norvig &amp; Ron
Jeffries very, very different attempts to produce a workable Sudoku solver. (I
highly recommend reading the original article as well, as Zach&#39;s deep analysis
of Ron Jeffries attempts at producing a Sudoku solver is fascinating).</p>
<p>Some background: Ron Jeffries made a career advocating for test-driven
development (TDD) and extreme programming. Peter Norvig is a research lead at
Google and author of many papers and a few books on AI. As you&#39;d expect, this
leads to different approaches to problems.</p>
<p>Ron Jeffries attempted to solve Sudoku by approaching it
&#34;rigorously&#34;<label for="sn-rigor-5eb8f6b4"></label><span>No offense intended, but just being clear this isn&#39;t like <a href="https://en.m.wikipedia.org/wiki/Rigour#Mathematics">mathematical rigour</a> but more of an applied philosophy. </span> from the perspective of TDD. He outlines the
problem, writes a test case and begins to iterate, adding tests and refactoring.
In the initial set of posts, he can&#39;t get to a real solution despite many hours
of effort. He then revisited the problem 20 years later, and in the end spends <em>50
posts</em> writing about the process of building a solver. At some point, he
<a href="https://ronjeffries.com/articles/-x024/-y01/7/">finds code from another site</a>
and starts to bring that into the fold. He eventually gets to a solution, though at
that point I honestly have trouble figuring out how much TDD had to do with the process.</p>
<p>Peter Norvig takes a different approach, analyzing the high-level problem and
then breaking down the data structures and outlining the solution in the course
of ~20 lines of code. While his code might be a bit dense to follow initially,
the way he approaches the problem and pre-builds data structures makes &#34;testing&#34;
trivial. His test for validity is part of the search condition for his program.
It&#39;s hard not to appreciate the systematic nature of Peter&#39;s approach: define
the problem, look through your toolkit, apply the relevant tools, success. Of
course, Peter has an advantage that he&#39;s <a href="https://aima.cs.berkeley.edu/">written
books</a> about related techniques.</p>
<p>Ron Jeffries attempt definitely didn&#39;t make me excited about TDD, I at least
respected that he didn&#39;t try to hide things after the fact.</p>
<p>Many people have commented about this over time, with lots to say
about TDD and programming. In Peter Siebel&#39;s post on
<a href="https://gigamonkeys.wordpress.com/2009/10/05/coders-unit-testing/">Unit testing in Coders at Work</a>
even Peter Norvig chimes in, indicating he&#39;s not &#34;anti-test&#34;, but that tests don&#39;t fix the
underlying issue of &#34;knowing what to do.&#34;</p>
<blockquote>
<p>Then bloggers were arguing back and forth about what this means. I don’t think
it means much of anything—I think test-driven design is great. I do that a lot
more than I used to do. But you can test all you want and if you don’t know how
to approach the problem, you’re not going to get a solution.</p>
</blockquote>
<h2>On How to Think</h2>
<p>Something in Peter&#39;s quote really struck me when pondering these issues of how
we approach problems.</p>
<blockquote>
<p><em>... if you don’t know how to approach the problem, you’re not going to get a solution.</em></p>
</blockquote>
<p>Why did Ron Jeffries struggle so much to build a Sudoku solver? <em>Because he
doesn&#39;t know much about search or CSP</em>. And if you don&#39;t know how to frame and
solve a search problem, and you don&#39;t know or desire to use the &#34;meta-tools&#34;<label for="sn-5-a13c62df"></label><span>Or you know, ask an LLM. But more generally, &#34;do a lot of similar problems and find patterns&#34;, or &#34;look around for things that seem similar and how people solve it&#34;. </span>
to learn about them, then you won&#39;t be able to solve this type of problem.</p>
<p>With this in mind, I was unsurprised when Jeffries spent multiple articles recently writing
about the process of building a <a href="https://ronjeffries.com/categories/bowling/">bowling score calculator</a>. This isn&#39;t quite
<a href="https://blog.codinghorror.com/why-cant-programmers-program/">FizzBuzz</a>,
but <a href="https://colab.research.google.com/drive/1NN6MeweOw5ArAW1LEdciNt5eOc3_FiMt">it&#39;s a still a single for-loop</a><label for="sn-tryit-07e08cf2"></label><span>It&#39;s a fun little problem if you want to try it yourself before you look at my solution. </span>.
My assertion is that Ron Jeffries downfall is due to the belief, and he doesn&#39;t come out and say this
directly, but it&#39;s implied, that with TDD he&#39;s found a
<em>tool that can systematize programming</em>.<label for="sn-kent-c3e9e7bf"></label><span>From Kent Beck&#39;s &#34;Test-driven development: by example&#34;: <em>One of the ironies of TDD is that it isn&#39;t a testing technique (the Cunningham Koan). It&#39;s an analysis technique, a design technique, really a technique for structuring all the activities of development.</em> </span> That is, if you apply this
approach, you will unfailingly reach your goal: you don&#39;t <em>need</em> to know all
this other stuff like CSP. Jeffries selection of and struggles with these simple problems,
like the Sudoku solver and bowling calculator, are indicative of the limitations of his approach
to problem solving.</p>
<p>The issue is that the results from the Entscheidungsproblem would suggest that
there is no general method to solving problems.</p>
<h2>The Entscheidungsproblem</h2>
<p>The Entscheidungsproblem (&#34;the decision problem&#34;) asks whether there
is an algorithm that can determine whether a given statement is provable from a
set of axioms. There&#39;s a bunch of related theorems you&#39;re probably familiar with
if you have a CS background, like the Halting Problem or Rice&#39;s theorem. They
all have to do with the impossibility of making a determination about whether a
machine &#34;does something&#34;.</p>
<p>The corollary for our case (which is more or less, &#34;can I devise an algorithm
for solving problems&#34;) is simple. If we can&#39;t decide if a program <em>P</em> solves a
task <em>T</em>, then we certainly can&#39;t solve the even harder problem of finding a
program <em>P</em> that solves a given task. More philosophically, we can&#39;t systematize
the process of thinking itself.</p>
<p>These proofs are all on infinite machines, but we can of course observe this
empirically as well: math and programming would be trivialized if you could
follow a simple process to solve all problems. This is part of the joy, the art,
of the discipline. If you can turn a crank to get the result, you lose the fun
in the process.</p>
<p>This isn&#39;t to say you can&#39;t have a process which helps you write programs, but
solving a new problem will always require some amount of insight.</p>
<h2>On Solving Problems</h2>
<p>The desire to have a system for solving problems is understandable. And I do
think Ron Jeffries really believes in it. After all, who
wouldn&#39;t like to be smart like Peter Norvig? Just imagine if you could apply a
simple procedure to solve all of these problems - it would be magical.</p>
<p>But the reality is there&#39;s no single approach we can take. If I&#39;m good at
programming, it&#39;s because I&#39;ve built up <em>the right toolbox</em> for programming
problems. When I start a project, or hit a bug, I reach for certain &#34;tools&#34;
(literally, in the case of say, an editor, but also figuratively, in the sense
of how I approach problems). I might even have &#34;meta&#34; tools, like how I approach
a new problem: how do I attempt to break things down. If my toolset is a good
match for the problem, then I will be more successful. A big part of learning
and becoming better at a task is finding and learning how to apply the right
tools. You learn from teachers, or from trying things out and paying attention
to what works.</p>
<p>The best we <em>can</em> do is to try develop better and better tools to understand
them, and ideally, figure out the right set of tools to have fun in the process.
But we have to have humility in what we believe and what we promise. Ruby on
Rails makes it easier for the average developer to make an average web app. It
doesn&#39;t attempt to solve all problems, but it is a good tool for a specific set
of problems. TDD might, for all I know<label for="sn-tdd-e634d50a"></label><span>I&#39;m not convinced, but if it genuinely helps some people do better, that&#39;s great. <a href="http://www.dalkescientific.com/writings/diary/archive/2009/12/29/problems_with_tdd.html">Andrew Daike&#39;s</a> post outlines most of the issues I see as well. </span>, be a decent way to develop certain
types of programs. It can&#39;t be a solution for how to do all of programming. In a
sense, the broader the subject, the less &#34;directed&#34; our tools can afford to be.</p>
<p>I know, I know, this is all so deeply... unsatisfying. Like, why can&#39;t someone
at least figure out general tools that work most of the time? In penance for
making you read through this, here&#39;s a grab bag of mine:</p>
<ul>
<li>Spend time with people I admire and try to understand how they do things. <label for="sn-moral-a0a7809f"></label><span>Admire technically but also people who I admire for their moral stance or approach to life etc etc. </span></li>
<li>Think scientifically, or at least play-act at it. Seriously, try it out. Write down a hypothesis, test it, see what happens, and iterate. There&#39;s something magical about this process which makes you feel productive (and I do think makes you actually more productive). This
doesn&#39;t guarantee an answer, but I find it at least forces me to acknowledge what I&#39;m doing.</li>
<li><a href="https://rjp.io/blog/2025-05-31-stepping-back">Stepping back</a> from time to time, and trying to get a new perspective on what I&#39;m doing.</li>
<li>For programming, just writing code and trying to solve problems. Your brain starts to absorb tricks over time.</li>
<li>For writing, writing, and sharing. There&#39;s nothing like knowing someone else is going to read your work to make you take a little bit more time.</li>
<li>Talking through my ideas with other people. It can be deflating to have someone tell you your idea is foolish, but better early than after you&#39;ve invested in it...</li>
</ul>
<p>And more tactically:</p>
<ul>
<li>Using LLMs when they make sense. Claude rewrote my blog software while I was typing this!</li>
<li>Setting up a keyboard break program. RSI sucks and your hands are important.</li>
<li>Going for walks or exercising. Maybe it&#39;s not for everyone, but it helps clear my head.</li>
</ul>
<p>...or perhaps I&#39;m way off base and there is a general solution to everything. The
best I&#39;ve found is to try things, and pay attention to what I try, and be open
to learning new things. What tools to you use?</p>


</section>

    </article></div>
  </body>
</html>
