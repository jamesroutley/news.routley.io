<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://atlas9.dev/blog/soft-delete.html">Original</a>
    <h1>The challenges of soft delete</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Software projects often implement &#34;soft delete&#34;, maybe with a <code>deleted</code> boolean or an <code>archived_at</code> timestamp column.
If customers accidentally delete their data, they can recover it, which makes work easier for customer support teams.
Perhaps archived records are even required for compliance or audit reasons.</p>
<p>I&#39;ve run into some trouble with soft delete designs. I&#39;ll cover those, and ponder ideas for how I&#39;d build this in the future.</p>
<p>Adding an <code>archived_at</code> column seems to ooze complexity out into queries, operations, and applications.
Recovering deleted records does happen, but 99% of archived records are never going to be read.</p>
<p>So, the database tables will have a lot of dead data. Depending on access patterns, that might even be a significant amount of data.
I&#39;ve seen APIs that didn&#39;t work well with Terraform, so Terraform would delete + recreate records on every run, and over time that led
to millions of dead rows. Your database can probably handle the extra bytes, and storage is fairly cheap, so it&#39;s not necessarily a problem, at first.</p>
<p>Hopefully, the project decided on a retention period in the beginning, and set up a periodic job to clean up those rows.
Unfortunately, I&#39;d bet that a significant percentage of projects did neither – it&#39;s really easy to ignore the archived data for a long time.</p>
<p>At some point, someone might want to restore a database backup. Hopefully that&#39;s for fun and profit and not because you lost the production database at 11 am.
If your project is popular, you might have a giant database full of dead data that takes a long time to recreate from a dump file.</p>
<p><code>archived_at</code> columns also complicate queries, operations, and application code. Applications need to make sure they always avoid the archived data that&#39;s sitting
right next to the live data. Indexes need to be careful to avoid archived rows. Manual queries run for debugging or analytics are longer and more complicated.
There&#39;s always a risk that archived data accidentally leaks in when it&#39;s not wanted. The complexity grows when there are mapping tables involved.</p>
<p>Migrations have to deal with archived data too. Migrations may involve more than just schema changes – perhaps you need to fix a mistake with default values, or add a new column and backfill values.
Is that going to work on records from 2 years ago? I&#39;ve done migrations where these questions were not trivial to answer.</p>
<p>Restoring an archived record is not always as simple as just running <code>SET archived_at = null</code> – creating a record may involve making calls to external systems as well.
I&#39;ve seen complex restoration code that was always a buggy, partial implementation of the &#34;create&#34; API endpoint. In the end, we removed the specialized restoration code
and required all restoration to go through the standard APIs – that simplified the server implementation, and ensured that old data that had since become invalid, could not
be restored incorrectly – it needs to pass the new validation rules.</p>
<p>I&#39;m not a fan of the <code>archived_at</code> column approach. It&#39;s simple at first, but in my experience, it&#39;s full of pitfalls down the line.</p>
<p>Let&#39;s look at some alternatives (in PostgreSQL): application events, triggers, and logical replication.</p>
<p>All these approaches store archived data separately from live data – that may be a separate database table, a separate database, object storage, etc.</p>

<p>One team I worked with took the approach of emitting an event at the application layer when a record was deleted. The event was sent to SQS, and another service would archive that object to S3 (among other things).</p>
<p>This had a few big benefits:</p>
<ul>
<li>The primary database and application code were substantially simpler.</li>
<li>Deleting a resource involved cleaning up resources in various external systems.
Handling this in an async background system improved performance and reliability.</li>
<li>The record and all its related records can be serialized to JSON in an application-friendly layout, rather than a serialized database table layout, so it&#39;s easier to work with.</li>
</ul>
<p>The tradeoffs:</p>
<ul>
<li>It&#39;s more likely to have a bug in the application code, and indeed this happened more than
once, which meant archived records were lost and manual cleanup of external resources was necessary.</li>
<li>It&#39;s more infrastructure to understand and operate: multiple services, a message queue, etc.</li>
<li>Archived objects in S3 were not easy to query – finding records to restore required extra tooling from the customer support teams.</li>
</ul>

<p>A trigger can copy a row to an archive table before it&#39;s deleted. The archive table can be a single, generic table that stores JSON blobs:</p>
<pre><code>CREATE TABLE archive (
    id UUID PRIMARY KEY,
    table_name TEXT NOT NULL,
    record_id TEXT NOT NULL,
    data JSONB NOT NULL,
    archived_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    caused_by_table TEXT,
    caused_by_id TEXT
);

CREATE INDEX idx_archive_table_record ON archive(table_name, record_id);
CREATE INDEX idx_archive_archived_at ON archive(archived_at);
</code></pre>
<p>The trigger function converts the deleted row to JSON:</p>
<pre><code>CREATE OR REPLACE FUNCTION archive_on_delete()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO archive (id, table_name, record_id, data)
    VALUES (
        gen_random_uuid(),
        TG_TABLE_NAME,
        OLD.id::TEXT,
        to_jsonb(OLD)
    );
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<p>Attach this trigger to any table you want to archive:</p>
<pre><code>CREATE TRIGGER archive_users
    BEFORE DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION archive_on_delete();

CREATE TRIGGER archive_documents
    BEFORE DELETE ON documents
    FOR EACH ROW EXECUTE FUNCTION archive_on_delete();
</code></pre>
<h2>Handling foreign key cascades</h2>
<p>When a parent record is deleted, PostgreSQL cascades the delete to child records. These child deletes also fire triggers, but in the context of a cascade, you often want to know <em>why</em> a record was deleted.</p>
<p>One approach is to use a session variable to track the root cause:</p>
<pre><code>CREATE OR REPLACE FUNCTION archive_on_delete()
RETURNS TRIGGER AS $$
DECLARE
    cause_table TEXT;
    cause_id TEXT;
BEGIN
    -- Check if we&#39;re in a cascade context
    cause_table := current_setting(&#39;archive.cause_table&#39;, true);
    cause_id := current_setting(&#39;archive.cause_id&#39;, true);

    -- If this is a top-level delete, set ourselves as the cause
    IF cause_table IS NULL THEN
        PERFORM set_config(&#39;archive.cause_table&#39;, TG_TABLE_NAME, true);
        PERFORM set_config(&#39;archive.cause_id&#39;, OLD.id::TEXT, true);
        cause_table := TG_TABLE_NAME;
        cause_id := OLD.id::TEXT;
    END IF;

    INSERT INTO archive (id, table_name, record_id, data, caused_by_table, caused_by_id)
    VALUES (
        gen_random_uuid(),
        TG_TABLE_NAME,
        OLD.id::TEXT,
        to_jsonb(OLD),
        cause_table,
        cause_id
    );
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<p>Now when you delete a user, you can see which archived documents were deleted because of that user:</p>
<pre><code>SELECT * FROM archive
WHERE caused_by_table = &#39;users&#39;
AND caused_by_id = &#39;123e4567-e89b-12d3-a456-426614174000&#39;;
</code></pre>
<h2>Tradeoffs</h2>
<p>Triggers add some overhead to deletes, and the archive table will grow. But:</p>
<ul>
<li>Live tables stay clean – no <code>archived_at</code> columns, no dead rows</li>
<li>Cleaning up the archive table is trivial with <code>WHERE archived_at &lt; NOW() - INTERVAL &#39;90 days&#39;</code>.</li>
<li>Queries don&#39;t need to filter out archived records</li>
<li>Indexes stay efficient</li>
<li>Applications and migrations only deal with live data</li>
<li>Backups of the main tables are smaller</li>
</ul>
<p>The archive table can even live in a separate tablespace or be partitioned by time if it grows large.</p>

<p>PostgreSQL&#39;s write-ahead log (WAL) records every change to the database. Change data capture (CDC) tools can read the WAL and stream those changes to external systems. For archiving, you&#39;d filter for DELETE events and write the deleted records to another datastore.</p>
<p>Debezium is the most well-known tool for this. It connects to PostgreSQL&#39;s logical replication slot, reads changes, and publishes them to Kafka. From there, a consumer writes the data wherever you want – S3, Elasticsearch, another database, etc.</p>
<pre><code>PostgreSQL → Debezium → Kafka → Consumer → Archive Storage
</code></pre>
<p>For simpler setups, there are lighter-weight alternatives:</p>
<ul>
<li><strong>pgstream</strong> – streams WAL changes directly to webhooks or message queues without Kafka</li>
<li><strong>wal2json</strong> – a PostgreSQL plugin that outputs WAL changes as JSON, which you can consume with a custom script</li>
<li><strong>pg_recvlogical</strong> – PostgreSQL&#39;s built-in tool for reading logical replication streams</li>
</ul>
<h2>Operational complexity</h2>
<p>The main downside is operational overhead. You&#39;re running additional services that need to be monitored, maintained, and made fault-tolerant. Debezium with Kafka is a significant infrastructure investment – Kafka alone requires careful tuning and monitoring.</p>
<p>The lighter-weight alternatives reduce this burden but shift reliability concerns to your custom code. If your consumer crashes or falls behind, you need to handle that gracefully.</p>
<h2>WAL retention and max_wal_size</h2>
<p>A critical configuration is <code>max_wal_size</code> in PostgreSQL. The database retains WAL segments until all replication slots have consumed them. If your CDC consumer stops processing – due to a bug, network issue, or downstream failure – WAL segments accumulate on the primary.</p>
<p>If this continues unchecked, the primary database can run out of disk space and crash.</p>
<p>PostgreSQL 13+ has <code>max_slot_wal_keep_size</code> to limit how much WAL a slot can retain:</p>
<pre><code>ALTER SYSTEM SET max_slot_wal_keep_size = &#39;10GB&#39;;
</code></pre>
<p>If a slot falls too far behind, PostgreSQL invalidates it rather than filling the disk. This protects the primary but means your CDC pipeline loses data and needs to be re-synced from a snapshot.</p>
<p>You need monitoring and alerting on replication slot lag. If a slot starts falling behind, you want to know before it becomes a crisis.</p>
<h2>Tradeoffs</h2>
<p>WAL-based CDC provides:</p>
<ul>
<li>Captures all changes without modifying application code or adding triggers</li>
<li>Can stream to any destination (object storage, data warehouses, search indexes)</li>
<li>The primary database has no additional query load – it just writes WAL as normal</li>
</ul>
<p>But:</p>
<ul>
<li>Significant operational complexity, especially with Kafka-based setups</li>
<li>Risk to primary database stability if consumers fall behind</li>
<li>Schema changes require careful coordination between source and consumers</li>
<li>More infrastructure to understand, deploy, and debug</li>
</ul>
<p>This approach makes the most sense when you already have Kafka or similar infrastructure, or when you need to stream changes to multiple destinations beyond just archiving.</p>

<p>This is an idea I had never considered until I wrote this post – I haven&#39;t tested this, it&#39;s just an idea.</p>
<p>What if you kept a PostgreSQL replica (e.g. using logical replication) that just didn&#39;t process DELETE queries? Would it
effectively accumulate records and updates without conflict over time?</p>
<p>One potential benefit of this is that the archive can be easily queried, so finding old data is simple.</p>
<p>Would the replica have <em>any</em> information about deletes? Could it separate live from deleted data? Would you be able to find a record that was &#34;deleted 2 hours ago in account 123&#34; for a customer? Perhaps instead of ignoring DELETE queries entirely, you could have a specialized replica that transforms DELETE events into an <code>archived_at</code> column.</p>
<p>One potential pitfall here could be schema migrations – would the archive run into difficulty applying migrations over time?</p>
<p>Another downside might be cost – running a replica and keeping all that storage could have a non-trivial cost: it costs money and has operational overhead.</p>

<p>If I were starting a new project today and needed soft delete, I&#39;d reach for the trigger-based approach first. It&#39;s simple to set up, keeps live tables clean, and doesn&#39;t require extra infrastructure. The archive table is easy to query when you need it, and easy to ignore when you don&#39;t.</p>
<p>If you have thoughts, comments, feedback, shoot me an email at <code>atlas9@eabuc.com</code>.</p>

</div></div>
  </body>
</html>
