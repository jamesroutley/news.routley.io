<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://herman.bearblog.dev/how-bear-does-analytics-with-css/">Original</a>
    <h1>How Bear does analytics with CSS</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
<i>
<time datetime="2023-11-01">
01 Nov, 2023
</time>
</i>
</p>
<p>Bear Blog has a few design constraints for speed, efficiency, and stability. There are many great open-source, privacy-focussed analytics platforms out there, but I wanted to build one native to Bear.</p>
<p><a href="#tldr">tldr;</a></p>
<p>One of my constraints for Bear is to not use client-side javascript. This applies to the analytics system as well. Client-side javascript can be tweaked to determine the authenticity of traffic to a page and determine (partially) whether it is bot traffic or not, which is very useful for analytics. The main downside, however, is that most adblockers block analytics scripts. And not just the bad ones, like Google Analytics. Even Fathom and Plausible analytics struggle with logging activity on adblocked browsers.</p>
<p>There&#39;s always the option of just parsing server logs, which gives a rough indication of the kinds of traffic accessing the server. Unfortunately all server traffic is generally seen as equal. Technically bots &#34;should&#34; have a user-agent that identifies them as a bot, but few identify that since they&#39;re trying to scrape information as a &#34;person&#34; using a browser. In essence, just using server logs for analytics gives a skewed perspective to traffic since a lot of it are search-engine crawlers and scrapers (and now GPT-based parsers).</p>
<p>So instead of using server logs, I trigger a read with CSS. Here&#39;s my slightly boutique analytics system.</p>
<p>When a person accesses the website the page is loaded.
On each page I have the following CSS:</p>
<div><pre><span></span><span>body</span><span>:</span><span>hover</span><span> </span><span>{</span>
<span>    </span><span>border</span><span>-</span><span>image</span><span>:</span><span> </span><span>url</span><span>(</span><span>&#34;/hit/{{ post.id }}/?ref={{ request.META.HTTP_REFERER }}&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>The only info I need to actively re-add to this request is the referrer (yes, HTTP_REFERER is <a href="https://en.wikipedia.org/wiki/HTTP_referer" target="_blank">spelt incorrectly</a>).</p>
<p>Now, when a person hovers their cursor over the page (or scrolls on mobile) it triggers <code>body:hover</code> which calls the URL for the post hit. I don&#39;t think any bots hover and instead just use JS to interact with the page, so I can, with reasonable certainty, assume that this is a human reader.</p>
<p>I then confirm the user-agent isn&#39;t a bot (which isn&#39;t perfect, but still something). I also extract the browser and platform from the user-agent string.</p>
<p>My second constraint is to not store any identifying information about the reader either in browser cookies, or on the server. In order to do this I use the IP address of the request to determine the country, then hash the IP address along with the date. All subsequent requests to the page are checked for matching IP address + date hashes and duplicates are discarded.</p>
<p>In this way each IP address per day constitutes one &#34;read&#34; of the page. No IP addresses are stored un-hashed and the IP-with-date-hash creates a convenient built-in expiry time.</p>
<p>Here&#39;s the code if you&#39;re interested:</p>
<div><pre><span></span><span>user_agent</span> <span>=</span> <span>httpagentparser</span><span>.</span><span>detect</span><span>(</span><span>self</span><span>.</span><span>request</span><span>.</span><span>META</span><span>.</span><span>get</span><span>(</span><span>&#39;HTTP_USER_AGENT&#39;</span><span>,</span> <span>None</span><span>))</span>
<span>if</span> <span>user_agent</span><span>.</span><span>get</span><span>(</span><span>&#39;bot&#39;</span><span>,</span> <span>False</span><span>):</span>
    <span>print</span><span>(</span><span>&#39;Bot traffic&#39;</span><span>)</span>
    <span>return</span>

<span>ip_hash</span> <span>=</span> <span>hashlib</span><span>.</span><span>md5</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>client_ip</span><span>(</span><span>self</span><span>.</span><span>request</span><span>)</span><span>}</span><span>-</span><span>{</span><span>timezone</span><span>.</span><span>now</span><span>()</span><span>.</span><span>date</span><span>()</span><span>}</span><span>&#34;</span><span>.</span><span>encode</span><span>(</span><span>&#39;utf-8&#39;</span><span>))</span><span>.</span><span>hexdigest</span><span>()</span>

<span>country</span> <span>=</span> <span>get_user_location</span><span>(</span><span>client_ip</span><span>(</span><span>self</span><span>.</span><span>request</span><span>))</span><span>.</span><span>get</span><span>(</span><span>&#39;country_name&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span>
<span>device</span> <span>=</span> <span>user_agent</span><span>.</span><span>get</span><span>(</span><span>&#39;platform&#39;</span><span>,</span> <span>{})</span><span>.</span><span>get</span><span>(</span><span>&#39;name&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span>
<span>browser</span> <span>=</span> <span>user_agent</span><span>.</span><span>get</span><span>(</span><span>&#39;browser&#39;</span><span>,</span> <span>{})</span><span>.</span><span>get</span><span>(</span><span>&#39;name&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span>

<span>referrer</span> <span>=</span> <span>self</span><span>.</span><span>request</span><span>.</span><span>GET</span><span>.</span><span>get</span><span>(</span><span>&#39;ref&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span>
<span>if</span> <span>referrer</span><span>:</span>
    <span>referrer</span> <span>=</span> <span>urlparse</span><span>(</span><span>referrer</span><span>)</span>
    <span>referrer</span> <span>=</span> <span>&#39;</span><span>{uri.scheme}</span><span>://</span><span>{uri.netloc}</span><span>/&#39;</span><span>.</span><span>format</span><span>(</span><span>uri</span><span>=</span><span>referrer</span><span>)</span>

<span>Hit</span><span>.</span><span>objects</span><span>.</span><span>get_or_create</span><span>(</span>
    <span>post_id</span><span>=</span><span>self</span><span>.</span><span>pk</span><span>,</span>
    <span>ip_address</span><span>=</span><span>ip_hash</span><span>,</span>
    <span>referrer</span><span>=</span><span>referrer</span><span>,</span>
    <span>country</span><span>=</span><span>country</span><span>,</span>
    <span>device</span><span>=</span><span>device</span><span>,</span>
    <span>browser</span><span>=</span><span>browser</span><span>)</span>
</pre></div>
<p><small>edit:</small> The IP address hash&#39;s only use is to prevent duplicate hits for a given day. This way all page views are unique by default. I then have a background task which runs at the end of each day to scrub the hashes from the hit logs, so as to not step on any over-zealous GDPR advocate&#39;s toes.</p>
<p>The only downside to this method is if there are multiple reads from the same IP address but on separate devices, it will still only be seen as one read. And I&#39;m okay with that since it constitutes such a minor fragment of traffic. This provides an accurate count of reads and I feel is more concise and simpler than many other forms of analytics capture.</p>
<h2 id="tldr">tldr;</h2>
<p>I use CSS to trigger a url analytics endpoint on <code>body:hover</code>, determine useful information from the IP address and user-agent, then hash the IP address with the date to create a unique &#34;read&#34; of a page.</p>
<h5 id="enjoyed-the-article-i-write-about-1-2-a-month-subscribe-via-email-or-rss-feed">Enjoyed the article? I write about 1-2 a month. Subscribe via <a href="https://herman.bearblog.dev/subscribe/">email</a> or <a href="https://herman.bearblog.dev/feed/">RSS feed</a>.</h5>


</div></div>
  </body>
</html>
