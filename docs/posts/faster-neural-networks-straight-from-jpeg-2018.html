<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.uber.com/blog/neural-networks-jpeg/">Original</a>
    <h1>Faster neural networks straight from JPEG (2018)</h1>
    
    <div id="readability-page-1" class="page"><div data-baseweb="block"><p>Neural networks, an important tool for processing data in a variety of industries, grew from an academic research area to a cornerstone of industry over the last few years. Convolutional Neural Networks (CNNs) have been particularly useful for extracting information from images, whether <span><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">classifying them</a></span>, <span><a href="https://research.fb.com/publications/deepface-closing-the-gap-to-human-level-performance-in-face-verification/">recognizing faces</a></span>, or <span><a href="https://deepmind.com/research/alphago/">evaluating board positions in Go</a></span>.</p>


<p>At Uber, we use CNNs for an assortment of purposes, from <span><a href="https://eng.uber.com/research/fast-and-furious-real-time-end-to-end-3d-detection-tracking-and-motion-forecasting-with-a-single-convolutional-net/">detecting objects and predicting their motion</a></span> to processing petabytes of street-level and satellite images to improve our maps. When making use of a CNN, we care about how accurately it completes its task, and in many cases, we also care about its speed. In these two examples, a network twice as fast may enable real-time detection instead of offline detection or be able to process an enormous dataset in one week of data center time instead of two.</p>


<p>In this article, we describe an approach <span><a href="https://papers.nips.cc/paper/7649-faster-neural-networks-straight-from-jpeg">presented</a></span> at <span><a href="https://neurips.cc">NeurIPS 2018</a></span> for making CNNs smaller, faster, and more accurate all at the same time by hacking <strong>libjpeg</strong> and leveraging the internal image representations already used by <span><a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a></span>, the popular image format. An earlier version of this work was presented as an <span><a href="https://openreview.net/forum?id=S1ry6Y1vG">ICLR workshop</a></span> poster in June 2018. This article will also discuss surprising insights about frequency space and color information as they relate to network architecture design.</p>


<p>To understand the approach, first let’s look at how the JPEG codec works. Once we understand JPEG, how we may apply a CNN will follow naturally.</p>


<p><h3 id="h-how-jpeg-works">How JPEG works</h3></p>


<p>JPEG is an old format, having celebrated its <span><a href="https://jpeg.org/items/20170813_press.html">25th birthday</a></span> in 2017, and remains one of the most widely used image formats. In one of its common configurations, the JPEG encoder proceeds through the steps in Figure 1, below, shown right-to-left:</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4893,&#34;hash&#34;:&#34;80716683-ea0b-4657-9ebe-77816eafb1d3&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image1-2-17.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image1-2-17.png" loading="lazy"/></a></span><figcaption>Figure 1. The JPEG encoding process consists of several stages, here shown right to left.</figcaption></figure></div>

<p>Starting with an RGB representation of an image (shown on the right), the image is converted to the YCbCr color space—Y representing luminance (brightness) and the Cb and Cr channels representing the chroma (hue). The Cb and Cr channels are then downsampled by a predetermined factor, usually two or three (in our work, we use a factor of two). This downsampling is the first stage of compression: the first stage at which information is lost. Each channel in this representation is then split into 8×8 blocks and put through the discrete cosine transform (DCT), a transform to frequency space similar to a Fourier transform. The DCT itself is lossless and reversible, transforming an 8×8 spatial block into 64 channels.</p>


<p>The coefficients are then quantized, a process which is lossy and comprises the second compression stage. Quantization is controlled by the JPEG quality parameter, with lower quality settings corresponding to more severe compression and resulting in smaller files. Quantization thresholds are specific to each spatial frequency and have been carefully designed: less compression is applied to low frequencies than high frequencies, as the human eye is more sensitive to subtle errors over broad areas than changes in magnitude of high frequency signals. The quantized DCT coefficients (integers) are then compressed losslessly by a variant of the Huffman encoding and stored in a JPEG file, like the image.jpg shown in Figure 1, above.</p>


<p>The JPEG decoding process is simply the reverse of the JPEG encoding process. All reversible steps are inverted exactly, and the two lossy steps—quantization and downsampling—are approximately inverted to produce an RGB image. For context, this process has probably been run ten times just to decode and display the images shown on this web page!</p>


<p>Let’s say we’d like to train a neural network on a JPEG image. We can decompress the JPEG image to RGB and feed it into the first layer of a neural network, as depicted in Figure 2, below:</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4899,&#34;hash&#34;:&#34;902b8247-ed12-471b-a13d-beb399cbee88&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image7-1-17.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image7-1-17.png" loading="lazy"/></a></span><figcaption>Figure 2. In a typical training procedure, a JPEG image is decompressed to RGB and then fed into a neural network.</figcaption></figure></div>

<p>Now that we understand the JPEG algorithm, can’t we easily do better? There’s no reason neural nets have to process images represented as an array of RGB pixels. And many neural nets <span><a href="http://yosinski.com/deepvis">seem to learn</a></span> a transformation from pixel space to frequency space in their first layers. So, as depicted in Figure 3, below, why not just feed the DCT representation directly into the network, skipping some early layers in the process?</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4902,&#34;hash&#34;:&#34;ce652ae5-d2f7-4b9a-93ee-d7b9f834c38b&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image10-25.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image10-25.png" loading="lazy"/></a></span><figcaption>Figure 3. Our proposed process: decompress JPEG images only to the DCT representation stage, then feed this representation directly into a neural network. As we’ll see, the frequency representation allows us to skip the first portion of the network, saving computation, and, compared to using raw pixels, results in networks with higher accuracy!</figcaption></figure></div>

<p>This is exactly the approach we detail below and in our <span><a href="https://papers.nips.cc/paper/7649-faster-neural-networks-straight-from-jpeg">paper</a></span>: we modify <strong>libjpeg</strong> to output DCT coefficients directly to TensorFlow (our <span><a href="https://github.com/uber-research/jpeg2dct">code is available</a></span> if you want to try for yourself) and train networks directly on this representation. It turns out to work really well as long as one gets a few details right!</p>


<p><h3 id="h-baselines">Baselines</h3></p>


<p>In our research, we trained networks from a JPEG representation, hoping for the resulting networks to be both accurate and fast to execute. There were several image processing tasks we considered, but for now we chose to experiment on classifying images from the <span><a href="https://ieeexplore.ieee.org/document/5206848">ImageNet dataset</a></span>. All networks we used were based on the Residual Network <span><a href="https://arxiv.org/abs/1512.03385">ResNet-50</a></span>, and all were trained for 90 epochs, which can be accomplished in our set-up in only two to three hours by using <span><a href="https://eng.uber.com/horovod/">Horovod</a></span> to take advantage of distributed training across 128 NVIDIA Pascal GPUs.</p>


<p>First, we trained a vanilla ResNet-50 in the most standard way—from RGB pixels—and found that it attains a top-five error of about 7.4 percent and could run inference on just over 200 images per second on an NVIDIA Pascal GPU. In Figure 4, below, we depict that network as a small black square on a plot that traces the relationship between error rate and speed:</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4897,&#34;hash&#34;:&#34;552b0d86-023e-4ac5-96d6-6dbd19bfb277&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image5-1-22.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image5-1-22.png" loading="lazy"/></a></span><figcaption>Figure 4. In this graph, we map the relationship between top-five error and speed in images per second for two networks trained from pixels.</figcaption></figure></div>

<p>The gray dotted line shows this baseline level of accuracy. We prefer networks that are faster to ones that are slower and networks that have lower error to ones with higher error, so we wanted to find networks that appear down and to the right in this plot. Depending on the specific application, we might be willing to make tradeoffs in terms of accuracy and speed. In addition to the RGB pixel network, we also trained a network from YCbCr pixels (gray diamond under the square) and found it to perform just about identically, showing that color space on its own doesn’t significantly affect performance here.</p>


<p>Since we aimed for networks that are fast and accurate, we first tried making ResNet-50 shorter (removing blocks from the bottom) or thinner (using fewer channels per layer). While this makes the networks faster, how much accuracy will we lose? In Figure 5, below, a few shorter and thinner networks display the trade-off curve available to us by simple mutations of ResNet-50 that still leverage RGB pixel input:</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4894,&#34;hash&#34;:&#34;9473058d-c665-49fb-8f30-c1e82414b40c&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image2-1-26.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image2-1-26.png" loading="lazy"/></a></span><figcaption>Figure 5. Different trade-off curves are available when making ResNet-50 shorter or thinner but still using RGB input.</figcaption></figure></div>

<p>In Figure 5, we can see that shorter networks with full width fare better than thin networks that maintain full depth. The light gray “Remove N ID Blocks” line forms the <span><a href="https://en.wikipedia.org/wiki/Pareto_efficiency">Pareto front</a></span>, showing the set of “non-dominated” networks, or those networks offering the best possible speed vs. accuracy tradeoffs. For example, simply removing three ID blocks gives us a boost to almost 300 images per second, but errors also increase, in this case to nearly eight percent. The “Remove 3 ID Blocks” network is on the Pareto front because no other network has both lower error and higher speed than it. (More details about these networks are available in our full research <span><a href="https://papers.nips.cc/paper/7649-faster-neural-networks-straight-from-jpeg">paper</a></span>.)</p>


<p>Now let’s try training networks directly on the DCT coefficients available in the JPEG decoder to see if we can push the whole Pareto front forward.</p>


<p><h3 id="h-training-networks-on-dct-inputs">Training networks on DCT inputs</h3></p>


<p>To train from DCT input, we must first consider the problem of different input sizes.</p>


<p>The vanilla ResNet-50 is designed for inputs with shape (224, 224, 3) — width and height of 224 pixels and 3 color channels (RGB). Our DCT coefficients are very differently shaped: the Y channel is 8x smaller along each spatial dimension but has 64 frequency channels, resulting in input shape (28, 28, 64). The Cb and Cr channels are 16x smaller (due to the additional 2x downsampling), so they each have shape (14, 14, 64). How should we deal with representations of these unusual shapes?</p>


<p>Assuming we do not completely ignore either input, a basic requirement of any proposed architecture is that it eventually combines Y and Cb/Cr before making a classification decision. All architectures we will consider are of the following form: apply a transform or sub-network T<sub>1</sub> to Y, apply another transform or sub-network T<sub>2</sub> to Cb and Cr, concatenate the results channel-wise, and feed the concatenated representation to a ResNet mirroring the top of ResNet-50 with or without some modifications. The general architecture is depicted in Figure 6, below:</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4895,&#34;hash&#34;:&#34;ed7abccd-2e8c-449d-9084-23537f058d34&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image3-1-15.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image3-1-15.png" loading="lazy"/></a></span><figcaption>Figure 6. In the general form used for networks taking DCT input, T<sub>1</sub> and T<sub>2</sub> may be arbitrary learned or non-learned transforms.</figcaption></figure></div>

<p>In cases where T<sub>2</sub> is a sub-network (learned transform), the weights are unshared between the Cb and Cr paths. Note that in order to concatenate the representations channel-wise, they must share the same spatial size, so, for example, it is not possible for T<sub>1</sub> and T<sub>2</sub> both to be identity transforms.</p>


<p>We consider two families of T<sub>1</sub> and T<sub>2</sub> transforms: those that <em>merge paths early</em> by using at most single-layer transforms, and those that do more significant processing first, <em>merging paths late</em>.</p>


<p><h4 id="h-dct-early-merge-architectures">DCT Early Merge architectures</h4></p>


<p>The simplest way of making the disparate spatial sizes of Y and Cb/Cr match is to downsample the large representation (Y) or upsample the small representations (Cb/Cr). We try both and add the results to our plot as blue “DownSampling” and “UpSampling” circles, depicted in Figure 7, below:</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4901,&#34;hash&#34;:&#34;8e8502bc-2a8a-4a9a-b61b-8a13f057a95c&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image9-1-5.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image9-1-5.png" loading="lazy"/></a></span><figcaption>Figure 7. Using a DCT representation and simply merging data streams as early as possible—with a single layer—results in a shifted Pareto front with both faster and more accurate networks.</figcaption></figure></div>

<p>Because the DownSampling model reduces the spatial size of input data at the first layer, it ends up being very fast—about 450 images per second, or more than twice the speed of ResNet-50—but its error is also much higher. The UpSampling model is slower and more accurate because it throws away less information.</p>


<p>We were initially a little disappointed that the error in the UpSampling model was higher than the baseline ResNet-50. We hypothesized that the source of this problem was a subtle issue: units in early layers in the DownSampling and UpSampling models have receptive fields that are too large. The receptive field of a unit in a CNN is the number of input pixels that it can see, or the number of input pixels that can possibly influence its activation. Indeed, after examining the strides and receptive fields of each layer in the network, we found that halfway through a vanilla ResNet-50, units have receptive fields of about 70. Just as far through our naively assembled UpSampling model the receptive fields are already 110px, larger because our DCT input layer has [stride, receptive field] of [8, 8] instead of the typical typical [1, 1] pixel input layer. Intuitively we’re asking the network to learn about 110px wide visual concepts but not giving it enough layers or computational capacity to do so. (See Section 3 and Figure 4 in our full <span><a href="https://papers.nips.cc/paper/7649-faster-neural-networks-straight-from-jpeg">paper</a></span> for more discussion.)</p>


<p>We created a new Receptive Field Aware (RFA) model, UpSampling-RFA, by adding extra stride-1 blocks early in the network. With this new model, the growth of receptive field layer-by-layer is now smoother, approximately matching that in ResNet-50, and performance is increased (see Figure 7). If the upsampling is done via learned Deconvolution instead of pixel duplication, error is further reduced, producing the best model yet: Deconvolution-RFA.</p>


<p>By being careful about receptive fields, we’ve now discovered a model that is both <strong>more accurate</strong> (6.98 percent compared to 7.35 percent error) <em>and</em> <strong>1.29x faster</strong> than the baseline! Other models along the same DCT Early Merge line now form the new Pareto front, dominating previous models in terms of the error and speed trade-offs they offer.</p>


<p>Next, we try deeper learned T<sub>1</sub>and T<sub>2</sub> transforms to see if we can push the frontier further.</p>


<p><h4 id="h-dct-late-merge-architectures">DCT Late Merge architectures</h4></p>


<p>Merging the Y and Cb/Cr channels early follows the typical and conceptually simple deep learning paradigm: get all the data together somehow, give it to the model, and let the model learn what to do with it. This approach is elegant in its simplicity, but could we produce even faster models by eliminating unneeded computation?</p>


<p>After some experimentation, we found that allowing the luminance branch many layers of computation was required for high accuracy, but the chroma paths could be afforded fewer layers of computation without detriment. In other words, putting the Y channel into the bottom of the network and then injecting Cb/Cr information halfway through works just as well as starting with all three at the bottom, but, of course, the former saves computation.</p>


<p>As depicted in Figure 8, below, we show the resulting speed and error rate of this Late-Concat model in red, together with two related networks: a receptive field aware version, Late-Concat-RFA, and a version tweaked for speed by using fewer filters, Late-Concat-RFA-Thinner. As we can see, the Pareto front moves forward once again! In particular, we now have found a model <strong>1.77x faster</strong> than a vanilla ResNet and with nearly the same rate of error.</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4898,&#34;hash&#34;:&#34;b28f009c-318a-464b-8935-922a5a1bbf99&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image6-1-20.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/image6-1-20.png" loading="lazy"/></a></span><figcaption>Figure 8. Late-Concat models push the Pareto front forward again. By allowing significantly deeper T<sub>1</sub> than T<sub>2</sub>—more computation along the Y path than Cb/Cr paths—we obtain the best speed/accuracy tradeoffs. Late-Concat-RFA-Thinner is 1.77x faster than a vanilla ResNet-50 at about the same accuracy.</figcaption></figure></div>

<p>It is interesting that color information is not needed until later in the network, when it is combined with higher-level concepts learned from luminance. At this point we can only speculate, but it may be that learning mid-level concepts (for example: grass or dog fur) requires several layers of processing fine brightness edges into textures before being combined with spatially less precise color information (for example: green or brown). Perhaps we could have expected this result (Figure 9) all along from the higher frequency black and white edges and lower frequency (or constant) color detectors learned by ResNet-50 from RGB pixels.</p>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;id&#34;:4915,&#34;hash&#34;:&#34;6aabdb5e-90b5-4d5f-8acf-89e115e55332&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><span><a href="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/collage.png"><img alt="Image" src="https://admin.preprod.blog.uber.10uplabs.com/wp-content/uploads/2022/08/collage.png" loading="lazy"/></a></span><figcaption>Figure 9. First layer features learned by ResNet-50 with RGB pixel input. Many edge detectors are primarily black and white, operating in luminance space. Many color features are either constant over space or lower frequency and may serve just to pass rough color information to higher layers where it will be needed. We’ve <span><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">seen filters like this since 2012</a></span>; should we have expected all along for color not to be needed until later in the network?</figcaption></figure></div>

<p><h3 id="h-pinpointing-gains-and-future-directions">Pinpointing gains and future directions</h3></p>


<p>The results we’ve shown so far are encouraging and useful to practitioners—we’ve shown <em>what</em> works to produce fast and accurate networks. To make this contribution to the field meaningful scientifically, we also need to <em>pinpoint</em> these gains and show <em>why</em> they are realized. In our <span><a href="https://papers.nips.cc/paper/7649-faster-neural-networks-straight-from-jpeg">paper</a></span>, we perform ablation studies to identify sources of gains.</p>


<p>In summary, we found that speed gains are simply due to a smaller volume of data on the input layer and subsequent layers, as one might expect. Accuracy gains are due primarily to the specific use of a DCT representation, which turns out to work curiously well for image classification. Surprisingly, simply <strong>replacing the first convolutional layer of a ResNet-50 with the stride 8 DCT transform results in much better performance</strong>. It works even better than a learned transform of exactly the same shape. In other words, in contrast to conventional wisdom, we find that using larger receptive fields and strides (of 8 each) works better than small, and hard coding the first layer works better than learning it. When <span><a href="https://arxiv.org/abs/1512.03385">Residual Networks</a></span> set the state of the art on ImageNet in 2015, simply replacing the first layer with a frozen DCT would have further improved the state of the art.</p>


<p>Future directions suggested by the above results include evaluating different frequency space representations, DCTs of different sizes, and performance on detection, segmentation, and other image-processing tasks.</p>


<p>If you work on any image processing using neural networks, we’d love to hear if switching to a DCT representation benefits your task as well as it has here. If you’d like a more detailed description of these results, <span><a href="https://papers.nips.cc/paper/7649-faster-neural-networks-straight-from-jpeg">see our paper</a></span> (including architectural details in the Supplementary Information section) and make use of our <span><a href="https://github.com/uber-research/jpeg2dct">codebase</a></span> to easily read DCT representations into TensorFlow or PyTorch.</p>


<p><em>If this type of research interests you, consider applying for a role at </em><span><a href="http://uber.ai/"><em>Uber AI Labs</em></a></span><em>.</em></p>
</div></div>
  </body>
</html>
