<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marian42.de/article/infinite-wfc/">Original</a>
    <h1>Generating an infinite world with the Wave Function Collapse algorithm</h1>
    
    <div id="readability-page-1" class="page"><div>
        <figure>
    <a href="https://marian42.de/article/infinite-wfc/city.jpg">
        <img src="https://marian42.de/article/infinite-wfc/city_1280.jpg" alt=""/>
    </a>
</figure>
<p>This article describes how I generate an infinite city using the Wave Function Collapse algorithm in a way that is fast, deterministic, parallelizable and reliable.
It&#39;s a follow-up to <a href="https://marian42.de/article/wfc/">my 2019 article</a> on adapting the WFC algorithm to generate an infinite world.
The new approach presented in this article removes the limitations of my original implementation.
I first mentioned these ideas in this <a href="https://twitter.com/marian42_/status/1490060483944140804">Twitter thread</a>.</p>

<p>The goal is to procedurally generate a 3D environment by placing human designed blocks on a 3D grid.
The blocks need to be placed in accordance with given adjacency contraints.
For each of the 6 sides of each block, some information about the face and its symmetry is used to generate a list of possible neighbors.</p>
<figure>
    <a href="https://marian42.de/article/infinite-wfc/modules.png">
        <img src="https://marian42.de/article/infinite-wfc/modules_1280.png" alt=""/>
    </a>
</figure>
<p>This is different from the original formulation of the <a href="https://github.com/mxgmn/WaveFunctionCollapse">WFC algorithm</a>, where the possible blocks, their adjacency rules and their spawn probabilities are extracted automatically from an example texture.</p>
<p>In this improved version, the generation method is robust enough to be shipped in a commercial game, so it needs to be reliable, fast and allow for artistic control over the result.</p>

<p>This article is aimed at readers who already know how the <a href="https://github.com/mxgmn/WaveFunctionCollapse">WFC algorithm</a> works, but here is a brief recap.
Remember, I&#39;m skipping the part where blocks are extracted from an example texture and I&#39;m only using the part where we generate a new &#34;texture&#34;.</p>
<figure>
    <a href="https://camo.githubusercontent.com/dc39c61e02aa67abd0f923628cf241120d14f517/687474703a2f2f692e696d6775722e636f6d2f734e75425653722e676966">
        <img src="https://camo.githubusercontent.com/dc39c61e02aa67abd0f923628cf241120d14f517/687474703a2f2f692e696d6775722e636f6d2f734e75425653722e676966" alt=""/>
    </a>
</figure></div></div>
  </body>
</html>
