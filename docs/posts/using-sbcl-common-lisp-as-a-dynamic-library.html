<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mstmetent.blogspot.com/2022/04/using-lisp-libraries-from-other.html">Original</a>
    <h1>Using SBCL Common Lisp as a Dynamic Library</h1>
    
    <div id="readability-page-1" class="page"><div id="text-1-2">
<p>
Let&#39;s take a classic example to illustrate this new functionality:
Suppose you want to write C code and call out to a library called
<b>calc</b>. <b>calc</b> is written entirely in Common Lisp, full of classes
and objects and methods defining ASTs for a simple symbolic
calculator. It has functions like <code>parse-expr</code>, <code>simplify</code>, and
<code>pretty-print-expr</code>, where everything works on Lisp objects.
</p>

<div>
<pre><span>(</span><span>defclass</span> <span>expression</span> <span>()</span>
  <span>()</span>
  <span>(</span><span>:documentation</span> <span>&#34;An abstract expression.&#34;</span><span>)</span><span>)</span>
<span>(</span><span>defclass</span> <span>int-literal</span> <span>(</span>expression<span>)</span>
  <span>(</span><span>(</span>value <span>:reader</span> int-literal-value<span>)</span><span>)</span>
  <span>(</span><span>:documentation</span> <span>&#34;An integer literal.&#34;</span><span>)</span><span>)</span>
<span>(</span><span>defclass</span> <span>sum-expression</span> <span>(</span>expression<span>)</span>
  <span>(</span><span>(</span>left-arg <span>:reader</span> sum-expression-left-arg<span>)</span>
   <span>(</span>right-arg <span>:reader</span> sum-expression-right-arg<span>)</span><span>)</span><span>)</span>
<span>(</span><span>defun</span> <span>parse</span> <span>(</span>string<span>)</span> ...<span>)</span>
<span>(</span><span>defun</span> <span>simplify</span> <span>(</span>expr<span>)</span> ...<span>)</span>
<span>(</span><span>defun</span> <span>expression-to-string</span> <span>(</span>expr<span>)</span> ...<span>)</span>
</pre>
</div>


<p>
We&#39;d like to expose these functions so that we can call these functions
from other programming languages using the C ABI. So how does it
work in the simplest case of using <b>calc</b> from a simple C program?
</p>

<p>
First, we need to define these function pointers in Lisp. The
primitives SBCL now exposes to deal with this is through the macro
<code>sb-alien:define-alien-callable</code>. You can use this macro in the
following way:
</p>

<div>
<pre><span>(</span><span>define-alien-callable</span> calc-parse int <span>(</span><span>(</span>source c-string<span>)</span> <span>(</span>result <span>(</span>* <span>(</span>* t<span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>handler-case</span>
      <span>(</span><span>progn</span>
         <span>;; </span><span>The following needs to use SBCL internal functions to</span>
         <span>;; </span><span>coerce a Lisp object into a raw pointer value. This is</span>
         <span>;; </span><span>unsafe and will be fixed in the next section.</span>
         <span>(</span>setf <span>(</span>deref result<span>)</span> <span>(</span>sap-alien <span>(</span>int-sap <span>(</span>get-lisp-obj-address <span>(</span>parse source<span>)</span><span>)</span><span>)</span> <span>(</span>* t<span>)</span><span>)</span><span>)</span>
         0<span>)</span>
    <span>(</span>t <span>(</span>condition<span>)</span> <span>(</span><span>declare</span> <span>(</span>ignore condition<span>)</span><span>)</span> 1<span>)</span><span>)</span><span>)</span>

<span>(</span><span>define-alien-callable</span> calc-simplify int <span>(</span><span>(</span>expr <span>(</span>* t<span>)</span><span>)</span> <span>(</span>result <span>(</span>* <span>(</span>* t<span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>handler-case</span>
      <span>(</span><span>progn</span>
         <span>;; </span><span>The following needs to use SBCL internal functions to</span>
         <span>;; </span><span>coerce a raw pointer value into a Lisp object and</span>
         <span>;; </span><span>back. This is unsafe and will be fixed in the next</span>
         <span>;; </span><span>section.</span>
         <span>(</span>setf <span>(</span>deref result<span>)</span>
               <span>(</span>sap-alien <span>(</span>int-sap <span>(</span>get-lisp-obj-address
                                    <span>(</span>simplify <span>(</span>%make-lisp-obj <span>(</span>sap-int <span>(</span>alien-sap expr<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
                          <span>(</span>* t<span>)</span><span>)</span><span>)</span>
         0<span>)</span>
    <span>(</span>t <span>(</span>condition<span>)</span> <span>(</span><span>declare</span> <span>(</span>ignore condition<span>)</span><span>)</span> 1<span>)</span><span>)</span><span>)</span>

<span>(</span><span>define-alien-callable</span> calc-expression-to-string int <span>(</span><span>(</span>expr <span>(</span>* t<span>)</span><span>)</span> <span>(</span>result <span>(</span>* c-string<span>)</span><span>)</span><span>)</span>
  <span>(</span><span>handler-case</span>
      <span>(</span><span>progn</span>
         <span>;; </span><span>The following needs to use SBCL internal functions to coerce a raw</span>
         <span>;; </span><span>pointer value into a Lisp object. This is unsafe and</span>
         <span>;; </span><span>will be fixed in the next section.</span>
         <span>(</span>setf <span>(</span>deref result<span>)</span> <span>(</span>%make-lisp-obj <span>(</span>sap-int <span>(</span>alien-sap <span>(</span>expression-to-string result<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
         0<span>)</span>
    <span>(</span>t <span>(</span>condition<span>)</span> <span>(</span><span>declare</span> <span>(</span>ignore condition<span>)</span><span>)</span> 1<span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Notice that for example purposes we just translate any exceptional
Lisp conditions into the C return error code convention. The actual
returned value is set through the second passing argument&#39;s
out-pointer in typical C fashion.
</p>

<p>
Now we&#39;ve defined C callable function pointers associated with
names. You can get the underlying function pointers with the
function <code>sb-alien:alien-callable-function</code>, which is useful for
passing these callable functions as callbacks to C. SBCL actually
didn&#39;t even have an external interface to callbacks before this,
and CFFI had been using an internal system interface which is now
superseded by this interface.
</p>

<p>
However, we&#39;re not too interested in callbacks right now. We want
to be able to call these functions from C! You can save the Lisp
image containing new callable function pointer definitions like so:
</p>

<div>
<pre><span>(</span>sb-ext:save-lisp-and-die <span>&#34;calc.core&#34;</span>
  <span>:callable-exports</span> &#39;<span>(</span><span>&#34;calc_parse&#34;</span> <span>&#34;calc_simplify&#34;</span> <span>&#34;calc_expression_to_string&#34;</span> ...<span>)</span><span>)</span>
</pre>
</div>

<p>
What the <code>:callable-exports</code> argument describes is the set of C
symbols you want to initialize with the corresponding function
pointers created with <code>define-alien-callable</code>. This image, when
started, has only two jobs: finish starting up the Lisp system and
initialize these callable exports with the proper function
pointers. It then immediately passes control back to C 
</p>

<p>
Here&#39;s an example C file which uses these functions:
</p>

<div>
<pre><span>#include</span> <span>&#34;libcalc.h&#34;</span>
<span>int</span> <span>main</span> <span>()</span> <span>{</span>
    initialize_lisp<span>(</span><span>&#34;libcalc.core&#34;</span><span>)</span>;
    <span>expr_type</span> <span>expr</span>;
    <span>if</span> <span>(</span>calc_parse<span>(</span>source, &amp;expr<span>)</span> != ERR_SUCCESS<span>)</span>
       die<span>(</span><span>&#34;unable to parse expression&#34;</span><span>)</span>;
    <span>char</span> *<span>result</span>;
    <span>expr_type</span> <span>simplified_expr</span>;
    calc_simplify<span>(</span>expr, &amp;simplified_expr<span>)</span>;
    <span>if</span> <span>(</span>calc_expression_to_string<span>(</span>simplified_expr, &amp;result<span>)</span> != ERR_SUCCESS<span>)</span>
      die<span>(</span><span>&#34;unable to print expression to string&#34;</span><span>)</span>;
    printf<span>(</span><span>&#34;\n%s\n&#34;</span>, result<span>)</span>;
    <span>return</span> 0;
<span>}</span>
</pre>
</div>

<p>
Notice that there is a symbol, <code>initialize_lisp</code>, that we can use
to initialize the Lisp runtime. Its arguments are the same as the
arguments you can normally pass to the main sbcl executable, so
once the core name is specified and the runtime initializes the
function pointers we are going to use, control is returned to the
program.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
Once the Lisp runtime has been initialized, your function pointers
are ready to use, and calling them from C works just like a
callback would, with the same type translation machinery used.
</p>
</div></div>
  </body>
</html>
