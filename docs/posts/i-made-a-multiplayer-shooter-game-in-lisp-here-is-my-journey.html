<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ertu.dev/posts/i-made-an-online-shooter-game-in-lisp/">Original</a>
    <h1>I made a multiplayer shooter game in Lisp, here is my journey</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p>Developing a multiplayer third-person shooter game as a solo developer is a journey filled with challenges and
rewards. I embarked on this adventure to create <strong>Wizard Masters</strong>, a web-based multiplayer game where players battle as
mages wielding elemental spells.</p><p>Built using <strong>Clojure</strong>, a Lisp dialect, this project pushed the boundaries of web game
development and my own skills as a programmer. Here’s how it went.</p><p>In Wizard Masters, players can choose from six elemental spells—fire, toxic, ice, lightning, and earth—and compete in
two modes: solo and team deathmatch. I published the game on CrazyGames to reach a broader audience. However, its
multiplayer nature demanded a large player base, which was a constant challenge.</p><p>Game Link: <a href="https://wizardmasters.io">https://wizardmasters.io</a></p><h3 id="why-clojure">Why Clojure?</h3><p>Clojure is my go-to programming language, both professionally and personally. It’s a full-stack language:</p><ul><li>Clojure runs on the JVM for backend development.</li><li>ClojureScript compiles to JavaScript, enabling smooth browser-based applications.</li></ul><p>This one language to rule them all approach made it an obvious choice for me. Additionally, Clojure’s REPL <em>(
Read-Eval-Print Loop)</em> system is a game-changer. Unlike typical REPLs, Clojure’s REPL is highly interactive and organic,
allowing live updates to the game without refreshing the browser. This significantly sped up my development process,
enabling me to create and test mechanics in real time.</p><p>I created a YouTube video showing how to use the REPL with jMonkeyEngine, a Java-based game framework. You
can <a href="https://www.youtube.com/watch?v=IOPz9I49snM">watch it here</a>.</p><h3 id="graphics-library">Graphics Library</h3><p>After experimenting with several graphics libraries, including Three.js and PlayCanvas, I chose Babylon.js. Here’s why:</p><ul><li>Feature-rich: Babylon.js offers a robust set of tools for 3D development.</li><li>Great documentation: Compared to other libraries, Babylon’s documentation stands out for its clarity and
comprehensiveness.</li><li>Supportive community: The community’s assistance proved invaluable.</li></ul><p>ClojureScript’s npm integration through <strong>shadow-cljs</strong> made it easy to incorporate Babylon.js, allowing me to focus on
building the game.</p><h3 id="code">Code</h3><p>The following code snippet showcases the implementation of a <code>:player/jump</code> rule, which handles the player’s ability to
jump in the game. This rule uses a <code>:what</code> block, essentially a hashmap, to define the conditions under which the rule
is triggered.</p><p>In <strong>Wizard Masters</strong>, all game data resides in a global game database—a single large hashmap. The fields referenced in
the :what block (e.g., :pointer-locked?, :player/ground?) are keys in this global hashmap. To execute the rule, several
conditions must be met:</p><ol><li>Each key in the <code>:what</code> block must have a non-null value.</li><li>The <code>:when</code> block must evaluate to true.</li><li>The <code>:then</code> block is executed when the above conditions are satisfied.</li></ol><p>The triggering of this rule occurs through the fire-rules function, which activates the rule whenever a <code>:what</code> field is
updated, regardless of whether the value changes. If a field has a <code>:then false</code> attribute, the rule will not trigger,
avoiding infinite loops and unnecessary executions. The rule system was influenced by the Clojure library <strong>O’Doyle
Rules by Zach Oakes</strong>.</p><p>Here’s the complete implementation for the <code>:player/jump</code> rule:</p><div><pre tabindex="0"><code data-lang="clojure"><span><span><span>(</span><span>reg-rule</span>
</span></span><span><span>  <span>:player/jump</span>
</span></span><span><span>  <span>{</span><span>:locals</span> <span>{</span><span>:jump-vec</span> <span>(</span><span>v3</span><span>)}</span>
</span></span><span><span>   <span>:what</span> <span>{</span><span>:keys-pressed</span> <span>{}</span>
</span></span><span><span>          <span>:player/mobile-jump-click?</span> <span>{}</span>
</span></span><span><span>          <span>:pointer-locked?</span> <span>{</span><span>:then</span> <span>false</span><span>}</span>
</span></span><span><span>          <span>:player/ground?</span> <span>{</span><span>:then</span> <span>false</span><span>}</span>
</span></span><span><span>          <span>:player/capsule</span> <span>{</span><span>:then</span> <span>false</span><span>}</span>
</span></span><span><span>          <span>:player/anim-groups</span> <span>{</span><span>:then</span> <span>false</span><span>}</span>
</span></span><span><span>          <span>:keys-was-pressed</span> <span>{</span><span>:then</span> <span>false</span><span>}</span>
</span></span><span><span>          <span>:player/jump-up?</span> <span>{</span><span>:then</span> <span>false</span><span>}}</span>
</span></span><span><span>   <span>:when</span> <span>(</span><span>fn </span><span>[{{</span><span>:keys</span> <span>[</span><span>player/game-started?</span>
</span></span><span><span>                       <span>player/mobile-jump-click?</span>
</span></span><span><span>                       <span>player/ground?</span>
</span></span><span><span>                       <span>player/dash?</span>
</span></span><span><span>                       <span>player/jump-up?</span>
</span></span><span><span>                       <span>player/current-running-anim-group</span>
</span></span><span><span>                       <span>player/current-health</span><span>]}</span> <span>:session</span><span>}]</span>
</span></span><span><span>             <span>(</span><span>and </span><span>game-started?</span>
</span></span><span><span>                  <span>(</span><span>nil? </span><span>current-running-anim-group</span><span>)</span>
</span></span><span><span>                  <span>(</span><span>or </span><span>(</span><span>re/key-is-pressed?</span> <span>&#34;Space&#34;</span><span>)</span> <span>mobile-jump-click?</span><span>)</span>
</span></span><span><span>                  <span>ground?</span>
</span></span><span><span>                  <span>(</span><span>not </span><span>(</span><span>freezing?</span><span>))</span>
</span></span><span><span>                  <span>(</span><span>not </span><span>(</span><span>wind-stunned?</span><span>))</span>
</span></span><span><span>                  <span>(</span><span>not </span><span>jump-up?</span><span>)</span>
</span></span><span><span>                  <span>(</span><span>not </span><span>dash?</span><span>)</span>
</span></span><span><span>                  <span>(</span><span>&gt; </span><span>current-health</span> <span>0</span><span>)))</span>
</span></span><span><span>   <span>:then</span> <span>(</span><span>fn </span><span>[{{</span><span>player-capsule</span> <span>:player/capsule</span>
</span></span><span><span>                <span>player-jump-force</span> <span>:player/jump-force</span><span>}</span> <span>:session</span>
</span></span><span><span>               <span>{</span><span>:keys</span> <span>[</span><span>jump-vec</span><span>]}</span> <span>:locals</span><span>}]</span>
</span></span><span><span>             <span>(</span><span>j/assoc!</span> <span>jump-vec</span> <span>:y</span> <span>player-jump-force</span><span>)</span>
</span></span><span><span>             <span>(</span><span>when-not </span><span>(</span><span>casting-spell?</span><span>)</span>
</span></span><span><span>                       <span>(</span><span>re/fire-rules</span> <span>{</span><span>:player/jump-up?</span> <span>true</span><span>}))</span>
</span></span><span><span>             <span>(</span><span>let </span><span>[</span><span>player-pos</span> <span>(</span><span>api.core/get-pos</span> <span>player-capsule</span><span>)]</span>
</span></span><span><span>                  <span>(</span><span>api.physics/apply-impulse</span> <span>player-capsule</span> <span>jump-vec</span> <span>player-pos</span><span>)))})</span>
</span></span></code></pre></div><h4 id="how-it-works">How It Works</h4><ul><li><code>:what</code> block defines dependencies, such as key presses and the character’s physical capsule etc.</li><li><code>:when</code> block ensures the jump can only occur under certain conditions (e.g., the player
isn’t frozen or stunned).</li><li><code>:then</code> block applies an upward force to the player’s capsule and triggers additional rules if needed.</li></ul><p>The next example demonstrates a rule for updating the player’s rotation every frame. This ensures the character always
faces the forward direction of the camera. Here, the <code>dt</code> field in the <code>:what</code> block represents the time elapsed between
the
current frame and the previous one, causing the rule to trigger <strong>on every frame</strong>.</p><div><pre tabindex="0"><code data-lang="clojure"><span><span><span>(</span><span>reg-rule</span>
</span></span><span><span>  <span>:player/rotation</span>
</span></span><span><span>  <span>{</span><span>:locals</span> <span>{</span><span>:forward-temp</span> <span>(</span><span>v3</span><span>)</span>
</span></span><span><span>            <span>:result-temp</span> <span>(</span><span>v3</span><span>)}</span>
</span></span><span><span>   <span>:what</span> <span>{</span><span>:dt</span> <span>{}</span>
</span></span><span><span>          <span>:camera</span> <span>{}</span>
</span></span><span><span>          <span>:player/model</span> <span>{}}</span>
</span></span><span><span>   <span>:when</span> <span>(</span><span>fn </span><span>[{{</span><span>:keys</span> <span>[</span><span>player/game-started?</span><span>]}</span> <span>:session</span><span>}]</span>
</span></span><span><span>             <span>game-started?</span><span>)</span>
</span></span><span><span>   <span>:then</span> <span>(</span><span>fn </span><span>[{{</span><span>camera</span> <span>:camera</span>
</span></span><span><span>                <span>player-model</span> <span>:player/model</span><span>}</span> <span>:session</span>
</span></span><span><span>               <span>{</span><span>:keys</span> <span>[</span><span>forward-temp</span> <span>result-temp</span><span>]}</span> <span>:locals</span><span>}]</span>
</span></span><span><span>             <span>(</span><span>let </span><span>[[</span><span>yaw</span> <span>offset</span><span>]</span> <span>(</span><span>api.camera/get-char-forward-dir</span> <span>{</span><span>:camera</span> <span>camera</span>
</span></span><span><span>                                                                  <span>:forward-temp</span> <span>forward-temp</span>
</span></span><span><span>                                                                  <span>:result-temp</span> <span>result-temp</span><span>})]</span>
</span></span><span><span>                  <span>(</span><span>m/assoc!</span> <span>player-model</span> <span>:rotation.y</span> <span>(</span><span>+ </span><span>yaw</span> <span>offset</span><span>))))})</span>
</span></span></code></pre></div><h3 id="network">Network</h3><p>Writing network code for a fast-paced multiplayer game was a monumental task. I initially chose to handle all the
networking myself, thinking it would be a rewarding experience. It was indeed rewarding—but also hellish. I used several
Clojure async libraries, including Aleph, Manifold, and core.async, to manage the complexity of real-time communication.</p><p>When a player joins a game, a WebSocket connection is established. The backend continuously sends world snapshots to all
connected players at a tick rate of 20 (one update every 50 milliseconds). Additionally, specific processes handle
actions like spellcasting, damage calculation, and player deaths.</p><p>The following snippet registers a process called <code>:super-nova</code>, which handles the logic for a player casting a <strong>Super
Nova</strong>
spell. When triggered, the backend processes the event asynchronously, computes the area of effect, and notifies
relevant players.</p><div><pre tabindex="0"><code data-lang="clj"><span><span><span>(</span><span>reg-pro</span>
</span></span><span><span>  <span>:super-nova</span>
</span></span><span><span>  <span>(</span><span>fn </span><span>[{</span><span>:keys</span> <span>[</span><span>id</span> <span>data</span><span>]}]</span>
</span></span><span><span>    <span>(</span><span>try</span>
</span></span><span><span>      <span>(</span><span>add-super-nova</span> <span>id</span> <span>(</span><span>:pos</span> <span>data</span><span>))</span> <span>;; Add the visual effect</span>
</span></span><span><span>      <span>(</span><span>apply-range-damage</span> <span>{</span><span>:current-player-id</span> <span>id</span>
</span></span><span><span>                           <span>:pos</span> <span>(</span><span>:pos</span> <span>data</span><span>)</span>
</span></span><span><span>                           <span>:radius</span> <span>super-nova-range</span>
</span></span><span><span>                           <span>:diameter</span> <span>super-nova-diameter</span>
</span></span><span><span>                           <span>:max-damage</span> <span>600</span>
</span></span><span><span>                           <span>:damage-pro-id</span> <span>:got-super-nova-hit</span><span>})</span> <span>;; Calculate damage</span>
</span></span><span><span>      <span>(</span><span>catch</span> <span>Exception</span> <span>e</span>
</span></span><span><span>        <span>(</span><span>log/error</span> <span>e</span> <span>&#34;Super nova hit error!&#34;</span><span>)))))</span>
</span></span></code></pre></div><h4 id="area-of-effect-damage-calculation">Area of Effect Damage Calculation</h4><p>The core of this process is the apply-range-damage function. This function determines which players are affected by a
spell, calculates the damage based on proximity, and updates the game state accordingly.</p><div><pre tabindex="0"><code data-lang="clj"><span><span><span>(</span><span>defn- </span><span>apply-range-damage</span> <span>[{</span><span>:keys</span> <span>[</span><span>current-player-id</span>
</span></span><span><span>                                   <span>pos</span>
</span></span><span><span>                                   <span>radius</span>
</span></span><span><span>                                   <span>height</span>
</span></span><span><span>                                   <span>diameter</span>
</span></span><span><span>                                   <span>max-damage</span>
</span></span><span><span>                                   <span>damage-pro-id</span>
</span></span><span><span>                                   <span>shape-type</span>
</span></span><span><span>                                   <span>damage-over-time</span>
</span></span><span><span>                                   <span>damage-params</span><span>]</span>
</span></span><span><span>                            <span>:or</span> <span>{</span><span>shape-type</span> <span>:sphere</span><span>}}]</span>
</span></span><span><span>  <span>(</span><span>when-let </span><span>[</span><span>room-id</span> <span>(</span><span>get-room-id-by-player-id</span> <span>current-player-id</span><span>)]</span>
</span></span><span><span>    <span>(</span><span>let </span><span>[</span><span>current-player-ids</span> <span>(</span><span>set </span><span>(</span><span>keys </span><span>(</span><span>get-players-with-same-room-id</span> <span>current-player-id</span><span>)))</span>
</span></span><span><span>          <span>my-team</span> <span>(</span><span>get-player-team</span> <span>current-player-id</span><span>)</span>
</span></span><span><span>          <span>players-within-range</span> <span>(</span><span>-&gt;&gt;</span> <span>(</span><span>get-world-by-player-id</span> <span>current-player-id</span><span>)</span>
</span></span><span><span>                                    <span>(</span><span>keep</span>
</span></span><span><span>                                      <span>(</span><span>fn </span><span>[[</span><span>player-id</span> <span>player-data</span><span>]]</span>
</span></span><span><span>                                        <span>(</span><span>let </span><span>[[</span><span>x</span> <span>y</span> <span>z</span><span>]</span> <span>[(</span><span>:px</span> <span>player-data</span><span>)</span> <span>(</span><span>:py</span> <span>player-data</span><span>)</span> <span>(</span><span>:pz</span> <span>player-data</span><span>)]</span>
</span></span><span><span>                                              <span>[</span><span>x1</span> <span>y1</span> <span>z1</span><span>]</span> <span>pos</span>
</span></span><span><span>                                              <span>player-distance</span> <span>(</span><span>distance</span> <span>x</span> <span>x1</span> <span>y</span> <span>y1</span> <span>z</span> <span>z1</span><span>)</span>
</span></span><span><span>                                              <span>within-range?</span> <span>(</span><span>if </span><span>(</span><span>= </span><span>shape-type</span> <span>:cylinder</span><span>)</span>
</span></span><span><span>                                                              <span>(</span><span>within-cylinder?</span> <span>pos</span> <span>[</span><span>x</span> <span>y</span> <span>z</span><span>]</span> <span>radius</span> <span>height</span><span>)</span>
</span></span><span><span>                                                              <span>(</span><span>&lt;= </span><span>player-distance</span> <span>radius</span><span>))]</span>
</span></span><span><span>                                          <span>(</span><span>when </span><span>(</span><span>and </span><span>(</span><span>not= </span><span>player-id</span> <span>current-player-id</span><span>)</span>
</span></span><span><span>                                                     <span>(</span><span>current-player-ids</span> <span>player-id</span><span>)</span>
</span></span><span><span>                                                     <span>(</span><span>enemy?</span> <span>room-id</span> <span>player-id</span> <span>my-team</span><span>)</span>
</span></span><span><span>                                                     <span>(</span><span>&gt; </span><span>(</span><span>:health</span> <span>player-data</span><span>)</span> <span>0</span><span>)</span>
</span></span><span><span>                                                     <span>(</span><span>:focus?</span> <span>player-data</span><span>)</span>
</span></span><span><span>                                                     <span>within-range?</span><span>)</span>
</span></span><span><span>                                            <span>[</span><span>player-id</span> <span>player-distance</span><span>])))))</span>
</span></span><span><span>          <span>damage-and-positions</span> <span>(</span><span>for </span><span>[[</span><span>player-id</span> <span>distance</span><span>]</span> <span>players-within-range</span>
</span></span><span><span>                                     <span>:let</span> <span>[</span><span>damage</span> <span>(</span><span>generate-damage</span> <span>{</span><span>:distance</span> <span>distance</span>
</span></span><span><span>                                                                    <span>:max-damage</span> <span>max-damage</span>
</span></span><span><span>                                                                    <span>:area-of-affect-diameter</span> <span>diameter</span>
</span></span><span><span>                                                                    <span>:shape-type</span> <span>shape-type</span><span>})</span>
</span></span><span><span>                                           <span>damage</span> <span>(</span><span>get-damage-for-player</span> <span>damage</span> <span>current-player-id</span> <span>player-id</span><span>)]</span>
</span></span><span><span>                                     <span>:when</span> <span>(</span><span>&gt; </span><span>damage</span> <span>0</span><span>)]</span>
</span></span><span><span>                                 <span>(</span><span>let </span><span>[</span><span>world</span> <span>(</span><span>swap!</span> <span>world</span> <span>(</span><span>fn </span><span>[</span><span>world</span><span>]</span>
</span></span><span><span>                                                            <span>(</span><span>let </span><span>[</span><span>health</span> <span>(</span><span>max </span><span>0</span> <span>(</span><span>- </span><span>(</span><span>get-in</span> <span>world</span> <span>[</span><span>room-id</span> <span>player-id</span> <span>:health</span><span>])</span> <span>damage</span><span>))</span>
</span></span><span><span>                                                                  <span>died?</span> <span>(</span><span>= </span><span>0</span> <span>health</span><span>)</span>
</span></span><span><span>                                                                  <span>world</span> <span>(</span><span>assoc-in</span> <span>world</span> <span>[</span><span>room-id</span> <span>player-id</span> <span>:health</span><span>]</span> <span>health</span><span>)]</span>
</span></span><span><span>                                                              <span>(</span><span>if </span><span>died?</span>
</span></span><span><span>                                                                <span>(</span><span>assoc-in</span> <span>world</span> <span>[</span><span>room-id</span> <span>player-id</span> <span>:st</span><span>]</span> <span>&#34;die&#34;</span><span>)</span>
</span></span><span><span>                                                                <span>world</span><span>))))</span>
</span></span><span><span>                                       <span>died?</span> <span>(</span><span>= </span><span>0</span> <span>(</span><span>get-in</span> <span>world</span> <span>[</span><span>room-id</span> <span>player-id</span> <span>:health</span><span>]))]</span>
</span></span><span><span>                                   <span>(</span><span>when </span><span>died?</span>
</span></span><span><span>                                     <span>(</span><span>update-stats-after-death</span> <span>current-player-id</span> <span>player-id</span><span>))</span>
</span></span><span><span>                                   <span>(</span><span>send!</span> <span>player-id</span> <span>damage-pro-id</span>
</span></span><span><span>                                          <span>(</span><span>merge </span><span>{</span><span>:player-id</span> <span>current-player-id</span>
</span></span><span><span>                                                  <span>:damage</span> <span>damage</span>
</span></span><span><span>                                                  <span>:died?</span> <span>died?</span><span>}</span>
</span></span><span><span>                                                 <span>damage-params</span><span>))</span>
</span></span><span><span>                                   <span>(</span><span>update-last-damage-time</span> <span>player-id</span><span>)</span>
</span></span><span><span>                                   <span>(</span><span>add-damage-effect</span> <span>player-id</span> <span>(</span><span>if </span><span>(</span><span>= </span><span>damage-pro-id</span> <span>:got-ice-tornado-hit</span><span>)</span>
</span></span><span><span>                                                                  <span>:ice</span>
</span></span><span><span>                                                                  <span>:fire</span><span>))</span>
</span></span><span><span>                                   <span>[</span><span>player-id</span> <span>damage</span> <span>died?</span><span>]))]</span>
</span></span><span><span>      <span>(</span><span>when </span><span>damage-over-time</span>
</span></span><span><span>        <span>(</span><span>register-enemies-for-damage-over-time</span> <span>(</span><span>now</span><span>)</span>
</span></span><span><span>                                               <span>current-player-id</span>
</span></span><span><span>                                               <span>room-id</span>
</span></span><span><span>                                               <span>damage-over-time</span>
</span></span><span><span>                                               <span>(</span><span>map first </span><span>players-within-range</span><span>)))</span>
</span></span><span><span>      <span>{</span><span>:damage-and-positions</span> <span>damage-and-positions</span><span>})))</span>
</span></span></code></pre></div><p>The process begins by filtering players to identify those in the same room, excluding teammates, and checking if they
are within the spell’s radius or cylindrical area. Once the affected players are identified, the damage is calculated,
decreasing with distance from the spell’s origin while ensuring it is positive and does not exceed a player’s current
health. Finally, the game state is updated by deducting the damage from each player’s health, marking players as “dead”
if their health reaches zero, notifying affected players of the damage, and updating the attacker’s stats accordingly.</p><p>The backend handles real-time complexity by continuously updating multiple players and ensuring synchronization across
all devices. Events such as spellcasting and deaths are processed asynchronously through queues to maintain performance.
Developing custom networking code from scratch was both challenging and educational, offering valuable insights into the
trade-offs between control and complexity.</p><h3 id="the-journey">The Journey</h3><p>At the beginning of my game development journey, everything felt fantastic. I was quickly iterating through features,
mechanics, and UI development, making substantial progress in short bursts. However, as the project grew, it became
increasingly challenging to manage. The difficulty wasn’t directly tied to Clojure’s nature—there were many other
contributing factors.</p><p>Game development is fundamentally an art of state management. States are everywhere, and managing numerous unrelated
systems in harmony is a challenging task. While Clojure’s immutability by default offers many advantages, it also
introduces complexity. To handle the intricate state management required for game development, I had to create my own
abstractions. Writing a custom DSL (domain-specific language) became a necessity, but it wasn’t easy.</p><p>Adding to the challenge was the lack of a strong Clojure game development community. While Clojure excels in domains
like SaaS products and finance, its adoption in game development is virtually nonexistent. The absence of shared tools,
libraries, and best practices in this space made the journey even more isolating.</p><p>I couldn’t help but feel envious of the tooling ecosystems surrounding major game engines like Unity and Unreal Engine.
While Babylon.js is a great library, it lacks the robust plugin ecosystems, frameworks, and tools that mainstream
engines offer. Developing with Babylon.js often meant building tools from scratch. While this taught me a lot about
graphics programming, it came at the cost of time—a critical resource in modern game development.</p><p>Good tooling is a cornerstone of game development today. The lack of it left me feeling perpetually one step behind.</p><p>Developing 3D games for the web comes with inherent limitations. While WebGL has improved significantly, and WebGPU is
on the horizon, web-based games are still far behind native games in terms of performance and graphical fidelity. These
limitations force developers to make compromises.</p><p>Resource constraints on the web are another hurdle. Users expect quick load times and minimal downloads. Asking players
to wait for a 500MB download before they can play is unrealistic. This restricts web games to being small, free, and
often simplistic. The result? Web games rarely rival the scale or polish of PC or console games.</p><p>Financially, web game development doesn’t make much sense. Monetization options are limited, with ads being the primary
choice. But ads disrupt immersion and often force you to design your game around them just to earn a modest income.</p><p>The web game market is tiny compared to PC and console markets. While there are a few success stories like Agar.io and
Wordle. Only a couple of major web game publishers, like <em>CrazyGames</em> and <em>Poki</em>, exist. Rejection from these platforms
can make it nearly impossible to reach a large audience. To sustain yourself financially, you’d need to create a high
volume of games in a short period, which is neither practical nor creatively satisfying.</p><p>The one advantage web games have is ease of distribution. Sharing a link is all it takes for anyone to jump in and start
playing. But this strength alone doesn’t compensate for the many weaknesses.</p><p>Making a game is hard; making a successful game is even harder. Creating a good game is like cooking a great meal—you
can do wonders with a handful of ingredients or fail miserably with a dozen. There’s no single formula for success.
Everything needs to align: timing, optimization, art, sound, trends, and theme.</p><p>A few years ago, the battle royale trend exploded, leading to a flood of games trying to capitalize on the craze. Even
great games like Spellbreak couldn’t sustain themselves. But following trends isn’t inherently bad; it’s about
execution. If done well, it can be a smart business move.</p><h3 id="final-thoughts">Final Thoughts</h3><p>Game development is a deeply rewarding yet demanding journey. Whether you’re building games with unconventional tools
like Clojure or navigating the limitations of web platforms, the challenges are immense. I’ve learned
several key lessons.</p><p>First, web games are fantastic for prototyping thanks to their ease of distribution, but resource
constraints make them unsuitable for larger projects.</p><p>Second, Clojure’s REPL and functional paradigm enabled rapid
iteration, but its niche nature and lack of game development resources added unnecessary difficulty.</p><p>Lastly, tooling is
crucial—while building custom tools taught me a lot, the absence of robust, ready-made tools significantly slowed
progress. Moving forward, transitioning to a mainstream engine like Unity or Unreal could streamline development and
allow me to focus more on the creative aspects of game design.</p><p>Ultimately, the act of creating games—bringing ideas to
life—remains an unparalleled experience, with each challenge offering invaluable lessons.</p><p>It’s not just about the end result but the lessons learned along the way.</p></div></article></div></div>
  </body>
</html>
