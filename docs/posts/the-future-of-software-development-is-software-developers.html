<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codemanship.wordpress.com/2025/11/25/the-future-of-software-development-is-software-developers/">Original</a>
    <h1>The future of software development is software developers</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>I’ve been a computer programmer all-told for 43 years. That’s more than half the entire history of electronic programmable computers. </p>



<p>In that time, I’ve seen a lot of things change. But I’ve also seen some things stay pretty much exactly the same.</p>



<p>I’ve lived through several cycles of technology that, at the time, was hailed as the “end of computer programmers”. </p>



<p>WYSIWYG, drag-and-drop editors like Visual Basic and Delphi were going to end the need for programmers. </p>



<figure><a href="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png"><img data-attachment-id="2936" data-permalink="https://codemanship.wordpress.com/2025/11/25/the-future-of-software-development-is-software-developers/image-42/" data-orig-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png" data-orig-size="800,600" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png?w=300" data-large-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png?w=800" width="800" height="600" src="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png?w=800" alt="" srcset="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png 800w, https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png?w=150 150w, https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png?w=300 300w, https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-4.png?w=768 768w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a></figure>



<p>Wizards and macros in Microsoft Office were going to end the need for programmers.</p>



<p>Executable UML was going to end the need for programmers.</p>



<p>No-Code and Low-Code platforms were going to end the need for programmers.</p>



<p>And now, Large Language Models are, I read on a daily basis, going to end the need for programmers.</p>



<p>These cycles are nothing new. In the 1970s and 1980s, 4GLs and 5GLs were touted as the end of programmers.</p>



<p>And before them, 3GLs like Fortran and COBOL.</p>



<p>And before them, compilers like A-0 were going to end the need for programmers who instructed computers in binary by literally punching holes in cards.</p>



<figure><a href="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png"><img data-attachment-id="2938" data-permalink="https://codemanship.wordpress.com/2025/11/25/the-future-of-software-development-is-software-developers/image-43/" data-orig-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png" data-orig-size="691,460" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png?w=300" data-large-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png?w=691" width="691" height="460" src="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png?w=691" alt="" srcset="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png 691w, https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png?w=150 150w, https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-5.png?w=300 300w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a></figure>



<p>But it goes back even further, if we consider the earliest (classified) beginning of electronic programmable computers. The first of them, COLOSSUS, was programmed by physically rewiring it.</p>



<figure><a href="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png"><img data-attachment-id="2939" data-permalink="https://codemanship.wordpress.com/2025/11/25/the-future-of-software-development-is-software-developers/image-44/" data-orig-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png" data-orig-size="275,183" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png?w=275" data-large-file="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png?w=275" loading="lazy" width="275" height="183" src="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png?w=275" alt="" srcset="https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png 275w, https://codemanship.wordpress.com/wp-content/uploads/2025/11/image-6.png?w=150 150w" sizes="(max-width: 275px) 85vw, 275px"/></a></figure>



<p>Perhaps the engineers who worked on that machine sneered at the people working on the first stored-program computers for not being “<em>real </em>programmers”.</p>



<p>In every cycle, the predictions have turned out to be very, very wrong. The end result hasn’t been fewer programmers, but <em>more </em>programs and <em>more </em>programmers. It’s a $1.5 trillion-a-year example of <a href="https://en.wikipedia.org/wiki/Jevons_paradox">Jevons Paradox</a>.</p>



<p>And here we are again, in another cycle. </p>



<p>“But this time it’s different, Jason!”</p>



<p>Yes, it certainly is. Different in scale to previous cycles. I don’t recall seeing the claims about Visual Basic or Executable UML on the covers of national newspapers. I don’t recall seeing entire economies betting on 4GLs.</p>



<p>And there’s another important distinction: in previous cycles, the technology <em>worked</em> <em>reliably</em>. We really could produce working software faster with VB or with Microsoft Access. This is proving not to be the case with LLMs, which – for the majority of teams – actually slow them down while making the software less reliable and less maintainable. It’s a kind of LOSE-LOSE in most cases. (Unless those teams have addressed the <a href="https://codemanship.wordpress.com/2025/10/30/the-ai-ready-software-developer-index/">real bottlenecks in their development process</a>.)</p>



<p>But all of this is academic. Even if the technology genuinely made a positive difference for more teams, it still wouldn’t mean that we don’t need programmers anymore.</p>



<p>The hard part of computer programming isn’t expressing what we want the machine to do in code. The hard part is turning human thinking – with all its wooliness and ambiguity and contradictions – into <em>computational thinking</em> that is logically precise and unambiguous, and that can then be expressed formally in the syntax of a programming language.</p>



<p>That was the hard part when programmers were punching holes in cards. It was the hard part when they were typing COBOL code. It was the hard part when they were bringing Visual Basic GUIs to life (presumably to track the killer’s IP address). And it’s the hard part when they’re prompting language models to predict plausible-looking Python.</p>



<p>The hard part has always been – and likely will continue to be for many years to come – knowing <em>exactly </em>what to ask for.</p>



<p>Edgar Dijkstra called it <a href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD667.html">nearly 50 years ago</a>: we will never be programming in English, or French, or Spanish. Natural languages have not evolved to be precise enough and unambiguous enough. Semantic ambiguity and language entropy will always defeat this ambition.</p>



<p>And while pretty much anybody can learn to think that way, not everybody’s going to enjoy it, and not everybody’s going to be good at it. The demand for people who do and people who are will always outstrip supply.</p>



<p><em>Especially </em>if businesses stop hiring and training them for a few years, like they recently have. But these boom-and-bust cycles have also been a regular feature during my career. This one just happens to coincide with a technology hype cycle that presents a convenient excuse.</p>



<p>There’s no credible evidence that “AI” is replacing software developers in significant numbers. A combination of over-hiring during the pandemic, rises in borrowing costs, and a data centre gold rush that’s diverting massive funds away from headcount, are doing the heavy lifting here.</p>



<p>And there’s no reason to believe that “AI” is going to evolve to the point where it can do what human programmers have to do – understand, reason and learn – anytime soon. AGI seem as far away as it’s always been, and the hard part of computer programming really does require general intelligence.</p>



<p>On top of all that, “AI” coding assistants are really nothing like the compilers and code generators of previous cycles. The exact same prompt is very unlikely to produce the exact same computer program. And the code that gets generated is pretty much guaranteed to have issues that a real programmer will need to be able to recognise and address.</p>



<p>When I write code, I’m executing it in my head. My internal model of a program isn’t just syntactic, like an LLM’s is. I’m not just matching patterns and predicting tokens to produce statistically plausible code. I actually <em>understand </em>the code.</p>



<p>Even the C-suite has noticed the correlation of major outages and incidents proceeding grand claims about how much of that company’s code is “AI”-generated.</p>



<p>The folly of many people now claiming that “prompts are the new source code”, and even that entire working systems can be regenerated from the original model inputs, will be revealed to be the nonsense that it is. The problem with getting into a debate with reality is that reality always wins. (And doesn’t even realise it’s in a debate.)</p>



<p>So, no, “AI” isn’t the end of programmers. I’m not even sure, 1-3 years from now, that this current mania won’t have just burned itself out, as the bean counters tot up the final scores. And they <em>always </em>win.</p>



<p>To folks who say this technology isn’t going anywhere, I would remind them of just how expensive these models are to build and what massive losses they’re incurring. Yes, you <em>could </em>carry on using your local instance of  some small model distilled from a hyper-scale model trained today. But as the years roll by, you may find not being able to move on from the programming language and library versions it was trained on a tad constraining.</p>



<p>For this reason, I’m skeptical that hyper-scale LLMs have a viable long-term future. They are the Apollo Moon missions of “AI”. In the end, quite probably just not worth it. Maybe we’ll get to visit them in the museums their data centres might become?</p>



<p>The foreseeable future of software development is one where perhaps “AI” – in a much more modest form (e.g., a Java coding assistant built atop a basic language model) – is used to generate prototypes, and maybe for inline completion on production code and those sorts of minor things.</p>



<p>But, when it matters, there <em>will </em>be a software developer at the wheel. And, if Jevons is to be believed, probably even <em>more </em>of us.</p>



<p>Employers, if I were you, I might start hiring now to beat the stampede when everyone wakes up from this fever dream.</p>



<p>And then maybe <a href="https://codemanship.co.uk/">drop me a line</a> if you’re interested in skilling them up in the technical practices that can dramatically shrink delivery lead times while improving reliability and reducing the cost of change, with or without “AI”. That’s a WIN-WIN-WIN.</p>

<div>
	<p><img referrerpolicy="no-referrer" alt="Unknown&#39;s avatar" src="https://1.gravatar.com/avatar/aadcfbd208e65a0829f5d259192a5886454439a708e425500c59c535e28ae081?s=42&amp;d=identicon&amp;r=G" srcset="https://1.gravatar.com/avatar/aadcfbd208e65a0829f5d259192a5886454439a708e425500c59c535e28ae081?s=42&amp;d=identicon&amp;r=G 1x, https://1.gravatar.com/avatar/aadcfbd208e65a0829f5d259192a5886454439a708e425500c59c535e28ae081?s=63&amp;d=identicon&amp;r=G 1.5x, https://1.gravatar.com/avatar/aadcfbd208e65a0829f5d259192a5886454439a708e425500c59c535e28ae081?s=84&amp;d=identicon&amp;r=G 2x, https://1.gravatar.com/avatar/aadcfbd208e65a0829f5d259192a5886454439a708e425500c59c535e28ae081?s=126&amp;d=identicon&amp;r=G 3x, https://1.gravatar.com/avatar/aadcfbd208e65a0829f5d259192a5886454439a708e425500c59c535e28ae081?s=168&amp;d=identicon&amp;r=G 4x" height="42" width="42" loading="lazy" decoding="async"/>	</p><!-- .author-avatar -->

	<!-- .author-description -->
</div><!-- .author-info -->
	</div></div>
  </body>
</html>
