<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiki.xxiivv.com/site/modal">Original</a>
    <h1>Modal is a matrioshka language based on pattern-matching to rewrite trees</h1>
    
    <div id="readability-page-1" class="page"><div><figure><img alt="Modal In A Postcard" src="https://wiki.xxiivv.com/media/diary/843.jpg"/><figcaption>Modal In A Postcard</figcaption></figure>
<h2>Modal is a matrioshka language based on pattern-matching to rewrite trees.</h2>

<img src="https://wiki.xxiivv.com/media/refs/soulages.png" title="Pierre Soulages | Lithographie n°30 (1972)"/>

<p>Modal programs are represented as a series of substitution rules, applied to a given tree which gets
continually modified until no rules match any given part of the tree. The principale elements of modal are:</p>

<ul>
	<li><a href="#rules">Rules</a>: &lt;&gt; left right</li>
	<li><a href="#registers">Registers</a>: ?x, ?y, ?z</li>
	<li><a href="#trees">Trees</a>: word, (a tuple), a (cons (list))</li>
</ul>

<hr/>

<p>The documentation below displays the examples as a series of rules, followed
by the rewriting steps in the following format:</p>

<pre>&lt;&gt; A rule

.. The input program
04 The result of applying rule #4
-1 The result of applying a lambda</pre>

<h3 id="rules">Rules</h3>

<p>To define a new rule, start with <kbd>&lt;&gt;</kbd>, followed by a
<i>left</i> and a <i>right</i> statement, which is either a word, or a <a href="#tree">tree</a>. The program evaluation starts at the first character of
the string and walks through to the end trying to match a transformation rule
from that location:</p>

<pre>&lt;&gt; hello (good bye)  <i>This is a rule</i>

.. hello world       <i>This is program data</i>
00 good bye world    <i>This is the result</i></pre>

<p>Homoiconicity is a property of some programming languages that treats code as
data, when the internal and external representation of a program is the same.
Modal is homoiconic, as any string is a potential program and new rules can be
composed directly during the evaluation. For instance, here is a rule to define
new rules with an <a href="https://wiki.xxiivv.com/site/notation.html">infix syntax</a>:</p>

<pre>&lt;&gt; ((?x -&gt; ?y)) (&lt;&gt; ?x ?y)
(a -&gt; apple)
(b -&gt; banana)
((apple banana) -&gt; (fruit-salad))

.. a b
01 apple b
02 apple banana
03 fruit-salad</pre>

<h3 id="registers">Registers</h3>

<p>Registers are single-character identifiers bound to an address in a pattern
used in rewriting:</p>

<pre>&lt;&gt; (copy ?a) (?a ?a)

.. copy cat
00 cat cat</pre>

<p>When a register is used in a pattern, and when we try
to match a given tree with a pattern, each register is bound to a
corresponding an address to the left of a rule, and referenced to the right:</p>

<pre>&lt;&gt; (swap ?x ?y) (?y ?x)

.. (swap fox rat)
00 (rat fox)</pre>

<p>When a register appears more than once in a rule, each instance is bound to
the first address:</p>

<pre>&lt;&gt; (?x ?x ?x) triplet

.. (fox fox fox)
00 (triplet)
</pre>

<p>Differently named registers can still match on the same pattern:</p>

<pre>&lt;&gt; (?x ?y) double

.. (fox fox)
00 (double)
</pre>

<h3 id="trees">Trees</h3>

<p>Trees can be found in rules and program data, they include words, registers
and nested trees. Rules can match specific trees and rewrite their content in a
new sequence.</p>

<pre>&lt;&gt; (rotate ?x (?y) ?z) (?y (?z) ?x)

.. rotate foo (bar) baz
00 bar (baz) foo
</pre>

<p>An efficient way to represent an array is to store information in
nested lists, it allows for rules to target specific segments of the list,
similarly to Lisp&#39;s car and cdr primitives. To print each element of such a
structure, we can use the following recursive rules:</p>

<pre>&lt;&gt; (putrec (?: ?x)) (putrec ?: ?x)
&lt;&gt; ((putrec (?:))) (?:)

.. (putrec (a (b (c (d (e))))))
00 (putrec (b (c (d (e)))))
00 (putrec (c (d (e))))
00 (putrec (d (e)))
00 (putrec (e))
01 

<b>&gt; abcde</b>
</pre>


<img src="https://wiki.xxiivv.com/media/refs/soulages2.png" title="Pierre Soulages | Lithographie n°19 (1968)"/>

<q><b>modal</b>(adj.): of, or relating to structure as opposed to substance.</q>

<h3>Special Registers</h3>

<p>Special registers are registers that do more than simply store a reference,
they allow implementations to choose which special behavior is needed by the
host platform, without impacting the core of the language:</p>

<table>
	<tbody><tr><th colspan="3">Substrings</th></tr>
	<tr><td>Explode token</td><td>?(?* ?*) abc</td><td>a (b (c ()))</td></tr>
	<tr><td>Explode tuple</td><td>?(?* ?*) (abc def ghi)</td><td>abc (def (ghi ()))</td></tr>
	<tr><td>Unpack</td><td>?(?. ?.) (abc def)</td><td>abc def</td></tr>
	<tr><td>Join</td><td>?(?^ ?^) (abc def ghi)</td><td>abcdefghi</td></tr>
	<tr><th colspan="3">IO</th></tr>
	<tr><td>Read</td><td>?~</td><td>Read from devices</td></tr>
	<tr><td>Send</td><td>?:</td><td>Send to devices</td></tr>
</tbody></table>



<p id="lambda">A <b>lambda</b> is created by using the <kbd>?(body)</kbd>
special register. Rules created that way exist only for the length of one
rewrite and must match what is found immediately after: </p>

<pre>.. ?((?x ?y) (?y ?x)) foo bar
-1 bar foo
</pre>

<p>Explode a token or tuple, into a nested list with the <kbd>?*</kbd> special
register, notice how the following program makes use the <a href="#types">List
type</a> to ensure a specific evaluation order:</p>

<pre>&lt;&gt; (reverse List () ?^) (?^)
&lt;&gt; (reverse (?*)) (reverse List (?*) ())
&lt;&gt; (reverse List (?x ?y) ?z) (reverse List ?y (?x ?z))

.. (reverse (modal))
01 (reverse List (m (o (d (a (l ()))))) ())
02 (reverse List (o (d (a (l ())))) (m ()))
02 (reverse List (d (a (l ()))) (o (m ())))
02 (reverse List (a (l ())) (d (o (m ()))))
02 (reverse List (l ()) (a (d (o (m ())))))
02 (reverse List () (l (a (d (o (m ()))))))
00 (ladom)
</pre>

<p>Sending a message to a device is done with the <kbd>?:</kbd> special
register, it sends a word or a tree to be handled by a device:</p>

<pre>&lt;&gt; (print ?:) (?:)

.. print (hello world\n)

<b>hello world</b>
</pre>

<p>Similarly, reading an incoming message from a device is done with the
<kbd>?~</kbd> special register:</p>

<pre>&lt;&gt; (?: print) (?:)
&lt;&gt; (READ ?~) ((You said: ?~ \n) print)

.. (READ stdin)

<b>You said: </b>
</pre>

<h3 id="types">Type Systems</h3>

<p>Understanding how to use types to guard rules for specific evaluation order is
important to become proficient with Modal. Creating a type system is merely a
matter of creating stricter rules expecting a specific grammar. Notice in the example below, how join-strings expects to match two String
typed words. Without typed inputs, the rule is not matched.</p>

<pre>&lt;&gt; (join-strings (String ?x) (String ?y)) (?x?y)

.. join-strings (String foo) (String bar)
00 foobar
</pre>

<h3>Logic</h3>

<p>Let us build a logic system, starting by comparing two registers:</p>

<pre>&lt;&gt; (eq ?x ?x) (#t)
&lt;&gt; (eq ?x ?y) (#f)

.. (eq fox bat)
01 (#f)
</pre>

<p>We can implement the truth tables by defining each case:</p>

<pre>&lt;&gt; (and #t #t) #t &lt;&gt; (or #t #t) #t 
&lt;&gt; (and #t #f) #f &lt;&gt; (or #t #f) #t
&lt;&gt; (and #f #t) #f &lt;&gt; (or #f #t) #t 
&lt;&gt; (and #f #f) #f &lt;&gt; (or #f #f) #f
&lt;&gt; (not #t) #f    &lt;&gt; (not #f) #t

.. (or #f #t)
08 (#t)
</pre>

<p>Building on the comparison rule above, we can write conditionals with a ternary statement: </p>
<pre>&lt;&gt; (ife #t ?t ?f) (?t)
&lt;&gt; (ife #f ?t ?f) (?f)
&lt;&gt; (print ?:) (?:)

.. ife #f (print True!) (print False!)
13 (print False!)
14 ()
</pre>

<h3 id="arithmetic">Arithmetic</h3>

<p>The language does not accommodate for any specific numerical system, but allows for the notion of numbers to be implemented with Peano Numerals:</p>

<pre>&lt;&gt; (add (s ?x) (s ?y)) (s (add ?x (s ?y)))
&lt;&gt; (add (s ?x) (0)) (s ?x)
&lt;&gt; (add (0) (s ?y)) (s ?y)
&lt;&gt; (add (0) (0)) (0)
&lt;&gt; (sub (s ?x) (s ?y)) (sub ?x ?y)
&lt;&gt; (sub (s ?x) (0)) (s ?x)
&lt;&gt; (sub (0) (s ?y)) (s ?y)
&lt;&gt; (sub (0) (0)) (0)
&lt;&gt; (mul (s ?x) (s ?y)) (add (s ?x) (mul (s ?x) (sub (s ?y) (s (0)))))
&lt;&gt; (mul (s ?x) (s (0))) (s ?x)
&lt;&gt; (mul (s (0)) (s ?y)) (s ?y)
&lt;&gt; (mul (s ?x) (0)) (0)
&lt;&gt; (mul (0) (s ?x)) (0)
</pre>

<p>To convert from prefix notation to infix: </p>
<pre>&lt;&gt; (?x + ?y) (add ?x ?y)
&lt;&gt; (?x - ?y) (sub ?x ?y)
&lt;&gt; (?x * ?y) (mul ?x ?y)
</pre>

<p>Altogether, we have enough parts to implement factorial: </p>
<pre>&lt;&gt; (factorial (s (0))) ((s (0)))
&lt;&gt; (factorial (s ?x)) (((s ?x) * factorial ((s ?x) - (s (0)))))

factorial (s (s (s (s (s (0))))))
</pre>

<h3>Binary</h3>

<p>Prefix rules to increment a binary number:</p>

<pre>&lt;&gt; (inc (0 ?x)) ((1 ?x))
&lt;&gt; (inc (1 ?x)) ((0 inc ?x))
&lt;&gt; (inc ()) ((1 ()))

?(?-) (Count to 0x7f)

&lt;&gt; (&gt; increc (1 (1 (1 (1 ()))))) (done.)
&lt;&gt; (&gt; increc ?i) (&gt; (inc ?i wait) increc)
&lt;&gt; (&gt; (?i wait) increc) (&gt; increc ?i)

&gt; increc ()
</pre>

<h3>Mimics</h3>

<p>We can use rules to define entire languages, Modal enforces no specific notation, for example, we could easily make a <a href="https://wiki.xxiivv.com/site/logic.html">combinatory logic</a> playground:</p>

<pre>&lt;&gt; (M ?x) (?x ?x)
&lt;&gt; (KI ?x ?y) (?y)
&lt;&gt; (T ?x ?y) (?y ?y)
&lt;&gt; (W ?x ?y) (?x ?y ?y)
&lt;&gt; (K ?x ?y) (?x)
&lt;&gt; (C ?x ?y ?z) (?x ?z ?y)
&lt;&gt; (B ?x ?y ?z) (?x (?y ?z))
&lt;&gt; (I ?x) (?x)
&lt;&gt; (S ?x ?y ?z) (?x ?z (?y ?z))

.. C KI x y z
05 KI y x z
01 x z
</pre>


<p>Any choice made in regard to syntax is completely arbitrary. To demonstrate, the following code defines a <a href="https://wiki.xxiivv.com/site/concatenative.html">concatenative</a> syntax:</p>

<pre>&lt;&gt; (?x dup) (?x ?x)
&lt;&gt; (?x ?y swap) (?y ?x)
&lt;&gt; (?x pop) ()

.. (1 2 3) (4 5 6) swap pop dup
01 (4 5 6) (1 2 3) pop dup
02 (4 5 6) dup
00 (4 5 6) (4 5 6)
</pre>

<h3>sierpiński.modal</h3>

<p>To review everything documented above, here is a small program that prints the Sierpiński triangle fractal:</p>

<pre>?(?-) (Rules)

&lt;&gt; (* (. &gt; (. ?x))) (* (. (. &gt; ?x))) 
&lt;&gt; (. (. &gt; (* ?x))) (* (. (* &gt; ?x))) 

?(?-) (Physics)

&lt;&gt; (Tri &gt; (?x ?y)) (Tri (?x &gt; ?y))
&lt;&gt; (Tri (?x &gt; (?y ?z))) (Tri (?x (?y &gt; ?z)))
&lt;&gt; (?x (?y &gt; (?z ?n))) (. (?y (?z &gt; ?n)))
&lt;&gt; ((?x &gt; ())) (&lt; ())
&lt;&gt; (Tri &lt; (* ?^)) (?(?: ?:) (*?^ \n))
&lt;&gt; ((?x &lt; ?y)) (&lt; (?x ?y))

?(?-) (Print)

&lt;&gt; (Tri.join ?x ?:) (Tri &gt; ?x ?:)
&lt;&gt; (Tri.dup ?x ?^) (Tri.join ?x ?^)
&lt;&gt; (Tri &lt; ?x) (Tri.dup (. ?x) (?x \n))

?(?* (Tri &lt; (?*))) ...............*...............</pre>

<h3>Implementation</h3>

<p>The Modal runtime can be implemented in about 200 lines of <a href="https://wiki.xxiivv.com/site/ansi_c.html">ANSI C</a>.</p>



<ul>
	<li><a href="https://git.sr.ht/~rabbits/modal" target="_blank">view sources</a>, ANSI C.</li>
	<li><a href="https://discord.gg/9e7vaVTSVs" target="_blank">discord channel</a>, in the concatenative server.</li>
	<li>This language is an original creation of <a href="https://wryl.tech/" target="_blank">wryl</a> from 2018, who has courteously spent countless hours to help me progress with the language, much of the code above is derived from their research and merely made available here as to give this fantastic system a home on the internet.</li>
</ul>

<ul></ul></div></div>
  </body>
</html>
