<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://madrona.ca/e/pdp11hack/index.html">Original</a>
    <h1>PDP-11/Hack (2014)</h1>
    
    <div id="readability-page-1" class="page">



<!-- Content ------------------------------>

<p>
<a href="http://madrona.ca/e/pdp11hack/large/DCJ11.jpg" target="large"><img src="http://madrona.ca/e/pdp11hack/DCJ11.jpg" width="400" height="300"/></a>

</p><p>
Some time ago a friend handed me a bare J11 chip.
It had been pulled from some system on the way to scrap, presumably just because it was a pretty object.
I don&#39;t know how many hands it had been through before arriving in mine but a few pins were bent and it had not been static-protected.
I wondered whether it was now anything more than a pretty object.
</p><p>

The J11 (more properly the DCJ11, aka &#34;Jaws&#34;) was one of the last gasps of the PDP-11 - a CMOS microprocessor implementation of the PDP-11/70.
It&#39;s two chips actually, mounted on a single 60-pin, over-wide, DIP ceramic carrier.
The J11 was developed in the early 1980s and introduced in the PDP-11/73 in 1983/84.
Although this was at the end of the heyday of the PDP-11, the J11 saw a relatively long production life, being produced till sometime into the 1990s.
The unit here has a date code from 1987.

</p><p>
I had a recollection of hearing that these microprocessors had a monitor program built into the microcode.
Documentation confirmed this - it&#39;s called ODT (Octal Debugging Technique), a simple ASCII-based console monitor.
In theory, if one could appropriately wire up a UART to the J11 one should be able to talk to the ODT via a serial terminal.
The question was what would be the minimal hardware setup that would accomplish this.

</p><p>
<table><tbody><tr>

<td>
<b>Contents (this page):</b></td>

<td>
<b>References / External Links:</b></td>

</tr></tbody></table>

<br clear="all"/>


</p><hr/>
<a name="hack"></a>

<h3>The Hack</h3>
<p>
The PDP-11/HACK is a minimal system built around the J11, enough to talk to the ODT, check the chip for basic operation, and enter and execute simple programs.
Implemented with just 12 or 13 ICs, it has 16 KB of memory and a single I/O device: the console serial port.
I&#39;ll hazard a guess this is the lowest-IC-count &#39;real&#39; PDP-11 system - that is, leaving aside emulations on modern system-on-a-chip hardware or FPGA implementations.
File it under silly-chip-tricks.

</p><p>
Thankfully, a datasheet for the J11 is available online at bitsavers.org.
In short: a little reading of the J11 User&#39;s Guide, a little designing, a little breadboarding, and voil√†: a functioning PDP-11.
The schematic is linked above.


</p><h4>The Console Device</h4>
<p>
The ODT expects to see a 4-register device at addresses 17777560-17777566 in the I/O space.
Normally this facility was provided by a DEC &#34;DLART-compatible&#34; device, DEC made the DC319-AA UART for the task.
I didn&#39;t have a DC319 and I expect they&#39;re somewhat difficult to come by.
Instead, I pulled a 6402 UART out of the parts bin, primarily because the 6402 is hardware configurable, so no boot-time programmatic access is required to load registers to configure it.
The 6402 is also single-supply, making it mildly preferable over other hardware-configured UARTs such as the 1402 or AY-5-1013, although they too should do the job.
</p><p>
Just a few TTL gates were needed to make the 6402 appear on the bus as the 4 device registers with enough functionality to make the ODT happy.
The small PC board seen at the top in the breadboard photos is a baud-rate generator from some unknown piece of equipment, used here for the UART serial clock.
Something simpler could be done with just one IC, such as a CMOS 4060.
A <nobr>MAX-232</nobr> provides the <nobr>RS-232</nobr> interface.

</p><h4>Bus Protocol</h4>
<p>
A couple more TTL chips were needed for an address latch for the multiplexed data/address lines and some bus protocol.
The BS0/1 lines from the J11 do some pre-decoding to distinguish memory and I/O bus operations.
This considerably simplifies the external address decoding required.

</p><h4>Working..</h4>
<p>
The first version had no memory, but it talked to the ODT and was enough to show the chip was working at some level.
Next, two 6264 8K*8 static RAM chips were added to provide 8KW/16KB of memory.
Two simple test programs were manually assembled, entered via the ODT and successfully executed (once I had reacquainted myself with the PDP-11 instruction set to the point of recalling that branch offsets are relative to the following instruction, not the branch instruction).

</p><h4>Clock Rates</h4>
<p>
There is a little confusion around the maximum clock rate for the J11.
The 1983 Preliminary User&#39;s Guide specifies a max clock rate of 15 MHz.
Bob Supnik&#39;s article (link above) suggests they were achieving only around 4.5 MHz in that time frame.
Other sources indicate that later units went to 18 MHz.
The 11/HACK ran with crystals of 2, 4, 8 and 11 MHz, but did not function with a 14 MHz crystal though the on-chip oscillator was still going.
The limit is likely more a consequence of the rest of the system rather than the J11.

<br clear="all"/>


</p><hr/>
<a name="use"></a>
<h3>Operating Notes</h3>

The J11 provides a couple of ways to get into ODT, but the default power-up/init/reset semantics do not take one into ODT.
With the minimal 11/HACK hardware design, properly, at power-up one should press the RESET switch, press the HALT switch, release RESET, then release HALT.
RESET sets the J11 to a defined and suitable state, HALT takes one into ODT.
Overlapping RESET and HALT ensures the J11 doesn&#39;t go off to try to execute boot code when RESET is released.
One should now be in ODT: ODT should display the PC and the &#34;@&#34; prompt.
When executing a program, pressing HALT will take one back to ODT, or a HALT instruction will return one to ODT.

<p>
Note that while ODT will run while HALT is asserted, HALT must be deasserted prior to executing a program.

</p><p>
Before running a program, ensure the PSW is appropriate via the RS command.
000340 is typically good.


</p><hr/>
<a name="test"></a>
<h3>Test Programs</h3>

<p>
All numbers in the following are expressed in octal.

</p><div><pre>;**************************************************************************
;***	PDP-11 Test #1 - Increment R5 and return to ODT

000	005205			INC R5
002	000000			HALT


;**************************************************************************
;***	PDP-11 Test #2 - Repeatedly output a character to the console port

010	032737		loop	BIT #200,@#177564	; check bit-7/ready of xmt status reg
012	000200
014	177564
016	001774			BEQ loop		; busy-loop while bit-7 is 0

020	012737			MOV #102,@#177566	; send ASCII B to xmt data reg
022	000102
024	177566
026	000770			BR loop			; go send character again
</pre></div>

</div>
  </body>
</html>
