<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vaibhavsagar.com/blog/2024/02/14/minimal-perfect-hashing/">Original</a>
    <h1>The Real Hash Was the Friends We Made along the Way</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            

            <p>
    Posted on 14 February 2024
    
</p>


<p>When I lived in Singapore, I attended a fascinating talk at FOSSASIA 2018 about
<a href="https://www.youtube.com/watch?v=8Zu-EVjN24s">Indeed’s fast and compact immutable key-value
stores</a> that went almost
completely over my head. In fact, if you listen carefully during the Q&amp;A
session at the end, you can hear me ask some not-very-good questions in an
ill-advised and ultimately futile attempt to relate to the speaker.</p>
<p>This was my first encounter with the concept of minimal perfect hashing.
Unfortunately for me, I found most of the existing literature so impenetrable
that I gave up on learning more. <a href="https://cmph.sourceforge.net/papers/esa09.pdf">Hash, displace, and
compress</a>? <a href="https://cmph.sourceforge.net/papers/wads07.pdf">Hypergraph
peeling</a>?
<a href="https://arxiv.org/abs/1910.06416">RecSplit</a>? Eventually I found a suitable
entry point: <a href="https://arxiv.org/abs/1702.03154">Fast and scalable minimal perfect hashing for massive key
sets</a>.</p>
<h2 id="minimal-perfect-hashing">Minimal perfect hashing</h2>
<p>Let’s start with what minimal perfect hashing is:</p>
<h3 id="hashing">Hashing</h3>
<p>One definition of hashing is a process that converts some key to a value of
some fixed size (e.g. an integer). We can think of this in terms of a hash
<em>function</em> that takes some input and produces an integer as output.</p>
<h3 id="perfect">Perfect</h3>
<p>In practice, sometimes these hash functions produce the same output for
different inputs, known as a <em>hash collision</em>. This is pretty annoying and
causes lots of problems, and it would be nice if we could guarantee that
distinct inputs always hash to different values, i.e. that the function is
<a href="https://en.wikipedia.org/wiki/Injective_function"><em>injective</em></a>. Hash functions
with this useful property are known as <em>perfect hash functions</em>. This requires
all possible inputs to be known in advance.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/5/5c/Gen_injection_not_surjection.svg" alt="Injective function"/>
<figcaption aria-hidden="true">Injective function</figcaption>
</figure>
<h3 id="minimal-perfect-hashing-1"><em>Minimal</em> perfect hashing</h3>
<p>Bringing it all together, a <em>minimal perfect hash</em> function is one that has no
gaps in its outputs, i.e. it
<a href="https://en.wikipedia.org/wiki/Bijection">bijectively</a> maps <span><em>n</em></span> different
inputs to <span><em>n</em></span> consecutive integers, e.g. <span>[0..<em>n</em>)</span> or <span>[1..<em>n</em>]</span>. It’s important
to note that <em>minimal</em> does not imply anything about the space or time
complexity of these functions, e.g. it would be totally valid to have an
internal hashtable that maps each input to a distinct integer without gaps and
then use that to implement our hash function. In practice, however, we want
these functions to be as efficient as possible to construct, store, and use,
and this is an active area of research.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/a/a5/Bijection.svg" alt="Bijective function"/>
<figcaption aria-hidden="true">Bijective function</figcaption>
</figure>
<p>You’d probably want to use a minimal perfect hash when</p>
<ul>
<li>all possible keys are known in advance</li>
<li>the set of keys doesn’t change</li>
<li>space is at a premium</li>
</ul>
<p>One attractive property of a minimal perfect hash function is that you can use
it to create a minimal perfect hash <em>table</em> by associating it with an array
where each value’s index is the hash of the corresponding key.</p>
<h2 id="how-it-works">How it works</h2>
<p>The approach used in the paper is based on cascading collisionless bitarrays,
as illustrated below. I have a more detailed example later so if you aren’t
able to follow this one that’s totally okay! It exists to give you a quick
taste of the algorithm.</p>
<figure>
<img src="https://vaibhavsagar.com/images/cascading-collisionless-arrays.svg" alt="Cascading Collisionless Bitarrays"/>
<figcaption aria-hidden="true"><em>Cascading Collisionless Bitarrays</em></figcaption>
</figure>
<p>In the example, keys <span><em>k</em><sub>1</sub></span> to <span><em>k</em><sub>6</sub></span> are hashed and positions where there are no
collisions are recorded. The keys that collide at each level are removed and
retried at the next level until all the keys are used. For the first bitarray
<span><em>A</em><sub>0</sub></span>, <span><em>k</em><sub>3</sub></span> and <span><em>k</em><sub>6</sub></span> do not collide when using the hash function <span><em>h</em><sub>0</sub></span>. For
the next bitarray <span><em>A</em><sub>1</sub></span>, <span><em>k</em><sub>1</sub></span> and <span><em>k</em><sub>5</sub></span> do not collide when using <span><em>h</em><sub>1</sub></span>.
Finally for <span><em>A</em><sub>2</sub></span>, <span><em>k</em><sub>2</sub></span> and <span><em>k</em><sub>4</sub></span> do not collide using <span><em>h</em><sub>2</sub></span> and we have no
more keys left. To compute the hash for a key, in this example <span><em>k</em><sub>2</sub></span>, we find
the position where <span><em>A</em><sub><em>n</em></sub>[<em>h</em><sub><em>n</em></sub>(<em>k</em><sub>2</sub>)] ≡ 1</span> and count the number of <code>1</code>s at or
preceding this position, also known as the <em>rank</em>, which will always give us
a number <span>[1..<em>n</em>]</span>. For <span><em>k</em>2</span>, the hash is <span>5</span>.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>To implement this, we’ll need</p>
<ul>
<li>a family of hash functions</li>
<li>bitvectors supporting <a href="https://en.wikipedia.org/wiki/Succinct_data_structure#Succinct_indexable_dictionaries"><span><em>r</em><em>a</em><em>n</em><em>k</em></span> (and
<span><em>s</em><em>e</em><em>l</em><em>e</em><em>c</em><em>t</em></span>)</a>
operations</li>
</ul>
<p>For the hash functions, I used
<a href="https://hackage.haskell.org/package/hashable-1.4.3.0/docs/Data-Hashable.html#v:hashWithSalt"><code>hashWithSalt</code></a>
from the <a href="https://hackage.haskell.org/package/hashable"><code>hashable</code></a> package,
and for the bitvectors I used the
<a href="https://hackage.haskell.org/package/bv-little"><code>bv-little</code></a> package because
<a href="https://github.com/recursion-ninja/bv-little/issues/3">past Vaibhav asked for <code>rank</code> and <code>select</code>
support</a>.</p>
<h3 id="construction">Construction</h3>
<p>At a high level, this is what the construction algorithm looks like:</p>
<ol type="1">
<li>Repeat the following steps until the maximum level is reached or we have no more keys:
<ol type="1">
<li>Hash each key to a number <span><em>i</em> ∈ [0..<em>n</em>)</span></li>
<li>If <span><em>b</em><em>i</em><em>t</em><em>v</em><em>e</em><em>c</em><em>t</em><em>o</em><em>r</em>[<em>i</em>]</span> has not been set this iteration, set it to <span>1</span>, otherwise unset it</li>
<li>Remove all keys that have been set successfully</li>
</ol></li>
<li>If there are any leftover keys, store them separately</li>
</ol>
<h4 id="hashing-1">Hashing</h4>
<p>As I mentioned previously, I used <code>hashWithSalt</code>:</p>
<div><pre><code><span>value</span><span> </span><span>=</span><span> </span><span>hashWithSalt</span><span> </span><span>currentLevel</span><span> </span><span>key</span><span> </span><span>`</span><span>mod</span><span>`</span><span> </span><span>(</span><span>gamma</span><span> </span><span>*</span><span> </span><span>currentLength</span><span>)</span></code></pre></div>
<p>The role of <code>gamma</code> is to control the amount of “slack” in the bitvector, since
sometimes making it larger than strictly necessary can reduce the probability
of collisions. More on this later.</p>
<h4 id="populating-the-bitvector">Populating the bitvector</h4>
<p>The approach described in the paper involves using an auxiliary bitvector <span><em>C</em></span>
to keep track of collisions:</p>
<ol type="1">
<li>Initialise two bitvectors <span><em>B</em></span> and <span><em>C</em></span> with <span>0</span>s</li>
<li>When setting an index <span><em>i</em></span>:
<ol type="1">
<li>If <span><em>B</em>[<em>i</em>] ≡ 0</span> and <span><em>C</em>[<em>i</em>] ≡ 0</span> then set <span><em>B</em>[<em>i</em>] = 1</span></li>
<li>If <span><em>B</em>[<em>i</em>] ≡ 1</span> then set <span><em>B</em>[<em>i</em>] = 0</span> and <span><em>C</em>[<em>i</em>] = 1</span></li>
<li>If <span><em>B</em>[<em>i</em>] ≡ 0</span> and <span><em>C</em>[<em>i</em>] ≡ 1</span> then do nothing</li>
</ol></li>
</ol>
<h3 id="lookup">Lookup</h3>
<p>To actually use our hash function, we can do the following:</p>
<ol type="1">
<li>For each level:
<ol type="1">
<li>Hash the key and check if the corresponding index is set</li>
<li>If so, find the rank</li>
<li>If not, increment the level count and repeat</li>
</ol></li>
<li>Otherwise check the leftovers</li>
</ol>
<h2 id="example">Example</h2>
<p>Let’s look at a small example. The <a href="https://www.bonditocoogeewalk.com/">Bondi to Coogee
walk</a> here in Sydney passes through the
following beaches:</p>
<ul>
<li>Bondi</li>
<li>Tamarama</li>
<li>Bronte</li>
<li>Clovelly</li>
<li>Gordons Bay</li>
<li>Coogee</li>
</ul>
<p>and we can use these as keys for a minimal perfect hash function.</p>
<h3 id="construction-1">Construction</h3>
<p>The results of the first iteration are</p>
<details open="">
<summary>
Level 0
</summary>
<pre><code>┌─┐
│0│ &lt;- [&#34;Clovelly&#34;,&#34;Bronte&#34;]
├─┤
│1│ &lt;- [&#34;Gordons Bay&#34;]
├─┤
│0│
├─┤
│0│
├─┤
│0│ &lt;- [&#34;Coogee&#34;,&#34;Tamarama&#34;]
├─┤
│1│ &lt;- [&#34;Bondi&#34;]
└─┘</code></pre>
</details>
<p>So far, so good.</p>
<details open="">
<summary>
Level 1
</summary>
<pre><code>┌─┐
│0│
├─┤
│0│
├─┤
│0│
├─┤
│0│ &lt;- [&#34;Coogee&#34;,&#34;Clovelly&#34;,&#34;Bronte&#34;,&#34;Tamarama&#34;]
└─┘</code></pre>
</details>
<p>Hmm, that’s a little concerning.</p>
<details open="">
<summary>
Level 2
</summary>
<pre><code>┌─┐
│0│ &lt;- [&#34;Coogee&#34;,&#34;Clovelly&#34;,&#34;Bronte&#34;,&#34;Tamarama&#34;]
├─┤
│0│
├─┤
│0│
├─┤
│0│
└─┘</code></pre>
</details>
<p>This is not going well.</p>
<details open="">
<summary>
Level 3
</summary>
<pre><code>┌─┐
│0│
├─┤
│0│ &lt;- [&#34;Coogee&#34;,&#34;Clovelly&#34;,&#34;Bronte&#34;,&#34;Tamarama&#34;]
├─┤
│0│
├─┤
│0│
└─┘</code></pre>
</details>
<p>It’s like the algorithm is taunting me.</p>
<details open="">
<summary>
Level 4
</summary>
<pre><code>┌─┐
│0│
├─┤
│0│
├─┤
│0│ &lt;- [&#34;Coogee&#34;,&#34;Clovelly&#34;,&#34;Bronte&#34;,&#34;Tamarama&#34;]
├─┤
│0│
└─┘</code></pre>
</details>
<p>I tried this for another 20 levels, and all 4 keys keep colliding.</p>
<p>If we take a step back, an easily-identifiable problem is that there are only
4 possible slots for each key to fit into, which increases the likelihood of
a collision. This is where the <code>gamma</code> parameter from earlier comes into play.
We can try again with a <code>gamma</code> of <code>1.5</code>:</p>
<details open="">
<summary>
Level 0
</summary>
<pre><code>┌─┐
│1│ &lt;- [&#34;Bronte&#34;]
├─┤
│1│ &lt;- [&#34;Gordons Bay&#34;]
├─┤
│0│
├─┤
│0│
├─┤
│0│ &lt;- [&#34;Coogee&#34;,&#34;Tamarama&#34;]
├─┤
│0│
├─┤
│1│ &lt;- [&#34;Clovelly&#34;]
├─┤
│0│
├─┤
│1│ &lt;- [&#34;Bondi&#34;]
└─┘</code></pre>
</details>
<p>Okay, this is already looking better.</p>
<details open="">
<summary>
Level 1
</summary>
<pre><code>┌─┐
│0│ &lt;- [&#34;Coogee&#34;,&#34;Tamarama&#34;]
├─┤
│0│
├─┤
│0│
└─┘</code></pre>
</details>
<p>Maybe I spoke too soon?</p>
<details open="">
<summary>
Level 2
</summary>
<pre><code>┌─┐
│1│ &lt;- [&#34;Tamarama&#34;]
├─┤
│1│ &lt;- [&#34;Coogee&#34;]
├─┤
│0│
└─┘</code></pre>
</details>
<p>Phew.</p>
<h3 id="lookup-1">Lookup</h3>
<p>Suppose we wanted to hash <code>Coogee</code>. This is what the final bitarrays look like:</p>
<details open="">
<summary>
Bitarrays
</summary>
<pre><code> 0 1 2 3 4 5 6 7 8
┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│0│0│0│0│1│0│1│ b0
└─┴─┴─┴─┴─┴─┴─┴─┴─┘
         └──────────── hashWithSalt 0 &#34;Coogee&#34; `mod` 9
┌─┬─┬─┐
│0│0│0│ b1
└─┴─┴─┘
 └──────────────────── hashWithSalt 1 &#34;Coogee&#34; `mod` 3
┌─┬─┬─┐
│1│1│0│ b2
└─┴─┴─┘
   └────────────────── hashWithSalt 2 &#34;Coogee&#34; `mod` 3</code></pre>
</details>
<p>We try each bitarray in sequence until we find a <span>1</span> at our index, and we find the <span><em>r</em><em>a</em><em>n</em><em>k</em></span> of that index:</p>
<div><pre><code><span>&gt;</span><span> </span><span>hashWithSalt</span><span> </span><span>0</span><span> </span><span>&#34;Coogee&#34;</span><span> </span><span>`</span><span>mod</span><span>`</span><span> </span><span>9</span><span>
</span><span>4</span><span>
</span><span>&gt;</span><span> </span><span>b0</span><span> </span><span>!</span><span> </span><span>4</span><span> </span><span>-- collision</span><span>
</span><span>0</span><span>
</span><span>&gt;</span><span> </span><span>hashWithSalt</span><span> </span><span>1</span><span> </span><span>&#34;Coogee&#34;</span><span> </span><span>`</span><span>mod</span><span>`</span><span> </span><span>3</span><span>
</span><span>0</span><span>
</span><span>&gt;</span><span> </span><span>b1</span><span> </span><span>!</span><span> </span><span>0</span><span> </span><span>-- collision</span><span>
</span><span>0</span><span>
</span><span>&gt;</span><span> </span><span>hashWithSalt</span><span> </span><span>2</span><span> </span><span>&#34;Coogee&#34;</span><span> </span><span>`</span><span>mod</span><span>`</span><span> </span><span>3</span><span>
</span><span>1</span><span>
</span><span>&gt;</span><span> </span><span>b2</span><span> </span><span>!</span><span> </span><span>1</span><span> </span><span>-- hit</span><span>
</span><span>1</span><span>
</span><span>&gt;</span><span> </span><span>popCount</span><span> </span><span>b0</span><span> </span><span>+</span><span> </span><span>popCount</span><span> </span><span>b1</span><span> </span><span>+</span><span> </span><span>rank</span><span> </span><span>b2</span><span> </span><span>1</span><span>
</span><span>6</span></code></pre></div>
<p>Our hash is <span>6</span>.</p>
<h4 id="false-positive">False positive</h4>
<p>Unfortunately, we also get seemingly-valid output for a key that wasn’t in our
input set, e.g.
<a href="https://www.sydney.com/destinations/sydney/sydney-north/manly/attractions/shelly-beach-manly"><code>Shelly</code></a>:</p>
<details open="">
<summary>
Bitarrays
</summary>
<pre><code> 0 1 2 3 4 5 6 7 8
┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│0│0│0│0│1│0│1│ b0
└─┴─┴─┴─┴─┴─┴─┴─┴─┘
   └─────────────────  hashWithSalt 0 &#34;Shelly&#34; `mod` 9
┌─┬─┬─┐
│0│0│0│ b1
└─┴─┴─┘
┌─┬─┬─┐
│1│1│0│ b2
└─┴─┴─┘</code></pre>
</details>
<div><pre><code><span>&gt;</span><span> </span><span>hashWithSalt</span><span> </span><span>0</span><span> </span><span>&#34;Shelly&#34;</span><span> </span><span>`</span><span>mod</span><span>`</span><span> </span><span>9</span><span>
</span><span>1</span><span>
</span><span>&gt;</span><span> </span><span>rank</span><span> </span><span>b0</span><span> </span><span>1</span><span>
</span><span>2</span></code></pre></div>
<p>This is a limitation of minimal perfect hash functions in general, and
something to keep in mind while using them.</p>
<h3 id="minimal-perfect-hash-table">Minimal perfect hash <em>table</em></h3>
<p>All we have to do is create an array <span><em>A</em></span> such that <span><em>A</em>[<em>h</em><em>a</em><em>s</em><em>h</em>(<em>k</em><sub><em>n</em></sub>)−1] = <em>v</em><sub><em>n</em></sub></span>!</p>
<details open="">
<summary>
Values
</summary>
<pre><code> ╭──────────── Bronte
 │ ╭────────── Gordons Bay
 │ │ ╭──────── Clovelly
 │ │ │ ╭────── Bondi
 │ │ │ │ ╭──── Tamarama
 │ │ │ │ │ ╭── Coogee
 0 1 2 3 4 5
┌─┬─┬─┬─┬─┬─┐
│ │ │ │ │ │ │
└─┴─┴─┴─┴─┴─┘</code></pre>
</details>
<p>The authors point out that trying to save a few bits per key by tweaking
<span><em>g</em><em>a</em><em>m</em><em>m</em><em>a</em></span> doesn’t make much sense in this case, since the values account for the
vast majority of the space usage.</p>
<h3 id="code">Code</h3>
<p>The authors provide a library called
<a href="https://github.com/rizkg/BBHash"><code>BBHash</code></a>, and I have <a href="https://github.com/vaibhavsagar/notebooks/blob/master/mph/MPH.ipynb">a small implementation
here</a>.</p>
<h2 id="thats-all">That’s all!</h2>
<p>An interesting thing I noticed was that after I was able to make sense of this
implementation of minimal perfect hashing, the other approaches were easier to
grasp. I wouldn’t go so far as to say I magically <em>understood</em> them when
I didn’t before, but I definitely feel less lost now. Maybe you’ll have
a similar experience?</p>

        </div></div>
  </body>
</html>
