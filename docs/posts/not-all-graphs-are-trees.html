<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/jaffray/archive/not-all-graphs-are-trees/">Original</a>
    <h1>Not all graphs are trees</h1>
    
    <div id="readability-page-1" class="page"><div>
                <date>
                    
                        April 29, 2024
                    </date>
                
                

                

                
                    
                        <p>It&#39;s pretty easy to imagine how to represent relational algebra expressions as a tree—they are already structurally rooted trees where each operator has its inputs as children.</p>
<p><img alt="image.png" src="https://assets.buttondown.email/images/7a8b4fab-ebc6-4b46-aab9-785a1bbcef2b.png?w=960&amp;fit=max"/> </p>
<p>Even in a language like Rust, which has not yet implemented mutable aliasing (an oft-requested feature stuck at the RFC stage) we can implement this easily:</p>
<div><pre><span></span><code><span>enum</span> <span>RelExpr</span><span> </span><span>{</span><span></span>
<span>    </span><span>Table</span><span>(</span><span>String</span><span>),</span><span></span>
<span>    </span><span>Join</span><span>(</span><span>ScalarExpr</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>RelExpr</span><span>&gt;</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>RelExpr</span><span>&gt;</span><span>),</span><span></span>
<span>    </span><span>Filter</span><span>(</span><span>ScalarExpr</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>RelExpr</span><span>&gt;</span><span>),</span><span></span>
<span>    </span><span>Project</span><span>(</span><span>HashSet</span><span>&lt;</span><span>ColumnId</span><span>&gt;</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>RelExpr</span><span>&gt;</span><span>),</span><span></span>
<span>}</span><span></span>
<span>..</span><span>.</span><span></span>
<span>let</span><span> </span><span>query</span><span> </span><span>=</span><span> </span><span>RelExpr</span>::<span>Join</span><span>(</span><span></span>
<span>    </span><span>q</span><span>,</span><span></span>
<span>    </span><span>Box</span>::<span>new</span><span>(</span><span></span>
<span>        </span><span>RelExpr</span>::<span>Filter</span><span>(</span><span></span>
<span>            </span><span>p</span><span>,</span><span></span>
<span>            </span><span>Box</span>::<span>new</span><span>(</span><span>RelExpr</span>::<span>Table</span><span>(</span><span>&#34;R&#34;</span><span>.</span><span>into</span><span>()))</span><span></span>
<span>        </span><span>)</span><span></span>
<span>    </span><span>),</span><span></span>
<span>    </span><span>Box</span>::<span>new</span><span>(</span><span></span>
<span>        </span><span>RelExpr</span>::<span>Project</span><span>(</span><span></span>
<span>            </span><span>c</span><span>,</span><span></span>
<span>            </span><span>Box</span>::<span>new</span><span>(</span><span></span>
<span>                </span><span>RelExpr</span>::<span>Table</span><span>(</span><span>&#34;S&#34;</span><span>.</span><span>into</span><span>())</span><span></span>
<span>            </span><span>),</span><span></span>
<span>        </span><span>),</span><span></span>
<span>    </span><span>),</span><span></span>
<span>);</span><span></span>
</code></pre></div>
<p>Things get hairier if we want to introduce some kind of non-tree structure into our query, like some kind of self-join:</p>
<p><img alt="image.png" src="https://assets.buttondown.email/images/aadb5291-7499-4c36-9831-0d66bcf607c6.png?w=960&amp;fit=max"/> </p>
<p>This structure permits neither an easy textual representation nor an easy Rust representation (interestingly, these are sort of the same thing).</p>
<p>There&#39;s a couple of ways to resolve this problem.</p>
<h2>Inlining</h2>
<p>The first is <em>inlining</em>. Which is to simply duplicate the expression we want to reference twice.</p>
<p><img alt="image.png" src="https://assets.buttondown.email/images/0a57b564-c535-4d28-a2d3-31dd6d0a5c10.png?w=960&amp;fit=max"/> </p>
<p>This works! But is non-ideal when the expression being referenced is complex, since we&#39;ll have a lot of duplicated expressions, and, if we recompute them each time, a lot of duplicated work.
Even worse is that multiple nested occurrences of multiple references can result in an exponential blowup in the size of the tree:</p>
<p><img alt="image.png" src="https://assets.buttondown.email/images/e58b80c0-361b-4864-a4fa-d9bcdc6245e3.png?w=960&amp;fit=max"/> </p>
<h2>Let Binding</h2>
<p>The other option to resolve this is to use some kind of let-binding.
This is directly supported in SQL as a <code>WITH</code> clause:</p>
<div><pre><span></span><code>WITH q AS (SELECT ...)
  SELECT * FROM q CROSS JOIN q
</code></pre></div>
<p>In Rust this might look something like</p>
<div><pre><span></span><code><span>..</span><span>.</span><span></span>
<span>Let</span><span> </span><span>{</span><span></span>
<span>  </span><span>binding</span>: <span>LetId</span><span>,</span><span></span>
<span>  </span><span>value</span>: <span>Box</span><span>&lt;</span><span>RelExpr</span><span>&gt;</span><span>,</span><span></span>
<span>  </span><span>// `expr` can refer to `value` by constructing</span>
<span>  </span><span>// a `Get` with the appropriate LetId.</span>
<span>  </span><span>expr</span>: <span>Box</span><span>&lt;</span><span>RelExpr</span><span>&gt;</span><span>,</span><span></span>
<span>},</span><span></span>
<span>Get</span><span> </span><span>{</span><span> </span><span>name</span>: <span>LetId</span><span> </span><span>},</span><span></span>
<span>..</span><span>.</span><span></span>
</code></pre></div>
<p>This comes with its own set of problems, of course, for both query planning and query execution.
See <a href="https://buttondown.email/jaffray/archive/why-are-query-plans-trees/" target="_blank">Why Are Query Plans Trees</a> and <a href="https://justinjaffray.com/query-engines-push-vs.-pull/?utm_source=jaffray&amp;utm_medium=email&amp;utm_campaign=not-all-graphs-are-trees" target="_blank">Query Engines: Push vs. Pull</a>. I have yet to see a satisfying solution to the optimization of query plans involving DAGs in this way. I think any real answer probably involves embedding an <a href="https://en.wikipedia.org/wiki/Integer_programming?utm_source=jaffray&amp;utm_medium=email&amp;utm_campaign=not-all-graphs-are-trees" target="_blank">ILP</a> solver in the optimizer.</p>
<p>What if we want to go further? The above two tools open up the world of directed acyclic graphs to us, but what if we want unrestricted access to represent graphs containing <em>cycles</em> in our programs?</p>
<p>There are three common ways to do this that I am aware of.</p>
<h2>Self-Reference</h2>
<p>SQL supports expressions referencing themselves with its <code>WITH RECURSIVE</code> construct:</p>
<div><pre><span></span><code>&gt; WITH RECURSIVE
    nums (n) AS (
        SELECT 1
     UNION ALL
        SELECT n+1 FROM nums WHERE n &lt; 10
    )
    SELECT n FROM nums;
=&gt;
1
2
3
4
5
6
7
8
9
10
</code></pre></div>
<p>By allowing let bindings to reference themselves, we can &#34;close the loop&#34; and introduce a looping edge.</p>
<h2>Fixpoint Operator</h2>
<p>Another way to graft recursion onto a tree-based expression language is to introduce self-reference in another way.</p>
<p>Part of the trickiness around constructing a self-referential expression is: how do you refer to it? </p>
<p>In the previous solution, we said &#34;I&#39;m going to give this thing a name, and put that name into scope before we begin constructing the expression itself so that the body of the expression is allowed to use it and achieve self reference.&#34; Another option is to leave a &#34;hole&#34; in the expression that will get filled in <em>later on</em>.</p>
<p>We can represent such a &#34;hole&#34; by introducing a lambda abstraction, or an anonymous function:</p>
<p>We might write the previous version like this in pseudocode:</p>
<div><pre><span></span><code>let x = {1} UNION (n + 1 FOR n IN x WHERE n &lt; 10)
</code></pre></div>
<p>This &#34;leave a hole&#34; version might look like this:</p>
<div><pre><span></span><code>let nums = fn (other_nums) =&gt; { other_nums UNION (n + 1 FOR n IN other_nums WHERE n &lt; 10) }
</code></pre></div>
<p>And then the language can provide an explicit &#34;fixpoint&#34; operator that takes an initial state and the lambda to iterate to close the loop for us:</p>

<h2>Explicit Listing of Edges</h2>
<p>If we want the full flexibility of graph construction, we can go all the way to how something like Datalog works, where we simply write out each edge explicitly.</p>
<div><pre><span></span><code>nums(1).
nums(n + 1) &lt;- nums(n), n &lt; 10.
</code></pre></div>
<p>(This is not actually valid Datalog, but is a coherent way to think about writing the program we&#39;ve been using so far.)</p>
<p>This is a pretty big syntactic jump—we basically lose the ability to write out entire nested expressions like we do with the previous options, short of introducing some additional syntactic sugar on top to get it back. I think maybe this is part of the reason Datalog conceptually scares a lot of people off, since it eschews a lot of the things we expect from traditional programming languages in terms of syntax, making the primary point of focus in the programs the edges between operators, rather than the operators themselves.
But it turns out that when you want to write graphs and not simply trees, this is a useful perspective shift, and freeing yourself from nested expressions makes graphs tenable.</p>
                    
                

                

            </div></div>
  </body>
</html>
