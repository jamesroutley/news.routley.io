<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexharri.com/blog/vector-networks">Original</a>
    <h1>The engineering behind Figma&#39;s vector networks (2019)</h1>
    
    <div id="readability-page-1" class="page"><div><main><p><img src="https://alexharri.com/images/posts/vector-networks/0.svg" width="2160"/></p>
<p>Adobe Illustrator introduced the pen tool back in <a target="_blank" href="https://www.youtube.com/watch?v=sT8Y7o-zsVw">1987</a> as a tool for creating and modifying paths. Since then the pen tool has become incredibly widespread, so much so that is has become the de facto icon of the graphic design industry.</p>
<p>The pen tool&#39;s functionality hasn&#39;t changed significantly in the 30 years since its introduction. Just click and drag to create smooth curves. Designers have learned to work with it, and around its idiosyncrasies.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/1.svg"/></p>
<p>The pen tool</p>
<p>But Figma felt like they could improve some aspects of how the pen tool worked, so they had a go at redesigning it. Instead of it being used to work with traditional paths, they improved the pen tool by creating what they call Vector Networks.</p>
<p>In this post we will go through what Vector Networks are and what problems they try to solve. After we&#39;ve defined what Vector Networks are, we will take a look at some of the engineering challenges you would face if you were to take a stab at implementing them.</p>
<p>This post can be thought of as an introduction to a really interesting problem space, and as a resource for people interesting in making use of some aspects of Vector Networks for future applications. I hope it succeeds in providing value to both developers being introduced to new concepts and ideas, and to designers interesting in learning more about the tool they know and love.</p>
<p>I will start off by laying out the core concepts behind the pen tool, and from there we will move onto Figma&#39;s Vector Networks.</p>
<h2>Paths</h2>
<p>The pen tool is used to create and manipulate paths.</p>
<p>If you&#39;ve every worked with graphics software like <a target="_blank" href="https://www.adobe.com/products/illustrator.html">Illustrator</a> before, you&#39;ve worked with paths. Paths are a series of lines and curves that may or may not form a loop.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/2.svg"/></p>
<p>Some paths</p>
<p>The path to the left loops, while the path to the right doesn&#39;t. Both of these are valid paths.</p>
<p>The main characteristic of paths is that they form a single continuous unbroken chain. This means that each node can only be connected to one or two other nodes.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/3.svg"/></p>
<p>Not valid paths</p>
<p>However, you could construct these shapes from multiple paths if you position them correctly together.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/4.svg"/></p>
<p>Multiple paths are used to create more complex shapes</p>
<p>From a combination of paths, you can create any shape imaginable.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/5.svg"/></p>
<p>This beer glass, for example, is just a combination of five different paths positioned and scaled a certain way.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/6.svg"/></p>
<h3>The building blocks of paths</h3>
<p>A path is made up of two things, points and lines.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/7.svg"/></p>
<p>Points and lines</p>
<p>The points are known as <strong>nodes</strong> (or vertices) and the lines are called <strong>edges</strong>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/8.svg"/></p>
<p>Together, they make a path</p>
<p>Any path can be described as a list of nodes and edges.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/9.svg"/></p>
<p>This path can be described as the series of nodes <code>(0, 1, 2, 3, 4)</code>. It could also be thought of as the series of the edges that composed it. That list of edges would be <code>(0, 1)</code>, <code>(1, 2)</code>, <code>(2, 3)</code>, <code>(3, 4)</code>, <code>(4, 0)</code>.</p>
<p>You can think of this like the <a target="_blank" href="https://www.google.com/search?q=dot+to+dot+for+kids&amp;tbm=isch">dot to dot puzzles</a> that you used to do as a kid: Draw the edges of the path in the order that the points lay out.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/10.svg"/></p>
<p>But instead of a kid drawing lines between numbered points on a paper, a cold calculating machine does it along the cartesian coordinate system.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/11.svg"/></p>
<h2>Edges</h2>
<p>An edge is a connection between a pair of nodes. Visually, edges are a line from node <code>a</code> to node <code>b</code>.</p>
<p>But that line can be drawn in a lot of different ways. How do you describe those different types of lines?</p>
<p>Edges fall into two categories, straight and curvy.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/12.svg"/></p>
<p>Straight edges are as simple as they seem, just a line from <code>a</code> to <code>b</code>. But how are those curvy edges defined?</p>
<h3>Bezier curves</h3>
<p>Curvy edges are <a target="_blank" href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">bezier curves</a>. Bezier curves are a special type of curve defined by four points.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/13.svg"/></p>
<p>The positions of the two nodes in our edge make up the start and end points of the curve. Each of the two nodes has a <em>control point</em>.</p>
<p>In most applications, these control points are shown as <em>handles</em> that extend from their respective node. These handles are used to control the shape of the curve.</p>
<p>Bezier curves can be chained to make more complex shapes that a single curve can&#39;t draw on its own. They can also be combined with straight lines to make some cool designs.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/14.svg"/></p>
<p>But what exactly are the handles doing? How do the handles tell the computer to draw the curve like it does?</p>
<p>Computers draw curves by splitting them into straight lines and drawing the individual lines.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/15.svg"/></p>
<p>The more lines you split a curve into, the smoother the curve becomes.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/16.svg"/></p>
<p>So to draw the curve we need to know how to get the different points that make up the curve. If we compute enough of them, we get a smooth curve.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/17.svg"/></p>
<h3>Computing a point on a bezier curve</h3>
<p>Let&#39;s compute the point at 25% point of the curve. We can start by connecting the control points with a third blue line.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/18.svg"/></p>
<p>Then for each blue line, we draw a blue dot at the 25% point of the line.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/19.svg"/></p>
<p>Next, draw two green lines between the three blue dots.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/20.svg"/></p>
<p>And we repeat the same step as we did with the blue dots. Draw green points at the 25% points of the green lines.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/21.svg"/></p>
<p>And then one more red line between the newly created green points.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/22.svg"/></p>
<p>Then we add a red point at the 25% point of the red line.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/23.svg"/></p>
<p>And just like that, we&#39;ve computed the point at the 25% point of the curve.</p>
<p>From now on we&#39;ll refer to points on curves through a <code>t</code> value, where <code>t</code> is a number from <code>0</code> to <code>1</code>. In the above example, the point would be at <code>t=0.25</code> (25%).</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/24.svg"/></p>
<p>t=0.25, t=0.5 and t=0.75</p>
<p>This way of computing the point at <code>t</code> is called <a target="_blank" href="https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm">De Casteljau&#39;s algorithm</a> and can also be used to subdivide a bezier curve. Using the points we created along the way, we can also subdivide the bezier curve into two smaller bezier curves.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/25.svg"/></p>
<p>Bezier curves are pretty amazing things. Shaping the curve by adjusting the handles feels surprisingly natural, and chaining them together allows you to create detailed and complex shapes.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/26.svg"/></p>
<p>And for computers, they&#39;re stable and inexpensive to compute. For this reason they&#39;re used for everything from <a target="_blank" href="https://helpx.adobe.com/illustrator/using/drawing-pen-curvature-or-pencil.html#draw_curves_with_the_pen_tool">vector graphics</a> to <a target="_blank" href="https://www.austinsaylor.com/blog/2015/3/20/4-after-effects-graph-editor-basics-you-need-to-know">animation curves</a> and <a target="_blank" href="https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier#B%C3%A9zier_curve">automobile bodies</a>.</p>
<p>You can see an interactive demo of bezier curves at <a target="_blank" href="https://www.jasondavies.com/animated-bezier/">Jason Davies&#39; site</a>. It&#39;s fascinating to watch a series of straight lines trace out a smooth curve.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/27.png"/></p>
<p>From <a target="_blank" href="https://jasondavies.com/animated-bezier">https://jasondavies.com/animated-bezier</a></p>
<h2>The creative constraints of paths</h2>
<p>Earlier in this post, paths were defined as a continuous series of lines and curves that may or may not form a loop.</p>
<p>The fact that paths are a single continuous chain is a pretty big limitation.</p>
<p>It means three way intersections are not possible using a single path. To create a three way intersection, two or more paths will have to be used. This means dealing with positioning and grouping different paths together. It also means that changes to a single path can lead to changes to multiple other paths.</p>
<p>But that&#39;s simply the routine. Seasoned designers know how paths behave, they can plan around it without really thinking about it. For a static design it doesn&#39;t really matter how many paths and layers you have to create if the piece is planned properly upfront.</p>
<p>But for some situations the constraints that paths impose cause a lot of friction.</p>
<h2>Vector Networks</h2>
<p>In 2016, Figma <a target="_blank" href="https://www.figma.com/blog/introducing-vector-networks/">introduced Vector Networks</a>. They lift the “single continuous” limitation by allowing any two nodes to be joined together without restrictions.</p>
<blockquote>
<p>“A vector network improves on the path model by allowing lines and curves between any two points instead of requiring that they all join up to form a single chain.”</p>
</blockquote>
<p><img src="https://alexharri.com/images/posts/vector-networks/28.gif"/></p>
<p>Source: <a target="_blank" href="https://www.figma.com/blog/introducing-vector-networks/">https://www.figma.com/blog/introducing-vector-networks/</a></p>
<p>The cube is the quintessential example for demonstrating Vector Networks.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/29.svg"/></p>
<p>Via traditional paths, you would have to create at minimum 3 different paths to describe this shape.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/30.svg"/></p>
<p>This creates a lot of friction for a seemingly simple and common shape. To modify the cube, you would have to modify two or three different paths. But with Vector Networks you can simply grab an edge and move it around, and the shape behaves like you would expect.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/31.svg"/></p>
<p>So if you would want to increase the extrusion of the cube, you could just grab the two appropriate edges and move them together.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/32.svg"/></p>
<p>This is the big selling point for Figma&#39;s Vector Networks. Ease of use.</p>
<p>Vector Networks don&#39;t enable you to create something that you couldn&#39;t create with other tools, but it does remove a lot of the friction in the process of creating things.</p>
<p>And you can take this even further. Say you want to add a hole to the side of the cube.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/33.svg"/></p>
<p>Just start off by selecting and copying the sides of the cube. You can then duplicate those edges and scale them to the size you want them to be.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/34.svg"/></p>
<p>And just like that, you have a cube with a hole.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/35.svg"/></p>
<p>And to make this hole believable, you just need the inner edge.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/36.svg"/></p>
<p>Again, Vector Networks may not allow you to create something you couldn&#39;t otherwise. Instead, they enable workflows that weren&#39;t previously possible.</p>
<h2>Creating Vector Networks</h2>
<p>With an understanding of what Vector Networks are, we can now take a look at how we would go about implementing them.</p>
<h3>Graph</h3>
<p>The main data structure behind Vector Networks is a graph. A graph can be thought of as a collection of nodes and edges.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/37.svg"/></p>
<p>A graph</p>
<h3>Nodes</h3>
<p>A graph may have any number of nodes. For our purposes nodes have two properties, a unique <code>id</code> and a <code>position</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/38.svg"/></p>
<h3>Edges</h3>
<p>Edges are the connection between two nodes. Each edge is a composed of two <em>edge parts</em>. An edge part contains a node&#39;s id and an optional control point.</p>
<p>The labels <code>n0</code> and <code>n1</code> will be used to refer to the nodes at the start and end of an edge, respectively. The control points will be labeled <code>cp0</code> and <code>cp1</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/39.svg"/></p>
<p>If the control points of the edge are omitted, the edge becomes a straight line.</p>
<h2>Filling the holes</h2>
<p><img src="https://alexharri.com/images/posts/vector-networks/40.gif"/></p>
<p>Source: <a target="_blank" href="https://www.figma.com/blog/introducing-vector-networks/">https://www.figma.com/blog/introducing-vector-networks/</a></p>
<p>When working with vector networks, the Fill tool allows you to “toggle” the fill of different “areas” of the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/41.svg"/></p>
<p>These areas can be defined as a sequence of node <code>id</code>s that go in a circle, a loop, if you will.</p>
<p>This loopy sequence is referred to as a <em>cycle</em>. In the above example, the cycle would consist of the nodes <code>n0</code>, <code>n1</code>, <code>n3</code>, <code>n4</code>, <code>n5</code>, <code>n6</code> and <code>n7</code>. These cycles will be written like <code>(0, 1, 3, 4, 5, 6, 7)</code>.</p>
<p>If you were to count the different visually distinct “areas” of the cycle your answer would probably be three, but you could easily find more than three cycles.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/42.svg"/></p>
<p>What makes this correct or incorrect?</p>
<p>The sequence <code>(0, 1, 2, 3, 4, 5, 6, 7)</code> is a cycle and it loops, but it is not what we&#39;re looking for. The problem can be illustrated with the “how many triangles” puzzle you might have seen on Facebook.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/43.svg"/></p>
<p>How many triangles are in this image?</p>
<p>You should be able to count 24 different triangles depending on which areas you choose to include.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/44.svg"/></p>
<p>But that&#39;s not what we want. What we need to find are the 16 small areas.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/45.svg"/></p>
<p>We need a way to find the <em>“small cycles”</em> in the graph.</p>
<h2>Minimal cycle basis</h2>
<p>This <a target="_blank" href="https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf">paper on Minimal Cycle Basis</a> is a bit less dense than most others academic papers (and it has pictures!). Its goal is:</p>
<blockquote>
<p>…to compute a minimal number of cycles that form a cycle basis for the graph.</p>
</blockquote>
<h3>What does “Minimal Cycle Basis” mean?</h3>
<p>It&#39;s just a fancy way to refer to all of the “small areas” of a graph. You can think of these as the “visually distinct” areas of a graph. Enclosed areas.</p>
<h3>Left or right?</h3>
<p>The main tool for finding the “minimal cycle basis” will be determining which edge to choose based on left- or rightness.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/47.svg"/></p>
<p>Should we go to <code>a</code> or <code>b</code>?</p>
<p>We&#39;ll think of this in terms of clockwise and counter clockwise.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/48.svg"/></p>
<p><code>curr</code> for current, <code>prev</code> for previous</p>
<p>When traveling left, we choose the counter clockwise most edge (CCW) relative to the previous one.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/49.svg"/></p>
<p>CCW</p>
<p>When traveling right, we choose the clockwise most edge (CW) relative to the previous one.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/50.svg"/></p>
<p>CW</p>
<h3>The algorithm</h3>
<p>We will be finding the minimal cycle basis for the graph we saw earlier.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/51.svg"/></p>
<p>The first step is choosing the leftmost node in the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/52.svg"/></p>
<p>When traveling from the first node, we want to go clockwise (CW). But relative to which edge?</p>
<p>For the first node, we imagine that the previous edge is “below” the current one. We then pick the CW edge relative to that.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/53.svg"/></p>
<p>In this case <code>a</code> is more CW relative to <code>prev</code> than <code>b</code>, so we&#39;ll walk to <code>a</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/54.svg"/></p>
<p>After the first walk, we start picking the CCW edge.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/55.svg"/></p>
<p>In this case, that&#39;s <code>b</code>. We repeat the previous step and keep selecting the CCW edge until we reach the original node.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/56.svg"/></p>
<p>When we reach the original node again, a cycle is found.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/57.svg"/></p>
<p>We now have the first small cycle in the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/58.svg"/></p>
<p>When a cycle has been found, the first edge of the cycle is then removed from the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/59.svg"/></p>
<p>The first edge, <code>(n0 n1)</code>, is removed</p>
<p>Then, the <em>filaments</em> of the first two nodes in the cycle are removed.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/60.svg"/></p>
<p>In this case, we only have a single filament</p>
<p>Filaments are nodes that only have one adjacent edge. Think of these as dead ends. When a filament is found, we also check whether or not the single adjacent node is a filament. This ensures that the first node of the next cycle has two adjacent nodes. We&#39;ll see an example of this later.</p>
<p>Now we pick the first node in the next cycle. In our graph, there are two equally left most nodes.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/61.svg"/></p>
<p>When this happens, we pick the bottom node, <code>n1</code> in this case.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/62.svg"/></p>
<p>We then repeat the process from before. CW from the bottom for the first node, then CCW from the previous node until we find the first node.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/63.svg"/></p>
<p>We find the cycle <code>(1, 2, 3)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/64.svg"/></p>
<p>Now we have the cycles <code>(0, 1, 3, 4, 5, 6, 7)</code> and <code>(1, 2, 3)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/65.svg"/></p>
<p>Then we remove the first edge of the cycle and filaments like before. We start by removing the filaments connected to the first two nodes of the cycle.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/66.svg"/></p>
<p>We keep going until there aren&#39;t any filaments left.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/67.svg"/></p>
<p>Finding the next cycle is pretty obvious.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/68.svg"/></p>
<p>CW then CCW</p>
<p>We now have all the cycles of the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/69.svg"/></p>
<p>This is the minimal cycle basis of our graph! Now we can toggle the fills of these cycles as we please.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/70.svg"/></p>
<h2>The math</h2>
<p>I want to dig into how the clockwise-ness of an edge relative to another edge is determined.</p>
<p>The only prerequisite for understanding this section are <a target="_blank" href="https://www.mathsisfun.com/algebra/vectors.html">vectors</a>; arrows pointing from one point of a 2D coordinate system to another.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/71.svg"/></p>
<p>i = (1, 0), j = (0, 1)</p>
<p>With two vectors sitting at the origin, <code>i</code> and <code>j</code>, we can create a square like so.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/72.svg"/></p>
<p>For the unit vectors <code>(1, 0)</code> and <code>(0, 1)</code> the square has an area of 1.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/73.svg"/></p>
<p>We can do this with any two vectors.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/74.svg"/></p>
<p>This shape is called a <em>parallelogram</em>. Parallelograms have one property that we care about, which is that their area is equal to the absolute value of their determinant.</p>
<p>That may sound like jargon, but the determinant happens to be really useful for us. Take a look at what happens when we move the vectors of the one-by-one square closer together.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/75.svg"/></p>
<p>When the vectors get closer, their area gets smaller. And when the vectors are parallel, the determinant and area become 0.</p>
<p>At this point the natural question to ask is what happens when we keep going and the blue arrow is to the right of the green arrow?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/76.svg"/></p>
<p>The determinant becomes negative!</p>
<p>When the blue vector <code>j</code> is to the left of the green vector <code>i</code> the determinant of the parallelogram becomes negative. When the opposite is true it becomes positive.</p>
<p>The implication for our use case is that we can check whether the determinant of two vectors is positive or negative to determine whether or not a vector is to the left or right of another vector.</p>
<p>And we can do this no matter the direction because the area of a parallelogram does not change depending on the orientation of the vectors that create it.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/77.svg"/></p>
<p>The determinant changes when the orientation of the vectors change <strong>relative to each other</strong>.</p>
<p>With this knowledge as our weapon, we can create a function, <code>det(i, j)</code>, that takes in two vectors and returns the determinant.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/78.svg"/></p>
<p>The function will return a positive value when <code>j</code> is to the left (CCW) of <code>i</code>.</p>
<h3>Applying the math</h3>
<p>Say we&#39;re in the middle of the finding a cycle and we&#39;re deciding whether or not to move to <code>n0</code> or <code>n1</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/79.svg"/></p>
<p>Let&#39;s move this into the coordinate system.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/80.svg"/></p>
<p>We&#39;ll start off with <code>a</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/81.svg"/></p>
<p>We want to get the vector from <code>curr</code> to <code>a</code>, which we do by subtracting <code>curr</code> from <code>a</code>. We&#39;ll call this new vector <code>da</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/82.svg"/></p>
<p>We can do the same for <code>curr</code> using <code>prev</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/83.svg"/></p>
<p>Now we can determine whether <code>a</code> is left of <code>curr</code> by computing the determinant of the parallelogram that <code>da</code> and <code>dcurr</code> form.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/84.svg"/></p>
<p>Note that the order is important. If we use <code>da</code> as <code>i</code> the area is negative. If we use it as <code>j</code> it becomes positive.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/85.svg"/></p>
<p>We can do the same with <code>b</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/86.svg"/></p>
<p>With this information as our weapon, we know whether or not <code>a</code>, <code>b</code> and <code>curr</code> are left or right of each other.</p>
<p>What do we do with this information?</p>
<h2>The green zone</h2>
<p>We will be focusing on determining whether <code>da</code> is more CCW than <code>db</code> relative to <code>curr</code>. Simply put, is <code>da</code> left of <code>db</code>?</p>
<p>If <code>da</code> is more CCW than <code>db</code> relative to <code>dcurr</code>, <code>da</code> can be said to be <em>better</em> than <code>db</code>.</p>
<p>The first step is to determine whether the angle between <code>dcurr</code> and <code>db</code> is convex.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/87.svg"/></p>
<p>This “convexity” can more easily visualized by shifting <code>dcurr</code> back and imagining an arc like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/88.svg"/></p>
<p>The angle is convex</p>
<p>If the angle is convex, we we use the following expression to check whether <code>da</code> is better than <code>db</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/89.svg"/></p>
<p>The ∨ symbol represents the logical OR operator in math.</p>
<p>Let&#39;s take a look at the individual parts of this expression.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/90.svg"/></p>
<p>Is <code>da</code> CCW of <code>dcurr</code>?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/91.svg"/></p>
<p>Is <code>da</code> CCW of <code>db</code>?</p>
<p>I find that it&#39;s pretty hard to visualize this mentally, so I think of the two different expressions creating a “green zone” where <code>da</code> is better than <code>db</code>.</p>
<p>For the first part of the expression (is <code>da</code> left of <code>dcurr</code>), the green area looks like so.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/92.svg"/></p>
<p>The second part of the expression asks if <code>da</code> is left of <code>db</code>. The green area look looks like so.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/93.svg"/></p>
<p>And since it&#39;s an OR expression, either of these sub-expressions being true would result in <code>a</code> being better than <code>b</code>. Thus, the green area looks like this:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/94.svg"/></p>
<p>Is <code>a</code> better than <code>b</code>?</p>
<p>We use this to determine the better-ness of <code>a</code> when the angle is convex.</p>
<p>But what if the angle from <code>dcurr</code> to <code>db</code> is concave?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/95.svg"/></p>
<p>Then the expression looks like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/96.svg"/></p>
<p>The only thing that changed here is that the logical OR operator (∨) changed to the logical AND operator (∧).</p>
<p>Let&#39;s take a look at what happens with the green zones using this expression.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/97.svg"/></p>
<p>Is <code>da</code> left of <code>dcurr</code>?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/98.svg"/></p>
<p>Is <code>da</code> left of <code>db</code>?</p>
<p>And since these sub-expressions are joined by logical AND, the green zone looks like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/99.svg"/></p>
<p>Using this method, we can always get the CCW or CW most node. And the great thing is that this method is independent of rotation and really cheap to compute.</p>
<h3>Computing the determinant</h3>
<p>Given two vectors, the <a target="_blank" href="https://en.wikipedia.org/wiki/Determinant">determinant</a> can be computed with this formula:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/100.svg"/></p>
<h2>Intersections in the graph</h2>
<p>Let&#39;s go back to our graph for a bit.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/101.svg"/></p>
<p>This graph is the simplest, most optimistic case. This graph only has straight lines, and no two lines cross each other.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/102.svg"/></p>
<p>This box shape has an intersection. The edge <code>(0, 2)</code> crosses the edge <code>(1, 3)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/103.svg"/></p>
<p>With the intersection, the above area looks fillable. But defining the “filled area” is pretty difficult.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/104.svg"/></p>
<p>What makes defining this area so difficult? Consider this rectangle and line.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/105.svg"/></p>
<p>There are two intersections with the edge <code>(4, 5)</code> intersecting <code>(0, 1)</code> and <code>(2, 3)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/106.svg"/></p>
<p>Say the area left of the line is filled. What happens if we move the line left?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/107.svg"/></p>
<p>Obviously the area shrinks, but what if we keep going and move the line outside of the rectangle? Which of these outcomes below should be the result, and why?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/108.svg"/></p>
<p>In this case kinda feels like the rectangle should be empty. But what if we move the line right?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/109.svg"/></p>
<p>Should it then be filled? Sure, but what if we move the line up or down instead? Should the rectangle fill or empty when the line is no longer separating the two sections?</p>
<h2>Expanding the graph</h2>
<p>This is how I believe Figma solves this problem. I call it “expanding the graph”, but the engineers at Figma probably use a different vocabulary to describe it.</p>
<p>Expanding the graph means taking each intersection, creating a node at the point of the intersections, and then splitting the edges that intersected each other at that point.</p>
<p>This is the original graph:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/110.svg"/></p>
<p>The edge <code>(0, 2)</code> intersects the edge <code>(1, 3)</code>. When expanded, the graph would look like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/111.svg"/></p>
<p>A new node, <code>5</code> would be added at the point of the intersection.</p>
<p>The edges <code>(0, 2)</code> and <code>(1, 3)</code> have been removed and replaced by the edges <code>(0, 5)</code>, <code>(5, 2)</code>, <code>(1, 5)</code>, and <code>(5, 3)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/112.svg"/></p>
<p>The structure of the graph has been changed</p>
<p>Here&#39;s a graphic that should illustrate this a bit more clearly.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/113.svg"/></p>
<p>Expanding an intersection</p>
<h3>Multiple intersections</h3>
<p>These steps are pretty simple for line edges with a single intersections. But each edge can have multiple other edges intersecting it, and two cubic bezier curves can create 9 intersections.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/114.svg"/></p>
<p>This complicates things a bit. Let&#39;s take a look at a bezier-line intersection.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/115.svg"/></p>
<p>The best way to go about this is to treat the intersections for an edge as separate from the edge that intersected it.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/116.svg"/></p>
<p>The <code>t</code> values go from 0 at the start of the curve to 1 at the end of it</p>
<p>The line has two intersections at <code>t = 0.3</code> and <code>t = 0.7</code>. The bezier has two intersections, but at <code>t = 0.25</code> and <code>t = 0.75</code>.</p>
<p>Before we move on with this example, I want to introduce a different way of thinking about edges since I believe it will help with the overall understanding of the problem.</p>
<h3>Duplicate edges</h3>
<p>Two nodes may be connected multiple times by different edges.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/117.svg"/></p>
<p>In this graph, an edge represented by the node pair <code>(2, 3)</code> could represent either of the two edges that connect <code>n2</code> and <code>n3</code>.</p>
<p>To get around this problem, we will give each edge a unique <code>id</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/118.svg"/></p>
<p>For most future examples, I will still refer to edges by the nodes they connect since I feel it&#39;s easier to think about. But for the next example it&#39;s better to separate nodes and edges.</p>
<h3>Intersection map</h3>
<p>We can structure the data for the intersections of the edges like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/119.svg"/></p>
<p>Creating nodes at the intersection points of edges</p>
<p>When we encounter an intersection, we create a node whose position is at the intersection. We then add intersections to an <em>intersection map</em> that will contain the intersections for each edge with a corresponding <code>t</code> value and a <code>nodeId</code>. These intersections are sorted by the <code>t</code> value.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/120.svg"/></p>
<p>For the intersection with the lowest <code>t</code> value, we create an edge with the first <em>edge part</em> having the <code>nodeId</code> of the first edge part of the original edge. The second edge part should contain the <code>nodeId</code> of the intersection. This creates the edge <code>(2, 4)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/121.svg"/></p>
<p>Subsequent edges will have the first edge part&#39;s <code>nodeId</code> be the <code>nodeId</code> of the previous intersection and the second <code>nodeId</code> be the <code>nodeId</code> of the current intersection. In this example, that edge is <code>(4, 5)</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/122.svg"/></p>
<p>One additional edge will be created for each edge with any intersections.</p>
<p>The first edge part&#39;s <code>nodeId</code> will be the <code>nodeId</code> of the last intersection and the second edge part&#39;s <code>nodeId</code> will be the <code>nodeId</code> of the second edge part of the original edge.</p>
<p>This was a bit of a mouthful, so hopefully this graphic helps a bit with understanding that alphabet soup.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/123.svg"/></p>
<p>Separating the intersections of an edge from the edges that created those intersections makes it easier to think about. It alleviates some of the complexity that might arise from multiple edges intersecting with each other.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/124.svg"/></p>
<h2>Self-intersection</h2>
<p>Cubic beziers can self-intersect.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/125.svg"/></p>
<p>This, unfortunately, means that every single cubic bezier edge has to be checked for self-intersection. It&#39;s an interesting problem that involves finding the two different <code>t</code> values that the bezier intersects itself at, but I won&#39;t be covering how to find those values here.</p>
<p>Once you have the <code>t</code> values, a self-intersecting bezier can be expanded like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/126.svg"/></p>
<p>The blue node should be invisible to the user</p>
<p>We insert <code>n3</code> since having a node with an edge that has itself on both ends of the edge is problematic, but it should be hidden from the user.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/127.svg"/></p>
<p>Intersecting the loop of a self-intersecting bezier</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/128.svg"/></p>
<p>Removing n3 at the first opportunity</p>
<h2>Curvy edges</h2>
<p>Earlier we covered the CW - CCW graph traversal algorithm to find the minimal cycle basis (small areas).</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/129.svg"/></p>
<p>Finding the better (counter clockwise most) point adjacent to <code>curr</code></p>
<p>But the algorithm described in the paper was designed to work with nodes connected by straight lines that don&#39;t intersect. Introducing edges defined by cubic beziers introduces significant complexity.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/130.svg"/></p>
<p>Which edge to choose, blue or green?</p>
<p>In the example above, we can find out that the blue edge is better than the green one by using the determinant. We are stilling defining better to mean the CCW most edge.</p>
<p>When working with cubic bezier curves, the naive solution would be to just convert the bezier to a line defined by the points at the start and end of the curve.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/131.svg"/></p>
<p>But that idea breaks down as soon as one edge curves over the other.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/132.svg"/></p>
<p>Oops</p>
<p>Let&#39;s take a fresh look at a bezier curves and try to work from there.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/133.svg"/></p>
<p>Looking at this, we notice that the tangent at the start of the curve, <code>n0</code>, is parallel to the line from <code>n0</code> to <code>cp0</code>. So to get the direction at the start of the edge we can use the line <code>(n0, cp0)</code>.</p>
<p>For clarity, the start of our edge, <code>n0</code>, is the same node as <code>curr</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/134.svg"/></p>
<p>So by converting edges defined by cubic beziers into a line defined by <code>(n0, cp0)</code>, we get the <em>initial</em> angle of the curve.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/135.svg"/></p>
<p>This seems like a good solution when looking at the “curve around” case.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/136.svg"/></p>
<p>Looks like we&#39;ve solved the problem. Right?</p>
<h3>No intersections</h3>
<p>Before we move on to further edge cases, it helps to understand that any solutions assume that no two edges may intersect when deciding which edge to travel.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/137.svg"/></p>
<p>This is not allowed</p>
<p>The edges of the graph we&#39;re traversing must not have any intersections when we compute the cycles (minimal cycle basis) of the graph.</p>
<p>We can only operate on an <em>expanded graph</em>.</p>
<p>Like we covered earlier, an expanded graph is a graph that has replaced all intersections with new nodes and edges. So if the original, user-defined graph has any intersections, they would have to be expanded before we can find the graph&#39;s cycles.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/138.svg"/></p>
<p>The same edges as above, but expanded</p>
<h2>Parallel edges</h2>
<p>The next edge case is two edges being parallel (pointing in the same direction).</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/139.svg"/></p>
<p>If the lines go in the same direction, determining which is better is impossible without more information.</p>
<p>Here are a few possible solutions for the cases where the control points of the curves are parallel.</p>
<h3>Point at <code>t</code></h3>
<p>What if we just take the point on the curve at, for example, <code>t = 0.1</code>?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/140.svg"/></p>
<p>This produces the correct result for curves of a similar length, but we can easily break this with one curve being significantly bigger than the other.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/141.svg"/></p>
<p>This is effectively the same problem as the “curve around” case we saw earlier.</p>
<h3>Point at length</h3>
<p>Instead of taking a point at a fixed <code>t</code> value, we could take a point at some length along the curve. The length would be determined by some point on the smaller curve, e.g. at <code>t=0.1</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/142.svg"/></p>
<p>I have not tried implementing this since I have another working solution, but this could possibly be a viable and performant solution if it works for all edge cases.</p>
<h3>Lasers!</h3>
<p>The next solution is a bit esoteric but produces the correct result. This is the solution I&#39;m currently using.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/143.svg"/></p>
<p>We begin by splitting each bezier at <code>t = 0.05</code> (image above is exaggerated). We then tesselate each part into n points.</p>
<p>Then, for each point of the tesselated bezier, we check whether a line from <code>n0</code> to that point intersects the other edge.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/144.svg"/></p>
<p>It&#39;s pretty hard to see what&#39;s going on at this scale, so let&#39;s zoom in a bit.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/145.svg"/></p>
<p>When a point intersects the other edge, we use the point before it.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/146.svg"/></p>
<p>Found an intersection</p>
<p>Let&#39;s zoom in a bit.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/147.svg"/></p>
<p>The intersection close up</p>
<p>For the other edge, we have no intersection.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/148.svg"/></p>
<p>In that case, we just use the end of the edge as the direction line.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/149.svg"/></p>
<p>With this method we&#39;ve produced lines that seem to represent their respective curves.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/150.svg"/></p>
<p>And this also works for the “curve around” case.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/151.svg"/></p>
<p>But it fails for a “curve behind” case.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/152.svg"/></p>
<p>This would produce the green edge as the more CCW edge, which is wrong.</p>
<p>My solution to this problem is to shoot an infinite laser in the direction of the previous edge.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/153.svg"/></p>
<p>We then check whether the points of the tesselated bezier intersect this laser.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/154.svg"/></p>
<p>But a line from <code>n0</code> to the points would never intersect the laser.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/155.svg"/></p>
<p>Passes right through</p>
<p>Instead, we can create a line from the current point to the previous point and use that for the intersection test.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/156.svg"/></p>
<p>When we intersect the laser, we use the previous point. The previous point will always be on the correct side of the laser.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/157.svg"/></p>
<p>The point we use</p>
<p>And like that, we have a solution.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/158.svg"/></p>
<h2>Parallel, but in reverse!</h2>
<p>It could also be the case that the blue or green edges, <code>a</code> and <code>b</code> respectively, could be parallel to the edge from <code>curr</code> to <code>prev</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/159.svg"/></p>
<p><code>a</code> is parallel to <code>prev</code></p>
<p>The process for finding the better edge follows a process similar to the one described above so we will cover this very quickly.</p>
<p>There are two cases:</p>
<h3>A or B are parallel to <code>Prev</code> , but not both</h3>
<p>If either <code>a</code> or <code>b</code>, but not both, are parallel to <code>prev</code>, we can simply compare the parallel edge to <code>prev</code>.</p>
<p>If the parallel edge is CW of <code>prev</code>, the parallel edge is better.</p>
<p>If the parallel edge is CCW of <code>prev</code>, the other edge is better.</p>
<p>Think a bit about why this is true.</p>
<p>If one edge is parallel to <code>prev</code> and curves CW, and the other is not parallel to <code>prev</code>, then the parallel edge is as CCW as can be. This means that the green zone for the other edge is completely empty.</p>
<p>The reverse is true if the parallel edge curves CCW, since it would be as CW as possible. This means that the green zone for the other edge is the whole circle.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/160.svg"/></p>
<h3>Both A and B are parallel to Prev</h3>
<p>Using the same laser solution as before, this case is covered.</p>
<h2>Cycles inside of cycles</h2>
<p>Now we&#39;re going to look at fills for a bit.</p>
<p>Let&#39;s take a look at a basic example of a graph with a cycle inside of another cycle.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/161.svg"/></p>
<p>You would expect the graph&#39;s areas to be defined like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/162.svg"/></p>
<p>But as it stands, if you hover over the outer area you get a different, unsatisfactory result.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/163.svg"/></p>
<p>But this makes sense. Let&#39;s take a look at the nodes of the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/164.svg"/></p>
<p>The cycle <code>(0, 1, 2, 3)</code> describes the outer boundary of the area we want, but we aren&#39;t describing the “inner boundary” of the area yet.</p>
<p>Let&#39;s take a look at how we can do that.</p>
<h3>Even-odd rule</h3>
<p>Telling a computer to draw the outline of a 2D shape is simple enough. But if you want to fill that shape, how do you tell the computer what is “inside” and what is “outside”?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/165.svg"/></p>
<p>One way of finding out whether a point is inside a shape or not is by shooting an infinite laser in any direction from that point and counting how many “walls” it passes through.</p>
<p>If the laser intersects an odd number of walls, it&#39;s inside of the shape. Otherwise it is outside of the shape.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/166.svg"/></p>
<p>Intersects 1 wall, we&#39;re inside of the shape</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/167.svg"/></p>
<p>Intersects 4 walls, we&#39;re outside of the shape</p>
<p>This works for any 2D shape, no matter which point you choose and which direction you shoot the laser in.</p>
<p>This also helps in the case of nested paths.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/168.svg"/></p>
<p>This gives us an idea for how we can define the “inner boundary” of a shape.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/169.svg"/></p>
<h3>Reducing closed walks</h3>
<p>Let&#39;s look at a graph with a cycle nested inside of another cycle, but with an edge connecting two nodes of the cycles.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/170.svg"/></p>
<p>This will lead back to how we can think about nested cycles and give us a deeper understanding on how to think about them.</p>
<p>Let&#39;s find the cycles. We use the same CW-CCW method as usual.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/171.svg"/></p>
<p>With this method, we go on what looks like a small detour around the inner cycle.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/172.svg"/></p>
<p>When we reach the node we started at, this is what the cycle looks like.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/173.svg"/></p>
<p>This is the first cycle we&#39;ve seen where we cross a node twice (both <code>n3</code> and <code>n4</code>). Something interesting appears when we take a look at the direction that the cycle takes throughout the graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/174.svg"/></p>
<p>We start off traveling CCW, but when we cross the edge from the outer cycle to the inner cycle the orientation we travel seems to flip.</p>
<p>I will state for now that we want to separate the outer cycle from the inner cycle and treat the edge between them as if it didn&#39;t exist. I will go into the <em>why</em> later and explain the <em>how</em> here.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/175.svg"/></p>
<p>We take all repeated nodes, in this case <code>n3</code>, and remove them from the cycle. We also remove any nodes that are between the two repeated nodes.</p>
<p>You might notice that <code>n4</code> is also repeated, but since it&#39;s “inside” of the part of the cycle that <code>n3</code> removes, we can ignore it.</p>
<p>We leave one instance of the repeated node, and then we have the cycle that would have been found if the <em>crossing</em> didn&#39;t exist.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/176.svg"/></p>
<p>We then mark the edge that connected the outer cycle from the inner cycle. I call these marked edges <em>crossings</em>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/177.svg"/></p>
<p>It could also be the case that an outer-inner cycle combo has multiple crossings.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/178.svg"/></p>
<p>In that case, we mark all edges adjacent to the node connected to the outer cycle as a crossing.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/179.svg"/></p>
<p>And after all this is done, our cycles look like so:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/180.svg"/></p>
<h2>Subcycles</h2>
<p>Instead of referring to “inner” and “outer” cycles, I will refer to subcycles and parent cycles. This will make it easier to think about multiple cycles relative to each other.</p>
<p>Having said that, let&#39;s introduce a third cycle.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/185.svg"/></p>
<p>When we hover over the outermost cycle, what do you expect to happen?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/186.svg"/></p>
<p>Because of the even-odd rule, the innermost cycle is filled too!</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/187.svg"/></p>
<p>To fix this, we can introduce the concept of <em>direct subcycles</em>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/188.svg"/></p>
<p>Parent cycles (blue) and their direct subcycles (green)</p>
<p>A parent cycle may have multiple direct subcycles. But due to the non-intersection rule, a subcycle may only have a single parent cycle.</p>
<p>Let&#39;s take a look at how this works.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/189.svg"/></p>
<p>This graph has a a rectangle, our outermost cycle, which has two direct subcycles: a diamond and an hourglass. The diamond has two direct subcycles of its own, and the hourglass has three direct subcycles.</p>
<p>We will begin with the rectangle and its direct subcycles. We will name them, <code>c0</code>, <code>c1</code> and <code>c2</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/190.svg"/></p>
<p>The user has decided to fill some of these cycles, and leave some of them empty.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/191.svg"/></p>
<p><code>c0</code> and <code>c1</code> are filled, and <code>c2</code> is empty</p>
<p>Let&#39;s draw the graph without a stroke and with a gray fill. When drawing this graph we start with the outermost cycle, <code>c0</code>.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/192.svg"/></p>
<p>The graph to the left with the render to the right</p>
<p>Since <code>c0</code> is filled, we draw it. If it were not filled we could skip drawing it. We can shoot a laser out of the rectangle and see that it intersects the walls of the rectangle once, so we can expect it to be filled considering the even-odd rule.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/193.svg"/></p>
<p>This may seem really obvious, but it&#39;s good to have the rules of the game laid out clearly before we move on.</p>
<p>Next we want to draw <code>c1</code>, the diamond in our graph. It was filled, just like the rectangle so we should draw it as well. But if we try to draw the diamond as well, we get the wrong result.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/194.svg"/></p>
<p>Our laser is intersecting two walls as a result of drawing both of the shapes when the have the same fill setting.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/195.svg"/></p>
<p>We intersect an even number of walls, so we&#39;re “outside” of the shape</p>
<p>So to draw the image the user wanted we can simply skip drawing the diamond since the parent cycle implicitly draws direct subcycles with the same fill setting.</p>
<p>The hourglass, <code>c2</code>, is supposed to be empty. With that being the case, just not drawing it seems like a reasonable conclusion. But since the parent cycle (rectangle) has already drawn the hourglass as if it were filled we need to “flip” the fill by drawing the hourglass.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/196.svg"/></p>
<p>And again, if we try to use the laser intersection method we see that the number of intersections is 2, an even number. And with the even-odd rule, an even number of walls means you&#39;re “outside” of the shape.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/197.svg"/></p>
<p>Now that we&#39;ve drawn the rectangle and its direct subcycles, we can move onto the direct subcycles of those.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/198.svg"/></p>
<p>When working with <code>c3</code> and <code>c4</code>, the direct subcycles of <code>c1</code>, we can treat them as if they&#39;re direct subcycles of <code>c0</code> since <code>c1</code> had the same fill setting.</p>
<p>For <code>c3</code>, we want to “flip” the fill setting so we draw it. But <code>c4</code> has the same fill setting as its parent cycle so we don&#39;t draw it.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/199.svg"/></p>
<p>Even number of intersections so we&#39;re outside of the shape</p>
<p>And we can think of <code>c5</code>, <code>c6</code> and <code>c7</code> in the same way. We don&#39;t care whether they&#39;re filled or empty when rendering them. We care whether or not they have the same fill as their parent cycle.</p>
<p>We only need to draw cycles if their parent cycle has the opposite “fill setting” as themselves. If they have the same fill setting, we don&#39;t have to draw them.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/200.svg"/></p>
<p>This means that when drawing cycles, start by drawing the outermost “filled” cycle and then look at that cycle&#39;s subcycles. If a subcycle has the same fill setting as its parent cycle, it should not be drawn.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/201.svg"/></p>
<h2>Contiguous cycles</h2>
<p>A graph may have multiple “clusters” of cycles.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/202.svg"/></p>
<p>I use the phrase <em>contiguous cycles</em> to describe the “togetherness” of the cycles, if you will. I often think of these contiguous groups of cycles as being in different colors.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/203.svg"/></p>
<p>Finding these contiguous cycles can be done with a depth-first traversal:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/204.svg"/></p>
<p>Start at the first node of the cycle</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/205.svg"/></p>
<p>Color each node you find</p>
<p>But remember the <em>crossings</em>? In the search, you may not crawl to adjacent nodes by edges marked as crossings.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/206.svg"/></p>
<p>So in the end, our colors actually look like this:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/207.svg"/></p>
<p>Take this group of contiguous cycles nested inside another group of contiguous cycles:</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/208.svg"/></p>
<p>Because of the non-intersection rule we know that if one of the nodes in a group of contiguous cycles is inside of a cycle not in the group, all of them are.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/209.svg"/></p>
<p>This “contiguous cycles” idea is maybe not the most interesting part of this post on the surface, but I&#39;ve found it to be useful when working on Vector Networks.</p>
<h2>Partial expansion</h2>
<p>When hovering an area defined by intersections, we are showing a cycle of the expanded graph.</p>
<p>Take this triangle as an example.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/210.svg"/></p>
<p>If we hover over one of its areas, we see an area defined by nodes that don&#39;t exist yet.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/211.svg"/></p>
<p>What the blue striped area represents is the area whose fill state would be “toggled” if the user clicks the left mouse button. This area does not exist on the graph as the user defined it. It exists as a cycle on the expanded version of the original graph.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/212.svg"/></p>
<p>The expanded graph</p>
<p>When the user clicks to toggle the fill state of the area, we would first have to expand the graph for the nodes and edges that make up that area to exist.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/213.svg"/></p>
<p>The expanded graph</p>
<p>But by doing that we&#39;ve expanded two intersections that we didn&#39;t need to expand to be able to describe the area. These expansions are destructive in nature and should be avoided when possible.</p>
<p>Instead, we can <em>partially expand</em> the graph by only expanding the intersections that define the selected cycle.</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/214.svg"/></p>
<p>Partially expanded graph</p>
<p>This allows us to maintain as much of the original graph as possible while still being able to define the fill.</p>
<h3>Implementing partial expansions</h3>
<p>The basic implementation is reasonably simple. When you create the expanded graph, just add a little metadata to each expanded node that tells you which two edges of the original graph were used to create it and at what <code>t</code> values those intersections occurred.</p>
<p>Then when the cycle is clicked, iterate over each node. If the node exists in the expanded graph but not the original graph, add it to a new partially expanded graph.</p>
<p>There are edge cases, but I will not be covering them here.</p>
<h2>Omitted topics</h2>
<p>Here are some of the topics that I decided to omit for this post. Go have a stab at them yourself!</p>
<h3>Joins</h3>
<p>Figma offers three types of joins. Round, pointy and square. How could these different types of joins be implemented?</p>
<p><img src="https://alexharri.com/images/posts/vector-networks/215.svg"/></p>
<h3>Stroke align</h3>
<p>Figma also offers three ways to align the stroke of a graph: center, inside and outside.</p>
<p>How do you determine inside- or outside-ness and what happens when the graph has no cycles?</p>
<h3>Boolean operations</h3>
<p>Figma, like most vector graphics tools, offers <a target="_blank" href="https://help.figma.com/article/65-boolean-operations">boolean operations</a>. How could those be implemented?</p>
<p><a target="_blank" href="http://paperjs.org/">Paper.js</a> is open source and has boolean operations for paths, maybe you can start there?</p>
<h2>Future topics</h2>
<p>These are some of the more open-ended features and ideas I want to explore in the future.</p>
<h3>A different way of working with fills</h3>
<p>There are alternatives to how Figma allows the user to work with fills.</p>
<p>One possible solution I&#39;m interested in exploring is multiple different “fill layers” that use one vector object as a reference. This would solve the “<a target="_blank" href="https://spectrum.chat/figma/feature-requests/paint-bucket-tool-with-multiple-colors~1b55179b-f911-468b-9355-fd361564fda0">one graph, multiple colors</a>” problem without having to duplicate the layer and keep multiple vector objects in sync if you want to make changes later on.</p>
<h3>Animating the graph</h3>
<p>Given an <a target="_blank" href="https://helpx.adobe.com/after-effects/using/expression-basics.html">expression</a> and reference based system similar to After Effects, what could you achieve when you combine it with Vector Networks?</p>
<p>Or maybe we could make use of a node editor similar to <a target="_blank" href="https://docs.blender.org/manual/en/latest/editors/shader_editor/index.html">Blender&#39;s shader editor</a> or <a target="_blank" href="https://www.blackmagicdesign.com/products/fusion/visualeffects">Fusion&#39;s node based workflow</a>?</p>
<p>There&#39;s a lot of exploration to be done here and I&#39;m really excited to dive into this topic.</p>
<h2>In closing</h2>
<p>Thanks for reading this post! I hope it served as a good introduction to what I think is a really interesting problem space. I&#39;ve been working on this problem alongside school and work for a good while. It&#39;s part of an animation editor plus runtime for the web I&#39;m working on. I intend for a modified version of Vector Networks to be the core of a few features.</p>
<p>I&#39;ve been working on implementing Vector Networks for a bit over half a year now. The vector editor is pretty robust when it comes to creating, modifying and expanding the graph. But the edge cases when modifying the fill state have been stumping me for quite a while now.</p>
<p>I wanted to have a fully working demo before publishing this post, but it&#39;s going to be a few months until it&#39;s stable enough for it to be usable for people that are not me.</p>
<p>The big idea behind the project is to be a piece of animation software that&#39;s tailor-made for creating and running dynamic animations on the web. I&#39;ll share more about this project at a later date.</p>
<p>I also just think that Figma&#39;s Vector Networks are super cool and it&#39;s really hard to find material about it online. I hope this post helps fix the lack of information that I encountered when attempting to find information about Vector Networks.</p></main></div></div>
  </body>
</html>
