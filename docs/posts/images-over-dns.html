<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgl.cx/2025/09/images-over-dns">Original</a>
    <h1>Images over DNS</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>What&#39;s the limit of what can be in a TXT record?</p>
<p>Some places say 255 bytes. They are
<a href="https://news.ycombinator.com/item?id=38420508">wrong</a>. Within a TXT record
there are multiple character-strings (RFC 1035 section
<a href="https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.14">3.3.14</a>) and
those are limited in length (because a single byte is used for their length),
however there can be many of them.</p>
<p>The actual limit is limited by the <a href="https://www.netmeister.org/blog/dns-size.html">size of the DNS
payload</a>, which for UDP is these
days around <a href="https://blog.apnic.net/2020/12/14/measuring-the-impact-of-dns-flag-day-2020/">1232
bytes</a>.
That is obviously quite low. However if we use TCP, which doesn&#39;t require
anything special, other than the normal fallback to TCP that DNS does, then we
can serve up to 64KB.</p>
<p>I set out to demonstrate exactly that, by using <a href="https://developers.google.com/speed/public-dns/docs/doh/json">Google Public DNS&#39;s JSON
API</a> and then
serving large TXT responses over TCP, from a custom server.</p>
<p>This mostly just works, the main issue is not with the length, but with binary
data, because JSON isn&#39;t really designed to handle binary data. Therefore there
is some slightly custom JSON parsing. Using raw binary data in a TXT record
avoids the overhead of Base64 or another encoding, meaning more data can be
packed in.</p>
<p>ðŸ‘‰ <a href="https://dgl.cx/2025/09/images-over-dns-demo#cat">See it in action</a>. For more read the comments in
<a href="https://git.sr.ht/~dgl/images-over-dns/tree/main/image.html">image.html</a>.</p>
<h2 id="non-browser">Non-browser</h2>
<p>It is possible to query this via dig. Although turning it back into binary
output is a bit tricky, as the presentation form of DNS responses is escaped
for output.</p>
<p>You can retrieve the data with dig and a little Perl to unescape and combine
the character sequences:</p>
<pre><code>$ dig +short dog.log.battery.st TXT | perl -pe&#39;chomp; s/&#34; &#34;//g; s/^&#34;//; s/&#34;$//; s/\\(\d{3})/chr $1/eg; s/\\([\\&#34;])/$1/g&#39; &gt; dog.avif
$ sha256sum dog.avif
7058fbd20ef2af84d5efb0ae7d91f87ce7a912380636c468b32f2c759cbb9130  dog.avif
</code></pre>
<p>(This is actually just a modified version of the Perl one liner from my
<a href="https://dgl.cx/wikipedia-dns">Wikipedia over DNS</a> from 2008, nothing changes.)</p>
<p>Because the web version uses Google&#39;s JSON resolver we know it doesn&#39;t have
problems querying very large TXT records, however your local recursor may not
support this. If it doesn&#39;t work you can add <code>@dns.google</code> to the dig command
line to send the query to Google&#39;s Public DNS servers (or any other open
recursor, <code>@9.9.9.9</code> seems to work too).</p>
<h2 id="why">Why?</h2>
<p>I thought it was a cute hack when I realised it was possible.</p>
<p>For those interested in security there is a consideration here, attackers have
long <a href="https://attack.mitre.org/techniques/T1071/004/">tunnelled over DNS</a>, but
tunnelling large payloads to a browser is potentially something new. Because
Google Public DNS has a certificate that includes <code>8.8.8.8</code> and so on, HTTPS
traffic can go directly from a browser without a DNS lookup. This may be
unexpected in environments that use DNS filtering. This is something that will
become more common once Lets Encrypt fully rolls out <a href="https://letsencrypt.org/2025/07/01/issuing-our-first-ip-address-certificate">IP address
certificates</a>,
the difference here is piggybacking on an existing IP address certificate.</p>
<p>This deliberately uses a low TTL (10 seconds) to avoid filling DNS recursor&#39;s
caches with useless content. It would be possible to increase this and
therefore get caching from the recursors, a bit like a free distributed CDN
(although I suspect if someone actually did this they would adaptively limit
TTLs, if something like that isn&#39;t already done).</p>
<h2 id="server-side">Server side</h2>
<p>The server is a custom Go DNS server. To be honest it was written by ChatGPT
because it&#39;s not that clever, the idea is what matters. (Although ChatGPT did
get some details like truncation wrong so I fixed the code myself.)</p>
<p>All the code is <a href="https://git.sr.ht/~dgl/images-over-dns">here</a>. AI was only
used for the server component, this blog post and the client HTML code is my
own work.</p>
<p><span>20<sup>th</sup> September 2025</span>
</p>

        </div></div>
  </body>
</html>
