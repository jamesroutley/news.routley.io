<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brandur.org/fragments/deleted-record-insert">Original</a>
    <h1>Easy, alternative soft deletion: `deleted_record_insert`</h1>
    
    <div id="readability-page-1" class="page"><div><div><div id=""><article><p>A few months back I wrote <a href="https://brandur.org/soft-deletion"><em>Soft deletion probably isn’t worth it</em></a> (referring to the traditional strategy of putting a <code>deleted_at</code> column in each table), an assertion that I still stand behind. I’ve spent the time migrating our code away from <code>deleted_at</code>, and we’re now at the point where it’s only left on a couple core tables where we want to retain deleted records for an exceptionally long time for debugging purposes.</p>

<p>Nearer to the end of the article I suggest an alternative to <code>deleted_at</code> called <code>deleted_record</code>, a separate schemaless table that gets a full dump of deleted data, but which doesn’t interfere with mainline code (no need to include a <code>deleted_at IS NULL</code> predicate in every live query, no foreign key problems), and without the expectation that it’ll be used to undelete data (which probably wouldn’t work for <code>deleted_at</code> anyway).</p>

<pre><code>CREATE TABLE deleted_record (
    id uuid PRIMARY KEY DEFAULT gen_ulid(),
    data jsonb NOT NULL,
    deleted_at timestamptz NOT NULL DEFAULT current_timestamp,
    object_id uuid NOT NULL,
    table_name varchar(200) NOT NULL,
    updated_at timestamptz NOT NULL DEFAULT current_timestamp
);
</code></pre>

<p>Previously, I’d suggested manually writing <code>deleted_record</code> into each deletion query, but we’ve seen found a much cleaner way to do it. Here’s a function which will generically insert a deleted record from any source table:</p>

<pre><code>CREATE FUNCTION deleted_record_insert() RETURNS trigger
    LANGUAGE plpgsql
AS $$
    BEGIN
        EXECUTE &#39;INSERT INTO deleted_record (data, object_id, table_name) VALUES ($1, $2, $3)&#39;
        USING to_jsonb(OLD.*), OLD.id, TG_TABLE_NAME;

        RETURN OLD;
    END;
$$;
</code></pre>

<p>Invoke it as an <code>AFTER DELETE</code> trigger on any table for which you want to retain soft deletion records:</p>

<pre><code>CREATE TRIGGER deleted_record_insert AFTER DELETE ON credit
    FOR EACH ROW EXECUTE FUNCTION deleted_record_insert();
CREATE TRIGGER deleted_record_insert AFTER DELETE ON discount
    FOR EACH ROW EXECUTE FUNCTION deleted_record_insert();
CREATE TRIGGER deleted_record_insert AFTER DELETE ON invoice
    FOR EACH ROW EXECUTE FUNCTION deleted_record_insert();
</code></pre>

<p>Speaking from 30,000 feet, programming is all about tradeoffs. However, this is one of those rare places where as far as I can tell the cost/benefit skew is so disproportionate that the common platitude falls flat.</p>

<p>Since introducing this pattern months ago I haven’t detected a single problem as it’s happily worked away in the background without issue and there hasn’t been a moment where I’ve found myself wishing that I had <code>deleted_at</code> back. During this time we’ve undoubtedly saved ourselves from dozens of bugs and countless hours of debugging time as people accidentally omit <code>deleted_at IS NULL</code> from production and analytical queries.</p>

<p>A++ programming pattern. Would implement again.</p>
</article></div></div></div></div>
  </body>
</html>
