<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zserge.com/posts/ai-eliza/">Original</a>
    <h1>AI or Ain&#39;t: Eliza</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>In the year 2023, AI took center stage in the media, stirring up discussions about whether it was mere hype or real progress.</p><p>However, the concept of <a href="https://en.wikipedia.org/wiki/Extraterrestrial_intelligence">non-human intelligence</a> isn’t a recent fascination; it has been a dream since ancient times. As we learned more about how neurons communicate through electronic pulses in our brains, it seemed plausible to simulate our “intelligence” with similar electronic circuits. The term “machine intelligence” was coined in the 1950s, around the same time the <a href="https://en.wikipedia.org/wiki/Turing_test">Turing test</a> was introduced.</p><p>This test (also known as the “imitation game”) suggests that AI can be considered genuinely intelligent if a human can’t tell whether they’re interacting with another human or a machine. Picture an interrogator in a room, chatting through a text interface, asking questions, and trying to figure out if their conversational partner is human or not. If the person talking to the computer believes it’s a human, even though it’s a machine, that signifies the machine is genuinely artificially intelligent.</p><h2 id="eliza">Eliza</h2><p>One of the first computer programs that successfully passed the Turing test was <a href="">Eliza</a>. Created in 1966 by <a href="https://web.stanford.edu/class/cs124/p36-weizenabaum.pdf">Joseph Weizenbaum</a>, Eliza skillfully emulated the speech patterns of a psychotherapist in its conversations. Interestingly, Eliza still <a href="https://arstechnica.com/information-technology/2023/12/real-humans-appeared-human-63-of-the-time-in-recent-turing-test-ai-study/">outperforms ChatGPT-3.5</a> in certain Turing test variations.</p><p>Eliza demonstrates how even the simplest algorithm can be just sufficient to appear intelligent. Let’s imagine a program that constantly prints “Hello, user!” when it starts. We can hardly consider it intelligent and a user will quickly start to suspect it’s just a hardcoded behaviour.</p><p>Now, imagine a program printing a random greeting from a predefined list. It will take more attempts to unveil its artificiality, but as soon as the interrogator starts asking questions, such a bot would appear too inadequate in comparison to human interaction.</p><h2 id="how-eliza-works">How Eliza works</h2><p>Let’s recreate Eliza just the way it worked 57 years ago. I’ll share some <a href="https://github.com/zserge/aint/tree/main/eliza">Go code</a>, but you can easily adapt it to the other programming languages.</p><p>We start with a basic chatbot interface:</p><div><pre><code data-lang="go"><span>func</span> <span>response</span><span>(</span><span>input</span> <span>string</span><span>)</span> <span>(</span><span>output</span> <span>string</span><span>)</span> <span>{</span>
    <span>return</span> <span>&#34;I&#39;m not sure I understand you fully&#34;</span>
<span>}</span>
<span>func</span> <span>main</span><span>()</span> <span>{</span>
    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;How do you do.  Please tell me your problem.&#34;</span><span>)</span>
    <span>defer</span> <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Goodbye.  It was nice talking to you.&#34;</span><span>)</span>
    <span>scanner</span> <span>:=</span> <span>bufio</span><span>.</span><span>NewScanner</span><span>(</span><span>os</span><span>.</span><span>Stdin</span><span>)</span>
    <span>for</span> <span>scanner</span><span>.</span><span>Scan</span><span>()</span> <span>{</span>
        <span>reply</span> <span>:=</span> <span>respond</span><span>(</span><span>scanner</span><span>.</span><span>Text</span><span>())</span>
        <span>if</span> <span>reply</span> <span>==</span> <span>&#34;&#34;</span> <span>{</span> <span>// no reply = end of conversation
</span><span></span>            <span>break</span>
        <span>}</span>
        <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>reply</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>Here, we’re reading text from stdin line by line and sending each line to the <code>response()</code> function. This function’s job is to handle what the user says, find a suitable reply, and send it back.</p><p>Currently, our Eliza is pretty brainless; it doesn’t really understand anything the user says and can’t wrap up a conversation properly. So, let’s give it a bit more intelligence by introducing some stop words to help Eliza bid a proper goodbye.</p><div><pre><code data-lang="go"><span>var</span> <span>quit</span> <span>=</span> <span>[]</span><span>string</span><span>{</span><span>&#34;bye&#34;</span><span>,</span> <span>&#34;goodbye&#34;</span><span>,</span> <span>&#34;done&#34;</span><span>,</span> <span>&#34;exit&#34;</span><span>,</span> <span>&#34;quit&#34;</span><span>}</span>

<span>func</span> <span>respond</span><span>(</span><span>input</span> <span>string</span><span>)</span> <span>string</span> <span>{</span>
  <span>q</span> <span>:=</span> <span>strings</span><span>.</span><span>ToLower</span><span>(</span><span>strings</span><span>.</span><span>TrimSpace</span><span>(</span><span>input</span><span>))</span>
  <span>if</span> <span>contains</span><span>(</span><span>q</span><span>,</span> <span>quit</span><span>)</span> <span>{</span>
    <span>return</span> <span>&#34;&#34;</span>
  <span>}</span>
  <span>...</span>
<span>}</span>

<span>// &gt; How do you do.  Please tell me your problem.
</span><span>// : Bye
</span><span>// &gt; Goodbye.  It was nice talking to you.
</span></code></pre></div><h2 id="knowledge-base">Knowledge base</h2><p>To enhance Eliza’s conversational skills, we need to implant some knowledge into its brain. In our case knowledge will be stored in a very structured and oranised manner – as a sorted list of keywords, each accompanied with a set of possible transformation rules.</p><p>Transformation rules are predefined instructions and patterns to help Eliza modify and respond to specific user inputs. Each transformation rule consist of a pattern to match (decomposition) and instructions on how to reassemble the reply.</p><p>Here’s a simple rule example:</p><div><pre><code data-lang="yaml"><span>keyword</span><span>:</span><span> </span><span>&#34;sorry&#34;</span><span>
</span><span></span><span>rules</span><span>:</span><span>
</span><span></span>- <span>match</span><span>:</span><span> </span><span>&#34;*&#34;</span><span>
</span><span>  </span><span>reasmb</span><span>:</span><span>
</span><span>  </span>- <span>Please don&#39;t apologise.</span><span>
</span><span>  </span>- <span>Apologies are not necessary.</span><span>
</span><span>  </span>- <span>I&#39;ve told you that apologies are not required.</span><span>
</span><span>  </span>- <span>It did not bother me.  Please continue.</span><span>
</span></code></pre></div><p>This rule is triggered when the user input contains the word “sorry”. Pattern is a wildcard (<code>*</code>) that matches all input text. Reassembly rules are just static strings and any of them can be returned as a possible reply:</p><div><pre><code data-lang="fallback">&gt; How do you do.  Please tell me your problem.
: Oh sorry
&gt; Please don&#39;t apologise.
</code></pre></div><p>More complicated examples would use reassembly rules that include parts of the user input:</p><div><pre><code data-lang="fallback">keyword: &#34;you&#34;
rules:
- match: &#34;* you * me&#34;
  reasmb:
  - &#34;What makes you think I (2) you ?&#34;
  - &#34;You like to think I (2) you -- don&#39;t you ?&#34;
  - &#34;Really, I (2) you ?&#34;
- match: &#34;* you are *&#34;
  - &#34;What makes you think I am (2) ?&#34;
</code></pre></div><p>Consider user input <em>“I suspect you are a bot”</em>. Eliza will detect the keyword <code>you</code> in the input and will start looking for matching patterns belonging to that keyword.</p><p>The first pattern <code>* you * me</code> will not match the input, but the second one will. Given the input <em>“I suspect you are a bot”</em> and pattern <code>* you are *</code> the first wildcard would hold <code>I suspect</code> and the second wildcard would hold <code>a bot</code>. Now, the reassembly rule would replace <code>(2)</code> placehodler with the contents of the second wildcard replying with <em>“What makes you think I am a bot?&#34;</em>.</p><p>Similarly for the input <em>“I think you might dislike me”</em> the reply could be <em>“Really, I might dislike you?&#34;</em>.</p><p>To avoid duplication of the rules, Eliza uses synonym groups in its patterns. For example, category <code>belief</code> may include words like “belief”, “feel”, “think”, “believe”, “wish” etc. Then in a pattern it becomes possible to refer to the whole category instead of individual words:</p><div><pre><code data-lang="fallback">keyword: &#34;i&#34;
rules:
- match: &#34;* i /belief i *&#34;
  reasmb:
  - &#34;Do you really think so ?&#34;,
  - &#34;But you are not sure you (2).&#34;,
  - &#34;Do you really doubt you (2) ?&#34;),
</code></pre></div><p>Here for the input <em>“I feel I am talking to a bot”</em> the reply could be <em>“But you are not sure you are talking to the bot”</em>.</p><p>You might wonder how “I am” turned into “you are”. Eliza has a list of preprocessing and postprocessing rules. Preprocessing helps to convert “I’m” into “I am” or fix some common typos. Postprocessing helps to invert the pronouns and verbs, i.e. “am → are”, “your → my”, “myself → yourself” etc.</p><p>Another trick Eliza uses to handle synonyms is a “goto” reassembly rule. For the given keyword some transformation rules might redirect Eliza to a different (related) keyword:</p><div><pre><code data-lang="fallback">keyword: &#34;apologise&#34;
rules:
- match: &#34;*&#34;
  reasmb:
  - &#34;=sorry&#34;
keyword: &#34;can&#34;
rules:
- match: &#34;* can you *&#34;
  reasmb:
  - &#34;You believe I can (2) don&#39;t you ?&#34;
  - &#34;=what&#34;
keyword: &#34;what&#34;
rules:
- match: &#34;*&#34;
  reamb:
  - &#34;Why do you ask ?&#34;
  - &#34;Does that question interest you ?&#34;
</code></pre></div><p>Here keyword “apologise” is treated just as if it was “sorry”. For the keyword “can” the first reply would be <em>“You believe I can…&#34;</em> and the second attempt would navigate Eliza to a generic reply.</p><p>Finally, there is one last feature that Eliza employed to simulate intelligence: memorisation. Some transformation rules would ask Eliza to store replies in a memory stack. Later, when no suitable reply could be found these previous replies are popped from memory and reused:</p><div><pre><code data-lang="fallback">&gt; How do you do.  Please tell me your problem.
: My chatbot is misbehaving
&gt; Lets discuss further why your chatbot is misbehaving.
: It pretends being intelligent while it&#39;s not
&gt; Lets discuss further why your chatbot is misbehaving.
: See?
&gt; Please go on.
</code></pre></div><p>Here the first reply about chatbot misbehaving is memorised and repeated when Eliza is out of suitable replies.</p><p>And that’s all Eliza does. Knowledge base can be represented directly with Go code, but you can also store Eliza “scripts” as JSON or YAML files and parse those on startup:</p><div><pre><code data-lang="go"><span>type</span> <span>Keyword</span> <span>struct</span> <span>{</span>
  <span>Word</span>   <span>string</span>
  <span>Rank</span>   <span>int</span>
  <span>Decomp</span> <span>[]</span><span>Decomp</span>
<span>}</span>

<span>type</span> <span>Decomp</span> <span>struct</span> <span>{</span>
  <span>Match</span>  <span>string</span>
  <span>Save</span>   <span>bool</span>
  <span>Reasmb</span> <span>[]</span><span>string</span>
<span>}</span>

<span>var</span> <span>keywords</span> <span>=</span> <span>[]</span><span>Keyword</span><span>{</span>
  <span>{</span>
    <span>&#34;sorry&#34;</span><span>,</span> <span>// keyword
</span><span></span>    <span>0</span><span>,</span>       <span>// rank to sort the keywords
</span><span></span>    <span>[]</span><span>Decomp</span><span>{</span>
      <span>Decomp</span><span>{</span><span>&#34;*&#34;</span><span>,</span> <span>false</span><span>,</span>
        <span>[]</span><span>string</span><span>{</span>
          <span>&#34;Please don&#39;t apologise.&#34;</span><span>,</span>
          <span>&#34;Apologies are not necessary.&#34;</span><span>,</span>
          <span>...</span>
        <span>},</span>
      <span>},</span>
    <span>},</span>
  <span>},</span>
  <span>...</span>
<span>}</span>

<span>var</span> <span>(</span>
  <span>pre</span> <span>=</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>{</span>
    <span>&#34;dont&#34;</span><span>:</span>       <span>&#34;don&#39;t&#34;</span><span>,</span>
     <span>...</span>
  <span>}</span>
    <span>post</span> <span>=</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>{</span>
    <span>&#34;am&#34;</span><span>:</span>       <span>&#34;are&#34;</span><span>,</span>
    <span>&#34;your&#34;</span><span>:</span>     <span>&#34;my&#34;</span><span>,</span>
    <span>...</span>
  <span>}</span>
  <span>quit</span> <span>=</span> <span>[]</span><span>string</span><span>{</span><span>&#34;bye&#34;</span><span>,</span> <span>&#34;goodbye&#34;</span><span>,</span> <span>&#34;done&#34;</span><span>,</span> <span>&#34;exit&#34;</span><span>,</span> <span>&#34;quit&#34;</span><span>}</span>
  <span>syn</span>  <span>=</span> <span>map</span><span>[</span><span>string</span><span>][]</span><span>string</span><span>{</span>
    <span>&#34;be&#34;</span><span>:</span>       <span>[]</span><span>string</span><span>{</span><span>&#34;be&#34;</span><span>,</span> <span>&#34;am&#34;</span><span>,</span> <span>&#34;is&#34;</span><span>,</span> <span>&#34;are&#34;</span><span>,</span> <span>&#34;was&#34;</span><span>},</span>
    <span>&#34;belief&#34;</span><span>:</span>   <span>[]</span><span>string</span><span>{</span><span>&#34;belief&#34;</span><span>,</span> <span>&#34;feel&#34;</span><span>,</span> <span>&#34;think&#34;</span><span>,</span> <span>&#34;believe&#34;</span><span>,</span> <span>&#34;wish&#34;</span><span>},</span>
    <span>...</span>
  <span>}</span>
  <span>fallback</span> <span>=</span> <span>[]</span><span>string</span><span>{</span>
    <span>&#34;I&#39;m not sure I understand you fully.&#34;</span><span>,</span>
    <span>&#34;Please go on.&#34;</span><span>,</span>
    <span>...</span>
  <span>}</span>
<span>)</span>
</code></pre></div><p>All of Eliza state can be stored in two variables: an index, pointing to the next available decomposition for each rule, and a memory of the latest stored replies:</p><div><pre><code data-lang="go"><span>var</span> <span>(</span>
  <span>index</span> <span>=</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>int</span><span>{}</span>
  <span>mem</span>   <span>[]</span><span>string</span>
<span>)</span>
</code></pre></div><p>Complete Eliza code is no more than three functions: a helper to pre/postprocess text, a pattern matching algorithm and a top-level response function to handle the rest of Eliza’s logic:</p><div><pre><code data-lang="go"><span>func</span> <span>replace</span><span>(</span><span>words</span> <span>[]</span><span>string</span><span>,</span> <span>mapping</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>)</span> <span>(</span><span>res</span> <span>[]</span><span>string</span><span>)</span> <span>{</span>
  <span>for</span> <span>_</span><span>,</span> <span>w</span> <span>:=</span> <span>range</span> <span>words</span> <span>{</span>
    <span>if</span> <span>s</span><span>,</span> <span>ok</span> <span>:=</span> <span>mapping</span><span>[</span><span>w</span><span>];</span> <span>ok</span> <span>{</span>
      <span>res</span> <span>=</span> <span>append</span><span>(</span><span>res</span><span>,</span> <span>strings</span><span>.</span><span>Fields</span><span>(</span><span>s</span><span>)</span><span>...</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>res</span> <span>=</span> <span>append</span><span>(</span><span>res</span><span>,</span> <span>w</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>res</span>
<span>}</span>

<span>replace</span><span>(</span><span>strings</span><span>.</span><span>Fields</span><span>(</span><span>&#34;i think you&#39;re a machine&#34;</span><span>},</span> <span>pre</span><span>)</span>
<span>// -&gt; [&#34;i&#34;, &#34;think&#34;, &#34;you&#34;, &#34;are&#34;, &#34;a&#34;, &#34;computer&#34;]
</span><span></span><span>replace</span><span>(</span><span>replace</span><span>(</span><span>strings</span><span>.</span><span>Fields</span><span>(</span><span>&#34;i think you&#39;re a machine&#34;</span><span>},</span> <span>pre</span><span>),</span> <span>post</span><span>)</span>
<span>// -&gt; [&#34;you&#34;, &#34;think&#34;, &#34;i&#34;, &#34;am&#34;, &#34;a&#34;, &#34;computer&#34;]
</span></code></pre></div><p>Pattern matching can be implemented in a number of ways. The obvious one would be to use regular expressions, but that’s too high-level for Eliza. Another option would be to implement <a href="https://benhoyt.com/writings/rob-pike-regex/">a 35-line tiny matcher</a> by <a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a>.</p><p>But since our text is already split into tokens we can build a similar recursive matcher that operates on words rather than characters:</p><div><pre><code data-lang="go"><span>func</span> <span>match</span><span>(</span><span>pat</span><span>,</span> <span>words</span> <span>[]</span><span>string</span><span>)</span> <span>([]</span><span>string</span><span>,</span> <span>bool</span><span>)</span> <span>{</span>
  <span>if</span> <span>len</span><span>(</span><span>pat</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>len</span><span>(</span><span>words</span><span>)</span> <span>==</span> <span>0</span> <span>{</span>
    <span>// Both, pattern and text are empty: match!
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>true</span>
  <span>}</span> <span>else</span> <span>if</span> <span>len</span><span>(</span><span>pat</span><span>)</span> <span>==</span> <span>0</span> <span>||</span> <span>(</span><span>len</span><span>(</span><span>words</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span><span>len</span><span>(</span><span>pat</span><span>)</span> <span>!=</span> <span>1</span> <span>||</span> <span>pat</span><span>[</span><span>0</span><span>]</span> <span>!=</span> <span>&#34;*&#34;</span><span>))</span> <span>{</span>
    <span>// Pattern is empty but some words left, or
</span><span></span>    <span>// Words are empty but pattern has some text left: no match!
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>false</span>
  <span>}</span> <span>else</span> <span>if</span> <span>pat</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;*&#34;</span> <span>{</span>
    <span>// Wildcard: be greedy, as long as the &#34;tails&#34; match!
</span><span></span>    <span>for</span> <span>i</span> <span>:=</span> <span>len</span><span>(</span><span>words</span><span>);</span> <span>i</span> <span>&gt;=</span> <span>0</span><span>;</span> <span>i</span><span>--</span> <span>{</span>
      <span>if</span> <span>m</span><span>,</span> <span>ok</span> <span>:=</span> <span>match</span><span>(</span><span>pat</span><span>[</span><span>1</span><span>:],</span> <span>words</span><span>[</span><span>i</span><span>:]);</span> <span>ok</span> <span>{</span>
        <span>g</span> <span>:=</span> <span>strings</span><span>.</span><span>Join</span><span>(</span><span>replace</span><span>(</span><span>words</span><span>[:</span><span>i</span><span>],</span> <span>post</span><span>),</span> <span>&#34; &#34;</span><span>)</span>
        <span>return</span> <span>append</span><span>([]</span><span>string</span><span>{</span><span>g</span><span>},</span> <span>m</span><span>...</span><span>),</span> <span>true</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> <span>nil</span><span>,</span> <span>false</span>
  <span>}</span> <span>else</span> <span>if</span> <span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>pat</span><span>[</span><span>0</span><span>],</span> <span>&#34;/&#34;</span><span>)</span> <span>{</span>
    <span>// Synonym: compare to one of the words in that category
</span><span></span>    <span>if</span> <span>slices</span><span>.</span><span>Contains</span><span>(</span><span>syn</span><span>[</span><span>pat</span><span>[</span><span>0</span><span>][</span><span>1</span><span>:]],</span> <span>words</span><span>[</span><span>0</span><span>])</span> <span>{</span>
      <span>if</span> <span>m</span><span>,</span> <span>ok</span> <span>:=</span> <span>match</span><span>(</span><span>pat</span><span>[</span><span>1</span><span>:],</span> <span>words</span><span>[</span><span>1</span><span>:]);</span> <span>ok</span> <span>{</span>
        <span>return</span> <span>append</span><span>([]</span><span>string</span><span>{</span><span>words</span><span>[</span><span>0</span><span>]},</span> <span>m</span><span>...</span><span>),</span> <span>true</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> <span>nil</span><span>,</span> <span>false</span>
  <span>}</span> <span>else</span> <span>if</span> <span>pat</span><span>[</span><span>0</span><span>]</span> <span>!=</span> <span>words</span><span>[</span><span>0</span><span>]</span> <span>{</span>
    <span>// Literal word in pattern does not match the text: no match!
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>false</span>
  <span>}</span>
  <span>// Seems to match so far, compare the rest!
</span><span></span>  <span>return</span> <span>match</span><span>(</span><span>pat</span><span>[</span><span>1</span><span>:],</span> <span>words</span><span>[</span><span>1</span><span>:])</span>
<span>}</span>

<span>//
</span><span>// func split(s) []string { ... }
</span><span>//
</span><span>// match(split(&#34;&#34;), split(&#34;&#34;)) -&gt; true
</span><span>// match(split(&#34;foo&#34;), split(&#34;foo&#34;)) -&gt; true
</span><span>// match(split(&#34;foo&#34;), split(&#34;bar&#34;)) -&gt; false
</span><span>// match(split(&#34;foo&#34;), split(&#34;bar&#34;)) -&gt; false
</span><span>// match(split(&#34;a * b&#34;), split(&#34;a b c d e b&#34;)) -&gt; true (1)=&#34;b c d e&#34;
</span><span>// match(split(* a * b *), split(&#34;a b c&#34;)) -&gt; true (1)=&#34;&#34;, (2)=&#34;&#34;, (3)=&#34;c&#34;
</span></code></pre></div><p>After having all the knowledge encoded and these utility functions written we can now build the rest of Eliza’s brain:</p><div><pre><code data-lang="go"><span>func</span> <span>respond</span><span>(</span><span>q</span> <span>string</span><span>)</span> <span>string</span> <span>{</span>
  <span>q</span> <span>=</span> <span>strings</span><span>.</span><span>ToLower</span><span>(</span><span>strings</span><span>.</span><span>TrimSpace</span><span>(</span><span>q</span><span>))</span>
  <span>// Handle stop words
</span><span></span>  <span>if</span> <span>slices</span><span>.</span><span>Contains</span><span>(</span><span>quit</span><span>,</span> <span>q</span><span>)</span> <span>{</span>
    <span>return</span> <span>&#34;&#34;</span>
  <span>}</span>
  <span>// Split into words and preprocess
</span><span></span>  <span>words</span> <span>:=</span> <span>replace</span><span>(</span><span>strings</span><span>.</span><span>Fields</span><span>(</span><span>q</span><span>),</span> <span>pre</span><span>)</span>
  <span>// Find a keyword
</span><span></span>  <span>for</span> <span>_</span><span>,</span> <span>k</span> <span>:=</span> <span>range</span> <span>keywords</span> <span>{</span>
    <span>if</span> <span>slices</span><span>.</span><span>Contains</span><span>(</span><span>words</span><span>,</span> <span>k</span><span>.</span><span>Word</span><span>)</span> <span>{</span>
    <span>nextKey</span><span>:</span>
      <span>// Find matching transformation rule
</span><span></span>      <span>for</span> <span>i</span><span>,</span> <span>d</span> <span>:=</span> <span>range</span> <span>k</span><span>.</span><span>Decomp</span> <span>{</span>
        <span>if</span> <span>m</span><span>,</span> <span>ok</span> <span>:=</span> <span>match</span><span>(</span><span>strings</span><span>.</span><span>Fields</span><span>(</span><span>d</span><span>.</span><span>Match</span><span>),</span> <span>words</span><span>);</span> <span>ok</span> <span>{</span>
          <span>// Choose the next reassembly
</span><span></span>          <span>id</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;%s:%d&#34;</span><span>,</span> <span>k</span><span>.</span><span>Word</span><span>,</span> <span>i</span><span>)</span>
          <span>reply</span> <span>:=</span> <span>d</span><span>.</span><span>Reasmb</span><span>[</span><span>index</span><span>[</span><span>id</span><span>]]</span>
          <span>index</span><span>[</span><span>id</span><span>]</span> <span>=</span> <span>(</span><span>index</span><span>[</span><span>id</span><span>]</span> <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>len</span><span>(</span><span>d</span><span>.</span><span>Reasmb</span><span>)</span>
          <span>// Handle &#34;goto&#34; rules
</span><span></span>          <span>if</span> <span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>reply</span><span>,</span> <span>&#34;=&#34;</span><span>)</span> <span>{</span>
            <span>for</span> <span>_</span><span>,</span> <span>nextk</span> <span>:=</span> <span>range</span> <span>keywords</span> <span>{</span>
              <span>if</span> <span>nextk</span><span>.</span><span>Word</span> <span>==</span> <span>reply</span><span>[</span><span>1</span><span>:]</span> <span>{</span>
                <span>k</span> <span>=</span> <span>nextk</span>
                <span>goto</span> <span>nextKey</span>
              <span>}</span>
            <span>}</span>
          <span>}</span>
          <span>// Replace placeholders with phrases from user input
</span><span></span>          <span>for</span> <span>i</span><span>,</span> <span>s</span> <span>:=</span> <span>range</span> <span>m</span> <span>{</span>
            <span>reply</span> <span>=</span> <span>strings</span><span>.</span><span>ReplaceAll</span><span>(</span><span>reply</span><span>,</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;(%d)&#34;</span><span>,</span> <span>i</span><span>+</span><span>1</span><span>),</span> <span>s</span><span>)</span>
          <span>}</span>
          <span>// Memorise the reply, if needed
</span><span></span>          <span>if</span> <span>d</span><span>.</span><span>Save</span> <span>{</span>
            <span>mem</span> <span>=</span> <span>append</span><span>(</span><span>mem</span><span>,</span> <span>reply</span><span>)</span>
          <span>}</span>
          <span>return</span> <span>reply</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>// Try to use memory before admitting that we don&#39;t have a clue what a user is talking about
</span><span></span>  <span>if</span> <span>len</span><span>(</span><span>mem</span><span>)</span> <span>&gt;</span> <span>0</span> <span>{</span>
    <span>reply</span> <span>:=</span> <span>mem</span><span>[</span><span>len</span><span>(</span><span>mem</span><span>)</span><span>-</span><span>1</span><span>]</span>
    <span>mem</span> <span>=</span> <span>mem</span><span>[:</span><span>len</span><span>(</span><span>mem</span><span>)</span><span>-</span><span>1</span><span>]</span>
    <span>return</span> <span>reply</span>
  <span>}</span>
  <span>index</span><span>[</span><span>&#34;fallback&#34;</span><span>]</span> <span>=</span> <span>(</span><span>index</span><span>[</span><span>&#34;fallback&#34;</span><span>]</span> <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>len</span><span>(</span><span>fallback</span><span>)</span>
  <span>return</span> <span>fallback</span><span>[</span><span>index</span><span>[</span><span>&#34;fallback&#34;</span><span>]]</span>
<span>}</span>
</code></pre></div><p>Full sources are available <a href="https://github.com/zserge/aint/tree/main/eliza/">on GitHub</a> and you can play around with one of Eliza implementations <a href="https://www.masswerk.at/elizabot/">online</a> to take a Turing test yourself.</p><p>Clearly, Eliza is not an AI. But it’s been a huge success and caused many people treat it as a human. Being empathetic to its users and reflecting their language back to them, Eliza seems to be very understanding. Also it doesn’t tend to reveal much about itself, making it harder to discover that it’s merely a short list of hardcoded phrases. Silence is golden, indeed.</p><p>Next part: <a href="https://zserge.com/posts/ai-markov/">Markov Chains</a></p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href="https://github.com/zserge">Github</a>, <a href="https://mastodon.social/@zserge">Mastodon</a>, <a href="https://twitter.com/zsergo">Twitter</a> or subscribe via <a href="https://zserge.com/rss.xml">rss</a>.</p><p><em>Jan 01, 2024</em></p></div></div>
  </body>
</html>
