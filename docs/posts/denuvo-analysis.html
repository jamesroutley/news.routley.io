<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://connorjaydunn.github.io/blog/posts/denuvo-analysis/">Original</a>
    <h1>Denuvo Analysis</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This post is intended for educational purposes only. Denuvo is arguably the most successful digital rights management solution to have ever existed, and is therefore an interest to many. This blog contains a large amount of my personal notes and correspondence with other reverse engineers (see <a href="#kudos">kudos</a>) which contains information about the recent iterations of Denuvo, lots of which I haven’t seen shared publicly before.</p>
<p>I mean no harm towards Irdeto and thus certain information will be redacted from this post.</p>

<p><img src="https://connorjaydunn.github.io/blog/posts/denuvo-analysis/denuvo.logo.png" alt=""/></p>
<p>Denuvo is an anti-tamper and digital rights management system (DRM). It is primarily used to protect digital media such as video games from piracy and reverse engineering efforts. Unlike traditional DRM systems, Denuvo employs a wide range of unique techniques and checks to confirm the integrity of both the game’s code and licensed user.</p>

<p>The core idea behind Denuvo is nothing new. It can only be described as a semi-online DRM for reasons that will become clear shortly. The general idea is as follows:</p>
<p><strong>(1)</strong> User boots program.exe for the first time.</p>
<p><strong>(2)</strong> Before any original game code is executed, Denuvo will collect hardware identification information regarding the current system, and prepare it for sending over the internet.</p>
<p><strong>(3)</strong> program.exe then sends this hardware information to a Denuvo hosted server. What occurs at the server is obviously a mystery, but it likely applies reversible mathematical functions to combine the “stolen constants” (more on those later) with the hardware information provided by program.exe. The server then sends this now mixed information, we will refer to this as “the license file”, back to program.exe.</p>
<p><strong>(4)</strong> Once program.exe receives the license file, a local copy is created that program.exe can refer to on future boots; removing the need for another online request to be made (hence the use of “semi-online” earlier).</p>
<p><strong>(5)</strong> program.exe will be redirected to the original entry point (OEP) and begin executing the actual game code. During this time, program.exe will collect hardware information at runtime and attempt to decrypt stolen constants from the license file. These now decrypted constants will then be used to execute “original game instructions”.</p>
<p>If it wasn’t made clear already, the game will effectively end up performing user integrity checks. This is due to the fact that if the hardware information collected at runtime is not the equal to that of which was used to create the license file on the Denuvo server, then an incorrect stolen constant will be decrypted and the game will likely suffer (most of the time this is a direct crash).</p>

<p>This section will investigate each protection mechanism and user integrity check more thoroughly. Remember, there is far more to Denuvo that what is outlined here.</p>
<h2 id="general-idea-revisited">General Idea Revisited</h2>
<h3 id="license-file">License File</h3>
<p>When Denuvo is first added to a binary, certain functions in that game are selected to become “protected”. All this means is that the function itself will be executed inside of a virtual machine, and select parts of certain instructions will be removed entirely from the binary. The license file is simply all of these removed bytes combined together and combined with the user’s hardware identification via reversible mathematical functions. It is important that whatever operations are applied are reversible, otherwise the client would have no way of decrypting and getting the original constant.</p>
<h3 id="license-dwords">License DWORDs</h3>
<p>Since there are multiple stolen instructions, prior to handling execution over to the OEP, Denuvo will write select parts of the license file into DWORDs, scattered around the .vm section (.vm being the PE section which contains the VM code). Each DWORD, we will nick “License DWORD”, is effectively a single instruction that was removed from the binary, combined with the hardware identification information of the customer.</p>
<h3 id="encrypted-constant--removed-instruction-example">Encrypted Constant / Removed Instruction Example</h3>
<p>In order to make the idea concrete, I will show an example of how instructions are “removed” from the binary. Assume we have the following function:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>add</span>(<span>int</span>, <span>int</span>):
</span></span><span><span>	<span>push</span>  <span>rbp</span>
</span></span><span><span>	<span>mov</span>  <span>rbp</span>, <span>rsp</span>
</span></span><span><span>	<span>mov</span>  <span>DWORD</span>  <span>PTR</span> [<span>rbp-4</span>], <span>edi</span>
</span></span><span><span>	<span>mov</span>  <span>DWORD</span>  <span>PTR</span> [<span>rbp-8</span>], <span>esi</span>
</span></span><span><span>	<span>mov</span>  <span>edx</span>, <span>DWORD</span>  <span>PTR</span> [<span>rbp-4</span>]
</span></span><span><span>	<span>mov</span>  <span>eax</span>, <span>DWORD</span>  <span>PTR</span> [<span>rbp-8</span>]
</span></span><span><span>	<span>add</span>  <span>eax</span>, <span>edx</span>
</span></span><span><span>	<span>pop</span>  <span>rbp</span>
</span></span><span><span>	<span>ret</span>
</span></span></code></pre></div><p>It is trivial to see that there exist parts of instructions that will never change once compiled. For instance:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span><span><span>mov</span>  <span>DWORD</span>  PTR [rbp<span>-</span><span>4</span>], edi
</span></span></code></pre></div><p>Here we are writing the contents of the 32-bit register, <em>EDI</em>, into <em>[RBP-4]</em>. In this case, Denuvo would strip the binary of the constant <em>-4</em> and store it on their server. Now, the only way for anyone to access this constant, which would be required for a successful execution of <em>add(int, int)</em>, would be to request a license file from Denuvo as that would contain the license DWORDs, which contain the encrypted constant <em>-4</em> (recall that the license file contains the constants mixed with hardware identification). Furthermore, Denuvo will convert the entire function, <em>add(int, int)</em>, into bytecode that only their virtual machine can understand. Present in this bytecode, there exists code which acts like a wrapper around the removed instruction. This wrapper is responsible for the following:</p>
<p><strong>(1)</strong> Collect the corresponding hardware information at runtime (the specific hardware information that was mixed in with the constant).</p>
<p><strong>(2)</strong> Read the corresponding license DWORD that contains the encrypted constant for this particular function.</p>
<p><strong>(3)</strong> Perform a series of mathematical operations using the license DWORD and the hardware identification collected at runtime to retrieve the value of <em>-4</em>. This should be the inverse of whatever the server did.</p>
<p><strong>(4)</strong> Execute the original instruction with the now decrypted constant.</p>
<p>Recall from a previous section, if the hardware identification collected at runtime does not align with that which was used on the Denuvo server to encrypt the constant, then <strong>(3)</strong> will likely yield a result that is not equal to <em>-4</em>; causing undefined behaviour.</p>
<h2 id="user-integrity-checks">User Integrity Checks</h2>
<p>I will now highlight all of the vectors Denuvo use to verify the integrity of the system executing the protected binary. By the nature of the protection, at least one instance of each check must be sent to the server when requesting for a license file.</p>
<h3 id="pre-oep-checks">Pre-OEP Checks</h3>
<p>After reading the previous section(s), you may be wondering what happens if a user’s hardware identification changes (e.g. Windows update, new CPU, etc). Denuvo account for this using special checks which execute just before handing control to the OEP. They will simply perform some constant decryptions but instead of using said constant to execute an instruction, they will check if it is equal to what it should be (these are the only checks that do this, everything else assumes that the decrypted constant is correct and acts accordingly). If the result is not as expected, Denuvo will delete the locally saved license file and request a new one from the Denuvo server; basically a repeat of the process described in <a href="#the-general-idea">The General Idea</a></p>

<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">KUSER_SHARED_DATA</a> is a single page of, <a href="https://msrc.microsoft.com/blog/2022/04/randomizing-the-kuser_shared_data-structure-on-windows/">now read-only</a>, memory (4096 bytes) that is mapped into every process running on a Windows machine. It contains information that processes may wish to access, such as the Windows Version, Windows Build Number, SystemTime, etc. A lot of the information it contains can be used to identify a machine, and therefore Denuvo make good use of it to aid in their needs.</p>
<p>Denuvo utilises the following fields:</p>
<hr/>
<ul>
<li>0x026C : ULONG NtMajorVersion</li>
<li>0x02E8 : ULONG NumberOfPhysicalPages</li>
<li>0x02D0 : ULONG SuiteMask</li>
<li>0x0260 : ULONG NtBuildNumber</li>
<li>0x0264 : NT_PRODUCT_TYPE NtProductType</li>
<li>0x0268 : BOOLEAN ProductTypeIsValid</li>
<li>0x0270 : ULONG NtMinorVersion</li>
<li>0x0274 : BOOLEAN ProcessorFeatures [0x40]</li>
<li>0x026A : USHORT NativeProcessorArchitecture</li>
<li>0x03C0 : ULONG volatile ActiveProcessorCount</li>
</ul>
<hr/>
<p><em><strong>NOTE:</strong></em> These offsets are for 64-bit machines.</p>
<h3 id="cpuid">CPUID</h3>
<p>The <a href="https://www.felixcloutier.com/x86/cpuid">CPUID</a> instruction is used to retrieve details about the processor. This is probably the most common method Denuvo uses to collect hardware information. And as will be shown later, great lengths are taken in order to protect its execution from tampering.</p>
<p>Denuvo makes use of the following parameters:</p>
<hr/>
<ul>
<li>EAX=0x1 : Processor Info and Feature Bits</li>
<li>EAX=0x80000001 : Extended Processor Info and Feature Bits</li>
<li>EAX=0x80000002, 0x80000003, 0x80000004 : Processor Brand String</li>
</ul>
<hr/>
<h3 id="syscall">SYSCALL</h3>
<p>The <a href="https://www.felixcloutier.com/x86/syscall">SYSCALL</a> instruction invokes an OS system-call handler at privilege level 0. You may think of it as a way for user mode programs to communicate and ask the kernel for services.</p>
<p>Denuvo makes use of a single parameter:</p>
<hr/>
<ul>
<li>0x36 : NtQuerySystemInformation</li>
</ul>
<hr/>
<h3 id="ntdll-checks">NTDLL Checks</h3>
<p>ntdll.dll is the “user-mode face of the windows kernel”. It basically offers a rich API that usermode applications may use to request the kernel to perform actions on their behalf. ntdll.dll is loaded into virtually every windows process by the Windows Loader and usually changes per Windows update; making it an ideal target for Denuvo.</p>
<h4 id="ntdll-function-checks">NTDLL Function Checks</h4>
<p>I didn’t look as deep into this as I should have. But it appears that Denuvo will identify the user based on bytes of certain functions located with ntdll.dll and their relative virtual address (RVA).</p>
<h4 id="ntdll-image-data-directory">NTDLL Image Data Directory</h4>
<p>As stated previously, ntdll.dll typically changes slightly per Windows Update / Version, so it makes sense why Denuvo would target its <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory">Image Data Directory</a>. To be specific, the following fields are accessed:</p>
<hr/>
<ul>
<li>Export Directory RVA</li>
<li>Export Directory Size</li>
<li>Import Directory RVA</li>
<li>Import Directory Size</li>
<li>Resource Directory RVA</li>
<li>Resource Directory Size</li>
<li>Exception Directory RVA</li>
<li>Exception Directory Size</li>
<li>Relocation Directory RVA</li>
<li>Relocation Directory Size</li>
</ul>
<hr/>
<h3 id="process-environment-block-peb">Process Environment Block (PEB)</h3>
<p>The <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">Process Environment Block</a> (PEB) is similar to KUSER_SHARED_DATA in the sense that both possess information. However, the PEB contains less “global” and more “local” information. Also, each process on the system has their own unique PEB. Another key difference is that the application is free to overwrite values in the PEB, making this a not so ideal place to use for verifying hardware information, but Denuvo use it regardless.</p>
<p>Denuvo makes use of the following fields:</p>
<hr/>
<ul>
<li>0x0118 : ULONG OSMajorVersion</li>
<li>0x011C : ULONG OSMinorVersion</li>
<li>0x012C : ULONG ImageSubsystemMajorVersion</li>
<li>0x0130 : ULONG ImageSubsystemMinorVersion</li>
</ul>
<hr/>
<p><em><strong>NOTE:</strong></em> These offsets are for 64-bit machines.</p>
<h3 id="xgetbv">XGETBV</h3>
<p><a href="https://www.felixcloutier.com/x86/xgetbv">XGETBV</a> reads an extended-control-register (XCR). I don’t have much to say about this in terms of specifics, its a very small and unique instruction, in terms of its execution, that can be used determine specifics about the CPU.</p>
<h3 id="getwindowsdirectoryw">GetWindowsDirectoryW</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectoryw">GetWindowsDirectoryW</a> retrieves the path of the windows directory.</p>
<h3 id="getvolumeinformationw">GetVolumeInformationW</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformationW</a> will fetch information about the file system and volume associated with the specific root directory.</p>
<h3 id="getcomputernamew">GetComputerNameW</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamew">GetComputerNameW</a> Retrieves the NetBIOS name of the local computer.</p>
<h3 id="getusernamew">GetUsernameW</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamew">GetUsernameW</a> Retrieves the name of the user associated with the current thread. Which in our case will be the username of the user trying to run the Denuvo protected binary.</p>
<h2 id="code-integrity-checks">Code Integrity Checks</h2>
<h3 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h3>
<h4 id="vm-handler-crc">VM Handler CRC</h4>
<p>As expected, Denuvo will perform scans of important handlers (e.g. CPUID, SYSCALL, etc), and maybe other code, to make sure there is no hooks / tampering going on. Unfortunately, that is all I have to say regarding those checks.</p>
<h4 id="seemingly-random-vm-check">Seemingly Random .VM Check</h4>
<p>Frequently, Denuvo will construct a constant via reading a seemingly random amount of bytes from the .VM section. This constant will then be used to perform calculations that would break given the constant changed. Take the following handler for instance:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span><span><span>mov</span> edx, <span>dword</span> ptr ds:[rax<span>+</span><span>0x03</span>] <span>; read next handler index</span>
</span></span><span><span>
</span></span><span><span><span>movsx</span> r13, <span>word</span> ptr ds:[<span>0x00000001467FEE8D</span>] <span>; here we see Denuvo read a &#34;random&#34; word from the .VM code</span>
</span></span><span><span>
</span></span><span><span><span>add</span> r13, <span>0xFFFFFFFFFFFFDBAB</span> <span>; decrypt word</span>
</span></span><span><span>
</span></span><span><span><span>add</span> rax,r13 <span>; update vip</span>
</span></span><span><span>
</span></span><span><span><span>mov</span> <span>qword</span> ptr ds:[rcx<span>+</span><span>418</span>],rax <span>; save vip</span>
</span></span><span><span>
</span></span><span><span><span>lea</span> rax,<span>qword</span> ptr ds:[<span>0x14E2FD140</span>] <span>; mov address of handler table into rax</span>
</span></span><span><span>
</span></span><span><span><span>; compute next handler and jmp to it</span>
</span></span><span><span><span>mov</span> r12,<span>qword</span> ptr ds:[rax<span>+</span>rdx<span>*</span><span>8</span>]
</span></span><span><span><span>xchg</span> <span>qword</span> ptr ss:[rsp],r12
</span></span><span><span><span>ret</span>
</span></span></code></pre></div><p>If the user had placed a breakpoint, hook, or tampered with the word stored at <em>0x00000001467FEE8D</em> (which iirc, is a CPUID), then the VM would likely end up executing a random handler since the resulting value in R13 would differ; causing undefined behaviour.</p>
<h2 id="misc">Misc</h2>
<h3 id="virtual-machine-vm">Virtual Machine (VM)</h3>
<p>I don’t know much about the virtual machine. I believe there are different types. It seems simple at times (e.g. handler table, no rolling key, etc). Perhaps in a future blog post I will discuss it? If anyone would like to chat about it, feel free to contact me ;).</p>
<h4 id="bit-vector">Bit Vector</h4>
<p>Probably my favourite thing about Denuvo is that unlike traditional VMs (e.g. VMP and Themida), Denuvo doesn’t store values in contiguous memory. Instead, they decide to store things like register values with their bytes / bits scattered everywhere. This makes it incredibly difficult to see what is going on, especially when operations are being performed on said values. This is probably the best example I can provide of Denuvo writing a value bit by bit:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span><span><span>; extract bit 0x7 of EDI</span>
</span></span><span><span><span>mov</span> eax, edi
</span></span><span><span><span>shr</span> rax, <span>0x7</span>
</span></span><span><span><span>and</span> eax, <span>0x1</span>
</span></span><span><span><span>mov</span> <span>qword</span> ptr ss:[rsp<span>+</span><span>0x48</span>], rax
</span></span><span><span>
</span></span><span><span><span>; extract bit 0x8 of EDI</span>
</span></span><span><span><span>mov</span> eax, edi
</span></span><span><span><span>shr</span> rax, <span>0x8</span>
</span></span><span><span><span>and</span> eax, <span>0x1</span>
</span></span><span><span><span>mov</span> <span>qword</span> ptr ss:[rsp<span>+</span><span>0xB0</span>], rax
</span></span><span><span>
</span></span><span><span><span>; extract bit 0x9 of EDI</span>
</span></span><span><span><span>mov</span> eax, edi
</span></span><span><span><span>shr</span> rax, <span>0x9</span>
</span></span><span><span><span>and</span> eax, <span>0x1</span>
</span></span><span><span><span>mov</span> <span>qword</span> ptr ss:[rsp<span>+</span><span>0x40</span>], rax
</span></span><span><span>
</span></span><span><span><span>; extract bit 0xC of EDI</span>
</span></span><span><span><span>mov</span> eax, edi
</span></span><span><span><span>shr</span> rax, <span>0xC</span>
</span></span><span><span><span>and</span> eax, <span>0x1</span>
</span></span><span><span><span>mov</span> <span>qword</span> ptr ss:[rsp<span>+</span><span>0xB8</span>], rax
</span></span><span><span><span>...</span>
</span></span></code></pre></div><h3 id="randomness">Randomness</h3>
<p>Randomness is a corner stone of the protection. Without it, patching checks would be extremely trivial. Unlike other protection schemes, Denuvo doesn’t utilise any API or the x86 <a href="https://www.felixcloutier.com/x86/rdrand">RDRAND</a> instruction. Instead, Denuvo opt to use values from the native registers. This is genius as the inputs are basically guaranteed to change, whether that be due to an image base relocation, or perhaps the player’s character in game lost health.</p>
<p>One method used by Denuvo, and perhaps the only, is to generate randomness based on a native game register value using modular arithmetic. Here is a real example from a Denuvo protected executable:</p>
<p><em><strong>NOTE:</strong></em> I’m unable to provide the assembly because it is extremely obfuscated and illegible, but this C demo should be sufficient.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>if</span> (VCTX[<span>0</span>] <span>%</span> <span>9</span> <span>==</span> <span>0</span>) <span>// VCTX -&gt; VM Context
</span></span></span><span><span><span></span>{
</span></span><span><span>	<span>CPUID_A</span>(); <span>// cpuid handler
</span></span></span><span><span><span></span>}
</span></span><span><span><span>else</span>
</span></span><span><span>{
</span></span><span><span>	<span>CPUID_B</span>(); <span>// cpuid handler
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>In this example, <em>CPUID_A</em> and <em>CPUID_B</em> are semantically identical. It makes no different which you decide to execute.</p>
<h3 id="mixed-boolean-arithmetic-mba">Mixed-Boolean-Arithmetic (MBA)</h3>
<p>Mixed-Boolean Arithmetic (MBA), is a method to translate expressions into a difficult to understand and analyse representation; all whilst maintaining the semantics of the original expression. Specifically, it replaces said expression with arithmetic and Boolean operations (e.g. ^, |, +, -, ~, &amp;).</p>
<h4 id="examples">Examples:</h4>
<p><strong>(1)</strong> x + y = (x &amp; y) + (x | y)</p>
<p><strong>(2)</strong> x | y = x + y + 1 + (~x | ~y)</p>
<p><strong>(3)</strong> x - y = (x ^ -y) + 2*(x &amp; -y)
= ((x ^ -y) &amp; 2*(x &amp; -y)) + ((x ^ -y) | 2*(x &amp; -y))
= ((x ^ -y) &amp; 2*(x &amp; -y)) + ((x ^ -y) + 2*(x &amp; -y) + 1 + (~(x ^ -y) | ~2*(x &amp; -y)))</p>
<p><strong>NOTE:</strong> The equivalence of these expressions can be proven via a theorem prover, such as <a href="https://github.com/Z3Prover/z3">Z3</a>.</p>
<p>If you look closely, you’ll find that to obtain <strong>(3)</strong> we simply substituted our identities for <em>x | y</em> and <em>x + y</em> into <em>x - y</em> repeatedly. This is a common and simple approach to generating MBA expressions. Other, and perhaps “better”, methods for generating MBA are out of the scope of this blog post, including linear and abstract algebra. But if you’re interested, see the following:</p>
<ul>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-540-77535-5_5">zhou2007</a></li>
<li><a href="https://arxiv.org/pdf/2209.06335">SiMBA</a></li>
<li><a href="https://plzin.github.io/posts/mba">Justus Polzin Blog</a></li>
<li><a href="https://www.usenix.org/system/files/sec21-liu-binbin.pdf">MBA-Blast</a></li>
</ul>
<p><strong>NOTE:</strong> This blog will only provide a high level understanding of concepts and ideas, but references to mentioned theorems are made for those readers that wish for the rigor.</p>
<p>With regards to Denuvo, they make great use of MBA. Namely, they exploit results due to zhou2007:</p>
<p><em><strong>(zhou2007, Theorem 2)</strong></em> Let e be a bitwise expression, then e has a non-trivial linear MBA expression.</p>
<p><em><strong>(zhou2007, Proposition 1)</strong></em> Every operation in BA-Algebra (think of this as Boolean and arithmetic operators e.g. ^, |, +, -, ~, &gt;, &lt;, &amp;, …) can be represented by a high degree polynomial MBA expression.</p>
<p><em><strong>NOTE:</strong></em> Again, the rigour has been dropped here. Read the papers described above for more information.</p>
<p>Both of these results effectively imply that we can rewrite most of our x86 instructions as MBA expressions. For instance, take the x86 instruction:</p>
<p>Rewriting:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span><span><span>; y = ((~x)&amp;(x))|y</span>
</span></span><span><span><span>push</span> rax
</span></span><span><span><span>not</span> rax
</span></span><span><span><span>and</span> <span>qword</span> ptr [rsp], rax
</span></span><span><span><span>pop</span> rax
</span></span><span><span><span>or</span> rbx
</span></span></code></pre></div><p>By zhou2007 (Theorem 2), we can apply further MBA transformations onto the BA-Algebra instructions present in the rewritten form; further complicating the expression. This example was purposefully made simple, here is some raw Denuvo VM code:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span><span><span>mov</span> r8b,<span>byte</span> ptr ds:[rcx<span>+</span><span>2</span>BA]
</span></span><span><span><span>and</span> r11d,r8d
</span></span><span><span><span>mov</span> al,<span>byte</span> ptr ds:[rcx<span>+</span><span>65</span>]
</span></span><span><span><span>shld</span> r11d,r8d,<span>18</span>
</span></span><span><span><span>lea</span> rbx,<span>qword</span> ptr ds:[rcx<span>+</span><span>2</span>BD]
</span></span><span><span><span>ror</span> r8d,<span>8</span>
</span></span><span><span><span>or</span> r8d,r11d
</span></span><span><span><span>lea</span> rbx,<span>qword</span> ptr ds:[rbx<span>+</span><span>564</span>C320C]
</span></span><span><span><span>shl</span> eax,<span>18</span>
</span></span><span><span><span>mov</span> dl,<span>byte</span> ptr ds:[rbx<span>-</span><span>564</span>C320C]
</span></span><span><span><span>ror</span> eax,<span>18</span>
</span></span><span><span><span>and</span> eax,FF
</span></span><span><span><span>rcr</span> r8d,<span>18</span>
</span></span><span><span><span>mov</span> r9b,<span>byte</span> ptr ds:[rcx<span>+</span><span>14</span>A]
</span></span><span><span><span>ror</span> edx,<span>8</span>
</span></span><span><span><span>and</span> r8d,FF
</span></span><span><span><span>sar</span> edx,<span>18</span>
</span></span><span><span><span>sub</span> ebx,ebx
</span></span><span><span><span>mov</span> r10d,FF
</span></span><span><span><span>or</span> ebx,r9d
</span></span><span><span><span>shr</span> r9d,<span>8</span>
</span></span><span><span><span>and</span> edx,FF
</span></span><span><span><span>and</span> ebx,r10d
</span></span><span><span><span>rcl</span> ebx,<span>18</span>
</span></span><span><span><span>sub</span> r10d,r10d
</span></span><span><span><span>sub</span> r11d,r11d
</span></span><span><span><span>xor</span> r9d,ebx
</span></span><span><span><span>mov</span> r10b,<span>byte</span> ptr ds:[rcx<span>+</span>AD]
</span></span><span><span><span>lea</span> rbx,<span>qword</span> ptr ds:[rcx<span>-</span><span>5</span>DF0648A]
</span></span><span><span><span>shr</span> r9d,<span>18</span>
</span></span><span><span><span>mov</span> r11b,<span>byte</span> ptr ds:[rcx<span>+</span><span>39</span>D]
</span></span><span><span><span>push</span> rsi
</span></span><span><span><span>not</span> rsi
</span></span><span><span><span>or</span> rsi,FFFFFFFFFFFFFF00
</span></span><span><span><span>and</span> <span>qword</span> ptr ss:[rsp],rsi
</span></span><span><span><span>pop</span> rsi
</span></span><span><span><span>or</span> sil,<span>byte</span> ptr ds:[rcx<span>+</span>C7]
</span></span><span><span><span>push</span> rdi
</span></span><span><span><span>not</span> rdi
</span></span><span><span><span>and</span> <span>byte</span> ptr ss:[rsp],dil
</span></span><span><span><span>pop</span> rdi
</span></span><span><span><span>rol</span> esi,<span>18</span>
</span></span><span><span><span>or</span> dil,<span>byte</span> ptr ds:[rbx<span>+</span><span>5</span>DF0669F]
</span></span><span><span><span>mov</span> dil,dil
</span></span><span><span><span>mov</span> rbx,FF
</span></span><span><span><span>shl</span> edi,<span>18</span>
</span></span><span><span><span>shr</span> edi,<span>18</span>
</span></span><span><span><span>shr</span> esi,<span>18</span>
</span></span><span><span><span>and</span> rdi,rbx
</span></span><span><span><span>pushfq</span> 
</span></span><span><span><span>push</span> r15
</span></span><span><span><span>mov</span> r15,FFFFFFFFFFFF0000
</span></span><span><span><span>shl</span> r15,<span>20</span>
</span></span><span><span><span>add</span> r15,<span>0</span>
</span></span><span><span><span>mov</span> rbx,r15
</span></span><span><span><span>pop</span> r15
</span></span><span><span><span>popfq</span> 
</span></span><span><span><span>push</span> rax
</span></span></code></pre></div><p>Not so simple anymore. Further applications of MBA include Software Watermarking and Constant Hiding, both of which can be found in zhou2007 (<em>Section 4, Protection Methods</em>). Although I’m not sure if Denuvo make use of these.</p>
<h3 id="on-the-fly-decryptedre-encrypted-cpuid">On-The-Fly Decrypted+Re-Encrypted CPUID</h3>
<p>Sometimes, as opposed to executing a bog-standard CPUID handler in the VM, Denuvo will decrypt a CPUID in the VM section, execute it, and then quickly re-encrypt it again. I imagine this is done to prevent crackers from pattern matching every CPUID instruction, although this likely wouldn’t be very helpful to the cracker. The use of real time encryption &amp; decryption has an interesting implication:</p>
<p>The VM shares handlers with different threads of execution. Therefore, what if two threads attempt to execute the same encrypted CPUID simultaneously? If it wasn’t obvious, a <a href="https://en.wikipedia.org/wiki/Spinlock">spin-lock</a> is required to prevent the threads from causing undefined behaviour. However, the spinlocks must be fast, because otherwise you’re executing already obfuscated code, and now you’re doing it in a loop. To remedy this, Denuvo opted to completely leave the main spinlock logic from any obfuscation. Therefore, crackers can pattern scan for the spin-lock, which in turns tells them where the encrypted CPUID is (more or less anyway). Denuvo’s solution to this? Encrypt the spin-lock, which requires yet another spin-lock.</p>
<p>I don’t know if they encrypt the spin-lock which monitors the encrypted spin-lock which is monitoring the encrypted CPUID instruction, but it isn’t far fetched to think so.</p>
<p>Denuvo’s spin-lock pattern:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span><span><span>push</span> r0
</span></span><span><span><span>push</span> r1
</span></span><span><span><span>mov</span> r1, <span>0x1</span>
</span></span><span><span><span>xor</span> r0, r0
</span></span><span><span>spinlock_entry:
</span></span><span><span><span>lock</span> cmpxchg <span>dword</span> ptr ds:[SPINLOCK_BOOL], r1 <span>; SPINLOCK_BOOL is a toggle byte</span>
</span></span><span><span><span>je</span> spinlock_exit
</span></span><span><span><span>pause</span>
</span></span><span><span><span>jmp</span> spinlock_entry
</span></span><span><span>spinlock_exit:
</span></span><span><span><span>pop</span> r1
</span></span><span><span><span>pop</span> r0
</span></span><span><span><span>...</span> <span>; will eventually jmp to the decrypted code</span>
</span></span></code></pre></div><h3 id="anti-exception-based-hooking">Anti-Exception-Based Hooking</h3>
<p>In the early days, Denuvo was attacked primarily by patching every hardware information check, ensuring that it returned the correct information required for the correct constant to be calculated later onwards. One method that was frequently used, was to intercept CPUID and SYSCALL instructions via an exception-based hook. Although one could nicely <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler">Register a vector exception handler</a> using the Windows API. The main approach was to instead replace each CPUID and SYSCALL instruction with a <a href="https://mudongliang.github.io/x86/html/file_module_x86_id_318.html">UD2</a> instruction, to trigger and INVALID_OPCODE_EXCEPTION, and hook KiUserExceptionDispatcher to load the correct hardware information into the correct registers when required.</p>
<p>This approach worked well, namely because both CPUID and SYSCALL are two bytes long, and so you only had to patch a single byte to hook them. However, Denuvo implemented a rather genius patch. Prior to executing the CPUID handler, Denuvo will write important values high up in “unused” stack space. Then, later on, it will retrieve this value to make important calculations that would cause undefined behaviour otherwise. This destroyed any exception-based hooking since majority of the time an exception is triggered, Windows will write an <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record">EXCEPTION_RECORD</a> high up in unused stack space. You can probably see where this is going. Now, whenever the CPUID is hooked via an exception, that important value will become overwritten with an EXCEPTION_RECORD, causing undefined behaviour later on. I believe this can be bypassed if you attach a debugger to the process and set certain flags when it comes to exception handling, but the method of patching every hardware check is still cumbersome due to randomness anyway.</p>

<h2 id="patching-hardware-id-checks">Patching Hardware ID Checks</h2>
<p>Ones first attempt at defeating this protection may be to manually patch each hardware identification check, ensuring that the correct hardware information is returned each time (“correct” here meaning the hardware that will decrypt the correct constant). However, as outlined in the sections above, this proves to be extremely difficult. Not only are you faced with complicated CRC, but also randomness that makes it close to impossible for a single person to find all the checks, let alone patch them.</p>
<h2 id="patching-constant-decryption">Patching Constant Decryption</h2>
<p>Similar to patching all hardware information checks, one could target the constant decryption routines instead, returning the correct constant as opposed to whatever was incorrectly decrypted, due to the misaligned hardware information. Furthermore, this approach is far more reasonable than patching all hardware information checks since there currently exist no CRC or randomness on these routines. However, in a trace of around 10,000,000+ x86 instructions, finding a single constant decryption is not a straightforward task.</p>
<h2 id="complete-restoration-of-binaryexe">Complete Restoration of binary.exe</h2>
<p>One can tell by the name of this approach just how difficult it would be. This would require the fix-up / devirt of potentially thousands of instructions. Despite this, I know of one instance where a Denuvo protected binary was <a href="https://i.imgur.com/6M6KBiO.png">completely restored</a> (potentially the best crack I’ve ever seen).</p>
<h2 id="hypervisor">Hypervisor</h2>
<p>A slightly more advanced approach is to utilise a hypervisor to spoof all the necessary hardware information. This is of-course easier said than done. Although, both AMD and Intel support the ability to intercept instructions such as CPUID and XGETBV, and SYSCALL hooking from a hypervisor level isn’t too difficult either. I suppose the only difficult section would be patching NTDLL and KUSER checks without breaking every other application on the computer. Actually, I’m surprised that there doesn’t already exist a peer2peer (p2p) hypervisor-based solution.</p>

<p>Denuvo is definitely a beast at what it does. It has demonstrated time and time again its ability to keep games protected for months, sometimes even years. Whether that is due to lazy crackers, or incompetency, Denuvo has clearly come out victorious. In my opinion, I don’t think Denuvo is going anywhere anytime soon.</p>

<p>Thank you to these great people for all their help:</p>
<ul>
<li>Sp********</li>
<li>Ma****</li>
<li>Mk***</li>
<li>Az****</li>
</ul>
</div></div>
  </body>
</html>
