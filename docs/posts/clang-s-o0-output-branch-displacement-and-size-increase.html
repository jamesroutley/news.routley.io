<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2024-04-27-clang-o0-output-branch-displacement-and-size-increase">Original</a>
    <h1>Clangâ€™s -O0 output: branch displacement and size increase</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <p>tl;dr Clang 19 will remove the <code>-mrelax-all</code> default at
<code>-O0</code>, significantly decreasing the text section size for
x86.</p>
<h2 id="span-dependent-instructions">Span-dependent instructions</h2>
<p>In assembly languages, some instructions with an immediate operand
can be encoded in two (or more) forms with different sizes. On x86-64, a
direct JMP/JCC can be encoded either in 2 bytes with a 8-bit relative
offset or 6 bytes with a 32-bit relative offset. A short jump is
preferred because it takes less space. However, when the target of the
jump is too far away (out of range for a 8-bit relative offset), a near
jump must be used.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>ja foo    # jump short if above, 77 &lt;rel8&gt;</span></pre></td></tr></tbody></table></figure>
<p>A 1978 paper by Thomas G. Szymanski (&#34;<em>Assembling Code for
Machines with Span-Dependent Instructions</em>&#34;) used the term
&#34;span-dependent instructions&#34; to refer to such instructions with short
and long forms. Assemblers grapple with the challenge of choosing the
optimal size for these instructions, often referred to as the &#34;branch
displacement problem&#34; since branches are the most common type. A good
resource for understanding Szymanski&#39;s work is <a target="_blank" rel="noopener" href="https://www.complang.tuwien.ac.at/anton/assembling-span-dependent.html"><em>Assembling
Span-Dependent Instructions</em></a>.</p>
<h2 id="start-small-and-grow">Start small and grow</h2>
<p>Popular assemblers still used today tend to favor a &#34;start small and
grow&#34; approach, typically requiring one more pass than Szymanski&#39;s
&#34;start big and shrink&#34; method. This approach often results in smaller
code and can handle additional complexities like alignment
directives.</p>
<p>In LLVM, the <a target="_blank" rel="noopener" href="https://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html">MC
library</a> (Machine Code) is reponsible for assembly, disassembly, and
object file formats. Within MC, &#34;assembler relaxation&#34; deals with
span-dependent instructions. This is distinct from <a href="https://maskray.me/blog/2021-03-14-the-dark-side-of-riscv-linker-relaxation">linker
relaxation</a>.</p>
<p>Eli Bendersky provides a detailed explanation in a <a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2013/01/03/assembler-relaxation">2013
blog post</a> and highlights an interesting behavior:</p>
<blockquote>
<p>For example, when compiling with -O0, the LLVM assembler simply
relaxes all jumps it encounters on first sight. This allows it to put
all instructions immediately into data fragments, which ensures there&#39;s
much fewer fragments overall, so the assembly process is faster and
consumes less memory.</p>
</blockquote>
<p>When <code>-O0</code> is enabled and the integrated assembler is used
(common by default), clangDriver passes the <code>-mrelax-all</code>
flag to the LLVM MC library. This sets the <code>MCRelaxAll</code> flag
in <code>MCTargetOptions</code>, instructing the assembler to
potentially start with the long form (near) for JMP and JCC instructions
on the X86 target only. Other instructions like ADD/SUB/CMP and non-x86
architectures remain unaffected.</p>
<h2 id="mrelax-all-tradeoff"><code>-mrelax-all</code> tradeoff</h2>
<p>Here is an example: </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>void</span> <span>foo</span><span>(<span>int</span> a)</span> {</span></pre></td></tr></tbody></table></figure>
<p>The assembly (<code>clang -S</code>) looks like: </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>foo:                                    # @foo</span></pre></td></tr></tbody></table></figure>
<p>The JE instruction assembles to either a short jump (8-bit relative
offset) or near jump (32-bit relative offset).</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span># -mrelax-all</span></pre></td></tr></tbody></table></figure>
<p>The impact of <code>-mrelax-all</code> on text section size is
significant, especially when there are many branch instructions. In an
x86-64 release build of lld, <code>-mrelax-all</code> increased the
<code>.text</code> section size by 7.9%. This translates to a 5.4%
increase in VM size and a 4.6% increase in the overall file size.</p>
<p>Dean Michael Berris proposed to <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D21830">remove the
<code>-mrelax-all</code> default for <code>-O0</code></a> in 2016, but
it stalled. <code>-mrelax-all</code> caused undesired interaction issues
with RISC-V&#39;s <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D108961">conditional
branch transforms</a>, leading Craig Topper to <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/88538">remove
<code>-mrelax-all</code></a> at <code>-O0</code> for RISC-V
recently.</p>
<p>While <code>-mrelax-all</code> might have offered slight compile time
benefits in the past, the gains are negligible today. Benchmarking using
stage 2 builds of Clang showed no measurable difference between
<code>-mrelax-all</code> and <code>-mno-relax-all</code>. On
llvm-compile-time-tracker running the llvm-test-suite/CTMark benchmark,
compile time actually <a target="_blank" rel="noopener" href="https://llvm-compile-time-tracker.com/compare.php?from=ef2ca97f48f1aee1483f0c29de5ba52979bec454&amp;to=18376810f359dbd39d2a0aa0ddfc0f7f50eac199&amp;stat=instructions%3Au">increased
slightly</a> by 0.62% while the text section size <a target="_blank" rel="noopener" href="https://llvm-compile-time-tracker.com/compare.php?from=ef2ca97f48f1aee1483f0c29de5ba52979bec454&amp;to=18376810f359dbd39d2a0aa0ddfc0f7f50eac199&amp;stat=size-text">decreased</a>
by 4.44%.</p>
<p>A difference for assembly at different optimisation levels would be
quite surprising. GCC/GNU assembler don&#39;t exhibit similar expansion of
JMP/JCC instructions even at <code>-O0</code>.</p>
<p>These arguments strengthen the case for removing
<code>-mrelax-all</code> as the default for <code>-O0</code>. <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/90013">My patch</a> has
landed and will be included in the next major release, LLVM 19.1.</p>
<h2 id="understanding-the-compile-time-difference">Understanding the
compile time difference</h2>
<p>I have studied a notorious huge file,
<code>llvm/lib/Target/X86/X86ISelLowering.cpp</code>.</p>
<p><strong>Fragment count</strong>: A significant difference exists in
the number of assembler fragments generated:</p>
<ul>
<li><code>-mrelax-all</code>: 89633</li>
<li><code>-mno-relax-all</code>: 143852</li>
</ul>
<p>With <code>-mrelax-all</code>, the number of
<code>MCRelaxableFragment</code>s is substantially reduced (to zero when
building Clang). This reduction likely contributes to the compile time
difference.</p>
<p><strong>Fixed-point iteration</strong>: <code>-mrelax-all</code>
ensures the fixed-point iteration algorithm (almost always) converges in
a single iteration. In contrast, with <code>-mno-relax-all</code>,
around 6% of sections require additional iterations. However, this
difference is likely not the primary factor affecting compile time.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>// -mrelax-all</span></pre></td></tr></tbody></table></figure>
<h2 id="why-didnt-people-complain-about-the-code-size-increase">Why
didn&#39;t people complain about the code size increase?</h2>
<p>Because people generally care less about <code>-O0</code> code
size.</p>
<p><code>-O0</code> is frequently used with <code>-g</code> to include
debugging information. This debug information can overshadow the size
increase caused by <code>-mrelax-all</code>. (<code>-O1</code> or above
sacrifices some debuggability.)</p>
<p>In addition, not all projects can be successfully built with
<code>-O0</code> optimization. This is typically due to issues like very
large programs or mandatory inlining behavior.</p>
<p>For a discussion on size reduction ideas in ELF relocatable files,
please check out my blog post about <a href="https://maskray.me/blog/2024-04-01-light-elf-exploring-potential-size-reduction">Light
ELF</a>.</p>
<hr/>
<p>You might also be interested in <a href="https://maskray.me/blog/2023-05-08-assemblers">my notes</a> about GNU assembler and
LLVM integrated assembler.</p>

      
    </div></div>
  </body>
</html>
