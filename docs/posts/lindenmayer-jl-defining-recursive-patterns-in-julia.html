<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cormullion.github.io/Lindenmayer.jl/stable/">Original</a>
    <h1>Lindenmayer.jl: Defining recursive patterns in Julia</h1>
    
    <div id="readability-page-1" class="page"><article id="documenter-page"><p>This is a simple package that can make LSystems. It uses Luxor.jl to draw them.</p><h2 id="Introduction"><a href="#Introduction">Introduction</a><a id="Introduction-1"></a><a href="#Introduction" title="Permalink"></a></h2><p>An LSystem, or Lindenmayer system, is a set of rules that can define recursive patterns.</p><p>These were introduced and developed in 1968 by Aristid Lindenmayer, a Hungarian theoretical biologist and botanist at the University of Utrecht. Lindenmayer used LSystems to describe the behaviour of plant cells and to model the growth processes of plant development. LSystems have also been used to model the morphology of a variety of organisms and can be used to generate self-similar fractals such as iterated function systems.</p><p>In Lindenmayer.jl you can define an LSystem like this:</p><pre><code>sierpinski_triangle = LSystem([
        &#34;F&#34; =&gt; &#34;G+F+Gt&#34;,
        &#34;G&#34; =&gt; &#34;F-G-F&#34;],
    &#34;G&#34;)</code></pre><p>This one has two rules, and an initial state. You can draw it using the <code>drawLSystem()</code> function.</p><p>For example:</p><pre><code>using Lindenmayer
sierpinski_triangle  = LSystem([
        &#34;F&#34; =&gt; &#34;G+F+Gt&#34;,
        &#34;G&#34; =&gt; &#34;7F-G-F&#34;
    ],
    &#34;G&#34;)

drawLSystem(sierpinski_triangle,
    forward     = 10,
    turn        = 60,
    iterations  = 6,
    startingx   = -300,
    startingy   = -300,
    filename    = :svg)</code></pre><img src="https://cormullion.github.io/Lindenmayer.jl/stable/index-b2e0fc47.svg" alt="Example block output"/><p>In Lindenmayer.jl, an LSystem consists of:</p><ul><li><p>Rules: one or more search and replace rules in a <code>Vector</code>. Each rule replaces a single-character string with a string of one or more characters</p></li><li><p>Initial state: the initial seed state for the system (sometimes called &#34;the Axiom&#34;)</p></li><li><p>State: the current evolved state (initially empty, added when the system is evaluated)</p></li></ul><p>The <code>sierpinski_triangle</code> LSystem has two rules. The first rule says replace &#34;F&#34; with &#34;G+F+Gt&#34; at every iteration. Rule 2 says replace &#34;G&#34; with &#34;F-G-F&#34; at every iteration. We start off with an initial state consisting of just a single &#34;G&#34;.</p><p>So the system State grows like this:</p><pre><code>1: G
2: (F-G-F) # after applying rule 2
3: (G+F+G)-(F-G-F)-(G+F+G) # after applying rule 1
4: (F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)
5: (G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)
6: (F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)-(G+F+G)-(F-G-F)-(G+F+G)-(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-(F-G-F)-(G+F+G)+(F-G-F)+(G+F+G)+(F-G-F)+(G+F+G)-F-G-F-(G+F+G)+F-G-F+(G+F+G)+F-G-F-(G+F+G)-F-G-F-(G+F+G)-F-G-F+(G+F+G)+F-G-F... etc.</code></pre><p>and, afer only a few iterations, the state consists of thousands of instructions.</p><h2 id="Drawing-the-LSystem"><a href="#Drawing-the-LSystem">Drawing the LSystem</a><a id="Drawing-the-LSystem-1"></a><a href="#Drawing-the-LSystem" title="Permalink"></a></h2><p>Use <code>drawLSystem()</code> to evaluate and draw the LSystem. The characters in the rule are interpreted as instructions to control a Luxor.jl turtle.</p><ul><li><p>&#34;F&#34; and &#34;G&#34; both convert to <code>Luxor.Forward()</code></p></li><li><p>&#34;+&#34; rotates the turtle clockwise</p></li><li><p>&#34;-&#34; rotates the turtle counterclockwise</p></li><li><p>&#34;5&#34; specifies a 5 pt thick line</p></li><li><p>&#34;t&#34; shifts the pen&#39;s hue color by 5¬∞</p></li></ul><p>The actual distance moved by &#34;F&#34; and &#34;G&#34; instructions, the angle of the turn, and other starting parameters, are specified when you evaluate the LSystem.</p><p>The following characters are turtle-ese, referring to existing instructions: </p><pre><code>&amp; * + - 1 2 3 4 5 6 7 8 9 @ 
B D F G O T U V [ ] 
b c f l n o q r s t</code></pre><p>You can use the remaining letters as placeholders or variables as you like. For example, the following Hilbert LSystem uses L and R, which don&#39;t do anything on their own - but they do expand to use plenty of &#34;F&#34;, &#34;+&#34;, and &#34;-&#34; rules.</p><pre><code>hilbert_curve = LSystem([
   &#34;L&#34; =&gt; &#34;+RF-LFL-FR+&#34;,
   &#34;R&#34; =&gt; &#34;-LF+RFR+FL-&#34;
   ],
   &#34;3L&#34;) # 90¬∞</code></pre><h2 id="Drawing-LSystems"><a href="#Drawing-LSystems">Drawing LSystems</a><a id="Drawing-LSystems-1"></a><a href="#Drawing-LSystems" title="Permalink"></a></h2><p>To evaluate and draw the LSystem, use <code>drawLSystem()</code>. </p><pre><code>drawLSystem(LSystem([&#34;F&#34; =&gt; &#34;5F+F--F+Ftt&#34;], &#34;F&#34;),
    startingx = -400,
    forward = 4,
    turn = 80,
    iterations = 6)</code></pre><p>Keyword options and defaults for <code>drawLSystem</code> are:</p><pre><code>forward              = 15,
turn                 = 45,
iterations           = 10,
filename             = &#34;/tmp/lsystem.png&#34;,
width                = 800,
height               = 800,
startingpen          = (0.3, 0.6, 0.8), # starting color in RGB
startingx            = 0,
startingy            = 0,
startingorientation  = 0,
backgroundcolor      = colorant&#34;black&#34;,
asteriskfunction     = (t::Turtle) -&gt; (),
showpreview          = true</code></pre><h2 id="Rules"><a href="#Rules">Rules</a><a id="Rules-1"></a><a href="#Rules" title="Permalink"></a></h2><p>The following characters are recognized in LSystem rules.</p><table><tbody><tr><th>Character in rule</th><th>Function</th></tr><tr><td>-</td><td>turn backwards by angle</td></tr><tr><td>[</td><td>push the current state on the stack</td></tr><tr><td>]</td><td>pop the current state off the stack</td></tr><tr><td>@</td><td>turn 5¬∞</td></tr><tr><td>*</td><td>execute the supplied function</td></tr><tr><td>&amp;</td><td>turn -5¬∞</td></tr><tr><td>+</td><td>turn by angle (degrees!)</td></tr><tr><td>1</td><td>set line width to 1</td></tr><tr><td>2</td><td>set line width to 2</td></tr><tr><td>3</td><td>set line width to 3</td></tr><tr><td>4</td><td>set line width to 4</td></tr><tr><td>5</td><td>set line width to 5</td></tr><tr><td>6</td><td>set line width to 6</td></tr><tr><td>7</td><td>set line width to 7</td></tr><tr><td>8</td><td>set line width to 8</td></tr><tr><td>9</td><td>set line width to 9</td></tr><tr><td>B</td><td>step backwards</td></tr><tr><td>b</td><td>turn 180¬∞ and take half a step forward</td></tr><tr><td>c</td><td>randomize the saturation</td></tr><tr><td>D</td><td>pen down (start drawing)</td></tr><tr><td>f</td><td>half a step forward</td></tr><tr><td>F</td><td>step Forward</td></tr><tr><td>G</td><td>same as F</td></tr><tr><td>l</td><td>increase the step size by 1</td></tr><tr><td>n</td><td>set line width to 0.5</td></tr><tr><td>O</td><td>choose a random opacity value</td></tr><tr><td>o</td><td>draw a circle with radius step/4</td></tr><tr><td>q</td><td>draw a square with side length step/4</td></tr><tr><td>r</td><td>turn randomly by 10¬∞ 15¬∞ 30¬∞ 45¬∞ or 60¬∞</td></tr><tr><td>s</td><td>decrease the step size by 1</td></tr><tr><td>T</td><td>change the hue at random</td></tr><tr><td>t</td><td>shift the hue by 5¬∞</td></tr><tr><td>U</td><td>lift the pen (stop drawing)</td></tr><tr><td>V</td><td>same as B</td></tr></tbody></table><h2 id="Arbitrary-functions"><a href="#Arbitrary-functions">Arbitrary functions</a><a id="Arbitrary-functions-1"></a><a href="#Arbitrary-functions" title="Permalink"></a></h2><p>You can define one external function in an LSystem. Whenever you include the <code>*</code> character in a rule, a function passed to <code>drawLSystem()</code> using the keyword option <code>asteriskfunction</code> will be called. This function accesses the Luxor turtle that&#39;s currently busy drawing the LSystem.</p><p>In the next example, a circle is drawn whenever the evaluation encounters a <code>*</code>. The advantage of using this (rather than the <code>o</code>) is that the radius of the circle can be made to vary with the distance from the center.</p><pre><code>phyllotax = LSystem([&#34;A&#34; =&gt; &#34;A+[UFD*]ll&#34;], &#34;A&#34;)

counter = 0
f(t::Turtle) = begin
   global counter
   fontsize(22)
   d = distance(O, Point(t.xpos, t.ypos))
   sethue(HSL(mod(counter, 360), 0.8, 0.5))
   circle(Point(t.xpos, t.ypos), rescale(d, 1, 200, 3, 15), :fill)
   counter += 1
end

drawLSystem(phyllotax,
   forward=65,
   turn=137.5,
   iterations=200,
   startingx=0,
   startingy=0,
   width=1000,
   height=1000,
   filename=:png,
   asteriskfunction=f
)</code></pre><img src="https://cormullion.github.io/Lindenmayer.jl/stable/index-38f9a270.png" alt="Example block output"/><p>In the next example, the asterisk function <code>f(t::Turtle)</code> passed to <code>drawLSystem()</code> is a bit disruptive. It changes the line width, sets the color, and then draws a group of rescaled pentagons at the turtle&#39;s current location and other rotationally symmetrical places. Then, it sets the opacity to 0. The turtle never realises this and never resets it (the <code>t</code> hue-shifting rule uses <code>Luxor.sethue()</code> which doesn&#39;t change the current opacity). So all the lines drawn by the turtle are completely transparent, leaving just the pentagons visible.</p><pre><code>using Lindenmayer, Luxor, Colors

recursive = LSystem([
   &#34;F&#34; =&gt; &#34;G+F+G6t&#34;,
   &#34;G&#34; =&gt; &#34;F*-G-F&#34;
    ],
   &#34;G2&#34;)

f(t::Turtle) = begin
    p = Point(t.xpos, t.ypos)
    setline(3)
    setopacity(1)
    setcolor(HSB(rand(0:359), 0.7, 0.7))
    for i in 0:4
        @layer begin
            rotate(i * deg2rad(72))
            ngon(p, rescale(distance(p, O), 1, 1000, 3, 20), 5, 0, :stroke)
        end
    end
    setopacity(0.0)
end

drawLSystem(recursive,
    forward=10,
    turn=72,
    iterations= 7,
    startingx = 0,
    startingy = 0,
    width=800,
    height=1000,
    backgroundcolor = colorant&#34;black&#34;,
    filename=:png,
    asteriskfunction = f)</code></pre><img src="https://cormullion.github.io/Lindenmayer.jl/stable/index-7f1eee89.png" alt="Example block output"/><h2 id="Custom-evaluations"><a href="#Custom-evaluations">Custom evaluations</a><a id="Custom-evaluations-1"></a><a href="#Custom-evaluations" title="Permalink"></a></h2><p><code>drawLSystem()</code> has plenty of options, but you might prefer to use an LSystem in a regular Luxor workflow. To do this, use the <code>Lindenmayer.evaluate()</code> and <code>Lindenmayer.render()</code> functions separately. </p><p>After <code>Lindenmayer.evaluate()</code> has run, the LSystem struct has all the turtle operations stored (as UInt16 integers) in the <code>.state</code> field. <code>Lindenmayer.render()</code> can convert these to Luxor turtle instructions.</p><pre><code>using Lindenmayer
using Luxor
using Colors

@drawsvg begin
   background(&#34;black&#34;)
   setlinecap(&#34;round&#34;)
   penrose = LSystem(Dict(&#34;X&#34; =&gt; &#34;PM++QM----YM[-PM----XM]++t&#34;,
         &#34;Y&#34; =&gt; &#34;+PM--QM[---XM--YM]+t&#34;,
         &#34;P&#34; =&gt; &#34;-XM++YM[+++PM++QM]-t&#34;,
         &#34;Q&#34; =&gt; &#34;--PM++++XM[+QM++++YM]--YMt&#34;,
         &#34;M&#34; =&gt; &#34;F&#34;,
         &#34;F&#34; =&gt; &#34;&#34;),
      &#34;[Y]++[Y]++[Y]++[Y]++[Y]&#34;)

   # evaluate the LSystem
   Lindenmayer.evaluate(penrose, 5)

   # create a turtle
   üê¢ = Turtle()
   Penwidth(üê¢, 5)
   Pencolor(üê¢, &#34;cyan&#34;)

   # render the LSystem&#39;s evaluation to the drawing;
   # forward step is 45
   # turn angle is 36¬∞
   Lindenmayer.render(penrose, üê¢, 45, 36)
end 800 800</code></pre><img src="https://cormullion.github.io/Lindenmayer.jl/stable/index-991a97b0.svg" alt="Example block output"/><h2 id="Debugging"><a href="#Debugging">Debugging</a><a id="Debugging-1"></a><a href="#Debugging" title="Permalink"></a></h2><p>To debug:</p><pre><code>ENV[&#34;JULIA_DEBUG&#34;] = Lindenmayer</code></pre><p>To stop debugging:</p><pre><code>ENV[&#34;JULIA_DEBUG&#34;] = nothing</code></pre><pre><code>Documentation built 2025-07-08T14:20:35.201 with Julia 1.11.5 on Linux</code></pre></article></div>
  </body>
</html>
