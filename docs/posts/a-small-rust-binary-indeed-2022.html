<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://darkcoding.net/software/a-very-small-rust-binary-indeed/">Original</a>
    <h1>A small Rust binary indeed (2022)</h1>
    
    <div id="readability-page-1" class="page"><section>
      <p><em>Updated 2022-10-30</em></p>
<p>How small can we make an x86_64 Linux Rust binary? Can it compete with a pure assembly program? Let’s find out! On the way we’ll learn things about how programs are loaded on Linux and appreciate how flexible Rust can be.</p>
<h2 id="starting-point-36-mib">Starting point: 3.6 MiB </h2>
<p>Create a project: <code>cargo new --vcs=none smallrs</code></p>
<p>Replace <code>src/main.rs</code> with the simplest possible Rust program:</p>
<pre tabindex="0"><code>fn main() {
    std::process::exit(42)
}
</code></pre><p>You might argue that this isn’t the simplest possible Rust program: <code>fn main() { }</code> would be simpler. You’d be right, but only because of what the Rust runtime is doing for you.</p>
<p>As you will know from <a href="https://amzn.to/3bLdcYg">studying your Kerrisk</a> there are only two ways a program can terminate:</p>
<ul>
<li>being killed by a signal,</li>
<li>requesting it’s own termination by calling <a href="https://man7.org/linux/man-pages/man2/exit.2.html">exit</a>.</li>
</ul>
<p>If you don’t exit the CPU will try running instructions past the end of your program, hit an invalid instruction, and kill your program.</p>
<p>Why don’t you have to do this in Rust? The default return type of <code>fn main() {}</code>, or any function that doesn’t provide a return type, is <code>()</code>. The <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">Termination trait</a> is implemented for <code>()</code>, which makes your <a href="https://github.com/rust-lang/rust/blob/2807f28de550fb6074dc4fb2f3099865de01bc1e/library/std/src/process.rs#L2152-L2157">main function default to returning SUCCESS</a>.</p>
<p>That SUCCESS return value gets picked up by the <a href="https://github.com/rust-lang/rust/blob/91ffbc43b18842594adb997c8eea8c51035bf0e1/library/std/src/rt.rs#L139">Rust runtime</a>. Something must then make the <code>exit</code> syscall with that value, either rustc or LLVM, but let’s not go <em>too</em> deep. By the time we’re done, all this machinery will be gone anyway.</p>
<p>Build that program, confirm it works, and check the size:</p>
<pre tabindex="0"><code>$ cargo build --release
   Compiling smallrs v0.1.0 (/home/graham/src/smallrs)
    Finished release [optimized] target(s) in 0.35s

$ ./target/release/smallrs
$ echo $?
42

$ ls -alh target/release/smallrs
-rwxr-xr-x 2 graham graham 3.6M Jul  1 09:10 target/release/smallrs
</code></pre><p>Three and a half megabytes! That’s not good at all. Let’s do better.</p>
<h2 id="the-biggest-gain-is-strip-300-kib">The biggest gain is strip: 300 KiB </h2>
<p>The easiest and largest gain is simply to <code>strip</code> the symbols from the binary. You can do this manually:</p>
<pre tabindex="0"><code>$ ls -alh target/release/smallrs
-rwxr-xr-x 2 graham graham 3.6M Jul  1 09:10 target/release/smallrs

$ strip target/release/smallrs

$ ls -alh target/release/smallrs
-rwxr-xr-x 2 graham graham 303K Jul  1 09:50 target/release/smallrs
</code></pre><p>or <code>cargo</code> can do it for you (which is better). Add this to your <code>Cargo.toml</code>:</p>
<pre tabindex="0"><code>[profile.release]
strip = true
</code></pre><p>You were probably going to forget to do this before release, so now you won’t. Easy win.</p>
<h2 id="easy-but-modest-gains-260-kib">Easy but modest gains: 260 KiB </h2>
<p>If you search for advice online on shrinking a Rust binary you’ll find these easy changes which aren’t particularly relevant to us here, but let’s add them anyway. In a real program they will probably help.</p>
<p>All of these go in the <code>[profile.release]</code> section of <code>Cargo.toml</code>.</p>
<p>No gain:</p>
<pre tabindex="0"><code>opt-level = &#34;z&#34;
codegen-units = 1
</code></pre><p>Small benefits:</p>
<pre tabindex="0"><code>panic = &#34;abort&#34;
lto = true
</code></pre><p>The first line simplifies panic handling and gains us about 8k. The second line enables link-time optimization, gains us about 30 KiB, but slows the build down.</p>
<p>Most projects will be use the standard library (<code>std</code>), and so will have to stop here. A final thing you can try is <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std">re-building the standard library</a>, which may allow some optimizations. Remove <code>panic = &#34;abort&#34;</code> (<a href="https://github.com/rust-lang/wg-cargo-std-aware/issues/29">because</a>) and try this:</p>
<blockquote>
<p>cargo build –release -Z build-std –target x86_64-unknown-linux-gnu</p>
</blockquote>
<p>It doesn’t help us here, and <strong>where we’re going, there are no standard libraries</strong>.</p>
<h2 id="libc-instead-of-the-standard-library-16-kib">libc instead of the standard library: 16 KiB </h2>
<p>Removing the Rust standard library (<code>std::*</code>) will get us our second biggest gain after <code>strip</code>.</p>
<p><a href="https://github.com/rust-lang/rust/blob/4e808f87ccb706d339c9ea10c3c9a9c9fd7fc6cb/library/std/src/sys/unix/os.rs#L644-L646">The std::process::exit function</a> just calls libc:</p>
<pre tabindex="0"><code>pub fn exit(code: i32) -&gt; ! {
    unsafe { libc::exit(code as c_int) }
}
</code></pre><p>Let’s drop the standard library and use libc directly. First add a dependency on <code>libc</code> in <code>Cargo.toml</code>:</p>
<pre tabindex="0"><code>[dependencies]
libc = { version = &#34;0.2&#34;, default-features = false }
</code></pre><p>Intuitively I thought this dependency would make the program <em>larger</em> but that’s not the case. The libc crate is a wrapper which contains mostly function definitions. The code itself is dynamically linked.</p>
<p>Then change <code>src/main.rs</code> to this:</p>
<pre tabindex="0"><code>#![no_std]
#![no_main]

extern crate libc;

#[no_mangle]
pub extern &#34;C&#34; fn main(_argc: i32, _argv: *const *const u8) -&gt; i32 {
	// Similar to previous version, but unneccessary:
	// unsafe { libc::exit(42) }

    42
}

#[panic_handler]
fn my_panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
</code></pre><p>We stopped using the standard library (<code>#![no_std]</code>) which forces two changes on us:</p>
<ul>
<li>Rust needs to know which function to call when something panics, and <a href="https://github.com/rust-lang/rust/blob/ef9b49881ba99248b68dbdebbebd50155587c509/library/std/src/panicking.rs#L531">the default one</a> is in the standard library so we have to provide our own.</li>
<li><code>#![no_std]</code> in a binary always seems to imply <code>#![no_main]</code>. As we’ll see in a minute programs don’t actually start at <code>main</code>. There’s a fair bit of libc and rust code between the start of the program and the normal Rust <code>fn main</code> being called. Most of that machinery is in the standard library, which we no longer have, so we have to provide an earlier entry point.</li>
</ul>
<p>What does that get us?</p>
<pre tabindex="0"><code>$ cargo build --release
   Compiling libc v0.2.126
   Compiling smallrs v0.1.0 (/home/graham/src/smallrs)
    Finished release [optimized] target(s) in 0.91s
$ ls -alh target/release/smallrs
-rwxr-xr-x 2 graham graham 16K Jul  1 10:47 target/release/smallrs
</code></pre><p>That’s a huge improvement, <strong>but is it the end? Of course not!</strong></p>
<h2 id="how-small-should-it-be-the-assembler-version-is-352-bytes">How small should it be? The assembler version is 352 bytes. </h2>
<p>Here’s the same program using <a href="https://nasm.us/">nasm</a>. Save it to <code>exit.s</code>:</p>
<pre tabindex="0"><code>section .text
global _start
_start:
        mov edi, 42  ; return code 42
        mov eax, 60  ; `_exit` syscall
        syscall
</code></pre><p>Assemble and link it:</p>
<pre tabindex="0"><code>$ nasm -f elf64 exit.s
$ ld -n -N --strip-all -o exit exit.o
</code></pre><p>Check it’s size:</p>
<pre tabindex="0"><code>$ ls -alh exit
-rwxr-xr-x 1 graham graham 352 Jul  1 10:59 exit
</code></pre><p>352 bytes! Now we’re talking! Let’s try to get closer to that.</p>
<p>Notice that there’s no <code>main</code> function in our assembly version. The first 64 bytes of a Linux binary are the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header">ELF header</a>. When Linux loads a file it looks at the <code>e_entry</code> field of that ELF header, jumps to that address and start decoding the bytes there assuming they are CPU instructions.</p>
<p>Re-link <code>exit</code> with symbols:</p>
<pre tabindex="0"><code>$ ld -n -N -o exit exit.o
</code></pre><p>Find the entry point:</p>
<pre tabindex="0"><code>$ readelf -h exit | grep &#39;Entry point&#39;
  Entry point address:               0x400080
</code></pre><p>Find the maching symbol:</p>
<pre tabindex="0"><code>$ nm exit | grep 400080
0000000000400080 T _start
</code></pre><p>That matches the <code>_start</code> symbol in our assembly. Calling it <code>_start</code> is just a convention and default, you can tell the linker to start anywhere.</p>
<p>There’s no machinery here - we jump straight to our code. By contrast in our latest Rust version there is a <code>_start</code> provided by libc (I think), which calls <code>__rt_lang_start</code>, which calls our C-style <code>main</code> function (<code>rt</code> here stands for “runtime”, C does indeed have a small runtime).</p>
<p>In the first version of our code there were many more layers because the C runtime calls the Rust runtime (<a href="https://github.com/rust-lang/rust/blob/91ffbc43b18842594adb997c8eea8c51035bf0e1/library/std/src/rt.rs#L139">all of this</a> linked earlier)) which calls our <code>main</code>.</p>
<p>In Rust can we provide our own <code>_start</code> and go straight there? I was delighted to discover <strong>you very much can</strong>.</p>
<h2 id="no-libc-either-13-kib">No libc either: 13 KiB </h2>
<p>At the very beginning I said that a program has to call <code>exit</code>, and that usually we don’t have to worry about that because the runtime takes care of it for. Well, we’re not going to have a runtime. Nothing is going to nicely wrap our <code>main</code> function and turn the return value into the program’s exit code. We’ll have to do it ourselves in assembly, using the same code as <code>exit.s</code>.</p>
<p>Remove the <code>libc</code> dependency from <code>Cargo.toml</code>. Then replace <code>src/main.rs</code> with this:</p>
<pre tabindex="0"><code>#![no_std]
#![no_main]

use core::arch::asm;

#[no_mangle]
pub extern &#34;C&#34; fn _start() -&gt; ! {
    unsafe {
        asm!(
            &#34;mov edi, 42&#34;,
            &#34;mov eax, 60&#34;,
            &#34;syscall&#34;,
            options(nostack, noreturn)
        )
        // nostack prevents `asm!` from push/pop rax
        // noreturn prevents it putting a &#39;ret&#39; at the end
        //  but it does put a ud2 (undefined instruction) instead
    }
}

#[panic_handler]
fn my_panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
</code></pre><p>We will need to tell the C compiler that we’re providing our own entry point, telling it not to include it’s own start files.</p>
<pre tabindex="0"><code>RUSTFLAGS=&#34;-Ctarget-cpu=native -Clink-args=-nostartfiles&#34; cargo build --release
</code></pre><p>Note the <code>target-cpu=native</code> is not necessary here. (Except it is! I paid for AVX-512, dammit, I expect you to use it!)</p>
<p>Let’s check how we’re doing for size:</p>
<pre tabindex="0"><code>$ ls -alh ./target/release/smallrs
-rwxr-xr-x 2 graham graham 13K Jul  1 11:52 ./target/release/smallrs
</code></pre><p>The gains are modest because the C runtime is very small.</p>
<p>We should be able to do better. The reason we can’t is that, <strong>all along, we have been the victims of a dastardly <a href="https://www.youtube.com/watch?v=z5rRZdiu1UE">sabotage</a></strong>.</p>
<h2 id="linker-flags-400-bytes">Linker flags: 400 bytes </h2>
<p>Open up <code>target/release/smallrs</code> in a hex editor (I like <a href="https://github.com/sharkdp/hexyl">hexyl</a>) and take a look. What do you see? Page and pages of zeros, that’s what!</p>
<p>The linker, in it’s wisdom, has been page-aligning the sections of our binary. The zeros fill space right before 0x1000 (4k) and 0x3000 (4k * 3). Normally this makes a lot of sense, we want our code to fit into as few 4k pages as possible; but not in this case!</p>
<p>Why didn’t this happen with our assembly version? Because I cheated, that’s why, by passing <code>ld</code> the <code>-n</code> and <code>-N</code> flags, which switch off the page aligning. Let’s do that here also:</p>
<pre tabindex="0"><code>$ RUSTFLAGS=&#34;-Ctarget-cpu=native -Clink-args=-nostartfiles -Clink-args=-Wl,-n,-N,--no-dynamic-linker&#34; cargo build --release
  Compiling smallrs v0.1.0 (/home/graham/src/smallrs)
   Finished release [optimized] target(s) in 0.24s
$ ls -alh target/release/smallrs
-rwxr-xr-x 2 graham graham 1.3K Jul  1 12:12 target/release/smallrs
</code></pre><p>Now that’s a lot better!</p>
<p>I’m not sure why I need <code>--no-dynamic-linker</code> here. Presumably the dynamic linker expects sections to be page aligned. We’re a static binary with no dependencies, so it’s not a problem.</p>
<p>Let’s compare the assembly binary to ours to find the remaining differences:</p>
<pre tabindex="0"><code>$ file target/release/smallrs
target/release/smallrs: ELF 64-bit LSB executable, x86-64, version 1 (SYSV),
static-pie linked, BuildID[sha1]=a7be8902583c68d08b22bff637461720db80a1cd, stripped

$ file ../asm-test/exit
../asm-test/exit: ELF 64-bit LSB executable, x86-64, version 1 (SYSV),
statically linked, not stripped
</code></pre><p>The <code>static-pie</code> means it’s a <a href="https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables">Position Independent Executable</a> which is a security feature to prevent a type of buffer overflow attack. It’s enabled by default basically everywhere these days. We don’t accept untrusted user input, so we’ll disable it.</p>
<p>(Aside: There might be a better way of disabling PIE than the linker flag I use. The rustc linker code mentions <code>LinkOutputKind::StaticNoPicExe</code> which I think is what we want, but I couldn’t figure out how to set that in Cargo.toml)</p>
<p>The <code>BuildID</code> is inserted by the linker to uniquely identify the file. I don’t know what it’s for, but it does not bring joy. The best argument I could find online for it was that it might help when analysing core files. Out it goes.</p>
<p>RUSTFLAGS will have:</p>
<ul>
<li>-Ctarget-cpu=native</li>
<li>-Clink-args=-nostartfiles</li>
<li>-Clink-args=-Wl,-n,-N,–no-dynamic-linker,–no-pie,–build-id=none</li>
</ul>
<p>Here is our final build command:</p>
<pre tabindex="0"><code>$ RUSTFLAGS=&#34;-Ctarget-cpu=native -Clink-args=-nostartfiles -Clink-args=-Wl,-n,-N,--no-dynamic-linker,--no-pie,--build-id=none&#34; cargo build --release
   Compiling smallrs v0.1.0 (/home/graham/src/smallrs)
    Finished release [optimized] target(s) in 0.24s

$ ls -alh target/release/smallrs
-rwxr-xr-x 2 graham graham 400 Jul  1 12:31 target/release/smallrs
</code></pre><p>Four hundred bytes!</p>
<p>The next steps would be to figure our where the extra almost 50 bytes is coming from, but I’m going to call it good enough and have lunch.</p>
<h2 id="update-bigger-programs">Update: Bigger programs </h2>
<p>That’s as far as we can go with such a simple example. In a more real-world setup we can get this far and our binary still isn’t small enough (I’m going to use <a href="https://github.com/grahamking/demeter-deploy">Demeter Deploy</a> as the example, but you don’t need it to follow along), so I’m adding some notes for reducing the size of more complex programs.</p>
<p>The most helpful activity is monitoring the binary size after every change. A quite small Rust change can pull in lots of library code and bloat the binary.</p>
<h3 id="dont-panic">Don’t panic </h3>
<p>Doing anything that can panic will pull in the panic machinery, which pulls in the voluminous print/format machinery. <a href="https://github.com/grahamking/demeter-deploy/blob/b2892473313d9769793cbfd3aa19a6c5c79fa451/seed/src/main.rs#L525">Indexing is where I noticed this</a>:</p>
<ul>
<li>BIG: <code>my_thing[idx]</code>, gives a binary of 7608 bytes.</li>
<li>SMALL: <code>my_thing.get_unchecked(idx)</code>, with that single change the binary is now 2976 bytes.</li>
</ul>
<p>This only applies if the overflow check is included. If the compiler is able to elide the size check (typically because you do it yourself: <code>if x &lt; arr.len() { arr[x] }</code>) then indexing is fine.</p>
<h3 id="avoid-fat-pointers">Avoid fat pointers </h3>
<p>A slice is a fat pointer containing the address of the backing array and it’s size. An array is just the data itself. If we can avoid storing slices it saves two <code>usize</code> (16 bytes). For example in <a href="https://github.com/grahamking/demeter-deploy/blob/0115ab369179cdbe6d155da9261d3cc36635c2a8/seed/src/main.rs#L94">this ERRS array</a> I gained about 200 bytes by using <code>&amp;[u8; 8]</code> instead of <code>&amp;[u8]</code>.</p>
<p>A <code>&amp;str</code> is also a fat pointer, also 16 bytes. By storing only the address of a null terminated string we can cut that in half, for example in <a href="https://github.com/grahamking/demeter-deploy/blob/0115ab369179cdbe6d155da9261d3cc36635c2a8/seed/src/main.rs#L66-L75">these error messages</a>.</p>
<h3 id="remove-sections">Remove sections </h3>
<p>LLVM will include more ELF sections than necessary. List these with <code>readelf -S</code>:</p>
<pre tabindex="0"><code>$ readelf -W -S target/release/seed
There are 9 section headers, starting at offset 0xa50:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000004000e8 0000e8 00050c 00 WAX  0   0  4
  [ 2] .rodata           PROGBITS        0000000000400600 000600 0001f4 00   A  0   0 16
  [ 3] .eh_frame_hdr     PROGBITS        00000000004007f4 0007f4 00001c 00   A  0   0  4
  [ 4] .eh_frame         X86_64_UNWIND   0000000000400810 000810 0000b0 00   A  0   0  8
  [ 5] .data.rel.ro      PROGBITS        00000000004008c0 0008c0 000120 00  WA  0   0  8
  [ 6] .got              PROGBITS        00000000004009e0 0009e0 000008 00  WA  0   0  8
  [ 7] .got.plt          PROGBITS        00000000004009e8 0009e8 000018 08  WA  0   0  8
  [ 8] .shstrtab         STRTAB          0000000000000000 000a00 00004c 00      0   0  1
</code></pre><p>Compared to a pure assembly version of the same program we have many more sections here. Here’s how we’re going to remove them:</p>
<ul>
<li><code>.eh_frame_hdr</code>: Loader flag <code>--no-eh-frame-hdr</code></li>
<li><code>.eh_frame</code>: Manually with <code>objcopy</code>.</li>
<li><code>.data.rel.ro</code>: cargo flag <code>-Crelocation-model=static</code></li>
<li><code>.got</code>: We need that. My guess is because Rust’s <code>core</code> lib depends on <code>memcpy</code>, <code>memset</code>, etc, so it must find those symbols (we provide them), but I’m not sure.</li>
<li><code>.got.plt</code>: Manually with <code>objcopy</code>.</li>
</ul>
<p>This gives our final final RUSTFLAGS of:</p>
<pre tabindex="0"><code>export RUSTFLAGS=&#34;-Ctarget-cpu=native -Clink-args=-nostartfiles -Crelocation-model=static -Clink-args=-Wl,-n,-N,--no-dynamic-linker,--no-pie,--build-id=none,--no-eh-frame-hdr&#34;
</code></pre><p>and a post-compile step of:</p>
<pre tabindex="0"><code>objcopy -R .eh_frame -R .got.plt target/release/my_bin my_final_bin
</code></pre><p>Note that technically the <code>.eh_frame</code> is required by the ABI. As long as we don’t have any exceptions to handle no-one will notice.</p>
<h2 id="conclusion">Conclusion </h2>
<p><strong>We went from 3.6 MiB to 400 bytes</strong>. Rust, I am impressed. This is a true systems programming language.</p>
<p>Note that even though our <code>_start</code> function here only contains a bit of assembly this is just to make a simple example. We still have access to all of the regular Rust language (including of course the borrow checker and so on) and all of <a href="https://doc.rust-lang.org/core/index.html">core</a>. That means Option, Result, time::Duration, sync::atomic, and lots more. Rust is used with no_std in embedded programming.</p>
<p>Aside from embedded, are there practical applications? Yes. I recently ported <a href="https://github.com/grahamking/demeter-deploy">Demeter Deploy</a>’s remote helper (called <code>seed</code>) from Assembly to Rust, and, wait for it, thanks to all of the above it compiles to <strong>exactly the same size</strong>. That’s incredible.</p>
<p>And because I seem to end all my recent blog posts with a link to a Happy Hardcore tune, here is what Darren Styles from old-school team Force &amp; Styles is up to these days: <a href="https://www.youtube.com/watch?v=6QYZkAdFb_Q&amp;t=206s">Darren Styles - Hard Generation</a>. You’ll need a standing desk for this one.</p>

    </section></div>
  </body>
</html>
