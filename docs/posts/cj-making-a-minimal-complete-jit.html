<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.veitheller.de/cj%3A_Making_a_minimal%2C_complete_JIT.html">Original</a>
    <h1>cj: Making a minimal, complete JIT</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>7 years ago, I had an idea for <a href="https://github.com/hellerve-pl-experiments/cj/">a JIT compiler</a>
in C for x86-64 architectures with a completely autogenerated backend
based on machine-readable information on the instructions. Sounds cool,
right?</p>
<p>I immediately built the hand-written parts of <a href="https://github.com/hellerve-pl-experiments/cj/blob/master/src/ctx.c#L54-L87">a
byte buffer I could turn into an executable function</a> and all the
infrastructure needed for two instructions, NOP and RET, the minimum I
needed to prove it worked. Then I found a JS library that <a href="https://www.npmjs.com/package/asmdb">contains the instruction
information I need</a>, covering all of the x86 ISA (thanks, <a href="https://github.com/asmjit/asmjit">asmjit</a>!). It would work with
Node.js; no problem, I can just write an emitter struct!</p>
<p>Then I abandoned the project. I got a bit of writer’s block,
priorities shifted, and I ignored the idea for a few years, until last
month. I was moving repositories around and the project was resurfaced.
I realized my writer’s block had gone and I was actually quite eager to
attack it again. So I did.</p>
<p>Over about two weeks, I reworked the project to semi-autogenerate the
x86 ISA (<a href="https://github.com/hellerve-pl-experiments/cj/blob/master/codegen/x86_encoder.js">the
code</a> is still full of warts and special cases, because I had trouble
finding the right abstraction at first and just kept going). I then
found <a href="https://github.com/alastairreid/mra_tools">mra_tools</a>,
which provides a machine-readable spec for ARM64, so I also <a href="https://github.com/hellerve-pl-experiments/cj/blob/master/codegen/arm64_encoder.js">added
a backend generator for it</a> (full disclosure: I had an LLM write the
specification extractor for me, because I couldn’t figure out the
project layout quickly and figured it would be easy enough; I also let
it write code comments for me, and they’re probably hilariously wrong).
The JS code is admittedly brutally messy, but hopefully one doesn’t have
to touch it all that much anymore (famous last words)!</p>
<p>Anyway, what we ended up with looks somewhat like this:</p>
<pre><code>// x86 version of a triangular number sum
#include &lt;stdio.h&gt;
#include &#34;ctx.h&#34;
#include &#34;op.h&#34;

int main(void) {
  cj_ctx* cj = create_cj_ctx();
  cj_operand rax = cj_make_register(&#34;rax&#34;);
  cj_operand rdi = cj_make_register(&#34;rdi&#34;);  // n (argument)
  cj_operand rcx = cj_make_register(&#34;rcx&#34;);  // loop counter
  cj_operand zero = cj_make_constant(0);
  cj_operand one = cj_make_constant(1);

  cj_mov(cj, rax, zero);         // sum = 0
  cj_mov(cj, rcx, one);          // i = 1
  cj_label loop = cj_create_label(cj);
  cj_label done = cj_create_label(cj);
  cj_mark_label(cj, loop);
  cj_cmp(cj, rcx, rdi);          // if (i &gt; n) break;
  cj_jg(cj, done);
  cj_add(cj, rax, rcx);          // sum += i;
  cj_add(cj, rcx, one);          // ++i;
  cj_jmp(cj, loop);              // loop;
  cj_mark_label(cj, done);
  cj_ret(cj);                    // result already in rax

  typedef int (*tri_fn)(int);
  tri_fn fn = (tri_fn)create_cj_fn(cj);
  printf(&#34;tri(10) = %d\n&#34;, fn(10));  // prints 55

  destroy_cj_fn(cj, (cj_fn)fn);
  destroy_cj_ctx(cj);
  return 0;
}</code></pre>
<p>Already quite good! We can basically handroll assembly at run-time,
make it generate a function, and then jump in. <a href="https://github.com/hellerve-pl-experiments/cj/tree/master/examples">Here
are some example programs</a>. What happens is that we write to a
buffer, mark it to executable using <a href="https://www.man7.org/linux/man-pages/man2/mprotect.2.html"><code>mprotect</code></a>,
and jump into it.</p>
<p>There are some limitations, however. Firstly, it’s not portable yet.
The backend is detected automatically, but the register names and most
of the instructions are still different, much like when we write
assembly. We also might have to write our own function prologues,
depending on the architecture.</p>
<p>I then decided I would at least work on a few very simple
“high-level” abstractions to also show how we could build out the JIT
compiler to allow for backend-independent code:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &#34;builder.h&#34;

typedef int (*sum_fn)(int);

int main(void) {
  cj_ctx* cj = create_cj_ctx();
  cj_builder_frame frame;
  cj_builder_fn_prologue(cj, 0, &amp;frame);

  cj_operand n = cj_builder_arg_int(cj, 0);
  cj_operand sum = cj_builder_scratch_reg(0);
  cj_operand i = cj_builder_scratch_reg(1);
  cj_operand one = cj_make_constant(1);

  cj_builder_assign(cj, sum, cj_builder_zero_operand());

  cj_builder_for_loop loop = cj_builder_for_begin(cj, i, one, n, one, CJ_COND_GE);
  cj_builder_add_assign(cj, sum, i);
  cj_builder_for_end(cj, &amp;loop);

  cj_builder_return_value(cj, &amp;frame, sum);

  sum_fn fn = (sum_fn)create_cj_fn(cj);
  printf(&#34;tri(10) = %d\n&#34;, fn ? fn(10) : -1);

  destroy_cj_fn(cj, (cj_fn)fn);
  destroy_cj_ctx(cj);
  return 0;
}</code></pre>
<p>As you can see above, the code is playing at a much higher level of
abstraction! We have for-loops and calling conventions and register
names do not concern us anymore. It’s still quite low-level: you own the
full lifecycle, and you’ll probably have to wrangle assembly for
anything non-trivial.</p>
<p>For now, I do not intend to move much further into building this out.
The concept has been more than proven, and I can already feel the
all-encompassing obsession consume me. Instead, I leave it as an
artifact to play with as-is.</p>
<p>I’m quite proud of it. It took me seven years, but in the end I
accomplished much of what I set out to do: understand the x86 ISA (and
now ARM too!) and build a JIT in the process! Even if it’s just a toy,
it’s a powerful toy, and it required a lot of fiddling to get it
(hopefully somewhat) right.</p>
<p>So, what do I intend to do with it? To be honest, I’m not quite sure
yet. I budgeted a time-boxed prototype of a simple Forth for myself to
see how language implementation in this framework would feel. From
there, we will see where things take us. If I do end up finishing the
Forth, you can look forward to another post!</p>

      
    </div></div>
  </body>
</html>
