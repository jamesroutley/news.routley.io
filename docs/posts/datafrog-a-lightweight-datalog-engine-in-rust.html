<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rust-lang/datafrog">Original</a>
    <h1>Datafrog: A lightweight Datalog engine in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Datafrog is a lightweight Datalog engine intended to be embedded in other Rust programs.</p>
<p dir="auto">Datafrog has no runtime, and relies on you to build and repeatedly apply the update rules.
It tries to help you do this correctly. As an example, here is how you might write a reachability
query using Datafrog (minus the part where we populate the <code>nodes</code> and <code>edges</code> initial relations).</p>
<div dir="auto" data-snippet-clipboard-copy-content="extern crate datafrog;
use datafrog::Iteration;

fn main() {
    // Prepare initial values, ..
    let nodes: Vec&lt;(u32,u32)&gt; = vec![
        // ..
    ];
    let edges: Vec&lt;(u32,u32)&gt; = vec![
        // ..
    ];

    // Create a new iteration context, ..
    let mut iteration = Iteration::new();

    // .. some variables, ..
    let nodes_var = iteration.variable::&lt;(u32,u32)&gt;(&#34;nodes&#34;);
    let edges_var = iteration.variable::&lt;(u32,u32)&gt;(&#34;edges&#34;);

    // .. load them with some initial values, ..
    nodes_var.insert(nodes.into());
    edges_var.insert(edges.into());

    // .. and then start iterating rules!
    while iteration.changed() {
        // nodes(a,c)  &lt;-  nodes(a,b), edges(b,c)
        nodes_var.from_join(&amp;nodes_var, &amp;edges_var, |_b, &amp;a, &amp;c| (c,a));
    }

    // extract the final results.
    let reachable: Vec&lt;(u32,u32)&gt; = nodes_var.complete();
}"><pre><span>extern</span> <span>crate</span> datafrog<span>;</span>
<span>use</span> datafrog<span>::</span><span>Iteration</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>// Prepare initial values, ..</span>
    <span>let</span> nodes<span>:</span> <span>Vec</span><span>&lt;</span><span>(</span><span>u32</span><span>,</span><span>u32</span><span>)</span><span>&gt;</span> = <span>vec</span><span>!</span><span>[</span>
        <span>// ..</span>
    <span>]</span><span>;</span>
    <span>let</span> edges<span>:</span> <span>Vec</span><span>&lt;</span><span>(</span><span>u32</span><span>,</span><span>u32</span><span>)</span><span>&gt;</span> = <span>vec</span><span>!</span><span>[</span>
        <span>// ..</span>
    <span>]</span><span>;</span>

    <span>// Create a new iteration context, ..</span>
    <span>let</span> <span>mut</span> iteration = <span>Iteration</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

    <span>// .. some variables, ..</span>
    <span>let</span> nodes_var = iteration<span>.</span><span>variable</span><span>::</span><span>&lt;</span><span>(</span><span>u32</span><span>,</span><span>u32</span><span>)</span><span>&gt;</span><span>(</span><span>&#34;nodes&#34;</span><span>)</span><span>;</span>
    <span>let</span> edges_var = iteration<span>.</span><span>variable</span><span>::</span><span>&lt;</span><span>(</span><span>u32</span><span>,</span><span>u32</span><span>)</span><span>&gt;</span><span>(</span><span>&#34;edges&#34;</span><span>)</span><span>;</span>

    <span>// .. load them with some initial values, ..</span>
    nodes_var<span>.</span><span>insert</span><span>(</span>nodes<span>.</span><span>into</span><span>(</span><span>)</span><span>)</span><span>;</span>
    edges_var<span>.</span><span>insert</span><span>(</span>edges<span>.</span><span>into</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>// .. and then start iterating rules!</span>
    <span>while</span> iteration<span>.</span><span>changed</span><span>(</span><span>)</span> <span>{</span>
        <span>// nodes(a,c)  &lt;-  nodes(a,b), edges(b,c)</span>
        nodes_var<span>.</span><span>from_join</span><span>(</span><span>&amp;</span>nodes_var<span>,</span> <span>&amp;</span>edges_var<span>,</span> |_b<span>,</span> <span>&amp;</span>a<span>,</span> <span>&amp;</span>c| <span>(</span>c<span>,</span>a<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// extract the final results.</span>
    <span>let</span> reachable<span>:</span> <span>Vec</span><span>&lt;</span><span>(</span><span>u32</span><span>,</span><span>u32</span><span>)</span><span>&gt;</span> = nodes_var<span>.</span><span>complete</span><span>(</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">If you&#39;d like to read more about how it works, check out <a href="https://github.com/frankmcsherry/blog/blob/master/posts/2018-05-19.md">this blog post</a>.</p>
<h2 dir="auto"><a id="user-content-authorship" aria-hidden="true" href="#authorship"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Authorship</h2>
<p dir="auto">Datafrog was initially developed by <a href="https://github.com/frankmcsherry">Frank McSherry</a> and was
later transferred to the rust-lang-nursery organization. Thanks Frank!</p>
</article>
          </div></div>
  </body>
</html>
