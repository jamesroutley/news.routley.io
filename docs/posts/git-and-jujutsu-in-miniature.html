<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lottia.net/notes/0013-git-jujutsu-miniature.html">Original</a>
    <h1>Git and Jujutsu: In Miniature</h1>
    
    <div id="readability-page-1" class="page"><div>
      <main>
        
        
          <p>
            <span>2024-11-09</span>
            
          </p>
        
        <section id="top">
<p>Last night in bed, I realised weâ€™d encountered a scenario at work during the day
where something happened so fluidly in jujutsu that itâ€™d make a good case story!
Letâ€™s compare, step by step, how itâ€™d look with git.</p>
<p>The stage is set: youâ€™re working on a <a href="https://radiopaedia.org">big, old, legacy codebase</a>,
and youâ€™re 10 commits deep in a branch where youâ€™re adding a new parsing
component which will, by the time the branch is merge-ready, completely supplant
an old one and all its uses.</p>
<p>The parser is mostly called through a centralised place, which is well-covered
by tests, so you can feel <em>reasonably</em> assured that green CI will mean youâ€™re
on the right track, and youâ€™ve been removing parts of the old parser as you
introduce the new.</p>
<p>But whatâ€™s this? Thereâ€™s an outlying case where a method on some random model
calls into the component directly â€” unlike most uses, itâ€™s just calling the
parser to clean up some input. And while the method is covered by a number of
tests, this particular function of it isnâ€™t at all â€” you could replace the
parser with the identity function and these tests would be fine with that.</p>
<p>So we need a new test. Weâ€™re currently in some other WIP on this branch, and the
original parser is half-taken to bits, so weâ€™ll write the tests against trunk,
called <code>develop</code> here.</p>
<pre><code><span>$</span><span> </span>jj new develop <span>-m</span> <span>&#39;content_spec: assert body_excerpt strips tokens.&#39;</span>
<span>Working copy now at: rltuvkoz 9b9f6db4 (empty) content_spec: assert body_excerpt strips tokens.
Parent commit      : xkowykqr 83ad162d develop | (empty) Merge pull request #1736 from backfill-pr
Added 10 files, modified 46 files, removed 4 files</span></code></pre>
<pre><code><span>$</span><span> </span>git checkout develop
<span>error: Your local changes to the following files would be overwritten by checkout:
        app/lib/rml_parser.rb
        spec/lib/rml_parser_spec.rb
Please commit your changes or stash them before you switch branches.
Aborting
</span><span>$</span><span> </span>git stash
<span>Saved working directory and index state WIP on (no branch): 478c7377 remove local artefacts.
</span><span>$</span><span> </span>git checkout develop
<span>Previous HEAD position was 478c7377 remove local artefacts.
Switched to branch &#39;develop&#39;
Your branch is up to date with &#39;origin/develop&#39;.</span></code></pre>
<p>Now, a seasoned git developer (with a good vcs prompt for their shell) will know
to stash reflexively, and indeed the above three commands under my aliases would
be <code>co develop</code>, <code>st</code>, <code>co develop</code>, but itâ€™s interesting that we kind of have
to context-switch for a moment here and think, â€œOK, working copy changes, maybe
some tracked, some untracked, put them all into this â€˜stashâ€™ thing over there so
we can move around freelyâ€.</p>
<p>So we write our test, confirm itâ€™s actually asserting the behaviour. Weâ€™re now here:</p>
<pre><code><span>$</span><span> </span>jj status
<span>Working copy changes:
M spec/models/content_spec.rb
Working copy : rltuvkoz e0186732 content_spec: assert body_excerpt strips tokens.
Parent commit: xkowykqr 83ad162d develop | (empty) Merge pull request #1736 from backfill-pr</span></code></pre>
<pre><code><span>$</span><span> </span>git status <span>-sb</span>
<span>## develop...origin/develop
</span><span> M spec/models/content_spec.rb</span></code></pre>
</section>
<section id="manoeuvre-jj">
<h2>The manoeuvre: jj <a href="#manoeuvre-jj" aria-hidden="true" title="Permalink to section">ğŸ”—</a> <a href="#top" aria-hidden="true" title="Back to top">â†©</a></h2>
<p>Great! We want to introduce this change into our branch, so we can be sure we
donâ€™t break this use case. We donâ€™t really want it right at the tip, since thereâ€™s a
progression of commits; we want it a few commits before.</p>
<pre><code><span>@</span>  <span>rl</span><span>tuvkoz</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:55:13</span> <span>e0</span><span>186732</span>
â”‚  <span>content_spec: assert body_excerpt strips tokens.
</span><span>â—†</span>    <span>xk</span><span>owykqr</span> <span>redacted@redacted.com</span> <span>2024-11-08 15:30:54</span> <span>develop</span> <span>git_head()</span> <span>8</span><span>3ad162d</span>
â”œâ”€â•®  (empty) Merge pull request #1736 from backfill-pr
â”‚ â”‚
â”‚ ~
â”‚
<span>~  (elided revisions)
</span>â”‚ â—‹  <span>xn</span><span>srwqok</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>ec</span><span>3df6f8</span>
â”‚ â”‚  (no description set)
â”‚ â—‹  <span>rv</span><span>umupsn</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>rml-parser*</span> <span>478</span><span>c7377</span>
â”‚ â”‚  remove local artefacts.
â”‚ â—‹  <span>pp</span><span>mltptr</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>25b</span><span>122ab</span>
â”‚ â”‚  Token: migrate uses of #token to #original_token.
â”‚ â—‹  <span>pyt</span><span>wvkmx</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>273</span><span>16b9a</span>
â”‚ â”‚  RmlParser: implementing in Token.
â”‚ â—‹  <span>nl</span><span>rsutxv</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>3e7</span><span>613e7</span>
â”‚ â”‚  RmlParser: strip_tokens.
â”‚ â—‹  <span>pyp</span><span>uqnwp</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 16:08:40</span> <span>1be</span><span>aebab</span>
â”‚ â”‚  RmlParser: blocks everywhere, include offset in bc.
â”‚ â—‹  <span>uv</span><span>mwxovu</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 15:29:14</span> <span>b0c</span><span>4bbba</span>
â”‚ â”‚  RmlParser: test roundtrip.</code></pre>
<p>Change <code>nlrsutxv</code> (commit <code>3e7613e7</code>) introduces the change weâ€™d like the test
to inform, so we want to slot the test in right before then.</p>
<pre><code><span>$</span><span> </span>jj rebase <span>-r</span> @ <span>-B</span> <span>nl</span>
<span>Rebased 1 commits onto destination
Rebased 5 descendant commits
Working copy now at: rltuvkoz 99a0a2a0 content_spec: assert body_excerpt strips tokens.
Parent commit      : pypuqnwp 1beaebab RmlParser: blocks everywhere, include offset in bc.
Added 7 files, modified 39 files, removed 8 files</span></code></pre>
<p><a href="https://martinvonz.github.io/jj/latest/cli-reference/#jj-rebase"><code>jj rebase</code></a> can rebase a â€œbranchâ€ (<code>-b</code>), a revision and its descendants
(<code>-s</code>), or just a single revision (<code>-r</code>). <code>-r @</code> means the revision currently
edited in the working copy. <code>-B</code> means â€œinsert beforeâ€.</p>
<p>The log now looks like this:</p>
<pre><code>â—‹  <span>xn</span><span>srwqok</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>cef</span><span>52288</span>
â”‚  (no description set)
â—‹  <span>rv</span><span>umupsn</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>rml-parser*</span> <span>735</span><span>abf79</span>
â”‚  remove local artefacts.
â—‹  <span>pp</span><span>mltptr</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>f34</span><span>335bf</span>
â”‚  Token: migrate uses of #token to #original_token.
â—‹  <span>pyt</span><span>wvkmx</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>0ff9</span><span>0a43</span>
â”‚  RmlParser: implementing in Token.
â—‹  <span>nl</span><span>rsutxv</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>783</span><span>90b57</span>
â”‚  RmlParser: strip_tokens.
<span>@</span>  <span>rl</span><span>tuvkoz</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>99a</span><span>0a2a0</span>
â”‚  <span>content_spec: assert body_excerpt strips tokens.
</span>â—‹  <span>pyp</span><span>uqnwp</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 16:08:40</span> <span>git_head()</span> <span>1be</span><span>aebab</span>
â”‚  RmlParser: blocks everywhere, include offset in bc.
â—‹  <span>uv</span><span>mwxovu</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 15:29:14</span> <span>b0c</span><span>4bbba</span>
â”‚  RmlParser: test roundtrip.</code></pre>
<p>We can now return to what we were doing, WIP ready for us to resume as we ever
were:</p>
<pre><code><span>$</span><span> </span>jj edit xn
<span>Working copy now at: xnsrwqok cef52288 (no description set)
Parent commit      : rvumupsn 735abf79 rml-parser* | remove local artefacts.
Added 1 files, modified 9 files, removed 6 files</span></code></pre>
<p>Note that git commit IDs have changed, as youâ€™d expect, but the jj change
IDs havenâ€™t. This stability of identity is very handy â€” <code>xn</code> was what I was
working on before I started this aside, and it still is afterwards.</p>
<p>The other side of this is the <code>rml-parser</code> bookmark â€” jjâ€™s equivalent to gitâ€™s
branches, but used far less frequently (most often for git interop) â€” has
<em>followed</em> its change, with the asterisk after noting itâ€™s diverged from the
remote one. You donâ€™t have to chase down your branches after a rebase.</p>
</section>
<section id="manoeuvre-git">
<h2>The manoeuvre: git <a href="#manoeuvre-git" aria-hidden="true" title="Permalink to section">ğŸ”—</a> <a href="#top" aria-hidden="true" title="Back to top">â†©</a></h2>
<p>How does the same play out with git? Letâ€™s look at the commit log from gitâ€™s
point of view:</p>
<pre><code>* 478c7377a4 (Fri, 8 Nov 2024) - (rml-parser) remove local artefacts. &lt;Asherah Connor&gt;
* 25b122abd8 (Fri, 8 Nov 2024) - Token: migrate uses of #token to #original_token. &lt;Asherah Connor&gt;
* 27316b9a2e (Fri, 8 Nov 2024) - RmlParser: implementing in Token. &lt;Asherah Connor&gt;
* 3e7613e704 (Fri, 8 Nov 2024) - RmlParser: strip_tokens. &lt;Asherah Connor&gt;
* 1beaebab8c (Fri, 8 Nov 2024) - RmlParser: blocks everywhere, include offset in bc. &lt;Asherah Connor&gt;
* b0c4bbbafb (Fri, 8 Nov 2024) - RmlParser: test roundtrip. &lt;Asherah Connor&gt;
</code></pre>
<p>We want to introduce our change â€” currently just an untracked change in the
working tree, with <code>develop</code> checked out â€” before commit <code>3e7613e704</code>.</p>
<p>We have two ways of getting it there:</p>
<ol>
<li>
<p>Stash the change, interactively rebase <code>rml-parser</code> and stop after the
previous commit (<code>edit 1beaebab8c</code>), pop stash, commit, continue rebase.</p>
</li>
<li>
<p>Commit the change now, interactively rebase <code>rml-parser</code> and add a <code>pick</code>
line for our new commit in the right place.</p>
</li>
</ol>
<p>I tend to commit early and often, so Iâ€™m more a fan of #2 as a rule, and
weâ€™re also already managing one item on the stash (our WIP from the tip of the
branch), and while thereâ€™s no problem with putting as much as we want on it
(itâ€™s a very competent stack!), I just donâ€™t wanna.</p>
<p>Alas, more choices:</p>
<ol>
<li>Commit to <code>develop</code>, copy the commit ID to the pasteboard, hard reset
<code>develop</code> back to its previous value.</li>
<li>Create a new branch, commit to that, delete branch when done.</li>
<li>Detach HEAD, calm your gitâ€™s nerves, itâ€™s ok I promise, commit.</li>
</ol>
<p>We donâ€™t really want <em>this</em> commit on a branch, but git really wants us to want
a branch. Letâ€™s go with purity.</p>
<pre><code><span>$</span><span> </span>git checkout <span>--detach</span>
<span>M       spec/models/content_spec.rb
HEAD is now at 83ad162d7c Merge pull request #1736 from backfill-pr
</span><span>$</span><span> </span>git add <span>-p</span>
<span>[...]
</span><span>$</span><span> </span>git commit <span>-m</span> <span>&#39;content_spec: assert body_excerpt strips tokens.&#39;</span>
<span>[detached HEAD 6005753744] content_spec: assert body_excerpt strips tokens.
 1 file changed, 8 insertions(+)</span></code></pre>
<p>Now itâ€™s time for the manoeuvre.</p>
<pre><code><span>$</span><span> </span>git checkout rml-parser
<span>Warning: you are leaving 1 commit behind, not connected to
any of your branches:

  6005753744 content_spec: assert body_excerpt strips tokens.

Switched to branch &#39;rml-parser&#39;
</span><span>$</span><span> </span>git rebase <span>-i</span> 3e7613^</code></pre>
<p>Weâ€™re presented with this:</p>
<pre><code>pick 3e7613e704 RmlParser: strip_tokens.
pick 27316b9a2e RmlParser: implementing in Token.
pick 25b122abd8 Token: migrate uses of #token to #original_token.
pick 478c7377a4 remove local artefacts.
</code></pre>
<p>Very easy: we add <code>pick 6005753744</code> above the first line, save and quit.</p>
<pre><code><span>Successfully rebased and updated refs/heads/rml-parser.</span></code></pre>
<p>Hereâ€™s our git log:</p>
<pre><code>* 7b836073ca (Fri, 8 Nov 2024) - (HEAD -&gt; rml-parser) remove local artefacts. &lt;Asherah Connor&gt;
* 70626ff5cb (Fri, 8 Nov 2024) - Token: migrate uses of #token to #original_token. &lt;Asherah Connor&gt;
* b4089df702 (Fri, 8 Nov 2024) - RmlParser: implementing in Token. &lt;Asherah Connor&gt;
* e385f17253 (Fri, 8 Nov 2024) - RmlParser: strip_tokens. &lt;Asherah Connor&gt;
* 652607c2f0 (Sat, 9 Nov 2024) - content_spec: assert body_excerpt strips tokens. &lt;Asherah Connor&gt;
* 1beaebab8c (Fri, 8 Nov 2024) - RmlParser: blocks everywhere, include offset in bc. &lt;Asherah Connor&gt;
* b0c4bbbafb (Fri, 8 Nov 2024) - RmlParser: test roundtrip. &lt;Asherah Connor&gt;
</code></pre>
<p>Donâ€™t forget to pop the stash!</p>
<pre><code><span>$</span><span> </span>git stash pop
<span>On branch rml-parser
Changes to be committed:
  (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
        new file:   app/lib/rml_parser_flux.rb

Changes not staged for commit:
  (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)
  (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory)
        modified:   app/lib/rml_parser.rb
        modified:   spec/lib/rml_parser_spec.rb

Dropped refs/stash@{0} (d5c281196fa218a33a55538111fa7770284ca2cb)</span></code></pre>
<p>Damn. I forgot to supply <code>--index</code>, and only new files (which were tracked
at the time of <code>stash</code>) are added to the index; all other stashed changes are
restored into the working copy, but not into the index. Oh well, itâ€™s git: I can
just go again with the stash reference from the last line.</p>
</section>



      </main>
      
    </div></div>
  </body>
</html>
