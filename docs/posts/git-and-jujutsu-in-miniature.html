<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lottia.net/notes/0013-git-jujutsu-miniature.html">Original</a>
    <h1>Git and Jujutsu: In Miniature</h1>
    
    <div id="readability-page-1" class="page"><div>
      <main>
        
        
          <p>
            <span>2024-11-09</span>
            
          </p>
        
        <section id="top">
<p>Last night in bed, I realised we’d encountered a scenario at work during the day
where something happened so fluidly in jujutsu that it’d make a good case story!
Let’s compare, step by step, how it’d look with git.</p>
<p>The stage is set: you’re working on a <a href="https://radiopaedia.org">big, old, legacy codebase</a>,
and you’re 10 commits deep in a branch where you’re adding a new parsing
component which will, by the time the branch is merge-ready, completely supplant
an old one and all its uses.</p>
<p>The parser is mostly called through a centralised place, which is well-covered
by tests, so you can feel <em>reasonably</em> assured that green CI will mean you’re
on the right track, and you’ve been removing parts of the old parser as you
introduce the new.</p>
<p>But what’s this? There’s an outlying case where a method on some random model
calls into the component directly — unlike most uses, it’s just calling the
parser to clean up some input. And while the method is covered by a number of
tests, this particular function of it isn’t at all — you could replace the
parser with the identity function and these tests would be fine with that.</p>
<p>So we need a new test. We’re currently in some other WIP on this branch, and the
original parser is half-taken to bits, so we’ll write the tests against trunk,
called <code>develop</code> here.</p>
<pre><code><span>$</span><span> </span>jj new develop <span>-m</span> <span>&#39;content_spec: assert body_excerpt strips tokens.&#39;</span>
<span>Working copy now at: rltuvkoz 9b9f6db4 (empty) content_spec: assert body_excerpt strips tokens.
Parent commit      : xkowykqr 83ad162d develop | (empty) Merge pull request #1736 from backfill-pr
Added 10 files, modified 46 files, removed 4 files</span></code></pre>
<pre><code><span>$</span><span> </span>git checkout develop
<span>error: Your local changes to the following files would be overwritten by checkout:
        app/lib/rml_parser.rb
        spec/lib/rml_parser_spec.rb
Please commit your changes or stash them before you switch branches.
Aborting
</span><span>$</span><span> </span>git stash
<span>Saved working directory and index state WIP on (no branch): 478c7377 remove local artefacts.
</span><span>$</span><span> </span>git checkout develop
<span>Previous HEAD position was 478c7377 remove local artefacts.
Switched to branch &#39;develop&#39;
Your branch is up to date with &#39;origin/develop&#39;.</span></code></pre>
<p>Now, a seasoned git developer (with a good vcs prompt for their shell) will know
to stash reflexively, and indeed the above three commands under my aliases would
be <code>co develop</code>, <code>st</code>, <code>co develop</code>, but it’s interesting that we kind of have
to context-switch for a moment here and think, “OK, working copy changes, maybe
some tracked, some untracked, put them all into this ‘stash’ thing over there so
we can move around freely”.</p>
<p>So we write our test, confirm it’s actually asserting the behaviour. We’re now here:</p>
<pre><code><span>$</span><span> </span>jj status
<span>Working copy changes:
M spec/models/content_spec.rb
Working copy : rltuvkoz e0186732 content_spec: assert body_excerpt strips tokens.
Parent commit: xkowykqr 83ad162d develop | (empty) Merge pull request #1736 from backfill-pr</span></code></pre>
<pre><code><span>$</span><span> </span>git status <span>-sb</span>
<span>## develop...origin/develop
</span><span> M spec/models/content_spec.rb</span></code></pre>
</section>
<section id="manoeuvre-jj">
<h2>The manoeuvre: jj <a href="#manoeuvre-jj" aria-hidden="true" title="Permalink to section">🔗</a> <a href="#top" aria-hidden="true" title="Back to top">↩</a></h2>
<p>Great! We want to introduce this change into our branch, so we can be sure we
don’t break this use case. We don’t really want it right at the tip, since there’s a
progression of commits; we want it a few commits before.</p>
<pre><code><span>@</span>  <span>rl</span><span>tuvkoz</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:55:13</span> <span>e0</span><span>186732</span>
│  <span>content_spec: assert body_excerpt strips tokens.
</span><span>◆</span>    <span>xk</span><span>owykqr</span> <span>redacted@redacted.com</span> <span>2024-11-08 15:30:54</span> <span>develop</span> <span>git_head()</span> <span>8</span><span>3ad162d</span>
├─╮  (empty) Merge pull request #1736 from backfill-pr
│ │
│ ~
│
<span>~  (elided revisions)
</span>│ ○  <span>xn</span><span>srwqok</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>ec</span><span>3df6f8</span>
│ │  (no description set)
│ ○  <span>rv</span><span>umupsn</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>rml-parser*</span> <span>478</span><span>c7377</span>
│ │  remove local artefacts.
│ ○  <span>pp</span><span>mltptr</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>25b</span><span>122ab</span>
│ │  Token: migrate uses of #token to #original_token.
│ ○  <span>pyt</span><span>wvkmx</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>273</span><span>16b9a</span>
│ │  RmlParser: implementing in Token.
│ ○  <span>nl</span><span>rsutxv</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 11:54:38</span> <span>3e7</span><span>613e7</span>
│ │  RmlParser: strip_tokens.
│ ○  <span>pyp</span><span>uqnwp</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 16:08:40</span> <span>1be</span><span>aebab</span>
│ │  RmlParser: blocks everywhere, include offset in bc.
│ ○  <span>uv</span><span>mwxovu</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 15:29:14</span> <span>b0c</span><span>4bbba</span>
│ │  RmlParser: test roundtrip.</code></pre>
<p>Change <code>nlrsutxv</code> (commit <code>3e7613e7</code>) introduces the change we’d like the test
to inform, so we want to slot the test in right before then.</p>
<pre><code><span>$</span><span> </span>jj rebase <span>-r</span> @ <span>-B</span> <span>nl</span>
<span>Rebased 1 commits onto destination
Rebased 5 descendant commits
Working copy now at: rltuvkoz 99a0a2a0 content_spec: assert body_excerpt strips tokens.
Parent commit      : pypuqnwp 1beaebab RmlParser: blocks everywhere, include offset in bc.
Added 7 files, modified 39 files, removed 8 files</span></code></pre>
<p><a href="https://martinvonz.github.io/jj/latest/cli-reference/#jj-rebase"><code>jj rebase</code></a> can rebase a “branch” (<code>-b</code>), a revision and its descendants
(<code>-s</code>), or just a single revision (<code>-r</code>). <code>-r @</code> means the revision currently
edited in the working copy. <code>-B</code> means “insert before”.</p>
<p>The log now looks like this:</p>
<pre><code>○  <span>xn</span><span>srwqok</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>cef</span><span>52288</span>
│  (no description set)
○  <span>rv</span><span>umupsn</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>rml-parser*</span> <span>735</span><span>abf79</span>
│  remove local artefacts.
○  <span>pp</span><span>mltptr</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>f34</span><span>335bf</span>
│  Token: migrate uses of #token to #original_token.
○  <span>pyt</span><span>wvkmx</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>0ff9</span><span>0a43</span>
│  RmlParser: implementing in Token.
○  <span>nl</span><span>rsutxv</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>783</span><span>90b57</span>
│  RmlParser: strip_tokens.
<span>@</span>  <span>rl</span><span>tuvkoz</span> <span>ashe@kivikakk.ee</span> <span>2024-11-09 12:02:07</span> <span>99a</span><span>0a2a0</span>
│  <span>content_spec: assert body_excerpt strips tokens.
</span>○  <span>pyp</span><span>uqnwp</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 16:08:40</span> <span>git_head()</span> <span>1be</span><span>aebab</span>
│  RmlParser: blocks everywhere, include offset in bc.
○  <span>uv</span><span>mwxovu</span> <span>ashe@kivikakk.ee</span> <span>2024-11-08 15:29:14</span> <span>b0c</span><span>4bbba</span>
│  RmlParser: test roundtrip.</code></pre>
<p>We can now return to what we were doing, WIP ready for us to resume as we ever
were:</p>
<pre><code><span>$</span><span> </span>jj edit xn
<span>Working copy now at: xnsrwqok cef52288 (no description set)
Parent commit      : rvumupsn 735abf79 rml-parser* | remove local artefacts.
Added 1 files, modified 9 files, removed 6 files</span></code></pre>
<p>Note that git commit IDs have changed, as you’d expect, but the jj change
IDs haven’t. This stability of identity is very handy — <code>xn</code> was what I was
working on before I started this aside, and it still is afterwards.</p>
<p>The other side of this is the <code>rml-parser</code> bookmark — jj’s equivalent to git’s
branches, but used far less frequently (most often for git interop) — has
<em>followed</em> its change, with the asterisk after noting it’s diverged from the
remote one. You don’t have to chase down your branches after a rebase.</p>
</section>
<section id="manoeuvre-git">
<h2>The manoeuvre: git <a href="#manoeuvre-git" aria-hidden="true" title="Permalink to section">🔗</a> <a href="#top" aria-hidden="true" title="Back to top">↩</a></h2>
<p>How does the same play out with git? Let’s look at the commit log from git’s
point of view:</p>
<pre><code>* 478c7377a4 (Fri, 8 Nov 2024) - (rml-parser) remove local artefacts. &lt;Asherah Connor&gt;
* 25b122abd8 (Fri, 8 Nov 2024) - Token: migrate uses of #token to #original_token. &lt;Asherah Connor&gt;
* 27316b9a2e (Fri, 8 Nov 2024) - RmlParser: implementing in Token. &lt;Asherah Connor&gt;
* 3e7613e704 (Fri, 8 Nov 2024) - RmlParser: strip_tokens. &lt;Asherah Connor&gt;
* 1beaebab8c (Fri, 8 Nov 2024) - RmlParser: blocks everywhere, include offset in bc. &lt;Asherah Connor&gt;
* b0c4bbbafb (Fri, 8 Nov 2024) - RmlParser: test roundtrip. &lt;Asherah Connor&gt;
</code></pre>
<p>We want to introduce our change — currently just an untracked change in the
working tree, with <code>develop</code> checked out — before commit <code>3e7613e704</code>.</p>
<p>We have two ways of getting it there:</p>
<ol>
<li>
<p>Stash the change, interactively rebase <code>rml-parser</code> and stop after the
previous commit (<code>edit 1beaebab8c</code>), pop stash, commit, continue rebase.</p>
</li>
<li>
<p>Commit the change now, interactively rebase <code>rml-parser</code> and add a <code>pick</code>
line for our new commit in the right place.</p>
</li>
</ol>
<p>I tend to commit early and often, so I’m more a fan of #2 as a rule, and
we’re also already managing one item on the stash (our WIP from the tip of the
branch), and while there’s no problem with putting as much as we want on it
(it’s a very competent stack!), I just don’t wanna.</p>
<p>Alas, more choices:</p>
<ol>
<li>Commit to <code>develop</code>, copy the commit ID to the pasteboard, hard reset
<code>develop</code> back to its previous value.</li>
<li>Create a new branch, commit to that, delete branch when done.</li>
<li>Detach HEAD, calm your git’s nerves, it’s ok I promise, commit.</li>
</ol>
<p>We don’t really want <em>this</em> commit on a branch, but git really wants us to want
a branch. Let’s go with purity.</p>
<pre><code><span>$</span><span> </span>git checkout <span>--detach</span>
<span>M       spec/models/content_spec.rb
HEAD is now at 83ad162d7c Merge pull request #1736 from backfill-pr
</span><span>$</span><span> </span>git add <span>-p</span>
<span>[...]
</span><span>$</span><span> </span>git commit <span>-m</span> <span>&#39;content_spec: assert body_excerpt strips tokens.&#39;</span>
<span>[detached HEAD 6005753744] content_spec: assert body_excerpt strips tokens.
 1 file changed, 8 insertions(+)</span></code></pre>
<p>Now it’s time for the manoeuvre.</p>
<pre><code><span>$</span><span> </span>git checkout rml-parser
<span>Warning: you are leaving 1 commit behind, not connected to
any of your branches:

  6005753744 content_spec: assert body_excerpt strips tokens.

Switched to branch &#39;rml-parser&#39;
</span><span>$</span><span> </span>git rebase <span>-i</span> 3e7613^</code></pre>
<p>We’re presented with this:</p>
<pre><code>pick 3e7613e704 RmlParser: strip_tokens.
pick 27316b9a2e RmlParser: implementing in Token.
pick 25b122abd8 Token: migrate uses of #token to #original_token.
pick 478c7377a4 remove local artefacts.
</code></pre>
<p>Very easy: we add <code>pick 6005753744</code> above the first line, save and quit.</p>
<pre><code><span>Successfully rebased and updated refs/heads/rml-parser.</span></code></pre>
<p>Here’s our git log:</p>
<pre><code>* 7b836073ca (Fri, 8 Nov 2024) - (HEAD -&gt; rml-parser) remove local artefacts. &lt;Asherah Connor&gt;
* 70626ff5cb (Fri, 8 Nov 2024) - Token: migrate uses of #token to #original_token. &lt;Asherah Connor&gt;
* b4089df702 (Fri, 8 Nov 2024) - RmlParser: implementing in Token. &lt;Asherah Connor&gt;
* e385f17253 (Fri, 8 Nov 2024) - RmlParser: strip_tokens. &lt;Asherah Connor&gt;
* 652607c2f0 (Sat, 9 Nov 2024) - content_spec: assert body_excerpt strips tokens. &lt;Asherah Connor&gt;
* 1beaebab8c (Fri, 8 Nov 2024) - RmlParser: blocks everywhere, include offset in bc. &lt;Asherah Connor&gt;
* b0c4bbbafb (Fri, 8 Nov 2024) - RmlParser: test roundtrip. &lt;Asherah Connor&gt;
</code></pre>
<p>Don’t forget to pop the stash!</p>
<pre><code><span>$</span><span> </span>git stash pop
<span>On branch rml-parser
Changes to be committed:
  (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
        new file:   app/lib/rml_parser_flux.rb

Changes not staged for commit:
  (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)
  (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory)
        modified:   app/lib/rml_parser.rb
        modified:   spec/lib/rml_parser_spec.rb

Dropped refs/stash@{0} (d5c281196fa218a33a55538111fa7770284ca2cb)</span></code></pre>
<p>Damn. I forgot to supply <code>--index</code>, and only new files (which were tracked
at the time of <code>stash</code>) are added to the index; all other stashed changes are
restored into the working copy, but not into the index. Oh well, it’s git: I can
just go again with the stash reference from the last line.</p>
</section>



      </main>
      
    </div></div>
  </body>
</html>
