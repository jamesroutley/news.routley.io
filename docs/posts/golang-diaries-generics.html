<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tbray.org/ongoing/When/202x/2022/05/14/Golang-Generics">Original</a>
    <h1>Golang Diaries: Generics</h1>
    
    <div id="readability-page-1" class="page"><div id="centercontent">
<p itemprop="description">My coding time this year has been invested in
    <a href="https://www.tbray.org/ongoing/When/202x/2022/05/12/Quamina">Quamina</a>, an event-filtering library implemented in Go.  Just in the last couple
    of weeks I spotted an opportunity to bring Go’s shiny new generics to bear, and not just anywhere, but for a central data
    structure. I got good results, but the process was sort of painful; I kept trying things that looked like they ought to work but
    didn’t. I’m sharing this tour through that experience because I’m a reasonably competent programmer with mainstream tastes
    and if I hit these bumps in the road others probably will too.</p>

<p>[The title of this piece suggests it’s a continuation of two
    <a href="https://www.tbray.org/ongoing/When/201x/2013/07/15/Golang-Diaries-2">Golang Diaries</a> entries I wrote back in 2013
    when I was first discovering the language. Why not? I have at least one more in mind.]</p>

<p id="p-1"><span>Why generics?</span> · 
Quamina is all about building and running finite automata. To do this you
    need a table-like data structure that represents states and the transitions between them. Quamina uses both deterministic and
    non-deterministic finite automata, DFAs and NFAs for short. The only real difference is that a transition from a DFA
    state is always to one other state; in an NFA you can have transitions to multiple others, in practice to a list of states.</p>

<p>I noticed that the NFA and DFA tables were almost identical, as was the code that that built them and stepped through them
    while matching. I had recently read
    <a href="https://go.dev/blog/when-generics">When To Use Generics</a> on the Go Blog, which has sections entitled:</p>

<ul>
<li><p><cite>When using
      language-defined container types,</cite></p>
</li>
<li><p><cite>General purpose data structures</cite>, and</p>
</li>
<li><p><cite>Implementing a common
      method</cite>.</p>
</li>
</ul>
<p>Check, check, and check. Then in the final section, <cite>One simple guideline</cite>, it says “If you find yourself writing
    the exact same code multiple times, where the only difference between the copies is that the code uses different types, consider
    whether you can use a type parameter.” Check.  So, off I went. Later that week it was all working.  But along the way I yelled
    at the computer more than I’d have expected.</p>

<p>I don’t recommend diving into the Quamina source at this point, there’s too much else to explain. So…</p>

<p id="p-2"><span>Back to basics</span> · 
To help illustrate my bumpy road, I made a toy GitHub project with a file called
    <a href="https://github.com/timbray/go-generics/blob/main/typing.go">typing.go</a>.  It defines a genericized container type:</p>

<div><pre><span>type</span> <span>container</span>[<span>S</span> <span>comparable</span>] <span>struct</span> {
  <span>label</span> <span>string</span>
  <span>list</span>  []<span>S</span>
}
</pre>    
    </div>
    <p>And one associated function:</p>

    <div><pre><span>func</span> (<span>c</span> <span>*</span><span>container</span>[<span>S</span>]<span></span>) <span>size</span>() <span>int</span> {
  <span>return</span> <span>len</span>(<span>c</span>.<span>list</span>)
}
</pre></div>
    <p>Now I’m going to define a boring struct type:</p>

    <div><pre><span>type</span> <span>fish</span> <span>struct</span> {
  <span>species</span> <span>string</span>
}</pre></div>
    <p id="p-5"><span>Strong typing oops</span> · 
    Here’s where things started going off the rails. I offered the following and neither the IDE nor the compiler complained:</p>

    <div><pre><span>type</span> <span>fishTank</span> <span>container</span>[<span>fish</span>]
</pre></div>
    <p>“Wow”, I told myself, “now I have a strongly-typed container, so I can write nice clean code without any generics cruft!”  On that
    basis, I defined another function:</p>

    <div><pre><span>func</span> (<span>t</span> <span>*</span><span>fishTank</span>) <span>fishCount</span>() <span>string</span> {
  <span>return</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;How many fishies? %d!&#34;</span>, <span>t</span>.<span>size</span>())
}</pre></div>
    <p>Ouch! The Goland IDE said <code>Unresolved reference &#39;size&#39;</code> and the compiler (via <code>go build</code>) said
    <code>t.size undefined (type *fishTank has no field or method size)</code>.</p>

    <p>It seems to me like <code>fishTank</code> should have a <code>size()</code> method?  After all, it’s a
    <code>container</code>, and the compiler seemed to be OK with me saying so, and container has <code>size()</code>.</p>

    <blockquote><p><b>Note:</b> Dear reader, as I proceed through this narrative, if you are Go-erudite it will doubtless occur to
    you that:</p>

    <ol>
      <li><p>There’s a better (and supported) way to do what I’m trying to do.</p>
</li>
      <li><p>I shouldn’t want to do what I’m trying to do.</p>
</li>
    </ol>
    <p>I welcome the first type of remark; one goal of writing this piece is to provoke them. As for the second, I really don’t
    care what what you think I should want.  As I said above, my hypothesis is that enough others will also want to do this type of
    thing that the issue’s worth addressing.</p>
</blockquote>
    <p id="p-6"><span>Fat fish</span> · 
    Let’s enrich that <code>fish</code> type a bit:</p>

    <div><pre><span>type</span> <span>dataRichFish</span> <span>struct</span> {
  <span>species</span> <span>string</span>
  <span>datum</span>   [<span>8</span>]<span>float64</span>
}
</pre></div>   
    <p>Now, suppose this: First of all, not all fish have that <code>datum</code> material available. Second, this app goes into
    production and we start to track a whole lot of fish, millions and millions. And people start yelling at us to use less memory.
    Well, Go’s <code>interface</code> mechanism should make this easy:</p>

    <div><pre><span>type</span> <span>flexibleFish</span> <span>interface</span> {
  <span>getSpecies</span>() <span>string</span>
  <span>getDatum</span>()   [<span>8</span>]<span>float64</span>
}
<span>func</span> (<span>f</span> <span>*</span><span>dataRichFish</span>) <span>getSpecies</span>() <span>string</span> {
  <span>return</span> <span>f</span>.<span>species</span>
}  
<span>func</span> (<span>f</span> <span>*</span><span>dataRichFish</span>) <span>getDatum</span>() [<span>8</span>]<span>float64</span> {
  <span>return</span> <span>f</span>.<span>datum</span>
}

<span>var</span> <span>dataNotProvided</span> [<span>8</span>]<span>float64</span>
<span>type</span> <span>stingyFish</span> <span>struct</span> {
  <span>species</span> <span>string</span>
}
<span>func</span> (<span>f</span> <span>*</span><span>stingyFish</span>) <span>getSpecies</span>() <span>string</span> {
  <span>return</span> <span>f</span>.<span>species</span>  
}
<span>func</span> (<span>f</span> <span>*</span><span>stingyFish</span>) <span>getDatum</span>() [<span>8</span>]<span>float64</span> {
  <span>return</span> <span>dataNotProvided</span>
}
</pre></div>
    <p>See how it works?  A <code>flexibleFish</code> can either have an attached <code>datum</code> or not and if it doesn’t, it
    signals the absence by returning the static global <code>dataNotProvided</code>.</p>

    <p>Now let’s put those <code>flexibleFish</code> in the tank…</p>

    <div><pre><span>type</span> <span>flexibleTank</span> <span>container</span>[<span>flexibleFish</span>]</pre></div>
    <p>Ouch! Quoth the compiler: <code>flexibleFish does not implement comparable</code>.</p>


    <p>So interfaces aren’t <code>comparable</code>?  Hmm, but I can <code>make(map[interface{}]int)</code> and don’t you have to be <code>comparable</code> to
    be a map key?  I guess an interface could be implemented by something whose type was <code>[]int</code>, which isn’t <code>comparable</code>.
    OK, the shallowness of my understanding is showing here.</p>

    <p>But, suppose there was a way to promise that a type was <code>comparable</code>.  It looks like there is, at least in Go
    1.18.  Let’s try it.</p>
 
    <div><pre><span>type</span> <span>comparableFlexibleFish</span> <span>interface</span> {
  comparable
  <span>getSpecies</span>() <span>string</span>
  <span>getDatum</span>()   [<span>8</span>]<span>float64</span>
}</pre></div>
    <p>The compiler seems to be OK with that. So, one last step…</p>

    <div><pre><span>type</span> <span>comparableFlexibleFishTank</span> <span>container</span>[<span>comparableFlexibleFish</span>]
</pre></div>
    <p>Ouch! Goland: <code>interface includes constraint elements, can only be used in type parameters</code>. Compiler:
    <code>interface is (or embeds) comparable</code>. I understand them about equally well.
    <i>[Narrator: He’s equally baffled.]</i></p>

    <p>I guess I am skating pretty far outside the lines here?  But I think the intent of that <code>comparable</code> in the
    type declaration is perfectly clear. This thing implements the listed methods and promises to be <code>comparable</code>.  So if
    I try to claim something is a <code>comparableFlexibleFish</code> and it’s
    implemented the right methods but isn’t <code>comparable</code>, the compiler can stop me with a helpful error.</p>

    <p>Once again, maybe I shouldn’t want to do these things, but I do.</p>

    <p id="p-8"><span>Take-aways</span> · 
    The performance was great, no detectable slowdown.
    [Note this is 
    <a href="https://planetscale.com/blog/generics-can-make-your-go-code-slower">not always true</a> and if you care, you should
    really follow that link. But get a large cup of coffee first.]</p>

    <p>And I threw away a whole bunch of duplicative code, which made me happy.</p>

    <p>When generics arrived in Java, I hated them. I thought the ratio of pain removed to complexity added was way too low.
    I don’t hate Go’s generics, which is actually pretty strong testimony given that I spent the best part of a couple of days
    fighting all the stuff described above.</p>

    <p>But, my guess is the Go generics story is isn’t finished yet.</p>


  <hr/>


<hr/>

</div></div>
  </body>
</html>
