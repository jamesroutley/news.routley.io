<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://viralinstruction.com/posts/mojo/">Original</a>
    <h1>A look at the Mojo language for bioinformatics</h1>
    
    <div id="readability-page-1" class="page"><div> <p><em>Written 2024-02-09</em></p> <p>A few days ago, <a href="https://www.modular.com/blog/outperforming-rust-benchmarks-with-mojo">a blog post</a> was posted on the website of <a href="https://www.modular.com/blog/outperforming-rust-benchmarks-with-mojo">Modular</a>, the company behind the new high-performance programming language <a href="https://www.modular.com/max/mojo">Mojo</a>.</p> <p>The post made the case for using Mojo in bioinformatics due to Mojo&#39;s dual features of being high-level language with high performance, and the blog author substantiated the case by presenting two benchmarks related to the processing of <a href="https://en.wikipedia.org/wiki/FASTQ_format">FASTQ files</a>, showing impressive speed.</p> <p>As a bioinformatician who is obsessed with high-performance, high-level programming, that&#39;s right in my wheelhouse! I decided to dig deeper into the benchmark, and this post is about what I found out.</p>   <h2 id="whats_the_blog_post_on_about"><a href="#whats_the_blog_post_on_about">What&#39;s the blog post on about?</a></h2> <p>The basic premise of the post is that the field of bioinformatics is struggling to handle its increasingly large datasets. These datasets are so large that they have to be processed programmatically, but programming is the field is split between high-level dynamic languages used to do the actual data analysis, and the high-performance, static languages that Python calls into to do the computation underlying the analysis. As the post states:</p> <blockquote> <p>This creates a two-world problem where bioinformaticians who are not skilled in low-level languages, are prohibited from understanding, customizing, and implementing low-level operations.</p> </blockquote> <p>The blog post goes on to suggest Mojo could bridge the gap between the two worlds, by being a &#34;Pythonic&#34;, but fast language.</p> <p>I have a lot more to say on the topic of the two-language problem in bioinformatics, so much that I&#39;ll reserve it for another blog post. In summary, I wholeheartedly agree with that analysis, except that I&#39;d encourage using Julia rather than Mojo.</p> <p>The post then describes how the author implemented a benchmark in Mojo and managed to beat a fairly optimised Rust library. That certainly made me curious, so I cloned <a href="https://github.com/MoSafi2/MojoFastTrim">the git repo with the Mojo code</a><sup id="fnref:1"><a href="#fndef:1">[1]</a></sup> and took a look myself.</p> <h2 id="on_mojo"><a href="#on_mojo">On Mojo</a></h2> <p>After cloning the repo, the first step is to download and install Mojo:</p> <div><pre><code>$ curl https://get.modular.com | sh - &amp;&amp; \
modular auth [MY AUTHENTICATION CODE]
[...]
Sorry, this system is not recognized. Please visit https://www.modular.com/mojo to learn about supported platforms. You can also build and run a Mojo container by following instructions at https://github.com/modularml/mojo</code></pre></div> <p>Well, that&#39;s disappointing. Apparently, Mojo currently only runs on Ubuntu and MacOS, and I run neither. So, I can&#39;t <em>run</em> any Mojo code, but must rely on just <em>reading</em> the code. Fortunately, the code is quite simple, and only a few hundred lines of code.</p> <h3 id="first_impressions"><a href="#first_impressions">First impressions</a></h3> <p>At first glance, it&#39;s clear that <em>Mojo isn&#39;t anything like Python</em>. Here are some things that I found in the few hundred lines of the supposedly Pythonic language:</p> <ul> <li><p>Generic functions parameterized by type parameters: <code>fn foo[x: T](arg: Int)</code></p> </li><li><p>Speaking of which, two distinct function definitions: <code>def foo</code> vs <code>fn foo</code></p> </li><li><p>...and different kinds of integers, here <code>Int</code> as opposed to <code>int</code></p> </li><li><p>Mutable vs immutable variables, initialized by <code>var x: T = y</code> vs <code>let x: T = y</code></p> </li><li><p>Also, type declarations before assignment, C-style: <code>let foo: T</code></p> </li><li><p><em>Mandatory</em> type declarations in type signatures: <code>fn foo(x: Int)</code></p> </li><li><p>Mutability declaration of arguments via the <code>inout</code> keyword: <code>fn foo(inout self)</code></p> </li><li><p>The ability of a function to raise errors must be marked with the <code>raises</code> keyword</p> </li><li><p>Data can be stored in <code>struct</code>s as well as <code>class</code>es.</p> </li><li><p>Compiler directives, notably <code>@always_inline</code> to control inlining heuristics</p> </li></ul> <p>Mojo apparently even implements a <a href="https://docs.modular.com/mojo/programming-manual.html">Rust-style borrow checker</a>, though I couldn&#39;t tell from just reading the code.</p> <p>Does this strike you as the features of a high-level, dynamic language?</p> <p>On one hand, the presence of low-level features is reassuring. When Mojo was initially announced, I didn&#39;t quite understand what Mojo was supposed to be. Was it supposed to be a faster Python implementation, like PyPy? Or perhaps a compiler to optimise selected parts of Python, like Numba? That left a lot of questions with me about how they were going to pull that off given that neither PyPy nor Numba can reliably produce fast code.</p> <p>Well, it looks like it&#39;s neither - instead, it&#39;s a <em>different, static language</em> that presumably aims to provide excellent interoperation with Python. That&#39;s a <em>much</em> more doable proposal! There is no reason to doubt that a static language can reliably generate fast code. And it could still provide great value for Pythonistas by essentially being a better version of Cython that they can selectively reach for when they have a need for speed. Especially so if Mojo can provide a kind of gradual performance where users from a Python background can gradually and selectively opt into each of these features as they get more familiar with lower level computing.</p> <p>On the other hand, it&#39;s also a much less exciting vision to provide a fast static language with good interop, compared to smashing <a href="https://en.wikipedia.org/wiki/Ousterhout%27s_dichotomy">Ousterhout&#39;s dichotomy</a> by providing a dynamic language that is also fast. It does make me question the use case somewhat. After all, static languages can already interoperate with Python relatively easily, e.g. with Rust&#39;s crate PyO3. Presumably, Mojo&#39;s interop is going to be even easier. But is the improved interop going to outweigh the benefits that come from designing a language to be ergonomic on its own terms?</p> <p>On that point, I don&#39;t really buy the idea that Mojo benefits terribly much from being &#34;Pythonic&#34; - which presumably means that its syntax is inspired by Python. What&#39;s the claim here, really? That it&#39;d be <em>too hard</em> for people to learn the superficial syntax of a new language, while it&#39;d simultaneously be <em>easy</em> for people to learn about function monomorphization, copy- vs borrow semantics, compiler directives and much more?</p> <p>The main intended application of Mojo appears to be deep learning, which has struggled with the same &#39;two-language problem&#39; as bioinformatics, since models are prototyped in Python but all the tensor operations are written in C++ or CUDA. It&#39;s not clear to me how Mojo is going to change the game there, though. It doesn&#39;t seem like Mojo can replace a framework like PyTorch, since those are at entirely different levels of the stack. Can it integrate into PyTorch, such that tensor gradients are preserved across Mojo functions? That would allow users to keep using PyTorch while implementing a single custom kernel in Mojo. But it&#39;s seems unlikely Mojo is compatible with PyTorch&#39;s C++ interface. Perhaps Mojo is aimed at being a language suitable for developing new, future frameworks from scratch when people are ready to ditch the existing Python ecosystem? But if that&#39;s the goal, you might as well ditch Python entirely and all its 35-year old baggage and come to Julia for a clean start.</p> <p>Let me also say some nice things about Mojo.</p> <p>First, judging by the language features I listed above it should be clear that Mojo is extremely serious about performance. This is not some PyPy-like attempt to speed up vanilla Python <em>somewhat</em>, this is an attempt to make a language that is <em>actually fast</em>. Second, Mojo&#39;s built-in SIMD capabilities are enviable. It might make a big difference if developers are pushed towards writing SIMD-friendly code by default. Also, keep in mind I probably just don&#39;t understand the intended use case of Mojo. I haven&#39;t paid <em>that</em> close attention to how Mojo is intended to be used, and I probably won&#39;t, until I can get my hands on Mojo and run it on my own computer.</p> <h2 id="dna_sequencing_the_birds-eye_view"><a href="#dna_sequencing_the_birds-eye_view">DNA sequencing: The birds-eye view</a></h2> <p>Before we get back to the benchmark, we need to understand <em>why</em> the work done in the benchmark is meaningful. Well, we don&#39;t <em>need to</em>, but I find it interesting because it&#39;s my field of research, so let&#39;s take a detour into DNA sequencing.</p> <p>Most people know that biological inheritance is controlled by DNA<sup id="fnref:2"><a href="#fndef:2">[2]</a></sup>. DNA is a linear polymer molecule of consisting of <em>nucleotides</em> stringed together in a chain, with each nucleotide containing one of four distinct <em>bases</em> which are abbreviated A, C, G or T. A DNA molecule can therefore be faithfully represented by a sequence of symbols, e.g. a string such as <code>TAGGCTATGCC</code>. Thus, DNA is a type of <em>digital</em> storage that controls much of how living organisms are built and how we behave. Reading the sequence of a physical sample containing DNA molecules is called <em>sequencing</em>, and is done by machines called <em>sequencers</em>.</p> <p>Incidentally, the applicability of the field of bioinformatics stem from these facts: 1. That much of molecular biology can be explained by the polymer molecule DNA (and RNA and protein), 2. That these polymers are easily and faithfully represented in a computer, and 3. That it&#39;s possible to construct sequencers which can computerize massive amounts of these polymers cheaply. Biochemistry on Earth didn&#39;t <em>have</em> to be this amenable to analysis, and we&#39;re very lucky that it happened to be so.</p> <p>There are different competing sequencers with different characteristics, but let&#39;s focus on the machines produced by the company Illumina, which currently dominate with around 80% market share. Illumina sequencers uses a chemical reaction to read DNA linearly from one end of the molecule. The output of reading one molecule of DNA is termed a <em>read</em>. Due to imperfections in the chemistry, the chemical reaction deteriorates to unreadability after around 150 bases, putting an upper limit on read length that is far too low to sequence full DNA molecules, which in humans are on the order of 100 million bases (100 Mbp) in length. To overcome this limitation, the DNA is broken apart to smaller fragments of around 500 bp, e.g. using ultrasound, and tens of millions of these fragments are then sequenced in parallel. Because we expect the sample to contain many near-identical DNA molecules that are fragmented independently and randomly, we can reconstruct the entire original sequence by merging partially overlapping reads, if only we sequence sufficiently many reads from each sample to ensure uniform coverage of the original sequence.</p> <p>The number of reads is typically expressed in <em>depth of coverage</em> (or just <em>depth</em>), which is the average number of times each position in the original DNA molecule is present across all sequenced reads. A typical experiment might target ~2 % of the human genome&#39;s total size of 3 Gbp and aim for a depth of 100x, producing around 5 Gbp of data. With a read length of 150 bp, this is around 35 million reads.</p> <p>Sequencers typically output the reads in the FASTQ format, which is a simple ASCII-encoded format<sup id="fnref:3"><a href="#fndef:3">[3]</a></sup>. One read in FASTQ format looks like this:</p> <pre><code>@HWI-ST180_0186:3:1:1484:1936#GGCTAC/2
GAGATCTCCAGCATCTGGGCGAGCGCGGCCTGACTGAACCCGCGTTCGCTCCGGAGTTGACGAAGGCGCCCTCAAACGTACGTTTTTGACACGTCGCGAG
+
defegg___adefbdhfdadbeffffggfgggaeaf_cffga\_a_babbZbbXdddT_\c_cccca_TbBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</code></pre> <p>That is:</p> <ul> <li><p>A read is always composed of four lines.</p> </li><li><p>The top line starts with <code>@</code> and contain a unique identifier of the read. It has no other restrictions. In the example read above, the name encodes a bunch of metadata about where the read originated.</p> </li><li><p>The next line contain the DNA sequence.</p> </li><li><p>The third line starts with a <code>+</code> and then may optionally repeat the same string as after the <code>@</code> on the first line</p> </li><li><p>The fourth header line contains the quality. This line must be the same length as the DNA sequence. It gives the estimated probability that the given DNA nucleotide is wrong. There are different encoding schemes, but by far the most common is Phred+33, where the error probability is:</p> </li></ul> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mfrac><mrow><mn>33</mn><mo>âˆ’</mo><mi>c</mi></mrow><mn>10</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">p = 10^\frac{33 - c}{10}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span><span>0</span><span><span><span><span><span><span></span><span><span><span></span><span><span><span><span><span><span></span><span><span><span>10</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>33</span><span>âˆ’</span><span>c</span></span></span></span></span><span>â€‹</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>Where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> is the ASCII value of the symbol in the quality line.</p> <p>A FASTQ file is then simply the concatenation of multiple reads like the one above. Since a research project may contain terabytes of FASTQ files, having a fast parser is important.</p> <h2 id="the_fastq_benchmark"><a href="#the_fastq_benchmark">The FASTQ benchmark</a></h2> <p>The Mojo blog post implements two benchmarks - I will only focus on one of them here. That&#39;s the FASTQ parsing benchmark, which is taken from one of <a href="https://github.com/lh3/biofast">the biofast benchmarks</a>. The task is simple: Given a 1.4 GB FASTQ file with ~5.5M reads, count the number of reads, number of bases, and number of quality characters, by using a parser to loop over the individual reads in the file.</p> <p>Currently, the Needletail parser, written in Rust, tops the benchmark. On my four year old laptop, it rips through the file in 458 ms, about 3.05 GB/s. In comparison, my own <code>FASTX.jl</code> parser written in Julia is under half the speed, taking 986 ms (1.42 GB/s). I&#39;ll get back to discrepancy later.</p> <h3 id="the_mojo_implementation"><a href="#the_mojo_implementation">The mojo implementation</a></h3> <p>Since I can&#39;t time the Mojo implementation myself, I&#39;ll use the numbers from their git repo. It lists Needletail taking 0.27s versus 0.21s for Mojo on a more modern, faster machine than my own. If we assume Mojo ran with the same relative speed versus Rust on my machine, it&#39;d clock in at 356 ms (3.92 GB/s).</p> <p>Nearly four GB/s is crazy fast. How does it do it? Let&#39;s dive into the Mojo code.</p> <p>The <code>main()</code> function is defined as:</p> <pre><code>fn main() raises:
    <span>let</span> vars = argv()
    var parser = FastParser(vars[<span>1</span>], <span>64</span> * KB)

    
    parser.parse_all()
    print(parser.parsing_stats)

    [some outcommented code...]</code></pre> <p>Where nearly all the work happens in <code>FastParser.parse_all</code>. That is defined as</p> <pre><code>fn parse_all(inout self) raises:
    <span>while</span> True:
        self.parse_chunk(self._current_chunk, start=<span>0</span>, <span>end</span>=self._chunk_last_index)
        <span>try</span>:
            self.fill_buffer()
            self.check_EOF()
        except:
            <span>break</span></code></pre> <p>The <code>fill_buffer</code> function seeks to the right location in the underlying file, then fills the internal buffer of <code>FastParser</code>. Either that or <code>self.check_EOF</code> can raise a (non-specific) <code>Error</code> on EOF, which breaks the loop in <code>parse_all</code>.</p> <p>I&#39;m not crazy about the mandatory seeking of <code>fill_buffer</code>. This happens if there are extra unused bytes in the buffer. Instead of copying them to the beginning of the buffer, the reader rewinds the underlying stream and simply re-reads the bytes from the stream - but what if the parser wraps a non-seekable stream? In any case that&#39;s not important - it could probably be solved with almost no performance cost.</p> <p>The function <code>parse_chunk</code> parses all the reads in the current buffer. Its definition is:</p> <pre><code>@always_inline
fn parse_chunk(inout self, chunk: Tensor[DType.int8], start: Int, end: Int) raises:
    let read: RecordCoord
    var pos = 0
    while True:
        try:
            read = self.parse_read(pos, chunk)
            self.parsing_stats.tally(read)
        except:
            raise Error(&#34;failed read&#34;)
        if pos &gt;= end - start:
            break</code></pre> <p>Here, the <code>.tally(read)</code> method increments the read number and number of bases seen. The cost of that is insignificant. The exception is expected to be raised when the buffer reaches the end, such that the remaining part of the buffer only contains a partial read.</p> <p>Also note the lack of any kind of error handling here. No matter why <code>parse_chunk</code> throws, it&#39;s caught in <code>parse_all</code> and terminates the reading without propagating the error or examining what kind of error it is. The same issue is repeated further down the call chain.</p> <p>Most work here happens in <code>parse_read</code> where the real parsing happens:</p> <pre><code>@always_inline
fn parse_read(
    self, inout pos: Int, chunk: Tensor[DType.int8]
) raises -&gt; RecordCoord:
    let start = pos
    let line1 = get_next_line_index(chunk, pos)
    let line2 = get_next_line_index(chunk, line1 + 1)
    let line3 = get_next_line_index(chunk, line2 + 1)
    let line4 = get_next_line_index(chunk, line3 + 1)
    pos = line4 + 1
    return RecordCoord(start, line1, line2, line3, line4)</code></pre> <p>That&#39;s the secret sauce, really. Each read is parsed by scanning four times to the next newline, then emitting the positions of the newlines with zero validation of any kind.</p> <p>I&#39;m sorry but this is not a serious parser. To be fair, the repo is pretty clear that:</p> <blockquote> <p>Disclaimer: MojoFastTrimðŸ”¥ is for demonstration purposes only and shouldn&#39;t be used as part of bioinformatic pipelines</p> </blockquote> <p>However, in my opinion, this lack of validation (really, lack of <em>parsing</em> in any meaningful sense) means that the performance between this parser and Needletail is incomparable. So what exactly does it demonstrate? You get to claim your implementation is faster than someone else if you do the same task in less time, but not if you skip half the job.</p> <p>Anyway, <code>get_next_line_index</code> is kind of neat. First, it statically checks if SIMD is enabled. If so, it calls <code>find_chr_next_occurance_simd</code>, which is essentially an implementation of <a href="https://man7.org/linux/man-pages/man3/memchr.3.html"><code>memchr</code></a>. It&#39;s implemented as:</p> <pre><code>@always_inline
fn find_chr_next_occurance_simd[
    T: DType
](in_tensor: Tensor[T], chr: Int, start: Int = 0) -&gt; Int:
    &#34;&#34;&#34;
    Function to find the next occurance of character using SIMD instruction.
    The function assumes that the tensor is always in-bounds. any bound checks should be in the calling function.
    &#34;&#34;&#34;
    let len = in_tensor.num_elements() - start
    let aligned = start + math.align_down(len, simd_width)

    for s in range(start, aligned, simd_width):
        let v = in_tensor.simd_load[simd_width](s)
        let mask = v == chr
        if mask.reduce_or():
            return s + arg_true(mask)

    for i in range(aligned, in_tensor.num_elements()):
        if in_tensor[i] == chr:
            return i

    return -1</code></pre> <p>Here we see Mojo&#39;s nice SIMD abstractions. First it uses <code>math.align_down</code> to get the last index from which it&#39;s safe to load a SIMD vector. The <code>simd_width</code> is automatically computed as <code>simdwidthof[DType.int8]()</code> and is presumably a compile time constant, so I assume its value is constant folded. I think that&#39;s pretty cool.</p> <p>In the first loop, each vector (<code>mask</code>) is then loaded and compared to the byte <code>chr</code>. If any of the bytes are true, then <code>arg_true</code> is called (which loops over the vector to find the first true). I&#39;m guessing this loops compiles effectively to a <code>vmovdqu</code> load instruction, and the reduction can be expressed as <code>vpcmpeqb</code> (compare vector to byte), <code>vpmovmskb</code> (extract upper bits of each byte in vector to a 32-bit integer), and then a comparison to zero.</p> <p>The function <code>arg_true</code> could be compiled to a single <code>tzcnt</code> instruction, but when I tried to emulate it in Julia I couldn&#39;t get the compiler to realise that, though that may just be Julia not having the right SIMD abstractions.</p> <p>Finally, the last elements of the chunk which can&#39;t be safely SIMD loaded are handled in the last loop. This is much less frequently hit, around once every 250 reads.</p> <h3 id="a_detour_how_much_should_parsers_validate"><a href="#a_detour_how_much_should_parsers_validate">A detour: How much should parsers validate?</a></h3> <p>The Mojo parser does zero validation and will even accept random bytes as input, which I think everyone can agree is not acceptable for real-life situations. But how much validation <em>should</em> a parser do? That&#39;s honestly a hard question to answer, and the performance you can expect from parsers hinges on the answer to that question.</p> <p>Let&#39;s return to comparing Needletail and the FASTQ parser I maintain, FASTX.jl. Needletail uses a quite similar algorithm to the Mojo parser: It uses a buffered reader and memchr&#39;s to find newlines before returning a record containing a view directly into the file buffer. However, it also handles <code>\r\n</code> newlines, and validates that the first and third lines begin with <code>@</code> and <code>+</code>, respectively, and that the seq and qual lines have the same length. That&#39;s certainly more validation than the Mojo parser, but is it enough? If the quality line contains pure <code>\x00</code> bytes, how is this a valid FASTQ file? What if the header is <code>&#34;@\r\v\r&#34;</code>?</p> <p>My own parser validates more - that the quality line is a printable ASCII character, that the sequence are ASCII letters, and that the second header is identical to the first. That&#39;s achieved through parsing the file with a state machine, which can therefore be much stricter. It&#39;s also partially the reason it&#39;s slower than Needletail<sup id="fnref:4"><a href="#fndef:4">[4]</a></sup>.</p> <p>On one side of the argument, one could say it&#39;s nice to provide as much validation as possible - suppose someone reads in a FASTQ file with non-ASCII sequences using Needletail, and the parser wrongly claims the seq and quality lines have a different number of symbols because they are encoded in a different number of bytes. That error is no good and will leave the user scratching their heads when they count the sequence and quality lengths and verifies that they match. Wouldn&#39;t it be nicer to instead have the parser check that the input is ASCII?</p> <p>Also in that favour - when do we ever need to parse files at 3 GB/s? What could we possibly <em>do</em> to the files that will be anywhere near that speed? Surely dropping to 2 or even 1 GB/s will have essentially no impact on the overall speed of a real life analysis.</p> <p>The other side of the argument is that parsers should do as <em>little</em> validation as possible. For example, my parser spends time checking that the first and third headers of FASTQ reads are identical, because the format says so. But what if a user has a record where they&#39;re not? Does it really help the user to have their program crash with otherwise perfectly fine records? After all, a sensible idiom of parsing goes &#34;be liberal in what you accept, and conservative in what you send&#34;. Maybe parsers ought to do as little validation as they can get away with while still ensuring they don&#39;t give garbage answers.</p> <p>One could also say that during the course of a project, the same file might be read tens of times, but it really only needs to be validated once. If the validation is a separate step from the parsing, it can be skipped all but the first time the file is read. In <a href="https://www.reddit.com/r/rust/comments/1al8cuc/comment/kpgjkkd/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">a Reddit comment</a> the maintainer of Needletail say they have an external tool to validate FASTQ files for this reason. That&#39;s also reasonable, but it does strike me as un-Rust like to opt-in to validation, especially when the cost is so low - after all, my parser still does more than 1 GB/s.</p> <h3 id="matching_the_implementation_in_julia"><a href="#matching_the_implementation_in_julia">Matching the implementation in Julia</a></h3> <p>My claim is that Mojo&#39;s high speed in this benchmarks comes from the implementation and not from Mojo being particularly fast. To back it up, I <a href="https://github.com/jakobnissen/MojoFQBenchmark">ported the implementation to Julia</a> with all the same lack of error handling or validation. It&#39;s currently 78 lines of code, but to be fair, it does only the absolutely minimal necessary to complete the FASTQ benchmark.</p> <p>It &#34;parses&#34; the file in 200 ms (6.98 GB/s), 78% faster than Mojo&#39;s (imputed) speed. That&#39;s pretty fucking fast. <code>cat input.fq &gt; /dev/null</code> takes 122 ms for comparison.</p> <p>I think there is only one real conclusion here:</p> <p>ðŸ”¥ðŸ”¥ðŸ”¥JULIAðŸ”¥ðŸ”¥ðŸ”¥ IS FASTER THAN MOJOðŸ”¥!!!!111</p> <p>Just kidding. I don&#39;t know why my implementation is faster - I don&#39;t strictly <em>know</em> that it&#39;s even faster since I can&#39;t run Mojo on my own machine. Maybe it&#39;s the fact that my implementation doesn&#39;t seek the underlying file, or maybe 200 ms is fast enough that Python&#39;s startup time begin to matter. If I include the time for Julia to start up and compile the script, my implementation takes 354 ms total, on the same level as Mojo&#39;s.</p> <p>One interesting observation is that replacing the manual <code>memchr</code> implementation with a call to glibc&#39;s <code>memchr</code> slows it down by about 25%, despite glibc&#39;s <code>memchr</code> being around 70% faster when used on long haystacks. Julia&#39;s ccall has close to zero overhead, so I&#39;m not sure what&#39;s up with that.</p> <p>Maybe it&#39;s that <code>memchr</code> doesn&#39;t inline, whereas the manual implementation is forcefully inlined into <code>parse_read</code>. If so, this might explain most of the performance difference to Needletail. Removing the <code>@inline</code> directive from my Julia code slows it down about 20%. Interestingly, setting <code>lto = &#34;thin&#34;</code> and <code>codegen-units = 1</code> in my Cargo.toml file reduces the runtime of Needletail to 357 ms, matching Mojo&#39;s imputed runtime nearly exactly.</p> <p>These differences are trivialities. I don&#39;t know why my Julia implementation is twice as fast as Needletail, but subtracting the lack of validation, I doubt it&#39;s something substantial. There are often real important reasons why some languages are faster than others - whether they provide good zero-cost abstractions for high-level data types, whether they provide good multithreading and SIMD support, how well they support generics and how well libraries compose together, how defensive vs adventurous they make programmers, and much else. I don&#39;t think this Mojo implementation shows any of this.</p> <h2 id="closing_thoughts"><a href="#closing_thoughts">Closing thoughts</a></h2> <p>I don&#39;t want to coldly dismiss the Mojo blog post. After all, its two main points are essentially right: That bioinformatics needs a language to bridge high-level and high-performance programming, and that Mojo is capable of producing fast code. I don&#39;t put too much value in the actual reported numbers in the benchmark, but they don&#39;t matter in the big picture. It&#39;s also feels a little like overkill to go to this length to tear apart a blog post from from a guy who is just excited about what Mojo could bring to bioinformatics. It&#39;s just his bad luck that there are people like me out there - a bioinformatician who is passionate about high performance computing for science, maintain my own FASTQ parsing library, and is particularly sceptical about Mojo.</p> <p>Introspecting, I think I&#39;m a little oversensitive to Mojo&#39;s marketing hype. Ostensibly because the original Mojo announcements (and also this Mojo blog post), made a lot of bold claims that could be construed as hyperbolic, while keeping the compiler to themselves, giving it the smell of vaporware. But if I&#39;m being honest with myself, it&#39;s probably because I&#39;m so invested in the prospect of Julia for bioinformatics.</p> <p>To me, Julia seems like <em>such an obvious</em> solution to the two-language problem in bioinformatics (and in deep learning). All the hard problems with bridging speed and dynamism have essentially been solved in Julia. At the same time, the language remains niche, mostly because it still has too many rough edges and usability issues, such as latency, the inability to statically analyse Julia or compile executable binaries. But these issues are not fundamental to the language - they&#39;re rather in the category of ordinary engineering problems. Solving them is mostly &#34;just&#34; a matter of putting in tens of thousands of professional dev hours, which is a matter of getting tens of millions of euros to pay for hiring people to do the job.</p> <p>It does grate me then, when <em>someone else</em> manages to raise 100M dollars on the premise of reinventing the wheel to solve the exact same problem, but from a worse starting point because they start from zero <em>and</em> they want to retain Python compatibility. Think of what money like that could do to Julia!</p> <p>A bigger person than me might have an attitude of &#39;let a thousand flowers bloom&#39; to solve the two language problem, and, sure, it&#39;s probable that Julia will learn from Mojo as Mojo already has learned from Julia. But I can&#39;t help the feeling that the two languages compete in a zero-sum game, at least to some extent. When I talk to my colleagues, half of them have no interest in high performance computing, and most others have resigned themselves to only doing the analyses that existing C libraries allow them to do, believing that writing new low-level routines is the job of someone else, probably computer scientists. Because they&#39;re not programming language nerds like me, they will use the tools that are at hand, without caring about their technical merit. If more money is spent on sanding the edges off a technically worse solution, then they will stick with it until the end of time, and not demand something better.</p> <p>Does Mojo bring real value to the Python ecosystem? To me it&#39;s still too early to tell. I&#39;m glad someone of the calibre of Chris Lattner is working on breaking the two-language barrier, but I wished he had joined forces with those who have been solving the problem the last decade in Julia-land.</p> <table id="fndef:1"> <tbody><tr> <td><a href="#fnref:1">[1]</a> </td><td>I&#39;ve looked at commit 42ba5bc. The repository has been updated since, so the code listed in this blog post might be out of date by the time you read this. </td></tr></tbody></table> <table id="fndef:2"> <tbody><tr> <td><a href="#fnref:2">[2]</a> </td><td>I&#39;ve found that when you mention that DNA is the basis of heritability, people will appear from thin air and argue about epigenetics. But I believe epigenetics is a rounding error compared to the DNA sequence when we talk about heritability and the medium of evolution. I don&#39;t doubt that e.g. chromatin accessibility is an important parameter in cells, but let&#39;s not conflate the biological state of a cell with a <em>heiritable signal</em> which is stable enough to be acted on over evolutionary time. </td></tr></tbody></table> <table id="fndef:3"> <tbody><tr> <td><a href="#fnref:3">[3]</a> </td><td>Some programmers wonder why DNA is usually saved encoded in plaintext. Isn&#39;t that inefficient, considering the cost of storage for terabyte-sized DNA datasets? Nope. It&#39;s usually stored gzip-compressed at decompressed on the fly when used. DNA compresses well, and the plaintext format allows extra metadata to be written directly into the file, as well as being much easier to parse. There are some more efficient formats, like CRAM, which are used in some large-scale projects, but in my subfield of microbial metagenomics, I can&#39;t recall ever having worked with a CRAM file. </td></tr></tbody></table> <table id="fndef:4"> <tbody><tr> <td><a href="#fnref:4">[4]</a> </td><td>Only partially the reason - Needletail has two more reasons it&#39;s faster. First, Rust&#39;s <code>memchr</code> crate used by Needletail is much more optimised than Julia&#39;s Automa.jl used by FASTX.jl, and Automa.jl probably can&#39;t be optimised to the same level because Julia doesn&#39;t support platform-specific SIMD code yet. Second, Rust&#39;s borrowchecker makes it safe for Needletail to return a view into the active file buffer. This would be totally reckless in Julia, so we need to copy the bytes out to a separate buffer first (we actually need to do <em>two copies</em> of each byte, since Julia&#39;s IO is buffered by default, using an inaccessible buffer). </td></tr></tbody></table>   </div></div>
  </body>
</html>
