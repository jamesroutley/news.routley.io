<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.cofault.com/2022/07/treadmill.html">Original</a>
    <h1>Treadmill garbage collector by H. Baker</h1>
    
    <div id="readability-page-1" class="page"><div>
<hr/><p><em>Treadmill</em> is a &#34;real-time&#34; in-place garbage collection algorithm
  designed by H. Baker [<a href="#0">0</a>]. It is simple, elegant, efficient and surprisingly
little known. Speaking of which, Mr. Baker&#39;s Wikipedia <a href="https://en.wikipedia.org/wiki/Henry_Baker_(computer_scientist)">page</a>
rivals one for an obscure Roman decadent poet in scarcity of information.</p><p>The general situation of garbage collection is that there is a program (called
<em>a mutator</em> in this case) that allocates <em>objects </em>(that will also be called <i>nodes</i>) in a
<em>heap</em>, which is a pool of memory managed by the garbage collector. The
mutator can update objects to point to other earlier allocated objects so that
objects form a graph, possibly with cycles. The mutator can store pointers to
objects in some locations outside of the heap, for example in the stack or in
the registers. These locations are called <em>roots</em>.</p><p>The mutator allocates objects, but does not frees them explicitly. It is the job
of the garbage collector to return unreachable objects, that is, the objects that
can not be reached by following pointers from the roots, back to the allocation
pool.</p><p>It is assumed that the collector, by looking at an object, can identify all
pointers to the heap stored in the object and that the collector knows all the
roots. If either of these assumptions does not hold, one needs a
<em>conservative collector</em> that can be implemented as a library for an
uncooperative compiler and run-time (<i>e.g.</i>, <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector">Boehm garbage
collector</a> for C and C++).</p><p>The earliest garbage collectors were part of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>
run-time. Lisp programs tend to allocate a large number of <a href="https://en.wikipedia.org/wiki/Cons">cons cells</a> and organise them in
complex structures with cycles and sub-structure sharing. In fact, some of the
<a href="https://en.wikipedia.org/wiki/Lisp_machine">Lisp Machines</a> had
garbage collection implemented in hardware and allocated everything including
stack frames and binding environments in the heap. Even processor instructions
were stored as cons cells in the heap.</p><div><p>To allocate a new object, the mutator calls </p><tt>alloc()</tt><p>. Treadmill is
&#34;real-time&#34; because the cost of </p><tt>alloc()</tt><p> in terms of processor cycles is
independent of the number of allocated objects and the total size of the heap,
in other words, </p><tt>alloc()</tt><p> is O(1) and this constant cost is not
high. This means garbage collection without &#34;stop-the-world&#34; pauses, at least as
long as the mutator does not genuinely exhaust the heap with reachable objects. </p></div><p>Treadmill is &#34;in-place&#34; because the address of an allocated object does not
change. This is in contrast with <em>copying</em> garbage collectors that can
move an object to a new place as part of the collection process (that implies some mechanism of updating the pointers to the moved object).</p>


<p>All existing garbage collection algorithms involve some form of scanning of
allocated objects and this scanning is usually described in terms of colours
assigned to objects. In the standard 3-colour scheme (introduced in [<a href="#3">3</a>] together
with the term &#34;mutator&#34;), <b><span>black</span></b> objects have been completely scanned together
with the objects they point to, <b>gray</b> objects have been scanned, but the
objects they point to are not guaranteed to be scanned and <b>white</b> objects
have not been scanned.
 </p><p>For historical reasons, Baker&#39;s papers colour free (un-allocated) objects white
and use black-gray-<a href="https://en.wikipedia.org/wiki/Ecru">ecru</a> instead
of black-gray-white. We stick with <span>ecru</span>, at least to get a chance to learn a fancy word.</p><div><p>Consider the simplest case first:</p><ul><li>the heap has a fixed size;</li><li>the mutator is single-threaded;</li><li>allocated objects all have the same size (like cons cells).</li></ul><p>(All these restrictions will be lifted eventually.)</p></div><p>The main idea of treadmill is that all objects in the heap are organised in a
cyclic double-linked list, divided by 4 pointers into 4 segments:</p><div><table><tbody><tr><td><img height="463" src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/0-treadmill.png" width="517"/></td></tr><tr><td><b>Figure 0: treadmill</b></td></tr></tbody></table></div><div><p>Allocation of new objects happens at </p><tt>free</tt><p> (clockwise), scan advances at
</p><tt>scan</tt><p> (counterclockwise), still non-scanned objects are between
</p><tt>bottom</tt><p> and </p><tt>top</tt><p> (the latter 2 terms, somewhat confusing for a cyclic
list of objects, are re-used from an earlier paper [<a href="#1">1</a>], where a copying real-time
garbage collector was introduced).</p></div><p>Remarkably, the entire description and the proof of correctness of Treadmill
algorithm (and many other similar algorithms) depends on a single invariant:</p><p><b>Invariant</b>: there are no pointers from black to ecru nodes.</p><div><p>That is, a black node can contain a pointer to another black node or to a gray
node. A non-black (that is, gray or ecru) node can point to any allocated node: black,
gray or ecru. An ecru node can be reached from a black node only through at least one intermediate gray node.</p><div><p>Let&#39;s for the time being postpone the explanation of why this invariant is important and instead discuss the usual 2 issues that any invariant introduces: how to establish it and how to maintain it.</p><p>Establishing is easy:</p><div><table><tbody><tr><td><img height="470" src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/4-init.png" width="584"/></td></tr><tr><td><b>Figure 1: initial heap state</b></td></tr></tbody></table></div><p>In the initial state, all objects are un-allocated (white), except for the roots that are gray. The invariant is satisfied trivially because there are no black objects.</p><p>After some allocations by the mutator and scanning, the heap looks like the one in
Figure 0. A call to </p><tt>alloc()</tt><p> advances </p><tt>free</tt><p> pointer clockwise,
thus moving one object from </p><tt>FREE</tt><p> to </p><tt>SCANNED</tt><p> part of the
heap. There is no need to update double-linked list pointers within the
allocated object and, as we will see, there is no need to change the object
colour. This makes the allocation fast path very quick: just a single pointer
update: </p><tt>free := free.next</tt><p>.

</p></div><div><p>Allocation cannot violate the invariant, because the newly allocated object does
not point to anything. In addition to calls to </p><tt>alloc()</tt><p> the mutator can
read pointer fields from nodes it already reached and update fields of reachable
nodes to point to other reachable nodes. There is no pointer arithmetic
(otherwise a conservative collector is needed). A reachable node is either
black, gray or ecru, so it seems, at the first sight, that the only way the
mutator can violate the invariant is by setting a field in a black object to
point to an ecru object. This is indeed the case with some collection algorithms
(called &#34;gray mutator algorithms&#34; in [<a href="#2">2</a>]). Such algorithms use
a <em>write barrier</em>, which is a special code inserted by the compiler
before (or instead of) updating a pointer field. The simplest write barrier
prevents a violation of the 3-colour invariant by graying the ecru target object if necessary:</p></div></div><div><div><pre><code>writebarrier(obj, field, target) {</code></pre><pre><p>        obj.field := target;</p><code><p>        if black(obj) &amp;&amp; ecru(target) {</p><p>                darken(target);</p><p>        }</p><p>}</p><p>darken(obj) { /* Make an ecru object gray. */
        assert ecru(obj);
        unlink(obj); /* Remove the object from the treadmill list. */
        link(top, obj); /* Put it back at the tail of the gray list. */
}</p></code></pre></div><div><p>More sophisticated write barriers were studied that make use of the old value
of </p><tt>obj.field</tt><p> or are integrated with virtual memory sub-system, see [<a href="#2">2</a>] for details.

In our case, however, when the mutator reads a pointer field of an object, it
effectively stores the read value in a register (or in a stack frame slot) and
in Treadmill, registers can be black (Treadmill is a &#34;black mutator
algorithm&#34;). That is, the mutator can violate the invariant simply by reading
the pointer to an ecru object in a black register. To prevent this a <em>read
barrier</em> is needed, executed on every read of a pointer field:</p></div></div><div> 

<div><pre><code>readbarrier(obj, field) {
        if ecru(obj) {
                darken(obj);
        }
        return obj.field;
}
</code></pre>
  </div>
  <table><tbody><tr><td><img data-original-height="676" data-original-width="800" height="425" src="https://nikitadanilov.github.io/treadmill/3-barrier.png" width="502"/>
  </td>
  </tr>
  <tr><td><b>Figure 3: read barrier<br/></b><br/></td></tr></tbody></table>
  
  <p><span>When a black or gray object is read, the read barrier leaves it in place. When an ecru
object is read, the barrier un-links the object from the treadmill list (effectively
removing it from TOSCAN section) and re-links it to the treadmill either at
</span></p><tt>top</tt><p><span> or at </span></p><tt>scan</tt><p><span>, thus making it gray. This barrier guarantees
that the mutator cannot violate the invariant simply because the mutator never
sees ecru objects (which are grayed by the barrier) and hence cannot store
pointers to them anywhere. If the read barrier is present, the write barrier is not
necessary.</span></p></div><p>That&#39;s how the invariant is established and maintained by the mutator. We still
haven&#39;t discussed how the collector works and where these mysterious ecru
objects appear from. The collector is very simple: it has a single entry point:</p><div><div><pre><code>advance() { /* Scan the object pointed to by &#34;scan&#34;. */</code></pre></div>

<tt></tt><div><tt><tt>advance() </tt></tt><p>takes the gray object pointed to by </p><tt>scan</tt><p>, which is the head of the FRONT list, and grays all ecru objects that this object points to. After that, </p><tt>scan</tt><p> is advanced (counterclockwise), effectively moving the scanned object into the SCANNED section and making it black.</p></div><div><table><tbody><tr><td><a href="https://nikitadanilov.github.io/treadmill/2-scan.png"><img data-original-height="723" data-original-width="800" height="452" src="https://nikitadanilov.github.io/treadmill/2-scan.png" width="500"/></a></td></tr><tr><td><b>Figure 4: advance()</b></td></tr></tbody></table></div><div><p> It&#39;s not important for now how
and when exactly </p><tt>advance()</tt><p> is called. What matters is that it blackens
an object while preserving the invariant. </p></div><div><p>Now comes the crucial part. An allocated object only darkens: the mutator
(</p><tt>readbarrier()</tt><p>) and the collector (</p><tt>advance()</tt><p>) can gray an ecru
object and </p><tt>advance()</tt><p> blackens a gray object. There is no way for a
black object to turn gray or for a gray object to turn ecru. Hence, the total
number of allocated non-black objects never increases. But </p><tt>advance()</tt><p>
always blackens one object, which means that after some number of calls
(interspersed with arbitrary mutator activity), </p><tt>advance()</tt><p> will run out
of objects to process: the FRONT section will be empty and there will be no gray
objects anymore:</p></div><table><tbody><tr><td><a href="https://nikitadanilov.github.io/treadmill/5-nogray.png"><img data-original-height="737" data-original-width="800" height="472" src="https://nikitadanilov.github.io/treadmill/5-nogray.png" width="512"/></a></td></tr><tr><td><b>Figure 5: no gray objects</b></td></tr></tbody></table></div><div><p>The algorithm is very flexible. First, the restriction of a single-threaded
mutator is not really important: as long as </p><tt>alloc()</tt><p>, </p><tt>advance()</tt><p>, </p><tt>readbarrier()</tt><p>
and flip are mutually exclusive, no further constraints on concurrency are
necessary. The mutator can be multi-threaded. The collector can be
multi-threaded. </p><tt>advance()</tt><p> can be called &#34;synchronously&#34; (from
</p><tt>alloc()</tt><p>), explicitly from the mutator code or &#34;asynchronously&#34; from the
dedicated collector threads. A feedback-based method can regulate the frequency
of calls to </p><tt>advance()</tt><p> depending on the amount of free and garbage
objects. </p><tt>alloc()</tt><p> can penalise heavy-allocating threads forcing
them to do most of the scanning, <i>etc</i>.</p></div>


<div><p>Next, when an object is grayed by </p><tt>darken()</tt><p>, all that matter is that the
object is placed in the FRONT section. If </p><tt>darken()</tt><p> places the object
next to </p><tt>top</tt><p>, then FRONT acts as a FIFO queue and the scan proceeds in the
breadth-first order. If the object is placed next to </p><tt>scan</tt><p> then the scan
proceeds in the depth-first order, which might result in a better locality of
reference and better performance of a heap in virtual memory. A multi-threaded collector can use multiple FRONT lists, <i>e.g.</i>, one per core and scan them
concurrently.</p></div><p>New objects can be added to the heap at any time, by atomically linking them
somewhere in the FREE list. Similarly, a bunch of objects can be at any moment
atomically released from the FREE list with the usual considerations of
fragmentation-avoidance in the lower layer allocator.</p><div><div><p>Support for variable-sized objects requires a separate cyclic list for each size
(plus, perhaps an additional overflow list for very large objects). The
</p><tt>top</tt><p>, </p><tt>bottom</tt><p>, </p><tt>scan</tt><p> and </p><tt>free</tt><p> pointers become
arrays of pointers with an element for each size. If arbitrarily large objects
(<i>e.g.</i>, arrays) are supported then atomicity of </p><tt>advance()</tt><p> will
require additional work: large objects need to be multi-coloured and will blacken gradually.</p></div><p>Forward and backward links to the cyclic list can be embedded in the object
header or they can be stored separately, the latter might improve cache
utilisation by the scanner.</p>
  
  <h2><tt>References</tt></h2>
  
  <p><a name="0"></a>[<b>0</b>] The Treadmill: Real-Time Garbage Collection Without Motion Sickness
<a href="https://dl.acm.org/doi/pdf/10.1145/130854.130862">PDF (subscription)</a>,
<a href="https://www.plover.com/~mjd/misc/hbaker-archive/NoMotionGC.ps.Z">Postscript</a> </p></div><p>[<b>1</b>] List Processing in Real Time on a Serial Computer
<a href="https://dspace.mit.edu/bitstream/handle/1721.1/41976/AI_WP_139.pdf">PDF</a> </p><p>[<b>2</b>] The Garbage Collection Handbook. The art of automatic memory management
<a href="https://gchandbook.org/">gchandbook.org</a> </p><p><a name="3"></a>[<b>3</b>] On-the-Fly Garbage Collection: An Exercise in Cooperation
<a href="https://lamport.azurewebsites.net/pubs/garbage.pdf">PDF</a>

</p>



</div></div>
  </body>
</html>
