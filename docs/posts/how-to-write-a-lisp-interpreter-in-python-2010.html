<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://norvig.com/lispy.html">Original</a>
    <h1>(How to Write a (Lisp) Interpreter (In Python)) (2010)</h1>
    
    <div id="readability-page-1" class="page">


This page has two purposes: to describe how to implement computer
language interpreters in general, and in particular to build an interpreter
for most of the <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)"><i>Scheme</i></a>
dialect of Lisp using <a href="http://python.org">Python 3</a> as the implementation language. 
I call my language and interpreter <i>Lispy</i> (<a href="https://norvig.com/lis.py"><b>lis.py</b></a>). Years ago, I showed how to write a semi-practical Scheme interpreter  <a (in="" href="https://norvig.com/jscheme.html">Java</a> and in <a href="http://books.google.com/books?id=QzGuHnDhvZIC&amp;lpg=PA756&amp;vq=scheme%20interpreter&amp;dq=Paradigms%20of%20Artificial%20Intelligence%20Programming&amp;pg=PA753#v=onepage&amp;q&amp;f=false">in Common
Lisp</a>).  This time around the goal is to demonstrate, as concisely
and simply as possible, what
<a href="http://queue.acm.org/detail.cfm?id=1039523">Alan Kay called</a> &#34;<a href="http://www.righto.com/2008/07/maxwells-equations-of-software-examined.html"><i>Maxwell&#39;s Equations of Software</i></a>.&#34;

<p>Why does this  matter? As <a href="http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html">Steve
  Yegge said</a>, <i>&#34;If you don&#39;t know how compilers work, then you
  don&#39;t know how computers work.&#34;</i> Yegge describes 8 problems that
  can be solved with compilers (or equally well with interpreters, or
   with Yegge&#39;s
  typical heavy dosage of cynicism).


</p><h2>Syntax and Semantics of Scheme Programs</h2>

The <i>syntax</i> of a language is the arrangement of characters to form correct statements or expressions; the
<i>semantics</i> is the meaning of those statements or expressions.  For example, in the language of
mathematical expressions (and in many programming languages), the syntax for adding one plus two is &#34;1 +
2&#34; and the semantics is the application of the addition operation to the two numbers, yielding the value 3. We say we
are <i>evaluating</i> an expression when we determine its
value; we would say that &#34;1 + 2&#34; evaluates to 3, and write
that as &#34;1 + 2&#34; ⇒ 3.

<p>Scheme syntax is different from most other programming languages. Consider:


</p><blockquote>
<table><tbody><tr><th>Java</th><th>      </th><th>Scheme
    </th></tr><tr><td>
</td></tr><tr><td>
<tt><b>if</b> (x.val() &gt; 0) {
</tt></td><td> 
  </td><td><tt>(<b>if</b> (&gt; (val x) 0)
    </tt></td></tr></tbody></table>
</blockquote>

Java has a wide variety
of syntactic conventions (keywords, infix operators, three kinds of brackets,
operator precedence, dot notation, quotes, commas,
semicolons), but Scheme syntax is much simpler: 
<ul>
<li> Scheme programs consist solely of <i>expressions</i>.  There is no statement/expression distinction.
</li><li> Numbers (e.g. <tt>1</tt>) and symbols (e.g. <tt>A</tt>) are called <i>atomic expressions</i>;
they cannot be broken into pieces.  These are similar to their Java counterparts, except that in
Scheme, operators such as <tt>+</tt> and <tt>&gt;</tt> are symbols too, and are treated the same
way as <tt>A</tt> and <tt>fn</tt>.
</li><li> Everything else is a <i>list expression</i>: a &#34;(&#34;, followed by zero or more expressions,
followed by a &#34;)&#34;.  The first element of the list determines what it means:
<ul>
<li>A list starting with a keyword, e.g. <tt>(if ...)</tt>, is a <i>special form</i>;
the meaning depends on the keyword.
</li><li>A list starting with a non-keyword, e.g. <tt>(fn ...)</tt>, is a function call.
</li></ul>
</li></ul>
The beauty of Scheme is that the full language only needs 5 keywords and 8 syntactic
forms.  In comparison, Python has 33 keywords and <a href="https://docs.python.org/3/reference/grammar.html">110</a>
syntactic forms, 
and Java has 50 keywords and <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-18.html">133</a> syntactic forms.
All those parentheses
may seem intimidating, but Scheme syntax has the virtues of
simplicity and consistency. (Some have joked that &#34;Lisp&#34; stands for
&#34;<a href="http://www.google.com/search?q=Lots+of+Irritating+Silly+Parentheses"><i><b>L</b>ots
of <b>I</b>rritating <b>S</b>illy <b>P</b>arentheses</i></a>&#34;; I think it stand for
&#34;<a href="http://www.google.com/search?hl=en&amp;as_q=&amp;as_epq=Lisp+Is+Syntactically+Pure"><i><b>L</b>isp
<b>I</b>s <b>S</b>yntactically <b>P</b>ure</i></a>&#34;.)  


<p>In this page we will cover all the important points of the Scheme language and its interpretation
(omitting some minor details), but we will take two steps to get there,
defining a simplified language first, before defining the near-full Scheme language. 

</p><h2>Language 1: Lispy Calculator</h2>

<i>Lispy Calculator</i> is a subset of Scheme using only five syntactic forms (two atomic, two special forms, and the procedure call).
Lispy Calculator lets you do any computation you could do on a typical calculator—as long as you are comfortable with prefix notation. 
And you can do two things that are not offered in typical calculator languages: &#34;if&#34; expressions, and the definition of new variables.  
Here&#39;s an example program, that computes the area of a circle of radius 10, using the formula π <i>r</i><sup>2</sup>:

<pre>(define r 10)
(* pi (* r r))
</pre>

Here is a table of all the allowable expressions:

<p>
<table>
  <tbody><tr><th>Expression</th><th>Syntax</th><th>Semantics and Example

  </th></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.1">variable reference</a></td><td><i>symbol</i></td><td>A symbol is interpreted as a variable name;
  its value is the variable&#39;s
  value. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2">constant
  literal</a></td><td><i>number</i></td><td>A number 
  evaluates to itself. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5">conditional</a></td><td><tt>(if</tt> <i>test conseq
  alt</i><tt>) </tt></td><td>Evaluate <i>test</i>; if true,
  evaluate and return <i>conseq</i>; otherwise  
  <i>alt</i>. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2">definition</a>
</td><td><tt>(define</tt> <i>symbol</i> <i>exp</i><tt>)</tt>
</td><td>Define a new variable and give it
  the value of evaluating the expression <i>exp</i>. 
      </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.3">procedure
   call</a></td><td><tt>(</tt><i>proc arg...</i><tt>)</tt>	</td><td>If <i>proc</i> is
   anything other than one of the symbols <tt>if,  define,
   </tt> or <tt>quote</tt> then it is treated as a procedure.  Evaluate <i>proc</i>
   and all the <i>args</i>, and then the procedure is applied to the list of <i>arg</i> values. </td></tr></tbody></table>

   

  </p><p>In the Syntax column of this table, <i>symbol</i> must be a
   symbol,
   <i>number</i> must be an integer or floating point number,
   and the other italicized words can be any
   expression. The notation <i>arg...</i> means zero or more repetitions
   of <i>arg</i>. 
   




</p><h2>What A Language Interpreter Does</h2>

A language interpreter has two parts:
<ol>

  <li> <b>Parsing:</b> The parsing component takes an input program in
the form of a sequence of characters, verifies it according to the
<i>syntactic rules</i> of the language, and translates the program
into an internal representation.  In a simple interpreter the internal
representation is a tree structure (often called an <i>abstract syntax tree</i>) 
that closely mirrors the nested
structure of statements or expressions in the program. In a language
translator called a <i>compiler</i> there is often a series of internal representations,
starting with an abstract syntax tree, and progressing to a
sequence of instructions that can be directly executed by the
computer. The Lispy parser is implemented with the function <tt>parse</tt>.</li><li> <b>Execution:</b> The internal representation is then
  processed according to the <i>semantic rules</i> of the
  language, thereby carrying out the computation. Lispy&#39;s execution function is called <tt>eval</tt> (note this shadows
  Python&#39;s built-in function of the same name).
  
</li></ol>

Here is a picture of the interpretation process:

<blockquote>program  ➡ <span><tt>parse</tt></span>
➡ abstract-syntax-tree 
➡ <span><tt>eval</tt></span>
➡ result 
</blockquote>

<p>And here is a short example of what we want <tt>parse</tt> and <tt>eval</tt> to be able to do (<tt>begin</tt> evaluates each expression in order and returns the final one):

</p><pre>&gt;&gt; program = &#34;(begin (define r 10) (* pi (* r r)))&#34;

&gt;&gt;&gt; parse(program)
[&#39;begin&#39;, [&#39;define&#39;, &#39;r&#39;, 10], [&#39;*&#39;, &#39;pi&#39;, [&#39;*&#39;, &#39;r&#39;, &#39;r&#39;]]]

&gt;&gt;&gt; eval(parse(program))
314.1592653589793
</pre>

<h2>Type Definitions</h2>

Let&#39;s be explicit about our representations for Scheme objects:

<pre>Symbol = str              # A Scheme Symbol is implemented as a Python str
Number = (int, float)     # A Scheme Number is implemented as a Python int or float
Atom   = (Symbol, Number) # A Scheme Atom is a Symbol or Number
List   = list             # A Scheme List is implemented as a Python list
Exp    = (Atom, List)     # A Scheme expression is an Atom or List
Env    = dict             # A Scheme environment (defined below) 
                          # is a mapping of {variable: value}

</pre>

<h2>Parsing: <tt>parse</tt>, <tt>tokenize</tt> and <tt>read_from_tokens</tt></h2>


Parsing is traditionally separated into two parts: <i>lexical
analysis</i>, in which the input character string is broken up into a
sequence of <i>tokens</i>, and <i>syntactic analysis</i>, in which the
tokens are assembled into an abstract syntax tree.  
The Lispy tokens are parentheses, symbols, and numbers.
There are
many tools for lexical analysis (such as Mike Lesk and Eric Schmidt&#39;s
<a href="http://dinosaur.compilertools.net/#lex">lex</a>), but for now we&#39;ll
use a very simple tool: Python&#39;s <tt>str.split</tt>. The function <tt>tokenize</tt> takes
as input a string of characters; it
adds spaces around each paren, and then calls <tt>str.split</tt> to get a
list of tokens:

<pre>def tokenize(chars: str) -&gt; list:
    &#34;Convert a string of characters into a list of tokens.&#34;
    return chars.replace(&#39;(&#39;, &#39; ( &#39;).replace(&#39;)&#39;, &#39; ) &#39;).split()
</pre>

Here we apply tokenize to our sample program:

<pre>&gt;&gt;&gt; program = &#34;(begin (define r 10) (* pi (* r r)))&#34;
&gt;&gt;&gt; tokenize(program)
[&#39;(&#39;, &#39;begin&#39;, &#39;(&#39;, &#39;define&#39;, &#39;r&#39;, &#39;10&#39;, &#39;)&#39;, &#39;(&#39;, &#39;*&#39;, &#39;pi&#39;, &#39;(&#39;, &#39;*&#39;, &#39;r&#39;, &#39;r&#39;, &#39;)&#39;, &#39;)&#39;, &#39;)&#39;]
</pre>


<p>Our function <tt>parse</tt> will take a string representation of a program as input, call <tt>tokenize</tt>
to get a list of tokens, and then call <tt>read_from_tokens</tt> to assemble an abstract syntax tree.
<tt>read_from_tokens</tt> looks at the first token; if
it is a <tt>&#39;)&#39;</tt> that&#39;s a syntax error. If it is a <tt>&#39;(&#39;</tt>, then we start
building up a list of sub-expressions until we hit a matching <tt>&#39;)&#39;</tt>.
Any non-parenthesis token must be a symbol or number. 
We&#39;ll let Python make the distinction between them: for each non-paren token,
first try to interpret it as an int, then as a float, and if it is neither
of those, it must be a
symbol. Here is the parser:

</p><pre>def parse(program: str) -&gt; Exp:
    &#34;Read a Scheme expression from a string.&#34;
    return read_from_tokens(tokenize(program))

def read_from_tokens(tokens: list) -&gt; Exp:
    &#34;Read an expression from a sequence of tokens.&#34;
    if len(tokens) == 0:
        raise SyntaxError(&#39;unexpected EOF&#39;)
    token = tokens.pop(0)
    if token == &#39;(&#39;:
        L = []
        while tokens[0] != &#39;)&#39;:
            L.append(read_from_tokens(tokens))
        tokens.pop(0) # pop off &#39;)&#39;
        return L
    elif token == &#39;)&#39;:
        raise SyntaxError(&#39;unexpected )&#39;)
    else:
        return atom(token)

def atom(token: str) -&gt; Atom:
    &#34;Numbers become numbers; every other token is a symbol.&#34;
    try: return int(token)
    except ValueError:
        try: return float(token)
        except ValueError:
            return Symbol(token)
</pre>




<tt>parse</tt> works like this:

<pre>&gt;&gt;&gt; program = &#34;(begin (define r 10) (* pi (* r r)))&#34;

&gt;&gt;&gt; parse(program)
[&#39;begin&#39;, [&#39;define&#39;, &#39;r&#39;, 10], [&#39;*&#39;, &#39;pi&#39;, [&#39;*&#39;, &#39;r&#39;, &#39;r&#39;]]]
</pre>


 
We&#39;re almost ready to define <tt>eval</tt>. But we need one more concept first.

<h2>Environments</h2>

An environment is a mapping from variable names to their values.
By default, <tt>eval</tt> will use a global environment that includes the names for a bunch of standard functions (like <tt>sqrt</tt> and <tt>max</tt>,
and also operators like <tt>*</tt>).  This environment can be augmented with user-defined variables,
using the expression <tt>(define <i>symbol value</i>)</tt>.  

<pre>import math
import operator as op

def standard_env() -&gt; Env:
    &#34;An environment with some Scheme standard procedures.&#34;
    env = Env()
    env.update(vars(math)) # sin, cos, sqrt, pi, ...
    env.update({
        &#39;+&#39;:op.add, &#39;-&#39;:op.sub, &#39;*&#39;:op.mul, &#39;/&#39;:op.truediv, 
        &#39;&gt;&#39;:op.gt, &#39;&lt;&#39;:op.lt, &#39;&gt;=&#39;:op.ge, &#39;&lt;=&#39;:op.le, &#39;=&#39;:op.eq, 
        &#39;abs&#39;:     abs,
        &#39;append&#39;:  op.add,  
        &#39;apply&#39;:   lambda proc, args: proc(*args),
        &#39;begin&#39;:   lambda *x: x[-1],
        &#39;car&#39;:     lambda x: x[0],
        &#39;cdr&#39;:     lambda x: x[1:], 
        &#39;cons&#39;:    lambda x,y: [x] + y,
        &#39;eq?&#39;:     op.is_, 
        &#39;expt&#39;:    pow,
        &#39;equal?&#39;:  op.eq, 
        &#39;length&#39;:  len, 
        &#39;list&#39;:    lambda *x: List(x), 
        &#39;list?&#39;:   lambda x: isinstance(x, List), 
        &#39;map&#39;:     map,
        &#39;max&#39;:     max,
        &#39;min&#39;:     min,
        &#39;not&#39;:     op.not_,
        &#39;null?&#39;:   lambda x: x == [], 
        &#39;number?&#39;: lambda x: isinstance(x, Number),  
		&#39;print&#39;:   print,
        &#39;procedure?&#39;: callable,
        &#39;round&#39;:   round,
        &#39;symbol?&#39;: lambda x: isinstance(x, Symbol),
    })
    return env

global_env = standard_env()
</pre>


<h2>Evaluation: <tt>eval</tt></h2>

<p>We are now ready for the implementation of <tt>eval</tt>.
As a refresher, we repeat the table of Lispy Calculator forms:

</p><p>
<table>
  <tbody><tr><th>Expression</th><th>Syntax</th><th>Semantics and Example

  </th></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.1">variable reference</a></td><td><i>symbol</i></td><td>A symbol is interpreted as a variable name;
  its value is the variable&#39;s
  value. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2">constant
  literal</a></td><td><i>number</i></td><td>A number 
  evaluates to itself. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5">conditional</a></td><td><tt>(if</tt> <i>test conseq
  alt</i><tt>) </tt></td><td>Evaluate <i>test</i>; if true,
  evaluate and return <i>conseq</i>; otherwise  
  <i>alt</i>. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2">definition</a>
</td><td><tt>(define</tt> <i>symbol</i> <i>exp</i><tt>)</tt>
</td><td>Define a new variable and give it
  the value of evaluating the expression <i>exp</i>. 
      </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.3">procedure
   call</a></td><td><tt>(</tt><i>proc arg...</i><tt>)</tt>	</td><td>If <i>proc</i> is
   anything other than one of the symbols <tt>if,  define,
   </tt> or <tt>quote</tt> then it is treated as a procedure.  Evaluate <i>proc</i>
   and all the <i>args</i>, and then the procedure is applied to the list of <i>arg</i> values. </td></tr></tbody></table>

</p><p>Here is the code for <tt>eval</tt>, which closely follows the table:

</p><pre>def eval(x: Exp, env=global_env) -&gt; Exp:
    &#34;Evaluate an expression in an environment.&#34;
    if isinstance(x, Symbol):        # variable reference
        return env[x]
    elif isinstance(x, Number):      # constant number
        return x                
    elif x[0] == &#39;if&#39;:               # conditional
        (_, test, conseq, alt) = x
        exp = (conseq if eval(test, env) else alt)
        return eval(exp, env)
    elif x[0] == &#39;define&#39;:           # definition
        (_, symbol, exp) = x
        env[symbol] = eval(exp, env)
    else:                            # procedure call
        proc = eval(x[0], env)
        args = [eval(arg, env) for arg in x[1:]]
        return proc(*args)
</pre>

<p><i>We&#39;re done!</i> You can see it all in action:

</p><pre>&gt;&gt;&gt; eval(parse(&#34;(begin (define r 10) (* pi (* r r)))&#34;))
314.1592653589793
</pre>

<h2>Interaction: A REPL</h2>

It is tedious to have to enter <tt>eval(parse(&#34;...&#34;))</tt> all the time.
One of Lisp&#39;s great legacies is the notion of an interactive read-eval-print loop:
a way for a programmer to enter an expression, and see it immediately read, evaluated, and printed, without having to go through a lengthy build/compile/run cycle.  So let&#39;s define the function <tt>repl</tt> (which stands for read-eval-print-loop), and the function <tt>schemestr</tt> which returns a string representing a Scheme object.

<pre>def repl(prompt=&#39;lis.py&gt; &#39;):
    &#34;A prompt-read-eval-print loop.&#34;
    while True:
        val = eval(parse(raw_input(prompt)))
        if val is not None: 
            print(schemestr(val))

def schemestr(exp):
    &#34;Convert a Python object back into a Scheme-readable string.&#34;
    if isinstance(exp, List):
        return &#39;(&#39; + &#39; &#39;.join(map(schemestr, exp)) + &#39;)&#39; 
    else:
        return str(exp)
</pre>

Here is <tt>repl</tt> in action:

<pre>&gt;&gt;&gt; repl()
lis.py&gt; (define r 10)
lis.py&gt; (* pi (* r r))
314.159265359
lis.py&gt; (if (&gt; (* 11 11) 120) (* 7 6) oops)
42
lis.py&gt; (list (+ 1 1) (+ 2 2) (* 2 3) (expt 2 3))
lis.py&gt; 
</pre>

<h2>Language 2: Full Lispy</h2>

We will now extend our language with three new special forms, giving us a much more nearly-complete Scheme subset:

<p><table>
  <tbody><tr><th>Expression</th><th>Syntax</th><th>Semantics and Example

          </th></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2">quotation</a></td><td><tt>(quote </tt><i>exp</i><tt>)</tt></td><td>
Return the <i>exp</i> literally; do not evaluate it. </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.6">assignment</a></td><td><tt>(set!</tt> <i>symbol
  exp</i><tt>)</tt></td><td>Evaluate <i>exp</i> and assign that value to
  <i>symbol</i>, which must have been previously defined (with a
  <tt>define</tt> or as a parameter to an enclosing procedure).
    </td></tr><tr><td><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.4">procedure</a></td><td><tt>(lambda (</tt><i>symbol...</i><tt>)</tt>
  <i>exp</i><tt>)</tt></td><td>Create a procedure
  with parameter(s) named <i>symbol...</i> and <i>exp</i> as the body. </td></tr></tbody></table>

</p><p>The <tt>lambda</tt> special form (an obscure nomenclature choice that refers to Alonzo Church&#39;s <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>) creates a procedure.  
We want procedures to work like this:

</p><pre>lis.py&gt; (define circle-area (lambda (r) (* pi (* r r)))
lis.py&gt; (circle-area (+ 5 5))
314.159265359
</pre>

There are two steps here. In the first step,  the <tt>lambda</tt> expression is evaluated to 
create a procedure, one which refers to the global variables <tt>pi</tt> and <tt>*</tt>, takes a single parameter, which it calls <tt>r</tt>.
This procedure is used as the value of the new variable <tt>circle-area</tt>. In the second step,  
the procedure we just defined is the value of <tt>circle-area</tt>, so it is called, with the value 10 as the argument.
We want <tt>r</tt> to take on the value 10,
but it wouldn&#39;t do to just set <tt>r</tt> to 10 in the global environment.  
What if we were using <tt>r</tt> for some other purpose? We wouldn&#39;t want a call to <tt>circle-area</tt> to alter that value.  Instead, we want to arrange for there to be a <i>local</i> variable named <tt>r</tt> that we can set to 10 without worrying about interfering with any global variable that happens to have the same name.
The process for calling a procedure introduces these new local variable(s), binding each symbol in the parameter list of. the function 
to the corresponding value in the argument list of the function call.

<h2>Redefining <tt>Env</tt> as a Class</h2>

To handle local variables, we will redefine <tt>Env</tt> to be a subclass of <tt>dict</tt>.
When we evaluate <tt>(circle-area (+ 5 5))</tt>, we will fetch the procedure body, <tt>(* pi (* r r))</tt>,
and evaluate it in an environment that has <tt>r</tt> as the sole local variable (with value 10), but also has the global environment as the &#34;outer&#34; 
environment; it is there that we will find the values of <tt>*</tt> and <tt>pi</tt>.  
In other words, we want an environment that looks like this, with the local (blue) environment nested inside the outer (red) global environment:

<p>When we look up a variable in such a nested environment, we look first at the innermost level, but if
we don&#39;t find the variable name there, we move to the next outer level.
Procedures and environments are intertwined, so let&#39;s define them together:

</p><pre>class Env(dict):
    &#34;An environment: a dict of {&#39;var&#39;: val} pairs, with an outer Env.&#34;
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms, args))
        self.outer = outer
    def find(self, var):
        &#34;Find the innermost Env where var appears.&#34;
        return self if (var in self) else self.outer.find(var)

class Procedure(object):
    &#34;A user-defined Scheme procedure.&#34;
    def __init__(self, parms, body, env):
        self.parms, self.body, self.env = parms, body, env
    def __call__(self, *args): 
        return eval(self.body, Env(self.parms, args, self.env))

global_env = standard_env()
</pre>

We see that every procedure has three components: a list of parameter names,  a body expression, and an environment
that tells us what other variables are accessible from the body. For a procedure defined at the top level this will be
the global environment, but it is also possible for a procedure to refer to the local variables of the environment
in which it was <i>defined</i> (and not the environment in which it is <i>called</i>). 

<p>An environment is a subclass of <tt>dict</tt>, so it has
all the methods that <tt>dict</tt> has. In addition there are two methods: the constructor
<tt>__init__</tt> builds a new environment by taking a list of parameter names
and a corresponding list of argument values, and creating a new environment that has those
{variable: value} pairs as the inner part, and also refers to the given <tt>outer</tt> environment.
The method <tt>find</tt> is used to find the right environment for
a variable: either the inner one or an outer one. 

</p><p>To see how these all go together, here is the new definition of <tt>eval</tt>. Note that
the clause for variable reference has changed: we now have to call <tt>env.find(x)</tt> to find at what level
the variable <tt>x</tt> exists; then we can fetch the value of <tt>x</tt> from that level. (The clause for
<tt>define</tt> has not changed, because a <tt>define</tt> always adds a new variable
to the innermost environment.)  There are two new clauses: for <tt>set!</tt>, we find the environment level
where the variable exists and set it to a new value.  With <tt>lambda</tt>, we create a new procedure object with the given
parameter list, body, and environment.

</p><pre>def eval(x, env=global_env):
    &#34;Evaluate an expression in an environment.&#34;
    if isinstance(x, Symbol):    # variable reference
        return env.find(x)[x]
    elif not isinstance(x, List):# constant 
        return x   
    op, *args = x       
    if op == &#39;quote&#39;:            # quotation
        return args[0]
    elif op == &#39;if&#39;:             # conditional
        (test, conseq, alt) = args
        exp = (conseq if eval(test, env) else alt)
        return eval(exp, env)
    elif op == &#39;define&#39;:         # definition
        (symbol, exp) = args
        env[symbol] = eval(exp, env)
    elif op == &#39;set!&#39;:           # assignment
        (symbol, exp) = args
        env.find(symbol)[symbol] = eval(exp, env)
    elif op == &#39;lambda&#39;:         # procedure
        (parms, body) = args
        return Procedure(parms, body, env)
    else:                        # procedure call
        proc = eval(op, env)
        vals = [eval(arg, env) for arg in args]
        return proc(*vals)
</pre>

<p>To appreciate how procedures and environments work together, consider this program and the environment that gets formed when we evaluate <tt>(account1 -20.00)</tt>:

</p><p><table><tbody><tr><td>
</td><td>   </td><td>

<p><b><tt>+</tt></b>: &lt;built-in operator add&gt;
</p>

</td></tr></tbody></table>

</p><p>Each rectangular box represents an environment, and the color of
the box matches the color of the variables that are newly defined in
the environment.  In the last two lines of the program we define <tt>account1</tt> and call
<tt>(account1 -20.00)</tt>; this represents the creation of a bank account
with a 100 dollar opening balance, followed by a 20 dollar withdrawal.
In the process of evaluating <tt>(account1 -20.00)</tt>, we will eval the
expression highlighted in yellow.  There are three variables in that
expression.  <tt>amt</tt> can be found immediately in the innermost
(green) environment. But <tt>balance</tt> is not defined there: we
have to look at the green environment&#39;s outer <tt>env</tt>, the blue
one. And finally, the variable <tt>+</tt> is not found in either of
those; we need to do one more outer step, to the global (red) environment.
This process of looking first in inner environments and then in
outer ones is called <i>lexical scoping</i>.  
<tt>Env.find(var)</tt> finds the right environment according to
lexical scoping rules.



</p><p>Let&#39;s see what we can do now:

</p><pre>&gt;&gt;&gt; repl()
lis.py&gt; (define circle-area (lambda (r) (* pi (* r r))))
lis.py&gt; (circle-area 3)
28.274333877
lis.py&gt; (define fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))
lis.py&gt; (fact 10)
3628800
lis.py&gt; (fact 100)
9332621544394415268169923885626670049071596826438162146859296389521759999322991
5608941463976156518286253697920827223758251185210916864000000000000000000000000
lis.py&gt; (circle-area (fact 10))
4.1369087198e+13
lis.py&gt; (define first car)
lis.py&gt; (define rest cdr)
lis.py&gt; (define count (lambda (item L) (if L (+ (equal? item (first L)) (count item (rest L))) 0)))
lis.py&gt; (count 0 (list 0 1 2 3 0 0))
3
lis.py&gt; (count (quote the) (quote (the more the merrier the bigger the better)))
4
lis.py&gt; (define twice (lambda (x) (* 2 x)))
lis.py&gt; (twice 5)
10
lis.py&gt; (define repeat (lambda (f) (lambda (x) (f (f x)))))
lis.py&gt; ((repeat twice) 10)
40
lis.py&gt; ((repeat (repeat twice)) 10)
160
lis.py&gt; ((repeat (repeat (repeat twice))) 10)
2560
lis.py&gt; ((repeat (repeat (repeat (repeat twice)))) 10)
655360
lis.py&gt; (pow 2 16)
65536.0
lis.py&gt; (define fib (lambda (n) (if (&lt; n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))
lis.py&gt; (define range (lambda (a b) (if (= a b) (quote ()) (cons a (range (+ a 1) b)))))
lis.py&gt; (range 0 10)
(0 1 2 3 4 5 6 7 8 9)
lis.py&gt; (map fib (range 0 10))
(1 1 2 3 5 8 13 21 34 55)
lis.py&gt; (map fib (range 0 20))
(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)
</pre>

We now have a language with procedures, variables, conditionals (<tt>if</tt>), and sequential execution (the <tt>begin</tt> procedure).  If you are familiar with other languages, you might think that a <tt>while</tt> or <tt>for</tt> loop would be needed, but
Scheme manages to do without these just fine. The Scheme report says &#34;Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language.&#34; In Scheme
you iterate by defining recursive functions.

<h2>How Small/Fast/Complete/Good is Lispy?</h2>

In which we judge Lispy on several criteria:

<ul>
<li><b><i>Small:</i></b> Lispy is <i>very</i> small: 117 non-comment
  non-blank lines; 4K of source code. (An earlier version was just 90 lines, but had fewer standard procedures
and was perhaps a bit too terse.)   The smallest version of
  my Scheme in Java, <a href="http://norvig.com/jscheme.html">Jscheme</a>, was 1664 lines and 57K of source. Jscheme was
  originally called SILK (Scheme in Fifty Kilobytes), but I only kept
  under that limit by counting bytecode rather than source code. Lispy does much
  better; I think it meets Alan Kay&#39;s 1972 <a href="http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html">claim</a>
  that <i>you could define the
  &#34;most powerful language in the world&#34; in &#34;a page of code.&#34;</i> (However,
  I think Alan would disagree, because he would count the Python compiler as part of the code, putting me <i>well</i> over a page.)

<pre>bash$ grep &#34;^\s*[^#\s]&#34; lis.py | wc
     117     497    4276
</pre></li><li><b><i>Fast:</i></b> Lispy computes <tt>(fact 100)</tt> exactly in 0.003
seconds.  That&#39;s fast enough for me (although far slower than most
other ways of computing it). </li><li><b><i>Complete:</i></b> Lispy is not very complete compared to the
Scheme standard.  Some major shortcomings:
<ul>
  <li> <b><i>Syntax</i></b>: Missing comments, quote and quasiquote notation, # literals, the derived
  expression types (such as <tt>cond</tt>, derived from <tt>if</tt>,
  or <tt>let</tt>, derived from <tt>lambda</tt>), and dotted list notation.
</li><li> <b><i>Semantics</i></b>: Missing call/cc and tail recursion.  
</li><li> <b><i>Data Types</i></b>: Missing strings, characters, booleans, ports,
  vectors, exact/inexact numbers.
  Python lists are actually closer to Scheme
  vectors than to the Scheme pairs and lists that we implement with them.
</li><li> <b><i>Procedures</i></b>: Missing over 100 primitive procedures.
  
 </li><li> <b><i>Error recovery</i></b>: Lispy does not attempt to detect,
  reasonably report, or recover from errors.  Lispy expects the
  programmer to be perfect.
</li></ul></li><li><b><i>Good:</i></b> That&#39;s up to the readers to decide.  I found it
was good for my purpose of explaining Lisp interpreters.
</li></ul>

<h2>True Story</h2>

To back up the idea that it can be very helpful to know how
interpreters work, here&#39;s a story.  Way back in 1984 I was writing a
Ph.D. thesis.  This was before LaTeX, before Microsoft Word for Windows—we used
troff. Unfortunately, troff had no facility for forward references
to symbolic labels: I wanted to be able to write &#34;As we will see on
page @theorem-x&#34; and then write something like &#34;@(set theorem-x \n%)&#34; in
the appropriate place (the troff register \n% holds the page number). My
fellow grad student Tony DeRose felt the same need, and together we
sketched out a simple Lisp program that would handle this as a preprocessor.  However,
it turned out that the Lisp we had at the time was good at reading
Lisp expressions, but so slow at reading character-at-a-time non-Lisp
expressions that our program was annoying to use.  
<p>
From there Tony and I split paths.  He reasoned that the hard part was
the interpreter for expressions; he needed Lisp for that, but he knew
how to write a tiny C routine
for reading and echoing the non-Lisp characters and link it in to the Lisp
program.  I didn&#39;t know how to do that linking, but I reasoned that writing an
interpreter for this trivial language (all it had was set variable,
fetch variable, and string concatenate) was easy, so I wrote an
interpreter in C. So, ironically, Tony wrote a Lisp program (with one small routine in C) because he was a
C programmer, and I wrote a C program because I was a Lisp programmer.
</p><p>
In the end, we both got our theses done (<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1985/6081.html">Tony</a>, <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1987/5995.html">Peter</a>).

</p><h2>The Whole Thing</h2>

The whole program is here: <a href="https://norvig.com/lis.py">lis.py</a>.

<h2>Further Reading</h2>

   
  
  <p>To learn more about Scheme consult some of the fine books (by
   <a href="http://books.google.com/books?id=xyO-KLexVnMC&amp;lpg=PP1&amp;dq=scheme%20programming%20book&amp;pg=PP1#v=onepage&amp;q&amp;f=false">Friedman
   and Fellesein</a>,
   <a href="http://books.google.com/books?id=wftS4tj4XFMC&amp;lpg=PA300&amp;dq=scheme%20programming%20book&amp;pg=PP1#v=onepage&amp;q&amp;f=false">Dybvig</a>,
   <a href="http://books.google.com/books?id=81mFK8pqh5EC&amp;lpg=PP1&amp;dq=scheme%20programming%20book&amp;pg=PP1#v=onepage&amp;q&amp;f=false">Queinnec</a>,
   <a href="http://www.eecs.berkeley.edu/~bh/ss-toc2.html">Harvey and
   Wright</a> or
   <a href="http://mitpress.mit.edu/sicp/">Sussman and Abelson</a>),
   videos (by <a href="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/">Abelson
   and Sussman</a>),
   tutorials (by
      <a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html">Dorai</a>,
   <a href="http://docs.racket-lang.org/quick/index.html">PLT</a>, or
   <a href="http://cs.gettysburg.edu/~tneller/cs341/scheme-intro/index.html">Neller</a>),
   or the
      <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML">reference
   manual</a>.

</p><p>I also have another page describing a <a href="http://norvig.com/lispy2.html">more advanced version of Lispy</a>.


</p><hr/>
<i><a href="http://norvig.com">Peter Norvig</a></i>

<hr/> 
 
 
 </div>
  </body>
</html>
