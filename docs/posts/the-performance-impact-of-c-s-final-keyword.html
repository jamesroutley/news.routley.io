<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://16bpp.net/blog/post/the-performance-impact-of-cpp-final-keyword/">Original</a>
    <h1>The Performance Impact of C&#43;&#43;&#39;s `final` Keyword</h1>
    
    <div id="readability-page-1" class="page"><div><p>If you&#39;re writing C++, there&#39;s a good reason (maybe...) as to why you are. And probably, that reason is performance. So often when reading about the language you&#39;ll find all sorts of &#34;<em>performance tips and tricks</em>&#34; or &#34;<em>do this instead because it&#39;s more efficient</em>&#34;. Sometimes you get a good explanation as to why you should. But more often than not, <strong>you won&#39;t find any hard numbers to back up that claim</strong>.</p>

<p>I recently found a peculiar one, the <code>final</code> keyword. I&#39;m a little ashamed I haven&#39;t learned about this one earlier. <a href="https://devblogs.microsoft.com/cppblog/the-performance-benefits-of-final-classes/">Multiple blog posts</a> <a href="https://blog.feabhas.com/2022/11/using-final-in-c-to-improve-performance/">claim that it can</a> <a href="https://levelup.gitconnected.com/c-performance-improvement-through-final-devirtualization-258e7ae1d2b5">improve performance</a><sup>(sorry for linking a Medium article)</sup>. It almost seems like it&#39;s almost free, and for a very measly change. After reading you&#39;ll notice something interesting: no one posted any metrics. Zero. Nada. Zilch. It essentially is <em>&#34;just trust me bro.&#34;</em> Claims of performance improvements aren&#39;t worth salt unless you have the numbers to back it up. You also need to be able to reproduce the results. I&#39;ve been guilty of this in the past (<a href="https://github.com/godotengine/godot/pull/33101">see a PR for Godot I made</a>).</p>

<p>Being a good little engineer with a high performance C++ pet project, I really wanted to validate this claim.</p>

<hr/>
<p>I keep on finding myself unable to get away from my pandemic era distraction, <a href="https://github.com/define-private-public/PSRayTracing">PSRayTracing</a>. But I think this is actually a VERY good candidate for testing <code>final</code>. It has many derived classes (implementing interfaces) and they are called millions of times in normal execution.</p>

<p>Side note: when publishing this (April 22nd, 2024), <a href="https://github.com/github/markup/issues/1798">GitHub&#39;s rendering of reStructuredText is broken</a>. So if you want to look at the README, please use the <a href="https://gitlab.com/define-private-public/PSRayTracing/-/blob/master/README.rst?ref_type=heads">GitLab mirror of this project</a>.</p>

<p>For the (many) of you who haven&#39;t been following this project, the quick and skinny on PSRayTracing: it&#39;s a ray tracer implemented in C++, derived from <a href="https://raytracing.github.io/">Peter Shirley&#39;s ray tracing minibooks</a>. It serves mainly an academic purpose, but is modeled after my professional experiences writing C++. The goal is to show readers how you can (re)write C++ to be more performant, clean, and well structured. It has additions and improvements from Dr. Shirley&#39;s original code. One of the big features I have in it is the ability to toggle on and off changes from the book (via CMake), as well as being able to supply other options like random seeds, multi-core rendering. It is somewhere 4-5x faster than the original book code (single threaded).</p>



<h3>How This Was Done</h3>

<p>Leveraging the build system, I added an extra option to the <code>CMakeLists.txt</code>:</p>


<p>Then in C++ we can use (ab)use the pre processor to make a <code>FINAL</code> macro:</p>


<p>And easily it can slapped onto any classes of interest:</p>


<p>Now, we can turn on &amp; off the usage of <code>final</code> in our code base. Yes, it is very hacky and I am disgusted by this myself. <strong>I would never do this in an actual product</strong>, but it provides us a really nice way to apply the <code>final</code> keyword to the code and turn it on and off as we need it for the experiment.</p>

<p><code>final</code> was placed on just about <a href="https://github.com/define-private-public/PSRayTracing/tree/b213aa1338744931977263e61cc6fd4cee6a7f32/render_library/Interfaces">every interface</a>. In the architecture we have things such as <a href="https://github.com/define-private-public/PSRayTracing/tree/b213aa1338744931977263e61cc6fd4cee6a7f32/render_library/Objects"><code>IHittable</code></a>, <a href="https://github.com/define-private-public/PSRayTracing/tree/b213aa1338744931977263e61cc6fd4cee6a7f32/render_library/Materials"><code>IMaterial</code></a>, <a href="https://github.com/define-private-public/PSRayTracing/tree/b213aa1338744931977263e61cc6fd4cee6a7f32/render_library/Textures"><code>ITexture</code></a>, etc. Take a look at the final scene from book two, we&#39;ve got quite a few 10K+ virtual objects in this scenario:</p>

<p><a href="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/book2_final_scene.png"><img alt="Book 2&#39;s final scene" src="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/book2_final_scene.png"/></a></p>



<p>And alternatively, there are some scenes that don&#39;t have many (maybe 10):</p>

<p><a href="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/perlin_noise_with_lights_scene.png"><img alt="Perlin noise with lights scene" src="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/perlin_noise_with_lights_scene.png"/></a></p>



<h3>Initial Concerns:</h3>

<p>For PSRT, when testing something that can boost the performance, I first reach for the default scene <code>book2::final</code>. After applying <code>final</code> enabled the console reported:</p>

<pre>$ ./PSRayTracing -n 100 -j 2
Scene: book2::final_scene
...
Render took 58.587 seconds
</pre>



<p>But then reverting the change:</p>

<pre>$ ./PSRayTracing -n 100 -j 2
Scene: book2::final_scene
...
Render took 57.53 seconds
</pre>



<p>I was a tad bit perplexed? <em>Final was slower?!</em> After a few more runs, I saw a very minimal performance hit. Those blog posts must have lied to me...</p>

<p>Before just tossing this away, I thought it would be best to pull out the verification test script. In a previous revision this was made to essentially fuzz test PSRayTracing (<a href="https://16bpp.net/blog/post/automated-testing-of-a-ray-tracer/">see previous post here</a>). The repo already contains a small set of well known test cases. That suite initially ran for about 20 minutes. But this is where it got a little interesting. The script reported using <code>final</code> slightly faster; wtih <code>final</code> it took 11m 29s. Without <code>final</code> it was 11m 44s. That&#39;s +2%. Actually significant.</p>

<p>Something seemed up; more investigation was required.</p>



<h3>Big Beefy Testing</h3>

<p>Unsatisfied with the above, I created a &#34;large test suite&#34; to be more intensive. On my dev machine it needed to run for 8 hours. This was done by bumping up some of the test parameters. Here are the details on what&#39;s been tweaked:</p>

<ul>
	<li>Number of Times to Test a Scene: <code>10</code>Â â†’ <code>30</code></li>
	<li>Image Size: <code>[320x240, 400x400, 852x480]</code>Â â†’ <code>[720x1280, 720x720, 1280x720]</code></li>
	<li>Ray Depth: <code>[10, 25, 50]</code>Â â†’ <code>[20, 35, 50]</code></li>
	<li>Samples Per Pixel: <code>[5, 10, 25]</code>Â â†’ <code>[25, 50, 75]</code></li>
</ul>

<p>Some test cases now would render in 10 seconds, others would take up to 10 minutes to complete. I thought this was much more comprehensive. The smaller suite did around 350+ test cases in 20+ minutes. This now would do 1150+ over the course of 8+ hours.</p>

<p>The performance of a C++ program is also very compiler (and system) dependent as well. So to be more thorough, this was tested across three machines, three operating systems, and with three different compilers; once with <code>final</code>, and once without it enabled. After doing the math, the machines were chugging along for a cumulative 125+ hours. ðŸ« </p>

<p>Please look at the tables below for specifics, but the configurations were:</p>

<ul>
	<li>AMD Ryzen 9:
	<ul>
		<li>Linux: GCC &amp; Clang</li>
		<li>Windows: GCC &amp; MSVC</li>
	</ul>
	</li>
	<li>Apple M1 Mac: GCC &amp; Clang</li>
	<li>Intel i7: Linux GCC</li>
</ul>

<p>For example, one configuration is &#34;AMD Ryzen 9 with Ubuntu Linux using GCC&#34; and another would be &#34;Apple M1 Mac with macOS using Clang&#34;. Not all versions of the compilers were all the same; some were harder to get than others. And I do need to note at the time of writing this (and after gathering the data) a new version of Clang was released. Here, is the general summary of the test results:</p>

<p><a href="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/test_suite_summary_results.png"><img alt="Overall Performance" src="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/test_suite_summary_results.png"/></a></p>



<p>This gives off some interesting findings, but tells us one thing right now: <strong>across the board, <code>final</code> isn&#39;t always faster; it&#39;s in fact slower in some situations</strong>. Sometimes there is a nice speedup (&gt;1%), other times it is detrimental.</p>

<p>While it may be fun to compare compiler vs. compiler for this application (e.g. &#34;Monday Night Compiler Smackdown&#34;), I do not believe it is a fair thing to do with this data; it&#39;s only fair to compare &#34;with <code>final</code>&#34; and &#34;without <code>final</code>&#34; To compare compilers (and on different systems) a more comprehensive testing system is required. But there are some interesting observations:</p>

<ul>
	<li>Clang on x86_64 is slow.</li>
	<li>Windows is less performant; Microsoft&#39;s own compiler is even lagging.</li>
	<li>Apple&#39;s silicon chips are absolute powerhouses.</li>
</ul>

<p>But each scene is different, and contains a different amount of objects that are marked with <code>final</code>. It would be interesting to see percentage wise, how many test cases ran faster or slower with <code>final</code>. Tabling that data, we get this:</p>

<p><a href="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/percent_of_tests_which_are_faster.png"><img alt="Percent of test cases that are faster with final turned on" src="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/percent_of_tests_which_are_faster.png"/></a></p>



<p>That 1% perf boost for some C++ applications is very desirable (e.g. HFT). And if we&#39;re hitting it for 50%+ of our test cases it seems like using <code>final</code> is something that we should consider. But on the flip side, we also need to see how the inverse looks. How much slower was it? And for how many test cases?</p>

<p><a href="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/percent_of_tests_which_are_slower.png"><img alt="Percent of test cases that are slower with final turned on" src="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/percent_of_tests_which_are_slower.png"/></a></p>



<p>Clang on x86_64 Linux right there is an absolute &#34;<em>yikes</em>&#34;. More than 90% of test cases ran at least 5% slower with <code>final</code> turned on!! Remember how I said a 1% increase is good for some applications? A 1% hit is also bad. Windows with MSVC isn&#39;t faring too well either.</p>

<p>As stated way above, this is very scene dependent. Some have only a handful of virtual objects. Others have warehouses full of them. Taking a look (on average) how much faster/slower a scene is with <code>final</code> turned on:</p>

<p><a href="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/average_performance_change_per_scene.png"><img alt="How much faster or slower was each scene on average is final was used" src="https://storage.googleapis.com/sixteenbpp/blog/images/the-performance-impact-of-cpps-final-keyword/average_performance_change_per_scene.png"/></a></p>

<p>I don&#39;t know Pandas that well. I was having some issues creating a Multi-Index table (from arrays) and having the table be both styled and formatted nicely. So instead each column has a configuration number appended to the end of its name. Here is what each number means:</p>

<ul>
	<li>0 - GCC 13.2.0 AMD Ryzen 9 6900HX Ubuntu 23.10</li>
	<li>1 - Clang 17.0.2 AMD Ryzen 9 6900HX Ubuntu 23.10</li>
	<li>2 - MSVC 17 AMD Ryzen 9 6900HX Windows 11 Home (22631.3085)</li>
	<li>3 - GCC 13.2.0 (w64devkit) AMD Ryzen 9 6900HX Windows 11 Home (22631.3085)</li>
	<li>4 - Clang 15 M1 macOS 14.3 (23D56)</li>
	<li>5 - GCC 13.2.0 (homebrew) M1 macOS 14.3 (23D56)</li>
	<li>6 - GCC 12.3.0 i7-10750H Ubuntu 22.04.3</li>
</ul>



<p>So this is where things are really eye popping. On some configurations and specific scenes might have a 10% perf boost. For example <code>book1::final_scene</code> with GCC on AMD &amp; Linux. But other scenes (on the same configuration) have a minimal 0.5% increase such as <code>fun::three_spheres</code>.</p>

<p>But just switching the compiler over to Clang (still running on that AMD &amp; Linux) <strong>there&#39;s a major perf hit of -5% and -17% (respectively) on those same two scenes</strong>!! MSVC (on AMD) looks to be a bit of a mixed bag where some scenes are more performant with final and others ones take a significant hit.</p>

<p>Apple&#39;s M1 is somewhat interesting where the gains and hits are very minimal, but GCC has a significant benefit for two scenes.</p>

<p>Whether there were many (or few) virtual objects had next to no correlation if <code>final</code> was a performance boon or hit.</p>



<h3>Clang Concerns Me</h3>

<p>PSRayTracing also runs on Android and iOS. Most likely a small fraction of apps available for these platforms are written in C++, but there are some programs that make use of language for performance reasons on the two systems. <strong>Clang is the compiler that is used for these two platforms.</strong></p>

<p>I unfortunately don&#39;t have a framework in place to test performance on Android and iOS like I do with desktop systems But I can do a simple &#34;<em>render-scene-with-same-parameters-one-with-final-and-one-without</em>&#34; test as the app reports how long the process took.</p>

<p>Going from the data above, my hypothesis was that both platforms would be less performant with <code>final</code> turned on. By how much, I don&#39;t know. Here are the results:</p>

<ul>
	<li>iPhone 12: I saw no difference; With and without <code>final</code> it took about 2 minutes and 36 seconds to perform the same render.</li>
	<li>Pixel 6 Pro: <code>final</code> was slower. It was 49 vs 46 seconds. A difference of three seconds might not seem like much, but that is a 6% slowdown; that is fairly significant. (clang 14 was used here BTW).</li>
</ul>

<p>If you think I&#39;m being a little silly with these tiny percentages, please take a look at <a href="https://www.youtube.com/watch?v=kPR8h4-qZdk">Nicholas Ormrod&#39;s 2016 CppCon talks about optimizing <code>std::string</code> for Facebook</a>. I&#39;ve referenced it before and will continue to do it.</p>

<p>I have no idea if this is a Clang issue or an LLVM one. If it is the latter, this may have implications for other LLVM languages such as Rust and Swift.</p>



<h3>For The Future (And What I Wish I Did Instead):</h3>

<p>All in all this was a very fascinating detour; but I think I&#39;m satisfied with what&#39;s been discovered. If I could redo some things (or be given money to work on this project):</p>

<ol>
	<li>Have each scene be able to report some metadata. E.g. number of objects, materials, etc. It is easily doable but didn&#39;t seem worth it for this study of <code>final</code>.</li>
	<li>Have better knowledge of Jupyter+Pandas. I&#39;m a C++ dev, not a data scientist. I&#39;d like to be able to understand how to better transform the measured results and make it look prettier.</li>
	<li>A way to run the automated tests on Android and iOS. These two platforms can&#39;t easily be tested right now and I feel like this is a notable blindspot</li>
	<li><code>run_verfication_tests.py</code> is turning more into an application (as opposed to a small script).
	<ul>
		<li>Features are being bolted on. Better architecture is needed soon.</li>
		<li>Saving and loading testing state was added, but this should have been something from the start and feels like more of a hack to me</li>
		<li>I wish the output of the results were in a JSON format first instead of CSV. I had to fuddle with PyExcel more than desired.</li>
	</ul>
	</li>
	<li>PNGs are starting to get kinda chunky. One time I ran out of disk space. Lossless WebP might be better as a render output.</li>
	<li>Comparing more Intel chips, and with more compilers. The i7 was something I had lying around.</li>
</ol>



<h3>Conclusions</h3>

<p>In case you skimmed to the end, here&#39;s the summary:</p>

<ul>
	<li>Benefit seems to be available for GCC.</li>
	<li>Doesn&#39;t affect Apple&#39;s chips much at all.</li>
	<li>Do not use <code>final</code> with Clang, and maybe MSVC as well.</li>
	<li>It all depends on your configuration/platform; <strong>test &amp; measure to see if it&#39;s worth it.</strong></li>
</ul>

<p><u>Personally, I&#39;m not turning it on. And would in fact, avoid using it. It doesn&#39;t seem consistent.</u></p>

<p>For those who want to look at the raw data and the Jupyter notebook I used to process &amp; present these findings, <a href="https://gitlab.com/define-private-public/PSRayTracing/-/tree/b275e22c5adaa0d576f788cbdfbe7f15f08c6196/final_keyword_experiment">it&#39;s over here</a>.</p>

<hr/>
<p>If you want to take a look at the project, <a href="https://github.com/define-private-public/PSRayTracing">it&#39;s up on GitHub </a>(but the active development is done <a href="https://gitlab.com/define-private-public/PSRayTracing/">over on GitLab</a>). Looking forward to the next time in one year when I pick up this project again. ðŸ˜‰</p></div></div>
  </body>
</html>
