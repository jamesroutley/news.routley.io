<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abstractexpr.com/2024/06/08/finding-out-where-syscalls-are-called-from-stack-traces-with-strace/">Original</a>
    <h1>Finding out where syscalls are called from: Stack traces with strace</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1919">
	<div>
		<!-- .entry-header -->

		<div>
			
<p>One of the great strengths of <code>strace</code> as a debugging tool is that it shows you what a program is doing regardless of whether it was compiled with debug info or not. The downside of this is that you only see the program’s syscall. You can use this information to deduce what is happening in the program but you don’t see from where in the program those syscalls originate.</p>



<p>The good news is that if your program was compiled with debug info <code>strace</code> can actually show a stack trace for every syscall in your binary.</p>



<h2>Example</h2>



<p>To demonstrate this we just save the following program to <code>hello.c</code>:</p>


<div><pre title="">#include &lt;stdio.h&gt;

void print_info()
{
    int num = 5;
    printf(&#34;== Info ==\n&#34;);
    printf(&#34;Hello World!\n&#34;);
    printf(&#34;Num: %d\n&#34;, num);
}

int main(int argc, char **argv)
{
    print_info();
    return 0;
}
</pre></div>


<p>This program uses the <code>printf</code> function to print three lines of output. This function is part of the C standard library. To actually output the text it has to call the operating system by using the syscall <code>write</code>. We will look for this later in the <code>strace</code> output.</p>



<p>To compile the program we enter the following command:</p>


<div><pre title="">$ gcc -g -o hello hello.c
</pre></div>


<p>Now we can run it with <code>strace</code> using the <code>--stack-trace</code> option (alternatively you can use the equivalent short-form option<code>-k</code>):</p>


<div><pre title="">$ strace --stack-trace ./hello
</pre></div>


<p>This will give us an output similar to this:</p>



<pre><code>...
write(1, &#34;Num: 5\n&#34;, 7Num: 5
)                 = 7
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__write+0x14) [0x11c574]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_file_write+0x35) [0x93965]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_do_write+0xb1) [0x92561]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_file_xsputn+0xcf) [0x93a9f]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(parse_printf_format+0xaf9) [0x60cb9]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_vfprintf+0x48e3) [0x6b733]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_printf+0xb3) [0x601a3]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(print_info+0x4a) [0x11b3]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(main+0x1d) [0x11d3]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_init_first+0x8a) [0x2a1ca]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x8b) [0x2a28b]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(_start+0x25) [0x10a5]
exit_group(0)                           = ?
+++ exited with 0 +++
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_exit+0x1d) [0xee21d]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(erand48_r+0x196) [0x47a26]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(exit+0x1e) [0x47bae]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_init_first+0x91) [0x2a1d1]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x8b) [0x2a28b]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(_start+0x25) [0x10a5]</code></pre>



<p>What we see here is that after every syscall (in this example only <code>write</code> and <code>exit_group</code> are shown) <code>strace</code> prints a stack trace that led to the call of the syscall. The stack trace has to be read from the bottom to the top with the top line being the function that made the actual syscall.</p>



<p>Most of the lines in the stack trace are function calls in the dynamically linked standard library (<code>libc.so.6</code>). But if you look closely you will see two lines that refer to functions in our <code>hello</code> program:</p>



<pre><code>...
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(print_info+0x4a) [0x11b3]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(main+0x1d) [0x11d3]
...</code></pre>



<p>We can see here that <code>main</code> has called <code>print_info</code> before the flow of control went to <code>printf</code> and from there deeper into the standard library.</p>



<p>At the end of each line, we see an address in square brackets. This is the address from where the function call occurred that ultimately led to the syscall. Unfortunately, <code>strace</code> doesn’t show us the source code file and the line number that this address relates to. But we can easily get this information with the <code>addr2line</code> tool:</p>


<div><pre title="">$ addr2line -e hello 0x11b3
/home/user/abstractexpr/strace-stacktrace/hello.c:9
</pre></div>


<h2>Prettifying the Stack Trace</h2>



<p>Now that we know how to resolve a single address we could write a Python script to replace every single address in the output of <code>strace</code> with the output of <code>addr2line</code>.</p>



<p>I’ve already written such a script:</p>


<div><pre title="">#!/usr/bin/env python3

import os
import sys

import subprocess

def usage():
    print(&#34;Usage: pretty_print_strace.py FILENAME&#34;)
    sys.exit(2)

if len(sys.argv) != 2:
    usage()

filename = sys.argv[1]

def handle_line(line):
    line = line.rstrip()
    if not line.startswith(&#34; &gt; &#34;) or not line.endswith(&#34;]&#34;):
        print(line)
        return
    enrich_line(line)

def enrich_line(line):
    line = line[3:]
    components = line.split(&#34; &#34;)
    binary_funcoffset = components[0]
    address = components[1]
    binary = binary_funcoffset.split(&#34;(&#34;)[0]
    address = address[1:]
    address = address[:-1]

    result = subprocess.run([&#34;addr2line&#34;, &#34;-e&#34;, binary, address], shell=False, capture_output=True, text=True)
    line_num_info = &#34;&#34;
    if result.returncode != 0:
        line_num_info = address
    else:
        line_num_info = result.stdout.rstrip()

    if line_num_info == &#34;??:?&#34;:
        line_num_info = address

    print(f&#34; &gt; {binary_funcoffset} [{line_num_info}]&#34;)

with open(filename) as f:
    for line in f:
        handle_line(line)
</pre></div>


<p>Save it as pretty_print_strace.py and make it executable with:</p>


<div><pre title="">$ chmod a+x pretty_print_strace.py
</pre></div>


<p>You can then execute <code>strace</code> again but use the <code>-o</code> option to tell it to write its output to a file:</p>



<p>$ strace -o strace.out –stack-trace ./hello</p>



<p>This output file can then be prettified with the following command:</p>


<div><pre title="">$ ./pretty_print_strace.py strace.out &gt; strace-pretty.out
</pre></div>


<p>The stack traces in the newly created file <code>strace-pretty.out</code> will then have a filename and a line number instead of an address for every stack trace entry where <code>addr2line</code> could resolve the address:</p>



<pre><code>...
write(1, &#34;Num: 5\n&#34;, 7)                 = 7
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__write+0x14) [./io/../sysdeps/unix/sysv/linux/write.c:26 (discriminator 1)]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_file_write+0x35) [./libio/./libio/fileops.c:1182]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_do_write+0xb1) [./libio/./libio/fileops.c:449 (discriminator 1)]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_file_xsputn+0xcf) [./libio/./libio/fileops.c:1244 (discriminator 2)]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(parse_printf_format+0xaf9) [./stdio-common/./stdio-common/printf_buffer_to_file.c:59 (discriminator 2)]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_vfprintf+0x48e3) [./stdio-common/./stdio-common/vfprintf-internal.c:1545]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_IO_printf+0xb3) [./stdio-common/./stdio-common/printf.c:37]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(print_info+0x4a) [/home/user/abstractexpr/strace-stacktrace/hello.c:9]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(main+0x1d) [/home/user/abstractexpr/strace-stacktrace/hello.c:14]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_init_first+0x8a) [./csu/../sysdeps/x86/libc-start.c:74]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x8b) [./csu/../csu/libc-start.c:128]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(_start+0x25) [0x10a5]
exit_group(0)                           = ?
+++ exited with 0 +++
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(_exit+0x1d) [./posix/../sysdeps/unix/sysv/linux/_exit.c:30 (discriminator 1)]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(erand48_r+0x196) [./stdlib/./stdlib/exit.c:131]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(exit+0x1e) [:?]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_init_first+0x91) [./csu/../sysdeps/x86/libc-start.c:63]
 &gt; /usr/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x8b) [./csu/../csu/libc-start.c:128]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(_start+0x25) [0x10a5]</code></pre>



<p>Interestingly, many locations in the standard library could be resolved here as well.</p>



<p>The two lines from our program look like this now:</p>



<pre><code>...
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(print_info+0x4a) [/home/user/abstractexpr/strace-stacktrace/hello.c:9]
 &gt; /home/user/abstractexpr/strace-stacktrace/hello(main+0x1d) [/home/user/abstractexpr/strace-stacktrace/hello.c:14]
...</code></pre>



<p>So here we have it! A stack trace for every syscall recorded by <code>strace</code> and the name of the C file and the line number are present in every entry of the stack trace.</p>
					</div><!-- .entry-content -->

		<!-- .entry-footer -->
	</div>
</article></div>
  </body>
</html>
