<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nathanotterness.com/2021/10/tiny_elf_modernized.html">Original</a>
    <h1>Tiny ELF Files: Revisited in 2021</h1>
    
    <div id="readability-page-1" class="page">

<h4>October 11, 2021</h4>

<small>
  <p>
  Quick edit: While I work on a proper update, I&#39;ll note here that
  several posters on reddit and hackernews have pointed out ways to bring the
  total size of the program down to 105 bytes while still printing the full
  &#34;Hello, world!&#34;  Much credit goes to
  <a href="https://twitter.com/josh_triplett">Josh Triplett</a>, who produced
  the 105-byte version <a href="https://nathanotterness.com/2021/10/hello_105.asm">which you can find here.</a>
  I fully plan to include this in an updated version of the page!
  </p>
  <p>
  Here are the tricks I wasn&#39;t aware of when
  writing the article:
  </p>
  <ul>
    <li><a href="https://old.reddit.com/r/programming/comments/q6mnz1/what_is_the_smallest_linux_elf_executable_2021/hgdpee0/">A shorter way to initialize registers</a></li>
    <li><a href="https://news.ycombinator.com/item?id=28849680">Linux initializes register state to 0 at the start of execution.</a></li>
    <li><a href="https://news.ycombinator.com/item?id=28849680">(Same post as before) The &#34;size in file&#34; program header field can be larger than the file, so long as it matches the size in memory.</a></li>
    <li><a href="https://news.ycombinator.com/item?id=28849023">You can clobber the number of section headers, if the section-header size is set to 0.</a></li>
    <li><a href="https://twitter.com/josh_triplett">Josh Triplett</a>, who found a couple of the previous improvements.
  </li></ul>
</small>

<h2>The Inspiration</h2>
<hr/>
<p>
Many years ago, I came across
<a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">this famous article</a>,
which I largely credit changing the trajectory of my career.  At the time, I
was an intern working on a the build system for a fairly large Java code base,
so I was particularly susceptible to an article attempting to do the polar
opposite of &#34;enterprise Java:&#34; strip away all but the most essential
components required to define a valid Linux program. (Before removing even more!)
</p>

<p>
In short, the article walks through the creation of a 45 byte (!) Linux binary.
While the resulting binary is arguably not an entirely &#34;valid&#34; ELF
file, it was at least one that Linux could run.  Or at least at the time.
Perhaps unfortunately, Linux has gotten more strict about ELF loading since
the article&#39;s original publication (I haven&#39;t been able to track down the
original date, but it was already around in the early 2000&#39;s), and the
migration of many systems to 64-bit CPUs has rendered the older 32-bit ELF
binary less relevant.
</p>


<h2>My Goals</h2>
<hr/>
<p>
Like the article I take for inspriation, I set out to create the smallest ELF
file that runs on modern Linux (kernel 5.14 at the time of writing).  Like the
original article, I will still use the
<a href="https://nasm.us/">nasm assembler</a>, since it is easy to install,
I love its syntax, and it remains one of the best x86 assemblers available.
</p>

<p>
However, I have a few goals that aren&#39;t quite like the original article:
</p>

<ul>
  <li>
    I will target x64_64 (64-bit AMD/Intel) Linux, since it&#39;s a stretch to
    claim that 32-bit Intel (used in the original article) is particularly
    modern at this point.
  </li>
  <li>
    As an added challenge, I figured I would try to make a &#34;Hello,
    world!&#34; program (that writes &#34;Hello, world!&#34; followed by a
    newline to stdout), rather than the original article&#39;s less-exciting
    program that exits with a code of 42.  As I will discuss later, this ended
    up costing very few bytes.
  </li>
  <li>My program must exit successfully, with a code of 0.</li>
</ul>

<h2>Background Information: The ELF64 File Format</h2>
<hr/>

<p>
ELF files are used everywhere in Linux (and plenty of other operating systems),
and serve as plain executables, static libraries produced by compilers, dynamic
libraries, and more.  Executable ELF files, the focus of this article,
typically contain the following components:
</p>

<ul>
  <li>The top-level ELF header.</li>
  <li>
    A <i>program header table</i>, which lists chunks of the ELF file
    that need to be loaded into memory, and where they need to be loaded. This
    is also sometimes called a <i>segment header table</i>.
  </li>
  <li>
    A <i>section header table</i>, which list <i>sections</i> of the
    ELF file.  This is <i>not</i> necessary for simply loading an executable
    ELF, but section information is essential for other ELF functionality,
    such as linking.
  </li>
  <li>Actual executable bytecode and any data it needs.</li>
</ul>

<p>
The ELF format has remarkably few hard requirements on where the various
pieces of metadata appear in the file, apart from the fact that the top-level
ELF header must appear at the beginning.  The location of the program header
table and section header table may be anywhere in the file, as the top-level
ELF header will contain their offsets.
</p>

<p>
If you want more details, the wikipedia article on the ELF format, and especially
<a href="https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png">
this accompanying graphic</a>, offers a sufficient summary that is not worth
repeating here.
</p>

<h2>Starting Point: A Reasonably Valid, Minimal Hello-world ELF</h2>
<hr/>
<p>
Even those who haven&#39;t looked into it have likely figured out that typical
gcc-produced executables are full of unecessary stuff for a simple hello-world.
For those who need convincing, the
<a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">original article</a>
covers several iterations of a C version, which does not need any updating to
be relevant to modern times.
</p>

<p>
So, rather than reproduce the entirety of the prior article, I&#39;ll skip straight
to assembly code, and define a valid ELF in its entirety. Here&#39;s what I came up
with:
</p>


</div>
  </body>
</html>
