<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.honeycomb.io/blog/its-the-end-of-observability-as-we-know-it-and-i-feel-fine">Original</a>
    <h1>It&#39;s the end of observability as we know it (and I feel fine)</h1>
    
    <div id="readability-page-1" class="page"><div>
		
		<div>
			<p>In a really broad sense, the history of observability tools over the past couple of decades have been about a pretty simple concept: how do we make terabytes of heterogeneous telemetry data comprehensible to human beings? New Relic did this for the Rails revolution, Datadog did it for the rise of AWS, and Honeycomb led the way for <a href="https://opentelemetry.io/" target="_blank" rel="noreferrer noopener">OpenTelemetry</a>.</p>
<p>The loop has been the same in each case. New abstractions and techniques for software development and deployment gain traction, those abstractions make software more accessible by hiding complexity, and that complexity requires new ways to monitor and measure what’s happening. We build tools like dashboards, adaptive alerting, and dynamic sampling. All of these help us compress the sheer amount of <em>stuff</em> happening into something that’s comprehensible to our human intelligence.</p>
<p>In AI, I see the death of this paradigm. It’s already real, it’s already here, and it’s going to fundamentally change the way we approach systems design and operation in the future.</p>
<div>
<hr/>
<div>
<p>New to Honeycomb? Get your <strong>free</strong> account today.</p>

</div>

<hr/>
</div>
<h2 id="useful">LLMs are just universal function approximators, but it turns out that those are really useful</h2>
<p>I’m going to tell you a story. It’s about this picture:</p>
<figure><img decoding="async" width="1024" height="808" src="https://www.honeycomb.io/wp-content/uploads/2025/06/image-1024x808.png" alt="LLMs are just universal function approximators, but it turns out that those are really useful" srcset="https://www.honeycomb.io/wp-content/uploads/2025/06/image-1024x808.png 1024w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-768x606.png 768w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-640x505.png 640w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-348x275.png 348w, https://www.honeycomb.io/wp-content/uploads/2025/06/image.png 1460w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>
<p>If you’ve ever seen a Honeycomb demo, you’ve probably seen this image. We love it, because it’s not only a great way to show a real-world problem—it’s something that plays well to our core strengths of enabling investigatory loops. Those little peaks you see in the heatmap represent slow requests in a <a href="https://www.honeycomb.io/frontend-observability">frontend</a> service that rise over time before suddenly resetting. They represent a small percentage of your users experiencing poor performance—and we all know what this means in the real world: lost sales, poor experience, and general malaise at the continued enshittification of software.</p>
<p>In a Honeycomb demo, we show you how easy it is to use our UI to understand what those spikes actually mean. You draw a box around them, and we run <a href="https://www.honeycomb.io/bubbleup">BubbleUp</a> to detect anomalies by analyzing the trace data that’s backing this visualization, showing you what’s similar and what’s different between the spikes and the baseline. Eventually, you can drill down to the specific service and even method call that’s causing the problem. It’s a great demo, and it really shows the power of our platform.</p>
<p>Last Friday, I showed a demo at our weekly internal Demo Day. It started with what I just showed you, and then I ran a single prompt through an AI agent that read as follows:</p>
<p><strong>Please investigate the odd latency spikes in the frontend service that happen every four hours or so, and tell me why they’re happening.</strong></p>
<figure><img decoding="async" width="1024" height="366" src="https://www.honeycomb.io/wp-content/uploads/2025/06/image-1-1024x366.png" alt="" srcset="https://www.honeycomb.io/wp-content/uploads/2025/06/image-1-1024x366.png 1024w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-1-768x275.png 768w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-1-1536x549.png 1536w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-1-640x229.png 640w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-1-348x124.png 348w, https://www.honeycomb.io/wp-content/uploads/2025/06/image-1.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>
<p>The screenshot here elides the remainder of the response from the LLM (please find the entire text at the end of this post), but there’s a few things I want to call out. First, this wasn’t anything too special. The agent was something I wrote myself in a couple of days; it’s just an LLM calling tools in a loop. The model itself is off-the-shelf <a href="https://www.anthropic.com/claude/sonnet" target="_blank" rel="noreferrer noopener">Claude Sonnet 4</a>. The integration with Honeycomb is our new <a href="https://www.honeycomb.io/blog/mcp-easy-as-1-2-3">Model Context Protocol (MCP)</a> server. It took 80 seconds, made eight tool calls, and not only did it tell me why those spikes happened, it figured it out in a pretty similar manner to how we’d tell you to do it with BubbleUp.</p>
<p>This isn’t a contrived example. I basically asked the agent the same question we’d ask you in a demo, and the agent figured it out with no additional prompts, training, or guidance. It effectively zero-shot a real-world scenario.</p>
<p>And it did it for <strong>sixty cents.</strong></p>
<h2 id="youcandoit">If I can do this, so can you. So can anyone.</h2>
<p>I want to be clear, this was perhaps the <em>least </em>optimized version of this workflow. Inference costs are only going down, and we can certainly make our MCP server more efficient. There are ways to reduce the amount of input tokens even more. We can play around with more tailored aggregations and function calls that return LLM-optimized query results. It’s an exciting new era!</p>
<p>It also should serve as a wakeup call to the entire industry. This is a seismic shift in how we should conceptualize observability tooling. <strong>If your product’s value proposition is nice graphs and easy instrumentation, you are </strong><strong><em>le cooked</em></strong><strong>. </strong>An LLM commoditizes the analysis piece, OpenTelemetry commoditizes the instrumentation piece. <strong>The moats are emptying.</strong></p>
<p>I’m not gonna sit here and say this destroys the idea of <a href="https://www.honeycomb.io/blog/ai-where-in-the-loop-should-humans-go">humans being involved in the process</a>, though. I don’t think that’s true. The rise of the cloud didn’t destroy the idea of IT. The existence of Rails doesn’t mean we don’t need server programmers. Productivity increases <em>expand the map</em>. There’ll be more software, of all shapes and sizes. We’re going to need <em>more</em> of everything.</p>
<p>The question, then, is: what does this require from us? Where does observability sit in a world where code is cheap, refactors are cheap, and analysis is a constant factor?</p>
<h2 id="feedback">Fast feedback is the only feedback</h2>
<p>I’m gonna put a marker out there: the only thing that really matters is fast, tight feedback loops at every stage of development and operations. AI thrives on speed—it’ll outrun you every time. To succeed, you need tools that move at the speed of AI as well. The slower your analysis engine, the worse your results. LLMs will generate, test, and discard hypotheses faster than you ever can. They might be wrong a dozen times before they get it right, but again, <em>we’re talking about fractional pennies here</em>. </p>
<p>I don’t see this as a reason to despair, but as something to celebrate. The things that AI-assisted development and operations can lead us to are the things <em>we’ve always been about</em>. Honeycomb’s entire modus operandi is predicated on fast feedback loops, collaborative knowledge sharing, and treating everything as an experiment. We’re built for the future that’s here today, on a platform that allows us to be the best tool for tomorrow.</p>
<p>The exact contours of what this industry looks like in two, five, or ten years are out of my view. I don’t think there’s anyone that can credibly tell you what things will look like. I’m also not really in the business of making predictions. What I can say, though, is that I think we’re going to see a spectrum of AI assistance in development and operational tasks across the entire <a href="https://www.honeycomb.io/blog/honeycomb-fit-software-development-lifecycle">software development lifecycle</a>:</p>
<ul>
<li>AI agents can run passively as you write and deploy code, suggesting fixes to improve code quality based on real-world observations from production.</li>
<li>Emergent system behavior can be detected and addressed by AI, with unattended agents identifying impacts to users, investigating them, compiling reports, and presenting those to human operators for approval and tweaks before making changes.</li>
<li>Bleeding-edge organizations can adopt entirely unattended SWE/SRE roles, powered by tools like Honeycomb and friends, optimizing and writing software to meet business needs and goals.</li>
</ul>
<p>In all of these cases, what matters most is <em>speed</em>. Traditional monitoring and observability tools don’t have what it takes to compete in this world. Pretty dashboards, pre-built alerts, and magic integrations aren’t sufficient for the future we’re building today. Sub-second query performance, unified data storage, and collaborative workflows between humans and AI are the keys to success in the future of observability.</p>
<p>Let’s go do something cool.</p>
<p><em>Addendum:</em> Here’s the full output from the investigation screenshot earlier.</p>
<p><strong>Perfect! Now I have a clear picture of what’s happening. Based on my investigation, I can explain the latency spikes you’re seeing in your frontend service.</strong></p>
<hr/>
<p><strong>🔍 Investigation Results: Frontend Latency Spikes</strong></p>
<hr/>
<p><strong>Root Cause Identified: Checkout Service Performance Issues</strong></p>
<p>The latency spikes you’re experiencing every ~4 hours are <strong>NOT actually periodic</strong>—this appears to be a <strong>load testing or synthetic traffic pattern</strong> rather than a scheduled system issue. Here’s what I found:</p>
<hr/>
<p><strong>📊 Key Findings:</strong></p>
<ol>
<li><strong>Primary Culprit: Checkout Operations</strong><strong><br/></strong>
<ul>
<li>/cart/checkout endpoint: <strong>P95 = 3.7 seconds</strong> (vs normal ~500ms)</li>
<li>CheckoutService/PlaceOrder: <strong>P95 = 4.2 seconds</strong><strong><br/></strong></li>
<li><strong>Maximum latency observed: 7.6 seconds</strong><strong><br/></strong></li>
</ul>
</li>
<li><strong>Spike Pattern Analysis:</strong><strong><br/></strong>
<ul>
<li>Spikes are concentrated in <strong>checkout operations only</strong><strong><br/></strong></li>
<li>Other endpoints remain relatively stable</li>
<li><strong>485 slow checkout operations</strong> in the last 24 hours</li>
<li>Pattern suggests <strong>load testing or batch checkout processing</strong><strong><br/></strong></li>
</ul>
</li>
<li><strong>Downstream Service Impact:</strong><strong><br/></strong>
<ul>
<li>CheckoutService/PlaceOrder: <strong>P95 = 4.6 seconds</strong><strong><br/></strong></li>
<li>getDiscounts operation: <strong>P95 = 4.2 seconds</strong><strong><br/></strong></li>
<li>ShippingService/ShipOrder: <strong>P95 = 4.0 seconds</strong><strong><br/></strong></li>
</ul>
</li>
</ol>
<hr/>
<p><strong>🕵️ Evidence from Trace Analysis:</strong></p>
<p>Looking at the sample traces, I can see:</p>
<ul>
<li><strong>User Agent Pattern:</strong> python-requests/2.28.2 and python-requests/2.31.0</li>
<li><strong>Consistent Client IPs:</strong> 52.45.250.5 and internal IPs</li>
<li><strong>High Cart Values:</strong> $6,861, $7,036, $259 (suggesting test scenarios)</li>
<li><strong>Same User IDs:</strong> Multiple requests from user 20109 with identical cart totals</li>
</ul>
<hr/>
<p><strong>💡 Why This is Happening:</strong></p>
<p><strong>Most Likely Cause: Load Testing or Synthetic Monitoring</strong></p>
<ul>
<li>The pattern suggests <strong>automated testing</strong> rather than real user traffic</li>
<li>Python requests library indicates <strong>scripted traffic</strong><strong><br/></strong></li>
<li>High cart values and repeated scenarios point to <strong>test data</strong><strong><br/></strong></li>
<li>The “every 4 hours” pattern is likely your <strong>load testing schedule</strong><strong><br/></strong></li>
</ul>
<p><strong>Technical Root Cause:</strong></p>
<ul>
<li><strong>Checkout service bottleneck</strong> during high-volume operations</li>
<li><strong>Discount calculation delays</strong> (4.2s P95)</li>
<li><strong>Shipping service delays</strong> during order processing</li>
<li>Possible <strong>database contention</strong> or <strong>external API timeouts</strong><strong><br/></strong></li>
</ul>
<hr/>
<p><strong>🎯 Recommendations:</strong></p>
<ol>
<li><strong>Immediate Actions:</strong><strong><br/></strong>
<ul>
<li><strong>Verify if this is load testing</strong>—check with your testing team</li>
<li><strong>Monitor checkout service resources</strong> during spike periods</li>
<li><strong>Check discount service performance</strong> and external dependencies</li>
</ul>
</li>
<li><strong>Performance Optimization:</strong><strong><br/></strong>
<ul>
<li><strong>Optimize discount calculation logic</strong><strong><br/></strong></li>
<li><strong>Add caching</strong> for shipping calculations</li>
<li><strong>Implement circuit breakers</strong> for external payment/shipping APIs</li>
<li><strong>Scale checkout service</strong> if this represents real user load</li>
</ul>
</li>
<li><strong>Monitoring Improvements:</strong><strong><br/></strong>
<ul>
<li><strong>Separate alerts</strong> for synthetic vs. real user traffic</li>
<li><strong>Add SLI tracking</strong> specifically for checkout operations</li>
<li><strong>Monitor downstream dependencies</strong> (payment, shipping, discount services)</li>
</ul>
</li>
</ol>
<hr/>
<p><strong>🚨 Action Items:</strong></p>
<ol>
<li>Confirm if the 4-hour pattern matches your load testing schedule</li>
<li>If it’s real traffic, investigate checkout service capacity and dependencies</li>
<li>Consider implementing checkout-specific performance monitoring and alerting</li>
</ol>
<hr/>
<p><strong>The good news is that your other services are performing well—this appears to be an isolated issue with the checkout flow, likely exacerbated by load testing scenarios.</strong></p>
<hr/>
		</div>
	</div></div>
  </body>
</html>
