<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://onestepcode.com/testing-library-user-event-with-fake-timers/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=testing-library-user-event-with-fake-timers">Original</a>
    <h1>Testing-library user event with fake timers</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>In this post, we’ll see an example of testing user interaction on JavaScript programs with the <a href="https://testing-library.com/">testing-library</a> and Jest <a href="https://jestjs.io/docs/jest-object#jestusefaketimersimplementation-modern--legacy">fake timers</a>. For a more detailed introduction of Jest and some testing tips, you can see my <a href="https://www.ocregister.com/jest-js-testing/">previous post</a>.</p>



<h2>Testing user interaction with the testing-library</h2>



<p>User interactions, like having the user click on a button, are complex events that are hard to replicate in the testing environment. While the <code><a href="https://testing-library.com/docs/dom-testing-library/api-events">fireEvent</a></code> API, can be used to issue DOM events, it’s <a href="https://ph-fritsche.github.io/blog/post/why-userevent">NOT</a> the recommended method for testing user interaction as it doesn’t reflect how the user really interacts with the DOM. The right approach is to use the <code><a href="https://testing-library.com/docs/user-event/intro/">userEvent</a></code> API, which replicates user interaction with more fidelity.  </p>



<h2>Example component with delayed effects</h2>



<p>For this simple demo, we’ll work with the following component. </p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">import React, { useState } from &#34;react&#34;;

const Demo = () =&gt; {
  const [isDisplayed, setIsDisplayed] = useState(true);

  const toggleHandler = () =&gt; setTimeout(()=&gt;setIsDisplayed(prev =&gt; !prev), 500)
  return (
    &lt;React.Fragment&gt;
    &lt;div&gt;
      {isDisplayed &amp;&amp; &lt;p&gt;Hello World!&lt;/p&gt;}
    &lt;/div&gt;
    &lt;button onClick={toggleHandler}&gt;toggle&lt;/button&gt;
    &lt;/React.Fragment&gt;
  );
}

export default Demo;</pre>



<p>It consists of a simple text that is hidden or displayed after pressing the “toggle” button. The effect takes place only after a short delay, using a <code>setTimeout</code> callback. </p>



<p>While the delay serves no purpose in this example, it could be necessary for a variety of situations. For example, pressing the button could trigger a fade animation before completely removing the text. Showing the text again could be done with an animation as well, like on this <a href="https://www.ocregister.com/simple-react-snackbar/">snackbar</a> example. For simplicity, we will not add any of those effects.</p>



<p>Next, let’s test this component.</p>



<h2>Testing user interaction</h2>



<p>We would like to verify the text disappears after first pressing the button.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">import React from &#34;react&#34;;

import { render, screen, waitFor } from &#34;@testing-library/react&#34;;
import userEvent from &#34;@testing-library/user-event&#34;;
import &#34;@testing-library/jest-dom&#34;;

import Demo from &#34;./Demo&#34;;

test(&#34;Pressing the button hides the text&#34;, async () =&gt; {
  const user = userEvent.setup();
  render(&lt;Demo /&gt;);
  const button = screen.getByRole(&#34;button&#34;);
  await user.click(button);
  const text = screen.getByText(&#34;Hello World!&#34;);
  await waitFor(() =&gt; expect(text).not.toBeInTheDocument());
});</pre>



<p>The <code>setup</code> method of <code>userEvent</code> is part of <code>user-event@14.0.0-beta</code>, which is the <a href="https://testing-library.com/docs/user-event/intro/#writing-tests-with-userevent">recommended approach</a> at the moment of this writing.</p>



<p>Launching this test will succeed.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> PASS  src/Demo.test.jsx (6.377 s)
  ✓ Pressing the button hides the text (624 ms)

Test Suites: 1 passed, 1 total</pre>



<p>However, this test takes more than half a second (<code>624 ms</code>) to complete. Here comes the need for fake timers.</p>



<h2>Using fake timers to speed up user interaction tests</h2>



<p>We’ll slightly modify our test to use Jest <a href="https://jestjs.io/docs/jest-object#jestusefaketimersimplementation-modern--legacy">fake timers</a>. They will allow us to manipulate the <code>setTimeout</code> callbacks to be run immediately after pressing the button.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;Pressing the button hides the text (fake timers)&#34;, async () =&gt; {
  const user = userEvent.setup();
  jest.useFakeTimers();
  render(&lt;Demo /&gt;);
  const button = screen.getByRole(&#34;button&#34;);
  await user.click(button);
  act(() =&gt; {
    jest.runAllTimers();
  });
  const text = screen.queryByText(&#34;Hello World!&#34;);
  expect(text).not.toBeInTheDocument();
  jest.useRealTimers();
});</pre>



<p>See that we changed <code>getByText</code> to <code>queryByText</code>. <code>getBy...</code> query methods fail when there is no matching element. <code>queryBy...</code> methods don’t throw an error when no element is found.</p>



<p>Additionally, we add instructions to active and de-active the fake timers,<code>jest.useFakeTimers</code> and <code>jest.useRealTimers</code>, respectively. <code><a href="https://jestjs.io/docs/jest-object#jestrunalltimers">jest.runAllTimers()</a></code> will make the pending <code>setTimeout</code> callbacks execute immediately. This way, we won’t have to wait for the setTimeout delay to complete during testing. </p>



<p>Note that the <code>runAllTimers</code> statement is wrapped inside <code><a href="https://reactjs.org/docs/test-utils.html#act">act</a></code> because it triggers a state change in our component.</p>



<p>Unfortunately, this test will fail.</p>



<pre data-enlighter-language="raw" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> FAIL  src/Demo.test.jsx (10.984 s)
  ✕ Pressing the button hides the text (fake timers) (5010 ms)
  
  ● Pressing the button hides the text (fake timers)

    thrown: &#34;Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.&#34;

      ...

Test Suites: 1 failed, 1 total
</pre>



<p>For some reason, using Jest fake timers doesn’t allow the <code>user-event</code> methods to complete. The test fails due to timeout (which is set to a maximum of 5 seconds by default).</p>



<p>Let’s see how to solve this issue.</p>



<h2>Solving timeout errors on user event tests with fake timers</h2>



<p>The reason our previous test failed has to do with <code>@testing-library/user-event</code> current implementation. By default, this library waits for a <code>setTimeout</code> delay during its execution. Since <code>jest.useFakeTimers</code> replaces the original timer functions (such as <code>setTimeout</code>), <code>user-event</code>  is kept indefinitely waiting for the original timers to complete.</p>



<p>Fortunately, the solution is quite simple. We just need to set the <code><a href="https://testing-library.com/docs/user-event/options#delay">delay</a></code> option to <code>null</code> so that <code>user-event</code> does not wait on <code>setTimeout</code>. </p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">const user = userEvent.setup({ delay: null });</pre>



<p>Besides this single change, our test remains unchanged.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test(&#34;Pressing the button hides the text (fake timers)&#34;, async () =&gt; {
  const user = userEvent.setup({ delay: null });
  jest.useFakeTimers();
  render(&lt;Demo /&gt;);
  const button = screen.getByRole(&#34;button&#34;);
  await user.click(button);
  act(() =&gt; {
    jest.runAllTimers();
  });
  const text = screen.queryByText(&#34;Hello World!&#34;);
  expect(text).not.toBeInTheDocument();
  jest.useRealTimers();
});</pre>



<p>Running the test again will pass with no errors.</p>



<pre data-enlighter-language="raw" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> PASS  src/Demo.test.jsx (5.032 s)
  ✓ Pressing the button hides the text (fake timers) (118 ms)

Test Suites: 1 passed, 1 total
</pre>



<p>We can see that the test is executed in about 100 ms, which shows that we’re effectively skipping the delay.</p>
					</div></div>
  </body>
</html>
