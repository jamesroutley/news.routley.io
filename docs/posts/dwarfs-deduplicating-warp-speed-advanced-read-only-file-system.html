<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mhx/dwarfs">Original</a>
    <h1>DwarFS – Deduplicating Warp-Speed Advanced Read-Only File System</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a href="https://github.com/mhx/dwarfs/releases/latest"><img src="https://camo.githubusercontent.com/7c14c3f1b59f09fab877e8fd13d3682f78ce4b9318fbe3cc4572e937200d6e56/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f6d68782f6477617266733f6c6162656c3d4c617465737425323052656c65617365" alt="Latest Release" data-canonical-src="https://img.shields.io/github/release/mhx/dwarfs?label=Latest%20Release"/></a>
<a href="https://github.com/mhx/dwarfs/releases"><img src="https://camo.githubusercontent.com/2b6c35d2fbd0dac827465bda94342ea83a91f3effafab9c1d117eb790cc936e9/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f646f776e6c6f6164732f6d68782f6477617266732f746f74616c2e7376673f26636f6c6f723d453935343230266c6162656c3d546f74616c253230446f776e6c6f616473" alt="Total Downloads" data-canonical-src="https://img.shields.io/github/downloads/mhx/dwarfs/total.svg?&amp;color=E95420&amp;label=Total%20Downloads"/></a>
<a href="https://github.com/mhx/dwarfs/actions/workflows/build.yml"><img src="https://github.com/mhx/dwarfs/actions/workflows/build.yml/badge.svg" alt="DwarFS CI Build"/></a>
<a href="https://app.travis-ci.com/github/mhx/dwarfs" rel="nofollow"><img src="https://camo.githubusercontent.com/9d83f6eb2696807dc865c941a7b37c7fc27346db3cbb11595be061b977b8866b/68747470733a2f2f6170702e7472617669732d63692e636f6d2f6d68782f6477617266732e7376673f6272616e63683d6d61696e" alt="Build Status" data-canonical-src="https://app.travis-ci.com/mhx/dwarfs.svg?branch=main"/></a>
<a href="https://app.codacy.com/gh/mhx/dwarfs/dashboard" rel="nofollow"><img src="https://camo.githubusercontent.com/6d5dac47834dc9a72470dd868d91391d3a808686e1457628e3022dfb61cf92fd/68747470733a2f2f6170702e636f646163792e636f6d2f70726f6a6563742f62616467652f47726164652f3533343839663737373535323438633939396533383035303032363765383839" alt="Codacy Badge" data-canonical-src="https://app.codacy.com/project/badge/Grade/53489f77755248c999e380500267e889"/></a>
<a href="https://codecov.io/github/mhx/dwarfs" rel="nofollow"><img src="https://camo.githubusercontent.com/028b266bc1c1b17af19e188abadf5901e33b4b9972e56631c7a76a0dea82d2e5/68747470733a2f2f636f6465636f762e696f2f6769746875622f6d68782f6477617266732f67726170682f62616467652e7376673f746f6b656e3d424b52344133584b4139" alt="codecov" data-canonical-src="https://codecov.io/github/mhx/dwarfs/graph/badge.svg?token=BKR4A3XKA9"/></a>
<a href="https://www.bestpractices.dev/projects/8663" rel="nofollow"><img src="https://camo.githubusercontent.com/9a7cc655c21144482581cbbfc96b3a1d20b4dbb174d99ca64ca27a682d2d9aa1/68747470733a2f2f7777772e626573747072616374696365732e6465762f70726f6a656374732f383636332f6261646765" alt="OpenSSF Best Practices" data-canonical-src="https://www.bestpractices.dev/projects/8663/badge"/></a></p>

<p dir="auto">The <strong>D</strong>eduplicating <strong>W</strong>arp-speed <strong>A</strong>dvanced <strong>R</strong>ead-only <strong>F</strong>ile <strong>S</strong>ystem.</p>
<p dir="auto">A fast high compression read-only file system for Linux and Windows.</p>

<ul dir="auto">
<li><a href="#overview">Overview</a></li>
<li><a href="#history">History</a></li>
<li><a href="#building-and-installing">Building and Installing</a>
<ul dir="auto">
<li><a href="#prebuilt-binaries">Prebuilt Binaries</a></li>
<li><a href="#universal-binaries">Universal Binaries</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#installing">Installing</a></li>
<li><a href="#static-builds">Static Builds</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a></li>
<li><a href="#windows-support">Windows Support</a>
<ul dir="auto">
<li><a href="#building-on-windows">Building on Windows</a></li>
</ul>
</li>
<li><a href="#macos-support">macOS Support</a>
<ul dir="auto">
<li><a href="#building-on-macos">Building on macOS</a></li>
</ul>
</li>
<li><a href="#use-cases">Use Cases</a>
<ul dir="auto">
<li><a href="#astrophotography">Astrophotography</a></li>
</ul>
</li>
<li><a href="#dealing-with-bit-rot">Dealing with Bit Rot</a></li>
<li><a href="#extended-attributes">Extended Attributes</a></li>
<li><a href="#comparison">Comparison</a>
<ul dir="auto">
<li><a href="#with-squashfs">With SquashFS</a></li>
<li><a href="#with-squashfs--xz">With SquashFS &amp; xz</a></li>
<li><a href="#with-lrzip">With lrzip</a></li>
<li><a href="#with-zpaq">With zpaq</a></li>
<li><a href="#with-zpaqfranz">With zpaqfranz</a></li>
<li><a href="#with-wimlib">With wimlib</a></li>
<li><a href="#with-cromfs">With Cromfs</a></li>
<li><a href="#with-erofs">With EROFS</a></li>
<li><a href="#with-fuse-archive">With fuse-archive</a></li>
</ul>
</li>
<li><a href="#performance-monitoring">Performance Monitoring</a></li>
<li><a href="#other-obscure-features">Other Obscure Features</a></li>
</ul>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/windows.gif?raw=true"><img src="https://www.jakef.science/mhx/dwarfs/raw/main/doc/windows.gif?raw=true" alt="Windows Screen Capture" title="DwarFS Windows" data-animated-image=""/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/screenshot.gif?raw=true"><img src="https://www.jakef.science/mhx/dwarfs/raw/main/doc/screenshot.gif?raw=true" alt="Linux Screen Capture" title="DwarFS Linux" data-animated-image=""/></a></p>
<p dir="auto">DwarFS is a read-only file system with a focus on achieving <strong>very
high compression ratios</strong> in particular for very redundant data.</p>
<p dir="auto">This probably doesn&#39;t sound very exciting, because if it&#39;s redundant,
it <em>should</em> compress well. However, I found that other read-only,
compressed file systems don&#39;t do a very good job at making use of
this redundancy. See <a href="#comparison">here</a> for a comparison with other
compressed file systems.</p>
<p dir="auto">DwarFS also <strong>doesn&#39;t compromise on speed</strong> and for my use cases I&#39;ve
found it to be on par with or perform better than SquashFS. For my
primary use case, <strong>DwarFS compression is an order of magnitude better
than SquashFS compression</strong>, it&#39;s <strong>6 times faster to build the file
system</strong>, it&#39;s typically faster to access files on DwarFS and it uses
less CPU resources.</p>
<p dir="auto">To give you an idea of what DwarFS is capable of, here&#39;s a quick comparison
of DwarFS and SquashFS on a set of video files with a total size of 39 GiB.
The twist is that each unique video file has two sibling files with a
different set of audio streams (I didn&#39;t make this up, this is
<a href="https://github.com/mhx/dwarfs/discussions/63" data-hovercard-type="discussion" data-hovercard-url="/mhx/dwarfs/discussions/63/hovercard">an actual use case</a>). So
there&#39;s redundancy in both the video and audio data, but as the streams
are interleaved and identical blocks are typically very far apart, it&#39;s
quite challenging to make use of that redundancy for compression. SquashFS
essentially fails to compress the source data at all, whereas DwarFS is
able to reduce the size by almost a factor of 3, which is close to the
theoretical maximum:</p>
<div data-snippet-clipboard-copy-content="$ du -hs dwarfs-video-test
39G     dwarfs-video-test
$ ls -lh dwarfs-video-test.*fs
-rw-r--r-- 1 mhx users 14G Jul  2 13:01 dwarfs-video-test.dwarfs
-rw-r--r-- 1 mhx users 39G Jul 12 09:41 dwarfs-video-test.squashfs"><pre><code>$ du -hs dwarfs-video-test
39G     dwarfs-video-test
$ ls -lh dwarfs-video-test.*fs
-rw-r--r-- 1 mhx users 14G Jul  2 13:01 dwarfs-video-test.dwarfs
-rw-r--r-- 1 mhx users 39G Jul 12 09:41 dwarfs-video-test.squashfs
</code></pre></div>
<p dir="auto">While this is already impressive, it gets even better. When mounting
the SquashFS image and performing a random-read throughput test using
<a href="https://github.com/axboe/fio/">fio</a>-3.34, both <code>squashfuse</code> and
<code>squashfuse_ll</code> top out at around 230 MiB/s:</p>
<div data-snippet-clipboard-copy-content="$ fio --readonly --rw=randread --name=randread --bs=64k --direct=1 \
      --opendir=mnt --numjobs=4 --ioengine=libaio --iodepth=32 \
      --group_reporting --runtime=60 --time_based
[...]
   READ: bw=230MiB/s (241MB/s), 230MiB/s-230MiB/s (241MB/s-241MB/s), io=13.5GiB (14.5GB), run=60004-60004msec"><pre><code>$ fio --readonly --rw=randread --name=randread --bs=64k --direct=1 \
      --opendir=mnt --numjobs=4 --ioengine=libaio --iodepth=32 \
      --group_reporting --runtime=60 --time_based
[...]
   READ: bw=230MiB/s (241MB/s), 230MiB/s-230MiB/s (241MB/s-241MB/s), io=13.5GiB (14.5GB), run=60004-60004msec
</code></pre></div>
<p dir="auto">DwarFS, however, manages to sustain <strong>random read rates of 20 GiB/s</strong>:</p>
<div data-snippet-clipboard-copy-content="  READ: bw=20.2GiB/s (21.7GB/s), 20.2GiB/s-20.2GiB/s (21.7GB/s-21.7GB/s), io=1212GiB (1301GB), run=60001-60001msec"><pre><code>  READ: bw=20.2GiB/s (21.7GB/s), 20.2GiB/s-20.2GiB/s (21.7GB/s-21.7GB/s), io=1212GiB (1301GB), run=60001-60001msec
</code></pre></div>
<p dir="auto">Distinct features of DwarFS are:</p>
<ul dir="auto">
<li>
<p dir="auto">Clustering of files by similarity using a similarity hash function.
This makes it easier to exploit the redundancy across file boundaries.</p>
</li>
<li>
<p dir="auto">Segmentation analysis across file system blocks in order to reduce
the size of the uncompressed file system. This saves memory when
using the compressed file system and thus potentially allows for
higher cache hit rates as more data can be kept in the cache.</p>
</li>
<li>
<p dir="auto"><a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/mkdwarfs.md#categorizers">Categorization framework</a> to categorize
files or even fragments of files and then process individual categories
differently. For example, this allows you to not waste time trying to
compress incompressible files or to compress PCM audio data using FLAC
compression.</p>
</li>
<li>
<p dir="auto">Highly multi-threaded implementation. Both the
<a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/mkdwarfs.md">file system creation tool</a> as well as the
<a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfs.md">FUSE driver</a> are able to make good use of the
many cores of your system.</p>
</li>
</ul>

<p dir="auto">I started working on DwarFS in 2013 and my main use case and major
motivation was that I had several hundred different versions of Perl
that were taking up something around 30 gigabytes of disk space, and
I was unwilling to spend more than 10% of my hard drive keeping them
around for when I happened to need them.</p>
<p dir="auto">Up until then, I had been using <a href="https://bisqwit.iki.fi/source/cromfs.html" rel="nofollow">Cromfs</a>
for squeezing them into a manageable size. However, I was getting more
and more annoyed by the time it took to build the filesystem image
and, to make things worse, more often than not it was crashing after
about an hour or so.</p>
<p dir="auto">I had obviously also looked into <a href="https://en.wikipedia.org/wiki/SquashFS" rel="nofollow">SquashFS</a>,
but never got anywhere close to the compression rates of Cromfs.</p>
<p dir="auto">This alone wouldn&#39;t have been enough to get me into writing DwarFS,
but at around the same time, I was pretty obsessed with the recent
developments and features of newer C++ standards and really wanted
a C++ hobby project to work on. Also, I&#39;ve wanted to do something
with <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" rel="nofollow">FUSE</a>
for quite some time. Last but not least, I had been thinking about
the problem of compressed file systems for a bit and had some ideas
that I definitely wanted to try.</p>
<p dir="auto">The majority of the code was written in 2013, then I did a couple
of cleanups, bugfixes and refactors every once in a while, but I
never really got it to a state where I would feel happy releasing
it. It was too awkward to build with its dependency on Facebook&#39;s
(quite awesome) <a href="https://github.com/facebook/folly">folly</a> library
and it didn&#39;t have any documentation.</p>
<p dir="auto">Digging out the project again this year, things didn&#39;t look as grim
as they used to. Folly now builds with CMake and so I just pulled
it in as a submodule. Most other dependencies can be satisfied
from packages that should be widely available. And I&#39;ve written
some rudimentary docs as well.</p>


<p dir="auto"><a href="https://github.com/mhx/dwarfs/releases">Each release</a> has pre-built,
statically linked binaries for <code>Linux-x86_64</code>, <code>Linux-aarch64</code> and
<code>Windows-AMD64</code> available for download. These <em>should</em> run without
any dependencies and can be useful especially on older distributions
where you can&#39;t easily build the tools from source.</p>

<p dir="auto">In addition to the binary tarballs, there&#39;s a <strong>universal binary</strong>
available for each architecture. These universal binaries contain
<em>all</em> tools (<code>mkdwarfs</code>, <code>dwarfsck</code>, <code>dwarfsextract</code> and the <code>dwarfs</code>
FUSE driver) in a single executable. These executables are compressed
using <a href="https://github.com/upx/upx">upx</a>, so they are much smaller than
the individual tools combined. However, it also means the binaries need
to be decompressed each time they are run, which can have a signficant
overhead. If that is an issue, you can either stick to the &#34;classic&#34;
individual binaries or you can decompress the universal binary, e.g.:</p>
<div data-snippet-clipboard-copy-content="upx -d dwarfs-universal-0.7.0-Linux-aarch64"><pre><code>upx -d dwarfs-universal-0.7.0-Linux-aarch64
</code></pre></div>
<p dir="auto">The universal binaries can be run through symbolic links named after
the proper tool. e.g.:</p>
<div data-snippet-clipboard-copy-content="$ ln -s dwarfs-universal-0.7.0-Linux-aarch64 mkdwarfs
$ ./mkdwarfs --help"><pre><code>$ ln -s dwarfs-universal-0.7.0-Linux-aarch64 mkdwarfs
$ ./mkdwarfs --help
</code></pre></div>
<p dir="auto">This also works on Windows if the file system supports symbolic links:</p>
<div data-snippet-clipboard-copy-content="&gt; mklink mkdwarfs.exe dwarfs-universal-0.7.0-Windows-AMD64.exe
&gt; .\mkdwarfs.exe --help"><pre><code>&gt; mklink mkdwarfs.exe dwarfs-universal-0.7.0-Windows-AMD64.exe
&gt; .\mkdwarfs.exe --help
</code></pre></div>
<p dir="auto">Alternatively, you can select the tool by passing <code>--tool=&lt;name&gt;</code> as
the first argument on the command line:</p>
<div data-snippet-clipboard-copy-content="&gt; .\dwarfs-universal-0.7.0-Windows-AMD64.exe --tool=mkdwarfs --help"><pre><code>&gt; .\dwarfs-universal-0.7.0-Windows-AMD64.exe --tool=mkdwarfs --help
</code></pre></div>
<p dir="auto">Note that just like the <code>dwarfs.exe</code> Windows binary, the universal
Windows binary depends on the <code>winfsp-x64.dll</code> from the
<a href="https://github.com/winfsp/winfsp">WinFsp</a> project. However, for the
universal binary, the DLL is loaded lazily, so you can still use all
other tools without the DLL.
See the <a href="#windows-support">Windows Support</a> section for more details.</p>

<p dir="auto">DwarFS uses <a href="https://cmake.org/" rel="nofollow">CMake</a> as a build tool.</p>
<p dir="auto">It uses both <a href="https://www.boost.org/" rel="nofollow">Boost</a> and
<a href="https://github.com/facebook/folly">Folly</a>, though the latter is
included as a submodule since very few distributions actually
offer packages for it. Folly itself has a number of dependencies,
so please check <a href="https://github.com/facebook/folly#dependencies">here</a>
for an up-to-date list.</p>
<p dir="auto">It also uses <a href="https://github.com/facebook/fbthrift">Facebook Thrift</a>,
in particular the <code>frozen</code> library, for storing metadata in a highly
space-efficient, memory-mappable and well defined format. It&#39;s also
included as a submodule, and we only build the compiler and a very
reduced library that contains just enough for DwarFS to work.</p>
<p dir="auto">Other than that, DwarFS really only depends on FUSE3 and on a set
of compression libraries that Folly already depends on (namely
<a href="https://github.com/lz4/lz4">lz4</a>, <a href="https://github.com/facebook/zstd">zstd</a>
and <a href="https://github.com/kobolabs/liblzma">liblzma</a>).</p>
<p dir="auto">The dependency on <a href="https://github.com/google/googletest">googletest</a>
will be automatically resolved if you build with tests.</p>
<p dir="auto">A good starting point for apt-based systems is probably:</p>
<div data-snippet-clipboard-copy-content="$ apt install \
    gcc \
    g++ \
    clang \
    git \
    ccache \
    ninja-build \
    cmake \
    make \
    bison \
    flex \
    ronn \
    fuse3 \
    pkg-config \
    binutils-dev \
    libacl1-dev \
    libarchive-dev \
    libbenchmark-dev \
    libboost-chrono-dev \
    libboost-context-dev \
    libboost-filesystem-dev \
    libboost-iostreams-dev \
    libboost-program-options-dev \
    libboost-regex-dev \
    libboost-system-dev \
    libboost-thread-dev \
    libbrotli-dev \
    libevent-dev \
    libhowardhinnant-date-dev \
    libjemalloc-dev \
    libdouble-conversion-dev \
    libiberty-dev \
    liblz4-dev \
    liblzma-dev \
    libmagic-dev \
    librange-v3-dev \
    libssl-dev \
    libunwind-dev \
    libdwarf-dev \
    libelf-dev \
    libfmt-dev \
    libfuse3-dev \
    libgoogle-glog-dev \
    libutfcpp-dev \
    libflac++-dev \
    python3-mistletoe"><pre><code>$ apt install \
    gcc \
    g++ \
    clang \
    git \
    ccache \
    ninja-build \
    cmake \
    make \
    bison \
    flex \
    ronn \
    fuse3 \
    pkg-config \
    binutils-dev \
    libacl1-dev \
    libarchive-dev \
    libbenchmark-dev \
    libboost-chrono-dev \
    libboost-context-dev \
    libboost-filesystem-dev \
    libboost-iostreams-dev \
    libboost-program-options-dev \
    libboost-regex-dev \
    libboost-system-dev \
    libboost-thread-dev \
    libbrotli-dev \
    libevent-dev \
    libhowardhinnant-date-dev \
    libjemalloc-dev \
    libdouble-conversion-dev \
    libiberty-dev \
    liblz4-dev \
    liblzma-dev \
    libmagic-dev \
    librange-v3-dev \
    libssl-dev \
    libunwind-dev \
    libdwarf-dev \
    libelf-dev \
    libfmt-dev \
    libfuse3-dev \
    libgoogle-glog-dev \
    libutfcpp-dev \
    libflac++-dev \
    python3-mistletoe
</code></pre></div>
<p dir="auto">Note that when building with <code>gcc</code>, the optimization level will be
set to <code>-O2</code> instead of the CMake default of <code>-O3</code> for release
builds. At least with versions up to <code>gcc-10</code>, the <code>-O3</code> build is
<a href="https://github.com/mhx/dwarfs/issues/14" data-hovercard-type="issue" data-hovercard-url="/mhx/dwarfs/issues/14/hovercard">up to 70% slower</a> than a
build with <code>-O2</code>.</p>

<p dir="auto">Firstly, either clone the repository...</p>
<div data-snippet-clipboard-copy-content="$ git clone --recurse-submodules https://github.com/mhx/dwarfs
$ cd dwarfs"><pre><code>$ git clone --recurse-submodules https://github.com/mhx/dwarfs
$ cd dwarfs
</code></pre></div>
<p dir="auto">...or unpack the release archive:</p>
<div data-snippet-clipboard-copy-content="$ tar xvf dwarfs-x.y.z.tar.bz2
$ cd dwarfs-x.y.z"><pre><code>$ tar xvf dwarfs-x.y.z.tar.bz2
$ cd dwarfs-x.y.z
</code></pre></div>
<p dir="auto">Once all dependencies have been installed, you can build DwarFS
using:</p>
<div data-snippet-clipboard-copy-content="$ mkdir build
$ cd build
$ cmake .. -DWITH_TESTS=1
$ make -j$(nproc)"><pre><code>$ mkdir build
$ cd build
$ cmake .. -DWITH_TESTS=1
$ make -j$(nproc)
</code></pre></div>
<p dir="auto">You can then run tests with:</p>

<p dir="auto">All binaries use <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>
as a memory allocator by default, as it is typically uses much less
system memory compared to the <code>glibc</code> or <code>tcmalloc</code> allocators.
To disable the use of <code>jemalloc</code>, pass <code>-DUSE_JEMALLOC=0</code> on the
<code>cmake</code> command line.</p>

<p dir="auto">Installing is as easy as:</p>

<p dir="auto">Though you don&#39;t have to install the tools to play with them.</p>

<p dir="auto">Attempting to build statically linked binaries is highly discouraged
and not officially supported. That being said, here&#39;s how to set up
an environment where you <em>might</em> be able to build static binaries.</p>
<p dir="auto">This has been tested with <code>ubuntu-22.04-live-server-amd64.iso</code>. First,
install all the packages listed as dependencies above. Also install:</p>
<div data-snippet-clipboard-copy-content="$ apt install ccache ninja libacl1-dev"><pre><code>$ apt install ccache ninja libacl1-dev
</code></pre></div>
<p dir="auto"><code>ccache</code> and <code>ninja</code> are optional, but help with a speedy compile.</p>
<p dir="auto">Depending on your distibution, you&#39;ll need to build and install static
versions of some libraries, e.g. <code>libarchive</code> and <code>libmagic</code> for Ubuntu:</p>
<div data-snippet-clipboard-copy-content="$ wget https://github.com/libarchive/libarchive/releases/download/v3.6.2/libarchive-3.6.2.tar.xz
$ tar xf libarchive-3.6.2.tar.xz &amp;&amp; cd libarchive-3.6.2
$ ./configure --prefix=/opt/static-libs --without-iconv --without-xml2 --without-expat
$ make &amp;&amp; sudo make install"><pre><code>$ wget https://github.com/libarchive/libarchive/releases/download/v3.6.2/libarchive-3.6.2.tar.xz
$ tar xf libarchive-3.6.2.tar.xz &amp;&amp; cd libarchive-3.6.2
$ ./configure --prefix=/opt/static-libs --without-iconv --without-xml2 --without-expat
$ make &amp;&amp; sudo make install
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ wget ftp://ftp.astron.com/pub/file/file-5.44.tar.gz
$ tar xf file-5.44.tar.gz &amp;&amp; cd file-5.44
$ ./configure --prefix=/opt/static-libs --enable-static=yes --enable-shared=no
$ make &amp;&amp; make install"><pre><code>$ wget ftp://ftp.astron.com/pub/file/file-5.44.tar.gz
$ tar xf file-5.44.tar.gz &amp;&amp; cd file-5.44
$ ./configure --prefix=/opt/static-libs --enable-static=yes --enable-shared=no
$ make &amp;&amp; make install
</code></pre></div>
<p dir="auto">That&#39;s it! Now you can try building static binaries for DwarFS:</p>
<div data-snippet-clipboard-copy-content="$ git clone --recurse-submodules https://github.com/mhx/dwarfs
$ cd dwarfs &amp;&amp; mkdir build &amp;&amp; cd build
$ cmake .. -GNinja -DWITH_TESTS=1 -DSTATIC_BUILD_DO_NOT_USE=1 \
           -DSTATIC_BUILD_EXTRA_PREFIX=/opt/static-libs
$ ninja
$ ninja test"><pre><code>$ git clone --recurse-submodules https://github.com/mhx/dwarfs
$ cd dwarfs &amp;&amp; mkdir build &amp;&amp; cd build
$ cmake .. -GNinja -DWITH_TESTS=1 -DSTATIC_BUILD_DO_NOT_USE=1 \
           -DSTATIC_BUILD_EXTRA_PREFIX=/opt/static-libs
$ ninja
$ ninja test
</code></pre></div>

<p dir="auto">Please check out the manual pages for <a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/mkdwarfs.md">mkdwarfs</a>,
<a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfs.md">dwarfs</a>, <a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfsck.md">dwarfsck</a> and
<a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfsextract.md">dwarfsextract</a>. You can also access the manual
pages using the <code>--man</code> option to each binary, e.g.:</p>

<p dir="auto">The <a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfs.md">dwarfs</a> manual page also shows an example for setting
up DwarFS with <a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt" rel="nofollow">overlayfs</a>
in order to create a writable file system mount on top a read-only
DwarFS image.</p>
<p dir="auto">A description of the DwarFS filesystem format can be found in
<a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfs-format.md">dwarfs-format</a>.</p>
<p dir="auto">A high-level overview of the internal operation of <code>mkdwarfs</code> is shown
in <a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/mkdwarfs-sequence.svg">this sequence diagram</a>.</p>

<p dir="auto">Support for the Windows operating system is currently experimental.
Having worked pretty much exclusively in a Unix world for the past two
decades, my experience with Windows development is rather limited and
I&#39;d expect there to definitely be bugs and rough edges in the Windows
code.</p>
<p dir="auto">The Windows version of the DwarFS filesystem driver relies on the awesome
<a href="https://github.com/winfsp/winfsp">WinFsp</a> project and its <code>winfsp-x64.dll</code>
must be discoverable by the <code>dwarfs.exe</code> driver.</p>
<p dir="auto">The different tools should behave pretty much the same whether you&#39;re
using them on Linux or Windows. The file system images can be copied
between Linux and Windows and images created on one OS should work fine
on the other.</p>
<p dir="auto">There are a few things worth pointing out, though:</p>
<ul dir="auto">
<li>
<p dir="auto">DwarFS supports both hardlinks and symlinks on Windows, just as it
does on Linux. However, creating hardlinks and symlinks seems to
require admin privileges on Windows, so if you want to e.g. extract
a DwarFS image that contains links of some sort, you might run into
errors if you don&#39;t have the right privileges.</p>
</li>
<li>
<p dir="auto">Due to a <a href="https://github.com/winfsp/winfsp/issues/454" data-hovercard-type="issue" data-hovercard-url="/winfsp/winfsp/issues/454/hovercard">problem</a> in
WinFsp, symlinks cannot currently point outside of the mounted file
system.  Furthermore, due to another
<a href="https://github.com/winfsp/winfsp/issues/530" data-hovercard-type="issue" data-hovercard-url="/winfsp/winfsp/issues/530/hovercard">problem</a> in WinFsp,
symlinks with a drive letter will appear with a mangled target path.</p>
</li>
<li>
<p dir="auto">The DwarFS driver on Windows correctly reports hardlink counts via
its API, but currently these counts are not correctly propagated
to the Windows file system layer. This is presumably due to a
<a href="https://github.com/winfsp/winfsp/issues/511" data-hovercard-type="issue" data-hovercard-url="/winfsp/winfsp/issues/511/hovercard">problem</a> in WinFsp.</p>
</li>
<li>
<p dir="auto">When mounting a DwarFS image on Windows, the mount point must not
exist. This is different from Linux, where the mount point must
actually exist. Also, it&#39;s possible to mount a DwarFS image as a
drive letter, e.g.</p>
<p dir="auto">dwarfs.exe image.dwarfs Z:</p>
</li>
<li>
<p dir="auto">Filter rules for <code>mkdwarfs</code> always require Unix path separators,
regardless of whether it&#39;s running on Windows or Linux.</p>
</li>
</ul>

<p dir="auto">Building on Windows is not too complicated thanks to <a href="https://vcpkg.io/" rel="nofollow">vcpkg</a>.
You&#39;ll need to install:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://visualstudio.microsoft.com/vs/features/cplusplus/" rel="nofollow">Visual Studio and the MSVC C/C++ compiler</a></p>
</li>
<li>
<p dir="auto"><a href="https://git-scm.com/download/win" rel="nofollow">Git</a></p>
</li>
<li>
<p dir="auto"><a href="https://cmake.org/download/" rel="nofollow">CMake</a></p>
</li>
<li>
<p dir="auto"><a href="https://github.com/ninja-build/ninja/releases">Ninja</a></p>
</li>
<li>
<p dir="auto"><a href="https://github.com/winfsp/winfsp/releases">WinFsp</a></p>
</li>
</ul>
<p dir="auto"><code>WinFsp</code> is expected to be installed in <code>C:\Program Files (x68)\WinFsp</code>;
if it&#39;s not, you&#39;ll need to set <code>WINFSP_PATH</code> when running CMake via
<code>cmake/win.bat</code>.</p>
<p dir="auto">Now you need to clone <code>vcpkg</code> and <code>dwarfs</code>:</p>
<div data-snippet-clipboard-copy-content="&gt; cd %HOMEPATH%
&gt; mkdir git
&gt; cd git
&gt; git clone https://github.com/Microsoft/vcpkg.git
&gt; git clone https://github.com/mhx/dwarfs"><pre><code>&gt; cd %HOMEPATH%
&gt; mkdir git
&gt; cd git
&gt; git clone https://github.com/Microsoft/vcpkg.git
&gt; git clone https://github.com/mhx/dwarfs
</code></pre></div>
<p dir="auto">Then, bootstrap <code>vcpkg</code>:</p>
<div data-snippet-clipboard-copy-content="&gt; .\vcpkg\bootstrap-vcpkg.bat"><pre><code>&gt; .\vcpkg\bootstrap-vcpkg.bat
</code></pre></div>
<p dir="auto">And build DwarFS:</p>
<div data-snippet-clipboard-copy-content="&gt; cd dwarfs
&gt; mkdir build
&gt; cd build
&gt; ..\cmake\win.bat
&gt; ninja"><pre><code>&gt; cd dwarfs
&gt; mkdir build
&gt; cd build
&gt; ..\cmake\win.bat
&gt; ninja
</code></pre></div>
<p dir="auto">Once that&#39;s done, you should be able to run the tests.
Set <code>CTEST_PARALLEL_LEVEL</code> according to the number of CPU cores in
your machine.</p>
<div data-snippet-clipboard-copy-content="&gt; set CTEST_PARALLEL_LEVEL=10
&gt; ninja test"><pre><code>&gt; set CTEST_PARALLEL_LEVEL=10
&gt; ninja test
</code></pre></div>

<p dir="auto">Support for the macOS operating system is currently experimental.</p>
<p dir="auto">The macOS version of the DwarFS filesystem driver relies on the awesome
<a href="https://https://osxfuse.github.io/" rel="nofollow">macFUSE</a> project.</p>

<p dir="auto">Building on macOS involves a few steps, but should be relatively
straightforward:</p>
<ul dir="auto">
<li>
<p dir="auto">Install <a href="https://brew.sh/" rel="nofollow">Homebrew</a></p>
</li>
<li>
<p dir="auto">Use Homebrew to install the necessary dependencies:</p>
</li>
</ul>
<div data-snippet-clipboard-copy-content="$ brew install cmake ninja ronn macfuse python3 brotli howard-hinnant-date \
               double-conversion fmt glog libarchive libevent flac openssl \
               pkg-config range-v3 utf8cpp xxhash boost zstd jemalloc"><pre><code>$ brew install cmake ninja ronn macfuse python3 brotli howard-hinnant-date \
               double-conversion fmt glog libarchive libevent flac openssl \
               pkg-config range-v3 utf8cpp xxhash boost zstd jemalloc
</code></pre></div>
<ul dir="auto">
<li>
<p dir="auto">When installing macFUSE for the first time, you&#39;ll need to explicitly
allow the sofware in <em>System Preferences</em> / <em>Privacy &amp; Security</em>. It&#39;s
quite likely that you&#39;ll have to reboot after this.</p>
</li>
<li>
<p dir="auto">Clone the DwarFS repository:</p>
</li>
</ul>
<div data-snippet-clipboard-copy-content="$ git clone --recurse-submodules https://github.com/mhx/dwarfs"><pre><code>$ git clone --recurse-submodules https://github.com/mhx/dwarfs
</code></pre></div>
<ul dir="auto">
<li>Prepare the build by installing the <code>mistletoe</code> python module
in a virtualenv:</li>
</ul>
<div data-snippet-clipboard-copy-content="$ cd dwarfs
$ python3 -m venv @buildenv
$ source ./@buildenv/bin/activate
$ pip3 install mistletoe"><pre><code>$ cd dwarfs
$ python3 -m venv @buildenv
$ source ./@buildenv/bin/activate
$ pip3 install mistletoe
</code></pre></div>
<ul dir="auto">
<li>Build DwarFS and run its tests:</li>
</ul>
<div data-snippet-clipboard-copy-content="$ git checkout v0.9.4
$ git submodule update
$ mkdir build &amp;&amp; cd build
$ cmake .. -GNinja -DWITH_TESTS=ON
$ ninja
$ export CTEST_PARALLEL_LEVEL=$(sysctl -n hw.logicalcpu)
$ ninja test"><pre><code>$ git checkout v0.9.4
$ git submodule update
$ mkdir build &amp;&amp; cd build
$ cmake .. -GNinja -DWITH_TESTS=ON
$ ninja
$ export CTEST_PARALLEL_LEVEL=$(sysctl -n hw.logicalcpu)
$ ninja test
</code></pre></div>
<ul dir="auto">
<li>Install DwarFS:</li>
</ul>

<p dir="auto">That&#39;s it!</p>


<p dir="auto">Astrophotography can generate huge amounts of raw image data. During a
single night, it&#39;s not unlikely to end up with a few dozens of gigabytes
of data. With most dedicated astrophotography cameras, this data ends up
in the form of FITS images. These are usually uncompressed, don&#39;t compress
very well with standard compression algorithms, and while there are certain
compressed FITS formats, these aren&#39;t widely supported.</p>
<p dir="auto">One of the compression formats (simply called &#34;Rice&#34;) compresses reasonably
well and is really fast. However, its implementation for compressed FITS
has a few drawbacks. The most severe drawbacks are that compression isn&#39;t
quite as good as it could be for color sensors and sensors with a less than
16 bits of resolution.</p>
<p dir="auto">DwarFS supports the <code>ricepp</code> (Rice++) compression, which builds on the basic
idea of Rice compression, but makes a few enhancements: it compresses color
and low bit depth images significantly better and always searches for the
optimum solution during compression instead of relying on a heuristic.</p>
<p dir="auto">Let&#39;s look at an example using 129 images (darks, flats and lights) taken
with an ASI1600MM camera. Each image is 32 MiB, so a total of 4 GiB of data.
Compressing these with the standard <code>fpack</code> tool takes about 16.6 seconds
and yields a total output size of 2.2 GiB:</p>
<div data-snippet-clipboard-copy-content="$ time fpack */*.fit */*/*.fit

user	14.992
system	1.592
total	16.616

$ find . -name &#39;*.fz&#39; -print0 | xargs -0 cat | wc -c
2369943360"><pre><code>$ time fpack */*.fit */*/*.fit

user	14.992
system	1.592
total	16.616

$ find . -name &#39;*.fz&#39; -print0 | xargs -0 cat | wc -c
2369943360
</code></pre></div>
<p dir="auto">However, this leaves you with <code>*.fz</code> files that not every application can
actually read.</p>
<p dir="auto">Using DwarFS, here&#39;s what we get:</p>
<div data-snippet-clipboard-copy-content="$ mkdwarfs -i ASI1600 -o asi1600-20.dwarfs -S 20 --categorize
I 08:47:47.459077 scanning &#34;ASI1600&#34;
I 08:47:47.491492 assigning directory and link inodes...
I 08:47:47.491560 waiting for background scanners...
I 08:47:47.675241 scanning CPU time: 1.051s
I 08:47:47.675271 finalizing file inodes...
I 08:47:47.675330 saved 0 B / 3.941 GiB in 0/258 duplicate files
I 08:47:47.675360 assigning device inodes...
I 08:47:47.675371 assigning pipe/socket inodes...
I 08:47:47.675381 building metadata...
I 08:47:47.675393 building blocks...
I 08:47:47.675398 saving names and symlinks...
I 08:47:47.675514 updating name and link indices...
I 08:47:47.675796 waiting for segmenting/blockifying to finish...
I 08:47:50.274285 total ordering CPU time: 616.3us
I 08:47:50.274329 total segmenting CPU time: 1.132s
I 08:47:50.279476 saving chunks...
I 08:47:50.279622 saving directories...
I 08:47:50.279674 saving shared files table...
I 08:47:50.280745 saving names table... [1.047ms]
I 08:47:50.280768 saving symlinks table... [743ns]
I 08:47:50.282031 waiting for compression to finish...
I 08:47:50.823924 compressed 3.941 GiB to 1.201 GiB (ratio=0.304825)
I 08:47:50.824280 compression CPU time: 17.92s
I 08:47:50.824316 filesystem created without errors [3.366s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
5 dirs, 0/0 soft/hard links, 258/258 files, 0 other
original size: 3.941 GiB, hashed: 315.4 KiB (18 files, 0 B/s)
scanned: 3.941 GiB (258 files, 117.1 GiB/s), categorizing: 0 B/s
saved by deduplication: 0 B (0 files), saved by segmenting: 0 B
filesystem: 3.941 GiB in 4037 blocks (4550 chunks, 516/516 fragments, 258 inodes)
compressed filesystem: 4037 blocks/1.201 GiB written"><pre><code>$ mkdwarfs -i ASI1600 -o asi1600-20.dwarfs -S 20 --categorize
I 08:47:47.459077 scanning &#34;ASI1600&#34;
I 08:47:47.491492 assigning directory and link inodes...
I 08:47:47.491560 waiting for background scanners...
I 08:47:47.675241 scanning CPU time: 1.051s
I 08:47:47.675271 finalizing file inodes...
I 08:47:47.675330 saved 0 B / 3.941 GiB in 0/258 duplicate files
I 08:47:47.675360 assigning device inodes...
I 08:47:47.675371 assigning pipe/socket inodes...
I 08:47:47.675381 building metadata...
I 08:47:47.675393 building blocks...
I 08:47:47.675398 saving names and symlinks...
I 08:47:47.675514 updating name and link indices...
I 08:47:47.675796 waiting for segmenting/blockifying to finish...
I 08:47:50.274285 total ordering CPU time: 616.3us
I 08:47:50.274329 total segmenting CPU time: 1.132s
I 08:47:50.279476 saving chunks...
I 08:47:50.279622 saving directories...
I 08:47:50.279674 saving shared files table...
I 08:47:50.280745 saving names table... [1.047ms]
I 08:47:50.280768 saving symlinks table... [743ns]
I 08:47:50.282031 waiting for compression to finish...
I 08:47:50.823924 compressed 3.941 GiB to 1.201 GiB (ratio=0.304825)
I 08:47:50.824280 compression CPU time: 17.92s
I 08:47:50.824316 filesystem created without errors [3.366s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
5 dirs, 0/0 soft/hard links, 258/258 files, 0 other
original size: 3.941 GiB, hashed: 315.4 KiB (18 files, 0 B/s)
scanned: 3.941 GiB (258 files, 117.1 GiB/s), categorizing: 0 B/s
saved by deduplication: 0 B (0 files), saved by segmenting: 0 B
filesystem: 3.941 GiB in 4037 blocks (4550 chunks, 516/516 fragments, 258 inodes)
compressed filesystem: 4037 blocks/1.201 GiB written
</code></pre></div>
<p dir="auto">In less than 3.4 seconds, it compresses the data down to 1.2 GiB, almost
half the size of the <code>fpack</code> output.</p>
<p dir="auto">In addition to saving a lot of disk space, this can also be useful when your
data is stored on a NAS. Here&#39;s a comparison of the same set of data accessed
over a 1 Gb/s network connection, first using the uncompressed raw data:</p>
<div data-snippet-clipboard-copy-content="find /mnt/ASI1600 -name &#39;*.fit&#39; -print0 | xargs -0 -P4 -n1 cat | dd of=/dev/null status=progress
4229012160 bytes (4.2 GB, 3.9 GiB) copied, 36.0455 s, 117 MB/s"><pre><code>find /mnt/ASI1600 -name &#39;*.fit&#39; -print0 | xargs -0 -P4 -n1 cat | dd of=/dev/null status=progress
4229012160 bytes (4.2 GB, 3.9 GiB) copied, 36.0455 s, 117 MB/s
</code></pre></div>
<p dir="auto">And next using a DwarFS image on the same share:</p>
<div data-snippet-clipboard-copy-content="$ dwarfs /mnt/asi1600-20.dwarfs mnt

$ find mnt -name &#39;*.fit&#39; -print0 | xargs -0 -P4 -n1 cat | dd of=/dev/null status=progress
4229012160 bytes (4.2 GB, 3.9 GiB) copied, 14.3681 s, 294 MB/s"><pre><code>$ dwarfs /mnt/asi1600-20.dwarfs mnt

$ find mnt -name &#39;*.fit&#39; -print0 | xargs -0 -P4 -n1 cat | dd of=/dev/null status=progress
4229012160 bytes (4.2 GB, 3.9 GiB) copied, 14.3681 s, 294 MB/s
</code></pre></div>
<p dir="auto">That&#39;s roughly 2.5 times faster. You can very likely see similar results
with slow external hard drives.</p>

<p dir="auto">Currently, DwarFS has no built-in ability to add recovery information to a
file system image. However, for archival purposes, it&#39;s a good idea to have
such recovery infomation in order to be able to repair a damaged image.</p>
<p dir="auto">This is fortunately relatively straightforward using something like
<a href="https://github.com/Parchive/par2cmdline">par2cmdline</a>:</p>
<div data-snippet-clipboard-copy-content="$ par2create -n1 asi1600-20.dwarfs"><pre><code>$ par2create -n1 asi1600-20.dwarfs
</code></pre></div>
<p dir="auto">This will create two additional files that you can place alongside the image
(or on a different storage), as you&#39;ll only need them if DwarFS has detected
an issue with the file system image. If there&#39;s an issue, you can run</p>
<div data-snippet-clipboard-copy-content="$ par2repair asi1600-20.dwarfs"><pre><code>$ par2repair asi1600-20.dwarfs
</code></pre></div>
<p dir="auto">which will very likely be able to recover the image if less than 5% (that&#39;s
the default used by <code>par2create</code>) of the image are damaged.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">Preserving Extended Attributes in DwarFS Images</h3><a id="user-content-preserving-extended-attributes-in-dwarfs-images" aria-label="Permalink: Preserving Extended Attributes in DwarFS Images" href="#preserving-extended-attributes-in-dwarfs-images"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Extended attributes are not currently supported. Any extended attributes
stored in the source file system will not currently be preserved when
building a DwarFS image using <code>mkdwarfs</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Extended Attributes exposed by the FUSE Driver</h3><a id="user-content-extended-attributes-exposed-by-the-fuse-driver" aria-label="Permalink: Extended Attributes exposed by the FUSE Driver" href="#extended-attributes-exposed-by-the-fuse-driver"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">That being said, the root inode of a mounted DwarFS image currently exposes
one or two extended attributes on Linux:</p>
<div data-snippet-clipboard-copy-content="$ attr -l mnt
Attribute &#34;dwarfs.driver.pid&#34; has a 4 byte value for mnt
Attribute &#34;dwarfs.driver.perfmon&#34; has a 4849 byte value for mnt"><pre><code>$ attr -l mnt
Attribute &#34;dwarfs.driver.pid&#34; has a 4 byte value for mnt
Attribute &#34;dwarfs.driver.perfmon&#34; has a 4849 byte value for mnt
</code></pre></div>
<p dir="auto">The <code>dwarfs.driver.pid</code> attribute simply contains the PID of the DwarFS
FUSE driver. The <code>dwarfs.driver.perfmon</code> attribute contains the current
results of the <a href="#performance-monitoring">performance monitor</a>.</p>
<p dir="auto">Furthermore, each regular file exposes an attribute <code>dwarfs.inodeinfo</code>
with information about the undelying inode:</p>
<div data-snippet-clipboard-copy-content="$ attr -l &#34;05 Disappear.caf&#34;
Attribute &#34;dwarfs.inodeinfo&#34; has a 448 byte value for 05 Disappear.caf"><pre><code>$ attr -l &#34;05 Disappear.caf&#34;
Attribute &#34;dwarfs.inodeinfo&#34; has a 448 byte value for 05 Disappear.caf
</code></pre></div>
<p dir="auto">The attribute contains a JSON object with information about the
underlying inode:</p>
<div data-snippet-clipboard-copy-content="$ attr -qg dwarfs.inodeinfo &#34;05 Disappear.caf&#34;
{
  &#34;chunks&#34;: [
    {
      &#34;block&#34;: 2,
      &#34;category&#34;: &#34;pcmaudio/metadata&#34;,
      &#34;offset&#34;: 270976,
      &#34;size&#34;: 4096
    },
    {
      &#34;block&#34;: 414,
      &#34;category&#34;: &#34;pcmaudio/waveform&#34;,
      &#34;offset&#34;: 37594368,
      &#34;size&#34;: 29514492
    },
    {
      &#34;block&#34;: 419,
      &#34;category&#34;: &#34;pcmaudio/waveform&#34;,
      &#34;offset&#34;: 0,
      &#34;size&#34;: 29385468
    }
  ],
  &#34;gid&#34;: 100,
  &#34;mode&#34;: 33188,
  &#34;modestring&#34;: &#34;----rw-r--r--&#34;,
  &#34;uid&#34;: 1000
}"><pre><code>$ attr -qg dwarfs.inodeinfo &#34;05 Disappear.caf&#34;
{
  &#34;chunks&#34;: [
    {
      &#34;block&#34;: 2,
      &#34;category&#34;: &#34;pcmaudio/metadata&#34;,
      &#34;offset&#34;: 270976,
      &#34;size&#34;: 4096
    },
    {
      &#34;block&#34;: 414,
      &#34;category&#34;: &#34;pcmaudio/waveform&#34;,
      &#34;offset&#34;: 37594368,
      &#34;size&#34;: 29514492
    },
    {
      &#34;block&#34;: 419,
      &#34;category&#34;: &#34;pcmaudio/waveform&#34;,
      &#34;offset&#34;: 0,
      &#34;size&#34;: 29385468
    }
  ],
  &#34;gid&#34;: 100,
  &#34;mode&#34;: 33188,
  &#34;modestring&#34;: &#34;----rw-r--r--&#34;,
  &#34;uid&#34;: 1000
}
</code></pre></div>
<p dir="auto">This is useful, for example, to check how a particular file is spread
across multiple blocks or which categories have been assigned to the
file.</p>

<p dir="auto">The SquashFS, <code>xz</code>, <code>lrzip</code>, <code>zpaq</code> and <code>wimlib</code> tests were all done on
an 8 core Intel(R) Xeon(R) E-2286M CPU @ 2.40GHz with 64 GiB of RAM.</p>
<p dir="auto">The Cromfs and EROFS tests were done with an older version of DwarFS
on a 6 core Intel(R) Xeon(R) CPU D-1528 @ 1.90GHz with 64 GiB of RAM.</p>
<p dir="auto">The systems were mostly idle during all of the tests.</p>

<p dir="auto">The source directory contained <strong>1139 different Perl installations</strong>
from 284 distinct releases, a total of 47.65 GiB of data in 1,927,501
files and 330,733 directories. The source directory was freshly
unpacked from a tar archive to an XFS partition on a 970 EVO Plus 2TB
NVME drive, so most of its contents were likely cached.</p>
<p dir="auto">I&#39;m using the same compression type and compression level for
SquashFS that is the default setting for DwarFS:</p>
<div data-snippet-clipboard-copy-content="$ time mksquashfs install perl-install.squashfs -comp zstd -Xcompression-level 22
Parallel mksquashfs: Using 16 processors
Creating 4.0 filesystem on perl-install-zstd.squashfs, block size 131072.
[=========================================================/] 2107401/2107401 100%

Exportable Squashfs 4.0 filesystem, zstd compressed, data block size 131072
        compressed data, compressed metadata, compressed fragments,
        compressed xattrs, compressed ids
        duplicates are removed
Filesystem size 4637597.63 Kbytes (4528.90 Mbytes)
        9.29% of uncompressed filesystem size (49922299.04 Kbytes)
Inode table size 19100802 bytes (18653.13 Kbytes)
        26.06% of uncompressed inode table size (73307702 bytes)
Directory table size 19128340 bytes (18680.02 Kbytes)
        46.28% of uncompressed directory table size (41335540 bytes)
Number of duplicate files found 1780387
Number of inodes 2255794
Number of files 1925061
Number of fragments 28713
Number of symbolic links  0
Number of device nodes 0
Number of fifo nodes 0
Number of socket nodes 0
Number of directories 330733
Number of ids (unique uids + gids) 2
Number of uids 1
        mhx (1000)
Number of gids 1
        users (100)

real    32m54.713s
user    501m46.382s
sys     0m58.528s"><pre><code>$ time mksquashfs install perl-install.squashfs -comp zstd -Xcompression-level 22
Parallel mksquashfs: Using 16 processors
Creating 4.0 filesystem on perl-install-zstd.squashfs, block size 131072.
[=========================================================/] 2107401/2107401 100%

Exportable Squashfs 4.0 filesystem, zstd compressed, data block size 131072
        compressed data, compressed metadata, compressed fragments,
        compressed xattrs, compressed ids
        duplicates are removed
Filesystem size 4637597.63 Kbytes (4528.90 Mbytes)
        9.29% of uncompressed filesystem size (49922299.04 Kbytes)
Inode table size 19100802 bytes (18653.13 Kbytes)
        26.06% of uncompressed inode table size (73307702 bytes)
Directory table size 19128340 bytes (18680.02 Kbytes)
        46.28% of uncompressed directory table size (41335540 bytes)
Number of duplicate files found 1780387
Number of inodes 2255794
Number of files 1925061
Number of fragments 28713
Number of symbolic links  0
Number of device nodes 0
Number of fifo nodes 0
Number of socket nodes 0
Number of directories 330733
Number of ids (unique uids + gids) 2
Number of uids 1
        mhx (1000)
Number of gids 1
        users (100)

real    32m54.713s
user    501m46.382s
sys     0m58.528s
</code></pre></div>
<p dir="auto">For DwarFS, I&#39;m sticking to the defaults:</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i install -o perl-install.dwarfs
I 11:33:33.310931 scanning install
I 11:33:39.026712 waiting for background scanners...
I 11:33:50.681305 assigning directory and link inodes...
I 11:33:50.888441 finding duplicate files...
I 11:34:01.120800 saved 28.2 GiB / 47.65 GiB in 1782826/1927501 duplicate files
I 11:34:01.122608 waiting for inode scanners...
I 11:34:12.839065 assigning device inodes...
I 11:34:12.875520 assigning pipe/socket inodes...
I 11:34:12.910431 building metadata...
I 11:34:12.910524 building blocks...
I 11:34:12.910594 saving names and links...
I 11:34:12.910691 bloom filter size: 32 KiB
I 11:34:12.910760 ordering 144675 inodes using nilsimsa similarity...
I 11:34:12.915555 nilsimsa: depth=20000 (1000), limit=255
I 11:34:13.052525 updating name and link indices...
I 11:34:13.276233 pre-sorted index (660176 name, 366179 path lookups) [360.6ms]
I 11:35:44.039375 144675 inodes ordered [91.13s]
I 11:35:44.041427 waiting for segmenting/blockifying to finish...
I 11:37:38.823902 bloom filter reject rate: 96.017% (TPR=0.244%, lookups=4740563665)
I 11:37:38.823963 segmentation matches: good=454708, bad=6819, total=464247
I 11:37:38.824005 segmentation collisions: L1=0.008%, L2=0.000% [2233254 hashes]
I 11:37:38.824038 saving chunks...
I 11:37:38.860939 saving directories...
I 11:37:41.318747 waiting for compression to finish...
I 11:38:56.046809 compressed 47.65 GiB to 430.9 MiB (ratio=0.00883101)
I 11:38:56.304922 filesystem created without errors [323s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
330733 dirs, 0/2440 soft/hard links, 1927501/1927501 files, 0 other
original size: 47.65 GiB, dedupe: 28.2 GiB (1782826 files), segment: 15.19 GiB
filesystem: 4.261 GiB in 273 blocks (319178 chunks, 144675/144675 inodes)
compressed filesystem: 273 blocks/430.9 MiB written [depth: 20000]
█████████████████████████████████████████████████████████████████████████████▏100% |

real    5m23.030s
user    78m7.554s
sys     1m47.968s"><pre><code>$ time mkdwarfs -i install -o perl-install.dwarfs
I 11:33:33.310931 scanning install
I 11:33:39.026712 waiting for background scanners...
I 11:33:50.681305 assigning directory and link inodes...
I 11:33:50.888441 finding duplicate files...
I 11:34:01.120800 saved 28.2 GiB / 47.65 GiB in 1782826/1927501 duplicate files
I 11:34:01.122608 waiting for inode scanners...
I 11:34:12.839065 assigning device inodes...
I 11:34:12.875520 assigning pipe/socket inodes...
I 11:34:12.910431 building metadata...
I 11:34:12.910524 building blocks...
I 11:34:12.910594 saving names and links...
I 11:34:12.910691 bloom filter size: 32 KiB
I 11:34:12.910760 ordering 144675 inodes using nilsimsa similarity...
I 11:34:12.915555 nilsimsa: depth=20000 (1000), limit=255
I 11:34:13.052525 updating name and link indices...
I 11:34:13.276233 pre-sorted index (660176 name, 366179 path lookups) [360.6ms]
I 11:35:44.039375 144675 inodes ordered [91.13s]
I 11:35:44.041427 waiting for segmenting/blockifying to finish...
I 11:37:38.823902 bloom filter reject rate: 96.017% (TPR=0.244%, lookups=4740563665)
I 11:37:38.823963 segmentation matches: good=454708, bad=6819, total=464247
I 11:37:38.824005 segmentation collisions: L1=0.008%, L2=0.000% [2233254 hashes]
I 11:37:38.824038 saving chunks...
I 11:37:38.860939 saving directories...
I 11:37:41.318747 waiting for compression to finish...
I 11:38:56.046809 compressed 47.65 GiB to 430.9 MiB (ratio=0.00883101)
I 11:38:56.304922 filesystem created without errors [323s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
330733 dirs, 0/2440 soft/hard links, 1927501/1927501 files, 0 other
original size: 47.65 GiB, dedupe: 28.2 GiB (1782826 files), segment: 15.19 GiB
filesystem: 4.261 GiB in 273 blocks (319178 chunks, 144675/144675 inodes)
compressed filesystem: 273 blocks/430.9 MiB written [depth: 20000]
█████████████████████████████████████████████████████████████████████████████▏100% |

real    5m23.030s
user    78m7.554s
sys     1m47.968s
</code></pre></div>
<p dir="auto">So in this comparison, <code>mkdwarfs</code> is <strong>more than 6 times faster</strong> than <code>mksquashfs</code>,
both in terms of CPU time and wall clock time.</p>
<div data-snippet-clipboard-copy-content="$ ll perl-install.*fs
-rw-r--r-- 1 mhx users  447230618 Mar  3 20:28 perl-install.dwarfs
-rw-r--r-- 1 mhx users 4748902400 Mar  3 20:10 perl-install.squashfs"><pre><code>$ ll perl-install.*fs
-rw-r--r-- 1 mhx users  447230618 Mar  3 20:28 perl-install.dwarfs
-rw-r--r-- 1 mhx users 4748902400 Mar  3 20:10 perl-install.squashfs
</code></pre></div>
<p dir="auto">In terms of compression ratio, the <strong>DwarFS file system is more than 10 times
smaller than the SquashFS file system</strong>. With DwarFS, the content has been
<strong>compressed down to less than 0.9% (!) of its original size</strong>. This compression
ratio only considers the data stored in the individual files, not the actual
disk space used. On the original XFS file system, according to <code>du</code>, the
source folder uses 52 GiB, so <strong>the DwarFS image actually only uses 0.8% of
the original space</strong>.</p>
<p dir="auto">Here&#39;s another comparison using <code>lzma</code> compression instead of <code>zstd</code>:</p>
<div data-snippet-clipboard-copy-content="$ time mksquashfs install perl-install-lzma.squashfs -comp lzma

real    13m42.825s
user    205m40.851s
sys     3m29.088s"><pre><code>$ time mksquashfs install perl-install-lzma.squashfs -comp lzma

real    13m42.825s
user    205m40.851s
sys     3m29.088s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i install -o perl-install-lzma.dwarfs -l9

real    3m43.937s
user    49m45.295s
sys     1m44.550s"><pre><code>$ time mkdwarfs -i install -o perl-install-lzma.dwarfs -l9

real    3m43.937s
user    49m45.295s
sys     1m44.550s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ll perl-install-lzma.*fs
-rw-r--r-- 1 mhx users  315482627 Mar  3 21:23 perl-install-lzma.dwarfs
-rw-r--r-- 1 mhx users 3838406656 Mar  3 20:50 perl-install-lzma.squashfs"><pre><code>$ ll perl-install-lzma.*fs
-rw-r--r-- 1 mhx users  315482627 Mar  3 21:23 perl-install-lzma.dwarfs
-rw-r--r-- 1 mhx users 3838406656 Mar  3 20:50 perl-install-lzma.squashfs
</code></pre></div>
<p dir="auto">It&#39;s immediately obvious that the runs are significantly faster and the
resulting images are significantly smaller. Still, <code>mkdwarfs</code> is about
<strong>4 times faster</strong> and produces and image that&#39;s <strong>12 times smaller</strong> than
the SquashFS image. The DwarFS image is only 0.6% of the original file size.</p>
<p dir="auto">So, why not use <code>lzma</code> instead of <code>zstd</code> by default? The reason is that <code>lzma</code>
is about an order of magnitude slower to decompress than <code>zstd</code>. If you&#39;re
only accessing data on your compressed filesystem occasionally, this might
not be a big deal, but if you use it extensively, <code>zstd</code> will result in
better performance.</p>
<p dir="auto">The comparisons above are not completely fair. <code>mksquashfs</code> by default
uses a block size of 128KiB, whereas <code>mkdwarfs</code> uses 16MiB blocks by default,
or even 64MiB blocks with <code>-l9</code>. When using identical block sizes for both
file systems, the difference, quite expectedly, becomes a lot less dramatic:</p>
<div data-snippet-clipboard-copy-content="$ time mksquashfs install perl-install-lzma-1M.squashfs -comp lzma -b 1M

real    15m43.319s
user    139m24.533s
sys     0m45.132s"><pre><code>$ time mksquashfs install perl-install-lzma-1M.squashfs -comp lzma -b 1M

real    15m43.319s
user    139m24.533s
sys     0m45.132s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i install -o perl-install-lzma-1M.dwarfs -l9 -S20 -B3

real    4m25.973s
user    52m15.100s
sys     7m41.889s"><pre><code>$ time mkdwarfs -i install -o perl-install-lzma-1M.dwarfs -l9 -S20 -B3

real    4m25.973s
user    52m15.100s
sys     7m41.889s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ll perl-install*.*fs
-rw-r--r-- 1 mhx users  935953866 Mar 13 12:12 perl-install-lzma-1M.dwarfs
-rw-r--r-- 1 mhx users 3407474688 Mar  3 21:54 perl-install-lzma-1M.squashfs"><pre><code>$ ll perl-install*.*fs
-rw-r--r-- 1 mhx users  935953866 Mar 13 12:12 perl-install-lzma-1M.dwarfs
-rw-r--r-- 1 mhx users 3407474688 Mar  3 21:54 perl-install-lzma-1M.squashfs
</code></pre></div>
<p dir="auto">Even this is <em>still</em> not entirely fair, as it uses a feature (<code>-B3</code>) that allows
DwarFS to reference file chunks from up to two previous filesystem blocks.</p>
<p dir="auto">But the point is that this is really where SquashFS tops out, as it doesn&#39;t
support larger block sizes or back-referencing. And as you&#39;ll see below, the
larger blocks that DwarFS is using by default don&#39;t necessarily negatively
impact performance.</p>
<p dir="auto">DwarFS also features an option to recompress an existing file system with
a different compression algorithm. This can be useful as it allows relatively
fast experimentation with different algorithms and options without requiring
a full rebuild of the file system. For example, recompressing the above file
system with the best possible compression (<code>-l 9</code>):</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs --recompress -i perl-install.dwarfs -o perl-lzma-re.dwarfs -l9
I 20:28:03.246534 filesystem rewrittenwithout errors [148.3s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
filesystem: 4.261 GiB in 273 blocks (0 chunks, 0 inodes)
compressed filesystem: 273/273 blocks/372.7 MiB written
████████████████████████████████████████████████████████████████████▏100% \

real    2m28.279s
user    37m8.825s
sys     0m43.256s"><pre><code>$ time mkdwarfs --recompress -i perl-install.dwarfs -o perl-lzma-re.dwarfs -l9
I 20:28:03.246534 filesystem rewrittenwithout errors [148.3s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
filesystem: 4.261 GiB in 273 blocks (0 chunks, 0 inodes)
compressed filesystem: 273/273 blocks/372.7 MiB written
████████████████████████████████████████████████████████████████████▏100% \

real    2m28.279s
user    37m8.825s
sys     0m43.256s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ll perl-*.dwarfs
-rw-r--r-- 1 mhx users 447230618 Mar  3 20:28 perl-install.dwarfs
-rw-r--r-- 1 mhx users 390845518 Mar  4 20:28 perl-lzma-re.dwarfs
-rw-r--r-- 1 mhx users 315482627 Mar  3 21:23 perl-install-lzma.dwarfs"><pre><code>$ ll perl-*.dwarfs
-rw-r--r-- 1 mhx users 447230618 Mar  3 20:28 perl-install.dwarfs
-rw-r--r-- 1 mhx users 390845518 Mar  4 20:28 perl-lzma-re.dwarfs
-rw-r--r-- 1 mhx users 315482627 Mar  3 21:23 perl-install-lzma.dwarfs
</code></pre></div>
<p dir="auto">Note that while the recompressed filesystem is smaller than the original image,
it is still a lot bigger than the filesystem we previously build with <code>-l9</code>.
The reason is that the recompressed image still uses the same block size, and
the block size cannot be changed by recompressing.</p>
<p dir="auto">In terms of how fast the file system is when using it, a quick test
I&#39;ve done is to freshly mount the filesystem created above and run
each of the 1139 <code>perl</code> executables to print their version.</p>
<div data-snippet-clipboard-copy-content="$ hyperfine -c &#34;umount mnt&#34; -p &#34;umount mnt; dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#34; -P procs 5 20 -D 5 &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P5 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.810 s ±  0.013 s    [User: 1.847 s, System: 0.623 s]
  Range (min … max):    1.788 s …  1.825 s    10 runs

Benchmark #2: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.333 s ±  0.009 s    [User: 1.993 s, System: 0.656 s]
  Range (min … max):    1.321 s …  1.354 s    10 runs

Benchmark #3: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P15 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.181 s ±  0.018 s    [User: 2.086 s, System: 0.712 s]
  Range (min … max):    1.165 s …  1.214 s    10 runs

Benchmark #4: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.149 s ±  0.015 s    [User: 2.128 s, System: 0.781 s]
  Range (min … max):    1.136 s …  1.186 s    10 runs"><pre><code>$ hyperfine -c &#34;umount mnt&#34; -p &#34;umount mnt; dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#34; -P procs 5 20 -D 5 &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P5 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.810 s ±  0.013 s    [User: 1.847 s, System: 0.623 s]
  Range (min … max):    1.788 s …  1.825 s    10 runs

Benchmark #2: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.333 s ±  0.009 s    [User: 1.993 s, System: 0.656 s]
  Range (min … max):    1.321 s …  1.354 s    10 runs

Benchmark #3: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P15 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.181 s ±  0.018 s    [User: 2.086 s, System: 0.712 s]
  Range (min … max):    1.165 s …  1.214 s    10 runs

Benchmark #4: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      1.149 s ±  0.015 s    [User: 2.128 s, System: 0.781 s]
  Range (min … max):    1.136 s …  1.186 s    10 runs
</code></pre></div>
<p dir="auto">These timings are for <em>initial</em> runs on a freshly mounted file system,
running 5, 10, 15 and 20 processes in parallel. 1.1 seconds means that
it takes only about 1 millisecond per Perl binary.</p>
<p dir="auto">Following are timings for <em>subsequent</em> runs, both on DwarFS (at <code>mnt</code>)
and the original XFS (at <code>install</code>). DwarFS is around 15% slower here:</p>
<div data-snippet-clipboard-copy-content="$ hyperfine -P procs 10 20 -D 10 -w1 &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34; &#34;ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     347.0 ms ±   7.2 ms    [User: 1.755 s, System: 0.452 s]
  Range (min … max):   341.3 ms … 365.2 ms    10 runs

Benchmark #2: ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     302.5 ms ±   3.3 ms    [User: 1.656 s, System: 0.377 s]
  Range (min … max):   297.1 ms … 308.7 ms    10 runs

Benchmark #3: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     342.2 ms ±   4.1 ms    [User: 1.766 s, System: 0.451 s]
  Range (min … max):   336.0 ms … 349.7 ms    10 runs

Benchmark #4: ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     302.0 ms ±   3.0 ms    [User: 1.659 s, System: 0.374 s]
  Range (min … max):   297.0 ms … 305.4 ms    10 runs

Summary
  &#39;ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39; ran
    1.00 ± 0.01 times faster than &#39;ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39;
    1.13 ± 0.02 times faster than &#39;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39;
    1.15 ± 0.03 times faster than &#39;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39;"><pre><code>$ hyperfine -P procs 10 20 -D 10 -w1 &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34; &#34;ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     347.0 ms ±   7.2 ms    [User: 1.755 s, System: 0.452 s]
  Range (min … max):   341.3 ms … 365.2 ms    10 runs

Benchmark #2: ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     302.5 ms ±   3.3 ms    [User: 1.656 s, System: 0.377 s]
  Range (min … max):   297.1 ms … 308.7 ms    10 runs

Benchmark #3: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     342.2 ms ±   4.1 ms    [User: 1.766 s, System: 0.451 s]
  Range (min … max):   336.0 ms … 349.7 ms    10 runs

Benchmark #4: ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     302.0 ms ±   3.0 ms    [User: 1.659 s, System: 0.374 s]
  Range (min … max):   297.0 ms … 305.4 ms    10 runs

Summary
  &#39;ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39; ran
    1.00 ± 0.01 times faster than &#39;ls -1 install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39;
    1.13 ± 0.02 times faster than &#39;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39;
    1.15 ± 0.03 times faster than &#39;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;&#39;
</code></pre></div>
<p dir="auto">Using the lzma-compressed file system, the metrics for <em>initial</em> runs look
considerably worse (about an order of magnitude):</p>
<div data-snippet-clipboard-copy-content="$ hyperfine -c &#34;umount mnt&#34; -p &#34;umount mnt; dwarfs perl-install-lzma.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#34; -P procs 5 20 -D 5 &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P5 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     10.660 s ±  0.057 s    [User: 1.952 s, System: 0.729 s]
  Range (min … max):   10.615 s … 10.811 s    10 runs

Benchmark #2: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      9.092 s ±  0.021 s    [User: 1.979 s, System: 0.680 s]
  Range (min … max):    9.059 s …  9.126 s    10 runs

Benchmark #3: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P15 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      9.012 s ±  0.188 s    [User: 2.077 s, System: 0.702 s]
  Range (min … max):    8.839 s …  9.277 s    10 runs

Benchmark #4: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      9.004 s ±  0.298 s    [User: 2.134 s, System: 0.736 s]
  Range (min … max):    8.611 s …  9.555 s    10 runs"><pre><code>$ hyperfine -c &#34;umount mnt&#34; -p &#34;umount mnt; dwarfs perl-install-lzma.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#34; -P procs 5 20 -D 5 &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P{procs} sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P5 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):     10.660 s ±  0.057 s    [User: 1.952 s, System: 0.729 s]
  Range (min … max):   10.615 s … 10.811 s    10 runs

Benchmark #2: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P10 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      9.092 s ±  0.021 s    [User: 1.979 s, System: 0.680 s]
  Range (min … max):    9.059 s …  9.126 s    10 runs

Benchmark #3: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P15 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      9.012 s ±  0.188 s    [User: 2.077 s, System: 0.702 s]
  Range (min … max):    8.839 s …  9.277 s    10 runs

Benchmark #4: ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;$0 -v &gt;/dev/null&#39;
  Time (mean ± σ):      9.004 s ±  0.298 s    [User: 2.134 s, System: 0.736 s]
  Range (min … max):    8.611 s …  9.555 s    10 runs
</code></pre></div>
<p dir="auto">So you might want to consider using <code>zstd</code> instead of <code>lzma</code> if you&#39;d
like to optimize for file system performance. It&#39;s also the default
compression used by <code>mkdwarfs</code>.</p>
<p dir="auto">Now here&#39;s a comparison with the SquashFS filesystem:</p>
<div data-snippet-clipboard-copy-content="$ hyperfine -c &#39;sudo umount mnt&#39; -p &#39;umount mnt; dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#39; -n dwarfs-zstd &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34; -p &#39;sudo umount mnt; sudo mount -t squashfs perl-install.squashfs mnt; sleep 1&#39; -n squashfs-zstd &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: dwarfs-zstd
  Time (mean ± σ):      1.151 s ±  0.015 s    [User: 2.147 s, System: 0.769 s]
  Range (min … max):    1.118 s …  1.174 s    10 runs

Benchmark #2: squashfs-zstd
  Time (mean ± σ):      6.733 s ±  0.007 s    [User: 3.188 s, System: 17.015 s]
  Range (min … max):    6.721 s …  6.743 s    10 runs

Summary
  &#39;dwarfs-zstd&#39; ran
    5.85 ± 0.08 times faster than &#39;squashfs-zstd&#39;"><pre><code>$ hyperfine -c &#39;sudo umount mnt&#39; -p &#39;umount mnt; dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#39; -n dwarfs-zstd &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34; -p &#39;sudo umount mnt; sudo mount -t squashfs perl-install.squashfs mnt; sleep 1&#39; -n squashfs-zstd &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: dwarfs-zstd
  Time (mean ± σ):      1.151 s ±  0.015 s    [User: 2.147 s, System: 0.769 s]
  Range (min … max):    1.118 s …  1.174 s    10 runs

Benchmark #2: squashfs-zstd
  Time (mean ± σ):      6.733 s ±  0.007 s    [User: 3.188 s, System: 17.015 s]
  Range (min … max):    6.721 s …  6.743 s    10 runs

Summary
  &#39;dwarfs-zstd&#39; ran
    5.85 ± 0.08 times faster than &#39;squashfs-zstd&#39;
</code></pre></div>
<p dir="auto">So, DwarFS is almost six times faster than SquashFS. But what&#39;s more,
SquashFS also uses significantly more CPU power. However, the numbers
shown above for DwarFS obviously don&#39;t include the time spent in the
<code>dwarfs</code> process, so I repeated the test outside of hyperfine:</p>
<div data-snippet-clipboard-copy-content="$ time dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4 -f

real    0m4.569s
user    0m2.154s
sys     0m1.846s"><pre><code>$ time dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4 -f

real    0m4.569s
user    0m2.154s
sys     0m1.846s
</code></pre></div>
<p dir="auto">So, in total, DwarFS was using 5.7 seconds of CPU time, whereas
SquashFS was using 20.2 seconds, almost four times as much. Ignore
the &#39;real&#39; time, this is only how long it took me to unmount the
file system again after mounting it.</p>
<p dir="auto">Another real-life test was to build and test a Perl module with 624
different Perl versions in the compressed file system. The module I&#39;ve
used, <a href="https://github.com/mhx/Tie-Hash-Indexed">Tie::Hash::Indexed</a>,
has an XS component that requires a C compiler to build. So this really
accesses a lot of different stuff in the file system:</p>
<ul dir="auto">
<li>
<p dir="auto">The <code>perl</code> executables and its shared libraries</p>
</li>
<li>
<p dir="auto">The Perl modules used for writing the Makefile</p>
</li>
<li>
<p dir="auto">Perl&#39;s C header files used for building the module</p>
</li>
<li>
<p dir="auto">More Perl modules used for running the tests</p>
</li>
</ul>
<p dir="auto">I wrote a little script to be able to run multiple builds in parallel:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#!/bin/bash
set -eu
perl=$1
dir=$(echo &#34;$perl&#34; | cut -d/ --output-delimiter=- -f5,6)
rsync -a Tie-Hash-Indexed/ $dir/
cd $dir
$1 Makefile.PL &gt;/dev/null 2&gt;&amp;1
make test &gt;/dev/null 2&gt;&amp;1
cd ..
rm -rf $dir
echo $perl"><pre><span><span>#!</span>/bin/bash</span>
<span>set</span> -eu
perl=<span>$1</span>
dir=<span><span>$(</span>echo <span><span>&#34;</span><span>$perl</span><span>&#34;</span></span> <span>|</span> cut -d/ --output-delimiter=- -f5,6<span>)</span></span>
rsync -a Tie-Hash-Indexed/ <span>$dir</span>/
<span>cd</span> <span>$dir</span>
<span>$1</span> Makefile.PL <span>&gt;</span>/dev/null <span>2&gt;&amp;1</span>
make <span>test</span> <span>&gt;</span>/dev/null <span>2&gt;&amp;1</span>
<span>cd</span> ..
rm -rf <span>$dir</span>
<span>echo</span> <span>$perl</span></pre></div>
<p dir="auto">The following command will run up to 16 builds in parallel on the 8 core
Xeon CPU, including debug, optimized and threaded versions of all Perl
releases between 5.10.0 and 5.33.3, a total of 624 <code>perl</code> installations:</p>
<div data-snippet-clipboard-copy-content="$ time ls -1 /tmp/perl/install/*/perl-5.??.?/bin/perl5* | sort -t / -k 8 | xargs -d $&#39;\n&#39; -P 16 -n 1 ./build.sh"><pre><code>$ time ls -1 /tmp/perl/install/*/perl-5.??.?/bin/perl5* | sort -t / -k 8 | xargs -d $&#39;\n&#39; -P 16 -n 1 ./build.sh
</code></pre></div>
<p dir="auto">Tests were done with a cleanly mounted file system to make sure the caches
were empty. <code>ccache</code> was primed to make sure all compiler runs could be
satisfied from the cache. With SquashFS, the timing was:</p>
<div data-snippet-clipboard-copy-content="real    0m52.385s
user    8m10.333s
sys     4m10.056s"><pre><code>real    0m52.385s
user    8m10.333s
sys     4m10.056s
</code></pre></div>
<p dir="auto">And with DwarFS:</p>
<div data-snippet-clipboard-copy-content="real    0m50.469s
user    9m22.597s
sys     1m18.469s"><pre><code>real    0m50.469s
user    9m22.597s
sys     1m18.469s
</code></pre></div>
<p dir="auto">So, frankly, not much of a difference, with DwarFS being just a bit faster.
The <code>dwarfs</code> process itself used:</p>
<div data-snippet-clipboard-copy-content="real    0m56.686s
user    0m18.857s
sys     0m21.058s"><pre><code>real    0m56.686s
user    0m18.857s
sys     0m21.058s
</code></pre></div>
<p dir="auto">So again, DwarFS used less raw CPU power overall, but in terms of wallclock
time, the difference is really marginal.</p>

<p dir="auto">This test uses slightly less pathological input data: the root filesystem of
a recent Raspberry Pi OS release. This file system also contains device inodes,
so in order to preserve those, we pass <code>--with-devices</code> to <code>mkdwarfs</code>:</p>
<div data-snippet-clipboard-copy-content="$ time sudo mkdwarfs -i raspbian -o raspbian.dwarfs --with-devices
I 21:30:29.812562 scanning raspbian
I 21:30:29.908984 waiting for background scanners...
I 21:30:30.217446 assigning directory and link inodes...
I 21:30:30.221941 finding duplicate files...
I 21:30:30.288099 saved 31.05 MiB / 1007 MiB in 1617/34582 duplicate files
I 21:30:30.288143 waiting for inode scanners...
I 21:30:31.393710 assigning device inodes...
I 21:30:31.394481 assigning pipe/socket inodes...
I 21:30:31.395196 building metadata...
I 21:30:31.395230 building blocks...
I 21:30:31.395291 saving names and links...
I 21:30:31.395374 ordering 32965 inodes using nilsimsa similarity...
I 21:30:31.396254 nilsimsa: depth=20000 (1000), limit=255
I 21:30:31.407967 pre-sorted index (46431 name, 2206 path lookups) [11.66ms]
I 21:30:31.410089 updating name and link indices...
I 21:30:38.178505 32965 inodes ordered [6.783s]
I 21:30:38.179417 waiting for segmenting/blockifying to finish...
I 21:31:06.248304 saving chunks...
I 21:31:06.251998 saving directories...
I 21:31:06.402559 waiting for compression to finish...
I 21:31:16.425563 compressed 1007 MiB to 287 MiB (ratio=0.285036)
I 21:31:16.464772 filesystem created without errors [46.65s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
4435 dirs, 5908/0 soft/hard links, 34582/34582 files, 7 other
original size: 1007 MiB, dedupe: 31.05 MiB (1617 files), segment: 47.23 MiB
filesystem: 928.4 MiB in 59 blocks (38890 chunks, 32965/32965 inodes)
compressed filesystem: 59 blocks/287 MiB written [depth: 20000]
████████████████████████████████████████████████████████████████████▏100% |

real    0m46.711s
user    10m39.038s
sys     0m8.123s"><pre><code>$ time sudo mkdwarfs -i raspbian -o raspbian.dwarfs --with-devices
I 21:30:29.812562 scanning raspbian
I 21:30:29.908984 waiting for background scanners...
I 21:30:30.217446 assigning directory and link inodes...
I 21:30:30.221941 finding duplicate files...
I 21:30:30.288099 saved 31.05 MiB / 1007 MiB in 1617/34582 duplicate files
I 21:30:30.288143 waiting for inode scanners...
I 21:30:31.393710 assigning device inodes...
I 21:30:31.394481 assigning pipe/socket inodes...
I 21:30:31.395196 building metadata...
I 21:30:31.395230 building blocks...
I 21:30:31.395291 saving names and links...
I 21:30:31.395374 ordering 32965 inodes using nilsimsa similarity...
I 21:30:31.396254 nilsimsa: depth=20000 (1000), limit=255
I 21:30:31.407967 pre-sorted index (46431 name, 2206 path lookups) [11.66ms]
I 21:30:31.410089 updating name and link indices...
I 21:30:38.178505 32965 inodes ordered [6.783s]
I 21:30:38.179417 waiting for segmenting/blockifying to finish...
I 21:31:06.248304 saving chunks...
I 21:31:06.251998 saving directories...
I 21:31:06.402559 waiting for compression to finish...
I 21:31:16.425563 compressed 1007 MiB to 287 MiB (ratio=0.285036)
I 21:31:16.464772 filesystem created without errors [46.65s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
4435 dirs, 5908/0 soft/hard links, 34582/34582 files, 7 other
original size: 1007 MiB, dedupe: 31.05 MiB (1617 files), segment: 47.23 MiB
filesystem: 928.4 MiB in 59 blocks (38890 chunks, 32965/32965 inodes)
compressed filesystem: 59 blocks/287 MiB written [depth: 20000]
████████████████████████████████████████████████████████████████████▏100% |

real    0m46.711s
user    10m39.038s
sys     0m8.123s
</code></pre></div>
<p dir="auto">Again, SquashFS uses the same compression options:</p>
<div data-snippet-clipboard-copy-content="$ time sudo mksquashfs raspbian raspbian.squashfs -comp zstd -Xcompression-level 22
Parallel mksquashfs: Using 16 processors
Creating 4.0 filesystem on raspbian.squashfs, block size 131072.
[===============================================================\] 39232/39232 100%

Exportable Squashfs 4.0 filesystem, zstd compressed, data block size 131072
        compressed data, compressed metadata, compressed fragments,
        compressed xattrs, compressed ids
        duplicates are removed
Filesystem size 371934.50 Kbytes (363.22 Mbytes)
        35.98% of uncompressed filesystem size (1033650.60 Kbytes)
Inode table size 399913 bytes (390.54 Kbytes)
        26.53% of uncompressed inode table size (1507581 bytes)
Directory table size 408749 bytes (399.17 Kbytes)
        42.31% of uncompressed directory table size (966174 bytes)
Number of duplicate files found 1618
Number of inodes 44932
Number of files 34582
Number of fragments 3290
Number of symbolic links  5908
Number of device nodes 7
Number of fifo nodes 0
Number of socket nodes 0
Number of directories 4435
Number of ids (unique uids + gids) 18
Number of uids 5
        root (0)
        mhx (1000)
        unknown (103)
        shutdown (6)
        unknown (106)
Number of gids 15
        root (0)
        unknown (109)
        unknown (42)
        unknown (1000)
        users (100)
        unknown (43)
        tty (5)
        unknown (108)
        unknown (111)
        unknown (110)
        unknown (50)
        mail (12)
        nobody (65534)
        adm (4)
        mem (8)

real    0m50.124s
user    9m41.708s
sys     0m1.727s"><pre><code>$ time sudo mksquashfs raspbian raspbian.squashfs -comp zstd -Xcompression-level 22
Parallel mksquashfs: Using 16 processors
Creating 4.0 filesystem on raspbian.squashfs, block size 131072.
[===============================================================\] 39232/39232 100%

Exportable Squashfs 4.0 filesystem, zstd compressed, data block size 131072
        compressed data, compressed metadata, compressed fragments,
        compressed xattrs, compressed ids
        duplicates are removed
Filesystem size 371934.50 Kbytes (363.22 Mbytes)
        35.98% of uncompressed filesystem size (1033650.60 Kbytes)
Inode table size 399913 bytes (390.54 Kbytes)
        26.53% of uncompressed inode table size (1507581 bytes)
Directory table size 408749 bytes (399.17 Kbytes)
        42.31% of uncompressed directory table size (966174 bytes)
Number of duplicate files found 1618
Number of inodes 44932
Number of files 34582
Number of fragments 3290
Number of symbolic links  5908
Number of device nodes 7
Number of fifo nodes 0
Number of socket nodes 0
Number of directories 4435
Number of ids (unique uids + gids) 18
Number of uids 5
        root (0)
        mhx (1000)
        unknown (103)
        shutdown (6)
        unknown (106)
Number of gids 15
        root (0)
        unknown (109)
        unknown (42)
        unknown (1000)
        users (100)
        unknown (43)
        tty (5)
        unknown (108)
        unknown (111)
        unknown (110)
        unknown (50)
        mail (12)
        nobody (65534)
        adm (4)
        mem (8)

real    0m50.124s
user    9m41.708s
sys     0m1.727s
</code></pre></div>
<p dir="auto">The difference in speed is almost negligible. SquashFS is just a bit
slower here. In terms of compression, the difference also isn&#39;t huge:</p>
<div data-snippet-clipboard-copy-content="$ ls -lh raspbian.* *.xz
-rw-r--r-- 1 mhx  users 297M Mar  4 21:32 2020-08-20-raspios-buster-armhf-lite.img.xz
-rw-r--r-- 1 root root  287M Mar  4 21:31 raspbian.dwarfs
-rw-r--r-- 1 root root  364M Mar  4 21:33 raspbian.squashfs"><pre><code>$ ls -lh raspbian.* *.xz
-rw-r--r-- 1 mhx  users 297M Mar  4 21:32 2020-08-20-raspios-buster-armhf-lite.img.xz
-rw-r--r-- 1 root root  287M Mar  4 21:31 raspbian.dwarfs
-rw-r--r-- 1 root root  364M Mar  4 21:33 raspbian.squashfs
</code></pre></div>
<p dir="auto">Interestingly, <code>xz</code> actually can&#39;t compress the whole original image
better than DwarFS.</p>
<p dir="auto">We can even again try to increase the DwarFS compression level:</p>
<div data-snippet-clipboard-copy-content="$ time sudo mkdwarfs -i raspbian -o raspbian-9.dwarfs --with-devices -l9

real    0m54.161s
user    8m40.109s
sys     0m7.101s"><pre><code>$ time sudo mkdwarfs -i raspbian -o raspbian-9.dwarfs --with-devices -l9

real    0m54.161s
user    8m40.109s
sys     0m7.101s
</code></pre></div>
<p dir="auto">Now that actually gets the DwarFS image size well below that of the
<code>xz</code> archive:</p>
<div data-snippet-clipboard-copy-content="$ ls -lh raspbian-9.dwarfs *.xz
-rw-r--r-- 1 root root  244M Mar  4 21:36 raspbian-9.dwarfs
-rw-r--r-- 1 mhx  users 297M Mar  4 21:32 2020-08-20-raspios-buster-armhf-lite.img.xz"><pre><code>$ ls -lh raspbian-9.dwarfs *.xz
-rw-r--r-- 1 root root  244M Mar  4 21:36 raspbian-9.dwarfs
-rw-r--r-- 1 mhx  users 297M Mar  4 21:32 2020-08-20-raspios-buster-armhf-lite.img.xz
</code></pre></div>
<p dir="auto">Even if you actually build a tarball and compress that (instead of
compressing the EXT4 file system itself), <code>xz</code> isn&#39;t quite able to
match the DwarFS image size:</p>
<div data-snippet-clipboard-copy-content="$ time sudo tar cf - raspbian | xz -9 -vT 0 &gt;raspbian.tar.xz
  100 %     246.9 MiB / 1,037.2 MiB = 0.238    13 MiB/s       1:18

real    1m18.226s
user    6m35.381s
sys     0m2.205s"><pre><code>$ time sudo tar cf - raspbian | xz -9 -vT 0 &gt;raspbian.tar.xz
  100 %     246.9 MiB / 1,037.2 MiB = 0.238    13 MiB/s       1:18

real    1m18.226s
user    6m35.381s
sys     0m2.205s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ls -lh raspbian.tar.xz
-rw-r--r-- 1 mhx users 247M Mar  4 21:40 raspbian.tar.xz"><pre><code>$ ls -lh raspbian.tar.xz
-rw-r--r-- 1 mhx users 247M Mar  4 21:40 raspbian.tar.xz
</code></pre></div>
<p dir="auto">DwarFS also comes with the <a href="https://www.jakef.science/mhx/dwarfs/blob/main/doc/dwarfsextract.md">dwarfsextract</a> tool
that allows extraction of a filesystem image without the FUSE driver.
So here&#39;s a comparison of the extraction speed:</p>
<div data-snippet-clipboard-copy-content="$ time sudo tar xf raspbian.tar.xz -C out1

real    0m12.846s
user    0m12.313s
sys     0m1.616s"><pre><code>$ time sudo tar xf raspbian.tar.xz -C out1

real    0m12.846s
user    0m12.313s
sys     0m1.616s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ time sudo dwarfsextract -i raspbian-9.dwarfs -o out2

real    0m3.825s
user    0m13.234s
sys     0m1.382s"><pre><code>$ time sudo dwarfsextract -i raspbian-9.dwarfs -o out2

real    0m3.825s
user    0m13.234s
sys     0m1.382s
</code></pre></div>
<p dir="auto">So, <code>dwarfsextract</code> is almost 4 times faster thanks to using multiple
worker threads for decompression. It&#39;s writing about 300 MiB/s in this
example.</p>
<p dir="auto">Another nice feature of <code>dwarfsextract</code> is that it allows you to directly
output data in an archive format, so you could create a tarball from
your image without extracting the files to disk:</p>
<div data-snippet-clipboard-copy-content="$ dwarfsextract -i raspbian-9.dwarfs -f ustar | xz -9 -T0 &gt;raspbian2.tar.xz"><pre><code>$ dwarfsextract -i raspbian-9.dwarfs -f ustar | xz -9 -T0 &gt;raspbian2.tar.xz
</code></pre></div>
<p dir="auto">This has the interesting side-effect that the resulting tarball will
likely be smaller than the one built straight from the directory:</p>
<div data-snippet-clipboard-copy-content="$ ls -lh raspbian*.tar.xz
-rw-r--r-- 1 mhx users 247M Mar  4 21:40 raspbian.tar.xz
-rw-r--r-- 1 mhx users 240M Mar  4 23:52 raspbian2.tar.xz"><pre><code>$ ls -lh raspbian*.tar.xz
-rw-r--r-- 1 mhx users 247M Mar  4 21:40 raspbian.tar.xz
-rw-r--r-- 1 mhx users 240M Mar  4 23:52 raspbian2.tar.xz
</code></pre></div>
<p dir="auto">That&#39;s because <code>dwarfsextract</code> writes files in inode-order, and by
default inodes are ordered by similarity for the best possible
compression.</p>

<p dir="auto"><a href="https://github.com/ckolivas/lrzip">lrzip</a> is a compression utility
targeted especially at compressing large files. From its description,
it looks like it does something very similar to DwarFS, i.e. it looks
for duplicate segments before passsing the de-duplicated data on to
an <code>lzma</code> compressor.</p>
<p dir="auto">When I first read about <code>lrzip</code>, I was pretty certain it would easily
beat DwarFS. So let&#39;s take a look. <code>lrzip</code> operates on a single file,
so it&#39;s necessary to first build a tarball:</p>
<div data-snippet-clipboard-copy-content="$ time tar cf perl-install.tar install

real    2m9.568s
user    0m3.757s
sys     0m26.623s"><pre><code>$ time tar cf perl-install.tar install

real    2m9.568s
user    0m3.757s
sys     0m26.623s
</code></pre></div>
<p dir="auto">Now we can run <code>lrzip</code>:</p>
<div data-snippet-clipboard-copy-content="$ time lrzip -vL9 -o perl-install.tar.lrzip perl-install.tar
The following options are in effect for this COMPRESSION.
Threading is ENABLED. Number of CPUs detected: 16
Detected 67106172928 bytes ram
Compression level 9
Nice Value: 19
Show Progress
Verbose
Output Filename Specified: perl-install.tar.lrzip
Temporary Directory set as: ./
Compression mode is: LZMA. LZO Compressibility testing enabled
Heuristically Computed Compression Window: 426 = 42600MB
File size: 52615639040
Will take 2 passes
Beginning rzip pre-processing phase
Beginning rzip pre-processing phase
perl-install.tar - Compression Ratio: 100.378. Average Compression Speed: 14.536MB/s.
Total time: 00:57:32.47

real    57m32.472s
user    81m44.104s
sys     4m50.221s"><pre><code>$ time lrzip -vL9 -o perl-install.tar.lrzip perl-install.tar
The following options are in effect for this COMPRESSION.
Threading is ENABLED. Number of CPUs detected: 16
Detected 67106172928 bytes ram
Compression level 9
Nice Value: 19
Show Progress
Verbose
Output Filename Specified: perl-install.tar.lrzip
Temporary Directory set as: ./
Compression mode is: LZMA. LZO Compressibility testing enabled
Heuristically Computed Compression Window: 426 = 42600MB
File size: 52615639040
Will take 2 passes
Beginning rzip pre-processing phase
Beginning rzip pre-processing phase
perl-install.tar - Compression Ratio: 100.378. Average Compression Speed: 14.536MB/s.
Total time: 00:57:32.47

real    57m32.472s
user    81m44.104s
sys     4m50.221s
</code></pre></div>
<p dir="auto">That definitely took a while. This is about an order of magnitude
slower than <code>mkdwarfs</code> and it barely makes use of the 8 cores.</p>
<div data-snippet-clipboard-copy-content="$ ll -h perl-install.tar.lrzip
-rw-r--r-- 1 mhx users 500M Mar  6 21:16 perl-install.tar.lrzip"><pre><code>$ ll -h perl-install.tar.lrzip
-rw-r--r-- 1 mhx users 500M Mar  6 21:16 perl-install.tar.lrzip
</code></pre></div>
<p dir="auto">This is a surprisingly disappointing result. The archive is 65% larger
than a DwarFS image at <code>-l9</code> that takes less than 4 minutes to build.
Also, you can&#39;t just access the files in the <code>.lrzip</code> without fully
unpacking the archive first.</p>
<p dir="auto">That being said, it <em>is</em> better than just using <code>xz</code> on the tarball:</p>
<div data-snippet-clipboard-copy-content="$ time xz -T0 -v9 -c perl-install.tar &gt;perl-install.tar.xz
perl-install.tar (1/1)
  100 %      4,317.0 MiB / 49.0 GiB = 0.086    24 MiB/s      34:55

real    34m55.450s
user    543m50.810s
sys     0m26.533s"><pre><code>$ time xz -T0 -v9 -c perl-install.tar &gt;perl-install.tar.xz
perl-install.tar (1/1)
  100 %      4,317.0 MiB / 49.0 GiB = 0.086    24 MiB/s      34:55

real    34m55.450s
user    543m50.810s
sys     0m26.533s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ll perl-install.tar.xz -h
-rw-r--r-- 1 mhx users 4.3G Mar  6 22:59 perl-install.tar.xz"><pre><code>$ ll perl-install.tar.xz -h
-rw-r--r-- 1 mhx users 4.3G Mar  6 22:59 perl-install.tar.xz
</code></pre></div>

<p dir="auto"><a href="http://mattmahoney.net/dc/zpaq.html" rel="nofollow">zpaq</a> is a journaling backup
utility and archiver. Again, it appears to share some of the ideas in
DwarFS, like segmentation analysis, but it also adds some features on
top that make it useful for incremental backups. However, it&#39;s also
not usable as a file system, so data needs to be extracted before it
can be used.</p>
<p dir="auto">Anyway, how does it fare in terms of speed and compression performance?</p>
<div data-snippet-clipboard-copy-content="$ time zpaq a perl-install.zpaq install -m5"><pre><code>$ time zpaq a perl-install.zpaq install -m5
</code></pre></div>
<p dir="auto">After a few million lines of output that (I think) cannot be turned off:</p>
<div data-snippet-clipboard-copy-content="2258234 +added, 0 -removed.

0.000000 + (51161.953159 -&gt; 8932.000297 -&gt; 490.227707) = 490.227707 MB
2828.082 seconds (all OK)

real    47m8.104s
user    714m44.286s
sys     3m6.751s"><pre><code>2258234 +added, 0 -removed.

0.000000 + (51161.953159 -&gt; 8932.000297 -&gt; 490.227707) = 490.227707 MB
2828.082 seconds (all OK)

real    47m8.104s
user    714m44.286s
sys     3m6.751s
</code></pre></div>
<p dir="auto">So, it&#39;s an order of magnitude slower than <code>mkdwarfs</code> and uses 14 times
as much CPU resources as <code>mkdwarfs -l9</code>. The resulting archive it pretty
close in size to the default configuration DwarFS image, but it&#39;s more
than 50% bigger than the image produced by <code>mkdwarfs -l9</code>.</p>
<div data-snippet-clipboard-copy-content="$ ll perl-install*.*
-rw-r--r-- 1 mhx users 490227707 Mar  7 01:38 perl-install.zpaq
-rw-r--r-- 1 mhx users 315482627 Mar  3 21:23 perl-install-l9.dwarfs
-rw-r--r-- 1 mhx users 447230618 Mar  3 20:28 perl-install.dwarfs"><pre><code>$ ll perl-install*.*
-rw-r--r-- 1 mhx users 490227707 Mar  7 01:38 perl-install.zpaq
-rw-r--r-- 1 mhx users 315482627 Mar  3 21:23 perl-install-l9.dwarfs
-rw-r--r-- 1 mhx users 447230618 Mar  3 20:28 perl-install.dwarfs
</code></pre></div>
<p dir="auto">What&#39;s <em>really</em> surprising is how slow it is to extract the <code>zpaq</code>
archive again:</p>
<div data-snippet-clipboard-copy-content="$ time zpaq x perl-install.zpaq
2798.097 seconds (all OK)

real    46m38.117s
user    711m18.734s
sys     3m47.876s"><pre><code>$ time zpaq x perl-install.zpaq
2798.097 seconds (all OK)

real    46m38.117s
user    711m18.734s
sys     3m47.876s
</code></pre></div>
<p dir="auto">That&#39;s 700 times slower than extracting the DwarFS image.</p>

<p dir="auto"><a href="https://github.com/fcorbelli/zpaqfranz">zpaqfranz</a> is a derivative of zpaq.
Much to my delight, it doesn&#39;t generate millions of lines of output.
It claims to be multi-threaded and de-duplicating, so definitely worth
taking a look. Like zpaq, it supports incremental backups.</p>
<p dir="auto">We&#39;ll use a different input to compare zpaqfranz and DwarFS: The source code
of 670 different releases of the &#34;wine&#34; emulator. That&#39;s 73 gigabytes of data
in total, spread across slightly more than 3 million files. It&#39;s obviously
highly redundant and should thus be a good data set to compare the tools.
For reference, a <code>.tar.xz</code> of the directory is still 7 GiB in size and a
SquashFS image of the data gets down to around 1.6 GiB. An &#34;optimized&#34;
<code>.tar.xz</code>, where the input files were ordered by similarity, compresses down
to 399 MiB, almost 20 times better than without ordering.</p>
<p dir="auto">Now it&#39;s time to try zpaqfranz. The input data is stored on a fast SSD and a
large fraction of it is already in the file system cache from previous runs,
so disk I/O is not a bottleneck.</p>
<div data-snippet-clipboard-copy-content="$ time ./zpaqfranz a winesrc.zpaq winesrc
zpaqfranz v58.8k-JIT-L(2023-08-05)
Creating winesrc.zpaq at offset 0 + 0
Add 2024-01-11 07:25:22 3.117.413     69.632.090.852 (  64.85 GB) 16T (362.904 dirs)
3.480.317 +added, 0 -removed.

0 + (69.632.090.852 -&gt; 8.347.553.798 -&gt; 617.600.892) = 617.600.892 @ 58.38 MB/s

1137.441 seconds (000:18:57) (all OK)

real    18m58.632s
user    11m51.052s
sys     1m3.389s"><pre><code>$ time ./zpaqfranz a winesrc.zpaq winesrc
zpaqfranz v58.8k-JIT-L(2023-08-05)
Creating winesrc.zpaq at offset 0 + 0
Add 2024-01-11 07:25:22 3.117.413     69.632.090.852 (  64.85 GB) 16T (362.904 dirs)
3.480.317 +added, 0 -removed.

0 + (69.632.090.852 -&gt; 8.347.553.798 -&gt; 617.600.892) = 617.600.892 @ 58.38 MB/s

1137.441 seconds (000:18:57) (all OK)

real    18m58.632s
user    11m51.052s
sys     1m3.389s
</code></pre></div>
<p dir="auto">That is considerably faster than the original zpaq, and uses about 60 times
less CPU resources. The output file is 589 MiB, so slightly larger than both
the &#34;optimized&#34; <code>.tar.gz</code> and the zpaq output.</p>
<p dir="auto">How does <code>mkdwarfs</code> do?</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i winesrc -o winesrc.dwarfs -l9
[...]
I 07:55:20.546636 compressed 64.85 GiB to 93.2 MiB (ratio=0.00140344)
I 07:55:20.826699 compression CPU time: 6.726m
I 07:55:20.827338 filesystem created without errors [2.283m]
[...]

real    2m17.100s
user    9m53.633s
sys     2m29.236s"><pre><code>$ time mkdwarfs -i winesrc -o winesrc.dwarfs -l9
[...]
I 07:55:20.546636 compressed 64.85 GiB to 93.2 MiB (ratio=0.00140344)
I 07:55:20.826699 compression CPU time: 6.726m
I 07:55:20.827338 filesystem created without errors [2.283m]
[...]

real    2m17.100s
user    9m53.633s
sys     2m29.236s
</code></pre></div>
<p dir="auto">It uses pretty much the same amount of CPU resources, but finishes more than
8 times faster. The DwarFS output file is more than 6 times smaller.</p>
<p dir="auto">You can actually squeeze a bit more redundancy out of the original data by
tweaking the similarity ordering and switching from lzma to brotli compression,
albeit at a somewhat slower compression speed:</p>
<div data-snippet-clipboard-copy-content="mkdwarfs -i winesrc -o winesrc.dwarfs -l9 -C brotli:quality=11:lgwin=26 --order=nilsimsa:max-cluster-size=200k
[...]
I 08:21:01.138075 compressed 64.85 GiB to 73.52 MiB (ratio=0.00110716)
I 08:21:01.485737 compression CPU time: 36.58m
I 08:21:01.486313 filesystem created without errors [5.501m]
[...]
real    5m30.178s
user    40m59.193s
sys     2m36.234s"><pre><code>mkdwarfs -i winesrc -o winesrc.dwarfs -l9 -C brotli:quality=11:lgwin=26 --order=nilsimsa:max-cluster-size=200k
[...]
I 08:21:01.138075 compressed 64.85 GiB to 73.52 MiB (ratio=0.00110716)
I 08:21:01.485737 compression CPU time: 36.58m
I 08:21:01.486313 filesystem created without errors [5.501m]
[...]
real    5m30.178s
user    40m59.193s
sys     2m36.234s
</code></pre></div>
<p dir="auto">That&#39;s almost a 1000x reduction in size.</p>
<p dir="auto">Let&#39;s also look at decompression speed:</p>
<div data-snippet-clipboard-copy-content="$ time zpaqfranz x winesrc.zpaq
zpaqfranz v58.8k-JIT-L(2023-08-05)
/home/mhx/winesrc.zpaq:
1 versions, 3.480.317 files, 617.600.892 bytes (588.99 MB)
Extract 69.632.090.852 bytes (64.85 GB) in 3.117.413 files (362.904 folders) / 16 T
        99.18% 00:00:00  (  64.32 GB)=&gt;(  64.85 GB)  548.83 MB/sec

125.636 seconds (000:02:05) (all OK)

real    2m6.968s
user    1m36.177s
sys     1m10.980s"><pre><code>$ time zpaqfranz x winesrc.zpaq
zpaqfranz v58.8k-JIT-L(2023-08-05)
/home/mhx/winesrc.zpaq:
1 versions, 3.480.317 files, 617.600.892 bytes (588.99 MB)
Extract 69.632.090.852 bytes (64.85 GB) in 3.117.413 files (362.904 folders) / 16 T
        99.18% 00:00:00  (  64.32 GB)=&gt;(  64.85 GB)  548.83 MB/sec

125.636 seconds (000:02:05) (all OK)

real    2m6.968s
user    1m36.177s
sys     1m10.980s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ time dwarfsextract -i winesrc.dwarfs

real    1m49.182s
user    0m34.667s
sys     1m28.733s"><pre><code>$ time dwarfsextract -i winesrc.dwarfs

real    1m49.182s
user    0m34.667s
sys     1m28.733s
</code></pre></div>
<p dir="auto">Decompression time is pretty much in the same ballpark, with just slightly
shorter times for the DwarFS image.</p>

<p dir="auto"><a href="https://wimlib.net/" rel="nofollow">wimlib</a> is a really interesting project that is
a lot more mature than DwarFS. While DwarFS at its core has a library
component that could potentially be ported to other operating systems,
wimlib already is available on many platforms. It also seems to have
quite a rich set of features, so it&#39;s definitely worth taking a look at.</p>
<p dir="auto">I first tried <code>wimcapture</code> on the perl dataset:</p>
<div data-snippet-clipboard-copy-content="$ time wimcapture --unix-data --solid --solid-chunk-size=16M install perl-install.wim
Scanning &#34;install&#34;
47 GiB scanned (1927501 files, 330733 directories)
Using LZMS compression with 16 threads
Archiving file data: 19 GiB of 19 GiB (100%) done

real    15m23.310s
user    174m29.274s
sys     0m42.921s"><pre><code>$ time wimcapture --unix-data --solid --solid-chunk-size=16M install perl-install.wim
Scanning &#34;install&#34;
47 GiB scanned (1927501 files, 330733 directories)
Using LZMS compression with 16 threads
Archiving file data: 19 GiB of 19 GiB (100%) done

real    15m23.310s
user    174m29.274s
sys     0m42.921s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ll perl-install.*
-rw-r--r-- 1 mhx users  447230618 Mar  3 20:28 perl-install.dwarfs
-rw-r--r-- 1 mhx users  315482627 Mar  3 21:23 perl-install-l9.dwarfs
-rw-r--r-- 1 mhx users 4748902400 Mar  3 20:10 perl-install.squashfs
-rw-r--r-- 1 mhx users 1016981520 Mar  6 21:12 perl-install.wim"><pre><code>$ ll perl-install.*
-rw-r--r-- 1 mhx users  447230618 Mar  3 20:28 perl-install.dwarfs
-rw-r--r-- 1 mhx users  315482627 Mar  3 21:23 perl-install-l9.dwarfs
-rw-r--r-- 1 mhx users 4748902400 Mar  3 20:10 perl-install.squashfs
-rw-r--r-- 1 mhx users 1016981520 Mar  6 21:12 perl-install.wim
</code></pre></div>
<p dir="auto">So, wimlib is definitely much better than squashfs, in terms of both
compression ratio and speed. DwarFS is however about 3 times faster to
create the file system and the DwarFS file system less than half the size.
When switching to LZMA compression, the DwarFS file system is more than
3 times smaller (wimlib uses LZMS compression by default).</p>
<p dir="auto">What&#39;s a bit surprising is that mounting a <em>wim</em> file takes quite a bit
of time:</p>
<div data-snippet-clipboard-copy-content="$ time wimmount perl-install.wim mnt
[WARNING] Mounting a WIM file containing solid-compressed data; file access may be slow.

real    0m2.038s
user    0m1.764s
sys     0m0.242s"><pre><code>$ time wimmount perl-install.wim mnt
[WARNING] Mounting a WIM file containing solid-compressed data; file access may be slow.

real    0m2.038s
user    0m1.764s
sys     0m0.242s
</code></pre></div>
<p dir="auto">Mounting the DwarFS image takes almost no time in comparison:</p>
<div data-snippet-clipboard-copy-content="$ time git/github/dwarfs/build-clang-11/dwarfs perl-install-default.dwarfs mnt
I 00:23:39.238182 dwarfs (v0.4.0, fuse version 35)

real    0m0.003s
user    0m0.003s
sys     0m0.000s"><pre><code>$ time git/github/dwarfs/build-clang-11/dwarfs perl-install-default.dwarfs mnt
I 00:23:39.238182 dwarfs (v0.4.0, fuse version 35)

real    0m0.003s
user    0m0.003s
sys     0m0.000s
</code></pre></div>
<p dir="auto">That&#39;s just because it immediately forks into background by default and
initializes the file system in the background. However, even when
running it in the foreground, initializing the file system takes only
about 60 milliseconds:</p>
<div data-snippet-clipboard-copy-content="$ dwarfs perl-install.dwarfs mnt -f
I 00:25:03.186005 dwarfs (v0.4.0, fuse version 35)
I 00:25:03.248061 file system initialized [60.95ms]"><pre><code>$ dwarfs perl-install.dwarfs mnt -f
I 00:25:03.186005 dwarfs (v0.4.0, fuse version 35)
I 00:25:03.248061 file system initialized [60.95ms]
</code></pre></div>
<p dir="auto">If you actually build the DwarFS file system with uncompressed metadata,
mounting is basically instantaneous:</p>
<div data-snippet-clipboard-copy-content="$ dwarfs perl-install-meta.dwarfs mnt -f
I 00:27:52.667026 dwarfs (v0.4.0, fuse version 35)
I 00:27:52.671066 file system initialized [2.879ms]"><pre><code>$ dwarfs perl-install-meta.dwarfs mnt -f
I 00:27:52.667026 dwarfs (v0.4.0, fuse version 35)
I 00:27:52.671066 file system initialized [2.879ms]
</code></pre></div>
<p dir="auto">I&#39;ve tried running the benchmark where all 1139 <code>perl</code> executables
print their version with the wimlib image, but after about 10 minutes,
it still hadn&#39;t finished the first run (with the DwarFS image, one run
took slightly more than 2 seconds). I then tried the following instead:</p>
<div data-snippet-clipboard-copy-content="$ ls -1 /tmp/perl/install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P1 sh -c &#39;time $0 -v &gt;/dev/null&#39; 2&gt;&amp;1 | grep ^real
real    0m0.802s
real    0m0.652s
real    0m1.677s
real    0m1.973s
real    0m1.435s
real    0m1.879s
real    0m2.003s
real    0m1.695s
real    0m2.343s
real    0m1.899s
real    0m1.809s
real    0m1.790s
real    0m2.115s"><pre><code>$ ls -1 /tmp/perl/install/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P1 sh -c &#39;time $0 -v &gt;/dev/null&#39; 2&gt;&amp;1 | grep ^real
real    0m0.802s
real    0m0.652s
real    0m1.677s
real    0m1.973s
real    0m1.435s
real    0m1.879s
real    0m2.003s
real    0m1.695s
real    0m2.343s
real    0m1.899s
real    0m1.809s
real    0m1.790s
real    0m2.115s
</code></pre></div>
<p dir="auto">Judging from that, it would have probably taken about half an hour
for a single run, which makes at least the <code>--solid</code> wim image pretty
much unusable for actually working with the file system.</p>
<p dir="auto">The <code>--solid</code> option was suggested to me because it resembles the way
that DwarFS actually organizes data internally. However, judging by the
warning when mounting a solid image, it&#39;s probably not ideal when using
the image as a mounted file system. So I tried again without <code>--solid</code>:</p>
<div data-snippet-clipboard-copy-content="$ time wimcapture --unix-data install perl-install-nonsolid.wim
Scanning &#34;install&#34;
47 GiB scanned (1927501 files, 330733 directories)
Using LZX compression with 16 threads
Archiving file data: 19 GiB of 19 GiB (100%) done

real    8m39.034s
user    64m58.575s
sys     0m32.003s"><pre><code>$ time wimcapture --unix-data install perl-install-nonsolid.wim
Scanning &#34;install&#34;
47 GiB scanned (1927501 files, 330733 directories)
Using LZX compression with 16 threads
Archiving file data: 19 GiB of 19 GiB (100%) done

real    8m39.034s
user    64m58.575s
sys     0m32.003s
</code></pre></div>
<p dir="auto">This is still more than 3 minutes slower than <code>mkdwarfs</code>. However, it
yields an image that&#39;s almost 10 times the size of the DwarFS image
and comparable in size to the SquashFS image:</p>
<div data-snippet-clipboard-copy-content="$ ll perl-install-nonsolid.wim -h
-rw-r--r-- 1 mhx users 4.6G Mar  6 23:24 perl-install-nonsolid.wim"><pre><code>$ ll perl-install-nonsolid.wim -h
-rw-r--r-- 1 mhx users 4.6G Mar  6 23:24 perl-install-nonsolid.wim
</code></pre></div>
<p dir="auto">This <em>still</em> takes surprisingly long to mount:</p>
<div data-snippet-clipboard-copy-content="$ time wimmount perl-install-nonsolid.wim mnt

real    0m1.603s
user    0m1.327s
sys     0m0.275s"><pre><code>$ time wimmount perl-install-nonsolid.wim mnt

real    0m1.603s
user    0m1.327s
sys     0m0.275s
</code></pre></div>
<p dir="auto">However, it&#39;s really usable as a file system, even though it&#39;s about
4-5 times slower than the DwarFS image:</p>
<div data-snippet-clipboard-copy-content="$ hyperfine -c &#39;umount mnt&#39; -p &#39;umount mnt; dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#39; -n dwarfs &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34; -p &#39;umount mnt; wimmount perl-install-nonsolid.wim mnt; sleep 1&#39; -n wimlib &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: dwarfs
  Time (mean ± σ):      1.149 s ±  0.019 s    [User: 2.147 s, System: 0.739 s]
  Range (min … max):    1.122 s …  1.187 s    10 runs

Benchmark #2: wimlib
  Time (mean ± σ):      7.542 s ±  0.069 s    [User: 2.787 s, System: 0.694 s]
  Range (min … max):    7.490 s …  7.732 s    10 runs

Summary
  &#39;dwarfs&#39; ran
    6.56 ± 0.12 times faster than &#39;wimlib&#39;"><pre><code>$ hyperfine -c &#39;umount mnt&#39; -p &#39;umount mnt; dwarfs perl-install.dwarfs mnt -o cachesize=1g -o workers=4; sleep 1&#39; -n dwarfs &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34; -p &#39;umount mnt; wimmount perl-install-nonsolid.wim mnt; sleep 1&#39; -n wimlib &#34;ls -1 mnt/*/*/bin/perl5* | xargs -d $&#39;\n&#39; -n1 -P20 sh -c &#39;\$0 -v &gt;/dev/null&#39;&#34;
Benchmark #1: dwarfs
  Time (mean ± σ):      1.149 s ±  0.019 s    [User: 2.147 s, System: 0.739 s]
  Range (min … max):    1.122 s …  1.187 s    10 runs

Benchmark #2: wimlib
  Time (mean ± σ):      7.542 s ±  0.069 s    [User: 2.787 s, System: 0.694 s]
  Range (min … max):    7.490 s …  7.732 s    10 runs

Summary
  &#39;dwarfs&#39; ran
    6.56 ± 0.12 times faster than &#39;wimlib&#39;
</code></pre></div>

<p dir="auto">I used <a href="https://bisqwit.iki.fi/source/cromfs.html" rel="nofollow">Cromfs</a> in the past
for compressed file systems and remember that it did a pretty good job
in terms of compression ratio. But it was never fast. However, I didn&#39;t
quite remember just <em>how</em> slow it was until I tried to set up a test.</p>
<p dir="auto">Here&#39;s a run on the Perl dataset, with the block size set to 16 MiB to
match the default of DwarFS, and with additional options suggested to
speed up compression:</p>
<div data-snippet-clipboard-copy-content="$ time mkcromfs -f 16777216 -qq -e -r100000 install perl-install.cromfs
Writing perl-install.cromfs...
mkcromfs: Automatically enabling --24bitblocknums because it seems possible for this filesystem.
Root pseudo file is 108 bytes
Inotab spans 0x7f3a18259000..0x7f3a1bfffb9c
Root inode spans 0x7f3a205d2948..0x7f3a205d294c
Beginning task for Files and directories: Finding identical blocks
2163608 reuse opportunities found. 561362 unique blocks. Block table will be 79.4% smaller than without the index search.
Beginning task for Files and directories: Blockifying
Blockifying:  0.04% (140017/2724970) idx(siz=80423,del=0) rawin(20.97 MB)rawout(20.97 MB)diff(1956 bytes)
Termination signalled, cleaning up temporaries

real    29m9.634s
user    201m37.816s
sys     2m15.005s"><pre><code>$ time mkcromfs -f 16777216 -qq -e -r100000 install perl-install.cromfs
Writing perl-install.cromfs...
mkcromfs: Automatically enabling --24bitblocknums because it seems possible for this filesystem.
Root pseudo file is 108 bytes
Inotab spans 0x7f3a18259000..0x7f3a1bfffb9c
Root inode spans 0x7f3a205d2948..0x7f3a205d294c
Beginning task for Files and directories: Finding identical blocks
2163608 reuse opportunities found. 561362 unique blocks. Block table will be 79.4% smaller than without the index search.
Beginning task for Files and directories: Blockifying
Blockifying:  0.04% (140017/2724970) idx(siz=80423,del=0) rawin(20.97 MB)rawout(20.97 MB)diff(1956 bytes)
Termination signalled, cleaning up temporaries

real    29m9.634s
user    201m37.816s
sys     2m15.005s
</code></pre></div>
<p dir="auto">So, it processed 21 MiB out of 48 GiB in half an hour, using almost
twice as much CPU resources as DwarFS for the <em>whole</em> file system.
At this point I decided it&#39;s likely not worth waiting (presumably)
another month (!) for <code>mkcromfs</code> to finish. I double checked that
I didn&#39;t accidentally build a debugging version, <code>mkcromfs</code> was
definitely built with <code>-O3</code>.</p>
<p dir="auto">I then tried once more with a smaller version of the Perl dataset.
This only has 20 versions (instead of 1139) of Perl, and obviously
a lot less redundancy:</p>
<div data-snippet-clipboard-copy-content="$ time mkcromfs -f 16777216 -qq -e -r100000 install-small perl-install.cromfs
Writing perl-install.cromfs...
mkcromfs: Automatically enabling --16bitblocknums because it seems possible for this filesystem.
Root pseudo file is 108 bytes
Inotab spans 0x7f00e0774000..0x7f00e08410a8
Root inode spans 0x7f00b40048f8..0x7f00b40048fc
Beginning task for Files and directories: Finding identical blocks
25362 reuse opportunities found. 9815 unique blocks. Block table will be 72.1% smaller than without the index search.
Beginning task for Files and directories: Blockifying
Compressing raw rootdir inode (28 bytes)z=982370,del=2) rawin(641.56 MB)rawout(252.72 MB)diff(388.84 MB)
 compressed into 35 bytes
INOTAB pseudo file is 839.85 kB
Inotab inode spans 0x7f00bc036ed8..0x7f00bc036ef4
Beginning task for INOTAB: Finding identical blocks
0 reuse opportunities found. 13 unique blocks. Block table will be 0.0% smaller than without the index search.
Beginning task for INOTAB: Blockifying
mkcromfs: Automatically enabling --packedblocks because it is possible for this filesystem.
Compressing raw inotab inode (52 bytes)
 compressed into 58 bytes
Compressing 9828 block records (4 bytes each, total 39312 bytes)
 compressed into 15890 bytes
Compressing and writing 16 fblocks...

16 fblocks were written: 35.31 MB = 13.90 % of 254.01 MB
Filesystem size: 35.33 MB = 5.50 % of original 642.22 MB
End

real    27m38.833s
user    277m36.208s
sys     11m36.945s"><pre><code>$ time mkcromfs -f 16777216 -qq -e -r100000 install-small perl-install.cromfs
Writing perl-install.cromfs...
mkcromfs: Automatically enabling --16bitblocknums because it seems possible for this filesystem.
Root pseudo file is 108 bytes
Inotab spans 0x7f00e0774000..0x7f00e08410a8
Root inode spans 0x7f00b40048f8..0x7f00b40048fc
Beginning task for Files and directories: Finding identical blocks
25362 reuse opportunities found. 9815 unique blocks. Block table will be 72.1% smaller than without the index search.
Beginning task for Files and directories: Blockifying
Compressing raw rootdir inode (28 bytes)z=982370,del=2) rawin(641.56 MB)rawout(252.72 MB)diff(388.84 MB)
 compressed into 35 bytes
INOTAB pseudo file is 839.85 kB
Inotab inode spans 0x7f00bc036ed8..0x7f00bc036ef4
Beginning task for INOTAB: Finding identical blocks
0 reuse opportunities found. 13 unique blocks. Block table will be 0.0% smaller than without the index search.
Beginning task for INOTAB: Blockifying
mkcromfs: Automatically enabling --packedblocks because it is possible for this filesystem.
Compressing raw inotab inode (52 bytes)
 compressed into 58 bytes
Compressing 9828 block records (4 bytes each, total 39312 bytes)
 compressed into 15890 bytes
Compressing and writing 16 fblocks...

16 fblocks were written: 35.31 MB = 13.90 % of 254.01 MB
Filesystem size: 35.33 MB = 5.50 % of original 642.22 MB
End

real    27m38.833s
user    277m36.208s
sys     11m36.945s
</code></pre></div>
<p dir="auto">And repeating the same task with <code>mkdwarfs</code>:</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i install-small -o perl-install-small.dwarfs
21:13:38.131724 scanning install-small
21:13:38.320139 waiting for background scanners...
21:13:38.727024 assigning directory and link inodes...
21:13:38.731807 finding duplicate files...
21:13:38.832524 saved 267.8 MiB / 611.8 MiB in 22842/26401 duplicate files
21:13:38.832598 waiting for inode scanners...
21:13:39.619963 assigning device inodes...
21:13:39.620855 assigning pipe/socket inodes...
21:13:39.621356 building metadata...
21:13:39.621453 building blocks...
21:13:39.621472 saving names and links...
21:13:39.621655 ordering 3559 inodes using nilsimsa similarity...
21:13:39.622031 nilsimsa: depth=20000, limit=255
21:13:39.629206 updating name and link indices...
21:13:39.630142 pre-sorted index (3360 name, 2127 path lookups) [8.014ms]
21:13:39.752051 3559 inodes ordered [130.3ms]
21:13:39.752101 waiting for segmenting/blockifying to finish...
21:13:53.250951 saving chunks...
21:13:53.251581 saving directories...
21:13:53.303862 waiting for compression to finish...
21:14:11.073273 compressed 611.8 MiB to 24.01 MiB (ratio=0.0392411)
21:14:11.091099 filesystem created without errors [32.96s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
3334 dirs, 0/0 soft/hard links, 26401/26401 files, 0 other
original size: 611.8 MiB, dedupe: 267.8 MiB (22842 files), segment: 121.5 MiB
filesystem: 222.5 MiB in 14 blocks (7177 chunks, 3559/3559 inodes)
compressed filesystem: 14 blocks/24.01 MiB written
██████████████████████████████████████████████████████████████████████▏100% \

real    0m33.007s
user    3m43.324s
sys     0m4.015s"><pre><code>$ time mkdwarfs -i install-small -o perl-install-small.dwarfs
21:13:38.131724 scanning install-small
21:13:38.320139 waiting for background scanners...
21:13:38.727024 assigning directory and link inodes...
21:13:38.731807 finding duplicate files...
21:13:38.832524 saved 267.8 MiB / 611.8 MiB in 22842/26401 duplicate files
21:13:38.832598 waiting for inode scanners...
21:13:39.619963 assigning device inodes...
21:13:39.620855 assigning pipe/socket inodes...
21:13:39.621356 building metadata...
21:13:39.621453 building blocks...
21:13:39.621472 saving names and links...
21:13:39.621655 ordering 3559 inodes using nilsimsa similarity...
21:13:39.622031 nilsimsa: depth=20000, limit=255
21:13:39.629206 updating name and link indices...
21:13:39.630142 pre-sorted index (3360 name, 2127 path lookups) [8.014ms]
21:13:39.752051 3559 inodes ordered [130.3ms]
21:13:39.752101 waiting for segmenting/blockifying to finish...
21:13:53.250951 saving chunks...
21:13:53.251581 saving directories...
21:13:53.303862 waiting for compression to finish...
21:14:11.073273 compressed 611.8 MiB to 24.01 MiB (ratio=0.0392411)
21:14:11.091099 filesystem created without errors [32.96s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
3334 dirs, 0/0 soft/hard links, 26401/26401 files, 0 other
original size: 611.8 MiB, dedupe: 267.8 MiB (22842 files), segment: 121.5 MiB
filesystem: 222.5 MiB in 14 blocks (7177 chunks, 3559/3559 inodes)
compressed filesystem: 14 blocks/24.01 MiB written
██████████████████████████████████████████████████████████████████████▏100% \

real    0m33.007s
user    3m43.324s
sys     0m4.015s
</code></pre></div>
<p dir="auto">So, <code>mkdwarfs</code> is about 50 times faster than <code>mkcromfs</code> and uses 75 times
less CPU resources. At the same time, the DwarFS file system is 30% smaller:</p>
<div data-snippet-clipboard-copy-content="$ ls -l perl-install-small.*fs
-rw-r--r-- 1 mhx users 35328512 Dec  8 14:25 perl-install-small.cromfs
-rw-r--r-- 1 mhx users 25175016 Dec 10 21:14 perl-install-small.dwarfs"><pre><code>$ ls -l perl-install-small.*fs
-rw-r--r-- 1 mhx users 35328512 Dec  8 14:25 perl-install-small.cromfs
-rw-r--r-- 1 mhx users 25175016 Dec 10 21:14 perl-install-small.dwarfs
</code></pre></div>
<p dir="auto">I noticed that the <code>blockifying</code> step that took ages for the full dataset
with <code>mkcromfs</code> ran substantially faster (in terms of MiB/second) on the
smaller dataset, which makes me wonder if there&#39;s some quadratic complexity
behaviour that&#39;s slowing down <code>mkcromfs</code>.</p>
<p dir="auto">In order to be completely fair, I also ran <code>mkdwarfs</code> with <code>-l 9</code> to enable
LZMA compression (which is what <code>mkcromfs</code> uses by default):</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i install-small -o perl-install-small-l9.dwarfs -l 9
21:16:21.874975 scanning install-small
21:16:22.092201 waiting for background scanners...
21:16:22.489470 assigning directory and link inodes...
21:16:22.495216 finding duplicate files...
21:16:22.611221 saved 267.8 MiB / 611.8 MiB in 22842/26401 duplicate files
21:16:22.611314 waiting for inode scanners...
21:16:23.394332 assigning device inodes...
21:16:23.395184 assigning pipe/socket inodes...
21:16:23.395616 building metadata...
21:16:23.395676 building blocks...
21:16:23.395685 saving names and links...
21:16:23.395830 ordering 3559 inodes using nilsimsa similarity...
21:16:23.396097 nilsimsa: depth=50000, limit=255
21:16:23.401042 updating name and link indices...
21:16:23.403127 pre-sorted index (3360 name, 2127 path lookups) [6.936ms]
21:16:23.524914 3559 inodes ordered [129ms]
21:16:23.525006 waiting for segmenting/blockifying to finish...
21:16:33.865023 saving chunks...
21:16:33.865883 saving directories...
21:16:33.900140 waiting for compression to finish...
21:17:10.505779 compressed 611.8 MiB to 17.44 MiB (ratio=0.0284969)
21:17:10.526171 filesystem created without errors [48.65s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
3334 dirs, 0/0 soft/hard links, 26401/26401 files, 0 other
original size: 611.8 MiB, dedupe: 267.8 MiB (22842 files), segment: 122.2 MiB
filesystem: 221.8 MiB in 4 blocks (7304 chunks, 3559/3559 inodes)
compressed filesystem: 4 blocks/17.44 MiB written
██████████████████████████████████████████████████████████████████████▏100% /

real    0m48.683s
user    2m24.905s
sys     0m3.292s"><pre><code>$ time mkdwarfs -i install-small -o perl-install-small-l9.dwarfs -l 9
21:16:21.874975 scanning install-small
21:16:22.092201 waiting for background scanners...
21:16:22.489470 assigning directory and link inodes...
21:16:22.495216 finding duplicate files...
21:16:22.611221 saved 267.8 MiB / 611.8 MiB in 22842/26401 duplicate files
21:16:22.611314 waiting for inode scanners...
21:16:23.394332 assigning device inodes...
21:16:23.395184 assigning pipe/socket inodes...
21:16:23.395616 building metadata...
21:16:23.395676 building blocks...
21:16:23.395685 saving names and links...
21:16:23.395830 ordering 3559 inodes using nilsimsa similarity...
21:16:23.396097 nilsimsa: depth=50000, limit=255
21:16:23.401042 updating name and link indices...
21:16:23.403127 pre-sorted index (3360 name, 2127 path lookups) [6.936ms]
21:16:23.524914 3559 inodes ordered [129ms]
21:16:23.525006 waiting for segmenting/blockifying to finish...
21:16:33.865023 saving chunks...
21:16:33.865883 saving directories...
21:16:33.900140 waiting for compression to finish...
21:17:10.505779 compressed 611.8 MiB to 17.44 MiB (ratio=0.0284969)
21:17:10.526171 filesystem created without errors [48.65s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
3334 dirs, 0/0 soft/hard links, 26401/26401 files, 0 other
original size: 611.8 MiB, dedupe: 267.8 MiB (22842 files), segment: 122.2 MiB
filesystem: 221.8 MiB in 4 blocks (7304 chunks, 3559/3559 inodes)
compressed filesystem: 4 blocks/17.44 MiB written
██████████████████████████████████████████████████████████████████████▏100% /

real    0m48.683s
user    2m24.905s
sys     0m3.292s
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ ls -l perl-install-small*.*fs
-rw-r--r-- 1 mhx users 18282075 Dec 10 21:17 perl-install-small-l9.dwarfs
-rw-r--r-- 1 mhx users 35328512 Dec  8 14:25 perl-install-small.cromfs
-rw-r--r-- 1 mhx users 25175016 Dec 10 21:14 perl-install-small.dwarfs"><pre><code>$ ls -l perl-install-small*.*fs
-rw-r--r-- 1 mhx users 18282075 Dec 10 21:17 perl-install-small-l9.dwarfs
-rw-r--r-- 1 mhx users 35328512 Dec  8 14:25 perl-install-small.cromfs
-rw-r--r-- 1 mhx users 25175016 Dec 10 21:14 perl-install-small.dwarfs
</code></pre></div>
<p dir="auto">It takes about 15 seconds longer to build the DwarFS file system with LZMA
compression (this is still 35 times faster than Cromfs), but reduces the
size even further to make it almost half the size of the Cromfs file system.</p>
<p dir="auto">I would have added some benchmarks with the Cromfs FUSE driver, but sadly
it crashed right upon trying to list the directory after mounting.</p>

<p dir="auto"><a href="https://github.com/hsiangkao/erofs-utils">EROFS</a> is a new read-only
compressed file system that has recently been added to the Linux kernel.
Its goals are quite different from those of DwarFS, though. It is
designed to be lightweight (which DwarFS is definitely not) and to run
on constrained hardware like embedded devices or smartphones. It only
supports LZ4 compression.</p>
<p dir="auto">I was feeling lucky and decided to run it on the full Perl dataset:</p>
<div data-snippet-clipboard-copy-content="$ time mkfs.erofs perl-install.erofs install -zlz4hc,9 -d2
mkfs.erofs 1.2
        c_version:           [     1.2]
        c_dbg_lvl:           [       2]
        c_dry_run:           [       0]
^C

real    912m42.601s
user    903m2.777s
sys     1m52.812s"><pre><code>$ time mkfs.erofs perl-install.erofs install -zlz4hc,9 -d2
mkfs.erofs 1.2
        c_version:           [     1.2]
        c_dbg_lvl:           [       2]
        c_dry_run:           [       0]
^C

real    912m42.601s
user    903m2.777s
sys     1m52.812s
</code></pre></div>
<p dir="auto">As you can tell, after more than 15 hours I just gave up. In those
15 hours, <code>mkfs.erofs</code> had produced a 13 GiB output file:</p>
<div data-snippet-clipboard-copy-content="$ ll -h perl-install.erofs
-rw-r--r-- 1 mhx users 13G Dec  9 14:42 perl-install.erofs"><pre><code>$ ll -h perl-install.erofs
-rw-r--r-- 1 mhx users 13G Dec  9 14:42 perl-install.erofs
</code></pre></div>
<p dir="auto">I don&#39;t think this would have been very useful to compare with DwarFS.</p>
<p dir="auto">Just as for Cromfs, I re-ran with the smaller Perl dataset:</p>
<div data-snippet-clipboard-copy-content="$ time mkfs.erofs perl-install-small.erofs install-small -zlz4hc,9 -d2
mkfs.erofs 1.2
        c_version:           [     1.2]
        c_dbg_lvl:           [       2]
        c_dry_run:           [       0]

real    0m27.844s
user    0m20.570s
sys     0m1.848s"><pre><code>$ time mkfs.erofs perl-install-small.erofs install-small -zlz4hc,9 -d2
mkfs.erofs 1.2
        c_version:           [     1.2]
        c_dbg_lvl:           [       2]
        c_dry_run:           [       0]

real    0m27.844s
user    0m20.570s
sys     0m1.848s
</code></pre></div>
<p dir="auto">That was surprisingly quick, which makes me think that, again, there
might be some accidentally quadratic complexity hiding in <code>mkfs.erofs</code>.
The output file it produced is an order of magnitude larger than the
DwarFS image:</p>
<div data-snippet-clipboard-copy-content="$ ls -l perl-install-small.*fs
-rw-r--r-- 1 mhx users  26928161 Dec  8 15:05 perl-install-small.dwarfs
-rw-r--r-- 1 mhx users 296488960 Dec  9 14:45 perl-install-small.erofs"><pre><code>$ ls -l perl-install-small.*fs
-rw-r--r-- 1 mhx users  26928161 Dec  8 15:05 perl-install-small.dwarfs
-rw-r--r-- 1 mhx users 296488960 Dec  9 14:45 perl-install-small.erofs
</code></pre></div>
<p dir="auto">Admittedly, this isn&#39;t a fair comparison. EROFS has a fixed block size
of 4 KiB, and it uses LZ4 compression. If we tweak DwarFS to the same
parameters, we get:</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i install-small -o perl-install-small-lz4.dwarfs -C lz4hc:level=9 -S 12
21:21:18.136796 scanning install-small
21:21:18.376998 waiting for background scanners...
21:21:18.770703 assigning directory and link inodes...
21:21:18.776422 finding duplicate files...
21:21:18.903505 saved 267.8 MiB / 611.8 MiB in 22842/26401 duplicate files
21:21:18.903621 waiting for inode scanners...
21:21:19.676420 assigning device inodes...
21:21:19.677400 assigning pipe/socket inodes...
21:21:19.678014 building metadata...
21:21:19.678101 building blocks...
21:21:19.678116 saving names and links...
21:21:19.678306 ordering 3559 inodes using nilsimsa similarity...
21:21:19.678566 nilsimsa: depth=20000, limit=255
21:21:19.684227 pre-sorted index (3360 name, 2127 path lookups) [5.592ms]
21:21:19.685550 updating name and link indices...
21:21:19.810401 3559 inodes ordered [132ms]
21:21:19.810519 waiting for segmenting/blockifying to finish...
21:21:26.773913 saving chunks...
21:21:26.776832 saving directories...
21:21:26.821085 waiting for compression to finish...
21:21:27.020929 compressed 611.8 MiB to 140.7 MiB (ratio=0.230025)
21:21:27.036202 filesystem created without errors [8.899s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
3334 dirs, 0/0 soft/hard links, 26401/26401 files, 0 other
original size: 611.8 MiB, dedupe: 267.8 MiB (22842 files), segment: 0 B
filesystem: 344 MiB in 88073 blocks (91628 chunks, 3559/3559 inodes)
compressed filesystem: 88073 blocks/140.7 MiB written
████████████████████████████████████████████████████████████████▏100% |

real    0m9.075s
user    0m37.718s
sys     0m2.427s"><pre><code>$ time mkdwarfs -i install-small -o perl-install-small-lz4.dwarfs -C lz4hc:level=9 -S 12
21:21:18.136796 scanning install-small
21:21:18.376998 waiting for background scanners...
21:21:18.770703 assigning directory and link inodes...
21:21:18.776422 finding duplicate files...
21:21:18.903505 saved 267.8 MiB / 611.8 MiB in 22842/26401 duplicate files
21:21:18.903621 waiting for inode scanners...
21:21:19.676420 assigning device inodes...
21:21:19.677400 assigning pipe/socket inodes...
21:21:19.678014 building metadata...
21:21:19.678101 building blocks...
21:21:19.678116 saving names and links...
21:21:19.678306 ordering 3559 inodes using nilsimsa similarity...
21:21:19.678566 nilsimsa: depth=20000, limit=255
21:21:19.684227 pre-sorted index (3360 name, 2127 path lookups) [5.592ms]
21:21:19.685550 updating name and link indices...
21:21:19.810401 3559 inodes ordered [132ms]
21:21:19.810519 waiting for segmenting/blockifying to finish...
21:21:26.773913 saving chunks...
21:21:26.776832 saving directories...
21:21:26.821085 waiting for compression to finish...
21:21:27.020929 compressed 611.8 MiB to 140.7 MiB (ratio=0.230025)
21:21:27.036202 filesystem created without errors [8.899s]
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
waiting for block compression to finish
3334 dirs, 0/0 soft/hard links, 26401/26401 files, 0 other
original size: 611.8 MiB, dedupe: 267.8 MiB (22842 files), segment: 0 B
filesystem: 344 MiB in 88073 blocks (91628 chunks, 3559/3559 inodes)
compressed filesystem: 88073 blocks/140.7 MiB written
████████████████████████████████████████████████████████████████▏100% |

real    0m9.075s
user    0m37.718s
sys     0m2.427s
</code></pre></div>
<p dir="auto">It finishes in less than half the time and produces an output image
that&#39;s half the size of the EROFS image.</p>
<p dir="auto">I&#39;m going to stop the comparison here, as it&#39;s pretty obvious that the
domains in which EROFS and DwarFS are being used have extremely little
overlap. DwarFS will likely never be able to run on embedded devices
and EROFS will likely never be able to achieve the compression ratios
of DwarFS.</p>

<p dir="auto">I came across <a href="https://github.com/google/fuse-archive">fuse-archive</a>
while looking for FUSE drivers to mount archives and it seems to be
the most versatile of the alternatives (and the one that actually
compiles out of the box).</p>
<p dir="auto">An interesting test case straight from fuse-archive&#39;s README is in
the <a href="https://github.com/google/fuse-archive#performance">Performance</a>
section: an archive with a single huge file full of zeroes. Let&#39;s
make the example a bit more extreme and use a 1 GiB file instead of
just 256 MiB:</p>
<div data-snippet-clipboard-copy-content="$ mkdir zerotest
$ truncate --size=1G zerotest/zeroes"><pre><code>$ mkdir zerotest
$ truncate --size=1G zerotest/zeroes
</code></pre></div>
<p dir="auto">Now, we build several different archives and a DwarFS image:</p>
<div data-snippet-clipboard-copy-content="$ time mkdwarfs -i zerotest -o zerotest.dwarfs -W16 --log-level=warn --progress=none

real    0m7.604s
user    0m7.521s
sys     0m0.083s

$ time zip -9 zerotest.zip zerotest/zeroes
  adding: zerotest/zeroes (deflated 100%)

real    0m4.923s
user    0m4.840s
sys     0m0.080s

$ time 7z a -bb0 -bd zerotest.7z zerotest/zeroes

7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21
p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,16 CPUs Intel(R) Xeon(R) E-2286M  CPU @ 2.40GHz (906ED),ASM,AES-NI)

Scanning the drive:
1 file, 1073741824 bytes (1024 MiB)

Creating archive: zerotest.7z

Items to compress: 1

Files read from disk: 1
Archive size: 157819 bytes (155 KiB)
Everything is Ok

real    0m5.535s
user    0m48.281s
sys     0m1.116s

$ time tar --zstd -cf zerotest.tar.zstd zerotest/zeroes

real    0m0.449s
user    0m0.510s
sys     0m0.610s"><pre><code>$ time mkdwarfs -i zerotest -o zerotest.dwarfs -W16 --log-level=warn --progress=none

real    0m7.604s
user    0m7.521s
sys     0m0.083s

$ time zip -9 zerotest.zip zerotest/zeroes
  adding: zerotest/zeroes (deflated 100%)

real    0m4.923s
user    0m4.840s
sys     0m0.080s

$ time 7z a -bb0 -bd zerotest.7z zerotest/zeroes

7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21
p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,16 CPUs Intel(R) Xeon(R) E-2286M  CPU @ 2.40GHz (906ED),ASM,AES-NI)

Scanning the drive:
1 file, 1073741824 bytes (1024 MiB)

Creating archive: zerotest.7z

Items to compress: 1

Files read from disk: 1
Archive size: 157819 bytes (155 KiB)
Everything is Ok

real    0m5.535s
user    0m48.281s
sys     0m1.116s

$ time tar --zstd -cf zerotest.tar.zstd zerotest/zeroes

real    0m0.449s
user    0m0.510s
sys     0m0.610s
</code></pre></div>
<p dir="auto">Turns out that <code>tar --zstd</code> is easily winning the compression speed
test. Looking at the file sizes did actually blow my mind just a bit:</p>
<div data-snippet-clipboard-copy-content="$ ll zerotest.* --sort=size
-rw-r--r-- 1 mhx users 1042231 Jul  1 15:24 zerotest.zip
-rw-r--r-- 1 mhx users  157819 Jul  1 15:26 zerotest.7z
-rw-r--r-- 1 mhx users   33762 Jul  1 15:28 zerotest.tar.zstd
-rw-r--r-- 1 mhx users     848 Jul  1 15:23 zerotest.dwarfs"><pre><code>$ ll zerotest.* --sort=size
-rw-r--r-- 1 mhx users 1042231 Jul  1 15:24 zerotest.zip
-rw-r--r-- 1 mhx users  157819 Jul  1 15:26 zerotest.7z
-rw-r--r-- 1 mhx users   33762 Jul  1 15:28 zerotest.tar.zstd
-rw-r--r-- 1 mhx users     848 Jul  1 15:23 zerotest.dwarfs
</code></pre></div>
<p dir="auto">I definitely didn&#39;t expect the DwarFS image to be <em>that</em> small.
Dropping the section index would actually save another 100 bytes.
So, if you want to archive lots of zeroes, DwarFS is your friend.</p>
<p dir="auto">Anyway, let&#39;s look at how fast and efficiently the zeroes can
be read from the different archives. First, the <code>zip</code> archive:</p>
<div data-snippet-clipboard-copy-content="$ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress
1020117504 bytes (1.0 GB, 973 MiB) copied, 2 s, 510 MB/s
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.10309 s, 511 MB/s

real    0m2.104s
user    0m0.264s
sys     0m0.486s"><pre><code>$ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress
1020117504 bytes (1.0 GB, 973 MiB) copied, 2 s, 510 MB/s
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.10309 s, 511 MB/s

real    0m2.104s
user    0m0.264s
sys     0m0.486s
</code></pre></div>
<p dir="auto">CPU time used by the FUSE driver was 1.8 seconds and mount time
was in the milliseconds.</p>
<p dir="auto">Now, the <code>7z</code> archive:</p>
<div data-snippet-clipboard-copy-content=" $ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress
594759168 bytes (595 MB, 567 MiB) copied, 1 s, 595 MB/s
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.76904 s, 607 MB/s

real    0m1.772s
user    0m0.229s
sys     0m0.572s"><pre><code> $ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress
594759168 bytes (595 MB, 567 MiB) copied, 1 s, 595 MB/s
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.76904 s, 607 MB/s

real    0m1.772s
user    0m0.229s
sys     0m0.572s
</code></pre></div>
<p dir="auto">CPU time used by the FUSE driver was 2.9 seconds and mount time
was just over 1.0 seconds.</p>
<p dir="auto">Now, the <code>.tar.zstd</code> archive:</p>
<div data-snippet-clipboard-copy-content="$ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.799409 s, 1.3 GB/s

real    0m0.801s
user    0m0.262s
sys     0m0.537s"><pre><code>$ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.799409 s, 1.3 GB/s

real    0m0.801s
user    0m0.262s
sys     0m0.537s
</code></pre></div>
<p dir="auto">CPU time used by the FUSE driver was 0.53 seconds and mount time
was 0.13 seconds.</p>
<p dir="auto">Last but not least, let&#39;s look at DwarFS:</p>
<div data-snippet-clipboard-copy-content="$ time dd if=mnt/zeroes of=/dev/null status=progress
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.753 s, 1.4 GB/s

real    0m0.757s
user    0m0.220s
sys     0m0.534s"><pre><code>$ time dd if=mnt/zeroes of=/dev/null status=progress
2097152+0 records in
2097152+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.753 s, 1.4 GB/s

real    0m0.757s
user    0m0.220s
sys     0m0.534s
</code></pre></div>
<p dir="auto">CPU time used by the FUSE driver was 0.17 seconds and mount time
was less than a millisecond.</p>
<p dir="auto">If we increase the block size for the <code>dd</code> command, we can get
even higher throughput. For fuse-archive with the <code>.tar.zstd</code>:</p>
<div data-snippet-clipboard-copy-content="$ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress bs=16384
65536+0 records in
65536+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.318682 s, 3.4 GB/s

real    0m0.323s
user    0m0.005s
sys     0m0.154s"><pre><code>$ time dd if=mnt/zerotest/zeroes of=/dev/null status=progress bs=16384
65536+0 records in
65536+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.318682 s, 3.4 GB/s

real    0m0.323s
user    0m0.005s
sys     0m0.154s
</code></pre></div>
<p dir="auto">And for DwarFS:</p>
<div data-snippet-clipboard-copy-content="$ time dd if=mnt/zeroes of=/dev/null status=progress bs=16384
65536+0 records in
65536+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.172226 s, 6.2 GB/s

real    0m0.176s
user    0m0.020s
sys     0m0.141s"><pre><code>$ time dd if=mnt/zeroes of=/dev/null status=progress bs=16384
65536+0 records in
65536+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.172226 s, 6.2 GB/s

real    0m0.176s
user    0m0.020s
sys     0m0.141s
</code></pre></div>
<p dir="auto">This is all nice, but what about a more real-life use case?
Let&#39;s take the 1.82.0 boost release archives:</p>
<div data-snippet-clipboard-copy-content="$ ll --sort=size boost_1_82_0.*
-rw-r--r-- 1 mhx users 208188085 Apr 10 14:25 boost_1_82_0.zip
-rw-r--r-- 1 mhx users 142580547 Apr 10 14:23 boost_1_82_0.tar.gz
-rw-r--r-- 1 mhx users 121325129 Apr 10 14:23 boost_1_82_0.tar.bz2
-rw-r--r-- 1 mhx users 105901369 Jun 28 12:47 boost_1_82_0.dwarfs
-rw-r--r-- 1 mhx users 103710551 Apr 10 14:25 boost_1_82_0.7z"><pre><code>$ ll --sort=size boost_1_82_0.*
-rw-r--r-- 1 mhx users 208188085 Apr 10 14:25 boost_1_82_0.zip
-rw-r--r-- 1 mhx users 142580547 Apr 10 14:23 boost_1_82_0.tar.gz
-rw-r--r-- 1 mhx users 121325129 Apr 10 14:23 boost_1_82_0.tar.bz2
-rw-r--r-- 1 mhx users 105901369 Jun 28 12:47 boost_1_82_0.dwarfs
-rw-r--r-- 1 mhx users 103710551 Apr 10 14:25 boost_1_82_0.7z
</code></pre></div>
<p dir="auto">Here are the timings for mounting each archive and then using
<code>tar</code> to build another archive from the mountpoint and just counting
the number of bytes in that archive, e.g.:</p>
<div data-snippet-clipboard-copy-content="$ time tar cf - mnt | wc -c
803614720

real    0m4.602s
user    0m0.156s
sys     0m1.123s"><pre><code>$ time tar cf - mnt | wc -c
803614720

real    0m4.602s
user    0m0.156s
sys     0m1.123s
</code></pre></div>
<p dir="auto">Here are the results in terms of wallclock time and FUSE driver
CPU time:</p>
<table>
<thead>
<tr>
<th>Archive</th>
<th>Mount Time</th>
<th><code>tar</code> Wallclock Time</th>
<th>FUSE Driver CPU Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.zip</code></td>
<td>0.458s</td>
<td>5.073s</td>
<td>4.418s</td>
</tr>
<tr>
<td><code>.tar.gz</code></td>
<td>1.391s</td>
<td>3.483s</td>
<td>3.943s</td>
</tr>
<tr>
<td><code>.tar.bz2</code></td>
<td>15.663s</td>
<td>17.942s</td>
<td>32.040s</td>
</tr>
<tr>
<td><code>.7z</code></td>
<td>0.321s</td>
<td>32.554s</td>
<td>31.625s</td>
</tr>
<tr>
<td><code>.dwarfs</code></td>
<td>0.013s</td>
<td>2.974s</td>
<td>1.984s</td>
</tr>
</tbody>
</table>
<p dir="auto">DwarFS easily wins all categories while still compressing the data
almost as well as <code>7z</code>.</p>
<p dir="auto">What about accessing files more randomly?</p>
<div data-snippet-clipboard-copy-content="$ find mnt -type f -print0 | xargs -0 -P32 -n32 cat | dd of=/dev/null status=progress"><pre><code>$ find mnt -type f -print0 | xargs -0 -P32 -n32 cat | dd of=/dev/null status=progress
</code></pre></div>
<p dir="auto">It turns out that fuse-archive grinds to a halt in this case, so I had
to run the test on a subset (the <code>boost</code> subdirectory) of the data.
The <code>.tar.bz2</code> and <code>.7z</code> archives were so slow to read that I stopped
them after a few minutes.</p>
<table>
<thead>
<tr>
<th>Archive</th>
<th>Throughput</th>
<th>Wallclock Time</th>
<th>FUSE Driver CPU Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.zip</code></td>
<td>1.8 MB/s</td>
<td>83.245s</td>
<td>83.669s</td>
</tr>
<tr>
<td><code>.tar.gz</code></td>
<td>1.2 MB/s</td>
<td>121.377s</td>
<td>122.711s</td>
</tr>
<tr>
<td><code>.tar.bz2</code></td>
<td>0.2 MB/s</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>.7z</code></td>
<td>0.3 MB/s</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>.dwarfs</code></td>
<td>598.0 MB/s</td>
<td>0.249s</td>
<td>1.099s</td>
</tr>
</tbody>
</table>

<p dir="auto">Both the FUSE driver and <code>dwarfsextract</code> by default have support for
simple performance monitoring. You can build binaries without this
feature (<code>-DENABLE_PERFMON=OFF</code>), but impact should be negligible even
if performance monitoring is enabled at run-time.</p>
<p dir="auto">To enable the performance monitor, you pass a list of components for which
you want to collect latency metrics, e.g.:</p>
<div data-snippet-clipboard-copy-content="$ dwarfs test.dwarfs mnt -f -operfmon=fuse"><pre><code>$ dwarfs test.dwarfs mnt -f -operfmon=fuse
</code></pre></div>
<p dir="auto">When the driver exits, you will see output like this:</p>
<div data-snippet-clipboard-copy-content="[fuse.op_read]
      samples: 45145
      overall: 3.214s
  avg latency: 71.2us
  p50 latency: 131.1us
  p90 latency: 131.1us
  p99 latency: 262.1us

[fuse.op_readdir]
      samples: 2
      overall: 51.31ms
  avg latency: 25.65ms
  p50 latency: 32.77us
  p90 latency: 67.11ms
  p99 latency: 67.11ms

[fuse.op_lookup]
      samples: 16
      overall: 19.98ms
  avg latency: 1.249ms
  p50 latency: 2.097ms
  p90 latency: 4.194ms
  p99 latency: 4.194ms

[fuse.op_init]
      samples: 1
      overall: 199.4us
  avg latency: 199.4us
  p50 latency: 262.1us
  p90 latency: 262.1us
  p99 latency: 262.1us

[fuse.op_open]
      samples: 16
      overall: 122.2us
  avg latency: 7.641us
  p50 latency: 4.096us
  p90 latency: 32.77us
  p99 latency: 32.77us

[fuse.op_getattr]
      samples: 1
      overall: 5.786us
  avg latency: 5.786us
  p50 latency: 8.192us
  p90 latency: 8.192us
  p99 latency: 8.192us"><pre><code>[fuse.op_read]
      samples: 45145
      overall: 3.214s
  avg latency: 71.2us
  p50 latency: 131.1us
  p90 latency: 131.1us
  p99 latency: 262.1us

[fuse.op_readdir]
      samples: 2
      overall: 51.31ms
  avg latency: 25.65ms
  p50 latency: 32.77us
  p90 latency: 67.11ms
  p99 latency: 67.11ms

[fuse.op_lookup]
      samples: 16
      overall: 19.98ms
  avg latency: 1.249ms
  p50 latency: 2.097ms
  p90 latency: 4.194ms
  p99 latency: 4.194ms

[fuse.op_init]
      samples: 1
      overall: 199.4us
  avg latency: 199.4us
  p50 latency: 262.1us
  p90 latency: 262.1us
  p99 latency: 262.1us

[fuse.op_open]
      samples: 16
      overall: 122.2us
  avg latency: 7.641us
  p50 latency: 4.096us
  p90 latency: 32.77us
  p99 latency: 32.77us

[fuse.op_getattr]
      samples: 1
      overall: 5.786us
  avg latency: 5.786us
  p50 latency: 8.192us
  p90 latency: 8.192us
  p99 latency: 8.192us
</code></pre></div>
<p dir="auto">The metrics should be self-explanatory. However, note that the
percentile metrics are logarithmically quantized in order to use
as little resources as possible. As a result, you will only see
values that look an awful lot like powers of two.</p>
<p dir="auto">Currently, the supported components are <code>fuse</code> for the FUSE
operations, <code>filesystem_v2</code> for the DwarFS file system component
and <code>inode_reader_v2</code> for the component that handles all <code>read()</code>
system calls.</p>
<p dir="auto">The FUSE driver also exposes the performance monitor metrics via
an <a href="#extended-attributes">extended attribute</a>.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">Setting Worker Thread CPU Affinity</h3><a id="user-content-setting-worker-thread-cpu-affinity" aria-label="Permalink: Setting Worker Thread CPU Affinity" href="#setting-worker-thread-cpu-affinity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This only works on Linux and usually only makes sense if you have CPUs
with different types of cores (e.g. &#34;performance&#34; vs &#34;efficiency&#34; cores)
and are <em>really</em> trying to squeeze the last ounce of speed out of DwarFS.</p>
<p dir="auto">By setting the environment variable <code>DWARFS_WORKER_GROUP_AFFINITY</code>, you
can set the CPU affinity of different worker thread groups, e.g.:</p>
<div data-snippet-clipboard-copy-content="export DWARFS_WORKER_GROUP_AFFINITY=blockify=3:compress=6,7"><pre><code>export DWARFS_WORKER_GROUP_AFFINITY=blockify=3:compress=6,7
</code></pre></div>
<p dir="auto">This will set the affinity of the <code>blockify</code> worker group to CPU 3 and
the affinity of the <code>compress</code> worker group to CPUs 6 and 7.</p>
<p dir="auto">You can use this feature for all tools that use one or more worker thread
groups. For example, the FUSE driver <code>dwarfs</code> and <code>dwarfsextract</code> use a
worker group <code>blkcache</code> that the block cache (i.e. block decompression and
lookup) runs on. <code>mkdwarfs</code> uses a whole array of different worker groups,
namely <code>compress</code> for compression, <code>scanner</code> for scanning, <code>ordering</code> for
input ordering, and <code>blockify</code> for segmenting. <code>blockify</code> is what you would
typically want to run on your &#34;performance&#34; cores.</p>
</article></div></div>
  </body>
</html>
