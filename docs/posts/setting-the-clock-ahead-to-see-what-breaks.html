<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2023/01/19/time/">Original</a>
    <h1>Setting the clock ahead to see what breaks</h1>
    
    
<p>
Given that we're now within 15 years of the signed 32-bit time_t 
craziness, I decided to start playing around with my own stuff to see 
how things are doing.  I wanted to see what would break and what would 
work.
</p><p>
One thing I particularly wanted to see was how my smaller systems would 
work.  It's basically a given that my 64 bit Linux boxes are going to be 
fine since time_t is already wider, and it won't explode in 2038.  But 
that's far from the whole story.  32 bit machines still exist, and are 
more common than some would think thanks to the existence of things like 
Raspberry Pis.
</p><p>
Unless you deliberately install the 64-bit flavor of Raspbian, you're 
going to get a 32-bit system.  With the version of glibc it's currently 
running, you will hit the wall.  It's easy enough to try - you'll notice 
that you can't actually set the clock that far ahead:
</p><p>
<pre>
root@rpi4b:/tmp# date -s "2038-01-19 03:14:08 UTC"
date: invalid date ‘2038-01-19 03:14:08 UTC’
</pre>
</p><p>
So, okay, put on your "time to do evil" hat, set it one second earlier, 
and wait for the fun to happen.  Starting from scratch again, it does 
this:
</p><p>
<pre>
root@rpi4b:/tmp# systemctl stop chrony
root@rpi4b:/tmp# date -s "2038-01-19 03:14:07 UTC"
Mon 18 Jan 2038 07:14:07 PM PST
root@rpi4b:/tmp# 
Message from syslogd@rpi4b at Jan 18 19:14:07 ...
 systemd[1]: Failed to run main loop: Invalid argument
</p><p>
Broadcast message from systemd-journald@rpi4b (--- XXXX-XX-XX XX:XX:XX):
</p><p>
systemd[1]: Failed to run main loop: Invalid argument
</p><p>
</p><p>
Message from syslogd@rpi4b at Jan 18 19:14:07 ...
 systemd[1]: Freezing execution.
</p><p>
Broadcast message from systemd-journald@rpi4b (--- XXXX-XX-XX XX:XX:XX):
</p><p>
systemd[1]: Freezing execution.
</pre>
</p><p>
Yee haw!  Look at that sucker burn.  I particularly dig the XX-XX 
stuff.  It's like a cartoon character who's been knocked out.
</p><p>
Now, before you whip out the pitchforks, keep in mind that systemd is 
just the messenger here.  It's just working with what it's been given.
</p><p>
Also, the system is actually still up here.  systemd has just basically 
checked out and is not going to do much more for you.  It's not even 
going to take an ordinary "reboot" since that's really just a request 
to init (pid 1, so systemd again) to reboot the box.  You're going to 
need to use "reboot -f" and suffer whatever badness might happen to 
stuff on the box.  It's like pulling the plug, so have fun with that.
</p><p>
What happened?  If you dig around in the remains, you will find that an 
<a href="https://github.com/systemd/systemd/blob/main/src/basic/time-util.c">assertion</a>
in systemd fired.  It's refusing to continue unless clock_gettime() 
returns 0.  Clearly, it returned something else.  systemd saw this 
not-zero value and decided to protect itself by effectively stopping.
</p><p>
So you think "I know, I'll try this again, and strace pid 1 this time, 
and see what was in fact returned".  You get something like this right 
before it croaks:
</p><p>
<tt>
clock_gettime64(CLOCK_REALTIME, {tv_sec=2147483648, tv_nsec=898182}) = 0 
</tt>
</p><p>
... what?  It returned 0?  Yes... and no.  Look at it closely.
</p><p>
clock_gettime<b>64</b> returned 0.  But systemd called clock_gettime.  
strace is showing you the system call... but that system call happens by 
way of a C library function which in this case is being provided by 
glibc 2.31.  If you were to open up glibc's source code and go digging 
around for clock_gettime(), you'd find this:
</p><p>
<pre>
  ret = __clock_gettime64 (clock_id, &amp;tp64);
</p><p>
  if (ret == 0)
    {
      if (! in_time_t_range (tp64.tv_sec))
        {
          __set_errno (EOVERFLOW);
          return -1;
        }
</pre>
</p><p>
First call the (64-bit capable) syscall.  Then assuming that succeeds 
(and it does, per strace), then see if it'll fit in a (32-bit) time_t.  
It won't, so set errno to EOVERFLOW, and return -1.
</p><p>
That's what systemd gets, and so it blows up.
</p><p>
glibc is saying "I can't fit this into that, so I'm failing this call".
</p><p>
This is wrapped in a bunch of preprocessor #if tests such that it only 
runs when __TIMESIZE isn't set to 64, but guess what?  On this 
particular combination of hardware and software, __TIMESIZE is in fact 
32.  Grovel around in the headers if you like and follow the bouncing 
ball starting here:
</p><p>
<pre>
./arm-linux-gnueabihf/bits/timesize.h:#define __TIMESIZE	__WORDSIZE
</pre>
</p><p>
... or just write something dumb to printf(..., __TIMESIZE) and see.
</p><p>
To be clear, this is glibc 2.31 on the 32 bit build of 
Raspbian/Raspberry Pi OS 11 (bullseye) on a Pi 4B.  Newer versions 
of the OS will almost certainly not behave this way, since glibc itself 
is marching down the road to having 64-bit time even on 32-bit 
machines.  Once that's done and rolled up into a release, expect this to 
go away.
</p><p>
...
</p><p>
And yes, NetBSD and OpenBSD tore off this band-aid about 10 years ago, 
and it's a done deal now.  I know.  Cheers to that.
</p>

  </body>
</html>
