<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iamkroot.github.io/blog/zig-memleak">Original</a>
    <h1>The curious case of a memory leak in a Zig program</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is a small exposition on an unexpected &#34;memory leak&#34; I encountered when writing a Zig program. We will mainly focus on a very simple allocation pattern and see how it causes a &#34;leak&#34; (you will see why I am putting it in quotes) when using a particular allocator from Zig&#39;s stdlib.</p><p><a target="_blank" rel="noopener noreferrer" href="https://adventofcode.com/2022/">Advent of Code 2022</a> gave me an excuse to learn the <a target="_blank" rel="noopener noreferrer" href="https://ziglang.org/">Zig programming language</a>. It is touted to be <em>the</em> C replacement, so I definitely expected to write lots of low-level code involving pointers and manual memory management. But the language is designed around making such code safe and ergonomic. I particularly liked how virtually every allocation requires an <em>explicit</em> memory allocator, and that the Zig standard library ships with many allocator types that we would need for common memory usage patterns.</p><p>As a personal challenge, I strived to explicitly limit the amount of memory needed for solving each AoC problem to something that fits on the stack (typically a few MBs at most).</p><p>The <code>FixedBufferAllocator</code> from Zig&#39;s standard library is a perfect fit for my challenge constraint. Here&#39;s a refresher:</p><div><pre><code><span>
</span><span><span>test</span> <span>&#34;fixed buffer allocator&#34;</span> <span>{</span>
</span><span>    <span>var</span> buffer<span>:</span> <span><span>[</span><span>1000</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
</span><span>    <span>var</span> fba <span>=</span> std<span>.</span>heap<span>.</span>FixedBufferAllocator<span>.</span><span>init</span><span>(</span><span>&amp;</span>buffer<span>)</span><span>;</span>
</span><span>
</span><span>    <span>const</span> allocator <span>=</span> fba<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>const</span> memory <span>=</span> <span>try</span> allocator<span>.</span><span>alloc</span><span>(</span><span>u8</span><span>,</span> <span>100</span><span>)</span><span>;</span>
</span><span>    <span>defer</span> allocator<span>.</span><span>free</span><span>(</span>memory<span>)</span><span>;</span>
</span><span>
</span><span>    <span>try</span> <span>expect</span><span>(</span>memory<span>.</span>len <span>==</span> <span>100</span><span>)</span><span>;</span>
</span><span>    <span>try</span> <span>expect</span><span>(</span><span>@TypeOf</span><span>(</span>memory<span>)</span> <span>==</span> <span>[</span><span>]</span><span>u8</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>The allocator is backed by a bytearray of fixed length (<code>1000</code> bytes in the snippet above) which is allocated on the stack. It keeps allocating memory from the slice until it hits the end, at which point it returns a <code>OutOfMemory</code> error. <sup><a href="#user-content-fn-oom" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-oom">1</a></sup></p><p>Enough background, let&#39;s dive into the primary reason this post was made.</p><p>The problem statement of <a target="_blank" rel="noopener noreferrer" href="https://adventofcode.com/2022/day/23">AoC&#39;22 Day 23</a> is similar to Conway&#39;s Game of Life, except with different rules. The details of the problem aren&#39;t important â€” it comes down to simulating an infinite grid of cells in 2D space for a certain number of steps, where each &#34;active&#34; cell interacts with its neighbours in every iteration according to certain rules.</p><p>Next I&#39;ll be describing some relevant portions of my solution. Pause here if you wish to take a shot at the <a target="_blank" rel="noopener noreferrer" href="https://adventofcode.com/2022/day/23">problem</a> yourself first!</p><p>As an implementation detail, an infinite grid means we can&#39;t use a traditional 2D array data structure in a very straightforward way. As a starting point, I elected to simply use a hashset to store the <code>(x,y)</code> coordinates of all the cells that are &#34;active&#34; in the grid in the current step. <sup><a href="#user-content-fn-dyn" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-dyn">2</a></sup></p><div><pre><code><span><span>const</span> <span>Point2D</span> <span>=</span> <span>struct</span> <span>{</span>
</span><span>	x<span>:</span> <span><span>i32</span></span><span>,</span>
</span><span>	y<span>:</span> <span><span>i32</span></span><span>,</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span>
</span><span><span>const</span> CellSet <span>=</span> std<span>.</span><span>AutoHashMap</span><span>(</span>Point2D<span>,</span> <span>void</span><span>)</span><span>;</span> 
</span><span>
</span><span><span>const</span> <span>Grid</span> <span>=</span> <span>struct</span> <span>{</span>
</span><span>	cells<span>:</span> <span>CellSet</span><span>,</span>
</span><span><span>}</span><span>;</span>
</span></code></pre></div><p>The data structures are pretty self-explanatory I hope. I chose to wrap <code>cells</code> inside a <code>Grid</code> just in case I needed to store other auxiliary data. Turned out to be unnecessary, but let&#39;s continue with this for now.</p><p>We need to run the simulation for certain number of iterations, updating the <code>grid</code> each time:</p><div><pre><code><span><span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
</span><span>	<span>var</span> buffer<span>:</span> <span><span>[</span><span>20000</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
</span><span>	<span>var</span> fba <span>=</span> std<span>.</span>heap<span>.</span>FixedBufferAllocator<span>.</span><span>init</span><span>(</span><span>&amp;</span>buffer<span>)</span><span>;</span>
</span><span>	<span>const</span> allocator <span>=</span> fba<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>	<span>...</span>
</span><span>
</span><span>	<span>for</span><span>(</span><span>0</span><span>..</span>numSteps<span>)</span> <span>|</span>i<span>|</span> <span>{</span>
</span><span>	    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;Round {}\n&#34;</span><span>,</span> <span>.</span><span>{</span> i <span>}</span><span>)</span><span>;</span>
</span><span>	    <span>try</span> <span>step</span><span>(</span>grid<span>)</span><span>;</span>
</span><span>	<span>}</span>
</span><span>	
</span><span><span>}</span>
</span></code></pre></div><p>The core part is a repated call to the <code>step</code> function. It takes the grid state (set of active cells) and basically applies the interaction rules to update the locations of active cells.</p><div><pre><code><span><span>fn</span> <span>step</span><span>(</span>grid<span>:</span> <span><span>*</span>Grid</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
</span><span>	
</span><span>	<span>var</span> new_cells <span>=</span> CellSet<span>.</span><span>init</span><span>(</span>grid<span>.</span>cells<span>.</span>allocator<span>)</span><span>;</span>
</span><span>	
</span><span>	<span>try</span> new_cells<span>.</span><span>ensureTotalCapacity</span><span>(</span>grid<span>.</span>cells<span>.</span><span>count</span><span>(</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>	<span>...</span>
</span><span>
</span><span>	
</span><span>	grid<span>.</span>cells<span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span> 
</span><span>	grid<span>.</span>cells <span>=</span> new_cells<span>;</span> 
</span><span><span>}</span>
</span></code></pre></div><p>The key insight here is that the game rules ensure that the number of active cells remains constant throughout. As a side note, Zig lets us take advantage of this with the <code>new_cells.ensureTotalCapacity</code> call. Our algorithm can guarantee that there will be no allocations needed when actually inserting elements into this set, preferring to call <code>CellSet.putAssumeCapacity</code>, and the like <sup><a href="#user-content-fn-tigerbeetle" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-tigerbeetle">3</a></sup>.</p><p>We can go one <em>step</em> further (pun intended :3), and assert that the amount of memory allocated before and after every invocation of <code>step</code> is the same. This is because we make sure that the old hashset is freed before we exit the function. So, we are done... Right?</p><p>Alas, we get an <code>OutOfMemory</code> error after a few calls to <code>step</code> when running on the provided input (~2500 active cells). My solution started with the <code>FixedBufferAllocator</code> backed by a modest <code>20KB</code> buffer. At its peak, we need to store 2 hash sets in memory (just before we free the old one at end of <code>step</code>). Maybe the hashsets really take up more than <code>20KB</code>?</p><p>So my first instinct was to increase the buffer size. But this does not work. What&#39;s more, increasing it all the way up to a few MBs is still not enough- each time we can make a few more calls to <code>step</code> than before, but eventually it gives <code>OutOfMemory</code>. This really goes against the &#34;no extra memory&#34; assertion we made about <code>step</code>.</p><p>There is a memory leak.</p><p>[Cut- some hours of head-bashing to figure out just <em>how</em> the old hashtables were being leaked. Why isn&#39;t <code>deinit</code> working??]</p><p>After coming to the conclusion that the <code>deinit</code> is doing its job just fine and frees the old hashset, I had to look for the leak elsewhere.</p><p>I started to use a <em>different</em> allocator for <code>new_cells</code>:</p><div><pre><code><span><span>fn</span> <span>step_with_tempalloc</span><span>(</span>grid<span>:</span> <span><span>*</span>Grid</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
</span><span>	<span>var</span> temp_buf<span>:</span> <span><span>[</span><span>40000</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
</span><span>	<span>var</span> temp_fba <span>=</span> std<span>.</span>heap<span>.</span>FixedBufferAllocator<span>.</span><span>init</span><span>(</span><span>&amp;</span>temp_buf<span>)</span><span>;</span>
</span><span>    <span>const</span> temp_alloc <span>=</span> temp_fba<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>	<span>var</span> new_cells <span>=</span> CellSet<span>.</span><span>init</span><span>(</span>temp_alloc<span>)</span><span>;</span>
</span><span>	
</span><span>	<span>try</span> new_cells<span>.</span><span>ensureTotalCapacity</span><span>(</span>grid<span>.</span>cells<span>.</span><span>count</span><span>(</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>	<span>...</span>
</span><span>
</span><span>	
</span><span>	
</span><span>	
</span><span>
</span><span>	grid<span>.</span>cells<span>.</span><span>clearRetainingCapacity</span><span>(</span><span>)</span><span>;</span>
</span><span>	
</span><span>	<span>copyHashTable</span><span>(</span>new_cells<span>,</span> <span>&amp;</span>grid<span>.</span>cells<span>)</span><span>;</span>
</span><span>	
</span><span><span>}</span>
</span></code></pre></div><p>Now, we allocate <code>new_cells</code> in a temporary allocator for every iteration, and copy it over to <code>grid.cells</code> at the end. Implementation detail- Now we cannot simply &#34;swap pointers&#34; and set the <code>grid.cells</code> field as we did before, since <code>new_cells</code> will be invalidated once the function exits. We need to manually copy over all the entries from <code>new_cells</code> into <code>grid.cells</code>.</p><p>It worked!! We could stop now, but this solution feels suboptimal. Can&#39;t we avoid the hash table copy somehow? Let&#39;s try to debug our old code.</p><p>One thing we can do is ask the <code>fba</code> how much memory it has allocated<sup><a href="#user-content-fn-lsp" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-lsp">4</a></sup>-</p><div><pre><code><span>    <span>...</span>
</span><span>	<span>copyHashTable</span><span>(</span>new_cells<span>,</span> <span>&amp;</span>grid<span>.</span>cells<span>)</span><span>;</span>
</span><span>
</span><span>    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;new_cells memuse: {}\n&#34;</span><span>,</span> <span>.</span><span>{</span>temp_fba<span>.</span>end_index<span>}</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>This always printed the same number (<code>36888</code> in my case) across different runs of <code>step</code>, meaning the <code>new_cells</code> hashset is always the same size. This further supports our assertion that total memory is constant across <code>step</code> calls. Then why did the original <code>step</code> leak?!!</p><p>Wait a minute...</p><p>.</p><p>.</p><p><code>end_index</code> is an interesting name for a variable... Why not call it <code>allocated_bytes</code>, or something?</p><p>AHA!</p><p>After reading the <a target="_blank" rel="noopener noreferrer" href="https://github.com/ziglang/zig/blob/c31007bb47a4d1d62917324a33e9a9a6cd1df5a6/lib/std/heap.zig#L365">source code of <code>FixedBufferAllocator</code></a>, it becomes clear why the <code>step</code> function leaked. Let us dig in.</p><p>The allocator state consists of only two fields-</p><div><pre><code><span><span>pub</span> <span>const</span> <span>FixedBufferAllocator</span> <span>=</span> <span>struct</span> <span>{</span>
</span><span>    end_index<span>:</span> <span><span>usize</span></span><span>,</span>
</span><span>    buffer<span>:</span> <span><span>[</span><span>]</span><span>u8</span></span><span>,</span>
</span><span>
</span><span>    <span>...</span>
</span><span><span>}</span>
</span></code></pre></div><p>The <code>buffer</code> is the backing slice of bytes (made of a <code>u8</code> pointer and <code>usize</code> length), and <code>end_index</code> is the last byte that has been allocated till now.</p><p>To realize how unsophisticated this is, here is the <a target="_blank" rel="noopener noreferrer" href="https://github.com/ziglang/zig/blob/c31007bb47a4d1d62917324a33e9a9a6cd1df5a6/lib/std/heap.zig#L458-L472">implementation of <code>free</code></a>-</p><div><pre><code><span><span>fn</span> <span>free</span><span>(</span>
</span><span>    ctx<span>:</span> <span><span>*</span>anyopaque</span><span>,</span>
</span><span>    buf<span>:</span> <span><span>[</span><span>]</span><span>u8</span></span><span>,</span>
</span><span>    log2_buf_align<span>:</span> <span><span>u8</span></span><span>,</span>
</span><span>    return_address<span>:</span> <span><span>usize</span></span><span>,</span>
</span><span><span>)</span> <span><span>void</span></span> <span>{</span>
</span><span>    <span>const</span> self <span>=</span> <span>@ptrCast</span><span>(</span><span>*</span>FixedBufferAllocator<span>,</span> <span>@alignCast</span><span>(</span><span>@alignOf</span><span>(</span>FixedBufferAllocator<span>)</span><span>,</span> ctx<span>)</span><span>)</span><span>;</span>
</span><span>    _ <span>=</span> log2_buf_align<span>;</span>
</span><span>    _ <span>=</span> return_address<span>;</span>
</span><span>    <span>assert</span><span>(</span>self<span>.</span><span>ownsSlice</span><span>(</span>buf<span>)</span><span>)</span><span>;</span> 
</span><span>
</span><span>    <span>if</span> <span>(</span>self<span>.</span><span>isLastAllocation</span><span>(</span>buf<span>)</span><span>)</span> <span>{</span>
</span><span>        self<span>.</span>end_index <span>-=</span> buf<span>.</span>len<span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>fn</span> <span>isLastAllocation</span><span>(</span>self<span>:</span> <span><span>*</span>FixedBufferAllocator</span><span>,</span> buf<span>:</span> <span><span>[</span><span>]</span><span>u8</span></span><span>)</span> <span><span>bool</span></span> <span>{</span>
</span><span>    <span>return</span> buf<span>.</span>ptr <span>+</span> buf<span>.</span>len <span>==</span> self<span>.</span>buffer<span>.</span>ptr <span>+</span> self<span>.</span>end_index<span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>Don&#39;t worry about all the extra cruft. The core part is in these lines-</p><div><pre><code><span><span>if</span> <span>(</span>self<span>.</span><span>isLastAllocation</span><span>(</span>buf<span>)</span><span>)</span> <span>{</span>
</span><span>    self<span>.</span>end_index <span>-=</span> buf<span>.</span>len<span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>Geddit?</p><p>The <code>end_index</code> is only decremented if the memory to be freed is at the end of the allocated region. Put another way, the allocator behaves like a stack. You can only <code>free</code> the most recently allocated slice first. Otherwise <code>free</code> is a no-op.</p><p>To verify, let&#39;s take one <em>step</em> back (sorry, I just couldn&#39;t help myself :3), and print the &#34;memory usage&#34; for our original version of <code>step</code>-</p><div><pre><code><span>
</span><span><span>for</span><span>(</span><span>0</span><span>..</span>numSteps<span>)</span> <span>|</span>i<span>|</span> <span>{</span>
</span><span>    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;Round {} memuse: {}\n&#34;</span><span>,</span> <span>.</span><span>{</span> i<span>,</span> fba<span>.</span>end_index <span>}</span><span>)</span><span>;</span>
</span><span>    <span>try</span> <span>step</span><span>(</span>grid<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>Output:</p><div><pre><code><span>Round 0 memuse: 41864
</span><span>Round 1 memuse: 78752
</span><span>Round 2 memuse: 115640
</span><span>Round 3 memuse: 152528
</span><span>Round 4 memuse: 189416
</span><span>Round 5 memuse: 226304
</span><span>Round 6 memuse: 263192
</span><span>Round 7 memuse: 300080
</span><span>Round 8 memuse: 336968
</span><span>Round 9 memuse: 373856
</span></code></pre></div><p>Yep, after each round the <code>end_index</code> is incremented by <code>36888</code> (<code>=78752-41864</code>), which is exactly the size of <code>new_cells</code> we got from <code>step_with_tempalloc</code> <sup><a href="#user-content-fn-extramem" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-extramem">5</a></sup>.</p><p>I hope you are beginning to see why <a href="#the-step-function">our implementation of <code>step</code></a> was flawed. Here&#39;s some ASCII art to visualize the allocation pattern<sup><a href="#user-content-fn-viz" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-viz">6</a></sup>-</p><div><pre><code><span>step0
</span><span> start: [gridcells...................................]
</span><span> alloc: [gridcells|new_cells.........................]
</span><span> swap : [..........gridcells.........................]
</span><span>step1
</span><span> start: [..........gridcells.........................]
</span><span> alloc: [..........gridcells|new_cells...............]
</span><span>         ^new_cells should ideally have come here
</span><span> swap : [....................gridcells...............]
</span><span>step2
</span><span> start: [....................gridcells...............]
</span><span> alloc: [....................gridcells|new_cells.....]
</span><span> swap : [..............................gridcells.....]
</span><span>... so on, until we hit end of buffer
</span></code></pre></div><p>(The chunks of <code>.</code> represent uninitialized/unused memory in the buffer.)</p><p>Since we always allocated <code>new_cells</code> <em>before</em> freeing <code>grid.cells</code>, the new hashset was always placed after the old one in the backing buffer. The calls to <code>grid.cells.deinit()</code> were thus hitting the no-op case of <code>free</code> since <code>grid.cells</code> was not the last allocation in that buffer.</p><p>There you have it... <code>FixedBufferAllocator</code> is implemented as a <a target="_blank" rel="noopener noreferrer" href="https://os.phil-opp.com/allocator-designs/#bump-allocator">Bump pointer allocator</a>.</p><p>There are many ways to fix the memory leak. I will only outline some of the most obvious solutions here-</p><ol><li>Keep the <code>step_with_tempalloc</code> implementation. It is totally fine to do some extra copies, as it is only a constant overhead.</li><li>To use the original version of <code>step</code> (no extra copies), we could switch to a more sophisticated allocator (like <code>std.heap.page_allocator</code>) that is capable of releasing memory from anywhere, not just the end.</li><li>If you are hell-bent on using <code>FixedBufferAllocator</code> only <em>and</em> you want to avoid copies, there is a way. Using two buffers (and separate allocators backed by them), it is possible to keep swapping between them after every iteration. Try drawing the visual diagram to see why it would work!</li></ol><ul><li>Now you can appreciate why I put &#34;leak&#34; in quotes at the very beginning. Since we are using a <code>FixedBufferAllocator</code>, we can&#39;t call this a &#34;leak&#34; in a traditional sense; there is no memory being &#34;lost&#34; during execution. When the underlying buffer is freed, we do end up releasing all the memory we acquired. More appropriate to call it a <a target="_blank" rel="noopener noreferrer" href="https://queue.acm.org/detail.cfm?id=2538488">Space Leak</a>.</li><li>Both <code>CellSet.deinit</code> and <code>FixedBufferAllocator.free</code> were doing the right thing in isolation. The bug was in my particular usage of the memory allocator. And this leads us to-</li><li><em>Zig&#39;s <code>FixedBufferAllocator</code>, as it is currently implemented, is meant to be used like a stack (Last In, First Out)</em>. Deviate from this at your own peril.</li></ul><p>I am sure I have been abusing <code>FixedBufferAllocator</code> to make it do much more than intended (which probably involved keeping it in a single function scope, useful for simple allocs). But hey, I had a lot of fun pushing the boundaries and discovering how it broke. I hope this was useful for you too!</p></div></div>
  </body>
</html>
