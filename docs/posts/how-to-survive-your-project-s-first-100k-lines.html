<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/first-100k-lines">Original</a>
    <h1>How to Survive Your Project&#39;s First 100k Lines</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<section>
<h2 id="stay-on-top-of-your-testing">
 Stay on top of your testing</h2>
<p>
In a small project, only a few thousand lines, it&#39;s easy to fix a bug without causing any more bugs because you know the system in and out.
</p>

</section>
<section>
<p>
Once you start approaching 10,000 lines, fixing one bug will often cause multiple other bugs. Not just easy bugs, but obscure bugs that your users find six months later.
</p>

</section>
<section>
<p>
However, with tests, you&#39;ll know <i>instantly</i> whether your fix caused any other bugs. You can then try a better fix.
</p>

</section>
<section>
<p>
If you don&#39;t have a vast suite of tests, your project might get slower and slower until changing anything feels like pulling teeth. <a href="#note8" data-noteid="8">8</a>
</p>

</section>
<section>
<p>
Some languages are easier to test with. Javascript&#39;s <a href="https://www.audero.it/blog/2016/12/05/monkey-patching-javascript/">Monkey Patching</a> is a wonderful alternative to mocking, and can make testing much easier. <a href="#note9" data-noteid="9">9</a>
</p>

</section>
<section>
<h3 id="prefer-end-to-end-tests">
 Prefer end-to-end tests</h3>
<p>
In the early days of the Vale compiler, we had a lot of unit tests for our various components.
</p>
<p>
For those unfamiliar, a <b>unit test</b> is one that specifically tests just one piece of code. You craft some inputs, feed those into your code, and check the outputs.
</p>
<p>
Unit tests are nice because they tell you <i>exactly</i> where the bug is, because they test only a small piece of your code.
</p>

</section>
<section>
<p>
However, the data being passed between these components was changing very often, because the project was evolving rapidly in response to user feedback and experiments.
</p>
<p>
<b>And unfortunately, every time this happened, we had to change the unit tests.</b> Quite irksome!
</p>

</section>
<section>
<p>
Instead, we&#39;ve switched over to <b>end-to-end tests.</b> An end-to-end test is where a script will open up your application and click on buttons and type inputs in the right sequence to indirectly run some specific code in your program.
</p>
<p>
For the Vale compiler, it means we run the compiler with some Vale source code, then run it, and make sure it produces the right output. As of this writing, the Vale compiler has <b>1,308 end-to-end tests.</b>
</p>

</section>
<section>
<p>
Some caveats on this advice:
</p>
<ul>
<li>
It not apply to larger endeavors, only ones that have rapidly shifting internals, as new projects often do. As a project becomes larger, other priorities dominate.
</li>
<li>
If there&#39;s a piece of the program whose code changes often but the inputs and outputs are relatively stable, unit tests are still a good choice.
</li>
</ul>

</section>
<section>
<h3 id="know-when-to-add-a-test">
 Know when to add a test</h3>
<p>
It&#39;s good practice to add a test whenever you stumble upon a bug.
</p>

</section>
<section>
<p>
However, let&#39;s take that advice one step further.
</p>

</section>
<section>
<p>
Whenever you have a test that discovers a bug, ask yourself, &#34;could a more specific test have caught this too?&#34; and then add that more specific test.
</p>

</section>
<section>
<p>
This approach has a hidden benefit. If you&#39;re refactoring a nearby area of your code and you break this functionality, you now have a much more specific test failure to tell you what exactly is going wrong.
</p>

</section>
<section>
<h2 id="prioritize-development-velocity">
 Prioritize development velocity</h2>
<p>
If you&#39;re not careful, your development speed can slow to a crawl. Here are some ways to keep yourself nimble:
</p>

</section>
<section>
<p>
<b>Use a language with good compile speeds.</b> If you go doomscrolling on reddit while you&#39;re building, you know your compile times are too long.
</p>

</section>
<section>
<p>
<b>Use a memory-safe language.</b> Memory safety doesn&#39;t just help with security, it helps you avoid bugs that are very difficult to diagnose.
</p>

</section>
<section>
<p>
<b>Prioritize looser coupling.</b> If you have to change code way over there to accommodate a feature way over here, take a step back.
</p>
<p>
Find a way to harness object-oriented benefits:
</p>
<ul>
<li>
Dependency injection (the pattern, not the kind of framework)
</li>
<li>
Encapsulation
</li>
<li>
Polymorphism
</li>
</ul>
<p>
...without incurring object-oriented drawbacks (implementation inheritance&#39;s brittleness).
</p>

</section>
<section>
<p>
<b>Use a flexible language.</b> The best languages let you focus on the problem you&#39;re trying to solve, rather than the constraints of the language which don&#39;t make much sense for your use cases.
</p>
<p>
For example, if you&#39;re making a turn-based roguelike game, C# or Typescript could be better choices than Haskell or Rust, whose extra constraints might cause extra refactoring and complexity. <a href="#note10" data-noteid="10">10</a>
</p>
<p>
Statically-typed, garbage collected languages like Java <a href="#note11" data-noteid="11">11</a> can sometimes be the best in this regard. They may not be flashy but they&#39;re flexible, much more multi-paradigm, and have good compile speeds.
</p>
<p>
Bonus points to languages like Scala that let you temporarily &#34;turn off&#34; the type system via <span>Nothing</span>, so you can work on your feature now and fix the types for unrelated code afterward.
</p>

</section>
<section>
<h2 id="bonus-sanity-checking">
 Bonus: Sanity Checking</h2>
<p>
Let&#39;s take assertions to the next level!
</p>

</section>
<section>
<p>
Let&#39;s say you have a <span>id_to_account HashMap&lt;ID, UserAccount&gt;</span>. Unfortunately, to find a user by name, you have to loop through the entire map, because it&#39;s keyed by ID, not by name.
</p>
<p>
So then you add a separate <span>name_to_account HashMap&lt;str, UserAccount&gt;</span>, and you try to keep these two maps in sync. However, if you accidentally remove an account from only one, you now have a <b>data inconsistency.</b>
</p>

</section>
<section>
<p>
After you add your normal assertions, also consider periodically calling a <span>sanityCheck</span> function:
</p>

    
  

</section>
<section>
<p>
In one case, we have an <a href="https://github.com/ValeLang/Vale/blob/f4ff0d4385484bced63a181c80bb2f81a48ab83f/Frontend/Solver/src/dev/vale/solver/OptimizedSolverState.scala#L547">80-line sanity check function</a> to check that all the state in the generics solver is consistent.
</p>

</section>
<section>
<p>
When I worked on <a href="https://earth.google.com/web/">Earth</a>, I made a 200-line sanityCheck function run before and after every click, which made sure the application was in a sane state. It saved <i>countless</i> hours of debugging.
</p>

</section>
<section>
<p>
Lean hard on this technique, it will serve you well.
</p>

</section>
<section>
<h2 id="thats-all">
 That&#39;s all!</h2>
<p>
Thanks for visiting, and I wish you the best of luck in your first 100,000 lines!
</p>
<p>
In the coming weeks, I&#39;ll be posting the next article in the <a href="https://verdagon.dev/blog/making-regions-part-1-human-factor">Implementing a New Memory Safety Approach</a> series, so subscribe to our <a href="https://verdagon.dev/rss.xml">RSS feed</a>, <a href="https://twitter.com/vale_pl">twitter</a>, or the <a href="https://reddit.com/r/vale">r/Vale</a> subreddit, and come hang out in the <a href="https://discord.gg/SNB8yGH">Vale discord</a>.
</p>

</section>
<section>
<p>
If you found this interesting or entertaining, please consider sponsoring me:
</p>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor me on GitHub!
  </a>
</center>

<p>
With your help, I can write this kind of nonsense more often!
</p>

</section>

      </div></div>
  </body>
</html>
