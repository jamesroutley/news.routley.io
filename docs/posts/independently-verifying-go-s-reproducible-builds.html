<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.agwa.name/blog/post/verifying_go_reproducible_builds">Original</a>
    <h1>Independently verifying Go&#39;s reproducible builds</h1>
    
    <div id="readability-page-1" class="page"><div>



<p>
When you try to compile a Go module that requires a newer version of the Go toolchain than the one you have
installed, the go command <a href="https://go.dev/doc/toolchain#download" rel="external">automatically downloads the newer toolchain</a> and uses it for compiling the module.<label for="sidenote_id1"></label><span><span> (</span>And only that module; your system&#39;s go installation is not replaced.<span>)</span></span>
This useful feature was introduced in Go 1.21 and has let me quickly adopt new Go features in my open source projects
without inconveniencing people with older versions of Go.
</p>

<p>
However, the idea of downloading a binary and executing it on demand makes a lot of people uncomfortable.
It feels like such an easy vector for a supply chain attack, where Google, or an attacker who has compromised
Google or gotten a misissued SSL certificate, could deliver a malicious binary.
Many developers are more comfortable getting Go from their Linux distribution, or compiling
it from source themselves.
</p>

<p>
To address these concerns, the Go project did two things:
</p>

<ol>
<li><p>They made it so every version of Go starting with 1.21 could be
easily reproduced from its source code.  Every time you compile a Go toolchain, it
produces the exact same Zip archive, byte-for-byte, regardless of the current time,
your operating system, your architecture, or other aspects of your environment (such as the directory
from which you run the build).</p></li>

<li><p>They started publishing the checksum of every toolchain Zip archive in a public
<a href="https://transparency.dev/" rel="external">transparency log</a> called the <a href="https://sum.golang.org/" rel="external">Go Checksum Database</a>.
The go command verifies that the checksum of a downloaded toolchain is published
in the Checksum Database for anyone to see.
</p>
</li>
</ol>

<p>
These measures mean that:
</p>

<ol>
<li><p>You can be confident that the binaries downloaded and executed by the
go command are the exact same binaries you would have gotten had you built the toolchain
from source yourself.  If there&#39;s a backdoor, the backdoor has to be in the source code.</p></li>

<li><p>You can be confident that the binaries downloaded and executed by the
go command are the same binaries that everyone else is downloading.  If there&#39;s a backdoor,
it has to be served to the whole world, making it easier to detect.</p></li>
</ol>

<p>
But these measures mean nothing if no one is checking that the binaries
are reproducible, or that the Checksum Database isn&#39;t presenting inconsistent information
to different clients.  Although Google checks reproducibility and publishes
a <a href="https://go.dev/rebuild" rel="external">report</a>, this doesn&#39;t help if you think Google might try to
slip in a backdoor themselves.  There needs to be an independent third party doing the checks.
</p>

<p>
Why not me?  I was involved in Debian&#39;s
<a href="https://reproducible-builds.org/" rel="external">Reproducible Builds</a> project back in the day and developed some of the core tooling used
to make Debian packages reproducible (strip-nondeterminism and disorderfs).  I also
have extensive experience monitoring Certificate Transparency logs and have detected
misbehavior by numerous logs since 2017.  And I do not work for Google (though I have
eaten their food).
</p>

<p>
In fact, I&#39;ve been quietly operating an auditor for the Go Checksum Database since 2020
called <a href="https://sourcespotter.com/" rel="external">Source Spotter</a> (Ã  la <a href="https://sslmate.com/certspotter/" rel="external">Cert Spotter</a>). Source Spotter monitors the Checksum Database,
making sure it doesn&#39;t present inconsistent information or publish more than one checksum for a given module
and version.  I decided to extend Source Spotter to also verify toolchain reproducibility.
</p>

<p>
The Checksum Database was originally intended for recording the checksums of Go modules.
Essentially, it&#39;s a verifiable, append-only log of records which say that a particular
version (e.g. <code>v0.4.0</code>) of a module (e.g. <code>src.agwa.name/snid</code>) has a particular SHA-256 hash.  Go repurposed
it for recording toolchain checksums.  Toolchain records have the pseudo-module
<code>golang.org/toolchain</code> and versions that look like <code>v0.0.1-go<var>VERSION</var>.<var>GOOS</var>-<var>GOARCH</var></code>.  For example, the Go1.24.2 toolchain for linux/amd64 has the module version <code>v0.0.1-go1.24.2.linux-amd64</code>.
</p>

<p>
When Source Spotter sees a new version of the <code>golang.org/toolchain</code> pseudo-module,
it downloads the corresponding source code, builds it in an AWS Lambda function by running <code>make.bash -distpack</code>,
and compares the checksum
of the resulting Zip file to the checksum published in the Checksum Database.  Any mismatches
are published <a href="https://sourcespotter.com/toolchain/" rel="external">on a webpage</a> and
in <a href="https://feeds.api.sourcespotter.com/toolchain/failures.atom" rel="external">an Atom feed</a> which I monitor.
</p>

<p>
So far, Source Spotter has successfully reproduced every toolchain since Go 1.21.0, for every architecture and operating system.
As of publication time, that&#39;s <a href="https://sourcespotter.com/toolchain/#verified" rel="external">2,672 toolchains</a>!
</p>

<h4>Bootstrap Toolchains</h4>

<p>
Since the Go toolchain is written in Go, building it requires an earlier version of the Go toolchain to be installed already.
</p>

<p>When reproducing Go 1.21, 1.22, and 1.23, Source Spotter uses a Go 1.20.14 toolchain that I built from source.  I started by building Go 1.4.3 using a C compiler.  I used Go 1.4.3 to build Go 1.17.13, which I used to build Go 1.20.14.  To mitigate <a href="https://dl.acm.org/doi/10.1145/358198.358210" rel="external">Trusting Trust</a> attacks, I repeated this process on both Debian and Amazon Linux using both GCC and Clang for the Go 1.4 build.  I got the exact same bytes every time, which I believe makes a compiler backdoor vanishingly unlikely.  The scripts I used for this are <a href="https://github.com/AGWA/build-go1.20" rel="external">open source</a>.</p>

<p>When reproducing Go 1.24 or higher, Source Spotter uses a binary toolchain downloaded from the Go module proxy
that it previously verified as being reproducible from source.</p>

<h4>Problems Encountered</h4>

<p>
Compared to reproducing a typical Debian package, it was really easy to reproduce the same bytes when building
the Go toolchains.  Nevertheless, there were some bumps along the way:
</p>

<p>
First, the Darwin (macOS) toolchains published by Google contain signatures produced by Google&#39;s private key.
Obviously, Source Spotter can&#39;t reproduce these.  Instead, Source Spotter has to download
the toolchain (making sure it matches the checksum published in the Checksum Database) and strip the signatures
to produce a new checksum that is verified against the reproduced toolchain.
I reused <a href="https://github.com/SSLMate/sourcespotter/blob/main/toolchain/darwin.go" rel="external">code written by Google</a>
to strip the signatures and I honestly have no clue what it&#39;s doing and whether
it could potentially strip a backdoor.  A review from someone versed in Darwin binaries would be very helpful!
</p>

<p>
Second, to reproduce the linux-arm toolchains, Source Spotter has
to set <code>GOARM=6</code> in the environment... except when reproducing Go 1.21.0, which
<a href="https://github.com/golang/go/issues/62164" rel="external">Google accidentally built using <code>GOARM=7</code></a>.
I don&#39;t understand why <a href="https://pkg.go.dev/cmd/dist" rel="external">cmd/dist</a> (the tool used to build the
toolchain) doesn&#39;t set this environment variable along with the many other environment variables it sets.
</p>

<p>
Finally, the Checksum Database contains a toolchain for Go 1.9.2rc2, which is not a
<a href="https://pkg.go.dev/go/version#IsValid" rel="external">valid version number</a>.
It turns out this version was <a href="https://github.com/golang/go/issues/68634#issuecomment-2867535846" rel="external">released by
mistake</a>.  To avoid raising an error for an invalid version number, Source Spotter has
to <a href="https://github.com/SSLMate/sourcespotter/blob/c883957f32a2162f94fdc6dafa607a1d534ebee3/internal/toolchain/build.go#L119-L124" rel="external">special case it</a>.  Not a huge deal, but I found it interesting because it
demonstrates one of the downsides of transparency logs: you can&#39;t fix or remove entries that were added by mistake!
</p>

<h4>Source Code Transparency</h4>

<p>
Although the toolchain binaries are published in the Checksum Database, the source code is not.
This means Google could serve Source Spotter, and only Source Spotter,
source code which contains a backdoor.  To mitigate this, Source Spotter publishes the
<a href="https://sourcespotter.com/toolchain/#sources" rel="external">checksums</a> of every source tarball it builds.
</p>

<p>
<a href="https://filippo.io/" rel="external">Filippo</a> suggested that Source Spotter build from Go&#39;s Git repository
and publish the Git commit IDs instead, since lots of Go developers have the Go Git repository checked out
and it would be relatively easy for them to compare the state of their repos against what Source Spotter has seen.
Regrettably, Git commit IDs are SHA-1, but this is mitigated by Git&#39;s use of
<a href="https://github.com/cr-marcstevens/sha1collisiondetection" rel="external">Marc Stevens&#39; collision detection</a>,
so the benefits may be worth the risk.
I think building from Git is a good idea, and to bootstrap it, Filippo used <a href="https://github.com/magic-wormhole/magic-wormhole" rel="external">Magic Wormhole</a> to send me the output of <code>git show-ref --tags</code> from his repo while we were both
at the <a href="https://transparency.dev/summit2025/" rel="external">Transparency.dev Summit</a> last week.
</p>

<p>
Ultimately, I would like to see the Go project publish source tarballs in the Checksum Database.
</p>

<h4>Conclusion</h4>

<p>
Thanks to Go&#39;s Checksum Database and reproducible toolchains, Go developers
get the usability benefits of a centralized package repository and binary toolchains
without sacrificing the security benefits of decentralized packages and building from source.
The Go team deserves enormous credit for making this a reality, particularly for building a system
that is not too hard for a third party to verify.  They&#39;ve raised the bar, and I
hope other language and package ecosystems can learn from what they&#39;ve done.
</p>

<p>
Learn more by visiting the <a href="https://sourcespotter.com/" rel="external">Source Spotter website</a>
or the <a href="https://github.com/SSLMate/sourcespotter" rel="external">GitHub repo</a>.
</p>



</div></div>
  </body>
</html>
