<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/BlinkDL/ChatRWKV">Original</a>
    <h1>ChatRWKV, like ChatGPT but powered by the RWKV (RNN-based, open) language model</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I’m in the middle of a programming retreat at the <a href="https://www.recurse.com/">Recurse Center</a> (W2’23), and one of the projects I’ve been working on is an interpreter for a language I designed called <a href="https://github.com/healeycodes/nodots-lang">nodots</a>.</p><p>It’s called <em>nodots</em> because I had some trouble in a <a href="https://github.com/healeycodes/adventlang">previous language</a> when it came to mutating via dot access. So I decided: no dots this time (okay, fine, you can use dots for floats).</p><p>It’s a dynamic language with strong types. It’s got variables, functions, logic, and a few more things — but no for loops (yet).</p><pre><div><div><p><span># recursive fibonacci!</span></p><p><span>fun fib(x)</span></p><p><span>  if (x == 0 or x == 1)</span></p><p><span>    return x;</span></p><p><span>  fi</span></p><p><span>  return fib(x - 1) + fib(x - 2);</span></p><p><span>nuf</span></p><p><span>log(fib(10));</span></p></div></div></pre><h2 id="brief-evaluation-tour">Brief Evaluation Tour</h2><p><em>nodots</em> is a tree-walk interpreter implemented in Python. It uses the <a href="https://github.com/lark-parser/lark">Lark</a> parsing toolkit to build a <a href="https://lark-parser.readthedocs.io/en/latest/classes.html#tree">Tree</a> of nodes from some source code. The interpreter then starts at the root of the tree and recursively visits the child nodes, processing each node according to its type and the context of the parent node.</p><p>Given a program like <code>log(1 + 2);</code>, the parser uses the language’s <a href="https://github.com/healeycodes/nodots-lang/blob/main/grammar.py">grammar</a> to construct a tree that looks a bit like below (I’ve trimmed some node levels for brevity).</p><pre><div><div><p><span>program</span></p><p><span> declaration</span></p><p><span>  statement</span></p><p><span>   call</span></p><p><span>    identifier  log</span></p><p><span>    arguments</span></p><p><span>     term</span></p><p><span>      call</span></p><p><span>       number   1</span></p><p><span>      call</span></p><p><span>       number   2</span></p></div></div></pre><p>Program state is stored in a context object, sometimes called a value table. The one-line program above doesn’t insert any variables but it does look up <code>log</code> to find a standard library function.</p><p>A child context is created when the scope deepens, like inside a <em>nodots</em> function. A reference to the root context object, or some child or grand-child context, is passed around during the evaluation step of the interpreter. When evaluating an identifier, the most local scope is checked first, and then the next scope up is checked, over and over, until the root scope when an error is thrown. Similar to JavaScript’s scoping rules.</p><p>Our one-line program’s tree requires a high number of function calls, and a high amount of memory allocation, relative to the computation required (this is why tree-walk interpreters are slower than <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)#Variations">the alternatives</a>). Here’s a trimmed list of function calls made by the interpreter, in order: </p><pre><div><div><p><span># root node and root context</span><span></span></p><p><span>eval_program</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span>eval_declaration</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span>eval_statement</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># look up `log` and find a function</span><span></span></p><p><span>eval_identifier</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># call the function with</span><span></span></p><p><span>eval_call</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># arguments that must be evaluated</span><span></span></p><p><span>eval_arguments</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># there&#39;s a single argument,</span><span></span></p><p><span></span><span># an addition sub-tree</span><span></span></p><p><span>eval_term</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># evaluate the left term</span><span></span></p><p><span>eval_call</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># evaluate the right term</span><span></span></p><p><span>eval_call</span><span>(</span><span>node</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span># `3` is sent to standard out</span></p></div></div></pre><h2 id="for-loop-syntax">For Loop Syntax</h2><p>In the C tradition of programming languages, a for loop has three parts; initial, limit, and increment. This is what the syntax will look like in <em>nodots.</em></p><pre><div><div><p><span>for (i = 0; i &lt; 5; i = i + 1)</span></p><p><span>  log(i);</span></p><p><span>rof</span></p></div></div></pre><p>So here, the initial is <code>i = 0;</code> which creates a variable inside the for loop’s scope, the limit is <code>i &lt; 5</code> which is checked before each iteration, and the increment is <code>i = i + 1</code>.</p><p>If we try to execute this example code, we get a parsing error like:</p><pre><div><div><p><span>Unexpected token Token(&#39;SEMICOLON&#39;, &#39;;&#39;) at line 3, column 11.</span></p></div></div></pre><p>We need to alter the language’s grammar so the parser understands our new feature.</p><p>The for loop’s parts are expressions which the interpreter already supports. The body contains any number of declarations — like a variable assignment, an expression, or even another for loop.</p><p>We use existing grammar rules, and evaluation logic, as building blocks to reuse abstractions that are already covered by the language’s test suite.</p><pre><div><div><p><span>-</span><span> statement       : expression_stmt | return_stmt | if_stmt</span></p><p><span></span><span>+</span><span> statement       : expression_stmt | return_stmt | if_stmt | for_stmt</span></p><p><span></span><span>expression_stmt : expression? &#34;;&#34;</span></p><p><span>return_stmt     : &#34;return&#34; expression? &#34;;&#34;</span></p><p><span>if_stmt         : &#34;if&#34; &#34;(&#34; expression &#34;)&#34; declaration* &#34;fi&#34;</span></p><p><span></span><span>+</span><span> for_stmt        : &#34;for&#34; &#34;(&#34; expression_stmt expression_stmt expression &#34;)&#34; declaration* &#34;rof&#34;</span></p></div></div></pre><p>When we execute the example code again, we no longer get a parsing error (yay) so the tree is constructed, and then evaluated and … we get a new error.</p><pre><div><div><p><span>File &#34;/Users/andrew/Documents/GitHub/nodots-lang/interpreter.py&#34;, line 457, in eval_statement</span></p><p><span>    raise Exception(&#34;unreachable&#34;)</span></p></div></div></pre><p>The interpreter doesn’t know how to evaluate a for statement. Let’s fix that.</p><pre><div><div><p><span>def</span><span> </span><span>eval_statement</span><span>(</span><span>node</span><span>:</span><span> Tree</span><span>,</span><span> context</span><span>:</span><span> Context</span><span>)</span><span> </span><span>-</span><span>&gt;</span><span> ReturnValue </span><span>|</span><span> Value</span><span>:</span><span></span></p><p><span>    </span><span>for</span><span> child </span><span>in</span><span> node</span><span>.</span><span>children</span><span>:</span><span></span></p><p><span>        </span><span>if</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;expression_stmt&#34;</span><span>:</span><span></span></p><p><span>            </span><span>return</span><span> eval_expression_stmt</span><span>(</span><span>child</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span>        </span><span>elif</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;return_stmt&#34;</span><span>:</span><span></span></p><p><span>            </span><span>return</span><span> eval_return_stmt</span><span>(</span><span>child</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span>        </span><span>elif</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;if_stmt&#34;</span><span>:</span><span></span></p><p><span>            </span><span>return</span><span> eval_if_stmt</span><span>(</span><span>child</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span>+</span><span>        </span><span>elif</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;for_stmt&#34;</span><span>:</span><span></span></p><p><span></span><span>+</span><span>            </span><span>return</span><span> eval_for_stmt</span><span>(</span><span>child</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span>    </span><span>raise</span><span> Exception</span><span>(</span><span>&#34;unreachable&#34;</span><span>)</span></p></div></div></pre><p>And the new function, <code>eval_for_stmt</code>:</p><pre><div><div><p><span>def</span><span> </span><span>eval_for_stmt</span><span>(</span><span>node</span><span>:</span><span> Tree</span><span>,</span><span> context</span><span>:</span><span> Context</span><span>)</span><span>:</span><span></span></p><p><span>    </span><span># we create a child context of the current scope</span><span></span></p><p><span>    </span><span># so the for loop body can alter existing</span><span></span></p><p><span>    </span><span># variables but doesn&#39;t &#34;pollute&#34; the outer</span><span></span></p><p><span>    </span><span># scope with new variables</span><span></span></p><p><span>    for_context </span><span>=</span><span> context</span><span>.</span><span>get_child_context</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span># Tree contains a list of children of type</span><span></span></p><p><span>    </span><span># List[Tree | Token], we can throw away</span><span></span></p><p><span>    </span><span># the &#34;for&#34;, &#34;(&#34;, &#34;)&#34;, and &#34;rof&#34; tokens</span><span></span></p><p><span>    parts</span><span>:</span><span> List</span><span>[</span><span>Tree</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span></span></p><p><span>    </span><span>for</span><span> child </span><span>in</span><span> node</span><span>.</span><span>children</span><span>:</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>isinstance</span><span>(</span><span>child</span><span>,</span><span> Tree</span><span>)</span><span>:</span><span></span></p><p><span>            parts</span><span>.</span><span>append</span><span>(</span><span>child</span><span>)</span><span></span></p><p><span>    </span><span># grab the for loop&#39;s parts</span><span></span></p><p><span>    initial_expr_stmt</span><span>,</span><span> limit_expr_stmt</span><span>,</span><span> increment_expr </span><span>=</span><span> parts</span><span>[</span><span>:</span><span>3</span><span>]</span><span></span></p><p><span>    </span><span># we start by evaluating the intial part</span><span></span></p><p><span>    </span><span># which is `i = 0` in our example code </span><span></span></p><p><span>    eval_expression_stmt</span><span>(</span><span>initial_expr_stmt</span><span>,</span><span> for_context</span><span>)</span><span></span></p><p><span>    </span><span>while</span><span> </span><span>True</span><span>:</span><span></span></p><p><span>        </span><span># evaluate the limit (`i &lt; 5`)</span><span></span></p><p><span>        limit_check </span><span>=</span><span> eval_expression_stmt</span><span>(</span><span>limit_expr_stmt</span><span>,</span><span> for_context</span><span>)</span><span></span></p><p><span>        </span><span># throw a language error if the type isn&#39;t BoolValue</span><span></span></p><p><span>        limit_check</span><span>.</span><span>check_type</span><span>(</span><span></span></p><p><span>            limit_expr_stmt</span><span>.</span><span>meta</span><span>.</span><span>line</span><span>,</span><span></span></p><p><span>            limit_expr_stmt</span><span>.</span><span>meta</span><span>.</span><span>column</span><span>,</span><span></span></p><p><span>            </span><span>&#34;BoolValue&#34;</span><span>,</span><span></span></p><p><span>            </span><span>&#34;expected boolean&#34;</span><span>,</span><span></span></p><p><span>        </span><span>)</span><span></span></p><p><span>        </span><span># stop looping if the limit evaluates to false</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>not</span><span> limit_check</span><span>.</span><span>value</span><span>:</span><span></span></p><p><span>            </span><span>break</span><span></span></p><p><span>        </span><span># the for loop body contains an any number of</span><span></span></p><p><span>        </span><span># declaration nodes which we evaluate in order</span><span></span></p><p><span>        </span><span>for</span><span> decl_expr </span><span>in</span><span> parts</span><span>[</span><span>3</span><span>:</span><span>]</span><span>:</span><span></span></p><p><span>            </span><span># `log(i);`</span><span></span></p><p><span>            eval_declaration</span><span>(</span><span>decl_expr</span><span>,</span><span> for_context</span><span>)</span><span></span></p><p><span>        </span><span># `i = i + 1`</span><span></span></p><p><span>        eval_expression</span><span>(</span><span>increment_expr</span><span>,</span><span> for_context</span><span>)</span><span></span></p><p><span>    </span><span>return</span><span> NilValue</span><span>(</span><span>None</span><span>)</span></p></div></div></pre><p>Now, when we execute our example code, the program runs and logs out the value of <code>i</code> five times. Success!</p><h2 id="language-tests">Language Tests</h2><p>When I write small languages, I like to add tests as soon as possible because iterating on syntax and evaluation logic can have spider-y effects. You never know what you’re going to break.</p><p>For <em>nodots</em>, the test suite is <code>./run_tests.sh</code> which checks type hints with Mypy, executes the test programs, and checks the final declaration’s result value. For example, we can perform a bunch of math calls that gives us some unique answer and then assert that the answer is correct. I find these black box tests better than unit tests because the internals of languages change very frequently during their early days!</p><p>See <a href="https://craftinginterpreters.com/chunks-of-bytecode.html#design-note">this design note</a> in Crafting Interpreters for an overview for why and how you should test your language.</p><p>The most obvious test case for the feature we just added is: does the for loop run the correct number of times, and maybe another test case is: are we bleeding out a declaration into the outer scope? This second issue could cause hard to debug bugs for users (aka me).</p><pre><div><div><p><span># for loop iteration</span><span></span></p><p><span></span><span># and access to outer scope</span><span></span></p><p><span>assert_or_log</span><span>(</span><span></span></p><p><span>    interpret</span><span>(</span><span>&#34;&#34;&#34;</span></p><p><span>sum = 0;</span></p><p><span>for (i = 0; i &lt; 5; i = i + 1)</span></p><p><span>  sum = sum + i;</span></p><p><span>rof</span></p><p><span>sum;</span></p><p><span>&#34;&#34;&#34;</span><span>)</span><span>.</span><span>value</span><span>,</span><span> </span><span>10</span><span>)</span><span> </span><span># 0 + 1 + 2 + 3 + 4</span></p></div></div></pre><p>The don’t-bleed-into-the-outer-scope test uses the same setup but we stringify the result because it’s a language error instead of a language value.</p><pre><div><div><p><span># new variables should be isolated</span><span></span></p><p><span>assert_or_log</span><span>(</span><span></span></p><p><span>    </span><span>str</span><span>(</span><span>interpret</span><span>(</span><span>&#34;for (i = 0; i &lt; 5; i = i + 1) rof i;&#34;</span><span>)</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>&#34;1:35 [error] unknown variable &#39;i&#39;&#34;</span><span>,</span><span></span></p><p><span></span><span>)</span></p></div></div></pre><h2 id="adding-break-and-continue-statements">Adding Break and Continue Statements</h2><p>The keywords <code>break</code> and <code>continue</code> are part of the minimum feature set one expects from a for loop.</p><p>Here’s some new example code that breaks out of the for loop, and as a result, never mutates the variable more than once.</p><pre><div><div><p><span>a = 0;</span></p><p><span>for (i = 0; i &lt; 5; i = i + 1)</span></p><p><span>  a = a + 1;</span></p><p><span>  break;</span></p><p><span>rof</span></p><p><span>a; # should be `1`</span></p></div></div></pre><p>If we run this example before making any changes, <em>nodots</em> tries to look up <code>break</code> as if it’s a variable, and we get the following error:</p><pre><div><div><p><span>5:3 [error] unknown variable &#39;break&#39;</span></p></div></div></pre><p>Like before, we start with a grammar change because we’re adding new statements.</p><pre><div><div><p><span>-</span><span> statement       : expression_stmt | return_stmt | if_stmt | for_stmt</span></p><p><span></span><span>+</span><span> statement       : expression_stmt | return_stmt | if_stmt | for_stmt | break_stmt | continue_stmt</span></p><p><span></span><span>expression_stmt : expression? &#34;;&#34;</span></p><p><span>return_stmt     : &#34;return&#34; expression? &#34;;&#34;</span></p><p><span>if_stmt         : &#34;if&#34; &#34;(&#34; expression &#34;)&#34; declaration* &#34;fi&#34;</span></p><p><span>for_stmt        : &#34;for&#34; &#34;(&#34; expression_stmt expression_stmt expression &#34;)&#34; declaration* &#34;rof&#34;</span></p><p><span></span><span>+</span><span> break_stmt      : &#34;break&#34; &#34;;&#34;</span></p><p><span></span><span>+</span><span> continue_stmt   : &#34;continue&#34; &#34;;&#34;</span></p></div></div></pre><p>Now, when we run our example we get a new error, similar to before. We’ve added a new statement but our interpreter doesn’t know how to evaluate it yet.</p><pre><div><div><p><span>File &#34;/Users/andrew/Documents/GitHub/nodots-lang/interpreter.py&#34;, line 473, in eval_statement</span></p><p><span>    raise Exception(&#34;unreachable&#34;)</span></p></div></div></pre><p>A break statement and a continue statement behave similar to return statements. When we hit them, we want to stop executing the current section, and “trampoline” up the call stack to some place where they can be handled.</p><p>As our interpreter is implemented in a high level language like Python, we have such a tool available to us. We can raise, and catch, exceptions.</p><pre><div><div><p><span>+</span><span> </span><span>class</span><span> </span><span>BreakEscape</span><span>(</span><span>Exception</span><span>)</span><span>:</span><span></span></p><p><span></span><span>+</span><span>    </span><span>pass</span><span></span></p><p><span></span><span>+</span><span> </span><span>class</span><span> </span><span>ContinueEscape</span><span>(</span><span>Exception</span><span>)</span><span>:</span><span></span></p><p><span></span><span>+</span><span>    </span><span>pass</span></p></div></div></pre><p>We’ll raise these after hitting a break or continue statement. Inside <code>eval_statement</code> we add:</p><pre><div><div><p><span>elif</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;for_stmt&#34;</span><span>:</span><span></span></p><p><span>  </span><span>return</span><span> eval_for_stmt</span><span>(</span><span>child</span><span>,</span><span> context</span><span>)</span><span></span></p><p><span></span><span>+</span><span> </span><span>elif</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;break_stmt&#34;</span><span>:</span><span></span></p><p><span></span><span>+</span><span>     </span><span>raise</span><span> BreakEscape</span><span>(</span><span>)</span><span></span></p><p><span></span><span>+</span><span> </span><span>elif</span><span> child</span><span>.</span><span>data </span><span>==</span><span> </span><span>&#34;continue_stmt&#34;</span><span>:</span><span></span></p><p><span></span><span>+</span><span>     </span><span>raise</span><span> ContinueEscape</span><span>(</span><span>)</span></p></div></div></pre><p>These exceptions should be caught while we’re executing the body of a for loop, so inside <code>eval_for_stmt</code> we alter the section we added earlier.</p><pre><div><div><p><span>for</span><span> decl_expr </span><span>in</span><span> parts</span><span>[</span><span>3</span><span>:</span><span>]</span><span>:</span><span></span></p><p><span></span><span>+</span><span>    </span><span>try</span><span>:</span><span></span></p><p><span></span><span>+</span><span>        eval_declaration</span><span>(</span><span>decl_expr</span><span>,</span><span> for_context</span><span>)</span><span></span></p><p><span></span><span>+</span><span>     </span><span>except</span><span> BreakEscape</span><span>:</span><span></span></p><p><span></span><span>+</span><span>        </span><span>return</span><span> NilValue</span><span>(</span><span>None</span><span>)</span><span></span></p><p><span></span><span>+</span><span>     </span><span>except</span><span> ContinueEscape</span><span>:</span><span></span></p><p><span></span><span>+</span><span>        </span><span>break</span></p></div></div></pre><p>Finally, we can confirm our change with two test cases.</p><pre><div><div><p><span># break stops a for loop</span><span></span></p><p><span>assert_or_log</span><span>(</span><span></span></p><p><span>    interpret</span><span>(</span><span>&#34;&#34;&#34;</span></p><p><span>a = 0;</span></p><p><span>for (i = 0; i &lt; 5; i = i + 1)</span></p><p><span>  a = a + 1;</span></p><p><span>  break;</span></p><p><span>rof</span></p><p><span>a;</span></p><p><span>&#34;&#34;&#34;</span><span>)</span><span>.</span><span>value</span><span>,</span><span> </span><span>1</span><span>)</span><span> </span><span># `1` because `a = a + 1;` runs once</span><span></span></p><p><span></span><span># continue skips to the next iteration</span><span></span></p><p><span>assert_or_log</span><span>(</span><span></span></p><p><span>    interpret</span><span>(</span><span>&#34;&#34;&#34;</span></p><p><span>a = 0;</span></p><p><span>for (i = 0; i &lt; 5; i = i + 1)</span></p><p><span>  continue;</span></p><p><span>  a = 1;</span></p><p><span>rof</span></p><p><span>a;</span></p><p><span>&#34;&#34;&#34;</span><span>)</span><span>.</span><span>value</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span># `=` because `a = 1;` never happens</span></p></div></div></pre><h2 id="links">Links</h2><p>This blog post covers two commits to <a href="https://github.com/healeycodes/nodots-lang">nodots</a>:</p><ul><li>Add basic for loop support (<a href="https://github.com/healeycodes/nodots-lang/commit/50faa7fd40d7d36d4ff60ad1c2428708667c452e">50faa7f</a>)</li><li>Add continue and break statements (<a href="https://github.com/healeycodes/nodots-lang/commit/513a2e71d667ad88a3675f22f7e0cf3ed3145590">513a2e7</a>)</li></ul><p>The latter commit also has logic to handle a case that we didn’t cover. When <code>break;</code> or <code>continue;</code> appears outside of a for loop body, the user should hit a helpful error.</p><p>Most of what I know about interpreters, I learned from <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>, the <a href="https://dotink.co">Ink blog</a>, the <a href="https://oaklang.org/posts/">Oak blog</a>, or another book called Language Implementation Patterns. I recommend the first resource, Crafting Interpreters, as it assumes less prior knowledge and has wonderful illustrations!</p><p><small>Thanks to <a href="https://samgeo.codes">Samuel Eisenhandler</a> for providing feedback on an early draft.</small></p></div></div></div>
  </body>
</html>
