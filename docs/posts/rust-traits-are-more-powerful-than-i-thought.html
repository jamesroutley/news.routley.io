<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://miccah.io/posts/rust-traits.html">Original</a>
    <h1>Rust traits are more powerful than I thought</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I have been learning the Rust programming language in my spare time for
a little over 2 years now. My first mental model of traits consisted of
a contract for types that would implement the trait, similar to Go’s
interfaces. It wasn’t until recently when I decided to explore traits
during <a href="https://adventofcode.com/2021/">Advent of Code</a> that I started
to realize how integrated these contracts are into the language and
standard library. Using traits really helped clean up the code I was
writing.</p>

<h2 id="hammers-and-nails">Hammers and nails</h2>
<p><a href="https://www.yourworldoftext.com/posts/hammer.html">If all you have is a hammer, everything looks like a nail</a>,
or, you can’t really use traits unless you know about them. For example,
the <a href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html">FromStr</a>
trait is used for <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse">str::parse</a>.</p>

<div><div><pre><code><span>use</span> <span>std</span><span>::</span><span>str</span><span>::</span><span>FromStr</span><span>;</span>

<span>#[derive(Debug,</span> <span>PartialEq)]</span>
<span>enum</span> <span>Foo</span> <span>{</span>
    <span>Bar</span><span>,</span>
    <span>Baz</span><span>,</span>
<span>}</span>

<span>impl</span> <span>FromStr</span> <span>for</span> <span>Foo</span> <span>{</span>
    <span>type</span> <span>Err</span> <span>=</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>;</span>
    <span>fn</span> <span>from_str</span><span>(</span><span>s</span><span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>,</span> <span>Self</span><span>::</span><span>Err</span><span>&gt;</span> <span>{</span>
        <span>match</span> <span>s</span> <span>{</span>
            <span>&#34;bar&#34;</span> <span>=&gt;</span> <span>Ok</span><span>(</span><span>Foo</span><span>::</span><span>Bar</span><span>),</span>
            <span>&#34;baz&#34;</span> <span>=&gt;</span> <span>Ok</span><span>(</span><span>Foo</span><span>::</span><span>Baz</span><span>),</span>
            <span>_</span> <span>=&gt;</span> <span>Err</span><span>(</span><span>&#34;not bar or baz&#34;</span><span>),</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>f</span><span>:</span> <span>Foo</span> <span>=</span> <span>&#34;bar&#34;</span><span>.parse</span><span>()</span><span>.unwrap</span><span>();</span>
    <span>assert_eq!</span><span>(</span><span>f</span><span>,</span> <span>Foo</span><span>::</span><span>Bar</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>As such, here’s a laundry list of traits that I’m currently finding
useful:</p>

<ul>
  <li><a href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html">FromStr</a></li>
  <li><a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> (and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a>, which we get for free if implementing <code>From</code>)</li>
  <li><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom</a> (and <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html">TryInto</a>, which we similarly get for free from <code>TryFrom</code>)</li>
  <li>Everything in <a href="https://doc.rust-lang.org/std/ops/index.html#traits">ops</a> like <code>Index</code> and <code>IndexMut</code></li>
  <li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a></li>
  <li><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef</a></li>
  <li><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a></li>
  <li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a></li>
  <li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a></li>
  <li><a href="https://doc.rust-lang.org/std/error/trait.Error.html">Error</a></li>
  <li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a></li>
  <li><a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a> and <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html">FromIterator</a></li>
</ul>

<p>Some of these are derivable, which makes it very easy to get functionality
for free.</p>

<h2 id="traits-and-generics">Traits and generics</h2>
<p>Traits are tightly integrated with generic code via <a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">trait
bounds</a>.
In the example above, <code>str::parse</code> is generic over any type that
implements the <code>FromStr</code> trait. Similarly, types that implement
<code>IntoIterator</code> work with Rust’s <code>for loop</code> syntax.</p>

<p>Something that clicked recently for me is using trait bounds to make
my library API friendlier to more types. For example, I might define a
function with an <code>AsRef&lt;str&gt;</code> trait boundary to allow any type that can
return a <code>&amp;str</code> to be used.</p>

<div><div><pre><code><span>fn</span> <span>print_it</span><span>&lt;</span><span>S</span><span>:</span> <span>AsRef</span><span>&lt;</span><span>str</span><span>&gt;&gt;</span><span>(</span><span>s</span><span>:</span> <span>S</span><span>)</span> <span>{</span>
    <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>s</span><span>.as_ref</span><span>());</span>
<span>}</span>

<span>// usage can be..</span>
<span>print_it</span><span>(</span><span>&#34;foo&#34;</span><span>);</span>
<span>print_it</span><span>(</span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;foo&#34;</span><span>));</span>
</code></pre></div></div>

<p>Perhaps the <code>Display</code> trait would have been more suitable here, but this
simple example demonstrates the flexibility in function definitions. This
aspect of trait boundaries is very similar to Go interfaces.</p>

<p>I think a very useful trait bound is <code>Into&lt;T&gt;</code>, which allows a function
to take any type so long as it can be converted into <code>T</code>.</p>

<div><div><pre><code><span>struct</span> <span>Foo</span> <span>{</span>
    <span>data</span><span>:</span> <span>String</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Foo</span> <span>{</span>
    <span>fn</span> <span>new</span><span>&lt;</span><span>S</span><span>:</span> <span>Into</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span><span>(</span><span>s</span><span>:</span> <span>S</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span> <span>data</span><span>:</span> <span>s</span><span>.into</span><span>()</span> <span>}</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>x</span> <span>=</span> <span>Foo</span><span>::</span><span>new</span><span>(</span><span>&#34;bar&#34;</span><span>);</span>
    <span>let</span> <span>y</span> <span>=</span> <span>Foo</span><span>::</span><span>new</span><span>(</span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;baz&#34;</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>Learning more about the trait ecosystem has helped me write cleaner and
more idiomatic Rust code. I have found it’s more than just a tool of
the language, but its deep integration in the standard library helps
tremendously with code composability and integration.</p>

  </div></div>
  </body>
</html>
