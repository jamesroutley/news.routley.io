<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.persistent.info/2022/03/blog-post.html">Original</a>
    <h1>Infinite Mac: An Instant-Booting Quadra in the Browser</h1>
    
    <div id="readability-page-1" class="page"><article>
<h3>tl;dr</h3>

<p>I’ve extended James Friend’s in-browser Basilisk II port to create a full-featured classic 68K Mac in your browser. You can see it in action at <a href="https://system7.app/">system7.app</a> or <a href="https://macos8.app">macos8.app</a>. For a taste, see also this screencast:</p>

<p>
<iframe width="800" height="558" src="https://www.youtube.com/embed/tljxs9zuaA8" title="YouTube video player" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; picture-in-picture" allowfullscreen=""></iframe>
</p>

<h3>Backstory</h3>

<p>It’s a golden age of emulation. Between increasing CPU power, WebAssembly, and retrocomputing being so popular <a href="https://www.nytimes.com/2021/01/08/style/retrocomputing.html">The New York Times is covering it</a>, it’s never been easier to relive your 80s/90s/2000s nostalgia. Projects like <a href="https://github.com/copy/v86">v86</a> make it easy to run your chosen old operating system in the browser. My heritage being of the <a href="https://blog.persistent.info/2021/04/git-resource-fork-hooks.html">classic</a> <a href="https://blog.persistent.info/2021/06/archiving-mscape-software.html">Mac</a> line, I was curious what the easiest to use emulation option was in the modern era. I had earlier <a href="https://blog.persistent.info/2011/10/adventures-in-retro-computing.html">experimented</a> with Basilisk II, which worked well enough, but it was rather annoying to set up, as far as gathering a ROM, a boot image, messing with configuration files, etc. As far as I could tell, that was <a href="https://www.emaculation.com/doku.php/mac_emulation">still the state of the art</a>, at least if you were targeting late era 68K Mac emulation.</p>

<p>Some research into browser-based alternatives uncovered a few options:</p>

<ul>
<li><a href="https://jamesfriend.com.au/">James Friend</a>’s in-browser ports of the <a href="https://jamesfriend.com.au/projects/basiliskii/BasiliskII-worker.html">Basilisk II</a> and <a href="https://jamesfriend.com.au/pce-js/">PCE.js</a> emulators</li>
<li>The <a href="https://blog.archive.org/2017/04/16/early-macintosh-emulation-comes-to-the-archive/">Internet Archive’s Mac Emulation</a>, which is partly based on James’s PCE.js work</li>
<li><a href="https://blog.archive.org/2017/04/16/early-macintosh-emulation-comes-to-the-archive/">OldWeb.Today</a>, which extends James’s Basilisk II work to support a working networking stack</li>
<li><a href="http://retroweb.maclab.org/">RetroWeb Vintage Computer Musem</a>, also based on James’s PCE.js work</li>
<li>The Macintosh Repository is <a href="https://www.emaculation.com/forum/viewtopic.php?t=10763">experimenting with</a> in-browser emulation via either Basilisk II or vMac</li>
</ul>

<p>However, none of these setups replicated the true feel of using a computer in the 90s. They’re great for quickly launching a single program and playing around with it, but they don’t have any persistence, way of getting data in or out of it, or running multiple programs at once. <a href="https://github.com/felixrieseberg/macintosh.js">macintosh.js</a> comes closest to that — it packages James’s Basilisk II port with a large (~600MB) disk image and provides a way of sharing files with the host. However, it’s an Electron app, and it feels wrong to download a ~250MB binary and <a href="https://persistent.info/images/macintosh.js.png">dedicate 1 CPU core</a> to running something that was meant to be in a browser.</p>

<p>I wondered what it would take to extend the Basilisk II support to have a macintosh.js-like experience in the browser, and ideally go beyond it.</p>

<h3>Streaming Storage and Startup Time</h3>The first thing that I looked into was reducing the time spent downloading the disk image that the emulator uses. There was some low-hanging fruit, like actually compressing it (ideally with Brotli), and dropping some <a href="https://github.com/mihaip/macemu/commit/4fd49f0cdf2f7ac914f0ec8273fc6ca331f6cca9">unused data</a> from it. However, it seemed like this goal was fundamentally incompatible with the other goal of putting as much software as possible onto it — the more software there was, the bigger the required disk image.

<p>At this point I switched my approach to downloading pieces of the disk image on demand, instead of all upfront. After some <a href="https://github.com/mihaip/infinite-mac/commit/7ea4f6e6bf762ec59f53ff76b239d5adb0ae3cbd">false</a> <a href="https://github.com/mihaip/infinite-mac/commit/a304dab9bb330d84d56c7b9f595fa5b962dceff2">starts</a>, I settled on <a href="https://github.com/mihaip/infinite-mac/commit/2992609ac3e86f595796759fb8aec6c1c354b298">an approach</a> where the disk image is broken up into fixed-size content-addressed 256K chunks. Filesystem requests from Emscripten are intercepted, and when they involve a chunk that has not been loaded yet, they are sent off to a service worker who will load the chunk over the network. Manually chunking (as opposed to <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests">HTTP range requests</a>) allows each chunk to be Brotli-compressed (ranges technically support compression too, but it’s <a href="https://stackoverflow.com/a/53135659/343108">lacking</a> in the real world). Using content addressing makes the large number of identical chunks from the empty portion of the disk map to the same URL. There is also basic <a href="https://github.com/mihaip/infinite-mac/commit/d537786c9916182b7bd578448a061674ae9ba84c">prefetching support</a>, so that sequential reads are less likely to be blocked on the network.</p>

<p>Along with some <a href="https://github.com/mihaip/infinite-mac/commit/01a78bf70b6a14d969036f0a72bb67289a88bf80">old fashioned web optimizations</a>, this makes the emulator show the Mac’s boot screen in a second, and be fully booted in 3 seconds, even with a cold HTTP cache.</p>

<h3>Building Disk Images, or Docker 1995-style</h3>

<p>I wanted to have a sustainable and repeatable way of building a disk image with lots of Mac software installed. While I could just boot the native version of Basilisk II and manually copy things over, if I made any mistakes, or wanted to repeat the process with a different base OS, I would have to repeat everything, which would be tedious and error-prone. What I effectively wanted was a <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> I could use to build a disk image out of a base OS and a set of programs. Though I didn’t go quite that far, I did end up something that is quite flexible:</p>

<ol>
<li>A bare OS image is <a href="https://github.com/mihaip/infinite-mac/commit/82a8a099116970336791163b14f1983b630ab9d1">parsed</a> using <a href="https://github.com/mihaip/machfs">machfs</a> (which can read and write the HFS disk format)</li>
<li>Software that’s been preserved by the Internet Archive <a href="https://archive.org/details/softwarelibrary_mac">as disk images</a> can be copied into it, by <a href="https://github.com/mihaip/infinite-mac/commit/a06a6df0d63139428d9e5959c47d9dca9cb6d159">reading those images</a> with <code>machfs</code> and merging them in</li>
<li>Software that’s available as <a href="https://en.wikipedia.org/wiki/StuffIt">Stuffit archives</a> or similar is decompressed with the <code>unar</code> and <code>lsar</code> utilities from <a href="https://github.com/mihaip/XADMaster">XADMaster</a> and copied into the image (the <a href="https://macintoshgarden.org/">Macintosh Garden</a> is a good source for these archives).</li>
<li>Software that’s only available as installers is installed by hand, and then the results of that are <a href="https://github.com/mihaip/infinite-mac/blob/main/src/BasiliskII/emulator-ui-extractor.ts">extracted</a> into a zip file that can be also copied into the image.</li>
</ol>

<p>I wanted to have a full-fidelity approach to the disk image creation, so I had to extend both <a href="https://github.com/mihaip/machfs/commit/2dde60a4032019fc86a00a51ce69db9702fcd5b4">machfs</a> and <a href="https://github.com/mihaip/XADMaster/commit/cf6767ff49a0707d2618dc748ff9c0baf33172e2">XADMaster</a> to preserve and copy Finder metadata like icon positions and timestamps. There was definitely some cognitive dissonance in dealing with late 80s structures in <a href="https://github.com/mihaip/infinite-mac/blob/997ed60a76e148eceab77aff0f8d67f69503a1a6/scripts/build-disk-image.py">Python 3</a> and <a href="https://github.com/mihaip/infinite-mac/blob/a304dab9bb330d84d56c7b9f595fa5b962dceff2/src/BasiliskII/emulator-finder.ts">TypeScript</a>.</p>

<h3>Interacting With The Outside World</h3>

<p>Basilisk II supports mounting a directory from the “host” into the Mac (via the ExtFS module). In this case the host is the pseudo-POSIX file system that Emscripten creates, which has <a href="https://emscripten.org/docs/api_reference/Filesystem-API.html">an API</a>. It thus seemed possible to handle <a href="https://github.com/mihaip/infinite-mac/commit/ec058cea53a57b159cdd87c2631ed8d2bd72bca5">files being dragged</a> into the emulator by reading them on the browser side and sending the contents over to the worker where the emulator runs, and creating them in a “Downloads” folder. That worked out well, especially once I switched a <a href="https://github.com/mihaip/infinite-mac/commit/3cbaac0d49cca9af067cbd08dda07de44f14f3da">custom lazy file implementation</a> and <a href="https://github.com/mihaip/macemu/commit/80e1038734b1f78980b0315c2ca1483f3293561a">fixed encoding issues</a>.</p>

<p>To get files out, the reverse process can be used, where files in a special “Uploads” folder are <a href="https://github.com/mihaip/infinite-mac/commit/45a2c5bb275499d30e92354745fb74fb36155a66">watched</a>, and when new ones appear, the contents are sent to the browser (as a single zip file in the case of directories).</p>

<h3>Persistence</h3>

<p>While Emscripten has an <a href="https://emscripten.org/docs/api_reference/Filesystem-API.html#filesystem-api-idbfs">IDBFS mode</a> where changes to the filesystem are persisted via IndexedDB, it’s not a good fit for the emulator, since it relies on there being an event loop, which is not the case in the emulator worker. Instead I used an approach <a href="https://github.com/mihaip/infinite-mac/commit/0899205dba8fc3104f6a4f65a1714816720fe67b">similar to uploading</a> to send the contents of a third ExtFS “Saved” directory, which can then be persisted using IndexedDB on the browser side.</p>

<h3>Performance</h3>

<p>The emulator using 100% of the CPU seems like a fundamental limitation — it’s simulating another CPU, and there’s always another instruction for it to run. However, Basilisk II is working at a slightly higher-level, and it <a href="https://github.com/mihaip/macemu/commit/adc4078914464794af33efa47c25455791aefb69">knows</a> when the Mac is idle (and waiting for the user input), and allows the host to intercept this and yield execution. I <a href="https://github.com/mihaip/macemu/commit/adc4078914464794af33efa47c25455791aefb69">made that work</a> in the browser-based version by using <code>Atomics</code> to wait until either there was user input or a screen refresh was required, which dropped CPU utilization significantly. A <a href="https://blog.persistent.info/2021/08/worker-loop.html">previous blog post</a> has more details, including the hoops required to get it working in Safari (which are thankfully not required with <a href="https://developer.apple.com/documentation/safari-release-notes/safari-15_2-release-notes#Security">Safari 15.2</a>).</p>

<p>The bulk of the remaining time was spent updating the screen, so I <a href="https://github.com/mihaip/macemu/commit/3738e1e2e2ed771a7683dd4c4491392736020330">made</a> <a href="https://github.com/mihaip/macemu/commit/973752a94ab4b1bc2ff75d9e66577330f677775c">some</a> <a href="https://github.com/mihaip/macemu/commit/2dbd859a74da4e347503ebdc0d8067a47e549fd4">optimizations</a> there to do less per-pixel manipulation, avoid some copies altogether, and not send the screen contents when they haven’t changed since the last frame.</p>

<p>The outcome of all this is that the emulator idles at ~13% of the CPU, which makes it much less disruptive to be left in the background.</p>

<h3>Odds and Ends</h3>

<p>There were a bunch more polish changes to improve the experience: making it responsive to <a href="https://github.com/mihaip/infinite-mac/commit/9081875a5f9d10c94e8fbada8771e6b1a5cb58a0">bigger</a> and <a href="https://github.com/mihaip/infinite-mac/commit/5e0dceb2ddd2d049afd412bd776ea445ef91c4a9">smaller</a> screens, <a href="https://github.com/mihaip/infinite-mac/commit/df9ecaef4d8db2a0f14199ec6bfc235d05ef98b5">handling touch events</a> so that it’s usable on an iPad (though double-taps are still tricky), <a href="https://github.com/mihaip/macemu/commit/5e822370c3b152822a56d18df6087011f8713d20">fixing the scaling</a> to preserve crispness, handling <a href="https://github.com/mihaip/macemu/commit/c5f7a41845274e43cfc59ce8556aeb290e682daf">other color modes</a>, <a href="https://github.com/mihaip/macemu/commit/25d10504e9e31ea41e1be2b4a9393bfc69ded100">better keyboard mapping</a>, and much more.</p>

<p>There is a ton <a href="https://github.com/mihaip/infinite-mac/issues">more work to be done</a>, but I figured <a href="https://www.marchintosh.com/">MARCHintosh</a> was as good a time at any to take a break and share this with the world. Enjoy!<br/>
</p></article></div>
  </body>
</html>
