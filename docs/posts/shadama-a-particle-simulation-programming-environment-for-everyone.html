<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tinlizzie.org/~ohshima/shadama2/live2017/">Original</a>
    <h1>Shadama: A particle simulation programming environment for everyone</h1>
    
    <div id="readability-page-1" class="page"><article>
      
      <p>Yoshiki Ohshima, Dan Amelang and Bert Freudenberg</p>

      <section id="abstract">
        <p>
We present a prototype of a programming system called Shadama.
Shadama is designed for writing programs that create, control and visualize large numbers of objects.
The basic execution model follows the tradition of StarLogo and its &#34;turtles and patches&#34; abstraction.
<label for="sn-starlogo">
</label>

<span>
<a href="#starlogo">
<i>Turtles, Termites, and Traffic Jams: Explorations in Massively Parallel Microworlds</i>
</a>
</span>
  This abstraction has been proven to be effective and easy to use.
The primary goal of the language is to facilitate the writing of scientific simulations by students
at the high school level.
        </p>

        <p>
The Shadama environment supports <i>liveness</i>.
Once changes to the program are saved, the effect on the running simulation is immediate;
there is no need to restart the simulation.
        </p>
        <p>
Shadama programs are run on the GPU by means of code translation to the OpenGL Shading Language.
<label for="sn-glsl">
</label>

<span>
<a href="#glsl">The OpenGL Shading Language</a>
</span>  
Program data resides entirely on the GPU, which enables high performance.
        </p>

        <p>
A prototype of Shadama can be found <a href="http://tinlizzie.org/~ohshima/shadama2">here</a>.
Be aware that Shadama requires WebGL 2 and is affected by the floating point precision provided
by your graphics card. Thus, it only works on certain computer systems.
From our experience, it seems to work better on computers with an AMD Radeon graphics
card and on Chrome or Firefox browsers.
</p>
      </section>
      <section>
        <h2>Introduction</h2>
        <p>
The computing power available to us today is astounding.  Achieving
one teraflop of performance was a milestone for a building-sized supercomputer in
the late &#39;90s, but now we expect smart phones to reach this same milestone soon.
Computing performance will only continue to increase in the future.
        </p>
        <p>
But what are people using this power for?  Not to be critical, but
people are generally more interested in watching cat videos and
playing games than trying to invent self-piloting personal airplanes
or discover the graviton.

All joking aside, one of the big problems we face today is our
struggle to advance science literacy, even within a
technologically-advanced society.  We need the next
generation to embrace science more, not less.
        </p>
        <p>
We think now is a good time to redouble our efforts to provide
environments where students and even professional
programmers can more easily tap into the computing power that is available.
To this end, we have been working on a prototype of a
programming language intended for high school students to explore
scientific concepts.
        </p>
        <p>
  Science is about making the invisible visible.  One notable example
of an invisible yet important concept is molecules in a gas.  We would
like students to learn about this, not by rote memorization, but
through actual experiments and model-building.  With the help of
computers, students can make a dynamic model and understand it more
deeply.  This kind of environment will help students construct
knowledge by doing, in line with the constructivism philosophy of
education.
        </p>
</section>

<section>
        <h2 id="a-science-experiment">A Science Experiment</h2>
        <p>
Before introducing the Shadama programming environment, we first
give an example of a physics experiment that could also be modeled
and simulated on a computer.
</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/07D0nB3mgLA" frameborder="0" allowfullscreen=""></iframe>
<p>
This movie demonstrates a vacuum cannon.  The cannon is a six foot PVC
pipe connected to a vacuum pump.  We put a ping pong ball inside the pipe,
cover the ends with sturdy but breakable material (such as plastic plates),
and pump the air out.
        </p>
        <p>
The pump reduces the pressure inside the tube to about 20% of full atmospheric pressure.
        </p>
        <p>
When the end near the ping pong ball is broken open by a box cutter, the
air molecules that rush into the pipe move into the
low pressure space and the ping pong ball is pushed out the other end.
Our crude setup can accelerate the ball to a speed of over 200 meters per second
(about 60% of the speed of sound).  Others have built similar setups
that can achieve supersonic speed.
        </p>
        <p>
An interesting point to understand is that it is just movement of
molecules that is causing the ball to shoot out. It is not that the
vacuum is sucking molecules into the pipe.
</p>
<p>
The invisible molecules that cause the ball to shoot out can
be made “visible” in a sense not only through this physical experiment,
but also through a computer simulation that reproduces the same phenomenon.
Creating such simulations is the purpose of our programming environment.
          </p>
</section>

<section>
        <h2 id="language-goals">Language Goals</h2>

<p>
We had the following goals when designing Shadama:
</p><ul>
<li> Easy to learn</li>
<li> Openness</li>
<li> Support for large numbers of particles</li>
<li> Liveness</li>
</ul>


<p>
To make learning Shadama easy, we based our language on StarLogo,
whose turtles and patches approach has proved intuitive to young learners.
In addition, we expect students familiar with Scratch to
learn Shadama easily because of similarites in how object behavior
is programmed and how objects can sense values near them spatially.
</p>

<p>
To encourage openness, we designed Shadama to be capable of implementing
complex behavior in the language itself, with as few primitives as possible.
We think that a learning environment should be open
in the sense that a student should be able to see, change and understand
how the various parts of the system work.
Although many sophisticated scientific software packages and simulation environments
exist, they are presented as immutable black boxes,
which limits understanding and stifles curiousity.
When additional software support is required, it should be provided in the
end-user&#39;s programming language, and it should be capable of modification
within the end-user&#39;s environment.
</p>

<p>
To support large numbers of particles, we designed the language
to execute on graphics hardware. Graphics processors today
are capable of computing on massive amounts of data.
Unfortunately, this requires a trade-off between ease of use and
high performance because there are fundamental limitations in
the execution model of today&#39;s graphics hardware.
Although Shadama has some features to mitigate these limitations,
certain behaviors cannot be implemented.
</p>

<p>
To support liveness, we designed the Shadama environment to show
the effects of code changes immediately. Of course,
a running simulation should not be updated for each and every key stroke.
Instead, the user submits a batch of code changes for the environment
to apply.
</p>

</section>

<section>
        <h2 id="shadama-in-Action">Shadama in Action</h2>
        <p>
The following movie introduces our prototype programming environment through several examples.
For details on the language, see the appendix.
The script for the narration of the movie is included below.
You can pause the movie at any time to scroll through and read the script.
        </p>
  
  
  <hr/>
</section>
<section>
        <h2 id="implementation">Implementation</h2>
</section>
<p>
Shadama is built on web technologies, including WebGL 2.0 and OpenGL
Shading Language version 3.0.
Our code translator is written in Ohm
<label for="sn-ohm">
</label>

<span>
<a href="#ohm">Ohm: A library and language for building parsers, interpreters, compilers, etc.</a>
</span>
and generates vertex shader, fragment shader and JavaScript code from the Shadama program.
All the values for a given breed and property are stored in a single OpenGL texture.
These textures are created with the OpenGL type &#34;R32F&#34;, to match
their use as an array of floating-point scalar values.
The values for a given patch and property are similarly represented.
</p>
<p>
Shadama static functions are translated to Javascript code that
runs OpenGL shaders derived from the Shadama methods.
For each method, a vertex shader is generated to fetch property values
from textures and perform the computation required for that method.
A generated fragment shader stores the property values back
into textures, using the multiple render targets feature of OpenGL.
</p>

<section>
        
        <p>
Previously, one of the authors implemented a particle system called Kedama as an extension of Etoys.
<label for="sn-kedama">
</label>

<span>
<a href="#kedama">
Kedama: A GUI-Based Interactive Massively Parallel Particle Programming System.</a><br/>

</span>      Shadama can be considered an attempt to give the same idea new life.
Kedama&#39;s target audience was middle school children, while Shadama&#39;s target audience is high school students.
        </p>
        <p>
The biggest inspiration for Shadama (and Kedama) was Resnick&#39;s StarLogo.
As such, it provided the basis for the basic organization of objects in Shadama.
However, StarLogo has certain features that Shadama does not, as mentioned in the introduction.
        </p>
        <p>
Based on Extempore, Swift et al. created a live programming environment for physics.
<label for="sn-extempore-pic">
</label>

<span>
<a href="#extempore">Live Programming in Scientific Simulation</a><br/>
</span>  
This environment brings dynamic code swapping and interactive data
inspection to a sophisticated and optimized particle-in-cell
simulation engine. The spirit of this work is much in line with ours,
although their environment uses a third-party engine that cannot be modified from this same environment.
This is a reflection of their focus on empowering scientific researchers.
Such users are already familiar with the concepts behind the simulation and
value the tight interaction offered by this approach.
While it is possible to rewrite parts of the third-party engine in Extempore,
this is beyond the ability of most users, especially our target audience.
</p>
<p>
Nicky Case&#39;s simulation construction environment represents an interesting point in the design space.
<label for="sn-emoji">
</label>

<span>
<a href="#emoji">Simulating the World (in Emoji)</a>
</span>   
The system features a user-friendly design for creating many types of open-ended models.
However, it is only designed to handle a few hundred particles and cells.
</p>
<p>
Programming the GPU from a high-level language is a hot topic.
<label for="sn-ikra">
</label>

<span>
<a href="#ikra">Object Support in an Array-based GPGPU Extension for Ruby</a>
</span>   Researchers in this area aim for better performance through
increasingly sophisticated compilation techniques and the use of the CUDA API to more directly access the GPU.
Ease of use is given little consideration.
The authors think that Shadama can occupy a unique position
by striking a better balance between performance and ease of use.
        </p>
        <p>
Some languages for programming massively parallel particle simulations
are based on visual programming blocks.
StarLogo Nova is a notable example.
<label for="sn-slnova">
</label>

<span>
<a href="#slnova">
StarLogo Nova: A Programming Environment For Students and Teachers to
Create 3D Games and Simulations for Understanding Complex Systems
</a>
</span>
Shadama is currently text-based because we feel that scientific simulations
can be naturally expressed with concise text.
However, we have not ruled out other possiblities for syntax,
including a visual representation of the program.
        </p>

        <p>
Although many simulation environments such as Liquid Fun
<label for="sn-liquidfun">
</label>

<span>
<a href="#liquidfun">LiquidFun: A 2D Rigid-body and Fluid Simulation C++ Library for Games Based Upon Box2D</a>
</span>
are available today, they do not provide an end-user language.
</p>

</section>

<section>
        <h2 id="conclusions-and-future-work">Conclusions and Future Work</h2>
        <p>
We have presented an early prototype of a language in
which users can make enlightening simulations and intricate visualizations.
The liveliness of the environment encourages an
exploratory style of programming that enables trying out different ideas quickly.
We have also discovered that such an interactive and graphical environment
can be motivating even as bugs appear because of the spectacular
unintentional visual effects that are produced.
        </p>
        <p>
We are considering various improvements to the system.  One major
addition would be to fully support simulations in 3D, not just 2D.
While computation in Shadama only uses scalar values and is agnostic to dimensionality,
the primitives and concepts the system currently provides only work well for 2D applications.
We will need new ideas to manage 3D spatial data.
        </p>
        <p>
We also plan to support more mathematical concepts, such as vectors and matrices.
While first-time users may not initially have use for such abstractions,
we would like them to eventually learn and use these powerful concepts.
Ideally, the environment would gradually introduce the user to new, more difficult approaches.
        </p>
        <p>
We would like to conclude this paper by stressing the importance of
education. Education raises our awareness and enables us to see our world from new perspectives.
In this way, we are empowered with new approaches to solve problems.
For the next generation to solve the challenges of the future, their science literacy
is imperative. Our aim with Shadama is to leverage the power and ubiquity of
computing devices to improve science literacy for high school students by providing an engaging, open
environment in which to explore scientific concepts.
        </p>
</section>

      <section>
        <h2>References</h2>
        <ol type="1">
          <li id="starlogo">
            Mitchel Resnick. <i>Turtles, Termites, and Traffic Jams: Explorations
            in Massively Parallel Microworlds</i>. MIT Press, Cambridge, MA, USA, 1994.
          </li>
          <li id="glsl">
            The OpenGL Shading Language
            (<a href="https://www.khronos.org/registry/OpenGL/index_gl.php">Khronos OpenGL Registry</a>)
          </li>
          <li id="ohm">
            Ohm: A library and language for building parsers, interpreters, compilers, etc.
            (<a href="https://ohmlang.github.io/">project page</a>)
          </li>
          <li id="kedama">
            Yoshiki Ohshima. Kedama: A GUI-based Interactive Massively Parallel Particle Programming System.
            In <i>2005 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC’05)</i>, pages 91–98, Sept 2005.
          </li>
          <li id="extempore">
            Ben Swift, Andrew Sorensen, Henry Gardner, Peter Davis, and Viktor K Decyk.
            Live Programming in Scientific Simulation. <i>Supercomputing Frontiers and Innovations</i>, 2(4):4–15, March 2015.
            (<a href="http://dx.doi.org/10.14529/jsfi150401">DOI</a>)
          </li>
          <li id="liquidfun">
            LiquidFun: A 2D Rigid-body and Fluid Simulation C++ Library for Games Based Upon Box2D
            (<a href="http://google.github.io/liquidfun/">project page</a>)
          </li>
          <li id="emoji">
            Nicky Case. Simulating the World (in Emoji)
            (<a href="http://ncase.me/simulating">project page</a>)
          </li>
          <li id="ikra">
            Matthias Springer and Hidehiko Masuhara. Object Support in an Array-based GPGPU Extension for Ruby.
            In <i>Proceedings of the 3rd ACM SIGPLAN International Workshop on
            Libraries, Languages, and Compilers for Array Programming</i>,
            ARRAY 2016, pages 25–31, New York, NY, USA, 2016.
          </li>
          <li id="slnova">
            StarLogo Nova: A Programming Environment For Students and Teachers to
            Create 3D Games and Simulations for Understanding Complex Systems
            (<a href="http://education.mit.edu/portfolio_page/starlogonova/">project page</a>)
          </li>
        </ol>
      </section>
<section>
        <h2 id="language">Appendix: A Primer for the Shadama Language</h2>

<p>
The Shadama language uses a turtles and patches abstraction, drawn from the tradition of StarLogo.
</p>

        <h3 id="breeds">Breeds</h3>
<p>
Turtles are organized into
&#34;breeds&#34;.  Each breed has its own set of properties.
A breed is declared in a program with the &#34;breed&#34; statement.  For example:
</p>
<pre>breed MyBreed (x, y)
</pre>
<p>
The above creates a breed of turtle called <code>MyBreed</code>, and declares that each
turtle in the breed has individual properties <code>x</code> and <code>y</code>.
</p>
<p>
Currently, properties in Shadama can only be scalar floating-point numbers.
</p>
<p>
Methods provide turtle behavior. The <code>def</code> statement is used to define
methods, as follows:
</p>
<pre>def move() {
  this.x = this.x + 1;
  this.y = this.y + 1;
}
</pre>
<p>
As expected, when this method is invoked on a turtle, the
turtle&#39;s x and y properties are incremented by one.
</p>
<p>
Methods can only be invoked from static functions. Methods calls are made
by first specifying a breed, then the method name.
The method is applied to all turtles in the breed concurrently.
For example:
</p>
<pre>static step() {
  MyBreed.move();
}
</pre>
<p>
The <code>step</code> function above calls the <code>move</code> method on all turtles of the <code>MyBreed</code> breed.
</p>

<p>
Shadama provides many built-in features made available through primitive methods:
</p>
<ul>

<li> <pre>aBreed.setCount(count);</pre>
  <span>
  The <code>setCount</code> primitive sets the number of turtles in the breed.
For example:
</span>
<pre>static setup() {
  MyBreed.setCount(10000);
}
</pre>
<span>
Invoking this static function will set the number of <code>MyBreed</code> turtles to 10,000.
In the current implementation, the number of turtles in a breed is limited to
1024 × 1024, or about 1 million.
</span>
</li>

<li> <pre>aBreed.fillRandom(name, min, max);</pre>
<span>
  The <code>fillRandom</code> primitive sets the property specified by <code>name</code>
  to be a random number between <code>min</code>
  (inclusive) and <code>max</code> (exclusive) for each turtle in the breed.
  For example:
</span>
<pre>static setup() {
  MyBreed.setCount(10000);
  MyBreed.fillRandom(&#34;x&#34;, 0, 100);
}
</pre>
<span>
  The above will set each of the 10,000 turtles <code>x</code> property to be a
  random floating-point number between 0 and 100.
</span>
</li>

<li> <pre>aBreed.fillRandomDir(dxName, dyName);</pre>
<span>
  The <code>fillRandomDir</code> primitive generates random 2D unit vectors.
  This is done for each turtle, and the x and y components of the result are stored
  in the <code>dxName</code> and <code>dyName</code> properties of the turtles.
  For example:
</span>
<pre>static setup() {
  MyBreed.setCount(10000);
  MyBreed.fillRandomDir(&#34;dx&#34;, &#34;dy&#34;);
}
</pre>
<span>
The above sets the <code>dx</code> and <code>dy</code> properties of the turtles with the x and y components of the randomly generated unit vectors.
</span>
</li>

<li> <pre>aBreed.fillSpace(xName, yName, xDim, yDim);</pre>
        <span>
The fillSpace primitive first sets the number of turtles in the breed
to be <code>xDim</code> × <code>yDim</code>.  Then, it places the turtles on integral 2D grid points
within the (0..<code>xDim</code>, 0..<code>yDim</code>) area, storing into the <code>xName</code> and <code>yName</code> turtle properties.
For example:
</span>
<pre>static setup() {
  MyBreed.fillSpace(&#34;x&#34;, &#34;y&#34;, 100, 100);
}
</pre>
<span>
The above creates 10,000 turtles of the MyBreed breed, setting the turtle&#39;s <code>x</code> and <code>y</code> properties
to be the integral grid points spanning (0, 0) to (99, 99), inclusive.
</span>
</li>

<li> <pre>aBreed.fillImage(xName, yName, rName, gName, bName, aName, anImageData);</pre>
        <span>
  The fillImage primitive converts a 2D image into a breed of turtles.
  The <code>anImageData</code> argument is a Javascript ImageData object containing the data used
  to populate the breed. The turtle count is set to be <code>anImageData.width</code> × <code>anImageData.height</code>.
  Similar to <code>fillSpace</code>, the turtles are placed on the 2D grid points within the image extent.
  The turtle properties given by <code>rName</code>, <code>gName</code>, <code>bName</code>, and <code>aName</code> are populated with the RGBA
  color component values of the image. Note that while the color components in <code>anImageData</code> range
  from 0 and 255 (integral values), those values in Shadama will be normalized to range from 0.0 and 1.0,
  inclusive (floating-point).
  For example:
<pre>breed MyBreed (x, y, r, g, b, a)
static setup() {
  MyBreed.fillImage(&#34;x&#34;, &#34;y&#34;, &#34;r&#34;, &#34;g&#34;, &#34;b&#34;, &#34;a&#34;, anImage);
}
</pre>
</span>
<span>
Static function variables, such as <code>anImage</code>, are described below.
</span>
</li></ul>

<h3 id="patches">Patches</h3>

<p>
A patch is a 2D set of cells that store values.
Patches are fixed size, 512 × 512 by default.
The following declares a patch:
</p><pre>patch Field (nx, ny)
</pre>

<p>
Each cell in this patch stores two values, <code>nx</code> and <code>ny</code>.
</p>

<p>
A patch can be manipulated by passing it as an argument to a method on a breed.
As the method is executed for each turtle, turtles can access the patch cell
nearest them. No other patch cells are available to them.
For example:
</p><pre>breed MyBreed (x, y, r, g, b, a)
patch Field (r, g, b, a)

def store(field) {
  field.r = this.r;
}

static setup() {
  MyBreed.fillImage(&#34;x&#34;, &#34;y&#34;, &#34;r&#34;, &#34;g&#34;, &#34;b&#34;, &#34;a&#34;, anImage);
  MyBreed.store(Field);
}
</pre>

<p>
The above declares a patch called Field which is used as an argument to <code>store</code>.
When <code>store</code> is executed for each turtle in <code>MyBreed</code>, the turtle&#39;s <code>r</code> property
is stored in the <code>r</code> property of the nearest cell in Field.
</p>

<p>
A turtle can read values from patch cells as well.  For example:
</p><pre>def load(field) {
   this.r = field.r;
}
</pre>

<p>
When the above method is executed, each turtle reads the <code>r</code> property of the nearest patch cell
and stores the value into its own <code>r</code> property.
</p>
<p>
Methods can receive multiple patches as arguments.
For example:
</p><pre>patch Field1 (nx, ny, r, g, b, a)
patch Field2 (nx, ny, r, g, b, a)
def transfer(f1, f2) {
  f2.r = f1.r;
  f2.a = f1.a;
}
</pre>

<p>
The following code is also valid, and correctly swaps values between patches.
</p><pre>def swap(f1, f2) {
  f2.r = f1.r;
  f1.r = f2.r
}
</pre>


<h3 id="local-variables">Local Variables</h3>

<p>
The <code>var</code> statement declares a local variable within a method.
The scope of a local variables is the whole method,
regardless of where in the method it is declared.
In the same method, there can be no more than one declaration for a given variable name.
This is in contrast to variable declarations in JavaScript.
For example:
</p><pre>def average() {
  var avg = (this.x + this.y) / 2.0;
  this.x = avg;
  this.y = avg;
}
</pre>
<p>
The above code properly defines and uses a local variable called <code>avg</code>.
However, the following code would raise an error because the variable <code>diff</code> is declared in two places:
</p><pre>def gcd() {
  if (this.a &gt; this.b) {
    var diff = this.a - this.b;
    this.a = diff;
  } else {
    var diff = this.b - this.a;
    this.b = diff;
  }
</pre>

<p>
The variable declaration has to be manually hoisted, as follows:
</p><pre>def gcd() {
  var diff;
  if (this.a &gt; this.b) {
    diff = this.a - this.b;
    this.a = diff;
  } else {
    diff = this.b - this.a;
    this.b = diff;
  }
</pre>


<h3 id="static-function-variables">Static Function Variables</h3>

<p>
Static function variables are declared within static functions, also using the &#34;var&#34; statement.
Static function variables are not available to methods, but are visible to all static functions.
For example:
</p><pre>static setup() {
  var begin = 1;
}

static loop() {
  if (begin) {
    begin = 0;
  }
}
</pre>

<p>
The two static functions above refer to the same <code>begin</code> variable.
</p>

<p>
Shadama provides the following built-in static function variables:
</p><ul>
  <li>
    <code>mousemove</code>:
    An object whose <code>x</code> and <code>y</code> properties refer to the most recent mouse cursor location.
  </li>
  <li>
    <code>mousedown</code>:
    An object whose <code>x</code> and <code>y</code> properties refer to the most
    recent location where the user pressed the mouse button down.
  </li>
  <li>
    <code>mouseup</code>:
    An object whose <code>x</code> and <code>y</code> properties refer to the most
    recent location where the user lifted the mouse button up.
  </li>
  <li>
    <code>time</code>:
    The number of seconds elapsed since the last time the <code>setup</code> function was called (in floating-point).
  </li>
  <li>
    <code>width, height</code>:
    The width and height of the Shadama canvas.
  </li>
</ul>

<p>
Be aware that mouse event objects are JavaScript objects. Thus, they can&#39;t be passed to methods because
methods can only take scalar arguments.
</p>

<p>
There is one additional variable called <code>Display</code>
for invoking certain system primitives.

For example:
</p><pre>static loop() {
  Display.clear();
  MyPatch.draw();
}
</pre>
<p>
The above code clears the canvas and then draws <code>MyPatch</code> by calling the <code>draw</code> primitive.  <code>Display</code> has <code>loadProgram</code>, and <code>clear</code>.
</p>

<h3 id="parallelism-considerations">Parallelism Considerations</h3>
<p>
It&#39;s possible for two or more nearby turtles to write into the same patch cell.
Which value gets stored in the patch is non-deterministic.
</p>
<p>
Also, updates to turtle properties and patch properties are not visible until after the method is run.
Consider the following method:
</p><pre>def test() {
  if (this.r &gt; 0) {
     this.r = 0;
  } else {
     this.r = 1;
  }
  this.b = this.r;
}
</pre>

<p>
Even though the last line reads <code>this.b = this.r;</code>, the <code>r</code> property and <code>b</code> property will
not be equal after the invocation. This is because the update to the <code>r</code> property seen earlier does not take effect
until after the method call is finished. Thus, the <code>b</code> property will have the previous <code>r</code> value.
</p>

<p>
The properties <code>this.b</code> and <code>this.r</code> can have the same value
through the following use of a local variable:
</p><pre>def test() {
  var r = this.r;
  if (r &gt; 0) {
     r = 0;
  } else {
     r = 1;
  }
  this.r = r;
  this.b = r;
}
</pre>


<p>
A script can be started by calling <code>start</code> on it. Likewise, you can stop it <code>stop</code>, and execute it once with <code>step</code>.
</p>

<h3 id="control-structures">Control Structures</h3>
<p>
The <code>if</code> statement is the only control structure that Shadama supports.
Loops may be supported in a future version of Shadama because the OpenGL shader language version 3.0
does support variable-count loops.
</p>
<h3 id="primitive-functions">Primitive Functions</h3>
<p>

There are a number of primitive functions that can be called from methods.
Most of them actually result in a direct call to a GLSL built-in function.
For example:
</p><pre>def prims(x) {
  var c = cos(x);
  var s = step(0.5, x);
  var a = abs(x);
  var f = fract(x); // the fraction part of x

  this.r = c * s * a * f;
}
</pre>

<p>
The above code uses several primitive functions to compute a contrived value which
is then stored into the turtle&#39;s <code>r</code> property.
</p>

<h3 id="method-binding">Method Binding</h3>
<p>
Methods are not defined for any particular breed, but a given
method can only be applied to breeds that have the properties referenced
in the method.
For example:
</p><pre>breed A (x, r)
breed B (x, y, r, g)
breed C (r)

def set() {
  this.r = 1;
  this.x = 0;
}

static test() {
  A.set();
  B.set();
}
</pre>

<p>
The <code>set</code> method above can be called for both breed <code>A</code> and breed <code>B</code>.
This is the not the case for breed C because it does not have an <code>x</code> property, which is
referenced in <code>set</code>.
</p>

<h3 id="limitations">Limitations</h3>

<p>
The following are important limitations of the Shadama language.
</p>

<p>
Methods can not take breeds as arguments.
For example, the following code is invalid:
</p><pre>breed A (x, y)
breed B (x, y)

def hit(other) {
  var diff = other.x - this.x;
  ...
}

static step() {
  A.hit(B);
}
</pre>


<p>
The <code>step</code> function passes breed B as an argument to the <code>hit</code> method, which is not allowed.
Even if it were, it is not clear which turtle from breed <code>B</code> should
be bound to the argument <code>other</code>.
</p>

<p>
Another limitation is that a given method can either update the turtle&#39;s properties or
the patch&#39;s properties, but not both.
For example, the following code is invalid:
</p><pre>def test(field) {
  field.r = 1;
  this.r = 1;
}
</pre>


<p>
This limitation arises from limitations in WebGL itself. Future
versions of WebGL, and thus Shadama, may no longer have this restriction.
In the meantime, a workaround is to split the method into two methods — one
for updating the patch and one for updating the turtle.
It is also possible that a future version of Shadama will automatically
perform this code transformation.
</p>

</section>

    </article></div>
  </body>
</html>
