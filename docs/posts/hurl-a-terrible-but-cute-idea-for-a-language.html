<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/introducing-hurl/">Original</a>
    <h1>Hurl: A terrible but cute idea for a language</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Monday, June 19, 2023</strong></p>

    <p>Sometimes we have ideas that are bad but demand to enter reality. A few months ago, while chatting with a friend, we toyed around with the idea of a language where the only control flow you get is error handling. This idea embedded itself in my brain and wouldn&#39;t let me go, so I kept just talking about it until two people in the same week accidentally encouraged me to do it.</p>
<p>Unfortunately, I decided to make this language a reality.
<em>I&#39;m sorry</em>.
You are probably better off if you close the tab now.
If you keep reading, it&#39;s at your own risk.</p>

<p>Here&#39;s the premise of the language.
You know how in Python, people sometimes use exceptions for control flow?
Yeah, yeah, I know exceptions aren&#39;t control flow and blah blah <em>except they are</em>.
They share a lot with <code>goto</code> statements, where you can just kind of get yeeted to somewhere else in the program.
But they&#39;re less flexible, since you can only go back up the stack.</p>
<p>Since you <em>can</em> use them for control flow, the natural question is how little other control flow can you provide?
How much of the heavy lifting can exceptions provide?</p>
<p>Turns out, holy cow, they can cover just about everything.</p>

<p>Here are the core language features:</p>
<ul>
<li>Binding local variables</li>
<li>Defining anonymous functions</li>
<li>Exception handling</li>
</ul>
<p>Let&#39;s go through those one by one and look at how they&#39;ll work, and then we can look at how they add up to something more full-featured.</p>
<h3 id="binding-local-variables">Binding local variables</h3>
<p>This looks like and works like you&#39;d expect.
You use the <code>let</code> keyword to bind a value to a name (no uninitialized variables, sorry!). Kind of like this:</p>
<pre><code><span>let x = 10;
let name = &#34;Nicole&#34;;
</span></code></pre>
<p>This brings up our first spicy decision: statements end in semicolons.
I&#39;m personally a fan of semicolons, and I think they make the grammar easier to parse as a human (at least, for this human named Nicole).</p>
<p>Otherwise, this looks a lot like JavaScript or Rust syntax.
I just took it off the shelf.</p>
<p>The language is dynamically typed, so you don&#39;t have to specify what type anything is.
This helps make the grammar small.
We&#39;ll see how it affects the interpreter implementation!</p>
<h3 id="defining-anonymous-functions">Defining anonymous functions</h3>
<p>The next thing we can do is define anonymous functions.
You do this with the <code>func</code> keyword, like in Go or Swift.
Each function may have as many arguments as you would like.</p>
<p>Here&#39;s a silly example defining a function to add together two numbers.</p>
<pre><code><span>func(x, y) {
  hurl x + y;
};
</span></code></pre>
<p>Oh yeah, forgot to mention something: we can&#39;t return values from functions.
If you want to send something out, you have to throw it as an exception, and one of the two keywords for that is <code>hurl</code>.</p>
<p>Also, anonymous functions aren&#39;t a whole lot of use if you can&#39;t ever refer to them to call them.
To get around this, we just combine anonymous functions with binding local variables, and we give them a name.
Then we call them with the syntax you would expect, the usual <code>f(1,2)</code> type deal.</p>
<pre><code><span>let add = func(x, y) {
  hurl x +  y;
};
</span></code></pre>
<p>Another important detail is that since Hurl is dynamically typed, you could pass in two ints, or you could pass in two strings, or an int and a string.
Some of these will work, some might cause problems if <code>+</code> isn&#39;t defined for those types!
Here&#39;s what some of the combinations would do:</p>
<pre><code><span>// hurls 3
add(1, 2);

// hurls &#34;1fish&#34;
add(1, &#34;fish&#34;);

// hurls &#34;me2&#34;
add(&#34;me&#34;, 2);

// hurls &#34;blue fish&#34;
add(&#34;blue&#34;, &#34; fish&#34;);
</span></code></pre>
<p>Oh, also, functions cannot be recursive (without passing in a function to itself), because we won&#39;t have the function bound to a name in the local context when defining itself.
Fun, right?</p>
<p>Great.
We&#39;ve got functions.
Now we need the spice.</p>
<h3 id="exception-handling">Exception handling</h3>
<p>First of all, I&#39;m really sorry.
I didn&#39;t have to do this, but I did, and here we are.</p>
<p>Exception handling has two components: throwing the exception, and catching it.</p>
<p>There are two ways to throw an exception:</p>
<ul>
<li>You can <code>hurl</code> it, which works like you&#39;d expect: it unwinds the stack as you go until it either reaches a <code>catch</code> block that matches the value, or exhausts the stack.</li>
<li>You can <code>toss</code> it, which works a little differently: it traverses the stack until you reach a matching <code>catch</code> block, but then you can use the <code>return</code> keyword to <em>go back</em> to where the value was tossed from.</li>
</ul>
<p>I know, it&#39;s cursed using <code>return</code> in this unusual way.
Again, sorry, I didn&#39;t make you keep reading.
But, the reward is that since you got here, you get to see how we can use these to create control flow.</p>
<p>Here are a couple of examples, which we will work through with explanations of the stack state in both.</p>
<p>In the first example, we&#39;ll make a dummy function which <code>hurls</code> a value, and catch it in the grandparent caller.
I&#39;ve inserted line numbers for ease of displaying a trace later.</p>
<pre><code><span> 1 | let thrower = func(val) {
 2 |   hurl val + 1;
 3 | };
 4 |
 5 | let middle = func(val) {
 6 |   print(&#34;middle before thrower&#34;);
 7 |   thrower(val);
 8 |   print(&#34;middle after thrower&#34;);
 9 | };
10 |
11 | let first = func(val) {
12 |   try {
13 |     middle(val);
14 |   } catch as new_val {
15 |     print(&#34;caught: &#34; + new_val);
16 |   };
17 | };
18 |
19 | first(2);
</span></code></pre>
<p>This program will define a few functions, then execute <code>first</code>.
Here&#39;s an imprecise trace of the program execution when we call <code>first(2)</code>:</p>
<pre><code><span>(file):19:
  stack: (empty)
  calls first

first:12:
  stack: [ (first, 2) ]
  enters try block

first:13:
  stack: [ (first, 2), (&lt;try&gt;) ]
  calls middle

middle:6:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2) ]
  prints &#34;middle before thrower&#34;

middle:7:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2) ]
  calls thrower

thrower:2:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  resolves val as 2, adds 1, and stores this (3) as a temp

thrower:2:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  hurls 3, pops current stack frame

middle:7:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2) ]
  status: hurling 3
  not in a try block, pops stack frame

first:13:
  stack: [ (first, 2), (&lt;try&gt;) ]
  status: hurling 3
  in a try block, try block matches, jump into matching block

first:15:
  stack: [ (first, 2), (&lt;try&gt;), (&lt;catch&gt;, 3) ]
  print &#34;caught: 3&#34;
  pop catch and try stack frames
  pop first stack frame

file:19:
  stack: []
  execution complete
</span></code></pre>
<p>That&#39;s a bit to follow (and if you have a better way of expressing this trace, please let me know so I can update the post and the future docs), but it&#39;s sufficient to understand it as &#34;normal exception handling except you can throw <em>anything</em>.&#34;</p>
<p>This also introduced one other construct, <code>catch as</code>, which lets you catch all values and store it in a new local variable.
The other thing you can do is something like <code>catch (true)</code> or <code>catch (&#34;hello&#34;)</code> to only match specific values.</p>
<p>Now the other one is pretty fun.
This is <code>toss</code>.
We can change the above example to use <code>toss</code> and <code>return</code>.
This time I&#39;ll just illustrate the stack starting from when we reach <code>toss</code>; execution is the same up until then (with slightly different line numbers).</p>
<pre><code><span> 1 | let thrower = func(val) {
 2 |   toss val + 1;
 3 | };
 4 |
 5 | let middle = func(val) {
 6 |   print(&#34;middle before thrower&#34;);
 7 |   thrower(val);
 8 |   print(&#34;middle after thrower&#34;);
 9 | };
10 |
11 | let first = func(val) {
12 |   try {
13 |     middle(val);
14 |   } catch as new_val {
15 |     print(&#34;caught: &#34; + new_val)
16 |     return;
17 |   };
18 | };
19 |
20 | first(2);
</span></code></pre>
<p>Here&#39;s the abridged trace, starting just from the <code>toss</code> statement.
Note that now we have an index of where we are in the stack.
This is 0-indexed, since that reflects the language I&#39;ll write the interpreter in.</p>
<pre><code><span>thrower:2:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  stack index: 3
  tosses 3 from stack index 3, decrements stack index

middle:7:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  stack index: 2
  status: tossing 3 from stack index 3
  not in a try block, decrements stack index

first:13:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  stack index: 1
  status: tossing 3 from stack index 3
  in a try block, try block matches, jump into matching block creating a substack

first:15:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  stack index: 1
  status: tossing 3 from stack index 3
  substack: [ (&lt;catch&gt;, 3) ]
  print &#34;caught: 3&#34;

first:16:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  stack index: 1
  status: tossing 3 from stack index 3
  substack: [ (&lt;catch&gt;, 3) ]
  returning, pop the substack, set stack index to 3

thrower:2:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2), (thrower, 2) ]
  stack index: 3
  finish this function, pops current stack frame

middle:8:
  stack: [ (first, 2), (&lt;try&gt;), (middle, 2) ]
  stack index: 2
  prints &#34;middle after thrower&#34;
  finish this function, pops current stack frame

first:13:
  stack: [ (first, 2), (&lt;try&gt;) ]
  stack index: 1
  finishes the try block, pops current stack frame
  finish this function, pops current stack frame

file:20:
  stack: []
  stack index: 0
  execution complete
</span></code></pre>
<p>And that&#39;s it!
That&#39;s what we need to make a useful language that can do all the ordinary things languages do.</p>
<p>Well, we don&#39;t have a clear way of handling <em>errors</em> since exception handling is being used for actual control flow.
So let&#39;s just be careful and not write any bugs, and not have errors.</p>
<p>But now it&#39;s time to put together the pieces and do &#34;useful&#34; things.</p>

<p>Conditionals and loops are pretty fundamental to how we write programs.
Howe do we express them in this paradigm?</p>
<p>Conditionals are pretty straightforward, so we will start there.
We can just hurl a value inside a try block, and use catch blocks to match values!</p>
<p>For example, let&#39;s check if a value is greater than 0.</p>
<pre><code><span>let val = 10;

try {
  hurl val &gt; 10;
} catch (true) {
  print(&#34;over 10&#34;);
} catch (false) {
  print(&#34;not over 10&#34;);
};
</span></code></pre>
<p>This will print &#34;over 10&#34;.
It evalutes the conditional, hurls the resulting <code>true</code>, and then immediately catches that value.
If it happens to hurl something other than true or false, that would continue unwinding the stack further, so be careful.
Consider including a <code>catch as error</code> catch-all.</p>
<p>Loops are where it gets trickier.
We don&#39;t actually have recursion available to us, so we have to be a little clever.</p>
<p>We start by defining a loop function.
This function has to itself take in a loop function.
It also has to take in the loop body and the loop local values.</p>
<p>This loop body has to meet one requirement:</p>
<ul>
<li>It must <code>toss</code> the next iteration&#39;s local values before the end of the loop body</li>
<li>Sometime after that, it must <code>hurl</code> either <code>true</code> (to run another iteration) or <code>false</code> (to complete iteration).</li>
</ul>
<p>It looks something like this:</p>
<pre><code><span>let loop = func(loop_, body, locals) {
    try {
        body(locals);
    } catch as new_locals {
        try {
            // `return` goes back to where the locals were tossed from.
            // This has to be inside a new `try` block since the next things
            // the body function does is hurl true or false.
            return;
        } catch (true) {
            loop_(loop_, body, new_locals);
        } catch (false) {
            hurl new_locals;
        }
    };
};
</span></code></pre>
<p>And then to use it, we have to define our body.</p>
<pre><code><span>let count = func(args) {
  let iter = args[1];
  let limit = args[2];
  print(&#34;round &#34; + iter);

  toss [iter + 1, limit];
  hurl iter &lt; limit;
}
</span></code></pre>
<p>And then if we call this, we can see what it does!</p>
<pre><code><span>loop(loop, count, [1, 3]);
</span></code></pre>
<p>This should print:</p>
<pre><code><span>round 1
round 2
round 3
</span></code></pre>
<p>And that&#39;s basically all we need!</p>

<p>Here&#39;s another fun sample program: fizzbuzz!
If a language can&#39;t implement fizzbuzz, it&#39;s useless for <del>torturing</del> evaluating candidates, so we have to be <em>sure</em> it can be written well.</p>
<p>Here&#39;s an implementation utilizing our previously-defined <code>loop</code> function.</p>
<pre><code><span>let fizzbuzz = func(locals) {
    let x = locals[1];
    let max = locals[2];

    try {
        hurl x == max;
    } catch (true) {
        hurl false;
    } catch (false) {};

    let printed = false;

    try {
        hurl ((x % 3) == 0);
    } catch (true) {
        print(&#34;fizz&#34;);
        printed = true;
    } catch (false) {};

    try {
        hurl ((x % 5) == 0);
    } catch (true) {
        print(&#34;buzz&#34;);
        printed = true;
    } catch (false) {};

    try {
        hurl printed;
    } catch (false) {
        print(x);
    } catch (true) {};

    toss [x+1, max];
    hurl true;
};

loop(loop, fizzbuzz, [0, 100]);
</span></code></pre>
<p>It looks pretty good to me!
By &#34;good&#34; I mean &#34;it looks like it works, technically.&#34;
I don&#39;t mean &#34;yeah let&#39;s use this in production&#34; because I don&#39;t hate my coworkers enough for that.</p>

<p>So, where does Hurl go from here?</p>
<p>I could stop here: it&#39;s a good gag, I&#39;ve written the code samples and we&#39;ve had a laugh.
I&#39;m not going to, though.
This is a nice compact language which seems fit to revisit some of the concepts from <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>, and it&#39;s my first swing at language design!
It&#39;s very low stakes, so I get to explore without being attached to anything very much.</p>
<p>The plan is to work on an interpreter iteratively.
The next steps are:</p>
<ol>
<li>Define the grammar</li>
<li>Write a lexer</li>
<li>Write a parser (demo: check if programs parse)</li>
<li>Write a formatter (demo: reformat programs)</li>
<li>Write an interpreter</li>
<li>Write some programs in it for fun (Advent of Code from 2022?) and create the standard library</li>
</ol>
<p>I&#39;m aiming for a formatter as one of the first components, because all modern languages need a formatter, and it will be a much smaller lift to write than the interpreter so it gets me going more quickly.
Writing the interpreter itself will take quite a while and will be a few iterations.</p>
<p>I&#39;ll be writing more blog posts along the way, so get subscribed to the RSS feed if you want to follow along!</p>
<hr/>



  </article><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a> or <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
