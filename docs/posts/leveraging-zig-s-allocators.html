<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Leveraging-Zigs-Allocators/">Original</a>
    <h1>Leveraging Zig&#39;s Allocators</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
  
  
  
<p>Let&#39;s say we wanted to write <a href="https://github.com/karlseguin/http.zig">an HTTP server library for Zig</a>. At the core of this library, we might have a pool of threads to handle requests. Keeping things simple, it might look something like:</p>

<pre><code><span>fn</span> <span>run</span><span>(</span>worker<span>:</span> <span><span>*</span>Worker</span><span>)</span> <span><span>void</span></span> <span>{</span>
  <span>while</span> <span>(</span>queue<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span> <span>|</span>conn<span>|</span> <span>{</span>
    <span>const</span> action <span>=</span> worker<span>.</span><span>route</span><span>(</span>conn<span>.</span>req<span>.</span>url<span>)</span><span>;</span>
    <span>action</span><span>(</span>conn<span>.</span>req<span>,</span> conn<span>.</span>res<span>)</span> <span>catch</span> <span>{</span> 
    worker<span>.</span><span>write</span><span>(</span>conn<span>.</span>res<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>

<p>As a user of this library, a sample action might be:</p>

<pre><code><span>fn</span> <span>greet</span><span>(</span>req<span>:</span> <span><span>*</span>http<span>.</span>Request</span><span>,</span> res<span>:</span> <span><span>*</span>http<span>.</span>Response</span><span>)</span> <span><span>void</span></span> <span>{</span>
  res<span>.</span>status <span>=</span> <span>200</span><span>;</span>
  res<span>.</span>body <span>=</span> &#34;hello<span>!</span><span>;</span>
<span>}</span></code></pre>

<p>This is promising, but we can probably expect that users of our library will want to write more dynamic content. If we assume that our server is given an allocator on startup, we could pass this allocator into the actions:</p>

<pre><code><span>fn</span> <span>run</span><span>(</span>worker<span>:</span> <span><span>*</span>Worker</span><span>)</span> <span><span>void</span></span> <span>{</span>
  
  <span>const</span> allocator <span>=</span> worker<span>.</span>server<span>.</span>allocator<span>;</span>

  <span>while</span> <span>(</span>queue<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span> <span>|</span>conn<span>|</span> <span>{</span>
    <span>const</span> action <span>=</span> worker<span>.</span><span>route</span><span>(</span>conn<span>.</span>req<span>.</span>url<span>)</span><span>;</span>

    
    <span>action</span><span>(</span>allocator<span>,</span> conn<span>.</span>req<span>,</span> conn<span>.</span>res<span>)</span> <span>catch</span> <span>{</span> 

    worker<span>.</span><span>write</span><span>(</span>conn<span>.</span>res<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>

<p>Which would allow users to write actions like:</p>

<pre><code><span>fn</span> <span>greet</span><span>(</span>allocator<span>:</span> <span>Allocator</span><span>,</span> req<span>:</span> <span><span>*</span>http<span>.</span>Request</span><span>,</span> res<span>:</span> <span><span>*</span>http<span>.</span>Response</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
  <span>const</span> name <span>=</span> req<span>.</span><span>query</span><span>(</span><span>&#34;name&#34;</span><span>)</span> <span>orelse</span> <span>&#34;guest&#34;</span><span>;</span>

  res<span>.</span>status <span>=</span> <span>200</span><span>;</span>
  res<span>.</span>body <span>=</span> <span>try</span> std<span>.</span>fmt<span>.</span><span>allocPrint</span><span>(</span>allocator<span>,</span> <span>&#34;Hello {s}&#34;</span><span>,</span> <span>.</span><span>{</span>name<span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre>

<p>While this is a step in the right direction, there&#39;s an obvious issue: the allocated greeting is never freed. Our <code>run</code> function can&#39;t just call <code>allocator.free(conn.res.body)</code> after writing the response because, in some cases, the body might not need to be freed. We could structure our API so that the action has to <code>write()</code> the response and thus be able to <code>free</code> any allocations it made, but that would make it impossible to add some features, like supporting middleware.</p>

<p>The best and simplest solution is to use an <code>ArenaAllocator</code>. The way it works is simple: when we <code>deinit</code> the arena all of its allocations are freed.</p>

<pre><code><span>fn</span> <span>run</span><span>(</span>worker<span>:</span> <span><span>*</span>Worker</span><span>)</span> <span><span>void</span></span> <span>{</span>
  <span>const</span> allocator <span>=</span> worker<span>.</span>server<span>.</span>allocator<span>;</span>

  <span>while</span> <span>(</span>queue<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span> <span>|</span>conn<span>|</span> <span>{</span>
    <span>var</span> arena <span>=</span> std<span>.</span>heap<span>.</span>ArenaAllocator<span>.</span><span>init</span><span>(</span>allocator<span>)</span><span>;</span>
    <span>defer</span> arena<span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>

    <span>const</span> action <span>=</span> worker<span>.</span><span>route</span><span>(</span>conn<span>.</span>req<span>.</span>url<span>)</span><span>;</span>
    <span>action</span><span>(</span>arena<span>.</span><span>allocator</span><span>(</span><span>)</span><span>,</span> conn<span>.</span>req<span>,</span> conn<span>.</span>res<span>)</span> <span>catch</span> <span>{</span> 
    worker<span>.</span><span>write</span><span>(</span>conn<span>.</span>res<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>

<p>Because <code>std.mem.Allocator</code> is an &#34;<a href="https://www.openmymind.net/Zig-Interfaces/">interface</a>&#34;, our action doesn&#39;t need to change. An <code>ArenaAllocator</code> is a great option for an HTTP server because they&#39;re bound to a request, which has a well defined/understood lifetime and is relatively short lived. And while it&#39;s possible to abuse them, it&#39;s probably safe to say: use them more!</p>

<p>We can take this a bit further and re-use the same arena. That might not seem too useful, but take a look at this:</p>

<pre><code><span>fn</span> <span>run</span><span>(</span>worker<span>:</span> <span><span>*</span>Worker</span><span>)</span> <span><span>void</span></span> <span>{</span>
  <span>const</span> allocator <span>=</span> worker<span>.</span>server<span>.</span>allocator<span>;</span>

  <span>var</span> arena <span>=</span> std<span>.</span>heap<span>.</span>ArenaAllocator<span>.</span><span>init</span><span>(</span>allocator<span>)</span><span>;</span>
  <span>defer</span> arena<span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>

  <span>while</span> <span>(</span>queue<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span> <span>|</span>conn<span>|</span> <span>{</span>
    
    <span>defer</span> _ <span>=</span> arena<span>.</span><span>reset</span><span>(</span><span>.</span><span>{</span><span>.</span>retain_with_limit <span>=</span> <span>8192</span><span>}</span><span>)</span><span>;</span>

    <span>const</span> action <span>=</span> worker<span>.</span><span>route</span><span>(</span>conn<span>.</span>req<span>.</span>url<span>)</span><span>;</span>
    <span>action</span><span>(</span>arena<span>.</span><span>allocator</span><span>(</span><span>)</span><span>,</span> conn<span>.</span>req<span>,</span> conn<span>.</span>res<span>)</span> <span>catch</span> <span>{</span> 
    worker<span>.</span><span>write</span><span>(</span>conn<span>.</span>res<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>

<p>We&#39;ve moved our arena outside the loop but the important part is inside: after each request, we reset the arena and retain up to 8K of memory. That means that, for many requests, we&#39;ll never have to go to our underling allocator (<code>worker.server.allocator</code>) to get more memory. This can significantly improve performance.</p>

<p>Now imagine a sad world where we couldn&#39;t reset our arena with <code>retain_with_limit</code>. Could we still apply the same optimization? Yes, by creating our own allocator which first attempts to use a <code>FixedBufferAllocator</code> and then falling back to our arena.</p>



<p>Here&#39;s our full <code>FallBackAllocator</code>:</p>

<pre><code><span>const</span> <span>FallbackAllocator</span> <span>=</span> <span>struct</span> <span>{</span>
  primary<span>:</span> <span>Allocator</span><span>,</span>
  fallback<span>:</span> <span>Allocator</span><span>,</span>
  fba<span>:</span> <span><span>*</span>std<span>.</span>heap<span>.</span>FixedBufferAllocator</span><span>,</span>

  <span>pub</span> <span>fn</span> <span>allocator</span><span>(</span>self<span>:</span> <span><span>*</span>FallbackAllocator</span><span>)</span> <span>Allocator</span> <span>{</span>
    <span>return</span> <span>.</span><span>{</span>
      <span>.</span>ptr <span>=</span> self<span>,</span>
      <span>.</span>vtable <span>=</span> <span>&amp;</span><span>.</span><span>{</span><span>.</span>alloc <span>=</span> alloc<span>,</span> <span>.</span>resize <span>=</span> resize<span>,</span> <span>.</span>free <span>=</span> free<span>}</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span>

  <span>fn</span> <span>alloc</span><span>(</span>ctx<span>:</span> <span><span>*</span>anyopaque</span><span>,</span> len<span>:</span> <span><span>usize</span></span><span>,</span> ptr_align<span>:</span> <span><span>u8</span></span><span>,</span> ra<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>?</span><span>[</span><span>*</span><span>]</span><span>u8</span></span> <span>{</span>
    <span>const</span> self<span>:</span> <span><span>*</span>FallbackAllocator</span> <span>=</span> <span>@ptrCast</span><span>(</span><span>@alignCast</span><span>(</span>ctx<span>)</span><span>)</span><span>;</span>
    <span>return</span> self<span>.</span>primary<span>.</span><span>rawAlloc</span><span>(</span>len<span>,</span> ptr_align<span>,</span> ra<span>)</span>
           <span>orelse</span> self<span>.</span>fallback<span>.</span><span>rawAlloc</span><span>(</span>len<span>,</span> ptr_align<span>,</span> ra<span>)</span><span>;</span>
  <span>}</span>

  <span>fn</span> <span>resize</span><span>(</span>ctx<span>:</span> <span><span>*</span>anyopaque</span><span>,</span> buf<span>:</span> <span><span>[</span><span>]</span><span>u8</span></span><span>,</span> buf_align<span>:</span> <span><span>u8</span></span><span>,</span> new_len<span>:</span> <span><span>usize</span></span><span>,</span> ra<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>bool</span></span> <span>{</span>
    <span>const</span> self<span>:</span> <span><span>*</span>FallbackAllocator</span> <span>=</span> <span>@ptrCast</span><span>(</span><span>@alignCast</span><span>(</span>ctx<span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>self<span>.</span>fba<span>.</span><span>ownsPtr</span><span>(</span>buf<span>.</span>ptr<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>self<span>.</span>primary<span>.</span><span>rawResize</span><span>(</span>buf<span>,</span> buf_align<span>,</span> new_len<span>,</span> ra<span>)</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> self<span>.</span>fallback<span>.</span><span>rawResize</span><span>(</span>buf<span>,</span> buf_align<span>,</span> new_len<span>,</span> ra<span>)</span><span>;</span>
  <span>}</span>

  <span>fn</span> <span>free</span><span>(</span>_<span>:</span> <span><span>*</span>anyopaque</span><span>,</span> _<span>:</span> <span><span>[</span><span>]</span><span>u8</span></span><span>,</span> _<span>:</span> <span><span>u8</span></span><span>,</span> _<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>void</span></span> <span>{</span>
    
    
  <span>}</span>
<span>}</span><span>;</span></code></pre>



<p>Our <code>alloc</code> implementation first tries to allocate using our &#34;primary&#34; allocator. If that fails, we use our &#34;fallback&#34; allocator. <code>resize</code>, which we have to implement as part of the <code>std.mem.Allocator</code> interface, determines which allocator owns the memory we&#39;re trying to resize and then calls its <code>rawResize</code>. To keep this somewhat simple, I left out the implementation of <code>free</code> - which is OK in this specific case since  &#34;primary&#34; is going to be a <code>FixedBufferAllocator</code> and &#34;fallback&#34; is going to be an <code>ArenaAllocator</code> (thus, all the freeing happens when the arena&#39;s <code>deinit</code> or <code>reset</code> are called).</p>

<p>Now we need to change our <code>run</code> method to take advantage of this new allocator:</p>

<pre><code><span>fn</span> <span>run</span><span>(</span>worker<span>:</span> <span><span>*</span>Worker</span><span>)</span> <span><span>void</span></span> <span>{</span>
  <span>const</span> allocator <span>=</span> worker<span>.</span>server<span>.</span>allocator<span>;</span>

  
  <span>const</span> buf <span>=</span> <span>try</span> allocator<span>.</span><span>alloc</span><span>(</span><span>u8</span><span>,</span> <span>8192</span><span>)</span><span>;</span>
  <span>defer</span> allocator<span>.</span><span>free</span><span>(</span>buf<span>)</span><span>;</span>

  <span>var</span> fba <span>=</span> std<span>.</span>heap<span>.</span>FixedBufferAllocator<span>.</span><span>init</span><span>(</span>buf<span>)</span><span>;</span>

  <span>while</span> <span>(</span>queue<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span> <span>|</span>conn<span>|</span> <span>{</span>
    <span>defer</span> fba<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> arena <span>=</span> std<span>.</span>heap<span>.</span>ArenaAllocator<span>.</span><span>init</span><span>(</span>allocator<span>)</span><span>;</span>
    <span>defer</span> arena<span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> fallback <span>=</span> <span>FallbackAllocator</span><span>{</span>
      <span>.</span>fba <span>=</span> <span>&amp;</span>fba<span>,</span>
      <span>.</span>primary <span>=</span> fba<span>.</span><span>allocator</span><span>(</span><span>)</span><span>,</span>
      <span>.</span>fallback <span>=</span> arena<span>.</span><span>allocator</span><span>(</span><span>)</span><span>,</span>
    <span>}</span><span>;</span>

    <span>const</span> action <span>=</span> worker<span>.</span><span>route</span><span>(</span>conn<span>.</span>req<span>.</span>url<span>)</span><span>;</span>
    <span>action</span><span>(</span>fallback<span>.</span><span>allocator</span><span>(</span><span>)</span><span>,</span> conn<span>.</span>req<span>,</span> conn<span>.</span>res<span>)</span> <span>catch</span> <span>{</span> 
    worker<span>.</span><span>write</span><span>(</span>conn<span>.</span>res<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>

<p>This achieves something similar to resetting our arena with a <code>retain_with_limit</code>. We create a <code>FixedBufferAllocator</code> which can be reused for each request. This represents the 8K of memory we were previously retaining. Because an action might need more memory, we still need our <code>ArenaAllocator</code>. By wrapping our <code>FixedBufferAllocator</code> and our <code>ArenaAllocator</code> in our <code>FallbackAllocator</code> we ensure that any allocations will first try to use the (very fast) <code>FixedBufferAllocator</code> and when that&#39;s full, use the <code>ArenaAllocator</code>.</p>

<p>Because we&#39;re exposing an <code>std.mem.Allocator</code>, we&#39;re able to make these changes, tweaking how we want our allocator to work, without breaking <code>greet</code>.</p>

<p>Hopefully this example highlights what I consider two real benefits to explicit allocators: simplifying resource management (via something like an <code>ArenaAllocator</code>) and improved performance by re-using allocations (like we did with <code>retain_with_limit</code> or with our<code>FixedBufferAllocator</code>).</p>


</article>
</div></div>
  </body>
</html>
