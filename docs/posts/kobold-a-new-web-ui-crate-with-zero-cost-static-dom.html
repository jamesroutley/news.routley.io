<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maciej.codes/2023-03-23-kobold.html">Original</a>
    <h1>Kobold, a new web UI crate with zero-cost static DOM</h1>
    
    <div id="readability-page-1" class="page"><article>
	<header>
		
		<time>Posted on March 23, 2023</time>
	</header>

	<img src="https://raw.githubusercontent.com/maciejhirsz/kobold/master/kobold.svg?sanitize=true" alt="Kobold logo" width="250"/>
<p><a href="https://github.com/maciejhirsz/kobold"><strong>Kobold</strong></a> is a <a href="https://crates.io/crates/kobold">crate</a> for creating declarative web UI.</p>
<p>The <a href="https://maciej.codes/kosz/kobold-todomvc/">TodoMVC implemented in Kobold</a> weighs about 30kb when gzipped over the wire, out of which the gzipped Wasm blob is under 20kb. <a href="https://github.com/maciejhirsz/kobold/tree/master/examples/todomvc">There are no tricks there</a>. I haven&#39;t replaced the default allocator, nor have I minified the JavaScript (although I probably should).</p>
<p>The goal I have set for myself was creating something that works and feels like a yet another <a href="https://en.wikipedia.org/wiki/JSX_(JavaScript)">JSX</a>-esque library akin to <a href="https://reactjs.org/"><strong>React</strong></a> or <a href="https://yew.rs/"><strong>Yew</strong></a>, but without the full <a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">performance overhead</a> of <a href="https://en.wikipedia.org/wiki/Virtual_DOM">Virtual DOM</a>.</p>
<p>All of it in <strong>Rust</strong>, of course.</p>
<p>The <a href="https://docs.rs/kobold/latest/kobold/">documentation</a> combined with the <a href="https://github.com/maciejhirsz/kobold/tree/master/examples">examples</a> should give you some insight into building things. What I would like to do here instead is lay down some context, explain how I think about this problem space and how <strong>Kobold</strong> actually works.</p>
<h2>Zero-Cost Static HTML</h2>
<p>On the surface <strong>Kobold</strong> works exactly like a Virtual-DOM-based library. There are no extra containers to wrap your data in and it does indeed perform <a href="https://twitter.com/pcwalton/status/1015694528857047040">the dreaded <em>diffing</em></a>, however the only thing that ever gets diffed is your data.</p>
<p>I first started <a href="https://github.com/maciejhirsz/kobold/blob/5b1d7b6f786ce7825f2df80adee18050a8fb0426/sketch/src/main.rs#L52-L62">experimenting in December of 2019</a> with a procedural macro that would eventually become the <code>view!</code> macro in <strong>Kobold</strong>. I didn&#39;t think about components, or data states, event handling, or even rendering lists. All I wanted is something that looked like JSX, but instead of producing Virtual DOM it would produce pre-compiled JavaScript code to manage all the stuff in the DOM that never changes.</p>
<p>Ignoring components for now, the absolute simplest piece of code we could do with Kobold would look something like this:</p>
<pre><code><b>fn</b> <u>hello</u>() -&gt; <b>impl</b> <i>View</i> {
    <i>view</i>! {
        &lt;<i>h1</i>&gt;<a>&#34;Hello world!&#34;</a>&lt;/<i>h1</i>&gt;
    }
}
</code></pre>
<p>If you have ever worked with <strong>Yew</strong> or <strong>React</strong> this should immediately look familiar. The main difference between <strong>Kobold</strong> and <strong>Yew</strong> here is the opaque <code>impl View</code> return type. The <code>View</code> trait definition looks as follows:</p>
<pre><code><em>/// Trait that describes types that can be rendered in the DOM.</em>
<b>pub trait</b> <i>View</i> {
    <em>/// The product should contain a DOM reference to this View and
    /// any data it needs to update itself.</em>
    <b>type</b> <i>Product</i><b>:</b> <u>Mountable</u>;

    <em>/// Build a product that can be mounted in the DOM from this type.</em>
    <b>fn</b> <u>build</u>(<b>self</b>) -&gt; <b>Self::</b><u>Product</u>;

    <em>/// Update the product and apply changes to the DOM if necessary.</em>
    <b>fn</b> <u>update</u>(<b>self</b>, <i>p</i><b>: &amp;mut Self::</b><u>Product</u>);

    <em>/// ... skipping some methods here that are auto provided</em>
}
</code></pre>
<p>Any type that implements <code>View</code> needs to know how to <em><code>build</code></em> its <em><code>Product</code></em> and how to <em><code>update</code></em> it on subsequent renders. Said <code>Product</code> will contain a reference to its root DOM element plus any data it might need to diff for updates. The important part is: you never have to write these two methods by hand.</p>
<p>If we expand the <code>view!</code> macro our <code>hello</code> function becomes:</p>
<pre><code><b>fn</b> <u>hello</u>() -&gt; <b>impl</b> <i>View</i> {
    #[wasm_bindgen(inline_js = &#34;&lt;snip&gt;&#34;)]
    <b>extern</b> <a>&#34;C&#34;</a> {
        <b>fn</b> <u>__e0_dd8ebbc530e4055f</u>() -&gt; <i>web_sys</i><b>::</b><u>Node</u>;
    }
    <i>Static</i>(<i>__e0_dd8ebbc530e4055f</i>)
}
</code></pre>
<p>I have taken the liberty of formatting the output while also <em>not expanding</em> the <code>#[wasm_bindgen]</code> attribute macro here. The snipped JavaScript is:</p>
<pre><code><b>export function</b> <u>__e0_dd8ebbc530e4055f</u>() {
    <b>let</b> <i>e0</i>=<i>document</i>.<u>createElement</u>(<a>&#34;h1&#34;</a>);
    <i>e0</i>.<u>append</u>(<a>&#34;Hello world!&#34;</a>);
    <b>return</b> <i>e0</i>;
}
</code></pre>
<p>The <code>Static</code> is just a <em>newtype</em> wrapper. Here is its declaration and <code>View</code> implementation:</p>
<pre><code><b>pub struct</b> <u>Static</u>&lt;<i>F</i>&gt;(<b>pub</b> <i>F</i>);

<b>impl</b>&lt;<i>F</i>&gt; <i>View</i> <b>for</b> <i>Static</i>&lt;<i>F</i>&gt;
<b>where</b>
    <i>F</i><b>:</b> <u>Fn</u>() -&gt; <i>Node</i>,
{
    <b>type</b> <i>Product</i> = <i>Element</i>;

    <b>fn</b> <u>build</u>(<b>self</b>) -&gt; <i>Element</i> {
        <i>Element</i><b>::</b><u>new</u>(<b>self.</b><a>0</a>())
    }

    <b>fn</b> <u>update</u>(<b>self</b>, _<b>: &amp;mut </b><u>Element</u>) {}
}
</code></pre>
<p>Two things of note:</p>
<ol>
<li><code>Static&lt;F&gt;</code> taking function as a generic parameter will have <code>std::mem::size_of::&lt;Static&lt;_&gt;&gt;() == 0</code>. This means that on runtime calling <code>hello()</code> does quite literally nothing, and only <code>hello().build()</code> calls the extern JavaScript function that constructs the <code>&lt;h1&gt;</code> header and gives us the reference to its root element.</li>
<li>Since there are no expressions here, the <code>update</code> method is also empty, meaning that invoking <code>hello().update(&amp;mut product)</code> also does absolutely nothing at runtime.</li>
</ol>
<p>Herein lies the crux of the #1 claim that <strong>Kobold</strong> makes: <strong>static HTML is zero-cost</strong>. It is created <em>in the precompiled JavaScript</em> with absolute minimum of Wasm-JavaScript boundary crossing necessary (one, exactly) and never updated. There is no diffing, not even a branch to check if diffing is necessary.</p>
<h2>Injecting Expressions</h2>
<p>Let&#39;s modify our <code>hello</code> function to render a string slice in the view:</p>
<pre><code><b>fn</b> <u>hello</u>(<i>name</i><b>: &amp;</b><u>str</u>) -&gt; <b>impl</b> <i>View</i> + <b>&#39;_ </b>{
    <i>view</i>! {
        &lt;<i>h1</i>&gt;<a>&#34;Hello &#34;</a>{ <i>name</i> }<a>&#34;!&#34;</a>&lt;/<i>h1</i>&gt;
    }
}
</code></pre>
<p>The expression in curly braces like <code>{ name }</code> must implement <code>View</code> itself, which <code>&amp;str</code> does. Notably a <code>View</code> only needs to live long enough to be used in either <code>build</code> or <code>update</code>, no <code>&#39;static</code> lifetime necessary. This avoids a whole bunch of temporary clones on each render.</p>
<p>The code this expands to is a bit longer, so let&#39;s look at it bit by bit. The important part is:</p>
<pre><code><b>fn</b> <u>hello</u>() -&gt; <b>impl</b> <i>View</i> {
    <em>/// snip!</em>

    <b>struct</b> <u>Transient</u>&lt;<i>A</i>&gt; {
        <i>a</i><b>:</b> <u>A</u>,
    }

    <i>Transient</i> { <i>a</i><b>:</b> <u>name</u> }
}
</code></pre>
<p>Given the previous example, you might already see where this is going. The macro defines a new <code>Transient</code> struct with a generic field and it puts the expression in it, in this case just the variable <code>name</code> into that field.</p>
<p>For this to work, the macro also has to implement the <code>View</code> trait for this <code>Transient</code> type. It does it like this:</p>
<pre><code><b>impl</b>&lt;<i>A</i>&gt; <i>View</i> <b>for</b> <i>Transient</i>&lt;<i>A</i>&gt;
<b>where</b>
    <i>A</i><b>:</b> <u>View</u>,
{
    <b>type</b> <i>Product</i> = <i>TransientProduct</i>&lt;<i>A</i><b>::</b><u>Product</u>&gt;;

    <b>fn</b> <u>build</u>(<b>self</b>) -&gt; <b>Self::</b><u>Product</u> {
        <b>let</b> <i>a</i> = <b>self.</b><u>a</u><b>.</b><u>build</u>();
        <b>let</b> <i>e0</i> = <i>Element</i><b>::</b><u>new</u>(<i>__e0_22790d91e19a0c42</i>(<i>a</i><b>.</b><u>js</u>()));

        <i>TransientProduct</i> { <i>a</i>, <i>e0</i> }
    }

    <b>fn</b> <u>update</u>(<b>self</b>, <i>p</i><b>: &amp;mut Self::</b><u>Product</u>) {
        <b>self.</b><u>a</u><b>.</b><u>update</u>(<b>&amp;mut </b><u>p</u><b>.</b><u>a</u>);
    }
}
</code></pre>
<p>Here is where the magic happens. The <code>build</code> method first builds product of the expression <code>a</code>. The <code>View</code> implementation for <code>&amp;str</code> will just make a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Text"><code>Text</code></a> DOM node and hold an allocated <code>String</code> of the <code>name</code> to check for changes later. Adventurous users could also write <code>{ name.fast_diff() }</code> to switch to pointer address diffing, making this view completely allocation-free for its entire life cycle.</p>
<p>We then take the <code>&amp;JsValue</code> reference to said text node and call a precompiled <code>__e0_22790d91e19a0c42</code> JavaScript function with it. Skipping the <code>#[wasm_bindgen]</code> part here is the code:</p>
<pre><code><b>export function</b> <u>__e0_22790d91e19a0c42</u>(<i>a</i>) {
    <b>let</b> <i>e0</i>=<i>document</i>.<u>createElement</u>(<a>&#34;h1&#34;</a>);
    <i>e0</i>.<u>append</u>(<a>&#34;Hello &#34;</a>,<i>a</i>,<a>&#34;!&#34;</a>);
    <b>return</b> <i>e0</i>;
}
</code></pre>
<p>This is almost identical to the previously generated function, except we append our <code>Text</code> node as variable <code>a</code> between two static text nodes: <code>&#34;Hello &#34;</code> and <code>&#34;!&#34;</code>. Rust only knows about that one <code>Text</code> node containing the <code>name</code> we need to render and the root (<code>&lt;h1&gt;</code> in this case) it needs in order to stick this view into the DOM.</p>
<p>The <code>update</code> method is even simpler: call update on all fields of the <code>Transient</code> with their corresponding products. In our case this just defers the update to the <code>View</code> implementation of <code>&amp;str</code>. No other node in the tree is ever touched: it is <em>zero-cost</em>.</p>
<p>The <code>TransientProduct</code> struct is rather dull so I am not going to explain it here in detail. Suffice to say it just holds all the products for all the expressions, the root <code>Element</code>, and potentially few other <em>hoisted</em> elements that need to have their attributes operated on directly.</p>
<h2>Zero-Cost Components</h2>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Zen_of_Python">There should be one-- and preferably only one --obvious way to do it.</a></p>
</blockquote>
<p>In <strong>Kobold</strong> there is only one sanctioned way to create components: by turning plain functions into <em>functional components</em>. This involves:</p>
<ol>
<li>Changing the name to follow <a href="https://en.wikipedia.org/wiki/Camel_case">PascalCase</a> scheme, just like Rust structs.</li>
<li>Annotating it with the <code>#[component]</code> attribute macro.</li>
</ol>
<p>Taking our <code>hello</code> example from above and turning it into a component is as simple as:</p>
<pre><code>#[component]
<b>fn</b> <u>Hello</u>(<i>name</i><b>: &amp;</b><u>str</u>) -&gt; <b>impl</b> <i>View</i> + <b>&#39;_ </b>{
    <i>view</i>! {
        &lt;<i>h1</i>&gt;<a>&#34;Hello &#34;</a>{<i>name</i>}<a>&#34;!&#34;</a>&lt;/<i>h1</i>&gt;
    }
}
</code></pre>
<p>The only difference between that component and a plain Rust function is how you would invoke them in the <code>view!</code> macro:</p>
<pre><code><i>view</i>! {
    <em>// the `Hello` functional component:</em>
    &lt;<i>Hello name</i>=<a>&#34;World&#34;</a> /&gt;

    <em>// the `hello` function:</em>
    { <i>hello</i>(<a>&#34;World&#34;</a>) }
}
</code></pre>
<p>The actual interaction between the <code>view!</code> and the <code>#[component]</code> macros is unstable so I wouldn&#39;t advise writing component structs by hand. That said, currently <code>&lt;Hello name=&#34;World&#34; /&gt;</code> simply desugars into:</p>
<pre><code><i>Hello</i><b>::</b><u>render</u>(<i>Hello</i> { <i>name</i><b>:</b> <a>&#34;World&#34;</a> })
</code></pre>
<p>The function becomes an associated <code>render</code> function on a struct with fields mapping to the original parameters. While this looks more complicated than <code>hello(&#34;World&#34;)</code>, it has no performance overhead compared to a regular function call. The only purpose components serve is the familiar syntax with named parameters.</p>
<h2>Off the Hook!</h2>
<p>Astute readers by now are surely wondering how stateful components work. Here is the kicker:</p>
<p><strong>Kobold</strong> does not have a concept of a <em>stateful component</em>. The view rendering part is relatively unopinionated about state management. It is entirely feasible to implement <strong>React</strong>-esque hooks like in <a href="https://yew.rs/"><strong>Yew</strong></a> or <a href="https://dioxuslabs.com/"><strong>Dioxus</strong></a> as a 3rd-party crate. <a href="https://en.wikipedia.org/wiki/Reactive_programming">Reactive signals</a> like in <a href="https://sycamore-rs.netlify.app/"><strong>Sycamore</strong></a> or <a href="https://github.com/leptos-rs/leptos"><strong>Leptops</strong></a> should also interact nicely with the <code>View</code> trait.</p>
<p>The state management provided by <strong>Kobold</strong> is in a very real sense optional, you can even opt out of it completely by disabling default features. Assuming you haven&#39;t here is an example:</p>
<pre><code><i>stateful</i>(<a>0</a>, |<i>count</i>| {
    <i>bind</i>! { <i>count</i><b>:
        let</b> <i>inc</i> = <b>move</b> |_| *<i>count</i> += <a>1</a>;
        <b>let</b> <i>dec</i> = <b>move</b> |_| *<i>count</i> -= <a>1</a>;
    }

    <i>view</i>! {
        &lt;<i>p</i>&gt;<a>&#34;Counter is at &#34;</a>{ <i>count</i> }&lt;/<i>p</i>&gt;
        &lt;<i>button onclick</i>={<i>inc</i>}&gt;<a>&#34;Increment&#34;</a>&lt;/<i>button</i>&gt;
        &lt;<i>button onclick</i>={<i>dec</i>}&gt;<a>&#34;Decrement&#34;</a>&lt;/<i>button</i>&gt;
    }
})
</code></pre>
<p>This creates a <em>stateful view</em>. In this case the state is just a simple <code>i32</code> integer. The <code>count</code> argument passed into the closure is of type <code>&amp;Hook&lt;i32&gt;</code> (not related to <strong>React</strong> hooks, I just like the name). You can read the state from the hook simply by dereferencing it. It itself also implements the <code>View</code> trait so we can just use it directly without having to write <code>{ **count }</code>.</p>
<p>The <code>bind!</code> macro creates event-handling closures that can mutate the state via a simple <code>&amp;mut i32</code> reference. If the macro looks a bit too magical for you, you can always choose to write binds the long way via <code>Hook::bind</code>:</p>
<pre><code><b>let</b> <i>inc</i> = <i>count</i><b>.</b><u>bind</u>(<b>move</b> |<i>count</i>, _| *<i>count</i> += <a>1</a>);
<b>let</b> <i>dec</i> = <i>count</i><b>.</b><u>bind</u>(<b>move</b> |<i>count</i>, _| *<i>count</i> -= <a>1</a>);
</code></pre>
<p>These are currently 100% equivalent, the macro just saves you from having to type &#34;<code>count</code>&#34; 4 extra times.</p>
<p>Without having to repeat much of <a href="https://docs.rs/kobold/latest/kobold/stateful/">the documentation</a> what happens here is pretty straight-forward: Clicking the button updates the state of the integer. The main closure is being run on every state change, the <code>count</code> is diffed with the old one and its DOM <code>Text</code> node is updated if necessary.</p>
<p>I personally quite like this model for its simplicity. While I have yet to push it to the point where it becomes really unwieldy, I can imagine that a more robust solution might be necessary for sufficiently complex applications.</p>
<h2>Going Forward</h2>
<p>For now <strong>Kobold</strong> is a complete minimum viable product. I reckon the <code>View</code> trait, the <code>view!</code> macro, and the <code>#[component]</code> attribute macro are reasonably stable by now. The next steps would be:</p>
<ul>
<li>Finishing support for default values in components.</li>
<li>Support for <em>keyed lists</em>, so that we can actually do proper apples-to-apples benchmarks.</li>
<li>Possibly a PR to <a href="https://trunkrs.dev/">Trunk</a> with an option to bundle all the JavaScript files from <code>wasm-bindgen</code> without resorting to extra tools like <a href="https://esbuild.github.io"><code>esbuild</code></a>.</li>
</ul>
<p>If you have come this far, thank you! Check out <a href="https://github.com/maciejhirsz/kobold">the repo</a> or this neat little <a href="https://maciej.codes/kosz/kobold-qr/">QR code</a> example using the <a href="https://crates.io/crates/fast_qr"><code>fast_qr</code></a>-based <a href="https://crates.io/crates/kobold_qr"><code>kobold_qr</code></a>. After all, one of my main motivations for doing this was pulling in complex code like QR code generation and have it work <em>instantly</em> in the browser.</p>
<p>Last, but not least...</p>
<h2>Why &#34;Kobold&#34;?</h2>
<p>Because I am in fact a colossal nerd and <a href="https://forgottenrealms.fandom.com/wiki/Kobold">Kobolds</a> are familiar, clever, and small.</p>

</article></div>
  </body>
</html>
