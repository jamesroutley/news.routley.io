<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/SerenityOS/jakt">Original</a>
    <h1>The Jakt Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>Jakt</strong> is a memory-safe systems programming language.</p>
<p dir="auto">It currently transpiles to C++.</p>
<p dir="auto"><strong>NOTE:</strong> The language is under heavy development.</p>
<p dir="auto"><strong>NOTE</strong> If you&#39;re cloning to a Windows PC (not WSL), make sure that your Git client keeps the line endings as <code>\n</code>. You can set this as a global config via <code>git config --global core.autocrlf false</code>.</p>

<p dir="auto">The transpilation to C++ requires <code>clang</code>. Make sure you have that installed.</p>
<div data-snippet-clipboard-copy-content="jakt file.jakt
./build/file"><pre><code>jakt file.jakt
./build/file
</code></pre></div>

<p dir="auto">See <a href="https://github.com/SerenityOS/jakt/blob/main/documentation/cmake-bootstrap.md">here</a>.</p>

<ol dir="auto">
<li>Memory safety</li>
<li>Code readability</li>
<li>Developer productivity</li>
<li>Executable performance</li>
<li>Fun!</li>
</ol>

<p dir="auto">The following strategies are employed to achieve memory safety:</p>
<ul dir="auto">
<li>Automatic reference counting</li>
<li>Strong typing</li>
<li>Bounds checking</li>
<li>No raw pointers in safe mode</li>
</ul>
<p dir="auto">In <strong>Jakt</strong>, there are three pointer types:</p>
<ul>
<li> <strong>T</strong> (Strong pointer to reference-counted class <code>T</code>.)</li>
<li> <strong>weak T</strong> (Weak pointer to reference-counted class <code>T</code>. Becomes empty on pointee destruction.)</li>
<li> <strong>raw T</strong> (Raw pointer to arbitrary type <code>T</code>. Only usable in <code>unsafe</code> blocks.)</li>
</ul>
<p dir="auto">Null pointers are not possible in safe mode, but pointers can be wrapped in <code>Optional</code>, i.e <code>Optional&lt;T&gt;</code> or <code>T?</code> for short.</p>

<ul>
<li> Integer overflow (both signed and unsigned) is a runtime error.</li>
<li> Numeric values are not automatically coerced to <code>int</code>. All casts must be explicit.</li>
</ul>
<p dir="auto">For cases where silent integer overflow is desired, there are explicit functions that provide this functionality.</p>

<p dir="auto">Far more time is spent reading code than writing it. For that reason, <strong>Jakt</strong> puts a high emphasis on readability.</p>
<p dir="auto">Some of the features that encourage more readable programs:</p>
<ul>
<li> Immutable by default.</li>
<li> Argument labels in call expressions (<code>object.function(width: 10, height: 5)</code>)</li>
<li> Inferred <code>enum</code> scope. (You can say <code>Foo</code> instead of <code>MyEnum::Foo</code>).</li>
<li> Pattern matching with <code>match</code>.</li>
<li> Optional chaining (<code>foo?.bar?.baz</code> (fallible) and <code>foo!.bar!.baz</code> (infallible))</li>
<li> None coalescing for optionals (<code>foo ?? bar</code> yields <code>foo</code> if <code>foo</code> has a value, otherwise <code>bar</code>)</li>
<li> <code>defer</code> statements.</li>
<li> Pointers are always dereferenced with <code>.</code> (never <code>-&gt;</code>)</li>
<li> Trailing closure parameters can be passed outside the call parentheses.</li>
<li> Error propagation with <code>ErrorOr&lt;T&gt;</code> return type and dedicated <code>try</code> / <code>must</code> keywords.</li>
</ul>

<p dir="auto">Jakt is flexible in how a project can be structured with a built-in module system.</p>
<div data-snippet-clipboard-copy-content="import a                                // (1)
import a { use_cool_things }            // (2)
import fn()                             // (3)
import relative foo::bar                // (4)
import relative parent::foo::baz        // (5)
import relative parent(3)::foo::baz     // (6)"><pre lang="jakt"><code>import a                                // (1)
import a { use_cool_things }            // (2)
import fn()                             // (3)
import relative foo::bar                // (4)
import relative parent::foo::baz        // (5)
import relative parent(3)::foo::baz     // (6)
</code></pre></div>
<ol dir="auto">
<li>Import a module from the same directory as the file.</li>
<li>Import only <code>use_cool_things()</code> from module <code>a</code>.</li>
<li>Imports can be calculated at compile time. See <a href="#comptime-imports">Comptime Imports</a></li>
<li>Import a module using the relative keyword when the module is a sub path of the directory containing the file.</li>
<li>Import a module in a parent path one directory up from the directory containing the file.</li>
<li>Syntactic sugar for importing a module three parent paths up from the directory containing the file.</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">The Jakt Standard Library</h3><a id="user-content-the-jakt-standard-library" aria-label="Permalink: The Jakt Standard Library" href="#the-jakt-standard-library"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Jakt has a Standard Library that is accessed using the <code>jakt::</code> namespace:</p>
<div data-snippet-clipboard-copy-content="import jakt::arguments
import jakt::libc::io { system }"><pre lang="jakt"><code>import jakt::arguments
import jakt::libc::io { system }
</code></pre></div>
<p dir="auto">The Jakt Standard Library is in its infancy, so please consider making a contribution!</p>

<p dir="auto">When calling a function, you must specify the name of each argument as you&#39;re passing it:</p>
<div data-snippet-clipboard-copy-content="rect.set_size(width: 640, height: 480)"><pre lang="jakt"><code>rect.set_size(width: 640, height: 480)
</code></pre></div>
<p dir="auto">There are two exceptions to this:</p>
<ul>
<li> If the parameter in the function declaration is declared as <code>anon</code>, omitting the argument label is allowed.</li>
<li> When passing a variable with the same name as the parameter.</li>
</ul>

<p dir="auto">There are two main ways to declare a structure in <strong>Jakt</strong>: <code>struct</code> and <code>class</code>.</p>

<p dir="auto">Basic syntax:</p>
<div data-snippet-clipboard-copy-content="struct Point {
    x: i64
    y: i64
}"><pre lang="jakt"><code>struct Point {
    x: i64
    y: i64
}
</code></pre></div>
<p dir="auto">Structs in <strong>Jakt</strong> have <em>value semantics</em>:</p>
<ul dir="auto">
<li>Variables that contain a struct always have a unique instance of the struct.</li>
<li>Copying a <code>struct</code> instance always makes a deep copy.</li>
</ul>
<div data-snippet-clipboard-copy-content="let a = Point(x: 10, y: 5)
let b = a
// &#34;b&#34; is a deep copy of &#34;a&#34;, they do not refer to the same Point"><pre lang="jakt"><code>let a = Point(x: 10, y: 5)
let b = a
// &#34;b&#34; is a deep copy of &#34;a&#34;, they do not refer to the same Point
</code></pre></div>
<p dir="auto"><strong>Jakt</strong> generates a default constructor for structs. It takes all fields by name. For the <code>Point</code> struct above, it looks like this:</p>

<p dir="auto">Struct members are <em>public</em> by default.</p>

<ul>
<li> basic class support</li>
<li> private-by-default members</li>
<li> inheritance</li>
<li> class-based polymorphism (assign child instance to things requiring the parent type)</li>
<li> <code>Super</code> type</li>
<li> <code>Self</code> type</li>
</ul>
<p dir="auto">Same basic syntax as <code>struct</code>:</p>
<div data-snippet-clipboard-copy-content="class Size {
    width: i64
    height: i64

    public fn area(this) =&gt; .width * .height
}"><pre><code>class Size {
    width: i64
    height: i64

    public fn area(this) =&gt; .width * .height
}
</code></pre></div>
<p dir="auto">Classes in <strong>Jakt</strong> have <em>reference semantics</em>:</p>
<ul dir="auto">
<li>Copying a <code>class</code> instance (aka an &#34;object&#34;) copies a reference to the object.</li>
<li>All objects are reference-counted by default. This ensures that objects don&#39;t get accessed after being deleted.</li>
</ul>
<p dir="auto">Class members are <em>private</em> by default.</p>

<p dir="auto">Both structs and classes can have member functions.</p>
<p dir="auto">There are three kinds of member functions:</p>
<p dir="auto"><strong>Static member functions</strong> don&#39;t require an object to call. They have no <code>this</code> parameter.</p>
<div data-snippet-clipboard-copy-content="class Foo {
    fn func() =&gt; println(&#34;Hello!&#34;)
}

// Foo::func() can be called without an object.
Foo::func()"><pre lang="jakt"><code>class Foo {
    fn func() =&gt; println(&#34;Hello!&#34;)
}

// Foo::func() can be called without an object.
Foo::func()
</code></pre></div>
<p dir="auto"><strong>Non-mutating member functions</strong> require an object to be called, but cannot mutate the object. The first parameter is <code>this</code>.</p>
<div data-snippet-clipboard-copy-content="class Foo {
    fn func(this) =&gt; println(&#34;Hello!&#34;)
}

// Foo::func() can only be called on an instance of Foo.
let x = Foo()
x.func()"><pre lang="jakt"><code>class Foo {
    fn func(this) =&gt; println(&#34;Hello!&#34;)
}

// Foo::func() can only be called on an instance of Foo.
let x = Foo()
x.func()
</code></pre></div>
<p dir="auto"><strong>Mutating member functions</strong> require an object to be called, and may modify the object. The first parameter is <code>mut this</code>.</p>
<div data-snippet-clipboard-copy-content="class Foo {
    x: i64

    fn set(mut this, anon x: i64) {
        this.x = x
    }
}

// Foo::set() can only be called on a mut Foo:
mut foo = Foo(x: 3)
foo.set(9)"><pre lang="jakt"><code>class Foo {
    x: i64

    fn set(mut this, anon x: i64) {
        this.x = x
    }
}

// Foo::set() can only be called on a mut Foo:
mut foo = Foo(x: 3)
foo.set(9)
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Shorthand for accessing member variables</h3><a id="user-content-shorthand-for-accessing-member-variables" aria-label="Permalink: Shorthand for accessing member variables" href="#shorthand-for-accessing-member-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To reduce repetitive <code>this.</code> spam in methods, the shorthand <code>.foo</code> expands to <code>this.foo</code>.</p>

<p dir="auto">Strings are provided in the language mainly as the type <code>String</code>, which is a reference-counted (and heap-allocated) string type.
String literals are written with double quotes, like <code>&#34;Hello, world!&#34;</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Overloaded string literals</h3><a id="user-content-overloaded-string-literals" aria-label="Permalink: Overloaded string literals" href="#overloaded-string-literals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">String literals are of type <code>String</code> by default; however, they can be used to implicitly construct any type that implements the <code>FromStringLiteral</code> (or <code>ThrowingFromStringLiteral</code>) trait. In the language prelude, currently only <code>StringView</code> implements this trait, which can be used only to refer to strings with a static lifetime:</p>
<div data-snippet-clipboard-copy-content="let foo: StringView = &#34;foo&#34; // This string is not allocated on the heap, and foo is only a fat pointer to the static string."><pre lang="jakt"><code>let foo: StringView = &#34;foo&#34; // This string is not allocated on the heap, and foo is only a fat pointer to the static string.
</code></pre></div>
<p dir="auto">Overloaded string literals can be used by providing a type hint, whether by explicit type annotations, or by passing the literal to a function that expects a specific type:</p>
<div data-snippet-clipboard-copy-content="struct NotString implements(FromStringLiteral) {
    fn from_string_literal(anon string: StringView) -&gt; NotString =&gt; NotString()
}

fn test(x: NotString) {}

fn main() {
    let foo: NotString = &#34;foo&#34;
    test(x: &#34;Some string literal&#34;)
}"><pre lang="jakt"><code>struct NotString implements(FromStringLiteral) {
    fn from_string_literal(anon string: StringView) -&gt; NotString =&gt; NotString()
}

fn test(x: NotString) {}

fn main() {
    let foo: NotString = &#34;foo&#34;
    test(x: &#34;Some string literal&#34;)
}
</code></pre></div>

<p dir="auto">Dynamic arrays are provided via a built-in <code>Array&lt;T&gt;</code> type. They can grow and shrink at runtime.</p>
<p dir="auto"><code>Array</code> is memory safe:</p>
<ul dir="auto">
<li>Out-of-bounds will panic the program with a runtime error.</li>
<li>Slices of an <code>Array</code> keep the underlying data alive via automatic reference counting.</li>
</ul>

<div data-snippet-clipboard-copy-content="// Function that takes an Array&lt;i64&gt; and returns an Array&lt;String&gt;
fn foo(numbers: [i64]) -&gt; [String] {
    ...
}"><pre lang="jakt"><code>// Function that takes an Array&lt;i64&gt; and returns an Array&lt;String&gt;
fn foo(numbers: [i64]) -&gt; [String] {
    ...
}
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Shorthand for creating arrays</h3><a id="user-content-shorthand-for-creating-arrays" aria-label="Permalink: Shorthand for creating arrays" href="#shorthand-for-creating-arrays"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="// Array&lt;i64&gt; with 256 elements, all initialized to 0.
let values = [0; 256]

// Array&lt;String&gt; with 3 elements: &#34;foo&#34;, &#34;bar&#34; and &#34;baz&#34;.
let values = [&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;]"><pre lang="jakt"><code>// Array&lt;i64&gt; with 256 elements, all initialized to 0.
let values = [0; 256]

// Array&lt;String&gt; with 3 elements: &#34;foo&#34;, &#34;bar&#34; and &#34;baz&#34;.
let values = [&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;]
</code></pre></div>

<ul>
<li> Creating dictionaries</li>
<li> Indexing dictionaries</li>
<li> Assigning into indexes (aka lvalue)</li>
</ul>
<div data-snippet-clipboard-copy-content="fn main() {
    let dict = [&#34;a&#34;: 1, &#34;b&#34;: 2]

    println(&#34;{}&#34;, dict[&#34;a&#34;])
}"><pre lang="jakt"><code>fn main() {
    let dict = [&#34;a&#34;: 1, &#34;b&#34;: 2]

    println(&#34;{}&#34;, dict[&#34;a&#34;])
}
</code></pre></div>

<div data-snippet-clipboard-copy-content="// Function that takes a Dictionary&lt;i64, String&gt; and returns an Dictionary&lt;String, bool&gt;
fn foo(numbers: [i64:String]) -&gt; [String:bool] {
    ...
}"><pre lang="jakt"><code>// Function that takes a Dictionary&lt;i64, String&gt; and returns an Dictionary&lt;String, bool&gt;
fn foo(numbers: [i64:String]) -&gt; [String:bool] {
    ...
}
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Shorthand for creating dictionaries</h3><a id="user-content-shorthand-for-creating-dictionaries" aria-label="Permalink: Shorthand for creating dictionaries" href="#shorthand-for-creating-dictionaries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="// Dictionary&lt;String, i64&gt; with 3 entries.
let values = [&#34;foo&#34;: 500, &#34;bar&#34;: 600, &#34;baz&#34;: 700]"><pre lang="jakt"><code>// Dictionary&lt;String, i64&gt; with 3 entries.
let values = [&#34;foo&#34;: 500, &#34;bar&#34;: 600, &#34;baz&#34;: 700]
</code></pre></div>

<ul>
<li> Creating sets</li>
<li> Reference semantics</li>
</ul>
<div data-snippet-clipboard-copy-content="fn main() {
    let set = {1, 2, 3}

    println(&#34;{}&#34;, set.contains(1))
    println(&#34;{}&#34;, set.contains(5))
}"><pre lang="jakt"><code>fn main() {
    let set = {1, 2, 3}

    println(&#34;{}&#34;, set.contains(1))
    println(&#34;{}&#34;, set.contains(5))
}
</code></pre></div>

<ul>
<li> Creating tuples</li>
<li> Index tuples</li>
<li> Tuple types</li>
</ul>
<div data-snippet-clipboard-copy-content="fn main() {
    let x = (&#34;a&#34;, 2, true)

    println(&#34;{}&#34;, x.1)
}"><pre><code>fn main() {
    let x = (&#34;a&#34;, 2, true)

    println(&#34;{}&#34;, x.1)
}
</code></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Enums and Pattern Matching</h2><a id="user-content-enums-and-pattern-matching" aria-label="Permalink: Enums and Pattern Matching" href="#enums-and-pattern-matching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul>
<li> Enums as sum-types</li>
<li> Generic enums</li>
<li> Enums as names for values of an underlying type</li>
<li> <code>match</code> expressions</li>
<li> Enum scope inference in <code>match</code> arms</li>
<li> Yielding values from match blocks</li>
<li> Nested <code>match</code> patterns</li>
<li> Traits as <code>match</code> patterns</li>
<li> Support for interop with the <code>?</code>, <code>??</code> and <code>!</code> operators</li>
</ul>
<div data-snippet-clipboard-copy-content="enum MyOptional&lt;T&gt; {
    Some(T)
    None
}

fn value_or_default&lt;T&gt;(anon x: MyOptional&lt;T&gt;, default: T) -&gt; T {
    return match x {
        Some(value) =&gt; {
            let stuff = maybe_do_stuff_with(value)
            let more_stuff = stuff.do_some_more_processing()
            yield more_stuff
        }
        None =&gt; default
    }
}

enum Foo {
    StructLikeThingy (
        field_a: i32
        field_b: i32
    )
}

fn look_at_foo(anon x: Foo) -&gt; i32 {
    match x {
        StructLikeThingy(field_a: a, field_b) =&gt; {
            return a + field_b
        }
    }
}

enum AlertDescription: i8 {
    CloseNotify = 0
    UnexpectedMessage = 10
    BadRecordMAC = 20
    // etc
}

// Use in match:
fn do_nothing_in_particular() =&gt; match AlertDescription::CloseNotify {
    CloseNotify =&gt; { ... }
    UnexpectedMessage =&gt; { ... }
    BadRecordMAC =&gt; { ... }
}"><pre lang="jakt"><code>enum MyOptional&lt;T&gt; {
    Some(T)
    None
}

fn value_or_default&lt;T&gt;(anon x: MyOptional&lt;T&gt;, default: T) -&gt; T {
    return match x {
        Some(value) =&gt; {
            let stuff = maybe_do_stuff_with(value)
            let more_stuff = stuff.do_some_more_processing()
            yield more_stuff
        }
        None =&gt; default
    }
}

enum Foo {
    StructLikeThingy (
        field_a: i32
        field_b: i32
    )
}

fn look_at_foo(anon x: Foo) -&gt; i32 {
    match x {
        StructLikeThingy(field_a: a, field_b) =&gt; {
            return a + field_b
        }
    }
}

enum AlertDescription: i8 {
    CloseNotify = 0
    UnexpectedMessage = 10
    BadRecordMAC = 20
    // etc
}

// Use in match:
fn do_nothing_in_particular() =&gt; match AlertDescription::CloseNotify {
    CloseNotify =&gt; { ... }
    UnexpectedMessage =&gt; { ... }
    BadRecordMAC =&gt; { ... }
}
</code></pre></div>

<ul>
<li> Generic types</li>
<li> Constant generics (minimal support)</li>
<li> Constant generics (full support)</li>
<li> Generic type inference</li>
<li> Traits</li>
</ul>
<p dir="auto"><strong>Jakt</strong> supports both generic structures and generic functions.</p>
<div data-snippet-clipboard-copy-content="fn id&lt;T&gt;(anon x: T) -&gt; T {
    return x
}

fn main() {
    let y = id(3)

    println(&#34;{}&#34;, y + 1000)
}"><pre lang="jakt"><code>fn id&lt;T&gt;(anon x: T) -&gt; T {
    return x
}

fn main() {
    let y = id(3)

    println(&#34;{}&#34;, y + 1000)
}
</code></pre></div>
<div data-snippet-clipboard-copy-content="struct Foo&lt;T&gt; {
    x: T
}

fn main() {
    let f = Foo(x: 100)

    println(&#34;{}&#34;, f.x)
}"><pre lang="jakt"><code>struct Foo&lt;T&gt; {
    x: T
}

fn main() {
    let f = Foo(x: 100)

    println(&#34;{}&#34;, f.x)
}
</code></pre></div>
<div data-snippet-clipboard-copy-content="struct MyArray&lt;T, comptime U&gt; {
    // NOTE: There is currently no way to access the value &#39;U&#39;, referring to &#39;U&#39; is only valid as the type at the moment.
    data: [T]
}"><pre lang="jakt"><code>struct MyArray&lt;T, comptime U&gt; {
    // NOTE: There is currently no way to access the value &#39;U&#39;, referring to &#39;U&#39; is only valid as the type at the moment.
    data: [T]
}
</code></pre></div>

<ul>
<li> Namespace support for functions and struct/class/enum</li>
<li> Deep namespace support</li>
</ul>
<div data-snippet-clipboard-copy-content="namespace Greeters {
    fn greet() {
        println(&#34;Well, hello friends&#34;)
    }
}

fn main() {
    Greeters::greet()
}"><pre><code>namespace Greeters {
    fn greet() {
        println(&#34;Well, hello friends&#34;)
    }
}

fn main() {
    Greeters::greet()
}
</code></pre></div>

<p dir="auto">There are two built-in casting operators in <strong>Jakt</strong>.</p>
<ul dir="auto">
<li><code>as? T</code>: Returns an <code>Optional&lt;T&gt;</code>, empty if the source value isn&#39;t convertible to <code>T</code>.</li>
<li><code>as! T</code>: Returns a <code>T</code>, aborts the program if the source value isn&#39;t convertible to <code>T</code>.</li>
</ul>
<p dir="auto">The <code>as</code> cast can do these things (note that the implementation may not agree yet):</p>
<ul dir="auto">
<li>Casts to the same type are infallible and pointless, so might be forbidden in the future.</li>
<li>If the source type is <em>unknown</em>, the cast is valid as a type assertion.</li>
<li>If both types are primitive, a safe conversion is done.
<ul dir="auto">
<li>Integer casts will fail if the value is out of range. This means that promotion casts like i32 -&gt; i64 are infallible.</li>
<li>Float -&gt; Integer casts truncate the decimal point (?)</li>
<li>Integer -&gt; Float casts resolve to the closest value to the integer representable by the floating-point type (?). If the integer value is too large, they resolve to infinity (?)</li>
<li>Any primitive -&gt; bool will create <code>true</code> for any value except 0, which is <code>false</code>.</li>
<li>bool -&gt; any primitive will do <code>false -&gt; 0</code> and <code>true -&gt; 1</code>, even for floats.</li>
</ul>
</li>
<li>If the types are two different pointer types (see above), the cast is essentially a no-op. A cast to <code>T</code> will increment the reference count as expected; that&#39;s the preferred way of creating a strong reference from a weak reference. A cast from and to <code>raw T</code> is unsafe.</li>
<li>If the types are part of the same type hierarchy (i.e. one is a child type of another):
<ul dir="auto">
<li>A child can be cast to its parent infallibly.</li>
<li>A parent can be cast to a child, but this will check the type at runtime and fail if the object was not of the child type or one of its subtypes.</li>
</ul>
</li>
<li>If the types are incompatible, a user-defined cast is attempted to be used. The details here are not decided yet.</li>
<li>If nothing works, the cast will not even compile.</li>
</ul>
<p dir="auto">Additional casts are available in the standard library. Two important ones are <code>as_saturated</code> and <code>as_truncated</code>, which cast integral values while saturating to the boundaries or truncating bits, respectively.</p>

<p dir="auto">To make generics a bit more powerful and expressive, you can add additional information to them:</p>
<div data-snippet-clipboard-copy-content="trait Hashable&lt;Output&gt; {
    fn hash(self) -&gt; Output
}

class Foo implements(Hashable&lt;i64&gt;) {
    fn hash(self) =&gt; 42
}"><pre lang="jakt"><code>trait Hashable&lt;Output&gt; {
    fn hash(self) -&gt; Output
}

class Foo implements(Hashable&lt;i64&gt;) {
    fn hash(self) =&gt; 42
}
</code></pre></div>
<p dir="auto">Traits can be used to add constraints to generic types, but also provide default implementations based on a minimal set of requirements - for instance:</p>
<div data-snippet-clipboard-copy-content="trait Fancy {
    fn do_something(this) -&gt; void
    fn do_something_twice(this) -&gt; void {
        .do_something()
        .do_something()
    }
}

struct Boring implements(Fancy) {
    fn do_something(this) -&gt; void {
        println(&#34;I&#39;m so boring&#34;)
    }

    // Note that we don&#39;t have to implement `do_something_twice` here, because it has a default implementation.
}

struct Better implements(Fancy) {
    fn do_something(this) -&gt; void {
        println(&#34;I&#39;m not boring&#34;)
    }

    // However, a custom implementation is still valid.
    fn do_something_twice(this) -&gt; void {
        println(&#34;I&#39;m not boring, but I&#39;m doing it twice&#34;)
    }
}"><pre lang="jakt"><code>trait Fancy {
    fn do_something(this) -&gt; void
    fn do_something_twice(this) -&gt; void {
        .do_something()
        .do_something()
    }
}

struct Boring implements(Fancy) {
    fn do_something(this) -&gt; void {
        println(&#34;I&#39;m so boring&#34;)
    }

    // Note that we don&#39;t have to implement `do_something_twice` here, because it has a default implementation.
}

struct Better implements(Fancy) {
    fn do_something(this) -&gt; void {
        println(&#34;I&#39;m not boring&#34;)
    }

    // However, a custom implementation is still valid.
    fn do_something_twice(this) -&gt; void {
        println(&#34;I&#39;m not boring, but I&#39;m doing it twice&#34;)
    }
}
</code></pre></div>
<p dir="auto">Traits can have methods that reference other traits as types, which can be used to describe a hierarchy of traits:</p>
<div data-snippet-clipboard-copy-content="trait ConstIterable&lt;T&gt; {
    fn next(this) -&gt; T?
}

trait IntoIterator&lt;T&gt; {
    // Note how the return type is a reference to the ConstIterable trait (and not a concrete type)
    fn iterator(this) -&gt; ConstIterable&lt;T&gt;
}"><pre lang="jakt"><code>trait ConstIterable&lt;T&gt; {
    fn next(this) -&gt; T?
}

trait IntoIterator&lt;T&gt; {
    // Note how the return type is a reference to the ConstIterable trait (and not a concrete type)
    fn iterator(this) -&gt; ConstIterable&lt;T&gt;
}
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Operator Overloading and Traits</h3><a id="user-content-operator-overloading-and-traits" aria-label="Permalink: Operator Overloading and Traits" href="#operator-overloading-and-traits"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Operators are implemented as traits, and can be overloaded by implementing them on a given type:</p>
<div data-snippet-clipboard-copy-content="struct Foo implements(Add&lt;Foo, Foo&gt;) {
    x: i32

    fn add(this, anon rhs: Foo) -&gt; Foo {
        return Foo(x: .x + other.x)
    }
}"><pre lang="jakt"><code>struct Foo implements(Add&lt;Foo, Foo&gt;) {
    x: i32

    fn add(this, anon rhs: Foo) -&gt; Foo {
        return Foo(x: .x + other.x)
    }
}
</code></pre></div>
<p dir="auto">The relationship between operators and traits is as follows (Note that <code>@</code> is used as a placeholder for any binary operator&#39;s name or sigil):</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Operator</th>
<th>Trait</th>
<th>Method Name</th>
<th>Derived From Method</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td><code>Add</code></td>
<td><code>add</code></td>
<td>-</td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>Subtract</code></td>
<td><code>subtract</code></td>
<td>-</td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>Multiply</code></td>
<td><code>multiply</code></td>
<td>-</td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>Divide</code></td>
<td><code>divide</code></td>
<td>-</td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>Modulo</code></td>
<td><code>modulo</code></td>
<td>-</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>Compare</code></td>
<td><code>less_than</code></td>
<td><code>compare</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>Compare</code></td>
<td><code>greater_than</code></td>
<td><code>compare</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>Compare</code></td>
<td><code>less_than_or_equal</code></td>
<td><code>compare</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>Compare</code></td>
<td><code>greater_than_or_equal</code></td>
<td><code>compare</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td><code>Equal</code></td>
<td><code>equals</code></td>
<td>-</td>
</tr>
<tr>
<td><code>!=</code></td>
<td><code>Equal</code></td>
<td><code>not_equals</code></td>
<td><code>equals</code></td>
</tr>
<tr>
<td><code>@=</code></td>
<td><code>@Assignment</code></td>
<td><code>@_assign</code></td>
<td>-</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Other operators have not yet been converted to traits, decided on, or implemented:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>Bitwise And</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>|</code></td>
<td>Bitwise Or</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Bitwise Xor</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>~</code></td>
<td>Bitwise Not</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Bitwise Shift Left</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Bitwise Shift Right</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>and</code></td>
<td>Logical And</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>or</code></td>
<td>Logical Or</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>not</code></td>
<td>Logical Not</td>
<td>Not Decided</td>
</tr>
<tr>
<td><code>=</code></td>
<td>Assignment</td>
<td>Not Decided</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto"><strong>(Not yet implemented)</strong></p>
<p dir="auto">To keep things safe, there are a few kinds of analysis we&#39;d like to do (non-exhaustive):</p>
<ul dir="auto">
<li>Preventing overlapping of method calls that would collide with each other. For example, creating an iterator over a container, and while that&#39;s live, resizing the container</li>
<li>Using and manipulating raw pointers</li>
<li>Calling out to C code that may have side effects</li>
</ul>

<p dir="auto">Functions that can fail with an error instead of returning normally are marked with the <code>throws</code> keyword:</p>
<div data-snippet-clipboard-copy-content="fn task_that_might_fail() throws -&gt; usize {
    if problem {
        throw Error::from_errno(EPROBLEM)
    }
    ...
    return result
}

fn task_that_cannot_fail() -&gt; usize {
    ...
    return result
}"><pre lang="jakt"><code>fn task_that_might_fail() throws -&gt; usize {
    if problem {
        throw Error::from_errno(EPROBLEM)
    }
    ...
    return result
}

fn task_that_cannot_fail() -&gt; usize {
    ...
    return result
}
</code></pre></div>
<p dir="auto">Unlike languages like C++ and Java, errors don&#39;t unwind the call stack automatically. Instead, they bubble up to the nearest caller.</p>
<p dir="auto">If nothing else is specified, calling a function that <code>throws</code> from within a function that <code>throws</code> will implicitly bubble errors.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Syntax for catching errors</h3><a id="user-content-syntax-for-catching-errors" aria-label="Permalink: Syntax for catching errors" href="#syntax-for-catching-errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you want to catch errors locally instead of letting them bubble up to the caller, use a <code>try</code>/<code>catch</code> construct like this:</p>
<div data-snippet-clipboard-copy-content="try {
    task_that_might_fail()
} catch error {
    println(&#34;Caught error: {}&#34;, error)
}"><pre lang="jakt"><code>try {
    task_that_might_fail()
} catch error {
    println(&#34;Caught error: {}&#34;, error)
}
</code></pre></div>
<p dir="auto">There&#39;s also a shorter form:</p>
<div data-snippet-clipboard-copy-content="try task_that_might_fail() catch error {
    println(&#34;Caught error: {}&#34;, error)
}"><pre lang="jakt"><code>try task_that_might_fail() catch error {
    println(&#34;Caught error: {}&#34;, error)
}
</code></pre></div>

<p dir="auto"><strong>(Not yet implemented)</strong></p>

<p dir="auto">For better interoperability with existing C++ code, as well as situations where the capabilities of <strong>Jakt</strong> within <code>unsafe</code> blocks are not powerful enough, the possibility of embedding inline C++ code into the program exists in the form of <code>cpp</code> blocks:</p>
<div data-snippet-clipboard-copy-content="mut x = 0
unsafe {
    cpp {
        &#34;x = (i64)&amp;x;&#34;
    }
}
println(&#34;{}&#34;, x)"><pre lang="jakt"><code>mut x = 0
unsafe {
    cpp {
        &#34;x = (i64)&amp;x;&#34;
    }
}
println(&#34;{}&#34;, x)
</code></pre></div>

<p dir="auto">Values and objects can be passed by reference in some situations where it&#39;s provably safe to do so.</p>
<p dir="auto">A reference is either immutable (default) or mutable.</p>

<ul dir="auto">
<li><code>&amp;T</code> is an immutable reference to a value of type <code>T</code>.</li>
<li><code>&amp;mut T</code> is a mutable reference to a value of type <code>T</code>.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Reference expression syntax</h3><a id="user-content-reference-expression-syntax" aria-label="Permalink: Reference expression syntax" href="#reference-expression-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><code>&amp;foo</code> creates an immutable reference to the variable <code>foo</code>.</li>
<li><code>&amp;mut foo</code> creates a mutable reference to the variable <code>foo</code>.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Dereferencing a reference</h3><a id="user-content-dereferencing-a-reference" aria-label="Permalink: Dereferencing a reference" href="#dereferencing-a-reference"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To &#34;get the value out&#34; of a reference, it must be dereferenced using the <code>*</code> operator, however the compiler will automatically dereference references if the dereferencing is the single unambiguous correct use of the reference (in practice, manual dereferencing is only required where the reference is being stored or passed to functions).</p>
<div data-snippet-clipboard-copy-content="fn sum(a: &amp;i64, b: &amp;i64) -&gt; i64 {
    return a + b
    // Or with manual dereferencing:
    return *a + *b
}

fn test() {
    let a = 1
    let b = 2
    let c = sum(&amp;a, &amp;b)
}"><pre lang="jakt"><code>fn sum(a: &amp;i64, b: &amp;i64) -&gt; i64 {
    return a + b
    // Or with manual dereferencing:
    return *a + *b
}

fn test() {
    let a = 1
    let b = 2
    let c = sum(&amp;a, &amp;b)
}
</code></pre></div>
<p dir="auto">For mutable references to structs, you&#39;ll need to wrap the dereference in parentheses in order to do a field access:</p>
<div data-snippet-clipboard-copy-content="struct Foo {
    x: i64
}
fn zero_out(foo: &amp;mut Foo) {
    foo.x = 0
    // Or with manual dereferencing:
    (*foo).x = 0
}"><pre lang="jakt"><code>struct Foo {
    x: i64
}
fn zero_out(foo: &amp;mut Foo) {
    foo.x = 0
    // Or with manual dereferencing:
    (*foo).x = 0
}
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">References (first version) feature list:</h3><a id="user-content-references-first-version-feature-list" aria-label="Permalink: References (first version) feature list:" href="#references-first-version-feature-list"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul>
<li> Reference types</li>
<li> Reference function parameters</li>
<li> Local reference variables with basic lifetime analysis</li>
<li> No references in structs</li>
<li> No references in return types</li>
<li> No mutable references to immutable values</li>
<li> Allow <code>&amp;foo</code> and <code>&amp;mut foo</code> without argument label for parameters named <code>foo</code></li>
<li> Auto-dereference references where applicable</li>
</ul>

<ul>
<li> (<code>unsafe</code>) references and raw pointers bidirectionally convertible</li>
<li> No capture-by-reference in persistent closures</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Closures (first version) feature list:</h3><a id="user-content-closures-first-version-feature-list" aria-label="Permalink: Closures (first version) feature list:" href="#closures-first-version-feature-list"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul>
<li> Function as parameter to function</li>
<li> Functions as variables</li>
<li> No returning functions from functions</li>
<li> Lambdas can throw</li>
<li> Explicit captures</li>
</ul>

<ul>
<li> Return function from function</li>
</ul>

<p dir="auto">Compiletime Function Execution (or CTFE) in Jakt allows the execution of any jakt function at compiletime, provided that the result value
may be synthesized using its fields - currently this only disallows a few prelude objects that cannot be constructed by their fields (like Iterator objects and StringBuilders).</p>
<p dir="auto">Any regular Jakt function can be turned into a compiletime function by replacing the <code>function</code> keyword in its declaration with the <code>comptime</code> keyword, which will force all calls to that specific function to be evaluated at compile time.</p>

<p dir="auto">Comptime functions may only be invoked by constant expressions; this restriction includes the <code>this</code> object of methods.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Throwing in a comptime context</h3><a id="user-content-throwing-in-a-comptime-context" aria-label="Permalink: Throwing in a comptime context" href="#throwing-in-a-comptime-context"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Throwing behaves the same way as normal error control flow does, if the error leaves the comptime context (by reaching the original callsite), it will be promoted to a compilation error.</p>

<p dir="auto">Currently all prelude functions with side effects behave the same as they would in runtime. This allows e.g. pulling in files into the binary; some functions may be changed later to perform more useful actions.</p>

<p dir="auto">It is possible to design custom import handling based on data available at compile time. An excellent example of this in the Jakt compiler is the <a href="https://github.com/SerenityOS/jakt/blob/main/selfhost/os.jakt#L41">Platform Module</a>.</p>
<p dir="auto">See a smaller example in the <a href="https://github.com/SerenityOS/jakt/blob/main/samples/modules/comptime_imports.jakt">comptime imports sample</a>.</p>

<ul>
<li> Implement execution of all Jakt expressions</li>
</ul>
</article></div></div>
  </body>
</html>
