<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.vladzahorodnii.com/2024/10/28/improving-xwayland-window-resizing/">Original</a>
    <h1>Improving Xwayland window resizing</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1217">
	
	<!-- .entry-header -->

	<div>
		
<p>One of the quickest ways to determine whether particular application runs using Xwayland is to resize one of its windows and see how it behaves, for example</p>



<figure></figure>



<p>While it can be handy for the debugging purposes, overall, it makes the Plasma Wayland session look less polished. So, one of the goals for 6.3 was to fix this visual glitch.</p>



<p>This article will provide some background behind what caused the glitch and how we addressed it. Just in case, here’s the same application, which was shown in a screen cast above, but with the corresponding resizing fixes in:</p>



<figure></figure>



<h2>X11 frame synchronization protocol(s)</h2>



<p>On X11, all window changes typically take place immediately, including resizing. This can lead to some issues. For example, if a window is resized, it can take a while until the application repaints the window with the new size. What if the compositing manager decides to compose the screen in meanwhile? You’re likely going to see some sort of visual glitches, e.g. the window contents getting cropped or seeing parts of the window that have not been repainted yet.</p>



<p>In order to address this issue, there exists an X11 protocol to synchronize window repaints during interactive resize. An application/client wishing to participate in this protocol needs to list <code>_NET_WM_SYNC_REQUEST</code> in the <code>WM_PROTOCOLS</code> property of the client window and also set the <code>XID</code> of the XSync counter in the <code>_NET_WM_SYNC_REQUEST_COUNTER</code> property. When the WM wants to resize the window, the following will happen:</p>



<figure><img data-recalc-dims="1" fetchpriority="high" decoding="async" width="660" height="463" data-attachment-id="1218" data-permalink="https://blog.vladzahorodnii.com/2024/10/28/improving-xwayland-window-resizing/basic-sync/" data-orig-file="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?fit=2254%2C1582&amp;ssl=1" data-orig-size="2254,1582" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="basic-sync" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?fit=300%2C211&amp;ssl=1" data-large-file="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?fit=660%2C463&amp;ssl=1" tabindex="0" role="button" src="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=660%2C463&amp;ssl=1" alt="" srcset="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=1024%2C719&amp;ssl=1 1024w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=300%2C211&amp;ssl=1 300w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=768%2C539&amp;ssl=1 768w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=1536%2C1078&amp;ssl=1 1536w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=2048%2C1437&amp;ssl=1 2048w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=1200%2C842&amp;ssl=1 1200w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?resize=388%2C272&amp;ssl=1 388w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?w=1320&amp;ssl=1 1320w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/basic-sync.png?w=1980&amp;ssl=1 1980w" sizes="(max-width: 660px) 100vw, 660px"/></figure>



<ol>
<li>The window manager sends a <code>_NET_WM_SYNC_REQUEST</code> client message containing a serial that the client will need to put in the XSync counter after processing a <code>ConfigureNotify</code> event that will be generated after the window is resized. The compositing manager and the window manager will block window updates until the XSync request acknowledgement is received;</li>



<li>The WM resizes the client window, for example by calling the <code>xcb_configure_window()</code> function;</li>



<li>The client would then repaint the window with the new size and update the XSync counter with the serial that it had received in step 1;</li>



<li>The window manager and the compositing manager unblock window updates after receiving receiving the XSync request acknowledgement. For example, now, the window can be repainted by the compositing manager and there shouldn’t be glitches as long as the client behaves well.</li>
</ol>



<p>Note that the window manager and the compositing manager are often the same. For example, both KWin and Mutter are compositing managers <em>and</em> window managers.</p>



<p>The frame synchronization protocol described above is called <em>basic frame synchronization</em> protocol. There is also an <em>extended frame synchronization</em> protocol, but it is not standardized and it is implemented only by a few compositing managers.</p>



<h2><code>_NET_WM_SYNC_REQUEST</code> and Xwayland</h2>



<p>KWin supports the basic frame synchronization protocol, so there should be no visual glitches when resizing X11 windows in the Plasma Wayland session, right? At quick glance, yes, but we forget about the most important detail: Wayland compositors don’t use <code>XCompositeNameWindowPixmap()</code> or <code>xcb_composite_name_window_pixmap()</code> to grab the contents of X11 windows, instead they rely on Xwayland attaching graphics buffers to <code>wl_surface</code> objects, so there is no strict order between the Wayland compositor receiving an XSync request acknowledgement and graphics buffers for the new window size.</p>



<p>In order to help better understand the issue, let’s consider a concrete example. Assume that a window with geometry <code>0,0 100x100</code> is being resized by dragging its left edge. If the left edge is dragged <code>10</code>px to the right, the following will happen:</p>



<ol>
<li>A <code>_NET_WM_SYNC_REQUEST</code> client message will be sent to the client containing the XSync counter serial that must be set after processing the <code>ConfigureNotify</code> event that will be generated after the Wayland compositor calls <code>xcb_configure_window()</code> with the new window size;</li>



<li>The Wayland compositor calls <code>xcb_configure_window()</code> to actually resize the window;</li>



<li>The client receives the sync request client message and the ConfigureNotify event, repaints the window, and acknowledges the sync request;</li>



<li>The Wayland compositor receives the sync request acknowledgement and updates the window position to <code>10,0</code>.</li>
</ol>



<p>But here is the problem, when the window position is updated to 10,0, it’s not guaranteed that the <code>wl_surface</code> associated with the X11 window has a buffer with the new window size, i.e. <code>90x100</code>. It can take a while until Xwayland commits a graphics buffer with the right size. In meanwhile, the compositor could compose the next frame with the new window position, i.e. <code>10,0</code>, but old surface size, i.e. <code>100x100</code>. It would look as if the right window edge sticks out of the window decoration. After Xwayland attaches a buffer with the right size, the right window edge will correct itself.</p>



<p>So, ideally, the Wayland compositor should update the window position after receiving the XSync request acknowledgement <em>and</em> Xwayland attaching a new graphics buffer to the <code>wl_surface</code>.</p>



<p>With that in mind, the frame synchronization procedure looks as follows:</p>



<figure><img data-recalc-dims="1" decoding="async" width="660" height="628" data-attachment-id="1219" data-permalink="https://blog.vladzahorodnii.com/2024/10/28/improving-xwayland-window-resizing/new-sync/" data-orig-file="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?fit=2232%2C2122&amp;ssl=1" data-orig-size="2232,2122" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="new-sync" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?fit=300%2C285&amp;ssl=1" data-large-file="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?fit=660%2C628&amp;ssl=1" tabindex="0" role="button" src="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=660%2C628&amp;ssl=1" alt="" srcset="https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=1024%2C974&amp;ssl=1 1024w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=300%2C285&amp;ssl=1 300w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=768%2C730&amp;ssl=1 768w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=1536%2C1460&amp;ssl=1 1536w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=2048%2C1947&amp;ssl=1 2048w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=1200%2C1141&amp;ssl=1 1200w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?resize=286%2C272&amp;ssl=1 286w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?w=1320&amp;ssl=1 1320w, https://i0.wp.com/blog.vladzahorodnii.com/wp-content/uploads/2024/10/new-sync.png?w=1980&amp;ssl=1 1980w" sizes="(max-width: 660px) 100vw, 660px"/></figure>



<ol>
<li>The compositor blocks <code>wl_surface</code> commits by setting the <code>_XWAYLAND_ALLOW_COMMITS</code> property to <code>0</code> for the toplevel X11 window. This is needed to ensure the consistent order between XSync request acknowledgements and <code>wl_surface</code> commits. As long as the <code>_XWAYLAND_ALLOW_COMMITS</code> property is set to <code>0</code>, Xwayland will not attempt to commit the wayland surface, for example attach a new graphics buffer after the client repaints the window;</li>



<li>The compositor sends a <code>_NET_WM_SYNC_REQUEST</code> client message as before;</li>



<li>The compositor resizes the client window as before;</li>



<li>The client repaints the window and acknowledges the XSync request as before;</li>



<li>After receiving the XSync acknowledgement, the compositor unblocks surface commits by setting the <code>_XWAYLAND_ALLOW_COMMITS</code> property to <code>1</code>. Note that the window updates are still blocked, i.e. the window position is not updated yet;</li>



<li>After Xwayland commits the <code>wl_surface</code> with a new graphics buffer, the window updates are unblocked, e.g. the window position is updated.</li>
</ol>



<p>The frame synchronization process looks more involved with Xwayland, but it is still manageable.</p>



<h2><code>_NET_WM_SYNC_REQUEST</code> support in applications</h2>



<p>Most applications that use GTK and Qt support <code>_NET_WM_SYNC_REQUEST</code>, but there are applications that don’t participate in the frame synchronization protocol. If you use one of those apps, you <strong>will observe visual glitches</strong> during interactive resize.</p>



<h2>Closing words</h2>



<p>Frame synchronization is a difficult problem, and requires some very intricate code both on the compositor and the client side. But with the changes that we’ve made, I’m proud to say that KWin is one of the few compositors that properly handles frame synchronization for X11 windows on Wayland.</p>



<p>I would also like to express many thanks to the Xwayland developers (Michel Dänzer and Olivier Fourdan) for <a href="https://gitlab.freedesktop.org/xorg/xserver/-/issues/1743">helping and assisting us</a> with fixing the glitch.</p>

	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
