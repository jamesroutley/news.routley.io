<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://debamitro.github.io/blog/karpathian-classification-of-software/">Original</a>
    <h1>Karpathian Classification of Software</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>In a <a href="https://youtu.be/LCEmiRjPEtQ?si=NAu70uEImlH4BZsj">recent speech</a>, <a href="https://karpathy.ai">Andrej Karpathy</a> has classified software into three broad categories. I have been thinking a lot about them. Here are my reflections on this topic.</p>
<h2 id="definition">Definition</h2>
<table>
  <thead>
      <tr>
          <th>Software 1.0</th>
          <th>Software 2.0</th>
          <th>Software 3.0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Needs a step-by-step algorithm, where it is told exactly what to do</td>
          <td>Can be trained to do tasks which donâ€™t have an exact definition</td>
          <td>Can learn on the fly and perform tasks based on prompts</td>
      </tr>
  </tbody>
</table>
<h2 id="examples-of-the-three-categories">Examples of the three categories</h2>
<table>
  <thead>
      <tr>
          <th>Software 1.0</th>
          <th>Software 2.0</th>
          <th>Software 3.0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Can draw geometric shapes</td>
          <td>Can draw a cat</td>
          <td>Can draw an imaginary animal based on a description</td>
      </tr>
  </tbody>
</table>
<p>As you can see, software 1.0 has been around since the mid-20th century, software 2.0 was impossible for a very long time. Tremendous advances in hardware, and multiple theoretical breakthroughs in machine learning made neural networks commonplace - which is what software 2.0 is. Software 3.0 is the most recent category. It is a way to provide a â€˜promptâ€™ to a certain kind of software 2.0 which can â€™learnâ€™, â€™thinkâ€™, and behave in a possibly new way.</p>
<h2 id="how-to-build-these">How to build these</h2>
<table>
  <thead>
      <tr>
          <th>Software 1.0</th>
          <th>Software 2.0</th>
          <th>Software 3.0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Express the algorithm in a programming language</td>
          <td>Create a dataset, and choose a training method</td>
          <td>Write what you want, in plain English</td>
      </tr>
  </tbody>
</table>
<p>The third column shows how insanely powerful software 3.0 is. It has opened up the field of software development to everyone who knows English. Which means, very soon every human being would be a software 3.0 programmer - because almost all spoken languages can be translated to English.</p>
<h2 id="when-to-choose-a-particular-category">When to choose a particular category</h2>
<p>As of now software 3.0 has caught fire ðŸ”¥. It is called â€˜prompt engineeringâ€™, and also â€˜vibe codingâ€™ in the case of software creation. Perhaps it will be the first approach to use in software creation. Weâ€™ll go over to software 2.0 or software 1.0 only when software 3.0 is not helping us. Or, maybe not. Letâ€™s look at some pros and cons.</p>
<h3 id="pros">Pros</h3>
<table>
  <thead>
      <tr>
          <th>Software 1.0</th>
          <th>Software 2.0</th>
          <th>Software 3.0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Easier to reason about, very reliable. Uses fewer hardware resources, hence power-efficient</td>
          <td>Can do things which are impossible with software 1.0. Closer to the human brain</td>
          <td>Much faster than software 2.0, and still retains the advantage over software 1.0. Also, more creative.</td>
      </tr>
  </tbody>
</table>
<h3 id="cons">Cons</h3>
<table>
  <thead>
      <tr>
          <th>Software 1.0</th>
          <th>Software 2.0</th>
          <th>Software 3.0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Cannot learn</td>
          <td>Takes a lot of hardware resources to learn, also takes time</td>
          <td>Less predictable</td>
      </tr>
  </tbody>
</table>
<p>It is clear that software 1.0 is the way to go if the task can be defined in steps, and also if we want to save money. While software 2.0 and software 3.0 keep pushing the boundary of what is possible. For example, creating new kinds of software is being done using software 3.0. However, software 3.0 need not be used to create a boilerplate project - something that has a defined structure. This is an easy trap to fall into, if you are mostly interacting with a software 3.0 chat window. Just the other day I caught myself using AI to create a basic expressjs project.</p>
<h2 id="the-future">The future</h2>
<p>Will there be a software 4.0? Maybe it will be something that can create new software 2.0. On the other hand, we might discover predictable algorithms for some software 2.0 tasks and then theyâ€™ll come down to the level of software 1.0.</p>
<p>Another way to think about the future is that hardware was the OG software 1.0. When software 1.0 arrived it looked vastly superior to hardware. Now we are blown away by software 3.0 a.k.a. prompt engineering. Maybe we are gradually climbing a ladder of increasing â€˜intelligenceâ€™, starting from transistors and ending at prompts today.</p>
<p>One thing is certain - all the three categories of software are going to be important and useful.
And every software x.0 uses software (x-1).0 under the hood. So it is not possible to do anything without using software 1.0 under the hood. Just like it is not possible to run anything without hardware.</p>

      </div></div>
  </body>
</html>
