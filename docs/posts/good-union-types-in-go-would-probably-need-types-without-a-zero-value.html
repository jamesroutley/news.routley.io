<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoUnionTypesAndZeroValues">Original</a>
    <h1>Good union types in Go would probably need types without a zero value</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Good union types in Go would probably need types without a zero value</h2>

	<p><small>December  2, 2024</small></p>
</div><div><p>One of the classical big reason to want <a href="https://en.wikipedia.org/wiki/Union_type">union types</a> in Go is so that one can
implement the general pattern of an <a href="https://en.wikipedia.org/wiki/Option_type">option type</a>, in order to force
people to deal explicitly with null values. Except this is not quite
true on both sides. <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/OptionTypesIndirectPower">The compiler can enforce null value checks
before use already</a>, and union and option
types by themselves don&#39;t fully protect you against null values.
Much like people ignore error returns (and the Go compiler allows
this), people can skip over that they can&#39;t extract an underlying
value from their Result value and return a zero value from their
&#39;get a result&#39; function.</p>

<p><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/OptionTypesIndirectPower">My view is that the power of option types is what they do in the
rest of the language</a>, but they can only
do this if you can express their guarantees in the type system. The
important thing you need for this is non-nullable types. This is
what lets you guarantee that something is a proper value extracted
from an error-free Result or whatever. If you can&#39;t express this
in your types, everyone has to check, one way or another, or you
risk a null sneaking in.</p>

<p>Go doesn&#39;t currently have a type concept for &#39;something that can&#39;t
be null&#39;, or for that matter a concept that is exactly &#39;null&#39;. The
closest Go equivalent is the general idea of zero values, of which
nil pointers (and nil interfaces) are a special case (but you can
also have zero value maps and channels, which also have special
semantics; the zero value of slices is more normal). If you want
to make Result and similar types particularly useful in Go, I believe
that you need to change this, somehow introducing types that don&#39;t
have a zero value.</p>

<p>(Such types would likely be a variation of existing types with zero
values, and presumably you could only use values or assign to
variables of that type if the compiler could prove that what you
were using or assigning wasn&#39;t a zero value.)</p>

<p>As noted in a comment by loreb on <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoUnionTypesComplexities">my entry on how union types
would be complicated</a>, these &#39;union&#39; or
&#39;sum&#39; types in Go <a href="https://github.com/golang/go/issues/57644#issuecomment-2014347541">also run into issues with their zero value</a>, and
as Ian Lance Taylor&#39;s issue comment says, zero values are built
quite deeply into Go. You can define semantics for union types that
allow zero values, but I don&#39;t think they&#39;re really particularly
useful for anything except cramming some data structures into a few
less bytes in a somewhat opaque way, and I&#39;m not sure that&#39;s something
Go should be caring about.</p>

<p>Given that zero values are a deep part of Go and the Go developers
don&#39;t seem particularly interested in trying to change this, I doubt
that we&#39;re ever going to get the powerful form of union types in
Go. If anything like union types appears, it will probably be merely
to save memory, and even then <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoUnionTypesComplexities">union types are complicated in Go&#39;s
runtime</a>.</p>

<h3>Sidebar: the simple zero value allowed union type semantics</h3>

<p>If you allow union types to have a zero value, the obvious meaning
of a zero value is something that can&#39;t have a value of any type
successfully extracted from it. If you try the union type equivalent
of a <a href="https://go.dev/ref/spec#Type_assertions">type assertion</a> you
get a zero value and &#39;false&#39; for all possible options. Of course this
completely gives up on the &#39;no zero value&#39; type side of things, but
at least you have a meaning.</p>

<p>This makes a zero value union very similar to a nil interface, which
will also fail all type assertions. At this point my feeling is
that Go might as well stick with interfaces and not attempt to
provide union types.</p>
</div></div>
  </body>
</html>
