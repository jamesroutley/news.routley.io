<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/06/11/fsr/">Original</a>
    <h1>Some early results for feed reader behavior monitoring</h1>
    
    
<p>
I&#39;ve had a few people ask me for results from the
<a href="https://rachelbythebay.com/w/2024/05/30/fs/">feed reader score</a>
project.  It&#39;s been long enough to where I can start giving some 
details, now that we&#39;ve had a good week or more of data collection.
</p>
<p>
There&#39;s one big thing to keep in mind here: I am assessing individual 
feed reader installations, including whatever config values the user 
might have set globally or on the test feed in particular.  Those config 
values can be the difference between &#34;amazing&#34; and &#34;get it away from 
me&#34;.
</p>
<p>
That means a single good entry doesn&#39;t necessarily mean that every 
install of that program will behave perfectly.  It also means that a 
single bad entry doesn&#39;t mean that all of them will be terrible.
</p>
<p>
I&#39;ve broken them down into a few groups.
</p>
<p>
Group A: No real complaints.  They do their jobs quietly and don&#39;t make 
messes.  Anomalies, if any, don&#39;t seem systemic and are probably just 
the result of the user clicking the &#34;poll now&#34; button (or equivalent).  
This is expected.
</p>
<p>
Group B: They tend to do spammy unconditional requests at startup, and 
usually at a needlessly fast rate, too - like less than a second apart.
This is what most entries in group B have, and if that&#39;s their only 
problem, then fixing that would move most of them into group A.  (There 
can be other small anomalies which put something here).
</p>
<p>
Group X: Unusable data.  This can be because there&#39;s hasn&#39;t been enough 
data collected yet, like if someone just started it up, or if they shut 
it off before it ran for several days.  It can also happen when someone 
points multiple feed reader instances (same version or not) at their 
unique tagged feed, or if they load it with a browser, curl, or similar.  
</p>
<p>
Groups C, D, and F: Everything else (and I&#39;m not identifying who&#39;s who, 
or what groups they might be in).
</p>
<p>
A few minutes ago, I went through all of the tests one by one and came 
up with my own assessment based on the available data.  Ordering within 
a group is not meaningful.
</p>
<p>
Group A: instances of:
</p>
<ul>
<li>awkbot</li>
<li>rawdog</li>
<li>Awasu/3.3PE</li>
<li>walrss/0.3.7</li>
<li>Mojolicious (Perl)</li>
<li>com.vanniktech.rssreader:1.40.5, 1.40.6</li>
<li>Broadsheet/0.1</li>
<li>feedbase-fetcher.pl/0.5</li>
<li>... something unknown that claims to be a web browser</li>
</ul>
<p>
Group B: instances of:
</p>
<ul>
<li>Liferea/1.15.3</li>
<li>NewsBlur</li>
<li>FreshRSS/1.23.1</li>
<li>bdrss/4.0</li>
<li>... some unknown Thunderbird extension</li>
<li>... another thing claiming to be a web browser</li>
</ul>
<p>
Anything not shown here is not being tested or is in another group, or I 
screwed something up and missed it.  Contact me if you think I skipped 
your entry.
</p>
<p>
I should mention that there are a more than a couple of systemic bugs
have been found across multiple reader programs:
</p>
<p>
Bug: It&#39;s entirely possible for a feed&#39;s Last-Modified value (seconds) 
to remain the same while the ETag (length + microseconds on stock 
Apache) changes.  More than a few feed readers assume if they get the 
same value for Last-Modified, then they don&#39;t have to update the cached 
ETag value.  This causes them to effectively make unconditional 
requests until the feed changes again.  Watch out for shortcut 
evaluations in your caching code!
</p>
<p>
Bug: If-Modified-Since is only really valid if you were served it as a 
Last-Modified value previously.  Readers are inventing values, or are 
sourcing them from the wrong layer of the stack.  Don&#39;t do this.  
</p>
<p>
Only use the last Last-Modified value for If-Modified-Since, and only 
use the last ETag value for If-None-Match.
</p>
<p>
Bug: Timing is too tight, and they aren&#39;t accounting for how long it 
takes to perform a poll.  I&#39;ll probably do a separate post about this 
since it comes up in other things in the world, too.
</p>
<p>
Bug: Launching multiple identical requests at feed init time, and 
usually in a volley that triggers rate-limiting.  There&#39;s something 
wrong with the network I/O design when this happens.  Calls across the 
network are not &#34;free&#34; and should be executed sparingly.  Don&#39;t discard 
the values only to fetch them again a moment later.
</p>

  </body>
</html>
