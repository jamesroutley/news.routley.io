<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.langworth.com/vim3">Original</a>
    <h1>Vim After 15 Years (2017)</h1>
    
    <div id="readability-page-1" class="page"><article><p>My earlier posts (<a href="https://blog.langworth.com/vim.html">1</a>, <a href="https://blog.langworth.com/vim2.html">2</a>) about using Vim were well received and it’s about time for an update. Vim 8 added a lot of much-needed functionality, and new community sites like <a href="https://vimawesome.com/">VimAwesome</a> have made plugin discovery and evaluation easier. I’ve been doing a lot more work with Vim lately and have spent some time configuring my workflow for <em>peak efficiency</em>, so here’s a snapshot of my current state.</p>
<p>TL;DR:</p>
<ul>
<li>fzf and fzf.vim for finding files</li>
<li>ack.vim and <code>ag</code> for searching files</li>
<li>Vim + tmux is the key to victory 🔑</li>
<li>ALE is the new Syntastic because it’s asynchronous</li>
<li>…and lots more. Keep reading.</li>
</ul>
<figure>
<a href="https://static.langworth.com/vim/vim3.png"><img src="https://static.langworth.com/vim/vim3.png"/></a>
<figcaption>A recent Vim session</figcaption>
</figure>
<p>As always, my <a href="https://github.com/statico/dotfiles/">dotfiles</a> and <a href="https://github.com/statico/dotfiles/blob/master/.vim/vimrc">vimrc</a> are available publicly. I also have a separate <a href="https://github.com/statico/dotfiles/blob/master/.vim/update.sh">install script</a> for updating and installing Vim plugins.</p>
<h2 id="fzf"><a aria-hidden="true" tabindex="-1" href="#fzf"><span></span></a>fzf</h2>
<p>TextMate and Sublime Text showed us that the fastest way to find a file is by <em>fuzzy finding</em>, which means typing parts of a filename or path or tag or whatever you’re looking for, sometimes even if the characters aren’t adjacent or you making a spelling error. Fuzzy-finding is so useful that it’s become a standard feature on modern text editors.</p>
<p>For years <a href="https://vimawesome.com/plugin/ctrlp-vim-everything-has-changed">Ctrl-P</a> has been the reigning fuzzy-finding champ, but a new tool, <a href="https://github.com/junegunn/fzf">fzf</a>, is faster and more forgiving when trying to find one file or tag among thousands. Ctrl-P used to do okay on a 30,000-file codebase on my 2013-era MacBook Pro but started to slow down during a search on an enormous tags file to the point of being unusable. fzf, however, shows no speed difference between files or tags — it’s blazingly fast either way.</p>
<figure>
<video loop="" muted="" controls="" poster="https://static.langworth.com/vim/vim3-fzf.jpg" src="https://static.langworth.com/vim/vim3-fzf.mp4"></video>
</figure>
<p>Getting started with fzf is easy. Simply follow the <a href="https://github.com/junegunn/fzf#installation">installation instructions</a> (basically <code>brew install fzf</code> on macOS with <a href="https://brew.sh/">Homebrew</a>) and install the additional <a href="https://github.com/junegunn/fzf.vim">fzf.vim</a> plugin for badass lightspeed functionality.</p>
<p>fzf comes with a basic Vim plugin but its functionality is minimal, so <a href="https://github.com/junegunn/fzf.vim">fzf.vim</a> was created to provide all of the functionality you would expect. The most useful commands are <code>:Buffers</code>, <code>:Files</code>, and <code>:Tags</code>, which I’ve bound to <kbd>;</kbd> and <kbd>,</kbd><kbd>t</kbd> and <kbd>,</kbd><kbd>r</kbd> respectively:</p>
<pre><code>nmap <span>;</span> <span>:</span>Buffers<span>&lt;</span>CR<span>&gt;</span>
nmap <span>&lt;</span>Leader<span>&gt;</span><span>t</span> <span>:</span>Files<span>&lt;</span>CR<span>&gt;</span>
nmap <span>&lt;</span>Leader<span>&gt;</span><span>r</span> <span>:</span>Tags<span>&lt;</span>CR<span>&gt;</span>
</code></pre>
<p>Binding <kbd>;</kbd> is important because I live and breathe buffers. I practically never use tabs — more on that later — so it’s important that I can switch my focus to something I’m thinking of with as little friction as possible.</p>
<p>When using fzf, make sure to tell it to use <code>ag</code>, a <code>grep</code>/<code>ack</code> replacement called the <a href="https://github.com/ggreer/the_silver_searcher">Silver Searcher</a>. ag will in respect your <code>.gitignore</code> and your <code>.agignore</code> files so you no longer need to keep a giant <code>wildignore</code> string in your <code>vimrc</code>.</p>
<p>fzf works in the shell as well and comes with bindings for Zsh, Bash, and the Fish shell. In Zsh, I can hit <kbd>Ctrl-t</kbd> to instantly fuzzy-find any file in the current directory. And since I’ve configured fzf to use <code>ag</code>, it’ll ignore anything excluded by <code>.gitignore</code>. It’s glorious.</p>
<p>Here’s the snippet from my <a href="https://github.com/statico/dotfiles/blob/340c01d0970bc2cd6a27284ddb87774131c00e5c/.zshrc#L812-L829">.zshrc</a>. The <code>FZF</code> environment variables are also used when fzf is called from within Vim:</p>
<pre><code>
<span>if</span> <span>[</span> -e /usr/local/opt/fzf/shell/completion.zsh <span>]</span><span>;</span> <span>then</span>
  <span>source</span> /usr/local/opt/fzf/shell/key-bindings.zsh
  <span>source</span> /usr/local/opt/fzf/shell/completion.zsh
<span>fi</span>


<span>if</span> <span>[</span> -e ~/.fzf <span>]</span><span>;</span> <span>then</span>
  _append_to_path ~/.fzf/bin
  <span>source</span> ~/.fzf/shell/key-bindings.zsh
  <span>source</span> ~/.fzf/shell/completion.zsh
<span>fi</span>


<span>if</span> _has fzf <span>&amp;&amp;</span> _has ag<span>;</span> <span>then</span>
  <span>export</span> <span>FZF_DEFAULT_COMMAND</span><span>=</span><span>&#39;ag --nocolor -g &#34;&#34;&#39;</span>
  <span>export</span> <span>FZF_CTRL_T_COMMAND</span><span>=</span><span>&#34;<span>$FZF_DEFAULT_COMMAND</span>&#34;</span>
  <span>export</span> <span>FZF_ALT_C_COMMAND</span><span>=</span><span>&#34;<span>$FZF_DEFAULT_COMMAND</span>&#34;</span>
  <span>export</span> <span>FZF_DEFAULT_OPTS</span><span>=</span><span>&#39;
  --color fg:242,bg:236,hl:65,fg+:15,bg+:239,hl+:108
  --color info:108,prompt:109,spinner:108,pointer:168,marker:168
  &#39;</span>
<span>fi</span>
</code></pre>
<p>I was going to write about how the one big drawback to fzf is that it’s an external command and doesn’t work with MacVim, but now it does! Support has been <a href="https://github.com/junegunn/fzf.vim/issues/416#issuecomment-327982805">recently added</a> by using <a href="https://vimhelp.appspot.com/terminal.txt.html">the new native terminals in Vim 8</a>. It works well but is much slower than the terminal in large codebases (~1m files).</p>
<h3 id="an-aside-on-fuzzy-finding"><a aria-hidden="true" tabindex="-1" href="#an-aside-on-fuzzy-finding"><span></span></a>An aside on fuzzy-finding</h3>
<p>While FZF and Ctrl-P and other editors support fuzzy searching for pathnames, I’m really hoping that someone will create a first-character search for Vim. In IntelliJ, for example, if you want to open the class <code>FooFactoryGeneratorBean</code> you hit <kbd>Cmd-o</kbd> and type <kbd>F</kbd><kbd>F</kbd><kbd>G</kbd><kbd>B</kbd><kbd>Enter</kbd> to open it (the first letter of each part of the class name). This would be great for searching tags since class names are often camel no matter which language you’re writing. Maybe it could treat characters before underscores as the first character so typing something like <kbd>f</kbd><kbd>b</kbd><kbd>b</kbd><kbd>q</kbd> would highlight a file like <code>foo_bar_baz_quux.js</code>.</p>
<h2 id="searching--the-quickfix-window"><a aria-hidden="true" tabindex="-1" href="#searching--the-quickfix-window"><span></span></a>Searching &amp; the QuickFix window</h2>
<p><code>ag</code> is the new <code>ack</code>, which was the new <code>grep</code>. The best way to use <code>ag</code> from within Vim seems to be <a href="https://vimawesome.com/plugin/ack-vim">ack.vim</a>, which is misleading since <a href="https://github.com/rking/ag.vim/issues/124#issuecomment-227038003">ag.vim is deprecated</a>, but ack.vim supports both <code>ack</code> and <code>ag</code>.</p>
<p>ack.vim gives you an <code>:Ack</code> command, which takes arguments in the same way as running <code>ag</code> from the command line, except that it opens the QuickFix window with the list of search results:</p>
<figure>
<video loop="" muted="" controls="" poster="https://static.langworth.com/vim/vim3-ack.jpg" src="https://static.langworth.com/vim/vim3-ack.mp4"></video>
</figure>
<p>Note that <code>:Ack</code> will jump to the first result in the QuickFix list by default. If you dislike this, use <code>:Ack!</code>, or reverse the functionality of the two commands <a href="https://github.com/mileszs/ack.vim#i-dont-want-to-jump-to-the-first-result-automatically">per the docs</a>.</p>
<p>(Somewhat confusingly, <code>fzf.vim</code> adds a <code>:Ag</code> command, which uses fzf to search with ag interactively. I bound it to <kbd>,</kbd><kbd>a</kbd> to try it out. I haven’t found it very useful, but it’s kind of cool.)</p>
<p>Once results are in the QuickFix window, the most straightforward way to use it is by moving the cursor there and hitting <kbd>Enter</kbd> to open a result. There are also the <code>:cnext</code> and <code>:cprev</code> commands to move and up down the results list, and I tried to find a cross-platform keybinding I liked for these for a while, but failed. Then I discovered <a href="https://vimawesome.com/plugin/unimpaired-vim">vim-unimpaired</a> which adds useful bindings like <kbd>[</kbd><kbd>q</kbd> and <kbd>]</kbd><kbd>q</kbd> for <code>:cprev</code> and <code>:cnext</code>. vim-unimpaired actually has a lot more bindings for next/previous pairs, like navigating compiler/linter errors and toggling common options like line numbers, that I’d argue should be built into Vim.</p>
<p>Using the QuickFix window for search results so useful that I wrote a few bindings which search for the current word under the cursor. As much as <code>exhuberant-ctags</code> tries to find tags in Ruby and CoffeeScript, sometimes you just need to search for the word that you’re staring at:</p>
<pre><code>nmap <span>&lt;</span>M<span>-</span><span>k</span><span>&gt;</span>    <span>:</span>Ack<span>!</span> <span>&#34;\b&lt;cword&gt;\b&#34;</span> <span>&lt;</span>CR<span>&gt;</span>
nmap <span>&lt;</span>Esc<span>&gt;</span><span>k</span>   <span>:</span>Ack<span>!</span> <span>&#34;\b&lt;cword&gt;\b&#34;</span> <span>&lt;</span>CR<span>&gt;</span>
nmap <span>&lt;</span>M<span>-</span>S<span>-</span><span>k</span><span>&gt;</span>  <span>:</span>Ggrep<span>!</span> <span>&#34;\b&lt;cword&gt;\b&#34;</span> <span>&lt;</span>CR<span>&gt;</span>
nmap <span>&lt;</span>Esc<span>&gt;</span>K   <span>:</span>Ggrep<span>!</span> <span>&#34;\b&lt;cword&gt;\b&#34;</span> <span>&lt;</span>CR<span>&gt;</span>
</code></pre>
<p>Finally, after I’m done searching and navigating, I usually hit <kbd>\</kbd><kbd>x</kbd> (bound to <code>:cclose</code>) to close the QuickFix window. I’ll probably need to navigate back to the file I was looking at before starting the search so I usually hit <kbd>Ctrl-o</kbd> a few times, which <a href="https://vimhelp.appspot.com/motion.txt.html#CTRL-O">jumps backward in the jump list</a> and is kind of like hitting the Back button in a browser. Other times I’ll use <kbd>;</kbd> to bring up the buffer list and find the original file there. But now that I’m thinking about it, maybe I’ll modify the binding set a <a href="https://vimhelp.appspot.com/motion.txt.html#%270">global mark</a> in my <kbd>Meta-k</kbd> binding, like <code>o</code>, so that <kbd>’</kbd><kbd>O</kbd> will always take me back to where I started.</p>
<h2 id="terminals-panes-and-multiplexing"><a aria-hidden="true" tabindex="-1" href="#terminals-panes-and-multiplexing"><span></span></a>Terminals, panes, and multiplexing</h2>
<p>I mentioned before that I’m not a frequent gvim/MacVim user. I strongly prefer to work in a terminal, but there are some good reasons to use a standalone Vim application:</p>
<ol>
<li>It’s more responsive than Vim inside tmux inside a terminal</li>
<li>It’s a better default application than TextEdit to open <code>.txt</code> files on macOS and Windows</li>
<li>It doesn’t have a problem <a href="https://stackoverflow.com/q/7000960/102704">clicking past the 220th column</a> in wide editor windows</li>
<li>If you’re writing a long blog post with lots of spelling errors and terminal Vim <a href="https://github.com/fabrizioschiavi/pragmatapro/issues/14">won’t show underlines</a>, or maybe you prefer the wiggly “undercurl” style lines</li>
<li>You demand to use the <em>true</em> Solarized color scheme instead of the blasphemous scheme created when Solarized is <a href="http://ethanschoonover.com/solarized/vim-colors-solarized#important-note-for-terminal-users">quantized to 256 colors</a></li>
</ol>
<p>Other than the proximity to a command line, a big reason to use Vim in a terminal is <a href="https://github.com/tmux/tmux/wiki/FAQ">tmux</a> which is popular for remote development but just as useful for local development. As of now, tmux is my daily fullscreen working environment, and Vim usually takes up one of the tmux panes. This lets me use Vim while keeping a few other shells open — usually a server and one or two other utility panes. Sometimes I’ll make Vim temporarily fullscreen with the <a href="https://sanctum.geek.nz/arabesque/zooming-tmux-panes/">zoom keybinding</a>.</p>
<p>The killer feature of tmux is the ability to <a href="http://minimul.com/increased-developer-productivity-with-tmux-part-5.html">send keys</a> to tmux panes from anywhere. I use tmux and Vim like an IDE — I can edit in one pane, execute commands in another, and I can keep the server log visible in case there are errors. For example, if I’m working on a REST endpoint, I can re-test the endpoint with <code>curl</code> and view the output with <a href="https://stedolan.github.io/jq/">jq</a> using a few keystrokes, like this:</p>
<figure>
<video loop="" muted="" controls="" poster="https://static.langworth.com/vim/vim3-tmux.jpg" src="https://static.langworth.com/vim/vim3-tmux.mp4"></video>
</figure>
<p>The regular way to do this would be to make a change in Vim, hit <kbd>:</kbd><kbd>w</kbd><kbd>Enter</kbd> to save, then <kbd>&lt;prefix&gt;</kbd><kbd>h</kbd> to move to the left pane (where <code>&lt;prefix&gt;</code> is the tmux prefix keystroke, usually <kbd>Ctrl-a</kbd>), then <kbd>Up</kbd><kbd>Enter</kbd> to repeat the command, and <kbd>&lt;prefix&gt;</kbd><kbd>l</kbd> to go back to Vim. But it’s much faster to rig up a Vim keybinding to do all of this:</p>
<pre><code>nmap \<span>r</span> <span>:</span><span>!</span>tmux send<span>-</span>keys <span>-</span><span>t</span> <span>0</span><span>:</span><span>0.1</span> C<span>-</span><span>p</span> C<span>-</span><span>j</span> <span>&lt;</span>CR<span>&gt;</span><span>&lt;</span>CR<span>&gt;</span>
</code></pre>
<p>The above runs <code>tmux send-keys</code>, which tells it to send keys to the session, window and pane <code>0:0.1</code> where I had run <code>curl</code> previously. It then sends <kbd>Ctrl-p</kbd>, which is equivalent to hitting <kbd>Up</kbd>, which pulls the previous command from history, and then <kbd>Enter</kbd> to execute it. I bound it to <kbd>\</kbd><kbd>r</kbd> as in “run” or “repeat.” You can read more about using <code>send-keys</code> <a href="http://minimul.com/increased-developer-productivity-with-tmux-part-5.html">here</a> and <a href="https://stackoverflow.com/a/19330452/102704">here</a>.</p>
<p>I’ve been using this for half a year and it’s been a massive productivity boost. However, it’s worth mentioning that Vim 8 now supports <a href="https://vimhelp.appspot.com/terminal.txt.html">in-editor native terminals</a>, after some basic use they seem pretty solid. While various plugins have tried to integrate terminals into Vim before with lackluster results, the new native terminals are fast, Unicode-aware, and 256 color-enabled, and there’s a new <code>term_sendkeys()</code> function that lets you send keystrokes like tmux. This was only added to Vim a few months ago so I need to experiment. Who knows, I might end up using MacVim splits with <code>:terminal</code>s instead of tmux.</p>
<h3 id="a-note-on-terminals-on-macos"><a aria-hidden="true" tabindex="-1" href="#a-note-on-terminals-on-macos"><span></span></a>A note on terminals on macOS</h3>
<p>I’ve been using <a href="https://www.iterm2.com/">iTerm2</a> instead of macOS’s default Terminal.app for as long as I can remember. I recently noticed, however, that typing in Vim inside iTerm2 felt sluggish, especially inside tmux. I tried using <code>urxvt</code> inside XQuartz to compare and it felt like lightning. Something was clearly adding latency, but I wasn’t about to make <code>urxvt</code> my primary terminal on macOS because of the clipboard woes, focus issues, and lack of high-DPI support on XQuartz.</p>
<p>A few days after noticing this I read <a href="https://danluu.com/term-latency/">an article</a> that demonstrated input latency between terminals on macOS and claimed that Terminal.app is now significantly faster than iTerm2. I tried it myself and found that the keystroke latency was somewhere between urxvt and iTerm2, so I’ve switched to Terminal.app completely. I was using a fancy <a href="https://github.com/mbadolato/iTerm2-Color-Schemes">custom iTerm2 color theme</a> and was pleased to find a project which has <a href="https://github.com/lysyi3m/osx-terminal-themes">converted all the themes</a> for Terminal.app.</p>
<p>I miss one thing about iTerm2 vertical splits, and that’s the occasional use case where I want different font sizes in different panes. It’s easy to do this with iTerm2, or in fact <em>any</em> editor environment where the editing area isn’t a single grid with fixed sized cells, but I can live without it for now.</p>
<h2 id="writing-prose-in-vim"><a aria-hidden="true" tabindex="-1" href="#writing-prose-in-vim"><span></span></a>Writing prose in Vim</h2>
<p>Distraction-free writing is popular and for good reason — it works. There are some nice-looking native and browser-based applications that do this, but I want to do my writing in Vim, so I worked on a solution.</p>
<figure>
<a href="https://static.langworth.com/vim/vim3-prose.png"><img src="https://static.langworth.com/vim/vim3-prose.png"/></a>
</figure>
<p>A great plugin is <a href="https://vimawesome.com/plugin/goyo-vim">goyo.vim</a>, which adds lots of padding to your buffer and hides all the cruft. It recognizes airline/powerline/lightline status bars so those get hidden too — <a href="https://github.com/itchyny/lightline.vim/issues/83">well, mostly</a>. That plus a few other settings tweaks is something I call <strong>Prose Mode</strong>:</p>
<pre><code><span>function</span><span>!</span> <span>ProseMode</span><span>(</span><span>)</span>
  <span>call</span> goyo#<span>execute</span><span>(</span><span>0</span><span>,</span> <span>[</span><span>]</span><span>)</span>
  <span>set</span> <span>spell</span> <span>noci</span> <span>nosi</span> <span>noai</span> <span>nolist</span> <span>noshowmode</span> <span>noshowcmd</span>
  <span>set</span> <span>complete</span><span>+=</span>s
  <span>set</span> <span>bg</span><span>=</span>light
  <span>if</span> <span>!</span><span>has</span><span>(</span><span>&#39;gui_running&#39;</span><span>)</span>
    <span>let</span> g<span>:</span>solarized_termcolors<span>=</span><span>256</span>
  <span>endif</span>
  colors solarized
<span>endfunction</span>

command<span>!</span> ProseMode <span>call</span> <span>ProseMode</span><span>(</span><span>)</span>
nmap \<span>p</span> <span>:</span>ProseMode<span>&lt;</span>CR<span>&gt;</span>
</code></pre>
<p>This command, which I’ve bound to <kbd>\</kbd><kbd>p</kbd>, turns on Goyo and gets rid of any funny source-code like indenting when you type parentheses. It also changes the color scheme from my regular dark theme to the light version of Solarized, which is important because it becomes a visual reminder that I’m in “writing mode” and that I shouldn’t mess around or get distracted since my goal is to produce words.</p>
<p>The command also makes autocompletion pull words from the thesaurus and dictionary when I hit <kbd>Tab</kbd> in hopes that I’ll be able to write faster. It’s still a work-in-progress, but it’s come in handy now and then.</p>
<h2 id="linting"><a aria-hidden="true" tabindex="-1" href="#linting"><span></span></a>Linting</h2>
<p>One of best and most sorely-needed additions to Vim has been <a href="https://vimhelp.appspot.com/channel.txt.html">asynchronous process control</a>. Now that Vim can finally run processes in the background, a good new plugin called <a href="https://vimawesome.com/plugin/ale">ALE</a> is gaining on <a href="https://vimawesome.com/plugin/syntastic">Syntastic</a> because it runs the linters asynchronously. You no longer have to wait for your linter to finish every time you write a file. I’ve been writing a lot of Ruby on JRuby lately and the linter takes a while to run, so I had turned Syntastic off because of the delays. With ALE I can now turn linting back on while I edit.</p>
<h2 id="lightline-powerline-airline-and-status-bars"><a aria-hidden="true" tabindex="-1" href="#lightline-powerline-airline-and-status-bars"><span></span></a>Lightline, Powerline, Airline, and status bars</h2>
<p>I was using Powerline for the last few years and eventually converted to the lighter-weight <a href="https://vimawesome.com/plugin/vim-airline">Airline</a>. But the information and widgets in these status bars are more distracting than useful — I don’t need to know the current file encoding or syntax type — plus I’m not excited about using <a href="https://github.com/powerline/fonts">hacked up fonts</a>. I switched to <a href="https://vimawesome.com/plugin/lightline-vim">Lightline</a> and spent <a href="https://github.com/statico/dotfiles/blob/202e30b23e5216ffb6526cce66a0ef4fa7070456/.vim/vimrc#L406-L453">a little effort</a> to make it minimal and add linter status icons:</p>
<figure>
<a href="https://static.langworth.com/vim/vim3-ale.png"><img src="https://static.langworth.com/vim/vim3-ale.png"/></a>
</figure>
<p>I don’t see the need of showing the current git branch name in the status line, especially with a terminal being a keystroke away. I also don’t like the idea of putting the git branch in the shell status because it’ll become inaccurate if you switch branches from another shell. But, clearly I’m in the minority here, so maybe I’m missing something.</p>
<h2 id="git"><a aria-hidden="true" tabindex="-1" href="#git"><span></span></a>Git</h2>
<p>If you’re using Git, a few plugins are important.</p>
<p><a href="https://vimawesome.com/plugin/vim-gitgutter">vim-gitgutter</a> is a plugin that shows you markers for any lines that have been added, delete, or modified, like most other editors do nowadays. I changed it to show a colored dot (<code>·</code>) for changes instead of the default <code>-</code> and <code>+</code> characters, which I think looks cleaner.</p>
<figure>
<a href="https://static.langworth.com/vim/vim3-gitgutter.png"><img src="https://static.langworth.com/vim/vim3-gitgutter.png"/></a>
</figure>
<p><a href="https://vimawesome.com/plugin/fugitive-vim">vim-fugitive</a> seems to be the most popular Git plugin for Vim and has lots of capability. I have <a href="https://github.com/statico/dotfiles/blob/master/.zshrc#L200">tons of shell aliases for git</a> so in Vim I rarely use anything other than <code>:Gblame</code> and <code>:Gbrowse</code>, but it’s got a lot of other nice things you’d expect from in-editor Git tools. (If your repo is hosted on GitHub you’ll need <a href="https://vimawesome.com/plugin/vim-rhubarb">vim-rhubarb</a> to get <code>:Gbrowse</code> to work.)</p>
<p><code>:Gbrowse</code> is wonderful — it opens the current file with optional line selection in the browser, assuming your repo is mirrored on GitHub or GitLab or whatever. It’s even more useful now that GitHub displays links to specific commits and line numbers as snippets when used in issues and pull requests. All you have to is select a few lines with <kbd>Shift-v</kbd>, do a <code>:Gbrowse</code>, copy the URL that opens, and paste it into a GitHub comment to get something like this:</p>
<figure>
<a href="https://static.langworth.com/vim/vim3-github.png"><img src="https://static.langworth.com/vim/vim3-github.png"/></a>
</figure>
<p>I thought I was going to talk about <a href="https://vimawesome.com/plugin/rootignore">RootIgnore</a> and how it sets the <code>wildignore</code> automatically based on your <code>.gitignore</code>. This turned out to be a bad idea because tab-completing paths on the Vim command line doesn’t work if the path is in <code>wildignore</code>. Worse, the built-in <code>expand()</code> returns null if the path you ask it to expand is in ignored. It took me a while to figure out that this was causing my <code>.gitignore</code>-ed host-specific <code>.vimlocal</code> file to not be sourced by my checked-in <code>.vimrc</code>.</p>
<h2 id="buffers-buffers-buffers"><a aria-hidden="true" tabindex="-1" href="#buffers-buffers-buffers"><span></span></a>Buffers, buffers, buffers</h2>
<p>I’m a staunch user of buffers. I’ve tried using tabs but never found them useful. All tabs do is create an additional way of hiding information and they require you to memorize another keybinding or command to get at them. If you’re using tmux, it’s simply easier to open Vim in another pane. And if you’re making good use of buffers, it’s easy to get at the file you’re thinking of with a few keystrokes using FZF as described earlier.</p>
<p>If you haven’t really used buffers they’re easy to understand: Once you start Vim, any file you open or create becomes a named buffer. You can view them using the <code>:buffers</code> command, and navigate to one of them using <code>:buf &lt;name&gt;</code>, where <code>&lt;name&gt;</code> is any part of the filename of the buffer, or the number shown to you with <code>:buffers</code>.</p>
<p>If you start Vim from the command line with multiple files as command line arguments then each file will already be open in a buffer for easy access. If you’ve installed <a href="https://vimawesome.com/plugin/unimpaired-vim">vim-unimpaired</a> you can use the <kbd>[</kbd><kbd>b</kbd> and <kbd>]</kbd><kbd>b</kbd> keybindings to navigate between them easily.</p>
<p>As I mentioned earlier, I’ve sped this process up considerably by binding the <kbd>;</kbd> key to the FZF <code>:Buffers</code> command so a single keystroke brings up a buffer list with fuzzy-finding. For example, if I open three files on the command line like <code>vim foo.txt bar.txt quux.txt</code>, getting to <code>quux.txt</code> is simply <kbd>;</kbd><kbd>q</kbd><kbd>Enter</kbd>. (Yes, using <code>:buf</code> is close, but fzf shows you a live preview when you have many similarly-named files open.)</p>
<p>Sometimes I create buffers by accident, such as when trying to open a file with <code>:e</code> and hitting <kbd>Enter</kbd> too quickly. The <code>:bd</code> command can be used to delete the buffer and remove it from the list, but it will also close the Vim window or split if that buffer is open in it. A good solution is to use <a href="https://vimawesome.com/plugin/bufkill-vim">bufkill.vim</a>, which provides <code>:BD</code> to delete the current buffer and keep the current window open. I use this often so I’ve bound it to <kbd>Meta-w</kbd>.</p>
<p>If you need to rename, chmod or delete a file, you can pop over to a terminal and make the change, but then the Vim buffer will be out of sync and show you an annoying “File is no longer available” warning. Instead, you can use <a href="https://github.com/scrooloose/nerdtree">NERDTree</a> to highlight the current file with <code>:NERDTreeFind</code>, hit <kbd>m</kbd> to modify it, and choose an action like move or rename. The solution I prefer is to use <a href="https://vimawesome.com/plugin/eunuch-vim">vim-eunuch</a>, which adds a bunch of commands: <code>:Chmod</code> chmods the current file, <code>:Rename</code> renames the file in its parent directory, <code>:Move</code> can move it to a new path, and <code>:Delete</code> will delete the file and the buffer. There are a few more commands but those are the ones I’ve used the most.</p>
<h2 id="miscellaneous-other-plugins"><a aria-hidden="true" tabindex="-1" href="#miscellaneous-other-plugins"><span></span></a>Miscellaneous other plugins</h2>
<p>A <a href="https://github.com/xonecas">friend</a> turned me onto <a href="https://vimawesome.com/plugin/vim-polyglot">vim-polyglot</a>, which bundles 100+ syntax plugins into a single package and makes them load only on demand. It’s kept very up to date, and the author has picked the best syntax plugins to make sure indenting and highlighting works well for the most popular languages.</p>
<p>Commenting out code is a common activity so it makes sense to use a plugin that is smart enough to comment lines or blocks of code in multiple languages. You can usually get away with <code>:s/^/#</code> if you’re writing code that uses hashes to comment out lines, but I prefer the <a href="https://vimawesome.com/plugin/commentary-vim">vim-commentary</a> plugin, which makes commenting and uncommenting in any language simple with <kbd>g</kbd><kbd>c</kbd>.</p>
<p>The <a href="https://vimawesome.com/plugin/surround-vim">vim-surround</a> plugin is so useful that it should probably be built into Vim. It adds keybindings to add, remove, and change the surrounding characters of any bit of text, such as changing single quotes to double quotes or brackets to parentheses. Unfortunately, the <kbd>.</kbd> key doesn’t repeat these changes by default, so you need <a href="https://vimawesome.com/plugin/repeat-vim">repeat.vim</a> to make that happen. For example, to change the quotes used for multiple strings, use the <kbd>c</kbd><kbd>S</kbd><kbd>’</kbd><kbd>”</kbd> or combination once, then use <kbd>.</kbd> to repeat the substitution on the next string.</p>
<p>If you’re writing Ruby or any language with end-block keywords then you’ll be writing a lot of <code>end</code>s. The <a href="https://vimawesome.com/plugin/endwise-vim">endwise</a> plugin inserts them automatically, which is nice. And if you’re writing HTML or XML, you should certainly use <a href="https://vimawesome.com/plugin/closetag-vim">closetag.vim</a> plugin which closes tags automatically when you type <kbd>&lt;</kbd><kbd>/</kbd>.</p>
<p>In the original Vim post I mentioned some <a href="https://blog.langworth.com/vim.html#other-peoples-code">tab and space fixing macros</a> to deal with codebases that use different tab and space variations. However, <a href="https://vimawesome.com/plugin/sleuth-vim">sleuth.vim</a> can detect these settings automatically by scanning files when they’re opened. It works 90% of the time and makes the macros I set up mostly unnecessary.</p>
<h2 id="thoughts-on-plugins"><a aria-hidden="true" tabindex="-1" href="#thoughts-on-plugins"><span></span></a>Thoughts on Plugins</h2>
<p>With the recent improvements to Vim and VimL, such as <a href="https://vimhelp.appspot.com/channel.txt.html">asynchronous process control</a> and some <a href="https://vimhelp.appspot.com/version7.txt.html#new-7">indispensable types</a>, the plugin ecosystem is thriving. A new plugin site, <a href="https://vimawesome.com/">VimAwesome</a>, makes finding popular plugins easy and has well-formatted documentation and install instructions.</p>
<p>Some of the responses to my previous posts included occasional backlashes against using Vim with lots of plugins. Part of this is understandable suspicion — any system which allows users to add unordered extensions to patch any part of itself without constraint can easily become a mess. Just look at WordPress. Or, if you were around 20 years ago, the horrors of Mac OS Classic extensions. There’s no way to declare dependencies and debugging interactions between plugins becomes the norm.</p>
<p>Vim plugins aren’t too bad, though. Debugging an interaction between plugins <em>X</em> and <em>Y</em> usually involves googling “vim X with Y” and I’ve only had to do it once or twice. The <a href="https://github.com/alampros/vim-styled-jsx/issues/1">one time</a> I experienced weirdness I had to binary-search my way through (like <a href="https://tidbits.com/article/1496">Conflict Catcher</a> used do twenty years) ago and had to rename one plugin so it loaded before another. I’m not proud, but so far it’s been the only bad plugin interaction that I’ve encountered.</p>
<p>Additional resistance towards plugins seems to be some kind of purist animosity against straying away from some <em>core set</em> of Vim functionality. But if you’re using Vim, you’re already in a subset of people who demand that editing text be fast and efficient, so it’s like a group of savants arguing about which is the most eccentric. The set of people that use a movement plugin like <a href="https://vimawesome.com/plugin/easymotion">EasyMotion</a> or <a href="https://vimawesome.com/plugin/vim-sneak">vim-sneak</a> will argue that they’re more efficient than vanilla Vim users, and vanilla Vim users will argue that they’re more efficient than non-Vim users, and so on. The argument will be moot when we can control computers <a href="https://www.theverge.com/2017/3/27/15077864/elon-musk-neuralink-brain-computer-interface-ai-cyborgs">with our brains</a> anyway.</p>
<p>I’ve also heard of practical resistance to plugins, such as when a plugin needs a version of Vim with Ruby or Python or who-knows-what compiled in, and maybe the plugin itself needs to be compiled. Vim 7 added a lot of essential language features so a lot of plugins are now pure VimL and don’t need an extra language dependency. Combined with <a href="https://github.com/tpope/vim-pathogen">vim-pathogen</a> which adds everything in <code>~/.vim/bundle/</code> to Vim’s runtime path, adding plugins should be <a href="https://github.com/statico/dotfiles/blob/master/.vim/update.sh">as easy as a <code>git clone</code></a>.</p>
<p>My opinion is as follows: If a plugin provides useful functionality that I wish were built into Vim, it’s worth installing. Otherwise, I try to keep the number of plugins at a minimum to avoid interaction problems and maintain crisp performance when starting Vim and viewing files. The plugins and configuration I list here are more about efficiency and getting stuff, but only to the point where I don’t need to completely rewire my brain.</p>
<h2 id="vim-isnt-the-only-editor"><a aria-hidden="true" tabindex="-1" href="#vim-isnt-the-only-editor"><span></span></a>Vim isn’t the only editor</h2>
<p>There are a lot more interesting editors than there were four years ago. <a href="https://atom.io/">Atom</a> and Microsoft’s <a href="https://code.visualstudio.com/">Visual Studio Code</a> have emerged now that browser-based native applications are practical. <a href="https://www.sublimetext.com/">Sublime Text</a> continues to be a great application. <a href="https://www.jetbrains.com/idea/download/">IntelliJ IDEA</a> now has a free Community Edition. All of these have support for Vim-like modes and are worth trying or using in certain situations.</p>
<p>New programmers often ask me which editor to use, and I always suggest starting with Sublime Text. Its interface is familiar, it has a great plugin ecosystem with up-to-date syntax highlighting, and it works well on macOS, Windows, and Linux. If you’re learning programming then you don’t want to also learn Vim’s strange arcane combinations of letters and different editing modes just to move and edit text on the screen. Though some of those people have later picked up Vim and remarked at how supremely fast and powerful they feel.</p>
<p>The best editor for Java is probably IntelliJ IDEA. The <a href="https://www.jetbrains.com/idea/download/">Community Edition</a> is available for free and has all of the features a modern Java or Kotlin developer probably wants or needs. It’s got nice Maven build support, solid Git integration, amazing refactoring support, intelligent completion, <a href="https://www.jetbrains.com/help/idea/viewing-method-parameter-information.html">snazzy function parameter hints</a>, smart indexing and searching that’s better than ctags, and its interactive debugger can be essential. In fact, when writing Ruby, if I need to debug anything and need more than one or two <code>puts</code> I’ll fire up IntelliJ and use the debugger. And if you miss Vim, the free <a href="https://plugins.jetbrains.com/plugin/164-ideavim">IdeaVIM</a> plugin gives you Vim keybindings and works reasonably well.</p>
<p>I haven’t tried Visual Studio Code, but I might give it a go when I start writing TypeScript, as both are developed by Microsoft and work well together. I’ve seen some GIFs and I’ve been impressed at its completion, and the things I’ve read about it are generally positive. A friend of mine claims that the <a href="https://vimawesome.com/plugin/youcompleteme">YouCompleteMe</a> Vim plugin is <em>essential</em> if you’re writing C or C++, and it has TypeScript support, so might try that as well.</p>
<p><a href="https://neovim.io/">NeoVim</a> looks interesting, but I don’t plan on giving it a try. When it was announced it boasted asynchronous job control and native terminals, but those features have been added to the Vim core. If there’s a killer reason for using it, let me know.</p>
<h2 id="conclusion"><a aria-hidden="true" tabindex="-1" href="#conclusion"><span></span></a>Conclusion</h2>
<p>My focus nowadays is on <em>getting stuff done</em> instead of mucking about with tools. But Vim has always been one of those things where a little work and research pays dividends. Browsing <a href="https://vimawesome.com/">VimAwesome.com</a> or reading a few lines in a help page can dramatically improve one’s effectiveness. Most of the plugin or configuration tweaks I’ve made are from running into some annoyance and thinking, “There <em>has</em> to be a better way to do this.”</p>
<p>I hope that this post has been useful. Let me know what you think in the comments.</p></article></div>
  </body>
</html>
