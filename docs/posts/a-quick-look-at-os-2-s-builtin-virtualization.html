<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/POSTING-en.html">Original</a>
    <h1>A quick look at OS/2&#39;s builtin virtualization</h1>
    
    <div id="readability-page-1" class="page"><div id="blogpostcontent">

<p><a href="https://www.uninformativ.de/blog/">blog</a> 路 <a href="https://www.uninformativ.de/git/">git</a> 路 <a href="https://www.uninformativ.de/desktop/">desktop</a> 路 <a href="https://www.uninformativ.de/pics/stream.html">images</a> 路 <a href="https://www.uninformativ.de/contact.html">contact</a></p>
<hr/>

<p>2024-12-13</p>

<p>A while ago, someone on the fediverse mentioned &#34;OS/2&#39;s virtualization
features&#34; to me. I don&#39;t remember who it was, sorry. I had the chance to
take a look at this today.</p>
<p>For maximum dramatic effect, I&#39;m going to use the oldest version of OS/2
that I own, which is OS/2 2.1 from 1993:</p>
<p><a href="https://www.uninformativ.de/blog/postings/2024-04-21/0/os2disks.jpg"><img alt="disks" src="https://www.uninformativ.de/blog/postings/2024-04-21/0/t/os2disks.jpg.jpg"/></a></p>
<p>There is this feature called &#34;DOS from drive A:&#34;:</p>
<p><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/dfda.png"><img alt="dfda.png" src="https://www.uninformativ.de/blog/postings/2024-12-13/0/t/dfda.png.jpg"/></a></p>
<p>You can insert a bootable DOS floppy and then run <em>that</em> DOS in a new
window.</p>
<p>Since this is called &#34;<em>DOS</em> from drive A:&#34;, surely this is something
DOS-specific, right? Maybe only supports MS-DOS or even only PC DOS?</p>
<p>Far from it, apparently.</p>
<h2 id="our-test-program">Our test program</h2>
<p>Let&#39;s write a little DOS program first:</p>
<pre><code>; Switch to VGA mode 13
mov ah, 0
mov al, 0x13
int 0x10

; Base address of VGA memory
mov cx, 0xA000
mov ds, cx

; Linear offset into VGA memory
mov bx, 0

next:
    ; Get x/y from linear offset -&gt; dx = x, ax = y
    mov dx, 0
    mov ax, bx
    mov cx, 320
    div cx

    ; cx = dx ^ ax  (i.e., x ^ y)
    mov cx, dx
    xor cx, ax

    ; Write to VGA memory
    mov byte [ds:bx], cl
    inc bx

    ; Quit if end of screen
    cmp bx, 320 * 200
    je halt

    jmp next

halt:
    cli
    hlt
    jmp halt
</code></pre>
<p>I used <a href="https://nasm.us/">NASM</a> on Linux to create a <code>.COM</code> file:</p>
<pre><code>$ nasm -o vga.com vga.s
</code></pre>
<p>Running this in DOSBox on Linux looks like this:</p>
<p><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/vgadosbox.png"><img alt="vgadosbox.png" src="https://www.uninformativ.de/blog/postings/2024-12-13/0/t/vgadosbox.png.jpg"/></a></p>
<p>So it draws something like
<a href="https://lodev.org/cgtutor/xortexture.html">the XOR texture</a>
in VGA mode 13.</p>
<p>Now, this program is actually not &#34;a DOS program&#34;. It runs in real-mode
and only uses BIOS functions, specifically
<a href="https://helppc.netcore2k.net/interrupt/int-10">INT 10</a> to change the
video mode and then it just assumes that the VGA memory is available at
<code>0xA000</code>. It does not make any DOS syscalls, nor does it assume
something in memory specific to DOS (to the best of my knowledge). And
it is a <code>.COM</code> file, meaning there is no file format overhead, it&#39;s just
plain executable code.</p>
<p>If you will, this is a &#34;real-mode BIOS program&#34;.</p>
<p>This means that you can write this little thing <em>to a bootsector</em> and it
should work.</p>
<h2 id="running-the-test-program-in-qemu">Running the test program in QEMU</h2>
<p>We&#39;ll create a &#34;bootable&#34; floppy disk image.</p>
<p>Let&#39;s start by creating a file of the correct size (1.44 MB) with all
zeroes:</p>
<pre><code>$ dd if=/dev/zero of=vga.img bs=1474560 count=1
</code></pre>
<p>Then we&#39;re going to need a
<a href="https://thestarman.pcministry.com/asm/mbr/DOS50FDB.htm">floppy disk boot record</a>.
Here&#39;s what <code>mkfs.fat</code> creates, but stripped down to the bare
essentials and with an
<a href="https://www.uninformativ.de/blog/postings/2024-09-21/0/POSTING-en.html">OEM label</a> of <code>MSDOS5.0</code>:</p>
<pre><code>00000000: eb3c 904d 5344 4f53 352e 3000 0201 0100  .&lt;.MSDOS5.0.....
00000010: 02e0 0040 0bf0 0900 1200 0200 0000 0000  ...@............
00000020: 0000 0000 0000 2906 c6b1 5356 4741 2020  ......)...SVGA  
00000030: 2020 2020 2020 4641 5431 3220 2020 0000        FAT12   ..
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000150: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000160: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000180: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000190: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001f0: 0000 0000 0000 0000 0000 0000 0000 55aa  ..............U.
</code></pre>
<p>Create a binary file from this hexdump:</p>
<pre><code>$ xxd -r hexdump.txt &gt;fbr.img
</code></pre>
<p>Overlay this on top of the empty file:</p>
<pre><code>$ dd if=fbr.img of=vga.img conv=notrunc
</code></pre>
<p>Then we&#39;re going to overlay our <code>vga.com</code> on top of that, starting at
position <code>0x3E</code> (the first two bytes of the boot record are a jump
instruction to that position):</p>
<pre><code>$ dd if=vga.com of=vga.img bs=1 seek=$((0x3E)) conv=notrunc
</code></pre>
<p>The resulting file should now be runnable in QEMU and display the same
pattern:</p>
<pre><code>$ qemu-system-x86_64 -enable-kvm -drive file=vga.img,index=0,if=floppy,format=raw
</code></pre>
<p><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/qemu.png"><img alt="qemu.png" src="https://www.uninformativ.de/blog/postings/2024-12-13/0/t/qemu.png.jpg"/></a></p>
<h2 id="running-our-program-in-os2s-virtualization">Running our program in OS/2&#39;s virtualization</h2>
<p>I&#39;m not sure yet why, but using &#34;DOS from drive A:&#34; <em>directly</em> does not
work. But it does not work with
<a href="https://www.os2world.com/wiki/index.php/User%27s_Guide_to_OS/2_Warp_Version_3_-_Part_3#Creating_a_DOS_Startup_Diskette">legitimage DOS floppy images</a>,
either. I run my OS/2 in QEMU, maybe that&#39;s the reason? Maybe it does
something funny with the floppy disk controller?
<a href="https://en.wikipedia.org/wiki/IBM_Extended_Density_Format">XDF</a>
also
<a href="https://www.uninformativ.de/blog/postings/2024-04-17/0/POSTING-en.html">does not work in QEMU</a>.
I haven&#39;t tried all this with real hardware, because I have so few
usable floppy disks left and don&#39;t want to waste them. Or maybe I&#39;m just
missing something here.</p>
<p>Instead, open an OS/2 command prompt and use <code>VMDISK</code> to create an image
file:</p>
<p><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/vmdisk.png"><img alt="vmdisk.png" src="https://www.uninformativ.de/blog/postings/2024-12-13/0/t/vmdisk.png.jpg"/></a></p>
<p>It warns that this might not be bootable, so it looks like it does some
sort of sanity check, but it does the work and that&#39;s what matters. (I
haven&#39;t had a closer look at the created file, yet. Maybe it&#39;s literally
just a disk dump and I could use my <a href="https://www.uninformativ.de/git/sdc">sdc</a> instead of
<code>VMDISK</code>.)</p>
<p>Then go to &#34;Templates&#34; and drag a new &#34;Program&#34; onto your desktop. As
path to run, just enter <code>*</code>. Then go to &#34;Session&#34;, select &#34;DOS
fullscreen&#34; and set <code>DOS_STARTUP_DRIVE</code> to the path of our image:</p>
<p><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/session.png"><img alt="session.png" src="https://www.uninformativ.de/blog/postings/2024-12-13/0/t/session.png.jpg"/></a></p>
<p>When you double click this newly created icon, it will switch to
fullscreen mode and show our pattern (use Ctrl+Esc to exit).</p>
<p>It can even do it in a window, if you configure the session accordingly:</p>
<p><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/windowed.png"><img alt="windowed.png" src="https://www.uninformativ.de/blog/postings/2024-12-13/0/t/windowed.png.jpg"/></a></p>
<p>(I don&#39;t have a proper graphics card driver installed in that QEMU VM,
hence only 16 color mode.)</p>
<h2 id="how-deep-does-the-rabbit-hole-go">How deep does the rabbit hole go?</h2>
<p>Now, all of the above clearly has nothing to do with &#34;a bootable DOS
floppy disk&#34;. To me, this looks like OS/2 works quite similar to the
hypervisors that we have today: It loads the disk image, maybe checks
the
<a href="https://thestarman.pcministry.com/asm/mbr/DOS50FDB.htm#BPB">BIOS Parameter Block</a>
(at least <code>VMDISK</code> does), and then just starts executing whatever code
it finds.</p>
<p>When you read through the
<a href="https://www.os2world.com/wiki/index.php/User%27s_Guide_to_OS/2_Warp_Version_3_-_Part_3#Creating_a_DOS_Startup_Diskette">guide to create DOS floppies</a>
I linked above, you&#39;ll see that you&#39;re supposed to create a little
<code>CONFIG.SYS</code> with this particular line in it:</p>
<pre><code>DEVICE=FSFILTER.SYS
</code></pre>
<p>This is a paravirtualized device driver to access the host filesystem,
it seems!</p>
<p><a href="https://www.xtof.info/inside-windows3.html">Windows 3 also uses virtualization for its DOS boxes</a>,
but this is &#34;internal&#34; to Windows. OS/2, on the other hand, exposes this
entire functionality to the user. And that is pretty crazy, especially
for 1993, if you ask me. This is basically a builtin QEMU that anybody
with a 386 could use.</p>
<p>I wonder how far you can push this. What else can you do with this?
Which (possibly emulated) devices are available in the VM?</p>


        </div></div>
  </body>
</html>
