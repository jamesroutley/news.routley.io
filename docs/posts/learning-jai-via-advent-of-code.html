<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.forrestthewoods.com/blog/learning-jai-via-advent-of-code/">Original</a>
    <h1>Learning Jai via Advent of Code</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Last year I got into the Jai beta. One of my favorite ways to learn a new language is via <a href="https://adventofcode.com/">Advent of Code</a></p>

            <ul>
                <li>(2019) <a href="https://www.forrestthewoods.com/blog/learning-rust-via-advent-of-code/">Learning Rust via Advent of Code</a></li>
                <li>(2022) <a href="https://www.forrestthewoods.com/blog/failing-to-learn-zig-via-advent-of-code/">Failing to Learn Zig via Advent of Code</a></li>
                <li>(2023) <a href="https://www.forrestthewoods.com/blog/learning-jai-via-advent-of-code/">Learning Jai via Advent of Code</a></li>
            </ul>

            <p>The Jai beta rules are that I am free to talk about the language and share my code. However the compiler is not to be shared. </p>

            <p>This is the type of topic where folks have, ahem, strong opinions. Be kind y&#39;all.</p>

            

            

            <ol>
                <li><a href="#what_is_jai">What is Jai</a></li>
                <!-- <li><a href="#blog_target_audience">Blog Target Audience</a></li>
                <li><a href="#who_am_i">Who am I</a></li>
                <li><a href="#getting_started_with_jai">Getting Started with Jai</a></li> -->
                <li><a href="#advent_of_code">Advent of Code</a></li>
                    <!-- <ol class="list_spacing m_bottom_xs">
                        <li>Day 01</li>
                        <li>Day 02</li>
                        <li>Summary</li>
                    </ol> -->
                <li><a href="#memory_management">Memory Management</a></li>
                    <!-- <ol class="list_spacing m_bottom_xs">
                        <li>No Destructors</li>
                        <li>Four Categories of Lifetime</li>
                        <li>Temporary Storage</li>
                    </ol> -->
                <!-- <li>Interesting Jai Ideas</li> -->
                <li><a href="#big_ideas">Big Ideas</a></li>
                    <ol>
                        <li><a href="#context">Context</a></li>
                        <li><a href="#compiler_directives">Compiler Directives</a></li>
                        <li><a href="#runtime_reflection">Runtime Reflection</a></li>
                        <li><a href="#compile_time_code">Compile Time Code</a></li>
                        <!-- <ol class="list_spacing m_bottom_s">
                            <li>#run</li>
                            <li>#insert</li>
                            <li>#code</li>
                            <li>Abstract Syntax Tree</li>
                            <li>assert_eq</li>
                        </ol> -->
                    </ol>
                <li><a href="#medium_ideas">Medium Ideas</a></li>
                    <!-- <ol class="list_spacing m_bottom_s">
                        <li>Polymorphic Procedure</li>
                        <li>Polymorphic Structs</li>
                        <li>Build System</li>
                    </ol> -->
                <li><a href="#think_about_jai">What do I think about Jai?</a></li>
                <li><a href="#conclusion">Conclusion</a></li>
                <li><a href="#bonus_content">Bonus Content</a></li>
                <!-- <ol class="list_spacing m_bottom_xs">
                    <li>Small Ideas</li>
                        <ol class="list_spacing m_bottom_xs">
                            <li>Initialized by Default</li>
                            <li>No Printf Formatters</li>
                            <li>Distinct</li>
                            <li>Universal Declaration Syntax</li>
                            <li>Relative Pointers</li>
                            <li>f. No references</li>
                        </ol>
                </ol> -->
            </ol>

            

            


            <p>Here is my attempt to define Jai. This is unofficial and reflects my own biases.</p>

            <p>Jai is a systems language that exists in-between C and C++. It is compiled and statically typed. It strives to be &#34;simple by default&#34;. It focuses on problems faced by games.</p>

            <p>It&#39;s worth pointing out several that Jai does NOT have or do.</p>

            <ul>
                <li>NO destructors or RAII</li>
                <li>NO garbage collection</li>
                <li>NO runtime</li>
                <li>NO virtual functions</li>
                <li>NOT a &#34;memory safe&#34; language</li>
            </ul>

            <p>The Philosophy of Jai is not explicitly written down. However the tutorials are full of philosophy and perspective. Based on tutorials, presentations, Q&amp;As, and community I think the Philosophy of Jai&#39;s looks very vaguely like this:</p>

            <ul>
                <li>C++ is super overcomplicated, but does some things right</li>
                <li>Jai is what C++ should have been</li>
                <li>Focus on games and real problems they face</li>
                <li>Increasingly high-level languages haven&#39;t increased productivity</li>
                <li>Design to solve hard problems</li>
                <li>Avoid small features that only solve easy problems</li>
                <li>Game logic bugs are harder and more frequent than memory bugs</li>
                <li>Modern &#34;memory safe&#34; techniques are too rigid for games</li>
                <li>Debug-mode run-time checks can detect most memory bugs</li>
                <li>Experiment with new ideas in a small, closed beta</li>
            </ul>

            <p>I think it&#39;s also critical to note that Jai:</p>

            <ul>
                <li>is NOT a finished language</li>
                <li>has experimental ideas that may turn out to be bad</li>
                <li>has papercuts, rough edges, and incomplete features</li>
            </ul>

            <p>Please take all that with a grain of salt. These are my early impressions.</p>

            

            

            <p>I always try to write with an explicit audience in mind. Sometimes it&#39;s a deeply technical article for professional programmers. Other times it&#39;s for the &#34;dev curious&#34; gamers who want a peak under the hood.</p>

            <p>This post has been very difficult to frame. Who is this blog post for? What do I want them to take away? Should this be an objective description of the language or my subjective opinion? So many choices!</p>

            <p>Here&#39;s what I settled on:</p>

            <ul>
                <li>write for game devs who haven&#39;t seen Jai code</li>
                <li>focus on language concepts I think are interesting</li>
            </ul>

            <p>The list of things this post is NOT is much longer:</p>

            <ul>
                <li>NOT for Jai beta users</li>
                <li>NOT a Jai tutorial</li>
                <li>NOT a comprehensive guide to Jai</li>
                <li>NOT an argument for or against C/C++/Rust/etc</li>
                <li>NOT a compare and contrast to other languages</li>
                <li>NOT an argument that you should convert to Jai</li>
            </ul>

            

            
            
            <p>This post is highly subjective and biased so I think it&#39;s important to understand where I&#39;m coming from. </p>

            <p>I have 15+ years professional experience working in games and VR. I&#39;ve shipped games in Unity, Unreal, and multiple custom engines. Most of my career has been writing C++ or Unity C#. I&#39;ve written some Python and Lua. I &lt;3 Rust. In games I worked on projects with 15 to 40 people. I worked on systems such as gameplay, pathfinding, networking, etc. I currently work in BigTech Research.</p>

            <p>I&#39;m not a language programmer. I don&#39;t know anything about webdev. I think C++ is terrible, but it&#39;s shipped everything I&#39;ve ever worked on. JavaScript is an abomination. I have thoughts on <a href="https://www.forrestthewoods.com/blog/things-i-like-about-python/">Python</a> and <a href="https://www.forrestthewoods.com/blog/global-variables-are-evil-and-unsafe/">global variables</a>. I don&#39;t know anything about backends.</p>

            <p>This post is just, like, my opinion, man.</p>
            
            <p><img src="https://www.forrestthewoods.com/blog/learning-jai-via-advent-of-code/assets/img/01.jpg" width="100%" alt="The Dude from The Big Lebowski"/></p>

            

            <p>Jai is very easy to run. The beta is distributed as a vanilla zip file. It contains:</p>

            <ul>
                <li><code>jai.exe</code> compiler</li>
                <li><code>lld.exe</code> linker</li>
                <li>default modules aka &#34;standard library&#34;</li>
                <li>65 &#34;how to&#34; tutorials</li>
                <li>a handful of examples</li>
            </ul>

            <p>That&#39;s basically it. Compiling and running a Jai program is as easy as:</p>

            <ol>
                <li>Run <code>jai.exe foo.jai</code></li>
                <li>Run <code>foo.exe</code></li>
            </ol>

            <p>On Windows the compiler will also produce `foo.pdb` which allows for full breakpoint and step debugging in Visual Studio or <a href="https://remedybg.handmade.network/">RemedyBG</a>. I&#39;m a card carrying member of #TeamDebugger and hate when new languages only offer <code>printf</code> for debugging.</p>
        </div><div>

            

            

            <p>I am pleased to say that this year I successfully solved all 25 days of Advent of Code exclusively with Jai. This ended up being 4821 lines of code. You can view full source on <a href="https://github.com/forrestthewoods/aoc2022/blob/master/jai/main.jai">GitHub</a>.</p>

            <p>My solutions are a little sloppy, inefficient, and non-idiomatic. One cool thing about learning a language via Advent of Code is learning from other people&#39;s solutions. Unfortunately with Jai being a closed beta I wasn&#39;t able to do that this year!</p>

            

            <p>Here&#39;s my solution to day 01. It&#39;s an exceedingly simple program. However I&#39;m assuming most readers have never seen Jai code before.</p>

<pre><span>// [..]u32 is similar to std::vector&lt;u32&gt;</span>
<span>// [..][..] is similar to std::vector&lt;std::vector&lt;u32&gt;&gt;</span>
day01_part1 <span>::</span> (elves<span>:</span> [..][..]<span>u32</span>) <span>-&gt;</span> s64 {
  <span>// := is declare and initialize </span>
  <span>// var_name : Type = Value;</span>
  <span>// Type can be deduced, but is statically known at compile-time</span>
  max_weight <span>:=</span> <span>0</span>;

  <span>// iterate elves</span>
  <span>for</span> elf <span>:</span> elves {
    <span>// sum weight of items carried by elf</span>
    elf_weight <span>:=</span> <span>0</span>;
    <span>for</span> weight <span>:</span> elf {
        elf_weight <span>+=</span> weight;
    }
  
    <span>// find elf carrying the most weight</span>
    max_weight <span>=</span> max(elf_weight, max_weight);
  }
  
  <span>return</span> max_weight;
}
</pre>

            <p>This code should be easy to understand. The syntax may be different than you&#39;re used to. It&#39;s good, just roll with it for now.</p>

            

            <p>Here&#39;s most of my solution to day 4.</p>

<pre>day04_solve <span>::</span> () {
  <span>// Read a file to a string</span>
  input, success <span>:=</span> read_entire_file(<span>&#34;data/day04.txt&#34;</span>);
  <span>assert</span>(success);
  
  <span>// Solve puzzle and print results</span>
  part1, part2 <span>:=</span> day04_bothparts(input);
  print(<span>&#34;day04 part1: %</span><span>\n</span><span>&#34;</span>, part1);
  print(<span>&#34;day04 part2: %</span><span>\n</span><span>&#34;</span>, part2);
}
  
<span>// Note multiple return values</span>
day04_bothparts <span>::</span> (input <span>:</span> string) <span>-&gt;</span> <span>u64</span>, <span>u64</span> {
  part1 <span>:</span> <span>u64</span> <span>=</span> <span>0</span>;
  part2 <span>:</span> <span>u64</span> <span>=</span> <span>0</span>;
  
  <span>while</span> input.count <span>&gt;</span> <span>0</span> {
    <span>// next_line is a helper function I wrote</span>
    <span>// this does NOT allocate. it &#34;slices&#34; input.</span>
    line <span>:</span> string <span>=</span> next_line(<span>*</span>input);
      
    <span>// split is part of the &#34;standard library&#34;</span>
    <span>// splits &#34;###-###,###-###&#34; in two &#34;###-###&#34; parts</span>
    elves <span>:=</span> split(line,<span>&#34;,&#34;</span>);
    <span>assert</span>(elves.count <span>==</span> <span>2</span>);
  
    <span>// declare a helper function inside my function</span>
    <span>// converts string &#34;###-###&#34; to two ints</span>
    get_nums <span>::</span> (s <span>:</span> string) <span>-&gt;</span> <span>int</span>, <span>int</span> {
      range <span>:=</span> split(s, <span>&#34;-&#34;</span>);
      <span>assert</span>(range.count <span>==</span> <span>2</span>);
      <span>return</span> string_to_int(range[<span>0</span>]), string_to_int(range[<span>1</span>]);
    }
  
    a,b <span>:=</span> get_nums(elves[<span>0</span>]);
    x,y <span>:=</span> get_nums(elves[<span>1</span>]);
  
    <span>// more helpers</span>
    contains <span>::</span> (a<span>:</span><span>int</span>, b<span>:</span><span>int</span>, x<span>:</span><span>int</span>, y<span>:</span> <span>int</span>) <span>-&gt;</span> bool {
      <span>return</span> (a <span>&gt;=</span> x <span>&amp;&amp;</span> b <span>&lt;=</span> y) <span>||</span> (x <span>&gt;=</span> a <span>&amp;&amp;</span> y <span>&lt;=</span> b);
    }
  
    overlaps <span>::</span> (a<span>:</span><span>int</span>, b<span>:</span><span>int</span>, x<span>:</span><span>int</span>, y<span>:</span> <span>int</span>) <span>-&gt;</span> bool {
      <span>return</span> a <span>&lt;=</span> y <span>&amp;&amp;</span> x <span>&lt;=</span> b;
    }
      
    <span>// Jai loves terse syntax</span>
    <span>// This style is encouraged</span>
    <span>if</span> contains(a,b,x,y) part1 <span>+=</span> <span>1</span>;
    <span>if</span> overlaps(a,b,x,y) part2 <span>+=</span> <span>1</span>;
  }
  
  <span>return</span> part1, part2;
}</pre>
  
            <p>This code should also be easy to understand. Compared to C there are a few new features such as nested functions and multiple return values.</p>

            <p>Advent of Code is pretty simple. The solutions are well defined. I didn&#39;t write a 5000 line Jai program. I wrote 25 Jai tiny programs that are at most a few hundred lines.</p>


            

            <p>I was going to share more AoC snippets but they&#39;re &#34;more of the same&#34;. It&#39;s all on <a href="https://github.com/forrestthewoods/aoc2022/blob/master/jai/main.jai">GitHub</a> if you&#39;d like to look.</p>

            <p>Would I recommend AoC to learn Jai? Absolutely! It&#39;s a great and fun way to learn the basics of any language, imho.</p>

            <p>Would I recommend Jai for competitive programming? Definitely not. Jai isn&#39;t designed for leet code. This year&#39;s AoC winner invented their own language <a href="https://github.com/betaveros/noulith">noulith</a> which is pure code golf sugar. I kinda love it. But that ain&#39;t Jai.</p>

            <p>If you want to solve puzzles fast use Python. If you want puzzle solutions that run fast use Rust. If you want to learn a new language then use anything.</p>

            

            

            <p>I want to discuss cool language features. I think it&#39;s necessary to go over memory management first.</p>
            
            

            <p>Jai does not have garbage collection. Memory is managed manually by the programmer.</p>

            

            <p>Jai has no destructors. There is no RAII. Users must manually call free on memory or release on handles. Jai does have <code>defer</code> which makes this a little easier.</p>

<pre><span>// Create a new Foo that we implicitly own and must free</span>
foo <span>:</span> <span>*</span>Foo <span>=</span> generate_new_foo();

<span>// free the Foo when this scope ends</span>
defer free(foo); 
</pre>

            <p>No destructors is very much like C and not at all like C++. If you&#39;re a C++ programmer you may be recoiling in horror. I beg you to keep an open mind.</p>

            

            <p>Jai documentation spends over 7000 words describing its philosophy on memory management. That&#39;s longer than my entire blog post! I can&#39;t possibly summarize it here.</p>

            <p>One subsection resonated with me. Jai theorizes that there are roughly four categories of lifetimes. </p>

            <ol>
                <li>Extremely short lived. Can be thrown away by end of function.</li>
                <li>Short lived + well defined lifetime. Memory allocated &#34;per frame&#34;.</li>
                <li>Long lived + well defined owner. Uniquely owned by a subsystem.</li>
                <li>Long lived + unclear owner. Heavily shared, unknown when it may be accessed or freed.</li>
            </ol>

            <p>Jai thinks that most program allocations are category 1. That category 4 allocations should be rare in well written programs. And that C++ allocators and destructors are focused on supporting cat 4. </p>

            <p>Categories 2 and 3 are best served by arena allocators. Consider a node based tree or graph. One implementation might be to manually `malloc` each node. Then `free` each node individually during shut down. A simpler, faster alternative would be to use an arena and `free` the whole thing in one simple call.</p>

            <p>These categories are NOT hard baked into the Jai language. However the ideas are heavily reflected.</p>

            
            
            <p>Jai provides standard access to both a &#34;regular&#34; heap allocator and a super fast temporary allocator for category 1 allocations.</p>

            <p>The temp allocator is a simple linear allocator / bump allocator. An allocation is a simple increment into a block of memory. Objects can not be freed individually. Instead the entire block is reset by simply resetting the offset to zero.</p>

<pre>silly_temp_print <span>::</span> (foo<span>:</span> Foo) <span>-&gt;</span> string {
  <span>// tprint allocates a new buffer</span>
  <span>// uses the temp allocator</span>
  <span>return</span> tprint(<span>&#34;hello world from %&#34;</span>, foo)
}

<span>// no destructor means we have to deal with memory</span>
msg <span>:</span> string <span>=</span> silly_temp_print(my_foo);

<span>// awhile later (maybe once per frame)</span>
reset_temporary_storage();   
</pre>

            <p>In this example we printed a <code>string</code> using the <code>temp</code> allocator via <code>tprint</code>. The function <code>silly_temp_print</code> doesn&#39;t own or maintain the <code>string</code>. The caller doesn&#39;t need to manually call <code>free</code> because it knows that <code>reset_temporary_storage()</code> will be called at some point.</p>

            <p>The concept of a temporary allocator is baked into Jai. Which means both library authors and users know it exists and can rely on it. </p>

            <p>Most allocations in most programs are very short lived. The goal of the temporary alloactor is to make these allocations super cheap in both performance and mental effort.</p>

            

            

            <p>At this point we&#39;ve seen some simple Jai code and learned a little bit about its memory management rules. Now I want to share Jai features and ideas that I think are interesting.</p>

            <p>This is explicitly NOT in tutorial order. Can Jai do all the basic things any language can do? Yes. Am I going to tell you how? No.</p>

            <p>Instead I&#39;m going to share more advanced ideas. These are the types of things you don&#39;t learn on day 1 but may provide the most value on day 1000.</p>

            

            <p>In Jai every procedure has an implicit <code>context</code> pointer. This is similar to how C++ member functions have an implicit <code>this</code> pointer.</p>

            <p>The context contains a few things:</p>

            <ol>
                <li>default memory allocator</li>
                <li>temporary allocator</li>
                <li>logging functions and style</li>
                <li>assertion handler</li>
                <li>cross-platform stack trace</li>
                <li>thread index</li>
            </ol>

            <p>This allows useful things like changing the memory allocator or logger when calling into a library. <code>contexts</code> can also be pushed.</p>

<pre>do_stuff <span>::</span> () {
  <span>// copy the implicit context</span>
  new_context <span>:=</span> context;

  <span>// change the default allocator to arena</span>
  new_context.allocator <span>=</span> my_arena_allocator;
  
  <span>// change the logger</span>
  new_context.logger <span>=</span> my_cool_logger;
  new_context.logger_data <span>=</span> my_logger_data;

  <span>// push the context</span>
  <span>// it pops when scope completes</span>
  push_context new_context {
    <span>// new_context is implicitly passed to subroutine</span>
    <span>// subroutine now uses our allocator and logger</span>
    call_subroutine();
  }
}
</pre>

            <p>The <code>context</code> struct can be extended with additional user data. However this doesn&#39;t play nice with <code>.dlls</code> so there are still design problems to solve.</p>

            <p>I <a href="https://www.forrestthewoods.com/blog/global-variables-are-evil-and-unsafe/">hate globals</a> with a fiery passion. I wish all languages had a <code>context</code> struct. It&#39;s quite elegant.</p>

            

            <p>One of the most powerful ideas I&#39;ve seen in Jai is the rampant use of compiler directives.</p>

            <p>Here&#39;s an example of <code>#complete</code> which forces an enum switch to be exhausive at compile-time.</p>

<pre><span>// Declare enum </span>
Stuff <span>::</span> <span>enum</span> { 
  Foo; 
  Bar; 
  Baz; 
};
    
<span>// Create variable</span>
stuff <span>:=</span> Stuff.Baz;

<span>// Compile Error: This &#39;if&#39; was marked #complete...</span>
<span>// ... but the following enum value was missing: Baz</span>
<span>if</span> <span>#complete</span> stuff <span>==</span> {
  case .Foo;  print(<span>&#34;found Foo&#34;</span>);
  case .Bar;  print(<span>&#34;found Bar&#34;</span>);
}
</pre>
            <p>This is a simple but genuinely useful example. Languages spend a <i>lot</i> of time bikeshedding syntax, keywords, etc. Meanwhile Jai has dozens of compiler directives and they&#39;re seemingly added willy nilly.</p>

            <p>Here are some of the directives currently available.</p>

<pre><span>#add_context</span>       inject data into context
<span>#as</span>                struct can cast to member
<span>#asm </span>              inline assembly
<span>#bake_arguments</span>    bake argument into function
<span>#bytes</span>             inline binary data
<span>#caller_location</span>   location of calling code
<span>#c_call </span>           c calling convention
<span>#code</span>              statement is code
<span>#complete</span>          exhaustive enum check
<span>#compiler</span>          interfaces with compiler internals
<span>#compile_time</span>      compile-time true/false
<span>#cpp_method</span>        C++ calling convention
<span>#deprecated</span>        induces compiler warning
<span>#dump</span>              dumps bytecode
<span>#expand</span>            function is a macro
<span>#filepath</span>          current filepath as a string
<span>#foreign</span>           foreign procedure
<span>#library</span>           file for foreign functions
<span>#system_library</span>    system file for foreign functions
<span>#import</span>            import module
<span>#insert</span>            inject code
<span>#intrinsic</span>         function handled by compiler
<span>#load</span>              includes target file
<span>#module_parameters</span> declare module &#34;argument&#34;
<span>#must</span>              return value must be used
<span>#no_abc</span>            disable array bounds checking
<span>#no_context</span>        function does not take context
<span>#no_padding</span>        specify no struct padding
<span>#no_reset</span>          global data persists from compile-time
<span>#place</span>             specify struct member location
<span>#placeholder</span>       symbol will be generated at compile-time
<span>#procedure_name</span>    acquire comp-time procedure name
<span>#run</span>               execute at compile-time
<span>#scope_export</span>      function accessible to whole program
<span>#scope_file</span>        function only accessible to file
<span>#specified</span>         enum values must be explicit
<span>#string</span>            multi-line string
<span>#symmetric</span>         2-arg function can be called either way
<span>#this</span>              return proc, struct, or data type
<span>#through</span>           if-case fall through
<span>#type</span>              next statement is a type
</pre>

            <p>They do a lot of things. Some simple things. Some big things we&#39;ll learn more about.</p>

            <p>What I think is rad is how game changing they are given how easy they are to add. They don&#39;t require bikeshed committees. They can be sprinkled in without declaring a new keyword that breaks existing programs. They appear to make it radically easier to elegantly add new capabilities.</p>

            

            

            <p>Jai has robust support for run-time reflection. Here is a very simple example.</p>

<pre>Foo <span>::</span> <span>struct</span> {
  a<span>:</span> s64;
  b<span>:</span> <span>float</span>;
  c<span>:</span> string;
}

Runtime_Walk <span>::</span> (ti<span>:</span> Type_Info_Struct) {

  print(<span>&#34;Type: %</span><span>\n</span><span>&#34;</span>, ti.name);
  <span>for</span> <span>*</span>ti.members {
    member <span>:</span> <span>*</span>Type_Info_Struct_Member <span>=</span> it;
    member_ti <span>:</span> <span>*</span>Type_Info <span>=</span> member.<span>type</span>;
    print(<span>&#34;  %&#34;</span>, member.name);
    print(<span>&#34;  % bytes&#34;</span>, member_ti.runtime_size);

    mem_type <span>:=</span> <span>&#34;unknown&#34;</span>;
      <span>if</span> member_ti.<span>type</span> <span>==</span> {
        case .INTEGER;  mem_type <span>=</span> <span>&#34;int&#34;</span>;
        case .FLOAT;    mem_type <span>=</span> <span>&#34;float&#34;</span>;
        case .STRING;   mem_type <span>=</span> <span>&#34;string&#34;</span>;
        case .STRUCT;   mem_type <span>=</span> (cast(<span>*</span>Type_Info_Struct)member_ti).name;
    }

    print(<span>&#34;  %</span><span>\n</span><span>&#34;</span>, mem_type);
  }
}

Runtime_Walk(type_info(Foo));
</pre>

            <p>At run-time this will print:</p>

<pre>Type<span>:</span> Foo
  a  <span> 8</span> bytes  <span>int</span>
  b  <span> 4</span> bytes  <span>float</span>
  c  <span>16</span> bytes  string
</pre>

            <p>This is an exceedingly powerful tool. It&#39;s built right into the language with full support for all types - primitives, enums, structs, procedures, etc.</p>

            

            <p>Jai has extremely powerful compile time capabilities. Like, frighteningly powerful.</p> 

            <p>First, here is a small syntax tutorial.</p>

<pre><span>// this is compile-time constant because ::</span>
<span>// you may have noticed that structs, enums,</span>
<span>// and procedures have all used ::</span>
foo <span>::</span> <span>5</span>; 

<span>// this is variable because :=</span>
bar <span>:=</span> <span>5</span>;
</pre>

            
            
            <p>Here&#39;s a super basic example of compile-time capabilities.</p>

<pre>factorial <span>::</span> (x<span>:</span> <span>int</span>) <span>-&gt;</span> <span>int</span> {
  <span>if</span> x <span>&lt;=</span> <span>1</span> <span>return</span> <span>1</span>;
  <span>return</span> x <span>*</span> factorial(x<span>-</span><span>1</span>);
}

<span>// :: means compile-time constant</span>
<span>// note the use of #run</span>
x <span>::</span> <span>#run</span> factorial(<span>5</span>);
print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, x);

<span>// compile error because factorial(5) is not constant</span>
<span>// y :: factorial(5);</span>

<span>// executes at runtime</span>
z <span>:=</span> factorial(<span>5</span>);
</pre>

            <p>Any code that has <code>#run</code> will be performed at compile-time. It can call <i>any</i> code in your program. Including code that allocates, reads files from disk, etc. ðŸ¤¯</p>

            

            <p>The <code>#insert</code> directive lets you insert code. Here&#39;s a toy example.</p>
            
<pre><span>// runtime variable</span>
x <span>:=</span> <span>3</span>;

<span>// insert string as code</span>
<span>#insert</span> <span>&#34;x *= 3;&#34;</span>;

<span>// runtime value of x is 9</span>
print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, x);
</pre>

            <p>This inserts the string <code>&#34;x *=3;&#34;</code> as code. This is silly because we could have just written that code like a normal person. However we can combine <code>#insert</code> with <code>#run</code> and do things that are starting to become interesting.</p>

<pre><span>// runtime variable</span>
x <span>:=</span> <span>3</span>;

<span>// helper to generate a string that represents code</span>
gen_code <span>::</span> (v<span>:</span> <span>int</span>) <span>-&gt;</span> string {
  <span>// compile-time string alloc and format!</span>
  <span>return</span> tprint(<span>&#34;x *= %;&#34;</span>, v);
}

<span>// generate and insert x *= 3;</span>
<span>#insert</span> <span>#run</span> gen_code(<span>3</span>);
print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, x); <span>// prints 9</span>

<span>// compile-time run factorial(3) to produce 6</span>
<span>// insert code x *= 6</span>
<span>#insert</span> <span>#run</span> gen_code(factorial(<span>3</span>));
print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, x); <span>// print 54</span>
</pre>

            <p>We can insert arbitrary <code>strings</code> as code. At compile-time we can execute arbitrary Jai code that generates and inserts <code>strings</code>. ðŸ¤¯ðŸ¤¯</p>

            

            <p>Thus far we&#39;ve been operating on <code>strings</code>. Jai can also operate with type safety. </p>

<pre><span>// runtime variable</span>
x <span>:=</span> <span>3</span>;

<span>// #expand makes this a &#34;macro&#34; so it can</span>
<span>// access variables in its surrounding scope</span>
do_stuff <span>::</span> (c<span>:</span> Code) <span>#expand</span> {
  <span>// splat the code four times</span>
  <span>#insert</span> c;
  <span>#insert</span> c;
  <span>#insert</span> c;
  <span>#insert</span> c;
}

<span>// generate a snippet of code</span>
c <span>:</span> Code <span>:</span> <span>#code</span> { x <span>*=</span> <span>3</span>; };

<span>// at compile-time: expand do_stuff macro</span>
<span>// at run-time: execute code four times</span>
do_stuff(c);

<span>// prints 243</span>
print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, x);
</pre>

            <p>Here we wrote <code>x *= 3;</code> and stored it in a variable of type <code>Code</code>. Then we wrote the macro <code>do_stuff</code> which copy pastes our snippet four times. And we did this with &#34;proper&#34; data types rather than <code>strings</code>. ðŸ¤¯ðŸ¤¯ðŸ¤¯</p>

            

            <p>At compile-time the <code>Code</code> type can be converted to Abstract Syntax Tree nodes, manipulated, and converted back.</p>

<pre><span>// our old friend</span>
factorial <span>::</span> (x<span>:</span> <span>int</span>) <span>-&gt;</span> <span>int</span> {
  <span>if</span> x <span>&lt;=</span> <span>1</span> <span>return</span> <span>1</span>;
  <span>return</span> x <span>*</span> factorial(x<span>-</span><span>1</span>);
}
    
<span>// function we&#39;re going to #run at compile-time</span>
comptime_modify <span>::</span> (code<span>:</span> Code) <span>-&gt;</span> Code {
  <span>// covert Code to AST nodes</span>
  root, expressions <span>:=</span> compiler_get_nodes(code);
  
  <span>// walk AST</span>
  <span>// multiply number literals by their factorial</span>
  <span>// 3 -&gt; 3*factorial(3) -&gt; 3*6 -&gt; 18</span>
  <span>for</span> expr <span>:</span> expressions {
    <span>if</span> expr.kind <span>==</span> .LITERAL {
      literal <span>:=</span> cast(<span>*</span>Code_Literal) expr;
      <span>if</span> literal.value_type <span>==</span> .NUMBER {
        <span>// Compute factorial</span>
        fac <span>:=</span> factorial(literal._s64);
        
        <span>// Modify node in place</span>
        literal._s64 <span>*=</span> fac;
      }
    }
  }
  
  <span>// convert modified nodes back to Code</span>
  modified <span>:</span> Code <span>=</span> compiler_get_code(root);
  <span>return</span> modified;
}

<span>// modify and duplicate code</span>
do_stuff <span>::</span> (code<span>:</span> Code) <span>#expand</span> {
  <span>// modify the code at compile-time</span>
  new_code <span>::</span> <span>#run</span> comptime_modify(code);
  
  <span>#insert</span> new_code;
  <span>#insert</span> new_code;
  <span>#insert</span> new_code;
  <span>#insert</span> new_code;
}

<span>// same as before</span>
x <span>:=</span> <span>3</span>;

c <span>::</span> <span>#code</span> { x <span>*=</span> <span>3</span>; };
do_stuff(c);

<span>// prints 3*18*18*18*18 = 314,928</span>
print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, x);
</pre>

            <p>In this example we:</p>

            <ol>
                <li>Declare the code <code>x *= 3;</code></li>
                <li>Compile-time modify the compiler parsed AST to <code>x *= 18;</code></li>
                <li>Insert <code>x *= 18;</code> four times</li>
            </ol>

            <p>We did all of this with code that looks and runs like regular vanilla Jai code. It isn&#39;t a new macro language using <code>#define</code> string manipulation or complex <code>macro_rules!</code> syntax. ðŸ¤¯ðŸ¤¯ðŸ¤¯ðŸ¤¯</p>

            <p>The possibilities for this are endless. Frighteningly endless even. Excessive compile-time code is more complex and harder to understand.</p>

            <p><img src="https://www.forrestthewoods.com/blog/learning-jai-via-advent-of-code/assets/img/03.jpg" width="100%" alt="With great power comes great responsibility"/></p>
                
            <p>I want to make a small detour share a small moment where Jai really sparked my joy.</p>

            <p>For Advent of Code I wrote a simple <code>assert_eq</code> macro I was proud of. It prints both the values that failed to match and also the expression that produced the value.</p>

<pre>assert_eq <span>::</span> (a<span>:</span> Code, b<span>:</span> Code) <span>#expand</span> {
  sa <span>:=</span> <span>#run</span> code_to_string(a);
  va <span>:=</span> <span>#insert</span> a;
  
  sb <span>:=</span> <span>#run</span> code_to_string(b);
  vb <span>:=</span> <span>#insert</span> b;
  <span>assert</span>(va <span>==</span> vb, 
    <span>&#34;(left == right)</span><span>\n</span><span>  left: %  expr: %</span><span>\n</span><span>  right: %  expr: %</span><span>\n</span><span>  loc: %</span><span>\n</span><span>&#34;</span>,
    va, sa, vb, sb,
    <span>#location</span>(a));
}

assert_eq(<span>42</span>, factorial(<span>3</span>));
<span>// stderr:</span>
<span>// C:/aoc2022/main.jai:154,5: Assertion failed: (left == right)</span>
<span>//   left: 42  expr: 42</span>
<span>//   right: 6  expr: factorial(3)</span>
<span>//   loc: {&#34;C:/aoc2022/main.jai&#34;, 85, 15}</span>
</pre>

        <p>It prints the value and also the code that produced the value. That&#39;s neat. It made me happy. It was a fun moment. </p>

        <p>Rust has convenient built-ins like <code>#[derive(Hash)]</code>. The community has built ultra powerful libraries like <code>serde</code>. Jai doesn&#39;t an ecosystem of similar libraries yet. I believe the powerful compile-time capabilities should make them possible. I&#39;m very curious to see what folks come up with.</p>

        

        

        <p>Now we&#39;re at the phase of what I&#39;ll call &#34;medium impact ideas&#34;. These ideas are super important, but perhaps a little less unique.</p>

        

        <p>Jai does not have object oriented polymorphism ala <code>virtual</code> functions. It does have &#34;polymorphic procedures&#34; which are Jai&#39;s version of <code>templates</code>, <code>generics</code>, etc. Naming things is hard. This name may change.</p>

        <p>Here&#39;s a basic example:</p>

<pre><span>// Jai</span>
square <span>::</span> (x<span>:</span> $T) <span>-&gt;</span> T {
  <span>return</span> x <span>*</span> x;
}

<span>// C++ equivalent</span>
template<span>&lt;</span>typename T<span>&gt;</span>
T square(T x) {
  <span>return</span> x <span>*</span> x;
}
</pre>

            <p>The <code>$T</code> means the type will be deduced at compile-time. Like most compiled languages this function is compiled for all necessary types and there is no dynamic dispatch or run-time overhead.</p>

            <p>Polymorphic procedure syntax has some subtle niceties to improve compiler errors.</p>

<pre><span>// compile error. $T can only be defined once.</span>
foo <span>::</span> (a<span>:</span> $T, b<span>:</span> $T);

<span>// deduce from array type</span>
array_add1 <span>::</span> (arr<span>:</span> [..]$T, value<span>:</span> T);

<span>// deduce from value type (gross)</span>
array_add2 <span>::</span> (arr<span>:</span> [..]T, value<span>:</span> $T);

<span>// dynamic array of ints</span>
nums<span>:</span> [..] <span>int</span>;

<span>// Error: Type mismatch. Type wanted: int; type given: string.</span>
array_add1(<span>*</span>nums, <span>&#34;not an int&#34;</span>);

<span>// Error: Type mismatch. Type wanted: *[..] string; type given: *[..] int.</span>
array_add2(<span>*</span>nums, <span>&#34;not an int&#34;</span>);
</pre>

            <p>Explicitly specifying which argument defines the type <code>T</code> is intuitive. It also enables much better error messages for compiler errors.</p>

            

            <p><code>structs</code> can also be declared polymorphically. </p>

<pre>Vector <span>::</span> <span>struct</span>($T<span>:</span> Type, $N<span>:</span> s64) {
  values <span>:</span> [N]T;
}

<span>// a simple vector of 3 floats</span>
Vec3 <span>::</span> Vector(<span>float</span>, <span>3</span>);
v1 <span>:</span> Vec3 <span>=</span> .{.[<span>1</span>,<span>2</span>,<span>3</span>]};

<span>// a big vector of 1024 ints (for some reason)</span>
BigVec <span>::</span> Vector(<span>int</span>, <span>1024</span>);
v2 <span>:</span> BigVec <span>=</span> .{.[<span>/*omitted*/</span>]};
</pre>

            <p>You can use this for simple types, <code>vectors</code>, <code>hash_maps</code>, etc. It&#39;s an important example of how Jai is C+ and not C.</p>

            

            <p>Build systems are a pain in the ass. Some languages require a configuration language just to define their build. Make, MSBuild, Ninja, etc. This build language may or may not be cross-platform.</p>

            <p>Jai provides a built-in build system that uses vanilla Jai code. Here is a very simplified look.</p>

<pre>build <span>::</span> () {
  <span>// workspace is a &#34;build mode&#34; like debug, release, shipping, etc</span>
  w <span>:=</span> compiler_create_workspace();
  
  <span>// get CLI args</span>
  args <span>:=</span> options.compile_time_command_line;
  
  <span>// set some flags and stuff</span>
  option <span>:=</span> get_build_options();
  <span>for</span> arg <span>:</span> args {
    <span>if</span> arg <span>==</span> <span>&#34;-release&#34;</span> {
      options.optimization_level <span>=</span> .RELEASE<span>:</span>
    }
  }
  set_build_options(options, w);
  
  <span>// specifiy target files</span>
  <span>// compiler auto-starts in background</span>
  add_build_string(TARGET_PROGRAM_TEXT, w);
  add_build_file(<span>&#34;extra_file.jai&#34;</span>, w);
}

<span>// invoke at compile-time via #run</span>
<span>#run</span> build();
</pre>

            <p>Jai ships <code>default_metaprogram.jai</code> and <code>minimal_metaprogram.jai</code> so users do not have to manually write this every time. Larger programs will inevitably have their own build systems to perform more complex operations.</p>

            <p>Jai&#39;s approach to a build systems is interesting. Having a real programming language is great. It&#39;s better than <code>cmake</code> hell.</p>

            <p>My professional life is a polyglot of languages (C, C++, C#, Rust, Python, Matlab, Javascript) and operating systems (Windows, macOS, Linux, Android, embedded) and devices (PC, Quest, Hololens, embedded) and environments (Unity, Unreal, Matlab, Jupytr, web). Kill me. â˜ </p>

            <p>C++ is under-defined and doesn&#39;t define any build system. Modern languages have rectified this and it&#39;s much better.</p>

            <p>Unfortunately I don&#39;t think anyone has solved &#34;the build system problem&#34; yet. I&#39;m not sure it can be &#34;solved&#34;. :( </p>

            

            

            <p>This post is getting too long. I&#39;m going to punt &#34;Small Ideas&#34; to the end of the post as a &#34;bonus section&#34;</p>

            

            

            <p>So, what do I think about Jai? Numerous folks have asked me this. It&#39;s incredibly hard to answer.</p>

            

             

            

             
            
            <p>I&#39;m intrigued by Jai&#39;s style of memory management. I&#39;m not fully sold just yet. Jai is chipping away at the ergonomics but hasn&#39;t cracked it yet.</p>

            <p>Ask me again in 2 years.</p>

            
            
            <p>I also think Rust still sucks for some things, like UI and games. There&#39;s cool projects trying to fix that. They&#39;re not there yet. Since Rust is not a good fit I would prefer Jai for such projects.</p>

            

            

            

            

            

            
             
            
            <p>Jai will be popular with the Handmade community. I expect folks will produce cool things. Jai will get off the ground. It may or may not hit escape velocity and reach the stars. I&#39;m rooting for it!</p>

            
            
            <p>Building a game engine is hard. Not many studios are capable of it. Maybe Jai will allow some mid sized indies to more effectively build custom engines to make games that Unity/Unreal are a bad fit for? That&#39;d be a very successful outcome I think.</p>

            
            
            <p>Designers and artists don&#39;t care what language their tools were made in. Being 15% better isn&#39;t enough to overcome inertia. It needs to be at least 50% better. Maybe even 100% better. That&#39;s tough.</p>

            

            

            

            

            

            

            

            <p>Let&#39;s wrap this up.</p>

            <p>Coming into all this I knew little to nothing about Jai. I got into the beta. Participated in Advent of Code. Read all the tutorials. And watched some videos. </p>

            <p>I feel like I have decent grasp of Jai&#39;s basics. I can see some of the things it&#39;s trying to do. It would take working on a big project to see if its ideas payoff.</p>

            <p>The Jai beta is still very small. If you&#39;ve got a project you&#39;d like to write or port to Jai you can probably get yourself in. If you just want to poke around for 30 minutes you&#39;d be better off waiting.</p>

            <p>I love the solution space that Jai is exploring. I&#39;m onboard with its philosophy. It has some genuinely good ideas and features. It&#39;s a very ambitious project. I hope it achieves its lofty goals.</p>

            <p>Thanks for reading. </p>

            <p>(keep scrolling for more bonus content)</p>

            

            

            <p>Welcome to the bonus section! There&#39;s so many things I want to talk about. For the sake of semi-brevity and narrative I can&#39;t say them all. Here&#39;s some unsorted and less polished thoughts from the cutting room. </p>

            

            <p>Sometimes I think about languages in 3 parts:</p>

            <ol>
                <li><b>Language</b>. Syntax, keywords, &#34;built-in&#34; features, etc.</li>
                <li><b>Standard library</b>. &#34;User mode&#34; code that you could have written yourself but ships with the compiler for convenience.</li>
                <li><b>Ecosystem</b>. Libraries written by the community.</li>
            </ol>

            <p>This post focused almost entirely on language. Jai is still in a small beta. I&#39;ll worry about the standard library and ecosystem later.</p>

            <p>Jai ships with a very small standard library. It is NOT a &#34;batteries included&#34; language. It wants to avoid compiling tens of thousands of lines of code because you imported a single file. </p>

            <p>Ecosystem can make or break language adoption. Python kinda sucks as a language, but the ecosystem is unrivaled. A key selling point of Rust is the vibrant and robust crate ecosystem. I don&#39;t know what approach Jai will ultimately take.</p>

            

            <p>One of Jai&#39;s selling points is fast compile times. They&#39;re relatively fast?</p> 

            <p>Here&#39;s a comparison between my 2022 Jai code and my 2021 Rust code. It&#39;s not quite apples to apples. But it&#39;s pretty similar.</p>

            <pre><b>Advent of Code 2022 (Jai) </b>
Jai debug full              0.56 seconds
Jai release full            1.36 seconds

Jai debug incremental       0.56 seconds
Jai release incremental     1.36 seconds

<b>Advent of Code 2021 (Rust)</b>
Rust debug full             13 seconds
Rust release full           14 seconds

(incremental)
Rust debug incremental      0.74 seconds
Rust release incremental    0.74 seconds</pre>

            <p>Jai doesn&#39;t do incremental builds. It always compiles everything from scratch. The long term goal is a million lines per second. The compiler is currently not fully multi-threaded.</p>

            <p>My impression is that Jai doesn&#39;t have any magic secret sauce to fast compile times. How do you make compiling fast? Compile fewer lines of code! Makes sense. But maybe a little disappointing. I wanted magic!</p>

            

            <p>I did not do extensive performance testing with Jai. It seems fast?</p>

            <p>I ported one solution that was running quite slow to C++ to compare. My C++ version ran slower. This was because C++ <code>std::unordered_map</code> was slower than Jai <code>Hash_Table</code>.</p>

            <p>I am NOT claiming that Jai is faster than your favorite language. However I am not concerned about Jai&#39;s performance long-term. It should be just as fast as other compiled languages. It&#39;s idioms may or may not be faster than another language&#39;s idioms.</p>

            

            <p>Once upon a time Jai talked about automagic struct-of-arrays compiler features. Those features have been cut. I believe the use cases were so specific that no generalized solution presented itself.</p>

            

            <p>I&#39;ll be honest, the only assembly I&#39;ve ever written was in school. It&#39;s not my jam.</p>

            <p>Jai might have some cool assembly features? I dunno!</p>

<pre>result <span>:</span> s64 <span>=</span> <span>0</span>;

<span>#asm</span> {
  <span>// compiler picks a general purpose register for you</span>
  <span>// that seems cool?</span>
  foo <span>:</span> gpr;
  bar <span>:</span> gpr;
  
  <span>// assign some 64-bit qwords</span>
  mov.q foo, <span>42</span>;
  mov.q bar, <span>13</span>;
  
  <span>// foo += bar</span>
  add foo, bar;
  
  <span>// result = foo</span>
  mov result, foo;
}

print(<span>&#34;%</span><span>\n</span><span>&#34;</span>, result);
<span>// prints: 15</span>
</pre>

            <p>Jai will allocate registers for you. If it runs out of registers it&#39;s a compiler error. Seems nice?</p>

            
            
            <p>Jai is NOT a memory safe language. Debug mode checks array bounds which is nice. But that&#39;s about it?</p>

            <p>There&#39;s no compile-time borrow checker. There&#39;s no checks for memory leaks or use after free. It&#39;s the C/C++ wild west for better or worse.</p>
            
            <p>There&#39;s also no special safety for multi-threading either. You&#39;re on your own just like in C/C++.</p>

            <p>There&#39;s also no mechanisms for async code.</p>

            

            <p>Jai imports modules. I think it follows typical module rules? It has some assorted macros. </p>

<pre><span>#import</span> <span>&#34;Foo&#34;</span>   <span>// import module</span>
<span>#load</span> <span>&#34;bar.jai&#34;</span> <span>// similar-ish to #include</span>
<span>#scope_file</span>     <span>// code is NOT exposed via import/load</span>
<span>#scope_export</span>   <span>// code is exposed via import/load</span>
</pre>
    
            <p>Jai does not have namespaces. It solves the C name collision issue by letting module imports be assigned to a name.</p>

<pre><span>// foo.jai</span>
do_stuff <span>::</span> () { <span>/* omitted */</span> }

<span>// bar.jai</span>
do_stuff <span>::</span> () { <span>/* omitted */</span> }

<span>// main.jai</span>
<span>#import</span> <spanstyle="color: #cc3300"="">&#34;Foo&#34;
Bar <span>::</span> <span>#import</span> <span>&#34;Bar&#34;</span>;

do_stuff(); <span>    // calls foo.jai do_stuff</span>
Bar.do_stuff(); <span>// calls bar.jai do_stuff</span>
</spanstyle="color:></pre>

            <p>Problem solved?</p>

            

            

            <p>As previously discussed, here are smaller language features I think are neat, valuable, or uncommon.</p>
            
            

            <p>By default all values in structs are initialized. You can have uninitialized memory but it&#39;s strictly opt-in via <code>---</code>.</p>

<pre>foo <span>:</span> <span>float</span>; <span>// zero</span>

Vec3 <span>::</span> <span>struct</span> { x, y, z<span>:</span> <span>float</span> };
bar <span>:</span> Vec3; <span>// 0,0,0</span>

baz <span>:</span> Vec3 <span>=</span> <span>---</span>; <span>// uninitialized</span>
</pre>

            <p>There are mechanics for specifying non-zero initial values. However there are no constructors.</p>

            

            <p>Printing in Jai is safe and simple. It doesn&#39;t use error prone printf specifier.</p>

<pre>Foo <span>::</span> <span>struct</span> {
  a <span>:</span> <span>int</span>;
  b <span>:</span> bool;
  c <span>:</span> string;
  d <span>:</span> Bar;
}

Bar <span>::</span> <span>struct</span> {
  x <span>:</span> <span>float</span>;
  y <span>:</span> string;
  z <span>:</span> [..]<span>int</span>;
}

foo <span>:=</span> Foo.{
  <span>42</span>, <span>true</span>, <span>&#34;hello&#34;</span>,
  Bar.{ <span>13.37</span>, <span>&#34;world&#34;</span>, .[<span>1</span>,<span>2</span>,<span>3</span>]}
};

print(<span>&#34;foo: %</span><span>\n</span><span>&#34;</span>, foo);
<span>// prints: {42, true, &#34;hello&#34;, {13.37, &#34;world&#34;, [1, 2, 3]}}</span>
</pre>

            <p>There are mechanics for fancy formatting. The important thing is that the simple case &#34;just works&#34;.</p>

            

            <p>Jai has an amazing feature I want so badly in other languages. It&#39;s what I would call a &#34;type safe typedef&#34;.</p>

<pre><span>// cpp: using HandleA = u32;</span>
<span>// rust: type HandleA = u32;</span>
HandleA <span>::</span> <span>u32</span>;

<span>// cpp: no equivalent</span>
<span>// rust: no equivalent</span>
HandleB <span>::</span> <span>#</span><span>type</span>,distinct <span>u32</span>;

<span>// Functions</span>
do_stuff_u <span>::</span> (h<span>:</span> <span>u32</span>) { <span>/* ... */</span> }
do_stuff_a <span>::</span> (h<span>:</span> HandleA) { <span>/* ... */</span> }
do_stuff_b <span>::</span> (h<span>:</span> HandleB) { <span>/* ... */</span> }

<span>// Variables</span>
u <span>:</span> <span>u32</span> <span>=</span> <span>7</span>;
a <span>:</span> HandleA <span>=</span> <span>42</span>;
b <span>:</span> HandleB <span>=</span> <span>1776</span>;

<span>// HandleA converts to u32</span>
<span>// HandleB does not</span>

<span>// Assignment</span>
u <span>=</span> a;
a <span>=</span> u;
<span>// a = b; // compile error</span>
<span>// b = a; // compile error</span>
<span>// u = b; // compile error</span>
<span>// b = u; // compile error</span>

<span>// procedure takes u32</span>
do_stuff_u(u);
do_stuff_u(a);
<span>//do_stuff_u(b); // compile error</span>

<span>// procedure takes HandleA</span>
do_stuff_a(u);
do_stuff_a(a);
<span>// do_stuff_a(b); // compile error</span>

<span>// procedure takes HandleB</span>
<span>// do_stuff_b(u); // compile error</span>
<span>// do_stuff_b(a); // compile error</span>
do_stuff_b(b);
</pre>
    
            <p>This is exceedingly valuable for handles. I&#39;ve lost track of how many wrapper structs I&#39;ve written.</p>

            

            <p>Something you may have noticed is everything is declared the same way.</p>

<pre><span>// compile-time constants use ::</span>
my_func <span>::</span> (v<span>:</span> <span>int</span>) <span>-&gt;</span> <span>int</span> { <span>return</span> v <span>+</span> <span>5</span>; }
my_enum <span>::</span> <span>enum</span> { Foo; Bar; Baz; }
my_struct <span>::</span> <span>struct</span> { v<span>:</span> <span>int</span>; }
my_const_float <span>::</span> <span>13.37</span>;
my_const_string <span>::</span> <span>&#34;hello world&#34;</span>;
my_func_type <span>::</span> <span>#</span><span>type</span> (<span>int</span>) <span>-&gt;</span> <span>int</span>;

<span>// variables use  :=</span>
<span>// the type can be explicit or deduced</span>
a_func_ptr <span>:</span> my_func_type <span>=</span> my_func;
a_float <span>:</span> <span>float</span> <span>=</span> my_const_float;
an_int <span>:</span> <span>int</span> <span>=</span> <span>42</span>;
another_int <span>:=</span> a_func_ptr(an_int);
a_type <span>:</span> Type <span>=</span> string;
another_type <span>:=</span> type_of(an_int);
</pre>

            <p>This standard syntax is surprisingly nice. It&#39;s simple and consistent.</p>

            <p>Some languages are exceedingly difficult and ambigious to parse. Jai strives to be easy to parse and to provide access to the AST to users. This will eventually enable very robust and reliable IDE support.</p>

            <p>Everyone has their own opinion on syntax. I work in enough languages I don&#39;t really care. Any C-ish syntax is easy to get used to. I&#39;ll gladly adapt to any rational syntax if it enables better tooling.</p>

            

            <p>Jai has first-class relative pointers. They store an offset relative to the pointer&#39;s storage address. </p>

<pre>Node <span>::</span> <span>struct</span> {
  <span>// relative pointer stored in s16</span>
  next<span>:</span> <span>*~</span>s16 Node;
  value<span>:</span> <span>float</span>;
}

<span>// Declare two nodes</span>
a <span>:=</span> Node.{null, <span>1337</span>};
b <span>:=</span> Node.{null, <span>42</span>};
a.next <span>=</span> <span>*</span>b;

<span>// can directly dereference relative pointer</span>
value <span>:=</span> a.next.value;
print(<span>&#34;rel: %  value: %</span><span>\n</span><span>&#34;</span>, a.next, value);

<span>// can convert to absolute pointer</span>
abs_ptr <span>:=</span> cast(<span>*</span>Node)rel_ptr;
print(<span>&#34;abs: %  value: %</span><span>\n</span><span>&#34;</span>, abs_ptr, abs_ptr.value);

<span>// example output:</span>
<span>// rel: r60 (5c_5d6f_ecc8)  value: 42</span>
<span>// abs: 5c_5d6f_ecc8  value: 42</span>
</pre>

            <p>Yes you could store an integer offset. What makes it nice is the syntax for using a relative pointer is the same as a regular pointer. The language handles applying the offset for you.</p>

            <p>Obvious use cases for this are packing data and deserializing binary blobs without having to run a fixup pass.</p>

            

            <p>Jai doesn&#39;t have references. Just value and pointers. It belives that references provide minimal value but significantly increase the complexity of the type system.</p>

            

            <p>Jai doesn&#39;t have the concept of a const pointer or variable. Yes there are compile time constants. But there&#39;s no way to declare a run-time variable and say you won&#39;t change it. </p>

            

            <p>Arguments are passed to procedure &#34;maybe by reference&#34;. This is kinda wild.</p>

            <p>Types <code>&lt;= 8 bytes</code> are passed by value. Types <code>&gt;8 bytes</code> are passed maybe by reference. The compiler might pass it by a pointer. Or maybe not! Who knows.</p>

            <p>However the code must be written as if it were passed by, in C++ parlance, <code>const &amp;</code>.</p>

<pre>do_stuff <span>::</span> (s<span>:</span> string) {
  <span>// compiler error</span>
  <span>// Error: Can&#39;t assign to an immutable argument.</span>
  s.count <span>=</span> <span>0</span>;
  
  <span>// you can make a copy and change that</span>
  s2 <span>:=</span> s;
  s2.count <span>=</span> <span>0</span>;
}
</pre>

            <p>In Jai the compiler is free to decide whether to pass a pointer or by value. This allows Jai to actually treat args as <code>const &amp; restrict</code> and assume that no pointer arguments alias. If you want to modify the arg then simply pass an actual pointer.</p>

            <p>Treating args as <code>const &amp; restrict</code> could be problematic. For example the data might be aliased by an evil global or a pointer. The Jai philosophy is don&#39;t do that and maybe try to detect it in debug mode by making a copy and comparing bytes at the end.</p>

            

            <p><code>Jai does not have virtual functions. However it does have some form what I shall call data-only pseudo-inheritance.</code></p><pre><span>// Declare a base class</span>
Entity <span>::</span> <span>struct</span> {
  id<span>:</span> <span>int</span> <span>=</span> <span>42</span>;
  name<span>:</span> string <span>=</span> <span>&#34;bob&#34;</span>;
}

<span>// Declare a &#34;derived&#34; class&#34;</span>
BadGuy <span>::</span> <span>struct</span> {
  <span>// base: Entity is a data member</span>
  <span>#</span><span>as</span> using base<span>:</span> Entity;
  
  health<span>:</span> <span>int</span> <span>=</span> <span>9000</span>;
}

<span>// Helper to print an entity&#39;s name</span>
print_name <span>::</span> (e<span>:</span> <span>*</span>Entity) {
  print(<span>&#34;Entity: %</span><span>\n</span><span>&#34;</span>, e.name);
}

<span>// Declare a bad hombre</span>
baddie <span>:</span> BadGuy;

<span>// note: not baddie.base.id thanks to `using`</span>
print(<span>&#34;Id: %</span><span>\n</span><span>&#34;</span>, baddie.id);

<span>// *BadGuy casts to *Entity thanks to #as</span>
baddie_ptr <span>:</span> <span>*</span>BadGuy <span>=</span> <span>*</span>baddie;
print_name(baddie_ptr);


<span>// Can also cast the other way</span>
<span>// Don&#39;t get this wrong!</span>
entity_ptr <span>:=</span> baddie_ptr;
baddie_ptr2 <span>:=</span> cast(<span>*</span>BadGuy)entity_ptr;
</pre>

            <p>The <code>#as</code> casting is maybe useful. The <code>using</code> sugar is sometimes nice. It can be used to do some real wacky things that are probably a bad idea.</p>

            

            <p>Imagine you have a custom data container and you want to write <code>for value : myContainer</code>. Jai has a slick mechanism to make this super easy.</p>

<pre><span>// Super dumb Vector with fixed size</span>
FixedVector <span>::</span> <span>struct</span>(ValueType<span>:</span> Type, Size<span>:</span> <span>int</span>) {
  values <span>:</span> [Size]ValueType;
  count <span>:</span> <span>int</span>;
}

<span>// Push a value!</span>
push <span>::</span> (vec<span>:</span> <span>*</span>FixedVector, value<span>:</span> $T) {
  <span>if</span> vec.count <span>&lt;</span> vec.Size {
    vec.values[vec.count] <span>=</span> value;
    vec.count <span>+=</span> <span>1</span>;
  }
}

<span>// iterate all values</span>
<span>for_expansion</span> <span>::</span> (vec<span>:</span> FixedVector, body<span>:</span> Code, flags<span>:</span> For_Flags) <span>#expand</span> {
  <span>// Loop over inner array by count</span>
  <span>for</span> i <span>:</span> <span>0.</span>.vec.count <span>-</span> <span>1</span> {
    <span>// Must declare `it and `it_index</span>
    <span>`</span>it <span>:=</span> vec.values[i];
    <span>`</span>it_index <span>:=</span> i;

    <span>// insert user code</span>
    <span>#</span>insert body;
  }
}

<span>// Declare a vector and push some values</span>
myVec <span>:</span> FixedVector(<span>int</span>, <span>10</span>);
push(<span>*</span>myVec, <span>5</span>);
push(<span>*</span>myVec, <span>1</span>);
push(<span>*</span>myVec, <span>5</span>);
push(<span>*</span>myVec, <span>2</span>);
push(<span>*</span>myVec, <span>5</span>);
push(<span>*</span>myVec, <span>3</span>);

<span>// Loop and print</span>
<span>for</span> value <span>:</span> myVec print(<span>&#34;% &#34;</span>, value);
<span>// prints: 5 1 5 2 5 3</span>
</pre>

            <p>It took roughly 5 lines of code to add write a custom <code>for_expansion</code> for our custom container. We didn&#39;t have to declare a helper struct with a million little helper functions and operators.</p>

            <p>Let&#39;s write a second version that skips values equal to <code>5</code>.</p>

<pre><span>// declare a custom iterator</span>
skip_fives <span>::</span> (vec<span>:</span> FixedVector, body<span>:</span> Code, flags<span>:</span> For_Flags) <span>#expand</span> {
  <span>// perform normal iteration</span>
  <span>for</span> value, index <span>:</span> vec {
    <span>// we don&#39;t like 5, booo!</span>
    <span>if</span> value <span>==</span> <span>5</span> continue;
    
    <span>// declare required `it and `it_index</span>
    <span>`</span>it <span>:=</span> value;
    <span>`</span>it_index <span>:=</span> index;
  
    <span>// insert user code</span>
    <span>#</span>insert body;
  }
}

<span>// iterate using skip_fives</span>
<span>for</span> <span>:</span>skip_fives v<span>:</span> myVec {
    print(<span>&#34;% &#34;</span>, v);
}
<span>// prints: 1 2 3</span>
</pre>

            <p>Here we&#39;ve made a second iteration function called <code>skip_fives</code>. It iterates across the array but ignores any value equal to <code>5</code>. We called it by writing <code>for :skip_fives</code>. </p>

            

            

            <p>Congrats for making it to the end. As a reward here is a picture of my dogs, Tank and Karma. They&#39;re adorable.</p>

            <p><img src="https://www.forrestthewoods.com/blog/learning-jai-via-advent-of-code/assets/img/04.jpg" width="100%" alt="Two Adorable Puppers"/>

        </p></div></div>
  </body>
</html>
