<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://norikitech.com/posts/functional-affirmations/">Original</a>
    <h1>Functional Programming Self-Affirmations</h1>
    
    <div id="readability-page-1" class="page"><div><p>Dmitrii Kovanikov writes posts about enterprise software development and functional programming, both entertaining and serious. I never used a functional programming language (such as Haskell or OCaml) at work, but several ideas from functional programming have become popular in mainstream general-purpose programming languages such as Swift (which I mostly write). Often even a partially functional approach produces simpler code that’s easy to understand and quick to write and maintain. I’m always looking for good ideas I can adopt to write better code, whatever their source.</p>

<p>Dmitrii recently <a href="https://x.com/ChShersh/status/1859922977208598610" target="_blank">posted a tweet</a> (now also <a href="https://bsky.app/profile/chshersh.com/post/3lbjuzgcf6k2w" target="_blank">reposted to Bluesky</a>) titled “Functional programming self-affirmations” that listed five items:</p>

<ol>
<li>Parse, don’t validate</li>
<li>Make illegal states unrepresentable</li>
<li>Errors as values</li>
<li>Functional core, imperative shell</li>
<li>Smart constructor</li>
</ol>

<p>These got me interested, but as usual, the problem with such distilled mantras is that you need a lot of context to understand and use them. What does it <em>mean</em> to have a “smart constructor”? In the comments  Dmitrii himself and other people added links to suggested reading. Let’s go over each item and uncover what it means.</p>

<h3 id="1-parse-don-t-validate">1. Parse, don’t validate</h3>

<p>The text that introduced this notion is <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" target="_blank">this blog post with the same name</a> written by Alexis King. It also covers the next notion so we’ll come back to it later. It gives a much better explanation than my second-hand version could ever do.</p>

<p>For me the two standout ideas were:</p>

<ul>
<li>While validation establishes correctness, parsing enriches the data and adds knowledge we can build upon, and does that early on the way from less-structured to more-structured data. In my own work I describe it as “building a solid foundation” meaning that you can confidently build higher-level abstractions when the lower-level abstractions are leak-proof, with correctness likely enforced by the compiler.</li>
<li>The notion of <em>shotgun parsing</em> (a mix of input validation and parsing that tries to capture all the “bad” cases — an antipattern, because it doesn’t work) defined in the paper “<a href="https://langsec.org/papers/langsec-cwes-secdev2016.pdf" target="_blank">The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them</a>”. It is exactly the same situation as writing tests: the tests cannot prove the absence of bugs, only that certain things are correct. To come closer to proven correctness, illegal states must be forced out of the program, usually with robust type definitions.</li>
</ul>

<p>Which neatly leads us to the next point…</p>

<h3 id="2-make-illegal-states-unrepresentable">2. Make illegal states unrepresentable</h3>

<p>This is an idea that I see talked about fairly often even in “regular” commercial programming. However, in my experience, not many people are willing to go all the way to achieve it. The post I linked above talks about this notion in its second half. I define it to mean “your logic and types (where applicable) are designed in such a way as to make it physically impossible to create a bad state”.</p>

<p>There are specific examples both in the blog post above and also in this <em>F# for Fun and Profit</em> “<a href="https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/" target="_blank">Designing with types</a>” post that make it clear. The latter makes an excellent point why people do not often go all the way — it often requires flipping assumptions about a system, and also not wanting to bother defining a type (for example) for a container that can hold either one or three items:</p>

<blockquote>
<p>At this point, you might be saying that we have made things unnecessarily complicated.</p>
</blockquote>

<p>People often see this upfront work as complicating the code (“Why can’t I just validate in the initializer and be done?”) and don’t do it. Down the line, someone else doesn’t know about the (unenforced) requirements, and that’s when bugs are introduced. If this idea is implemented well, then the API design or the compiler will make it impossible to make a mistake, because you cannot use the code in a way that represents a bad state. It may be tedious but it’s <em>so</em> worth it.</p>

<h3 id="3-errors-as-values">3. Errors as values</h3>

<p>This notion is well-described in “<a href="https://jessewarden.com/2021/04/errors-as-values.html" target="_blank">Errors as Values: Free Yourself From Unexpected Runtime Exceptions</a>”. The “values” in the phrase refers to returning an error value from a function instead of raising an exception. Usually, the error value is well-defined, and exceptions are unexpected.</p>

<p>This idea is now fairly mainstream and I see that people try to avoid using exceptions. Many languages encourage and support you to return something like a <code>Result</code> (which, for example in Swift, is a sum type of <code>Success</code> and <code>Error</code>) or, like Go, a tuple of values: a successful result and an optional error. This practice came to replace setting a global error variable or returning magic “error” values (like in C) and throwing exceptions (like in C++, Java, etc.).</p>

<p>To me, this simply makes more sense: isn’t it <em>objectively</em> better to get a finite and predictable error value from a function than an unspecified exception that may or may not happen that you still have to guard against?</p>

<h3 id="4-functional-core-imperative-shell">4. Functional core, imperative shell</h3>

<p>I was not familiar with this notion at all, but after reading <a href="https://www.javiercasas.com/articles/functional-programming-patterns-functional-core-imperative-shell" target="_blank">this blog post</a> by Javier Casas it now makes sense. Functional programming is, ideally, a realm of pure functions without side effects that are easy to reason about and easily testable in isolation.</p>

<p>To integrate this code into real systems in the real world you need to set up an environment, procure and provide input values, maybe talk to the OS (which is often stateful) and communicate output values. That’s where the dichotomy comes from. You push as much code as possible that deals with logic into a “functional core”, and only the messy interfacing routines end up in an “imperative shell”. This way the meat of the program can get easily tested without any scaffolding, and the test environment and possibly mocks only need to be provided to the shell.</p>

<h3 id="5-smart-constructor">5. Smart constructor</h3>

<p>The page “<a href="https://wiki.haskell.org/index.php?title=Smart_constructors" target="_blank">Smart constructors</a>” on the Haskell Wiki explains this notion well. It neatly dovetails with “making illegal states unrepresentable” by providing compile- or at least runtime checks when making new values. If the type system cannot enforce a constraint, you can prevent “bad” values from being constructed at runtime.</p>

<p>The page raises another point, that smart constructors can do optimizations because they control internal representation. The example on the page is compacting data, but it can also be normalization, making structures homogenous or converting value formats.</p>

<p>The benefit is, again, creating a solid foundation that you can build on. You know the data you operate is clean, tidy and valid. This means you can do fewer checks later in the pipeline which improves both performance (less code is executed) and clarity (there are fewer noisy checks).</p>

<h3 id="conclusion">Conclusion</h3>

<p>Do these ideas belong only in functional programming? While they are practiced more there, and functional programming languages generally have strong type systems that help implement these constraints, we “regular” developers can use most of these concepts when writing our mostly imperative code to make it simpler. Clearly, if your functions have few or no side effects, the underlying data is clean, and you can’t accidentally create “bad” objects, you’ll have an easier time.</p>
</div></div>
  </body>
</html>
