<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/">Original</a>
    <h1>Debugging a memory leak in a Clojure service</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2 id="background">Background</h2>
<p>Fraud Rules Service (FRS) is a rule engine in Goto Financial’s sanctions platform (my team). FRS lets you write dynamic rules to fight against fraud.</p>
<p>FRS operates on a large scale. It is integrated into several points such as payments, login, and KYC, with the list going on. It is handling about 180k requests per minute including ingestion + fraud evaluation with 100ms as response time.</p>
<p>This article will discuss a curious case of a memory leak that occurred in FRS and how we fixed it.</p>
<p>Read more about FRS here: <a href="https://blog.gojek.io/protecting-indonesias-largest-digital-payments-app/">link</a></p>
<h2 id="preface">Preface</h2>
<p>Approximately two months ago, we started seeing issues with the service where the pod’s <code>current</code> memory would keep increasing and exceed the <code>request</code> set up on Kubernetes.</p>
<figure>

    <p><img loading="lazy" alt="image (2).png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/image%20%282%29.png"/>
    </p>

    
</figure>
<p>We assumed it might be because the required memory was higher, so we increased the request, but it still exceeded the request threshold.</p>
<p>At this point, we were not seeing any issues. There were occasional increases in response time when the memory would come close to the <code>limit</code> threshold. Since the development was going in full swing, there were several deployments back to back which would cause the pods to restart and never hit the <code>limit</code>.</p>
<p>Once we moved to other tasks, we started seeing the pods go OOMKilled. We took turns looking into the issue, but we couldn’t determine the exact cause. The usual fix for this was to restart the pods and leave it at that.</p>
<p>We had tried several things to get the memory back to previous state. The response time was increasing and hence we had to scale it up. The scale up helped with the response time and gave us some breathing room until we fixed the issue.</p>
<p>I’ll be skipping the things that were attempted as I want to focus on the problem caused by a Clojure core(std) library function.</p>
<h2 id="the-problem">The Problem</h2>
<p>After going through millions of graphs (not literally), we saw that New Relic has JVM instrumentation through APIs exposed on JMX. One of the graphs particularly stood out. We had looked at it earlier, but we ignored it, thinking it was a common JVM behaviour.</p>
<figure>

    <p><img loading="lazy" alt="Screenshot 2024-08-26 at 2.29.12 AM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-08-26%20at%202.29.12%20AM.png"/>
    </p>

    
</figure>
<p>The classes unloaded count keeps increasing after each deployment. It would never stop. The loaded classes was also inconsistent.</p>
<p>Tried to find ways to see the classes being loaded. Turns out we can turn on class loader tracing with couple of JVM params. Using the following:</p>
<pre tabindex="0"><code>-XX:+TraceClassLoading
-XX:+TraceClassUnloading
</code></pre><p>Added these params to the staging server and started hitting the server with high number of requests. Started to see lot of logs of classes being loaded and most of them were loaded by <code>clojure.core/eval</code>.</p>
<figure>

    <p><img loading="lazy" alt="Screenshot 2024-08-19 at 3.28.04 PM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-08-19%20at%203.28.04%20PM.png"/>
    </p>

    
</figure>
<p>Simple google search brought up this stackoverflow <a href="https://stackoverflow.com/questions/71447267/clojure-memory-leaks-using-eval">link</a>. There seems to be instances of this behaviour noticed earlier and it is the default behaviour of <code>clojure.core/eval</code>.</p>
<h2 id="the-actual-issue">The Actual Issue</h2>
<p>The <code>eval</code> function makes a call to a Java method in the <code>Compiler.java</code> class. As you can see:</p>
<figure>

    <p><img loading="lazy" alt="Screenshot 2024-09-01 at 2.27.44 AM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-09-01%20at%202.27.44%20AM.png"/>
    </p>

    
</figure>
<p>If we dig into this method, we’ll see the following code, which initializes a classloader on each call.</p>
<figure>

    <p><img loading="lazy" alt="Screenshot 2024-09-01 at 2.29.48 AM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-09-01%20at%202.29.48%20AM.png"/>
    </p>

    
</figure><p>
This causes the memory overhead. This will also not be cleaned up until the classes loaded by the loader is dereferenced.</p>
<p>There were several reported cases of eval causing memory issues, functionality issues and performance in some cases.</p>
<ol>
<li><a href="https://stackoverflow.com/questions/71447267/clojure-memory-leaks-using-eval">Clojure: memory leaks using eval</a></li>
<li><a href="https://groups.google.com/g/clojure/c/kvBuI_ksOQo">Clojure creates lots of classloaders</a></li>
<li><a href="https://github.com/oracle-samples/clara-rules/issues/381#issuecomment-366068883">Reduce number of calls to eval by the compiler</a></li>
<li><a href="https://clojurians-log.clojureverse.org/clojure/2023-04-20#inst-2023-04-20T17:01:29.711929Z">Clojurian slack</a></li>
</ol>
<p>The reason eval loads a new classloader every time is justified as dynamically generated classes cannot be garbage collected as long as the classloader is referencing to them. In this case, single classloader evaluating all the forms and generating new classes can lead to the generated class not being garbage collected.</p>
<p>To avoid this, a new classloader is being created every time, this way once the evaluation is done. The classloader will no longer be reachable and all it’s dynamically loaded class.</p>
<h2 id="final-notes">Final Notes</h2>
<p>As a result, we removed the usage of eval and did a quick load test on the staging. We were able to see that the classes loaded were stabilised. After compiling all the results, we concluded to take the changes to production.</p>
<p>After a week of the deployment, the following graph shows the same:</p>
<figure>

    <p><img loading="lazy" alt="Screenshot 2024-09-01 at 4.08.59 AM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-09-01%20at%204.08.59%20AM.png"/>
    </p>

    
</figure>
<p>This also reduced the GC CPU time:











</p><figure>

    <p><img loading="lazy" alt="Screenshot 2024-09-01 at 4.09.30 AM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-09-01%20at%204.09.30%20AM.png"/>
    </p>

    
</figure>
<p>And drum roll, the memory usage dropped by a lot and we started planning to reduce the resources for the service.</p>
<p>There was also an additional reduction in response time, which I assume was due to the decrease in GC time.</p>
<figure>

    <p><img loading="lazy" alt="Screenshot 2024-09-01 at 4.12.45 AM.png" src="https://charanvasu.com/posts/debugging-a-memory-leak-in-a-clojure-service/%20/Screenshot%202024-09-01%20at%204.12.45%20AM.png"/>
    </p>

    
</figure>
<p>This has impacted the error rate and it went near zero. Our overall SLA has improved.</p>
<p>Further: I still want to dig on why the classloader is not being GC’d. Will make a separate article if I manage to find out.</p>

    
  </div></div>
  </body>
</html>
