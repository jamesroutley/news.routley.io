<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joaoabbottgribben.bearblog.dev/over-complicating-things-with-rust/">Original</a>
    <h1>Over complicating things - with Rust!</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
<i>
<time datetime="2023-10-15">
15 Oct, 2023
</time>
</i>
</p>
<h2 id="introduction">Introduction</h2>
<p>This post details one of the rare occasions where changing your code with the sole priority of “just making it work” creates an end result that&#39;s arguably superior to the “proper” code you had initially set out to write.</p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#context">Context</a></li>
<li><a href="#what-i-wanted-to-do">What I wanted to do</a></li>
<li><a href="#why-i-wanted-to-do-it">Why I wanted to do it</a></li>
<li><a href="#how-i-started-to-implement-this-approach">How I started to implement this approach</a></li>
<li><a href="#where-i-got-totally-blocked">Where I got totally blocked</a></li>
<li><a href="#what-i-did-instead">What I did instead</a></li>
<li><a href="#tl-dr">TL;DR</a></li>
</ul>
<p>(If you want to skip the journey and go straight to the before and after, then pop straight down to <a href="#what-i-did-instead">What I did instead</a> and the <a href="#tl-dr">TL;DR</a>.)</p>
<h2 id="context">Context</h2>
<p>I was implementing this user story for my CLI maze maker (repo <a href="https://github.com/joaoag/mazes_with_nannou">here</a>):</p>
<div><pre><span></span>As a user
So I can choose the algorithm used to make my maze
I want to be able to select algorithms via the CLI
</pre></div>
<p>Things went without a hitch in terms of getting arguments from the CLI and using them to pick the maze making algorithm.</p>
<p>The trouble (and main focus of this post) came when I tried to add some simple validation and error handling on the user input.</p>
<h2 id="what-i-wanted-to-do">What I wanted to do</h2>
<ul>
<li>I wanted to sanitise the user’s input, without matching against bare strings, e.g. avoiding <code>selected_algo === “binary_tree”</code></li>
<li>So I wanted to assign the string to a variable, specifically a constant</li>
</ul>
<p>I didn’t go straight to a standalone constant for each string. Instead, my plan was to wrap all the name constants in a container constant, so I would access the relevant string with something like <code>ALGORITHM_NAMES.BINARY_TREE</code></p>
<h2 id="why-i-wanted-to-do-it">Why I wanted to do it</h2>
<p>Why would I start with this structure vs a standalone constant?</p>
<ul>
<li>I thought just <code>BINARY_TREE</code> on its own was ambiguous in comparison to e.g. <code>ALGORITHM_NAMES.BINARY_TREE</code>, especially as I was already referring to an imported function called <code>binary_tree</code> nearby </li>
<li>The organiser in me likes the encapsulation that name spacing provides.</li>
<li>I love dot notation, on aesthetic and ergonomic grounds (so much easier and more pleasant to type <code>something.else</code> than <code>something[“else”]</code>) </li>
</ul>
<p>I was also very much influenced by habit: in previous Python projects we’d had something like the below code:</p>
<div><pre><span></span><span>#constants.py</span>
<span>LOCAL</span> <span>=</span> <span>&#34;local&#34;</span>
<span>DEV</span> <span>=</span> <span>&#34;development&#34;</span>
<span>STAGING</span> <span>=</span> <span>&#34;staging&#34;</span>
<span>PROD</span> <span>=</span> <span>&#34;production&#34;</span>


<span>class</span> <span>Envs</span><span>:</span>
  <span>LOCAL</span> <span>=</span> <span>LOCAL</span>
  <span>DEV</span> <span>=</span> <span>DEV</span>
  <span>STAGING</span> <span>=</span> <span>STAGING</span>
  <span>PROD</span> <span>=</span> <span>PROD</span>


<span>#buckets.py</span>
<span>import</span> <span>os</span>
<span>current_env</span> <span>=</span> <span>os</span><span>.</span><span>environ</span><span>.</span><span>get</span><span>(</span><span>&#39;env&#39;</span><span>)</span>

<span>if</span> <span>current_env</span> <span>==</span> <span>Envs</span><span>.</span><span>LOCAL</span><span>:</span>
  <span>print</span><span>(</span><span>&#34;Hey we&#39;re doing local dev, set up some LocalStack stuff&#34;</span><span>)</span>
</pre></div>
<p>I found this easy to read and easy to use.</p>
<p>All of the above were enough for me to think it would be reasonable and worthwhile to recreate the approach in Rust for this use-case.</p>
<h2 id="how-i-started-to-implement-this-approach">How I started to implement this approach</h2>
<p>Initially, it was looking promising.</p>
<p>First, I created the container structure (which took far more work than I anticipated):</p>
<div><pre><span></span><span>// constants.rs</span>
<span>const</span><span> </span><span>BINARY_TREE</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;binary_tree&#34;</span><span>;</span>
<span>const</span><span> </span><span>SIDEWINDER</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;sidewinder&#34;</span><span>;</span>

<span>#[derive(Debug)]</span>
<span>pub</span><span> </span><span>struct</span> <span>Algorithms</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>binary_tree</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>str</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>sidewinder</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>str</span>
<span>}</span>

<span>pub</span><span> </span><span>const</span><span> </span><span>ALGORITHMS</span>: <span>Algorithms</span><span> </span><span>=</span><span> </span><span>Algorithms</span><span> </span><span>{</span>
<span>    </span><span>binary_tree</span>: <span>BINARY_TREE</span><span>,</span>
<span>    </span><span>sidewinder</span>: <span>SIDEWINDER</span>
<span>};</span>
</pre></div>
<p>Then, I imported the struct and checked I could access the values:</p>
<div><pre><span></span><span>// maze_display.rs</span>
<span>use</span><span> </span><span>constants</span>::<span>*</span><span>;</span><span> </span><span>// remember readers, just trying to make it work!</span>

<span>println!</span><span>(</span><span>&#34;{:?}&#34;</span><span>,</span><span> </span><span>ALGORITHMS</span><span>.</span><span>binary_tree</span><span>);</span>
</pre></div>
<p>That was successful, so next step was to use to set a default algorithm in case the user doesn’t pass one in themselves:</p>
<div><pre><span></span><span>// maze_display.rs</span>

<span>// fetch user input from the command line</span>
<span>let</span><span> </span><span>cli_args</span>: <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>env</span>::<span>args</span><span>().</span><span>collect</span><span>();</span>

<span>// default to binary tree if relevant arg not present</span>
<span>// yes, this is still very loosey-goosey input sanitisation</span>
<span>let</span><span> </span><span>algorithm</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>if</span><span> </span><span>cli_args</span><span>.</span><span>len</span><span>()</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>{</span><span> </span><span>&amp;</span><span>cli_args</span><span>[</span><span>1</span><span>]</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>ALGORITHMS</span><span>.</span><span>binary_tree</span><span> </span><span>};</span>
</pre></div>
<h2 id="where-i-got-totally-blocked">Where I got totally blocked</h2>
<p>All of the above code was up and working, so I moved onto creating a <code>match</code> statement to do the following:</p>
<ol>
<li>Check user input matches a valid algorithm</li>
<li>If a match is found, return the relevant function that implements that algorithm</li>
<li>If no match found, tell them they’ve given an invalid option</li>
</ol>
<p>In the same file as the above blocks, I added the below code:</p>
<div><pre><span></span><span>//maze_display.rs</span>
<span>use</span><span> </span><span>maze_makers</span>::<span>{</span><span>binary_tree</span><span>,</span><span> </span><span>sidewinder</span><span>};</span><span> </span><span>// functions to make mazes</span>

<span>match</span><span> </span><span>algorithm</span><span> </span><span>{</span><span> </span><span>// get string representing user&#39;s algorithm selection</span>
<span>    </span><span>// if this matches a known algo, return the appropriate function</span>
<span>    </span><span>ALGORITHMS</span><span>.</span><span>binary_tree</span><span> </span><span>=&gt;</span><span> </span><span>binary_tree</span><span>,</span><span> </span>
<span>    </span><span>ALGORITHMS</span><span>.</span><span>sidewinder</span><span> </span><span>=&gt;</span><span> </span><span>sidewinder</span><span>,</span>
<span>    </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>panic!</span><span>(</span><span>&#34;Unrecognised algorithm&#34;</span><span>),</span>
<span>}</span>
</pre></div>
<p>And this is where I ran into trouble, with the below error:</p>
<div><pre><span></span>error:<span> </span>expected<span> </span>one<span> </span>of<span> </span><span>`</span><span>=</span>&gt;<span>`</span>,<span> </span><span>`</span>@<span>`</span>,<span> </span><span>`</span><span>if</span><span>`</span>,<span> </span>or<span> </span><span>`</span><span>|</span><span>`</span>,<span> </span>found<span> </span><span>`</span>.<span>`</span>

<span>       </span>ALGORITHMS.binary_tree<span> </span><span>=</span>&gt;<span> </span>btree,
<span>                 </span>^<span> </span>expected<span> </span>one<span> </span>of<span> </span><span>`</span><span>=</span>&gt;<span>`</span>,<span> </span><span>`</span>@<span>`</span>,<span> </span><span>`</span><span>if</span><span>`</span>,<span> </span>or<span> </span><span>`</span><span>|</span><span>`</span>
</pre></div>
<p>This was a surprise to me. If I could access <code>ALGORITHMS.binary_tree</code> in the below block :</p>
<div><pre><span></span><span>let</span><span> </span><span>algorithm</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>if</span><span> </span><span>cli_args</span><span>.</span><span>len</span><span>()</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>{</span><span> </span><span>&amp;</span><span>cli_args</span><span>[</span><span>1</span><span>]</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>ALGORITHMS</span><span>.</span><span>binary_tree</span><span> </span><span>};</span>
</pre></div>
<p>Why could I not access it the same way in the <code>match</code> statement?</p>
<h2 id="what-i-did-instead">What I did instead</h2>
<p>Eventually, I decided to change tactic completely and just use simple string constants.</p>
<p>Before:</p>
<div><pre><span></span><span>// constants.rs</span>
<span>const</span><span> </span><span>BINARY_TREE</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;binary_tree&#34;</span><span>;</span>
<span>const</span><span> </span><span>SIDEWINDER</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;sidewinder&#34;</span><span>;</span>

<span>#[derive(Debug)]</span>
<span>pub</span><span> </span><span>struct</span> <span>Algorithms</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>binary_tree</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>str</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>sidewinder</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>str</span>
<span>}</span>

<span>pub</span><span> </span><span>const</span><span> </span><span>ALGORITHMS</span>: <span>Algorithms</span><span> </span><span>=</span><span> </span><span>Algorithms</span><span> </span><span>{</span>
<span>    </span><span>binary_tree</span>: <span>BINARY_TREE</span><span>,</span>
<span>    </span><span>sidewinder</span>: <span>SIDEWINDER</span>
<span>};</span>
</pre></div>
<p>After:</p>
<div><pre><span></span><span>// constants.rs</span>
<span>pub</span><span> </span><span>const</span><span> </span><span>BINARY_TREE</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;binary_tree&#34;</span><span>;</span>
<span>pub</span><span> </span><span>const</span><span> </span><span>SIDEWINDER</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;sidewinder&#34;</span><span>;</span>
</pre></div>
<p>On doing this, and comparing the two, I realised just how unnecessarily complex my initial approach had been.
I don’t know if it’s possible to do what I wanted in Rust, but I was ultimately glad that I couldn’t.</p>
<p>A lot is said about Rust’s design being made to push developers into the pit of success, and I wonder if this is an example of that.</p>
<h3 id="tl-dr">TL;DR</h3>
<p>Rust string validation takeaway:</p>
<ul>
<li>If you want to group related strings in a data structure and read them in a match statement, think carefully on whether that data structure is truly necessary.</li>
</ul>
<p>More transferable takeaways:</p>
<ol>
<li>When totally blocked, try changing your approach completely - you may be pleasantly surprised by the results</li>
<li>Sometimes over-engineering things is fun, sometimes it’s an awful waste of time</li>
<li>It is dangerously easy to forget the below principles when writing things for yourself:<ul>
<li>premature optimisation (or organisation) is the root of all evil</li>
<li>YAGNI</li>
<li>KISS</li>
</ul>
</li>
</ol>
<p>Hopefully this was useful for anyone (maybe particularly people from a Python background?) rolling their own simple string validation in Rust.</p>
<p>Next up I&#39;ll be writing about how I moved the maze display from a shell-based co-ordinate system (not a real term) to a 2D Cartesian co-ordinate system. Watch this space! ... hehe</p>
</div></div>
  </body>
</html>
