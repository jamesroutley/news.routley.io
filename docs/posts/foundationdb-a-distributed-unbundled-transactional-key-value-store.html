<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://muratbuffalo.blogspot.com/2022/03/foundationdb-distributed-unbundled.html">Original</a>
    <h1>FoundationDB: A distributed unbundled transactional key value store</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8258994304766050613">
<p><a href="https://dl.acm.org/doi/10.1145/3448016.3457559">This paper  from Sigmod 2021</a> presents FoundationDB, a transactional key-value store that supports multi-key strictly serializable transactions across its entire key-space. <a href="https://github.com/apple/foundationdb">FoundationDB (FDB, for short) is opensource.</a> The paper says that: &#34;<i>FDB is the underpinning of cloud infrastructure at Apple, Snowflake and other companies, due to its consistency, robustness and availability for storing user data, system metadata and configuration, and other critical information.</i>&#34;</p><p>The main idea in FDB is to decouple transaction processing from logging and storage. Such an unbundled architecture enables the separation and horizontal scaling of both read and write handling. </p><h2>Unbundled architecture</h2><p>FDB architecture comprises of a control plane and a data plane. </p><p><a href="https://blogger.googleusercontent.com/img/a/AVvXsEgkLBLilc4igR38QOl1SKdOIqAXpaY_25i8RPVeiQaCMYuG-Dno4WhMpqelWWZN9Esz5fODNcqSnQ6uSQHR5JmYmvdYaEHDQ-7ep2jY9qitdI9hpcxbWDvzYEBbKaY9aQOgxtIQ0IaqvHcCUvnPtSljTFl6ohsozXzOe1GqXJC1h5HA1u0m-ejAliem"><img alt="" data-original-height="1070" data-original-width="990" height="400" src="https://blogger.googleusercontent.com/img/a/AVvXsEgkLBLilc4igR38QOl1SKdOIqAXpaY_25i8RPVeiQaCMYuG-Dno4WhMpqelWWZN9Esz5fODNcqSnQ6uSQHR5JmYmvdYaEHDQ-7ep2jY9qitdI9hpcxbWDvzYEBbKaY9aQOgxtIQ0IaqvHcCUvnPtSljTFl6ohsozXzOe1GqXJC1h5HA1u0m-ejAliem=w370-h400" width="370"/></a></p><h2>Concurrency control</h2><p>The TS provides transaction processing and consists of a Sequencer, Proxies, and Resolvers. The Sequencer assigns a read version and a commit version to each transaction. Proxies offer MVCC read versions to clients and orchestrate transaction commits. Resolvers are key-partitioned and help check for conflicts between transactions. </p><h3>Getting a read-version </h3><p>On the topic of getting a read-version (GRV), there is a divergence between <a href="https://apple.github.io/foundationdb/architecture.html">the FDB website</a> and the paper. The website says, a Proxy needs to talk to all proxies before it can provide the view. <i>&#34;When a client requests a read version from a proxy, the proxy asks all other proxies for their last commit versions, and checks a set of transaction logs satisfying replication policy are live. Then the proxy returns the maximum commit version as the read version to the client. The reason for the proxy to contact all other proxies for commit versions is to ensure the read version is larger than any previously committed version. Consider that if proxy A commits a transaction, and then the client asks proxy B for a read version. The read version from proxy B must be larger than the version committed by proxy A. The only way to get this information is by asking proxy A for its largest committed version.&#34;</i></p><h3>Committing the transaction </h3><p>A Proxy commits a client transaction in three steps. <br/></p><ol><li>First, the Proxy contacts the Sequencer to obtain a commit version that is larger than any existing read versions or commit versions. </li><li>Then, the Proxy sends the transaction information to range-partitioned Resolvers, which implement FDB&#39;s OCC by checking for read-write conflicts. If all Resolvers return with no conflict, the transaction can proceed to the final commit stage. Otherwise, the Proxy marks the transaction as aborted. </li><li>Finally, committed transactions are sent to a set of LogServers for persistence. A transaction is considered committed after all designated LogServers have replied to the Proxy, which reports the committed version to the Sequencer (to ensure that later transactions’ read versions are after this commit) and then replies to the client. At the same time, StorageServers continuously pull mutation logs from LogServers and apply committed updates to disks.</li></ol><h3>Read-only transactions</h3><p>In addition to the above read-write transactions, FDB also supports read-only transactions and snapshot reads. A read-only transaction in FDB is both serializable (happens at the read version) and performant (thanks to the MVCC). The client can commit these transactions locally without contacting the database. Snapshot reads in FDB selectively relax the isolation property of a transaction by reducing conflicts, i.e., concurrent writes will not conflict with snapshot reads.<br/></p><h3>Atomic operations</h3><p>FDB supports atomic operations such as atomic add, bitwise “and” operation, compare-and-clear, and set-versionstamp. These atomic operations enable a transaction to write a data item without reading its value, saving a round-trip time to the StorageServers. Atomic operations also eliminate read-write conflicts with other atomic operations on the same data item (only write-read conflicts can still happen). This makes atomic operations ideal for operating on keys that are frequently modified, such as a key-value pair used as a counter. The set-versionstamp operation is another interesting optimization, which sets part of the key or part of the value to be the transaction’s commit version. This enables client applications to later read back the commit version and has been used to improve the performance of client-side caching.<a href="https://muratbuffalo.blogspot.com/2019/01/paper-review-foundationdb-record-layer.html"> In the FDB Record Layer</a>, many aggregate indexes are maintained using atomic mutations.<br/></p><h3>Discussion about concurrency control<br/></h3><p>By decoupling the read and write path, and leveraging the client to do the staging of the transaction updates before Commit, FDB achieves simple concurrency control. I really liked that FDB has a very simple transition going from  strict serializability to snapshot isolation consistency level, by just relaxing the GRV appropriately. If you remember our CockroachDB discussion, this was not possible in CockroachDB. I think FDB also enjoys the benefit of using a single sequencer for timestamping here.</p><h2>Fault tolerance </h2><p>Besides a lock-free architecture, one of the features distinguishing FDB from other distributed databases is its approach to handling failures. Unlike most similar systems, FDB does not rely on quorums to mask failures, but rather tries to eagerly detect and recover from them by reconfiguring the system. FDB handles all failures through the recovery path: instead of fixing all possible failure scenarios, the transaction system proactively shuts down and restarts when it detects a failure. As a result, all failure handling is reduced to a single recovery operation, which becomes a common and well-tested code path. Such error handling strategy is desirable as long as the recovery is quick, and pays dividends by simplifying the normal transaction processing. <a href="https://muratbuffalo.blogspot.com/2011/01/crash-only-software-hotos03.html">This reminds me of the crash-only software approach.</a> </p><h2>Replication</h2><p>When a Proxy writes logs to LogServers, each sharded log record is synchronously replicated on f+1 LogServers. Only after all f+1 have replied with successful persistence, the Proxy sends back the commit response to the client. These WAL logs also does double-duty for simplifying replication to other datacenters and for providing automatic failover between regions without losing data.</p><p><a href="https://blogger.googleusercontent.com/img/a/AVvXsEiVjoR5AmLpNMxLmoFVnHaSUy-PkFXLlJ4DaP5MczVuC60ZQ5nV1XrBDbp4QeOAW-XJ-eAXpnINh4bkRGKqbfLIonnzv5O5s8AtceUhCS-gXfJfp97lLGE7r0eXDKdmedZs_hJasQKaZ2PcsEWcCS5haVvH7uHejFJ6PILYc-6c3ZCnE9NxhVOqYHvw"><img alt="" data-original-height="556" data-original-width="1018" height="219" src="https://blogger.googleusercontent.com/img/a/AVvXsEiVjoR5AmLpNMxLmoFVnHaSUy-PkFXLlJ4DaP5MczVuC60ZQ5nV1XrBDbp4QeOAW-XJ-eAXpnINh4bkRGKqbfLIonnzv5O5s8AtceUhCS-gXfJfp97lLGE7r0eXDKdmedZs_hJasQKaZ2PcsEWcCS5haVvH7uHejFJ6PILYc-6c3ZCnE9NxhVOqYHvw=w400-h219" width="400"/></a></p></div></div>
  </body>
</html>
