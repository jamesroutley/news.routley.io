<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://solar.lowtechmagazine.com/2023/06/low-tech-magazine-the-comic/">Original</a>
    <h1>Low-tech Magazine: The Comic</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-06-09T00:00:00-07:00">June 9, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>Today while meeting with my SICP group mates I learned about piecewise functions.</p>


<p>Some background before getting to the problem at hand. The initial task was to come up with a procedure for an infinite continued fraction like this:</p>

\[f = \frac{N_1}{D_1 + \cfrac{N_2}{D_2 + \cfrac{N_3}{D_3 + ...}}}\]

<p>In this case, <code>N</code> and <code>D</code> are not not meant to be numbers but functions of index <code>i</code>. As we’ll see, this will make the infinite fraction procedure more flexible and allow us to use it to approximate several things.</p>

<p>For example, when \(N_i\) and \(D_i\) always return 1, the result of this equation approximates \(\frac{1}{\phi}\), where \(\phi\) is the golden ratio. Since this equation (as its name implies) is infinite, the procedure we’re tasked with writing will compute a truncated version according to parameter <code>k</code>:</p>

\[f = \frac{N_1}{D_1 + \cfrac{N_2}{... + \cfrac{N_k}{D_k}}}\]

<p>In other words, it will iterate <code>k</code> times.</p>

<p>Here’s my implementation for both recursive and iterative approaches:</p>

<div><div><pre><code><span>; recursive implementation</span>
<span>(</span><span>define</span> <span>(</span><span>cont-frac</span> <span>n</span> <span>d</span> <span>k</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>iter</span> <span>n</span> <span>d</span> <span>k</span> <span>i</span><span>)</span>
    <span>(</span><span>if</span> <span>(</span><span>=</span> <span>k</span> <span>0</span><span>)</span>
      <span>(</span><span>/</span> <span>(</span><span>n</span> <span>i</span><span>)</span> <span>(</span><span>d</span> <span>i</span><span>))</span>
      <span>(</span><span>/</span> <span>(</span><span>n</span> <span>i</span><span>)</span>
         <span>(</span><span>+</span> <span>(</span><span>d</span> <span>i</span><span>)</span>
            <span>(</span><span>iter</span> <span>n</span> <span>d</span> <span>(</span><span>-</span> <span>k</span> <span>1</span><span>)</span> <span>(</span><span>+</span> <span>i</span> <span>1</span><span>))))))</span>
  <span>(</span><span>iter</span> <span>n</span> <span>d</span> <span>k</span> <span>1</span><span>))</span>

<span>; iterative implementation</span>
<span>(</span><span>define</span> <span>(</span><span>cont-frac-iter</span> <span>n</span> <span>d</span> <span>k</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>iter</span> <span>n</span> <span>d</span> <span>k</span> <span>i</span> <span>cur</span><span>)</span>
    <span>(</span><span>if</span> <span>(</span><span>=</span> <span>i</span> <span>k</span><span>)</span>
      <span>cur</span>
      <span>(</span><span>iter</span> <span>n</span> <span>d</span> <span>k</span> <span>(</span><span>+</span> <span>1</span> <span>i</span><span>)</span> <span>(</span><span>/</span> <span>(</span><span>n</span> <span>i</span><span>)</span> <span>(</span><span>+</span> <span>(</span><span>d</span> <span>i</span><span>)</span> <span>cur</span><span>)))))</span>
  <span>(</span><span>iter</span> <span>n</span> <span>d</span> <span>k</span> <span>0</span> <span>(</span><span>/</span> <span>(</span><span>n</span> <span>k</span><span>)</span> <span>(</span><span>d</span> <span>k</span><span>))))</span>
</code></pre></div></div>

<p>Either of these can be called to estimate \(\phi\) like so, where <code>k</code> is the number of iterations desired:</p>

<div><div><pre><code><span>(</span><span>/</span> <span>1</span> <span>(</span><span>cont-frac</span> <span>(</span><span>lambda</span> <span>(</span><span>i</span><span>)</span> <span>1.0</span><span>)</span>
                 <span>(</span><span>lambda</span> <span>(</span><span>i</span><span>)</span> <span>1.0</span><span>)</span>
                 <span>k</span><span>))</span>
</code></pre></div></div>

<p>Again, <code>n</code> and <code>d</code> are procedures, not variables. In the case of this golden ratio approximation algorithm, they are constant – \(N(\imath) = 1\) and \(D(\imath) = 1\) for all values <code>i</code> – but they are procedures nonetheless. That’s why we pass to <code>cont-frac</code> the two identical lambda functions for <code>n</code> and <code>d</code> respectively that return 1 regardless of <code>i</code>.</p>

<p>What’s cool is that the above approximates \(\phi\) to 4 decimal places in 11 iterations.</p>

<div><div><pre><code><span>(</span><span>/</span> <span>1</span> <span>(</span><span>cont-frac</span> <span>(</span><span>lambda</span> <span>(</span><span>i</span><span>)</span> <span>1.0</span><span>)</span>
                 <span>(</span><span>lambda</span> <span>(</span><span>i</span><span>)</span> <span>1.0</span><span>)</span>
                 <span>11</span><span>))</span>
</code></pre></div></div>

<div><div><pre><code>;Value: 1.6180555555555558
</code></pre></div></div>



<p>This brings us to the next puzzle. Using the same infinite fraction procedure <code>cont-frac</code>, we can approximate \(e - 2\) where \(N(\imath) = 1\) (that’s the same lambda function used above) and \(D(\imath)\) returns the following sequence: 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, …</p>

<p>The latter pattern is obvious to me, but my question was how to derive a function that will result in such a sequence.</p>

<p>I’m very grateful that one of my group mates is a mathematician with a talent for patiently stepping through math problems (turns out what we need is called a pairwise function). Here’s my attempt to reconstruct his process for arriving at the answer.</p>

<p>His approach was to create a table with the index in one column and the expected value in the next:</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>D(i)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <td>5</td>
      <td>4</td>
    </tr>
    <tr>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <td>7</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>6</td>
    </tr>
    <tr>
      <td>9</td>
      <td>1</td>
    </tr>
    <tr>
      <td>10</td>
      <td>1</td>
    </tr>
    <tr>
      <td>11</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<p>The first observation to make is that D(i) is constant (\(D(\imath) = 1\)) when \(\imath \bmod 3 \neq 2\).</p>

<p>Let’s look at the remaining table:</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>D(i)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>4</td>
    </tr>
    <tr>
      <td>8</td>
      <td>6</td>
    </tr>
    <tr>
      <td>11</td>
      <td>8</td>
    </tr>
    <tr>
      <td>14</td>
      <td>10</td>
    </tr>
  </tbody>
</table>

<p>What’s the rule here? Well, \(D(\imath) = (\imath // 3) \cdot 2 + 2\) where ‘//’ is integer division, meaning that the answer is rounded down. We can also write the equation using floor function notation like so:
\(D(\imath) = 2 \cdot \lfloor \frac{\imath}{3} \rfloor + 2\)</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>D(i)</th>
      <th>i // 3</th>
      <th>(i // 3) * 2 + 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>0</td>
      <td>0 * 2 + 2 = 2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>4</td>
      <td>1</td>
      <td>1 * 2 + 2 = 4</td>
    </tr>
    <tr>
      <td>8</td>
      <td>6</td>
      <td>2</td>
      <td>2 * 2 + 2 = 6</td>
    </tr>
    <tr>
      <td>11</td>
      <td>8</td>
      <td>3</td>
      <td>3 * 2 + 2 = 8</td>
    </tr>
    <tr>
      <td>14</td>
      <td>10</td>
      <td>4</td>
      <td>4 * 2 + 2 = 10</td>
    </tr>
  </tbody>
</table>

<p>Thanks to that insight, I managed to implement my own solution to this pi-estimation problem.</p>

<div><div><pre><code><span>(</span><span>define</span> <span>(</span><span>euler</span> <span>k</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>d-seq</span> <span>i</span><span>)</span>
    <span>(</span><span>if</span> <span>(</span><span>not</span> <span>(</span><span>=</span> <span>2</span> <span>(</span><span>remainder</span> <span>i</span> <span>3</span><span>)))</span>
      <span>1</span>
      <span>(</span><span>+</span> <span>2</span>
         <span>(</span><span>*</span> <span>2</span>
            <span>(</span><span>floor</span> <span>(</span><span>/</span> <span>i</span> <span>3</span><span>))))))</span>
  <span>(</span><span>+</span> <span>2</span> <span>(</span><span>cont-frac</span> <span>(</span><span>lambda</span> <span>(</span><span>i</span><span>)</span> <span>1.0</span><span>)</span>
                  <span>d-seq</span>
                  <span>k</span><span>)))</span>

<span>(</span><span>euler</span> <span>10</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>;Value: 2.7182818352059925
</code></pre></div></div>

<p>Looks pretty Euler-y to me.</p>



<p>Now that I understood how to approach a piecewise function, I could tackle the following approach to approximating \(\pi\):</p>

\[\frac{\pi}{4} = \frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \cdot ...}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \cdot ...}\]

<p>The numerator and denominator sequences here look suspiciously piecewise.</p>

<p>Here’s my solution:</p>

\[N(\imath) = 2 + 2 \cdot \lfloor \frac{\imath}{2} \rfloor
\\
D(\imath) = 3 + 2 \cdot \lfloor \frac{(\imath - 1)}{2} \rfloor\]

<p>Thus, in scheme:</p>

<div><div><pre><code><span>(</span><span>define</span> <span>(</span><span>product</span> <span>term</span> <span>a</span> <span>next</span> <span>b</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>&gt;</span> <span>a</span> <span>b</span><span>)</span>
    <span>1</span>
    <span>(</span><span>*</span> <span>(</span><span>term</span> <span>a</span><span>)</span>
       <span>(</span><span>product</span> <span>term</span> <span>(</span><span>next</span> <span>a</span><span>)</span> <span>next</span> <span>b</span><span>))))</span>

<span>(</span><span>define</span> <span>(</span><span>inc</span> <span>x</span><span>)</span> <span>(</span><span>+</span> <span>x</span> <span>1</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>pi-term</span> <span>i</span><span>)</span>
  <span>(</span><span>let</span> <span>((</span><span>numer</span> <span>(</span><span>+</span> <span>2</span><span>.</span> <span>(</span><span>*</span> <span>2</span> <span>(</span><span>floor</span> <span>(</span><span>/</span> <span>i</span> <span>2</span><span>)))))</span>
        <span>(</span><span>denom</span> <span>(</span><span>+</span> <span>3</span><span>.</span> <span>(</span><span>*</span> <span>2</span> <span>(</span><span>floor</span> <span>(</span><span>/</span> <span>(</span><span>-</span> <span>i</span> <span>1</span><span>)</span> <span>2</span><span>))))))</span>
    <span>(</span><span>/</span> <span>numer</span> <span>denom</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>pi-approx</span> <span>n</span><span>)</span>
  <span>(</span><span>*</span> <span>4</span> <span>(</span><span>product</span> <span>pi-term</span> <span>1</span> <span>inc</span> <span>n</span><span>)))</span>

<span>(</span><span>pi-approx</span> <span>200</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>;Value: 3.149378473168593
</code></pre></div></div>

<p>Takes a while to converge, but we’re getting there.</p>



<ul>
  <li>paired on some EDA in prep for feature selection/engineering for a random forest project I have in the works</li>
  <li>SICP meeting</li>
  <li>data disco</li>
  <li>weekly presentations</li>
</ul>



          

        

        
      </section>

      

      

      
  <nav>
    
      <a href="https://www.datadoodad.com/recurse%20center/RC18/" title="RC18.
">Previous</a>
    
    
      <a href="#">Next</a>
    
  </nav>

    </div></div>
  </body>
</html>
