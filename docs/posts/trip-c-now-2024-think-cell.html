<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.think-cell.com/en/career/devblog/trip-report-cpp-now-2024">Original</a>
    <h1>Trip C&#43;&#43;Now 2024 – think-cell</h1>
    
    <div id="readability-page-1" class="page"><div>
                        <div>
                            <div>
                                <p>I attended C++Now for the fourth time last week, and it was definitely one of the best conferences I&#39;ve ever been to. I don&#39;t think I&#39;ve ever experienced so many amazing talks in a row, so I can only highlight <em>some</em> of the talks that are definitely worth watching.</p>
                                <h2>C++, Rust, and safety</h2>
                                <p>A talk absolutely everybody should watch is <a target="_blank" href="https://schedule.cppnow.org/session/2024/cpp-should-be-cpp/">C++ should be C++</a> by David Sankel. It shouldn&#39;t be controversial that C++ has a bit of an image problem right now, given the legislative push for memory safety in programming languages and all the successor languages popping up. David argues that this isn&#39;t a big problem: There is already a proven, memory-safe systems programming language, Rust, and you should use it for safety-critical code. Programming languages are tools, and you should use the right tool for the job. Sometimes that&#39;s Rust, sometimes that&#39;s C++, and that&#39;s fine. The committee should instead focus on keeping C++ mostly as-is and look at ways to improve inter-op with other programming languages. I tend to agree with that.</p>
                                <p>If you violate a precondition in the standard library, it is undefined behavior, which is unsafe. People often complain about that; the Rust approach, where preconditions are checked and the program panics instead, is safe. However, an implementation is free to do whatever it wants in the presence of undefined behavior, including checking the precondition and aborting. And finally, somebody does: Users of libcxx can now enable a hardening mode in production to reliably check cheap preconditions. Louis Dionne presented the design in <a target="_blank" href="https://schedule.cppnow.org/session/2024/security-in-cpp-hardening-techniques-from-the-trenches/">Security in C++ - Hardening techniques from the trenches</a>. It has minimal runtime and code-size overhead, can be enabled/disabled separately for each translation unit, and is currently running in many production systems like Chrome. There really is no excuse anymore to ship code that can suffer from buffer overflows!</p>
                                <h2>C++ at Google</h2>
                                <p>Google does not use <code>std::ranges</code> for many reasons, including performance, the ability to create dangling references, and a cubic stack blowup when deeply nesting some range adapters like <code>std::views::filter</code>. John Bandela shared their custom range library design in <a target="_blank" href="https://schedule.cppnow.org/session/2024/rappel-compose-algorithms-not-iterators/">Rappel: Compose algorithms, not iterators - Google&#39;s alternative to ranges</a>. Instead of using iterators, which need to be pulled to receive new values one at a time, the library composes callbacks, which are eagerly invoked with the new values. This is faster because it doesn&#39;t involve a state machine, ensures that references can never outlive the user because the user code runs inside the algorithm, and only scales linearly in stack space because adapters don&#39;t need to repeatedly store pointers. Google&#39;s library isn&#39;t open source (yet?), but we at think-cell identified the problems with the iterator model decades ago and have built a very similar design in our own standard library, which you can already find on GitHub: <a target="_blank" href="https://github.com/think-cell/think-cell-library">github.com/think-cell/think-cell-library</a>. It&#39;s really good to see that many different people converge on the same design, and I&#39;m working on bringing some of it into the standard in the future.</p>
                                <p>Google does use coroutines, and Aaron Jacobs presented a smart way to prevent lifetime issues in <a target="_blank" href="https://schedule.cppnow.org/session/2024/coroutines-at-scale-implementation-choices-at-google/">Coroutines at scale - Implementation choices at Google</a>. Consider the following coroutine:</p>
                                <figure>
                                    <div>
                                        <div>
                                            
                                        </div>
                                        <pre><code>Task&lt;void&gt; coroutine(std::string const&amp; str) {
    co_await do_sth();
    std::print(&#34;{}\n&#34;, str);
}</code></pre>
                                    </div>
                                    <figcaption>A coroutine that takes a reference and uses it after a suspension point</figcaption>
                                </figure>
                                <p>A reference argument in a coroutine can easily dangle, as the referred object is not owned by the coroutine and needs to outlive the entire coroutine. So, it must not be called with a temporary object that&#39;s destroyed too early:</p>
                                <figure>
                                    <div>
                                        <div>
                                            
                                        </div>
                                        <pre><code>auto task = coroutine(&#34;hello&#34;);
co_await task;</code></pre>
                                    </div>
                                    <figcaption>Calling the coroutine with a dangling reference</figcaption>
                                </figure>
                                <p>The temporary <code>std::string</code> created in the first line is destroyed by the time we actually need it! However, Aaron realized that the following code is perfectly fine:</p>
                                <figure>
                                    <div>
                                        <div>
                                            
                                        </div>
                                        <pre><code>co_await coroutine(&#34;hello&#34;);</code></pre>
                                    </div>
                                    <figcaption>Calling the coroutine with a reference that lives long enough</figcaption>
                                </figure>
                                <p>Here, the temporary <code>std::string</code> is only destroyed after the <code>co_await</code> returns. So, to enforce the immediate use of <code>co_await</code>, the default task type in their library (called <code>Co</code>) is immovable, and <code>co_await</code> takes it by value. As such, you can only <code>co_await</code> prvalues, which allows the second use but not the first. If you do want to create the coroutine and await it later, you need to wrap it in a different type, which takes ownership over the temporary objects and keeps them alive until the coroutine finishes. It is pretty neat!</p>
                                <h2>Functional C++, value-oriented programming, Carbon, and floats</h2>
                                <p>Gašper Ažman presented his library for monadic error handling and composition in <a target="_blank" href="https://schedule.cppnow.org/session/2024/functional-cpp/">Functional C++</a>. Using <code>std::expected</code> for error handling gets annoying when each operation returns a different type. He solved it by using <code>expected&lt;T, sum&lt;E&gt;&gt;</code>, where <code>sum</code> is a sum type (like <code>std::variant</code>). Combining an existing <code>expected&lt;T, sum&lt;E&gt;&gt;</code> in <code>and_then</code> with a function that returns an <code>expected&lt;U, sum&lt;F&gt;&gt;</code> results in an <code>expected&lt;T, sum&lt;E, F&gt;&gt;</code>, forcing you to handle both potential errors later on.</p>
                                <p>The library also features a <code>pack&lt;A, B, C&gt;</code> type, which is like <code>std::tuple</code>, but it is automatically unpacked when invoking a lambda. That way, you can have operations that return multiple values at once and forward them as individual arguments to the next function, instead of having to write everything in terms of <code>std::tuple</code>. Our <a target="_blank" href="https://github.com/think-cell/think-cell-library">think-cell-library</a> does the same to make <code>tc::zip(rng1, rng2)</code> more straightforward to use.</p>
                                <p>Other talks I enjoyed watching were Tony Van Eerd&#39;s <a target="_blank" href="https://schedule.cppnow.org/session/2024/value-oriented-programming-part-v-return-of-the-values/">Value-oriented programming part V - Return of the values</a>, where he describes how you can write better code by avoiding object-oriented programming and using value semantics instead; <a target="_blank" href="https://schedule.cppnow.org/session/2024/generic-arity-definition-checked-variadics-in-carbon/">Generic Arity: Definition-checked variadics in Carbon</a> by Geoffrey Romer, where he talks about the implementation of variadic templates in Carbon; and <a target="_blank" href="https://schedule.cppnow.org/session/2024/a-new-dragon-in-the-den-fast-conversion-from-floating-point-numbers/">A new dragon in the den - Fast conversion from floating point numbers</a> by Cassio Neri about his new, surprisingly simple float-to-string algorithm.</p>
                                <hr/>
                                <p>I also gave my talk, <a target="_blank" href="https://schedule.cppnow.org/session/2024/an-in-complete-guide-to-cpp-object-lifetimes/">An (in-)complete guide to C++ object lifetimes</a>, about everything from <code>std::launder</code> to <code>std::start_lifetime_as</code>. It was very well received, and I managed to have a prepared slide for almost all questions, which is always cool—of course, given that it&#39;s C++Now, there were always questions I could not answer.</p>
                                <p>Aspen itself was beautiful as always, and I ended the conference with a hike up the mountains. I always say that if you can only go to one conference, go to C++Now, so I hope to see you there next year!</p>
                            </div>
                        </div>
                    </div><p>Don&#39;t miss out on new posts! Sign up to receive a notification whenever we publish a new article.</p><p>Just submit your email address below. Be assured that we will not forward your email address to any third party.</p></div>
  </body>
</html>
