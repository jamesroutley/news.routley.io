<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danieltan.weblog.lol/2025/07/the-big-oops-in-type-systems-this-problem-extends-to-fp-as-well">Original</a>
    <h1>The Big Oops in type systems: This problem extends to FP as well</h1>
    
    <div id="readability-page-1" class="page"><article>
	
<p>Building on Casey Muratori&#39;s critique (<a href="https://www.youtube.com/watch?v=wo84LFzx5nI">youtube</a>) of &#34;compile time hierarchies that match the domain model,&#34; this problem extends beyond OOP to encompass a broader pattern in static type systems, particularly functional programming approaches that attempt to &#34;make illegal states unrepresentable.&#34;</p>
<p>Type systems are often ranked in a &#34;correctness hierarchy&#34;, with Idris/Haskell at the top, Java/C# in the middle, Python/JavaScript at the bottom. Static type proponents argue that better type systems can capture domain models more accurately, reducing the need for tests by proving certain software properties impossible.</p>
<p>The experiment of encoding complex business domains directly into mathematical type constructs has shown mixed results, succeeding in some areas while struggling with the inherent messiness of business logic. While functional programming concepts have spread to other languages, they&#39;ve largely abandoned the rigid philosophy that defines languages like Haskell.</p>
<h2 id="content-technical-models-vs-domain-reality"><a href="#content-technical-models-vs-domain-reality" aria-hidden="true" title="Permalink"></a>Technical Models vs. Domain Reality</h2>
<p>There&#39;s a critical distinction between <strong>technical understanding</strong> (how data is processed) and <strong>domain presentation</strong> (how data is conceptualized within the problem domain).</p>
<p>Data processing works best when mapped onto &#34;simpler&#34; reasoning models (à la Rich Hickey&#39;s &#34;simple not easy&#34;) and then transformed. But domain presentation must accommodate legacy and entrenched domain understanding that evolves with business requirements.</p>
<p>The trap is that both OOP hierarchies and FP &#34;make illegal states unrepresentable&#34; create <strong>premature crystallization</strong> of domain understanding into rigid technical models. When domains evolve (and they always do), this coupling demands expensive refactoring.</p>
<p>It&#39;s fascinating that an industry that learned the pitfalls of premature optimization and tight coupling has convinced itself that encoding domains into type systems is beneficial—despite creating these very same problems.</p>
<h2 id="content-the-categorical-mismatch"><a href="#content-the-categorical-mismatch" aria-hidden="true" title="Permalink"></a>The Categorical Mismatch</h2>
<p>Here&#39;s the thing nobody talks about: domain experts think in workflows, exceptions, and contextual rules. They&#39;ll tell you things like &#34;normally we validate the credit card first, but if it&#39;s a returning customer and the amount is under $50, we can process it immediately&#34; or &#34;a shipment is &#39;pending&#39; until it leaves the warehouse, except for digital goods which are &#39;delivered&#39; instantly, unless there&#39;s a compliance hold.&#34;</p>
<p>Traditional algebraic type systems encourage exhaustive, mutually exclusive categories, though modern approaches like row types and effect systems offer more flexibility:</p>
<pre><code data-lang="haskell"><span><span>data</span> <span>PaymentStatus</span> = <span>Pending</span> | <span>Validated</span> | <span>Failed</span> | <span>Completed</span></span>
<span><span>data</span> <span>ShipmentStatus</span> = <span>Created</span> | <span>InTransit</span> | <span>Delivered</span> | <span>Returned</span></span>
</code></pre>
<p>But business domains are messy, contextual, and full of overlapping states that depend on multiple factors simultaneously. Consider healthcare: patient status isn&#39;t just &#39;active&#39; or &#39;discharged&#39;—it depends on insurance authorization, bed availability, treatment protocols, and family preferences. In finance, a &#39;trade&#39; might be pending, executed, settled, or failed, but also partially filled, awaiting counter-party confirmation, under regulatory review, or in dispute resolution.</p>
<p>The &#34;ubiquitous language&#34; from Domain-Driven Design tries to bridge this gap, but encoding domain language directly into types creates brittle mappings that satisfy nobody. Domain experts can&#39;t recognize their mental models in rigid algebraic structures, and developers get trapped maintaining complex type hierarchies that resist change.</p>
<p>When the business inevitably adds &#34;VIP customers can modify orders after payment if the change is under $20,&#34; watch what happens to your beautiful type system.</p>
<p>In raw Haskell, you might start with clean sum types:</p>
<pre><code data-lang="haskell">
<span><span>data</span> <span>PaymentStatus</span> = <span>Pending</span> | <span>Completed</span> | <span>Failed</span></span>
<span><span>data</span> <span>Order</span> = <span>Order</span> { <span>status</span> :: <span>PaymentStatus</span>, <span>customer</span> :: <span>Customer</span> }</span>
</code></pre>
<p>The new requirement forces you to encode every state combination. You end up with something like:</p>
<pre><code data-lang="haskell">
<span><span>data</span> <span>PaymentStatus</span> = </span>
    <span>Pending</span> 
  | <span>Completed</span> <span>CompletedState</span>
  | <span>Failed</span> <span>FailureReason</span>

<span><span>data</span> <span>CompletedState</span> = <span>CompletedState</span></span>
  { canModify :: <span>Bool</span>              
  , maxModificationAmount :: <span>Maybe</span> <span>Decimal</span>
  , customerType :: <span>CustomerType</span> 
  , itemType :: <span>ItemType</span> }

<span><span>data</span> <span>CustomerType</span> = <span>Standard</span> | <span>VIP</span> | <span>Enterprise</span></span>
<span><span>data</span> <span>ItemType</span> = <span>Physical</span> | <span>Digital</span> | <span>Service</span></span>
</code></pre>
<p>But wait—digital goods have instant delivery, enterprise customers need approval workflows, and seasonal promotions affect modification rules. Soon you&#39;re maintaining a baroque hierarchy:</p>
<pre><code data-lang="haskell">
<span><span>data</span> <span>PaymentStatus</span> = </span>
    <span>Pending</span> <span>PendingState</span>
  | <span>Completed</span> <span>CompletedState</span>  
  | <span>Failed</span> <span>FailureReason</span>
  | <span>PartiallyCompleted</span> <span>PartialState</span> <span>CompletedState</span>  
  | <span>PendingApproval</span> <span>ApprovalWorkflow</span> <span>CompletedState</span> 

<span><span>data</span> <span>CompletedState</span> = <span>CompletedState</span></span>
  { canModify :: <span>Bool</span>
  , maxModificationAmount :: <span>Maybe</span> <span>Decimal</span>
  , customerType :: <span>CustomerType</span>
  , itemType :: <span>ItemType</span>
  , deliveryStatus :: <span>DeliveryStatus</span>           
  , seasonalRules :: [<span>SeasonalRule</span>]           
  , approvalRequired :: <span>Bool</span> }                
</code></pre>
<p>The domain expert&#39;s simple mental model (&#34;VIP customers get special flexibility&#34;) has been shredded across multiple type definitions that resist every new requirement. This complexity explosion isn&#39;t unique to Haskell—it&#39;s symptomatic of a deeper mismatch between how businesses think and how type systems work.</p>
<p>At some point a good Haskell program might need a complete rewrite of the architecture from scratch:</p>
<pre><code data-lang="haskell">

<span><span>data</span> <span>CustomerId</span> = <span>CustomerId</span> <span>Text</span></span>
<span><span>data</span> <span>OrderId</span> = <span>OrderId</span> <span>Text</span></span>
<span><span>data</span> <span>Money</span> = <span>Money</span> <span>Decimal</span></span>


<span><span>data</span> <span>OrderEvent</span> </span>
  = <span>OrderCreated</span> <span>CustomerId</span> [<span>Item</span>] <span>UTCTime</span>
  | <span>PaymentAttempted</span> <span>Money</span> <span>PaymentMethod</span> <span>UTCTime</span>
  | <span>PaymentCompleted</span> <span>PaymentReference</span> <span>UTCTime</span>
  | <span>PaymentFailed</span> <span>FailureReason</span> <span>UTCTime</span>
  | <span>OrderModified</span> [<span>Item</span>] <span>Money</span> <span>UTCTime</span>
  | <span>OrderShipped</span> <span>ShippingDetails</span> <span>UTCTime</span>


<span><span>data</span> <span>Order</span> = <span>Order</span></span>
  { orderId :: <span>OrderId</span>
  , events :: [<span>OrderEvent</span>]
  , metadata :: <span>Map</span> <span>Text</span> <span>Value</span> }


<span>canModifyOrder</span> :: <span>Order</span> -&gt; <span>Bool</span>
<span>canModifyOrder</span> order = 
  <span>let</span> currentState = deriveCurrentState order
      customer = getCustomer (customerId currentState)
  <span>in</span> <span>case</span> (customerTier customer, paymentStatus currentState, orderTotal currentState) <span>of</span>
    (<span>VIP</span>, <span>Paid</span>, total) | total &lt; <span>Money</span> <span>20</span> -&gt; <span>True</span>
    (_, <span>Pending</span>, _) -&gt; <span>True</span>
    _ -&gt; <span>False</span>


<span>deriveCurrentState</span> :: <span>Order</span> -&gt; <span>OrderState</span>
<span>deriveCurrentState</span> = foldl applyEvent emptyOrderState . events


<span><span>type</span> <span>BusinessRule</span> = <span>Order</span> -&gt; <span>ValidationResult</span></span>

<span>validateOrderModification</span> :: [<span>BusinessRule</span>] -&gt; <span>Order</span> -&gt; [<span>Item</span>] -&gt; <span>ValidationResult</span>
<span>validateOrderModification</span> rules order newItems = 
  mconcat $ map (\rule -&gt; rule order) rules


<span>vipModificationRule</span> :: <span>BusinessRule</span>
<span>vipModificationRule</span> order = 
  <span>if</span> canModifyOrder order 
    <span>then</span> <span>Valid</span> 
    <span>else</span> <span>Invalid</span> <span>&#34;Order cannot be modified&#34;</span>

<span>seasonalPromotionRule</span> :: <span>BusinessRule</span>  
<span>seasonalPromotionRule</span> order = 
  
  validateSeasonalRules order
</code></pre>
<h2 id="content-the-clojure-alternative"><a href="#content-the-clojure-alternative" aria-hidden="true" title="Permalink"></a>The Clojure Alternative</h2>
<p>Clojure&#39;s approach of modeling software around data rather than mathematical constructs or type hierarchies has successfully brought functional programming concepts to traditionally OO languages. This approach trades compile-time guarantees for runtime flexibility. You lose some categories of errors that static typing catches, but gain the ability to handle domain complexity that resists categorical thinking.</p>
<p>Instead of encoding business rules in type structures, you represent domain concepts as descriptive data that mirrors how domain experts actually think:</p>
<pre><code data-lang="clojure">
{<span>:customer-type</span> <span>:premium</span>
 <span>:order-total</span> <span>150.00</span>
 <span>:shipping-rules</span> #{<span>:free-shipping</span> <span>:expedited-available</span>}}
</code></pre>
<p>Business logic becomes explicit transformation functions rather than implicit type system constraints:</p>
<pre><code data-lang="clojure">(<span><span>defn</span></span> apply-shipping-rules [order]
  (<span>cond-&gt;</span> order
    (<span><span>and</span></span> (<span><span>=</span></span> <span>:premium</span> (<span>:customer-type</span> order))
         (<span><span>&gt;</span></span> (<span>:order-total</span> order) <span>100</span>))
    (<span><span>assoc</span></span> <span>:shipping-cost</span> <span>0</span>)))
</code></pre>
<p>Domain experts can read and verify this logic directly. When rules change, you modify functions, not type hierarchies.</p>
<p>A full clojure production example demonstrates this flexibility without requiring fundamental architecture updates:</p>
<pre><code data-lang="clojure">(<span>require</span> &#39;[clojure.spec.alpha <span>:as</span> s])


(<span>s/def</span> <span>::customer-id</span> uuid?)
(<span>s/def</span> <span>::customer-type</span> #{<span>:standard</span> <span>:premium</span> <span>:vip</span> <span>:enterprise</span>})
(<span>s/def</span> <span>::order-total</span> (<span>s/and</span> number? pos?))
(<span>s/def</span> <span>::order-status</span> #{<span>:pending</span> <span>:paid</span> <span>:shipped</span> <span>:delivered</span> <span>:cancelled</span>})

(<span>s/def</span> <span>::order</span> (<span>s/keys</span> <span>:req</span> [<span>::customer-id</span> <span>::customer-type</span> <span>::order-total</span> <span>::order-status</span>]
                      <span>:opt</span> [<span>::items</span> <span>::payment-method</span> <span>::shipping-address</span>]))


(<span><span>defmulti</span></span> can-modify-order? 
  (<span><span>fn</span></span> [order] [(<span>:customer-type</span> order) (<span>:order-status</span> order)]))

(<span><span>defmethod</span></span> can-modify-order? [<span>:vip</span> <span>:paid</span>] [order]
  (<span><span>&lt;</span></span> (<span>:order-total</span> order) <span>20.00</span>))

(<span><span>defmethod</span></span> can-modify-order? [<span>:enterprise</span> <span>:paid</span>] [order]
  
  (<span>requires-approval?</span> order))

(<span><span>defmethod</span></span> can-modify-order? [_ <span>:pending</span>] [_order]
  <span>true</span>)

(<span><span>defmethod</span></span> can-modify-order? <span>:default</span> [_order]
  <span>false</span>)


(<span><span>def</span></span> shipping-rules
  [{<span>:id</span> <span>:free-shipping-vip</span>
    <span>:condition</span> (<span><span>fn</span></span> [order] (<span><span>and</span></span> (<span><span>=</span></span> <span>:vip</span> (<span>:customer-type</span> order))
                               (<span><span>&gt;</span></span> (<span>:order-total</span> order) <span>100</span>)))
    <span>:action</span> (<span><span>fn</span></span> [order] (<span><span>assoc</span></span> order <span>:shipping-cost</span> <span>0</span>))
    <span>:description</span> <span>&#34;VIP customers get free shipping over $100&#34;</span>}
   
   {<span>:id</span> <span>:expedited-available</span>
    <span>:condition</span> (<span><span>fn</span></span> [order] (<span>#</span>{<span>:vip</span> <span>:enterprise</span>} (<span>:customer-type</span> order)))
    <span>:action</span> (<span><span>fn</span></span> [order] (<span>assoc-in</span> order [<span>:shipping-options</span> <span>:expedited</span>] <span>true</span>))
    <span>:description</span> <span>&#34;Premium customers can choose expedited shipping&#34;</span>}])

(<span><span>defn</span></span> apply-shipping-rules [order]
  (<span><span>reduce</span></span> (<span><span>fn</span></span> [order rule]
            (<span><span>if</span></span> ((<span>:condition</span> rule) order)
              ((<span>:action</span> rule) order)
              order))
          order
          shipping-rules))


(<span><span>defn</span></span> validate-order [order rules-config]
  (<span><span>let</span></span> [validation-results 
        (<span><span>for</span></span> [rule rules-config
              <span>:let</span> [result ((<span>:validator</span> rule) order)]
              <span>:when</span> (<span><span>not</span></span> (<span>:valid?</span> result))]
          result)]
    (<span><span>if</span></span> (<span><span>empty?</span></span> validation-results)
      {<span>:valid?</span> <span>true</span> <span>:order</span> order}
      {<span>:valid?</span> <span>false</span> <span>:errors</span> (<span><span>map</span></span> <span>:error</span> validation-results)})))


(<span><span>defn</span></span> apply-event [order event]
  (<span><span>case</span></span> (<span>:type</span> event)
    <span>:payment-completed</span> (<span><span>assoc</span></span> order <span>:order-status</span> <span>:paid</span> <span>:payment-ref</span> (<span>:payment-ref</span> event))
    <span>:order-modified</span> (<span><span>-&gt;</span></span> order 
                       (<span><span>assoc</span></span> <span>:items</span> (<span>:new-items</span> event))
                       (<span><span>assoc</span></span> <span>:order-total</span> (<span>:new-total</span> event))
                       (<span>update</span> <span>:events</span> conj event))
    <span>:seasonal-rule-added</span> (<span><span>update-in</span></span> order [<span>:active-rules</span>] conj (<span>:rule</span> event))
    order))


(<span><span>defn</span></span> process-order-modification [order new-items]
  (<span><span>-&gt;</span></span> order
      (<span>s/assert</span> <span>::order</span>) 
      (<span>apply-business-rules</span>)
      (<span>apply-seasonal-rules</span>)
      (<span>calculate-new-total</span> new-items)
      (<span>validate-modification-limits</span>)
      (<span>update</span> <span>:events</span> conj {<span>:type</span> <span>:order-modified</span> 
                           <span>:new-items</span> new-items 
                           <span>:timestamp</span> (<span>java.time.Instant/now</span>)})))
</code></pre>
<p>Treating data as immutable facts and designing transformation pipelines sidesteps the minigame of creating type structures that are simultaneously flexible enough for change and rigid enough to prevent errors.</p>
<h2 id="content-finding-the-right-abstraction-level"><a href="#content-finding-the-right-abstraction-level" aria-hidden="true" title="Permalink"></a>Finding the Right Abstraction Level</h2>
<p>The real insight here isn&#39;t that type systems are bad or that dynamic languages are superior—it&#39;s that we&#39;ve been applying type system rigor at the wrong abstraction level.</p>
<p>Think about it: we happily use strong typing for low-level concerns. Nobody argues that pointers should be dynamically typed, or that we shouldn&#39;t distinguish between integers and floats at the machine level. The type system earns its keep by preventing segfaults and arithmetic errors.</p>
<p>But as we move up the abstraction stack toward business logic, the cost-benefit equation flips. Business rules change frequently, involve contextual exceptions, and resist categorical thinking. Trying to encode &#34;VIP customers can modify small orders&#34; as a compile-time guarantee is like using a precision instrument for rough carpentry.</p>
<p>The sweet spot appears to be recognizing that different abstraction levels have different stability characteristics. Low-level concerns like data integrity and API contracts benefit from compile-time guarantees, while business logic benefits from runtime flexibility. The mistake isn&#39;t choosing the wrong paradigm—it&#39;s applying the same approach everywhere.</p>
<p>This isn&#39;t about abandoning type systems—it&#39;s about recognizing that different problems require different tools. Use compile-time guarantees where stability matters and runtime flexibility where change is constant.</p>
<p>The industry&#39;s mistake was treating this as an either/or choice. The mature approach recognizes that a payment processing system needs both the reliability of strong typing (for financial calculations) and the flexibility of data manipulation (for business rules).</p>
<p>You don&#39;t have to pick a side in the type system wars. You can use the right tool at the right level of abstraction.</p>
<h2 id="content-conclusion"><a href="#content-conclusion" aria-hidden="true" title="Permalink"></a>Conclusion</h2>
<p>The path forward isn&#39;t to abandon static typing, but to recognize its proper scope. Use it where stability and correctness matter most—data integrity, API contracts, and core algorithms. Embrace runtime flexibility where business logic lives. The goal isn&#39;t ideological purity but practical effectiveness.</p>
<p>This is how we escape the trap elucidated in &#34;The Big OOPs&#34;, regardless of paradigm. The translation layer between domain and technical models becomes a feature, not a bug. Each model optimizes for its purpose without artificial coupling through shared type hierarchies.</p>
<p>We can have both reliability where it matters and flexibility where it&#39;s needed—we just need to stop trying to solve business domain complexity with type system complexity.</p>

	
	
</article></div>
  </body>
</html>
