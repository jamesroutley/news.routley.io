<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shopify.engineering/how-we-built-shopifys-bfcm-2023-globe">Original</a>
    <h1>How we built the Black Friday Cyber Monday 2023 globe</h1>
    
    <div id="readability-page-1" class="page"><div id="article-content" itemprop="articleBody"><div><p>Every year for Black Friday Cyber Monday (BFCM), we put together a real-time visualization of purchases made through Shopify-powered merchants worldwide. This year we&#39;re cooking up something big, and in anticipation we wanted to show you how we built the globe last year.</p>
<figure><video controls="controls" src="https://cdn.shopify.com/videos/c/o/v/1af3f7cda59c46d1b95dbcb5c162c820.mp4"></video>
<figcaption>Video of BFCM 2023 Globe</figcaption>
</figure>
<p>Besides going for better visuals, a big focus was performance. We&#39;ve put together an interactive deep dive into how we built and optimized the 3D visuals using technologies such as Three.js and React-three-fiber.</p>
<p>Before we jump in, here&#39;s the globe with simulated data that you can play with.</p>

<h2>Arcs</h2>
<p>The arcs flying around are the most important component. Each one represents an order being placed in real time, and they travel from the merchant to the buyer&#39;s location.</p>
<p>These can be defined as a BÃ©zier curve with 4 control points. Each point is a 3-dimensional vector.</p>
<ul>
<li>P0: located at start position</li>
<li>P1: located 25% of the way between start and end</li>
<li>P2: located 75% of the way between start and end</li>
<li>P3: located at end position</li>
</ul>

<p>Arc height can be adjusted by moving control points P1 and P2 away from the surface.</p>
<p>To render the arc, we create a mesh that is a strip of triangles moving along the curve. This gives us the ability to control thickness and have better flexibility for stylizing it with shaders.</p>

<p>You&#39;ll notice however that as you move the mesh around, it disappears from certain angles. We needed a way to make it always face the viewer. The solution was surprisingly simple.</p>
<p>The red lines along the curve represent the tangent at those points. Taking the cross product of the tangent with the direction of the camera gives a new vector. This is used in the vertex shader to offset the position so the mesh always faces the viewer.</p>


<p>To texture the arcs, the UVs of the mesh are defined with <code>v</code> going from 0 at the start to 1 at the end. So a vertex in the middle of the arc would have <code>v</code> being 0.5.</p>
<p>Here it is represented with color = uv.y</p>

<p>To animate an arc, the current age of it has to be calculated. This is given by:</p>

<p>The age is normalized to the range 0 to 2.</p>
<ul>
<li>age = 0: the arc is starting</li>
<li>age = 1: the arc has reached its destination</li>
<li>age = 2: the entire arc trail animation has fully played out</li>
</ul>
<p>To achieve the dissolve type effect we wanted, we use the UV and the age of the arc and pass that into a noise function.</p>


<p>As new orders come in, these arc meshes are created and added to the globe. They each have their own <code>startTime</code> attribute. As the <code>uTime</code> value increases each frame, all arcs animate independently.</p>

<p>This was the initial setup we had, and was based on code we had been using for many years. There are many implementations of arc rendering floating around the web, and it&#39;s very common for each arc to have its own mesh.</p>
<p>But it&#39;s not very performant.</p>
<p>In previous years we were limited by how many arcs we could draw per frame. Rendering over 1000 arcs at once would bring some mobile devices to a crawl. We finally found our solution: <strong>instancing</strong>.</p>
<h3>Optimizing the arcs</h3>
<p>Instancing is a technique where multiple copies (instances) of the same base mesh can be drawn at the same time on the GPU. Each instance can have its own unique properties such as position or rotation, but they all share the same geometry and material data. This results in a single draw call. The shared geometry also means that only the vertices of the base mesh need to be uploaded to the GPU.</p>
<p>Without instancing, each mesh requires a separate draw call, as the CPU must send individual data sets to the GPU for each mesh. This increases memory usage and impacts performance.</p>
<p>React-three-fiber and Three.js support instancing out of the box.</p>

<p>But how can a common piece of geometry be used to represent every shape of arc instance? For this we landed on an approach to deform the geometry in the vertex shader.</p>
<p>Instead of computing the Bezier curve for each mesh on the CPU, it was all done on the GPU. Even though instances share the same geometry data, they can have their own unique attributes. These are known as instanced buffer attributes.</p>
<p>For each arc we need the P0, P1, P2, P3 control points. There are 3 floats for each of these to represent the x, y, and z coordinates. We also need a single float for the start time.</p>
<p>The data for each arc is then interleaved into a single large buffer.</p>
<figure><img src="https://cdn.shopify.com/s/files/1/0779/4361/files/buffer.png?v=1729887790" alt="Interleaved buffer"/>
<figcaption>Data layout of an interleaved buffer</figcaption>
</figure>
<p>Inside the vertex shader we can then use these attributes to recreate the curve. Since each vertex has a UV attribute between 0 and 1 depending on where it is along the curve, this can be used to calculate its position.</p>

<p>As new orders come in, we don&#39;t have to upload new geometry anymore. This is our new flow:</p>
<ol>
<li>Loop through data until an arc is found with age &gt; 2. This means the arc is finished</li>
<li>Calculate new control points &amp; start time based on the order&#39;s origin and destination</li>
<li>Upload the data to the GPU only for that specific arc.</li>
</ol>

<p>With this new method we are able to render tens of thousands of arcs in a single draw call. Our initial benchmarking found we can render up to a million arcs at once on an M1 laptop. This should give us a good deal of elbow room for years to come!</p>

<h2>City Dots</h2>
<p>The glowing dots on the globe represent cities with placed orders in the past 24 hours. We debated whether to use meshes aligned to the surface or to use particles that always face the camera.</p>
<p>The difference is subtle, but we chose instanced particles with <code>gl.POINTS</code> since they lead to a nicer glow on the horizon.</p>
<p>See for yourself with the slider below. The left side is surface aligned quads, and the right side are the billboarded points.</p>

<h2>Fireworks</h2>
<p>We really wanted to find a way to celebrate merchants having their first sale. What better way than to have fireworks go off above their city!</p>
<p>Similar to our arcs, we wanted to see if all fireworks could be done in a single draw call. We generate the base mesh by using Three.js&#39;s IcosahedronGeometry and connect triangle strips from the center to each vertex.</p>

<p>To give the mesh the look of a firework burst, we gradually lower vertices along each trail to simulate gravity.</p>

<p>The UVs on each trail are treated the same way as the arcs with <code>v</code> starting at 0 at the start and going to 1 towards the end. This allows us to easily animate the trails bursting outwards.</p>


<p>We also use the noise effect from the arcs to simulate the burst dissipating over time. This is combined with a delayFactor so that the burst trails have a bit of time before starting to disappear.</p>


<p>The whole effect really comes together once bloom is added. This globe was the first where we added postprocessing effects and it added the extra visual oomph we were looking for.</p>

<p>While the bursts themselves were really satisfying to look at, they were missing a launch trail coming up from the ground. We didn&#39;t want to introduce a second mesh for this, so instead we have an additional long triangle strip that starts at the origin and goes to the center of the burst.</p>
<p>We added a geometry attribute called <code>isBurstTrail</code> which is false for any vertex part of that launch trail, and true for the burst trails. This lets us drive the animation for each part.</p>


<p>Linearly animating t from 0 to 1 felt a bit too slow so we experimented with different easing values. Cubic easing gives it the speed we were looking for.</p>


<p>We also added some shader uniforms for launch trail height, burst size, and rotation offsets. This let us group together fireworks in fun ways.</p>

<p>The best part is this is all still one single draw call. Each separate firework has its own start time attribute similar to the arcs so they can animate in and out independently.</p>

<p>The end result is endlessly fascinating to watch.</p>

<h2>Camera Animations</h2>
<p>One of the most delightful features of this globe was the way the camera moved. You could search the name of any city, and no matter where the camera was at that moment, it would move along a beautiful path until it framed the city in the horizon.</p>
<p>The simplest way to go about this is with spherical interpolation:</p>
<ol>
<li>Convert the 3D start position of the camera into spherical coordinates.</li>
<li>Convert the 3D end position of the camera into spherical coordinates.</li>
<li>Interpolate between the start and end points over time.</li>
</ol>
<p>The spherical coordinates have <code>radius</code>, <code>phi</code>, and <code>theta</code> attributes which relate to zoom, latitude, and longitude.</p>

<p>In order to make sure the camera looks at the desired city as it moves, the <code>lookAt</code> function on the camera can be used.</p>


<p>Ideally we want the camera tilted down so that it frames the city with the horizon. Offsetting the <code>phi</code> angle slightly downwards achieves the desired effect.</p>

<p>There is a hidden problem here though. If you travel to New York or London everything works great, but watch what happens when you travel to Sydney.</p>

<p>Why does the world flip upside down when we visit Sydney?</p>
<ul>
<li>The lookAt function uses the <code>up</code> <a href="https://threejs.org/docs/#api/en/core/Object3D.up" target="_blank" rel="nofollow noopener noreferrer">property</a> of the camera to establish which way is up.</li>
<li>The <code>up</code> property is a reference direction, not the actual upward direction of the camera. Even when the camera rotates, the <code>up</code> property stays as [0, 1, 0] unless we manually change it.</li>
<li>When the camera moves to Sydney, the angle between the <code>up</code> property and the actual upward direction of the camera becomes greater than 90 degrees. This causes the camera to flip.</li>
</ul>
<p>There&#39;s luckily a simple fix for that. We need to set the <code>up</code> property each frame, and we can use the <code>phi</code> and <code>theta</code> values to calculate it.</p>

<p>With that fix in place, we now have a system that works perfectly for any city on earth. Try traveling to Sydney to see for yourself:</p>

<h2>Animated Pins</h2>
<p>This globe&#39;s main addition was showing insights about individual cities. To promote discovery, small pins pop out of the globe that you could tap to navigate to that city.</p>
<p>To give the pins a satisfying entrance animation, we turned to <a href="https://www.react-spring.dev/" target="_blank" rel="nofollow noopener noreferrer">react-spring</a>.</p>
<p>Here&#39;s a comparison of an early pin animation (left) with the final one (right) that shows how a bit of easing can go a long way to giving a polished feel.</p>

<h2>Airplanes</h2>
<p>Did you notice the tiny airplanes flying around the globe? They are one of many little surprises to discover. They each follow orbits that pass through two random cities.</p>

<p>Here&#39;s a quick way to achieve the circular motion:</p>
<ol>
<li>Parent the airplane to an empty object (this will be the pivot point)</li>
<li>Offset the airplane by a given amount</li>
<li>Rotate the pivot object each frame</li>
</ol>

<p>The airplane is now orbiting around the equator. Aligning its orbit to pass through two cities turned out to be simpler than we thought:</p>


<p>This method works perfectly fine and is suitable for the small amount of airplanes we have. However, we really wanted to see if we could animate all the airplanes in the GPU in a single draw call. For this to work, we had to replicate the above in a shader.</p>
<p>We start by creating the instanced mesh.</p>

<p>In this case we can&#39;t use separate pivot objects, but we can achieve the same effect with trigonometry in the shader. The airplane material is a <code>MeshBasicMaterial</code>, and we can use the <code>onBeforeCompile</code> method to modify its vertex shader.</p>

<p>This gives the same effect as the airplanes pivoting around the origin. Since each instance has its own transformation matrix, we can set it to a matrix representing the <code>lookAt</code> rotation from before.</p>

<p>The airplanes are now rendered in a single draw call on the GPU. Animating the airplanes is just a matter of updating the <code>currentTime</code> uniform each frame.</p>


<p>While we could have rendered tens of thousands of airplanes without breaking a sweat, we settled on a much more reasonable dozen.</p>
<p>The only airplane on the globe that isn&#39;t instanced is a special &#34;Shopify Airplane&#34; that flies across different cities. For this we use 6 orbits and interpolate between them. To make it look natural, we make the airplane bank when it transitions from one orbit to the next. It also sways horizontally and vertically by following some sinusoidal waves.</p>

<p>At the height of BFCM, with thousands of orders flying around the globe every second, hopping on the Shopify Airplane was truly epic.</p>
<h2>Loopy Arcs</h2>
<p>Loopy arcs were the source of a lot of jokes such as &#34;no wonder my order took 6 weeks to ship, apparently it was doing backflips in the stratosphere.&#34;</p>

<p>Having an order do a loop in outer space is certainly not the most efficient way of getting it from point A to point B, but they sure add a nice whimsical feel to our globe.</p>
<p>In order to have as much control over the animations as possible, we opted not to use BÃ©zier splines. Instead we wanted to try defining the animations using keyframes and cubic Hermite splines. These are common for 3D animations, and give an artist more fine grained controls over the look and feel.</p>
<p>Let&#39;s take a look.</p>

<p>Above is a box that slides back and forth along the X axis. On the right is a Hermite curve made up of two separate splines (the left half and the right half).</p>
<p>Each spline is defined by a start and end point, as well as a slope (or tangent) for each point. You can think of each point/slope pair as a keyframe. The X axis represents time, and the Y axis represents the value.</p>
<p>This is what the three keyframes above look like in code:</p>

<p>So how do we get the value of the curve for an arbitrary time? For example, 3 seconds.</p>
<ol>
<li>
<p><strong>Find the keyframe that comes before 3 seconds, and the keyframe that comes after.</strong></p>
</li>
<li>
<p><strong>Interpolate between both keyframes</strong></p>
</li>
</ol>

<p>In order to animate more than one property, we just need to create a separate curve for each property. In the example below we move the box in an arc-like motion. The red curve represents the X position of the box, while the green one represents its Y position.</p>

<p>Here are the curves for moving the box in a circle.</p>

<p>In order to get our loopy arcs, we had to combine the arc-like motion with the circular motion above. The final curves end up looking like this:</p>

<p>Now that we have a beautiful loopy arc, the question becomes how do we orient our coordinate system above so that the arc flies between two cities?</p>
<p>Our friend <code>lookAt</code> comes in handy once again.</p>

<p>This time we use the <code>Matrix4</code> version of <code>lookAt</code> because it lets us specify the up axis. This allows us to create a rotation matrix that rotates our coordinate system so that the X axis lines up between both cities, and the Y axis comes out of the globe at the desired spot.</p>

<p>If we want to find the position on our animation curve relative to this new coordinate system, we can apply our <code>lookAtMatrix</code>.</p>

<p>Now comes the real challenging part. How do we instance this?</p>
<p>The first thing to note is that the geometry of the loopy arcs is identical to the geometry of regular arcs. The way the triangles are arranged and billboarded, and the way the UVs are used to fade out the arcs with noise are all the same.</p>

<p>What&#39;s different about loopy arcs are the attributes we upload to the GPU.</p>
<p>To describe a loopy arc we need to upload all the keyframes of our animation curves and some additional data to construct a transformation equivalent to the <code>lookAtMatrix</code>.</p>
<p>Each keyframe is 4 floats of data. Once we added up all the floats we needed to pass to the GPU, we were at 94. That&#39;s 376 bytes of data per arc, which turns out isn&#39;t possible to upload. WebGL displayed this error when we tried:</p>
<p><code>Stride is over the maximum stride allowed by WebGL</code></p>
<p>The maximum stride allowed by WebGL is 255 bytes.</p>
<p>We started to reconsider our options. We thought about storing the data in a texture, which is a technique called Vertex Texture Animation (VAT). This would get around the limits, but would add some complexity. Luckily we ended up noticing that a lot of the floats we were trying to upload were equal to zero. You can see this yourself in the graphs above. All the flat slopes are equal to zero, and there are a lot of them. Additionally, a lot of the floats that are nonzero are equal to each other or equal but negated.</p>
<p>After identifying which of the attributes were unique, we ended up only needing to upload 17 floats per arc. WebGL could handle that without any problems as it was way below the 255 byte limit. The rest of the values were hardcoded or computed directly in the shader.</p>
<p>With that we had beautiful instanced loopy arcs!</p>

<p>In retrospect, there are definitely simpler ways we could have implemented these. A combination of Bezier curves and circle equations would have been much simpler and more performant. However we were curious about experimenting with Hermite curves to allow for more bespoke animations. We&#39;ll explore this more for a future Globe!</p>
<h2>Globe Material</h2>
<p>In the early stages of the project, we experimented with a wide range of styles for the globe. This idea kept coming back of a hand-painted aesthetic.</p>
<p>We toyed with effects like toon-shading and ink-shading, but eventually we found ourselves drawn to a style that mirrored the look of a risograph print.</p>
<figure><img src="https://cdn.shopify.com/s/files/1/0779/4361/files/risograph.jpg?v=1729887790" alt="Risograph style" loading="lazy"/>
<figcaption>Depiction of Risograph style artwork used as inspiration for Globe.</figcaption>
</figure>
<h3>Implementing noise</h3>
<p>A key element of risograph prints is the noise that you see all over them. They are covered with little dots of varying sizes. We initially tried to implement that as a screen space effect using the <a href="https://github.com/pmndrs/react-postprocessing" target="_blank" rel="nofollow noopener noreferrer">react-postprocessing</a> library, but it never felt quite right.</p>
<p>We needed to add noise to the water, land and atmosphere materials of our globe. The challenge was how to apply noise to the surface of a sphere with no visible seams and without it stretching or getting distorted at the poles.</p>
<p>We tried a few different 2D and 3D noise functions like Perlin noise, Simplex noise and Worley noise (also called Voronoi noise or cellular noise). It wasn&#39;t until we discovered <a href="https://github.com/stegu/psrdnoise" target="_blank" rel="nofollow noopener noreferrer">psrdnoise</a>, and in particular the flow noise one can create with psrdnoise, that we felt we had found what we were looking for.</p>

<p>Psrdnoise is a variant of Simplex noise that tiles in 2D and 3D, and that supports an animation technique called flow noise in 3D. It&#39;s fairly new and was published in 2022.</p>
<p>3D psrdnoise can be applied to a sphere without any modifications and it gives noise with no seams, stretching or distortion. The following example walks through how we apply 3D psrdnoise to a sphere. The number in the bottom right corresponds to the explanation below.</p>

<ol>
<li>Start with a standard <code>THREE.SphereGeometry</code>. The color gradient represents the vertex positions visualized as colors.</li>
<li>Feed the vertex positions into the noise function. It returns a value of 0 to 1 for every point on the sphere. Use a time value to animate it.</li>
<li>Change the scale by multiplying vertex positions by a scaling factor. As the scaling factor gets bigger, the noise gets smaller. With 3D noise there are no seams, stretching or distortion.</li>
<li>Add another layer of the psrdnoise function again using a &#34;fractal sum&#34; technique. This creates flow noise.</li>
<li>Add two more layers of the psrdnoise function to make the flow noise more detailed.</li>
<li>Scale the noise.</li>
</ol>
<p>3D psrdnoise is wonderful, but it&#39;s not without its downsides. It is computationally expensive, especially when calling the psrdnoise function more than once per fragment to create flow noise. Because of that we switched to using the cheaper 2D psrdnoise function. However, now we had to fix issues with seams, stretching and distortion:</p>

<ol>
<li>Start with an icosphere. Use the UVs of the icosphere as inputs to the 2D psrdnoise function. Notice the seam.</li>
<li>Scale the noise. The seam is a little less noticeable, but it&#39;s still there. There is a lot of stretching at the equator and distortion at the poles.</li>
<li>The stretching and distortion is caused by the default UV mapping of the icosphere.</li>
<li>Switch to a custom UV layout consisting of six round planes. There is no more stretching or distortion.</li>
<li>Seams are still present, but they will go away after the next steps.</li>
<li>Create flow noise by calling the 2D psrdnoise function one additional time.</li>
<li>Add two additional psrdnoise calls.</li>
<li>Scale the noise. The seams have now disappeared.</li>
</ol>
<p>Below is a comparison of 2D psrdnoise (left) and 3D psrdnoise (right). While the 3D noise does have some subtle visual improvements, we opted to compromise for the more performant version.</p>

<p>Next time you need to use a noise function, give psrdnoise a shot!</p>
<h3>Material optimizations</h3>
<p>The standard shader in Three.js is a PBR (Physically Based Rendering) shader. It&#39;s great for realism, but it&#39;s also more computationally expensive, especially on mobile devices.</p>
<p>To simplify the shader, we use the <code>onBeforeCompile</code> method from before to strip down to only the most necessary parts. It was mostly done through trial and error of removing bits that didn&#39;t have any effect on the appearance.</p>
<p>The final shader was around a hundred lines vs the thousands in the standard shader, and we switched most to be vertex based instead of fragment based.</p>
<p>Can you tell the difference? The left globe is the PBR one.</p>

<h2>Stars</h2>
<p>The stars in the distance ended up using psrdnoise as well. Creating a really nice starry sky shader only ends up taking a few lines of code.</p>

<ol>
<li>Start with an icosphere with the same UVs as our globe.</li>
<li>Use the UVs of the sphere as inputs for the 2D psrdnoise function. The noise is not animated because a time value is not given as an input.</li>
<li>Scale and stretch the UVs.</li>
<li>Feed the noise to the <code>pow</code> function. Increasing the exponent filters the noise so that only the brightest parts remain.</li>
<li>Multiply the color by an intensity factor to add more bloom.</li>
</ol>
<p>Here is the corresponding GLSL code:</p>

<h2>Wrapping up</h2>
<p>Building the 2023 BFCM Globe was a journey in pushing the boundaries of what is possible with instancing and WebGL. We look forward to sharing what we&#39;ve been cooking up for this year&#39;s Globe!</p>

</div></div></div>
  </body>
</html>
