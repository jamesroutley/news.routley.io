<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://keymaterial.net/2024/06/15/reconstructing-public-keys-from-signatures/">Original</a>
    <h1>Reconstructing Public Keys from Signatures</h1>
    
    <div id="readability-page-1" class="page"><div id="site-content">

	
<article id="post-3114">

	
<!-- .entry-header -->

	<div>

		<div>

			
<p>One weird hobby of mine is reasonable properties of cryptographic schemes that nobody promised they do or don’t have. Whether that’s <a href="https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/" data-type="link" data-id="https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/">invisible salamanders</a> or <a href="https://eprint.iacr.org/2024/523">binding through shared secrets</a>, anything that isn’t just boring IND-CCA2 or existential unforgeability is just delightful material to construct vulnerabilities with.</p>



<p>Normally, with a signature scheme, you have the public key and want to know whether a given signature is valid. But what if we instead have a message and a signature, assume the signature is valid, and want to know which public key signed it? A rather delightful property if you want to attack anonymity in some proposed “everybody just uses cryptographic signatures for everything” scheme.</p>



<h2>Chapter 1: ECDSA</h2>



<p>This one is so famous it even has it’s <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Public_key_recovery">own Wikipedia section</a>. In short, yes, it is very much possible to recover a public key from a single valid signature.</p>



<p>An ECDSA signature are two integers <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28r%2C+s%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(r, s)"/> such that <img decoding="async" src="https://s0.wp.com/latex.php?latex=sR+%3D+zG+%2B+rP_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="sR = zG + rP_A"/>, where <img decoding="async" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R"/> is one of the two points with x coordinate <img decoding="async" src="https://s0.wp.com/latex.php?latex=r&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="r"/>. To reconstruct the public key, we can just solve for <img decoding="async" src="https://s0.wp.com/latex.php?latex=P_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="P_A"/> and get <img decoding="async" src="https://s0.wp.com/latex.php?latex=P_A+%3D+r%5E%7B-1%7DsR+-+r%5E%7B-1%7DzG&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="P_A = r^{-1}sR - r^{-1}zG"/>, where we compute <img decoding="async" src="https://s0.wp.com/latex.php?latex=r%5E%7B-1%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="r^{-1}"/> as the inverse of <img decoding="async" src="https://s0.wp.com/latex.php?latex=r&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="r"/> modulo the order of the elliptic curve.</p>



<p>Public key recovered.</p>



<h2>Chapter 2: RSA</h2>



<p>Here, it gets a bit tricker. Instead of a single signature, we will need two, <img decoding="async" src="https://s0.wp.com/latex.php?latex=s_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s_1"/> and <img decoding="async" src="https://s0.wp.com/latex.php?latex=s_2&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s_2"/>, with corresponding messages <img decoding="async" src="https://s0.wp.com/latex.php?latex=m_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="m_1"/> and <img decoding="async" src="https://s0.wp.com/latex.php?latex=m_2&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="m_2"/>. RSA usually will hash a message and then pad it in some way, but we don’t really care about that part here, and assume that <img decoding="async" src="https://s0.wp.com/latex.php?latex=m&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="m"/> is already this hashed and padded message. The only important property is that in order to be valid, a RSA signature has to fulfill <img decoding="async" src="https://s0.wp.com/latex.php?latex=s%5Ee+%3D+m+%5Cmod+n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s^e = m \mod n"/>. To achieve this property, the signer has calculated <img decoding="async" src="https://s0.wp.com/latex.php?latex=s+%3D+m%5Ed+%5Cmod+n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s = m^d \mod n"/>, with <img decoding="async" src="https://s0.wp.com/latex.php?latex=d%5Ccdot+e+%5Cmod+%5Cvarphi%28n%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="d\cdot e \mod \varphi(n)"/>. <img decoding="async" src="https://s0.wp.com/latex.php?latex=e&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="e"/> is usually 65537, and we will just assume this value and only recover <img decoding="async" src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="n"/>. We do this by computing <img decoding="async" src="https://s0.wp.com/latex.php?latex=n%27+%3D+%5Cgcd%28s_1%5Ee+-+m_1%2C+s_2%5Ee+-+m_2%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="n&#39; = \gcd(s_1^e - m_1, s_2^e - m_2)"/>. Note the lack of modulus operation, this is just a raw exponent, and yes, the result will have roughly 65537 times as many digits as the signature, message, or modulus do. The Euclidean Algorithm is just so efficient, it doesn’t care. Well it cares a little, but I still was able to compute this for a 2048 bit public key within just a few minutes. The result isn’t quite equal to <img decoding="async" src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="n"/>, though, as there is a 1/4 probability that both numbers were even, and 1/9 that both of them were divisible by 3. But <img decoding="async" src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="n"/> is supposed to have only two, very large prime divisors, so after doing trial division of the first few hundred primes or so, we can be relatively certain that what is left over is the actual public key.</p>



<h2>Chapter 3: A slight detour into Schnorr signatures</h2>



<p>Before we go into post quantum signature schemes, we should look at one more classical signature scheme, that while not used much in practice (curse you, patents), is going to be very important to understand for PQ schemes. Schnorr signatures are elliptic curve signatures, that use a specific method to transform a zero knowledge proof into a signature scheme, the Fiat-Shamir transform.</p>



<p>For Schnorr, we have the usual setup of an elliptic curve of order <img decoding="async" src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="n"/> with generator point <img decoding="async" src="https://s0.wp.com/latex.php?latex=G&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="G"/>, and public key <img decoding="async" src="https://s0.wp.com/latex.php?latex=P_A+%3D+x_AG&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="P_A = x_AG"/></p>



<p>The Zero Knowledge protocol works in the following way:</p>



<p>First, the prover commits to some value <img decoding="async" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R"/>. In the case of Schnorr, this is done by choosing a random value <img decoding="async" src="https://s0.wp.com/latex.php?latex=k&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="k"/> and setting <img decoding="async" src="https://s0.wp.com/latex.php?latex=R+%3D+kG&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R = kG"/>.</p>



<p>Next, the verifier issues a challenge <img decoding="async" src="https://s0.wp.com/latex.php?latex=c&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="c"/>.</p>



<p>The prover now reveals <img decoding="async" src="https://s0.wp.com/latex.php?latex=s+%3D+k+-+c%5Ccdot+x_A+%5Cmod+n&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s = k - c\cdot x_A \mod n"/>. The verifier can check that <img decoding="async" src="https://s0.wp.com/latex.php?latex=R+%3D+sG+%2B+cP_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R = sG + cP_A"/>.</p>



<p>This proves that the prover knows <img decoding="async" src="https://s0.wp.com/latex.php?latex=x_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="x_A"/>, as without foreknowledge of the challenge, the proof <img decoding="async" src="https://s0.wp.com/latex.php?latex=s&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s"/> cannot be given for a given commitment without knowing it (or having a quantum computer at hand). However, this proof is zero knowledge, since if one knows the challenge beforehand, it is rather easy to come up with the right commitment and proof, while still keeping the commitment uniformly random, by choosing <img decoding="async" src="https://s0.wp.com/latex.php?latex=s&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s"/> randomly, and then computing <img decoding="async" src="https://s0.wp.com/latex.php?latex=R%27+%3D+sG&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R&#39; = sG"/>, and “committing” to <img decoding="async" src="https://s0.wp.com/latex.php?latex=R+%3D+R%27+%2B+cP_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R = R&#39; + cP_A"/>. This will mean that we do not lose security by playing this game multiple times, and an attacker might as well concentrate on key recovery attacks instead.</p>



<p>To convert this zero knowledge protocol into a signature scheme, we replace the challenger with a hash function. In order to ensure that our commitment was actually committed to, we add it to the hash function as well. In other words the signature scheme looks like this:</p>



<p>Choose <img decoding="async" src="https://s0.wp.com/latex.php?latex=k&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="k"/> randomly. Set <img decoding="async" src="https://s0.wp.com/latex.php?latex=r&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="r"/> to the x coordinate of <img decoding="async" src="https://s0.wp.com/latex.php?latex=R+%3D+kG&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="R = kG"/>. Compute <img decoding="async" src="https://s0.wp.com/latex.php?latex=c+%3D+H%28r+%7C%7C+m%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="c = H(r || m)"/>, and set <img decoding="async" src="https://s0.wp.com/latex.php?latex=s+%3D+k+-+c%5Ccdot+x_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s = k - c\cdot x_A"/>. We now have two variants, either setting the signature to the tuple <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28r%2C+s%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(r, s)"/> or to the tuple <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28c%2C+s%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(c, s)"/>. </p>



<p>In the first case, the verifier computes <img decoding="async" src="https://s0.wp.com/latex.php?latex=c+%3D+H%28r+%7C%7C+m%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="c = H(r || m)"/> and checks that <img decoding="async" src="https://s0.wp.com/latex.php?latex=sG+%2B+cP_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="sG + cP_A"/> has x coordinate <img decoding="async" src="https://s0.wp.com/latex.php?latex=r&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="r"/>, in the second variant, the verifier first computes <img decoding="async" src="https://s0.wp.com/latex.php?latex=sG+%2B+cP_A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="sG + cP_A"/>, takes the x coordinate and checks that <img decoding="async" src="https://s0.wp.com/latex.php?latex=c+%3D+H%28r+%7C%7C+m%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="c = H(r || m)"/>.</p>



<p>Both variants are perfectly secure, and in the case of elliptic curves it really does not matter which one is chosen. But now it gets interesting: Whether or not we can recover the public key depends on the variant. If the signature is <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28r%2C+s%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(r, s)"/>, we can compute <img decoding="async" src="https://s0.wp.com/latex.php?latex=c+%3D+H%28r+%7C%7C+m%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="c = H(r || m)"/> and perform the same operation as previously on ECDSA, and compute <img decoding="async" src="https://s0.wp.com/latex.php?latex=P_A+%3D+c%5E%7B-1%7DR+-+c%5E%7B-1%7DsG&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="P_A = c^{-1}R - c^{-1}sG"/>. However, if the signature is <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28c%2C+s%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(c, s)"/>, we have no way of finding <img decoding="async" src="https://s0.wp.com/latex.php?latex=r&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="r"/>, as it is a random x coordinate with enough entropy in order to make finding a preimage of <img decoding="async" src="https://s0.wp.com/latex.php?latex=c&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="c"/> impossible.</p>



<h2>Chapter 4: Dilithium</h2>



<p>And with that, we go to our first post quantum signature scheme. Dilithium really deserves its own full blog post, but since here we are only interested in recovering public keys, we can simplify it quite a bit. <a href="https://keymaterial.net/2023/09/01/learning-but-with-errors/" data-type="link" data-id="https://keymaterial.net/2023/09/01/learning-but-with-errors/">Recall</a> that for a learning with errors scheme, the public key is a vector <img decoding="async" src="https://s0.wp.com/latex.php?latex=t&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="t"/> and a matrix <img decoding="async" src="https://s0.wp.com/latex.php?latex=A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="A"/> modulo some prime <img decoding="async" src="https://s0.wp.com/latex.php?latex=q&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="q"/> such that <img decoding="async" src="https://s0.wp.com/latex.php?latex=t+%3D+As+%2B+e+%5Cmod+q&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="t = As + e \mod q"/> with some <em>short</em> vectors <img decoding="async" src="https://s0.wp.com/latex.php?latex=s&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s"/> and <img decoding="async" src="https://s0.wp.com/latex.php?latex=e&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="e"/>. The secret key is the short vector <img decoding="async" src="https://s0.wp.com/latex.php?latex=s&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="s"/>. For Dilithium, we now use the following zero knowledge proof:</p>



<p>First, the prover commits to the high bits <img decoding="async" src="https://s0.wp.com/latex.php?latex=w_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="w_1"/> of <img decoding="async" src="https://s0.wp.com/latex.php?latex=Ay&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="Ay"/>, where <img decoding="async" src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="y"/> is shortish. Using the high bits only is similar to adding an error, since the small error also only affects the least significant bits. The challenger then challenges with a small scalar <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathit%7Bc%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="\mathit{c}"/> (this scalar is somehow multidimensional, in a way that I will simply ignore here), and the prover responds with <img decoding="async" src="https://s0.wp.com/latex.php?latex=z+%3D+y+%2B+%5Cmathit%7Bc%7D+s&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="z = y + \mathit{c} s"/>. The challenger can now check that <img decoding="async" src="https://s0.wp.com/latex.php?latex=Az+-+%5Cmathit%7Bc%7D+t+%3D+Ay+%2B+%5Cmathit%7Bc%7DAs+-+%5Cmathit%7Bc%7DAs+-+%5Cmathit%7Bc%7De&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="Az - \mathit{c} t = Ay + \mathit{c}As - \mathit{c}As - \mathit{c}e"/> has the same high bits as the commitment <img decoding="async" src="https://s0.wp.com/latex.php?latex=w_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="w_1"/>.</p>



<p>We are just going to ignore that this protocol would not be zero knowledge, and that Dilithium actually has to use something called Fiat-Shamir with aborts, since, as mentioned, that stuff really should go into its own blog post.</p>



<p>For our purposes, the only question that matters is how this <s>zero</s>some knowledge proof is turned into a signature scheme. And here comes the bad news for our public-key-recovering ambitions: It turns out that the commitment <img decoding="async" src="https://s0.wp.com/latex.php?latex=w_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="w_1"/> is significantly larger than the challenge <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathit%7Bc%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="\mathit{c}"/>, so Dilithium uses the challenge in the signature landing on <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28%5Cmathit%7Bc%7D%2C+z%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(\mathit{c}, z)"/>, instead of the commitment, which, as with Schnorr signatures, makes the public key unrecoverable.</p>



<p>A separate, interesting question is if we could recover the public key if <img decoding="async" src="https://s0.wp.com/latex.php?latex=w_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="w_1"/> was part of the signature instead. If we knew <img decoding="async" src="https://s0.wp.com/latex.php?latex=A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="A"/>, we could at least recover the high bits of <img decoding="async" src="https://s0.wp.com/latex.php?latex=t&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="t"/>, which are the ones that matter. (As it turns out, Dilithium actually doesn’t even include the least significant bits of <img decoding="async" src="https://s0.wp.com/latex.php?latex=t&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="t"/> in the actual public key, to save a few bits in there).</p>



<p>Without knowledge of <img decoding="async" src="https://s0.wp.com/latex.php?latex=A&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="A"/>, this becomes a lot of linear algebra, which I haven’t done, you’d certainly need more than one valid signature, as a single signature does not contain enough information to recover that giant matrix.</p>



<p>Part of the reason why I haven’t done that linear algebra is that if we knew <img decoding="async" src="https://s0.wp.com/latex.php?latex=w_1&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="w_1"/> through some side channel or similar, we still would have no chance recovering the public key since Dilithium rudely hashes the public key with the message when computing the challenge, destroying any hopes of recovery.</p>



<h2>Chapter 5 SPHINCS+</h2>



<p>This brings us nicely to SPHINCS+. SPHINCS+ is a hash based signature scheme, meaning that it follows the simple logic that if, at time of public key creation, you already know what you would like to sign, you can just hash that thing and call that your public key instead. If you want to sign a lot of things, you can just pack all of these things into a <a href="https://en.wikipedia.org/wiki/Merkle_tree" data-type="link" data-id="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a>, and declare the root of that tree to be your public key. If you don’t know what you want to sign, you can just commit to every possible message, by creating commitments for the single bits of a hash. Throw some randomness in there so you don’t by accident reuse your commitments to the point of breaking, and you get SPHINCS+. The scheme probably also deserves its own blog post, but we don’t really need much more for now. A Merkle tree inclusion proof will leak the root node of the Merkle tree, as long as we can observe the initial message of which the inclusion is proven. Unfortunately, loving hashing so much, the authors of SPHINCS+ did the same thing as Dilithium did, and hash in the public key when computing the initial message hash, making the public key unrecoverable. You only need relatively little extra information to recover though, and it is possible that some timing attacks on the verifying logic would suffice to pick back up and continue along the Merkle tree.</p>



<h2>Chapter 6: Unbalanced Oil and Vinegar</h2>



<p>Lastly, let’s look at a fun candidate in the second onramp called Unbalanced Oil and Vinegar. It again could use its own blog post, but here it is, slightly condensed and leaving out such unnecessary details as what the private key is and how anyone actually computes a valid signature in the first place.</p>



<p>Remember solving quadratic equations in high school? Like just given a value <img decoding="async" src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="y"/>, find the value <img decoding="async" src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="x"/> such that <img decoding="async" src="https://s0.wp.com/latex.php?latex=ax%5E2+%2B+bx+%2B+c+%3D+y&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="ax^2 + bx + c = y"/>? Now imagine someone turned that into a signature scheme. Of course, even adversaries know that <img decoding="async" src="https://s0.wp.com/latex.php?latex=x_%7B1%2C2%7D+%3D+%5Cfrac%7B-b%5Cpm+%5Csqrt%7Bb%5E2+-+4ac%7D%7D%7B2a%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="x_{1,2} = \frac{-b\pm \sqrt{b^2 - 4ac}}{2a}"/>, so we will have to increase the difficulty a tiny bit by making things higher dimensional, but the idea remains the same.</p>



<p>A UOV public key is a system of <img decoding="async" src="https://s0.wp.com/latex.php?latex=o&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="o"/> quadratic equations <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28f_i%28x_1%2C+x_2%2C+%5Cdots%2C+x_%7Bo%2Bv%7D%29_%7Bi%3D1%2C%5Cdots+o%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(f_i(x_1, x_2, \dots, x_{o+v})_{i=1,\dots o}"/> in <img decoding="async" src="https://s0.wp.com/latex.php?latex=o+%2B+v&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="o + v"/> variables. These equations are homogenous, so we can also describe them via a matrix: <img decoding="async" src="https://s0.wp.com/latex.php?latex=f_i%28x%29+%3D+x%5ETA_ix&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="f_i(x) = x^TA_ix"/>, where <img decoding="async" src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="x"/> is a vector. To sign with this, signer computes (via a miraculous trap door, this post is too short to contain) a value <img decoding="async" src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="x"/>, such that <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28f_i%28x%29%29_i%3D%7B1%5Cdots+o%7D+%3D+H%28m%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(f_i(x))_i={1\dots o} = H(m)"/>. The real trick to UOV is in the process of <em>how</em> the signer computes this preimage, but we do not care about that, we care about recovering public keys. Clearly, since a UOV signature is much shorter than a UOV public key, a single signature will not suffice to recover the public key, but what if we collect more than just one? What we have is a unknown set of polynomials, evaluated at certain known points (the signatures) getting to certain known images (the hashes of the messages). This sounds like a job for polynomial interpolation!</p>



<p>And indeed, with “just” <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cfrac%7B%28o%2Bv%29%28o%2Bv%2B1%29%7D%7B2%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="\frac{(o+v)(o+v+1)}{2}"/> message/signature pairs, we will be able to recover the public key:</p>



<p>We take the basis</p>



<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cleft%28b_i%5Cright%29_%7Bi%3D1%7D%5E%7B%5Cfrac%7B%28o%2Bv%29%28o%2Bv%2B1%29%7D%7B2%7D%7D%3D%5Cleft%28X_i%5Ccdot+X_j%5Cright%29_%7Bi%3D1%2Cj%3Di%7D%5E%7Bu%2Bv%2C+u%2Bv%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="\left(b_i\right)_{i=1}^{\frac{(o+v)(o+v+1)}{2}}=\left(X_i\cdot X_j\right)_{i=1,j=i}^{u+v, u+v}"/></p>



<p>and for each message/signature pair <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28x_j%2C+y_j%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="(x_j, y_j)"/>, we compute <img decoding="async" src="https://s0.wp.com/latex.php?latex=b_k%28x_j%29&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="b_k(x_j)"/>. Since we know that <img decoding="async" src="https://s0.wp.com/latex.php?latex=f_i%28x_j%29%3Dy_j&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="f_i(x_j)=y_j"/>, and know that each <img decoding="async" src="https://s0.wp.com/latex.php?latex=f_i&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="f_i"/> is a linear combination of the <img decoding="async" src="https://s0.wp.com/latex.php?latex=b_k&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="b_k"/>, this gives us a linear equation, which starts having a unique solution once we have collected <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cfrac%7B%28o%2Bv%29%28o%2Bv%2B1%29%7D%7B2%7D&amp;bg=ffffff&amp;fg=000&amp;s=0&amp;c=20201002" alt="\frac{(o+v)(o+v+1)}{2}"/> signatures. On top of that, UOV doesn’t hash in the public key (probably because the public key is ginormous), so this works even on the candidate as published.</p>



<p>UOV also features a version with a compressed public key (as mentioned the public key is a tad big). This blog post is already really long, so I just remark that we cannot recover this compressed public key, since it involves a seed and we can’t find preimages of hash functions when the preimage has that much entropy. But the expanded public key is equivalent in any way, so I will still count UOV as a success.</p>



<h2>Conclusion</h2>



<p>Public keys are public, even when you don’t tell people about them. Signature schemes vary greatly in how easily the keys are recovered, but keep in mind that verification logic is usually not written to be side channel resistant, so even with schemes that do not leak the public key algebraically, there might still be a way for an adversary to recover the public key, and you need to design your protocols to be resilient against that property.</p>

		</div><!-- .entry-content -->

	</div><!-- .post-inner -->

	<!-- .section-inner -->

	
	<!-- .pagination-single -->

	
		<!-- .comments-wrapper -->

		
</article><!-- .post -->

</div></div>
  </body>
</html>
