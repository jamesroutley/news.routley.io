<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andrevidela.com/blog/2025/binding-application/">Original</a>
    <h1>Binding Application in Idris</h1>
    
    <div id="readability-page-1" class="page"><article> <div id="markdown-content"> <p>I’ve recently implemented <em>binding</em> application as a language feature in Idris. This feature allows writing types such as Dependent pairs in a more ergonomic way without relying on special compiler magic. Or rather, the compiler magic is made available to everyone. This post is a collection of uses for this feature.</p> <p>This feature is not publicly available yet, but I intend to make it available in the near future.</p> <h2 id="what-is-it">What is it?</h2> <p>Binding syntax and binding-application is an idea I had a couple of years ago and presented at <a href="https://popl24.sigplan.org/details/wits-2024-papers/1/Binding-Syntax-for-Dependently-Typed-Programs" rel="external nofollow noopener" target="_blank">WITS 2024</a>. It’s a syntactic feature piggybacking on the function-space of a dependent programming language that offers some customisation to the notion of <em>binding</em>. The main use case is to facilitate writing types such as \(\Pi\) or \(\Sigma\) where the second argument is a function dependent on the type given in the first argument. In Idris, one can mark such functions as <code>typebind</code> because they are meant to bind a type argument, and any such function written <code>f (x : t) | g x</code> desugars to <code>f t (\x : t =&gt; g x)</code> This pattern can be generalised to any function with a trailing lambda where the second argument does not necessarily depend on the first. This syntax looks like this <code>f (x &lt;- e) | g x</code> and desugars to <code>f e (\x : ? =&gt; g x)</code>, those functions are <code>autobind</code> since the type is automatically inferred.</p> <p>Let’s move onto the use cases.</p> <h3 id="sigma">Sigma</h3> <p>Dependent pairs, or sigma-types, are ubiquitous in programming with dependent types. If you define your own sigma-type, you have to use a lambda to describe the type of the second projection.</p> <div><div><pre><code><span>record</span> <span>Sigma</span> <span>(</span><span>a</span> <span>:</span> <span>Type</span><span>)</span> <span>(</span><span>b</span> <span>:</span> <span>a</span> <span>-&gt;</span> <span>Type</span><span>)</span> <span>where</span>
  <span>constructor</span> <span>(</span><span>&amp;&amp;</span><span>)</span>
  <span>first</span> <span>:</span> <span>a</span>
  <span>second</span> <span>:</span> <span>b</span> <span>first</span>

<span>RichList :</span> <span>Type </span><span>-&gt;</span> <span>Type
RichList</span> <span>a</span> <span>=</span> <span>Sigma</span> <span>Nat </span><span>(</span><span>\</span><span>n</span> <span>=&gt;</span> <span>Vect</span> <span>n</span> <span>a</span><span>)</span> <span>-- lambda here</span>
</code></pre></div></div> <p>By marking the type as binding, we can use a much more natural syntactic form.</p> <div><div><pre><code><span>typebind</span>
<span>record</span> <span>Sigma</span> <span>(</span><span>a</span> <span>:</span> <span>Type</span><span>)</span> <span>(</span><span>b</span> <span>:</span> <span>a</span> <span>-&gt;</span> <span>Type</span><span>)</span> <span>where</span>
  <span>constructor</span> <span>(</span><span>&amp;&amp;</span><span>)</span>
  <span>first</span> <span>:</span> <span>a</span>
  <span>second</span> <span>:</span> <span>b</span> <span>first</span>

<span>RichList :</span> <span>Type </span><span>-&gt;</span> <span>Type
RichList</span> <span>a</span> <span>=</span> <span>Sigma</span> <span>(</span><span>n</span> <span>:</span> <span>Nat</span><span>)</span> <span>|</span> <span>Vect</span> <span>n</span> <span>a</span>
</code></pre></div></div> <h3 id="exists">Exists</h3> <p>The Idris <code>base</code> library has a type called <code>Exists : (a : Type) -&gt; (b : a -&gt; Type) -&gt; Type</code> which is exactly the same as the dependent pair, except that its first argument is erased. Marking the type as <code>typebind</code> allows writing <code>Exists (a : Type) | p a</code>, that syntax enables the natural mathematical reading “There exists a type <code>a</code> <em>such that</em> <code>p</code> of <code>a</code> holds”.</p> <div><div><pre><code><span>typebind</span>
<span>record</span> <span>Exists </span><span>(</span><span>a</span> <span>:</span> <span>Type</span><span>)</span> <span>(</span><span>b</span> <span>:</span> <span>a</span> <span>-&gt;</span> <span>Type</span><span>)</span> <span>where</span>
  <span>constructor</span> <span>(</span><span>-!</span><span>)</span>
  <span>0</span> <span>index</span> <span>:</span> <span>a</span>
  <span>pred</span> <span>:</span> <span>b</span> <span>index</span>
</code></pre></div></div> <h3 id="subset">Subset</h3> <p>A similar type exists in base except that the predicate is erased. This type represents values which are constrained by a predicate, but we don’t need to carry the predicate at runtime.</p> <div><div><pre><code><span>typebind</span>
<span>record</span> <span>Subset</span> <span>(</span><span>a</span> <span>:</span> <span>Type</span><span>)</span> <span>(</span><span>pred</span> <span>:</span> <span>a</span> <span>-&gt;</span> <span>Type</span><span>)</span> <span>where</span>
  <span>constructor</span> <span>(</span><span>!-</span><span>)</span>
  <span>value</span> <span>:</span> <span>a</span>
  <span>0</span> <span>constraint</span> <span>:</span> <span>pred </span><span>value</span>
</code></pre></div></div> <p>Such a type can be written <code>Subset (x : Nat) | LTE x 9</code> and can be read “a value <code>x</code> of type <code>Nat</code> <em>such that</em> <code>x</code> is smaller or equal to <code>9</code>”</p> <h3 id="ornaments">Ornaments</h3> <p>Ornaments are type-descriptors, they contain all the necessary to build types within a dependently-typed programming language. Here is the most basic definitions:</p> <div><div><pre><code>  <span>data</span> <span>Orn</span> <span>:</span> <span>(</span><span>j</span> <span>:</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>(</span><span>j</span> <span>-&gt;</span> <span>i</span><span>)</span> <span>-&gt;</span> <span>Desc</span> <span>i</span> <span>-&gt;</span> <span>Type </span><span>where</span>

    <span>Say</span> <span>:</span> <span>Inverse</span> <span>e</span> <span>i</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>Say</span> <span>i</span><span>)</span>

    <span>Ask</span> <span>:</span> <span>Inverse</span> <span>e</span> <span>i</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>d</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>Ask</span> <span>i</span> <span>d</span><span>)</span>

    <span>Sig</span> <span>:</span> <span>(</span><span>s</span> <span>:</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>{</span><span>d</span> <span>:</span> <span>s</span> <span>-&gt;</span> <span>Desc</span> <span>i</span><span>}</span> <span>-&gt;</span> <span>((</span><span>sv</span> <span>:</span> <span>s</span><span>)</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>d</span> <span>sv</span><span>))</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>Sig</span> <span>s</span> <span>d</span><span>)</span>

    <span>Del</span> <span>:</span> <span>(</span><span>s</span> <span>:</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>(</span><span>s</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>d</span><span>)</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>d</span>
</code></pre></div></div> <p>We notice that both <code>Sig</code> and <code>Del</code> have the perfect shape for making use of binding application. Therefore, we can rename them and mark them as binding:</p> <div><div><pre><code>  <span>data</span> <span>Orn</span> <span>:</span> <span>(</span><span>j</span> <span>:</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>(</span><span>j</span> <span>-&gt;</span> <span>i</span><span>)</span> <span>-&gt;</span> <span>Desc</span> <span>i</span> <span>-&gt;</span> <span>Type</span> <span>where</span>

    <span>Say</span> <span>:</span> <span>Inverse</span> <span>e</span> <span>i</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>Say</span> <span>i</span><span>)</span>

	<span>Ask</span> <span>:</span> <span>Inverse</span> <span>e</span> <span>i</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>d</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>Ask</span> <span>i</span> <span>d</span><span>)</span>

    <span>typebind</span>
    <span>Σ</span> <span>:</span> <span>(</span><span>s</span> <span>:</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>{</span><span>d</span> <span>:</span> <span>s</span> <span>-&gt;</span> <span>Desc</span> <span>i</span><span>}</span> <span>-&gt;</span> <span>((</span><span>sv</span> <span>:</span> <span>s</span><span>)</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>d</span> <span>sv</span><span>))</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>(</span><span>Sig</span> <span>s</span> <span>d</span><span>)</span>

    <span>typebind</span>
    <span>Δ</span>  <span>:</span> <span>(</span><span>s</span> <span>:</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>(</span><span>s</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>d</span><span>)</span> <span>-&gt;</span> <span>Orn</span> <span>j</span> <span>e</span> <span>d</span>
</code></pre></div></div> <p>Every time we want to use <code>Σ</code> or <code>Δ</code>, we can use binding syntax, for example, the ornament decorating the <code>Nat</code> description into <code>Fin n</code> makes use of <code>Δ</code>:</p> <div><div><pre><code><span>NatD :</span> <span>Desc</span> <span>()</span>
<span>NatD</span> <span>=</span> <span>Sig</span> <span>(</span><span>#</span><span>[</span><span>&#34;Z&#34;</span><span>,</span> <span>&#34;S&#34;</span><span>])</span> <span>$</span> <span>\</span><span>case</span>
    <span>&#34;Z&#34;</span> <span>=&gt;</span> <span>Say</span> <span>()</span>
    <span>&#34;S&#34;</span> <span>=&gt;</span> <span>Ask</span> <span>()</span> <span>(</span><span>Say</span> <span>()</span><span>)</span>

<span>FinO :</span> <span>Orn</span> <span>NatT</span> <span>(</span><span>const ()</span><span>)</span> <span>NatD</span>
<span>FinO</span> <span>=</span> <span>Sig</span> <span>(</span><span>#</span><span>[</span><span>&#34;Z&#34;</span><span>,</span> <span>&#34;S&#34;</span><span>])</span> <span>$</span> <span>\</span><span>case</span>
    <span>&#34;Z&#34;</span> <span>=&gt;</span> <span>Δ</span> <span>(</span><span>xn</span> <span>:</span> <span>NatT</span><span>)</span> <span>|</span> <span>Say</span> <span>(</span><span>Ok</span> <span>(</span><span>S</span> <span>xn</span><span>))</span>
    <span>&#34;S&#34;</span> <span>=&gt;</span> <span>Δ</span> <span>(</span><span>xn</span> <span>:</span> <span>NatT</span><span>)</span> <span>|</span> <span>Ask</span> <span>(</span><span>Ok</span> <span>xn</span><span>)</span> <span>(</span><span>Say</span> <span>(</span><span>Ok</span> <span>(</span><span>S</span> <span>xn</span><span>)))</span>
</code></pre></div></div> <h3 id="forall">ForAll</h3> <p>Another type in <code>base</code> is the predicate transformer <code>All : (p : a -&gt; Type) -&gt; (xs : List a) -&gt; Type</code>. It takes a predicate <code>p</code> and ensures it holds for every element of the list <code>xs</code>. There are some cases where writing the predicate is a bit awkward because it cannot be written point-free and requires a lambda. For this, one can use a binding alias:</p> <div><div><pre><code><span>autobind</span>
<span>ForAll :</span> <span>List </span><span>a</span> <span>-&gt;</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>Type
ForAll</span> <span>xs</span> <span>p</span> <span>=</span> <span>All</span> <span>p</span> <span>xs</span>
</code></pre></div></div> <p>Because the first argument is not a type, we use <code>autobind</code> instead of <code>typebind</code>. The syntax also makes clear that we are “iterating” over the list rather than using the list itself as the argument to the predicate.</p> <p>This enables the syntax:</p> <div><div><pre><code><span>ForAll</span> <span>(</span><span>x</span> <span>&lt;-</span> <span>xs</span><span>)</span> <span>|</span> <span>LTE</span> <span>x</span> <span>9</span>
</code></pre></div></div> <p>Which reads “for all <code>x</code> in <code>xs</code> the predicate <code>LTE x 9</code> holds”</p> <p>Without the binding syntax, we would have to write the following, which doesn’t read as nicely:</p>  <h3 id="forsome">ForSome</h3> <p>In addition to <code>All</code> there is <code>Any</code> a predicate transformer that ensures exactly one of the elements in the list satisfies the predicate. The alias can be written in the same way:</p> <div><div><pre><code><span>autobind</span>
<span>ForSome :</span> <span>List </span><span>a</span> <span>-&gt;</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>Type</span><span>)</span> <span>-&gt;</span> <span>Type
ForSome</span> <span>xs</span> <span>p</span> <span>=</span> <span>Any</span> <span>p</span> <span>xs</span>
</code></pre></div></div> <p>And similarly we can write</p> <div><div><pre><code><span>ForSome</span> <span>(</span><span>x</span> <span>&lt;-</span> <span>xs</span><span>)</span> <span>|</span> <span>LTE</span> <span>x</span> <span>9</span>
</code></pre></div></div> <p>With the benefit that it reads nicely as “For some <code>x</code> in <code>xs</code>, the predicate <code>LTE x 9</code> holds”</p> <h3 id="for-loops">For-Loops</h3> <p>The most exciting application for me is the fact that we can have idiomatic-looking for-loops in the language.</p> <p>A for-loop in its C interpretation is a loop defined by three components: An initial state, a break condition, and a state update. This is a very low-level representation of loops, so much so that subsequent languages have abstracted over the notion of loops by relying on <em>iterators</em>. While the details differ from language to language, the general idea remains: An iterator allows iterating over each element once using <code>for</code>. Here are a few examples where the iterator is <code>xs</code>:</p> <div><div><pre><code>// python
for x in xs:
  body

//scala
for (x &lt;- xs) body

// zig
for (xs) |x| {
  body
}

// java
for (x : xs) {
  body
}

//rust
for x in xs {
  body
}
</code></pre></div></div> <p>Back to Idris, it has a function <code>traverse</code> with the type <code>traverse : Traversable t =&gt; Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</code>, this type captures the notion that for every “ iterator” <code>t</code>, we can perform a side-effect <code>f</code> and return a new list. With binding application we can define <code>for</code> in Idris as an alias for <code>traverse</code>.</p> <div><div><pre><code><span>autobind</span>
<span>for</span> <span>:</span> <span>Applicative</span> <span>f</span> <span>=&gt;</span> <span>Traversable</span> <span>t</span> <span>=&gt;</span> <span>t</span> <span>a</span> <span>-&gt;</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>f</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>f</span> <span>(</span><span>t</span> <span>b</span><span>)</span>
<span>for</span> <span>=</span> <span>flip</span> <span>traverse</span>
</code></pre></div></div> <p>It enables the following syntax:</p> <div><div><pre><code><span>xs :</span> <span>List String</span>
<span>xs</span> <span>=</span> <span>[</span><span>&#34;hello&#34;</span><span>,</span>  <span>&#34;world&#34;</span><span>,</span> <span>&#34;!&#34;</span><span>]</span>

<span>main :</span> <span>IO </span><span>()</span>
<span>main</span> <span>=</span> <span>ignore</span> <span>$</span> <span>for</span> <span>(</span><span>x</span> <span>&lt;-</span> <span>xs</span><span>)</span> <span>|</span>
  <span>putStrLn </span><span>x</span>
</code></pre></div></div> <p>Which mimics the syntax used in other programming languages to iterate on a list. <code>ignore</code> discards the result of the iteration.</p> </div> </article></div>
  </body>
</html>
