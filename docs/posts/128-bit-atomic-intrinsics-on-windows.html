<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iangrunert.com//2025/02/07/128-bit-atomic-intrinsics-windows-x86.html">Original</a>
    <h1>128 bit atomic intrinsics on Windows</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>While working on <a href="https://bugs.webkit.org/show_bug.cgi?id=283311">enabling libpas on the Windows port for WebKit</a>, I ran into some linking errors:</p>

<div><div><pre><code>lld-link: error: undefined symbol: __atomic_compare_exchange
lld-link: error: undefined symbol: __atomic_store
lld-link: error: undefined symbol: __atomic_load
</code></pre></div></div>

<p>These corresponded to clang’s builtin 128-bit atomic intrinsic functions operating on a 
struct with two 64 bit pointers - <code>__c11_atomic_store</code>, <code>__c11_atomic_compare_exchange_weak</code>, 
<code>__c11_atomic_compare_exchange_strong</code>, and <code>__c11_atomic_load</code>.</p>

<p>After quite the run-around confirming that clang’s C runtime library was linked, 
I tried replacing the c11 intrinsics with the Microsoft <a href="https://learn.microsoft.com/en-us/cpp/intrinsics/interlockedcompareexchange128?view=msvc-170">_InterlockedCompareExchange128</a> 
intrinsic instead - which are also supported by clang.</p>

<p>The compiler gave me a much, much more useful error message after trying this:</p>

<div><div><pre><code>error: &#39;_InterlockedCompareExchange128&#39; needs target feature cx16
</code></pre></div></div>

<p>Looks like clang doesn’t assume the processor has the CX16 feature, which 
introduces the cmpxchg16b instruction. After adding the compile option:</p>

<div><div><pre><code>add_compile_options(-mcx16)
</code></pre></div></div>

<p>The original c11 atomic intrinsics on 128 bit values work - the compiler can output the CMPXCHG16B 
instruction instead of attempting to call a function that it can’t link. I don’t have to rewrite them 
to use the Microsoft intrinsics.</p>

<p>This is a pretty frustrating default. The last processor without the CMPXCHG16B instruction 
was released in 2006 so far as I can tell. Windows 8.1 64-bit had a hard requirement on the CMPXCHG16B 
instruction, and that was released in 2013 (and is no longer supported as of 2023). I think clang should assume 
we’re building for modern hardware and supported operating systems, and make old hardware require a compiler flag. 
Seems insane that everyone has to remind the compiler that we’re running on hardware built in the last 15(+) years.</p>

<p>Specifically - I think -march=x86-64 should become an alias, x86-64-v1 should be added for the old 
processors, and x86-64 should point at x86-64-v2 (or maybe even x86-64-v3). Failing that - this is a reminder that you 
probably want to compile for x86-64-v2, not x86-64.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
