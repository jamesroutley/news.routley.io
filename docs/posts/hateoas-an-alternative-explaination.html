<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://htmx.org/essays/hateoas/">Original</a>
    
    <div id="readability-page-1" class="page"><div>
    


 
 

<section>
<h2>Preface: <em>HATEOAS — An Alternative Explanation</em></h2>
<p>This page is a reworking on the <a href="https://en.wikipedia.org/wiki/HATEOAS">Wikipedia Entry on HATEOAS</a>, which uses JSON.
Here we use HTML to explain the concept, and contrast it with JSON APIs.  It is a more opinionated explanation of the
concept than would be appropriate for Wikipedia, but it is more correct in our opinion.</p>
</section>
<p>Hypermedia as the Engine of Application State (HATEOAS) is a constraint of the <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST application architecture</a> that distinguishes it from other network application architectures.</p>
<p>With HATEOAS, a client interacts with a network application whose application servers provide information dynamically through <a href="https://en.wikipedia.org/wiki/Hypermedia"><em>hypermedia</em></a>. A REST client needs little to no prior knowledge about how to interact with an application or server beyond a generic understanding of hypermedia.</p>
<p>By contrast, today JSON-based web clients typically interact through a fixed interface shared through documentation via a tool
such as <a href="https://swagger.io/">swagger</a>.</p>
<p>The restrictions imposed by HATEOAS decouples client and server. This enables server functionality to evolve independently.</p>
<h2>Example</h2>
<p>A user-agent that implements HTTP makes a HTTP request of a REST end point through a simple URL. All subsequent requests the user-agent may make are discovered within the hypermedia responses to each request. The media types used for these representations, and the link relations they may contain, are standardized. The client transitions through application states by selecting from links within a hypermedia representation or by manipulating the representation in other ways afforded by its media type.</p>
<p>In this way, RESTful interaction is driven by hypermedia, rather than out-of-band information.</p>
<p>A concrete example will clarify this.  Consider this GET request, issued by a web browser, which fetches a bank account resource:</p>
<pre><code>GET /accounts/12345 HTTP/1.1
Host: bank.example.com
</code></pre>
<p>The server responds with a hypermedia representation using HTML:</p>
<pre><code>HTTP/1.1 200 OK

&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;Account number: 12345&lt;/div&gt;
    &lt;div&gt;Balance: $100.00 USD&lt;/div&gt;
    &lt;div&gt;Links:
        &lt;a href=&#34;/accounts/12345/deposits&#34;&gt;deposits&lt;/a&gt;
        &lt;a href=&#34;/accounts/12345/withdrawals&#34;&gt;withdrawals&lt;/a&gt;
        &lt;a href=&#34;/accounts/12345/transfers&#34;&gt;transfers&lt;/a&gt;
        &lt;a href=&#34;/accounts/12345/close-requests&#34;&gt;close-requests&lt;/a&gt;
    &lt;/div&gt;
  &lt;body&gt;
&lt;/html&gt;
</code></pre>
<p>The response contains following possible follow-up actions: navigate to a UI to enter a deposit, withdrawal, transfer, or to close request (to close the account).</p>
<p>Consider the situation at a later point, after the account has been overdrawn.  Now, a different set of links are available due to this
account status change.</p>
<pre><code>HTTP/1.1 200 OK

&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;Account number: 12345&lt;/div&gt;
    &lt;div&gt;Balance: -$50.00 USD&lt;/div&gt;
    &lt;div&gt;Links:
        &lt;a href=&#34;/accounts/12345/deposits&#34;&gt;deposits&lt;/a&gt;
    &lt;/div&gt;
  &lt;body&gt;
&lt;/html&gt;
</code></pre>
<p>Only one link is available: to deposit more money. In the accounts current overdrawn state the other actions are not available, and
this fact is reflected internally in <em>the hypermedia</em>.  The web browser does not know about the concept of an overdrawn account or,
indeed, even what an account is.  It simply knows how to present hypermedia representations to a user.</p>
<p>Hence we have the notion of the Hypermedia being the Engine of Application State. What actions are possible varies as the
state of the resource varies and this information is encoded in the hypermedia.</p>
<p>Contrast the HTML response above with a typical JSON API which, instead, might return a representation of the account with a
status field:</p>
<pre><code>HTTP/1.1 200 OK

{
    &#34;account&#34;: {
        &#34;account_number&#34;: 12345,
        &#34;balance&#34;: {
            &#34;currency&#34;: &#34;usd&#34;,
            &#34;value&#34;: -50.00
        },
        &#34;status&#34;: &#34;overdrawn&#34;
    }
}
</code></pre>
<p>Here we can see that the client must know specifically what the value of the <code>status</code> field means and how it might affect
the rendering of a user interface, and what actions can be taken with it.  The client must also know what URLs must be used
for manipulation of this resource since they are not encoded in the response.  This would typically be achieved by
consulting documentation for the JSON API.</p>
<p>It is this requirement of out-of-band information that distinguishes this JSON API from a RESTful API that implements
HATEOAS.</p>
<p>This shows the core difference between the two approaches: in the RESTful, HATEOAS HTML representation, all operations are encoded
directly in the response.  In the JSON API example, out-of-band information is necessary for processing and working with
the remote resource.</p>
<h2>Origins</h2>
<p>The HATEOAS constraint is an essential part of the <a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface">&#34;uniform interface&#34;</a> feature of REST, as defined in Roy Fielding&#39;s <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">doctoral dissertation</a>. Fielding&#39;s dissertation was a discussion of the
early web architecture, consisting mainly of HTML and HTTP at the time.</p>
<p>Fielding has further described the concept, and the crucial requirement of hypermedia, <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">on his blog</a>.</p>
<h2>HATEOAS and JSON</h2>
<p><em>NOTE: The Neutral Tone Of This Section is Disputed</em></p>
<p>In the early 2000s the concept of REST was appropriated from its initial conceptual environment as a description of the early web into other areas of web development: first XML API development (often using <a href="https://en.wikipedia.org/wiki/SOAP">SOAP</a>) and then JSON API development.  This, despite the fact that neither XML nor JSON was a natural hypermedia in the same manner as HTML.</p>
<p>In order to characterize different levels of adherence to REST in these new areas, <a href="https://en.wikipedia.org/wiki/Richardson_Maturity_Model">The Richardson Maturity Model</a> was proposed, consisting of various levels of &#34;maturity&#34; of APIs, with the highest level,
Level 3, consisting of &#34;Hypermedia Controls&#34;.</p>
<p>JSON is not a natural hypermedia and, therefore, hypermedia concepts can only be imposed on top of it.  A JSON engineer
attempting to meet Level 3 of the Richardson Maturity Model might return the following JSON corresponding to the
bank account example above:</p>
<pre><code>HTTP/1.1 200 OK

{
    &#34;account&#34;: {
        &#34;account_number&#34;: 12345,
        &#34;balance&#34;: {
            &#34;currency&#34;: &#34;usd&#34;,
            &#34;value&#34;: 100.00
        },
        &#34;links&#34;: {
            &#34;deposits&#34;: &#34;/accounts/12345/deposits&#34;,
            &#34;withdrawals&#34;: &#34;/accounts/12345/withdrawals&#34;,
            &#34;transfers&#34;: &#34;/accounts/12345/transfers&#34;,
            &#34;close-requests&#34;: &#34;/accounts/12345/close-requests&#34;
        }
    }
}
</code></pre>
<p>Here, the &#34;hypermedia controls&#34; are encoded in a <code>links</code> property on the account object.</p>
<p>Unfortunately, the client of this API still needs to know quite a bit of additional information:</p>
<ul>
<li>What http methods can be used against these URLs?</li>
<li>Can it issue a <code>GET</code> to these URLs in order to get a representation of the mutation in question?</li>
<li>If it can <code>POST</code> to a given URL, what values are expected?</li>
</ul>
<p>Compare the above JSON with the following HTTP response, retrieved by a browser after a user has clicked on the
link to <code>/accounts/12345/deposits</code> found in the first HTML example:</p>
<pre><code>HTTP/1.1 200 OK

&lt;html&gt;
  &lt;body&gt;
    &lt;form method=&#34;post&#34; action=&#34;/accounts/12345/deposits&#34;&gt;
        &lt;input name=&#34;amount&#34; type=&#34;number&#39;/&gt;
        &lt;button&gt;Submit&lt;/button&gt;
    &lt;/div&gt;
  &lt;body&gt;
&lt;/html&gt;
</code></pre>
<p>Note that this HTML response encodes all the information necessary to update the account balance, providing a <code>form</code> with a <code>method</code>
and <code>action</code> attribute, as well as the inputs necessary for updating the resource correctly.</p>
<p>The JSON representation does not have the same self-contained &#34;uniform interface&#34; as the HTML representation does.</p>
<p>Labelling JSON APIs, no matter how far they stray from RESTful concepts, as &#39;REST&#39; has lead Roy Fielding to say:</p>
<blockquote>
<p>I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.</p>
</blockquote>
<p>While attempts have been made to impose more elaborate hypermedia controls on JSON APIs, broadly the industry has rejected
this approach in favor of simpler RPC-style APIs that forego HATEOAS and other elements of the REST-ful architecture.</p>
<p>This fact is strong evidence for the assertion that a natural hypermedia such as HTML is a practical
necessity for building RESTful systems.</p>


</div></div>
  </body>
</html>
