<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://organicdonut.com/2024/11/18/i-wrote-crossword-software-in-haskell/">Original</a>
    <h1>I Wrote Crossword Software! In Haskell!</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>I‚Äôve been <a href="https://organicdonut.com/category/crosswords/">posting the crossword puzzles I‚Äôve been making</a> on this blog. A fellow <a href="https://recurse.com">Recurse Center</a> alum asked if I‚Äôd blogged about the software I wrote to help make these crosswords and I thought that was an interesting idea, so here we go!</p>



<p>I‚Äôll first do a high-level overview, and then we‚Äôll dive into some of the code for folks who are interested in the details of how the code actually works.</p>



<h2>Crossword Software ‚Äì Overview</h2>



<p>The software itself is in two parts: a Vue.js frontend written in JS (<a href="https://github.com/ertyseidohl/crossword-fe">github</a>), and a web API written in Haskell (<a href="https://github.com/ertyseidohl/crossword-hs">github</a>). I did this because I wanted to practice writing Haskell, and I specifically wanted to write a web server in Haskell, so the architecture isn‚Äôt optimized for anything else.</p>



<p>The frontend uses what I jokingly refer to as a SFSPA ‚Äì a ‚ÄúSingle File Single Page Application‚Äù. Pretty much all of the useful code in the frontend is written in<a href="https://github.com/ertyseidohl/crossword-fe/blob/master/src/components/Crossword.vue"> one ~1300 line Vue file</a>, all in one Vue component. For projects of a fixed, small size like this, breaking everything out into its own component and having to pass data up and down the rendering tree just ends up slowing down development. If I ever decide to turn this into anything more than it is, I would probably go through the trouble to break it up. But for now it‚Äôs really easy to just have one data store, one component, etc. I spent very little time fighting with Vue, and a lot of time actually working on the fun parts of the code, which was great.</p>



<p>The UI is super important, actually ‚Äì it‚Äôs probably more useful than the backend. It allows intuitive (to me) navigation of the crossword, and pressing ‚Äúenter‚Äù brings up a list of words that fit in the currently selected word-space. Then, I can navigate through a list of potential words and see them ‚Äúghost‚Äù into the puzzle, so that I can check what looks like it will work with the cross-words. </p>



<p>The backend uses a historical dump of NYT crossword answers, sorted by number of appearances in puzzles. I wrote this four years ago so I don‚Äôt remember where I got the data. </p>



<p>The Haskell that I wrote is super overengineered. I was learning the language, so I put my effort into figuring out how the heck to write anything, versus writing anything particularly smart. The algorithm is brute force, but it‚Äôs ‚Äúfast enough‚Äù. Someday perhaps I‚Äôll be lucky enough spend a few hours pairing with someone who really knows Haskell and I can really make this go, but right now I can use it to make crosswords and that‚Äôs good enough for me. Caveats aside, I‚Äôm still proud of the code ‚Äì it‚Äôs the first significant application I wrote in Haskell.</p>



<p>The basic approach is that the backend responds to queries that look like ‚Äú‚Ä¶A‚Äù, and then returns all of the words that match that string, where . represents an empty square. The previous string, for example, returns ‚ÄúAREA ARIA IDEA ASIA ASEA ETNA IOTA ELLA AURA ELIA‚Äù as the first page of results. You can see that the words get more obscure as you move down the list. (ARIA is up there because it has a lot of vowels, which increases its utility as a cross-word).</p>



<p>It can also attempt to solve an entire puzzle, although it does this via brute force, and therefore takes exponential(?) time. I‚Äôve found that it can solve 5√ó5 puzzles pretty well, but anything above that often causes a timeout. I don‚Äôt use the ‚Äúsolve‚Äù functionality very often, although sometimes for a difficult final corner I‚Äôll give it a try.</p>



<p>Some functionality I would LOVE to add to this is the ability to designate just a few word spaces (e.g. ‚Äú1 down, 4 across, 6 across‚Äù with spacing/letters info) and have it generate words that work in those spaces. Maybe someday ‚Äì I think that‚Äôs mostly a matter of writing the API endpoint.</p>



<p>Anyway, this has helped me write quite a few crosswords. Writing about this now, since the solver isn‚Äôt particularly useful, I could probably load the NYT data right into the frontend and just query it there in JS and that would be faster, but then I couldn‚Äôt claim that I‚Äôd written something useful in Haskell üôÇ</p>



<h2>Code Dive</h2>



<p>Just in case it‚Äôs interesting to anyone, here‚Äôs a deeper dive into the Haskell code that runs the API. Let‚Äôs trace through the function calls to the <code>/words</code> endpoint, which is the endpoint that takes in a string like ‚Äú‚Ä¶A‚Äù and returns ‚ÄúAREA ARIA‚Äù etc., as I mentioned above.</p>



<p>I‚Äôll assume you are at least familiar with Haskell syntax (which you can <a href="https://learnyouahaskell.com/">learn for free</a>, if you‚Äôre not!)</p>



<p>The main function for the entire server is in Server.hs and is:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>main</span><span> </span><span>::</span><span> </span><span>IO</span><span> </span><span>()</span></span>
<span><span>main </span><span>=</span><span> </span><span>do</span></span>
<span><span>    </span><span>-- Debug text</span></span>
<span><span>    putStrLn </span><span>&#34;Loading Words...&#34;</span></span>
<span><span>    </span></span>
<span><span>     </span><span>-- Pull data (with empty list of excluded files</span></span>
<span><span>    (errors, results) </span><span>&lt;-</span><span> loadData </span><span>&#34;data&#34;</span><span> </span><span>[]</span></span>
<span><span>    </span></span>
<span><span>    </span><span>-- Print the errors (mapM allows IO), and ignore the results (_)</span></span>
<span><span>    mapM_ print errors</span></span>
<span><span>    </span></span>
<span><span>    </span><span>-- Generate a trie structure from the results.</span></span>
<span><span>    </span><span>-- Each trie node has a &#34;wordFrequency&#34; if that node is a word</span></span>
<span><span>    </span><span>let</span><span> wts </span><span>=</span><span> map wordTrieFromFileResult results</span></span>
<span><span>    </span></span>
<span><span>    </span><span>-- Get the port from an env var and start the server</span></span>
<span><span>    port </span><span>&lt;-</span><span> getPort</span></span>
<span><span>    putStrLn </span><span>$</span><span> </span><span>&#34;Server Started at http://localhost:&#34;</span><span> </span><span>++</span><span> show port </span><span>++</span><span> </span><span>&#34;/&#34;</span></span>
<span><span>    </span></span>
<span><span>    </span><span>-- Importantly, allow Cors, and also wrap this in a timeout func</span></span>
<span><span>    </span><span>-- since the solve endpoint in particular can take a while to run</span></span>
<span><span>    run port </span><span>$</span><span> allowCors </span><span>$</span><span> timebound </span><span>$</span><span> wordsApp wts</span></span></code></pre></div>



<p>The words are stored in a Trie generated in <code>wordTrieFromFileResult</code>, which allows for easier recursive access (<a href="https://github.com/ertyseidohl/crossword-hs/blob/master/src/WordTrie.hs">source</a>).  </p>



<p>I‚Äôll skip the code for building the tree (<a href="https://github.com/ertyseidohl/crossword-hs/blob/master/src/WordTrie.hs">source</a>) but once it‚Äôs built, we set up an API endpoint for looking up words:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>findWordCompletions</span><span> </span><span>::</span><span> [</span><span>WordTrie</span><span>] </span><span>-&gt;</span><span> </span><span>Query</span><span> </span><span>-&gt;</span><span> </span><span>Maybe</span><span> </span><span>String</span></span>
<span><span>findWordCompletions wts q </span><span>=</span><span> </span><span>do</span></span>
<span><span>    </span><span>-- Get the &#34;word&#34; query parameter</span></span>
<span><span>    wq </span><span>&lt;-</span><span> lookup </span><span>&#34;word&#34;</span><span> q</span></span>
<span><span>    </span><span>-- Unpack the Maybe value</span></span>
<span><span>    wqv </span><span>&lt;-</span><span> wq</span></span>
<span><span>    </span><span>-- Get the &#34;page&#34; query parameter (or 0, if not present)</span></span>
<span><span>    </span><span>let</span><span> page </span><span>=</span><span> </span><span>case</span><span> lookup </span><span>&#34;page&#34;</span><span> q </span><span>of</span></span>
<span><span>                </span><span>Just</span><span> pgv </span><span>-&gt;</span><span> fromMaybe </span><span>0</span><span> </span><span>$</span><span> readMaybe (maybe </span><span>&#34;0&#34;</span><span> toString pgv) </span><span>::</span><span> </span><span>Int</span></span>
<span><span>                </span><span>Nothing</span><span> </span><span>-&gt;</span><span> </span><span>0</span></span>
<span><span>    </span><span>-- call getCompletions</span></span>
<span><span>    </span><span>let</span><span> completions </span><span>=</span><span> getCompletions&#39; wts (toString wqv)</span></span>
<span><span>    </span><span>-- Return just the words that we care about. I&#39;m not entirely sure</span></span>
<span><span>    </span><span>-- if this does extra work, or if it just computes the word</span></span>
<span><span>    </span><span>-- completions lazily. Potential future optimization point!</span></span>
<span><span>    </span><span>Just</span><span> </span><span>$</span><span> unwords </span><span>$</span><span> take </span><span>10</span><span> </span><span>$</span><span> drop (</span><span>10</span><span> </span><span>*</span><span> page) completions</span></span></code></pre></div>



<p>And then <code>getCompletions&#39;</code> is the meat of this process. I can‚Äôt tell you why <code>getCompletions&#39;</code> is the main function and <code>getCompletions</code> is the helper function. Usually the apostrophe means a strict version of the function, but it doesn‚Äôt look like that‚Äôs what I‚Äôm doing here. Not sure what I was thinking four years ago!</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>getCompletions</span><span> </span><span>::</span><span> [</span><span>WordTrie</span><span>] </span><span>-&gt;</span><span> [</span><span>String</span><span>] </span><span>-&gt;</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> [</span><span>String</span><span>]</span></span>
<span><span>-- The completions for an empty string is an empty list</span></span>
<span><span>getCompletions _ _ </span><span>&#34;&#34;</span><span> </span><span>=</span><span> </span><span>[]</span></span>
<span></span>
<span><span>-- wts is the WordTrie, used is a list of words we&#39;ve already used (and therefore should be ignored), and s is the search string.</span></span>
<span><span>getCompletions wts used s</span></span>
<span></span>
<span><span>    </span><span>-- If there&#39;s a &#34;.&#34; in the word, then we need to do a search. </span></span>
<span><span>    </span><span>-- First we calculate the words using getWords, and then remove any</span></span>
<span><span>    </span><span>-- words from that list with (\\) which are already used.</span></span>
<span><span>    </span><span>|</span><span> </span><span>&#39;.&#39;</span><span> </span><span>`elem`</span><span> s </span><span>=</span><span> </span><span>let</span><span> foundWords </span><span>=</span><span> nub </span><span>$</span><span> concatMap (getWords s) wts</span></span>
<span><span>        </span><span>in</span><span> foundWords </span><span>\\</span><span> used</span></span>
<span><span>        </span></span>
<span><span>    </span><span>-- If there&#39;s no &#34;.&#34; in the word, no search is needed since it&#39;s</span></span>
<span><span>    </span><span>-- already a full word!</span></span>
<span><span>    </span><span>|</span><span> any (isWord s) wts </span><span>=</span><span> [s]</span></span>
<span><span>    </span></span>
<span><span>    </span><span>-- Handling any other case (which should never happen). Probably</span></span>
<span><span>    </span><span>-- could rewrite this as an if/else, honestly?</span></span>
<span><span>    </span><span>|</span><span> otherwise </span><span>=</span><span> </span><span>[]</span></span>
<span></span>
<span><span>getCompletions&#39;</span><span> </span><span>::</span><span> [</span><span>WordTrie</span><span>] </span><span>-&gt;</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> [</span><span>String</span><span>]</span></span>
<span><span>getCompletions&#39; wts </span><span>=</span><span> getCompletions wts </span><span>[]</span></span></code></pre></div>



<p><code>getWords</code>, then, returns a list of words that match the search string:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>getWords</span><span> </span><span>::</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>WordTrie</span><span> </span><span>-&gt;</span><span> [</span><span>String</span><span>]</span></span>
<span><span>getWords s wt </span><span>=</span></span>
<span><span>    </span><span>-- sort the (word, frequency) pairs by the frequency</span></span>
<span><span>    </span><span>let</span><span> sort </span><span>=</span><span> sortBy (flip compare </span><span>`on`</span><span> snd)</span></span>
<span><span>    </span><span>-- Return just the words, sorted</span></span>
<span><span>    </span><span>in</span><span> map fst </span><span>$</span><span> sort </span><span>$</span><span> getWords1 s wt</span></span></code></pre></div>



<p><code>GetWords1</code> (why not <code>GetWords&#39;</code>??) is almost the end of this particular deep-dive. </p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>getWords1</span><span> </span><span>::</span><span>  </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>WordTrie</span><span> </span><span>-&gt;</span><span> [</span><span>WordWithFreq</span><span>]</span></span>
<span><span>-- Empty search? All done!</span></span>
<span><span>getWords1 </span><span>[]</span><span> _ </span><span>=</span><span> </span><span>[]</span></span>
<span></span>
<span><span>-- If we&#39;re looking at a &#34;.&#34;, then we need to kick off searches</span></span>
<span><span>-- for every letter (in this case, `nodes w`). Looking at this now, I&#39;m</span></span>
<span><span>-- pretty sure I could refactor this to just call getLeaves, which *also*</span></span>
<span><span>-- fans out when it finds a &#34;.&#34;. Probably doing a lot of extra work here!</span></span>
<span><span>getWords1 (</span><span>&#39;.&#39;</span><span>:</span><span>cs) w </span><span>=</span></span>
<span><span>    </span><span>let</span><span> leaves </span><span>=</span><span> concatMap (getLeaves cs) (nodes w)</span></span>
<span><span>    </span><span>in</span><span> produceWords leaves</span></span>
<span><span>-- If we have anything but a &#34;.&#34;, then we look for just that letter</span></span>
<span><span>-- in the tree and start there. Finally, we call produceWords, which</span></span>
<span><span>-- will create letters out of the list of nodes that `getLeaves`</span></span>
<span><span>-- produces. This feels overengineered! </span></span>
<span><span>getWords1 (c</span><span>:</span><span>cs) w </span><span>=</span><span> </span><span>case</span><span> findLetter (nodes w) c </span><span>of</span></span>
<span><span>    </span><span>Just</span><span> n </span><span>-&gt;</span><span> produceWords </span><span>$</span><span> getLeaves cs n</span></span>
<span><span>    </span><span>Nothing</span><span> </span><span>-&gt;</span><span> </span><span>[]</span></span></code></pre></div>



<p>Finally, we have <code>getLeaves</code>, which returns a list of letterNodes that match the string. If, for example, we had the search string ‚ÄúAB.‚Äù and the words ‚ÄúABC ABD‚Äù, we would return both the ‚ÄúC‚Äù and ‚ÄúD‚Äù nodes.</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>getLeaves</span><span> </span><span>::</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>LetterNode</span><span> </span><span>-&gt;</span><span> [</span><span>LetterNode</span><span>]</span></span>
<span><span>-- I had to ask about this when reading it again four years after I</span></span>
<span><span>-- wrote it! The pipe character here creates a list comprehension</span></span>
<span><span>-- (https://wiki.haskell.org/List_comprehension). In this case, we</span></span>
<span><span>-- have reached the end of the search string, so we check: if this</span></span>
<span><span>-- is a word (this node has a wordFrequency) then we return a list</span></span>
<span><span>-- containing just l. Otherwise, we return an empty list.</span></span>
<span><span>getLeaves </span><span>[]</span><span> l </span><span>=</span><span> [l </span><span>|</span><span> isJust </span><span>$</span><span> wordFrequency l]</span></span>
<span></span>
<span><span>-- If we encounter a dot, we fan out and continue with all of the children,</span></span>
<span><span>-- since &#34;.&#34; matches every character</span></span>
<span><span>getLeaves (</span><span>&#39;.&#39;</span><span>:</span><span>cs) l </span><span>=</span></span>
<span><span>    concatMap (getLeaves cs) (children l)</span></span>
<span></span>
<span><span>-- Finally, if we have any actual character, we see if that character is</span></span>
<span><span>-- in the current node&#39;s children. If it is, we continue, if not, we have</span></span>
<span><span>-- found a non-word and can return an empty list. </span></span>
<span><span>getLeaves (c</span><span>:</span><span>cs) l </span><span>=</span><span> </span><span>case</span><span> findLetter (children l) c </span><span>of</span></span>
<span><span>    </span><span>Just</span><span> n </span><span>-&gt;</span><span> getLeaves cs n</span></span>
<span><span>    </span><span>Nothing</span><span> </span><span>-&gt;</span><span> </span><span>[]</span></span></code></pre></div>



<p><code>produceWords</code> takes in a list of letter nodes that match, and walks backward up the trie to actually figure out the strings that those letter nodes represent. As a side note, I‚Äôm really not a fan of <code>where</code> notation since it means you have to read the entire function to figure out what variables are defined!</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>produceWords</span><span> </span><span>::</span><span> [</span><span>LetterNode</span><span>] </span><span>-&gt;</span><span> [</span><span>WordWithFreq</span><span>]</span></span>
<span><span>-- Call readUp on each of the letter nodes in the list</span></span>
<span><span>produceWords </span><span>=</span><span> map readUp</span></span>
<span></span>
<span><span>readUp</span><span> </span><span>::</span><span> </span><span>LetterNode</span><span> </span><span>-&gt;</span><span> </span><span>WordWithFreq</span></span>
<span><span>-- We take in a single letterNode</span></span>
<span><span>readUp l </span><span>=</span><span> </span><span>case</span><span> parent l </span><span>of</span></span>
<span><span>        </span><span>-- If that letternode has a parent, we call readUp_ which gives us</span></span>
<span><span>        </span><span>-- the string associated with this letter node, and then we</span></span>
<span><span>        </span><span>-- reverse that string (since we &#34;read&#34; it backwards). Finally, we</span></span>
<span><span>        </span><span>-- include the word frequency in the return value for sorting.</span></span>
<span><span>        </span><span>Just</span><span> p </span><span>-&gt;</span><span> (reverse (char l </span><span>:</span><span> readUp_ p), wf)</span></span>
<span><span>        </span><span>-- When we hit the top, that means we&#39;re done!</span></span>
<span><span>        </span><span>Nothing</span><span> </span><span>-&gt;</span><span> ([char l], wf)</span></span>
<span><span>        </span><span>where</span></span>
<span><span>            </span><span>-- Get the word frequency. Throws an error if there isn&#39;t a </span></span>
<span><span>            </span><span>-- word frequency (which should never happen, since we only</span></span>
<span><span>            </span><span>-- call this function when we are trying to read a word, which</span></span>
<span><span>            </span><span>-- by defintion has a frequency).</span></span>
<span><span>            wf </span><span>=</span><span> fromMaybe (error </span><span>&#34;Can&#39;t readUp nonword&#34;</span><span>) (wordFrequency l)</span></span>
<span></span>
<span><span>readUp_</span><span> </span><span>::</span><span> </span><span>LetterNode</span><span> </span><span>-&gt;</span><span> </span><span>String</span></span>
<span><span>-- Helper function that actually recurses up the parent stack,</span></span>
<span><span>-- building the String along the way</span></span>
<span><span>readUp_ l </span><span>=</span><span> </span><span>case</span><span> parent l </span><span>of</span></span>
<span><span>    </span><span>Just</span><span> p </span><span>-&gt;</span><span> char l </span><span>:</span><span> readUp_ p</span></span>
<span><span>    </span><span>Nothing</span><span> </span><span>-&gt;</span><span> [char l]</span></span></code></pre></div>



<p>And that‚Äôs the main thing that this program does! Reading it again four years later, I think it‚Äôs really overengineered. Iterating over a list of words with a regex in javascript would probably be faster, but this was a really fun exploration of Haskell and allowed me to test out some interesting data structures that I don‚Äôt normally get to try! </p>



<p>From Grand Rapids,</p>



<p>Erty</p>
</div></div>
  </body>
</html>
