<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neilmadden.blog/2018/08/30/moving-away-from-uuids/">Original</a>
    <h1>Moving Away from UUIDs</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>If you need an unguessable random string (for a session cookie or access token, for example), it can be tempting to reach for a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)">random UUID</a>, which looks like this:</p>
<pre> 88cf3e49-e28e-4c0e-b95f-6a68a785a89d</pre>
<p>This is a 128-bit value formatted as 36 hexadecimal digits separated by hyphens. In Java and most other programming languages, these are very simple to generate:</p>
<pre> import java.util.UUID;  
String id = UUID.randomUUID().toString();</pre>
<p>Under the hood this uses a cryptographically secure pseudorandom number generator (CSPRNG), so the IDs generated are pretty unique. However, there are some downsides to using random UUIDs that make them less useful than they first appear. In this note I will describe them and what I suggest using instead.</p>

<h2>How random is a UUID anyway?</h2>
<p>As stated on the <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)">Wikipedia entry</a>, of the 128 bits in a random UUID, 6 are fixed variant and version bits leaving 122 bits of actual random. 122 bits is still quite a lot of random, but is it actually enough? If you are generating OAuth 2 access tokens, then <a href="https://tools.ietf.org/html/rfc6749#section-10.10">the spec says no</a>:</p>
<blockquote><p>The probability of an attacker guessing generated tokens (and other</p></blockquote>
<p>Well, even if the attacker only makes a single guess, the probability of guessing a 122-bit random value can never be less than 2<sup>-122</sup>, so strictly speaking a random UUID is in violation of the spec. But does it really matter?</p>
<p>To work out how long it would take an attacker to guess a valid token/cookie, we need to consider a number of factors:</p>
<ul>
<li>How quickly can the attacker make guesses? An attacker that can try millions of candidate tokens per second can find a match much faster than somebody who can only try a hundred. We will call this rate (in guesses per second) <em>A</em>.</li>
<li>How many bits of randomness are in each token? A 128-bit random token is more difficult to guess than a 64-bit token. We will label the number of random bits <em>B</em>.</li>
<li>How many tokens are valid at any given time? If you have issued a million active session cookies then an attacker can try and guess <em>any</em> of them, making their job easier than if there was just one. Such <a href="https://blog.cr.yp.to/20151120-batchattacks.html">batch attacks</a> are often overlooked. We will label the number of valid tokens in circulation at any one time <em>S</em>.</li>
</ul>
<p>Given these parameters, <a href="https://www.owasp.org/index.php/Insufficient_Session-ID_Length">OWASP give a formula for calculating how long it will take an attacker to guess a random token as</a>:</p>
<p><img data-attachment-id="3321" data-permalink="https://neilmadden.blog/2018/08/30/moving-away-from-uuids/img_1549/" data-orig-file="https://neilmadden.files.wordpress.com/2018/08/img_1549.jpg" data-orig-size="242,187" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="img_1549" data-image-description="" data-image-caption="" data-medium-file="https://neilmadden.files.wordpress.com/2018/08/img_1549.jpg?w=242" data-large-file="https://neilmadden.files.wordpress.com/2018/08/img_1549.jpg?w=242" src="https://neilmadden.files.wordpress.com/2018/08/img_1549.jpg?w=840" alt="(2^B+1)/(2AS)" srcset="https://neilmadden.files.wordpress.com/2018/08/img_1549.jpg 242w, https://neilmadden.files.wordpress.com/2018/08/img_1549.jpg?w=150 150w" sizes="(max-width: 242px) 85vw, 242px"/></p>
<p>Let’s plug in some numbers and see what we get. But what are reasonable numbers? Well, for security we usually want to push the numbers <em>well beyond</em> what we think is actually possible to be really sure. So what is actually possible now?</p>
<p>When we consider how fast a well resourced attacker could guess a token, we can use the <a href="https://blockchain.info/charts/hash-rate?timespan=30days">Bitcoin hash rate</a> as a reasonable upper-bound approximation. A lot of people are investing a lot of time and money into generating random hashes, and we can view this as roughly equivalent to our attacker’s task. When I looked back in February (you can see how long my blog queue is!), the maximum rate was around 24293141000000000000 hashes per second, or around 2<sup>64</sup>.</p>
<p>That’s a pretty extreme number. It’s fairly unlikely that anyone would direct that amount of resource at breaking your site’s session tokens, and you can use rate limiting and other tactics. But it is worth considering the extremes. After all, this is clearly <em>possible</em> with current technology and will only improve over time.</p>
<p>How many tokens might we have in circulation at any time? Again, it is helpful to consider extremes. Let’s say your widely successful service issues access tokens to every IoT (Internet of Things) device on the planet, at a rate of 1 million tokens per second. As you have a deep instinctive trust in the security of these devices (what could go wrong?), you give each token a 2-year validity period. At a peak you will then have around 63 trillion (2<sup>46</sup>) tokens in circulation.</p>
<p>If we plug these figures into the equation from before, we can see how long our 122-bit UUID will hold out:</p>
<p><em>A</em> = 2<sup>64</sup></p>
<p><img data-attachment-id="3322" data-permalink="https://neilmadden.blog/2018/08/30/moving-away-from-uuids/img_1550/" data-orig-file="https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg" data-orig-size="469,182" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="img_1550" data-image-description="" data-image-caption="" data-medium-file="https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg?w=300" data-large-file="https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg?w=469" src="https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg?w=840" srcset="https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg 469w, https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg?w=150 150w, https://neilmadden.files.wordpress.com/2018/08/img_1550.jpg?w=300 300w" sizes="(max-width: 469px) 85vw, 469px"/></p>
<p>That comes out as … 2048 seconds. Or a bit less than 35 minutes. Oh.</p>
<p>OK, so those extreme numbers look pretty terrifying, but they are also quite extreme. The Bitcoin community spend enormous sums of money (certainly in the tens of millions of dollars) annually to produce that kind of output. Also, testing each guess most likely requires actually making a request to one of your servers, so you are quite likely to notice that level of traffic – say by your servers melting a hole through the bottom of your datacentre. If you think you are likely to attract this kind of attention then you might want to carefully consider which side of the <a href="https://www.schneier.com/blog/archives/2015/08/mickens_on_secu.html">Mossad/not-Mossad threat divide</a> you live on and maybe check your phone isn’t a piece of Uranium.</p>
<p>All this is to say that if you have deployed random UUIDs in production, <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Don%27t_Panic">don’t panic</a>! While I would recommend that you move to something better (see below) at some point, plugging more likely numbers into the equation should reassure you that you are unlikely to be at risk immediately. An attacker would still have to invest considerable time and money into launching such an attack.</p>
<h2>Other nits</h2>
<p>The borderline acceptable level of entropy in a random UUID is my main concern with them, but there are others too. In the standard string form, they are quite inefficient. The dash-separated hexadecimal format takes 36 characters to represent 16 bytes of data. That’s a 125% expansion, which is pretty terrible. Base64-encoding would instead use just 24 characters, and just 22 if we remove the padding, resulting in just 37.5% expansion.</p>
<p>Finally, a specific criticism of Java’s random UUID implementation is that internally it uses a single shared <code>SecureRandom</code> instance to generate the random bits. Depending on the backend configured, this can acquire a lock which can become heavily contended if you are generating large numbers of random tokens, especially if you are using the system blocking entropy source (don’t do that, use /dev/urandom). By rolling your own token generation you can use a thread-local or pool of SecureRandom instances to avoid such contention. (NB – the NativePRNG uses a shared static lock internally, so this doesn’t help in that case, but it also holds the lock for shorter critical sections so is less prone to the problem).</p>
<h2>What should we use instead?</h2>
<p>My recommendation is to use a 160-bit (20 byte) random value that is then <a href="https://en.wikipedia.org/wiki/Base64#URL_applications">URL-safe base64</a>-encoded. The URL-safe base64 variant can be used pretty much anywhere, and is reasonably compact. In Java:</p>
<pre>import java.security.SecureRandom;
import java.util.Base64;

public class SecureRandomString {
    private static final SecureRandom random = new SecureRandom();
    private static final Base64.Encoder encoder = Base64.getUrlEncoder().withoutPadding();

    public static String generate() {
        byte[] buffer = new byte[20];
        random.nextBytes(buffer);
        return encoder.encodeToString(buffer);
    }
}
</pre>
<p>This produces output values like the following:</p>
<pre>Xl3S2itovd5CDS7cKSNvml4_ODA</pre>
<p>This is both shorter than a UUID and also more secure having 160 bits of entropy. I can also make the SecureRandom into a ThreadLocal if I want.</p>
<p>So how long would it take our extreme attacker to find a 160-bit random token? Around <strong>17.9 million years</strong>. By tweaking the format of our tokens just a little we can move from worrying about attacker capabilities and resources to inner peace and happiness. It is so far beyond the realm of possible that we can stop worrying.</p>
<p>Why not go further? Why not 256 bits? That would push the attack costs into even more absurd territory. I find that 160 bits is a sweet spot of excellent security while still having a compact string representation.</p>


<div>
	<!-- .author-avatar -->

	<div>
		<h2><span>Author:</span> Neil Madden</h2>

		<p>
			Security Architect at ForgeRock. Experienced software engineer with a PhD in computer science. Interested in application security, applied cryptography, logic programming and intelligent agents.			<a href="https://neilmadden.blog/author/neilmadden/" rel="author">
				View all posts by Neil Madden			</a>
		</p><!-- .author-bio -->
	</div><!-- .author-description -->
</div><!-- .author-info -->
	</div></div>
  </body>
</html>
