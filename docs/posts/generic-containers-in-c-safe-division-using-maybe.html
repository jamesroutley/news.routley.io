<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://uecker.codeberg.page/2025-08-10.html">Original</a>
    <h1>Generic Containers in C: Safe Division Using Maybe</h1>
    
    <div id="readability-page-1" class="page"><div id="body">
	
	
	
        <h3>Generic Containers in C: Safe Division Using Maybe.</h3>
        <p max-width="150px">
	Martin Uecker, 2025-08-10</p>
	<pre><code>
	static maybe(int) divide(int a, int b)
	{
	    return (b != 0) ? maybe_just(int, a / b) : maybe_nothing(int);
	}
	</code></pre>
        <p max-width="150px">
	But careful, there is another error case not checked here! Which is it?
	</p>
	<pre><code>
	#define maybe(T) 		struct maybe_##T { bool ok; T value; }
	#define maybe_just(T, x)	(maybe(T)){ .value = (x), .ok = true }
	#define maybe_nothing(T)	(maybe(T)){ .value = (T){ }, .ok = false }
	</code></pre>
        <p max-width="150px">
	In the caller, we can then check whether the value exists or not.
	</p>
	<pre><code>
	int main()
	{
	    int d = 2; // 0

	    maybe(int) p = divide(6, d);

	    if (p.ok) {

	        printf(&#34;%d\n&#34;, p.value);

	    } else {

        	printf(&#34;division by zero\n&#34;);
		fflush(stdout);
	    }

	    return 0;
	}
	</code></pre>
        <p max-width="150px">
	Can we make this safer to use? In principle, we like to get some
	error if we try to use the value although it does not exist.  For this,
	we add a macro <code>maybe_value</code> which includes a check.
	</p>
	<pre><code>
	#define maybe_value(T, x) (*({ maybe(T) *_p = &amp;(x); _p-&gt;ok ? &amp;_p-&gt;value : (void*)0; }))
	</code></pre>
        <p max-width="150px">
	Here, instead of handling the error condition, I create an lvalue that
	points nowhere in case of an error because it then corresponds to
	<code>(*({ (void*)0; }))</code>, relying on the null sanitizer to transform
	it into a run-time trap for safety.
	</p>
	<pre><code>
	maybe(int) p = divide(6, d);

	if (p.ok) {

		printf(&#34;%d\n&#34;, maybe_value(p));
	}
	</code></pre>
        <p max-width="150px">
	You can find the full example here: <a href="https://godbolt.org/z/WWfGcvrc4">Godbolt</a>
	</p>
	<pre><code>
	maybe(int) unsafe_divide(int a, int b)
	{ 
		if (b == -1 &amp;&amp; a == INT_MAX)
			return maybe_nothing(int);

		return (b != 0) ? maybe_just(int, a / b) : maybe_nothing(int);
	}
	</code></pre>
        <p max-width="150px">
	So we created a safe function for integer division.  But can we be sure it
	is safe?  Maybe we made mistake.  Now, there are tools and a complete industry
	that may be able to help with this, but instead let&#39;s first simply look at the
	<a href="https://godbolt.org/z/1PKEnxMd7">assembly</a> generated by GCC when
	using the signed overflow sanitizer in trapping mode with
	<code>-O2 -fsanitize=signed-integer-overflow,integer-divide-by-zero -fsanitize-trap=undefined</code>.
	</p>
	<pre><code>
unsafe_divide:
        cmp     esi, -1
        sete    dl
        cmp     edi, 2147483647
        jne     .L2
        test    dl, dl
        je      .L2
.L4:
        xor     eax, eax
        ret
.L2:
        test    esi, esi
        je      .L4
        cmp     edi, -2147483648
        je      .L20
        mov     eax, edi
        cdq
        idiv    esi
        sal     rax, 32
        or      rax, 1
        ret
.L20:
        test    dl, dl
        jne     .L18
        mov     eax, edi
        cdq
        idiv    esi
        sal     rax, 32
        or      rax, 1
        ret
safe_divide.cold:
.L18:
        ud2 
	</code></pre>
        <p max-width="150px">
	This is strange, there is still a code path that ends in a trap in the form of
	the <code>ud2</code> instruction.  So either the optimizer was not able to see
	that this is not possible or our check was incorrect. In fact, I got it wrong and
	we have to check against <code>INT_MIN</code> and not <code>INT_MAX</code>. Here
	is the corrected and nicer version.
	</p>
	<pre><code>
	maybe(int) safe_divide(int a, int b) 
	{ 
		if (b == 0 || (b == -1 &amp;&amp; a == INT_MIN))
			return maybe_nothing(int);

		return maybe_just(int, a / b);
	}
	</code></pre>
        <p max-width="150px">
	The <a href="https://godbolt.org/z/PzPG1GjrT">assembly</a> looks different now
	and does not contain a code path leading to an <code>ud2</code> anymore.
	</p>
	<pre><code>
safe_divide:
        test    esi, esi
        je      .L2
        cmp     esi, -1
        jne     .L3
        cmp     edi, -2147483648
        je      .L2
.L3:
        mov     eax, edi
        cdq
        idiv    esi
        sal     rax, 32
        or      rax, 1
        ret
.L2:
        xor     eax, eax
        ret
	</code></pre>
        <p max-width="150px">
	The optimizer has proven that there is no overflow or division by zero left in our function!
	Does this also work for our complete <a href="https://godbolt.org/z/E6jf38M79">example</a>
	using <code>maybe</code>? It does! The optimizer has statically shown that there is no overflow
	and that all error cases are handled. Isn&#39;t this cool!  One could now turn off the sanitizer
	and still be sure that there is no overflow possible, as it was statically proven.
	</p>
    </div></div>
  </body>
</html>
