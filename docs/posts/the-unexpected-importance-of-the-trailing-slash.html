<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tookmund.com/2022/04/importance-of-the-trailing-slash">Original</a>
    <h1>The Unexpected Importance of the Trailing Slash</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>For many using Unix-derived systems today, we take for granted
that <code>/some/path</code> and <code>/some/path/</code> are the same.
Most shells will even add a trailing slash for you when you press the Tab key
after the name of a directory or a symbolic link to one.</p>

<p>However, many programs treat these two paths as subtly different in certain cases,
which I outline below, as all three have tripped me up
in various ways<sup id="fnref:threetrailing" role="doc-noteref"><a href="#fn:threetrailing" rel="footnote">1</a></sup>.</p>

<h2 id="posix-and-coreutils">POSIX and Coreutils</h2>

<p>Perhaps the trickiest use of the trailing slash in a distinguishing way is in
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13">POSIX</a><sup id="fnref:posixadditional" role="doc-noteref"><a href="#fn:posixadditional" rel="footnote">2</a></sup>
which states:</p>
<blockquote>
  <p>When the final component of a pathname is a symbolic link, the standard requires that a trailing <code>&lt;slash&gt;</code> causes the link to be followed. This is the behavior of historical implementations<sup id="fnref:historical" role="doc-noteref"><a href="#fn:historical" rel="footnote">3</a></sup>. For example, for <code>/a/b</code> and <code>/a/b/</code>, if <code>/a/b</code> is a symbolic link to a directory, then <code>/a/b</code> refers to the symbolic link, and <code>/a/b/</code> refers to the directory to which the symbolic link points.</p>
</blockquote>

<p>This leads to some unexpected behavior.
For example, if you have the following structure
of a directory <code>dir</code> containing a file <code>dirfile</code> with a symbolic link <code>link</code> pointing to <code>dir</code>.
(which will be used in all shell examples throughout this article):</p>
<div><div><pre><code>$ ls -lR
.:
total 4
drwxr-xr-x 2 jacob jacob 4096 Apr  3 00:00 dir
lrwxrwxrwx 1 jacob jacob    3 Apr  3 00:00 link -&gt; dir

./dir:
total 0
-rw-r--r-- 1 jacob jacob 0 Apr  3 00:12 dirfile
</code></pre></div></div>

<p>On Unixes such as MacOS, FreeBSD or Illumos<sup id="fnref:otherunixes" role="doc-noteref"><a href="#fn:otherunixes" rel="footnote">4</a></sup>,
you can move a directory through a symbolic link by using
a trailing slash:</p>
<div><div><pre><code>$ mv link/ otherdir
$ ls
link	otherdir
</code></pre></div></div>

<p>On Linux<sup id="fnref:renametrailing" role="doc-noteref"><a href="#fn:renametrailing" rel="footnote">5</a></sup>, <code>mv</code> will not “rename the indirectly referenced directory and not the symbolic link,”
when given a symbolic link with a trailing slash as the source to be renamed.
despite the <a href="https://www.gnu.org/software/coreutils/manual/html_node/Trailing-slashes.html">coreutils documentation’s claims to the contrary</a><sup id="fnref:fairtocoreutils" role="doc-noteref"><a href="#fn:fairtocoreutils" rel="footnote">6</a></sup>, instead failing with <code>Not a directory</code>:</p>

<div><div><pre><code>$ mv link/ other
mv: cannot move &#39;link/&#39; to &#39;other&#39;: Not a directory
$ mkdir otherdir
$ mv link/ otherdir
mv: cannot move &#39;link/&#39; to &#39;otherdir/link&#39;: Not a directory
$ mv link/ otherdir/
mv: cannot move &#39;link/&#39; to &#39;otherdir/link&#39;: Not a directory
$ mv link otherdirlink
$ ls -l otherdirlink
lrwxrwxrwx 1 jacob jacob 3 Apr  3 00:13 otherdirlink -&gt; dir
</code></pre></div></div>

<p>This is probably for the best, as it is very confusing behavior.
There is still one advantage the trailing slash has when using <code>mv</code>,
even on Linux, in that is it does not allow you to move a file to
a non-existent directory, or move a file that you expect to be a directory
that isn’t.</p>
<div><div><pre><code>$ mv dir/dirfile nonedir/
mv: cannot move &#39;dir/dirfile&#39; to &#39;nonedir/&#39;: Not a directory
$ touch otherfile
$ mv otherfile/ dir
mv: cannot stat &#39;otherfile/&#39;: Not a directory
$ mv otherfile dir
$ ls dir
dirfile  otherfile
</code></pre></div></div>

<p>However, Linux still exhibits some confusing behavior of its own, like
when you attempt to remove <code>link</code> recursively with a trailing slash:</p>


<p>Neither <code>link</code> nor <code>dir</code> are removed, but the contents of <code>dir</code> are removed:</p>


<p>Whereas if you remove the trailing slash, you just remove the symbolic link:</p>
<div><div><pre><code>$ rm -rvf link
removed &#39;link&#39;
</code></pre></div></div>

<p>While on MacOS, FreeBSD or Illumos<sup id="fnref:otherunixes:1" role="doc-noteref"><a href="#fn:otherunixes" rel="footnote">4</a></sup>, <code>rm</code> will also remove the
source directory:</p>
<div><div><pre><code>$ rm -rvf link
link/dirfile
link/
$ ls
link
</code></pre></div></div>

<p>The <code>find</code> and <code>ls</code> commands, in contrast, behave the same on all
three operating systems.</p>

<p>The <code>find</code> command only searches the contents of the
directory a symbolic link points to if the trailing slash is added:</p>
<div><div><pre><code>$ find link -name dirfile
$ find link/ -name dirfile
link/dirfile
</code></pre></div></div>

<p>The <code>ls</code> command acts similarly, showing information on just a symbolic link by
itself unless a trailing slash is added, at which point it shows the contents
of the directory that it links to:</p>
<div><div><pre><code>$ ls -l link
lrwxrwxrwx 1 jacob jacob 3 Apr  3 00:13 link -&gt; dir
$ ls -l link/
total 0
-rw-r--r-- 1 jacob jacob 0 Apr  3 00:13 dirfile
</code></pre></div></div>

<h2 id="rsync">rsync</h2>

<p>The command <code>rsync</code> handles a trailing slash in an unusual way that
trips up many new users.
The <a href="https://linux.die.net/man/1/rsync">rsync man page</a> notes:</p>
<blockquote>
  <p>You can think of a trailing <code>/</code> on a source as meaning “copy the contents of this directory” as opposed to “copy the directory
by name”, but in both cases the attributes of the containing directory are transferred to the containing  directory  on  the
destination.</p>
</blockquote>

<p>That is to say, if we had two folders <code>a</code> and <code>b</code> each of which contained some files:</p>
<div><div><pre><code>$ ls -R .
.:
a  b

./a:
a1  a2

./b:
b1  b2

</code></pre></div></div>

<p>Running <code>rsync -av a b</code> moves the entire directory <code>a</code> to directory <code>b</code>:</p>
<div><div><pre><code>$ rsync -av a b
sending incremental file list
a/
a/a1
a/a2

sent 181 bytes  received 58 bytes  478.00 bytes/sec
total size is 0  speedup is 0.00
$ ls -R b
b:
a  b1  b2

b/a:
a1  a2
</code></pre></div></div>
<p>While running <code>rsync -av a/ b</code> moves the contents of directory <code>a</code> to <code>b</code>:</p>
<div><div><pre><code>$ rsync -av a/ b
sending incremental file list
./
a1
a2

sent 170 bytes  received 57 bytes  454.00 bytes/sec
total size is 0  speedup is 0.00
$ ls b
a1  a2	b1  b2
</code></pre></div></div>

<h2 id="dockerfile-copy">Dockerfile COPY</h2>
<p>The Dockerfile <code>COPY</code> command also cares about the presence of the trailing slash,
using it to determine whether the destination should be considered a file or directory.</p>

<p>The <a href="https://docs.docker.com/engine/reference/builder/#copy">Docker documentation</a>
explains the rules of the command thusly:</p>
<blockquote>
  <p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p>
</blockquote>

<p>…</p>

<blockquote>
  <p>If <code>&lt;src&gt;</code> is a directory, the entire contents of the directory are copied, including filesystem metadata.</p>

  <p>Note: The directory itself is not copied, just its contents.</p>

  <p>If <code>&lt;src&gt;</code> is any other kind of file, it is copied individually along with its metadata. In this case, if <code>&lt;dest&gt;</code> ends with a trailing slash <code>/</code>, it will be considered a directory and the contents of <code>&lt;src&gt;</code> will be written at <code>&lt;dest&gt;/base(&lt;src&gt;)</code>.</p>

  <p>If multiple <code>&lt;src&gt;</code> resources are specified, either directly or due to the use of a wildcard, then <code>&lt;dest&gt;</code> must be a directory, and it must end with a slash <code>/</code>.</p>

  <p>If <code>&lt;dest&gt;</code> does not end with a trailing slash, it will be considered a regular file and the contents of <code>&lt;src&gt;</code> will be written at <code>&lt;dest&gt;</code>.</p>

  <p>If <code>&lt;dest&gt;</code> doesn’t exist, it is created along with all missing directories in its path.</p>
</blockquote>

<p>This means if you had a <code>COPY</code> command that moved <code>file</code> to a nonexistent <code>containerfile</code>
without the slash, it would create <code>containerfile</code> as a file with the contents of <code>file</code>.</p>
<div><div><pre><code>COPY file /containerfile
container$ stat -c %F containerfile
regular empty file
</code></pre></div></div>
<p>Whereas if you add a trailing slash, then <code>file</code> will be added as a file under
the new directory <code>containerdir</code>:</p>
<div><div><pre><code>COPY file /containerdir/
container$ stat -c %F containerdir
directory
</code></pre></div></div>

<p>Interestingly, at no point can you copy a directory completely, only its contents.
Thus if you wanted to make a directory in the new container, you need to
specify its name in both the source and the destination:</p>
<div><div><pre><code>COPY dir /dirincontainer
container$ stat -c %F /dirincontainer
directory
</code></pre></div></div>

<p>Dockerfiles do also make good use of the trailing slash to ensure they’re
doing what you mean by requiring a trailing slash on the destination of
multiple files:</p>
<div><div><pre><code>COPY file otherfile /othercontainerdir
</code></pre></div></div>
<p>results in the following error:</p>
<div><div><pre><code>When using COPY with more than one source file, the destination must be a directory and end with a /
</code></pre></div></div>


  </div></div>
  </body>
</html>
