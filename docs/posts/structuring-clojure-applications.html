<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yogthos.net/posts/2022-12-18-StructuringClojureApplications.html">Original</a>
    <h1>Structuring Clojure Applications</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <p>This post will take a look at a strategy for structuring Clojure applications that I&#39;ve found useful in my projects.</p><p>While the idea of writing applications in a pure functional style is appealing, it&#39;s not always clear how to separate side effects from pure compuation in practice. Variations of <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a> approach are often suggested as a way to accomplish this goal. This style dictates that IO should be handled in the outer layer that wraps pure computation core of the application.</p><p>While this notion is appealing, it only works in cases where the totality of the data that will be operated on is known up front. Unfortunately, it&#39;s impossible to know ahead of time what data will be needed in most real world applications. In many cases additional data needs to load conditionally based on the type of input and the current state of processing.</p><p>What we can do, however, is break up our application into small components that can be reasoned about in isolation. Such components can then be composed together to accomplish tasks of increased complexity. I like to think of this as a Lego model of software development. Each component can be viewed as a Lego block, and we can compose these Lego block in many different ways as we solve different problems.</p><p>The problem being solved can be expressed in terms of a workflow represented by a graph where the nodes compute the state, and the edges represent transitions between the states. Each time we enter a node in this graph, we look at the input, decide what additional data we may need, run the computation, and transition to the next state. Each node in the graph is a Lego block that accomplishes a particular task. These nodes are then connected by a layer of code governs the data flow.</p><p>One approach to implement the above architecture is to use a map to describe overall state, then pass it through multimethods that each operate on a particular type of state and produce a new one. Each multimethod takes the state map as a parameter, does some operations on it, and then returns a new map that gets passed to the next multimethod. If you&#39;re thinking that this sounds a like a state machine then you&#39;re very much correct.</p><h3 id="implemention">Implemention</h3><p>Let&#39;s take a look at a concrete example of what this looks like in practice. Say we have a workflow where one user would like to send an email money transfer to another user using our system. There are a few cases we might want to handle here.</p><p>There&#39;s the happy path scenario where both users are in the system. In this case we simply withdraw the amount from the payor account and deposit it into the payee account.</p><p>Another scenario could be that the payor does not have the sufficient funds to do the transaction. In this case we may want to suspend the transaction until the user adds more funds.</p><p>Finally, the user receiving the funds may not be in the system, and they need to be invited before they can accept the transfer.</p><p>We can start by defining a few helper functions that represent interactions with external resources.</p><pre><code>(defn persist [store {:keys [id] :as state}]
  (swap! store assoc-in [:workflows id] state))

(defn query [store email]
  (get-in @store [:users email]))

(defn load-state [store workflow-id]
  (get-in @store [:workflows workflow-id]))

(defn send-invite [email]
  (println &#34;sending invite to&#34; email))

(defn notify-user [email message]
  (println &#34;notifying&#34; email message))

(defn send-transfer [store from to amount]
  (println &#34;transfering from&#34; from &#34;to&#34; to amount)
  (swap! store
         #(-&gt; %
             (update-in [:users from :funds] - amount)
             (update-in [:users to :funds] + amount))))
</code></pre><p>Next, we&#39;ll create a map to represent the initial state of the workfow.</p><pre><code>{:id &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;
 :from   {:email &#34;bob@foo.bar&#34;}
 :to     {:email &#34;alice@bar.baz&#34;}
 :amount 200
 :action :transfer}
</code></pre><p>The map will contain a unique id, some initial data that represents user input, and an <code>:action</code> key indicating what action should be applied to the current state of the workflow.</p><p>Let&#39;s define a multimethod that will dispatch the approprate action handler based on the value of the <code>:action</code> key. The multimethod will accept a map of resources as the first argument. The resources represent any code that deals with IO side effects such as database connections. The map representing the state of the workflow will be passed in as the second argument.  </p><pre><code>(defmulti handle-action (fn [_resources {:keys [action]}] action))
</code></pre><p>We can now define a handler for the <code>:transfer</code> operation. This multimethod will hydrate some additional data about the users from the datastore, take the appropriate action, and return a new state with the updated <code>:action</code> key to indicate the next step in the workflow.</p><pre><code>(defmethod handle-action :transfer [{:keys [store]} {:keys [from to amount] :as state}]
   (let [from-info (query store (:email from))
         to-info   (query store (:email to))
         available-funds (:funds from-info)
         state     (-&gt; state
                       (update :from merge from-info)
                       (update :to merge to-info))] 
     (cond 
       (&gt;= available-funds amount)
       (do
         (send-transfer store (:email from) (:email to) amount)
         (assoc state :action :done))
       (&lt; available-funds amount)
       (assoc state :action :notify-missing-funds)
       (nil? to-info)
       (assoc state :action :invite))))
</code></pre><p>Let&#39;s add the handlers for <code>:invite</code> and <code>:notify-missing-funds</code> actions.</p><pre><code>(defmethod handle-action :notify-missing-funds [{:keys [store]} {:keys [from] :as state}] 
  (notify-user (:email from) &#34;missing funds&#34;)
  (persist store (assoc state :action :transfer))
  {:action :await})

(defmethod handle-action :invite [{:keys [store]} {:keys [to] :as state}]
  (send-invite to)
  (persist store (assoc state :action :transfer))
  {:action :await})
</code></pre><p>Note that <code>:invite</code> and <code>:notify-missing-funds</code> actions persist the state and return the <code>:await</code> action when they complete. We&#39;ll use this behavior to indicate that the workflow is blocked on an external action and needs to be suspended.</p><p>Finally, we&#39;ll add a function that executes the state machine. This function will accept a map containing the resources along with a workflow id. It will load the current state and execute it by dispatching the multimethod defined above.</p><pre><code>(defn run-workflow
  [{:keys [store] :as resources} workflow-id]
  (loop [state (load-state store workflow-id)] 
    (condp = (-&gt; state :action)
      :done state
      :await :workflow-suspended
      (let [state (handle-action resources state)]
        (recur state)))))
</code></pre><p>For simplicity&#39;s sake let&#39;s use an atom as our mock data store.</p><pre><code>(def store (atom {:workflows {&#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;
                              {:id &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;
                               :from   {:email &#34;bob@foo.bar&#34;}
                               :to     {:email &#34;alice@bar.baz&#34;}
                               :amount 200
                               :action :transfer}}
                  :users {&#34;bob@foo.bar&#34; {:funds 100}
                          &#34;alice@bar.baz&#34; {:funds 10}}}))
</code></pre><p>We can now try running this workflow in the REPL. If we run it with the initial state, then we should see that the workflow was suspended because there were insufficient funds to transfer.</p><pre><code>=&gt; (run-workflow {:store store} &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;)

notifying bob@foo.bar missing funds
:workflow-suspended
</code></pre><p>The workflow tries to notify the user of the missing funds and returns. Let&#39;s add more funds to the account trying to send the transfer.</p><pre><code>=&gt; (swap! store assoc-in [:users &#34;bob@foo.bar&#34; :funds] 300)
</code></pre><p>The workflow restarts where it left off and completes the transfer successfully.</p><pre><code>=&gt; (run-workflow {:store store} &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;)

transfering from bob@foo.bar to alice@bar.baz 200
{:id &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;,
 :from {:email &#34;bob@foo.bar&#34;, :funds 300},
 :to {:email &#34;alice@bar.baz&#34;, :funds 10},
 :amount 200,
 :action :done}
</code></pre><h3 id="formalizing_side_effects">Formalizing Side Effects</h3><p>We can make one futher improvement over the implementation above by formalizing resource providers using protocols. Doing so will make it clear what the external dependecies are and facilitate mocking. Let&#39;s create <code>Notify</code> and <code>DataStore</code> protocols that look as follows.</p><pre><code>(defprotocol Notify
  (send-invite [email])
  (notify-user [email message]))

(defprotocol DataStore
  (persist [_ state])
  (query [_ email])
  (add-funds [_ email amount])
  (load-state [_ workflow-id])
  (send-transfer [_ from to amount]))
</code></pre><p>Next, let&#39;s add a couple of records that implement these protocols.</p><pre><code>(defrecord MockNotify []
  Notify
  (send-invite [_ email]
    (println &#34;sending invite to&#34; email))
  (notify-user [_ email message]
    (println &#34;notifying&#34; email message)))

(defrecord AtomDataStore [store]
  DataStore
  (persist [_ {:keys [id] :as state}]
    (swap! store assoc-in [:workflows id] state))
  (query [_  email]
    (get-in @store [:users email]))
  (add-funds [_ email amount]
    (swap! store assoc-in [:users &#34;bob@foo.bar&#34; :funds] 300))
  (load-state [_ workflow-id]
    (println &#34;hi&#34;)
    (get-in @store [:workflows workflow-id]))
  (send-transfer [_ from to amount]
    (println &#34;transfering from&#34; from &#34;to&#34; to amount)
    (swap! store
           #(-&gt; %
                (update-in [:users from :funds] - amount)
                (update-in [:users to :funds] + amount)))))
</code></pre><p>We&#39;ll also need to modify our multimethods to use <code>Notify</code> protocol instead of simply calling the functions we defined earlier.</p><pre><code>(defmethod handle-action :notify-missing-funds [{:keys [store notify]} {:keys [from] :as state}]
  (notify-user notify (:email from) &#34;missing funds&#34;)
  (persist store (assoc state :action :transfer))
  {:action :await})

(defmethod handle-action :invite [{:keys [store notify]} {:keys [to] :as state}]
  (send-invite notify to)
  (persist store (assoc state :action :transfer))
  {:action :await})
</code></pre><p>Finally, we&#39;ll instantiate the records and passing them to our <code>run-workflow</code> function.</p><pre><code>(def store (-&gt;AtomDataStore (atom {:workflows {&#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;
                                                {:id &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;
                                                :from   {:email &#34;bob@foo.bar&#34;}
                                                :to     {:email &#34;alice@bar.baz&#34;}
                                                :amount 200
                                                :action :transfer}}
                                    :users {&#34;bob@foo.bar&#34; {:funds 100}
                                            &#34;alice@bar.baz&#34; {:funds 10}}})))
(def notify (-&gt;MockNotify))

(run-workflow {:store store
               :notify notify} 
              &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;)

(add-funds store &#34;bob@foo.bar&#34; 100)

(run-workflow {:store store
               :notify notify} 
              &#34;33a19b1f-c7d1-45d8-9864-0ea17e01a26d&#34;)
</code></pre><h3 id="discussion">Discussion</h3><p>There are several aspects of the above approach that I&#39;ve found to be particularly useful when building applications.</p><p>Each multimethod can be treated as a small program that can be reasoned about and tested independently. These multimethods can easily be structured using Clean Architecture style keepng IO at the edges.</p><p>Passing resources in as an explicit parameter allows decoupling IO from computation. This design lends itself well to testing since resources, such as the data store, are passed in explicitly. We can pass in a map of mock resources when running tests without any changes to the rest of the code. In fact, we can start developing against mock resources and ensure that the workflow logic works as intended before having to worry about connecting to databases or other systems.</p><p>Using a map to track the state of the execution makes it easy to inspect it. We can log this map to see what operation we&#39;re doing, what the data looks like, and so on. The state can also be easily serialized, allowing us to suspend and resume computation as needed. This is particularly useful in cases when the workflow needs to be suspended pending some external action as we saw earlier.</p><p>This design also plays well with Integrant which can be used to manage the system map containing stateful resources.</p><p>Most importantly, this type of architecture creates reusable components without implicit coupling. Each multimethod can be used indepenently of the others, and composed into different workflows. This gives us composable Lego blocks that we can use to build larger structures.</p>
</div></div>
  </body>
</html>
