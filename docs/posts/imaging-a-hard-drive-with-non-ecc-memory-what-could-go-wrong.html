<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.robertelder.org/importance-of-ecc-memory/">Original</a>
    <h1>Imaging a Hard Drive with Non-ECC Memory – What Could Go Wrong?</h1>
    
    <div id="readability-page-1" class="page"><div>
						<div>


<h5>2022-12-30 - By Robert Elder</h5>

<p>     I recently came home to visit with family, but right now as I write this, it&#39;s 1:00am and I&#39;m running memtest86+ by myself in the basement.</p>

<p>     The purpose of this article, is to provide a real-life case study to show why ECC memory is not a waste of money, and to provide a detailed account of how much time you can waste when bit flips become a part of you daily computing life.  Having said that, the previous sentence is a bit of lie because this article is actually about more than that:  Specifically, I will discuss various learnings that I had in the process of trying to image the hard drive of an old failing family computer, and the process of trying to restore the computer to fully working order.  These learnings include:</p>

<ul>
<li>Is the process of diagnosing failing RAM very fast and easy?  Nope!</li>
<li>Should you use &#39;ddrescue&#39; or &#39;dd&#39; to image a failing hard drive?  The answer depends on whether your memory is failing, and it may surprise you!</li>
<li>So, you just imaged a drive with &#39;dd&#39;, but the hash checksum doesn&#39;t match?  Pay attention to copy block sizes!</li>
<li>Does the cheap new DDR3 RAM from eBay or NewEgg work in old motherboards?  Nope, but sometimes yes.</li>
<li>Does increased heat increase the likelihood of memory errors?  I think it does.</li>
</ul>

<iframe src="https://www.youtube.com/embed/0itrM7t4l34" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>     Speaking of wasting time, I wasted huge amount of time on the analysis described in this article (4-6 hours per 500GB hard drive md5 checksum and ~12 hours+ per memtest run).  This is probably the reason that you don&#39;t read too many articles like this one.  It&#39;s not because bit flips are rare, but rather because most people who encounter them are smart enough to declare &#34;It was probably just a ghost in my program!&#34; and reboot the machine instead of investigating the issue and then wasting even more time writing a blog post to document the issue in excruciating detail.</p>



<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/0-hard-drive_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/0-hard-drive_600x338_q70.jpeg" alt="Hard Drive" width="600" height="338"/></a></p>

<p>     My overall goal was to back up the data from an old family computer that was experiencing some &#39;problems&#39;.  This was actually a computer that I personally put together back in the year 2008.  This would make it (2022 - 2008) = 14 years old!  I found it fairly impressive that it was still running, despite the reports of occasional unexplained reboots.</p>

<p>     Backing up an old computer...  Sounds like a simple task, right?  Well, allow me to make it more complicated for you:</p>

<p>     Most people would probably just use the simplest backup approach of copying parts of the filesystem to an external flash drive to be adequate, but in my case I wanted to approach things from a thorough data recovery perspective.  Therefore, I decided to image the entire hard disk to guarantee a perfect preservation of all data.  This computer was old, so I figured it would be reasonable to assume that the hard drive might be already starting to fail.</p>

<p>     I decided to use &#39;ddrescue&#39; to image the drive since I know that &#39;ddrescue&#39; maintains awareness of disk read errors.  This is useful because it allows you to confirm if there are indeed problems reading from the drive, and the extent of how bad the drive health is.  &#39;ddrescue&#39; also attempts to carefully read the disk in a way that should preserve as much data as possible even when the drive is mechanically failing.  You can even go back and try to re-try sectors that failed to read properly the first time.</p>

<p>     And so, I changed the boot order of the machine, then booted into a live install of Ubuntu 20 with an attached USB disk to write the image to.  I installed ddrescue, and ran it using the following command:</p>

<p><code><pre>sudo ddrescue -vv -d -r0 /dev/sdb hd-image-ddrescued.img progress.log
</pre></code></p><p>     Fortunately, ddrescue completed the imaging process without error and exited normally.  Immediately after ddrescue finished, I decided to compute and md5 checksum of the raw disk device itself to compare it with the checksum of the image that I had just obtained:</p>

<p><code><pre>md5sum /dev/sdb
</pre></code></p><p>     The resulting checksum value was the following:</p>

<p><code><pre>3d3085c04c3b148f6abb08ceb4b3d6e0  /dev/sdb
</pre></code></p><p>     I also made sure to use the &#39;sync&#39; command and properly unmount the external USB storage (where my copied image was located):</p>

<p><code><pre>sync
</pre></code></p><p>     By using the &#39;sync&#39; command, I can ensure that any cached writes of the copied disk image are committed to my external hard drive before I try to unmount and remove it.</p>



<p>     On another, much faster computer, I did a checksum to verify the saved disk image, and to my surprise I got the following:</p>

<p><code><pre>fc0e287bd2fc9f09c8f48a8ab675294f  hd-image-ddrescued.img
</pre></code></p><p>     That wasn&#39;t what I expected (I was expecting it to be 3d3085c04c3b148f6abb08ceb4b3d6e0).  I started to wonder if I had done something wrong, or maybe I had some incorrect assumptions about running md5sum directly on the block device, or maybe I didn&#39;t understand what result ddrescue was supposed to produce?</p>

<p>     I decided to reboot the computer and, again, boot into the Ubuntu live system.  Throughout this process, I was careful to never mount or boot into the disk that I was imaging to avoid accidentially writing to it.</p>

<p>     This time I decided to use the &#39;dd&#39; command to clone the drive.  If you don&#39;t specify a block size to &#39;dd&#39;, it will use a value of 512 bytes.  If you try this for yourself, you&#39;ll probably discover that the copy progress of &#39;dd&#39; is quite slow with small block size like 512 bytes.  Now, if you do a bit of googling, you&#39;ll find that you can explicitly set the block size to a larger number to get a copy speed.  Therefore, I chose a block size of &#39;64K&#39;:</p>

<p><code><pre>dd if=/dev/sdb of=image-dd-cloned.img bs=64K conv=noerror,sync
</pre></code></p><p>     After I finished making the image with dd, I then ran another checksum on the block device to make sure that its md5sum had not changed:</p>

<p><code><pre>md5sum /dev/sdb
3d3085c04c3b148f6abb08ceb4b3d6e0  /dev/sdb
</pre></code></p><p>     This is the same value that I got the first time I calculated the checksum of this block device.  This was re-assuring since it meant that the raw data on the disk had not changed even after rebooting the machine.</p>



<p>     Next, I ran an md5sum of the disk image that I just created with dd:</p>

<p><code><pre>md5sum image-dd-cloned.img
a974938dcfb9eb25121d33cdf673330f  image-dd-cloned.img
</pre></code></p><p>     What?!?  That&#39;s now 3 different hashes, and none of them match!  Am I losing my mind?</p>

<p>     Then, I started to look a bit more closely at the file/device sizes:</p>

<p>     fdisk shows the following:</p>

<p><code><pre>Disk /dev/sdb: 465.78 GiB, 500107862016 bytes, 976773168 sectors
Disk model: Hitachi HDP72505
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x07650765

Device     Boot  Start       End   Sectors   Size Id Type
/dev/sdb1  *      2048    206847    204800   100M  7 HPFS/NTFS/exFAT
/dev/sdb2       206848 976771071 976564224 465.7G  7 HPFS/NTFS/exFAT
</pre></code></p><p>     and lsblk -b shows this:</p>

<p><code><pre>NAME   MAJ:MIN RM          SIZE RO TYPE MOUNTPOINT
sdb      8:0    0  500107862016  0 disk
├─sdb1   8:1    0     104857600  0 part
└─sdb2   8:2    0  500000882688  0 part
</pre></code></p>

<p>     So at least these two commands agree that the size of this drive is 500107862016 bytes.  Now, how large are the disk images that I created?</p>

<p><code><pre>ls -latr *
-rw-r--r--  1 robert robert 500107862016 Jul 22 19:47 hd-image-ddrescued.img
-rw-r--r--  1 robert robert 500107902976 Jul 23 20:09 image-dd-cloned.img
</pre></code></p><p>     Ok, that explains why the hash of the image that was copied using &#39;dd&#39; is different.  The &#39;dd&#39;ed image size is larger than the size of the block device!  There is no way the checksums would match (ok sure, it could if there was a hash collision, but this is not an article on cryptographically secure hashes).</p>

<p>     So why is the image size wrong when creating the disk image using &#39;dd&#39;, but not &#39;ddrescue&#39;?  Well, here&#39;s the first interesting take-away from this article:</p>

<p>     It has everything to do with the block size that I supplied to the &#39;dd&#39; command:  The block size of the drive itself is 512 bytes, and its capacity is 500107862016, so 500107862016 / 512 = exactly 976773168 blocks.  <strong> However, when running &#39;dd&#39;, I didn&#39;t use the default block size 512 because that&#39;s too slow.  Instead, I specified a block size of &#39;64K&#39; or 1024 * 64 = 65536 bytes.  If you calculate 500107862016 / 65536 you get 7631040.375.  Last time I checked, you can&#39;t perform 0.375 of a hard disk read, so it&#39;s reasonable to assume that this gets rounded up to 1.0 hard disk reads, or &#39;7631041 block reads of size 65536&#39;.   But guess what?  7631041 * 65536 = 500107902976 which is <em>exactly</em> the size of the image that I got with the &#39;dd&#39; command! </strong> I checked the contents of this &#39;extra&#39; data, and it simply contains zeros.  The (somewhat presumptuous) conclusion that I will draw from this single experience is as follows:  If the total size of the block device is not an integer multiple of the block size that you specify to &#39;dd&#39;, then you can expect to get zero-padding on the end of your image.  In this case, your important data from the drive is not lost, but this result could lead to confusing results if you ever try to copy the image back (and find that it doesn&#39;t fit), or if you actually verify your hash checksums like I do.  (<strong>Note</strong>: After publishing this video/article, I got an email providing more insight on this issue, and it likely has to do with the flags that I supplied to dd: <a href="#2022-12-29-update">See 2022-12-29 Note</a>).</p>

<p>     So, now let&#39;s pretend the end of the image past byte 500107862016 does not exist and re-compute the hash:</p>

<p><code><pre>$ head -c 500107862016 image-dd-cloned.img | md5sum
3d3085c04c3b148f6abb08ceb4b3d6e0  -
</pre></code></p><p>     Success!  That&#39;s exactly the hash value that I got from directly hashing the block device!</p>



<p>     Ok, we&#39;ve made some progress getting the dd image checksum to match, now let&#39;s look into why the ddrescue one didn&#39;t produce the right hash value.  It&#39;s probably another file size/block padding issue, right?</p>

<p>     &#39;ddrescue&#39; seems to have produced an image that is exactly the right size, so extra padding at the end can&#39;t be the issue.  Furthermore, the difference can&#39;t be due to an unexpected write/modification, because the image created with the dd command was taken later, and the md5 checksum was able to match then!  Maybe I&#39;ve misunderstood something fundamental about how ddrescue works and constructs images?</p>

<p>     Let&#39;s see what the differences are with this &#39;cmp&#39; command:</p>

<p><code><pre>cmp -lb hd-image-ddrescued.img &lt;(head -c 500107862016 image-dd-cloned.img)
</pre></code></p><p>     I expected to see some huge section changed in the ddrescue image, but instead I got the following:</p>

<p><code><pre> 52185498315 107 G    307 M-G
 73775329995 177 ^?   377 M-^?
 86801068747 147 g    347 M-g
181705323211 107 G    307 M-G
186007311051  66 6    266 M-6
207345296075  55 -    255 M--
235067732683  76 &gt;    276 M-&gt;
290357666507  37 ^_   237 M-^_
300967236299 106 F    306 M-F
305192092363 147 g    347 M-g
313683256011 104 D    304 M-D
322162291403 167 w    367 M-w
355933934283  56 .    256 M-.
383209988811 124 T    324 M-T
</pre></code></p><p>     It&#39;s worth explaining the above output a bit to make sure it&#39;s clear, so if we focus on this line:</p>

<p><code><pre> 52185498315 107 G    307 M-G
</pre></code></p><p>     The above line means that at 1-based byte offset 52185498315 in the file &#39;hd-image-ddrescued.img&#39;, the &#39;cmp&#39; command saw a byte that can be represented as octal 107 (hex value 0x47, text value G), but in the other file (or pipe in this case) &#39;head -c 500107862016 image-dd-cloned.img&#39;, it saw a byte with octal number 307 (hex value 0xC7 represented as M-G).</p>

<p>     To be even more clear, here is a simple example of using the cmp command to compare the bytes &#39;a&#39; and &#39;b&#39;:</p>

<p><code><pre>cmp -lb &lt;(echo -n &#39;a&#39;) &lt;(echo -n &#39;b&#39;)
</pre></code></p><p>     and the corresponding output from the above command:</p>

<p><code><pre>1 141 a    142 b
</pre></code></p><p>     Now that you know how to read the output of the commands above, do you notice something in common with the differences in these bytes?  Let&#39;s put the output from above in a file called &#39;differences.txt&#39; and try to format the output a bit differently with this python script:</p>

<p><code><pre><span>import</span> re
<span>import</span> sys

<span>for</span> header <span>in</span> [<span>&#39;</span><span>Byte Offset</span><span>&#39;</span>, <span>&#39;</span><span>Octal Byte #1</span><span>&#39;</span>, <span>&#39;</span><span>Byte #1</span><span>&#39;</span>, <span>&#39;</span><span>Octal Byte #2</span><span>&#39;</span>, <span>&#39;</span><span>Byte #2</span><span>&#39;</span>, <span>&#39;</span><span>Binary Byte #1</span><span>&#39;</span>, <span>&#39;</span><span>Binary Byte #2</span><span>&#39;</span>, <span>&#39;</span><span>Byte #1 XOR Byte #2</span><span>&#39;</span>]:
    sys.stdout.write(<span>&#34;</span><span>{:&lt;20}</span><span>&#34;</span>.format(header))
sys.stdout.write(<span>&#34;</span><span>\n</span><span>&#34;</span>)

<span>for</span> line <span>in</span> sys.stdin:
    parts = re.split(<span>&#34;</span><span>\\</span><span>s+</span><span>&#34;</span>, line.strip())
    offset_number = <span>int</span>(parts[<span>0</span>])
    octal_a = <span>int</span>(parts[<span>1</span>], <span>8</span>)  
    octal_b = <span>int</span>(parts[<span>3</span>], <span>8</span>)  
    parts.append(<span>&#39;</span><span>{0:08b}</span><span>&#39;</span>.format(octal_a))  
    parts.append(<span>&#39;</span><span>{0:08b}</span><span>&#39;</span>.format(octal_b))  
    parts.append(<span>&#39;</span><span>{0:08b}</span><span>&#39;</span>.format(octal_a ^ octal_b))  
    <span>for</span> part <span>in</span> parts:
        sys.stdout.write(<span>&#34;</span><span>{:&lt;20}</span><span>&#34;</span>.format(part))
    sys.stdout.write(<span>&#34;</span><span>\n</span><span>&#34;</span>)
</pre></code></p><p>     After putting the above script into the file &#39;parse_differences.py&#39;, and running it like this:</p>

<p><code><pre><span>cat</span> differences.txt | python3 parse_differences.py
</pre></code></p><p>     The output is as follows:</p>


<p><code><pre>Byte Offset         Octal Byte #1       Byte #1             Octal Byte #2       Byte #2             Binary Byte #1      Binary Byte #2      Byte #1 XOR Byte #2
52185498315         107                 G                   307                 M-G                 01000111            11000111            10000000
73775329995         177                 ^?                  377                 M-^?                01111111            11111111            10000000
86801068747         147                 g                   347                 M-g                 01100111            11100111            10000000
181705323211        107                 G                   307                 M-G                 01000111            11000111            10000000
186007311051        66                  6                   266                 M-6                 00110110            10110110            10000000
207345296075        55                  -                   255                 M--                 00101101            10101101            10000000
235067732683        76                  &gt;                   276                 M-&gt;                 00111110            10111110            10000000
290357666507        37                  ^_                  237                 M-^_                00011111            10011111            10000000
300967236299        106                 F                   306                 M-F                 01000110            11000110            10000000
305192092363        147                 g                   347                 M-g                 01100111            11100111            10000000
313683256011        104                 D                   304                 M-D                 01000100            11000100            10000000
322162291403        167                 w                   367                 M-w                 01110111            11110111            10000000
355933934283        56                  .                   256                 M-.                 00101110            10101110            10000000
383209988811        124                 T                   324                 M-T                 01010100            11010100            10000000
</pre></code></p><p>     Pay special attention to the column &#39;Byte #1 XOR Byte #2&#39;.  This columns shows the bitwise exclusive OR between each byte that had a difference in the &#39;ddrescue&#39; image when compared against the image that was created with &#39;dd&#39; (at least the first 500107862016 bytes of this image).</p>

<p>     The exclusive OR shows us a &#39;1&#39; wherever the bits have &#39;flipped&#39;.  This makes it incredibly obvious that the only difference in the &#39;ddrescue&#39; image is that these 14 individual bytes in the 500GB image file where the <em>exact same</em> high bit of our byte has flipped to 1 when it was supposed to 0.  <strong><em>This is why the md5 checksum of the ddrescue image does not match the md5sum of the raw block device, or the one created using &#39;dd&#39;!</em></strong></p>



<p>     At this point, it&#39;s reasonable to suspect memory errors.  Let&#39;s reboot into memtest86 and test out the memory:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/2-memtest-failure_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/2-memtest-failure_600x338_q70.jpeg" alt="Memtest Failure" width="600" height="338"/></a></p>

<p>     Yup, that&#39;s a memory error!</p>

<p>     But we&#39;re not done yet.  We can go even deeper.</p>

<p>     The failing address in the image is 0x000784512c8, or 2017792712 in decimal.  The &#39;Err-Bits&#39; was reported by memtest as 0x00800000&#39;.  This value of &#39;0x00800000&#39; represents a mask that shows exactly which bits of memory at address 0x000784512c8 contributed to the error.  Since this machine uses little-endian, the address 0x000784512c8 points to the byte on the right-most end of the mask &#39;0x00800000&#39;.  If we split up this machine word into bytes, we get Byte #3: <strong>0x00</strong> Byte #2: <strong>0x80</strong> Byte #1: <strong>0x00</strong> Byte #0: <strong>0x00</strong>. and counting upward, one byte at a time, the exact byte where the single-bit error is located is in Byte #2: <strong>0x80</strong>.</p>

<p>     Therefore, the exact address of the individual byte where there error occurred was at memory address 0x000784512c8 + 2, which is 0x000784512ca, or 2017792714 in decimal.</p>

<p>     Now, if we think back to our list of &#39;Byte Offsets&#39; from the output of the &#39;cmp&#39; command, we can look for even more patterns even though these might seem like random numbers at first:</p>

<p><code><pre>Byte Offset
52185498315
73775329995
86801068747
181705323211
186007311051
207345296075
235067732683
290357666507
300967236299
305192092363
313683256011
322162291403
355933934283
383209988811
</pre></code></p><p>     Remember, that the above numbers are byte offsets that tell us the <em>number of bytes into the hard drive image</em> that when the &#39;cmp&#39; command found a difference.  These are <em>not</em> addresses in RAM, so they won&#39;t have anything to do with the address of our failing bit in memory...  Or do they?</p>

<p>     The word on the street is that information is read into the computer&#39;s memory in chunks called &#39;pages&#39;.  There&#39;s also talk about how these so-called &#39;pages&#39; are typically 4K or 4096 bytes in size.  Let&#39;s modify our previous python script to show us the &#39;byte offset into the file modulo 4096&#39; (with a -1 adjustment to account for 1-based indexing):</p>

<p><code><pre><span>import</span> re
<span>import</span> sys

<span>for</span> header <span>in</span> [<span>&#39;</span><span>(Offset -1) % 4096</span><span>&#39;</span>, <span>&#39;</span><span>Byte Offset</span><span>&#39;</span>, <span>&#39;</span><span>Octal Byte #1</span><span>&#39;</span>, <span>&#39;</span><span>Byte #1</span><span>&#39;</span>, <span>&#39;</span><span>Octal Byte #2</span><span>&#39;</span>, <span>&#39;</span><span>Byte #2</span><span>&#39;</span>, <span>&#39;</span><span>Binary Byte #1</span><span>&#39;</span>, <span>&#39;</span><span>Binary Byte #2</span><span>&#39;</span>, <span>&#39;</span><span>Byte #1 XOR Byte #2</span><span>&#39;</span>]:
    sys.stdout.write(<span>&#34;</span><span>{:&lt;20}</span><span>&#34;</span>.format(header))
sys.stdout.write(<span>&#34;</span><span>\n</span><span>&#34;</span>)

<span>for</span> line <span>in</span> sys.stdin:
    parts = re.split(<span>&#34;</span><span>\\</span><span>s+</span><span>&#34;</span>, line.strip())
    offset_number = <span>int</span>(parts[<span>0</span>])
    octal_a = <span>int</span>(parts[<span>1</span>], <span>8</span>)  
    octal_b = <span>int</span>(parts[<span>3</span>], <span>8</span>)  
    parts.insert(<span>0</span>, <span>str</span>((offset_number-<span>1</span>) % (<span>4</span> * <span>1024</span>)))
    parts.append(<span>&#39;</span><span>{0:08b}</span><span>&#39;</span>.format(octal_a))  
    parts.append(<span>&#39;</span><span>{0:08b}</span><span>&#39;</span>.format(octal_b))  
    parts.append(<span>&#39;</span><span>{0:08b}</span><span>&#39;</span>.format(octal_a ^ octal_b))  
    <span>for</span> part <span>in</span> parts:
        sys.stdout.write(<span>&#34;</span><span>{:&lt;20}</span><span>&#34;</span>.format(part))
    sys.stdout.write(<span>&#34;</span><span>\n</span><span>&#34;</span>)
</pre></code></p><p>     And the output is now this (pay attention to the first column):</p>

<p><code><pre>(Offset -1) % 4096  Byte Offset         Octal Byte #1   Byte #1     Octal Byte #2     Byte #2         Binary Byte #1      Binary Byte #2      Byte #1 XOR Byte #2
714                 52185498315         107             G           307               M-G             01000111            11000111            10000000
714                 73775329995         177             ^?          377               M-^?            01111111            11111111            10000000
714                 86801068747         147             g           347               M-g             01100111            11100111            10000000
714                 181705323211        107             G           307               M-G             01000111            11000111            10000000
714                 186007311051        66              6           266               M-6             00110110            10110110            10000000
714                 207345296075        55              -           255               M--             00101101            10101101            10000000
714                 235067732683        76              &gt;           276               M-&gt;             00111110            10111110            10000000
714                 290357666507        37              ^_          237               M-^_            00011111            10011111            10000000
714                 300967236299        106             F           306               M-F             01000110            11000110            10000000
714                 305192092363        147             g           347               M-g             01100111            11100111            10000000
714                 313683256011        104             D           304               M-D             01000100            11000100            10000000
714                 322162291403        167             w           367               M-w             01110111            11110111            10000000
714                 355933934283        56              .           256               M-.             00101110            10101110            10000000
714                 383209988811        124             T           324               M-T             01010100            11010100            10000000
</pre></code></p><p>     And just like that, these &#39;seemingly random&#39; image file byte offsets contain an incredibly obvious pattern:  They are all congruent to 714 modulo 4096.   And, remember that exact address of the failing memory byte, 0x000784512ca?  Go ahead and calculate what it&#39;s congruent to modulo 4096.  I dare you.  It&#39;s <strong>0x000784512ca % 4096 = 714 in decimal</strong>.</p>

<p>     If that&#39;s not enough to convince you, try piping the output above through the following awk command:</p>

<p><code><pre><span>cat</span> differences.txt | python3 parse_differences.py | awk <span>-F</span> <span>&#39;&#39;</span> <span>&#39;</span><span>{for(i=1; i&lt;=NF; i++){if((i&gt;(60-(NR-14)*1))&amp;&amp;(i&lt;(86+(NR-14)*1))&amp;&amp;NR&lt;15&amp;&amp;(((i-73)^2/3^2)+((NR-9)^2/1^2)&gt;3)) printf &#34;1&#34;; else printf &#34; &#34;} printf &#34;\n&#34;}</span><span>&#39;</span>
</pre></code></p><p>     Take one look at the output and the truth becomes obvious:</p>

<p><code><pre>                                                     <span>1</span>
                                                    <span>111</span>
                                                   <span>11111</span>
                                                  <span>1111111</span>
                                                 <span>111111111</span>
                                                <span>11111111111</span>
                                               <span>11</span>         <span>11</span>
                                              <span>11</span>           <span>11</span>
                                             <span>1111</span>         <span>1111</span>
                                            <span>1111111111111111111</span>
                                           <span>111111111111111111111</span>
                                          <span>11111111111111111111111</span>
                                         <span>1111111111111111111111111</span>

</pre></code></p><p>     Doesn&#39;t this remind you of something?</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/illuminati-revealed_492x211_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/illuminati-revealed_492x211_q70.jpeg" alt="Illuminati Confirmed" width="492" height="211"/></a></p>



<p>     At this point, we&#39;ve confirmed that there are in fact &#39;bit flips&#39; occurring in memory, and furthermore, we can make a precise association between the individual bit flips that were reported by memtest in hardware, and the bit flips that we saw in the &#39;ddrescue&#39; software as we imaged the hard drive image.  This association comes from the fact that all the failing address were both congruent to 714 modulo 4096.  The value &#39;714&#39; (modulo 4096) in relation to the hardware itself is not significant, but the fact that we also saw the exact same value, 714 (modulo 4096), through the software activity of &#39;ddrescue&#39; seems like more than a coincidence.  It is reasonable to conclude that the &#39;ddrescue&#39; program requested heap memory pages from the operating system that were 4096 bytes in size as a temporary storage for data that was coped during the imaging process of the hard drive.  By chance, some of these memory pages just happened to include the bad physical memory address noted above (0x000784512ca), causing the bits to be flipped and corrupting the resulting image.</p>


<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/2b-bad-byte-association_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/2b-bad-byte-association_600x338_q70.jpeg" alt="Tracking Bad Bit In Memory" width="600" height="338"/></a></p>

<p>     So, if we got 14 bit flips when creating the image with &#39;ddrescue&#39;, how come we got 0 bit flips when copying with the &#39;dd&#39; command?  That&#39;s a good question, and I don&#39;t have a great answer, but I would speculate that it has something to do with how &#39;ddrescue&#39; uses heap memory internally compared with how &#39;dd&#39; so.  The &#39;dd&#39; command is much a much simpler tool to do block copies of information without trying to maintain data structures to re-construct and retry failed sectors in the same way that &#39;ddrescue&#39; does.   It&#39;s likely down the fact that the &#39;dd&#39; command simply makes less use of heap memory or access it in a different pattern compared to the way the &#39;ddrescue&#39; command does.</p>

<p>     Whatever the reason is for the difference in behaviour between &#39;dd&#39; and &#39;ddrescue&#39;, we could argue that you might prefer to use one or the other tool to image a drive depending on the circumstances.  In cases where you suspect a hard drive to be failing, you would prefer to image the drive using &#39;ddrescue&#39;.  However, in cases where you suspect that the <em>memory</em> is failing, then you would prefer to image using the &#39;dd&#39; command.  If you suspect that either could be failing, you would image the drive using both methods and then verify by computing the hash of all three:  The raw block device, the dd-based image and the ddrescue-based image.</p>



<p>     Okay, so at this point, I was sure that there are <em>definitely</em> memory errors in this computer.  However, I already have my fully intact and verifiably correct hard drive image despite the failing memory, so we&#39;re done right?   Nope!  It&#39;s time to replace the memory and then verify that the hardware issue has been fixed!</p>

<p>     One of the first changes that I made to the hardware was to replace the power supply with a brand new one.  Power supplies contain components like capacitors that can degrade over time.</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/1-electrolytic-capacitor_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/1-electrolytic-capacitor_600x338_q70.jpeg" alt="Electrolytic Capacitor" width="600" height="338"/></a></p>
<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/1b-power-supply-insides_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/1b-power-supply-insides_600x338_q70.jpeg" alt="Power Supply Insides" width="600" height="338"/></a></p>

<p>     I didn&#39;t actually do any kind of fancy analysis to evaluate whether the power supply really did have any problems (I don&#39;t even have the kind of equipment you&#39;d need to do such a test), but I felt it was safe to assume that after almost 15 years of operation, a replacement couldn&#39;t hurt.</p>

<p>     Replacing the power supply might seem like a strange place to start debugging a problem with the computer&#39;s memory, but if there really <em>was</em> a problem with the power supply then you can end up with all sorts of extremely strange and hard to debug problems with the rest of your hardware/software.  When the power supply functions correctly, it should convert 120V or 240V AC into well filtered 3.3V, 5V or 12V DC.  However, if the power supply starts to fail, these DC voltages could be too high or low, or experience ripple.</p>

<p>     Many experienced computer users have heard of the idea that bit flips are extremely rare occurrences that are almost always caused by cosmic rays from space.  In my experience, bit flips are a much more frequent occurrence that can typically be attributed to a presistent hardware issue (like a failing power supply).</p>

<p>     With the power supply replaced, my weeks-long saga of troubleshooting the memory began:</p>

<p>     First, I started with a test to confirm that I still had memory failure even after replacing the power supply.  Indeed, memtest was still identifying failures after just a few minutes.  For this test, I still had all 4 memory slots populated with a 1GB stick each.   I should also mention that this computer had multiple failed case fans, so it was running hotter than normal.</p>


<p>     I decided to try and use a process of elimination to identify whether there was a single stick, or possibly multiple sticks that were the root cause of the problem.  I ran another test with only a single stick of ram in the slot closest to the CPU.  After 40 min, it had 0 errors, so I concluded that this stick might be Okay.</p>



<p>     Then, to be extra thorough, I put all 4 sticks back in and ran memtest again.  A common cause of memory errors is RAM that isn&#39;t making a good connection with the slots on the motherboard.  Sometimes, simply taking the RAM out and putting it back in will fix the issue.  This wasn&#39;t the case here, because more errors appears within a few minutes.</p>

<p>     Based on the addresses where the memory errors occurred, I started to suspect that there might actually two sticks of RAM that were bad.  I ran another test where I kept only two of these sticks in the motherboard.  This time, the test ran for 1 hours 22 minutes without reporting any errors.</p>

<p>     At this point, I was starting to suspect that maybe it wasn&#39;t even the RAM that was bad, but perhaps the RAM slots (or the motherboard, or the CPU) that was bad.   I ran another test where I put the two remaining sticks of RAM into the exact same slots that I had just seen working without errors in the previous test.</p>

<p>     This time I got errors again.  So now, I had the errors down to two stick of ram in the two slots that were closest to the CPU.  I first tested again with only the first stick of RAM in the slot closest to the CPU.  This time, it ran for 1 hours and 46 minutes with no errors.  From this, I concluded that the culprit probably wasn&#39;t this stick or the slot closest to the CPU.</p>

<p>     Next, I tested the second of the two RAM sticks in second slot away from the CPU.  I did get an error just before the 1 hour mark.  So, now I had localized the error down to one stick of ram in at least one of the slots.</p>

<p>     In order to try and rule out a problem with the RAM slot itself, I did another test with this exact same stick in the slot closest to the CPU, and got another failure at almost the three hour mark.</p>

<p>     I found it a bit odd that it took a lot longer to trigger errors in this slot, so I did another identical test of this RAM stick in this same slot while the computer was still warm.  Again, it took about 3 hours for errors to pop up.</p>

<p>     In order to completely rule out any involvement of the second RAM slot itself, I decided to do even more testing in this slot with one of the other sticks of RAM that I hadn&#39;t yet observed failures on.  This test ran for over 10 hours, and did not result in any error.  At this point, I concluded that I had identified at least one bad stick of RAM, since it failed with the same error mask in multiple slots. I put a mark on this stick to identify it as stick #1.  Furthermore, I concluded that the motherboard itself (or the CPU) was not likely to be the root cause of the failures.  I also concluded that the stick that ran for over 10 hours without error was probably okay.  I then marked this stick to identify it as stick #2.</p>

<p>     Next, I took one of the remaining untested sticks and did the same test on it in the second slot away from the CPU.  This stick ran for over 11 hours without any errors.  I identified this stick as #3.</p>

<p>     Finally, I tested the last stick, #4, for 12:47, and did not seen any errors.   So far, I&#39;ve identified #1 as bad, and #2, #3, and #4 as likely good.</p>



<p>     So, the next thing to do is put these three so-called &#39;good&#39; sticks together, and test them out because hopefully they should work, right?  Nope!  One failure after only a hour:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/3-memtest-failure-good-sticks_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/3-memtest-failure-good-sticks_600x338_q70.jpeg" alt="Memtest Failure" width="600" height="338"/></a></p>

<p>     I wasn&#39;t completely sure about how the RAM addresses mapped to the actual RAM slots, and I had a hunch there might be an issue with the stick in third slot away from the CPU.  I decided to take out all but this stick in the third slot, and do another test.  I also hadn&#39;t tested much in this slot before, so I figured it was worth a shot.  I was hoping to get lucky and catch a failure in this stick, but after an hour there were still no errors on this stick.</p>

<p>     At this point, it was clear that testing individual sticks one at a time wouldn&#39;t quickly reveal more failures, so I decided to move to an approach of testing more than one stick at once.  I would also start being more careful in tracking the stick and slot numbers, and logging the exact failure addresses.</p>

<p>     So, for the first test, I put sticks in the order #3, #2, #4 and got my first failure just before the 2 hour mark.  The was only one error and its mask was 0x100.  The failing address was 0x000b08f3204.</p>

<p>     For the second test, the sticks had the order #2, #3, #4, and it had failures by the 32 min mark.  There were 7 failures with mask 0x200 at address 0x000b4218f9c, and 1 failure with mask 0x4 at address 0x000b2cdf93c.</p>

<p>     For the third test, the sticks had the order #2, #4, #3, and I noted the first failure occurred at the 1hr 49min.  This test had logged 2 errors with mask 0x4 at address 0x000659bf27c.</p>

<p>     For the fourth test, the sticks had the order #4, #2, #3, and I noted the first failure at the 36 min mark.  This test had logged 1 error with mask 0x100 at address 0x000b08f3204.  As I started to review the data from all four tests, I realized that this was probably the worst possible result:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/4-memtest-overview_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/4-memtest-overview_600x338_q70.jpeg" alt="Memtest Results Overview" width="600" height="338"/></a></p>



<p>     From the above test results, you can see that test #1 and test #4 both have a failure at the exact same address with the exact same bit mask.  If you look at the RAM slot orderings for these two tests, you can see that the only commonality between them is position of the #2 stick.  If you assume that stick #2 is the only bad stick among these three (or slot) then you would expect to also see a clear pattern between the failures in test #2 and test #3.  The #2 stick is in the same location between test #2 and test #3, but clearly the failures between these two tests show locations that are in different megabytes.</p>

<p>     From this, I concluded the following:  The remaining hardware error in these last 3 sticks of RAM cannot be due to a single bad stick of RAM.  It must either be due to multiple bad sticks of RAM, or some sort of less obvious common-mode problem.  There may be an issue motherboard&#39;s ability to refresh the RAM states when more than a couple RAM sticks are present.  Perhaps there is a leaking capacitor somewhere on the motherboard, or maybe the presence of multiple sticks of RAM causes an intolerably long increase in the time between refreshes.</p>

<p>     I also haven&#39;t given much consideration toward the selection of RAM timings, voltages, and frequencies.  So far, I&#39;ve just relied to BIOS to automatically select the right default values, and it is beyond my capabilities to select better values.</p>

<p>     At this point, I felt that I had done just about everything I could do to isolate which sticks of RAM were bad, and that it was probably worth giving up on all 4 of the original sticks of RAM.</p>



<p>     For this next bit of hardware improvement, I decided to replace all the thermal paste and install a new CPU fan and replace all the case fans:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/5-replacing-thermal-paste_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/5-replacing-thermal-paste_600x338_q70.jpeg" alt="Replacing Thermal Paste" width="600" height="338"/></a></p>


<p>     Now, with all the fans replaced, I decided to start up memtest again with these three sticks and see if the cooler temperature had much influence on the rate at which errors appear.</p>

<p>     I let this test run for almost 18 hours, and it only recorded 1 error during that time.  This is contrasted with the exact same test that I did before where I would usually get multiple errors within the first couple hours.  From this, I conclude that letting your computer get very hot is a one very likely cause of increased memory errors.</p>



<p>     Back when I had seen the first memtest error, I decided to order some new ram from china and since that finally arrived, I decoded to test it out too.  It cost me $30 including shipping to get these 4 brand new sticks direct from China:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/6-replacement-ram-1_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/6-replacement-ram-1_600x338_q70.jpeg" alt="DDR3 RAM" width="600" height="338"/></a></p>

<p>     I started out by putting all 4 sticks of RAM in, and tried to boot it up.  Unfortunately, the motherboard didn&#39;t like this RAM and I only got POST beeping codes for memory   issues.  Then, I removed 3 of the sticks so that only one remained, and tried again.  It still just gave me beeping codes for memory issues.  Around this time, I started doing more research and discovered that there is another important variable to consider when buying RAM, and that is the &#39;RAM density&#39;.  Apparently, older motherboards cannot handle newer high density RAM.  This is a problem because most of the cheap RAM that you find online does not give any indication of what it&#39;s density is, so there&#39;s no way to know if it will work until you buy it and put it in the motherboard.</p>



<p>     I decided to give it another shot, so I bought some more cheap RAM off of eBay:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/7-replacement-ram-2_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/7-replacement-ram-2_600x338_q70.jpeg" alt="DDR3 RAM" width="600" height="338"/></a></p>

<p>     This here is supposed to be 2 sticks of 2GB each.  From the label on the RAM it looks like it might actually be 4GB sticks, but the description assured me that they were indeed 2GB sticks, which are supposed to work in this motherboard.  For the record, the motherboard is an Intel <a href="https://www.intel.ca/content/www/ca/en/support/articles/000005865/boards-and-kits/desktop-boards.html">DP45SG</a>.</p>

<p>     I installed this RAM and found that it also wouldn&#39;t work.  I tried a few times with only one stick and I also tried re-arranging the RAM slots a couple times, but this only produced more POST error codes.</p>



<p>     Naturally, the next step was to buy even more RAM off of eBay:</p>

<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/8-replacement-ram-3_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/8-replacement-ram-3_600x338_q70.jpeg" alt="DDR3 RAM" width="600" height="338"/></a></p>

<p>     I believe these ones were actually used sticks.  They are 1GB each, and they appear to be a mixed lot.  For this set it looks like there is a high probability that the RAM timings, voltage and density may all be different and possibly incompatible.  I decided to start by not paying any attention to this detail, and just put them in all at once and see what happens.</p>

<p>     Clearly, it doesn&#39;t work with all 3 sticks of RAM together, so I tested out each stick individually, and to my surprise, all three of these sticks work!</p>

<p>     After looking a bit more carefully at the voltages and timings of these sticks of RAM, there are two of them that appear to be fairly similar, so I decided to try installing both of them together.</p>

<p>     And fortunately, it did manage to boot up successfully and I was able to get into memetest:</p>


<p><a href="https://blog.robertelder.org/importance-of-ecc-memory/9-final-memtest-pass_3840x2160_q92.png"><img src="https://blog.robertelder.org/importance-of-ecc-memory/9-final-memtest-pass_600x338_q70.jpeg" alt="Memtest Pass" width="600" height="338"/></a></p>

<p>     I decided to let memtest run with these sticks for 50 hours, and after 69 passes with 0 failures, I think it&#39;s time to declare this a success.  This 2GB of memory is a lot less than the 8GB that I wanted to install in this machine, but given how hard it is to find old RAM that actually works, I&#39;ll have to declare this as &#39;good enough&#39;.</p>



<p>     So what kind of conclusions can we draw from the experience described above?  There are a lot of mini-lessons and learnings, but the most significant idea that I want to impart to the reader is the scale of <strong>how much <em>time I wasted on debugging this</em></strong>.  With cheap consumer non-ECC memory, your bits can flip here and there, and you&#39;ll have no idea!  The first indication that I had that there was even a problem was a silently corrupted hard drive image.  To even detect this, I needed the patience and discipline to verify the checksum on a 500GB file!  Imagine how much more time I could have wasted if I didn&#39;t bother to verify the checksum and made use of an important business document that contained one of the 14 bit flips?</p>

<p>     Now some of you might think that it&#39;s a bit melodramatic to even consider it a big deal when only 14 bits per 500GB of data are corrupted, but that&#39;s really what defines the difference a user that needs ECC memory and a casual user who doesn&#39;t.  Some people need computers to produce exactly correct results all the time, and some people are okay with just rebooting the machine when it mis-behaves and then blaming the problem on &#39;ghosts&#39;.</p>

<p>     Having said this, the performance and cost advantage of using consumer-grade non-ECC memory compared to ECC memory is getting smaller and smaller every year.  Hopefully, one of these days, memory and CPU manufacturers will finally bite the bullet and declare &#34;We are permanently discontinuing non-ECC memory and CPU production forever.  Moving forward, all consumer grade memory and CPUs will use error correction.&#34;.  Once this happens, we can finally stop having conversations about this topic, and people like me will no longer need to write articles like this one.</p>

<p>     Okay, now time to go upstairs and see what everyone else in the family is up to.  Oops, everybody went to bed already.</p>



<p>     After publishing the video above, I got an email from someone who suggested an explanation for the padding issue that I encountered above.  The email reads as follows:</p>

<p>Hi, I just saw your video on the non-ECC RAM corrupted hard drive image. I don&#39;t like commenting on social media, so I thought I&#39;d send you an e-mail instead.</p>

<p>The reason your dd command creates an image size that does not match the size of your block device is because you&#39;re running &#34;dd conv=sync&#34;. The sync conversion option explicitly tells dd to pad every input block with NULs up to the input block size, which is the behaviour you&#39;re seeing. I assume you&#39;re trying to tell dd to use synchronous I/O, but that&#39;s a flag, not a conversion option.</p>

<p>While this is documented in the dd man page, it is really confusing.</p>

<p>If you really want synchronous I/O, try:</p>

<p><code><pre>dd if=/dev/whatever of=image bs=64k conv=noerror iflag=sync oflag=sync
</pre></code></p><p>Although I&#39;ve never used synchronous I/O in dd, I just run &#34;sync&#34; afterwards as you do since I like buffering and caching during the transfer :)</p>

<p>No affiliation with dd, gnu, youtube or anything else. I just saw your video and wanted to clear it up, since I recognized the problem.

</p><p>Have a good one, Andreas</p>

<p>--End Of Email--</p>

<p>I must admit that I have never taken the time to gain a detailed understanding of all the flags that &#39;dd&#39; supports, and I have not personally taken the time to verify the suggestions in the email described above.  However, I will keep this note here as it may help others (and I will likely try this out myself some time in the future).</p>






<table>
	<tbody>
		<tr>
			<td>
				<span id="leads-signup-message">Join My Mailing List</span>
				
						
						
					
				<a href="https://www.robertelder.org/privacy-policy/">Privacy Policy</a>
			</td>
			<td>
				<span>Why Bother Subscribing?</span>
				<ul>
					<li><strong>Free Software/Engineering Content.</strong> I publish all of my educational content publicly for free so everybody can make use of it.  Why bother signing up for a paid &#39;course&#39;, when you can just sign up for this email list?</li>
					<li><strong>Read about cool new products that I&#39;m building.</strong> How do I make money? Glad you asked!  You&#39;ll get some emails with examples of things that I sell.  You might even get some business ideas of your own :)</li>
					<li><strong>People actually like this email list.</strong> I know that sounds crazy, because who <em>actually</em> subscribes to email lists these days, right?  Well, some do, and if you end up not liking it, I give you permission to unsubscribe and mark it as spam.</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>

							</div>
						</div></div>
  </body>
</html>
