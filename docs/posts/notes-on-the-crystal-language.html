<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiki.alopex.li/CrystalNotes">Original</a>
    <h1>Notes on the Crystal Language</h1>
    
    <div id="readability-page-1" class="page"><div id="wikipage">

<p>A friend talked me into trying out the <a href="https://crystal-lang.org">Crystal programming language</a>, and
then another friend talked me into starting a <a href="https://hg.sr.ht/~icefox/casual-benchmarks">little project</a>
that Crystal would be good for, so here’s the traditional rambling
thoughts on it. Written in September 2024, using Crystal 1.13. Also note
that I’ve used almost no statically-typed language besides Rust for like
8 years, so I am <em>very</em> Rust-brained these days.</p>

<ul>
<li>Language started in 2014</li>
<li>Overarching idea: Strongly-typed Ruby (with lots of type
inference)</li>
<li>This means Everything Is An Object, which always feels wrong to me
these days, but like Ruby it’s a fairly good implementation of the idea.
You can have standalone functions and whatever and it works fine.</li>
<li>Programs are just compiled to native executables through LLVM.
Compilation isn’t instant, but it’s Fast Enough for me so far.</li>
<li>No repl that I’ve found, but also no <code>main()</code> function,
writing bare statements in a toplevel file executes them from start to
end. Sounds like a potential liability to me, with order of file imports
changing side effects, but it sure is convenient to learn with.</li>
<li>The tutorial also has editable and executable online code blocks,
which is an excellent way to play around</li>
<li>Has a good range of useful-but-less-common built-in types like sets,
symbols/atoms, tuples and closures, so the creator is no fool</li>
<li>Reasonably modern package/build manager: <code>shards</code>. Uses
yaml for the file format unfortunately, but oh well.</li>
<li>Decent project-blessed Debian packages and the usual (bad)
<code>curl ... | sudo sh</code> style install script, which I eyeballed
and is not at this time a rootkit. Its .deb is hosted on opensuse.org,
which feels weird; someday I should actually learn anything about SuSE
besides “RPM based, I tried it in 2005 and it didn’t work well on my PC
at the time”</li>
<li>Tutorial is really minimal, be prepared to just read through the
reference once you get through the bare essentials</li>
<li>The reference is pretty good though</li>
<li>Where the hell are for loops??? Oh they don’t exist, you use
<code>10.each do |x| ... end</code> like Ruby. Sure, why not.</li>
<li>Reasonable ecosystem of libs, seemingly mostly decentralized like Go
but <code>shards</code> has at least the framework for different package
sources, so if someone makes a centralized Crystal package lib and it
gets popular it can just be added as another option. Standard lib is
more of the maximalist style, has a bunch of handy script-y things in
it.</li>
<li>Compiles to static-ish binaries with LLVM. So it’s not a scripting
language per se, but… scripting-language-coded, I suppose.</li>
<li>Was sold to me as having very good FFI and macro metaprogramming,
which sounds useful.</li>
</ul>

<ul>
<li>It splits apart <code>new</code> to allocate memory and
<code>initialize</code> to initialize it like Objective C does, which is
always nice to see. Usually unnecessary, but nice to see.</li>
<li>Class variables are all private, everything is done through
accessors. There’s freely-available overloads for operators like
<code>=[]</code> for <code>x[y] = z</code>, and more shortcuts (which
turn out to be <a href="https://crystal-lang.org/api/1.13.2/Object.html#property%28%2Anames%2C%26block%29-macro">macros</a>)
for defining accessors.</li>
<li>Does the Ruby annotation thing where <code>foo</code> is local var,
<code>@foo</code> is instance var, <code>@@foo</code> is class var,
which feels weird but after using it for a while I actually kinda like
it.</li>
<li>Oooooh all constants start with capital letters… and all
types/classes start with capital letters… so all types are constants at
runtime. Classy. …No, not that kind of <code>class</code>-y. Dammit that
wasn’t supposed to be a pun! Go away!</li>
<li>Structs are value-typed classes, like in C#. IMO this is a worse
design than just having explicit references, but fine for 2014 when the
language was created.</li>
<li>There’s a feature called “splat assignment” which just seems like
weaksauce pattern matching. Looks useful, but why not just have pattern
matching? Splat assignment probably evolved out of Python’s
<code>*</code> function argument swizzling operators.</li>
<li>Has some nice shortcut syntax for designing your own collections
types, so <code>{1 =&gt; :foo, 2 =&gt; :bar}</code> makes the builtin
<code>Hash</code> type, but you can write
<code>MyType{1 =&gt; :foo, 2 =&gt; :bar}</code> and it will desugar to
<code>MyType.new(); MyType[1] = :foo; MyType[2] = :bar;</code> Feels a
bit like C# there, nice option to have.</li>
</ul>

<ul>
<li>You (almost) never need to add type annotations to vars and function
args/returns to make the program typecheck, but you always have the
option to add them so it typechecks the way you want,, which is
good</li>
<li>It looks like it does some form of global type inference, which
sounds somewhat ad-hoc compared to OCaml-y HM but seems to work fine in
practice (so far).</li>
<li>The type inference allows unions of types like Typescript does, such
as <code>Int | String</code>.</li>
<li>Variables are declared by being assigned to, which to me feels a
little unnecessarily sloppy but usually works okay in practice. The
<code>@</code> sigils help a bit.</li>
<li>Variables can be reassigned with a value of a different type, which
is a little bold. So you can do <code>a = 3; a = &#34;hi&#34;</code> and it
works. Not sure yet how hazardous this is in practice. I assume it types
<code>a</code> as <code>Int32 | String</code> in that case? Yep; if you
declare the type of a variable <code>a : Int32 = 3; a = &#34;hi&#34;</code> then
it complains that the type of <code>a</code> is <code>Int32</code> but
you’re trying to use it as if it were <code>Int32 | String</code>.
Writing <code>a : Int32 | String = 3; a = &#34;hi&#34;</code> works just
fine.</li>
<li>This is also how uninitialized variables work. Uninitialized vars
have type <code>Nil</code>, which has only one value <code>nil</code>,
which then interacts with other types like normal. So an uninitialized
variable that is later set to a <code>String</code> has type
<code>Nil | String</code>.</li>
<li>So if you don’t want this to happen, you can always just give a
variable a type. And if you don’t do that, but screw something up, it
will get caught next time that variable is used with a function that has
typed args.</li>
<li>That feels <em>very</em> much like Typescript’s type system. Now, TS
is a little infamously unsound, which means you can write contradictions
in it; invalid programs can typecheck successfully. In practice this is
<em>seldom</em> too much of a problem in TS, afaik, but definitely can
fuck you up sometimes. I have no idea whether Crystal is unsound or not,
since its logic around types and objects and stuff seems different from
TS’s approach, which is shaped by needing to interoperate with the
abject sadness that is JS. Would be interesting to learn more about
it!</li>
<li>In general subtyping (such as OO inheritance) and union types (like
<code>Int | String</code>) are places where type systems get Hard, and
are areas of active research. So having Crystal wandering around this
design space is pretty neat from a language creator’s point of
view.</li>
<li>There are also real generics, haven’t touched them much yet but they
seem to do the job?</li>
<li>There’s the usual zoo of OO features like private/protected methods,
covariance and contravariance, virtual and abstract types, etc. I’m
happy to ignore them when possible.</li>
</ul>

<ul>
<li>Woohoo, batteries! Fun change from Rust. There’s hash functions in
there! JSON parser/writer! A smol HTTP server! Bignums! Tempfiles!</li>
<li>Oops, looks like its tempfile lib is written in library code in the
style of <code>mktemp(3)</code>, instead of calling the OS’s
<code>mkstemp(3)</code> or equivalent. So it just finds a filename that
doesn’t exist and then opens it separately, letting an attacker create a
new file which they can read at that location between those two steps.
Uh, have fun with your temporary files leading to exploitable race
conditions guys.</li>
<li>Digging through the Crystal issue tracker for this problem shows
multiple attempts to try to make this better done at different times by
different people, none of which seem to have been Good Enough. It’s a
pretty good example of the downsides of a batteries-included library,
tbh. Trying not to break shit is hard work.</li>
<li>The stdlib’s <code>OptionParser</code> is hella better than a C/bash
<code>argparse</code>-like API but it could be better still. I wish it
were more declarative and a little more opinionated, like Rust’s
<code>clap</code> or <code>argh</code>.</li>
<li>Oh I take it back, there’s no way I can find to just tell
<code>OptionParser</code> “this command line flag is necessary”. WTF?
It’s basically “wire your own state machine” like Python’s lame-ass
<code>argparse</code>. Maybe I should write a new command line parser
lib.</li>
<li>Oh, there’s already a bunch already written. A disadvantage of
Crystal’s Go-style package management where everything is in its own
repo, vs. Rust-style where there’s a blessed <code>crates.io</code> or
equivalent: it’s hard to know where to go to find packages. There
appears to be a decent (if commercial) curated list at <a href="https://crystal.libhunt.com/">https://crystal.libhunt.com/</a>. <a href="https://github.com/mrrooijen/commander">commander</a> and <a href="https://github.com/jwaldrip/admiral.cr">admiral</a> seem close to
what I want, though there’s plenty of others.</li>
<li>Annoying as this is, I <em>love</em> that there’s a good language
out there that makes decisions <em>different</em> from my habitual
Rust/Python/Elixir ecosystem. Tradeoffs are worth exploring.</li>
</ul>
<p>Okay I hate writing this ’cause I’ve been having fun up until now,
but the stdlib honestly needs some help. I had this code:</p>
<pre><code>testdir = Dir.new(testdir_path)
LANGUAGES.each do |name, lang|
  Dir.cd(testdir_path)
  # Iterate through subdirs
  testdir.each_child do |subdir|
    puts &#34;Processing stuff in #{subdir}&#34;
    do_stuff(testdir_path / subdir)
  end
end</code></pre>
<p>First off, <code>Dir#each_child()</code> returns a
<code>String</code>, not a <code>Path</code> or a <code>Dir</code> or
<code>File</code> object. Okay fine, paths are fucking cursed no matter
what. But it turns out that the <code>Dir</code> object <em>is</em> an
iterator, instead of what I expected, which was
<code>Dir#each_child</code> <em>creating</em> an iterator. So for the
first run of the outer loop it would iterate through the subdirectories
of <code>testdir_path</code>, and <code>do_stuff()</code> in each one.
Then for the <em>next</em> run of the outer loop it calls
<code>testdir.each_child()</code> again… which is already at the end of
the iterator, so it just bloody runs zero times. Want to iterate through
the directory again? Gotta call <code>testdir.rewind()</code> first. Is
this in the docs? Only if you look at the <code>rewind()</code> method
and understand that this is a possibility; otherwise you just gotta
figure it out the hard way like I did. Apparently this (like a lot of
the rest of the Crystal stdlib) is inherited from Ruby, but that doesn’t
mean it’s a good idea.</p>
<p>THIS is why you need an immutable-first language with move semantics
and borrowing, dammit! People ask me what Rust is good for if you are
happy to have a GC? Shit like this, that’s what.</p>
<p>Fine, Crystal isn’t that language, but still. But for as good as
Crystal itself is, it deserves to have the stdlib that doesn’t result in
me tripping across three separate footguns while writing what is, in the
end, a 300-line “I didn’t want to write a shell script” program. That’s
not great. Asking a good lang designer to also be a good stdlib designer
is a pretty tall order, but fortunately lib improvements are the sort of
work that can be done by a community more easily than core lang design.
Someone with intimate knowledge of the Rust stdlib and all the horrible
footguns its incredibly labyrinthine design tries to avoid, and the
intestinal fortitude to rewrite major parts of a stdlib, please help
Crystal out.</p>

<ul>
<li>You can make functions with named args and call them like
<code>some_method 10, w: 1, y: 2, z: 3</code>. Heh, more Objective C
lineage – I don’t <em>think</em> Ruby does that? Oops it does; I think I
last touched Ruby in like 2012. Either way, classy. Feels like how
Elixir writes DSL’s out of functions, but in a good way. Probably not a
coincidence, since they’re both Ruby-ish syntax.</li>
<li>Yep, you can use the “splat operator” in function args and it’s
exactly like Python’s arg swizzle operators. Always a nice feature for a
dynamic-ish language, and one of the fun things that is just really
fucking annoying to do sensibly in a For Realsies Static language like
Rust. Even when it’s statically typed and compiled to native code, being
able to have the language say “yeah we just use lots of dynamic dispatch
and/or reflection here, it’s fine” is pretty convenient at times.</li>
<li>Oh shit, there’s no sum types! Heck, no <em>wonder</em> this feels
weird to write in. There’s enums, which is nice, but they are very
explicitly limited to integers and intended for flags and stuff. If you
really wanted Rust-style sum types you could fake them easily enough,
but that always Feels Bad. No real pattern matching either, so you it’s
more annoying to use the “tuple of symbol + value” style of sum types
that’s ubiquitous in Elixir or Erlang.</li>
<li>Modules are first-class values, huh. And have some relation to
classes. Again I am reminded of one of my more mind-bending moments
while learning Ruby, which was reading something along the lines of “the
<code>Module</code> class of <code>Module</code> is a subclass of the
<code>Class</code> class of <code>Class</code>.” Good times.</li>
<li>The <code>crystal</code> binary comes with some handy tools built
in, with the command <code>crystal tool</code>. There’s fairly mundane
things like a formatter and a macro-expander, and also slightly more
uncommon but interesting bits like something that prints out the full
class tree for a program, or shows the implementations possible for an
overloaded method call.</li>
<li>The <code>require</code> file import statement is mostly file-based,
vs Rust or Elixir’s more abstract module tree knowing where it
<em>expects</em> to find files. There’s still some default search paths
that result in a particular file layout in a multi-file project, but it
seems to be more of a suggestion than a rule. Files also all share the
same namespace by default, if you want nested namespaces you just make
the file <code>foo/bar.cr</code> contain your code inside
<code>module Foo::Bar ... end</code> . Feels a little oldschool compared
to more abstract systems, like the concept is “C includes done
properly”, but it seems to work fine. Meshes decently with the
scripting-language vibe, you can just kinda throw files together if you
want to.</li>
<li>There’s some auto-casting of numerical types, but it’s very
conservative compared to say C or Python 2. It only can occur in
function args or class initialization as well, which is an interesting
choice.</li>
<li>Error handling is fairly mundane exceptions, so far.</li>
<li>Crystal’s tools for dealing with <code>Nil</code> are kinda
interesting. The type <code>String?</code> is a shortcut for
<code>String | Nil</code>. <code>Nil</code> is falsey, but has a little
syntactic sugar to it: if you have a value <code>x</code> of type
<code>String?</code> you can write
<code>if x do_stuff_with(x) end</code> and the <code>x</code> inside the
if block is of type <code>String</code>. It’s smart enough to do the
opposite too; if you write
<code>if !x do_stuff(x) else do_other_stuff(x) end</code> then inside
the “if” part <code>x</code> is type <code>Nil</code>, and inside the
“else” part <code>x</code> is type <code>String</code>. So I guess it’s
a case/pattern match on the type, really, but a very handy one. Very
alien to my brain used to Rust’s <code>Option</code>’s; Crystal once
again does something that <em>feels</em> like how you’d write stuff in a
dynamic language, but makes it type safe.</li>
<li>The shortcuts for properties in class constructors are very
convenient. Rust could learn some things there, tbh.</li>
</ul>

<ul>
<li>Reflection</li>
<li>FFI</li>
<li>Error handling</li>
<li>Macros</li>
<li>Generics (in more depth)</li>
<li>Can you magically return/break out of iterator functions like you
can in Ruby?</li>
<li>Threads/fibers?</li>
</ul>

<p>I still think the world really needs a solid, immutable-first and
functional-first scripting/glue language, and Crystal isn’t that. But it
<em>is</em> a solid, well-considered OO language with a static type
system that feels as low-friction as a dynamic one. So give Crystal a go
next time you’re sick of writing your bajillion’th Python/Ruby/JS
script. It steals lots of stuff from Ruby, but the stuff it adds is very
solid so far.</p></div></div>
  </body>
</html>
