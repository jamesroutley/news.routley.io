<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2022/Oct/29/the-perfect-commit/">Original</a>
    <h1>The Perfect Commit</h1>
    
    <div id="readability-page-1" class="page"><div id="primary">

<div>




<p>For the last few years I’ve been trying to center my work around creating what I consider to be the <em>Perfect Commit</em>. This is a single commit that contains all of the following:</p>
<ul>
<li>The <strong>implementation</strong>: a single, focused change</li>
<li>
<strong>Tests</strong> that demonstrate the implementation works</li>
<li>Updated <strong>documentation</strong> reflecting the change</li>
<li>A link to an <strong>issue thread</strong> providing further context</li>
</ul>
<p>Our job as software engineers is not to write new software: it’s to apply changes to existing software.</p>
<p>The commit is our principle unit of work. It deserves to be treated thoughtfully and with care.</p>
<h4>Implementation</h4>
<p>Each commit should change a single thing.</p>
<p>The definition of “thing” here is left deliberately vague!</p>
<p>The goal is have something that can be easily reviewed, and that can be clearly understood in the future when revisited using tools like <code>git blame</code> or <a href="https://til.simonwillison.net/git/git-bisect">git bisect</a>.</p>
<p>I like to keep my commit history linear, as I find that makes it much easier to comprehend later. This further reinforces the value of each commit being a single, focused change.</p>
<p>Atomic commits are also much easier to cleanly revert if something goes wrong—or to cherry-pick into other branches.</p>
<p>For things like web applications that can be deployed to production, a commit should be a unit that can be deployed. Aiming to keep the main branch in a deployable state is a good rule of thumb for deciding if a commit is a sensible atomic change or not.</p>
<h4>Tests</h4>
<p>The ultimate goal of tests is to <em>increase</em> your productivity. If your testing practices are slowing you down, you should consider ways to improve them.</p>
<p>In the longer term, this productivity improvement comes from gaining the freedom to make changes and stay confident that your change hasn’t broken something else.</p>
<p>But tests can help increase productivity in the immediate short term as well.</p>
<p>How do you know when the change you have made is finished and ready to commit? It’s ready when the new tests pass.</p>
<p>I find this reduces the time I spend second-guessing myself and questioning whether I’ve done enough and thought through all of the edge cases.</p>
<p>Without tests, there’s a very strong possibility that your change will have broken some other, potentially unrelated feature. Your commit could be held up by hours of tedious manual testing. Or you could <abbr title="You Only Live Once">YOLO</abbr> it and learn that you broke something important later!</p>
<p>Writing tests becomes far less time consuming if you already have good testing practices in place.</p>
<p>Adding a new test to a project with a lot of existing tests is easy: you can often find an existing test that has 90% of the pattern you need already worked out for you.</p>
<p>If your project has no tests at all, adding a test for your change will be a lot more work.</p>
<p>This is why I start every single one of my projects with a passing test. It doesn’t matter what this test is—<code>assert 1 + 1 == 2</code> is fine! The key thing is to get a testing framework in place, such that you can run a command (for me that’s usually <code>pytest</code>) to execute the test suite—and you have an obvious place to add new tests in the future.</p>
<p>I use <a href="https://simonwillison.net/2021/Aug/28/dynamic-github-repository-templates/">these cookiecutter templates</a> for almost all of my new projects. They configure a testing framework with a single passing test and GitHub Actions workflows to exercise it all from the very start.</p>
<p>I’m not a huge advocate of test-first development, where tests are written before the code itself. What I care about is tests-included development, where the final commit bundles the tests and the implementation together. I wrote more about my approach to testing in <a href="https://simonwillison.net/2020/Feb/11/cheating-at-unit-tests-pytest-black/">How to cheat at unit tests with pytest and Black</a>.</p>
<h4>Documentation</h4>
<p>If your project defines APIs that are meant to be used outside of your project, they need to be documented. In my work these projects are usually one of the following:</p>
<ul>
<li>Python APIs (modules, functions and classes) that provide code designed to be imported into other projects.</li>
<li>Web APIs—usually JSON over HTTP these days—that provide functionality to be consumed by other applications.</li>
<li>Command line interface tools, such as those implemented using <a href="https://click.palletsprojects.com/">Click</a> or <a href="https://typer.tiangolo.com/">Typer</a> or <a href="https://docs.python.org/3/library/argparse.html">argparse</a>.</li>
</ul>
<p>It is critical that this documentation <strong>must live in the same repository as the code itself</strong>.</p>
<p>This is important for a number of reasons.</p>
<p>Documentation is only valuable <strong>if people trust it</strong>. People will only trust it if they know that it is kept up to date.</p>
<p>If your docs live in a separate wiki somewhere it’s easy for them to get out of date—but more importantly it’s hard for anyone to quickly confirm if the documentation is being updated in sync with the code or not.</p>
<p>Documentation should be <strong>versioned</strong>. People need to be able to find the docs for the specific version of your software that they are using. Keeping it in the same repository as the code gives you synchronized versioning for free.</p>
<p>Documentation changes should be <strong>reviewed</strong> in the same way as your code. If they live in the same repository you can catch changes that need to be reflected in the documentation as part of your code review process.</p>
<p>And ideally, documentation should be <strong>tested</strong>. I wrote about my approach to doing this using <a href="https://simonwillison.net/2018/Jul/28/documentation-unit-tests/">Documentation unit tests</a>. Executing example code in the documentation using a testing framework is a great idea too.</p>
<p>As with tests, writing documentation from scratch is much more work than incrementally modifying existing documentation.</p>
<p>Many of my commits include documentation that is just a sentence or two. This doesn’t take very long to write, but it adds up to something very comprehensive over time.</p>
<p>How about end-user facing documentation? I’m still figuring that out myself. I created my <a href="https://simonwillison.net/2022/Mar/10/shot-scraper/">shot-scraper tool</a> to help automate the process of keeping screenshots up-to-date, but I’ve not yet found personal habits and styles for end-user documentation that I’m confident in.</p>
<h4>A link to an issue</h4>
<p>Every perfect commit should include a link to an issue thread that accompanies that change.</p>
<p>Sometimes I’ll even open an issue seconds before writing the commit message, just to give myself something I can link to from the commit itself!</p>
<p>The reason I like issue threads is that they provide effectively unlimited space for commentary and background for the change that is being made.</p>
<p>Most of my issue threads are me talking to myself—sometimes with dozens of issue comments, all written by me.</p>
<p>Things that can go in an issue thread include:</p>
<ul>
<li>
<strong>Background</strong>: the reason for the change. I try to include this in the opening comment.</li>
<li>
<strong>State of play</strong> before the change. I’ll often link to the current version of the code and documentation. This is great for if I return to an open issue a few days later, as it saves me from having to repeat that initial research.</li>
<li>
<strong>Links to things</strong>. So many links! Inspiration for the change, relevant documentation, conversations on Slack or Discord, clues found on StackOverflow.</li>
<li>
<strong>Code snippets</strong> illustrating potential designs and false-starts. Use <code>```python ... ```</code> blocks to get syntax highlighting in your issue comments.</li>
<li>
<strong>Decisions</strong>. What did you consider? What did you decide? As programmers we make hundreds of tiny decisions a day. Write them down! Then you’ll never find yourself relitigating them in the future having forgotten your original reasoning.</li>
<li>
<strong>Screenshots</strong>. What it looked like before, what it looked like after. Animated screenshots are even better! I use <a href="https://www.cockos.com/licecap/">LICEcap</a> to generate quick GIF screen captures or QuickTime to capture videos—both of which can be dropped straight into a GitHub issue comment.</li>
<li>
<strong>Prototypes</strong>. I’ll often paste a few lines of code copied from a Python console session. Sometimes I’ll even paste in a block of HTML and CSS, or add a screenshot of a UI prototype.</li>
</ul>
<p>After I’ve closed my issues I like to add one last comment that links to the updated documentation and ideally a live demo of the new feature.</p>
<h4>An issue is more valuable than a commit message</h4>
<p>I went through a several year phase of writing essays in my commit messages, trying to capture as much of the background context and thinking as possible.</p>
<p>My commit messages grew a lot shorter when I started bundling the updated documentation in the commit—since often much of the material I’d previously included in the commit message was now in that documentation instead.</p>
<p>As I extended my practice of writing issue threads, I found that they were a better place for most of this context than the commit messages themselves. They supported embedded media, were more discoverable and I could continue to extend them even after the commit had landed.</p>
<p>Today many of my commit messages are a single line summary and a link to an issue!</p>
<p>The biggest benefit of lengthy commit messages is that they are guaranteed to survive for as long as the repository itself. If you’re going to use issue threads in the way I describe here it is critical that you consider their long term archival value.</p>
<p>I expect this to be controversial! I’m advocating for abandoning one of the core ideas of Git here—that each repository should incorporate a full, decentralized record of its history that is copied in its entirety when someone clones a repo.</p>
<p>I understand that philosophy. All I’ll say here is that my own experience has been that dropping that requirement has resulted in a net increase in my overall productivity. Other people may reach a different conclusion.</p>
<p>If this offends you too much, you’re welcome to construct an <em>even more perfect commit</em> that incorporates background information and additional context in an extended commit message as well.</p>
<p>One of the reasons I like GitHub Issues is that it includes a comprehensive API, which can be used to extract all of that data. I use my <a href="https://github.com/dogsheep/github-to-sqlite">github-to-sqlite tool</a> to maintain an ongoing archive of my issues and issue comments as a SQLite database file.</p>
<h4>Not every commit needs to be “perfect”</h4>
<p>I find that the vast majority of my work fits into this pattern, but there are exceptions.</p>
<p>Typo fix for some documentation or a comment? Just ship it, it’s fine.</p>
<p>Bug fix that doesn’t deserve documentation? Still bundle the implementation and the test plus a link to an issue, but no need to update the docs—especially if they already describe the expected bug-free behaviour.</p>
<p>Generally though, I find that aiming for implementation, tests, documentation and an issue link covers almost all of my work. It’s a really good default model.</p>
<h4>Write scrappy commits in a branch</h4>
<p>If I’m writing more exploratory or experimental code it often doesn’t make sense to work in this strict way. For those instances I’ll usually work in a branch, where I can ship “WIP” commit messages and failing tests with abandon. I’ll then squash-merge them into a single perfect commit (sometimes via a self-closed GitHub pull request) to keep my main branch as tidy as possible.</p>
<h4>Some examples</h4>
<p>Here are some examples of my commits that follow this pattern:</p>
<ul>
<li>
<a href="https://github.com/simonw/datasette/commit/9676b2deb07cff20247ba91dad3e84a4ab0b00d1">Upgrade Docker images to Python 3.11</a> for <a href="https://github.com/simonw/datasette/issues/1853">datasette #1853</a>—a pretty tiny change, but still includes tests, docs and an issue link.</li>
<li>
<a href="https://github.com/simonw/sqlite-utils/commit/ab8d4aad0c42f905640981f6f24bc1e37205ae62">sqlite-utils schema now takes optional tables</a> for <a href="https://github.com/simonw/sqlite-utils/issues/299">sqlite-utils #299</a>
</li>
<li>
<a href="https://github.com/simonw/shot-scraper/commit/5048e21a1ca5accedfeca6ac25a16a38dc240b81">shot-scraper html command</a> for <a href="https://github.com/simonw/shot-scraper/issues/96">shot-scraper #96</a>
</li>
<li>
<a href="https://github.com/simonw/s3-credentials/commit/c7bb7268c4a124349bb511f7ec3ee3f28f9581ad">s3-credentials put-objects command</a> for <a href="https://github.com/simonw/s3-credentials/issues/68">s3-credentials #68</a>
</li>
<li>
<a href="https://github.com/simonw/datasette-gunicorn/commit/0d561d7a94f76079b1eb7779b3e944c163d2539e">Initial implementation</a> for <a href="https://github.com/simonw/datasette-gunicorn/issues/1">datasette-gunicorn #1</a>—this was the first commit to this repository, but I still bundled the tests, docs, implementation and a link to an issue.</li>
</ul>




</div>

</div></div>
  </body>
</html>
