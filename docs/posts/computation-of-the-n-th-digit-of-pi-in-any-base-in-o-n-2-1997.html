<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bellard.org/pi/pi_n2/pi_n2.html">Original</a>
    <h1>Computation of the n&#39;th digit of pi in any base in O(n^2) (1997)</h1>
    
    <div id="readability-page-1" class="page">
<meta name="description" value="Computation of the n&#39;th digit of  in any base in  "/>
<meta name="keywords" value="pi_n2"/>
<meta name="resource-type" value="document"/>
<meta name="distribution" value="global"/>

<p><strong>Fabrice Bellard</strong></p><p>
<b> This article is an <em> alpha</em> version. Please send any comments to <tt> Fabrice.Bellard@enst.fr</tt> </b>
</p><p>
Simon Plouffe explained in [<a href="https://bellard.org/pi/pi_n2/pi_n2.html#plo96">1</a>] a new algorithm to compute the
n&#39;th digit of <img alt="" src="https://bellard.org/pi/pi_n2/img3.gif"/> and some other mathematical constants in any base with
very little memory. Its running time is <img alt="" src="https://bellard.org/pi/pi_n2/img4.gif"/>. We
present here an improvement of this algorithm whose running time is
<img alt="" src="https://bellard.org/pi/pi_n2/img5.gif"/> while its memory requirements stay <img alt="" src="https://bellard.org/pi/pi_n2/img6.gif"/>, which makes it
practical to compute the millionth digit of <img alt="" src="https://bellard.org/pi/pi_n2/img7.gif"/> for example.
</p>
<p>
We want to compute the <b>n</b>&#39;th digit in base <b>B</b> of <b>s</b>, where
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img8.gif"/></p><p>
Let <img alt="" src="https://bellard.org/pi/pi_n2/img9.gif"/> , <img alt="" src="https://bellard.org/pi/pi_n2/img10.gif"/> and
<img alt="" src="https://bellard.org/pi/pi_n2/img11.gif"/>. We have
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img12.gif"/></p><p>
with the Chinese remainder theorem. Hence
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img13.gif"/></p><p>
The <img alt="" src="https://bellard.org/pi/pi_n2/img14.gif"/>&#39;th digits of <b>s</b>, where <img alt="" src="https://bellard.org/pi/pi_n2/img15.gif"/>, are the digits in base <b>B</b> of
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img16.gif"/></p><p>
With the last formula we have
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img17.gif"/></p><p>
As shown in [<a href="https://bellard.org/pi/pi_n2/pi_n2.html#plo96">1</a>], this equality is interesting because each term
can be computed separatly, with a total memory of <img alt="" src="https://bellard.org/pi/pi_n2/img18.gif"/> if we already
know <b>b</b> and <img alt="" src="https://bellard.org/pi/pi_n2/img19.gif"/>.
</p>
<p>
We want now to compute the <b>n</b>&#39;th digit in base <b>B</b> of <img alt="" src="https://bellard.org/pi/pi_n2/img20.gif"/>, where
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img21.gif"/></p><p>
with
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img22.gif"/></p><p>
With the first result we have
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img23.gif"/></p><p>
where
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img24.gif"/></p><p>
with
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img25.gif"/></p><p>
and
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img26.gif"/></p><p>
The key observation is that we can use for all <img alt="" src="https://bellard.org/pi/pi_n2/img27.gif"/> the same
modulo, hence
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img28.gif"/></p><p>
This can be rewritten
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img29.gif"/></p><p>
To have the digits after the n&#39;th one, in base B, we compute
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img30.gif"/></p><p>
The running time is <img alt="" src="https://bellard.org/pi/pi_n2/img31.gif"/> and the memory requirements stay
<img alt="" src="https://bellard.org/pi/pi_n2/img32.gif"/> if we suppose that:
</p>
<p>
Given
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img43.gif"/></p><p> we can use the result of section <a href="https://bellard.org/pi/pi_n2/pi_n2.html#res2">2</a> because if <b>p</b> is a
prime number, we notice that </p><p><img alt="" src="https://bellard.org/pi/pi_n2/img44.gif"/></p><p> where <img alt="" src="https://bellard.org/pi/pi_n2/img45.gif"/> is the multiplicity of
<b>p</b> in <b>n</b>. It comes from the relation
</p><p><img alt="" src="https://bellard.org/pi/pi_n2/img46.gif"/></p><p>
Hence, if we want the n&#39;th digit of <img alt="" src="https://bellard.org/pi/pi_n2/img47.gif"/> in base B, we may use the
following algorithm:
</p><ul><li> <img alt="" src="https://bellard.org/pi/pi_n2/img48.gif"/> where
  <img alt="" src="https://bellard.org/pi/pi_n2/img49.gif"/> is a small integer to ensure we have the precision needed
  ; <img alt="" src="https://bellard.org/pi/pi_n2/img50.gif"/>.
</li><li> For each prime number <b>a</b> with <b>2 &lt; a &lt; 2N</b>, do:
<ul><li>
    <img alt="" src="https://bellard.org/pi/pi_n2/img51.gif"/> ;
    <img alt="" src="https://bellard.org/pi/pi_n2/img52.gif"/>.
</li><li>
    <img alt="" src="https://bellard.org/pi/pi_n2/img53.gif"/> ; 
    <img alt="" src="https://bellard.org/pi/pi_n2/img54.gif"/> ;
    <img alt="" src="https://bellard.org/pi/pi_n2/img55.gif"/> ;
    <img alt="" src="https://bellard.org/pi/pi_n2/img56.gif"/>.
</li><li> for <b>k</b> in <img alt="" src="https://bellard.org/pi/pi_n2/img57.gif"/> do:

</li><li> <img alt="" src="https://bellard.org/pi/pi_n2/img63.gif"/> ; 
<img alt="" src="https://bellard.org/pi/pi_n2/img64.gif"/>.
</li></ul>
</li><li> If we suppose that <img alt="" src="https://bellard.org/pi/pi_n2/img65.gif"/>, then, if we
  neglect rounding errors,
  <img alt="" src="https://bellard.org/pi/pi_n2/img66.gif"/>. The number <b>q</b> of
  correct digits depends on <img alt="" src="https://bellard.org/pi/pi_n2/img67.gif"/>.
</li></ul>
<p>
The running time is <img alt="" src="https://bellard.org/pi/pi_n2/img68.gif"/> because there are <img alt="" src="https://bellard.org/pi/pi_n2/img69.gif"/>
prime numbers between <b>2</b> and <b>2n</b> . The memory requirements are, as
expected, in <img alt="" src="https://bellard.org/pi/pi_n2/img70.gif"/>.
</p>
<p>
We have presented an algorithm to compute the n&#39;th digit in any base B of
<img alt="" src="https://bellard.org/pi/pi_n2/img71.gif"/> whose running time is <img alt="" src="https://bellard.org/pi/pi_n2/img72.gif"/>. It has the same running time as other
classical methods for computing <img alt="" src="https://bellard.org/pi/pi_n2/img73.gif"/> (e.g. arctangent formulas), but it
uses little memory, it is very simple and does not need high precision
computations. It is still slower than the BBP algorithm [<a href="https://bellard.org/pi/pi_n2/pi_n2.html#bbp95">2</a>], but it
works in any base. As described in [<a href="https://bellard.org/pi/pi_n2/pi_n2.html#plo96">1</a>], the same algorithm may
be used to compute other numbers such as <img alt="" src="https://bellard.org/pi/pi_n2/img74.gif"/>, <img alt="" src="https://bellard.org/pi/pi_n2/img75.gif"/>, <img alt="" src="https://bellard.org/pi/pi_n2/img76.gif"/>,
<img alt="" src="https://bellard.org/pi/pi_n2/img77.gif"/> and <img alt="" src="https://bellard.org/pi/pi_n2/img78.gif"/>.
</p><h2><a name="SECTIONREF">References</a></h2><dl compact="">
<dt><a name="plo96"><strong>1</strong></a></dt><dd> Simon Plouffe, <i> On the computation of the n&#39;th 
decimal digit of various transcendental numbers</i>, November 1996.
</dd><dt><a name="bbp95"><strong>2</strong></a></dt><dd> David H. Bailey, Peter B. Borwein and 
Simon Plouffe, <i> On the Rapid Computation of Various Polylogarithmic
Constants</i>, April 1997 in Mathematics of Computation.
</dd></dl></div>
  </body>
</html>
