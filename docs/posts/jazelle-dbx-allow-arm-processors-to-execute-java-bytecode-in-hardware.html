<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikipedia.org/wiki/Jazelle">Original</a>
    <h1>Jazelle DBX: Allow ARM processors to execute Java bytecode in hardware</h1>
    
    <div id="readability-page-1" class="page"><div>
							

						<p>From Wikipedia, the free encyclopedia</p>
					</div><div id="mw-content-text"><div lang="en" dir="ltr">
<p><b>Jazelle DBX</b> (direct bytecode execution)<sup id="cite_ref-patent_1-0"><a href="#cite_note-patent-1">[1]</a></sup> is an extension that allows some <a href="https://en.wikipedia.org/wiki/ARM_architecture" title="ARM architecture">ARM</a> processors to execute <a href="https://en.wikipedia.org/wiki/Java_bytecode" title="Java bytecode">Java bytecode</a> in <a href="https://en.wikipedia.org/wiki/Computer_hardware" title="Computer hardware">hardware</a> as a third execution state alongside the existing ARM and <a href="https://en.wikipedia.org/wiki/ARM_architecture#Thumb" title="ARM architecture">Thumb</a> modes.<sup id="cite_ref-product_2-0"><a href="#cite_note-product-2">[2]</a></sup> Jazelle functionality was specified in the ARMv5TEJ architecture<sup id="cite_ref-armarm_3-0"><a href="#cite_note-armarm-3">[3]</a></sup> and the first processor with Jazelle technology was the <a href="https://en.wikipedia.org/wiki/ARM9" title="ARM9">ARM926EJ-S</a>.<sup id="cite_ref-Shanghai_4-0"><a href="#cite_note-Shanghai-4">[4]</a></sup> Jazelle is denoted by a &#34;J&#34; appended to the CPU name, except for post-v5 cores where it is required (albeit only in trivial form) for architecture conformance.
</p><p><a href="https://en.wikipedia.org/wiki/Jazelle_RCT" title="Jazelle RCT">Jazelle RCT</a> (Runtime Compilation Target) is a different technology based on ThumbEE mode; it supports <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" title="Ahead-of-time compilation">ahead-of-time</a> (AOT) and <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" title="Just-in-time compilation">just-in-time</a> (JIT) compilation with Java and other execution environments.
</p><p>The most prominent use of Jazelle DBX is by manufacturers of mobile phones to increase the execution speed of <a href="https://en.wikipedia.org/wiki/Java_ME" title="Java ME">Java ME</a> games and applications.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (November 2008)">citation needed</span></a></i>]</sup> A Jazelle-aware <a href="https://en.wikipedia.org/wiki/Java_virtual_machine" title="Java virtual machine">Java virtual machine</a> (JVM) will attempt to run Java bytecode in hardware, while returning to the software for more complicated, or lesser-used bytecode operations.  ARM claims that approximately 95% of bytecode in typical program usage ends up being directly processed in the hardware.
</p><p>The published specifications are very incomplete, being only sufficient for writing <a href="https://en.wikipedia.org/wiki/Operating_system" title="Operating system">operating system</a> code that can support a JVM that uses Jazelle.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (November 2008)">citation needed</span></a></i>]</sup>  The declared intent is that only the JVM software needs to (or is allowed to) depend on the hardware interface details.  This tight binding facilitates the hardware and JVM evolving together without affecting other software.  In effect, this gives <a href="https://en.wikipedia.org/wiki/ARM_Holdings" title="ARM Holdings">ARM Holdings</a> considerable control over which JVMs are able to exploit Jazelle.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (November 2008)">citation needed</span></a></i>]</sup> It also prevents open source JVMs from using Jazelle.  These issues do not apply to the ARMv7 ThumbEE environment, the nominal successor to Jazelle DBX.
</p>
<meta property="mw:PageProp/toc"/>
<h2><span id="Implementation">Implementation</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=1" title="Edit section: Implementation"><span>edit</span></a><span>]</span></span></h2>
<p>The Jazelle extension uses low-level <a href="https://en.wikipedia.org/wiki/Binary_translation" title="Binary translation">binary translation</a>, implemented as an extra stage between the fetch and decode stages in the processor <a href="https://en.wikipedia.org/wiki/Instruction_pipeline" title="Instruction pipeline">instruction pipeline</a>.  Recognised bytecodes are converted into a string of one or more native ARM instructions.
</p><p>The Jazelle mode moves JVM interpretation into hardware for the most common simple JVM instructions.  This is intended to significantly reduce the cost of interpretation.  Among other things, this reduces the need for <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" title="Just-in-time compilation">Just-in-time compilation</a> and other JVM accelerating techniques.<sup id="cite_ref-CPM_5-0"><a href="#cite_note-CPM-5">[5]</a></sup>  JVM instructions that are not implemented in Jazelle hardware cause appropriate routines in the Jazelle-aware JVM implementation to be invoked.  Details are not published, since all JVM innards are transparent (except for performance) if correctly interpreted.
</p><p>Jazelle mode is entered via the BXJ instructions.  A hardware implementation of Jazelle will only cover a subset of JVM bytecodes.  For unhandled bytecodes—or if overridden by the operating system—the hardware will invoke the software JVM.  The system is designed so that the software JVM does not need to know which bytecodes are implemented in hardware and a software fallback is provided by the software JVM for the full set of bytecodes.
</p>
<h2><span id="Instruction_set">Instruction set</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=2" title="Edit section: Instruction set"><span>edit</span></a><span>]</span></span></h2>
<p>The Jazelle <a href="https://en.wikipedia.org/wiki/Instruction_set" title="Instruction set">instruction set</a> is well documented as <a href="https://en.wikipedia.org/wiki/Java_bytecode" title="Java bytecode">Java bytecode</a>. However, ARM has not released details on the exact execution environment details;  the documentation provided with Sun&#39;s <a href="https://en.wikipedia.org/wiki/HotSpot_(virtual_machine)" title="HotSpot (virtual machine)">HotSpot</a> <a href="https://en.wikipedia.org/wiki/Java_virtual_machine" title="Java virtual machine">Java Virtual Machine</a> goes as far as to state: &#34;For the avoidance of doubt, distribution of products containing software code to exercise the BXJ instruction and enable the use of the ARM Jazelle architecture extension without [..] agreement from ARM is expressly forbidden.&#34;<sup id="cite_ref-Hotspot_6-0"><a href="#cite_note-Hotspot-6">[6]</a></sup>
</p><p>Employees of ARM have in the past published several white papers that do give some good pointers about the processor extension.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (January 2021)">citation needed</span></a></i>]</sup>  Versions of the ARM Architecture reference Manual available from 2008 have included pseudocode for the &#34;BXJ&#34; (Branch and eXchange to Java) instruction, but with the finer details being shown as &#34;SUB-ARCHITECTURE DEFINED&#34; and documented elsewhere.
</p>
<h2><span id="Application_binary_interface_.28ABI.29"></span><span id="Application_binary_interface_(ABI)">Application binary interface (ABI)</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=3" title="Edit section: Application binary interface (ABI)"><span>edit</span></a><span>]</span></span></h2>
<p>The Jazelle state relies on an agreed <a href="https://en.wikipedia.org/wiki/Calling_convention" title="Calling convention">calling convention</a> between the JVM and the Jazelle hardware state.  This <a href="https://en.wikipedia.org/wiki/Application_binary_interface" title="Application binary interface">application binary interface</a> is not published by ARM, rendering Jazelle an <a href="https://en.wikipedia.org/wiki/Undocumented_feature" title="Undocumented feature">undocumented feature</a> for most users and Free Software JVMs.
</p><p>The entire VM state is held within normal ARM registers, allowing compatibility with existing operating systems and interrupt handlers unmodified.  Restarting a bytecode (such as following a return from interrupt) will re-execute the complete sequence of related ARM instructions.
</p><p>Specific registers are designated to hold the most important parts of the JVM state: registers R0–R3 hold an alias of the top of the Java stack, R4 holds Java local operand zero (pointer to <code>*this</code>) and R6 contains the Java stack pointer.<sup id="cite_ref-accelerating_7-0"><a href="#cite_note-accelerating-7">[7]</a></sup>
</p><p>Jazelle reuses the existing <a href="https://en.wikipedia.org/wiki/Program_counter" title="Program counter">program counter</a> PC or its synonym register R15. A pointer to the <i>next</i> bytecode goes in R14,<sup id="cite_ref-Intel_8-0"><a href="#cite_note-Intel-8">[8]</a></sup> so the use of the PC is not generally user-visible except during debugging.
</p>
<h3><span id="CPSR:_Mode_indication">CPSR: Mode indication</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=4" title="Edit section: CPSR: Mode indication"><span>edit</span></a><span>]</span></span></h3>
<p>Java bytecode is indicated as the current instruction set by a combination of two bits in the ARM CPSR (Current Program Status Register).  The &#34;T&#34;-bit must be cleared and the &#34;J&#34;-bit set.<sup id="cite_ref-lkml_9-0"><a href="#cite_note-lkml-9">[9]</a></sup>
</p><p>Bytecodes are decoded by the hardware in two stages (versus a single stage for Thumb and ARM code) and switching between hardware and software decoding (Jazelle mode and ARM mode) takes ~4 clock cycles.<sup id="cite_ref-embedded_10-0"><a href="#cite_note-embedded-10">[10]</a></sup>
</p><p>For entry to Jazelle hardware state to succeed, the JE (Jazelle Enable)<sup id="cite_ref-armarm_3-1"><a href="#cite_note-armarm-3">[3]</a></sup> bit in the CP14:C0(C2)[bit 0] register must be set; clearing of the JE bit by a [privileged] operating system provides a high-level override to prevent application programs from using the hardware Jazelle acceleration.<sup id="cite_ref-armarmjp_11-0"><a href="#cite_note-armarmjp-11">[11]</a></sup> Additionally, the CV (Configuration Valid) bit<sup id="cite_ref-armarm_3-2"><a href="#cite_note-armarm-3">[3]</a></sup> found in CP14:c0(c1)[bit 1]<sup id="cite_ref-armarmjp_11-1"><a href="#cite_note-armarmjp-11">[11]</a></sup> must be set to show that there is a consistent Jazelle state setup for the hardware to use.
</p>
<h3><span id="BXJ:_Branch_to_Java">BXJ: Branch to Java</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=5" title="Edit section: BXJ: Branch to Java"><span>edit</span></a><span>]</span></span></h3>
<p>The BXJ instruction attempts to switch to Jazelle state, and if allowed and successful, sets the &#34;J&#34; bit in the CPSR; otherwise, it &#34;falls through&#34; and acts as a standard BX (<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)" title="Branch (computer science)">Branch</a>) instruction.<sup id="cite_ref-armarm_3-3"><a href="#cite_note-armarm-3">[3]</a></sup> The only time when an operating system or debugger must be fully aware of the Jazelle mode is when decoding a faulted or trapped instruction.  The Java <a href="https://en.wikipedia.org/wiki/Program_counter" title="Program counter">program counter</a> (PC) pointing to the next instructions must be placed in the Link Register (R14) before executing the BXJ branch request, as regardless of hardware or software processing, the system must know where to begin decoding.
</p><p>Because the current state is held in the CPSR, the bytecode instruction set is automatically reselected after task-switching and processing of the current Java bytecode is restarted.<sup id="cite_ref-accelerating_7-1"><a href="#cite_note-accelerating-7">[7]</a></sup>
</p><p>Following an entry into the Jazelle state mode, bytecodes can be processed in one of three ways:  decoded and executed natively in hardware, handled in software (with optimised ARM/ThumbEE JVM code), or treated as an invalid/illegal opcode. The third case will cause a branch to an ARM exception mode, as will a Java bytecode of 0xff, which is used for setting JVM breakpoints.<sup id="cite_ref-ARM1026EJ-S_12-0"><a href="#cite_note-ARM1026EJ-S-12">[12]</a></sup>
</p><p>Execution will continue in hardware until an unhandled bytecode is encountered, or an exception occurs.  Between 134 and 149 bytecodes (out of 203 bytecodes specified in the JVM specification) are translated and executed directly in the hardware.
</p>
<h3><span id="Low-level_registers">Low-level registers</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=6" title="Edit section: Low-level registers"><span>edit</span></a><span>]</span></span></h3>
<p>Low-level configuration registers, for the hardware virtual machine, are held in the ARM Co-processor &#34;CP14 register c0&#34;. The registers allow detecting, enabling or disabling the hardware accelerator (if it is available).<sup id="cite_ref-CIHIGDHI_13-0"><a href="#cite_note-CIHIGDHI-13">[13]</a></sup>
</p>
<ul><li>The Jazelle Identity Register in register CP14:C0(C0) is read-only accessible in all modes.</li>
<li>The Jazelle OS Control Register at CP14:c0(c1) is only accessible in kernel mode and will cause an exception when accessed in user mode.</li>
<li>The Jazelle Main Configuration Register at CP14:C0(C2) is write-only in user mode and read-write in kernel mode.</li></ul>
<p>A &#34;trivial&#34; hardware implementation of Jazelle (as found in the <a href="https://en.wikipedia.org/wiki/QEMU" title="QEMU">QEMU</a> emulator) is only required to support the BXJ opcode itself (treating BXJ as a normal BX instruction<sup id="cite_ref-armarm_3-4"><a href="#cite_note-armarm-3">[3]</a></sup>) and to return RAZ (Read-As-Zero) for all of the CP14:c0 Jazelle-related registers.<sup id="cite_ref-Cortex-A8_14-0"><a href="#cite_note-Cortex-A8-14">[14]</a></sup>
</p>
<h2><span id="Successor:_ThumbEE">Successor: ThumbEE</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=7" title="Edit section: Successor: ThumbEE"><span>edit</span></a><span>]</span></span></h2>
<p>The ARMv7 architecture has de-emphasized Jazelle and <i>Direct Bytecode Execution</i> of JVM bytecodes.  In implementation terms, only trivial hardware support for Jazelle is now required:  support for entering and exiting Jazelle mode, but not for executing any Java bytecodes.
</p><p>Instead, the <i>Thumb Execution Environment</i> (<a href="https://en.wikipedia.org/wiki/ARM_architecture#Thumb_Execution_Environment_(ThumbEE)" title="ARM architecture">ThumbEE</a>) was to be preferred, but <a href="https://en.wikipedia.org/wiki/ARM_architecture#Thumb_Execution_Environment_(ThumbEE)" title="ARM architecture">has since also been deprecated.</a> Support for ThumbEE was mandatory in ARMv7-A processors (such as the Cortex-A8 and Cortex-A9), and optional in ARMv7-R processors.  ThumbEE targeted compiled environments, perhaps using <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" title="Just-in-time compilation">JIT</a> technologies. It was not at all specific to Java, and was fully documented; much broader adoption was anticipated than Jazelle was able to achieve.
</p><p>ThumbEE was a variant of the Thumb2 16/32-bit instruction set.  It integrated null pointer checking; defined some new fault mechanisms; and repurposed the 16-bit LDM and STM opcode space to support a few instructions such as range checking, a new handler invocation scheme, and more. Accordingly, compilers that produced Thumb or Thumb2 code could be modified to work with ThumbEE-based runtime environments.
</p>
<h2><span id="References">References</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Jazelle&amp;action=edit&amp;section=8" title="Edit section: References"><span>edit</span></a><span>]</span></span></h2>
<ul role="navigation" aria-label="Portals">
<li><span><span typeof="mw:File"><a href="https://en.wikipedia.org/wiki/File:Octicons-terminal.svg"><img alt="icon" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Octicons-terminal.svg/24px-Octicons-terminal.svg.png" decoding="async" width="24" height="28" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Octicons-terminal.svg/37px-Octicons-terminal.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Octicons-terminal.svg/49px-Octicons-terminal.svg.png 2x" data-file-width="896" data-file-height="1024"/></a></span></span><span><a href="https://en.wikipedia.org/wiki/Portal:Computer_programming" title="Portal:Computer programming">Computer programming portal</a></span></li></ul>


<!-- 
NewPP limit report
Parsed by mw‐web.eqiad.main‐6f7f97ff5c‐xk6vj
Cached time: 20240109063710
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.308 seconds
Real time usage: 0.436 seconds
Preprocessor visited node count: 1922/1000000
Post‐expand include size: 47178/2097152 bytes
Template argument size: 4509/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 4/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 36570/5000000 bytes
Lua time usage: 0.184/10.000 seconds
Lua memory usage: 5484256/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  388.437      1 -total
 35.22%  136.812      1 Template:Refs
 30.39%  118.044      1 Template:Java_(Sun)
 30.23%  117.416      2 Template:Navbox
 22.14%   85.990      7 Template:Cite_web
 13.41%   52.078      1 Template:Short_description
 12.21%   47.428      5 Template:Fix
 11.94%   46.376      3 Template:Citation_needed
  7.62%   29.600     10 Template:Category_handler
  7.30%   28.366      2 Template:Pagetype
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:2123310-0!canonical and timestamp 20240109063710 and revision id 1184441701. Rendering was triggered because: page-view
 -->
</div><!--esi <esi:include src="/esitest-fa8a495983347898/content" /> -->
</div></div>
  </body>
</html>
