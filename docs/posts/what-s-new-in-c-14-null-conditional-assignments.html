<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ivankahl.com/csharp-14-null-conditional-assignments/">Original</a>
    <h1>What&#39;s New in C# 14: Null-Conditional Assignments</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<!--kg-card-begin: html-->

<!--kg-card-end: html-->
<p>If you&#39;ve ever developed in C#, you&#39;ve likely encountered a snippet like the one below:</p><pre><code>if (config?.Settings is not null) 
{
    config.Settings.RetryPolicy = new ExponentialBackoffRetryPolicy();
}</code></pre><p>This check is necessary because, if <code>config</code> or <code>config.Settings</code> is <code>null</code>, a <code>NullReferenceException</code> is thrown when trying to set the <code>RetryPolicy</code> property.</p><p>But no more endless <code>if</code>s! The latest version of C#, scheduled for release later this year with .NET 10, introduces the null-conditional assignment operators, which are designed to solve this exact issue.</p><h2 id="wait-doesnt-c-already-have-null-conditionals">Wait, Doesn&#39;t C# Already Have Null-Conditionals?</h2><p>Yes! The <a href="https://blog.ivankahl.com/csharp-null-conditional-and-null-coalescing-operators-explained/">null-conditional and null-coalescing operators have been around for awhile</a>. They simplify checking if a value is <code>null</code> before assigning or reading it.</p><pre><code>// Null-conditional (?.)
if (customer?.Profile is not null) 
{
    // Null-coalescing (??)
    customer.Profile.Avatar = request.Avatar ?? &#34;./default-avatar.jpg&#34;;
}</code></pre><p>However, these operators only worked when reading a value, not setting one. With C# 14, you&#39;ll be able to use it on the left-hand side of the <code>=</code> operator! Depending on your codebase, this can drastically clean up your code by reducing the number of <code>if</code> statements needed to assign values.</p><h2 id="prerequisites">Prerequisites</h2><p>C# 14 is still in development. This means that the syntax might change slightly before the final release of .NET 10. However, I&#39;ll update this article if anything does change before the final release.</p><p>You&#39;ll need to download and install the <a href="https://dotnet.microsoft.com/en-us/download/dotnet/10.0?ref=blog.ivankahl.com">latest .NET 10 preview SDK</a> to run the snippets below. Next, create a new C# project (using a Console project in this article) and ensure it targets .NET 10. You&#39;ll also need to enable preview language features by opening your <code>*.csproj</code> file and adding the <code>&lt;LangVersion&gt;preview&lt;/LangVersion&gt;</code> tag:</p>
<!--kg-card-begin: html-->
<pre data-line="7-8"><code>&lt;Project Sdk=&#34;Microsoft.NET.Sdk&#34;&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net10.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;!-- Add the LangVersion tag below. --&gt;
    &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</code></pre>
<!--kg-card-end: html-->
<p>You&#39;re all set to follow along with the snippets below.</p><h2 id="null-conditional-assignments-with-object-properties">Null-Conditional Assignments With Object Properties</h2><p>The introduction illustrated a typical pattern you&#39;ll find in C# projects when assigning values to object properties: first check if the object itself is not <code>null</code>. If you don&#39;t, a frustrating <code>NullReferenceException</code> gets thrown, and those are no fun to debug.</p><p>Take the snippet you saw at the beginning of this article:</p><pre><code>if (config?.Settings is not null) 
{
    config.Settings.RetryPolicy = new ExponentialBackoffRetryPolicy();
}</code></pre><p>This becomes a one-liner in C# 14:</p><pre><code>config?.Settings?.RetryPolicy = new ExponentialBackoffRetryPolicy();</code></pre><p>Now, the compiler will first make sure that <code>config?.Settings</code> is not <code>null</code> before proceeding to assign the <code>RetryPolicy</code> property. If <code>config?.Settings</code> is <code>null</code>, the assignment is skipped.</p><h2 id="null-conditional-assignments-with-indexer-elements">Null-Conditional Assignments With Indexer Elements</h2><p>The new operator also works on indexers. This is useful when you&#39;re unsure whether a dictionary or list is <code>null</code> before assigning a value.</p><p>Below is how you&#39;d currently check if a dictionary is defined before assigning a value to it:</p><pre><code>if (customerData is not null)
{
    customerData[&#34;LastLogin&#34;] = DateTime.UtcNow;
}</code></pre><p>Again, this is much simpler in C# 14:</p><pre><code>customerData?[&#34;LastLogin&#34;] = DateTime.UtcNow;</code></pre><p>Similar to the first example, the compiler will first check if properties is defined. If it is, the assignment is executed; otherwise, it&#39;s ignored.</p><h2 id="null-conditional-assignments-with-compound-assignments">Null-Conditional Assignments with Compound Assignments</h2><p>You&#39;re not limited to just using standard <code>=</code> assignments. You can also use the new operator with compound assignment operators like <code>+=</code> and <code>-=</code>.</p><p>Previously, you would have probably written something similar to the snippet below:</p><pre><code>if (results is not null)
{
    results.ItemsProcessed += 5;
}</code></pre><p>This now becomes:</p><pre><code>results?.ItemsProcessed += 5;</code></pre><p>You can evenÂ combine it with other operators, like the null-coalescing assignment operator (<code>??=</code>), to handle cases where the object exists but the property itself is <code>null</code>.</p><pre><code>customer?.Name ??= &#34;Guest&#34;;</code></pre><p>In the one-liner above, if <code>customer</code> is <code>null</code>, the entire assignment is skipped. Otherwise, if <code>customer</code> is defined, but <code>Name</code> is <code>null</code>, then the property is assigned <code>&#34;Guest&#34;</code>.</p><h2 id="things-to-keep-in-mind">Things To Keep In Mind</h2><p>Before applying null-conditional assignments throughout your codebase, keep these things in mind.</p><h3 id="side-effect-prevention">Side-Effect Prevention</h3><p>When a null-conditional statement assignment is evaluated, the right-hand side of the expression is not executed unless the left-hand side is defined. This is to prevent side effects arising from the right-hand side executing, but then resulting value is being discarded when performing the assignment.</p><p>For example, you might have a function that generates the next ID in a sequence and returns it:</p><pre><code>customer?.Id = GenerateNextCustomerId();</code></pre><p>If <code>customer</code> is <code>null</code>, then <code>GenerateNextCustomerId()</code> won&#39;t be executed. This is logical, since you don&#39;t want to unnecessarily increment your customer ID counter if the value isn&#39;t going to be used. Nevertheless, it&#39;s good to keep in mind when utilizing the operator.</p><h3 id="increment-and-decrement-operators-arent-supported">Increment and Decrement Operators Aren&#39;t Supported</h3><p>Sometimes it&#39;s convenient to increment a value using the <code>++</code> or <code>--</code> operators. However, those <strong>won&#39;t </strong>work if you&#39;re using a null-conditional assignment operator.</p><p>For example, this code snippet will break:</p><pre><code>// Will fail as ++ and -- are not supported with null-conditional assignments
customer?.TotalOrders++;</code></pre><p>Why not support it? The C# design team decided that these operators would be more challenging to implement and might not yield the expected results. Hence, a <a href="https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-28.md?ref=blog.ivankahl.com#increment-and-decrement-operators-in-null-conditional-access">decision was taken not to support it</a>.</p><h3 id="dont-overuse-it">Don&#39;t Overuse It</h3><p>This is my personal preference: avoid overusing the operator, as it might make it unclear why a specific value isn&#39;t being assigned.</p><p>For example, consider the snippet below:</p><pre><code>customer?.Orders?.FirstOrDefault()?.OrderNumber = GenerateNewOrderNumber();</code></pre><p>If a customer reports that the order number is not showing, you would need to look at this single line of code and determine:</p><ul><li>Did the <code>GenerateNewOrderNumber()</code> method return <code>null</code></li><li>Was <code>customer</code> set to <code>null</code>? Maybe the query to retrieve it is incorrect.</li><li>Was <code>customer.Orders</code> set to <code>null</code> ? Maybe the ORM never attached the order list to the customer entity.</li><li>Was the <code>customer.Orders</code> list empty, so <code>FirstOrDefault()</code> returned a <code>null</code> value?</li><li>Was the first value in the <code>Orders</code> list a <code>null</code>? This could indicate some deserialization issue somewhere.</li></ul><p>It&#39;s too many &#34;what ifs&#34; for one line. So, if your code looks like that, seriously consider refactoring it to be easier to debug. Perhaps to something like this:</p><pre><code>if (customer is null)
{
    logger.LogWarning(&#34;Customer is null for {CustomerId}&#34;, customerId);
    return;
}

var firstOrder = customer.Orders?.FirstOrDefault();
if (firstOrder is null)
{
    logger.LogWarning(&#34;Could not find an order for customer {CustomerId}&#34;, customerId);
    return;
}

firstOrder.OrderNumber = GenerateNewOrderNumber();</code></pre><p>This code makes it much easier to determine why an order number was not assigned, simply by reviewing the application logs.</p><h2 id="conclusion">Conclusion</h2><p>The new null-conditional assignment operator is a convenient feature coming in C# 14. It lets you avoid nesting assignments inside <code>if</code> statements, making your code easier to read. However, keep in mind the limitation of not supporting <code>++</code> and <code>--</code> operators, and try not to overuse the new operator.</p><p>This is just <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14?ref=blog.ivankahl.com">one of several enhancements being introduced with C# 14</a>. When you do update your projects to .NET 10, which is the next LTS version of the SDK, consider how you can take advantage of these quality-of-life improvements to neaten your codebase.</p>
    </div></div>
  </body>
</html>
