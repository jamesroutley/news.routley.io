<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/954787/41470c731eda02a4/">Original</a>
    <h1>Progress toward a GCC-based Rust compiler</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 1 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>

<p>
The <a href="https://rust-gcc.github.io/">gccrs</a> project is an ambitious
effort started in 2014 to implement a Rust compiler within The GNU Compiler
Collection (GCC).  Even though the task is far from complete, progress has
been made since LWN&#39;s <a href="https://lwn.net/Articles/909887/">previous coverage</a>,
according to reports from the project.  Meanwhile, another hybrid and more
mature approach to GCC Rust code generation is available in <a href="https://github.com/rust-lang/rustc_codegen_gcc"><tt>rustc_codegen_gcc</tt></a>.

</p><p>
In 2022, the goal of gccrs was to be included in the GCC 13 release,
but <a href="https://rust-gcc.github.io/2023/04/24/gccrs-and-gcc13-release.html">this expectation has not been met</a>.
The team is currently aiming for inclusion in GCC 14 (likely to be
released by mid-2024), judging from its
<a href="https://rust-gcc.github.io/2023/12/05/2023-11-monthly-report.html">November
2023 monthly report</a>.

</p><p>
On October 13, Arthur Cohen gave a talk titled &#34;The road to compiling the
standard library with gccrs&#34; (the <a href="https://www.youtube.com/watch?v=WgqGahDl-sY">video</a> is available)
at EuroRust 2023.  In his talk, Cohen gave a little bit of general
background on gccrs but mainly focused on what work has recently gone into
compiling the Rust standard library, and why gccrs cannot do it yet.

</p><p>
Gccrs targets a specific Rust version, <a href="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html">1.49,
released at the end of 2020</a>, rather than trying to keep up with the
rapidly developing Rust language.  This version was chosen because it is
the latest version predating support for <a href="https://doc.rust-lang.org/reference/items/generics.html#const-generics">const
generics</a>, which were introduced in 1.50.  However, Cohen expressed
regret in his talk that the project has not been able to ignore const
generics after all, because they are in use in the standard library, even in
1.49.  They were &#34;stabilized&#34; for general availability in 1.50, but there
is internal standard library usage in earlier versions as well.  Const
generics have since been fully implemented, however, and this issue is no
longer a hindrance.

</p><p>
A lot of care is being put into gccrs not becoming a &#34;superset&#34; of Rust, as
Cohen put it.  The project wants to make sure that it does not create a
special &#34;GNU Rust&#34; language, but is trying instead to replicate the output of
rustc — bugs, quirks, and all.  Both the Rust and GCC test suites
are being used to accomplish this.

</p><p>
The Rust standard library consists of a number of &#34;crates&#34;, which is what
software packages are called in Rust lingo.  Cohen explained that gccrs is
working on supporting compilation of the two most important ones: <a href="https://doc.rust-lang.org/core/"><tt>core</tt></a> and <a href="https://doc.rust-lang.org/alloc/"><tt>alloc</tt></a>.  The
<tt>core</tt> crate is the foundation of the standard library, implementing
features such as primitive types and macros; <tt>alloc</tt> deals with
heap-memory allocation and various container types.

</p><p>
Currently gccrs is not able to compile these crates because of various
shortcomings, such as incorrect behavior in macro-name resolution and
incomplete support for decorator macros.  The lack of a borrow checker
(discussed more below), while not blocking compilation, means that the
compiler cannot properly check the safety of the code.  An additional
hurdle is formed by missing compiler intrinsics in GCC. Rustc uses some
intrinsics provided by LLVM that are not supported by GCC, which means the
gccrs team needs to spend time implementing them in GCC.

</p><p>
Another talk (<a href="https://gcc.gnu.org/wiki/cauldron2023talks?action=AttachFile&amp;do=view&amp;target=GCC+Rust+Update.pdf">slides
available</a>) was given by Pierre-Emmanuel Patry at the GNU Tools Cauldron
in September 2023.  He mainly focused on progress toward inclusion in GCC
14 as well as macros, which seem to be an interrelated issue because the
approach to implement procedural macros necessitates changes to the GCC
build system.  <a href="https://doc.rust-lang.org/reference/procedural-macros.html">Procedural
macros</a> are function-like macros that emit token streams rather than
plain source code text like C or C++ macros.  They are implemented in a
built-in crate called <a href="https://doc.rust-lang.org/proc_macro/"><tt>proc_macro</tt></a>.  Such
macros are notoriously tricky to implement but also powerful; they form the
core of features such as <tt>#[attribute]</tt> and <tt>#[derive()]</tt>
decorators, and can be used to create compile-time evaluated,
domain-specific languages.

</p><p>
In the GNU Cauldron talk, Patry also mentioned that gccrs had more than 800
commits waiting to be upstreamed to GCC.

</p><h4>Taking advantage of the GCC ecosystem</h4>

<p>
Cohen&#39;s EuroRust talk highlighted that one of the major reasons gccrs is
being developed is to be able to take advantage of GCC&#39;s security plugins.
There is a wide range of existing GCC plugins that can aid in debugging,
static analysis, or hardening; these work on the GCC intermediate
representation.  Gccrs intends to support workflows where developers could
reuse these plugins with Rust code.  As an example, Cohen mentioned that &#34;C
programmers have been forgetting to close their file descriptors for 40
years, [so] there are a lot of plugins to catch that&#34;.  Gccrs intends to
enable Rust programmers to use existing GCC plugins and static analyzers to
catch bugs in <tt>unsafe</tt> code.

</p><p>
Cohen listed a few things that gccrs is already useful for.
According to him, the Sega Dreamcast homebrew community uses gccrs to
create new games for the Dreamcast gaming console, and GCC
plugins can already be used to perform static analysis on unsafe Rust code.
The Dreamcast community&#39;s interest stems from the fact that rustc&#39;s LLVM
backend does not support the Hitachi SH-4 architecture of the console,
whereas GCC does; even in its incomplete state, gccrs is helpful for this
embedded use case.


</p><p>
Additionally, he mentioned that the gccrs effort has revealed some
unspecified language features, such as <tt>Deref</tt> and macro name
resolution; in response, the project has been able to contribute additions
to the Rust specification.  Currently Rust does not have a formal
specification, but work is underway to create one, as proposed in <a href="https://rust-lang.github.io/rfcs/3355-rust-spec.html">RFC 3355</a>.
&#34;The gccrs people want to be a part&#34; of that effort, Cohen
said.

</p><p>
One more reason for gccrs to exist is <a href="https://rust-for-linux.com/">Rust for Linux</a>, the initiative to
add Rust support to the Linux kernel.  Cohen said the
Linux kernel is a key motivator for the project because there are a lot of
kernel people who would prefer the kernel to be compiled only by the GNU
toolchain.

</p><h4>Things under development</h4>

<p>
Gccrs is still missing a lot of core functionality.  Cohen listed several
important features, such as <tt>async</tt>/<tt>await</tt>, LLVM intrinsics
that are absent in GCC, and the <tt>format_args!()</tt> macro used by
output macros such as <tt>println!()</tt>.  The borrow checker, which is a
compiler subsystem that enforces the reference rules of the language, is a
key Rust feature that gccrs will need to provide.  Cohen briefly mentioned
that the likely solution is a separate borrow-checker project called <a href="https://github.com/rust-lang/polonius">Polonius</a>, and said Gccrs
will most likely have it integrated a few months down the line.
Contributor Jakub Dupak has <a href="https://rust-gcc.github.io/2023/11/06/2023-10-monthly-report.html">made
progress</a> on this in the past few months.

</p><p>
Polonius is a library that implements a borrow checker that is semantically
equivalent to the (not quite flawlessly implemented) checker in rustc today,
by approaching the computation of reference lifetimes with <a href="https://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/">a
radically different algorithm</a>.  Polonius aims to one day resolve the
shortcomings and corner cases of rustc&#39;s current borrow checker.  Once it
has matured, rustc itself will likely also adopt it in the future.

</p><p>
According to the gccrs monthly report for November 2023, work has begun on
the <tt>format_args!()</tt> macro.  This helper macro is responsible for
constructing parameters for other string-formatting macros.  It involves
the <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><tt>Display</tt></a>
and <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><tt>Debug</tt></a>
traits, and is a necessity for preparing arguments that are later passed to
other macros such as <tt>format!()</tt> and <tt>println!()</tt>.  Without
<tt>format_args!()</tt>, a Rust program cannot create formatted output;
this feature is thus necessary before gccrs can compile a &#34;Hello, World&#34;
program.

</p><p>
For a deep dive on <tt>format_args!()</tt>, see Mara Bos&#39;s recent <a href="https://blog.m-ou.se/format-args/">blog post</a>.

</p><h4><tt>rustc_codegen_gcc</tt></h4>

<p>
There is another GCC-based Rust project, called <tt>rustc_codegen_gcc</tt>,
that is more mature and more limited in scope compared to gccrs.  It is not
a full implementation of a Rust compiler from the ground up; instead, it
uses the <a href="https://gcc.gnu.org/wiki/JIT">libgccjit</a> library to
hook into an API of the LLVM backend used by rustc.  This approach performs
much of the compilation with rustc and turns to GCC at a later stage.
Despite the &#34;JIT&#34; (just in time) in the name of the library,
<tt>rustc_codegen_gcc</tt> is intended for ahead-of-time compilation.  Its
stated primary goal is to enable Rust code generation on platforms
unsupported by LLVM.

</p><p>
<a href="https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-26">As
of October 2023</a>, <tt>rustc_codegen_gcc</tt> can now compile Rust for
Linux without any additional patches.  Over the past year, the project
seems to have made good progress on many fronts; for example, it has added
support for SIMD (single instruction, multiple data) operations and
link-time optimization, both of which were earlier identified as causes for
test failures.  Cohen deferred to <tt>rustc_codegen_gcc</tt> at several
points in his EuroRust talk, encouraging attendees to use it instead of
gccrs for now.  It is, in fact, already upstreamed into the Rust language
repository.

</p><h4>Rust for Linux</h4>

<p>
Currently, the Rust for Linux project provides documentation for using
either <a href="https://docs.kernel.org/rust/quick-start.html">rustc</a> or
<a href="https://rust-for-linux.com/rustc_codegen_gcc"><tt>rustc_codegen_gcc</tt></a>
to build Rust code for the kernel.  The kernel also contains <a href="https://docs.kernel.org/process/changes.html">documentation</a> for
the minimal supported versions of various build tools, including compilers.
For rustc, the version is considered an exact match, rather than a minimum.
The currently stated supported rustc version is 1.73.0 (released in October
2023), much more recent than the 1.49 targeted by gccrs.  Rust for Linux
support is also a stated goal for gccrs, but because of this significant
discrepancy, it seems to be quite far off.

</p><p>
Gccrs has progressed nicely in the year since we last looked at it: the
repository has well over 3,000 commits since January 1, 2023.
However, it is not yet in a usable state for almost any practical purpose,
since as a complete implementation from the ground up, gccrs is much more
ambitious in scope than <tt>rustc_codegen_gcc</tt>.  The latter is already
merged to the upstream Rust repository and sees real-world use with Rust
for Linux.  We are not yet in a world with multiple implementations of a
compiler for the Rust language, but it is getting closer.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Archives/GuestIndex/">GuestArticles</a></td><td><a href="https://lwn.net/Archives/GuestIndex/#Koistinen_Ronja">Koistinen, Ronja</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
