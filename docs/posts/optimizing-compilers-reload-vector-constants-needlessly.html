<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/12/06/optimizing-compilers-reload-vector-constants-needlessly/">Original</a>
    <h1>Optimizing compilers reload vector constants needlessly</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Modern processors have powerful vector instructions which allow you to load several values at once, and operate (in one instruction) on all these values. Similarly, they allow you to have vector constants. Thus if you wanted to add some integer (say 10001) to all integers in a large array, you might first load a constant with 8 times the value 10001, then you would load elements from your array, 8 elements by 8 elements, add the vector constant (thus do 8 additions at once), and then store the result. Everything else being equal, this might be 8 times faster.</p>
<p>An optimizing compiler might even do this optimization for you (a process called ‘auto-vectorization). However, for more complex code, you might need to do it manually using “intrinsic” functions (e.g., _mm256_loadu_si256, _mm256_add_epi32, etc.).</p>
<p>Let us consider the simple case I describe, but where we process two arrays at once… using the same constant:</p>
<pre><span>#</span><span>include </span><span>&lt;</span><span>x86intrin.h</span><span>&gt;</span>
<span>#</span><span>include </span><span>&lt;</span><span>stdint.h</span><span>&gt;</span>
<span>void</span> process_avx2<span>(</span><span>const</span> uint32_t <span>*</span>in1<span>,</span> <span>const</span> uint32_t <span>*</span>in2<span>,</span> <span>size_t</span> len<span>)</span> <span>{</span>
  <span>// define the constant, 8 x 10001</span>
  __m256i c <span>=</span> _mm256_set1_epi32<span>(</span><span>10001</span><span>)</span><span>;</span>
  <span>const</span> uint32_t <span>*</span>finalin1 <span>=</span> in1 <span>+</span> len<span>;</span>
  <span>const</span> uint32_t <span>*</span>finalin2 <span>=</span> in2 <span>+</span> len<span>;</span>
  <span>for</span> <span>(</span><span>;</span> in1 <span>+</span> <span>8</span> <span>&lt;</span><span>=</span> finalin1<span>;</span> in1 <span>+</span><span>=</span> <span>8</span><span>)</span> <span>{</span>
    <span>// load 8 integers into a 32-byte register</span>
    __m256i x <span>=</span> _mm256_loadu_si256<span>(</span><span>(</span>__m256i <span>*</span><span>)</span>in1<span>)</span><span>;</span>
    <span>// add the 8 integers just loaded to the 8 constant integers</span>
    x <span>=</span> _mm256_add_epi32<span>(</span>c<span>,</span> x<span>)</span><span>;</span>
    <span>// store the 8 modified integers</span>
    _mm256_storeu_si256<span>(</span><span>(</span>__m256i <span>*</span><span>)</span>in1<span>,</span> x<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  <span>for</span> <span>(</span><span>;</span> in2 <span>+</span> <span>8</span> <span>&lt;</span><span>=</span> finalin2<span>;</span> in2 <span>+</span><span>=</span> <span>8</span><span>)</span> <span>{</span>
    <span>// load 8 integers into a 32-byte register</span>
    __m256i x <span>=</span> _mm256_loadu_si256<span>(</span><span>(</span>__m256i <span>*</span><span>)</span>in2<span>)</span><span>;</span>
    <span>// add the 8 integers just loaded to the 8 constant integers</span>
    x <span>=</span> _mm256_add_epi32<span>(</span>c<span>,</span> x<span>)</span><span>;</span>
    <span>// store the 8 modified integers</span>
    _mm256_storeu_si256<span>(</span><span>(</span>__m256i <span>*</span><span>)</span>in2<span>,</span> x<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</pre>
<p>My expectation, until recently, was that optimizing compilers would  keep the constant in a register, and never load it twice. Why would they?</p>
<p>Yet you can check that <a href="https://godbolt.org/z/G3z1qPG8M">GCC loads the constant twice</a>. You will recognize the assembly sequence:</p>
<pre>mov          eax, 10001 // load 10001 in a general register
vpbroadcastd ymm1, eax  // broadcast 10001 to all elements
</pre>
<p>In  this instance, other compilers (like LLVM) do better. However, in other instances, both LLVM and GCC happily <a href="https://godbolt.org/z/Gs3che1ds">load constants more than once</a>. Only the Intel compiler (ICC) seems to be able to avoid this issue with some consistency.</p>
<p>The processor has more than enough vector registers, so it is not a register allocation issue. Of course, there are instances where it is  best to avoid creating the constant, but you can check that even when the compiler ought to know that the constant is always needed, it may still create it twice. AVX-512 has introduced new mask types and they suffer from this effect as well.</p>
<p>Does it matter? In most cases, this effect should have little performance impact. It is almost surely only a few instructions of overhead per function.</p>
<p>It would be interesting to be able to instruct the compiler not to do reload the constants. You might think that the static keyword could help, but with LLVM, static vector variables may be protected by a lock, which probably makes your code even heavier.</p>

</div></div>
  </body>
</html>
