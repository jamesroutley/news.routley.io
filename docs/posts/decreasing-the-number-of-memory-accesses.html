<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnnysswlab.com/decreasing-the-number-of-memory-accesses-1-2/">Original</a>
    <h1>Decreasing the number of memory accesses</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>We at <strong>Johnny’s Software Lab LLC</strong> are experts in performance. If performance is in any way concern in your software project, feel free to <a href="https://johnnysswlab.com/contact/">contact us</a>.</em></p><p>When we are trying to speed up a memory-bound loop, there are several different paths. We could try decreasing the <a href="https://johnnysswlab.com/memory-consumption-dataset-size-and-performance-how-does-it-all-relate/" target="_blank" rel="noreferrer noopener">dataset size</a>. We could try increasing available <a href="https://johnnysswlab.com/instruction-level-parallelism-in-practice-speeding-up-memory-bound-programs-with-low-ilp/">instruction level parallelism</a>. We could try modifying the <a href="https://johnnysswlab.com/for-software-performance-the-way-data-is-accessed-matters/" target="_blank" rel="noreferrer noopener">way we access data</a>.  Some of these techniques are very advanced. But sometimes we should start with the basics.</p><p>One of the ways to improve on memory boundness of a certain piece of code is the old-fashioned way: decrease the total number of memory accesses (loads or stores). Once a piece of data is in the register, using it is very cheap, to the point of being free (due to CPU’s ability to execute up to 4 instructions in a single cycle and their out-of-order nature). So all techniques that try to lower the total number of loads and stores should result in speedups.</p><h2>Techniques</h2><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><h3>Loop Fusion</h3><p>If we have two consecutive loops that operate on the same dataset, fusing them into one loop would decrease the number of memory loads and stores and consequently improve performance. This transformation is called <em>loop fusion</em> or <em>loop jamming</em>. Consider the example of finding a minimum and maximum in an array. One of the ways to do it is using two separate loops:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">double min = a[0];

for (int i = 1; i &lt; n; i++) {
    if (a[i] &lt; min) { min = a[i] };
}

double max = a[0];

for (int i = 1; i &lt; n; i++) {
    if (a[i] &gt; max) { max = a[i] };
}
</pre><p>Both loops touch process the same dataset. We could merge the two loops into one loop that finds both minimum and maximum. This cuts the number of data loads by two.</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">double min = a[0];
double max = a[0];

for (int i = 1; i &lt; n; i++) {
    if (a[i] &lt; min) { min = a[i] };
    if (a[i] &gt; max) { max = a[i] };
}</pre><p>We measure the effect of loop fusion in the experiments section.</p><p>A few notes about loop fusion:</p><ul><li><em>Loop fusion is also a compiler optimization technique</em>, so in theory the compiler can do it automatically. But this doesn’t happen often and when it does happen, this optimization has a tendency to break easily.</li><li>With regard to loop fusion, <em>there are cases where loop fusion would fail to deliver speed improvements</em>. If one or both loops are <a href="https://johnnysswlab.com/crash-course-introduction-to-parallelism-simd-parallelism/" target="_blank" rel="noreferrer noopener">vectorized</a> before the fusion, but the fused loop is not vectorized, then this transformation can result in a slowdown, not a speedup.</li><li><em>Loop fusion is a close relative of <a href="https://johnnysswlab.com/for-software-performance-the-way-data-is-accessed-matters/#sectioning" target="_blank" rel="noreferrer noopener">loop sectioning</a></em>. The main difference is that loop fusion reuses the data while it is in registers, whereas loop sectioning reuses the data while it is in fast data caches. Therefore, a loop fusion is more memory efficient that loop sectioning, but fusing two loops is more complex than sectioning two loops. Also, preserving vectorization is easier with loop sectioning.</li></ul><h4>C++ Ranges</h4><p>For folks using C++ STL algorithms, it is important to be aware of C++ ranges. The original STL library contains many algorithms, but they are not composable. Composability means that the result of one algorithm is fed into another algorithm. Consider the example<sup><a href="#footnote_0_2816" id="identifier_0_2816" title="Taken from here">1</a></sup>:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">struct user_t {
   int id;
   std::string name;
   int age;
};

std::vector&lt;int&gt; get_ids_adult_users(std::vector&lt;user_t&gt;&amp; users) {
    std::vector&lt;user_t&gt; adult_users;
    std::copy_if(std::cbegin(users), std::cend(users), std::back_inserter(adult_users), [](auto const&amp; user) { return user.age &gt;= 18; });
    std::vector&lt;int&gt; ids;
    std::transform(std::cbegin(adult_users), std::cend(adult_users), std::back_inserter(ids), [](auto const&amp; user){ return user.id; });
    return ids;
}</pre><p>The function <code>get_ids_adult_users</code> returns the vector containing the <code>id</code>s of all the users who are adults, i.e. whose age is 18 or more. To achieve this using STL, we use two algorithms: <code>std::copy_if</code> which filters out the minor users to create the list of adult users and <code>std::transform</code> to extract only ids from the vector of <code>user_t</code> class.</p><p>This approach forces the code to iterate the two collections instead of one: the first collection is the original collection of users, and the second collection is the temporary collection holding adult users. To avoid this, C++ developers have <em>STL ranges</em> at their disposal. Here is the same example rewritten using ranges:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::vector&lt;int&gt; get_ids_adult_users(std::vector&lt;user_t&gt;&amp; users) {
    auto ids = users | std::views::filter([](auto const&amp; user){ return user.age &gt;= 18; })
                     | std::views::transform([](auto const&amp; user){ return user.id; });
    return {ids.begin(), ids.end()}
}</pre><p>This code, apart from being cleaner, also performs fewer memory loads and memory stores. The filter adapter performs the filtering, and the result of filtering is directly fed into the transform adapter, element by element. This avoids running through the vector two times, and it is equivalent to loop fusion.</p><h4>Kernel Fusion</h4><p><em>Kernel Fusion</em> is just loop fusion brought to a much higher level. Consider the following: imagine you have N image processing algorithms making an image processing pipeline. The output of algorithm X is the input of algorithm X+1. One of the ways to implement the pipeline is to have them run one after another, from zero to N-1. Each algorithm must finish before the next one starts.</p><p>With this kind of setup, processing an image will often be memory inefficient. The whole image is loaded from the slower parts of the memory subsystem to CPU registers, processed, then the output is written back to the memory subsystem. And this is repeated for each algorithm in the pipeline: load input, do some modifications, store output.</p><p>In this example, each algorithm is a <em>kernel</em>. And by kernel fusion, we mean that two algorithms are fused. An algorithm X generates a single pixel, and feeds it directly to the algorithm X + 1, then to the algorithm X + 2, etc. The benefit of such an approach is that all relevant data never leaves the CPU, which avoids unnecessary data movements.</p><p>However, there are two problems with this approach:</p><ul><li>Writing such a processing pipeline is not easy, and this task needs to be planned from day one. In fact, there is a special programming language, <em>Halide</em>, that is designed for writing fast and portable image and tensor processing codes.</li><li>The types of algorithms that would benefit from this approach must be memory bound, i.e. light in computation. Algorithms that are computationally intensive would benefit little or not at all, because computational bottleneck will hide the memory latency.</li></ul><p>If you happen to know more about this topic, please leave a comment or send me an e-mail, I would like to know more as well (and also keep this post updated).</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><h4>Loop Fusion inside a Loop Nest</h4><p>Loop fusion inside a loop nest (also called <em>unroll-and-jam</em>) is a more advanced type of loop fusion, applicable to loop nests. The technique is simple to apply to many sorting algorithms, but not only them. Consider the selection sort algorithm. Here is the source code:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">for (int i = 0; i &lt; n; i++) {
    double min = a[i];
    int index_min = i;
    for (int j = i + 1; j &lt; n; j++) {
        if (a[j] &lt; min) {
            min = a[j];
            index_min = j;
        }
    }

    std::swap(a[i], a[index_min]);
}</pre><p>The algorithm is very simple: in the <code>i</code>-th iteration, it scans the elements from <code>i</code> to <code>n</code> to find the smallest value, and puts the value in place <code>a[i]</code>.</p><p>For loop fusion inside a loop nest, we need to unroll the outer loop two or more times to make the fusion potential explicit. Here is the selection sort algorithm, where the outer loop has been unrolled two times:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">for (int i = 0; i &lt; n; i+=2) {
    min = a[i];
    index_min = i;
    for (int j = i + 1; j &lt; n; j++) {
        if (a[j] &lt; min) {
            min = a[j];
            index_min = j;
        }
    }

    std::swap(a[i], a[index_min]);

    min = a[i + 1];
    index_min = i + 1;
    for (int j = i + 2; j &lt; n; j++) {
        if (a[j] &lt; min) {
            min = a[j];
            index_min = j;
        }
    }

    std::swap(a[i + 1], a[index_min]);
}</pre><p>The first and second inner loops are iterating over almost identical datasets. There are a few statements preventing a simple loop fusion, but they can be moved away. With some tricks, we fused together the two inner loops. Here is the result:</p><pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">for (int i = 0; i &lt; n; i+=2) {
    min_1 = a[i];
    min_2 = a[i + 1];
    index_min_1 = i;
    index_min_2 = i + 1;

    // min1 must be smaller than min2
    // Swap two values if not true
    if (min2 &lt; min1) {
        std::swap(min1, min2);
        std::swap(index_min_1, index_min_2);
    }

    // Look-up two smallest values in array.
    // The smaller is kept in min1, the larger
    // in min2.
    for (int j = i + 2; j &lt; n; j++) {
        if (a[j] &lt; min_2) {
            if (a[j] &lt; min_1) {
                min_2 = min_1;
                index_min_2 = index_min_1;
                min_1 = a[j];
                index_min_1 = j;
            } else {
                min_2 = a[j];
                index_min_2 = j;
            }
        }
    }

    std::swap(a[i], a[index_min_1]);
    std::swap(a[i + 1], a[index_min_2]);
}</pre><p>The loop fusion in this case is not trivial, but it is possible. The inner loop is looking up the two smallest values in the array to put them into the beginning of the section currently being processed. The total number of memory accesses is about two times lower compared to the simple selection sort algorithm.</p><p>Note: This optimization closely resembles <em><a href="https://johnnysswlab.com/vectorization-dependencies-and-outer-loop-vectorization-if-you-cant-beat-them-join-them/" target="_blank" rel="noreferrer noopener">outer loop vectorization</a></em>, where the outer loop is running several instances of the inner loop in parallel.</p><h3 id="decrease">Decreasing the Number of Data Passes by Doing More Work</h3><p>As we have seen in previous examples, loop fusion allows the elimination of some memory accesses by fusing two neighboring loops running over the same data. But this is not the only way. Many ideas that decrease the number of data passes will result in fewer memory accesses and better performance.</p><p>Consider the simple selection sort algorithm from the previous section. The original algorithm was looking for the minimum in the remaining array. To decrease the number of total memory accesses, we could scan for both minimum and maximum. We would  then put the minimum element at the beginning of the remaining array and the maximum element at its end. The algorithm looks like this:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">for (int i = 0, j = n - 1; i &lt; j; i++, j--) {
    double min = a[i];
    int index_min = i;
    double max = a[j];
    int index_max = j;
    for (int k = i; k &lt; j; k++) {
        if (a[k] &lt; min) {
            min = a[k];
            index_min = k;
        }
        if (a[k] &gt; max) {
            max = a[k];
            index_max = k;
        }
    }

    std::swap(a[i], a[index_min]);

    if (a[index_min] != max) {
        std::swap(a[j], a[index_max];
    } else {
        std::swap(a[j], a[index_min]);
    }
}</pre><p>This version has fewer iterations, and therefore fewer memory loads, but inside each iteration it does twice as much work. From the algorithmic point of view, it performs roughly the same number of operations as the first version. But, performance-wise it is more efficient. In the experiments section we will see how much efficient.</p><p>Another important algorithm with a similar reduction in memory accesses is a variant of <a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noreferrer noopener">Quicksort</a> called <a href="https://cs.uwaterloo.ca/~skushagr/multipivotQuicksort.pdf" target="_blank" rel="noreferrer noopener">Multi-Pivot Quicksort</a>. Before explaining MPQ, let’s give a quick reminder about Quicksort. The Quicksort algorithm consists of two steps. The first step is array partitioning: picking a pivot and then partitioning the array into a left part that is smaller than the pivot and a right part that is larger. The second step is the recursive call: the partitioning is performed recursively on the left and right part of the input array, until the size of the array becomes 1.</p><div><figure><img decoding="async" width="703" height="312" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20703%20312%22%3E%3C/svg%3E" data-src="https://johnnysswlab.com/wp-content/uploads/image-10.png" alt="" data-srcset="https://johnnysswlab.com/wp-content/uploads/image-10.png 703w, https://johnnysswlab.com/wp-content/uploads/image-10-300x133.png 300w" data-sizes="(max-width: 703px) 100vw, 703px"/><figcaption>Recursive array partitioning in Quicksort<sup><a href="#footnote_1_2816" id="identifier_1_2816" title="Source">2</a></sup></figcaption></figure></div><p>With Multi-Pivot Quicksort, the partitioning step is performed by picking two pivots and partitioning the array into three parts. Then partitioning is recursively performed on the left, middle and right part of the array. If an array has N elements, with plain Quicksort we expect an average number of memory accesses for each element of the array to be O(log<sub>2</sub> N). With Multi-Pivot Quicksort, the average number of memory accesses would be O(log<sub>3</sub> N).</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><h2>Experiments</h2><p>All the experiments were executed on Intel Core i5-10210U CPU, 4 cores, 2 threads per core. Each core has 32kB of L1i cache, 32kB of L1d cache and 256kB of L2 cache. There is a total of 6MB of L3 cache shared by all the cores. The source code used for all experiments is available <a href="https://github.com/ibogosavljevic/johnysswlab/tree/master/2023-02-decreasememoryaccesses" target="_blank" rel="noreferrer noopener">here</a>.</p><h3>Loop Fusion</h3><p>The first experiment is related to loop fusion. We measure the runtime of two separate loops and compare it with the runtime of the fused loop. The examples we use for testing are loops that calculate the min and max, first in two separate loops, then merged.</p><p>Here are the runtimes (five repetitions, average values):</p><figure><table><thead><tr><th>Array Size</th><th>Original</th><th>Fused</th></tr></thead><tbody><tr><td>32 kB</td><td>Runtime: 0.159 s</td><td>Runtime: 0.068 s</td></tr><tr><td>256 kB</td><td>Runtime: 0.136 s</td><td>Runtime: 0.068 s</td></tr><tr><td>2 MB</td><td>Runtime: 0.136 s</td><td>Runtime: 0.068 s</td></tr><tr><td>16 MB</td><td>Runtime: 0.171 s</td><td>Runtime: 0.085 s</td></tr><tr><td>128 MB</td><td>Runtime: 0.175 s</td><td>Runtime: 0.086 s</td></tr></tbody></table></figure><p>The table shows, that, on average, the fused version is about two times faster than the original version. The fused version also executes less instruction and is more hardware efficient (Cycle per Instruction metric is better). Fewer instructions are executed because (1) there is only one loop instead of two, so this means fewer iterator increases, iterator comparisons, jumps and (2) removed one redundant load, since the piece of data is already in a register.</p><h3>Selection Sort</h3><p>We are going to experiment with selection sort, as described in the section about <a href="#decrease">decreasing the number of data passes</a>. To measure the effect we will compare the version of the selection sort where we are finding minimum only vs the version where we are finding both minimum and maximum. The first version scans the remaining part of the array to find the minimum and put it at the beginning. The second version scans to find both the minimum and maximum, and places them at the beginning and at the end of the array respectively. We expect the second version to be faster because it needs to perform two times fewer scans.</p><p>Here are the numbers (five runs, average numbers):</p><figure><table><thead><tr><th>Array Size</th><th>Only Min</th><th>Min and Max</th></tr></thead><tbody><tr><td>8 kB</td><td>Runtime: 8.74 s</td><td>Runtime: 4.44 s</td></tr><tr><td>32 kB</td><td>Runtime: 8.72 s</td><td>Runtime:  4.36 s</td></tr><tr><td>128 kB</td><td>Runtime: 8.69 s</td><td>Runtime: 4.37 s</td></tr><tr><td>512 kB</td><td>Runtime: 8.69 s</td><td>Runtime: 4.39 s</td></tr></tbody></table></figure><p>The Min and Max version is both faster and more hardware efficient in all cases. It also executes fewer instructions, because both the inner and the outer loops are shorter, so they perform fewer memory accesses.</p><h2>Conclusion</h2><p>Loop fusion is a simple and powerful technique to decrease the total number of memory accesses in the program. Although we described here the simplest version, loop fusion is possible even if datasets overlap partially.</p><p>In general, any idea that would result in a decrease of memory accesses has the potential to speed up your code. If you have any ideas that are not mentioned in this post, feel free to leave a comment so we can update this post.</p><p>In the next post we will talk about another way to decrease the total number of memory accesses. These memory accesses are “unwanted”, in the sense that the compiler has created them without your intention: memory accesses related to pointer aliasing and memory accesses related to register spilling. Until soon!</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><ol><li id="footnote_0_2816">Taken from <a href="https://code.egym.de/composing-stl-algorithms-with-ranges-a4589e7e61f9" target="_blank" rel="noreferrer noopener">here</a><span> [<a href="#identifier_0_2816">↩</a>]</span></li><li id="footnote_1_2816"><a href="https://www.geeksforgeeks.org/quick-sort/">Source</a><span> [<a href="#identifier_1_2816">↩</a>]</span></li></ol></div></div>
  </body>
</html>
