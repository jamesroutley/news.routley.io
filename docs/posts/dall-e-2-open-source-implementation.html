<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/lucidrains/DALLE2-pytorch">Original</a>
    <h1>DALL-E 2 open source implementation</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/lucidrains/DALLE2-pytorch/blob/main/dalle2.png"><img src="https://github.com/lucidrains/DALLE2-pytorch/raw/main/dalle2.png" width="450px"/></a></p>
<h2 dir="auto"><a id="user-content-dall-e-2---pytorch" aria-hidden="true" href="#dall-e-2---pytorch"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DALL-E 2 - Pytorch</h2>
<p dir="auto">Implementation of <a href="https://openai.com/dall-e-2/" rel="nofollow">DALL-E 2</a>, OpenAI&#39;s updated text-to-image synthesis neural network, in Pytorch.</p>
<p dir="auto"><a href="https://youtu.be/RJwPN4qNi_Y?t=555" rel="nofollow">Yannic Kilcher summary</a> | <a href="https://www.youtube.com/watch?v=F1X4fHzF4mQ" rel="nofollow">AssemblyAI explainer</a></p>
<p dir="auto">The main novelty seems to be an extra layer of indirection with the prior network (whether it is an autoregressive transformer or a diffusion network), which predicts an image embedding based on the text embedding from CLIP. Specifically, this repository will only build out the diffusion prior network, as it is the best performing variant (but which incidentally involves a causal transformer as the denoising network <g-emoji alias="joy" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png">ðŸ˜‚</g-emoji>)</p>
<p dir="auto">This model is SOTA for text-to-image for now.</p>
<p dir="auto">Please join <a href="https://discord.gg/xBPBXfcFHd" rel="nofollow"><img alt="Join us on Discord" src="https://camo.githubusercontent.com/6752f150c04aa4fb06db9d04d900329ef595a2376ea06860a1e834c89e5ab725/68747470733a2f2f696d672e736869656c64732e696f2f646973636f72642f3832333831333135393539323030313533373f636f6c6f723d353836354632266c6f676f3d646973636f7264266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/discord/823813159592001537?color=5865F2&amp;logo=discord&amp;logoColor=white"/></a> if you are interested in helping out with the replication</p>
<p dir="auto">There was enough interest for a <a href="https://github.com/lucidrains/dalle2-jax">Jax version</a>. I will also eventually extend this to <a href="https://github.com/lucidrains/dalle2-video">text to video</a>, once the repository is in a good place.</p>
<h2 dir="auto"><a id="user-content-install" aria-hidden="true" href="#install"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Install</h2>
<div data-snippet-clipboard-copy-content="$ pip install dalle2-pytorch"><pre>$ pip install dalle2-pytorch</pre></div>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">To train DALLE-2 is a 3 step process, with the training of CLIP being the most important</p>
<p dir="auto">To train CLIP, you can either use <a href="https://github.com/lucidrains/x-clip">x-clip</a> package, or join the LAION discord, where a lot of replication efforts are already <a href="https://github.com/mlfoundations/open_clip">underway</a>.</p>
<p dir="auto">This repository will demonstrate integration with <code>x-clip</code> for starters</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import CLIP

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 1,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 1,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8,
    use_all_token_embeds = True,            # whether to use fine-grained contrastive learning (FILIP)
    decoupled_contrastive_learning = True,  # use decoupled contrastive learning (DCL) objective function, removing positive pairs from the denominator of the InfoNCE loss (CLOOB + DCL)
    extra_latent_projection = True,         # whether to use separate projections for text-to-image vs image-to-text comparisons (CLOOB)
    use_visual_ssl = True,                  # whether to do self supervised learning on images
    visual_ssl_type = &#39;simclr&#39;,             # can be either &#39;simclr&#39; or &#39;simsiam&#39;, depending on using DeCLIP or SLIP
    use_mlm = False,                        # use masked language learning (MLM) on text (DeCLIP)
    text_ssl_loss_weight = 0.05,            # weight for text MLM loss
    image_ssl_loss_weight = 0.05            # weight for image self-supervised learning loss
).cuda()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# train

loss = clip(
    text,
    images,
    return_loss = True              # needs to be set to True to return contrastive loss
)

loss.backward()

# do the above with as many texts and images as possible in a loop"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>CLIP</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>1</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>1</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>,
    <span>use_all_token_embeds</span> <span>=</span> <span>True</span>,            <span># whether to use fine-grained contrastive learning (FILIP)</span>
    <span>decoupled_contrastive_learning</span> <span>=</span> <span>True</span>,  <span># use decoupled contrastive learning (DCL) objective function, removing positive pairs from the denominator of the InfoNCE loss (CLOOB + DCL)</span>
    <span>extra_latent_projection</span> <span>=</span> <span>True</span>,         <span># whether to use separate projections for text-to-image vs image-to-text comparisons (CLOOB)</span>
    <span>use_visual_ssl</span> <span>=</span> <span>True</span>,                  <span># whether to do self supervised learning on images</span>
    <span>visual_ssl_type</span> <span>=</span> <span>&#39;simclr&#39;</span>,             <span># can be either &#39;simclr&#39; or &#39;simsiam&#39;, depending on using DeCLIP or SLIP</span>
    <span>use_mlm</span> <span>=</span> <span>False</span>,                        <span># use masked language learning (MLM) on text (DeCLIP)</span>
    <span>text_ssl_loss_weight</span> <span>=</span> <span>0.05</span>,            <span># weight for text MLM loss</span>
    <span>image_ssl_loss_weight</span> <span>=</span> <span>0.05</span>            <span># weight for image self-supervised learning loss</span>
).<span>cuda</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># train</span>

<span>loss</span> <span>=</span> <span>clip</span>(
    <span>text</span>,
    <span>images</span>,
    <span>return_loss</span> <span>=</span> <span>True</span>              <span># needs to be set to True to return contrastive loss</span>
)

<span>loss</span>.<span>backward</span>()

<span># do the above with as many texts and images as possible in a loop</span></pre></div>
<p dir="auto">Then, you will need to train the decoder, which learns to generate images based on the image embedding coming from the trained CLIP above</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import Unet, Decoder, CLIP

# trained clip from step 1

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 1,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 1,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8
).cuda()

# unet for the decoder

unet = Unet(
    dim = 128,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults=(1, 2, 4, 8)
).cuda()

# decoder, which contains the unet and clip

decoder = Decoder(
    unet = unet,
    clip = clip,
    timesteps = 100,
    image_cond_drop_prob = 0.1,
    text_cond_drop_prob = 0.5
).cuda()

# mock images (get a lot of this)

images = torch.randn(4, 3, 256, 256).cuda()

# feed images into decoder

loss = decoder(images)
loss.backward()

# do the above for many many many many steps
# then it will learn to generate images based on the CLIP image embeddings"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>Unet</span>, <span>Decoder</span>, <span>CLIP</span>

<span># trained clip from step 1</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>1</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>1</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># unet for the decoder</span>

<span>unet</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>128</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span><span>=</span>(<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>)
).<span>cuda</span>()

<span># decoder, which contains the unet and clip</span>

<span>decoder</span> <span>=</span> <span>Decoder</span>(
    <span>unet</span> <span>=</span> <span>unet</span>,
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>image_cond_drop_prob</span> <span>=</span> <span>0.1</span>,
    <span>text_cond_drop_prob</span> <span>=</span> <span>0.5</span>
).<span>cuda</span>()

<span># mock images (get a lot of this)</span>

<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># feed images into decoder</span>

<span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>)
<span>loss</span>.<span>backward</span>()

<span># do the above for many many many many steps</span>
<span># then it will learn to generate images based on the CLIP image embeddings</span></pre></div>
<p dir="auto">Finally, the main contribution of the paper. The repository offers the diffusion prior network. It takes the CLIP text embeddings and tries to generate the CLIP image embeddings. Again, you will need the trained CLIP from the first step</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import DiffusionPriorNetwork, DiffusionPrior, CLIP

# get trained CLIP from step one

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 6,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 6,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8,
).cuda()

# setup prior network, which contains an autoregressive transformer

prior_network = DiffusionPriorNetwork(
    dim = 512,
    depth = 6,
    dim_head = 64,
    heads = 8
).cuda()

# diffusion prior network, which contains the CLIP and network (with transformer) above

diffusion_prior = DiffusionPrior(
    net = prior_network,
    clip = clip,
    timesteps = 100,
    cond_drop_prob = 0.2
).cuda()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# feed text and images into diffusion prior network

loss = diffusion_prior(text, images)
loss.backward()

# do the above for many many many steps
# now the diffusion prior can generate image embeddings from the text embeddings"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DiffusionPriorNetwork</span>, <span>DiffusionPrior</span>, <span>CLIP</span>

<span># get trained CLIP from step one</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>6</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>6</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>,
).<span>cuda</span>()

<span># setup prior network, which contains an autoregressive transformer</span>

<span>prior_network</span> <span>=</span> <span>DiffusionPriorNetwork</span>(
    <span>dim</span> <span>=</span> <span>512</span>,
    <span>depth</span> <span>=</span> <span>6</span>,
    <span>dim_head</span> <span>=</span> <span>64</span>,
    <span>heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># diffusion prior network, which contains the CLIP and network (with transformer) above</span>

<span>diffusion_prior</span> <span>=</span> <span>DiffusionPrior</span>(
    <span>net</span> <span>=</span> <span>prior_network</span>,
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>cond_drop_prob</span> <span>=</span> <span>0.2</span>
).<span>cuda</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># feed text and images into diffusion prior network</span>

<span>loss</span> <span>=</span> <span>diffusion_prior</span>(<span>text</span>, <span>images</span>)
<span>loss</span>.<span>backward</span>()

<span># do the above for many many many steps</span>
<span># now the diffusion prior can generate image embeddings from the text embeddings</span></pre></div>
<p dir="auto">In the paper, they actually used a <a href="https://cascaded-diffusion.github.io/" rel="nofollow">recently discovered technique</a>, from <a href="http://www.jonathanho.me/" rel="nofollow">Jonathan Ho</a> himself (original author of DDPMs, the core technique used in DALL-E v2) for high resolution image synthesis.</p>
<p dir="auto">This can easily be used within this framework as so</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import Unet, Decoder, CLIP

# trained clip from step 1

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 6,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 6,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8
).cuda()

# 2 unets for the decoder (a la cascading DDPM)

unet1 = Unet(
    dim = 32,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults = (1, 2, 4, 8)
).cuda()

unet2 = Unet(
    dim = 32,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults = (1, 2, 4, 8, 16)
).cuda()

# decoder, which contains the unet(s) and clip

decoder = Decoder(
    clip = clip,
    unet = (unet1, unet2),            # insert both unets in order of low resolution to highest resolution (you can have as many stages as you want here)
    image_sizes = (256, 512),         # resolutions, 256 for first unet, 512 for second. these must be unique and in ascending order (matches with the unets passed in)
    timesteps = 1000,
    image_cond_drop_prob = 0.1,
    text_cond_drop_prob = 0.5
).cuda()

# mock images (get a lot of this)

images = torch.randn(4, 3, 512, 512).cuda()

# feed images into decoder, specifying which unet you want to train
# each unet can be trained separately, which is one of the benefits of the cascading DDPM scheme

loss = decoder(images, unet_number = 1)
loss.backward()

loss = decoder(images, unet_number = 2)
loss.backward()

# do the above for many steps for both unets"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>Unet</span>, <span>Decoder</span>, <span>CLIP</span>

<span># trained clip from step 1</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>6</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>6</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># 2 unets for the decoder (a la cascading DDPM)</span>

<span>unet1</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>)
).<span>cuda</span>()

<span>unet2</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>, <span>16</span>)
).<span>cuda</span>()

<span># decoder, which contains the unet(s) and clip</span>

<span>decoder</span> <span>=</span> <span>Decoder</span>(
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>unet</span> <span>=</span> (<span>unet1</span>, <span>unet2</span>),            <span># insert both unets in order of low resolution to highest resolution (you can have as many stages as you want here)</span>
    <span>image_sizes</span> <span>=</span> (<span>256</span>, <span>512</span>),         <span># resolutions, 256 for first unet, 512 for second. these must be unique and in ascending order (matches with the unets passed in)</span>
    <span>timesteps</span> <span>=</span> <span>1000</span>,
    <span>image_cond_drop_prob</span> <span>=</span> <span>0.1</span>,
    <span>text_cond_drop_prob</span> <span>=</span> <span>0.5</span>
).<span>cuda</span>()

<span># mock images (get a lot of this)</span>

<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>512</span>, <span>512</span>).<span>cuda</span>()

<span># feed images into decoder, specifying which unet you want to train</span>
<span># each unet can be trained separately, which is one of the benefits of the cascading DDPM scheme</span>

<span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>1</span>)
<span>loss</span>.<span>backward</span>()

<span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>2</span>)
<span>loss</span>.<span>backward</span>()

<span># do the above for many steps for both unets</span></pre></div>
<p dir="auto">Finally, to generate the DALL-E2 images from text. Insert the trained <code>DiffusionPrior</code> as well as the <code>Decoder</code> (which wraps <code>CLIP</code>, the causal transformer, and unet(s))</p>
<div data-snippet-clipboard-copy-content="from dalle2_pytorch import DALLE2

dalle2 = DALLE2(
    prior = diffusion_prior,
    decoder = decoder
)

# send the text as a string if you want to use the simple tokenizer from DALLE v1
# or you can do it as token ids, if you have your own tokenizer

texts = [&#39;glistening morning dew on a flower petal&#39;]
images = dalle2(texts) # (1, 3, 256, 256)"><pre><span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DALLE2</span>

<span>dalle2</span> <span>=</span> <span>DALLE2</span>(
    <span>prior</span> <span>=</span> <span>diffusion_prior</span>,
    <span>decoder</span> <span>=</span> <span>decoder</span>
)

<span># send the text as a string if you want to use the simple tokenizer from DALLE v1</span>
<span># or you can do it as token ids, if you have your own tokenizer</span>

<span>texts</span> <span>=</span> [<span>&#39;glistening morning dew on a flower petal&#39;</span>]
<span>images</span> <span>=</span> <span>dalle2</span>(<span>texts</span>) <span># (1, 3, 256, 256)</span></pre></div>
<p dir="auto">That&#39;s it!</p>
<p dir="auto">Let&#39;s see the whole script below</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import DALLE2, DiffusionPriorNetwork, DiffusionPrior, Unet, Decoder, CLIP

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 6,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 6,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8
).cuda()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# train

loss = clip(
    text,
    images,
    return_loss = True
)

loss.backward()

# do above for many steps ...

# prior networks (with transformer)

prior_network = DiffusionPriorNetwork(
    dim = 512,
    depth = 6,
    dim_head = 64,
    heads = 8
).cuda()

diffusion_prior = DiffusionPrior(
    net = prior_network,
    clip = clip,
    timesteps = 100,
    cond_drop_prob = 0.2
).cuda()

loss = diffusion_prior(text, images)
loss.backward()

# do above for many steps ...

# decoder (with unet)

unet1 = Unet(
    dim = 128,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults=(1, 2, 4, 8)
).cuda()

unet2 = Unet(
    dim = 16,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults = (1, 2, 4, 8, 16)
).cuda()

decoder = Decoder(
    unet = (unet1, unet2),
    image_sizes = (128, 256),
    clip = clip,
    timesteps = 100,
    image_cond_drop_prob = 0.1,
    text_cond_drop_prob = 0.5,
    condition_on_text_encodings = False  # set this to True if you wish to condition on text during training and sampling
).cuda()

for unet_number in (1, 2):
    loss = decoder(images, unet_number = unet_number) # this can optionally be decoder(images, text) if you wish to condition on the text encodings as well, though it was hinted in the paper it didn&#39;t do much
    loss.backward()

# do above for many steps

dalle2 = DALLE2(
    prior = diffusion_prior,
    decoder = decoder
)

images = dalle2(
    [&#39;cute puppy chasing after a squirrel&#39;],
    cond_scale = 2. # classifier free guidance strength (&gt; 1 would strengthen the condition)
)

# save your image (in this example, of size 256x256)"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DALLE2</span>, <span>DiffusionPriorNetwork</span>, <span>DiffusionPrior</span>, <span>Unet</span>, <span>Decoder</span>, <span>CLIP</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>6</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>6</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># train</span>

<span>loss</span> <span>=</span> <span>clip</span>(
    <span>text</span>,
    <span>images</span>,
    <span>return_loss</span> <span>=</span> <span>True</span>
)

<span>loss</span>.<span>backward</span>()

<span># do above for many steps ...</span>

<span># prior networks (with transformer)</span>

<span>prior_network</span> <span>=</span> <span>DiffusionPriorNetwork</span>(
    <span>dim</span> <span>=</span> <span>512</span>,
    <span>depth</span> <span>=</span> <span>6</span>,
    <span>dim_head</span> <span>=</span> <span>64</span>,
    <span>heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span>diffusion_prior</span> <span>=</span> <span>DiffusionPrior</span>(
    <span>net</span> <span>=</span> <span>prior_network</span>,
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>cond_drop_prob</span> <span>=</span> <span>0.2</span>
).<span>cuda</span>()

<span>loss</span> <span>=</span> <span>diffusion_prior</span>(<span>text</span>, <span>images</span>)
<span>loss</span>.<span>backward</span>()

<span># do above for many steps ...</span>

<span># decoder (with unet)</span>

<span>unet1</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>128</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span><span>=</span>(<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>)
).<span>cuda</span>()

<span>unet2</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>16</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>, <span>16</span>)
).<span>cuda</span>()

<span>decoder</span> <span>=</span> <span>Decoder</span>(
    <span>unet</span> <span>=</span> (<span>unet1</span>, <span>unet2</span>),
    <span>image_sizes</span> <span>=</span> (<span>128</span>, <span>256</span>),
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>image_cond_drop_prob</span> <span>=</span> <span>0.1</span>,
    <span>text_cond_drop_prob</span> <span>=</span> <span>0.5</span>,
    <span>condition_on_text_encodings</span> <span>=</span> <span>False</span>  <span># set this to True if you wish to condition on text during training and sampling</span>
).<span>cuda</span>()

<span>for</span> <span>unet_number</span> <span>in</span> (<span>1</span>, <span>2</span>):
    <span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>unet_number</span>) <span># this can optionally be decoder(images, text) if you wish to condition on the text encodings as well, though it was hinted in the paper it didn&#39;t do much</span>
    <span>loss</span>.<span>backward</span>()

<span># do above for many steps</span>

<span>dalle2</span> <span>=</span> <span>DALLE2</span>(
    <span>prior</span> <span>=</span> <span>diffusion_prior</span>,
    <span>decoder</span> <span>=</span> <span>decoder</span>
)

<span>images</span> <span>=</span> <span>dalle2</span>(
    [<span>&#39;cute puppy chasing after a squirrel&#39;</span>],
    <span>cond_scale</span> <span>=</span> <span>2.</span> <span># classifier free guidance strength (&gt; 1 would strengthen the condition)</span>
)

<span># save your image (in this example, of size 256x256)</span></pre></div>
<p dir="auto">Everything in this readme should run without error</p>
<p dir="auto">You can also train the decoder on images of greater than the size (say 512x512) at which CLIP was trained (256x256). The images will be resized to CLIP image resolution for the image embeddings</p>
<p dir="auto">For the layperson, no worries, training will all be automated into a CLI tool, at least for small scale training.</p>
<h2 dir="auto"><a id="user-content-training-on-preprocessed-clip-embeddings" aria-hidden="true" href="#training-on-preprocessed-clip-embeddings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Training on Preprocessed CLIP Embeddings</h2>
<p dir="auto">It is likely, when scaling up, that you would first preprocess your images and text into corresponding embeddings before training the prior network. You can do so easily by simply passing in <code>image_embed</code>, <code>text_embed</code>, and optionally <code>text_encodings</code> and <code>text_mask</code></p>
<p dir="auto">Working example below</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import DiffusionPriorNetwork, DiffusionPrior, CLIP

# get trained CLIP from step one

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 6,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 6,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8,
).cuda()

# setup prior network, which contains an autoregressive transformer

prior_network = DiffusionPriorNetwork(
    dim = 512,
    depth = 6,
    dim_head = 64,
    heads = 8
).cuda()

# diffusion prior network, which contains the CLIP and network (with transformer) above

diffusion_prior = DiffusionPrior(
    net = prior_network,
    clip = clip,
    timesteps = 100,
    cond_drop_prob = 0.2,
    condition_on_text_encodings = False  # this probably should be true, but just to get Laion started
).cuda()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# precompute the text and image embeddings
# here using the diffusion prior class, but could be done with CLIP alone

clip_image_embeds = diffusion_prior.clip.embed_image(images).image_embed
clip_text_embeds = diffusion_prior.clip.embed_text(text).text_embed

# feed text and images into diffusion prior network

loss = diffusion_prior(
    text_embed = clip_text_embeds,
    image_embed = clip_image_embeds
)

loss.backward()

# do the above for many many many steps
# now the diffusion prior can generate image embeddings from the text embeddings"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DiffusionPriorNetwork</span>, <span>DiffusionPrior</span>, <span>CLIP</span>

<span># get trained CLIP from step one</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>6</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>6</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>,
).<span>cuda</span>()

<span># setup prior network, which contains an autoregressive transformer</span>

<span>prior_network</span> <span>=</span> <span>DiffusionPriorNetwork</span>(
    <span>dim</span> <span>=</span> <span>512</span>,
    <span>depth</span> <span>=</span> <span>6</span>,
    <span>dim_head</span> <span>=</span> <span>64</span>,
    <span>heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># diffusion prior network, which contains the CLIP and network (with transformer) above</span>

<span>diffusion_prior</span> <span>=</span> <span>DiffusionPrior</span>(
    <span>net</span> <span>=</span> <span>prior_network</span>,
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>cond_drop_prob</span> <span>=</span> <span>0.2</span>,
    <span>condition_on_text_encodings</span> <span>=</span> <span>False</span>  <span># this probably should be true, but just to get Laion started</span>
).<span>cuda</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># precompute the text and image embeddings</span>
<span># here using the diffusion prior class, but could be done with CLIP alone</span>

<span>clip_image_embeds</span> <span>=</span> <span>diffusion_prior</span>.<span>clip</span>.<span>embed_image</span>(<span>images</span>).<span>image_embed</span>
<span>clip_text_embeds</span> <span>=</span> <span>diffusion_prior</span>.<span>clip</span>.<span>embed_text</span>(<span>text</span>).<span>text_embed</span>

<span># feed text and images into diffusion prior network</span>

<span>loss</span> <span>=</span> <span>diffusion_prior</span>(
    <span>text_embed</span> <span>=</span> <span>clip_text_embeds</span>,
    <span>image_embed</span> <span>=</span> <span>clip_image_embeds</span>
)

<span>loss</span>.<span>backward</span>()

<span># do the above for many many many steps</span>
<span># now the diffusion prior can generate image embeddings from the text embeddings</span></pre></div>
<p dir="auto">You can also completely go <code>CLIP</code>-less, in which case you will need to pass in the <code>image_embed_dim</code> into the <code>DiffusionPrior</code> on initialization</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import DiffusionPriorNetwork, DiffusionPrior

# setup prior network, which contains an autoregressive transformer

prior_network = DiffusionPriorNetwork(
    dim = 512,
    depth = 6,
    dim_head = 64,
    heads = 8
).cuda()

# diffusion prior network, which contains the CLIP and network (with transformer) above

diffusion_prior = DiffusionPrior(
    net = prior_network,
    image_embed_dim = 512,               # this needs to be set
    timesteps = 100,
    cond_drop_prob = 0.2,
    condition_on_text_encodings = False  # this probably should be true, but just to get Laion started
).cuda()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# precompute the text and image embeddings
# here using the diffusion prior class, but could be done with CLIP alone

clip_image_embeds = torch.randn(4, 512).cuda()
clip_text_embeds = torch.randn(4, 512).cuda()

# feed text and images into diffusion prior network

loss = diffusion_prior(
    text_embed = clip_text_embeds,
    image_embed = clip_image_embeds
)

loss.backward()

# do the above for many many many steps
# now the diffusion prior can generate image embeddings from the text embeddings"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DiffusionPriorNetwork</span>, <span>DiffusionPrior</span>

<span># setup prior network, which contains an autoregressive transformer</span>

<span>prior_network</span> <span>=</span> <span>DiffusionPriorNetwork</span>(
    <span>dim</span> <span>=</span> <span>512</span>,
    <span>depth</span> <span>=</span> <span>6</span>,
    <span>dim_head</span> <span>=</span> <span>64</span>,
    <span>heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># diffusion prior network, which contains the CLIP and network (with transformer) above</span>

<span>diffusion_prior</span> <span>=</span> <span>DiffusionPrior</span>(
    <span>net</span> <span>=</span> <span>prior_network</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,               <span># this needs to be set</span>
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>cond_drop_prob</span> <span>=</span> <span>0.2</span>,
    <span>condition_on_text_encodings</span> <span>=</span> <span>False</span>  <span># this probably should be true, but just to get Laion started</span>
).<span>cuda</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># precompute the text and image embeddings</span>
<span># here using the diffusion prior class, but could be done with CLIP alone</span>

<span>clip_image_embeds</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>512</span>).<span>cuda</span>()
<span>clip_text_embeds</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>512</span>).<span>cuda</span>()

<span># feed text and images into diffusion prior network</span>

<span>loss</span> <span>=</span> <span>diffusion_prior</span>(
    <span>text_embed</span> <span>=</span> <span>clip_text_embeds</span>,
    <span>image_embed</span> <span>=</span> <span>clip_image_embeds</span>
)

<span>loss</span>.<span>backward</span>()

<span># do the above for many many many steps</span>
<span># now the diffusion prior can generate image embeddings from the text embeddings</span></pre></div>
<h2 dir="auto"><a id="user-content-openai-clip" aria-hidden="true" href="#openai-clip"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>OpenAI CLIP</h2>
<p dir="auto">Although there is the possibility they are using an unreleased, more powerful CLIP, you can use one of the released ones, if you do not wish to train your own CLIP from scratch. This will also allow the community to more quickly validate the conclusions of the paper.</p>
<p dir="auto">To use a pretrained OpenAI CLIP, simply import <code>OpenAIClipAdapter</code> and pass it into the <code>DiffusionPrior</code> or <code>Decoder</code> like so</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import DALLE2, DiffusionPriorNetwork, DiffusionPrior, Unet, Decoder, OpenAIClipAdapter

# openai pretrained clip - defaults to ViT/B-32

clip = OpenAIClipAdapter()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# prior networks (with transformer)

prior_network = DiffusionPriorNetwork(
    dim = 512,
    depth = 6,
    dim_head = 64,
    heads = 8
).cuda()

diffusion_prior = DiffusionPrior(
    net = prior_network,
    clip = clip,
    timesteps = 100,
    cond_drop_prob = 0.2
).cuda()

loss = diffusion_prior(text, images)
loss.backward()

# do above for many steps ...

# decoder (with unet)

unet1 = Unet(
    dim = 128,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults=(1, 2, 4, 8)
).cuda()

unet2 = Unet(
    dim = 16,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults = (1, 2, 4, 8, 16)
).cuda()

decoder = Decoder(
    unet = (unet1, unet2),
    image_sizes = (128, 256),
    clip = clip,
    timesteps = 100,
    image_cond_drop_prob = 0.1,
    text_cond_drop_prob = 0.5,
    condition_on_text_encodings = False  # set this to True if you wish to condition on text during training and sampling
).cuda()

for unet_number in (1, 2):
    loss = decoder(images, unet_number = unet_number) # this can optionally be decoder(images, text) if you wish to condition on the text encodings as well, though it was hinted in the paper it didn&#39;t do much
    loss.backward()

# do above for many steps

dalle2 = DALLE2(
    prior = diffusion_prior,
    decoder = decoder
)

images = dalle2(
    [&#39;a butterfly trying to escape a tornado&#39;],
    cond_scale = 2. # classifier free guidance strength (&gt; 1 would strengthen the condition)
)

# save your image (in this example, of size 256x256)"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DALLE2</span>, <span>DiffusionPriorNetwork</span>, <span>DiffusionPrior</span>, <span>Unet</span>, <span>Decoder</span>, <span>OpenAIClipAdapter</span>

<span># openai pretrained clip - defaults to ViT/B-32</span>

<span>clip</span> <span>=</span> <span>OpenAIClipAdapter</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># prior networks (with transformer)</span>

<span>prior_network</span> <span>=</span> <span>DiffusionPriorNetwork</span>(
    <span>dim</span> <span>=</span> <span>512</span>,
    <span>depth</span> <span>=</span> <span>6</span>,
    <span>dim_head</span> <span>=</span> <span>64</span>,
    <span>heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span>diffusion_prior</span> <span>=</span> <span>DiffusionPrior</span>(
    <span>net</span> <span>=</span> <span>prior_network</span>,
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>cond_drop_prob</span> <span>=</span> <span>0.2</span>
).<span>cuda</span>()

<span>loss</span> <span>=</span> <span>diffusion_prior</span>(<span>text</span>, <span>images</span>)
<span>loss</span>.<span>backward</span>()

<span># do above for many steps ...</span>

<span># decoder (with unet)</span>

<span>unet1</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>128</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span><span>=</span>(<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>)
).<span>cuda</span>()

<span>unet2</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>16</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>, <span>16</span>)
).<span>cuda</span>()

<span>decoder</span> <span>=</span> <span>Decoder</span>(
    <span>unet</span> <span>=</span> (<span>unet1</span>, <span>unet2</span>),
    <span>image_sizes</span> <span>=</span> (<span>128</span>, <span>256</span>),
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>image_cond_drop_prob</span> <span>=</span> <span>0.1</span>,
    <span>text_cond_drop_prob</span> <span>=</span> <span>0.5</span>,
    <span>condition_on_text_encodings</span> <span>=</span> <span>False</span>  <span># set this to True if you wish to condition on text during training and sampling</span>
).<span>cuda</span>()

<span>for</span> <span>unet_number</span> <span>in</span> (<span>1</span>, <span>2</span>):
    <span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>unet_number</span>) <span># this can optionally be decoder(images, text) if you wish to condition on the text encodings as well, though it was hinted in the paper it didn&#39;t do much</span>
    <span>loss</span>.<span>backward</span>()

<span># do above for many steps</span>

<span>dalle2</span> <span>=</span> <span>DALLE2</span>(
    <span>prior</span> <span>=</span> <span>diffusion_prior</span>,
    <span>decoder</span> <span>=</span> <span>decoder</span>
)

<span>images</span> <span>=</span> <span>dalle2</span>(
    [<span>&#39;a butterfly trying to escape a tornado&#39;</span>],
    <span>cond_scale</span> <span>=</span> <span>2.</span> <span># classifier free guidance strength (&gt; 1 would strengthen the condition)</span>
)

<span># save your image (in this example, of size 256x256)</span></pre></div>
<p dir="auto">Now you&#39;ll just have to worry about training the Prior and the Decoder!</p>
<h2 dir="auto"><a id="user-content-experimental" aria-hidden="true" href="#experimental"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Experimental</h2>
<h3 dir="auto"><a id="user-content-dall-e2-with-latent-diffusion" aria-hidden="true" href="#dall-e2-with-latent-diffusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DALL-E2 with Latent Diffusion</h3>
<p dir="auto">This repository decides to take the next step and offer DALL-E v2 combined with <a href="https://huggingface.co/spaces/multimodalart/latentdiffusion" rel="nofollow">latent diffusion</a>, from Rombach et al.</p>
<p dir="auto">You can use it as follows. Latent diffusion can be limited to just the first U-Net in the cascade, or to any number you wish.</p>
<p dir="auto">The repository also comes equipped with all the necessary settings to recreate <code>ViT-VQGan</code> from the <a href="https://arxiv.org/abs/2110.04627" rel="nofollow">Improved VQGans</a> paper. Furthermore, the <a href="https://github.com/lucidrains/vector-quantize-pytorch">vector quantization</a> library also comes equipped to do <a href="https://arxiv.org/abs/2203.01941" rel="nofollow">residual or multi-headed quantization</a>, which I believe will give an even further boost in performance to the autoencoder.</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import Unet, Decoder, CLIP, VQGanVAE

# trained clip from step 1

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 1,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 1,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8
)

# 3 unets for the decoder (a la cascading DDPM)

# first two unets are doing latent diffusion
# vqgan-vae must be trained beforehand

vae1 = VQGanVAE(
    dim = 32,
    image_size = 256,
    layers = 3,
    layer_mults = (1, 2, 4)
)

vae2 = VQGanVAE(
    dim = 32,
    image_size = 512,
    layers = 3,
    layer_mults = (1, 2, 4)
)

unet1 = Unet(
    dim = 32,
    image_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    sparse_attn = True,
    sparse_attn_window = 2,
    dim_mults = (1, 2, 4, 8)
)

unet2 = Unet(
    dim = 32,
    image_embed_dim = 512,
    channels = 3,
    dim_mults = (1, 2, 4, 8, 16),
    cond_on_image_embeds = True,
    cond_on_text_encodings = False
)

unet3 = Unet(
    dim = 32,
    image_embed_dim = 512,
    channels = 3,
    dim_mults = (1, 2, 4, 8, 16),
    cond_on_image_embeds = True,
    cond_on_text_encodings = False,
    attend_at_middle = False
)

# decoder, which contains the unet(s) and clip

decoder = Decoder(
    clip = clip,
    vae = (vae1, vae2),                # latent diffusion for unet1 (vae1) and unet2 (vae2), but not for the last unet3
    unet = (unet1, unet2, unet3),      # insert unets in order of low resolution to highest resolution (you can have as many stages as you want here)
    image_sizes = (256, 512, 1024),    # resolutions, 256 for first unet, 512 for second, 1024 for third
    timesteps = 100,
    image_cond_drop_prob = 0.1,
    text_cond_drop_prob = 0.5
).cuda()

# mock images (get a lot of this)

images = torch.randn(1, 3, 1024, 1024).cuda()

# feed images into decoder, specifying which unet you want to train
# each unet can be trained separately, which is one of the benefits of the cascading DDPM scheme

with decoder.one_unet_in_gpu(1):
    loss = decoder(images, unet_number = 1)
    loss.backward()

with decoder.one_unet_in_gpu(2):
    loss = decoder(images, unet_number = 2)
    loss.backward()

with decoder.one_unet_in_gpu(3):
    loss = decoder(images, unet_number = 3)
    loss.backward()

# do the above for many steps for both unets

# then it will learn to generate images based on the CLIP image embeddings

# chaining the unets from lowest resolution to highest resolution (thus cascading)

mock_image_embed = torch.randn(1, 512).cuda()
images = decoder.sample(mock_image_embed) # (1, 3, 1024, 1024)"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>Unet</span>, <span>Decoder</span>, <span>CLIP</span>, <span>VQGanVAE</span>

<span># trained clip from step 1</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>1</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>1</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>
)

<span># 3 unets for the decoder (a la cascading DDPM)</span>

<span># first two unets are doing latent diffusion</span>
<span># vqgan-vae must be trained beforehand</span>

<span>vae1</span> <span>=</span> <span>VQGanVAE</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_size</span> <span>=</span> <span>256</span>,
    <span>layers</span> <span>=</span> <span>3</span>,
    <span>layer_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>)
)

<span>vae2</span> <span>=</span> <span>VQGanVAE</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_size</span> <span>=</span> <span>512</span>,
    <span>layers</span> <span>=</span> <span>3</span>,
    <span>layer_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>)
)

<span>unet1</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>sparse_attn</span> <span>=</span> <span>True</span>,
    <span>sparse_attn_window</span> <span>=</span> <span>2</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>)
)

<span>unet2</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>, <span>16</span>),
    <span>cond_on_image_embeds</span> <span>=</span> <span>True</span>,
    <span>cond_on_text_encodings</span> <span>=</span> <span>False</span>
)

<span>unet3</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>32</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>, <span>16</span>),
    <span>cond_on_image_embeds</span> <span>=</span> <span>True</span>,
    <span>cond_on_text_encodings</span> <span>=</span> <span>False</span>,
    <span>attend_at_middle</span> <span>=</span> <span>False</span>
)

<span># decoder, which contains the unet(s) and clip</span>

<span>decoder</span> <span>=</span> <span>Decoder</span>(
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>vae</span> <span>=</span> (<span>vae1</span>, <span>vae2</span>),                <span># latent diffusion for unet1 (vae1) and unet2 (vae2), but not for the last unet3</span>
    <span>unet</span> <span>=</span> (<span>unet1</span>, <span>unet2</span>, <span>unet3</span>),      <span># insert unets in order of low resolution to highest resolution (you can have as many stages as you want here)</span>
    <span>image_sizes</span> <span>=</span> (<span>256</span>, <span>512</span>, <span>1024</span>),    <span># resolutions, 256 for first unet, 512 for second, 1024 for third</span>
    <span>timesteps</span> <span>=</span> <span>100</span>,
    <span>image_cond_drop_prob</span> <span>=</span> <span>0.1</span>,
    <span>text_cond_drop_prob</span> <span>=</span> <span>0.5</span>
).<span>cuda</span>()

<span># mock images (get a lot of this)</span>

<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>1</span>, <span>3</span>, <span>1024</span>, <span>1024</span>).<span>cuda</span>()

<span># feed images into decoder, specifying which unet you want to train</span>
<span># each unet can be trained separately, which is one of the benefits of the cascading DDPM scheme</span>

<span>with</span> <span>decoder</span>.<span>one_unet_in_gpu</span>(<span>1</span>):
    <span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>1</span>)
    <span>loss</span>.<span>backward</span>()

<span>with</span> <span>decoder</span>.<span>one_unet_in_gpu</span>(<span>2</span>):
    <span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>2</span>)
    <span>loss</span>.<span>backward</span>()

<span>with</span> <span>decoder</span>.<span>one_unet_in_gpu</span>(<span>3</span>):
    <span>loss</span> <span>=</span> <span>decoder</span>(<span>images</span>, <span>unet_number</span> <span>=</span> <span>3</span>)
    <span>loss</span>.<span>backward</span>()

<span># do the above for many steps for both unets</span>

<span># then it will learn to generate images based on the CLIP image embeddings</span>

<span># chaining the unets from lowest resolution to highest resolution (thus cascading)</span>

<span>mock_image_embed</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>1</span>, <span>512</span>).<span>cuda</span>()
<span>images</span> <span>=</span> <span>decoder</span>.<span>sample</span>(<span>mock_image_embed</span>) <span># (1, 3, 1024, 1024)</span></pre></div>
<h2 dir="auto"><a id="user-content-training-wrapper-wip" aria-hidden="true" href="#training-wrapper-wip"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Training wrapper (wip)</h2>
<h3 dir="auto"><a id="user-content-decoder-training" aria-hidden="true" href="#decoder-training"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Decoder Training</h3>
<p dir="auto">Training the <code>Decoder</code> may be confusing, as one needs to keep track of an optimizer for each of the <code>Unet</code>(s) separately. Each <code>Unet</code> will also need its own corresponding exponential moving average. The <code>DecoderTrainer</code> hopes to make this simple, as shown below</p>
<div data-snippet-clipboard-copy-content="import torch
from dalle2_pytorch import DALLE2, Unet, Decoder, CLIP, DecoderTrainer

clip = CLIP(
    dim_text = 512,
    dim_image = 512,
    dim_latent = 512,
    num_text_tokens = 49408,
    text_enc_depth = 6,
    text_seq_len = 256,
    text_heads = 8,
    visual_enc_depth = 6,
    visual_image_size = 256,
    visual_patch_size = 32,
    visual_heads = 8
).cuda()

# mock data

text = torch.randint(0, 49408, (4, 256)).cuda()
images = torch.randn(4, 3, 256, 256).cuda()

# decoder (with unet)

unet1 = Unet(
    dim = 128,
    image_embed_dim = 512,
    text_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults=(1, 2, 4, 8)
).cuda()

unet2 = Unet(
    dim = 16,
    image_embed_dim = 512,
    text_embed_dim = 512,
    cond_dim = 128,
    channels = 3,
    dim_mults = (1, 2, 4, 8, 16),
    cond_on_text_encodings = True
).cuda()

decoder = Decoder(
    unet = (unet1, unet2),
    image_sizes = (128, 256),
    clip = clip,
    timesteps = 1000,
    condition_on_text_encodings = True
).cuda()

decoder_trainer = DecoderTrainer(
    decoder,
    lr = 3e-4,
    wd = 1e-2,
    ema_beta = 0.99,
    ema_update_after_step = 1000,
    ema_update_every = 10,
)

for unet_number in (1, 2):
    loss = decoder_trainer(images, text = text, unet_number = unet_number)  # use the decoder_trainer forward
    loss.backward()

    decoder_trainer.update(unet_number) # update the specific unet as well as its exponential moving average

# after much training
# you can sample from the exponentially moving averaged unets as so

mock_image_embed = torch.randn(4, 512).cuda()
images = decoder_trainer.sample(mock_image_embed, text = text) # (4, 3, 256, 256)"><pre><span>import</span> <span>torch</span>
<span>from</span> <span>dalle2_pytorch</span> <span>import</span> <span>DALLE2</span>, <span>Unet</span>, <span>Decoder</span>, <span>CLIP</span>, <span>DecoderTrainer</span>

<span>clip</span> <span>=</span> <span>CLIP</span>(
    <span>dim_text</span> <span>=</span> <span>512</span>,
    <span>dim_image</span> <span>=</span> <span>512</span>,
    <span>dim_latent</span> <span>=</span> <span>512</span>,
    <span>num_text_tokens</span> <span>=</span> <span>49408</span>,
    <span>text_enc_depth</span> <span>=</span> <span>6</span>,
    <span>text_seq_len</span> <span>=</span> <span>256</span>,
    <span>text_heads</span> <span>=</span> <span>8</span>,
    <span>visual_enc_depth</span> <span>=</span> <span>6</span>,
    <span>visual_image_size</span> <span>=</span> <span>256</span>,
    <span>visual_patch_size</span> <span>=</span> <span>32</span>,
    <span>visual_heads</span> <span>=</span> <span>8</span>
).<span>cuda</span>()

<span># mock data</span>

<span>text</span> <span>=</span> <span>torch</span>.<span>randint</span>(<span>0</span>, <span>49408</span>, (<span>4</span>, <span>256</span>)).<span>cuda</span>()
<span>images</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>3</span>, <span>256</span>, <span>256</span>).<span>cuda</span>()

<span># decoder (with unet)</span>

<span>unet1</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>128</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>text_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span><span>=</span>(<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>)
).<span>cuda</span>()

<span>unet2</span> <span>=</span> <span>Unet</span>(
    <span>dim</span> <span>=</span> <span>16</span>,
    <span>image_embed_dim</span> <span>=</span> <span>512</span>,
    <span>text_embed_dim</span> <span>=</span> <span>512</span>,
    <span>cond_dim</span> <span>=</span> <span>128</span>,
    <span>channels</span> <span>=</span> <span>3</span>,
    <span>dim_mults</span> <span>=</span> (<span>1</span>, <span>2</span>, <span>4</span>, <span>8</span>, <span>16</span>),
    <span>cond_on_text_encodings</span> <span>=</span> <span>True</span>
).<span>cuda</span>()

<span>decoder</span> <span>=</span> <span>Decoder</span>(
    <span>unet</span> <span>=</span> (<span>unet1</span>, <span>unet2</span>),
    <span>image_sizes</span> <span>=</span> (<span>128</span>, <span>256</span>),
    <span>clip</span> <span>=</span> <span>clip</span>,
    <span>timesteps</span> <span>=</span> <span>1000</span>,
    <span>condition_on_text_encodings</span> <span>=</span> <span>True</span>
).<span>cuda</span>()

<span>decoder_trainer</span> <span>=</span> <span>DecoderTrainer</span>(
    <span>decoder</span>,
    <span>lr</span> <span>=</span> <span>3e-4</span>,
    <span>wd</span> <span>=</span> <span>1e-2</span>,
    <span>ema_beta</span> <span>=</span> <span>0.99</span>,
    <span>ema_update_after_step</span> <span>=</span> <span>1000</span>,
    <span>ema_update_every</span> <span>=</span> <span>10</span>,
)

<span>for</span> <span>unet_number</span> <span>in</span> (<span>1</span>, <span>2</span>):
    <span>loss</span> <span>=</span> <span>decoder_trainer</span>(<span>images</span>, <span>text</span> <span>=</span> <span>text</span>, <span>unet_number</span> <span>=</span> <span>unet_number</span>)  <span># use the decoder_trainer forward</span>
    <span>loss</span>.<span>backward</span>()

    <span>decoder_trainer</span>.<span>update</span>(<span>unet_number</span>) <span># update the specific unet as well as its exponential moving average</span>

<span># after much training</span>
<span># you can sample from the exponentially moving averaged unets as so</span>

<span>mock_image_embed</span> <span>=</span> <span>torch</span>.<span>randn</span>(<span>4</span>, <span>512</span>).<span>cuda</span>()
<span>images</span> <span>=</span> <span>decoder_trainer</span>.<span>sample</span>(<span>mock_image_embed</span>, <span>text</span> <span>=</span> <span>text</span>) <span># (4, 3, 256, 256)</span></pre></div>
<h2 dir="auto"><a id="user-content-cli-wip" aria-hidden="true" href="#cli-wip"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>CLI (wip)</h2>
<div data-snippet-clipboard-copy-content="$ dream &#39;sharing a sunset at the summit of mount everest with my dog&#39;"><pre>$ dream <span><span>&#39;</span>sharing a sunset at the summit of mount everest with my dog<span>&#39;</span></span></pre></div>
<p dir="auto">Once built, images will be saved to the same directory the command is invoked</p>
<p dir="auto"><a href="https://github.com/lucidrains/big-sleep">template</a></p>
<h2 dir="auto"><a id="user-content-training-cli-wip" aria-hidden="true" href="#training-cli-wip"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Training CLI (wip)</h2>
<p dir="auto"><a href="https://github.com/lucidrains/stylegan2-pytorch">template</a></p>
<h2 dir="auto"><a id="user-content-todo" aria-hidden="true" href="#todo"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Todo</h2>
<ul>
<li> finish off gaussian diffusion class for latent embedding - allow for prediction of epsilon</li>
<li> add what was proposed in the paper, where DDPM objective for image latent embedding predicts x0 directly (reread vq-diffusion paper and get caught up on that line of work)</li>
<li> make sure it works end to end to produce an output tensor, taking a single gradient step</li>
<li> augment unet so that it can also be conditioned on text encodings (although in paper they hinted this didn&#39;t make much a difference)</li>
<li> figure out all the current bag of tricks needed to make DDPMs great (starting with the blur trick mentioned in paper)</li>
<li> build the cascading ddpm by having Decoder class manage multiple unets at different resolutions</li>
<li> add efficient attention in unet</li>
<li> be able to finely customize what to condition on (text, image embed) for specific unet in the cascade (super resolution ddpms near the end may not need too much conditioning)</li>
<li> offload unets not being trained on to CPU for memory efficiency (for training each resolution unets separately)</li>
<li> build out latent diffusion architecture, with the vq-reg variant (vqgan-vae), make it completely optional and compatible with cascading ddpms</li>
<li> for decoder, allow ability to customize objective (predict epsilon vs x0), in case latent diffusion does better with prediction of x0</li>
<li> use attention-based upsampling <a href="https://arxiv.org/abs/2112.11435" rel="nofollow">https://arxiv.org/abs/2112.11435</a></li>
<li> use inheritance just this once for sharing logic between decoder and prior network ddpms</li>
<li> bring in vit-vqgan <a href="https://arxiv.org/abs/2110.04627" rel="nofollow">https://arxiv.org/abs/2110.04627</a> for the latent diffusion</li>
<li> abstract interface for CLIP adapter class, so other CLIPs can be brought in</li>
<li> take care of mixed precision as well as gradient accumulation within decoder trainer</li>
<li> just take care of the training for the decoder in a wrapper class, as each unet in the cascade will need its own optimizer</li>
<li> bring in tools to train vqgan-vae</li>
<li> add convnext backbone for vqgan-vae (in addition to vit [vit-vqgan] + resnet)</li>
<li> become an expert with unets, cleanup unet code, make it fully configurable, port all learnings over to <a href="https://github.com/lucidrains/x-unet">https://github.com/lucidrains/x-unet</a></li>
<li> copy the cascading ddpm code to a separate repo (perhaps <a href="https://github.com/lucidrains/denoising-diffusion-pytorch">https://github.com/lucidrains/denoising-diffusion-pytorch</a>) as the main contribution of dalle2 really is just the prior network</li>
<li> transcribe code to Jax, which lowers the activation energy for distributed training, given access to TPUs</li>
<li> pull logic for training diffusion prior into a class DiffusionPriorTrainer, for eventual script based + CLI based training</li>
<li> train on a toy task, offer in colab</li>
<li> think about how best to design a declarative training config that handles preencoding for prior and training of multiple networks in decoder</li>
<li> extend diffusion head to use diffusion-gan (potentially using lightweight-gan) to speed up inference</li>
<li> bring in cross-scale embedding from iclr paper <a href="https://github.com/lucidrains/vit-pytorch/blob/main/vit_pytorch/crossformer.py#L14">https://github.com/lucidrains/vit-pytorch/blob/main/vit_pytorch/crossformer.py#L14</a></li>
<li> figure out if possible to augment with external memory, as described in <a href="https://arxiv.org/abs/2204.11824" rel="nofollow">https://arxiv.org/abs/2204.11824</a></li>
<li> test out grid attention in cascading ddpm locally, decide whether to keep or remove</li>
</ul>
<h2 dir="auto"><a id="user-content-citations" aria-hidden="true" href="#citations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Citations</h2>
<div data-snippet-clipboard-copy-content="@misc{ramesh2022,
    title   = {Hierarchical Text-Conditional Image Generation with CLIP Latents}, 
    author  = {Aditya Ramesh et al},
    year    = {2022}
}"><pre><span>@misc</span>{<span>ramesh2022</span>,
    <span>title</span>   = <span><span>{</span>Hierarchical Text-Conditional Image Generation with CLIP Latents<span>}</span></span>, 
    <span>author</span>  = <span><span>{</span>Aditya Ramesh et al<span>}</span></span>,
    <span>year</span>    = <span><span>{</span>2022<span>}</span></span>
}</pre></div>
<div data-snippet-clipboard-copy-content="@misc{crowson2022,
    author  = {Katherine Crowson},
    url     = {https://twitter.com/rivershavewings}
}"><pre><span>@misc</span>{<span>crowson2022</span>,
    <span>author</span>  = <span><span>{</span>Katherine Crowson<span>}</span></span>,
    <span>url</span>     = <span><span>{</span>https://twitter.com/rivershavewings<span>}</span></span>
}</pre></div>
<div data-snippet-clipboard-copy-content="@misc{rombach2021highresolution,
    title   = {High-Resolution Image Synthesis with Latent Diffusion Models}, 
    author  = {Robin Rombach and Andreas Blattmann and Dominik Lorenz and Patrick Esser and BjÃ¶rn Ommer},
    year    = {2021},
    eprint  = {2112.10752},
    archivePrefix = {arXiv},
    primaryClass = {cs.CV}
}"><pre><span>@misc</span>{<span>rombach2021highresolution</span>,
    <span>title</span>   = <span><span>{</span>High-Resolution Image Synthesis with Latent Diffusion Models<span>}</span></span>, 
    <span>author</span>  = <span><span>{</span>Robin Rombach and Andreas Blattmann and Dominik Lorenz and Patrick Esser and BjÃ¶rn Ommer<span>}</span></span>,
    <span>year</span>    = <span><span>{</span>2021<span>}</span></span>,
    <span>eprint</span>  = <span><span>{</span>2112.10752<span>}</span></span>,
    <span>archivePrefix</span> = <span><span>{</span>arXiv<span>}</span></span>,
    <span>primaryClass</span> = <span><span>{</span>cs.CV<span>}</span></span>
}</pre></div>
<div data-snippet-clipboard-copy-content="@inproceedings{Liu2022ACF,
    title   = {A ConvNet for the 2020s},
    author  = {Zhuang Liu and Hanzi Mao and Chaozheng Wu and Christoph Feichtenhofer and Trevor Darrell and Saining Xie},
    year    = {2022}
}"><pre><span>@inproceedings</span>{<span>Liu2022ACF</span>,
    <span>title</span>   = <span><span>{</span>A ConvNet for the 2020s<span>}</span></span>,
    <span>author</span>  = <span><span>{</span>Zhuang Liu and Hanzi Mao and Chaozheng Wu and Christoph Feichtenhofer and Trevor Darrell and Saining Xie<span>}</span></span>,
    <span>year</span>    = <span><span>{</span>2022<span>}</span></span>
}</pre></div>
<div data-snippet-clipboard-copy-content="@article{shen2019efficient,
    author  = {Zhuoran Shen and Mingyuan Zhang and Haiyu Zhao and Shuai Yi and Hongsheng Li},
    title   = {Efficient Attention: Attention with Linear Complexities},
    journal = {CoRR},
    year    = {2018},
    url     = {http://arxiv.org/abs/1812.01243},
}"><pre><span>@article</span>{<span>shen2019efficient</span>,
    <span>author</span>  = <span><span>{</span>Zhuoran Shen and Mingyuan Zhang and Haiyu Zhao and Shuai Yi and Hongsheng Li<span>}</span></span>,
    <span>title</span>   = <span><span>{</span>Efficient Attention: Attention with Linear Complexities<span>}</span></span>,
    <span>journal</span> = <span><span>{</span>CoRR<span>}</span></span>,
    <span>year</span>    = <span><span>{</span>2018<span>}</span></span>,
    <span>url</span>     = <span><span>{</span>http://arxiv.org/abs/1812.01243<span>}</span></span>,
}</pre></div>
<div data-snippet-clipboard-copy-content="@inproceedings{Tu2022MaxViTMV,
    title   = {MaxViT: Multi-Axis Vision Transformer},
    author  = {Zhe-Wei Tu and Hossein Talebi and Han Zhang and Feng Yang and Peyman Milanfar and Alan Conrad Bovik and Yinxiao Li},
    year    = {2022}
}"><pre><span>@inproceedings</span>{<span>Tu2022MaxViTMV</span>,
    <span>title</span>   = <span><span>{</span>MaxViT: Multi-Axis Vision Transformer<span>}</span></span>,
    <span>author</span>  = <span><span>{</span>Zhe-Wei Tu and Hossein Talebi and Han Zhang and Feng Yang and Peyman Milanfar and Alan Conrad Bovik and Yinxiao Li<span>}</span></span>,
    <span>year</span>    = <span><span>{</span>2022<span>}</span></span>
}</pre></div>
<div data-snippet-clipboard-copy-content="@article{Yu2021VectorquantizedIM,
    title   = {Vector-quantized Image Modeling with Improved VQGAN},
    author  = {Jiahui Yu and Xin Li and Jing Yu Koh and Han Zhang and Ruoming Pang and James Qin and Alexander Ku and Yuanzhong Xu and Jason Baldridge and Yonghui Wu},
    journal = {ArXiv},
    year    = {2021},
    volume  = {abs/2110.04627}
}"><pre><span>@article</span>{<span>Yu2021VectorquantizedIM</span>,
    <span>title</span>   = <span><span>{</span>Vector-quantized Image Modeling with Improved VQGAN<span>}</span></span>,
    <span>author</span>  = <span><span>{</span>Jiahui Yu and Xin Li and Jing Yu Koh and Han Zhang and Ruoming Pang and James Qin and Alexander Ku and Yuanzhong Xu and Jason Baldridge and Yonghui Wu<span>}</span></span>,
    <span>journal</span> = <span><span>{</span>ArXiv<span>}</span></span>,
    <span>year</span>    = <span><span>{</span>2021<span>}</span></span>,
    <span>volume</span>  = <span><span>{</span>abs/2110.04627<span>}</span></span>
}</pre></div>
<p dir="auto"><em>Creating noise from data is easy; creating data from noise is generative modeling.</em> - Yang Song&#39;s <a href="https://arxiv.org/abs/2011.13456" rel="nofollow">paper</a></p>
</article>
          </div></div>
  </body>
</html>
