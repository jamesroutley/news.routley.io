<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vishnubharathi.codes/blog/exploring-middlewares-in-go/">Original</a>
    <h1>Exploring Middlewares in Go</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I came across ‚ÄúMiddlewares‚Äù for writing HTTP servers originally in the Node.js ecosystem. There is this beautiful library called <a target="_blank" rel="noopener" href="https://expressjs.com/">express</a> which sparked the joy of middleware in me. In case you haven‚Äôt heard of middleware before, I think you should read <a target="_blank" rel="noopener" href="https://expressjs.com/en/guide/using-middleware.html">this beautiful page</a> from expressjs documentation to get a taste of them. (I genuinely feel that it is the best possible introduction for middleware, hence opening up the post with it)</p>
<p>With enough JavaScript for the day, we will jump into Go now. üòÖ</p>
<p>My goal for this post is to understand how to {use, write} middlewares in Go HTTP servers. We will also try to search the internet and surface some Go middlewares that we can add to our day-to-day toolkit.</p>
<h2 id="Problem"><a href="#Problem" title="Problem"></a>Problem</h2><p>Let us take a simple problem and work our way upwards. Here is the problem statement:</p>
<p>Write an HTTP server that contains multiple routes. When a request is made to a route, print a log line at the start and the end of the request. Something like</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>2024/05/21 00:49:32 INFO start method=GET path=/one</span></pre></td></tr></tbody></table></figure>
<h2 id="Solution"><a href="#Solution" title="Solution"></a>Solution</h2><h3 id="Without-Middleware"><a href="#Without-Middleware" title="Without Middleware"></a>Without Middleware</h3><p>A solution without using middleware would look like</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> main</span></pre></td></tr></tbody></table></figure>
<p>How do we avoid copy-pasting those two lines to every HTTP handler function? Middlewares for the win!</p>
<h3 id="Basic-Middleware"><a href="#Basic-Middleware" title="Basic Middleware"></a>Basic Middleware</h3><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> main</span></pre></td></tr></tbody></table></figure>
<h3 id="Using-http-HandleFunc"><a href="#Using-http-HandleFunc" title="Using http.HandleFunc"></a>Using http.HandleFunc</h3><p>We are not done yet! There is still room for improvement. Notice how big the method signature for <code>logRequest</code> is! we can start from there. I remember a standard library type called <code>http.HandlerFunc</code> which could be used in the place of <code>func(ResponseWriter, *Request)</code>. If we start using it, our middleware looks like this.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>func</span> <span>logRequest</span><span>(next http.HandlerFunc)</span> <span>http</span>.<span>HandlerFunc</span></span> {</span></pre></td></tr></tbody></table></figure>
<p>While browsing through the Go docs, I noticed that <code>http.HandleFunc</code> has the below method signature.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span><span>func</span> <span>HandleFunc</span><span>(pattern <span>string</span>, handler <span>func</span>(ResponseWriter, *Request)</span>)</span></span><br/></pre></td></tr></tbody></table></figure>
<p>That raised a question in me. Why don‚Äôt they use <code>func HandleFunc(pattern string, handler http.HandlerFunc)</code> instead? I thought <code>http.HandlerFunc</code> is an alias type for <code>func(ResponseWriter, *Request)</code>. Digging through the standard library source code had the answer. It seems like it is just not a simple alias, but more than that. Copy pasting the implementation of <code>http.HanderFunc</code> for you straight out of Go source :D</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>oh wow, so http.HandleFunc is a <code>func(ResponseWriter, *Request)</code> which implements the <a target="_blank" rel="noopener" href="https://pkg.go.dev/net/http#Handler">http.Handler</a> interface.</p>
<h3 id="Enter-http-Handler"><a href="#Enter-http-Handler" title="Enter http.Handler"></a>Enter http.Handler</h3><p>Why would we need an adapter like <code>http.HandlerFunc</code> that implements the <code>http.Handler</code> interface. To understand, let us take a look at the interface definition.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>type</span> Handler <span>interface</span> {</span></pre></td></tr></tbody></table></figure>
<p>and also read through the <a target="_blank" rel="noopener" href="https://pkg.go.dev/net/http#Handler">http.Handler documentation</a>. At first, it didn‚Äôt solve my doubt, but then I discovered <a target="_blank" rel="noopener" href="https://pkg.go.dev/net/http#example-Handle">this beautiful example</a> in the docs. Copy pasting the example from the docs here for you to have a quick look.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> main</span></pre></td></tr></tbody></table></figure>
<p>wow, did you get it? Sometimes your handler is more than just a <code>func(http.ResponseWriter, *http.Request)</code>. It could be a struct that contains data that could be used in your request logic. Like in the above case, <code>countHandler</code> maintains a counter protected by a mutex. Each and every request to <code>/count</code> would increment the counter atomically.</p>
<p>For simple routes, which are just a bunch of instructions we could use <code>http.HandleFunc</code>. But once your handler gets complex, like having to maintain data that is common to all requests of the handler, then move upward and go for <code>http.Handle</code>.</p>
<p>woah, this just cleared my long-standing doubt about ‚Äúwhen to use <code>http.Handle</code> and <code>http.HandleFunc</code>?‚Äù</p>
<p>It is getting a bit clearer now on why the <code>http.Handler</code> interface is needed. With two ways of defining a HTTP handler: one being to write a <code>func(http.ResponseWriter, *http.Request)</code> and pass it to <code>http.HandleFunc</code> and another being to write a struct with the necessary logic and pass it down to <code>http.Handle</code> function, the standard libary needs a common ground in which all its methods can operate on both the types of handlers. Hence an interface.</p>
<h3 id="http-HandlerFunc-to-http-Handler"><a href="#http-HandlerFunc-to-http-Handler" title="http.HandlerFunc to http.Handler"></a>http.HandlerFunc to http.Handler</h3><p>Now that it is evident that a Go programmer could choose between using <code>http.Handle</code> or <code>http.HandleFunc</code> to serve their handlers, it is necessary that any HTTP middleware should work for both of those use cases. With the current approach to our solution, we will only support middlewares that are input to <code>http.HandleFunc</code>. Hence moving our middleware to use <code>http.Handler</code> interface, that way we could accommodate both types of handlers.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> main</span></pre></td></tr></tbody></table></figure>
<h2 id="Standard-library-Middlewares"><a href="#Standard-library-Middlewares" title="Standard library Middlewares"></a>Standard library Middlewares</h2><p>The <code>net/http</code> package in the standard library of Go contains middlewares. If you haven‚Äôt realized it yet, don‚Äôt worry. That is because they don‚Äôt advertise those functions as ‚Äúmiddleware‚Äù (ctrl+f on docs for middleware leaves you with 0 matches :D)</p>
<h3 id="AllowQuerySemicolons"><a href="#AllowQuerySemicolons" title="AllowQuerySemicolons"></a>AllowQuerySemicolons</h3><figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span><span>func</span> <span>AllowQuerySemicolons</span><span>(h Handler)</span> <span>Handler</span></span></span><br/></pre></td></tr></tbody></table></figure>
<p>TIL that we could use semicolons instead of ampersands in query strings (though this style is deprecated by W3C). Read more about it here: <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/25192">https://github.com/golang/go/issues/25192</a>. This middleware is present in the stdlib for solving that problem by replacing the <code>;</code> with <code>&amp;</code> under the hood. </p>
<h3 id="MaxBytesHandler"><a href="#MaxBytesHandler" title="MaxBytesHandler"></a>MaxBytesHandler</h3><figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span><span>func</span> <span>MaxBytesHandler</span><span>(h Handler, n <span>int64</span>)</span> <span>Handler</span></span></span><br/></pre></td></tr></tbody></table></figure>
<p>This could be used to limit the acceptable request body size. Under the hood, it uses <code>MaxBytesReader</code>:</p>
<blockquote>
<p>MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, it tells the ResponseWriter to close the connection after the limit has been reached.</p>
</blockquote>
<h3 id="StripPrefix"><a href="#StripPrefix" title="StripPrefix"></a>StripPrefix</h3><figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span><span>func</span> <span>StripPrefix</span><span>(prefix <span>string</span>, h Handler)</span> <span>Handler</span></span></span><br/></pre></td></tr></tbody></table></figure>
<p>The docs says</p>
<blockquote>
<p>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL‚Äôs Path (and RawPath if set) and invoking the handler h.</p>
</blockquote>
<p>My first impression is how could this be useful. Oh, wait for the blast! Here we go once again with a beautiful copy-paste of an stdlib example.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> main</span></pre></td></tr></tbody></table></figure>
<h3 id="TimeoutHandler"><a href="#TimeoutHandler" title="TimeoutHandler"></a>TimeoutHandler</h3><figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span><span>func</span> <span>TimeoutHandler</span><span>(h Handler, dt time.Duration, msg <span>string</span>)</span> <span>Handler</span></span></span><br/></pre></td></tr></tbody></table></figure>
<p>As the name says, it times out the handler if the request is taking more than the given duration.</p>
<h2 id="Third-party-Middlewares"><a href="#Third-party-Middlewares" title="Third-party Middlewares"></a>Third-party Middlewares</h2><p>I came across this beautiful library called <code>chi</code> which comes loaded up with a bunch of middlewares out of the box: <a target="_blank" rel="noopener" href="https://github.com/go-chi/chi?tab=readme-ov-file#middlewares">https://github.com/go-chi/chi?tab=readme-ov-file#middlewares</a></p>
<p>I would suggest starting with the default chi recommendation:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>and then build up the chain. Go explore and catch ‚Äòem all!</p>
<p>(also let me know your favorite middleware if you have one - because I am trying to discover more third-party middlewares in Go)</p>
<h2 id="Communicate"><a href="#Communicate" title="Communicate"></a>Communicate</h2><p>When writing or using middleware, you may need to pass down a variable that was created by one middleware into another middleware or in the request handler. In the case of JS, we would just mutate the <code>request</code> object directly since it is dynamically typed :D (lol, good old days). In the case of Go, we can‚Äôt do that and we will need a way of passing through variables of any type via the available <code>ResponseWriter</code> or <code>Request</code> objects.</p>
<p>I have previously written a whole blog post on the <a href="https://vishnubharathi.codes/blog/context-with-value-pitfall">pitfalls of context.WithValue</a> and when not to use them. And well, this is actually the use-case where you can use them!</p>
<p>A context variable is available to you in all the middlewares and the handlers via the <code>http.Request</code> object. We could use that to store and pass down information. </p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>You still need to be careful while using <code>context.WithValue</code>. What if you miss calling a middleware, but try to look up the value that it is supposed to set in <code>r.Context</code>? It changes the trajectory of your request during runtime and in the worst case it will lead to runtime panics in your handler. I am wondering if we could somehow catch this kind of stuff during compile time (like maybe by writing a library or perhaps someone already thought about this before - if so, let me know!)</p>
<h2 id="Chain"><a href="#Chain" title="Chain"></a>Chain</h2><p>You might soon end up having to call multiple middleware for your handlers. In that case, your code would look like:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>We need a way to chain the middleware and store the chain so that we can reuse it between handlers. I recently discovered a library for this, which might help here: <a target="_blank" rel="noopener" href="https://github.com/justinas/alice">https://github.com/justinas/alice</a></p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>unAuth := alice.New(Logger, RequestID)</span></pre></td></tr></tbody></table></figure>
<p>You can also use a routing library like <code>chi</code> where the request middlewares are defined at the router level.</p>
<h2 id="Closing-Thoughts"><a href="#Closing-Thoughts" title="Closing Thoughts"></a>Closing Thoughts</h2><p>I hope this exploration was useful to you! It definitely made me learn some unexpected things like ‚Äúwhen to use http.Handle? when to use http.HandleFunc? ‚Ä¶.‚Äù. This is also inspiring me to write a small middleware library that I have been thinking about.</p>
<p>~ ~ ~ ~</p>
<p>In an alternate universe, someone declared <code>type Middleware func(Handler) Handler</code> in <code>net/http</code> and (use your imagination).</p>

  </div></div>
  </body>
</html>
