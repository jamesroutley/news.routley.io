<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bamsoftware.com/hacks/zipbomb/">Original</a>
    <h1>A better zip bomb (2019)</h1>
    
    <div id="readability-page-1" class="page"><article>

<header>


<address id="contact">
<p>
David Fifield</p>
</address>

<p>
<time>2019-07-02</time>
<small>updated <time>2019-07-03</time>, <time>2019-07-05</time>, <time>2019-07-06</time>, <time>2019-07-08</time>,
<time>2019-07-18</time>, <time>2019-07-20</time>, <time>2019-07-22</time>, <time>2019-07-24</time>,
<time>2019-08-05</time>, <time>2019-08-19</time>, <time>2019-08-22</time>, <time>2019-10-14</time>,
<time>2019-10-18</time>, <time>2019-10-30</time>, <a href="#xfinity"><time>2019-11-28</time></a>,
<a href="#flytech"><time>2020-07-28</time></a>, <time>2021-01-21</time>, <time>2021-02-02</time>,
<a href="#ios"><time>2021-05-03</time></a>, <time>2021-07-29</time>,
<a href="#42.zip-tld"><time>2023-05-18</time></a>
</small>
</p>
</header>

<section id="summary">
<h2>Summary</h2>

<p>
This article shows how to construct a
<em>non-recursive</em> <a href="https://en.wikipedia.org/wiki/Zip_bomb">zip bomb</a>
that achieves a high compression ratio by
overlapping files inside the zip container.
&#34;Non-recursive&#34; means that it does not rely on
a decompressor&#39;s recursively unpacking zip files nested within zip files:
it expands fully after a single round of decompression.
The output size increases quadratically in the input size,
reaching a compression ratio of over <data value="28442385.9286689">28 million</data>
(<data value="9893525">10 <abbr title="megabyte">MB</abbr></data> → <data value="281395456244934">281 <abbr title="terabyte">TB</abbr></data>)
at the limits of the zip format.
Even greater expansion is possible using
64-bit extensions.
The construction uses only the most common compression algorithm, DEFLATE,
and is compatible with most zip parsers.
</p>

<div id="download">
<p><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/zip.png" alt=""/></p>
</div>

<dl id="source">
<dt>Source code:</dt>
<dd>
<pre>git clone https://www.bamsoftware.com/git/zipbomb.git</pre>
<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/zipbomb-20210121.zip">zipbomb-20210121.zip</a>
</dd>
<dt>Data and source for figures:</dt>
<dd>
<pre>git clone https://www.bamsoftware.com/git/zipbomb-paper.git</pre>
</dd>
</dl>

<p>
<a href="http://ablwr.github.io/talks/woot19-zipbomb/">Presentation video</a>
</p>

<p>
<a href="https://habr.com/ru/post/459254/">Русский перевод</a> от <a href="https://habr.com/en/users/m1rko/">@m1rko</a>.
</p>
<p>
<a href="https://zerosun.top/2019/07/07/A-better-zip-bomb/">中文翻译</a>: 北岸冷若冰霜.
</p>
<!-- https://blog.csdn.net/u013469753/article/details/106298143 -->
</section>

<section id="introduction">

<table id="comparison">

<!--
Uncompressed size of 42.zip not including intermediate files, only final 0.dll:
>>> 16*16*16*16*16*4294967295
4503599626321920
Uncompressed size of 42.zip including all intermediate files:
>>> 16*(34902 + 16*(29446 + 16*(32150 + 16*(165302 + 16*(4168266 + 4294967295)))))
4507981343026016
-->

<caption id="42-note">
<ul>
<li>
There are two versions of 42.zip,
an <a href="https://web.archive.org/web/20120222083624/http://www.unforgettable.dk/">older version</a> of <data value="42374">42 374</data> bytes,
and a <a href="https://web.archive.org/web/20120301154142/http://www.unforgettable.dk/">newer version</a> of <data value="42838">42 838</data> bytes.
The difference is that the newer version requires a password before unzipping.
We compare only against the older version.
Here is a copy if you need it:
<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/42.zip" download="">42.zip</a>.
</li>
</ul>

</caption>

<thead>
<tr>
<td colspan="2"></td>
<th colspan="2">non-recursive</th>
<th colspan="2">recursive</th>
</tr>
<tr>
<td></td>
<th>zipped size</th>
<th>unzipped size</th>
<th>ratio</th>
<th>unzipped size</th>
<th>ratio</th>
</tr>
</thead>

<tbody>
<tr>
<th><a href="https://research.swtch.com/zip">Cox quine</a></th>
<td><data value="440">440</data></td>
<td><data value="440">440</data></td>
<td><data value="1.0">1.0</data></td>
<td><data value="∞">∞</data></td>
<td><data value="∞">∞</data></td>
</tr>

<tr>
<th><a href="https://web.archive.org/web/20160130230432/http://www.steike.com/code/useless/zip-file-quine/">Ellingsen quine</a></th>
<td><data value="28809">28 809</data></td>
<td><data value="42569">42 569</data></td>
<td><data value="1.4776285188656322">1.5</data></td>
<td><data value="∞">∞</data></td>
<td><data value="∞">∞</data></td>
</tr>

<tr>
<th><a href="https://www.unforgettable.dk/">42.zip</a></th>
<td><a href="#42-note">*</a><data value="42374">42 374</data></td>
<td><data value="558432">558 432</data></td>
<td><data value="13.17864728371171">13.2</data></td>
<td><data value="4507981343026016">4 507 981 343 026 016</data></td>
<td><data value="106385551116.86449">106 billion</data></td>
</tr>

<tr>
<th>this technique</th>
<td><data value="42374">42 374</data></td>
<td><data value="5461307620">5 461 307 620</data></td>
<td><data value="128883.45730872705">129 thousand</data></td>
<td><data value="5461307620">5 461 307 620</data></td>
<td><data value="128883.45730872705">129 thousand</data></td>
</tr>

<tr>
<th>this technique</th>
<td><data value="9893525">9 893 525</data></td>
<td><data value="281395456244934">281 395 456 244 934</data></td>
<td><data value="28442385.9286689">28 million</data></td>
<td><data value="281395456244934">281 395 456 244 934</data></td>
<td><data value="28442385.9286689">28 million</data></td>
</tr>

<tr>
<th>this technique <small>(Zip64)</small></th>
<td><data value="45876952">45 876 952</data></td>
<td><data value="4507981427706459">4 507 981 427 706 459</data></td>
<td><data value="98262444.01996146">98 million</data></td>
<td><data value="4507981427706459">4 507 981 427 706 459</data></td>
<td><data value="98262444.01996146">98 million</data></td>
</tr>

<!--
<tr>
<th>this technique<br><small>(Zip64, less compatible)</small></th>
<td><data value="2961656712">2 961 656 712</data></td>
<td class=nonrec><data value="18446744085437447493">18 446 744 085 437 447 493</data></td>
<td class=nonrec><data value="6228522033.190134">6 billion</data></td>
<td class=rec><data value="18446744085437447493">18 446 744 085 437 447 493</data></td>
<td class=rec><data value="6228522033.190134">6 billion</data></td>
</tr>
-->

</tbody>

</table>





<p>
Compression bombs that use the zip format
must cope with the fact that DEFLATE,
the compression algorithm most commonly supported by zip parsers,
<a href="https://www.zlib.net/zlib_tech.html">cannot achieve</a> a compression ratio greater than 1032.
For this reason, zip bombs typically rely on recursive decompression,
nesting zip files within zip files to get an extra factor of 1032 with each layer.
But the trick only works on implementations that
unzip recursively, and most do not.
The best-known zip bomb,
<a href="https://www.unforgettable.dk/">42.zip</a>,
expands to a formidable <data value="4507981343026016">4.5 <abbr title="petabyte">PB</abbr></data>
if all six of its layers are recursively unzipped,
but a trifling <data value="558432">0.6 <abbr title="megabyte">MB</abbr></data> at the top layer.
Zip quines,
like those of <a href="https://web.archive.org/web/20160130230432/http://www.steike.com/code/useless/zip-file-quine/">Ellingsen</a>
and <a href="https://research.swtch.com/zip">Cox</a>,
which contain a copy of themselves
and thus expand infinitely if recursively unzipped,
are likewise perfectly safe to unzip once.
</p>

<p>
This article shows how to construct a non-recursive zip bomb
whose compression ratio surpasses the DEFLATE limit of 1032.
It works by overlapping files inside the zip container,
in order to reference a &#34;kernel&#34; of highly compressed data
in multiple files,
without making multiple copies of it.
The zip bomb&#39;s output size grows quadratically in the input size; i.e.,
the compression ratio gets better as the bomb gets bigger.
The construction depends on features of both zip and DEFLATE—it
is not directly portable to other file formats or compression algorithms.
It is compatible with most zip parsers,
the exceptions being &#34;streaming&#34; parsers that
parse in one pass without first consulting the zip file&#39;s central directory.
We try to balance
two conflicting goals:
</p>

<ul>
<li>
Maximize the compression ratio.
We define the compression ratio as the the sum of the sizes
of all the files contained the in the zip file,
divided by the size of the zip file itself.
It does not count filenames or other filesystem metadata,
only contents.
</li>
<li>
Be compatible.
Zip is a tricky format and parsers differ, especially
around edge cases and optional features.
Avoid taking advantage of tricks that only work with certain parsers.
We will remark on certain ways to increase the efficiency of the zip bomb
that come with some loss of compatibility.
</li>
</ul>

</section>

<section id="zip">
<h2>Structure of a zip file</h2>

<p>
A zip file consists of
a <em>central directory</em> which references
<em>files</em>.
</p>

<figure id="fig-normal">
<picture>
<source srcset="normal.svg" type="image/svg+xml"/>
<img src="http://ablwr.github.io/blog/2025/12/18/annual-report/normal.png" alt="A block diagram of the structure of a zip file. The central directory header consists of three central directory headers labeled CDH[1] (README), CDH[1] (Makefile), and CDH[3] (demo.c). The central directory headers point backwards to three local file headers LFH[1] (README), LFH[2] (Makefile), and LFH[3] (demo.c). Each local file header is joined with file data. The three joined blocks of (local file header, file data) are labeled file 1, file 2, and file 3."/>
</picture>
</figure>

<p>
The central directory is at the end of the zip file.
It is a list of <em>central directory headers</em>.
Each central directory header contains metadata for a single file,
like its filename and CRC-32 checksum,
and a backwards pointer to a local file header.
A central directory header is 46 bytes long,
plus the length of the filename.
</p>

<p>
A file consists of a <em>local file header</em>
followed by compressed <em>file data</em>.
The local file header is 30 bytes long,
plus the length of the filename.
It contains a redundant copy
of the metadata from the central directory header,
and the compressed and uncompressed sizes of the file data
that follows.
Zip is a container format, not a compression algorithm.
Each file&#39;s data is compressed
using an algorithm specified in the metadata—usually <a href="https://tools.ietf.org/html/rfc1951">DEFLATE</a>.
</p>



<p>
This description of the zip format omits many details that
are not needed for understanding the zip bomb.
For full information,
refer to
<a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">section 4.3 of APPNOTE.TXT</a>
or <a href="https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html">The structure of a PKZip file</a> by Florian Buchholz,
or see the <a href="#source">source code</a>.
</p>

</section>

<section id="overlap">
<h2>The first insight: overlapping files</h2>

<p>
By compressing a long string of repeated bytes,
we can produce a <em>kernel</em>
of highly compressed data.
By itself, the kernel&#39;s compression ratio cannot
exceed the DEFLATE limit of 1032,
so we want a way to reuse the kernel in many files,
without making a separate copy of it in each file.
We can do it by overlapping files:
making many central directory headers point to
a single file, whose data is the kernel.
</p>

<figure id="fig-overlap">
<picture>
<source srcset="overlap.svg" type="image/svg+xml"/>
<img src="http://ablwr.github.io/blog/2025/12/18/annual-report/overlap.png" alt="A block diagram of a zip file with fully overlapping files. The central directory header consists of central directory headers CDH[1], CDH[2], ..., CDH[N−1], CDH[N], with filenames A, B, ..., Y, Z. There is a single local file header LFH[1] with filename A whose file data is a compressed kernel. Every one of the central directory headers points backwards to the same local file header, LFH[1]. The lone file is multiply labeled file 1, file 2, ..., file N−1, file N."/>
</picture>
</figure>

<p>
Let&#39;s look at an example to see how this construction affects the compression ratio.
Suppose the kernel is <data value="1000">1000 bytes</data> and
decompresses to <data value="1000000">1 <abbr title="megabyte">MB</abbr></data>.
Then the first <data value="1000000"><abbr title="megabyte">MB</abbr></data> of output &#34;costs&#34;
<data value="1078">1078 bytes</data> of input:
</p>
<ul>
<li><data value="31">31 bytes</data> for a local file header (including a 1-byte filename)</li>
<li><data value="47">47 bytes</data> for a central directory header (including a 1-byte filename)</li>
<li><data value="1000">1000 bytes</data> for the kernel itself</li>
</ul>
<p>
But every <data value="1000000">1 <abbr title="megabyte">MB</abbr></data> of output
after the first costs only <data value="47">47 bytes</data>—we don&#39;t need another local file header or another copy of the kernel,
only an additional central directory header.
So while the first reference of the kernel has a compression ratio of
1 000 000 / 1078 ≈ 928,
each additional reference pulls the ratio closer to
1 000 000 / 47 ≈ 21 277.
A bigger kernel raises the ceiling.
</p>

<p>
The problem with this idea is a lack of compatibility.
Because many central directory headers point to a single local file header,
the metadata—specifically the filename—cannot match for every file.
Some parsers <a href="#compatibility">balk at that</a>.
<a href="http://infozip.sourceforge.net/UnZip.html">Info-ZIP UnZip</a>
(the standard Unix <code>unzip</code> program)
extracts the files, but with warnings:
</p>
<figure>
<pre>$ <kbd>unzip overlap.zip</kbd>
<samp>  inflating: A
B:  mismatching &#34;local&#34; filename (A),
         continuing with &#34;central&#34; filename version
  inflating: B
<i>...</i></samp>
</pre>
</figure>
<p>
And the Python <a href="https://docs.python.org/3/library/zipfile.html">zipfile</a> module
<a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1486-L1489">throws an exception</a>:
</p>
<figure>
<pre>$ <kbd>python3 -m zipfile -e overlap.zip .</kbd>
<samp>Traceback (most recent call last):
<i>...</i>
__main__.BadZipFile: File name in directory &#39;B&#39; and header b&#39;A&#39; differ.</samp>
</pre>
</figure>
<!--
<p>
We could make every central directory header have the same filename
as the local file header, but that too is unsatisfying
because it means that if extracted to disk,
all the files will just overwrite each other and not take up more space
than a single file.
</p>
-->

<p>
Next we will see how to modify the construction
for consistency of filenames,
while still retaining most of the advantage
of overlapping files.
</p>

</section>

<section id="quote">
<h2>The second insight: quoting local file headers</h2>

<p>
We need to separate the local file headers for each file,
while still reusing a single kernel.
Simply concatenating all the local file headers does not work,
because the zip parser will find a local file header
where it expects to find the beginning of a DEFLATE stream.
But the idea will work, with a minor modification.
We&#39;ll use a feature of DEFLATE, non-compressed blocks,
to &#34;quote&#34; local file headers
so that they appear to be part of the same DEFLATE stream
that terminates in the kernel.
Every local file header
(except the first)
will be interpreted in two ways:
as code (part of the structure of the zip file)
and as data (part of the contents of a file).
</p>

<figure id="fig-quote">
<picture>
<source srcset="quote.svg" type="image/svg+xml"/>
<img src="http://ablwr.github.io/blog/2025/12/18/annual-report/quote.png" alt="A block diagram of a zip file with quoted local file headers. The central directory header consists of central directory headers CDH[1], CDH[2], ..., CDH[N−1], CDH[N], with filenames A, B, ..., Y, Z. The central directory headers point to corresponding local file headers LFH[1], LFH[2], ..., LFH[N−1], LFH[N] with filenames A, B, ..., Y, Z. The files are drawn and labeled to show that file 1 does not end before file 2 begins; rather file 1 contains file 2, file 2 contains file 3, and so on. There is a small green-colored space between LFH[1] and LFH[2], and between LFH[2] and LFH[3], etc., to stand for quoting the following local file header using an uncompressed DEFLATE block. The file data of the final file, whose local file header is LFH[N] and whose filename is Z, does not contain any other files, only the compressed kernel."/>
</picture>
</figure>

<p>
A DEFLATE stream is a sequence of
<a href="https://tools.ietf.org/html/rfc1951#section-3.2.3">blocks</a>,
where each block may be compressed or non-compressed.
Compressed blocks are what we usually think of;
for example the kernel is one big compressed block.
But there are also non-compressed blocks,
which start with a
<a href="https://tools.ietf.org/html/rfc1951#section-3.2.4">5-byte header</a>
with a length field that means simply, &#34;output the next <var>n</var> bytes verbatim.&#34;
Decompressing a non-compressed block means only stripping the 5-byte header.
Compressed and non-compressed blocks may be intermixed freely
in a DEFLATE stream.
The output is the concatenation of
decompressing all the blocks in order.
The &#34;non-compressed&#34; notion only has meaning at the DEFLATE layer;
the file data still counts as &#34;compressed&#34; at the zip layer,
no matter what kind of blocks are used.
</p>

<p>
It is easiest to understand this quoted-overlap construction from the inside out,
beginning with the last file and working backwards to the first.
Start by inserting the kernel, which will form the end of file data for every file.
Prepend a local file header LFH<sub><var>N</var></sub>
and add a central directory header CDH<sub><var>N</var></sub> that points to it.
Set the &#34;compressed size&#34; metadata field in the LFH<sub><var>N</var></sub> and CDH<sub><var>N</var></sub> to the compressed size of the kernel.
Now prepend a 5-byte non-compressed block header (colored green in the diagram)
whose length field is equal to the size of LFH<sub><var>N</var></sub>.
Prepend a second local file header LFH<sub><var>N</var>−1</sub>
and add a central directory header CDH<sub><var>N</var>−1</sub> that points to it.
Set the &#34;compressed size&#34; metadata field in both of the new headers to the compressed size of the kernel
<em>plus</em> the size of the non-compressed block header (5 bytes)
<em>plus</em> the size of LFH<sub><var>N</var></sub>.
</p>



<p>
At this point the zip file contains two files, named &#34;Y&#34; and &#34;Z&#34;.
Let&#39;s walk through what a zip parser would see while parsing it.
Suppose the compressed size of the kernel is 1000 bytes
and the size of LFH<sub><var>N</var></sub> is 31 bytes.
We start at CDH<sub><var>N</var>−1</sub>
and follow the pointer to LFH<sub><var>N</var>−1</sub>.
The first file&#39;s filename is &#34;Y&#34; and
the compressed size of its file data is 1036 bytes.
Interpreting the next 1036 bytes as a DEFLATE stream,
we first encounter the 5-byte header of a non-compressed block
that says to copy the next 31 bytes.
We write the next 31 bytes,
which are LFH<sub><var>N</var></sub>,
which we decompress and append to file &#34;Y&#34;.
Moving on in the DEFLATE stream, we find a compressed block (the kernel),
which we decompress to file &#34;Y&#34;.
Now we have reached the end of the compressed data and are done with file &#34;Y&#34;.
Proceeding to the next file, we follow the pointer from CDH<sub><var>N</var></sub>
to LFH<sub><var>N</var></sub> and find a file named &#34;Z&#34;
whose compressed size is 1000 bytes.
Interpreting those 1000 bytes as a DEFLATE stream,
we immediately encounter a compressed block (the kernel again)
and decompress it to the file &#34;Z&#34;.
Now we have reached the end of the final file and are done.
The output file &#34;Z&#34; contains the decompressed kernel;
the output file &#34;Y&#34; is the same, but additionally prefixed by
the 31 bytes of
LFH<sub><var>N</var></sub>.
</p>

<p>
We complete the construction by repeating the quoting procedure
until the zip file contains the desired number of files.
Each new file adds a central directory header,
a local file header,
and a non-compressed block to quote the immediately succeeding local file header.
Compressed file data is generally a chain of DEFLATE non-compressed blocks
(the quoted local file headers)
followed by the compressed kernel.
Each byte in the kernel contributes about
1032 <var>N</var> to the output size,
because each byte is part of all <var>N</var> files.
The output files are not all the same size:
those that appear earlier in the zip file
are larger than those that appear later,
because they contain more quoted local file headers.
The contents of the output files are not particularly meaningful,
but no one said they had to make sense.
</p>

<p>
This quoted-overlap construction has better compatibility
than the full-overlap construction of the previous section,
but the compatibility comes at the expense of the compression ratio.
There, each added file cost only a central directory header;
here, it costs a central directory header,
a local file header,
and another 5 bytes for the quoting header.
</p>

<!--
<figure>
<pre>
File "A": compressed size 1900, uncompressed size 1000775
Non-compressed block header for the next 31 bytes
...
File "X": compressed size 1072, uncompressed size 1000062
Non-compressed block header for the next 31 bytes
File "Y": compressed size 1036, uncompressed size 1000031
Non-compressed block header for the next 31 bytes
File "Z": compressed size 1000, uncompressed size 1000000
Kernel
Central Directory Header "A"
...
Central Directory Header "X"
Central Directory Header "Y"
Central Directory Header "Z"
</pre>
</figure>
-->

</section>

<section id="optimization">
<h2>Optimization</h2>

<p>
Now that we have the basic zip bomb construction,
we will try to make it as efficient as possible.
We want to answer two questions:
</p>
<ul>
<li>For a given zip file size, what is the maximum compression ratio?</li>
<li>What is the maximum compression ratio, given the limits of the zip format?</li>
</ul>

<section id="bulkdeflate">
<h3>Kernel compression</h3>

<p>
It pays to compress the kernel as densely as possible,
because every decompressed byte gets magnified by a factor of <var>N</var>.
To that end, we use a custom DEFLATE compressor
called bulk_deflate,
specialized for compressing
a string of repeated bytes.
</p>

<!--
         engine compressed_size max_uncompressed_size
1: bulk_deflate           21090              21749401
2:         zlib           21090              21723602
3:       zopfli           21090              21734018
-->

<p>
All decent DEFLATE compressors will approach a compression ratio of 1032
when given an infinite stream of repeating bytes,
but we care more about specific finite sizes
than asymptotics.
bulk_deflate compresses more data
into the same space than the general-purpose compressors:
about 26 kB more than zlib and Info-ZIP,
and about 15 kB more than
<a href="https://github.com/google/zopfli">Zopfli</a>,
a compressor that trades speed for density.
</p>

<figure id="max_uncompressed_size">
<picture>
<source srcset="max_uncompressed_size.svg" type="image/svg+xml"/>
<img src="http://ablwr.github.io/blog/2025/12/18/annual-report/max_uncompressed_size.png" alt="A scatterplot showing the maximum uncompressed data for a given DEFLATE stream size, for four compression engines: bulk_deflate, Zopfli, zlib, and Info-ZIP. The points form three lines because zlib and Info-ZIP were identical. All three lines have a slope of 1032. For a given DEFLATE stream size, bulk_deflate compresses about 15 kB more than Zopfli, and Zopfli compresses about 10 kB more than zlib/Info-ZIP."/>
</picture>
</figure>

<p>
The price of bulk_deflate&#39;s high compression ratio is a lack of generality.
bulk_deflate can only compress strings of a single repeated byte,
and only those of specific lengths,
namely 517 + 258 <var>k</var> for integer <var>k</var> ≥ 0.
Besides compressing densely, bulk_deflate is fast,
doing essentially constant work regardless of the input size,
aside from the work of actually writing out the compressed string.
</p>

</section>

<section id="filenames">
<h3>Filenames</h3>



<p>
For our purposes, filenames are mostly dead weight.
While filenames do contribute something to the output size
by virtue of being part of quoted local file headers,
a byte in a filename does not contribute nearly as much
as a byte in the kernel.
We want filenames to be as short as possible,
while keeping them all distinct,
and subject to compatibility considerations.
</p>



<p>
The first compatibility consideration is character encoding.
The zip format specification states that filenames
are to be interpreted as <a href="https://en.wikipedia.org/wiki/Code_page_437">CP 437</a>,
or <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> if a certain flag bit is set
(<a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">APPNOTE.TXT Appendix D</a>).
But this is a major point of incompatibility
across zip parsers,
which may interpret filenames as being in
some fixed or locale-specific encoding.
So for compatibility, we must limit ourselves to characters
that have the same encoding in both
CP 437 and UTF-8;
namely, the 95 printable characters of US-ASCII.
</p>



<p>
We are further restricted by filesystem naming limitations.
Some filesystems are case-insensitive, so &#34;a&#34; and &#34;A&#34; do not count as distinct names.
Common filesystems like FAT32
<a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits">prohibit certain characters</a>
like &#39;*&#39; and &#39;?&#39;.
</p>

<p>
As a safe but not necessarily optimal compromise,
our zip bomb will use filenames consisting of characters
drawn from a 36-character alphabet
that does not
rely on case distinctions
or use special characters:
</p>
<figure>
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
</figure>
<p>
Filenames are generated in the obvious way,
cycling each position through the possible characters
and adding a position on overflow:
</p>
<figure>
&#34;0&#34;, &#34;1&#34;, &#34;2&#34;, …, &#34;Z&#34;,</figure>

<p>
There are 36 filenames of length 1,
36<sup>2</sup> filenames of length 2, and so on.
The length of the <var>n</var>th filename is
⌊log<sub>36</sub>((<var>n</var> + 1) / (36 / 35))⌋ + 1.
<!--
The sum of the lengths of the first <var>n</var> filenames is
<var>d</var><var>n</var> − ((36<sup><var>d</var></sup> − 1) ⋅ (36 / 35<sup>2</sup>) − <var>d</var> / 35),
where <var>d</var> = ⌊log<sub>36</sub>(<var>n</var> / (36 / 35))⌋.
-->
Four bytes are enough to represent
<data value="1727604">1 727 604</data> distinct filenames.
</p>

<p>
Given that the <var>N</var> filenames in the zip file
are generally not all of the same length,
which way should we order them,
shortest to longest or longest to shortest?
A little reflection shows that it is better to
put the longest names last, because those names are the most quoted.
Ordering filenames longest last
adds over <data value="929872440">900 <abbr title="megabyte">MB</abbr></data> of output
to <a href="#allocation">zblg.zip</a>,
compared to ordering them longest first.
It is a minor optimization, though,
as those <data value="929872440">900 <abbr title="megabyte">MB</abbr></data>
comprise only <data value="0.000003304504104">0.0003%</data>
of the total output size.
</p>

<!--
$ unzip -l zblg.zip | tail -n 1
281395456244934                     65534 files
$ unzip -l zblg.rev.zip | tail -n 1
281394526372494                     65534 files
$ python
>>> 281395456244934 - 281394526372494
929872440
>>> 929872440 / 281395456244934. * 100
0.00033045041039703735
-->

</section>

<section id="allocation">
<h3>Kernel size</h3>

<p>
The quoted-overlap construction
allows us to place a compressed kernel of data,
and then cheaply copy it many times.
For a given zip file size <var>X</var>,
how much space should we devote to storing the kernel,
and how much to making copies?
</p>

<p>
To find the optimum balance,
we only have to optimize the single variable <var>N</var>,
the number of files in the zip file.
Every value of <var>N</var> requires
a certain amount of overhead for
central directory headers,
local file headers,
quoting block headers, and filenames.
All the remaining space can be taken up by the kernel.
Because <var>N</var> has to be an integer,
and you can only fit so many files
before the kernel size drops to zero,
it suffices to test every possible value of <var>N</var>
and select the one that yields the most output.
</p>

<p>
Applying the optimization procedure to <var>X</var> = 42 374,
the size of 42.zip,
finds a maximum at <var>N</var> = 250.
Those 250 files require <data value="21195">21 195</data> bytes of overhead,
leaving <data value="21179">21 179</data> bytes for the kernel.
A kernel of that size decompresses to <data value="21841249">21 841 249</data> bytes
(a ratio of <data value="1031.2691345200435">1031.3</data>).
The 250 copies of the decompressed kernel,
plus the little bit extra that comes from the quoted local file headers,
produces an overall unzipped output of
5 461 307 620 bytes
and a compression ratio of <data value="128883.45730872705">129 thousand</data>.

</p><div id="download-zbsm">
<p><a href="http://ablwr.github.io/blog/2025/12/18/annual-report/zbsm.zip" download=""><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/zip.png" alt=""/> zbsm.zip</a>
<span><data value="42374">42 <abbr title="kilobyte">kB</abbr></data> → <data value="5461307620">5.5 <abbr title="gigabyte">GB</abbr></data></span></p><pre>zipbomb --mode=quoted_overlap --num-files=250 --compressed-size=21179 &gt; zbsm.zip</pre>
</div>

<p>
Optimization produced an almost even split
between the space allocated to the kernel
and the space allocated to file headers.
It is not a coincidence.
Let&#39;s look at a simplified model of the quoted-overlap construction.
In the simplified model,
we ignore filenames,
as well as the slight increase in output file size
due to quoting local file headers.
Analysis of the simplified model will show that the optimum
split between kernel and file headers is approximately even,
and that the output size grows quadratically
when allocation is optimal.
</p>

<p>
Define some constants and variables:
</p>

<figure>
<table>
<tbody><tr>
<td><var>X</var></td><td></td><td>zip file size (take as fixed)</td>
</tr>
<tr>
<td><var>N</var></td><td></td><td>number of files in the zip file (variable to optimize)</td>
</tr>
<tr>
<td>CDH</td><td> = 46</td><td>size of a central directory header (without filename)</td>
</tr>
<tr>
<td>LFH</td><td> = 30</td><td>size of a local file header (without filename)</td>
</tr>
<tr>
<td>Q</td><td> = 5</td><td>the size of DEFLATE non-compressed block header</td>
</tr>
<tr>
<td>C</td><td> ≈ 1032</td><td>compression ratio of the kernel</td>
</tr>
</tbody></table>
</figure>

<!--
JACAL session to do the algebra and calculus:

# S_X(N)
e1 : C * N * (X - (N * (LFH + CDH) + (N - 1) * Q)));
                                                  ^

                       2             2
e1: (- C CDH - C LFH) N  + (C N - C N ) Q + C N X

# S_X(N) as a polynomial in N
e2 : coeffs(e1, N);

e2: [0, C Q + C X, - C CDH - C LFH - C Q]

# S'_X(N)
e3 : diff(e1, N);

e3: (- 2 C CDH - 2 C LFH) N + (C - 2 C N) Q + C X

# S'_X(N) as a polynomial in N
e4 : coeffs(e3, N);

e4: [C Q + C X, - 2 C CDH - 2 C LFH - 2 C Q]

# Solve S'_X(N) = 0. e5 == N_OPT
e5 : suchthat(N, e3);

           Q + X
e5: - - - - - - - - - -
    2 CDH + 2 LFH + 2 Q

# H(N_OPT)
e6 : e5 * (LFH + CDH) + (e5 - 1) * Q;

    - Q + X
e6: - - - -
       2

# S_X(N_OPT)
e7 : -C * (CDH + LFH + Q) * e5^2 + C * (Q + X) * e5;

       2                2
    C Q  + 2 C Q X + C X
e7: - - - - - - - - - - -
     4 CDH + 4 LFH + 4 Q
-->

<p>
Let <var>H</var>(<var>N</var>)
be the amount of header overhead required by <var>N</var> files.
Refer to
<a href="#fig-quote">the diagram</a>
to understand where this formula comes from.
</p>

<figure>
<table>
<tbody><tr>
<td><var>H</var>(<var>N</var>)</td><td> = <var>N</var> ⋅ (CDH + LFH) + (<var>N</var> − 1) ⋅ Q</td>
</tr>
</tbody></table>
</figure>

<p>
The space remaining for the kernel is
<var>X</var> − <var>H</var>(<var>N</var>).
The total unzipped size
<var>S</var><sub><var>X</var></sub>(<var>N</var>)
is the size of <var>N</var> copies
of the kernel,
decompressed at ratio C.
(In this simplified model we ignore
the minor additional expansion from quoted local file headers.)
</p>

<figure>
<table>
<tbody><tr>
<td><var>S</var><sub><var>X</var></sub>(<var>N</var>)</td><td> = (<var>X</var> − <var>H</var>(<var>N</var>)) C <var>N</var></td>
</tr>
<tr>
<td></td><td> = (<var>X</var> − (<var>N</var> ⋅ (CDH + LFH) + (<var>N</var> − 1) ⋅ Q)) C <var>N</var></td>
</tr>
<tr>
<td></td><td> = −(CDH + LFH + Q) C <var>N</var><sup>2</sup> + (<var>X</var> + Q) C <var>N</var></td>
</tr>
</tbody></table>
</figure>

<p>
<var>S</var><sub><var>X</var></sub>(<var>N</var>) is a polynomial in <var>N</var>,
so its maximum must be at a place where the derivative
<var>S</var>′<sub><var>X</var></sub>(<var>N</var>)
is zero.
Taking the derivative and finding the zero gives us
<var>N</var><sub>OPT</sub>,
the optimal number of files.
</p>

<figure>
<table>
<tbody><tr>
<td><var>S</var>′<sub><var>X</var></sub>(<var>N</var><sub>OPT</sub>)</td><td> = −2 (CDH + LFH + Q) C <var>N</var><sub>OPT</sub> + (<var>X</var> + Q) C</td>
</tr>
<tr>
<td>0</td><td> = −2 (CDH + LFH + Q) C <var>N</var><sub>OPT</sub> + (<var>X</var> + Q) C</td>
</tr>
<tr>
<td><var>N</var><sub>OPT</sub></td><td> = (<var>X</var> + Q) / (CDH + LFH + Q) / 2</td>
</tr>
</tbody></table>
</figure>

<p>
<var>H</var>(<var>N</var><sub>OPT</sub>)
gives the optimal amount of space to allocate for file headers.
It is independent of CDH, LFH, and C,
and is close to <var>X</var> / 2.
</p>

<figure>
<table>
<tbody><tr>
<td><var>H</var>(<var>N</var><sub>OPT</sub>)</td><td> = <var>N</var><sub>OPT</sub> ⋅ (CDH + LFH) + (<var>N</var><sub>OPT</sub> − 1) ⋅ Q</td>
</tr>
<tr>
<td></td><td> = (<var>X</var> − Q) / 2</td>
</tr>
</tbody></table>
</figure>

<p>
<var>S</var><sub><var>X</var></sub>(<var>N</var><sub>OPT</sub>)
is the total unzipped size
when the allocation is optimal.
From this we see that the output size grows quadratically
in the input size.
</p>

<figure id="eq-S_X_N_OPT">
<table>
<tbody><tr>
<td>
<var>S</var><sub><var>X</var></sub>(<var>N</var><sub>OPT</sub>)</td><td> = (<var>X</var> + Q)<sup>2</sup> C / (CDH + LFH + Q) / 4</td>
</tr>
</tbody></table>
</figure>



<p>
As we make the zip file larger,
eventually we run into the limits of the zip format.
A zip file can contain at most 2<sup>16</sup> − 1 files,
and each file can have an uncompressed size of at most 2<sup>32</sup> − 1 bytes.
Worse than that,
<a href="#compatibility">some implementations</a>
take the maximum possible values
as an indicator of the presence of <a href="#zip64">64-bit extensions</a>,
so our limits are actually 2<sup>16</sup> − 2 and 2<sup>32</sup> − 2.
<!--
https://github.com/golang/go/commit/4aedbf5be4631693f774063410707ef467ca78e7
https://github.com/golang/go/commit/b6c5edae7c0e9dd6d12dbb8f1c9638dea45f9464
-->
It happens that the first limit we hit is the one on uncompressed file size.
At a zip file size of 8 319 377 bytes,
naive optimization would give us a file count of 47 837
and a largest file of
2<sup>32</sup> + 311 bytes.
</p>

<!--
$compressed_size
[1] 4160277

$num_files
[1] 47837

[1] "zipped size" "8319377"
[1] "unzipped size"   "205420672417247"
[1] 4294967607
-->

<p>
Accepting that we cannot increase <var>N</var> nor the size of the kernel without bound,
we would like find the maximum compression ratio achievable
while remaining within the limits of the zip format.
The way to proceed is to make the kernel as large as possible,
and have the maximum number of files.
Even though we can no longer maintain the roughly even split
between kernel and file headers,
each added file <em>does</em> increase the compression ratio—just
not as fast as it would if we were able to keep growing the kernel, too.
In fact, as we add files we will need to <em>decrease</em> the size of the kernel
to make room for the maximum file size
that gets slightly larger with each added file.
</p>

<p>
The plan results in a zip file
that contains 2<sup>16</sup> − 2 files and a kernel that decompresses
to 2<sup>32</sup> − 2 178 825 bytes.
Files get longer towards the beginning of the zip file—the
first and largest file decompresses to
2<sup>32</sup> − 56 bytes.
That is as close as we can get using the coarse
output sizes of bulk_deflate—encoding
the final 54 bytes would cost more bytes than they are worth.
(The zip file as a whole has a compression ratio
of 28 million, and the final 54 bytes would gain
at most 54 ⋅ 1032 ⋅ (2<sup>16</sup> − 2) ≈ <data value="3652078752">36.5 million bytes</data>,
so it only helps if the 54 bytes can be encoded
in 1 byte—I could not do it in less than 2.)
The output size of this zip bomb, 281 395 456 244 934 bytes,
is 99.97% of the theoretical maximum
(2<sup>32</sup> − 1) ⋅ (2<sup>16</sup> − 1).
<!-- 65 535 × 0xffffffff = <data value="281470681677825">281 470 681 677 825</data>. -->
Any major improvements to the compression ratio can only come
from reducing the input size,
not increasing the output size.
<!--
>>> (2**32-1)*65535 - 281399752637796
70929040029
>>> 70929040029. / ((2**32-1)*65535)
0.00025199441592352524
>>> 1 - _
0.9997480055840765
>>> _ * 100
99.97480055840765
-->
</p>

<div id="download-zblg">
<p><a href="http://ablwr.github.io/blog/2025/12/18/annual-report/zblg.zip" download=""><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/zip.png" alt=""/> zblg.zip</a>
<span><data value="9893525">10 <abbr title="megabyte">MB</abbr></data> → <data value="281395456244934">281 <abbr title="terabyte">TB</abbr></data></span></p><pre>zipbomb --mode=quoted_overlap --num-files=65534 --max-uncompressed-size=4292788525 &gt; zblg.zip</pre>
</div>

</section>

</section>

<section id="crc32">
<h2>Efficient CRC-32 computation</h2>

<p>
Among the metadata in the central directory header and local file header
is a
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC-32</a>
checksum of the uncompressed file data.
This poses a problem, because directly calculating the CRC-32 of each file
requires doing work proportional to the total <em>unzipped</em> size,
which is large by design. (It&#39;s a zip bomb, after all.)
We would prefer to do work that in the worst case is
proportional to the <em>zipped</em> size.
Two factors work in our advantage:
all files share a common suffix (the kernel),
and the uncompressed kernel is a string of repeated bytes.
We will represent CRC-32 as a matrix product—this
will allow us not only to compute the checksum of the kernel quickly,
but also to reuse computation across files.
The technique described in this section is a slight extension of the
<a href="https://github.com/madler/zlib/blob/v1.2.11/crc32.c#L372"><code>crc32_combine</code></a>
function in zlib,
which Mark Adler explains
<a href="https://stackoverflow.com/questions/23122312/crc-calculation-of-a-mostly-static-data-stream/23126768#23126768">here</a>.
</p>

<p>
You can model CRC-32 as a state machine that updates a 32-bit state register
for each incoming bit.
The basic update operations for a 0 bit and a 1 bit are:
</p>

<figure>
<pre><code>uint32 crc32_update_0(uint32 state) {
    // Shift out the least significant bit.
    bit b = state &amp; 1;
    state = state &gt;&gt; 1;
    // If the shifted-out bit was 1, XOR with the CRC-32 constant.
    if (b == 1)
        state = state ^ 0xedb88320;
    return state;
}

uint32 crc32_update_1(uint32 state) {
    // Do as for a 0 bit, then XOR with the CRC-32 constant.
    return crc32_update_0(state) ^ 0xedb88320;
}</code></pre>
</figure>

<p>
If you think of the state register as a 32-element binary vector,
and use XOR for addition and AND for multiplication, then
<code>crc32_update_0</code> is a
<a href="https://en.wikipedia.org/wiki/Linear_map">linear transformation</a>;
i.e., it can be represented as multiplication by a
32×32 binary
<a href="https://en.wikipedia.org/wiki/Transformation_matrix">transformation matrix</a>.
To see why, observe that multiplying a matrix by a vector
is just summing the columns of the matrix,
after multiplying each column by the corresponding element of the vector.
The shift operation <code>state &gt;&gt; 1</code>
is just taking each bit <var>i</var> of the state vector
and multiplying it by a vector that is 0 everywhere except at bit <var>i</var> − 1
(numbering the bits from right to left).
The conditional final XOR <code>state ^ 0xedb88320</code>
that only happens when bit <code>b</code> is 1
can instead be represented as first multiplying
<code>b</code> by 0xedb88320
and then XORing it into the state.
</p>

<p>
Furthermore, <code>crc32_update_1</code> is just
<code>crc32_update_0</code> plus (XOR) a constant.
That makes <code>crc32_update_1</code> an
<a href="https://en.wikipedia.org/wiki/Affine_transformation">affine transformation</a>:
a matrix multiplication followed by a translation (i.e., vector addition).
We can represent both the matrix multiplication and the translation
in a single step
if we enlarge the dimensions of the transformation matrix to 33×33
and append an extra element to the state vector that is always 1.
(This representation is called
<a href="https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations">homogeneous coordinates</a>.)
</p>

<figure>

<table>
<caption><var>M</var><sub>0</sub></caption>
<tbody>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</tbody>
</table><!--

--><table>
<caption><var>M</var><sub>1</sub></caption>
<tbody>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</tbody>
</table>
<figcaption>
The 33×33 transformation matrices <var>M</var><sub>0</sub> and <var>M</var><sub>1</sub> that compute
the CRC-32 state change effected by a 0 bit and a 1 bit respectively.
Column vectors are stored with the most significant bit at the bottom:
reading the first column from bottom to top, you see
the CRC-32 polynomial constant edb88320<sub>16</sub> =
<span>1</span><span>1</span><span>1</span><span>0</span><span>1</span><span>1</span><span>0</span><span>1</span><span>1</span><span>0</span><span>1</span><span>1</span><span>1</span><span>0</span><span>0</span><span>0</span><span>1</span><span>0</span><span>0</span><span>0</span><span>0</span><span>0</span><span>1</span><span>1</span><span>0</span><span>0</span><span>1</span><span>0</span><span>0</span><span>0</span><span>0</span><span>0</span><sub>2</sub>.
The two matrices differ only in the final column, which represents a translation vector
in homogeneous coordinates.
In <var>M</var><sub>0</sub> the translation is zero and
in <var>M</var><sub>1</sub> it is edb88320<sub>16</sub>, the CRC-32 polynomial constant.
The 1&#39;s just above the diagonal represent the
shift operation <code>state &gt;&gt; 1</code>.
</figcaption>
</figure>

<p>
Both operations <code>crc32_update_0</code> and <code>crc32_update_1</code>
can be represented by a 33×33 transformation matrix.
The matrices <var>M</var><sub>0</sub> and <var>M</var><sub>1</sub> are shown.
The benefit of a matrix representation is that matrices compose.
Suppose we want to represent the state change effected by processing
the ASCII character &#39;a&#39;, whose binary representation is
01100001<sub>2</sub>.
We can represent the cumulative CRC-32 state change of those 8 bits
in a single transformation matrix:
</p>
<figure>
<table>
<tbody><tr>
<td><var>M</var><sub>a</sub></td><td> = <var>M</var><sub>0</sub> <var>M</var><sub>1</sub> <var>M</var><sub>1</sub> <var>M</var><sub>0</sub> <var>M</var><sub>0</sub> <var>M</var><sub>0</sub> <var>M</var><sub>0</sub> <var>M</var><sub>1</sub></td>
</tr>
</tbody></table>
</figure>
<p>
And we can represent the state change of a string of repeated &#39;a&#39;s
by multiplying many copies of <var>M</var><sub>a</sub> together—matrix exponentiation.
We can do matrix exponentiation quickly
using a <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">square-and-multiply</a> algorithm,
which allows us to compute <var>M</var><sup><var>n</var></sup>
in only about log<sub>2</sub> <var>n</var> steps.
For example, the matrix representing the state change
of a string of 9 &#39;a&#39;s is
</p>
<figure>
<table>
<tbody><tr>
<td>(<var>M</var><sub><code>a</code></sub>)<sup>9</sup></td><td> = <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub></td>
</tr>
<tr>
<td></td><td> = (<var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub>)<sup>2</sup> <var>M</var><sub><code>a</code></sub></td>
</tr>
<tr>
<td></td><td> = ((<var>M</var><sub><code>a</code></sub> <var>M</var><sub><code>a</code></sub>)<sup>2</sup>)<sup>2</sup> <var>M</var><sub><code>a</code></sub></td>
</tr>
<tr>
<td></td><td> = (((<var>M</var><sub><code>a</code></sub>)<sup>2</sup>)<sup>2</sup>)<sup>2</sup> <var>M</var><sub><code>a</code></sub></td>
</tr>
</tbody></table>
</figure>

<p>
The square-and-multiply algorithm is useful
for computing <var>M</var><sub>kernel</sub>,
the matrix for the uncompressed kernel,
because the kernel is a string of repeated bytes.
To produce a CRC-32 checksum value from a matrix,
multiply the matrix by the zero vector.
(The zero vector in homogeneous coordinates, that is:
32 0&#39;s followed by a 1.
Here we omit the minor complication of pre- and post-conditioning the checksum.)
To compute the checksum for every file, we work backwards.
Start by initializing <var>M</var> := <var>M</var><sub>kernel</sub>.
The checksum of the kernel is also the checksum
of the final file, file <var>N</var>,
so multiply <var>M</var> by the zero vector and store the resulting checksum in
CDH<sub><var>N</var></sub> and LFH<sub><var>N</var></sub>.
The file data of file <var>N</var> − 1 is the same as the file data of file <var>N</var>,
but with an added prefix of LFH<sub><var>N</var></sub>.
So compute <var>M</var><sub>LFH<sub><var>N</var></sub></sub>,
the state change matrix for LFH<sub><var>N</var></sub>,
and update <var>M</var> := <var>M</var> <var>M</var><sub>LFH<sub><var>N</var></sub></sub>.
Now <var>M</var> represents the cumulative state change from processing
LFH<sub><var>N</var></sub> followed by the kernel.
Compute the checksum for file <var>N</var> − 1 by again multiplying <var>M</var> by the zero vector.
Continue the procedure, accumulating state change matrices into <var>M</var>,
until all the files have been processed.
</p>

<!--
<p>
The <a href=#source>source code</a> employs an additional
optimization on top of the conceptual scheme outlined in the previous paragraph.
Instead of updating
<var>M</var> := <var>M</var> <var>M</var><sub>LFH<sub><var>i</var></sub></sub>
after each file, we update
<var>M</var> := <var>M</var> (<var>M</var><sub>0</sub>)<sup>|LFH<sub><var>i</var></sub>|</sup>,
where |LFH<sub><var>i</var></sub>|
is the size of LFH<sub><var>i</var></sub> in bytes.
</p>
-->

</section>

<section id="zip64">
<h2>Extension: Zip64</h2>

<p>
<a href="#allocation">Earlier</a> we hit a wall on expansion
due to limits of the zip format—it was impossible
to produce more than about 281 TB of output,
no matter how cleverly packed the zip file.
It is possible to surpass those limits
using <a href="https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64">Zip64</a>,
an extension to the zip format that increases
the size of certain header fields to 64 bits.
Support for Zip64 is <a href="#compatibility">by no means universal</a>,
but it is one of the more commonly implemented extensions.
As regards the compression ratio,
the effect of Zip64 is to
increase the size of a central directory header from
46 bytes to 58 bytes,
and the size of a local directory header from
30 bytes to 50 bytes.
Referring to
<a href="#eq-S_X_N_OPT">the formula</a>
for optimal expansion in the simplified model,
we see that a zip bomb in Zip64 format
still grows quadratically,
but more slowly because of the larger denominator—this
is visible in
<a href="#zipped_size">the figure below</a>
in the Zip64 line&#39;s
slightly lower vertical placement.
In exchange for the loss of compatibility
and slower growth,
we get the removal of all practical file size limits.
</p>

<p>
Suppose we want a zip bomb that expands to
<data value="4507981343026016">4.5 <abbr title="petabyte">PB</abbr></data>,
the same size that 42.zip recursively expands to.
How big must the zip file be?
Using binary search, we find that the smallest
zip file whose unzipped size exceeds the unzipped size of 42.zip
has a zipped size of
<data value="45876952">46 <abbr title="megabyte">MB</abbr></data>.
</p>

<div id="download-zbxl">
<p><a href="http://ablwr.github.io/blog/2025/12/18/annual-report/zbxl.zip" download=""><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/zip.png" alt=""/> zbxl.zip</a>
<span><data value="45876952">46 <abbr title="megabyte">MB</abbr></data> → <data value="4507981427706459">4.5 <abbr title="petabyte">PB</abbr></data> (Zip64, less compatible)</span></p><pre>zipbomb --mode=quoted_overlap --num-files=190023 --compressed-size=22982788 --zip64 &gt; zbxl.zip</pre>
</div>

<p>
4.5 <abbr title="petabyte">PB</abbr> is roughly
the size of the data captured by the Event Horizon Telescope
to make the
<a href="https://www.vice.com/en/article/597m7q/reddits-data-hoarders-are-freaking-out-over-all-that-black-hole-data">first image of a black hole</a>,
stacks and stacks of hard drives.
</p>

<p>
With Zip64, it&#39;s no longer practically interesting to
consider the maximum compression ratio,
because we can just keep increasing the zip file size,
and the compression ratio along with it,
until even the compressed zip file is prohibitively large.
An interesting threshold, though,
is
<data value="18446744073709551616">2<sup>64</sup> bytes</data>
(<data value="18446744073709551616">18 <abbr title="exabyte">EB</abbr></data> or
<data value="18446744073709551616">16 <abbr title="exbibyte">EiB</abbr></data>)—that
much data
<a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits">will not fit on most filesystems</a>.
Binary search finds the smallest zip bomb that produces at least that much output:
it contains <data value="12056313">12 million</data> files
and has a compressed kernel of <data value="1482284040">1.5 <abbr title="gigabyte">GB</abbr></data>.
The total size of the zip file is
<data value="2961656712">2.9 <abbr title="gigabyte">GB</abbr></data>
and it unzips to
<data value="18446744085437447493">2<sup>64</sup> + 11 727 895 877 bytes</data>,
having a compression ratio of over <data value="6228522033.190134">6.2 billion</data>.
I didn&#39;t make this one downloadable,
but you can generate it yourself using the <a href="#source">source code</a>.
It contains files so large that it uncovers
<a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=929502">a bug</a>
in Info-ZIP UnZip 6.0.
</p>

<pre>zipbomb --mode=quoted_overlap --num-files=12056313 --compressed-size=1482284040 --zip64 &gt; zbxxl.zip
</pre>

<!--
# time python3 zipbomb - -mode=quoted_overlap - -num-files=12056313 - -compressed-size=1482284040 - -zip64 > zbxxl.zip

real    52m3.082s
user    51m50.728s
sys     0m11.940s
-->

</section>

<section id="bzip2">
<h2>Extension: bzip2</h2>



<p>
DEFLATE is the most common compression algorithm
used in the zip format, but it is only one of many options.
Probably the second most common algorithm is <a href="https://en.wikipedia.org/wiki/Bzip2">bzip2</a>,
while not as compatible as DEFLATE,
is probably the second most commonly supported compression algorithm.
Empirically, bzip2 has a maximum compression ratio of about 1.4 million,
which allows for denser packing of the kernel.
Ignoring the loss of compatibility,
does bzip2 enable a more efficient zip bomb?
</p>

<p>
Yes—but only for small files.
The problem is that bzip2 does not have anything like the
<a href="#quote">non-compressed blocks</a> of DEFLATE
that we used to <a href="#quote">quote local file headers</a>.
So it is not possible to overlap files and reuse the kernel—each file must have
its own copy, and therefore the overall compression ratio
is no better than the ratio of any single file.
In <a href="#zipped_size">the figure</a> we see that
no-overlap bzip2 outperforms quoted DEFLATE
only for files under about a megabyte.
</p>

<p>
There is still hope for using bzip2—an
alternative means of local file header quoting
discussed in <a href="#extra">the next section</a>.
Additionally,
if you happen to know that a certain zip parser supports bzip2
<em>and</em> tolerates mismatched filenames,
then you can use the <a href="#overlap">full-overlap construction</a>,
which has no need for quoting.
</p>

<figure id="zipped_size">
<picture>
<source srcset="zipped_size.svg" type="image/svg+xml"/>
<img src="http://ablwr.github.io/blog/2025/12/18/annual-report/zipped_size.png" alt="Log–log plot of unzipped size versus zipped size for different zip file constructions: DEFLATE, bzip2, quoted DEFLATE, and 42.zip (recursive and non-recursive)."/>
</picture>
<figcaption>
Zipped size versus unzipped size for various zip bomb constructions.
Note the log–log scales.
Each construction is shown with and without Zip64.
The no-overlap constructions
have a linear rate of growth,
which is visible in the 1:1 slope of the lines.
The vertical offset of the bzip2 lines shows that the compression ratio
of bzip2 is about a thousand times greater than that of DEFLATE.
The quoted-DEFLATE constructions
have a quadratic rate of growth,
as evidenced by the 2:1 slope of the lines.
The Zip64 variant is slightly less efficient,
but permits output in excess of 281 TB.
The lines for extra-field-quoted bzip2
transition from quadratic to linear
upon reaching either the maximum file size
(<data value="65534">2<sup>32</sup> − 2 bytes</data>),
or the maximum number of files allowed by extra-field quoting.
</figcaption>
</figure>

</section>



<section id="discussion">
<h2>Discussion</h2>

<p>
In related work,
<a href="http://sar.informatik.hu-berlin.de/research/publications/index.htm#SAR-PR-2006-04">Plötz et al.</a>
used overlapping files to create a
near-self-replicating zip file.
Gynvael Coldwind
has <a href="https://gynvael.coldwind.pl/?id=682">previously suggested</a> (slide 47)
overlapping files.
<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/pellegrino">Pellegrino et al.</a>
found systems vulnerable to compression bombs
and other resource exhaustion attacks
and listed common pitfalls in specification,
implementation, and configuration.
</p>

<p>
We have designed the quoted-overlap zip bomb construction for compatibility,
taking into consideration a number of implementation differences,
some of which are shown in <a href="#compatibility">the table below</a>.
The resulting construction is compatible with zip parsers that work
in the usual back-to-front way,
first consulting the central directory
and using it as an index of files.
Among these is the example
zip parser included in <a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/bangert">Nail</a>,
which is automatically generated from a formal grammar.
The construction is not compatible, however,
with &#34;streaming&#34; parsers,
those that parse the zip file from beginning to end in one pass
without first reading the central directory.
By their nature, streaming parsers
do not permit any kind of file overlapping.
The most likely outcome is that they
will extract only the first file.
They may even raise an error besides,
as is the case with <a href="https://github.com/madler/sunzip">sunzip</a>,
which parses the central directory at the end and checks it for consistency
with the local file headers it has already seen.
</p>

<p>
If you need the extracted files to start with a certain prefix
(so that they will be identified as a certain file type, for example),
you can insert a data-carrying DEFLATE block just before the
block that quotes the next header.
Not every file has to participate in the bomb construction:
you can include ordinary files
alongside the bomb files
if you need the zip file to conform to some higher-level format.
(The <a href="#source">source code</a> has a <code>--template</code>
option to facilitate this use case.)
Many file formats use zip as a container;
examples are Java JAR, Android APK, and LibreOffice documents.
</p>

<p id="pdf">
<a href="https://en.wikipedia.org/wiki/PDF">PDF</a>
is in many ways similar to zip.
It has a cross-reference table at the end of the file
that points to objects earlier in the file,
and it supports DEFLATE compression of objects through
the FlateDecode filter.
Didier Stevens
<a href="https://blog.didierstevens.com/2008/05/19/pdf-stream-objects/">writes</a>
about having contained a 1 GB stream inside a
<data value="2642">2.6 kB</data> PDF file
by stacking FlateDecode filters.
If a PDF parser limits the amount of stacking,
then it is probably possible to use the DEFLATE quoting idea
to overlap PDF objects.
</p>



<p id="mitigation">
Detecting the specific class of zip bomb we have developed in this article is easy:
look for overlapping files.
Mark Adler has written <a href="https://github.com/madler/unzip/commits/6519bf0f8a896851d9708da11e1b63c818238c8f">a patch</a>
for Info-ZIP UnZip that does just that.
<!-- updated:
https://github.com/madler/unzip/commit/6d351831be705cc26d897db44f878a978f4138fc

https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=963996
https://github.com/madler/unzip/commit/5e2efcd633a4a1fb95a129a75508e7d769e767be
https://github.com/madler/unzip/commit/5c572555cf5d80309a07c30cf7a54b2501493720
-->
In general, though, rejecting overlapping files
does not by itself make it safe to handle untrusted zip files.
There are zip bombs that do not rely on overlapping files,
and there are malicious zip files that are not bombs.
Furthermore, any such detection logic must
be implemented inside the parser itself,
not as a separate prefilter.
One of the details
omitted from <a href="#zip">the description of the zip format</a> is that
there is no single well-defined algorithm for locating
the central directory in a zip file:
two parsers may find two different central directories
and therefore
<a href="https://gynvael.coldwind.pl/?id=682">may not even agree on what files a zip file contains</a>
(slides 67–80).
Predicting the total uncompressed size
by summing the sizes of all files
does not work, in general,
because the sizes stored in metadata
<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/pellegrino">may not match</a>
(§4.2.2)
the actual uncompressed sizes.
(See the &#34;permits too-short file size&#34; row in <a href="#compatibility">the compatibility table</a>.)
Robust protection against zip bombs
involves sandboxing the parser to limit
its use of time, memory, and disk space—just
as if you were processing image files,
or any other complex file format prone to parser bugs.
</p>

<table id="compatibility">

<caption>
<p>
Compatibility of selected zip parsers with various zip features,
edge cases,
and zip bomb constructions.
The background colors indicate a scale from <span>less restrictive to more restrictive</span>.
For best compatibility,
use DEFLATE compression without Zip64,
match names in central directory headers and local file headers,
compute correct CRCs,
and avoid the maximum values of 32-bit and 16-bit fields.
</p>
</caption>

<!--
Open Packaging Conventions:
DEFLATE: yes (Table (C-3)
Zip64: yes (Table C-1, Table C-3)
bzip2: no (Table C-3)
permits mismatched filenames: no (C.1 Archive File Header Consistency)
permits incorrect CRC-32: unknown
permits file size of 0xffffffff: unknown
permits file count of 0xffff: unknown
https://www.ecma-international.org/news/TC45_current_work/Office%20Open%20XML%20Part%202%20-%20Open%20Packaging%20Conventions.pdf
-->

<!--
$ git clone https://android.googlesource.com/platform/system/core
$ cd core
$ git checkout android-9.0.0_r1
$ g++ -o unzip -std=c++17 -Iinclude -Ibase/include -Iliblog/include -Ilibutils/include -Ilibziparchive/include libziparchive/{zip_archive.cc,unzip.cpp} base/{strings.cpp,file.cpp,logging.cpp,stringprintf.cpp} libutils/FileMap.cpp libunwindstack/tests/LogFake.cpp -lz
-->

<thead>
<tr>
<td></td>
<th><a href="http://infozip.sourceforge.net/UnZip.html">Info-ZIP</a></th>
<th><a href="https://docs.python.org/3/library/zipfile.html">Python 3.7</a></th>
<th><a href="https://golang.org/pkg/archive/zip/">Go 1.12</a></th>
<th><a href="https://github.com/thejoshwolfe/yauzl">yauzl 2.10.0</a></th>
<th><a href="https://github.com/jbangert/nail/tree/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip">Nail</a></th>
<th><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive">Android 9.0.0 r1</a></th>
<th><a href="https://github.com/madler/sunzip">sunzip 0.4</a></th>
</tr>
</thead>

<tbody>

<!--
<td class= title=></td>
<td class=y title=yes>✓</td>
<td class=n title=no>✖</td>
-->

<tr>
<th>DEFLATE</th>
<td title="yes">✓</td>
<td title="yes"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L57">✓</a></td>
<td title="yes"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/struct.go#L31">✓</a></td>
<td title="yes"><a href="https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L520-L521">✓</a></td>
<td title="yes"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L63">✓</a></td>
<td title="yes"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#1059">✓</a></td>
<td title="yes"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1256">✓</a></td>
</tr>

<tr>
<th>Zip64</th>
<td title="yes"><a href="http://infozip.sourceforge.net/UnZip.html#Release">✓</a></td>
<td title="yes"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L186">✓</a></td>
<td title="yes"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L519">✓</a></td>
<td title="limited to the range of IEEE doubles"><a href="https://github.com/thejoshwolfe/yauzl/tree/2.10.0#limitted-zip64-support">✓</a></td>
<td title="no"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L103-L125">✖</a></td>
<td title="no"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#168">✖</a></td>
<td title="yes"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L922">✓</a></td>
</tr>

<tr>
<th>bzip2</th>
<td title="yes"><a href="http://infozip.sourceforge.net/UnZip.html#Release">✓</a></td>
<td title="yes"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L58">✓</a></td>
<td title="unless you provide an implementation with RegisterDecompressor"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/struct.go#L28-L32">✖</a></td>
<td title="no"><a href="https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L517-L525">✖</a></td>
<td title="no"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.c#L86">✖</a></td>
<td title="no"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#1061">✖</a></td>
<td title="yes"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1256">✓</a></td>
</tr>

<tr>
<th>permits mismatched filenames</th>
<td title="warns, then takes name from central directory">warns</td>
<td><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1486-L1489"><abbr title="no">✖</abbr></a></td>
<td title="ignores local file header metadata"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L244">✓</a></td>
<td title="ignores local file header metadata"><a href="https://github.com/thejoshwolfe/yauzl/tree/2.10.0#local-file-headers-are-ignored">✓</a></td>
<td title="with a TODO to add the check"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L49">✓</a></td>
<td title="no"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#594">✖</a></td>
<td title="ignores local file header filename"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1268-L1269">✓</a></td>
</tr>

<tr>
<th>permits incorrect CRC-32</th>
<td><abbr title="shows expected and actual CRC">warns</abbr></td>
<td title="no"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L893-L894">✖</a></td>
<td title="CRC-32 ignored if set to 0"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L219-L224">if zero</a></td>
<td title="yes"><a href="https://github.com/thejoshwolfe/yauzl/tree/2.10.0#no-crc-32-checking">✓</a></td>
<td title="no"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L41">✖</a></td>
<td title="with a compile-time bool to enable CRC checks; but does check for consistency between CDH CRC and data descriptor CRC"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#52">✓</a></td>
<td title="no"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1113-L1124">✖</a></td>
</tr>

<tr>
<th>permits too-short file size</th>
<td title="yes">✓</td>
<td title="permits uncompressed size field to be longer, but not shorter, than the actual size"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L772">✖</a></td>
<td title="no"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L205-L207">✖</a></td>
<td title="no"><a href="https://github.com/thejoshwolfe/yauzl/blob/2.10.0/index.js#L641-L655">✖</a></td>
<td title="no"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L47">✖</a></td>
<td title="no"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive.cc#847">✖</a></td>
<td title="no"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1113-L1124">✖</a></td>
</tr>

<tr>
<th>permits file size of 2<sup>32</sup> − 1</th>
<td title="yes">✓</td>
<td title="0xffffffff not treated as special"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L1311-L1313">✓</a></td>
<td title="special case to allow file size of 0xffffffff, still disallows compressed size or local file header offset of 0xffffffff"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L406-L414">✓</a></td>
<td title="requires Zip64 Extended Information extra field when file size is 0xffffffff"><a href="https://github.com/thejoshwolfe/yauzl/issues/109">✖</a></td>
<td title="no Zip64 support"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L59">✓</a></td>
<td title="no Zip64 support"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive_common.h#95">✓</a></td>
<td title="checks for Zip64 Extended Information extra field if file size is 0xffffffff, but does not require it"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1275-L1277">✓</a></td>
</tr>

<tr>
<th>permits file count of 2<sup>16</sup> − 1</th>
<td title="checks for Zip64 end of central directory locator independent of file count">✓</td>
<td title="checks for Zip64 end of central directory locator independent of file count"><a href="https://github.com/python/cpython/blob/v3.7.0/Lib/zipfile.py#L258-L259">✓</a></td>
<td title="looks for Zip64 end of central directory locator, but continues if not present"><a href="https://github.com/golang/go/blob/go1.12/src/archive/zip/reader.go#L502-L511">✓</a></td>
<td title="no"><a href="https://github.com/thejoshwolfe/yauzl/issues/108">✖</a></td>
<td title="no Zip64 support"><a href="https://github.com/jbangert/nail/blob/4bd9cc29c4092abe7a77f8294aff2337bba02ec5/examples/zip/zip.nail#L79">✓</a></td>
<td title="no Zip64 support"><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-9.0.0_r1/libziparchive/zip_archive_common.h#51">✓</a></td>
<td title="Zip64 end of central directory locator is optional"><a href="https://github.com/madler/sunzip/blob/v0.4/sunzip.c#L1139">✓</a></td>
</tr>
</tbody>

<tbody>
<!--
<tr>
<th>unzips recursively (42.zip)</th>
<td class=n title=no>✖</td>
<td class=n title=no>✖</td>
<td class=na title="is a library">N/A</td>
<td class=na title="is a library">N/A</td>
<td class=n title=no>✖</td>
<td class=n title=no>✖</td>
<td class=n title=no>✖</td>
</tr>
-->

<tr>
<th>unzips <a href="#overlap">overlap.zip</a></th>
<td>warns</td>
<td title="no">✖</td>
<td title="yes">✓</td>
<td title="yes">✓</td>
<td title="yes">✓</td>
<td title="no">✖</td>
<td title="no">✖</td>
</tr>

<tr>
<th>unzips <a href="#allocation">zbsm.zip and zblg.zip</a></th>
<td><abbr title="yes">✓</abbr></td>
<td><abbr title="yes">✓</abbr></td>
<td title="yes">✓</td>
<td title="yes">✓</td>
<td title="crashes because it tries to extract all into memory, but handles the construction">✓</td>
<td title="yes">✓</td>
<td title="no">✖</td>
</tr>

<tr>
<th>unzips <a href="#zip64">zbxl.zip</a></th>
<td><abbr title="yes">✓</abbr></td>
<td><abbr title="yes">✓</abbr></td>
<td title="yes">✓</td>
<td title="yes">✓</td>
<td title="no Zip64 support">✖</td>
<td title="no Zip64 support">✖</td>
<td title="no">✖</td>
</tr>
</tbody>

</table>

</section>

<section id="credits">
<h2>Credits</h2>

<p>
I thank
<a href="https://madler.net/madler/">Mark Adler</a>,
<a href="https://bburky.com/">Blake Burkhart</a>,
<a href="https://gynvael.coldwind.pl/">Gynvael Coldwind</a>,
<a href="https://swtch.com/~rsc/">Russ Cox</a>,
<a href="https://www.brandonenright.net/">Brandon Enright</a>,
<a href="https://github.com/jorangreef">Joran Dirk Greef</a>,
<a href="https://idea.popcount.org/">Marek Majkowski</a>,
<a href="https://wolfesoftware.com/">Josh Wolfe</a>,
and the <a href="https://www.usenix.org/conference/woot19/">USENIX WOOT 2019</a> reviewers
for comments on this article or a draft.
Caolán McNamara evaluated the security impact
of the zip bombs in LibreOffice.
<a href="https://habr.com/users/m1rko/">@m1rko</a>
wrote a <a href="https://habr.com/ru/post/459254/">Russian translation</a>.
<a href="https://zerosun.top/">北岸冷若冰霜</a>
wrote a <a href="https://zerosun.top/2019/07/07/A-better-zip-bomb/">Chinese translation</a>.
Daniel Ketterer reported that the <code>--template</code> option
was broken after the addition of <a href="#giant-steps"><code>--giant-steps</code></a>.
</p>

<p>
A version of this article
appeared at the
<a href="https://www.usenix.org/conference/woot19/presentation/fifield">USENIX WOOT 2019</a>
workshop.
The workshop talk
<a href="http://ablwr.github.io/talks/woot19-zipbomb/">video, slides, and transcript</a>
are available.
The <a href="#source">source code</a> of the paper is available.
The <a href="https://www.usenix.org/conference/woot19/call-for-artifacts">artifacts</a>
prepared for submission are <a href="http://ablwr.github.io/blog/2025/12/18/annual-report/zipbomb-woot19.zip">zipbomb-woot19.zip</a>.
</p>

<p>
Did you find a system that chokes on one of these zip bombs?
Did they help you demonstrate a vulnerability or
win a bug bounty?
<a href="#contact">Let me know</a> and I&#39;ll try to mention it here.
</p>

<dl>
<dt id="libreoffice">LibreOffice 6.1.5.2</dt>
<dd>
<p>
zblg.zip renamed to zblg.odt or zblg.docx
will cause LibreOffice to
create and delete a number of ~4 GB temporary files
as it attempts to determine the file format.
It does eventually finish, and it deletes
the temporary files as it goes,
so it&#39;s only a temporary DoS that doesn&#39;t fill up the disk.
Caolán McNamara replied to my bug report.
</p>
</dd>
<dt id="addons-server">Mozilla addons-server 2019.06.06</dt>
<dd>
<p>
I tried the zip bombs against a local installation of addons-server,
which is part of the software behind addons.mozilla.org.
The system handles it gracefully,
imposing a <a href="https://github.com/mozilla/addons-server/blob/2019.06.06/src/olympia/lib/settings_base.py#L1457-L1458">time limit</a>
of <time datetime="110s">110 s</time> on extraction.
The zip bomb expands as fast as the disk will let it up to the time limit,
but after that point the process is killed and the unzipped files
are eventually automatically cleaned up.
</p>
</dd>
<dt id="unzip">UnZip 6.0</dt>
<dd>
<p>
Mark Adler wrote
<a href="https://github.com/madler/unzip/commits/6519bf0f8a896851d9708da11e1b63c818238c8f">a patch</a>
for UnZip to detect this class of zip bomb.
</p>
<p>
<time>2019-07-05</time>:
I noticed that <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13232">CVE-2019-13232</a>
was assigned for UnZip.
Personally, I would dispute that UnZip&#39;s (or any zip parser&#39;s)
ability to process a zip bomb of the kind discussed here
necessarily represents a security vulnerability, or even a bug.
It&#39;s a natural implementation and does not violate the specification
in any way that I can tell.
The type discussed in this article is only one type of zip bomb,
and there are many ways in which zip parsing can go wrong that are not bombs.
If you want to defend against resource exhaustion attacks,
you should <em>not</em> try to enumerate, detect, and block
every individual known attack;
rather you should impose external limits on time and other resources
so that the parser cannot misbehave too much,
no matter what kind of attack it faces.
There is nothing wrong with attempting to detect and reject certain
constructions as a first-pass optimization,
but you can&#39;t stop there.
If you do not eventually isolate and limit
operations on untrusted data, your system is likely still vulnerable.
Consider an analogy with <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a> in HTML:
the right defense is not to try and filter out bytes that may be interpreted as code,
it&#39;s to escape everything properly.
</p>
<p>
Mark Adler&#39;s patch made its way into Debian in
<a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=931433">bug #931433</a>.
<!-- Debian 8 "Jessie" https://lists.debian.org/debian-lts-announce/2019/07/msg00005.html -->
There were some unanticipated consequences:
problems parsing certain Java JARs
(<a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=931895">bug #931895</a>)
and problems with the mutant zip format of Firefox&#39;s omni.ja file
(<a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=932404">bug #932404</a>).
SUSE decided
<a href="https://bugzilla.suse.com/show_bug.cgi?id=1140748#c2">not to do anything</a>
about CVE-2019-13232.
I think both Debian&#39;s and SUSE&#39;s choices are defensible.
</p>
<!-- https://bugzilla.redhat.com/show_bug.cgi?id=1727761 -->
<!-- https://bugs.gentoo.org/691566 -->
</dd>
<dt id="ronomon">ronomon/zip</dt>
<dd>
<p>
Shortly after the publication of this article,
Joran Dirk Greef published a
<a href="https://github.com/ronomon/zip">restrictive zip parser</a> (JavaScript)
that prohibits irregularities such as overlapping files
or unused space between files.
While it may thereby reject certain valid zip files,
the idea is to ensure that any downstream parsers
will receive only clean, easy-to-parse files.
</p>
</dd>
<dt id="antivirus">antivirus engines</dt>
<dd>
<p>
Overall, it seems that malware scanners have slowly begun
to recognize zip bombs of this kind
(or at least the specific samples available for download)
as malicious.
It would be interesting to see whether the detection is robust or brittle.
You could reverse the order of the entries in the central directory, for example,
and see whether the zip files are still detected.
In the <a href="#source">source code</a>,
there&#39;s a recipe for generating zbsm.extra.zip,
which is like zbsm.zip except that it uses
<a href="#extra">extra-field quoting</a> instead of
<a href="#quote">DEFLATE quoting</a>—if you are a customer
of an AV service that detects zbsm.zip but not zbsm.extra.zip,
you should ask for an explanation.
Another simple variant is
<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/spacer.txt">inserting spacer files between the bomb files</a>,
which may fool certain overlap-detection algorithms.
</p>
<p>
Twitter user @TVqQAAMAAAAEAAA
<a href="https://twitter.com/TVqQAAMAAAAEAAA/status/1146351962486476801">reports</a>
<!-- https://web.archive.org/web/20190703141828/https:/twitter.com/TVqQAAMAAAAEAAA/status/1146351962486476801 -->
&#34;McAfee AV on my test machine just exploded.&#34;
I haven&#39;t independently confirmed it, nor do I have details such as a version number.
</p>
<p>
Tavis Ormandy <a href="https://twitter.com/taviso/status/1146477576132542466">points out</a>
<!-- https://web.archive.org/web/20190707044306/https://twitter.com/taviso/status/1146477576132542466 -->
that there are a number of &#34;Timeout&#34; results in
<a href="https://www.virustotal.com/gui/file/f1dc920869794df3e258f42f9b99157104cd3f8c14394c1b9d043d6fcda14c0a/detection">the VirusTotal for zblg.zip</a>
<small><a href="http://ablwr.github.io/blog/2025/12/18/annual-report/vt-zblg-20190706.png">(screenshot <time>2019-07-06</time>)</a></small>.
<!-- Nor wayback machine nor archive.is worked on the virustotal site :(
https://web.archive.org/web/20190705165359/https://www.virustotal.com/gui/file/f1dc920869794df3e258f42f9b99157104cd3f8c14394c1b9d043d6fcda14c0a/detection
https://web.archive.org/web/20190705170818/https://www.virustotal.com/gui/file/fb4ff972d21189beec11e05109c4354d0cd6d3b629263d6c950cf8cc3f78bd99/detection
https://web.archive.org/web/20190705170924/https://www.virustotal.com/gui/file/eafd8f574ea7fd0f345eaa19eae8d0d78d5323c8154592c850a2d78a86817744/detection
-->
<!-- but the old-browsers mode kinda works
https://www.virustotal.com/old-browsers/file/fb4ff972d21189beec11e05109c4354d0cd6d3b629263d6c950cf8cc3f78bd99
http://archivecaslytosk.onion/sgvC9

https://www.virustotal.com/old-browsers/file/f1dc920869794df3e258f42f9b99157104cd3f8c14394c1b9d043d6fcda14c0a
http://archivecaslytosk.onion/ywtHj

https://www.virustotal.com/old-browsers/file/eafd8f574ea7fd0f345eaa19eae8d0d78d5323c8154592c850a2d78a86817744
http://archivecaslytosk.onion/Xz7q3
-->
AhnLab-V3, ClamAV, DrWeb, Endgame, F-Secure, GData, K7AntiVirus, K7GW, MaxSecure, McAfee, McAfee-GW-Edition, Panda, Qihoo-360, Sophos ML, VBA32.
<a href="https://www.virustotal.com/gui/file/fb4ff972d21189beec11e05109c4354d0cd6d3b629263d6c950cf8cc3f78bd99/detection">The results for zbsm.zip</a>
<small><a href="http://ablwr.github.io/blog/2025/12/18/annual-report/vt-zbsm-20190706.png">(screenshot <time>2019-07-06</time>)</a></small>
are similar, though with a different set of timed-out engines:
Baido, Bkav, ClamAV, CMC, DrWeb, Endgame, ESET-NOD32, F-Secure, GData, Kingsoft, McAfee-GW-Edition, NANO-Antivirus, Acronis.
Interestingly, there are no timeouts in
<a href="https://www.virustotal.com/gui/file/eafd8f574ea7fd0f345eaa19eae8d0d78d5323c8154592c850a2d78a86817744/detection">the results for zbxl.zip</a>;
<small><a href="http://ablwr.github.io/blog/2025/12/18/annual-report/vt-zbxl-20190706.png">(screenshot <time>2019-07-06</time>)</a></small>
perhaps this means that some antivirus doesn&#39;t support Zip64?
</p>
<p>
Forum user 100 <a href="https://forum.eset.com/topic/20123-zip-bombs-with-zip64-not-detected/">reported</a>
that a certain ESET product did not detect zbxl.zip, possibly because it uses Zip64.
An update in the thread three days later showed the product being updated to detect it.
</p>
<p>
In <a href="https://bugzilla.clamav.net/show_bug.cgi?id=12356">ClamAV bug 12356</a>,
Hanno Böck reported that zblg.zip caused high CPU usage
in clamscan.
<a href="https://bugzilla.clamav.net/show_bug.cgi?id=12356#c5">An initial patch</a>
to detect overlapping files
<a href="https://seclists.org/oss-sec/2019/q3/121">turned out to be incomplete</a>
because it only checked adjacent pairs of files.
(I personally mishandled this issue
by posting details of a workaround on the bug tracker,
instead of reporting it privately.)
<a href="https://bugzilla.clamav.net/show_bug.cgi?id=12356#c14">A later patch</a>
imposed a time limit on file analysis.
</p>
<p id="flytech">
<time>2020-07-28</time>: FlyTech Videos presented a
<a href="https://www.youtube.com/watch?v=peeYOqejWfg">video testing various zip bombs</a>,
including <a href="#zbxl">zbxl.zip</a>,
against Windows Defender, Windows Explorer, and 7-zip.
</p>
<p>
In my web server logs, I noticed a number of referers that
appear to point to bug trackers.
</p>
<ul>
<li>http://jira.athr.ru/browse/WEB-12882</li>
<li>https://project.avira.org/browse/ENGINE-2307</li>
<li>https://project.avira.org/browse/ENGINE-2363</li>
<li>https://topdesk-imp.cicapp.nl/tas/secure/mango/window/4</li>
<li>https://jira-eng-rtp3.cisco.com/jira/browse/AMP4E-4849</li>
<li>https://jira-eng-sjc1.cisco.com/jira/browse/CLAM-965</li>
<li>https://flightdataservices.atlassian.net/secure/RapidBoard.jspa?selectedIssue=FDS-136</li>
<li>https://projects.ucd.gpn.gov.uk/browse/VULN-1483</li>
<li>https://testrail-int.qa1.immunet.com/index.php?/cases/view/923720</li>
<li>http://redmine-int-prod.intranet.cnim.net/issues/5596</li>
<li>https://bugs.drweb.com/view.php?id=159759</li>
<li>https://dev-jira.dynatrace.org/browse/APM-188227</li>
<li>https://webgate.ec.europa.eu/CITnet/jira/browse/EPREL-2150</li>
<li>https://jira.egnyte-it.com/browse/IN-8480</li>
<li>https://jira.hq.eset.com/browse/CCDBL-1492</li>
<li>https://bugzilla.olympus.f5net.com/show_bug.cgi?id=819053</li>
<li>https://mantis.fortinet.com/bug_view_page.php?bug_id=0570222</li>
<li>https://redmine.joesecurity.org:64998/issues/4705</li>
<li>http://dev.maildev.jp/mantis/view.php?id=5839</li>
<li>https://confluence.managed.lu/pages/viewpage.action?pageId=47974242</li>
<li>https://jira-lvs.prod.mcafee.com/browse/TSWS-653</li>
<li>https://jira.modulbank.ru/browse/PV-33012</li>
<li>http://jira.netzwerk.intern:8080/browse/SALES-81</li>
<li>https://jira-hq.paloaltonetworks.local/browse/CON-43391</li>
<li>https://jira-hq.paloaltonetworks.local/browse/GSRT-11680</li>
<li>https://jira-hq.paloaltonetworks.local/browse/PAN-124201</li>
<li>https://paynearme.atlassian.net/browse/PNM-4494</li>
<li>https://jira.proofpoint.com/jira/browse/PE-29410</li>
<li>https://dev.pulsesecure.net/jira/browse/PRS-379163</li>
<li>https://qualtrics.atlassian.net/browse/APP-326</li>
<li>https://jira.sastdev.net/browse/CIS-2819</li>
<li>https://jira.sastdev.net/secure/RapidBoard.jspa?selectedIssue=EC-709</li>
<li>https://bugzilla.seeburger.de/show_bug.cgi?id=89294</li>
<li>https://svm.cert.siemens.com/auseno/create_edit_vulnerability.php?vulnid=48573</li>
<li>https://jira.sophos.net/browse/CPISSUE-6560</li>
<li>https://jira.vrt.sourcefire.com/browse/TT-1070</li>
<li>https://task.jarvis.trendmicro.com/browse/JPSE-10432</li>
<li>https://segjira.trendmicro.com:8443/browse/SEG-55636</li>
<li>https://segjira.trendmicro.com:8443/browse/SEG-58824</li>
<li>https://ucsc-cgl.atlassian.net/secure/RapidBoard.jspa?selectedIssue=SEAB-327</li>
<li>https://jira.withbc.com/browse/BC-43950</li>
<li>https://zscaler.zendesk.com/agent/tickets/849971</li>
</ul>
</dd>
<dt id="browsers">web browsers</dt>
<dd>
<p>
I didn&#39;t directly experience this myself,
but reports online say that Chrome and Safari may automatically unzip
files after downloading.
</p>
<ul>
<li><p><a href="https://habr.com/ru/post/459254/#comment_20369364">ittakir</a>: &#34;Скачал самый маленький файл на 5GB, Chrome тут же начал его распаковывать, хотя его об этом не просили, ну и кушать процессор и диск.&#34; <i>&#34;I downloaded the smallest file on 5GB, Chrome immediately began to unpack it, although it was not asked for it, well, to eat the processor and disk.&#34;</i></p></li>
<li><p><a href="https://old.reddit.com/r/programming/comments/c8ylxn/zblg_nonrecursive_zip_bomb_with_a_280000001_ratio/esrsxvi/">Rzah</a>: &#34;Yet another reason why &#39;Open Safe files after downloading&#39; is a stupid default setting for a web browser.&#34;</p></li>
</ul>
<p>
Chromium commit <a href="https://chromium.googlesource.com/chromium/src/+/f04d9b15bd1cba1433ad5453bc3ebff933d0e3bb">f04d9b15bd1cba1433ad5453bc3ebff933d0e3bb</a> is perhaps related:
</p>
<blockquote>
<p>
Add metrics detecting anomalously high ZIP compression ratios
</p>
<p>
It&#39;s possible for a single ZIP entry to be very large, even if we only
scan small ZIP archives. These metrics will measure how often that occurs.
</p>
</blockquote>
</dd>
<dt id="filesystems">filesystems</dt>
<dd>
<p>
Something I didn&#39;t anticipate:
unzipping one of the bombs on a compressed filesystem can be relatively safe.
</p>
<ul>
<li><p><a href="https://old.reddit.com/r/programming/comments/cbvqzu/the_most_clever_zip_bomb_ever_made_explodes_a/etkazxk/">flying_gel</a>:
&#34;If I unzip this onto a compressed zfs dataset, will the resulting file be small? Edit: Just did a small test with a 42KB-&gt;5.5GB zip bomb. I ended up with 165MB worth of files so while just 3% of the full bomb, it&#39;s still a 4028 times inflation. ... I only have the standard LZ4 compression enabled, no dedup.&#34;</p></li>
</ul>
</dd>
<dt id="twitter">Twitter</dt>
<dd>
<p>
Links to this article had been widely shared on Twitter
since around <time>2019-07-02</time>,
but around <time>2019-07-20</time> it began showing
<a href="https://twitter.com/safety/unsafe_link_warning?unsafe_link=https://www.bamsoftware.com/hacks/zipbomb/">an &#34;unsafe link&#34; interstitial</a>
<small>(<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/twitter-unsafe.png">screenshot</a>, <a href="https://web.archive.org/web/20190721031831/https://twitter.com/safety/unsafe_link_warning?unsafe_link=https://www.bamsoftware.com/hacks/zipbomb/">archive</a>)</small>.
</p>
</dd>
<dt id="safebrowsing">Safe Browsing</dt>
<dd>
<p>
Sometime around <time>2019-07-23</time> it seems that this page,
and <em>every</em> page on a *.bamsoftware.com domain,
got added to the <a href="https://safebrowsing.google.com/">Safe Browsing</a>
service used by web browsers
to block malware and phishing sites.
<a href="https://transparencyreport.google.com/safe-browsing/search?url=bamsoftware.com">Site status check</a>,
<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/safebrowsing-www.bamsoftware.com-20190724.png">block page screenshot</a>.
From a few quick checks, it looks like pages on bamsoftware.com
have been demoted or delisted on the google.com search engine as well.
</p>
<p>
The Safe Browsing block is a bit annoying,
because it disrupted <a href="https://snowflake.torproject.org/">Snowflake</a>,
a completely unrelated service that happened to use the domain
snowflake-broker.bamsoftware.com, which did not even host any files
but was strictly a web API server.
See <a href="https://bugs.torproject.org/31230">#31230 Firefox addon blocked from agent by Google Safe Browsing service</a>.
</p>
<p>
The Safe Browsing block seemed to end
on or before
<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/transparencyreport.google-www.bamsoftware.com-20190816.png"><time>2019-08-16</time></a>.
</p>
</dd>
<dt id="xfinity">Xfinity xFi Protected Browsing</dt>
<dd>
<p>
On <time>2019-11-26</time>, I was informed
by Hooman Mohajeri Moghaddam
that the Comcast Xfinity xFi
<a href="https://www.vice.com/en_us/article/evm3qk/comcast-blocking-paypal-customers-say-forum-net-neutrality">&#34;Protected Browsing&#34;</a>
feature blocks the bamsoftware.com domain, including this page
(<a href="http://ablwr.github.io/blog/2025/12/18/annual-report/xfinity-blockpage.png">screenshot</a>).
</p>
</dd>
<dt id="dlang">D std.zip</dt>
<dd>
<p>
The D programming language
<a href="https://issues.dlang.org/show_bug.cgi?id=20027">made a modification</a>
to the <a href="https://dlang.org/library/std/zip.html">std.zip module</a>
to detect overlapping files.
</p>
</dd>
<!-- https://issues.dlang.org/show_bug.cgi?id=20027 -->
<!-- https://github.com/golang/go/issues/33026 https://github.com/golang/go/issues/33036 -->

<dt id="ios">Apple iOS and iPadOS</dt>
<dd>
<p>
Dzmitry Plotnikau sent me a report saying that
a zip bomb could use up all cache storage
on iPhones running iOS 12 and 13, even if only opened using &#34;Quick look.&#34;
The exhaustion of storage could have various side effects,
including misbehaving apps, deletion of local cloud files, and OS crashes,
in some cases requiring a factory reset to remedy.
The bug was mitigated in iOS 14.0
(and likely other, contemporaneous point release of iOS and iPadOS).
See <a href="https://support.apple.com/en-us/HT211850">HT211850</a>
under the &#34;libarchive&#34; heading.
</p>
</dd>
</dl>

</section>

<section id="plea">
<h2>A final plea</h2>

<p>
It&#39;s time to put an end to Facebook.
Working there is not ethically neutral:
every day that you go into work, you are doing something wrong.
If you have a Facebook account, delete it.
If you work at Facebook, quit.
</p>

<p>
And let us not forget that the National Security Agency
must be destroyed.
</p>

</section>

</article></div>
  </body>
</html>
