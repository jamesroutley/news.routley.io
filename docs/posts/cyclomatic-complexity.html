<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Original</a>
    <h1>Cyclomatic Complexity</h1>
    
    <div id="readability-page-1" class="page"><div>
							

						<p>From Wikipedia, the free encyclopedia</p>
					</div><div id="mw-content-text"><div lang="en" dir="ltr">
<p><b>Cyclomatic complexity</b> is a <a href="https://en.wikipedia.org/wiki/Software_metric" title="Software metric">software metric</a> used to indicate the <a href="https://en.wikipedia.org/wiki/Programming_complexity" title="Programming complexity">complexity of a program</a>. It is a quantitative measure of the number of linearly independent paths through a program&#39;s <a href="https://en.wikipedia.org/wiki/Source_code" title="Source code">source code</a>. It was developed by <a href="https://en.wikipedia.org/w/index.php?title=Thomas_J._McCabe,_Sr.&amp;action=edit&amp;redlink=1" title="Thomas J. McCabe, Sr. (page does not exist)">Thomas J. McCabe, Sr.</a> in 1976.
</p><p>Cyclomatic complexity is computed using the <a href="https://en.wikipedia.org/wiki/Control-flow_graph" title="Control-flow graph">control-flow graph</a> of the program: the nodes of the <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)" title="Graph (discrete mathematics)">graph</a> correspond to indivisible groups of commands of a program, and a <a href="https://en.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed</a> edge connects two nodes if the second command might be executed immediately after the first command. Cyclomatic complexity may also be applied to individual <a href="https://en.wikipedia.org/wiki/Function_(computer_science)" title="Function (computer science)">functions</a>, <a href="https://en.wikipedia.org/wiki/Modular_programming" title="Modular programming">modules</a>, <a href="https://en.wikipedia.org/wiki/Method_(computer_science)" title="Method (computer science)">methods</a> or <a href="https://en.wikipedia.org/wiki/Class_(computer_science)" title="Class (computer science)">classes</a> within a program.
</p><p>One <a href="https://en.wikipedia.org/wiki/Software_testing" title="Software testing">testing</a> strategy, called <a href="https://en.wikipedia.org/wiki/Basis_path_testing" title="Basis path testing">basis path testing</a> by McCabe who first proposed it, is to test each linearly independent path through the program; in this case, the number of test cases will equal the cyclomatic complexity of the program.<sup id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>
</p>
<meta property="mw:PageProp/toc"/>
<h2><span id="Description">Description</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=1" title="Edit section: Description"><span>edit</span></a><span>]</span></span></h2>
<h3><span id="Definition">Definition</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=2" title="Edit section: Definition"><span>edit</span></a><span>]</span></span></h3>
<figure typeof="mw:File/Thumb"><a href="https://en.wikipedia.org/wiki/File:Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg"><img alt="See caption" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg/240px-Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg.png" decoding="async" width="240" height="300" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg/360px-Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg/480px-Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg.png 2x" data-file-width="400" data-file-height="500"/></a><figcaption>A control-flow graph of a simple program. The program begins executing at the red node, then enters a loop (group of three nodes immediately below the red node). Exiting the loop, there is a conditional statement (group below the loop) and the program exits at the blue node. This graph has nine edges, eight nodes and one <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)" title="Connected component (graph theory)">connected component</a>, so the program&#39;s cyclomatic complexity is <span>9 − 8 + 2×1 = 3</span>.</figcaption></figure>
<p>The cyclomatic complexity of a section of <a href="https://en.wikipedia.org/wiki/Source_code" title="Source code">source code</a> is the number of <a href="https://en.wikipedia.org/wiki/Linearly_independent" title="Linearly independent">linearly independent</a> <a href="https://en.wikipedia.org/wiki/Path_(graph_theory)" title="Path (graph theory)">paths</a> within it; a set of paths is linearly dependent if there is a subset of one (or more) paths where the <a href="https://en.wikipedia.org/wiki/Symmetric_difference" title="Symmetric difference">symmetric difference</a> of their edge sets is empty. If the source code contained no <a href="https://en.wikipedia.org/wiki/Control_flow" title="Control flow">control flow statements</a> (conditionals or decision points) the complexity would be 1, since there would be only a single path through the code. If the code had one single-condition IF statement, there would be two paths through the code: one where the IF statement is TRUE and another one where it is FALSE, so the complexity would be 2. Two nested single-condition IFs, or one IF with two conditions, would produce a complexity of 3.
</p><p>The cyclomatic complexity of a <a href="https://en.wikipedia.org/wiki/Structured_programming" title="Structured programming">structured program</a><sup id="cite_ref-2"><a href="#cite_note-2">[a]</a></sup> is defined with reference to the <a href="https://en.wikipedia.org/wiki/Control-flow_graph" title="Control-flow graph">control-flow graph</a> of the program, a <a href="https://en.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed graph</a> containing the <a href="https://en.wikipedia.org/wiki/Basic_block" title="Basic block">basic blocks</a> of the program, with an edge between two basic blocks if control may pass from the first to the second. The complexity <span>M</span> is then defined as<sup id="cite_ref-mccabe76_3-0"><a href="#cite_note-mccabe76-3">[2]</a></sup>
</p><div><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8a1e796b1ad8a2a3b04a33ae908b0559bc35fd24" aria-hidden="true" alt="{\displaystyle M=E-N+2P,}"/></p></div>
<p>where
</p>
<ul><li><span>E</span> = the number of edges of the graph.</li>
<li><span>N</span> = the number of nodes of the graph.</li>
<li><span>P</span> = the number of <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)" title="Connected component (graph theory)">connected components</a>.</li></ul>
<figure typeof="mw:File/Thumb"><a href="https://en.wikipedia.org/wiki/File:Control_flow_graph_of_function_with_loop_and_an_if_statement.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/30/Control_flow_graph_of_function_with_loop_and_an_if_statement.svg/240px-Control_flow_graph_of_function_with_loop_and_an_if_statement.svg.png" decoding="async" width="240" height="300" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/30/Control_flow_graph_of_function_with_loop_and_an_if_statement.svg/360px-Control_flow_graph_of_function_with_loop_and_an_if_statement.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/30/Control_flow_graph_of_function_with_loop_and_an_if_statement.svg/480px-Control_flow_graph_of_function_with_loop_and_an_if_statement.svg.png 2x" data-file-width="400" data-file-height="500"/></a><figcaption>The same function, represented using the alternative formulation where each exit point is connected back to the entry point. This graph has 10 edges, eight nodes and one <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)" title="Connected component (graph theory)">connected component</a>, which also results in a cyclomatic complexity of 3 using the alternative formulation (<span>10 − 8 + 1 = 3</span>).</figcaption></figure> 
<p>An alternative formulation is to use a graph in which each exit point is connected back to the entry point. In this case, the graph is <a href="https://en.wikipedia.org/wiki/Strongly_connected" title="Strongly connected">strongly connected</a>; the cyclomatic complexity of the program is equal to the <a href="https://en.wikipedia.org/wiki/Cyclomatic_number" title="Cyclomatic number">cyclomatic number</a> of its graph (also known as the <a href="https://en.wikipedia.org/wiki/Betti_number#Example_2:_the_first_Betti_number_in_graph_theory" title="Betti number">first Betti number</a>), which is defined as<sup id="cite_ref-mccabe76_3-1"><a href="#cite_note-mccabe76-3">[2]</a></sup>
</p><div><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89a806a26e1fd3d0b6e5be82e970de570a0a44f3" aria-hidden="true" alt="{\displaystyle M=E-N+P.}"/></p></div>
<p>This may be seen as calculating the number of <a href="https://en.wikipedia.org/wiki/Linearly_independent_cycle" title="Linearly independent cycle">linearly independent cycles</a> that exist in the graph: those cycles that do not contain other cycles within themselves. Because each exit point loops back to the entry point, there is at least one such cycle for each exit point.
</p><p>For a single program (or subroutine or method), <span>P</span> is always equal to 1; a simpler formula for a single subroutine is<sup id="cite_ref-Laplante2007_4-0"><a href="#cite_note-Laplante2007-4">[3]</a></sup>
</p><div><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a15025f995045d46efd884f3337dfcaeec0af2bc" aria-hidden="true" alt="{\displaystyle M=E-N+2.}"/></p></div>
<p>Cyclomatic complexity may be applied to several such programs or subprograms at the same time (to all of the methods in a class, for example), and in these cases <span>P</span> will be equal to the number of programs in question; each subprogram will appear as a disconnected subset of the graph.
</p><p>McCabe showed that the cyclomatic complexity of a structured program with only one entry point and one exit point is equal to the number of decision points (&#34;if&#34; statements or conditional loops) contained in that program plus one. This is true only for decision points counted at the lowest, machine-level instructions.<sup id="cite_ref-5"><a href="#cite_note-5">[4]</a></sup> Decisions involving compound predicates like those found in high-level languages like <code>IF cond1 AND cond2 THEN ...</code> should be counted in terms of predicate variables involved; in this example, one should count two decision points because at machine level it is equivalent to <code>IF cond1 THEN IF cond2 THEN ...</code>.<sup id="cite_ref-mccabe76_3-2"><a href="#cite_note-mccabe76-3">[2]</a></sup><sup id="cite_ref-ecst_6-0"><a href="#cite_note-ecst-6">[5]</a></sup>
</p><p>Cyclomatic complexity may be extended to a program with multiple exit points; in this case, it is equal to
</p><div><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7b51ee47e0b5c3fcc4317df9c03364a691057576" aria-hidden="true" alt="{\displaystyle \pi -s+2,}"/></p></div><p>
where <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9be4ba0bb8df3af72e90a0535fabcc17431e540a" aria-hidden="true" alt="{\displaystyle \pi }"/></span> is the number of decision points in the program and <span>s</span> is the number of exit points.<sup id="cite_ref-ecst_6-1"><a href="#cite_note-ecst-6">[5]</a></sup><sup id="cite_ref-harrison_7-0"><a href="#cite_note-harrison-7">[6]</a></sup></p>
<h3><span id="Algebraic_topology"><span id="Explanation_in_terms_of_algebraic_topology"></span>Algebraic topology</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=3" title="Edit section: Algebraic topology"><span>edit</span></a><span>]</span></span></h3>
<p>An even subgraph of a graph (also known as an <a href="https://en.wikipedia.org/wiki/Eulerian_path" title="Eulerian path">Eulerian subgraph</a>) is one where every <a href="https://en.wikipedia.org/wiki/Vertex_(graph_theory)" title="Vertex (graph theory)">vertex</a> is <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Graph" title="Graph (discrete mathematics)">incident</a> with an even number of edges; such subgraphs are unions of cycles and isolated vertices. Subgraphs will be identified with their edge sets, which is equivalent to only considering those even subgraphs which contain all vertices of the full graph.
</p><p>The set of all even subgraphs of a graph is closed under <a href="https://en.wikipedia.org/wiki/Symmetric_difference" title="Symmetric difference">symmetric difference</a>, and may thus be viewed as a vector space over <a href="https://en.wikipedia.org/wiki/GF(2)" title="GF(2)">GF(2)</a>; this vector space is called the cycle space of the graph. The <a href="https://en.wikipedia.org/wiki/Cyclomatic_number" title="Cyclomatic number">cyclomatic number</a> of the graph is defined as the dimension of this space. Since GF(2) has two elements and the cycle space is necessarily finite, the cyclomatic number is also equal to the <a href="https://en.wikipedia.org/wiki/Natural_logarithm_of_2" title="Natural logarithm of 2">2-logarithm</a> of the number of elements in the cycle space.
</p><p>A basis for the cycle space is easily constructed by first fixing a <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Trees" title="Glossary of graph theory">spanning forest</a> of the graph, and then considering the cycles formed by one edge not in the forest and the path in the forest connecting the endpoints of that edge; these cycles form a basis for the cycle space. The cyclomatic number also equals the number of edges not in a maximal spanning forest of a graph. Since the number of edges in a maximal spanning forest of a graph is equal to the number of vertices minus the number of components, the formula <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c90a4856abe1ef57f4c28079fcd1eb7427ebcbda" aria-hidden="true" alt="{\displaystyle E-N+P}"/></span> for the cyclomatic number follows.<sup id="cite_ref-8"><a href="#cite_note-8">[7]</a></sup>
</p><p>Cyclomatic complexity can also be defined as a relative <a href="https://en.wikipedia.org/wiki/Betti_number" title="Betti number">Betti number</a>, the size of a <a href="https://en.wikipedia.org/wiki/Relative_homology" title="Relative homology">relative homology</a> group:
</p><div><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aa966d87b64dc22bd0d5f21c4b708952ccf78638" aria-hidden="true" alt="{\displaystyle M:=b_{1}(G,t):=\operatorname {rank} H_{1}(G,t),}"/></p></div>
<p>which is read as &#34;the rank of the first <a href="https://en.wikipedia.org/wiki/Homology_(mathematics)" title="Homology (mathematics)">homology</a> group of the graph <i>G</i> relative to the <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology" title="Tree (data structure)">terminal nodes</a> <i>t</i>&#34;. This is a technical way of saying &#34;the number of linearly independent paths through the flow graph from an entry to an exit&#34;, where:
</p>
<ul><li>&#34;linearly independent&#34; corresponds to homology; backtracking is not double-counted</li>
<li>&#34;paths&#34; corresponds to first homology; a path is a one-dimensional object</li>
<li>&#34;relative&#34; means the path must begin and end at an entry (or exit) point.</li></ul>
<p>This cyclomatic complexity can be calculated. It may also be computed via absolute <a href="https://en.wikipedia.org/wiki/Betti_number" title="Betti number">Betti number</a> by identifying the terminal nodes on a given component, or drawing paths connecting the exits to the entrance. The new, augmented graph <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/312d458e93142c5d455e0ab9837b52147ff843dc" aria-hidden="true" alt="{\displaystyle {\tilde {G}}}"/></span> obtains
</p><div><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6af5be0b3236222e462a4b8eb22c3c01e3d94abc" aria-hidden="true" alt="{\displaystyle M=b_{1}({\tilde {G}})=\operatorname {rank} H_{1}({\tilde {G}}).}"/></p></div>
<p>It can also be computed via <a href="https://en.wikipedia.org/wiki/Homotopy" title="Homotopy">homotopy</a>. If a (connected) control-flow graph is considered a one-dimensional <a href="https://en.wikipedia.org/wiki/CW_complex" title="CW complex">CW complex</a> called <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/68baa052181f707c662844a465bfeeb135e82bab" aria-hidden="true" alt="{\displaystyle X}"/></span>, the <a href="https://en.wikipedia.org/wiki/Fundamental_group" title="Fundamental group">fundamental group</a> of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/68baa052181f707c662844a465bfeeb135e82bab" aria-hidden="true" alt="{\displaystyle X}"/></span> will be <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/24b1123607d02ac07c5603513a8bfaaa08476065" aria-hidden="true" alt="{\displaystyle \pi _{1}(X)\cong \mathbb {Z} ^{*n}}"/></span>. The value of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a135e65a42f2d73cccbfc4569523996ca0036f1" aria-hidden="true" alt="{\displaystyle n+1}"/></span> is the cyclomatic complexity. The fundamental group counts how many loops there are through the graph up to homotopy, aligning as expected.
</p>
<h3><span id="Interpretation">Interpretation</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=4" title="Edit section: Interpretation"><span>edit</span></a><span>]</span></span></h3>
<p>In his presentation &#34;Software Quality Metrics to Identify Risk&#34;<sup id="cite_ref-9"><a href="#cite_note-9">[8]</a></sup> for the Department of Homeland Security, Tom McCabe introduces the following categorisation of cyclomatic complexity:
</p>
<ul><li>1 - 10: Simple procedure, little risk</li>
<li>11 - 20: More complex, moderate risk</li>
<li>21 - 50: Complex, high risk</li>
<li>&gt; 50: Untestable code, very high risk</li></ul>
<h2><span id="Applications">Applications</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=5" title="Edit section: Applications"><span>edit</span></a><span>]</span></span></h2>
<h3><span id="Limiting_complexity_during_development">Limiting complexity during development</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=6" title="Edit section: Limiting complexity during development"><span>edit</span></a><span>]</span></span></h3>
<p>One of McCabe&#39;s original applications was to limit the complexity of routines during program development; he recommended that programmers should count the complexity of the modules they are developing, and split them into smaller modules whenever the cyclomatic complexity of the module exceeded 10.<sup id="cite_ref-mccabe76_3-3"><a href="#cite_note-mccabe76-3">[2]</a></sup> This practice was adopted by the <a href="https://en.wikipedia.org/wiki/NIST" title="NIST">NIST</a> Structured Testing methodology, with an observation that since McCabe&#39;s original publication, the figure of 10 had received substantial corroborating evidence, but that in some circumstances it may be appropriate to relax the restriction and permit modules with a complexity as high as 15. As the methodology acknowledged that there were occasional reasons for going beyond the agreed-upon limit, it phrased its recommendation as &#34;For each module, either limit cyclomatic complexity to [the agreed-upon limit] or provide a written explanation of why the limit was exceeded.&#34;<sup id="cite_ref-nist_10-0"><a href="#cite_note-nist-10">[9]</a></sup>
</p>
<h3><span id="Measuring_the_.22structuredness.22_of_a_program"></span><span id="Measuring_the_&#34;structuredness&#34;_of_a_program">Measuring the &#34;structuredness&#34; of a program</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=7" title="Edit section: Measuring the &#34;structuredness&#34; of a program"><span>edit</span></a><span>]</span></span></h3>
 
<p>Section VI of McCabe&#39;s 1976 paper is concerned with determining what the control-flow graphs (CFGs) of non-<a href="https://en.wikipedia.org/wiki/Structured_programming" title="Structured programming">structured programs</a> look like in terms of their subgraphs, which McCabe identifies. (For details on that part see <a href="https://en.wikipedia.org/wiki/Structured_program_theorem" title="Structured program theorem">structured program theorem</a>.) McCabe concludes that section by proposing a numerical measure of how close to the structured programming ideal a given program is, i.e. its &#34;structuredness&#34; using McCabe&#39;s neologism. McCabe called the measure he devised for this purpose <a href="https://en.wikipedia.org/wiki/Essential_complexity_(numerical_measure_of_%22structuredness%22)" title="Essential complexity (numerical measure of &#34;structuredness&#34;)">essential complexity</a>.<sup id="cite_ref-mccabe76_3-4"><a href="#cite_note-mccabe76-3">[2]</a></sup>
</p><p>In order to calculate this measure, the original CFG is iteratively reduced by identifying subgraphs that have a single-entry and a single-exit point, which are then replaced by a single node. This reduction corresponds to what a human would do if they extracted a subroutine from the larger piece of code. (Nowadays such a process would fall under the umbrella term of <a href="https://en.wikipedia.org/wiki/Refactoring" title="Refactoring">refactoring</a>.) McCabe&#39;s reduction method was later called <i>condensation</i> in some textbooks, because it was seen as a generalization of the <a href="https://en.wikipedia.org/wiki/Condensation_(graph_theory)" title="Condensation (graph theory)">condensation to components used in graph theory</a>.<sup id="cite_ref-11"><a href="#cite_note-11">[10]</a></sup> If a program is structured, then McCabe&#39;s reduction/condensation process reduces it to a single CFG node. In contrast, if the program is not structured, the iterative process will identify the irreducible part. The essential complexity measure defined by McCabe is simply the cyclomatic complexity of this irreducible graph, so it will be precisely 1 for all structured programs, but greater than one for non-structured programs.<sup id="cite_ref-nist_10-1"><a href="#cite_note-nist-10">[9]</a></sup><sup><span title="Page / location: 80">: 80 </span></sup>
</p>
<h3><span id="Implications_for_software_testing">Implications for software testing</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=8" title="Edit section: Implications for software testing"><span>edit</span></a><span>]</span></span></h3>
<p>Another application of cyclomatic complexity is in determining the number of test cases that are necessary to achieve thorough test coverage of a particular module.
</p><p>It is useful because of two properties of the cyclomatic complexity, <span>M</span>, for a specific module:
</p>
<ul><li><span>M</span> is an upper bound for the number of test cases that are necessary to achieve a complete <a href="https://en.wikipedia.org/wiki/Branch_coverage" title="Branch coverage">branch coverage</a>.</li>
<li><span>M</span> is a lower bound for the number of paths through the control-flow graph (CFG). Assuming each test case takes one path, the number of cases needed to achieve <a href="https://en.wikipedia.org/wiki/Path_coverage" title="Path coverage">path coverage</a> is equal to the number of paths that can actually be taken. But some paths may be impossible, so although the number of paths through the CFG is clearly an upper bound on the number of test cases needed for path coverage, this latter number (of <i>possible</i> paths) is sometimes less than <span>M</span>.</li></ul>
<p>All three of the above numbers may be equal: branch coverage <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/440568a09c3bfdf0e1278bfa79eb137c04e94035" aria-hidden="true" alt="{\displaystyle \leq }"/></span> cyclomatic complexity <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/440568a09c3bfdf0e1278bfa79eb137c04e94035" aria-hidden="true" alt="{\displaystyle \leq }"/></span> number of paths.
</p><p>For example, consider a program that consists of two sequential if-then-else statements.
</p>
<div dir="ltr"><pre><span></span><span>if</span><span> </span><span>(</span><span>c1</span><span>())</span>
<span>    </span><span>f1</span><span>();</span>
<span>else</span>
<span>    </span><span>f2</span><span>();</span>

<span>if</span><span> </span><span>(</span><span>c2</span><span>())</span>
<span>    </span><span>f3</span><span>();</span>
<span>else</span>
<span>    </span><span>f4</span><span>();</span>
</pre></div>
<figure typeof="mw:File/Thumb"><a href="https://en.wikipedia.org/wiki/File:Control_flow_graph_of_function_with_two_if_else_statements.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Control_flow_graph_of_function_with_two_if_else_statements.svg/250px-Control_flow_graph_of_function_with_two_if_else_statements.svg.png" decoding="async" width="250" height="313" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Control_flow_graph_of_function_with_two_if_else_statements.svg/375px-Control_flow_graph_of_function_with_two_if_else_statements.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Control_flow_graph_of_function_with_two_if_else_statements.svg/500px-Control_flow_graph_of_function_with_two_if_else_statements.svg.png 2x" data-file-width="400" data-file-height="500"/></a><figcaption>The control-flow graph of the source code above; the red circle is the entry point of the function, and the blue circle is the exit point. The exit has been connected to the entry to make the graph strongly connected.</figcaption></figure>
<p>In this example, two test cases are sufficient to achieve a complete branch coverage, while four are necessary for complete path coverage. The cyclomatic complexity of the program is 3 (as the strongly connected graph for the program contains 9 edges, 7 nodes and 1 connected component) (<span>9 − 7 + 1</span>).
</p><p>In general, in order to fully test a module, all execution paths through the module should be exercised. This implies a module with a high complexity number requires more testing effort than a module with a lower value since the higher complexity number indicates more pathways through the code. This also implies that a module with higher complexity is more difficult for a programmer to understand since the programmer must understand the different pathways and the results of those pathways.
</p><p>Unfortunately, it is not always practical to test all possible paths through a program. Considering the example above, each time an additional if-then-else statement is added, the number of possible paths grows by a factor of 2. As the program grows in this fashion, it quickly reaches the point where testing all of the paths becomes impractical.
</p><p>One common testing strategy, espoused for example by the NIST Structured Testing methodology, is to use the cyclomatic complexity of a module to determine the number of <a href="https://en.wikipedia.org/wiki/White-box_testing" title="White-box testing">white-box tests</a> that are required to obtain sufficient coverage of the module. In almost all cases, according to such a methodology, a module should have at least as many tests as its cyclomatic complexity; in most cases, this number of tests is adequate to exercise all the relevant paths of the function.<sup id="cite_ref-nist_10-2"><a href="#cite_note-nist-10">[9]</a></sup>
</p><p>As an example of a function that requires more than simply branch coverage to test accurately, consider again the above function, but assume that to avoid a bug occurring, any code that calls either <code>f1()</code> or <code>f3()</code> must also call the other.<sup id="cite_ref-12"><a href="#cite_note-12">[b]</a></sup> Assuming that the results of <code>c1()</code> and <code>c2()</code> are independent, that means that the function as presented above contains a bug.  Branch coverage would allow us to test the method with just two tests, and one possible set of tests would be to test the following cases:
</p>
<ul><li><code>c1()</code> returns true and <code>c2()</code> returns true</li>
<li><code>c1()</code> returns false and <code>c2()</code> returns false</li></ul>
<p>Neither of these cases exposes the bug. If, however, we use cyclomatic complexity to indicate the number of tests we require, the number increases to 3. We must therefore test one of the following paths:
</p>
<ul><li><code>c1()</code> returns true and <code>c2()</code> returns false</li>
<li><code>c1()</code> returns false and <code>c2()</code> returns true</li></ul>
<p>Either of these tests will expose the bug.
</p>
<h3><span id="Correlation_to_number_of_defects">Correlation to number of defects</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=9" title="Edit section: Correlation to number of defects"><span>edit</span></a><span>]</span></span></h3>
<p>A number of studies have investigated the correlation between McCabe&#39;s cyclomatic complexity number with the frequency of defects occurring in a function or method.<sup id="cite_ref-fenton_13-0"><a href="#cite_note-fenton-13">[11]</a></sup>  Some studies<sup id="cite_ref-schroeder99_14-0"><a href="#cite_note-schroeder99-14">[12]</a></sup> find a positive correlation between cyclomatic complexity and defects: functions and methods that have the highest complexity tend to also contain the most defects. However, the correlation between cyclomatic complexity and program size (typically measured in <a href="https://en.wikipedia.org/wiki/Lines_of_code" title="Lines of code">lines of code</a>) has been demonstrated many times. <a href="https://en.wikipedia.org/wiki/Les_Hatton" title="Les Hatton">Les Hatton</a> has claimed<sup id="cite_ref-taic_15-0"><a href="#cite_note-taic-15">[13]</a></sup> that complexity has the same predictive ability as lines of code.
Studies that controlled for program size (i.e., comparing modules that have different complexities but similar size) are generally less conclusive, with many finding no significant correlation, while others do find correlation. Some researchers question the validity of the methods used by the studies finding no correlation.<sup id="cite_ref-kan_16-0"><a href="#cite_note-kan-16">[14]</a></sup> Although this relation likely exists, it is not easily used in practice.<sup id="cite_ref-cherf_17-0"><a href="#cite_note-cherf-17">[15]</a></sup> Since program size is not a controllable feature of commercial software, the usefulness of McCabe&#39;s number has been questioned.<sup id="cite_ref-fenton_13-1"><a href="#cite_note-fenton-13">[11]</a></sup> The essence of this observation is that larger programs tend to be more complex and to have more defects. Reducing the cyclomatic complexity of code is <a href="https://en.wikipedia.org/wiki/Correlation_does_not_imply_causation" title="Correlation does not imply causation">not proven</a> to reduce the number of errors or bugs in that code. International safety standards like <a href="https://en.wikipedia.org/wiki/ISO_26262" title="ISO 26262">ISO 26262</a>, however, mandate coding guidelines that enforce low code complexity.<sup id="cite_ref-ISO26262Part3_18-0"><a href="#cite_note-ISO26262Part3-18">[16]</a></sup>
</p>
<h2><span id="Artificial_intelligence">Artificial intelligence</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=10" title="Edit section: Artificial intelligence"><span>edit</span></a><span>]</span></span></h2>
<p>Cyclomatic complexity may also be used for the evaluation of the semantic complexity of artificial intelligence programs.<sup id="cite_ref-19"><a href="#cite_note-19">[17]</a></sup>
</p>
<h2><span id="Ultrametric_topology">Ultrametric topology</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=11" title="Edit section: Ultrametric topology"><span>edit</span></a><span>]</span></span></h2>
<p>Cyclomatic complexity has proven useful in geographical and landscape-ecological analysis, after it was shown that it can be implemented on graphs of <a href="https://en.wikipedia.org/wiki/Ultrametric_space" title="Ultrametric space">ultrametric</a> distances.<sup id="cite_ref-20"><a href="#cite_note-20">[18]</a></sup>
</p>
<h2><span id="See_also">See also</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=12" title="Edit section: See also"><span>edit</span></a><span>]</span></span></h2>
<ul><li><a href="https://en.wikipedia.org/wiki/Programming_complexity" title="Programming complexity">Programming complexity</a></li>
<li><a href="https://en.wikipedia.org/wiki/Complexity_trap" title="Complexity trap">Complexity trap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Computer_program" title="Computer program">Computer program</a></li>
<li><a href="https://en.wikipedia.org/wiki/Computer_programming" title="Computer programming">Computer programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Control_flow" title="Control flow">Control flow</a></li>
<li><a href="https://en.wikipedia.org/wiki/Decision-to-decision_path" title="Decision-to-decision path">Decision-to-decision path</a></li>
<li><a href="https://en.wikipedia.org/wiki/Design_predicates" title="Design predicates">Design predicates</a></li>
<li><a href="https://en.wikipedia.org/wiki/Essential_complexity_(numerical_measure_of_%22structuredness%22)" title="Essential complexity (numerical measure of &#34;structuredness&#34;)">Essential complexity (numerical measure of &#34;structuredness&#34;)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Halstead_complexity_measures" title="Halstead complexity measures">Halstead complexity measures</a></li>
<li><a href="https://en.wikipedia.org/wiki/Software_engineering" title="Software engineering">Software engineering</a></li>
<li><a href="https://en.wikipedia.org/wiki/Software_testing" title="Software testing">Software testing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Static_program_analysis" title="Static program analysis">Static program analysis</a></li>
<li><a href="https://en.wikipedia.org/wiki/Maintainability" title="Maintainability">Maintainability</a></li></ul>
<h2><span id="Notes">Notes</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=13" title="Edit section: Notes"><span>edit</span></a><span>]</span></span></h2>
<div>
<div><ol>
<li id="cite_note-2"><span><b><a href="#cite_ref-2">^</a></b></span> <span>Here, &#34;structured&#34; means &#34;with a single exit (<a href="https://en.wikipedia.org/wiki/Return_statement" title="Return statement">return statement</a>) per function&#34;.</span>
</li>
<li id="cite_note-12"><span><b><a href="#cite_ref-12">^</a></b></span> <span>This is a fairly common type of condition; consider the possibility that <code>f1</code> allocates some resource which <code>f3</code> releases.</span>
</li>
</ol></div></div>
<h2><span id="References">References</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=14" title="Edit section: References"><span>edit</span></a><span>]</span></span></h2>

<h2><span id="External_links">External links</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Cyclomatic_complexity&amp;action=edit&amp;section=15" title="Edit section: External links"><span>edit</span></a><span>]</span></span></h2>
<ul><li><a rel="nofollow" href="http://www.mathworks.com/discovery/cyclomatic-complexity.html">Generating cyclomatic complexity metrics with Polyspace</a></li>
<li><a rel="nofollow" href="http://www.leshatton.org/Documents/TAIC2008-29-08-2008.pdf">The role of empiricism in improving the reliability of future software</a></li>
<li><a rel="nofollow" href="https://web.archive.org/web/20230203195937/https://www.cqse.eu/en/news/blog/mccabe-cyclomatic-complexity//">McCabe&#39;s Cyclomatic Complexity and Why We Don&#39;t Use It</a></li></ul>
<!-- 
NewPP limit report
Parsed by mw2335
Cached time: 20240121024302
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.266 seconds
Real time usage: 0.382 seconds
Preprocessor visited node count: 1818/1000000
Post‐expand include size: 35641/2097152 bytes
Template argument size: 1458/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 56689/5000000 bytes
Lua time usage: 0.141/10.000 seconds
Lua memory usage: 7000117/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  278.565      1 -total
 57.40%  159.895      2 Template:Reflist
 29.00%   80.785      5 Template:Cite_web
 17.83%   49.668      1 Template:Short_description
 11.76%   32.763      7 Template:Cite_journal
 10.11%   28.155      2 Template:Pagetype
  8.24%   22.961      6 Template:Cite_book
  7.35%   20.468      1 Template:Rp
  6.66%   18.556      1 Template:Main
  6.40%   17.840      1 Template:R/superscript
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:1014906-0!canonical and timestamp 20240121024301 and revision id 1192212743. Rendering was triggered because: page-view
 -->
</div><!--esi <esi:include src="/esitest-fa8a495983347898/content" /> -->
</div></div>
  </body>
</html>
