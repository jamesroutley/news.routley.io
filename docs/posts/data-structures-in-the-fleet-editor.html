<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jetbrains.com/fleet/2022/02/fleet-below-deck-part-ii-breaking-down-the-editor/">Original</a>
    <h1>Data Structures in the Fleet Editor</h1>
    
    <div id="readability-page-1" class="page"><section>
                <div>
                                                            <div>
                        <p><img src="https://blog.jetbrains.com/wp-content/uploads/2021/08/bio-200x200.png" width="200" height="200" alt="Hadi Hariri" loading="lazy"/></p>
                    </div>
                                        
<p>This is a multipart series on building Fleet, a next generation IDE by JetBrains.</p>



<ul><li><a href="https://blog.jetbrains.com/fleet/2022/01/fleet-below-deck-part-i-architecture-overview/">Part I – Architecture Overview</a></li><li>Part II – Breaking down the editor</li></ul>



<p>In the first part of this series we looked at an overview of the Fleet architecture. In this second part we’re going to cover the algorithms and data structures that are used under the covers in the editor.</p>







<p>Take a look at the following screenshot of the editor window in Fleet</p>



<figure><img width="1126" height="154" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/image-7.png" alt=""/></figure>



<p>There’s a line of text with syntax highlighting and a widget providing information about usages of the particular variable. Now one could find multiple ways to display this information, but the issue with editors is that they are not read-only. In addition to visualization of data, they can also be updated. A simple operation such as changing a function name could impact many things such as syntax highlighting, usages, and of course any other feature offered such as static analysis or on-the-fly compilation. </p>



<p>In order to be able to provide a good experience, we need to make sure that editing text and the consequent visualization can be as seamless as possible. In order to accomplish this, we have to store and manipulate data in an efficient manner. However, it’s not just one way of storing data. In fact, the image above stores data in multiple ways, using different data structures that all come together to form what we call the editor. In other words, think of the editor as an aggregator of data structures!</p>



<p>Let’s break these down!</p>



<h2 id="ropes-everywhere">Ropes everywhere</h2>



<p>For those familiar with working with large amounts of text, you may already know that using strings (i.e. array of chars) to store them isn’t very efficient. Usually any operation on an array is going to imply having to create a new larger or smaller array, and copy the contents from the old one to the new one. This is hardly efficient. </p>



<p>A better and more standardized approach is to use <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">rope structures</a>. The idea behind this abstract data type is to store strings in leaf nodes on a tree.</p>



<figure><img loading="lazy" width="1600" height="832" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/1_diagram-2x.png" alt=""/></figure>



<p>Each leaf node contains a string and its length (called weight), and each intermediate node also contains a weight which is the sum of all the leaves in its left subtree.</p>



<p>From the example above, if we take for instance the node which holds the characters <em>fun</em>, the count of the node is 3 because the length of the string is 3. Moving up to the parent node, the count is also 3 because the sum of the weight of all nodes to its left is 3. Its parent in turn has a count of 19 because the sum of the leaves to its left is 3 and 16. </p>



<p>Common actions such as searching, appending, removing, splitting strings can be performed with O(log N) time complexity, where N is the length of the string. Operations start by traversing a tree, and given the information of the nodes, this makes it faster. For instance, if we want to find a character in position <em>i =</em> 30, we start with the node, and if 30 is less than the weight of the node (character count), we go to the left, subtracting (see note below) the value of the weight from i. If on the other hand <em>i </em>is higher, we go to the right. As we move down and the value of <em>i </em>decreases, once we reach a leaf node, the character at the <em>i </em>position of the string the leaf node holds is what we’re looking for. </p>







<p><em><strong>Note: </strong>depending on the metric used, subtraction may not be the required operation. What’s important is that as we move down the tree we accumulate the metric up to that point and compare it to the key we are scanning for. </em></p>



<p>When inserting or deleting nodes in the rope structure in Fleet, we use a self-balancing <a href="https://en.wikipedia.org/wiki/B-tree">B-Tree</a>. We start by reading chunks of 64 characters, and once we get to 32 chunks we create a node and start collecting chunks for a second node. Each node has two numbers – in addition to the weight we also store the line count (combination of both is what we call <em>metrics</em>). </p>



<figure><img loading="lazy" width="1600" height="528" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/2_diagram-2x.png" alt=""/></figure>



<p>By storing the line count, we can navigate faster to specific offsets. Another trait of the tree in Fleet is that we aim to keep them wide as opposed to deep. </p>



<h3 id="interval-trees-for-widgets-et-al">Interval trees for widgets et al. </h3>



<p>As we saw before a fragment of code may not only contain the actual text, but also additional elements like <em>usages</em>. </p>



<figure><img loading="lazy" width="1126" height="154" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/image-8.png" alt=""/></figure>



<p>We call these widgets, and they can be interline widgets such as the <em>Find Usages</em> or <em>Run </em>widgets, postline (e.g. debug information appearing after the line of code) or inlay (e.g. type hinting on variables and lambdas). </p>



<p>A widget in itself is merely a markup element, and the data structure that holds it is a variation on <a href="https://www.geeksforgeeks.org/interval-tree/">interval trees</a>, which in some way is also a rope structure. In Interval trees, nodes hold a range and the weight corresponds to the maximum of the ranges from the subtree.</p>



<figure><img loading="lazy" width="1600" height="704" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/3_diagram-2x.png" alt=""/></figure>



<p>In Fleet, each node contains a relative start and end of children nodes. Leaves in turn contain an actual widget. When running queries to see if a particular widget needs to be displayed based on some specific coordinate, we traverse the tree until we find an intersection of the range with the one we’re querying. </p>



<p>An important aspect is that the leaves also contain the widget ID. This means that in addition to querying what intersects with a specific range, for any widget we can also query to determine where it actually is located. </p>



<p>One variation from a standard interval tree is that in Fleet we allow nodes to overlap. This leads to the possibility of making searches somewhat less efficient, but by allowing this, we can create balanced trees and have them updatable as we type. </p>



<p>In addition to widgets, interval trees in Fleet are also used to keep track of carets, highlighting of text, as well as <em>sticky</em> locations in text which we call anchors.</p>



<h3 id="ropes-for-tokens-and-the-abstract-syntax-tree">Ropes for Tokens and the Abstract Syntax Tree</h3>



<p>When working with source code, whether it’s a compiler or an editor, you normally would use an Abstract Syntax Tree (AST). The way this works is that a parser analyzes the source code and creates a series of tokens. These tokens are then used to build up the AST. </p>



<p>Take the following code</p>



<p><code>fun compileBundles(ship: JpsModule, model: JpsModel, src: SrcBundles): DstBundles</code></p>



<p>It would be broken down into the following tokens</p>



<p><code>[fun][ ][compileBundles][(][ship][:][ ][JpsModule][,][ ][model][:][ ][JpsModel][,][ ][src][:][ ][SrcBundles][)][:][ ][DstBundles]</code></p>



<p>where each token is represented by square brackets (notice how empty spaces are also tokens). These tokens are then used to build the corresponding AST</p>



<figure><img loading="lazy" width="1600" height="608" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/4_diagram-2x.png" alt=""/></figure>



<p>The AST is then used for a variety of operations such as syntax highlighting, static analysis, etc. It is an important part of any IDE. </p>



<p><em>By the way, if you’re interested in seeing how some code is translated into an AST, check-out this </em><a href="https://astexplorer.net/"><em>cool online AST explorer</em></a><em> (which provides support for a variety of languages) </em></p>



<p>As we type in the editor, the text changes, meaning the tokens change, which in turn requires building a new AST so as to be able to provide the above functionality. </p>



<p>In Fleet, in order to avoid updating the AST directly, we use a rope structure to store the tokens in leaves (actually only the lengths are stored). To give an example, the above list of tokens could be represented with the following tree</p>



<figure><img loading="lazy" width="1600" height="432" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/5_diagram-2x.png" alt=""/></figure>



<p>When the user types something, for instance a space character, the tree is updated (length of 1 added in the leftmost leaf, causing increase in count along that path)</p>



<figure><img loading="lazy" width="1600" height="432" src="https://blog.jetbrains.com/wp-content/uploads/2022/02/6_diagram-2x.png" alt=""/></figure>



<p>The specific leaf gets the new token length added, which in turn causes updates to certain nodes of the tree in order to adjust the weight. The parser then receives a notification which forces it to update and reparse the AST. As such, for a fraction of second the AST may not be entirely correct, however the user experience is much better when it comes to editing as very little has to be updated. </p>



<h3 id="ropes-for-rendering">Ropes for Rendering </h3>



<p>The image below is yet another example of the editor, but this time with a few additional elements, namely the actual usages widget expanded to display usages, soft-wrap of lines, and other things such as colored vertical lines in the scrollbar.</p>



<figure><img src="https://lh3.googleusercontent.com/wXqgUrNtxzOqdwxikmtI_bYmCybYTHy3_yDB6rYyckmXk70lC5rvTul8_67JxxxqsWaS90CYaofSXdWtRgkJ3AFXgJL3NSEf7IToek3oVUtVHOUpMMuO5WMz5Dnk8OCng7pbGXxj" alt=""/></figure>



<p>To render the above, for a specific <em>Y</em> coordinate, we need to know not only which line is displayed but also take into account all the widgets and soft-wrapped lines. </p>



<p><em><strong>Fun fact:</strong> the editor rendered in the usages widget uses the same underlying data structures we’re exploring in this post. For usages in the same file, the same ropes are used to build and render this overlay editor.</em></p>



<p>Widget and soft-wrap information is also stored as a rope structure. Whereas before the leaves of the tree would hold the string and its length, in this case, we’re using leaves to hold what we call <em>SoftLine</em> objects. These are chunks of text accompanied by the heights that are considered visual lines. The weight of the nodes in this case (what we call metrics) are the height and length of the <em>SoftLine</em>. The height is stored in order to be able to support viewport queries. This height is affected by the interlines located inside of it. In addition, when soft-wraps are enabled, <em>SoftLines</em> don’t correspond one to one with real lines, but can span multiple lines. </p>



<h2 id="a-note-on-immutability">A note on immutability</h2>



<p>It’s important to mention that in Fleet we embrace immutability. Working with pure functions and immutable objects provide many benefits. Pure functions allow us to not only reason better about the code but also know that calling a function will not cause some other part of a system to change without our knowledge (i.e. have side-effects). In terms of data, knowing that an object is immutable means that it is thread-safe, and consequently there would not be race conditions when attempting any updates. For multi-threaded environments, this provides huge benefits. </p>



<p>This idea of immutability is also central to operations that use rope structures. Previously we spoke about how we make updates to nodes and leaves of the trees. These are all done in an immutable way – any operation on the tree produces a new copy of the tree which shares the structure with the old one, except from the root to the single node which needs changing. The fact that the trees in general are wide and not deep means that paths are very short. If the operation leads to any unreferenced nodes, these get garbage collected.</p>



<p>This is a significantly different approach from what we do on the IntelliJ platform where we use read-write lock mechanisms to perform changes. </p>







<p>As we’ve seen in this second part on how we build Fleet, something as simple as an editor where we can type and read code turns out to be a complex underlying aggregation of multiple different data structures, many of them being ropes. If you’re interested in learning more about ropes, make sure you check out the series on <a href="https://xi-editor.io/docs/rope_science_00.html">Rope Science</a>, which has heavily influenced the work we’ve been doing on Fleet. </p>



<p>Until the next time, happy sailing! </p>
                    
                                                                        </div>
                
            </section></div>
  </body>
</html>
