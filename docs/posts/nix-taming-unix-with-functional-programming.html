<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2022-07-14-taming-unix-with-nix/">Original</a>
    <h1>Nix: Taming Unix with Functional Programming</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>You may be aware of <a href="https://nixos.org">Nix or NixOS</a>.
Users love it for being a superior tool for building, deploying, and managing software.
Yet, it is generally perceived as notoriously hard to learn.</p>
<p>The core Nix ecosytem consists of several distinct components:</p>
<ul>
<li>The <em>Nix package manager</em> comes with a configuration language to declare software components, the <em>Nix language</em>.</li>
<li>Software made available through the package manager is centrally maintained in the <em>Nix package collection</em>, also known as <code>nixpkgs</code>.</li>
<li>There also exists a Linux distribution called <em>NixOS</em>, which is based on the package manager and the package collection.</li>
</ul>
<p>In an attempt to provide an alternative learning approach, this article discusses the Nix package manager (hereafter simply referred to as Nix) and its underlying principles in the context of the history of computing.
The condensed findings presented here reflect only some of our ongoing community effort<sup id="fnref-1"><a href="#fn-1">1</a></sup>, started this year to improve documentation and make the benefits of Nix more accessible to software developers, and eventually computer users in general.</p>
<h2 id="everything-is-a-what"><a href="#everything-is-a-what" aria-label="everything is a what permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Everything is a… what?</h2>
<p>Nix is not new.
It has been under active development <a href="https://github.com/NixOS/nix/commit/75d788b0f24e8de033a22c0869032549d602d4f6">since 2003</a>.</p>
<p>While touted as the purely functional package manager, one cannot say that Nix introduces a fundamentally new paradigm.
<a href="https://en.wikipedia.org/wiki/Functional_programming">Functional programming</a> goes back to John McCarthy’s <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> (1962), rooted in Alonzo Church’s <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a> (1936), where everything is a function.</p>
<p>It is not even a new idea for Nix to propose parting ways with one of the most pervasive <a href="https://en.wikipedia.org/wiki/Skeuomorph">skeuomorphisms</a> in computing, the file system, which <a href="https://en.wikipedia.org/wiki/File_system#Origin_of_the_term">naturally followed</a> from an era where everything was a piece of paper.</p>
<p>Ken Thompson and Dennis Ritchie inherited the novelty of a hierarchical file system from one of its predecessors <a href="https://en.wikipedia.org/wiki/Multics">Multics</a> and firmly assumed it as a given by 1974:</p>
<blockquote>
<p>The most important job of UNIX is to provide a file system.</p>
<p>— <a href="https://dsf.berkeley.edu/cs262/unix.pdf">The UNIX Time-Sharing System</a> (1974)</p>
</blockquote>
<p>Although arguably it is a severely limiting abstraction<sup id="fnref-2"><a href="#fn-2">2</a></sup>, it remains largely unquestioned as a cornerstone of software development practice<sup id="fnref-3"><a href="#fn-3">3</a></sup>.
The rise of object oriented-programming brought about a number of experimental systems<sup id="fnref-4"><a href="#fn-4">4</a></sup> where everything is an object — an idea attributed to Alan Kay’s <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> (1972) — but none of them saw mass adoption.</p>
<p>Part of the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a> later even turned into the malapropism <a href="https://en.wikipedia.org/wiki/Everything_is_a_file">everything is a file</a>.
Linus Torvalds clarified in various public emails that it was really about small, composable tools operating on uniform interfaces, not the specific mapping of names to contents:</p>
<blockquote>
<p>The whole point with “everything is a file” is not that you have some random filename (indeed, sockets and pipes show that “file” and “filename” have nothing to do with each other), but the fact that you can use common tools to operate on different things.</p>
<p>— <a href="https://lore.kernel.org/all/Pine.LNX.4.44.0206081523410.11630-100000@home.transmeta.com/T/#u">Linus Torvalds</a> (2002)</p>
</blockquote>
<blockquote>
<p>The UNIX philosophy is often quoted as “everything is a file”, but that really means “everything is a stream of bytes”.</p>
<p>— <a href="https://groups.google.com/g/fa.linux.kernel/c/Zm8SQ82bBYg/m/M2Xv-BfRv_YJ">Linus Torvalds</a> (2007)</p>
</blockquote>
<p>Rob Pike and Ken Thompson have further pursued the design of an entire system around a hierarchy of named files with <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan 9</a> since the 1980s, culminating in what Torvalds phrased as “everything is a namespace”:</p>
<blockquote>
<p>It may be unnatural to the Plan-9 way of “everything is a namespace”, but that was never the UNIX way.
The UNIX way is “everything is a file descriptor or a process”, but that was never about namespaces.<sup id="fnref-5"><a href="#fn-5">5</a></sup></p>
<p>— <a href="https://lore.kernel.org/all/Pine.LNX.4.44.0206091056550.13459-100000@home.transmeta.com/T/#u">Linus Torvalds</a> (2002)</p>
</blockquote>
<p>Today’s <a href="https://en.wikipedia.org/wiki/Usage_share_of_operating_systems">most widely used operating systems</a> (Linux, XNU, and Windows NT) all have file systems at their core.
However, Nix is special not so much because it radically puts that into question with the purely functional approach, but for rather pragmatically offering an intriguing shift in perspective:</p>
<p>What if we could continue developing and using all our software (mostly) as it is, and (mostly) stop bothering with file names, paths, and directories when building and deploying it?</p>
<h2 id="an-intriguing-shift-in-perspective"><a href="#an-intriguing-shift-in-perspective" aria-label="an intriguing shift in perspective permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An intriguing shift in perspective</h2>
<p>The key insight behind Nix is that the problem of <strong>software deployment</strong> can be seen through the lens of programming language theory.
The idea was first put forward by Eelco Dolstra et al. in <a href="https://edolstra.github.io/pubs/immdsd-icse2004-final.pdf">Imposing a Memory Management Discipline on Software Deployment</a> (2004). In his PhD thesis <a href="https://edolstra.github.io/pubs/phd-thesis.pdf">The Purely Functional Software Deployment Model</a> (2005), Dolstra proposed that we can treat the file system in an operating system like memory in a running program, and equate package management to memory management.
With Nix, he showed how to apply proven solutions, such as garbage collection or disallowing arbitrary manipulation of pointers (also known as <em>pointer discipline</em>), to the perennial struggle of making software work reliably.</p>
<p>The following figure illustrates the analogy of memory structures in programs and operating systems down to single objects.</p>
<p><img src="https://words.filippo.io/26d911ec4ffeff4a35bac3b52601b7f0/memory-analogy.svg" alt="Memory Analogy"/></p>
<p>As an example of this equivalence, take the following shell script:</p>

<p>It contains a reference to <code>/usr/bin/sh</code>.
That file path is just like a mutable pointer to a mutable variable:</p>
<ul>
<li>The path itself can be changed to reference a different file or one that does not even exist.</li>
<li>The contents of <code>/usr/bin/sh</code> can be changed or the file deleted entirely.</li>
</ul>
<p>This makes it hard to reason about the overall system state – the same problem as for program state in an imperative programming language.</p>
<p>More details are elaborated in the table below (based on Figure 3.1 in <a href="https://edolstra.github.io/pubs/phd-thesis.pdf">The Purely Functional Software Deployment Model</a>, p. 55).</p>
<table>
<thead>
<tr>
<th>Programming Language Domain</th>
<th>Deployment Domain</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory</td>
<td>disk</td>
</tr>
<tr>
<td>value, object</td>
<td>file</td>
</tr>
<tr>
<td>address</td>
<td>path name</td>
</tr>
<tr>
<td>pointer dereference</td>
<td>file access</td>
</tr>
<tr>
<td>pointer arithmetic</td>
<td>string operations</td>
</tr>
<tr>
<td>dangling pointer</td>
<td>path to absent file</td>
</tr>
<tr>
<td>object graph</td>
<td>dependency graph</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>calling constructed object with reference to other object</td>
<td>runtime dependency</td>
</tr>
<tr>
<td>calling constructor with reference to other object, not stored</td>
<td>build-time dependency</td>
</tr>
<tr>
<td>calling constructor with reference to other object, stored</td>
<td>retained dependency</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>languages without pointer discipline (e.g. assembler)</td>
<td>typical Unix-style deployment</td>
</tr>
<tr>
<td>languages with enough pointer discipline to </td>
<td>Nix</td>
</tr>
<tr>
<td>languages with full pointer discipline (e.g. Java, Haskell)</td>
<td>as-yet unknown deployment style not enabled </td>
</tr>
</tbody>
</table>
<p>This notion was further refined by Andrey Mokhov et al. in <a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf">Build Systems à la Carte</a> (2018), from a slightly different angle: distilling the essential features of build systems shows that <strong>building software</strong> can also be seen through the lens of programming language theory.
It is really about applying functions to arbitrary values, which happen to be files in a file system; some of these files end up being run as processes.
Again, proven solutions like memoization and self-adjusting computation offer themselves, this time, for tackling the perennial problem of long compilation times.</p>
<p><img src="https://words.filippo.io/2ffefe1d82e7cf3919bf811cd27aa936/dataflow-analogy.svg" alt="Dataflow Analogy"/></p>
<p>Both building and deploying software components as if they were values in a program’s call graph clearly shows the benefits and power of <a href="https://en.wikipedia.org/wiki/Purely_functional_programming">purely functional programming</a>: ensuring correctness while allowing flexible composition and automatic optimizations.</p>
<p>In case of Nix, this enables reproducible builds and deployments, comfortable construction of packages and their variants from reusable building blocks, and features such as transparent binary caching.</p>
<p>The following table shows equivalence in terminology between build systems and programming language theory:</p>
<table>
<thead>
<tr>
<th>Nix</th>
<th>Bazel</th>
<th>Build Systems à la Carte</th>
<th>programming language</th>
</tr>
</thead>
<tbody>
<tr>
<td>store object</td>
<td>artifact</td>
<td>value</td>
<td>value</td>
</tr>
<tr>
<td>builder</td>
<td>(depends on action type)</td>
<td>function</td>
<td>function</td>
</tr>
<tr>
<td>derivation</td>
<td>action</td>
<td><code>Task</code></td>
<td>thunk</td>
</tr>
<tr>
<td>derivation graph</td>
<td>action graph, build graph</td>
<td><code>Tasks</code></td>
<td>call graph</td>
</tr>
<tr>
<td>build</td>
<td>build</td>
<td>application of <code>Build</code></td>
<td>evaluation</td>
</tr>
<tr>
<td>store</td>
<td>action cache</td>
<td><code>Store</code></td>
<td>heap</td>
</tr>
</tbody>
</table>
<p>What Nix has been doing successfully since 2004 is encoding the <a href="https://www.youtube.com/watch?v=-6BsiVyC1kM&amp;t=123s">place-oriented</a> paradigm of files and processes in terms of a <a href="https://en.wikipedia.org/wiki/Dataflow_programming">dataflow-oriented</a> programming language, and hooking its evaluation results back into the operating system.</p>
<p>Maybe surprisingly, that programming language is <em>not</em> the Nix language, but what is called the <em>derivation language</em> — a key mechanism in the Nix store.
The purely functional, lazily evaluated Nix language is merely a user interface to declare objects and their relations (values and functions) as expressions in the derivation language.
The Nix package manager’s command line tools in turn allow running operations on the store, such as deriving new values by evaluating these expressions, and exposing values to the Unix environment.</p>
<p>NixOS pushes this idea to the limit by capturing as much operating system state as possible into the realm of <a href="https://en.wikipedia.org/wiki/Declarative_programming">declarative programming</a>.</p>
<p>The following diagram shows a drastic simplification of how Nix interacts with the operating system:
It uses files as function inputs, and outputs are files again.
On the operating system, files can be run as processes, which, in turn, operate on files.
A build function also amounts to an operating system process (not depicted).</p>
<p><img src="https://words.filippo.io/18d63a6c0a19d2c965a67f68ac7cc4a3/functional-mapping.svg" alt="Functional Mapping"/></p>
<p>Since its inception, Nix development has been primarily occupied with imposing the abstraction of functional programming onto the messy, real world of our Unix lineage:
encoding and correctly dealing with object references in the file system, ensuring purity of function application, and working around built-in assumptions behind the mechanisms of different language ecosystems and build procedures — all while keeping performance acceptable.</p>
<p>Despite numerous rough edges remaining due to the enormous scope of the undertaking, Nix, <code>nixpkgs</code>, and NixOS have been working products for many years.
Currently there is much work in progress to improve the user experience by presenting a more consistent command line interface and better error messages.</p>
<p>However, something much more interesting lives in the long-term.
Which other results from programming language theory and mathematics will we be able to leverage to make software build quickly, work reliably, and further tame Unix?
Nix is begging the question:
what if everything on our computers was, in fact, a computer program?</p>
</div></div></div>
  </body>
</html>
