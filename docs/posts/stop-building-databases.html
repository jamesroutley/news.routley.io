<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sqlsync.dev/posts/stop-building-databases/">Original</a>
    <h1>Stop building databases</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-d3haqyqs="">  <a href="https://sqlsync.dev/" data-astro-prefetch="" data-astro-cid-egg7nqdx=""> <svg viewBox="0 0 24 24" data-astro-cid-egg7nqdx="" astro-icon="mdi:arrow-up-left"><path fill="currentColor" d="M20 18v2h-6.5A6.5 6.5 0 0 1 7 13.5V7.83l-3.09 3.09L2.5 9.5 8 4l5.5 5.5-1.41 1.41L9 7.83v5.67C9 16 11 18 13.5 18H20z"></path></svg> back
</a>  <section data-astro-cid-egg7nqdx="">  <nav data-astro-cid-egg7nqdx=""> <strong data-astro-cid-egg7nqdx="">Outline</strong> <ul data-astro-cid-egg7nqdx=""> <li data-astro-cid-2dwpsowv=""> <a href="#the-humble-cache" aria-label="The humble cache" data-astro-prefetch="" data-astro-cid-2dwpsowv="">The humble cache</a> </li> <li data-astro-cid-2dwpsowv=""> <a href="#going-faster-with-indexes" aria-label="Going faster with indexes" data-astro-prefetch="" data-astro-cid-2dwpsowv="">Going faster with indexes</a> </li> <li data-astro-cid-2dwpsowv=""> <a href="#glass-half-full-mutations" aria-label="Glass half-full mutations" data-astro-prefetch="" data-astro-cid-2dwpsowv="">Glass half-full mutations</a> </li> <li data-astro-cid-2dwpsowv=""> <a href="#recursive-cache-invalidation" aria-label="Recursive Cache invalidation" data-astro-prefetch="" data-astro-cid-2dwpsowv="">Recursive Cache invalidation</a> </li> <li data-astro-cid-2dwpsowv=""> <a href="#are-we-building-databases" aria-label="Are we building databases?" data-astro-prefetch="" data-astro-cid-2dwpsowv="">Are we building databases?</a> </li> <li data-astro-cid-2dwpsowv=""> <a href="#lets-talk" aria-label="Let’s talk!" data-astro-prefetch="" data-astro-cid-2dwpsowv="">Let’s talk!</a> </li> <li data-astro-cid-2dwpsowv=""> <a href="#prior-art" aria-label="Prior art" data-astro-prefetch="" data-astro-cid-2dwpsowv="">Prior art</a> </li>  </ul> </nav> </section> <p>There comes a time in every frontend engineer’s life where we realize we need to cache data from an API. It might start off benign – storing a previous page of data for that instant back button experience, implementing a bit of undo logic, or merging some state from different API requests. But we all know what ends up happening. More feature requests show up, and soon we’re busy implementing data caches, manual indexes, optimistic mutations, and recursive cache invalidation.</p>
<p>These features bear a remarkable resemblance to the inner workings of databases. Indeed, <strong>in any frontend application of sufficient complexity, engineers will necessarily end up building so many data management features that they are essentially creating a domain specific database</strong>. This added complexity is duplicated in each project we work on, and takes away from spending time on delighting users and solving business problems.</p>
<p>So today, I’d like you to join me as we take a look at common application data patterns, and how they relate to database features. Afterwards, we will take a look at an alternative solution to these patterns - a frontend optimized database stack which allows us to focus on the application rather than micromanaging data.</p>
<p>Welcome to the world of accidental database programming.</p>
<h2 id="the-humble-cache">The humble cache</h2>
<p>Our journey starts in the most humble of ways. Send an API request to the server and store it in a local variable. We might want to do this for any number of reasons, but one good example is working around declarative re-renders. Many modern web applications use declarative frameworks like React, which internally will re-render the tree many times over the course of a user’s interaction with a page. We wouldn’t want to issue an API request for each render - so we throw the data into a variable. Here is an example using <a href="https://react.dev/learn" data-astro-prefetch="">React Hooks</a>:</p>
<pre tabindex="0"><code><span><span>const</span><span> Newsfeed</span><span> =</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> [{ </span><span>loading</span><span>, </span><span>entries</span><span>, </span><span>error</span><span> }, </span><span>setEntries</span><span>] </span><span>=</span><span> useState</span><span>({</span></span>
<span><span>    loading: </span><span>true</span><span>,</span></span>
<span><span>    entries: [],</span></span>
<span><span>    error: </span><span>null</span><span>,</span></span>
<span><span>  });</span></span>
<span></span>
<span><span>  useEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>    NewsfeedAPI.</span><span>getAll</span><span>()</span></span>
<span><span>      .</span><span>then</span><span>((</span><span>entries</span><span>) </span><span>=&gt;</span><span> setEntries</span><span>({entries }))</span></span>
<span><span>      .</span><span>catch</span><span>((</span><span>error</span><span>) </span><span>=&gt;</span><span> setEntries</span><span>({ error }));</span></span>
<span><span>  }, []);</span></span>
<span></span>
<span><span>  // render loading, entries, and error states</span></span>
<span><span>  return</span><span> &lt;</span><span>div</span><span>&gt;...&lt;/</span><span>div</span><span>&gt;;</span></span>
<span><span>};</span></span></code></pre>
<p>In this example<sup><a href="#user-content-fn-dont-do-this" data-astro-prefetch="" id="user-content-fnref-dont-do-this" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup> we can see a basic API request cache stored using React state hooks. Once the API request completes, we will cache the result (or an error) until the component is removed and re-added to the tree.</p>
<p>Soon we are tempted to add more features. A common next step is to “lift the cache” into a higher layer, or out of the UI tree entirely.</p>
<p>One example of this is using <a href="https://redux.js.org/" data-astro-prefetch="">Redux</a>, a popular state management library for React. At its core, Redux allows developers to consolidate state and coordinate atomic changes to that state over time. However, over time, Redux has evolved into an ecosystem of tools and patterns which can be used to manage API data caching. The goal of using Redux (or similar) in this way is to centralize cache logic, coordinate refresh, and most importantly share cache results between components.</p>
<p>As our humble caching layer grows in complexity it starts to take on a new identity: A centralized storage system that coordinates with the rendering engine and user actions to efficiently wrangle data. We might say it’s starting to look a bit like a database…</p>
<p>But that’s crazy. Let’s talk about indexes instead.</p>
<h2 id="going-faster-with-indexes">Going faster with indexes</h2>
<p>When I started building web apps almost two decades ago, I was immediately drawn to the elegance of properly structured data. By organizing data in a certain way, the application could do less work and deliver a much better user experience. At the time, my interactions with data in the backend were abstracted through databases - databases which allowed me to think about indexes as magical fairy dust sprinkled on queries to make them go fast. It wasn’t until I joined <a href="https://www.singlestore.com" data-astro-prefetch="">SingleStore</a> (formerly MemSQL) that I discovered how similar frontend data optimization was to the internals of database storage.<sup><a href="#user-content-fn-simple-indexes" data-astro-prefetch="" id="user-content-fnref-simple-indexes" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></p>
<p>One optimization we can leverage in the frontend is to store data cached from the server in an object keyed by ID. This often arises due to the structure of the underlying API. For example, in an application using a <a href="https://en.wikipedia.org/wiki/REST" data-astro-prefetch="">REST API</a>, we often read some data in batch and then enrich specific objects as needed. This requires constantly merging API results into the cache which is made easier if objects are stored by ID. Let’s look at an example of this kind of cache:</p>
<pre tabindex="0"><code><span><span>const</span><span> CACHE</span><span> =</span><span> {</span></span>
<span><span>  &#34;f3ac87&#34;</span><span>: {</span></span>
<span><span>    id: </span><span>&#34;f3ac87&#34;</span><span>,</span></span>
<span><span>    author: </span><span>&#34;@carlsverre&#34;</span><span>,</span></span>
<span><span>    title: </span><span>&#34;stop building databases&#34;</span><span>,</span></span>
<span><span>    description: </span><span>&#34;There comes a time in every software engineers life...&#34;</span><span>,</span></span>
<span><span>    createdAt: </span><span>new</span><span> Date</span><span>(),</span></span>
<span><span>  },</span></span>
<span><span>  /*</span></span>
<span><span>  &#34;a281f0&#34;: { ... },</span></span>
<span><span>  &#34;2f9f6c&#34;: { ... },</span></span>
<span><span>  ...</span></span>
<span><span>  */</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// retrieval by ID</span></span>
<span><span>console.</span><span>log</span><span>(</span><span>CACHE</span><span>[</span><span>&#34;f3ac87&#34;</span><span>]);</span></span>
<span></span>
<span><span>// update by ID</span></span>
<span><span>CACHE</span><span>[</span><span>&#34;f3ac87&#34;</span><span>].title </span><span>=</span><span> &#34;everyone is a database programmer&#34;</span><span>;</span></span></code></pre>
<p>In the example above, we are indexing entries by ID in a simple JavaScript object. Due to this “data shape,” we have optimized for creating, reading, updating, and deleting entries by ID. However, any operation that needs to look at multiple entries, such as a filter, would require checking every entry. Let’s improve this data structure to help us quickly look up entries by date:</p>
<pre tabindex="0"><code><span><span>const</span><span> truncateTime</span><span> =</span><span> (</span><span>date</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> clone</span><span> =</span><span> new</span><span> Date</span><span>(date);</span></span>
<span><span>  clone.</span><span>setHours</span><span>(</span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>);</span></span>
<span><span>  return</span><span> clone;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>const</span><span> ENTRIES_BY_DATE</span><span> =</span><span> Object.</span><span>groupBy</span><span>(</span></span>
<span><span>  Object.</span><span>values</span><span>(</span><span>CACHE</span><span>),</span></span>
<span><span>  (</span><span>e</span><span>) </span><span>=&gt;</span><span> truncateTime</span><span>(e.createdAt),</span></span>
<span><span>);</span></span>
<span></span>
<span><span>// filter by date == today</span></span>
<span><span>console.</span><span>log</span><span>(</span><span>ENTRIES_BY_DATE</span><span>[</span><span>truncateTime</span><span>(</span><span>new</span><span> Date</span><span>())]);</span></span></code></pre>
<p>In this second example, we create a basic index tracking the year/month/day portion of each entry’s <code>createdAt</code> field.<sup><a href="#user-content-fn-index-ways" data-astro-prefetch="" id="user-content-fnref-index-ways" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup> Now our frontend has gained the ability to quickly look up entries published on a given date – at the expense of having to maintain consistency between the two data structures: <code>CACHE</code> and <code>ENTRIES_BY_DATE</code>.</p>
<p>Consider what happens as we start managing many of these indexes - each requiring custom logic to build, update, and query. Verifying correctness quickly becomes a burden on testing and code review. Forgetting to properly delete or update an entry in one index can lead to difficult bugs. Soon, we are spending more time building infrastructure to manage this complexity than building new application features. <strong>It’s only a matter of time before we start to realize that we are, in fact, building a database.</strong></p>
<p>Caching and indexing data is not where our journey ends! Without fail, someone will realize that optimistically mutating these data structures could lead to a much snappier user experience.</p>
<h2 id="glass-half-full-mutations">Glass half-full mutations</h2>
<p>What are optimistic mutations anyway? Basically, the idea is to simulate the effect of a particular operation locally – before the server has had a chance to respond. By doing this, we can build user interfaces that seem to respond instantly, “eliminating” network latency. Of course, this comes at a cost - in the event that the server decides to do something other than anticipated (or there is some kind of error), the UI may need to “rollback” this change and prompt the user to fix issues. Assuming that the UI is good at predicting the server outcome (i.e. errors can be handled on the client side and logic is kept tightly in sync), optimistic mutations can be a powerful tool in a frontend engineer’s toolbox. It is also a great way to further practice our database engineering skills!</p>
<p>Let’s break down how optimistic mutations work, and think about the new challenges they bring to the table:</p>
<p><img src="https://sqlsync.dev/_astro/optimistic-updates.e800c3cb_MTwvt.webp" alt="A diagram illustrating the phases of an optimistic mutation&#39;s execution, which is described in detail below." width="1683" height="962" loading="lazy" decoding="async"/></p>
<p>In the diagram above, we can trace the execution path of an optimistic update:</p>
<ol>
<li>The UI emits a write operation. In this case, the UI is trying to update some piece of data.</li>
<li>This update is optimistically applied to the local cache - making the assumption that the server will end up agreeing with this decision. The UI can immediately re-render with the new state.</li>
<li>Asynchronously, the update operation is sent to the server.</li>
<li>Finally, the server responds with the result of the update which is merged into the local cache, overwriting the earlier optimistic update. This allows the UI to re-render (if needed), leaving the system in a (hopefully) consistent state.</li>
</ol>
<p>Ensuring that this process maintains consistency with the server comes with a number of challenges. First, we need to duplicate logic between the client and server, so we can optimistically predict the result. Next, each in-flight mutation must be tracked in order to handle asynchronous errors or server disagreements. Finally, in order to provide the best user experience, the optimistic portion of the cache may even need to be made durable to reconcile changes across application restart. Solving each of these challenges incurs a huge tax on both developer time and correctness verification. <strong>Once again, we find ourselves micromanaging data rather than delighting customers with new, differentiating features.</strong></p>
<p>But these issues pale in comparison to what I like to call: recursive cache invalidation.</p>
<h2 id="recursive-cache-invalidation">Recursive Cache invalidation</h2>
<p>In any reasonably data intensive application, pieces of data will often show up in multiple places in the cache:</p>
<pre tabindex="0"><code><span><span>const</span><span> CACHE</span><span> =</span><span> {</span></span>
<span><span>  projects: {</span></span>
<span><span>    1</span><span>: { id: </span><span>1</span><span>, name: </span><span>&#34;build a spaceship&#34;</span><span>, progress: </span><span>0.5</span><span>, numTasks: </span><span>10</span><span> },</span></span>
<span><span>    2</span><span>: { id: </span><span>2</span><span>, name: </span><span>&#34;to the moon&#34;</span><span>, progress: </span><span>0.0</span><span>, numTasks: </span><span>10</span><span> },</span></span>
<span><span>    // ...</span></span>
<span><span>  },</span></span>
<span><span>  tasks: {</span></span>
<span><span>    1</span><span>: { id: </span><span>1</span><span>, project: </span><span>1</span><span>, name: </span><span>&#34;finish hull design&#34;</span><span>, status: </span><span>&#34;pending&#34;</span><span> },</span></span>
<span><span>    9</span><span>: { id: </span><span>9</span><span>, project: </span><span>1</span><span>, name: </span><span>&#34;order bolts&#34;</span><span>, status: </span><span>&#34;pending&#34;</span><span> },</span></span>
<span><span>    // ...</span></span>
<span><span>  },</span></span>
<span><span>  users: {</span></span>
<span><span>    1</span><span>: { id: </span><span>1</span><span>, name: </span><span>&#34;Carl&#34;</span><span>, assignedTasks: [</span><span>1</span><span>] },</span></span>
<span><span>    2</span><span>: { id: </span><span>2</span><span>, name: </span><span>&#34;ChatGPT&#34;</span><span>, assignedTasks: [</span><span>9</span><span>] },</span></span>
<span><span>  },</span></span>
<span><span>};</span></span></code></pre>
<p>In the example above, we are caching projects, tasks, and users working on an important space mission.<sup><a href="#user-content-fn-space" data-astro-prefetch="" id="user-content-fnref-space" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup> Let’s figure out what we need to do after we complete a task in order to keep the cache consistent with the server:</p>
<p><img src="https://sqlsync.dev/_astro/recursive-invalidation.65e234ff_1PWkQ2.webp" alt="A sequence diagram illustrating recursive invalidation as outlined below." width="331" height="335" loading="lazy" decoding="async"/></p>
<p>Let’s walk through the steps:</p>
<ol>
<li>We inform the server that the task is complete.</li>
<li>Refresh the project as its progress has now changed.</li>
<li>60% complete! Now let’s check for new task assignments.</li>
<li>Darn, more work to do. Let’s see what the new assignment is.</li>
</ol>
<p>In this example, the UI has to do multiple round trips after an update to correctly invalidate every part of the cache that was potentially changed. While it’s certainly possible to build more complex APIs that reduce this into one trip,<sup><a href="#user-content-fn-graphql" data-astro-prefetch="" id="user-content-fnref-graphql" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup> ultimately the result is coupling API or client logic to the underlying data model. Let’s consider two reasons why this might be bad:</p>
<p>First, this requires that the UI knows what part of the cache is relevant to each mutation. This can become very brittle at scale, as data relationships and aggregations may influence many parts of the local cache. Also, as the engineering team grows, these issues may even cross team boundaries, which can start to feel similar to mutable global variables in large software projects.</p>
<p>Second, when coupled with optimistic mutations, reproducing server logic on the client side in order to predict server changes becomes much more difficult. For example, in this case, we may want to optimistically remove task 1 from user 1 and increase the progress value by calculating a new ratio (we can use the total number of tasks). As we teach our applications how to predict these nested changes locally, our clients naturally duplicate more and more of the backend stack.</p>
<h2 id="are-we-building-databases">Are we building databases?</h2>
<p>In any frontend application of sufficient complexity, engineers will necessarily end up building so many data management features that they are essentially creating a domain specific database. This added complexity is duplicated in each project we work on and takes away from spending time on delighting users and solving business problems. My goal here was to shine a light on these patterns we have grown accustomed to and ask: <strong>where is the frontend optimized database stack we deserve?</strong></p>
<p>I’m tired of waiting - so I’m tackling this problem head-on. I call it <a href="https://github.com/orbitinghail/sqlsync" data-astro-prefetch="">SQLSync</a>. SQLSync is a frontend optimized database stack built on top of <a href="https://www.sqlite.org/" data-astro-prefetch="">SQLite</a><sup><a href="#user-content-fn-sqlite-stats" data-astro-prefetch="" id="user-content-fnref-sqlite-stats" data-footnote-ref="" aria-describedby="footnote-label">6</a></sup> with a synchronization engine powered by ideas from <a href="https://git-scm.com/" data-astro-prefetch="">Git</a> and distributed systems. The stack is designed to integrate seamlessly with the most popular frontend frameworks like <a href="https://react.dev/" data-astro-prefetch="">React</a>, <a href="https://vuejs.org/" data-astro-prefetch="">Vue</a>, and <a href="https://nextjs.org/" data-astro-prefetch="">Next.js</a>. SQLSync’s goal is to handle the hardest data management problems, allowing developers to focus on what makes their application unique.</p>
<p>As an early example of what SQLSync can do, check out <a href="https://sqlsync-todo.pages.dev/" data-astro-prefetch="">this Todo app</a>. The entire data layer is implemented in <a href="https://github.com/orbitinghail/sqlsync/blob/ba762ce2a10afbb8d7856d26ce5b2f108716e38d/demo/demo-reducer/src/lib.rs" data-astro-prefetch="">60 lines of Rust</a> and a couple of <a href="https://github.com/orbitinghail/sqlsync/blob/ba762ce2a10afbb8d7856d26ce5b2f108716e38d/demo/frontend/src/components/TaskList.tsx#L12" data-astro-prefetch="">SQL queries</a> scattered across components. In exchange, SQLSync provides a durable cache, the full power of SQLite (indexes, constraints, triggers, query optimization), optimistic mutations, smart cache invalidation, and reactive queries.</p>
<p>Let’s briefly take a deeper look at how SQLSync approaches each of the data management problems we’ve discussed today.</p>
<p>SQLSync stores data locally in one or more SQLite databases. At face value, this gives us a durable cache that looks very similar to the databases we use in the backend. But it’s a durable cache with superpowers!</p>
<p>First off, indexes can be created easily, and are automatically kept in sync with the data. Just like on the backend, these indexes can be automatically used by the database to accelerate queries.</p>
<p>But it’s not just indexes! SQLite also gives us the full power of SQL which can easily express complex queries over our data, as well as <a href="https://www.sqlite.org/lang_createtrigger.html" data-astro-prefetch="">triggers</a>, <a href="https://www.sqlite.org/foreignkeys.html" data-astro-prefetch="">foreign keys</a>, <a href="https://www.sqlite.org/lang_createtable.html#check_constraints" data-astro-prefetch="">constraints</a>, and extensions such as <a href="https://www.sqlite.org/fts5.html" data-astro-prefetch="">full-text search</a>.</p>
<p>On top of all that, SQLSync provides optimistic mutations out of the box. It does this by handling mutations in a reducer, similar to <a href="https://redux.js.org/introduction/core-concepts" data-astro-prefetch="">how Redux works</a>. The reducer can be written in any language that can be compiled to WebAssembly. Using this reducer, SQLSync can execute mutations optimistically on the client, and then run them in a globally consistent order on the server. Finally, the client performs an operation similar to a <a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing" data-astro-prefetch="">Git Rebase</a> to synchronize the client with the server.<sup><a href="#user-content-fn-sqlsync-talk" data-astro-prefetch="" id="user-content-fnref-sqlsync-talk" data-footnote-ref="" aria-describedby="footnote-label">7</a></sup></p>
<p>One advantage of SQLSync’s architecture is that it eliminates the need for recursive cache invalidation. By writing all the data mutation logic within a reducer that can be easily shared on both the client and the server, all changes made during a mutation are automatically visible. Even better, due to synchronization working like “Git Rebase”, this approach allows the server to make different changes than what happened on the client - with the guarantee that the client will always reach the same consistent outcome. This is a powerful capability that eliminates the need for developers to spend mental bandwidth on data micromanagement.</p>
<h2 id="lets-talk">Let’s talk!</h2>
<p>I’m building SQLSync because I want to make client-side applications easier to build without us having to reinvent the wheel each time. If you share my vision of the future, consider <a href="https://github.com/orbitinghail/sqlsync" data-astro-prefetch="">starring SQLSync on Github</a>, <a href="https://discord.gg/etFk2N9nzC" data-astro-prefetch="">joining our discord</a>, or <a href="https://sqlsync.dev/cdn-cgi/l/email-protection#99f1fcf5f5f6d9f6ebfbf0edf0f7fef1f8f0f5b7fdfcef" data-astro-prefetch="">emailing me</a>. I’d love to hear what your perfect client-side database looks like and what you think about SQLSync’s approach to the problem.</p>
<h2 id="prior-art">Prior art</h2>
<p>The topic of using a database (or database methods) in the frontend stack is a popular topic these days. I’d like to highlight some specific articles that I found insightful and relevant.</p>
<h3 id="riffle">Riffle</h3>
<p>In Riffle’s essay <a href="https://riffle.systems/essays/prelude/" data-astro-prefetch="">“Building data-centric apps with a reactive relational database”</a>, the authors explore the idea of storing all application state – including UI state – in a single reactive database. Some key ideas that inspired this blog post as well as the development of SQLSync include:</p>
<ul>
<li>Reactive queries provide a clean mental model and align well with declarative systems like React</li>
<li>Solving technical challenges in client-side application development using ideas originating in the database community</li>
<li>The benefits of modeling state using a relational data model and real indexes</li>
</ul>
<h3 id="instantdb">Instant.db</h3>
<p>Stepan, the author of Instant.db, wrote two fantastic blog posts on databases in the browser.</p>
<ul>
<li><a href="https://stopa.io/post/279" data-astro-prefetch="">Database in the Browser, a Spec</a></li>
<li><a href="https://stopa.io/post/296" data-astro-prefetch="">A Graph-Based Firebase</a></li>
</ul>
<p>I highly recommend reading both posts, as they describe many of the same issues I mention in this post, with more of a focus on the relationship between the frontend and backend stack. Ultimately Stepan clearly describes the motivation which led to the creation of Instant.db, a graph-based successor to Firebase.</p>
<h3 id="cr-sqlite">CR-SQLite</h3>
<p>Matt Wonlaw’s <a href="https://github.com/vlcn-io/cr-sqlite" data-astro-prefetch="">CR-SQLite</a> is an extension to SQLite which uses conflict free replicated data types (CRDTs) and causally ordered event logs to support merging data consistently. This allows peer-to-peer applications to store and collaborate on data in SQLite without requiring a central coordinator. This project is also a fantastic example of running SQLite in the browser.</p>
<p>In addition, Matt is exploring related ideas like <a href="https://github.com/vlcn-io/materialite" data-astro-prefetch="">incremental computation</a> and making SQL easier to work with via <a href="https://github.com/vlcn-io/typed-sql" data-astro-prefetch="">typed-sql</a>. Overall, Matt is an inspiring builder in the space, and I recommend taking a look at what he is working on.</p>

  </div></div>
  </body>
</html>
