<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/GothicKit/dmusic">Original</a>
    <h1>Show HN: I wrote a partial re-implementation of DirectMusic</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This project aims to re-implement Microsoft&#39;s long-deprecated DirectMusic API available in early Direct3D and DirectX
versions. It is currently under heavy development at this time and might be unstable for some use-cases.</p>
<p dir="auto">Soundtracks tested and verified to work (somewhat) correctly:</p>
<ul dir="auto">
<li>Gothic</li>
<li>Gothic II (+ Night of the Raven)</li>
</ul>

  Gothic II&#39;s &#34;Khorinis Day Standard&#34; theme rendered using this library:
<details open="">
  <summary>
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path d="M16 3.75v8.5a.75.75 0 0 1-1.136.643L11 10.575v.675A1.75 1.75 0 0 1 9.25 13h-7.5A1.75 1.75 0 0 1 0 11.25v-6.5C0 3.784.784 3 1.75 3h7.5c.966 0 1.75.784 1.75 1.75v.675l3.864-2.318A.75.75 0 0 1 16 3.75Zm-6.5 1a.25.25 0 0 0-.25-.25h-7.5a.25.25 0 0 0-.25.25v6.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-6.5ZM11 8.825l3.5 2.1v-5.85l-3.5 2.1Z"></path>
</svg>
    <span aria-label="Video description KH_DayStd.mp4">KH_DayStd.mp4</span>
    <span></span>
  </summary>

  <video src="https://private-user-images.githubusercontent.com/20187490/337955325-56d14b3f-6fab-427f-88b8-959f100b6c79.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc5NjQ0NjcsIm5iZiI6MTcxNzk2NDE2NywicGF0aCI6Ii8yMDE4NzQ5MC8zMzc5NTUzMjUtNTZkMTRiM2YtNmZhYi00MjdmLTg4YjgtOTU5ZjEwMGI2Yzc5Lm1wND9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDklMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA5VDIwMTYwN1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTJiNGE0YzdmMTlmNGUwMjA3YmExMWZlOGViZjliNzkyZTIxZDU1ZGQ5YWU2NTE5N2QwY2FlMjlhNmJjYTM2M2UmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.zWIacmaneTjei43JcKMhjxHhnSGC85FclXlFngvlavg" data-canonical-src="https://private-user-images.githubusercontent.com/20187490/337955325-56d14b3f-6fab-427f-88b8-959f100b6c79.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc5NjQ0NjcsIm5iZiI6MTcxNzk2NDE2NywicGF0aCI6Ii8yMDE4NzQ5MC8zMzc5NTUzMjUtNTZkMTRiM2YtNmZhYi00MjdmLTg4YjgtOTU5ZjEwMGI2Yzc5Lm1wND9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDklMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA5VDIwMTYwN1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTJiNGE0YzdmMTlmNGUwMjA3YmExMWZlOGViZjliNzkyZTIxZDU1ZGQ5YWU2NTE5N2QwY2FlMjlhNmJjYTM2M2UmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.zWIacmaneTjei43JcKMhjxHhnSGC85FclXlFngvlavg" controls="controls" muted="muted">

  </video>
</details>

<p dir="auto">Download the MP3 <a href="https://raw.githubusercontent.com/GothicKit/dmusic/main/support/KH_DayStd.mp3" rel="nofollow">here</a>.</p>

<p dir="auto">If you tested other games, please let me know. If you own any games with <code>.dls</code>, <code>.sty</code> and <code>.sgt</code> files in the data
folders, and you want to contribute, please contact me as well or open an issue.</p>


<p dir="auto">To build this project, you will need a C11-capable C compiler (like <code>gcc</code> or <code>clang</code>) and CMake 3.10 or newer. Linux,
macOS and Windows are supported, but I can only assist with compilation error in a limited fashion on platforms other
than Linux.</p>
<p dir="auto">On Linux, you can build the project like this (macOS and Windows might work differently):</p>
<div data-snippet-clipboard-copy-content="cmake -B build -DDM_ENABLE_ASAN=OFF -DDM_BUILD_EXAMPLES=ON
cmake --build build"><pre><code>cmake -B build -DDM_ENABLE_ASAN=OFF -DDM_BUILD_EXAMPLES=ON
cmake --build build
</code></pre></div>
<p dir="auto">(set <code>-DDM_BUILD_EXAMPLES=OFF</code>, if the example fails to compile)</p>
<p dir="auto">You will find the library and executable files in the <code>build</code> and <code>build/examples</code> directories. Note that the example
only works on systems providing the <code>&lt;unistd.h&gt;</code> and <code>&lt;sys/stat.h&gt;</code> headers.</p>

<p dir="auto">Here&#39;s how you play back a segment. This example works on POSIX only since it uses <code>&lt;sys/stat.h&gt;</code> for the file resolver.
On Windows, you simply need to replace <code>dm_resolve_file</code> with a Windows-compatible implementation.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;dmusic.h&gt;

#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;

static void* dm_resolve_file(void* ctx, char const* name, size_t* len);

int main(int argc, char** argv) {
	Dm_setLoggerDefault(DmLogLevel_INFO);

	// 1. Create a new DmLoader. The loader is responsible for loading and caching DirectMusic files using a
	//    user-defined callback function called a &#34;resolver&#34;. You really only ever need one for your application.

	DmLoader* loader = NULL;
	DmResult rv = DmLoader_create(&amp;loader, DmLoader_DEFAULT | DmLoader_DOWNLOAD);
	if (rv != DmResult_SUCCESS) {
		puts(&#34;Creating the loader failed\n&#34;);
		return rv;
	}

	// 2. Register a resolver with the loader. A resolver is simply a function which gets a context pointer,
	//    a filename and returns a memory buffer and its length as an output parameter. The context pointer
	//    is user-defined, here it&#39;s just a path string. You can return NULL from a resolver to indicate that
	//    the file was not found.

	rv = DmLoader_addResolver(loader, dm_resolve_file, &#34;/path/to/your/music/folder&#34;);
	if (rv != DmResult_SUCCESS) {
		puts(&#34;Adding the resolver failed\n&#34;);
		return rv;
	}

	// 3. Use the loader to obtain a segment. The loader will call your resolvers in order to read in the
	//    file, and it will then perform some internal magic to load the segment. Since we set the
	//    DmLoader_DOWNLOAD option when constructing the loader, we don&#39;t need to call DmSegment_download
	//    afterward. Otherwise, you do have to call it.

	DmSegment* segment = NULL;
	rv = DmLoader_getSegment(loader, &#34;YourSegment.sgt&#34;, &amp;segment);
	if (rv != DmResult_SUCCESS) {
		puts(&#34;Getting the segment failed\n&#34;);
		return rv;
	}

	// 4. Create a new performance. The performance represents your main playback device. It handles all
	//    the DirectMusic magic needed to produce music from your segments. You typically only need one
	//    performance for your application. The second parameter here is the sample rate, defaulted to
	//    44100 Hz.

	DmPerformance* performance = NULL;
	rv = DmPerformance_create(&amp;performance, 44100);
	if (rv != DmResult_SUCCESS) {
		puts(&#34;Creating the performance failed\n&#34;);
		return rv;
	}

	// 5. Instruct the performance to play a segment. This will set up the performance&#39;s internals so that
	//    the following call to DmPerformance_renderPcm will start producing music. The performance renders
	//    music on-demand, so as long as you don&#39;t call DmPerformance_renderPcm, you can consider playback to
	//    be paused. To stop playing music, you can pass NULL as the segment parameter.
	//
	//    The third parameter here is the timing. It tells the performance at which boundary to start playing
	//    the new segment as to not interrupt the flow of music. The options are &#34;instant&#34;, which ignores all
	//    that and immediately plays the segment, &#34;grid&#34; which plays the segment at the next possible beat
	//    subdivision, &#34;beat&#34; which plays the segment at the next beat and &#34;measure&#34; which plays it at the next
	//    measure boundary.
	//
	//    The performance also supports transitions. To play those, use DmPerformance_playTransition and see
	//    its inline documentation for more information.

	rv = DmPerformance_playSegment(performance, segment, DmTiming_MEASURE);
	if (rv != DmResult_SUCCESS) {
		puts(&#34;Playing the segment failed\n&#34;);
		return rv;
	}

	size_t len = 1000000;
	float* pcm = malloc(sizeof *pcm * len);

	// 6. Finally, render some PCM! This will instruct the performance to start processing the underlying
	//    DirectMusic messages and render the resulting PCM to the output buffer. In this case it will
	//    render 1000000 stereo samples which is 500000 samples per channel.
	//
	//    This will advance the internal clock for as many ticks as required to render the requested number
	//    of samples. No more, no less.

	rv = DmPerformance_renderPcm(performance, pcm, len, DmRender_FLOAT | DmRender_STEREO);
	if (rv != DmResult_SUCCESS) {
		puts(&#34;Playing the PCM failed\n&#34;);
		return rv;
	}

	// 6.1. Write out the PCM data to some place where we can access it later. This could also just be some
	//      audio output device or another library.

	FILE* fp = fopen(&#34;output.pcm&#34;, &#34;w&#34;);
	if (fp == NULL) {
		puts(&#34;Opening the output file failed\n&#34;);
		return -1;
	}

	(void) fwrite(pcm, sizeof *pcm, len, fp);
	(void) fclose(fp);

	// 7. Don&#39;t forget to clean up after yourself.
	free(pcm);

	DmSegment_release(segment);
	DmPerformance_release(performance);
	DmLoader_release(loader);
	return 0;
}

static void* dm_resolve_file(void* ctx, char const* name, size_t* len) {
	char const* root = ctx;

	// 1. Concat `root` and `name` to produce the final path. If a slash is missing
	//    at the end of `root`, add it.
	size_t root_len = strlen(root);
	size_t name_len = strlen(name);

	int miss_sep = root[root_len - 1] != &#39;/&#39;;

	char* path = malloc(root_len + name_len + 1 + miss_sep);
	memcpy(path, root, root_len);
	memcpy(path + root_len + miss_sep, name, name_len);

	if (miss_sep) {
		path[root_len] = &#39;/&#39;;
	}

	path[root_len + name_len + miss_sep] = &#39;\0&#39;;

	// 2. Check if the file we want to open actually exists. If it doesn&#39;t, return NULL.
	struct stat st;
	if (stat(path, &amp;st) != 0) {
		free(path);
		return NULL;
	}

	// 3. Read in data from the file.
	FILE* fp = fopen(path, &#34;re&#34;);
	if (fp == NULL) {
		free(path);
		return NULL;
	}

	void* bytes = malloc((size_t) st.st_size);
	*len = fread(bytes, 1, (size_t) st.st_size, fp);

	(void) fclose(fp);
	free(path);

	return bytes;
}"><pre><span>#include</span> <span>&lt;dmusic.h&gt;</span>

<span>#include</span> <span>&lt;stddef.h&gt;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;string.h&gt;</span>
<span>#include</span> <span>&lt;sys/stat.h&gt;</span>

<span>static</span> <span>void</span><span>*</span> <span>dm_resolve_file</span>(<span>void</span><span>*</span> <span>ctx</span>, <span>char</span> <span>const</span><span>*</span> <span>name</span>, <span>size_t</span><span>*</span> <span>len</span>);

<span>int</span> <span>main</span>(<span>int</span> <span>argc</span>, <span>char</span><span>*</span><span>*</span> <span>argv</span>) {
	<span>Dm_setLoggerDefault</span>(<span>DmLogLevel_INFO</span>);

	<span>// 1. Create a new DmLoader. The loader is responsible for loading and caching DirectMusic files using a</span>
	<span>//    user-defined callback function called a &#34;resolver&#34;. You really only ever need one for your application.</span>

	<span>DmLoader</span><span>*</span> <span>loader</span> <span>=</span> <span>NULL</span>;
	<span>DmResult</span> <span>rv</span> <span>=</span> <span>DmLoader_create</span>(<span>&amp;</span><span>loader</span>, <span>DmLoader_DEFAULT</span> | <span>DmLoader_DOWNLOAD</span>);
	<span>if</span> (<span>rv</span> <span>!=</span> <span>DmResult_SUCCESS</span>) {
		<span>puts</span>(<span>&#34;Creating the loader failed\n&#34;</span>);
		<span>return</span> <span>rv</span>;
	}

	<span>// 2. Register a resolver with the loader. A resolver is simply a function which gets a context pointer,</span>
	<span>//    a filename and returns a memory buffer and its length as an output parameter. The context pointer</span>
	<span>//    is user-defined, here it&#39;s just a path string. You can return NULL from a resolver to indicate that</span>
	<span>//    the file was not found.</span>

	<span>rv</span> <span>=</span> <span>DmLoader_addResolver</span>(<span>loader</span>, <span>dm_resolve_file</span>, <span>&#34;/path/to/your/music/folder&#34;</span>);
	<span>if</span> (<span>rv</span> <span>!=</span> <span>DmResult_SUCCESS</span>) {
		<span>puts</span>(<span>&#34;Adding the resolver failed\n&#34;</span>);
		<span>return</span> <span>rv</span>;
	}

	<span>// 3. Use the loader to obtain a segment. The loader will call your resolvers in order to read in the</span>
	<span>//    file, and it will then perform some internal magic to load the segment. Since we set the</span>
	<span>//    DmLoader_DOWNLOAD option when constructing the loader, we don&#39;t need to call DmSegment_download</span>
	<span>//    afterward. Otherwise, you do have to call it.</span>

	<span>DmSegment</span><span>*</span> <span>segment</span> <span>=</span> <span>NULL</span>;
	<span>rv</span> <span>=</span> <span>DmLoader_getSegment</span>(<span>loader</span>, <span>&#34;YourSegment.sgt&#34;</span>, <span>&amp;</span><span>segment</span>);
	<span>if</span> (<span>rv</span> <span>!=</span> <span>DmResult_SUCCESS</span>) {
		<span>puts</span>(<span>&#34;Getting the segment failed\n&#34;</span>);
		<span>return</span> <span>rv</span>;
	}

	<span>// 4. Create a new performance. The performance represents your main playback device. It handles all</span>
	<span>//    the DirectMusic magic needed to produce music from your segments. You typically only need one</span>
	<span>//    performance for your application. The second parameter here is the sample rate, defaulted to</span>
	<span>//    44100 Hz.</span>

	<span>DmPerformance</span><span>*</span> <span>performance</span> <span>=</span> <span>NULL</span>;
	<span>rv</span> <span>=</span> <span>DmPerformance_create</span>(<span>&amp;</span><span>performance</span>, <span>44100</span>);
	<span>if</span> (<span>rv</span> <span>!=</span> <span>DmResult_SUCCESS</span>) {
		<span>puts</span>(<span>&#34;Creating the performance failed\n&#34;</span>);
		<span>return</span> <span>rv</span>;
	}

	<span>// 5. Instruct the performance to play a segment. This will set up the performance&#39;s internals so that</span>
	<span>//    the following call to DmPerformance_renderPcm will start producing music. The performance renders</span>
	<span>//    music on-demand, so as long as you don&#39;t call DmPerformance_renderPcm, you can consider playback to</span>
	<span>//    be paused. To stop playing music, you can pass NULL as the segment parameter.</span>
	<span>//</span>
	<span>//    The third parameter here is the timing. It tells the performance at which boundary to start playing</span>
	<span>//    the new segment as to not interrupt the flow of music. The options are &#34;instant&#34;, which ignores all</span>
	<span>//    that and immediately plays the segment, &#34;grid&#34; which plays the segment at the next possible beat</span>
	<span>//    subdivision, &#34;beat&#34; which plays the segment at the next beat and &#34;measure&#34; which plays it at the next</span>
	<span>//    measure boundary.</span>
	<span>//</span>
	<span>//    The performance also supports transitions. To play those, use DmPerformance_playTransition and see</span>
	<span>//    its inline documentation for more information.</span>

	<span>rv</span> <span>=</span> <span>DmPerformance_playSegment</span>(<span>performance</span>, <span>segment</span>, <span>DmTiming_MEASURE</span>);
	<span>if</span> (<span>rv</span> <span>!=</span> <span>DmResult_SUCCESS</span>) {
		<span>puts</span>(<span>&#34;Playing the segment failed\n&#34;</span>);
		<span>return</span> <span>rv</span>;
	}

	<span>size_t</span> <span>len</span> <span>=</span> <span>1000000</span>;
	<span>float</span><span>*</span> <span>pcm</span> <span>=</span> <span>malloc</span>(<span>sizeof</span> <span>*</span><span>pcm</span> <span>*</span> <span>len</span>);

	<span>// 6. Finally, render some PCM! This will instruct the performance to start processing the underlying</span>
	<span>//    DirectMusic messages and render the resulting PCM to the output buffer. In this case it will</span>
	<span>//    render 1000000 stereo samples which is 500000 samples per channel.</span>
	<span>//</span>
	<span>//    This will advance the internal clock for as many ticks as required to render the requested number</span>
	<span>//    of samples. No more, no less.</span>

	<span>rv</span> <span>=</span> <span>DmPerformance_renderPcm</span>(<span>performance</span>, <span>pcm</span>, <span>len</span>, <span>DmRender_FLOAT</span> | <span>DmRender_STEREO</span>);
	<span>if</span> (<span>rv</span> <span>!=</span> <span>DmResult_SUCCESS</span>) {
		<span>puts</span>(<span>&#34;Playing the PCM failed\n&#34;</span>);
		<span>return</span> <span>rv</span>;
	}

	<span>// 6.1. Write out the PCM data to some place where we can access it later. This could also just be some</span>
	<span>//      audio output device or another library.</span>

	<span>FILE</span><span>*</span> <span>fp</span> <span>=</span> <span>fopen</span>(<span>&#34;output.pcm&#34;</span>, <span>&#34;w&#34;</span>);
	<span>if</span> (<span>fp</span> <span>==</span> <span>NULL</span>) {
		<span>puts</span>(<span>&#34;Opening the output file failed\n&#34;</span>);
		<span>return</span> <span>-1</span>;
	}

	(<span>void</span>) <span>fwrite</span>(<span>pcm</span>, <span>sizeof</span> <span>*</span><span>pcm</span>, <span>len</span>, <span>fp</span>);
	(<span>void</span>) <span>fclose</span>(<span>fp</span>);

	<span>// 7. Don&#39;t forget to clean up after yourself.</span>
	<span>free</span>(<span>pcm</span>);

	<span>DmSegment_release</span>(<span>segment</span>);
	<span>DmPerformance_release</span>(<span>performance</span>);
	<span>DmLoader_release</span>(<span>loader</span>);
	<span>return</span> <span>0</span>;
}

<span>static</span> <span>void</span><span>*</span> <span>dm_resolve_file</span>(<span>void</span><span>*</span> <span>ctx</span>, <span>char</span> <span>const</span><span>*</span> <span>name</span>, <span>size_t</span><span>*</span> <span>len</span>) {
	<span>char</span> <span>const</span><span>*</span> <span>root</span> <span>=</span> <span>ctx</span>;

	<span>// 1. Concat `root` and `name` to produce the final path. If a slash is missing</span>
	<span>//    at the end of `root`, add it.</span>
	<span>size_t</span> <span>root_len</span> <span>=</span> <span>strlen</span>(<span>root</span>);
	<span>size_t</span> <span>name_len</span> <span>=</span> <span>strlen</span>(<span>name</span>);

	<span>int</span> <span>miss_sep</span> <span>=</span> <span>root</span>[<span>root_len</span> <span>-</span> <span>1</span>] <span>!=</span> <span>&#39;/&#39;</span>;

	<span>char</span><span>*</span> <span>path</span> <span>=</span> <span>malloc</span>(<span>root_len</span> <span>+</span> <span>name_len</span> <span>+</span> <span>1</span> <span>+</span> <span>miss_sep</span>);
	<span>memcpy</span>(<span>path</span>, <span>root</span>, <span>root_len</span>);
	<span>memcpy</span>(<span>path</span> <span>+</span> <span>root_len</span> <span>+</span> <span>miss_sep</span>, <span>name</span>, <span>name_len</span>);

	<span>if</span> (<span>miss_sep</span>) {
		<span>path</span>[<span>root_len</span>] <span>=</span> <span>&#39;/&#39;</span>;
	}

	<span>path</span>[<span>root_len</span> <span>+</span> <span>name_len</span> <span>+</span> <span>miss_sep</span>] <span>=</span> <span>&#39;\0&#39;</span>;

	<span>// 2. Check if the file we want to open actually exists. If it doesn&#39;t, return NULL.</span>
	<span>struct</span> <span>stat</span> <span>st</span>;
	<span>if</span> (<span>stat</span>(<span>path</span>, <span>&amp;</span><span>st</span>) <span>!=</span> <span>0</span>) {
		<span>free</span>(<span>path</span>);
		<span>return</span> <span>NULL</span>;
	}

	<span>// 3. Read in data from the file.</span>
	<span>FILE</span><span>*</span> <span>fp</span> <span>=</span> <span>fopen</span>(<span>path</span>, <span>&#34;re&#34;</span>);
	<span>if</span> (<span>fp</span> <span>==</span> <span>NULL</span>) {
		<span>free</span>(<span>path</span>);
		<span>return</span> <span>NULL</span>;
	}

	<span>void</span><span>*</span> <span>bytes</span> <span>=</span> <span>malloc</span>((<span>size_t</span>) <span>st</span>.<span>st_size</span>);
	<span>*</span><span>len</span> <span>=</span> <span>fread</span>(<span>bytes</span>, <span>1</span>, (<span>size_t</span>) <span>st</span>.<span>st_size</span>, <span>fp</span>);

	(<span>void</span>) <span>fclose</span>(<span>fp</span>);
	<span>free</span>(<span>path</span>);

	<span>return</span> <span>bytes</span>;
}</pre></div>
<p dir="auto">More examples can be found in the <code>examples/</code> folder.</p>

<p dir="auto">If you have any questions, or you just want to say hi, you can reach me via e-mail (<a href="mailto:me@lmichaelis.de"><code>me@lmichaelis.de</code></a>)
or on Discord either via DM but preferably in the Gothic VR and GMC Discords (<code>@lmichaelis</code>).</p>
</article></div></div>
  </body>
</html>
