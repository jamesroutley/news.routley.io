<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://decomposition.al/blog/2025/11/17/i-took-the-crusty-interpreter-class/">Original</a>
    <h1>I took the â€œCrusty Interpreterâ€ class!</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2025-11-17T10:48:00+00:00">November 17, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p>Last week, I cleared everything else off my schedule to take the <a href="https://dabeaz.com/crusty.html">â€œCrusty Interpreterâ€</a> course, an immersive 5-day â€œwrite an interpreter in Rustâ€ course taught by <a href="https://dabeaz.com/about.html">Dave Beazley</a>. I have <a href="https://decomposition.al/blog/categories/#rust">a long history with Rust</a>, but the language has moved on considerably from what I used to know.  Worse, Iâ€™d barely written code in <em>any</em> language in years, except for a bit of Haskell for courses I teach and the occasional horrible one-off Python script to automate some task â€“ so I was eager to change that.</p>

<p>The course was a blast!  The idea was to write an interpreter for Lox, the toy language from <a href="https://craftinginterpreters.com/">Bob Nystromâ€™s <em>Crafting Interpreters</em> book</a>.  The book already presents a complete Lox interpreter in Java, but we were doing our own thing in Rust, and I pretty quickly stopped following the bookâ€™s code since it was very different from what I was trying to do in Rust.  If youâ€™re curious what I ended up with, my code is now <a href="https://github.com/lkuper/roxette">public</a>. Itâ€™s incomplete â€“ I only got as far as section 8.1 of the book â€“ but it runs and does stuff; give <code>cargo run</code> a whirl! If a course like this sounds fun to you, consider <a href="https://dabeaz.com/courses.html">taking one of Daveâ€™s various upcoming courses</a>.</p>

<p>I posted lots of <a href="https://recurse.social/@lindsey/115528312385404703">thoughts about the course on Mastodon</a> after each day ended.  Here are all of those, cleaned up and collected in one place.</p>

<h2 id="day-1">Day 1</h2>

<ul>
  <li>Weâ€™re only on lexing so far. Dave mentioned that itâ€™s kind of a bummer that the course has to start with tedious string processing stuff. It wouldnâ€™t have to be that way! We could have gone back to front! But thatâ€™s the way the Nystrom book is written, and weâ€™re following the book.</li>
  <li>Iâ€™m doing more talking than anyone else other than Dave. I wish other people would speak up more. I have no idea how far along they are, or if this is hard for them or easy for them or what.</li>
  <li>The Nystrom book uses Java as its implementation language. Rust is really different from Java along at least two axes: low-level memory layout concerns, and, uh, â€œobject-orientednessâ€. It is kind of fun trying to figure out how to port the Java code to Rust while navigating <em>both</em> of those at once.</li>
  <li>We are doing quite a lot of talking about error handling. Thatâ€™s probably a good thing!</li>
  <li>I find <a href="https://doc.rust-lang.org/std/result/#the-question-mark-operator-">the <code>?</code> thing for error handling</a> in Rust to be rather mysterious so far, and Iâ€™d much rather write explicit <code>match</code>es on <code>Result</code>s. I can always refactor later once I figure out what Iâ€™m doing. (Perhaps itâ€™s not really different from a typical Haskell pattern for error chaining, as seen when programming with <code>Maybe</code> or <code>Either</code>, and so it ought to be familiar to me. But hey, I never claimed to be good at Haskell either.)</li>
  <li>We talked a lot today about how slicing strings doesnâ€™t respect character widths. Someone had a cute example of slicing a ZWJâ€™d emoji in half and getting one of the constituent emoji.</li>
  <li>I donâ€™t really know if I am writing idiomatic Rust. I donâ€™t even know if anyone in the class can tell me whether Iâ€™m writing idiomatic Rust.</li>
  <li>I spent quite a while today trying to figure out how to implement <code>Display</code> on things, then trying to figure out if I could derive <code>Display</code>, all kind of needlessly.</li>
  <li>Dave mentioned that he didnâ€™t want people to get hung up on fiddly details of Rust and thus lose sight of the big picture. On the one hand, I already feel very comfortable with the big picture of interpreters; fiddly details of Rust are exactly what Iâ€™m here to learn! On the other hand, I do want to actually â€œfinishâ€ the project by the end of the week, which will probably require sacrificing some attention to detail. Weâ€™ll see how it goes.</li>
</ul>

<h2 id="day-2">Day 2</h2>

<ul>
  <li>We talked a bunch about move semantics today. Itâ€™s funny, but the time Iâ€™ve spent thinking about <a href="https://decomposition.al/blog/categories/#choreographic-programming">choreographic programming</a> â€“ where all data and computation is <em>located</em> somewhere, and it moves around when communication occurs â€“ actually seems like it could be helpful for reasoning about data movement in Rust.</li>
  <li>Iâ€™m worried about having enough time to write code. This course is really making obvious what a weird silo of knowledge I have as an academic PL person! I could have any number of deep conversations about PL concepts in the abstract, but Iâ€™m <em>super slow</em> at actually writing code; I donâ€™t have the muscle memory for anything, I have to look every little thing up, and I usually know enough to know my code is inelegant, but not enough to know how to fix it.</li>
  <li>That said, I think I might waste time preemptively looking things up, when in Rust I could actually just try stuff and then let error messages tell me what to do. For example, it is really slick how if you donâ€™t know, say, what functions you need to implement for a trait, you can just write <code>impl Trait for Type { }</code> (with the actual name of the trait and the type, of course!), and the compiler will tell you whatâ€™s missing.</li>
  <li>From the Nystrom book: â€œIn Lox, as in most programming languages, the rules of that grammar are simple enough for the language to be classified a regular language.â€ Hmm, really?  Are â€œmost programming languagesâ€ regular languages? I donâ€™t think so.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup></li>
  <li>I had to derive <code>PartialEq</code> on a bunch of my types so that I could write tests with  <code>assert_eq!</code>. I was curious what â€œpartialâ€ meant. (In Haskell you would just use <code>Eq</code> , most of the time.) Welp, TIL that a partial equivalence relation is an equivalence relation that isnâ€™t reflexive (!). The example in the docs for <code>PartialEq</code> is that NaN != NaN, so floating point types implement <code>PartialEq</code> but not <code>Eq</code>. ğŸ˜¬<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup></li>
  <li>Dave was using some types called <code>Person</code> and <code>Pet</code> for an example and kept saying things like â€œput the <code>Pet</code> in a <code>Box</code>â€ and â€œwhen the <code>Person</code> dies, the <code>Pet</code> dies, tooâ€ and it was all very sad.</li>
  <li>Recursive types have to be of finite size, so for example, for an <code>Expr</code> enum type for an AST, apparently you need to use <code>Box</code> when you refer to an <code>Expr</code> inside an <code>Expr</code>. For the record, this sucks and is ugly.</li>
  <li>Itâ€™s the end of day 2 of this 5-day course and Iâ€™m, uh, almost done with the lexer. :lolsob: Today I finally got the multi-character operators and string literals done. I still have to deal with numeric literals and keywords, and then I can finally move on. Also, my lexer is absolutely hideous and the error handling is laughably bad! Oh, well!</li>
</ul>

<h2 id="day-3">Day 3</h2>

<ul>
  <li>I finished my lexer and moved on to parsing today! I took some time to make my lexer nicer once I got it passing tests, and that brought me joy.</li>
  <li>The style Daveâ€™s lexer is written in seems very different from mine. For instance, <code>self</code> doesnâ€™t occur in my code at all. I think he hewed closely to the style of the Nystrom book, but I didnâ€™t know how to do that in Rust, so â€“ I didnâ€™t.</li>
  <li>I got hung up on data structures today.  I wanted a mapping from keywords to token types. This data structure will never change, so I wanted it to be static. Well, it turns out that <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#usage-in-const-and-static">you canâ€™t have a static <code>HashMap</code> in Rust</a>. After much flailing, I didnâ€™t use a data structure at all and just wrote a function that pattern matches on strings and returns token types.   The <code>HashMap</code> wouldâ€™ve been overkill anyway â€“ but I dunno what wouldâ€™ve been idiomatic.</li>
  <li>We continued with the <code>Pet</code> and <code>Person</code> examples, and they got sillier and sillier. We kept saying things like, â€œMaybe the groomer should have borrowed your pet instead of taking ownership of your petâ€ or â€œWhen you get your dog back from the groomer is it the <em>same</em> dog or is it a <em>different</em> dog?â€</li>
  <li>The first parsing-related project in the course was just coming up with an AST representation and then writing a pretty printer. That was easy, but parsing itself is going to kick my butt.</li>
  <li>I find the bookâ€™s example parsing code to be incredibly hard to follow. Dave doesnâ€™t seem to be a big fan of it, either. His own example parsing code (in Python, for a tiny toy language) is more helpful to me, but I still think parsing is going to kick my butt.  It is quite possible that parsing is as far as I manage to get this week.  (Although, once I finally have an AST, I imagine that I can bang out an evaluator for at least a subset of the language really fast.)</li>
  <li>Sorry, but Iâ€™m going to get on my soapbox about the <code>HashMap</code> thing some more. Is there not a nice simple lightweight association list data structure in the standard library? I couldnâ€™t find one. I would be happy to just call <code>lookup</code> on a vector of tuples, but do I have to write it myself? Surely itâ€™s already there and I missed it, right? Like, come on. I really, really do not want or need â€œresistance against HashDoS attacksâ€ for my &amp;ast;checks notes&amp;ast; toy interpreterâ€™s token lookup table.</li>
  <li>Even if I donâ€™t make it past parsing, this course is serving the purpose that I hoped it would, which is to get me writing Rust in a semi-serious way (again). Rust is <em>nice</em>. I know everyone says this, but I have to say it too: the user experience is nice â€“ and Iâ€™m not even using any of the fancy-pants tooling that exists these days! I just mean simple stuff, like error messages are thoughtful, and itâ€™s easy to write and run tests, and <em>docs search works</em>. So much love and care was put in. â¤ï¸</li>
</ul>

<h2 id="day-4">Day 4</h2>

<ul>
  <li>I talked with some people on Mastodon last night and I realized that maybe I could write a macro that solves the <code>HashMap</code> problem I was complaining about yesterday. I didnâ€™t get a chance to attempt it, though, becauseâ€¦</li>
  <li>I spent the whole day on parsing. I had a complete mess that didnâ€™t really work. Then, after a conversation with Dave late in the day, I overhauled it, and now itâ€™s pretty and works!</li>
  <li>Iâ€™ve never actually written a parser from scratch before (except in Scheme, for Scheme, for my Scheme compiler course in grad school, and that totally doesnâ€™t count), and I didnâ€™t expect to actually <em>like</em> the code at the end. Itâ€™s really kind of magical.</li>
  <li>We talked a bunch about lifetimes and borrowing and stuff in class today, but I was honestly pretty distracted with the parsing stuff and wasnâ€™t paying close attention.</li>
  <li>It will be a piece of cake to write a simple expression evaluator now. Iâ€™m not that worried about variables â€“ Iâ€™ve written a lot of environment-passing interpreters â€“ but I <em>am</em> worried about how to deal with variable <em>mutation</em>. I donâ€™t know how Iâ€™m going to handle that, and I might run out of time for it, since thereâ€™s only one day left. Thatâ€™s kind of too bad, because thatâ€™s the part of the project that would force me to confront interesting corners of Rust. Well, weâ€™ll see.</li>
  <li>My parser, like my lexer, is in a very functional style. <code>self</code> still doesnâ€™t occur anywhere in my code. Dave was like â€œsooner or later youâ€™re gonna have to go over to the dark sideâ€, but, empirically, no, I donâ€™t. (Itâ€™s not actually that Iâ€™m opposed to writing things in a more object-oriented style! Itâ€™s that I literally do not even know <em>how</em> to do it in Rust. I guess I could look at Daveâ€™s Rust code more. I havenâ€™t been doing that.)</li>
  <li>There seems to have been a lot of attrition in the course. For a big chunk of today, it was only Dave, one other person, and me. Apparently someone dropped the course because it was moving too slow for them. (That has, uh, not been my experience.) Other people had to bail because life happened.</li>
  <li>I wonder if maybe I should have taken <a href="https://www.dabeaz.com/ruckus.html">this other course</a>, which is the one Dave <a href="https://mastodon.social/@dabeaz/115531678338530673">suggested to Shriram</a>. I think it wouldâ€™ve been easier for me. Oh, well â€“ challenge is good!</li>
</ul>

<h2 id="day-5">Day 5</h2>

<ul>
  <li>The course is officially over. I learned a ton! I didnâ€™t get that far on the actual interpreter (lexing and parsing alone took four days, and then today I banged out a simple evaluator for a small subset of the whole language, but even that involved some interesting design choices and some stuff I hadnâ€™t thought about before). I definitely got a lot better at Rust, which was the goal.</li>
  <li>I developed some strong opinions about the Nystrom book. Pedagogically, I donâ€™t much care for it aas an introduction to language design and implementation. As one example: <a href="https://craftinginterpreters.com/representing-code.html">Chapter 5</a> is supposed to be about ASTs. Java is so ill-suited for the task that the book instead does this metaprogramming thing to generate the AST code, which is a neat hack, but itâ€™s completely beside the point of what an AST is all about! I would be very confused if it were my first exposure to the concept.</li>
  <li>Also! Modern Java has enums and pattern matching and stuff! It wouldnâ€™t <em>have</em> to be done in this boilerplatey, verbose way that necessitates a bunch of automation just to <em>checks notes</em> define an AST type! But thatâ€™s how the book does it.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup></li>
  <li>Another complaint about the book is that thereâ€™s so much ink spilled about operator precedence. Really? For Fisher-Price: My First Interpreter? Words can scarcely describe how little I care about operator precedence.</li>
  <li>Anyway, enough complaining. On my first quick 20-minute hack-up of the expression evaluator, I made a beginner mistake: I evaluated subexpressions and then tried to do Rust operations on them, but of course I couldnâ€™t because theyâ€™re Lox values, not Rust values. But this raised a design question: implement a bunch of traits (like <code>Neg</code>, <code>Not</code>, <code>Add</code>, <code>Sub</code>, etc.) for Lox values, or convert Lox values to Rust values so you can do normal Rust operations on them? I went with the latter.</li>
  <li>I ended up having to think about some design choices more than I expected! For instance, I decided that it should be okay to use comparison operations on arguments of different types, but that the result should always be <code>false</code>. So, <code>3 &lt;= &#34;hello&#34;</code> evaluates to <code>false</code>, and <code>3 &gt; &#34;hello&#34;</code> does as well. I could imagine how this behavior might be surprising. Thereâ€™s a lot of nuance here. (There might be a â€œcorrectâ€ semantics for Lox, but I didnâ€™t bother to read the book in detail to find out.)</li>
  <li>Part of the point of this course was supposed to be that dealing with things like mutable variables in Lox would force people to confront thorny issues with ownership in Rust. I didnâ€™t get that far, but Dave said that in the multiple times heâ€™s taught this course, <em>everyone</em> has implemented the environment incorrectly by using cloning where they shouldnâ€™t â€“ but they never notice the problem, apparently because it doesnâ€™t surface until you get further in the book than this course goes!</li>
  <li>We spent a lot of time talking about ownership and borrowing. One interesting question is: how to express co-ownership of an object? Returning again to the â€œpetâ€ example, we talked about how you could model a situation where two people co-own a pet and should both be able to feed the pet (which mutates the pet!). This made talking about the example even sillier, of course. We kept saying things like, â€œInstead of a person having a pet, they can have a ref-counted pet.â€</li>
  <li>Had I gotten further on the interpreter, the ref-counting thing would have been relevant for correctly managing the environment in Lox. But I didnâ€™t even get as far as implementing mutable variables, since, again, lexing and parsing took 80% of the time. I probably wouldâ€™ve gotten through those parts faster if were either more familiar with Rust, or if I had ever in my life implemented a proper lexer or parser before! Iâ€™m still happy with how much I got done, though.</li>
  <li>I thought it was kind of a bummer how many people seemed to disappear from the course. One person apparently said the course was going too slow for them, which makes no sense to me. The project was very self-directed, and every aspect of it had fractal complexity. You could spend the week just thinking about how to make error reporting good. (Dave kind of did this.) Or you could spend the week just trying to figure out how to allocate the barest minimum of memory. (Dave did a little of this.)</li>
  <li>All in all, Iâ€™m really glad I did this! I didnâ€™t get that far on the actual interpreter, but it runs and does stuff, and I implemented a few things I had never implemented before. I donâ€™t think I had any new insights about interpretation as such, but that wasnâ€™t what I was going for. I did get better at Rust, which <em>was</em> what I was going for.</li>
  <li>Dave invited us to sit in on <a href="https://www.dabeaz.com/ruckus.html">the â€œRuckusâ€ course</a> for free, so I hope to do that at some point, if I can make the time!</li>
  <li>Last thing: I now have a Rust thing I want to build! I want immutable association lists that are constructed at compile time, so you can use them in a <code>static</code> initializer. Basically, I think what I want is something with the interface of the <a href="https://docs.rs/alist/latest/alist/"><code>alist</code> crate</a>, but instead of being backed by a <code>Vec</code>, it would just be backed by, I guess, a plain olâ€™ array of pairs. So, static, like the <a href="https://docs.rs/phf/latest/phf/"><code>phf</code> crate</a>, but without all the complexity of <code>phf</code>.</li>
  <li>Okay, actually, that wasnâ€™t the last thing. Thereâ€™s something else: programming is cool and fun! I donâ€™t write a lot of code in my day-to-day life, and it was really nice to spend a whole week doing almost nothing but that. <code>tokei</code> says I wrote 1262 lines of Rust this week (a huge fraction of which is tests), not counting my initial attempt at a parser, which was a non-working mess and got thrown away. It was extremely satisfying to make something come to life completely from scratch.</li>
  <li>Also: my laptop is getting a bit long in the tooth, and I grow weary of macOS. I had been thinking about getting one of those pretty purple Framework laptops, putting Arch or something on it, and using that for the course this week. I was stoked! And then the Framework fiasco happened, I no longer wanted to give them business, and I was bummed about my personal computing situation and by extension, less excited about the course. But it ended up being fine! The Rust tooling all worked great! â¤ï¸</li>
</ul>

<h2 id="some-final-thoughts">Some final thoughts</h2>

<p>Iâ€™m very happy to have now had the experience of (a) finally having written a lexer and parser from scratch, and (b) having done it in Rust specifically.  But I agree with <a href="https://mastodon.social/@shriramk/115549647125405815">Shriram</a> that this wouldnâ€™t have been a good way to learn about â€œthe essence of interpretationâ€! Fortunately, learning about â€œthe essence of interpretationâ€ wasnâ€™t my goal â€“ I already feel <a href="https://events.iu.edu/event/2081205-interpreters-everywhere">pretty comfortable</a> with that topic.</p>

<p>Slava Pestov <a href="https://mathstodon.xyz/@slava/115550903290567943">asked</a> what language implementation book I <em>do</em> like, if not the Nystrom book.  I donâ€™t really know if I have a favorite â€“ I learned about language implementation first by taking classes from Dan Friedman and Kent Dybvig at Indiana University (and those courses didnâ€™t use books), and then by working on the Rust compiler as an intern. I donâ€™t use a book in the PL course I teach now, either. That said, Jeremy Siekâ€™s compilers book (in <a href="https://mitpress.mit.edu/9780262047760/essentials-of-compilation/">Racket</a> and <a href="https://mitpress.mit.edu/9780262048248/essentials-of-compilation/">Python</a>) attempts to distill the Indiana approach â€“ which was <a href="https://blog.sigplan.org/2019/07/09/my-first-fifteen-compilers/">particularly formative for me</a> â€“ into a book. So maybe <em>that</em> book is my favorite. (In fact, the Racket edition is the only book that Iâ€™ve ever written a back-cover blurb for.)</p>



        
      </section>

      

      

      
  


    </div></div>
  </body>
</html>
