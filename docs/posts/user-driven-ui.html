<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://garden.bradwoods.io/notes/design/user-driven-ui">Original</a>
    <h1>User Driven UI</h1>
    
    <div id="readability-page-1" class="page"><article><div><section><div><p><img alt="A sketch of a vintage cockpit" fetchpriority="high" width="340" height="340" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2FuserDrivenUI.webp&amp;w=384&amp;q=75 1x, /_next/image?url=%2Fimages%2FuserDrivenUI.webp&amp;w=750&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2Fimages%2FuserDrivenUI.webp&amp;w=750&amp;q=75"/></p><div><p>Planted<!-- -->: <time datetime="2023-05-18T00:00:00.000Z">May 2023</time></p><p>Status: <a href="https://garden.bradwoods.io/about#aboutthisgarden"><span>seed</span></a></p></div><p>We use software to solve a problem.
When someone chooses a new software product.
Instead of solving their problem, we give them another.
To learn the UI (User Interface).
If the software is at a certain level of complexity, new users will only learn parts of it or not use it at all.</p></div></section>
<section><div><p>People learn best when in the Zone of Proximal Development (ZPD).
<strong>It is the space between what a student can do without help and what they can&#39;t do, even with help.</strong>
Below is a list of math tasks.
Ranked from easy to hard.</p><div><p><img alt="A list of math tasks ranked from easy to hard" loading="lazy" width="442" height="510" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/zoneOfProximalDevelopment1.svg"/></p></div><p>If a teacher took on a new student, they would first assess them.
To find the hardest task the student could do without help.
Imagine it was <em>Student can combine 2 groups of marbles..</em>.
The teacher would then create lessons based on the task above it.
<em>Student can solve a 2 digit addition problem..</em>.
Because it is in the ZPD.
The area one above what the student can do without help.
Teaching something above the ZPD will result in the student becoming intimidated and overwhelmed.
Teaching below means teaching content already learnt.</p><div><p><img alt="A list of math tasks ranked from easy to hard" loading="lazy" width="442" height="510" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/zoneOfProximalDevelopment2.svg"/></p></div></div></section>
<section><div><p>When a software product is first released, it is an MVP (Minimal Viable Product).
It has the least amount of features required to deliver value.
The less features, the simpler the UI, the easier to learn.
Over time, features get added.
The software becomes more powerful.
More complex.
Harder to learn.
Consider three different users.</p><div><p><img alt="A sketch of a vintage cockpit" loading="lazy" width="320" height="238" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2FcockpitVintage.webp&amp;w=384&amp;q=75 1x, /_next/image?url=%2Fimages%2FcockpitVintage.webp&amp;w=640&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2Fimages%2FcockpitVintage.webp&amp;w=640&amp;q=75"/></p><p>One begins using the software when first released.
With a minimal UI, it&#39;s easy to learn and quick to master.
When the creators release a new feature, it is little effort to learn that too.
As the user has a solid foundation to build on top of &amp; it is a small amount to learn.
Considering creators release new features one at a time or in small groups, rather than several at once.
This user is a power user.
They get a feeling of joy and confidence when using the software.
They get max value from the product.
They are always in the ZPD.</p></div><div><p><img alt="A sketch of a modern cockpit" loading="lazy" width="300" height="249" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2FcockpitModern.webp&amp;w=384&amp;q=75 1x, /_next/image?url=%2Fimages%2FcockpitModern.webp&amp;w=640&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2Fimages%2FcockpitModern.webp&amp;w=640&amp;q=75"/></p><p>Another user begins using the software three years after release.
The UI presented to them is the MVP and three years worth of added features.
The complexity intimidates and overwhelms them.
They don&#39;t have time to learn everything.
Resulting in learning the least amount to solve their immediate problem.
When the creators release a new feature, the overwhelming feeling grows.
They don&#39;t understand all existing features let alone this new one.
They get limited value from the software.
Sticking to the parts they know.
They are always above the ZPD.</p></div><p>The third user adopts the software five years after release.
They take one look at the UI and abandon it.
Looking for a simpler solution.</p><figure><p>”</p><blockquote>
1. Simple product is released
2. Lots of people use it every day
3. More features are added
4. It&#39;s now complicated
5. But most people learned the basics when it was simple, so they don&#39;t notice that it got complicated
<!-- -->”</blockquote><figcaption><a rel="noopener noreferrer" target="_blank" href="https://twitter.com/hobdaydesign/status/1655680006901624839"><span>- </span><span>Anthony Hobday</span></a></figcaption></figure></div></section>
<section><div><p>Solutions to teaching UIs include <em>onboarding walkthrough</em>.
A tour of the core features.
Pop-ups highlighting parts of the UI with snippets of text and / or video.
Its flaw is not providing a chance for the user to practice what they learnt before moving to the next feature.
<strong>After explaining a feature, the user needs to use that knowledge to consolidate it.</strong></p><div><p><img alt="Adobe Photoshop and Photoshop Elements product icons" loading="lazy" width="119" height="54" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/photoshopElements.svg"/></p><p><em>Progressive disclosure.</em>
Only revealing parts of a UI when required.
For example, the modal that appears when you click <em>save as</em>.
Revealing parts of a UI based on what the user is doing is effective at moving the user closer to the ZPD.
<em>Workspaces</em> do a similar thing.
The user selects what task they are doing.
The UI then changes to only show a subset of features related to that task.
An extreme approach to a reduced UI is creating a product that is a simpler version of a more complex one.
For example, Photoshop and Photoshop Elements.</p></div><div><p>A <a rel="noopener noreferrer" target="_blank" href="https://layout.bradwoods.io/customize"><em>basic / advanced mode</em></a> allows the user to begin in a reduced UI then switch to the full UI when confident to do so.
Its flaw is <strong>instead of small, incremental jumps in complexity required for effective learning. It is one large leap.</strong></p><p><em>Help on Hover.</em>
Hovering on a feature displays a pop-up with educational content.
Efficient, intuitive and non-obtrusive.
This teaches the user how to use a feature but not what features to use to solve a given problem.
To move the user in the ZPD we also need problem based solutions.</p><p><em>Help menus</em> are a problem based solution.
Providing a way to ask the software &#34;<em>how to I ...</em>&#34;.
Their effectiveness depends on the quality of the search and documentation.
Documentation has a reputation of being poorly written, outdated and only using text and images.
Giving rise to power users creating video tutorials on YouTube and <a rel="noopener noreferrer" target="_blank" href="https://bezier.method.ac/">interactive experiences</a>.</p></div></div></section>
<section><div><div><p><img alt="Spanner" loading="lazy" width="22" height="120" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/spanner.svg"/></p><p>I always liked the idea of a simple tool.
A tool that does one thing and does it well.
We could make software like this.
Refine the MVP instead of adding to it.
This would solve our problem.
Keeping the user in the ZPD.
It would always be easy to learn, master and get max value.
The problem is, after some time, you start saying, <em>&#34;If only it could do this ...&#34;</em> or <em>&#34;I wish it could integrate with that ...&#34;</em>.
<strong>The value of simplicity decays over time.</strong>
Once you are confident with a tool, you want more from it.
To increase the max value.</p></div><p>The inverse is true for complex tools.
They are hard to learn.
It takes time to master and get max value.
But, once you do, you have a valued skill.
<strong>The value of complexity improves over time.</strong>
Often, users don&#39;t reach this point.
The way these tools are taught always places the user above the ZPD.
A place no one likes to be.
So they learn the smallest amount and stop.
Limiting the value.
Can you name a piece of software that you know inside out?</p><p>Another thing to consider with simple tools is the user, not the UX (User Experience).
Would people be better with 10 simple tools or 1 complex one?
The problem is not software complexity.
It is the software not adapting to the user&#39;s ability.
Not keeping them in the ZPD.</p></div></section>
<section><div><p>With the capabilities of natural language processors, we can create a new approach to teaching UIs.
User-driven UI.
Instead of pushing features onto the user, the user pulls them in when needed.
The software always presents a new user with the MVP.
Regardless of how many features have been added since the initial release.
For example, lets say you downloaded a new painting app.
The initial UI would be a blank canvas with a few essential features.
The square, circle and triangle tool.</p><section></section><p>There would also be a text input.
If the user couldn&#39;t do something with the UI, they would enter what they are attempting to do.
Using a natural language processor, like ChatGPT.
The software would return a list of features that could help.
Each has a button to add them to the UI.
Going back to our painting app.
Imagine you wanted to add color to a shape.
With the current UI, you can&#39;t.
Enter &#34;Color a shape&#34; into the text input, the paint bucket tool will become available to add to the UI.</p><section><header><label for="featureInput">What do you want to do?</label></header><svg></svg></section><p>The UI would grow in complexity, in pace with the user&#39;s knowledge.
Along with keeping the user in the ZPD, it also provides:</p><ul><li><span><span>▪</span> <!-- -->a non-intrusive way of <strong>providing educational content about features. When the user wants them</strong>. The results from the text input could contain links to documentation, videos, examples, ...</span></li><li><span><span>▪</span> <!-- -->an efficient and automated way to inform the user a feature they want isn&#39;t available yet,</span></li><li><span><span>▪</span> <!-- -->a non-intrusive way to collect data about what problems users are trying to solve and</span></li><li><span><span>▪</span> <!-- -->a way to know which users want to be notified about certain feature releases. Allowing you to be more accurate when using <em>new feature pop-ups.</em> Making the software less one-size-fits-all.</span></li></ul><p>Like all approaches, it has flaws.
One being, by hiding functionality, users may be unaware of features.
Leading to them not reaching max value.</p><p>For user to reach max value in complex software, they need to be in the ZPD.
This requires multiple approaches.
In the past, teaching has been considered an after-thought to making the product.
Underestimating the value of teaching.
Resulting in power user making their own educational content.
This is a mistake.
You could have the cure for cancer.
If people don&#39;t know how to use it, it might as well not exist.
<strong>Creating a tool for someone to use and ensuring they know how to use it are equally important.</strong></p></div></section>
<section></section><section><div><div><p><img alt="The Weighted Companion Cube from Aperture" loading="lazy" width="209" height="170" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2FcompanionCube.webp&amp;w=256&amp;q=75 1x, /_next/image?url=%2Fimages%2FcompanionCube.webp&amp;w=640&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2Fimages%2FcompanionCube.webp&amp;w=640&amp;q=75"/></p><ul><li><a href="https://www.patreon.com/bradwoods" rel="noopener noreferrer" target="_blank"></a></li><li><a href="https://ko-fi.com/bradwoods" rel="noopener noreferrer" target="_blank"></a></li><li><a href="https://twitter.com/bradwoodsio" rel="noopener noreferrer" target="_blank"></a></li></ul></div></div></section><section><div><div><pre><div><p><svg viewBox="0 0 24 24" width="18px" height="18px"><title>Arrow pointing down</title><path d="M12,23.36L2.94,15h5.56V1h7V15h5.56l-9.06,8.36Zm-3.94-6.36l3.94,3.64,3.94-3.64h-2.44V3h-3v14h-2.44Z" vector-effect="non-scaling-stroke"></path></svg></p><p>YOU ARE HERE</p></div><div><div><p>  │</p><p>  └── <span>User Driven UI</span></p></div></div></pre></div></div></section></div></article></div>
  </body>
</html>
