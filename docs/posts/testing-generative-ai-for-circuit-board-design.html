<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jitx.com/jitx-corporate-blog/testing-generative-ai-for-circuit-board-design">Original</a>
    <h1>Testing Generative AI for Circuit Board Design</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      <time datetime="2024-06-21 16:16:00">
        Jun 21, 2024 9:16:00 AM
      </time>
      
      
      <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p><em>TLDR: We test LLMs to figure out how helpful they are for designing a circuit board. We focus on utility of frontier models (GPT4o, Claude 3 Opus, Gemini 1.5) across a set of design tasks, to find where they are and are not useful. They look pretty good for building skills, writing code, and getting useful data out of datasheets.</em></p>
<!--more-->


<p>Can an AI-powered chatbot help with a task as precise as circuit board design? These LLMs (Large Language Models) are famous for hallucinating details, and missing a *single* important detail can sink a design. Determinism is hard but super important for electronics design! </p>

<p><span>There is a lot to know in circuit board design, and nobody has mastered every relevant domain. Asking an LLM stupid questions is a great way to learn.</span><span><em><span>What is the delay per unit length of a trace on a circuit board?</span></em></span></p>
<p><span><img src="https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=734&amp;height=1154&amp;name=Pasted%20image%2020240606134032-png.png" loading="lazy" width="734" height="1154" srcset="https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=367&amp;height=577&amp;name=Pasted%20image%2020240606134032-png.png 367w, https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=734&amp;height=1154&amp;name=Pasted%20image%2020240606134032-png.png 734w, https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=1101&amp;height=1731&amp;name=Pasted%20image%2020240606134032-png.png 1101w, https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=1468&amp;height=2308&amp;name=Pasted%20image%2020240606134032-png.png 1468w, https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=1835&amp;height=2885&amp;name=Pasted%20image%2020240606134032-png.png 1835w, https://blog.jitx.com/hs-fs/hubfs/Pasted%20image%2020240606134032-png.png?width=2202&amp;height=3462&amp;name=Pasted%20image%2020240606134032-png.png 2202w" sizes="(max-width: 734px) 100vw, 734px"/></span></p>
<p><span>Notice the gotchas here! The speed of a signal changes based on which layer of a circuit board you route it on, and what the materials are.</span></p>

<p>One of the superpowers of an experienced engineer is knowing things like: &#34;A DAC + DSP system good enough for this audio pipeline should be about this big, and cost $1.40 in production&#34;. They&#39;ll then go do some turbo googling and find it.</p>
<p>You can see a communication layer like this as the daisy-chained black cabling in this picture from <a href="http://www.hebirobotics.com" rel="noopener">HEBI</a>:</p>
<p><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=510&amp;height=467&amp;name=image-png-1.png" loading="lazy" width="510" height="467" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=255&amp;height=234&amp;name=image-png-1.png 255w, https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=510&amp;height=467&amp;name=image-png-1.png 510w, https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=765&amp;height=701&amp;name=image-png-1.png 765w, https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=1020&amp;height=934&amp;name=image-png-1.png 1020w, https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=1275&amp;height=1168&amp;name=image-png-1.png 1275w, https://blog.jitx.com/hs-fs/hubfs/image-png-1.png?width=1530&amp;height=1401&amp;name=image-png-1.png 1530w" sizes="(max-width: 510px) 100vw, 510px"/></p>
<p>Time to use AI to find the parts should I use for the ethernet switch, and the optical transceivers.</p>
<p>I want to design a daisy-chained communications layer for a motor driver, using 100M optical Ethernet. Each motor controller will have a microcontroller that interfaces to the Ethernet network over RGMII. It needs to be compact, robust to mechanical vibration and shock, and handle temperatures up to 60 degrees Celsius. Please help me choose parts for the optical connectors, transceivers, and Ethernet networking device. </p>
<p>Here I&#39;m pulling more prompt engineering tricks to boost the performance of the model, and being careful in detailed specifications to really get this to work.</p>
<p>Instead, performance across all models was uniformly bad and no amount of prompting or follow ups could fix it. It felt a lot like trying to get AI to solve a variant of the <a href="https://chatgpt.com/share/67a305cf-dc5f-45a2-a496-0886116f4659" rel="noopener">wolf, sheep, cabbage problem</a>. It&#39;s got the answer locked in, and it&#39;s hard to get out of that basin.</p>
<p><span> Example Part Selection</span></p>
<p>Grading this:</p>
<p>- All models missed that to get the daisy chain you need a three port ethernet switch. They instead recommend an Ethernet Phy, which isn&#39;t going to do it.</p>
<p>Overall the generative models don&#39;t demonstrate a solid grasp on what the motor controller communication network is, or what application-specific considerations need to be made. </p>

<p><span>Sadly, most of the data you need to design a circuit board is baked away in PDF datasheets, instead of being available via APIs. Directly trying to parse PDFs with python tends to not go well, but LLMs should be pretty good at pulling data from these human-structured documents.</span></p>
<p><span>I&#39;ll be using the data available for the <a href="https://docs.nordicsemi.com/bundle/ps_nrf5340/page/keyfeatures_html5.html" rel="noopener">Nordic nRF5340 WLCSP</a> for the experiment. A little 4.0 x 4.4 mm Bluetooth chip, with an 820 page datasheet. </span></p>
<p><span><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=350&amp;height=324&amp;name=image-png-2.png" loading="lazy" width="350" height="324" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=175&amp;height=162&amp;name=image-png-2.png 175w, https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=350&amp;height=324&amp;name=image-png-2.png 350w, https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=525&amp;height=486&amp;name=image-png-2.png 525w, https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=700&amp;height=648&amp;name=image-png-2.png 700w, https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=875&amp;height=810&amp;name=image-png-2.png 875w, https://blog.jitx.com/hs-fs/hubfs/image-png-2.png?width=1050&amp;height=972&amp;name=image-png-2.png 1050w" sizes="(max-width: 350px) 100vw, 350px"/></span></p>
<p>Observations on this part:  </p>
<ol>
<li>This is by no means the largest datasheet for a electrical component but has many typical features including pin tables, mechanical drawings, application specific notes, graphs, etc</li>
<li>This datasheet has significantly more content than you might expects for simpler components - like OpAmps or digital logic gates. If the LLMs are useful here, they will likely be useful for smaller cases.</li>
<li>This datasheet is about 570k tokens, a little more than half the huge context window available from Gemini.</li>
</ol>
<h3>Make a symbol and footprint</h3>
<p>First step is a to make a linked symbol and footprint (landpattern) for our component. </p>
<p>Please write the the pin table for the wlcsp version of the nRF5340 as code using the following format: </p>
<p>The AI then returns a block of text with our pin list in a usable format:</p>
<p><code>[ XC1 | A1 | Left | analog_input ] </code></p>
<p>It got this list exactly correct, impressive for 95 rows of data buried in an 820 page datasheet. Usually I have to get a model to write a little code to reach that level of accuracy, but that was unnecessary here.</p>
<p><code>; This test is based on the Nordic Semiconductor, nRF5340</code></p>
<p>A few more misses here than in the pin table, but close overall. I have to go in and separately prompt for the depopulated balls in the grid, as well as correct the dimensions in the PackageBody. </p>
<p><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=2682&amp;height=1404&amp;name=image-png-3.png" loading="lazy" width="2682" height="1404" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=1341&amp;height=702&amp;name=image-png-3.png 1341w, https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=2682&amp;height=1404&amp;name=image-png-3.png 2682w, https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=4023&amp;height=2106&amp;name=image-png-3.png 4023w, https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=5364&amp;height=2808&amp;name=image-png-3.png 5364w, https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=6705&amp;height=3510&amp;name=image-png-3.png 6705w, https://blog.jitx.com/hs-fs/hubfs/image-png-3.png?width=8046&amp;height=4212&amp;name=image-png-3.png 8046w" sizes="(max-width: 2682px) 100vw, 2682px"/></p>
<p>I really like the combination of code and scraped data here because of precision and flexibility. </p>
<p><code>property(P0[0].digital_io) = DigitalIO(CMOSOutput(VSS + 0.4, VDD - 0.4), 0.3*VDD, 0.7*VDD, &#34;VDD&#34;, &#34;VSS&#34;, 0)</code></p>
<p>If you don&#39;t have the AI return an answer as code, it tends to spread the data you want across multiple paragraphs, and it is easier to get the answer you want by just reading the datasheet instead.</p>
<p>It can even read a bit of the reference schematic and turn it into a netlist:</p>
<p><code><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=1104&amp;height=1426&amp;name=image-png-4.png" loading="lazy" width="1104" height="1426" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=552&amp;height=713&amp;name=image-png-4.png 552w, https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=1104&amp;height=1426&amp;name=image-png-4.png 1104w, https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=1656&amp;height=2139&amp;name=image-png-4.png 1656w, https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=2208&amp;height=2852&amp;name=image-png-4.png 2208w, https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=2760&amp;height=3565&amp;name=image-png-4.png 2760w, https://blog.jitx.com/hs-fs/hubfs/image-png-4.png?width=3312&amp;height=4278&amp;name=image-png-4.png 3312w" sizes="(max-width: 1104px) 100vw, 1104px"/></code></p>
<p><code>* Power Supply Nets:</code></p>
<p>It hallucinated this task a little bit, inventing resistors here and there. </p>

<p><span>We&#39;ve seen that LLMs can understand an image of a schematic well enough to (mostly) turn it into a netlist. Can they take on a much more challenging task and design the circuit itself?</span></p>
<p><span>I want to design a microphone pre-amp where I need to bias the electret microphone and create a single-ended signal out to drive the ADC of a microcontroller. Include a bandpass filter with a gain of 20dB, corner frequencies at 100Hz and 20kHz. Help me select an architecture for this amplifier. Propose different filter architectures and describe their pros and cons for this application. </span></p>
<p><span>Claude 3 Opus came back with the best answer of the three contenders. I&#39;ll analyze it piece by piece.</span></p>
<p><span>Okay, let&#39;s think through this step-by-step as an expert electrical engineer:</span></p>
<p>Claude did a good job calling out the need to bias the microphone, nice to have that called out explicitly.</p>
<p><span>3. Bandpass filter: We need a 100Hz to 20kHz passband with 20dB gain. Some filter options: </span></p>
<p><span>The comments on the Passive RC filter are reasonable. </span></p>
<p><span>Moving on:</span></p>
<p><span>For this application, an active 2nd-order filter like a DABP seems a good balance of simplicity, stability, and easy gain integration.  </span></p>
<p><span>Here, Claude chooses the DABP and estimates some reasonablish values given that choice. (Usually you would choose values greater than 10k and less than 1M in op amp circuit design, to make assumptions about input and output impedance hold better). The wording is a bit confusing but it could be interpreted as a non-inverting op-amp for the gain stage, followed by a DABP filter with a lower gain. Which can work! Technically!</span></p>
<p><span><code>Great! Let&#39;s dive into the calculations and generate the netlists. We&#39;ll assume a 3.3V power supply and a microphone bias of 2.5V. We&#39;ll use an ideal op-amp model for simplicity.</code></span><span><code>; close to 2.5V.</code></span></p>
<p><span>The decoupling cap in the bias circuit here really hampers the high-frequency performance of the circuit. What the circuit actually needs is a <em>coupling cap</em>, shown in the <code>human.mic</code> circuit here:</span></p>
<p><span><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=1205&amp;height=480&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png" loading="lazy" width="1205" height="480" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=603&amp;height=240&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png 603w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=1205&amp;height=480&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png 1205w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=1808&amp;height=720&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png 1808w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=2410&amp;height=960&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png 2410w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=3013&amp;height=1200&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png 3013w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-34-17-2563-PM.png?width=3615&amp;height=1440&amp;name=image-png-Jun-21-2024-03-34-17-2563-PM.png 3615w" sizes="(max-width: 1205px) 100vw, 1205px"/></span></p>
<p><span>Presumably in the training corpus, many articles and datasheets write extensively about decoupling caps. Maybe the &#34;average&#34; recommendation wins out here, and once it sees a positive and negative pin it slaps a capacitor across them right away. In our tests (and most product demos), LLMs <em>loved</em> to give naive advice about decoupling, which usually isn&#39;t as actively harmful as it is here.<br/></span></p>
<p><span>Moving on to the amplifier:</span></p>
<p><code>; Non-Inverting Amplifier:</code></p>
<p>The AI describes the amplifier as non-inverting, but then feeds the signal into the inverting input. It&#39;s also missing a few other parts and nets that would make for a working circuit. Easier to see in the generated schematic:</p>
<p><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=561&amp;height=349&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png" loading="lazy" width="561" height="349" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=281&amp;height=175&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png 281w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=561&amp;height=349&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png 561w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=842&amp;height=524&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png 842w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=1122&amp;height=698&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png 1122w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=1403&amp;height=873&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png 1403w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-38-28-2912-PM.png?width=1683&amp;height=1047&amp;name=image-png-Jun-21-2024-03-38-28-2912-PM.png 1683w" sizes="(max-width: 561px) 100vw, 561px"/>(Cue EE eye twitching)</p>
<p>Moving on to the DABP filter implementation:</p>
<p><code>; DABP Bandpass Filter:</code></p>
<p><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=934&amp;height=425&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png" loading="lazy" width="934" height="425" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=467&amp;height=213&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png 467w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=934&amp;height=425&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png 934w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=1401&amp;height=638&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png 1401w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=1868&amp;height=850&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png 1868w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=2335&amp;height=1063&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png 2335w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-41-30-4263-PM.png?width=2802&amp;height=1275&amp;name=image-png-Jun-21-2024-03-41-30-4263-PM.png 2802w" sizes="(max-width: 934px) 100vw, 934px"/>Generated circuit (left), versus reference from ADI (right).</p>
<p>A few more misses on the netlist here, and about as correct as the amplifier (which is to say, not very). We also see the weirdly strong default of attaching capacitors across positive and negative pins. I guess LLMs are high decouplers.</p>
<p>And to round it off, we&#39;ve got another reminder to add decoupling caps, and a reasonable note about what to watch out for:</p>
<p><span>The output of op2 is the final output of the pre-amp circuit. This should give you a good starting point. Remember to add decoupling capacitors and power supply connections as needed. Also, the actual component values may need to be adjusted based on the real specs of your chosen op-amp and the exact requirements of your ADC. Let me know if you have any other questions!</span></p>
<h3><span>Comparing against ground truth</span></h3>
<p><span>This <a href="https://www.ti.com/lit/ug/tidu765/tidu765.pdf" rel="noopener">reference design</a> from Texas Instruments is a good implementation of the requirements we asked these LLMs to design to. It uses passive RC filters (which the AI considered and avoided), and a single op-amp. I did a quick implementation of this in JITX (<a href="https://github.com/JITx-Inc/generative-ai-test-cases/blob/main/amplifier/reference.stanza" rel="noopener">code here</a>) to compare the AI generated circuit (<a href="https://github.com/JITx-Inc/generative-ai-test-cases/blob/main/amplifier/ai-generated.stanza" rel="noopener">code here</a>) to the TI version.</span></p>
<p><span><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=849&amp;height=547&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png" loading="lazy" width="849" height="547" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=425&amp;height=274&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png 425w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=849&amp;height=547&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png 849w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=1274&amp;height=821&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png 1274w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=1698&amp;height=1094&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png 1698w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=2123&amp;height=1368&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png 2123w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-49-51-0951-PM.png?width=2547&amp;height=1641&amp;name=image-png-Jun-21-2024-03-49-51-0951-PM.png 2547w" sizes="(max-width: 849px) 100vw, 849px"/></span></p>
<p><span>The AI generated circuit was three times the cost and size of the design created by that expert engineer at TI. It is also missing many of the necessary connections. </span></p>
<h3><span>Testing higher level code</span></h3>
<p><span>In fairness, it&#39;s rare to write code like this to design a circuit board. In practice you&#39;re primarily calling higher level functions, e.g. selecting an op-amp, configuring a filter with parameters, then using a parametric pre-amp circuit:</span></p>
<p><code>  val OpAmpType = components/STMicroelectronics/TS971ILT/component</code></p>
<p>Would LLMs do better if we try to get them to define and use higher-level functions instead?</p>
<p><code># Modules</code></p>
<p>(Still misses on the netlist generation though.)</p>
<p>Our experiments with code generation reveal an interesting pattern: the LLMs are not great at generating detailed code for a netlist <em>to implement a circuit design</em>. That was a little surprising because as shown in the datasheet parsing section, they can write a 95% correct netlist matching an uploaded image of a schematic. This difference suggests that LLMs excel at information extraction and transformation tasks, but struggle with original design synthesis.</p>
<p>Future research could either explore fine-tuning models specifically for netlist generation tasks, or (this being generative AI) wait a month and see how well the next generation of models does on this problem.</p>

<p><span>Circuit board design requires a lot of precision to get all the details correct -- for unsupervised AI techniques, I think there is a data problem here. </span></p>
<p><span><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=933&amp;height=601&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png" loading="lazy" width="933" height="601" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=467&amp;height=301&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png 467w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=933&amp;height=601&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png 933w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=1400&amp;height=902&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png 1400w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=1866&amp;height=1202&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png 1866w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=2333&amp;height=1503&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png 2333w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-03-59-44-3288-PM.png?width=2799&amp;height=1803&amp;name=image-png-Jun-21-2024-03-59-44-3288-PM.png 2799w" sizes="(max-width: 933px) 100vw, 933px"/>From the <a href="https://storage.googleapis.com/deepmind-media/gemini/gemini_v1_5_report.pdf" rel="noopener">Gemini 1.5 Report</a></span></p>
<p><span>Surprisingly GPT-4o didn&#39;t have the most useful answer in any of the categories we tested. It feels wrong to not include any outputs from the model in this summary article, so here&#39;s how GPT-4o feels about coming in third:</span></p>
<p><span><img src="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=345&amp;height=342&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png" loading="lazy" width="345" height="342" srcset="https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=173&amp;height=171&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png 173w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=345&amp;height=342&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png 345w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=518&amp;height=513&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png 518w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=690&amp;height=684&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png 690w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=863&amp;height=855&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png 863w, https://blog.jitx.com/hs-fs/hubfs/image-png-Jun-21-2024-04-01-30-3403-PM.png?width=1035&amp;height=1026&amp;name=image-png-Jun-21-2024-04-01-30-3403-PM.png 1035w" sizes="(max-width: 345px) 100vw, 345px"/><br/></span></p>
<p><span>Overall we have some promising directions. Using LLMs for circuit board design looks a lot like using them for other complex tasks. They work well for pulling concrete data out of human-shaped data sources, they can do slightly more difficult tasks if they can solve that task by writing code, but eventually their capabilities break down in domains too far out of the training distribution.</span></p>
<p><span>Let me know what you think! You can find me on the JITX discord, and on <a href="https://x.com/DuncanHaldane" rel="noopener">Twitter</a>.</span></p></span>
      </p>
      
        
      
    </article>
  </div></div>
  </body>
</html>
