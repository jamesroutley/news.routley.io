<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://typon.github.io/wordle.html">Original</a>
    <h1>Solving Wordle with Z3</h1>
    
    <div id="readability-page-1" class="page"><p>
                    I&#39;ve been enjoying this viral new word game eponymously named <a href="https://www.powerlanguage.co.uk/wordle/">Wordle</a>. The aim of the game is to guess the day&#39;s word in six or less tries.

                    I&#39;ll go through an example game to give an idea of the rules.
                    </p><div>
                        <li>the hidden word was
                            <span>G</span>
                            <span>O</span>
                            <span>R</span>
                            <span>G</span>
                            <span>E</span>, guessed correctly on the fifth try.
                        </li>
                        <li>the first guess was
                            <span>R</span>
                            <span>E</span>
                            <span>N</span>
                            <span>T</span>
                            <span>S</span>, which was incorrect. However it gave us clues:
                                <span>R</span> is found withing in the correct word, but not at this location (same with <span>E</span>) and <span>N</span>, <span>T</span>, <span>S</span> are not found in the correct word.
                        </li>
                        <li>the second guess confirms that <span>O</span> appears in the correct word and at the same location we guessed.
                        </li>
                        <li>Note that letters are allowed to appear more than once in the correct word - however if a letter appears only once, but our guess contains that letter multiple times, all except one instance will be marked gray.
                        </li>

                    
                    <p>
                        Armed with these rules and an English dictionary, we can encode these rules as constraint satisfaction program and try to solve it using an SMT solver.
                        My go to SMT solver is <a href="https://github.com/Z3Prover/z3">Z3</a> because it is simple to install, has well-made python bindings and an easy to use API.
                    </p>
                    <p>
                        With pip, cmake and a C++ compiler as prerequisites, you can simply install z3 with the following command:
                        </p><pre><code>$ pip install z3-solver</code></pre>
                    

                    <p>
                        My goal is to model this problem with variables and constraints that are easy to understand - hopefully helpful for people who are new to SMT solvers.

                        Let&#39;s first start by instantiating the z3 solver class and constructing our variables:
</p><pre><code>import z3

word_length = 5

def define_letter_variables():
    return [z3.Int(f&#34;letter_{index}&#34;) for index in range(word_length)]

if __name__ == &#34;__main__&#34;:
    solver = z3.Solver()
    letter_vars = define_letter_variables()
</code></pre>

We are going to model each letter of our guess as a separate <code>z3.Int</code>. z3 can represent arbitrarily large integers - but we only need to model each variable as a letter - ranging from 0 - 25 for the English alphabet. To model our variables in that legal range, let&#39;s add some constraints:

<pre><code>def add_alphabet_modeling_constraints(solver, letter_vars):
    for letter_var in letter_vars:
        solver.add(letter_var &gt;= 0, letter_var &lt;= 25)

    return solver
</code></pre>

Just to sanity check our work so far, let&#39;s run the solver and see what it gives us:

<pre><code>letter_to_index_map = {letter: index for index, letter in enumerate(&#34;abcdefghijklmnopqrstuvwxyz&#34;)}
index_to_letter_map = {index: letter for letter, index in letter_to_index_map.items()}

def pretty_print_solution(model, letter_vars):
    word = []
    for index, letter_var in enumerate(letter_vars):
        word.append(index_to_letter_map[model[letter_var].as_long()])

    print(&#39;&#39;.join(word))

if __name__ == &#34;__main__&#34;:
    solver = z3.Solver()
    letter_vars = define_letter_variables()
    solver = add_alphabet_modeling_constraints(solver, letter_vars)

    print(&#34;Solving...&#34;)
    result = solver.check()
    print(result)
    assert result == z3.sat

    model = solver.model()
    pretty_print_solution(model, letter_vars)
</code></pre>

<pre><code>$ python wordle.py
Solving...
sat
aaaaa
</code></pre>
A pretty boring result. The solver decided to set each of our letter variables to 0, resulting in the final word guess of <code>aaaaa</code>.
                    
                    <p>
We&#39;ll need to teach the solver about English if we want it to pick words that actually make sense. We can use the dictionary that UNIX-like OS&#39;s come with:

</p><pre><code>
def remove_plurals(words):
    five_letter_words = list(filter(lambda word: len(word) == 5, words))
    four_letter_words = set(filter(lambda word: len(word) == 4, words))
    all_five_letter_words_ending_in_s = set(filter(lambda word: word[4] == &#34;s&#34;, five_letter_words))
    singular_five_letter_words = list(filter(lambda word: not (word in all_five_letter_words_ending_in_s and word[:4] in four_letter_words), five_letter_words))
    return singular_five_letter_words

def remove_words_with_invalid_chars(words):
    valid_chars_set = set(letter_to_index_map.keys())

    def contains_only_valid_chars(word):
        return set(word).issubset(valid_chars_set)

    return filter(contains_only_valid_chars, words)

def load_dictionary(dictionary_path=None):
    with open(dictionary_path, &#34;r&#34;) as f:
        all_legal_words = set(word.strip() for word in f.readlines())

    words = remove_words_with_invalid_chars(all_legal_words)
    words = list(words)
    words = remove_plurals(words)
    return words


if __name__ == &#34;__main__&#34;:
    ...
    words = load_dictionary(dictionary_path=&#34;/usr/share/dict/words&#34;)
</code></pre>

Now that we have loaded the dictionary, cleaned up invalid characters and removed plurals (I&#39;ve found that Wordle only uses singular words for answer words, if you found otherwise let me know!), we can add
constraints to force the solver to pick only legal words.

<pre><code>def add_legal_words_constraints(solver, words, letter_vars):
    all_words_disjunction = []

    for word in words:
        word_conjuction = z3.And([letter_vars[index] == letter_to_index_map[letter] for index, letter in enumerate(word)])
        all_words_disjunction.append(word_conjuction)

    solver.add(z3.Or(all_words_disjunction))

    return solver

if __name__ == &#34;__main__&#34;:
    ...
    solver = add_legal_words_constraints(solver, words, letter_vars)
</code></pre>

The <code>add_legal_words_constraints</code> function seems innocuous, but it adds a whole bunch of constraints and makes up the meat of the solver. Read in boolean logic, you can think of the solver now having the following constraints, given our dictionary only consisted of two words: &#34;hello&#34; and &#34;world&#34;.

<pre><code>
(letter_0 == &#34;h&#34; and letter_1 == &#34;e&#34; and letter_2 == &#34;l&#34; and letter_3 == &#34;l&#34; and letter_4 == &#34;o&#34;) or
(letter_0 == &#34;w&#34; and letter_1 == &#34;o&#34; and letter_2 == &#34;r&#34; and letter_3 == &#34;l&#34; and letter_4 == &#34;d&#34;)
</code></pre>

Now we are ready to run the solver and get valid guesses only! Let&#39;s give it a try:
<pre><code>$ python wordle.py
Solving...
sat
badge
</code></pre>

Awesome! We get <code>badge</code> as our guess. We can input that into Wordle and see what we get.

For the Wordle on January 10th, 2022, I get the following result:
<img src="https://typon.github.io/first_guess.png" alt="Badge"/>

A relatively bad hit - we got 4 letters wrong and only one right, but in the wrong position.

Let&#39;s add constraints to the solver to prevent it from picking these letters again and tell it that it should definitely consider <span>E</span> in it&#39;s future guesses.

<pre><code>def add_doesnt_contain_letter_constraint(solver, letter_vars, letter):
    for letter_var in letter_vars:
        solver.add(letter_var != letter_to_index_map[letter])

    return solver

def add_contains_letter_constraint(solver, letter_vars, letter):
    solver.add(z3.Or([letter_var == letter_to_index_map[letter] for letter_var in letter_vars]))

    return solver

def add_invalid_position_constraint(solver, letter_vars, letter, position):
    solver.add(letter_vars[position] != letter_to_index_map[letter])

    return solver

if __name__ == &#34;__main__&#34;:
    ...
    for banned_letter in &#34;badg&#34;:
        solver = add_doesnt_contain_letter_constraint(solver, letter_vars, banned_letter)

    solver = add_contains_letter_constraint(solver, letter_vars, &#34;e&#34;)
    solver = add_invalid_position_constraint(solver, letter_vars, &#34;e&#34;, 4)
</code></pre>

We prevent
<span>B</span>
<span>A</span>
<span>D</span>
<span>G</span> from appearing in any position and tell the solver that while <span>E</span> must appear in one of the positions, it can&#39;t appear in the fifth position.

Let&#39;s run the solver again:

<pre><code>$ python wordle.py
Solving...
sat
every
</code></pre>

Okay, great. It kept the <span>E</span>, but not at the fifth position and didn&#39;t guess either of
<span>B</span>
<span>A</span>
<span>D</span>
<span>G</span>.

Let&#39;s input that guess and see what we get.

<img src="https://typon.github.io/second_guess.png" alt="Tuner"/>
                    
                    <p>
Wonderful, we got an exact match for
<span>E</span>
<span>R</span>
<span>Y</span>. Note that the <span>E</span> in the first position is grayed out - this means that it should appear only once in this word. Let&#39;s add a constraint for that as well as adding more banning constraints.

</p><pre><code>def add_exact_letter_position_constraint(solver, letter_vars, letter, position):
    solver.add(letter_vars[position] == letter_to_index_map[letter])

    return solver

def add_letter_appears_once_constraint(solver, letter_vars, letter):
    unique_letter_disjunction = []

    for letter_var in letter_vars:
        this_letter_conjunction = [letter_var == letter_to_index_map[letter]]
        for other_letter_var in letter_vars:
            if letter_var == other_letter_var:
                continue
            this_letter_conjunction.append(other_letter_var != letter_to_index_map[letter])
        unique_letter_disjunction.append(z3.And(this_letter_conjunction))

    solver.add(z3.Or(unique_letter_disjunction))

    return solver

if __name__ == &#34;__main__&#34;:
    ...
    for banned_letter in &#34;badgv&#34;:
        solver = add_doesnt_contain_letter_constraint(solver, letter_vars, banned_letter)

    solver = add_letter_appears_once_constraint(solver, letter_vars, &#34;e&#34;)

    solver = add_exact_letter_position_constraint(solver, letter_vars, &#34;e&#34;, 2)
    solver = add_exact_letter_position_constraint(solver, letter_vars, &#34;r&#34;, 3)
    solver = add_exact_letter_position_constraint(solver, letter_vars, &#34;y&#34;, 4)
</code></pre>

With these new constraints, running the solver produces the guess:

<pre><code>$ python wordle.py
Solving...
sat
fiery
</code></pre>

<img src="https://typon.github.io/third_guess.png" alt="Tuner"/>
                    
                    <p>
A complete miss :(. Let&#39;s prevent the solver from guessing both these letters:

</p><pre><code>if __name__ == &#34;__main__&#34;:
    ...
    for banned_letter in &#34;badgvfi&#34;:
        solver = add_doesnt_contain_letter_constraint(solver, letter_vars, banned_letter)
    ...
</code></pre>

<pre><code>$ python wordle.py
Solving...
sat
query
</code></pre>

<img src="https://typon.github.io/fourth_guess.png" alt="Tuner"/>
                    
                    <p>
Yay! The solver guessed the correct word:
<span>Q</span>
<span>U</span>
<span>E</span>
<span>R</span>
<span>Y</span>
                    </p>
                    <p>

While the modeling we have so far works pretty well, we can further improve it by taking into account letter frequencies (how often a letter appears across words) and word frequencies (how often a word appears in a large corpus). In my testing I also found that the solver tended to guess words that I wouldn&#39;t really go for because they&#39;re words that, while legal, are obscure and never really used in common English. Wordle tends to use words that are not very obscure, but also not very common.

We can use z3&#39;s optimization features to encode a cost function - valuing guesses that contain more frequent letters early on and more obscure words later as we have more information about the word&#39;s makeup.

                    </p>
                    <p>
Here&#39;s a snippet of such a model:
                    </p>

<pre><code>def optimize_search(solver, word_to_freq, letter_vars):

    def maximize_letter_frequency():
        normalized_letter_frequency_map = make_normalized_letter_frequency_map(letter_frequency_map)

        for freq_var, letter_var in zip(letter_frequency_vars, letter_vars):
            for letter_index, letter in index_to_letter_map.items():
                solver.add(z3.Implies(letter_var == letter_index, freq_var == normalized_letter_frequency_map[letter]))

    def maximize_word_frequency():
        normalized_word_frequency_map = make_normalized_word_frequency_map(word_to_freq)

        for word, freq in normalized_word_frequency_map.items():
            word_conjuction = z3.And([letter_vars[index] == letter_to_index_map[letter] for index, letter in enumerate(word)])
            solver.add(z3.Implies(word_conjuction, word_frequency == freq))


    letter_frequency_vars = [z3.Real(f&#34;letter_{index}_frequency&#34;) for index in range(len(letter_vars))]
    letter_frequency_sum = z3.Real(f&#34;letter_frequency_sum&#34;)

    word_frequency = z3.Real(f&#34;word_frequency&#34;)

    # Each letter frequency can be [0, 1.0], we divide the sum by num of letters to get a normalized sum
    solver.add(letter_frequency_sum == (z3.Sum(letter_frequency_vars) / len(letter_vars)))

    maximize_letter_frequency()
    maximize_word_frequency()

    # We weight common words a bit higher than common letters
    # otherwise the solver goes for words like &#34;eerie&#34; and similar weirdness
    solver.maximize((0.7*word_frequency) + (0.3*letter_frequency_sum))

    return solver
</code></pre>

                    <p>

I highly recommend that you give modeling a problem with Z3 (or any SMT solver) a try - it&#39;s rewarding and allows you to express algorithms declaratively that otherwise become unmaintainable messes.
                    </p>



                </div></div>
  </body>
</html>
