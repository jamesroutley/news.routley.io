<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://potetm.com/devtalk/bifurcate-the-problem.html">Original</a>
    <h1>Bifurcate the Problem Space</h1>
    
    <div id="readability-page-1" class="page"><div><section><time datetime="2023-02-18">2023-02-18</time> <p>I recently read Hillel Wayne&#39;s <a href="https://buttondown.email/hillelwayne/archive/improve-your-debugging-by-asking-broad-questions/">newsletter issue on debugging</a>. In it, Hillel&#39;s advises the reader to &#34;ask broad questions&#34; in order to improve your debugging skills. As I was reading, it occurred to me that this was a technique I&#39;d seen advocated before in Stuart Halloway&#39;s <a href="https://youtu.be/FihU5JxmnBg?t=1545"><em>Debugging with the Scientific Method</em></a>. Halloway calls it &#34;carving the world in half&#34; or &#34;proportional reduction.&#34; I watched his talk when it was released in 2015 and somehow internalized the phrase, <em><abbr title="to divide into two branches or parts">bifurcate</abbr> the problem space</em>.<a href="#footnote-1" id="return-1"><sup>†</sup></a></p> <p>Bifurcating the problem space means running a test which will rule in or rule out a <em>large number</em> of possible root causes. When playing 20 questions, instead of immediately guessing &#34;Kevin Bacon,&#34; you start by asking, &#34;Is it a man or a woman?&#34; Doing so cuts down on half of all possible answers. Likewise, when solving a problem, you want to run tests that cut down a large number of possible root causes.</p> <p>Reading Wayne&#39;s newsletter reminded me that this technique is both unreasonably effective and yet, somehow, not terribly widespread. It is, admittedly, counterintuitive. Instead of asking the natural question, &#34;What is the answer?&#34; this approach pushes you to ask some version of, &#34;What might <em>not</em> be the answer?&#34;</p> <p>That said, the cost-to-benefit ratio for adopting this strategy is outrageously good compared to many strategies which, for whatever reason, did manage to catch on. Asking broad questions usually costs some number of minutes, and the benefit is you solve your problem in minutes or hours instead of weeks or never.</p> <p>As I was reading Wayne&#39;s post, I began to think that others might find it helpful to see an example of how to use this approach in real life. I can think of a few such examples, but one incident in particular stands out in my memory.</p> <h2>The Case of the Missing Jobs</h2> <p>Some time ago, I was working at a company that had the following backend architecture:</p> <ol> <li>A Web Server receives a request</li> <li>The Web Server calls to a Job Runner to start a job</li> <li>The Web Server stores the Job Runner ID to the Database</li> <li>The Job Runner finishes and calls to the Web Server to indicate the job is done</li> <li>The Web Server stores the completed job details to the database</li> </ol> <pre><code>+------------+               +------------+
|            |               |            |
| Job Runner | &lt;------------ | Web Server | &lt;----- [Client Request]
|     A      |               |            |
+------------+               +------------+
                                   |
                             [Running on A]
                                   |
                                   v
                               +-------+
                               |  DB   |
                               +-------+

later....
+------------+               +------------+
|            |               |            |
| Job Runner | ------------&gt; | Web Server |
|     A      |               |            |
+------------+               +------------+
                                   |
                               [Job Done]
                                   |
                                   v
                               +-------+
                               |  DB   |
                               +-------+
</code></pre> <p>Of course, as is the case with all architecture diagrams, the above picture is <em>massively</em> simplified. In reality, there were multiple web servers sitting behind load-balancing proxies, multiple databases of varying types, many hundreds of job runners spread across multiple datacenters (also sitting behind load-balancing proxies), and a few queues tossed in for good measure.</p> <p>As one might guess, occasionally Job Runner A would reject a job. When that happened, the job was supposed to be sent to another job runner, Job Runner B.</p> <pre><code>+------------+               +------------+
| ¡¡OUTAGE!! |               |            |
| Job Runner | &lt;------------ | Web Server | &lt;----- [Client Request]
|     A      | ---[Error]--&gt; |            |
+------------+               |            |
                     +------ |            |
                     |       +------------+
+------------+       |             |
|            |       |       [Running on B]
| Job Runner | &lt;-----+             |
|     B      |                     v
+------------+                 +-------+
                               |  DB   |
                               +-------+
</code></pre> <p>One day we deployed a new version of the Job Runner. In that deploy, there was a misconfiguration of Job Runner A which caused <em>every</em> job to be rejected. However, instead of falling back to Job Runner B as it was supposed to, the Web Server reported in the database that Job Runner A accepted the job.</p> <pre><code>+------------+               +------------+
| ¡¡OUTAGE!! |               |            |
| Job Runner | &lt;------------ | Web Server | &lt;----- [Client Request]
|     A      | ---[?????]--&gt; |            |
+------------+               |            |
                             +------------+
+------------+                     |
|            |               [Running on A]
| Job Runner |                     |
|     B      |                     v
+------------+                 +-------+
                               |  DB   |
                               +-------+
</code></pre> <p>This was not good. The end result was that jobs would appear to clients as if they were running forever.</p> <h2>Part One: The System Architecture</h2> <p>So the problem could be in a couple of places:</p> <ol> <li>The Web Server logic</li> <li>The Job Runner return value</li> </ol> <p>Now the question is: <em>What do you do?</em></p> <p>You could assume the problem is in the Web Server and start debugging the Web Server code. Alternatively, you could assume the problem was in the Job Runner and start debugging that code.</p> <p>However, if you were trying to bifurcate the problem space, you would look for a way to disqualify either the Web Server or the Job Runner. Doing so isolates the problem to one codebase or the other.</p> <p>In our case, we decided to test the Job Runner by removing the Web Server as a variable. We replicated the <em>exact</em> calls made to the Job Runner from the command line. If we could get the Job Runner to erroneously return &#34;Success&#34; instead of &#34;Error,&#34; we would know the problem is in the Job Runner. Otherwise, we have very strong evidence (but not proof) that the problem is in the Web Server.</p> <p>After half a dozen tries, we were unable to get the Job Runner to give us an incorrect &#34;Success&#34; status. Awesome! The problem is likely in the Web Server. We just bifurcated a problem space that included two machines to a problem space that only includes one!</p> <h2>Part Two: The Code Architecture</h2> <p>Assuming we didn&#39;t completely flub the DB write (possible, but unlikely), the problem was somewhere in the code path that handles job submission. Unsurprisingly, there were multiple layers of code where the error could be occurring. A simplified version of the code looks something like:</p> <pre><code>function callJobRunner(runner, request) {
  // prep the request
  return http.request(runner, request);
}


function withCircuitBreaker(circuitBreaker, runner, request) {
  // check circuit breaker
  return callJobRunner(request)
}


function withRetry(retryOpts, circuitBreaker, runner, request) {
  return withCircuitBreaker(circuitBreaker, request);
  // retry if failed
}


function retryWithOtherRunner(runner, request) {
  withRetry(retryOpts, circuitBreaker, runner, request);
  response.setJobRunner(runner);
}


function checkIfActuallyReceived(runner, request) {
  return !listJobs(runner, request.jobName).isEmpty;
}


function submit(runner, request) {
  response = withRetry(retryOpts, circuitBreaker, runner, request)
  if (isFailed(response)) {
    if (retryCheckFeatureFlag) {
      if (checkIfActuallyReceived(runner, request)) {
        return response;
      } else {
        return retryWithOtherRunner(&#34;Job Runner B&#34;);
      }
    } else {
    return retryWithOtherRunner(&#34;Job Runner B&#34;);
  }
  return response;
}


function handleRequest(request) {
  jobRunner = &#34;Job Runner A&#34;;

  response = submit(jobRunner, request);

  jobRunner = response.getJobRunner();

  db.save(request, jobRunner);
}
</code></pre> <p>Except each function was in its own file, <em>and</em> each function was itself broken up into smaller bits which were in <em>their</em> own files, <em>and</em> what was being passed around wasn&#39;t a request plus a <code>job_runner</code> string, it was a bunch of different objects holding a bunch of information.<a href="#footnote-3" id="return-3"><sup>††</sup></a></p> <p>So the problem could be in any of the following spots:</p> <ul> <li><code>handleRequest</code></li> <li><code>submit</code></li> <li><code>retryWithOtherRunner</code></li> <li><code>checkIfActuallyReceived</code></li> <li><code>withRetry</code></li> <li><code>withCircuitBreaker</code></li> <li><code>callJobRunner</code></li> </ul> <p>Once again, our question is: <em>What do you do?</em></p> <p>You could assume the problem is in the http request and start debugging that. Or you could assume it&#39;s in the retry code, and start there.</p> <p>Or you could try and bifurcate the code architecture.</p> <p>We decided to cut out the circuit breaker and retry logic. We commented out those functions, made them no-ops, and re-ran a job. It stored the wrong value to the database.</p> <p>Nice! Now we know the problem is in one of:</p> <ul> <li><code>handleRequest</code></li> <li><code>submit</code></li> <li><code>retryWithOtherRunner</code></li> <li><code>checkIfActuallyReceived</code></li> <li><code>callJobRunner</code></li> </ul> <p>The next part is tricky. We could not easily comment out the remainder and maintain enough functionality to have a viable test. Therefore, we started debugging each function individually, starting with <code>handleRequest</code>. However, <em>we did not set out to prove <code>handleRequest</code> was the culprit</em>. Rather, we set out to prove it was <em>not</em> the culprit. Our goal was to <em>isolate</em> the problem, not to <em>solve</em> the problem.</p> <p>Instead of carefully reading the code in <code>handleRequest</code>, adding print statements and the like, we simply invoked <code>handleRequest</code> directly to see if we could get it to erroneously report a success. After a few tries, it became clear that it was working properly, so we moved on to the <code>submit</code> call. Invoking it directly, we found that it did, in fact, return a <code>response</code> with the wrong <code>jobRunner</code>.</p> <p>Bingo!</p> <h2>Part Three: A Function</h2> <p>We were down to three possible spots:</p> <ul> <li><code>submit</code></li> <li><code>retryWithOtherRunner</code></li> <li><code>checkIfActuallyReceived</code></li> </ul> <p>Once again, we ask: <em>What do you do?</em></p> <p>By now, you know then answer is: Bifurcate the function!</p> <p>Luckily, there was a built-in way to split this code. Toggling <code>retryCheckFeatureFlag</code> shuts off half of the conditionals in the function, thereby isolating the other half. Doing that, we found we were <em>unable</em> to replicate the issue, so the problem wasn&#39;t in <code>retryWithOtherRunner</code>. Now we know for certain that the problem is somewhere in this code:</p> <pre><code>function checkIfActuallyReceived(runner, request) {
  return listJobs(runner, request.jobName)[0] == null;
}


if (checkIfActuallyReceived(runner, request)) {
  return response;
} else {
  return retryWithOtherRunner(&#34;Job Runner B&#34;);
}
</code></pre> <p>Running <code>checkIfActuallyReceived</code> in isolation showed that it did in fact return <code>true</code> even when the Job Runner failed.<a href="#footnote-4" id="return-4"><sup>†††</sup></a> We did it! Mission accomplished.</p> <hr/> <p>Hopefully this was a helpful illustration of how to put <em>Bifurcating the Problem Space</em> into practice. It is a true story. The details are anonymized, but I had a fair amount of notes lying around, so it&#39;s a pretty accurate portrayal of what happened.</p> <p>As you can see, this is a <em>recursive</em> practice. You apply it at the top to cut as much of the problem space as possible. Then you apply it at the next level down, then the next level down, until you get to a single branch in the code.</p> <p>I also want to highlight a couple of common bifurcating techniques showcased in this story:</p> <ul> <li><strong>Run things directly</strong>. Directly call APIs or functions. Doing so isolates those routines and excludes the surrounding code.</li> <li><strong>Comment things out</strong>. It&#39;s not always possible, but if you&#39;re able to comment out code blocks, you&#39;ll quickly rule those chunks of code in or out.</li> </ul> <p>Lastly, I will note, while it is generally useful, bifurcating the problem space really shines when you&#39;ve exhausted the obvious leads. It turned out that the bug in <code>checkIfActuallyReceived</code> had been living undetected in production for several months. Had it been a recent change, I suspect we would have been able to guess the cause much more quickly.</p> <hr/> <p> <sub> <a href="#return-1" id="footnote-1">†</a> If you&#39;d asked me where I learned that phrase before I wrote this article, I would have told you it was from <em>Debugging with the Scientific Method</em>. I searched through the talk transcript, and I can find no mention of &#34;bifurcate&#34; whatsoever. I suppose I either made it up or unknowingly picked it up from someone else. </sub> </p> <p> <sub> <a href="#return-3" id="footnote-3"><sup>††</sup></a> Don&#39;t bother reading too much into that code. It looks very little like the actual code anyways. The point here is to show how convoluted a relatively straightforward interaction can become. </sub> </p> <p> <sub> <a href="#return-4" id="footnote-4"><sup>†††</sup></a> The actual problem ended up being something to do with the code expecting a list of null when it actually got a list of empty lists in return. Plus one for the type checkers. </sub> </p> <hr/> <p>A big thank you to <a href="https://indieweb.social/@mshenfield">Max Shenfield</a> and <a href="https://twitter.com/jcsims">Chris Sims</a> for their inspiration to start writing again and for their feedback on this article.</p> </section></div></div>
  </body>
</html>
