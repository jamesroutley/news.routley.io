<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.shuttle.rs/blog/2022/07/28/patterns-with-rust-types">Original</a>
    <h1>Patterns with Rust Types</h1>
    
    <div id="readability-page-1" class="page"><article><p>This post introduces some patterns and tricks to better utilise Rust&#39;s type system for clean and safe code.
This post is on the advanced side and in general there are no absolutes - these patterns usually need to be evaluated on a case-by-case basis to see if the cost / benefit trade-off is worth it.</p>
<h2 id="the-new-type-pattern">The new type pattern</h2>
<p>The new type pattern provides encapsulation  as well as a guarantee that the right type of value is supplied at compile time. There are several uses and benefits for the new type pattern - let&#39;s take a look at some examples.</p>
<h3 id="identifier-separation">Identifier Separation</h3>
<p>A common representation of an identifier is a number - in this case let&#39;s use the unsigned integer type <code>usize</code>.</p>
<p>Let&#39;s say we have a function that receives an identifier for a <strong>User</strong> from a database by username. By using a unique username our API retrieves the identifier of the user:</p>
<div><pre><code><span>fn</span> <span>get_user_id_from_username</span><span>(</span>username<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>usize</span>
</code></pre></div>
<p>Let&#39;s say we have a similar mechanism for another entity, <code>Post</code>.</p>
<p>If our application is performing operations involving posts <strong>and</strong> users, the logic can get in a mix:</p>
<div><pre><code><span>let</span> user_id<span>:</span> <span>usize</span> <span>=</span> <span>get_user_id_from_username</span><span>(</span>username<span>)</span><span>;</span>
<span>let</span> post_id<span>:</span> <span>usize</span> <span>=</span> <span>get_last_post</span><span>(</span><span>)</span><span>;</span>
<!-- -->
<span>fn</span> <span>delete_post</span><span>(</span>post_id<span>:</span> <span>usize</span><span>)</span> <span>{</span>
<!-- -->	
<span>}</span>
<!-- -->
<span>delete_post</span><span>(</span>user_id<span>)</span><span>;</span>
</code></pre></div>
<p>Here <code>get_user_id_from_username</code> and <code>get_last_post</code> both return <code>usize</code>s while <code>delete)_post</code> also takes a usize. In this code we can accidentally call <code>delete_post</code> with a <code>user_id</code>, there&#39;s nothing in the type system that would stop us from doing that.</p>
<p>To differentiate between these two identifiers we can use the new type pattern:</p>
<p>The new type pattern boils down to creating <strong>a new tuple struct with a single item</strong>, in this case <code>usize</code></p>
<div><pre><code><span>struct</span> <span>UserId</span><span>(</span><span>pub</span> <span>usize</span><span>)</span><span>;</span>
</code></pre></div>
<p>Now we can change our library definition to return a <code>UserId</code> instead of <code>usize</code></p>
<div><pre><code><span>fn</span> <span>get_user_id_from_username</span><span>(</span>username<span>:</span> <span>String</span><span>)</span> <span>-&gt;</span> <span>UserId</span> <span>{</span>
<!-- -->	<span>let</span> user_id<span>:</span> <span>usize</span> <span>=</span> <span>...</span>
<!-- -->	<span>UserId</span><span>(</span>user_id<span>)</span>
<span>}</span>
</code></pre></div>
<p>Doing similar for the posts system with a <code>PostId</code>, when now compiling we get an error on when calling <code>get_post</code>.</p>
<div><pre><code>   <span>|</span>
<span>14</span> <span>|</span>     <span>get_post</span><span>(</span>x<span>)</span><span>;</span>
<!-- -->   <span>|</span>              <span>^</span> expected <span>struct</span> `<span>PostId</span>`<span>,</span> found <span>struct</span> `<span>UserId</span>`<!-- -->
</code></pre></div>
<p>The new-type pattern enforces type-safety at compile time without any performance overhead at runtime.</p>
<h3 id="re-adding-functionality-to-our-type">Re-adding functionality to our type</h3>
<p>After creating this new <em>wrapper</em> type, we may need to implement some of the behaviour of the type it is encapsulating to appease our compiler. For example consider a set of &#39;banned&#39; users:</p>
<div><pre><code><span>let</span> banned_users<span>:</span> <span>HashSet</span><span>&lt;</span><span>UserId</span><span>&gt;</span> <span>=</span> <span>HashSet</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
</code></pre></div>
<p>The above doesn&#39;t compile because our new type <code>UserId</code> doesn&#39;t implement equality and hashing behaviour whereas <code>usize</code> did. To add these traits back we can use the inbuilt derive macro, which generates implementations for our struct based on the single and only field.</p>
<div><pre><code><span>#[derive(PartialEq, Eq, Hash)]</span>
<span>struct</span> <span>UserId</span><span>(</span><span>usize</span><span>)</span><span>;</span>
</code></pre></div>
<p>And we&#39;re good to go!</p>
<h3 id="contract-based-programming-in-rust--sub-typing">Contract based programming in Rust / sub-typing</h3>
<p>The new type pattern can also be used to constrain types to only take &#39;valid&#39; values.</p>
<p>In the above example we used a wrapper type to enforce <em>flow</em> of values, this method also enforces the <em>content</em> of the value. In our application we only want usernames to contain <strong>lowercase</strong> alphabetic characters. Wrapping over String we can do this:</p>

<p>The only way to create a Username is using the <code>TryFrom</code> trait.</p>
<div><pre><code><span>impl</span> <span>TryFrom</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>for</span> <span>Username</span> <span>{</span>
<!-- -->	<span>type</span> <span>Error</span> <span>=</span> <span>String</span><span>;</span>
<!-- -->
<!-- -->	<span>fn</span> <span>try_from</span><span>(</span>value<span>:</span> <span>String</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>,</span> <span>Self</span><span>::</span><span>Error</span><span>&gt;</span> <span>{</span>
<!-- -->		<span>if</span> value<span>.</span><span>chars</span><span>(</span><span>)</span><span>.</span><span>all</span><span>(</span><span><span>|</span>c<span>|</span></span> <span>matches!</span><span>(</span>c<span>,</span> <span>&#39;a&#39;</span><span>..=</span><span>&#39;z&#39;</span><span>)</span><span>)</span> <span>{</span>
<!-- -->			<span>Ok</span><span>(</span><span>Username</span><span>(</span>value<span>)</span><span>)</span>
<!-- -->		<span>}</span> <span>else</span> <span>{</span>
<!-- -->			<span>Err</span><span>(</span>value<span>)</span>
<!-- -->		<span>}</span>
<!-- -->	<span>}</span>
<span>}</span>
</code></pre></div>
<p>This implementation returns a new <code>Username</code> if <em>all</em> the characters are lowercase. Else the string is returned and can be reused in logic possibly displaying an error.</p>
<p>As the string field is private a <code>Username</code> cannot be created with <code>Username(my_string)</code>. It also cannot be modified by outsiders and invalidate our contract.</p>
<p>We can now use this structure as an argument to our API.</p>
<div><pre><code><span>fn</span> <span>create_user</span><span>(</span>db<span>:</span> <span>&amp;</span><span>mut</span> <span>DB</span><span>,</span> username<span>:</span> <span>Username</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>CreationError</span><span>&gt;</span> <span>{</span>
<!-- -->	
<span>}</span>
</code></pre></div>
<p>Since the username is validated to be lowercase ahead of time, the <code>create_user</code> function doesn&#39;t care about whether the username is valid inside in its own scope.</p>
<p>This can lead to easier error handling. <code>CreationError</code> doesn&#39;t have to include a variant for the if the username has invalid characters.</p>
<p>Although <strong>the only safe way</strong> to construct if through the validator <code>TryFrom</code> trait, the <code>Username</code> can be created through unsafe transmute (casting the bits of one value to the type of another without checks). This is normally fine though as with unsafe you are introducing undefined behaviour anyway.</p>
<div><pre><code><span>let</span> string <span>=</span> <span>String</span><span>::</span><span>new</span><span>(</span><span>&#34;muahahaha ðŸ‘¿&#34;</span><span>)</span><span>;</span>
<span>let</span> bad_username <span>=</span> <span>unsafe</span> <span>{</span> <span>std<span>::</span>mem<span>::</span></span><span>transmute</span><span>::</span><span>&lt;</span><span>String</span><span>,</span> <span>Username</span><span>&gt;</span><span>(</span>string<span>)</span> <span>}</span><span>;</span>
<span>dbg!</span><span>(</span>bad_username<span>)</span><span>;</span>
</code></pre></div>
<h3 id="wrapping-vs-canonical-type">Wrapping vs canonical type</h3>
<p>Our wrapped type is great from the outside, however we are relying on logic internal to the type to validate our contract.</p>
<p>If we want to we can be really drill down on the structure of our username. Here we also enforce that the username has to be between four and ten letters.</p>
<div><pre><code><span>#[rustfmt::skip]</span>
<span>enum</span> <span>Alphabet</span> <span>{</span>
<!-- -->	<span>A</span><span>,</span><span>B</span><span>,</span><span>C</span><span>,</span><span>D</span><span>,</span><span>E</span><span>,</span><span>F</span><span>,</span><span>G</span><span>,</span><span>H</span><span>,</span><span>I</span><span>,</span><span>J</span><span>,</span><span>K</span><span>,</span><span>L</span><span>,</span><span>M</span><span>,</span><span>N</span><span>,</span><span>O</span><span>,</span><span>P</span><span>,</span><span>Q</span><span>,</span><span>R</span><span>,</span><span>S</span><span>,</span><span>T</span><span>,</span><span>U</span><span>,</span><span>V</span><span>,</span><span>W</span><span>,</span><span>X</span><span>,</span><span>Y</span><span>,</span><span>Z</span>
<span>}</span>
<!-- -->
<span>enum</span> <span>Username</span> <span>{</span>
<!-- -->	<span>FourLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>4</span><span>]</span><span>)</span><span>,</span>
<!-- -->	<span>FiveLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>5</span><span>]</span><span>)</span><span>,</span>
<!-- -->	<span>SixLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>6</span><span>]</span><span>)</span><span>,</span>
<!-- -->	<span>SevenLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>7</span><span>]</span><span>)</span><span>,</span>
<!-- -->	<span>EightLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>8</span><span>]</span><span>)</span><span>,</span>
<!-- -->	<span>NineLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>9</span><span>]</span><span>)</span><span>,</span>
<!-- -->	<span>TenLetters</span><span>(</span><span>[</span><span>Alphabet</span><span>;</span> <span>10</span><span>]</span><span>)</span><span>,</span>
<span>}</span>
</code></pre></div>
<p>Even though there is no way to make an invalid username (except for unsafe) this is a little over the top ðŸ˜‚. In some edge cases it can be beneficial but in the example above this is clearly overkill.</p>
<h3 id="working-with-foreign-traits-on-foreign-types">Working with foreign traits on foreign types</h3>
<p>Traits are great. They can be defined on structs and enums, but you may run into some issues when implementing a foreign trait on a foreign type.</p>
<p>This is by design, and here&#39;s why:</p>
<p><img src="https://www.shuttle.rs/images/blog/rust-trait-rules-diagram.png" alt=""/></p>
<p>In our crate the compiler doesn&#39;t know when calling <code>MyTrait</code> methods on <code>MyStruct</code> whether to use the implementation defined in <code>crate 3</code> or <code>crate 4</code>! <a href="https://github.com/Ixrec/rust-orphan-rules">Rust has a set of orphan rules</a> to prevent this situation from happening.</p>
<p>In the situation where you&#39;d like to implement a foreign trait on a foreign type - the &#39;new type&#39; pattern can come to the rescue yet again:</p>
<div><pre><code>
<span>trait</span> <span>ToTree</span> <span>{</span>
<!-- -->	
<span>}</span>
<!-- -->
<span>fn</span> <span>very_useful_function</span><span>(</span>something<span>:</span> <span>impl</span> <span>ToTree</span><span>)</span> <span>-&gt;</span> <span>(</span><span>)</span> <span>{</span>
<!-- -->    
<span>}</span>
<!-- -->

<span>struct</span> <span>Wrapper</span><span>(</span><span>pub</span> <span>crate_y<span>::</span></span><span>MyType</span><span>)</span><span>;</span>
<!-- -->
<span>impl</span> <span>ToTree</span> <span>for</span> <span>Wrapper</span> <span>{</span>
<!-- -->	
<span>}</span>
<!-- -->

<span>very_useful_function</span><span>(</span><span>Wrapper</span><span>(</span>foreign_value<span>)</span><span>)</span>
</code></pre></div>
<p>One of the gotchas with this is that you have to manually implement the trait. You can&#39;t use derive macros, e.g. <code>#[derive(PartialEq)]</code> and reach through to the declaration of the wrapped type and read its declaration. You also have to make sure that you can properly implement the trait on the item. <code>crate_y::MyType</code> might hide information needed for the implementation ðŸ˜•.</p>
<p>Ok - enough with the new type pattern. Let&#39;s leave it for a minute and look at some other tricks when working with types in Rust.</p>
<h2 id="using-either-to-unify-different-types">Using either to unify different types</h2>
<p>Sometimes we have a case where we have a complicated data type</p>
<div><pre><code><span>enum</span> <span>PostUser</span> <span>{</span>
<!-- -->	<span>Single</span> <span>{</span>
<!-- -->		username<span>:</span> <span>UserId</span>
<!-- -->	<span>}</span><span>,</span>
<!-- -->	<span>Group</span> <span>{</span>
<!-- -->		usernames<span>:</span> <span>HashSet</span><span>&lt;</span><span>UserId</span><span>&gt;</span>
<!-- -->	<span>}</span>
<span>}</span>
</code></pre></div>
<p>We&#39;d like a method that returns an iterator, but we&#39;re stuck since we either return a single once iterable (<a href="https://doc.rust-lang.org/std/iter/struct.Once.html">std::iter::Once</a>) or an iterator over a hashset. These iterators are different types and have different properties, so Rust doesn&#39;t like when we try to build a function returning both.</p>
<p>A Rust function / method can only return one type:</p>
<div><pre><code><span>impl</span> <span>PostUser</span> <span>{</span>
<!-- -->	<span>fn</span> <span>iter</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>impl</span> <span>Iterator</span><span>&lt;</span><span>Item</span><span>=</span><span>&amp;</span><span>UserId</span><span>&gt;</span> <span>+</span> <span>&#39;_</span> <span>{</span>
<!-- -->		<span>match</span> <span>self</span> <span>{</span>
<!-- -->			<span>PostUser</span><span>::</span><span>User</span> <span>{</span> username <span>}</span> <span>=&gt;</span> <span>std<span>::</span>iter<span>::</span></span><span>once</span><span>(</span>username<span>)</span><span>,</span>
<!-- -->			<span>PostUser</span><span>::</span><span>Group</span> <span>{</span> usernames <span>}</span> <span>=&gt;</span> usernames<span>.</span><span>into_iter</span><span>(</span><span>)</span><span>,</span>
<!-- -->		<span>}</span>
<!-- -->	<span>}</span>
<span>}</span>
</code></pre></div>
<p>The following will fail because the match arms have different types.</p>
<div><pre><code>   <span>|</span>
<span>17</span> <span>|</span> <span>/</span>         <span>match</span> <span>self</span> <span>{</span>
<span>18</span> <span>|</span> <span>|</span>             <span>PostUser</span><span>::</span><span>User</span> <span>{</span> username <span>}</span> <span>=&gt;</span> <span>std<span>::</span>iter<span>::</span></span><span>once</span><span>(</span>username<span>)</span><span>,</span>
<!-- -->   <span><span>|</span> <span>|</span></span>                                            <span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> this is found to be of <span>type</span> `<span>std<span>::</span>iter<span>::</span></span><span>Once</span><span>&lt;</span><span>&amp;</span><span>UserId</span><span>&gt;</span>`<!-- -->
<span>19</span> <span>|</span> <span>|</span>             <span>PostUser</span><span>::</span><span>Group</span> <span>{</span> usernames <span>}</span> <span>=&gt;</span> usernames<span>.</span><span>into_iter</span><span>(</span><span>)</span><span>,</span>
<!-- -->   <span><span>|</span> <span>|</span></span>                                              <span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span><span>^</span> expected <span>struct</span> `<span>std<span>::</span>iter<span>::</span></span><span>Once</span>`<span>,</span> found <span>struct</span> `<span>std<span>::</span>collections<span>::</span>hash_set<span>::</span></span><span>Iter</span>`<!-- -->
<span>20</span> <span>|</span> <span>|</span>         <span>}</span>
<!-- -->   <span>|</span> <span>|</span><span>_________</span><span>-</span> `<span>match</span>` arms have incompatible types<!-- -->
<!-- -->   <span>|</span>
<!-- -->   <span>=</span> note<span>:</span> expected <span>struct</span> `<span>std<span>::</span>iter<span>::</span></span><span>Once</span><span>&lt;</span><span>&amp;</span><span>UserId</span><span>&gt;</span>`<!-- -->
<!-- -->              found <span>struct</span> `<span>std<span>::</span>collections<span>::</span>hash_set<span>::</span></span><span>Iter</span><span>&lt;</span><span>&#39;_</span><span>,</span> <span>UserId</span><span>&gt;</span>`<!-- -->
</code></pre></div>
<p>The <a href="https://github.com/bluss/either"><code>either</code> crate</a> offers a general purpose sum type <a href="https://docs.rs/either/1.7.0/either/enum.Either.html#trait-implementations">that implements many traits</a>. Using <code>either::Left</code> for the once iterator and <code>either::Right</code> we can build two iterators into what Rust considers as a single type.</p>
<div><pre><code><span>impl</span> <span>PostUser</span> <span>{</span>
<!-- -->	<span>fn</span> <span>iter</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>impl</span> <span>Iterator</span><span>&lt;</span><span>Item</span><span>=</span><span>&amp;</span><span>UserId</span><span>&gt;</span> <span>+</span> <span>&#39;_</span> <span>{</span>
<!-- -->		<span>match</span> <span>self</span> <span>{</span>
<!-- -->			<span>PostUser</span><span>::</span><span>User</span> <span>{</span> username <span>}</span> <span>=&gt;</span> <span>either<span>::</span></span><span>Left</span><span>(</span><span>std<span>::</span>iter<span>::</span></span><span>once</span><span>(</span>username<span>)</span><span>)</span><span>,</span>
<!-- -->			<span>PostUser</span><span>::</span><span>Group</span> <span>{</span> usernames <span>}</span> <span>=&gt;</span> <span>either<span>::</span></span><span>Right</span><span>(</span>usernames<span>.</span><span>into_iter</span><span>(</span><span>)</span><span>)</span><span>,</span>
<!-- -->		<span>}</span>
<!-- -->	<span>}</span>
<span>}</span>
</code></pre></div>
<p>We could have instead boxed the results and returned <code>Box&lt;dyn Iterator&lt;Item=&amp;UserId&gt;&gt;</code>. The benefit of using either is that it uses static dispatch rather than dynamic dispatch. <a href="https://docs.rs/enum_dispatch/latest/enum_dispatch/#the-benchmarks">enum_dispatch has good performance comparison for using static dispatch over dyn</a> so if you are on a critical hot path, and you know all the returned types it is faster to use enums to unify types rather than dynamic trait dispatching.</p>
<h2 id="extension-traits">Extension traits</h2>
<p>When creating a library we may add some functions for working with existing types (whether in the standard library or a different crate).</p>
<p>Let&#39;s say we are writing a library on top of <em>serenity</em> which has models for discord servers (discord refers to them as guilds).</p>
<p>Let&#39;s write a helper function that gets the number of channels in a <a href="https://docs.rs/serenity/0.11.4/serenity/model/guild/struct.Guild.html">Guild</a>.</p>
<div><pre><code><span>async</span> <span>fn</span> <span>get_number_of_channels</span><span>(</span>
<!-- -->	guild<span>:</span> <span>&amp;</span><span>serenity<span>::</span>model<span>::</span></span><span>Guild</span><span>,</span>
<!-- -->	http<span>:</span> <span>impl</span> <span>AsRef</span><span>&lt;</span><span>Http</span><span>&gt;</span>
<span>)</span> <span>-&gt;</span> <span>serenity<span>::</span></span><span>Result</span><span>&lt;</span><span>usize</span><span>&gt;</span>
</code></pre></div>
<p>When calling the function we <strong>have to</strong> pass the guild as the first argument.</p>
<div><pre><code><span>let</span> guild<span>:</span> <span>serenity<span>::</span>model<span>::</span></span><span>Guild</span> <span>=</span> 
<span>get_number_of_channels</span><span>(</span><span>&amp;</span>guild<span>,</span> client<span>)</span><span>;</span>
</code></pre></div>
<p>But from a design perspective we might prefer to use member notation instead: <code>guild.get_number_of_channels(client)</code>.</p>
<p>We can&#39;t use add a direct implementation for a type defined outside our current crate.</p>
<div><pre><code><span>/</span> <span>impl</span> <span>serenity<span>::</span>model<span>::</span></span><span>Guild</span> <span>{</span>
<span>|</span>     <span>fn</span> <span>number_of_channels</span><span>&lt;</span><span>T</span><span>:</span> <span>AsRef</span><span>&lt;</span><span>Http</span><span>&gt;&gt;</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> http<span>:</span> <span>T</span><span>)</span> <span>-&gt;</span> <span>serenity<span>::</span></span><span>Result</span><span>&lt;</span><span>usize</span><span>&gt;</span> <span>{</span>
<span>|</span>         <span>todo!</span><span>(</span><span>)</span>
<span>|</span>     <span>}</span>
<span>|</span> <span>}</span>
<span>|</span>_<span>^</span> <span>impl</span> <span>for</span> <span>type</span> <span>defined</span> outside of <span>crate</span><span>.</span>
</code></pre></div>
<p>To define an associated method on a type outside the crate we must instead make an intermediate &#39;Extension&#39; trait:</p>
<div><pre><code><span>trait</span> <span>GuildExt</span> <span>{</span>
<!-- -->	<span>fn</span> <span>number_of_channels</span><span>&lt;</span><span>T</span><span>:</span> <span>AsRef</span><span>&lt;</span><span>Http</span><span>&gt;&gt;</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> http<span>:</span> <span>T</span><span>)</span> <span>-&gt;</span> <span>serenity<span>::</span></span><span>Result</span><span>&lt;</span><span>usize</span><span>&gt;</span><span>;</span>
<span>}</span>
<!-- -->
<span>impl</span> <span>GuildExt</span> <span>for</span> <span>serenity<span>::</span>model<span>::</span></span><span>Guild</span> <span>{</span>
<!-- -->	<span>fn</span> <span>number_of_channels</span><span>&lt;</span><span>T</span><span>:</span> <span>AsRef</span><span>&lt;</span><span>Http</span><span>&gt;&gt;</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> http<span>:</span> <span>T</span><span>)</span> <span>-&gt;</span> <span>serenity<span>::</span></span><span>Result</span><span>&lt;</span><span>usize</span><span>&gt;</span> <span>{</span>
<!-- -->		
<!-- -->	<span>}</span>
<span>}</span>
</code></pre></div>
<p>Using the intermediate trait the compiler can reason about when the method exists. To use the method syntax and show the compiler that the extension exists we must import the trait into our scope:</p>
<div><pre><code><span>use</span> <span>crate</span><span>::</span><span>GuildExt</span><span>;</span>
<span>let</span> guild<span>:</span> <span>serenity<span>::</span>model<span>::</span></span><span>Guild</span> <span>=</span> 
<span>let</span> number_of_channels <span>=</span> guild<span>.</span><span>get_number_of_channels</span><span>(</span>client<span>)</span><span>;</span>
</code></pre></div>
<p>This pattern is used in the futures crate with the <a href="https://docs.rs/futures/0.3.21/futures/future/trait.FutureExt.html">FutureExt trait</a>.
Here using the trait <code>FutureExt</code> provides additional methods to the existing <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code> trait in Rust&#39;s standard library</a>. Aside from syntax aesthetics, it becomes much easier to find object-specific functions when using an IDE.</p>
<p>You can use the <a href="https://docs.rs/easy-ext/1.0.0/easy_ext/">easy_ext</a> for doing this pattern on a single type without having to write the trait / trait definition is generated for you.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how we can use various patterns like the new-type pattern and extension pattern to make our Rust code more ergonomic and take advantage of the type system and compiler to write better code. There is a great book out on <a href="https://rust-unofficial.github.io/patterns/intro.html">Rust design patterns</a> which covers some of these and many more patterns in Rust. What are your favourite design patterns in Rust? Let us know and we&#39;ll cover them next time!</p></article></div>
  </body>
</html>
