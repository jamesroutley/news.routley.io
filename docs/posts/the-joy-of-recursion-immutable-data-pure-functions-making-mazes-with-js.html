<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jrsinclair.com/articles/2025/joy-of-immutable-data-recursion-pure-functions-javascript-mazes/">Original</a>
    <h1>The joy of recursion, immutable data, &amp; pure functions: Making mazes with JS</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-bvzihdzo="">  
<p>Let’s start by addressing the elephant in the room. Why the heck am I talking about making mazes?</p>
<p>Normally, I try to be practical when I’m writing or speaking. I want to give people tools they can use to make their coding lives better. So, I try to discuss things like creating <abbr title="Document Object Model">DOM</abbr> elements and processing <abbr title="JavaScript Object Notation">JSON</abbr> data. Because those things are practical. I would rather not waste people’s time on things they’re not going to use.</p>
<p>But, mazes, they’re not so practical.</p>
<p>Unless you’re working in game development, it’s unlikely that you’re going to need a maze in your web app. So, in that sense, knowing how to build a maze is useless. You’re never going to use it.</p>
<p>However, the nice thing about generating mazes is that they’re a challenge. A challenge that’s not too big, and not too small. You see, an issue I often have is that people ask me for ‘real world’ examples. But the trouble with ‘real world’ examples is that they’re complex. Much more complex than you can reasonably talk about in a blog post. There are all these edge cases that you have to handle. Things like error-handling, network outages, and input validation. But a maze is a contained problem that’s just complex enough to be interesting.</p>
<p>And it’s not a to-do list.</p>
<p>Furthermore, we can build our maze in such a way that we’ll learn about immutable data and recursion while we’re at it.</p>
<p>So let’s get into it.</p>
<h2 id="building-a-maze">Building a maze</h2>
<p>How, then, do we build a maze? Let’s start with an example. We’ll work through building a small maze, step-by-step. We start with a grid. The one in the picture below is a 4 × 4 grid with 16 ‘rooms’ and ‘walls’ between each room.</p>
<figure>
 <img src="https://jrsinclair.com/assets/grid.svg" alt="A grid of 16 squares, arranged into 4 columns and 4 rows. The rows and columns are numbered from 0 to 3, starting from the top-left corner."/>
 <figcaption>A 4 × 4 grid. The starting point for our maze.</figcaption>
</figure>
<p>Next, we pick a room at random. I’ve picked one near the middle, but it could be any room in the grid.</p>
<figure>
 <img alt="A grid of 16 squares, arranged into 4 columns and 4 rows. The square at position 1,1 contains a blue inner square to indicate the starting point for the maze building algorithm." src="https://jrsinclair.com/assets/starting-square.svg"/>
 <figcaption>We’ve selected the room at (1, 1) as our starting-point.</figcaption>
</figure>
<p>Then, we make a list of the adjoining rooms to the north, south, east, and west. But only if they that <em>aren’t</em> already connected to another room.</p>
<figure>
 <img alt="A grid of 16 squares, arranged into 4 columns and 4 rows. The square at position 1,1 contains a blue inner square, and the 4 squares to the north, east, south, and west of it contain grey squares." src="https://jrsinclair.com/assets/four-adjoining-rooms.svg"/>
 <figcaption>The room at (1, 1) has four adjacent rooms that aren&#39;t connected to another room.</figcaption>
</figure>
<p>Next, we pick one of those rooms at random, and we punch a hole through the wall connecting those two rooms. In this case, we choose the room to the north.</p>
<figure>
 <img alt="Join the room to the north" src="https://jrsinclair.com/assets/join-room-north-01.svg"/>
 <figcaption>We’ve randomly selected the room to the north. We join the two rooms, removing the wall between them.</figcaption>
</figure>
<p>Then, we repeat that process for the room we’ve just connected. This time, we have only two directions to pick from. This is because the room to the south is connected to this one, and we’re butting up against the north edge.</p>
<figure>
 <img alt="Two adjoining rooms to the east and west" src="https://jrsinclair.com/assets/two-adjoining-rooms.svg"/>
 <figcaption>The room at (1, 0) has two adjoining, unconnected rooms. One is to the east, and the other to the west.</figcaption>
</figure>
<p>This time we’ll pick the room to the west. We join those two rooms, and move west.</p>
<figure>
 <img alt="Join the room to the west" src="https://jrsinclair.com/assets/join-room-west.svg"/>
 <figcaption>We’ve randomly selected the room to the west. We join the two rooms, removing the wall between them.</figcaption>
</figure>
<p>Then we join the room to the south because there’s nowhere else to go.</p>
<figure>
 <img alt="Join the room to the south" src="https://jrsinclair.com/assets/join-room-south-01.svg"/>
 <figcaption>The room at (0, 0) has one adjoining, unconnected room. It is to the south. We join the two rooms, removing the wall between them.</figcaption>
</figure>
<p>Once again to the south, because there’s no other direction to join.</p>
<figure>
 <img alt="Join the room to the south" src="https://jrsinclair.com/assets/join-room-south-02.svg"/>
 <figcaption>The room at (0, 1) has one adjoining unconnected room. It is to the south. We join the two rooms, removing the wall between them.</figcaption>
</figure>
<p>And we keep joining rooms until we reach a point where we can’t go any further. That is, there are no more directions to choose from.  Once we get there, then we backtrack one square… and start again. We keep repeating this process until we have no unconnected squares left. Once that’s done, our maze is complete.</p>
<figure>
 <img alt="An animation showing the process of detecting unconnected rooms, joining one at random, them moving to the next square" src="https://jrsinclair.com/assets/maze-animation-css.svg"/>
 <figcaption>The whole maze drawing process from start to finish.</figcaption>
</figure>
<p>And, if we feel like it, we can add an entry and exit.</p>
<figure>
 <img alt="Complete maze" src="https://jrsinclair.com/assets/final-maze-with-exits.svg"/>
 <figcaption>The completed maze with an entry and exit point.</figcaption>
</figure>
<h2 id="the-maze-building-algorithm">The maze-building algorithm</h2>
<p>Now that we’ve seen an example, let’s try to write that out in words, as an algorithm.</p>
<ol>
<li>Start with a grid of unconnected rooms and a randomly selected room.</li>
<li>Make a list of rooms adjacent to the current room, not yet connected to another room.</li>
<li>If this list is empty, go back one room and repeat from 2 (or finish).</li>
<li>Pick one of the rooms in the list at random and connect it.</li>
<li>Move to this new room and repeat from 2.</li>
</ol>
<p>This algorithm will work for a grid of any size. And we’re almost ready to turn this into code. But, to make life easier for ourselves, we’re going to create our very own immutable data structure… from scratch.</p>
<h2 id="creating-an-immutable-data-structure">Creating an immutable data structure</h2>
<p>Now, in case you’re wondering, ‘immutable’ simply means ‘doesn’t change’. That is, we’ll write a class in such a way that once you create an object, you can’t modify it.</p>
<p>We’ll create a helper class, <code>Point</code>, that represents an <em>x</em>,<em>y</em> coordinate.</p>
<pre data-language="javascript"><code is:raw="">
<span>class</span> <span>Point</span> <span>{</span>
  <span>constructor</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>x <span>=</span> x<span>;</span>
    <span>this</span><span>.</span>y <span>=</span> y<span>;</span>
  <span>}</span>
<span>}</span>

</code></pre>
<p>It has a constructor that takes an <em>x</em>-value, and a <em>y</em>-value, and assigns those to properties. There’s not much to it. But we now have a simple class.</p>
<p>Now, so far, this class doesn’t do very much. And it’s not immutable. So what we’re going to do is hide this class away. We won’t export it. Instead, we’re going to create a constructor function, <code>point()</code> (lowercase ‘p’). And that will be the only way to get yourself a <code>Point</code>.</p>
<pre data-language="javascript"><code is:raw="">
<span>export</span> <span>function</span> <span>point</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  
  
  <span>const</span> p <span>=</span> <span>new</span> <span>Point</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
  <span>return</span> p<span>;</span>
<span>}</span>

</code></pre>
<p>We have the beginnings of a constructor function. It takes an <em>x</em> and a <em>y</em> coordinate, calls the class constructor, and returns as a <code>Point</code> object. But we still haven’t achieved immutability yet. To achieve that, we’re going to <em>memoise</em> this function. That is, we’re going to create a cache of all the <em>x</em>,<em>y</em> values we’ve seen so far. And if we’ve already seen one we’ll return the point we created earlier.</p>
<p>We create our cache using the built-in <code>Map</code> structure. In this case, we call it <code>allPoints</code>.</p>
<pre data-language="javascript"><code is:raw="">
<span>const</span> allPoints <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<p>With that in place, we can memoise our <code>point()</code> function. When a new call for a point comes in, we convert the <em>x</em>,<em>y</em> pair into a string. Then we use that to check to see if we’ve already seen this pair of numbers before. If we have, we return the existing point. If not, we’ll create a new one.</p>
<pre data-language="javascript"><code is:raw="">
<span>export</span> <span>function</span> <span>point</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  
  
  <span>const</span> key <span>=</span> <span><span>`</span><span><span>${</span>x<span>}</span></span><span>-</span><span><span>${</span>y<span>}</span></span><span>`</span></span><span>;</span>
  <span>if</span> <span>(</span>allPoints<span>.</span><span>has</span><span>(</span>key<span>)</span><span>)</span> <span>return</span> allPoints<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>

  
  
  <span>const</span> newPoint <span>=</span> <span>new</span> <span>Point</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
  allPoints<span>.</span><span>set</span><span>(</span>key<span>,</span> newPoint<span>)</span><span>;</span>
  <span>return</span> newPoint<span>;</span>
<span>}</span>
</code></pre>
<p>While we’re at it, we’ll freeze the object so the <abbr title="JavaScript">JS</abbr> runtime will stop anyone who tries to change those <em>x</em>- or <em>y</em>-values.</p>
<pre data-language="javascript"><code is:raw="">
<span>export</span> <span>function</span> <span>point</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>const</span> key <span>=</span> <span><span>`</span><span><span>${</span>x<span>}</span></span><span>-</span><span><span>${</span>y<span>}</span></span><span>`</span></span><span>;</span>
  <span>if</span> <span>(</span>allPoints<span>.</span><span>has</span><span>(</span>key<span>)</span><span>)</span> <span>return</span> allPoints<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>

  <span>const</span> newPoint <span>=</span> <span>new</span> <span>Point</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>

  
  
  Object<span>.</span><span>freeze</span><span>(</span>newPoint<span>)</span><span>;</span> 

  allPoints<span>.</span><span>set</span><span>(</span>key<span>,</span> newPoint<span>)</span><span>;</span>
  <span>return</span> newPoint<span>;</span>
<span>}</span>
</code></pre>
<p>Okay. We now have a helper class. And let’s face it, it doesn’t do much. So why do we bother? Why not just use a plain ol’ JavaScript object? Zero code needed.</p>
<p>Well, building a special class like this lets me do something plain objects can’t. I can compare them using triple equals.</p>
<p>So let’s try this. We create an object, <code>objA</code>, and another object, <code>objB</code>, and compare them with <code>===</code>. And we get <code>false</code>. This is because <code>objA</code> and <code>objB</code> are pointing to two different locations in memory. But if we use our <code>point()</code> function, and compare with <code>===</code>, we get <code>true</code>. Because we memoised our function, <code>pA</code> and <code>pB</code> are pointing to the same memory location.</p>
<pre data-language="javascript"><code is:raw=""><span>const</span> objA <span>=</span> <span>{</span><span>x</span><span>:</span> <span>3</span><span>,</span> <span>y</span><span>:</span> <span>5</span><span>}</span><span>;</span>
<span>const</span> objB <span>=</span> <span>{</span><span>x</span><span>:</span> <span>3</span><span>,</span> <span>y</span><span>:</span> <span>5</span><span>}</span><span>;</span>
objA <span>===</span> objB<span>;</span> 

<span>const</span> pointA <span>=</span> <span>point</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span><span>;</span>
<span>const</span> pointB <span>=</span> <span>point</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span><span>;</span>
pA <span>===</span> pB 
</code></pre>
<p>Again, you might legitimately ask, ‘So what?’ But things become much more interesting when we combine this with other data structures.</p>
<p>For example, we could use these points as keys in a <code>Map</code> structure. For this example, we’ll use the <code>Map</code> structure from the venerable <a href="https://immutable-js.com/">Immutable.js</a> library here. But it will work just fine with the built-in JavaScript <code>Map</code> too.</p>
<pre data-language="javascript"><code is:raw=""><span>import</span> <span>{</span> Map <span>}</span> <span>from</span> <span>&#39;immutable&#39;</span><span>;</span>
<span>import</span> <span>{</span> point <span>}</span> <span>from</span> <span>&#39;./point&#39;</span><span>;</span>

<span>const</span> mapWithObjects <span>=</span> <span>Map</span><span>(</span><span>[</span>
  <span>[</span><span>{</span><span>x</span><span>:</span> <span>3</span><span>,</span> <span>y</span><span>:</span> <span>5</span><span>}</span><span>,</span> <span>&#39;object A&#39;</span><span>]</span><span>,</span>
  <span>[</span><span>{</span><span>x</span><span>:</span> <span>3</span><span>,</span> <span>y</span><span>:</span> <span>5</span><span>}</span><span>,</span> <span>&#39;object B&#39;</span><span>]</span>
<span>]</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>mapWithObjects<span>.</span><span>toArray</span><span>(</span><span>)</span><span>)</span><span>;</span>





<span>const</span> mapWithPoints <span>=</span> <span>Map</span><span>(</span><span>[</span>
  <span>[</span><span>point</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>&#39;First Point 3,5&#39;</span><span>]</span><span>,</span>
  <span>[</span><span>point</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>&#39;Second Point 3,5&#39;</span><span>]</span>
<span>]</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>mapWithPoints<span>.</span><span>toArray</span><span>(</span><span>)</span><span>)</span><span>;</span>




</code></pre>
<p>So, we import the <code>Map</code> structure from Immutable. Then we create a <code>Map</code> using two identical plain objects. And this results in a <code>Map</code> with <em>two</em> entries—even though the values in the objects are the same. But if we use our <code>point()</code> constructor, the second point overwrites the first. We get a <code>Map</code> with a single entry. And this is where things start to get interesting. Because using the right data structures will be crucial for our maze-building algorithm.</p>
<h2 id="coding-the-algorithm">Coding the algorithm</h2>
<p>So, let’s get into writing our algorithm. We’ll go over it one more time.</p>
<ol>
<li>Start with a grid of unconnected rooms and a randomly selected room.</li>
<li>Make a list of rooms adjacent to the current room, not yet connected to another room.</li>
<li>If this list is empty, go back one room and repeat from 2 (or finish).</li>
<li>Pick one of the rooms in the list at random and connect it.</li>
<li>Move to this new room and repeat from 2.</li>
</ol>
<h2 id="step-1">Step 1</h2>
<p>If we’re going to turn this algorithm into code. We need to set things up so we can start our algorithm in the right state. The two main things we need are:</p>
<ol>
<li>A grid of unconnected rooms; and</li>
<li>A random room to start in.</li>
</ol>
<p>Let’s start building those out. We’ll start with the grid. And, for now, we’re going to assume we’re only building square mazes. To help us build our set of unconnected rooms, we’ll do a bit of maths.</p>
<p>The total number of rooms will be <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>n</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span>. So, we create an array with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>n</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> entries, and map over it to create a <code>Map</code> structure that will represent our maze.</p>
<p>This (immutable) <code>Map</code> structure will have points as keys. And each value for the map will be a <code>List</code> of rooms it’s connected to.</p>
<h3 id="building-the-grid">Building the grid</h3>
<p>So let’s build our grid.</p>
<pre data-language="javascript"><code is:raw=""><span>import</span> <span>{</span>Map<span>,</span> List<span>}</span> <span>from</span> <span>&#39;immutable&#39;</span><span>;</span>

<span>const</span> emptyArray <span>=</span> <span>new</span> <span>Array</span><span>(</span>n <span>**</span> <span>2</span><span>)</span><span>.</span><span>fill</span><span>(</span><span>undefined</span><span>)</span><span>;</span>
<span>const</span> roomList <span>=</span> emptyArray<span>.</span><span>map</span><span>(</span>
  <span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=&gt;</span> <span>[</span><span>point</span><span>(</span>i <span>%</span> n<span>,</span> Math<span>.</span><span>floor</span><span>(</span>i <span>/</span> n<span>)</span><span>)</span><span>,</span> <span>List</span><span>(</span><span>)</span><span>]</span>
<span>)</span><span>;</span>
<span>const</span> grid <span>=</span> <span>Map</span><span>(</span>roomList<span>)</span><span>;</span>
</code></pre>
<p>All we do is create an array with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>n</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> entries, then we map over it to create an array of pairs. The left item in each pair is a point. The <em>x</em>-value for the point is <code>i</code> modulo <code>n</code>. The <em>y</em>-value is <code>i</code> divided by <code>n</code>. And the right item in the pair is an empty list. We then pass that list of pairs to the immutable <code>Map</code> constructor, and that creates our <code>Map</code>.</p>
<h3 id="a-random-room-to-start-in">A random room to start in</h3>
<p>Next, we need a room picked at random to start in. But for this exercise, we’re trying to work with pure functions as much as possible. And something that’s different every time you call it, like <code>Math.random()</code>, is considered ‘impure’. So, we’re going to quickly whip up our own pseudo-random number generator to sidestep this problem.</p>
<pre data-language="javascript"><code is:raw="">
<span>const</span> <span>M</span> <span>=</span> <span>2</span> <span>**</span> <span>31</span><span>;</span> 
<span>const</span> <span>A</span> <span>=</span> <span>110351245</span><span>;</span>
<span>const</span> <span>C</span> <span>=</span> <span>12345</span><span>;</span>

<span>export</span> <span>function</span> <span>randomInt</span><span>(</span><span>seed</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span><span>A</span> <span>*</span> seed <span>+</span> <span>C</span><span>)</span> <span>%</span> <span>M</span><span>;</span>
<span>}</span>
</code></pre>
<p>I won’t go into the details of how this one works, but it’s using prime numbers to generate a pseudorandom sequence. And this implementation is a lot like the random number generator used by the C language. (Most implementations of it, anyway).</p>
<pre data-language="javascript"><code is:raw=""><span>import</span> <span>{</span> randomInt <span>}</span> <span>from</span> <span>&#39;./random&#39;</span><span>;</span>



<span>const</span> seed <span>=</span> <span>1093487523</span><span>;</span>
<span>const</span> randomValue1 <span>=</span> <span>randomInt</span><span>(</span>seed<span>)</span><span>;</span>
<span>const</span> randomValue2 <span>=</span> <span>randomInt</span><span>(</span>randomValue1<span>)</span><span>;</span>

</code></pre>
<p>Here’s how we use that function. To get a random number, we start with a seed. And this seed can be any integer. We pass that seed to our <code>randomInt()</code> function. And, once we’ve called that, we can get another pseudorandom value. We do that by passing the returned value to <code>randomInt()</code> again. And if we keep doing that, we can get as many pseudorandom numbers as I want. But, if we give it the same starting seed, I will always get the same sequence of integers.</p>
<pre data-language="javascript"><code is:raw=""><span>export</span> <span>function</span> <span>randomInRange</span><span>(</span><span>seed<span>,</span> n</span><span>)</span> <span>{</span>
  <span>const</span> nextSeed <span>=</span> <span>randomInt</span><span>(</span>seed<span>)</span><span>;</span>
  <span>const</span> randVal <span>=</span> Math<span>.</span><span>abs</span><span>(</span>nextSeed<span>)</span> <span>%</span> n<span>;</span>
  <span>return</span> <span>[</span>nextSeed<span>,</span> randVal<span>]</span><span>;</span>
<span>}</span>

</code></pre>
<p>For our purposes, though, we mostly want a random number in a range between 0 and some number. So we’ll use another helper. All it does is a bit of maths to make the random number fit the range we want. But, it also returns the raw integer, so we can use it as a seed for future generation.</p>
<p>With that in place, we’re now able to pick a starting room at random from the grid. And we can put that all into a single function that generates our initial state.</p>
<pre data-language="javascript"><code is:raw="">
<span>import</span> <span>{</span>Set<span>,</span> List<span>}</span> <span>from</span> <span>&#39;immutable&#39;</span><span>;</span>
<span>import</span> <span>{</span>randomInRange<span>}</span> <span>from</span> <span>&#39;./random.js&#39;</span><span>;</span>

<span>function</span> <span>buildInitialState</span><span>(</span><span>n<span>,</span> seed</span><span>)</span> <span>{</span>
  <span>const</span> emptyArray <span>=</span> <span>new</span> <span>Array</span><span>(</span>n <span>**</span> <span>2</span><span>)</span><span>.</span><span>fill</span><span>(</span><span>undefined</span><span>)</span><span>;</span>
  <span>const</span> roomList <span>=</span> emptyArray<span>.</span><span>map</span><span>(</span>
    <span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=&gt;</span> <span>[</span><span>point</span><span>(</span>i <span>%</span> n<span>,</span> Math<span>.</span><span>floor</span><span>(</span>i <span>/</span> n<span>)</span><span>)</span><span>,</span> <span>List</span><span>(</span><span>)</span><span>]</span>
  <span>)</span><span>;</span>
  <span>const</span> grid <span>=</span> <span>Map</span><span>(</span>roomList<span>)</span><span>;</span>

  <span>const</span> <span>[</span>newSeed<span>,</span> roomIdx<span>]</span> <span>=</span> <span>randomInRange</span><span>(</span>
    seed<span>,</span>
    n <span>**</span> <span>2</span>
  <span>)</span><span>;</span>
  <span>const</span> room <span>=</span> roomList<span>[</span>roomIdx<span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>

  <span>return</span> <span>[</span>room<span>,</span> grid<span>,</span> newSeed<span>]</span><span>;</span>
<span>}</span>

</code></pre>
<h2 id="recursion">Recursion</h2>
<p>We’re ready to code our actual algorithm. Now, we’re going to do this using recursion. And recursion has a bad reputation. People think it’s scary. One reason they think it’s scary is because it’s easy to accidentally cause infinite recursion. And that’s fair. I understand that. But I would argue that it’s just as easy to get yourself into a situation where you write a loop that never terminates.</p>
<p>You probably don’t do that, though, because you’ve been taught how to write loops safely. You’ve most likely been taught (or have taught yourself) two rules:</p>
<ol>
<li>Pay attention to the state you’re changing; and</li>
<li>Know the exit condition.</li>
</ol>
<pre data-language="javascript"><code is:raw=""><span>let</span> i <span>=</span> <span>10</span><span>;</span>
<span>while</span> <span>(</span>i <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
  
  i<span>--</span><span>;</span>
<span>}</span>

</code></pre>
<p>Suppose you’re writing a while loop, for example. One that repeats something 10 times. In that case, you make darn sure you’ve got some counter, <code>i</code> and that you decrement it each time around the loop. That counter <code>i</code> is the state we’re changing. It’s the thing we need to pay attention to.</p>
<p>And the exit condition is built in to while loops. In this case, <code>i &gt; 0</code>.</p>
<p>When we’re writing recursive algorithms, we pay attention to <em>the same things</em>. They simply happen to live in different locations.</p>
<ul>
<li>
<p>For a recursive function, the changing <strong>state</strong> always goes into the function parameters. (That is, assuming we’re working with pure functions). And if you need to update more pieces of state, then you’ll need more function parameters.</p>
</li>
<li>
<p>When we write a recursive function, we check our <strong>exit condition</strong> as early as possible. Much like how the exit condition is the first thing you write in a for-loop.</p>
</li>
</ul>
<h3 id="what-is-the-state-for-our-maze-algorithm">What is the state for our maze algorithm?</h3>
<p>Let’s apply this to our maze algorithm. What state do we update as we go through the process? We have three components:</p>
<ol>
<li><strong>The current room:</strong> At each step, we’re considering a particular room. And the room we’re considering changes, so that means it’s part of our state.</li>
<li><strong>The maze so far:</strong> Another thing we do as we go along is we update our maze by updating the list of rooms a given room is connected to.</li>
<li><strong>The random seed:</strong> And there’s one final piece of state that might not be obvious. That’s our random number seed. We pass that along to the next iteration of our algorithm. This allows it to continue generating random numbers.</li>
</ol>
<p>So we have enough here to create the signature for our <code>buildMaze()</code> function.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>
  
<span>}</span>

</code></pre>
<h2 id="step-2">Step 2</h2>
<p>We’re now all set up to create the initial state. So let’s figure out step 2 of our algorithm. That is, we want to make a list of adjacent rooms that aren’t yet connected. We’ll write a function to do that.</p>
<p>We start by creating some constants. One for each direction: <code>NORTH</code>, <code>SOUTH</code>, <code>EAST</code>, and <code>WEST</code>.</p>
<pre data-language="javascript"><code is:raw="">
<span>export</span> <span>const</span> <span>NORTH</span> <span>=</span> <span>point</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
<span>export</span> <span>const</span> <span>EAST</span> <span>=</span> <span>point</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>export</span> <span>const</span> <span>SOUTH</span> <span>=</span> <span>point</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>export</span> <span>const</span> <span>WEST</span> <span>=</span> <span>point</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>
</code></pre>
<p>And then we’ll create a helper function to add two points together:</p>
<pre data-language="javascript"><code is:raw="">
<span>export</span> <span>const</span> <span>addPoint</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=&gt;</span> <span>point</span><span>(</span>
  a<span>.</span>x <span>+</span> b<span>.</span>x<span>,</span>
  a<span>.</span>y <span>+</span> b<span>.</span>y
<span>)</span><span>;</span>
</code></pre>
<p>And with those in place, we can write a function to find unconnected adjacent rooms. We make an array of the four directions, and map over it with <code>addPoint()</code> to get all the adjacent rooms. Then we filter out the rooms that are already connected.</p>
<pre data-language="javascript"><code is:raw="">
<span>import</span> <span>{</span>point<span>,</span> <span>NORTH</span><span>,</span> <span>SOUTH</span><span>,</span> <span>EAST</span><span>,</span> <span>WEST</span><span>}</span> <span>from</span> <span>&#39;./point&#39;</span><span>;</span>

<span>function</span> <span>getCandidates</span><span>(</span><span>room<span>,</span> mazeSoFar</span><span>)</span> <span>{</span>
    <span>return</span> <span>[</span><span>NORTH</span><span>,</span> <span>SOUTH</span><span>,</span> <span>EAST</span><span>,</span> <span>WEST</span><span>]</span>
        <span>.</span><span>map</span><span>(</span><span>direction</span> <span>=&gt;</span> <span>addPoint</span><span>(</span>room<span>,</span> direction<span>)</span><span>)</span>
        <span>.</span><span>filter</span><span>(</span><span>(</span><span>pt</span><span>)</span> <span>=&gt;</span> mazeSoFar<span>.</span><span>get</span><span>(</span>pt<span>)</span><span>?.</span>size <span>===</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

</code></pre>
<p>We can then use that in our main function.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>

  
  <span>const</span> candidates <span>=</span> <span>getCandidates</span><span>(</span>room<span>,</span> mazeSoFar<span>)</span><span>;</span>
<span>}</span>

</code></pre>
<h2 id="step-3">Step 3</h2>
<p>Now, it might be that there are no unconnected rooms left adjacent to the current room. That means we’ve gone as far as we can along this path. We’ve reached our exit condition.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>

  
  <span>const</span> candidates <span>=</span> <span>getCandidates</span><span>(</span>room<span>,</span> mazeSoFar<span>)</span><span>;</span>
  <span>if</span> <span>(</span>candidates<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span> <span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<p>So, we’re now supposed to go back one room. In our case, that means we’ll return. But we don’t quite know what we need to return yet. We’ll come back and fill that in momentarily.</p>
<h2 id="step-4">Step 4</h2>
<p>We’ve completed the first three steps, and we’re now at step four.</p>
<p>We want to pick a room from the candidate list at random. That gives us a new seed that we’ll hold on to for now.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>

  
  <span>const</span> candidates <span>=</span> <span>getCandidates</span><span>(</span>room<span>,</span> mazeSoFar<span>)</span><span>;</span>
  <span>if</span> <span>(</span>candidates<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span> <span>;</span>
  <span>}</span>

  
  <span>const</span> <span>[</span>seed1<span>,</span> idx<span>]</span> <span>=</span> <span>randomInRange</span><span>(</span>
    seed0<span>,</span>
    candidates<span>.</span>length
  <span>)</span><span>;</span>
  <span>const</span> roomToConnect <span>=</span> candidates<span>[</span>idx<span>]</span><span>;</span>
<span>}</span>

</code></pre>
<p>So, we now know which room to move on to next. We connect two rooms by updating our <code>Map</code>, pushing each room onto the list. And we move on to the next room by calling our <code>buildMaze()</code> function recursively. We just have to make sure that we update each piece of state that we pass on. And again, we still need to figure out that return value.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>
  
  

  
  <span>const</span> mazeWithConnectedRoom <span>=</span> mazeSoFar
    <span>.</span><span>set</span><span>(</span>room<span>,</span> mazeSoFar<span>.</span><span>get</span><span>(</span>room<span>)</span><span>.</span><span>push</span><span>(</span>newRoom<span>)</span><span>)</span>
    <span>.</span><span>set</span><span>(</span>newRoom<span>,</span> mazeSoFar<span>.</span><span>get</span><span>(</span>newRoom<span>)</span><span>.</span><span>push</span><span>(</span>room<span>)</span><span>)</span><span>;</span>

  
  <span>const</span> someReturnValueWeHaventFiguredOut <span>=</span> <span>buildMaze</span><span>(</span>
    roomToConnect<span>,</span>
    mazeWithConnectedRoom<span>,</span>
    seed1
  <span>)</span><span>;</span>
<span>}</span>
</code></pre>
<h2 id="what-do-we-do-when-we-get-back">What do we do when we get back?</h2>
<p>When we call <code>buildMaze()</code>, our algorithm starts to connect a bunch of rooms in a long branch off this current room. But, there’s a chance that when it comes back, there still might be unconnected rooms adjacent to this one. So, we make <em>another</em> recursive call, but pass <em>the same room</em> to try out the remaining candidates.</p>
<p>However, when we call the recursive function, we need to make sure we update the state. And for that, we need the previous call to tell us what the new state should be. In particular, we need 2 things:</p>
<ol>
<li>The updated maze.</li>
<li>A new random seed.</li>
</ol>
<p>This list tells us what our return value from the function needs to be. Each time we call <code>buildMaze()</code> we will have to pass back each of these two values.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>
  
  

  
  <span>const</span> mazeWithConnectedRoom <span>=</span> mazeSoFar
    <span>.</span><span>set</span><span>(</span>room<span>,</span> mazeSoFar<span>.</span><span>get</span><span>(</span>room<span>)</span><span>.</span><span>push</span><span>(</span>newRoom<span>)</span><span>)</span>
    <span>.</span><span>set</span><span>(</span>newRoom<span>,</span> mazeSoFar<span>.</span><span>get</span><span>(</span>newRoom<span>)</span><span>.</span><span>push</span><span>(</span>room<span>)</span><span>)</span><span>;</span>
  
  
  <span>const</span> <span>[</span>newMaze<span>,</span> seed2<span>]</span> <span>=</span> <span>buildMaze</span><span>(</span>
    roomToConnect<span>,</span>
    mazeWithConnectedRoom<span>,</span>
    seed1
  <span>)</span><span>;</span>
  
  
  
  <span>return</span> <span>buildMaze</span><span>(</span>room<span>,</span> newMaze<span>,</span> seed2<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>So we fill in those return values. And with those in place, we can make the final recursive call.</p>
<pre data-language="javascript"><code is:raw="">
<span>function</span> <span>buildMaze</span><span>(</span><span>room<span>,</span> mazeSoFar<span>,</span> seed0</span><span>)</span> <span>{</span>

  
  <span>const</span> candidates <span>=</span> <span>getCandidates</span><span>(</span>room<span>,</span> unconnected<span>)</span><span>;</span>
  <span>if</span> <span>(</span>candidates<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span> <span>[</span>mazeSoFar<span>,</span> seed0<span>]</span><span>;</span>
  <span>}</span>

  
  <span>const</span> <span>[</span>seed1<span>,</span> idx<span>]</span> <span>=</span> <span>randomInRange</span><span>(</span>
    seed0<span>,</span>
    candidates<span>.</span>length
  <span>)</span><span>;</span>

  
  <span>const</span> mazeWithConnectedRoom <span>=</span> mazeSoFar
    <span>.</span><span>set</span><span>(</span>room<span>,</span> mazeSoFar<span>.</span><span>get</span><span>(</span>room<span>)</span><span>.</span><span>push</span><span>(</span>newRoom<span>)</span><span>)</span>
    <span>.</span><span>set</span><span>(</span>newRoom<span>,</span> mazeSoFar<span>.</span><span>get</span><span>(</span>newRoom<span>)</span><span>.</span><span>push</span><span>(</span>room<span>)</span><span>)</span><span>;</span>
  
  
  <span>const</span> <span>[</span>newMaze<span>,</span> seed2<span>]</span> <span>=</span> <span>buildMaze</span><span>(</span>
    roomToConnect<span>,</span>
    mazeWithConnectedRoom<span>,</span>
    seed1
  <span>)</span><span>;</span>
  
  
  
  <span>return</span> <span>buildMaze</span><span>(</span>room<span>,</span> newMaze<span>,</span> seed2<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>Once we sort out the other return values, then that’s it. We have everything necessary to build our maze.</p>
<h2 id="wiring-it-all-together">Wiring it all together</h2>
<p>All we need to do is wire it up with the initial state. We’ll do that in a new function.</p>
<pre data-language="javascript"><code is:raw="">
<span>export</span> <span>function</span> <span>maze</span><span>(</span><span>n<span>,</span> seed0</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>room<span>,</span> emptyMaze<span>,</span> seed1<span>]</span> <span>=</span> <span>buildInitialState</span><span>(</span>n<span>,</span> seed0<span>)</span><span>;</span>
  <span>const</span> <span>[</span>maze<span>]</span> <span>=</span> <span>buildMaze</span><span>(</span>room<span>,</span> emptyMaze seed1<span>)</span><span>;</span>
  <span>return</span> maze<span>;</span>
<span>}</span>
</code></pre>
<p>We craft the initial state, then we build our maze and return it.</p>
<h2 id="demo">Demo</h2>
<p>And putting that all together, we get something like the following demo. If you have JavaScript enabled, try it out.</p>

<h2 id="rendering">Rendering</h2>
<p>Now, all we’ve done so far is to create a map of point objects. We haven’t talked at all about how we render it. And the beauty of the web platform is that we have so many options. But there’s a lot to discuss there, so I’ve broken that out into a separate article.</p>
<h2 id="so-what">So what?</h2>
<p>Is this the most performant way to create a maze?</p>
<p>No.</p>
<p>Is this the most memory-efficient way to create a maze?</p>
<p>No.</p>
<p>Why bother with all this, then? Why muck around with recursion and immutable data structures?</p>
<p>Two reasons.</p>
<ol>
<li>
<p><strong>Because it helps you think differently</strong></p>
</li>
<li>
<p><strong>Because it’s fun</strong></p>
</li>
</ol>
 
  </div></div>
  </body>
</html>
