<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.akpain.net/blog/breaking-secnet-assignments/">Original</a>
    <h1>Breaking My Security Assignments</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p>This post was first written in March 2024, but at the time, I was asked not to publish it for reasons that will shortly become apparent. Circumstances have changed since, so I&#39;ve gone ahead and published it now with some minor alterations.</p>
</div>

<p>For the assignments in my security module this semester, we&#39;ve been given a barebones virtual machine that we install updates into and complete assignments on. When each new assignment is released, we get given a file to download and run with this preinstalled piece of software on the VM. This sets the assignment up for us and from there we go on to solve it to get a token that can be submitted, <a href="https://ctftime.org/ctf-wtf">capture-the-flag style</a>. These files aren&#39;t any obviously readable type of file - they mostly look like garbage data.</p>
<p>But without that update file, there&#39;s no trace of the assignment on the system anywhere - which also means that those update files must contain the tokens we ned to submit and the VM must somehow be able to decrypt them... so surely we can break that for our own advantage?</p>
<h2 id="toc_1">Cracking Open the Updates</h2>
<p>Having decided that I wanted to attack this the VM to try and pull out tokens without doing exercises, the first thing I turned my attention to was <code>installUpdate</code> - the program that was left on the VM for us to use to install updates. Every update file that we were given took the form <code>*.gpg</code>, so (working on the assumption that these are encrypted blobs) the logical thing to do would be to take a poke around this executable to see if there&#39;s any way to decipher how these updates are decrypted.</p>
<p>After getting <code>installUpdate</code> on my machine and checking that it wasn&#39;t a Bash script, I ran <code>strings</code> on it was greeted with an immediate goldmine:</p>
<pre><code>$ strings installUpdate
...
/usr/bin/gpg --homedir /root/.gnupg --batch --pinentry-mode loopback --passphrase-file /root/.vmPassphrase --output %s/update.tgz --decrypt %s/updateArchive.gpg &gt; /dev/null 2&gt;&amp;1
...
/usr/bin/tar zxf update.tgz &gt; /dev/null 2&gt;&amp;1
...
</code></pre>
<p>Great! It looks like the update files are GPG encrypted tarballs. The decryption command references a <code>/root/.vmPassphrase</code> file, as well as <code>/root/.gnupg</code> that presumedly stores some keys, so it&#39;s probably a safe bet that we need both of those to do decryption.</p>
<p>In the VM, we don&#39;t have root so I can&#39;t just boot the VM and grab the password - but I can mount its virtual disk on my local machine. Since I&#39;m using QEMU to run the VM, I can do that using these instructions: <a href="https://unix.stackexchange.com/a/598265">https://unix.stackexchange.com/a/598265</a></p>
<p>The magical powers of having root on my own computer means that I can make a local copy of the VM&#39;s <code>/root</code> directory change the permissions of everything inside to be something a little more open.</p>
<p>With the directory in hand, some fiddling with some of the arguments in the above GPG command gives me something I can use to decrypt myself a tarball:</p>
<pre><code>$ gpg --homedir root-copy/.gnupg --batch --pinentry-mode loopback --passphrase-file root-copy/.vmPassphrase --output update.tgz --decrypt ex3/update_ex3.gpg
gpg: WARNING: unsafe permissions on homedir &#39;/media/akp/Data/Uni/S+N/root-copy/.gnupg&#39;
gpg: encrypted with 3072-bit RSA key, ID 57ABAFF0A7DE8CC8, created 2024-01-11
      &#34;************** (Encryption key for SecNet VMs) &lt;*****@bham.ac.uk&gt;&#34;
gpg: Signature made Thu 15 Feb 2024 13:12:56 GMT
gpg:                using RSA key E18EFB226702A6240F9E9A150985CE5D508F4DAE
gpg:                issuer &#34;*****@bham.ac.uk&#34;
gpg: Good signature from &#34;&#34;************** (Signing key for SecNet VMs) &lt;*****@bham.ac.uk&gt;&#34; [ultimate]
gpg:                 aka &#34;&#34;************** &lt;*****@bham.ac.uk&gt;&#34; [ultimate]
</code></pre>
<p>!!!!</p>
<h2 id="toc_2">Digging Around Inside</h2>
<p>Once we extract the tarball, we&#39;re met with a few directories - the actual names of the directories vary a little bit from exercise to exercise but at the very least, they all contain a <code>bin</code> directory and a <code>java</code> directory.</p>
<p>As far as I can tell, each update has an &#34;entrypoint&#34; in the form of a shell script called <code>bin/updateVM</code> that copies and uses files in the other directories of the archive (though I can&#39;t tell if any of these directories have special meaning since I&#39;ve not put any time into reversing the <code>installUpdate</code> binary).</p>
<p>Much of the time, the entrypoint script compiles and runs some Java code from the <code>java</code> directory. Typically there are two files present - one file always named in the form <code>GenTokenEx\d_2023.java</code> and another just called <code>Keys.java</code>. Since this is just source code, a cursory poke around reveals that these files handle on-the-fly generation and installation of tokens as required by the exercises.</p>
<p>Some update files also reference a mysterious <code>systemd</code> service called <code>tokens</code> and, quite frankly, I can&#39;t work out why it exists. Closer inspection of the shell script that it runs shows that&#39;s it&#39;s a mechanism to <em>run</em> the Java code included in update archives, but it&#39;s also only used by (so far) 1 of 3 exercises, with the rest opting to directly run the token generation code in the entrypoint script.</p>
<h2 id="toc_3">Understanding the Token Format</h2>
<p>Most of the Java code that&#39;s included in the update files has roughly the same format. Along the exercise-specific setup code, they all include a function called <code>genToken</code> that looks a little something like this, here shown in a tidied up form that has a little context as well:</p>
<div><pre><span></span><code><span>public</span><span> </span><span>class</span> <span>GenTokenEx2_2023</span><span> </span>{
<span>  </span><span>static</span><span> </span>String<span> </span>moduleKey<span> </span><span>=</span><span> </span>Keys2023.<span>getModuleKey</span>();
<span>  </span><span>static</span><span> </span>SecureRandom<span> </span>random<span> </span><span>=</span><span> </span><span>new</span><span> </span>SecureRandom();
<span>  </span><span>static</span><span> </span>String<span> </span>randomString;

<span>  </span><span>public</span><span> </span><span>static</span><span> </span><span>void</span><span> </span><span>main</span>(String<span>[]</span><span> </span>paramArrayOfString)<span> </span><span>throws</span><span> </span>Exception<span> </span>{
<span>    </span><span>int</span><span> </span>i<span> </span><span>=</span><span> </span><span>11</span>;
<span>    </span>String<span> </span>str<span> </span><span>=</span><span> </span><span>new</span><span> </span>BigInteger(<span>88</span>,<span> </span>random).<span>toString</span>(<span>36</span>);
<span>    </span>randomString<span> </span><span>=</span><span> </span>str.<span>substring</span>(<span>0</span>,<span> </span>i);
<span>    </span><span>// [trimmed]</span>
<span>    </span><span>byte</span><span>[]</span><span> </span>tokenPart1<span> </span><span>=</span><span> </span>genToken(<span>&#34;Ex21&#34;</span>);
<span>    </span><span>byte</span><span>[]</span><span> </span>tokenPart2<span> </span><span>=</span><span> </span>genToken(<span>&#34;Ex22&#34;</span>);
<span>  </span>}

<span>  </span><span>private</span><span> </span><span>static</span><span> </span><span>byte</span><span>[]</span><span> </span><span>genToken</span>(String<span> </span>paramString)<span> </span><span>throws</span><span> </span>Exception<span> </span>{
<span>    </span>String<span> </span>str<span> </span><span>=</span><span> </span>paramString<span> </span><span>+</span><span> </span>randomString;
<span>    </span>SecretKeySpec<span> </span>localSecretKeySpec<span> </span><span>=</span><span> </span><span>new</span><span> </span>SecretKeySpec(hexStringToByteArray(moduleKey),<span> </span><span>&#34;AES&#34;</span>);
<span>    </span>Cipher<span> </span>localCipher<span> </span><span>=</span><span> </span>Cipher.<span>getInstance</span>(<span>&#34;AES&#34;</span>);
<span>    </span>localCipher.<span>init</span>(<span>1</span>,<span> </span>localSecretKeySpec);
<span>    </span><span>return</span><span> </span>localCipher.<span>doFinal</span>(str.<span>getBytes</span>());
<span>  </span>}

<span>  </span><span>private</span><span> </span><span>static</span><span> </span>String<span> </span><span>byteArrayToHexString</span>(<span>byte</span><span>[]</span><span> </span>paramArrayOfByte)<span> </span>{
<span>    </span><span>// [trimmed]</span>
<span>  </span>}

<span>  </span><span>private</span><span> </span><span>static</span><span> </span><span>byte</span><span>[]</span><span> </span><span>hexStringToByteArray</span>(String<span> </span>paramString)<span> </span>{
<span>    </span><span>// [trimmed]</span>
<span>  </span>}
}
</code></pre></div>
<p>This is all fairly self-explainatory - when the program starts, a random number is generated, converted to hexadecimal and the first 11 characters are retained. This sequence is then combined with a unique identifier for each exercise to form a 15 character long string that is AES encrypted using a &#34;module key&#34; (which is a key that&#39;s used for all token submissions across every exercise and is included in the <code>Keys.java</code> file). The exercise identifiers always start with <code>Ex</code> then contain a single digit each to represent the assignment number and exercise number (eg. exercise 2 part 1 is <code>Ex21</code>, exercise 3 part 2 is <code>Ex32</code>, exercise 1 part 1 is <code>Ex11</code>, etc.).</p>
<p>All-in, the raw body of a token looks like this:</p>
<p><img loading="lazy" src="https://www.akpain.net/blog/breaking-secnet-assignments/tokenlayout.png" alt="Diagram of a token&#39;s layout, byte by byte"/></p>
<p>The encrypted payload is hex encoded and then used by the rest of the Java code to set up the assignment. This scheme means that everyone has different tokens so token sharing can be detected, and these tokens can be submitted to a custom-built website that gives instant feedback on if they&#39;re correct or not.</p>
<p>So, armed with this knowledge and the source code, it&#39;s trivially simple to comment out some sections, add one or two new lines calling <code>genToken</code> with the right exercise identifier and you have a working token in-hand. This happens to be how I (somewhat inadvisably) ended up being the first person to submit their tokens for an exercise - taking literally about 45 minutes to &#34;complete&#34; quite a complex assignment that later took me about 4 hours to complete.</p>
<p><img loading="lazy" src="https://www.akpain.net/blog/breaking-secnet-assignments/firstsubmitwhoopsies.png" alt="Screenshot of a text conversation where one the module TAs tells me that I was the first to submit the assignment"/></p>
<h2 id="toc_4">How This Could Be Prevented</h2>
<p>This entire attack was possible because I have the VM&#39;s disk image right here on my computer and I can do absolutely whatever I want to it, such as overriding its access control settings.</p>
<p>Within the aims of the module this is fine - this is an introuction to security module so if you can exploit it like this, you&#39;re not really the target audience and you&#39;ve already achieved the aims of the module.</p>
<p>That said, if we&#39;re trying to make this attack impossible, something like hosting a remote VM for each student enrolled on the module that could be accessed only via SSH. This way, with appropriate access control measures, there&#39;d be no way to dump secrets from <code>/root</code> short of a kernel bug. Realistically though, hosting 330 VMs like that would never fly - it&#39;s simply too expensive and time-consuming versus the benefit gained.</p>
<div>
<p>Comment from the future: bad predictions aside, that&#39;s exactly what they&#39;re now doing - giving each student their own VM to do the exercises on, properly.</p>
</div>

<h2 id="toc_5">To Sum Up</h2>
<p>This was fun a fun little thing to meddle with for a while, but ultimately a pointless exercise. This isn&#39;t going to save me any time - I still need to do the assignments because they&#39;re assignments for a University module, which is supposed to teach me things. If I don&#39;t do the assignments and effectively cheat by submitting tokens I recover this way, <strong>I personally will suffer</strong> and not know what I&#39;m doing in enough detail when it comes to the final exam and just generally will lack this knowledge that might be useful in future.</p>
<hr/>

</div></div>
  </body>
</html>
