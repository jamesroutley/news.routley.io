<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/">Original</a>
    <h1>An Interactive Intro to CRDTs</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-rnrqlda2="">
<p>Have you heard about CRDTs and wondered what they are? Maybe you’ve looked into them a bit, but ran into a wall of academic papers and math jargon? That was me before I started my <a href="https://www.recurse.com/" data-astro-cid-bi7aps5f="">Recurse Center</a><a data-tooltip="" href="https://www.recurse.com/" data-astro-cid-bi7aps5f=""><img src="https://d29xw0ra2h4o4u.cloudfront.net/assets/logo_square-60e12570c3a1b0b0798e651a0755f71a40ff15421761b786f720e4c02fc89a1f.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">The Recurse Center</span><span data-astro-cid-bi7aps5f="">The Recurse Center is a self-directed, community-driven educational retreat for programmers in New York City.</span><span data-astro-cid-bi7aps5f=""><img src="https://d29xw0ra2h4o4u.cloudfront.net/assets/favicon-fbfd4d3b58909892b7caada24c507292a4f96f5ab03fda9a7ae3050ce4618f78.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">www.recurse.com/</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> batch. But I’ve spent the past month or so doing research and writing code, and it turns out that you can build a lot with just a few simple things!</p>
<p>In this two-part series, we’ll learn what a CRDT is. Then we’ll write a primitive CRDT, compose it into more complex data structures, and finally use what we’ve learned to build a collaborative pixel art editor. All of this assumes no prior knowledge about CRDTs, and only a rudimentary knowledge of TypeScript.</p>
<p>To pique your curiosity, this is what we’ll end up with:</p>
<pixelart-demo resolution="100"></pixelart-demo>

<p>Draw by clicking and dragging with your mouse. Change the paint color by using the color input on the bottom left. You can draw on either canvas and your changes will show up on the other, as if they were collaborating on the same picture.</p>
<p>Clicking the network button prevents changes from reaching the other canvas (although they’ll sync up again when they come back “online”). The latency slider adds a delay before changes on one canvas show up on the other.</p>
<p>We’ll build that in the next post. First, we need to learn about CRDTs!</p>
<h3 id="what-is-a-crdt">What is a CRDT?</h3>
<p>Okay, let’s start from the top. CRDT stands for “Conflict-free Replicated Data Type”. That’s a long acronym, but the concept isn’t too complicated. It’s a kind of data structure that can be stored on different computers (peers). Each peer can update its own state instantly, without a network request to check with other peers. Peers may have different states at different points in time, but are guaranteed to eventually converge on a single agreed-upon state. That makes CRDTs great for building rich collaborative apps, like Google Docs and Figma — without requiring a central server to sync changes.</p>
<p>Broadly, there are two kinds of CRDTs: state-based and operation-based.<sup><a href="#user-content-fn-cvrdt" id="user-content-fnref-cvrdt" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup> State-based CRDTs transmit their full state between peers, and a new state is obtained by merging all the states together. Operation-based CRDTs transmit only the actions that users take, which can be used to calculate a new state.</p>
<p>That might make operation-based CRDTs sound way better. For example, if a user updates one item in a list, an operation-based CRDT can send a description of only that update, while a state-based CRDT has to send the whole list! The drawback is that operation-based CRDTs impose constraints on the communication channel: messages must be delivered exactly once, in causal order, to each peer.<sup><a href="#user-content-fn-delta" id="user-content-fnref-delta" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup></p>
<p>This post will exclusively focus on on state-based CRDTs. For brevity, I’ll just say “CRDTs” from here on out, but know that I’m referring specifically to state-based CRDTs.</p>
<p>I’ve been talking about what CRDTs do, but what <strong>is</strong> a CRDT? Let’s make it concrete: a CRDT is any data structure that implements this interface:<sup><a href="#user-content-fn-ackshually" id="user-content-fnref-ackshually" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup></p>
<pre><code><span>interface</span> <span><span>CRDT</span><span>&lt;</span><span>T</span><span>,</span> <span>S</span><span>&gt;</span></span> <span>{</span>
  value<span>:</span> <span>T</span><span>;</span>
  state<span>:</span> <span>S</span><span>;</span>
  <span>merge</span><span>(</span>state<span>:</span> <span>S</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span></code></pre>
<p>That is to say, a CRDT contains at least three things:</p>
<ul>
<li>A value, <code>T</code>. This is the part the rest of our program cares about. The entire point of the CRDT is to reliably sync the value between peers.</li>
<li>A state, <code>S</code>. This is the metadata needed for peers to agree on the same value. To update other peers, the whole state is serialized and sent to them.</li>
<li>A merge function. This is a function that takes some state (probably received from another peer) and merges it with the local state.</li>
</ul>
<p>The merge function must satisfy three properties to ensure that all peers arrive at the same result (I’ll use the notation <code>A ∨ B</code> to indicate merging state <code>A</code> into state <code>B</code>):</p>
<ul>
<li>Commutativity: states can be merged in any order; <code>A ∨ B = B ∨ A</code>. If Alice and Bob exchange states, they can each merge the other’s state into their own and arrive at the same result.</li>
<li>Associativity: when merging three (or more) states, it doesn’t matter which are merged first; <code>(A ∨ B) ∨ C = A ∨ (B ∨ C)</code>. If Alice receives states from both Bob and Carol, she can merge them into her own state in any order and the result will be the same.<sup><a href="#user-content-fn-thesamepicture" id="user-content-fnref-thesamepicture" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">4</a></sup></li>
<li>Idempotence: merging a state with itself doesn’t change the state; <code>A ∨ A = A</code>. If Alice merges her own state with itself, the result will be the same state she started with.</li>
</ul>
<p>Mathematically proving that a merge function has all these properties might sound hard. But luckily, we don’t have to do that! Instead, we can just combine CRDTs that already exist, leaning on the fact that someone has proven these things for us.</p>
<p>Speaking of CRDTs that already exist: let’s learn about one!</p>
<h3 id="last-write-wins-register">Last Write Wins Register</h3>
<p>A register is a CRDT that holds a single value. There are a couple kinds of registers, but the simplest is the Last Write Wins Register (or LWW Register).</p>
<p>LWW Registers, as the name suggests, simply overwrite their current value with the last value written. They determine which write occurred last using timestamps, represented here by integers that increment whenever the value is updated.<sup><a href="#user-content-fn-logical" id="user-content-fnref-logical" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">5</a></sup> Here’s the algorithm:</p>
<ul>
<li>If the received timestamp is less than the local timestamp, the register doesn’t change its state.</li>
<li>If the received timestamp is greater than the local timestamp, the register overwrites its local value with the received value. It also stores the received timestamp and some sort of identifier unique to the peer that last wrote the value (the peer ID).</li>
<li>Ties are broken by comparing the local peer ID to the peer ID in the received state.</li>
</ul>
<p>Try it out with the playground below.</p>
<lwwregister-demo></lwwregister-demo>

<p>Did you get a sense for how LWW Registers work? Here are a couple specific scenarios to try:</p>
<ul>
<li>Turn the network off, make a bunch of updates to <code>bob</code>, and then turn it back on. When you send updates from <code>alice</code>, they’ll be rejected until the timestamp exceeds <code>bob</code>’s timestamp.</li>
<li>Perform the same setup, but once you turn the network back on, send an update from <code>bob</code> to <code>alice</code>. Notice how the timestamps are now synced up and <code>alice</code> can write to <code>bob</code> again!</li>
<li>Increase the latency and send an update from both peers simultaneously. <code>alice</code> will accept <code>bob</code>’s update, but <code>bob</code> will reject <code>alice</code>‘s. Since <code>bob</code>’s peer ID is greater, it breaks the timestamp tie.</li>
</ul>
<p>Here’s the code for the LWW Register:</p>
<pre><code><span>class</span> <span>LWWRegister<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>{</span>
  <span>readonly</span> id<span>:</span> <span>string</span><span>;</span>
  state<span>:</span> <span>[</span>peer<span>:</span> <span>string</span><span>,</span> timestamp<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>]</span><span>;</span>

  <span>get</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>state<span>[</span><span>2</span><span>]</span><span>;</span>
  <span>}</span>

  <span>constructor</span><span>(</span>id<span>:</span> <span>string</span><span>,</span> state<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>,</span> <span>T</span><span>]</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
    <span>this</span><span>.</span>state <span>=</span> state<span>;</span>
  <span>}</span>

  <span>set</span><span>(</span>value<span>:</span> <span>T</span><span>)</span> <span>{</span>
    
    <span>this</span><span>.</span>state <span>=</span> <span>[</span><span>this</span><span>.</span>id<span>,</span> <span>this</span><span>.</span>state<span>[</span><span>1</span><span>]</span> <span>+</span> <span>1</span><span>,</span> value<span>]</span><span>;</span>
  <span>}</span>

  <span>merge</span><span>(</span>state<span>:</span> <span>[</span>peer<span>:</span> <span>string</span><span>,</span> timestamp<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>]</span><span>)</span> <span>{</span>
    <span>const</span> <span>[</span>remotePeer<span>,</span> remoteTimestamp<span>]</span> <span>=</span> state<span>;</span>
    <span>const</span> <span>[</span>localPeer<span>,</span> localTimestamp<span>]</span> <span>=</span> <span>this</span><span>.</span>state<span>;</span>

    
    <span>if</span> <span>(</span>localTimestamp <span>&gt;</span> remoteTimestamp<span>)</span> <span>return</span><span>;</span>

    
    <span>if</span> <span>(</span>localTimestamp <span>===</span> remoteTimestamp <span>&amp;&amp;</span> localPeer <span>&gt;</span> remotePeer<span>)</span> <span>return</span><span>;</span>

    
    <span>this</span><span>.</span>state <span>=</span> state<span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>Let’s see how this stacks up to the CRDT interface:</p>
<ul>
<li><code>state</code> is a tuple of the peer ID that last wrote to the register, the timestamp of the last write and the value stored in the register.</li>
<li><code>value</code> is simply the last element of the <code>state</code> tuple.</li>
<li><code>merge</code> is a method that implements the algorithm described above.</li>
</ul>
<p>LWW Registers have one more method named <code>set</code>, which is called locally to set the register’s value. It also updates the local metadata, recording the local peer ID as the last writer and incrementing the local timestamp by one.</p>
<p>That’s it! Although it appears simple, the humble LWW Register is a powerful building block with which we can create actual applications.</p>
<h3 id="last-write-wins-map">Last Write Wins Map</h3>
<p>Most programs involve more than one value,<sup><a href="#user-content-fn-citation" id="user-content-fnref-citation" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">6</a></sup> which means we’ll need a more complex CRDT than the LWW Register. The one we’ll learn about today is called the Last Write Wins Map (or LWW Map).</p>
<p>Let’s start by defining a couple types. First, our value type:</p>
<pre><code><span>type</span> <span>Value<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>=</span> <span>{</span>
  <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> <span>T</span><span>;</span>
<span>}</span><span>;</span></code></pre>
<p>If each individual map value holds type <code>T</code>, then the value of the entire LWW Map is a mapping of string keys to <code>T</code> values.</p>
<p>Here’s our state type:</p>
<pre><code><span>type</span> <span>State<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>=</span> <span>{</span>
  <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> LWWRegister<span>&lt;</span><span>T</span> <span>|</span> <span>null</span><span>&gt;</span><span>[</span><span>&#34;state&#34;</span><span>]</span><span>;</span>
<span>}</span><span>;</span></code></pre>
<p>Do you see the trick? From our application’s perspective, the LWW Map just holds normal values — but <strong>it actually holds LWW Registers</strong>. When we look at the full state, each key’s state is the state of the LWW Register at that key.<sup><a href="#user-content-fn-null" id="user-content-fnref-null" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">7</a></sup></p>
<p>I want to pause on that for a moment, because it’s important. Composition lets us combine primitive CRDTs into more complex ones. When it’s time to merge, all the parent does is pass slices of incoming state to the appropriate child’s merge function. We can nest this process as many times as we want; each complex CRDT passing ever-smaller slices of state down to the next level, until we finally hit a primitive CRDT that performs the actual merge.</p>
<p>From this perspective, the LWW Map merge function is simple: iterate through each key and hand off the incoming state at that key to the corresponding LWW Register to merge. Try it out in the playground below:</p>
<lwwmap-demo add="off" delete="off" state="{ &#34;foo&#34;: [&#34;alice&#34;, 1, &#34;lorem ipsum&#34;], &#34;bar&#34;: [&#34;bob&#34;, 1, &#34;dolor sit amet&#34;] }"></lwwmap-demo>

<p>It’s kind of difficult to trace what’s happening here, so let’s split up the state for each key. Note, though, that this is just a visualization aid; the full state is still being transmitted as a single unit.</p>
<p>Try increasing the latency and then updating different keys on each peer. You’ll see that each peer accepts the updated value with a higher timestamp, while rejecting the value with a lower timestamp.</p>
<lwwmap-demo split="true" add="off" delete="off" state="{ &#34;foo&#34;: [&#34;alice&#34;, 1, &#34;lorem ipsum&#34;], &#34;bar&#34;: [&#34;bob&#34;, 1, &#34;dolor sit amet&#34;] }"></lwwmap-demo>

<p>The full LWW Map class is kinda beefy, so let’s go through each property one by one. Here’s the start of it:</p>
<pre><code><span>class</span> <span>LWWMap<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>{</span>
  <span>readonly</span> id <span>=</span> <span>&#34;&#34;</span><span>;</span>
  #data <span>=</span> <span>new</span> <span>Map<span>&lt;</span><span>string</span><span>,</span> LWWRegister<span>&lt;</span><span>T</span> <span>|</span> <span>null</span><span>&gt;&gt;</span></span><span>(</span><span>)</span><span>;</span>

  <span>constructor</span><span>(</span>id<span>:</span> <span>string</span><span>,</span> state<span>:</span> State<span>&lt;</span><span>T</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>id <span>=</span> id<span>;</span>

    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> register<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>state<span>)</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>new</span> <span>LWWRegister</span><span>(</span><span>this</span><span>.</span>id<span>,</span> register<span>)</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre>
<p><code>#data</code> is a private property holding a map of the keys to LWW Register instances. To instantiate a LWW Map with preexisting state, we need to iterate through the state and instantiate each LWW Register.</p>
<p>Remember, CRDTs need three properties: <code>value</code>, <code>state</code> and <code>merge</code>. We’ll look at <code>value</code> first:</p>
<pre><code>  <span>get</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> value<span>:</span> Value<span>&lt;</span><span>T</span><span>&gt;</span> <span>=</span> <span>{</span><span>}</span><span>;</span>

    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> register<span>]</span> <span>of</span> <span>this</span><span>.</span>#data<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>register<span>.</span>value <span>!==</span> <span>null</span><span>)</span> value<span>[</span>key<span>]</span> <span>=</span> register<span>.</span>value<span>;</span>
    <span>}</span>

    <span>return</span> value<span>;</span>
  <span>}</span></code></pre>
<p>It’s a getter that iterates through the keys and gets each register’s <code>value</code>. As far as the rest of the app is concerned, it’s just normal map!</p>
<p>Now let’s look at <code>state</code>:</p>
<pre><code>  <span>get</span> <span>state</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> state<span>:</span> State<span>&lt;</span><span>T</span><span>&gt;</span> <span>=</span> <span>{</span><span>}</span><span>;</span>

    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> register<span>]</span> <span>of</span> <span>this</span><span>.</span>#data<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>register<span>)</span> state<span>[</span>key<span>]</span> <span>=</span> register<span>.</span>state<span>;</span>
    <span>}</span>

    <span>return</span> state<span>;</span>
  <span>}</span></code></pre>
<p>Similar to <code>value</code>, it’s a getter that builds up a map from each register’s <code>state</code>.</p>
<p>There’s a clear trend here: iterating through the keys in <code>#data</code> and handing things off to the register stored at that key. You’d think <code>merge</code> would work the same way, but it’s a little more involved:</p>
<pre><code>  <span>merge</span><span>(</span>state<span>:</span> State<span>&lt;</span><span>T</span><span>&gt;</span><span>)</span> <span>{</span>
    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> remote<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>state<span>)</span><span>)</span> <span>{</span>
      <span>const</span> local <span>=</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>

      
      <span>if</span> <span>(</span>local<span>)</span> local<span>.</span><span>merge</span><span>(</span>remote<span>)</span><span>;</span>
      
      <span>else</span> <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>new</span> <span>LWWRegister</span><span>(</span><span>this</span><span>.</span>id<span>,</span> remote<span>)</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span></code></pre>
<p>First, we iterate through the incoming <code>state</code> parameter rather than the local <code>#data</code>. That’s because if the incoming state is missing a key that <code>#data</code> has, we know that we don’t need to touch that key.<sup><a href="#user-content-fn-delete" id="user-content-fnref-delete" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">8</a></sup></p>
<p>For each key in the incoming state, we get the local register at that key. If we find one, the peer is <strong>updating</strong> an existing key that we already know about, so we call that register’s <code>merge</code> method with the incoming state at that key. Otherwise, the peer has <strong>added</strong> a new key to the map, so we instantiate a new LWW Register using the incoming state at that key.</p>
<p>In addition to the CRDT methods, we need to implement methods more commonly found on maps: <code>set</code>, <code>get</code>, <code>delete</code> and <code>has</code>.</p>
<p>Let’s start with <code>set</code>:</p>
<pre><code>  <span>set</span><span>(</span>key<span>:</span> <span>string</span><span>,</span> value<span>:</span> <span>T</span><span>)</span> <span>{</span>
    
    <span>const</span> register <span>=</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>

    
    <span>if</span> <span>(</span>register<span>)</span> register<span>.</span><span>set</span><span>(</span>value<span>)</span><span>;</span>
    
    <span>else</span> <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>new</span> <span>LWWRegister</span><span>(</span><span>this</span><span>.</span>id<span>,</span> <span>[</span><span>this</span><span>.</span>id<span>,</span> <span>1</span><span>,</span> value<span>]</span><span>)</span><span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>Just like in the merge method, we’re either calling the register’s <code>set</code> to update an existing key, or instantiating a new LWW Register to add a new key. The initial state uses the local peer ID, a timestamp of 1 and the value passed to <code>set</code>.</p>
<p><code>get</code> is even simpler:</p>
<pre><code>  <span>get</span><span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>?.</span>value <span>??</span> <span>undefined</span><span>;</span>
  <span>}</span></code></pre>
<p>Get the register from the local map, and return its value if it has one.</p>
<p>Why coalesce to <code>undefined</code>? Because each register holds <code>T | null</code>. And with the <code>delete</code> method, we’re ready to explain why:</p>
<pre><code>  <span>delete</span><span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>{</span>
    
    <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>?.</span><span>set</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>Rather than fully removing the key from the map, we set the register value to <code>null</code>. The metadata is kept around so we can disambiguate deletions from states that simply don’t have a key yet. These are called <strong>tombstones</strong> — the ghosts of CRDTs past.</p>
<p>Consider what would happen if we really did delete the keys from the map, rather than leaving a tombstone. Here’s a playground where peers can add keys, but not delete them. Can you figure out how to get a peer to delete a key?</p>
<lwwmap-demo delete="off" merge="naive" state="{ &#34;foo&#34;: [&#34;alice&#34;, 1, &#34;lorem ipsum&#34;] }"></lwwmap-demo>

<p>Turn off the network, add a key to <code>alice</code>’s map, then turn the network back on. Finally, make a change to <code>bob</code>’s map. Since <code>alice</code> sees that the incoming state from <code>bob</code> is missing that key, she removes it from her own state — even though <code>bob</code> never knew about that key in the first place. Whoops!</p>
<p>Here’s a playground with the correct behavior. You can also see what happens when a key is deleted.</p>
<lwwmap-demo state="{ &#34;foo&#34;: [&#34;alice&#34;, 1, &#34;lorem ipsum&#34;] }"></lwwmap-demo>

<p>Notice how we never remove deleted keys from the map. This is one drawback to CRDTs — we can only ever add information, not remove it. Although from the application’s perspective the key has been fully deleted, the underlying state still records that the key was once there. In technical terms, we say that CRDTs are <strong>monotonically increasing</strong> data structures.<sup><a href="#user-content-fn-efficiency" id="user-content-fnref-efficiency" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">9</a></sup></p>
<p>The final LWW Map method is <code>has</code>, which returns a boolean indicating whether the map contains a given key.</p>
<pre><code>  <span>has</span><span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>{</span>
    
    <span>return</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>?.</span>value <span>!==</span> <span>null</span><span>;</span>
  <span>}</span></code></pre>
<p>There’s a special case here: if the map contains a register at the given key, but the register contains <code>null</code>, the map is considered to not contain the key.</p>
<p>For posterity, here’s the full LWW Map code:</p>
<pre><code><span>class</span> <span>LWWMap<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>{</span>
  <span>readonly</span> id<span>:</span> <span>string</span><span>;</span>
  #data <span>=</span> <span>new</span> <span>Map<span>&lt;</span><span>string</span><span>,</span> LWWRegister<span>&lt;</span><span>T</span> <span>|</span> <span>null</span><span>&gt;&gt;</span></span><span>(</span><span>)</span><span>;</span>

  <span>constructor</span><span>(</span>id<span>:</span> <span>string</span><span>,</span> state<span>:</span> State<span>&lt;</span><span>T</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>id <span>=</span> id<span>;</span>

    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> register<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>state<span>)</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>new</span> <span>LWWRegister</span><span>(</span><span>this</span><span>.</span>id<span>,</span> register<span>)</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>get</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> value<span>:</span> Value<span>&lt;</span><span>T</span><span>&gt;</span> <span>=</span> <span>{</span><span>}</span><span>;</span>

    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> register<span>]</span> <span>of</span> <span>this</span><span>.</span>#data<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>register<span>.</span>value <span>!==</span> <span>null</span><span>)</span> value<span>[</span>key<span>]</span> <span>=</span> register<span>.</span>value<span>;</span>
    <span>}</span>

    <span>return</span> value<span>;</span>
  <span>}</span>

  <span>get</span> <span>state</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> state<span>:</span> State<span>&lt;</span><span>T</span><span>&gt;</span> <span>=</span> <span>{</span><span>}</span><span>;</span>

    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> register<span>]</span> <span>of</span> <span>this</span><span>.</span>#data<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>register<span>)</span> state<span>[</span>key<span>]</span> <span>=</span> register<span>.</span>state<span>;</span>
    <span>}</span>

    <span>return</span> state<span>;</span>
  <span>}</span>

  <span>has</span><span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>?.</span>value <span>!==</span> <span>null</span><span>;</span>
  <span>}</span>

  <span>get</span><span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>?.</span>value<span>;</span>
  <span>}</span>

  <span>set</span><span>(</span>key<span>:</span> <span>string</span><span>,</span> value<span>:</span> <span>T</span><span>)</span> <span>{</span>
    
    <span>const</span> register <span>=</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>

    
    <span>if</span> <span>(</span>register<span>)</span> register<span>.</span><span>set</span><span>(</span>value<span>)</span><span>;</span>
    
    <span>else</span> <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>new</span> <span>LWWRegister</span><span>(</span><span>this</span><span>.</span>id<span>,</span> <span>[</span><span>this</span><span>.</span>id<span>,</span> <span>1</span><span>,</span> value<span>]</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>

  <span>delete</span><span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>{</span>
    
    <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>?.</span><span>set</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>}</span>

  <span>merge</span><span>(</span>state<span>:</span> State<span>&lt;</span><span>T</span><span>&gt;</span><span>)</span> <span>{</span>
    
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> remote<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>state<span>)</span><span>)</span> <span>{</span>
      <span>const</span> local <span>=</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>

      
      <span>if</span> <span>(</span>local<span>)</span> local<span>.</span><span>merge</span><span>(</span>remote<span>)</span><span>;</span>
      
      <span>else</span> <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>new</span> <span>LWWRegister</span><span>(</span><span>this</span><span>.</span>id<span>,</span> remote<span>)</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre>
<h3 id="next-steps">Next Steps</h3>
<p>If you’re reading this now, we’re in the short period when this post has been published, but the next one has not. <a href="https://www.scattered-thoughts.net/rss.xml" data-astro-cid-bi7aps5f="">Subscribe to my RSS feed</a> to be notified when it’s ready!</p>
</div></div>
  </body>
</html>
