<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/tokenized-tokens/">Original</a>
    <h1>Tokenized Tokens</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/btoews.webp" alt="Ben Toews" srcset=""/> <dl> <dt>Name</dt> <dd> Ben Toews </dd> <dt>Social Media</dt> <dd> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/blog/2023-07-12/ghosts.png" alt="Sort of the Ghostbusters containment unit? Maybe?"/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com/" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p> We&#39;re Fly.io. We run apps for our users on hardware we host around the world. Building security for a platform like this is tricky, and that&#39;s what the post is about. But you don&#39;t have to read any of this to get an app running on here. See how to <a href="https://fly.io/docs/speedrun/">speedrun getting an app running on Fly.io here</a>.</p><p>We built some little security thingies. We&#39;re open sourcing them, and hoping you like them as much as we do. In a nutshell: it&#39;s a proxy that injects secrets into arbitrary 3rd-party API calls. We could describe it more completely here, but that wouldn&#39;t be as fun as writing a big long essay about how the thingies came to be, so: buckle up.</p> <p>The problem we confront is as old as Rails itself. Our application started simple: some controllers, some models. The only secrets it stored were bcrypt password hashes. But not unlike a pet baby alligator, it grew up. Now it&#39;s become more unruly than we&#39;d planned.</p> <p>That&#39;s because frameworks like Rails make it easy to collect secrets: you just create another model for them, <a href="https://guides.rubyonrails.org/active_record_encryption.html">roll some kind of secret to encrypt them</a>, jam that secret into the deployment environment, and call it a day.</p> <p>And, at least in less sensitive applications, or even the early days of an app like ours, that can work!</p> <p> For what it&#39;s worth, and to the annoyance of some of our Heroku refugees, we&#39;ve never stored customer app secrets this way; our Rails API can write customer secrets, but has never been able to read them. We&#39;ll talk more about how this works in a sec.</p><p>But for us, not anymore. At the stage we&#39;re at, all secrets are hazmat. And Rails itself is the portion of our attack surface we&#39;re least confident about – the rest of it is either outside of our trust boundaries, or written in Rust and Go, strongly-typed memory-safe languages that are easy to reason about, and which have never accidentally treated YAML as an executable file format.</p> <p>So, a few months back, during an integration with a 3rd party API that relied on OAuth2 tokens, we drew a line: ⚡ <em>henceforth, hazmat shall only be removed from Rails, never added</em> ⚡. This is easier said than done, though: despite prominent &#34;this is not a place of honor&#34; signs all over the codebase, our Rails API is still where much of the action in our system takes place.</p> <h3 id="how-apps-use-secrets-3-different-approaches"><a href="#how-apps-use-secrets-3-different-approaches" aria-label="Anchor"></a>How Apps Use Secrets: 3 Different Approaches</h3><p><img src="https://fly.io/blog/2023-07-12/secrets-1.png?2/3&amp;card&amp;center" alt=""/></p> <p>We just gave you one way, probably the most common. Stick &#39;em in a model, encrypt them with an environment secret, and watch Dependabot religiously for vulnerabilities in transitively-added libraries you&#39;ve never heard of before.</p> <p><img src="https://fly.io/blog/2023-07-12/secrets-2.png?2/3&amp;card&amp;center" alt=""/></p> <p>Here&#39;s a second way, probably the second-most popular: use a secrets management system, like <a href="https://aws.amazon.com/kms/">KMS</a> or <a href="https://www.hashicorp.com/products/vault">Vault</a>. These systems, which are great, keep secrets encrypted and allow access based on an intricate access control language, which is great.</p> <p>That&#39;s what we do for customer app secrets, like <code>DATABASE_URL</code> and <code>API_KEY</code>. We use <a href="https://www.hashicorp.com/products/vault">HashiCorp Vault</a> (for the time being). Our Rails API has an access token for Vault that allows it to set secrets, but not read any of them back, like a kind of diode. A game-over Rails vulnerability might allow an attacker to scramble secrets, but not to easily dump them.</p> <p>In the happiest cases with secrets, systems like Vault can keep secret bits from ever touching the application. Customer app secrets are a happy case: Rails never needs to read them, <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/">just our orchestrator</a>, to inject them into VM environments. In other happy cases, Vault operates on the app&#39;s behalf: signing a time-limited request URL for AWS, or making a direct request to a known 3rd-party service. Vault calls these features &#34;<a href="https://developer.hashicorp.com/vault/docs/secrets">secret engines</a>&#34;, and when you can get away with using them, it&#39;s hard to do better.</p> <p>The catch is, sometimes you can&#39;t get away with them. For most 3rd parties, Vault has no idea how to interact with them. And most secrets are bearer tokens, not request signatures. The only way to use those kinds of secrets is to read them into app memory. If good code can read a secret from Vault, so can a YAML vulnerability.</p> <p> Still: this is better than nothing: even if apps can read raw secrets, systems like Vault can provide an audit trail of which secrets were pulled when, and make it much easier to rotate secrets, which you&#39;ll want to do with raw secrets to contain their blast radius. HashiCorp Vault is great, so is KMS, we recommend them unreservedly.</p><p><img src="https://fly.io/blog/2023-07-12/secrets-3.png?2/3&amp;card&amp;center" alt=""/></p> <p>So that&#39;s why there&#39;s a third way to handle this problem, which is: decompose your application into services so that the parts that have to handle secrets are tiny and well-contained. The bulk of our domain-specific business code can chug along in Rails, and the parts that trade bearer tokens with 3rd parties can be built in a couple hundred lines of Go.</p> <p>This is a good approach, too. It&#39;s just cumbersome, because a big application ends up dealing with lots of different kinds of secrets, making a trusted microservice for each of them is a drag. What you want is to notice some commonality in how 3rd party API secrets are used, and to come up with some possible way of exploiting that.</p> <p>We thought long and hard on this and came up with:</p> <h3 id="tokenizer-the-fabled-4th-way"><a href="#tokenizer-the-fabled-4th-way" aria-label="Anchor"></a>Tokenizer: The Fabled 4th Way</h3><p><img src="https://fly.io/blog/2023-07-12/secrets-4.png?2/3&amp;card&amp;center" alt=""/></p> <p>We developed a multipurpose secret-using service called the <code>Tokenizer</code>.</p> <p><code>Tokenizer</code> is a stateless HTTP proxy that holds the private key of a <a href="https://pkg.go.dev/golang.org/x/crypto/nacl/box">Curve25519 keypair.</a></p> <p>When we get a new 3rd party API secret, we encrypt it to <code>Tokenizer&#39;s</code> public key; we &#34;tokenize&#34; it. Our API server can handle the (encrypted) tokenized secret, but it can&#39;t read or use it directly. Only <code>Tokenizer</code> can.</p> <p>When it comes time to talk to the 3rd party API, Rails does so via <code>Tokenizer</code>. Here&#39;s how that works:</p> <ol> <li>The API request is proxied, as an ordinary HTTP 1.1 request, through <code>Tokenizer</code>. </li><li>The request carries one or more additional <code>Proxy-Tokenizer</code> headers. </li><li>Each <code>Proxy-Tokenizer</code> header carries an encrypted secret and instructions for <code>Tokenizer</code> to rewrite the request in some way, usually by injecting the decrypted plaintext into a header. </li></ol> <p>You can think of <code>Tokenizer</code> as a sort of Vault-style &#34;secret engine&#34; that happens to capture virtually everything an app needs secrets for. It can even use decrypted secrets to selectively HMAC parts of requests, for APIs that authenticate with signatures instead of bearer tokens.</p> <p>Check it out: <a href="https://github.com/superfly/tokenizer">it&#39;s not super complicated</a>.</p> <p>Now, our goal is to keep Rails from ever touching secret bits. But, hold on: a game-over Rails vulnerability would give attackers an easy way around <code>Tokenizer</code>: you&#39;d just proxy requests for a particular secret to a service you ran that collected the plaintext.</p> <p>To mitigate that, we built the obvious feature: you can lock requests for specific secrets down to a list of allowed hosts or host regexp patterns.</p> <p>We think this approach to handling secrets is pretty similar to how payment processors tokenize payment card information, hence the name. The advantages are straightforward:</p> <ul> <li>Secrets are exposed to a much smaller attack surface that doesn&#39;t include Rails. </li><li>Virtually every usage of secrets we&#39;re likely to run across is captured by HTTP proxying, without us needing to write per-service code. </li><li>The tokenizer is a tiny project that&#39;s easy to audit and reason about. </li><li>Every language we work in already has first-class support for running requests through a proxy (something we already do for <a href="https://github.com/stripe/smokescreen">SSRF protection</a>.) </li></ul> <h3 id="ssokenizer-tokenizing-oauth-sso"><a href="#ssokenizer-tokenizing-oauth-sso" aria-label="Anchor"></a>SSOkenizer: Tokenizing OAuth SSO</h3><p>When we created <code>Tokenizer</code>, we were motivated by the problem of OAuth2 tokens other services providers gave us, for partnership features we build for mutual customers.</p> <p>We&#39;d also dearly like our customers to use OAuth2/OIDC to log into Fly.io itself; it&#39;s more secure for them, and gives them the full complement of Google MFA features, meaning we don&#39;t immediately have to implement the full complement of Google MFA features. Letting people log into Fly.io with a Google OAuth token means we have to keep track of people&#39;s OAuth tokens. That sounds like a job for the <code>Tokenizer</code>!</p> <p>But there&#39;s a catch: acquiring those OAuth tokens in the first place means doing the OAuth2 dance, which means that for a brief window of time, Rails is handling hazmat. We&#39;d like to close that window.</p> <p><img src="https://fly.io/blog/2023-07-12/ssokenizer.png?2/3&amp;card&amp;center" alt=""/></p> <p>Enter the <code>SSOkenizer</code>.</p> <p>The job of the <code>SSOkenizer</code> is to perform the OAuth2 dance on behalf of Rails, and then use the output of that process (the OAuth2 bearer token yielded from the OAuth2 code flow, which you can <a href="https://github.com/superfly/ssokenizer#ssokenizer">see in its cursed majesty here</a>) to drive the <code>Tokenizer</code>.</p> <p>In other words, where we&#39;d otherwise explicitly encrypt secrets to be tokenized a-priori, the <code>SSOkenizer</code> does that on the fly, passing tokenized OAuth2 credentials back to Rails. Those… tokenized tokens can only be used through the <code>Tokenizer</code> proxy, which is the only component in our system with the private key that unseals them.</p> <p>We think this is a pretty neat trick. The <code>SSOkenizer</code> itself is tiny, even smaller than the <code>Tokenizer</code> (<a href="https://github.com/superfly/ssokenizer/">you can read it here</a>), and essentially stateless; in fact, pretty much everything in this system is minimally stateful, except Rails, which is great at being stateful. We even keep almost all of OAuth2 out of Rails and confined to Go code (where it&#39;s practically the hello-world of Go OAuth2 libraries).</p> <p>A nice side effect-slash-validation of this design: once we got it working for Google, it became a super easy project to get OAuth2 logins working for other providers.</p> <h3 id="feel-free-to-poach-this"><a href="#feel-free-to-poach-this" aria-label="Anchor"></a>Feel Free To Poach This</h3><p>We&#39;re psyched for a bunch of reasons:</p> <ul> <li>We&#39;ve got a clear path to rolling out SSO logins. </li><li>We can do integrations with third-party services now without infecting Rails with more hazmat secrets. </li><li>We&#39;ve honored the rule of &#34;only removing hazmat from Rails, not adding it&#34;. </li><li>We&#39;ve also cleared a path to getting all the rest of the hazmat Rails has access to tokenized. </li></ul> <p>These are standalone tools with no real dependencies on Fly.io, so they&#39;re easy for us to open source. Which is what we did: if they sound useful to you, check out the <a href="https://github.com/superfly/tokenizer">tokenizer</a> and <a href="https://github.com/superfly/ssokenizer">ssokenizer</a> repositories for instructions on deploying and using these services yourself.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/flydotio-heart-bun/"> Fly.io ❤️ Bun </a> </dd> </dl> </article></div>
  </body>
</html>
