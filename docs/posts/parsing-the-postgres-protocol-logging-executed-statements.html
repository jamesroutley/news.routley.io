<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kviklet.dev/blog/parsing-the-postgres-protocol/">Original</a>
    <h1>Parsing the Postgres protocol – logging executed statements</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container" itemprop="articleBody"><p>Kviklet as an application already allows you to execute arbitrary SQL statements on your database. However a feedback we heard multiple times is that using a simple web tool for query execution is not the same as e.g. a designated DB access software like Datagrip.</p>
<p>And engineers did not always want to have to approve every individual statement. Especially when debugging a production error, they need break glass kind of access.
We already have a temp access mode that lets you execute any amount of statements for 1 hour. But the UI for this is yah well... lacking. We definitely can&#39;t compete with datagrip.</p>
<p>So I wanted to experiment... in theory nothing stops us from starting a proxy server and listening in on the postgres network traffic between a client application and the server. This would allow us to add all the cool kviklet features, like an auditlog on SSO level in a very seemless manner almost unnoticable for the actual engineers that had to connect to prod.</p>
<p>This post is about how this works, I found it interesting to poke around on such a low level of the postgres implementation. So maybe you do too.</p>
<p>Postgres runs on a binary frontend/backend protocol. This traffic is potentially SSL encrypted but if we ignore that,
listening in on the traffic results in fun stuff to read like:</p>
<div><div><pre tabindex="0"><code><span><span>P�����select name, is_dst from pg_catalog.pg_timezone_names</span><br/></span><span><span>B�����������</span><br/></span></code></pre></div></div>
<p>Which is not very useful by itself. As noted above I wanted to figure out which statements the user runs on the DB.
However we can parse the traffic into individual messages to make more sense of them.</p>
<p>If we look at the postgres docs we can for example see that &#39;P&#39; from the frontend stand for a Parse Message.
Which is defined as such:</p>
<hr/>
<blockquote>
<p>Byte1(&#39;P&#39;)
Identifies the message as a Parse command.</p>
</blockquote>
<blockquote>
<p>Int32
Length of message contents in bytes, including self.</p>
</blockquote>
<blockquote>
<p>String
The name of the destination prepared statement (an empty string selects the unnamed prepared statement).</p>
</blockquote>
<blockquote>
<p>String
The query string to be parsed.</p>
</blockquote>
<blockquote>
<p>Int16
The number of parameter data types specified (can be zero). Note that this is not an indication of the number of parameters that might appear in the query string, only the number that the frontend wants to prespecify types for.</p>
</blockquote>
<blockquote>
<p>Then, for each parameter, there is the following:</p>
</blockquote>
<blockquote>
<p>Int32
Specifies the object ID of the parameter data type. Placing a zero here is equivalent to leaving the type unspecified.</p>
</blockquote>
<hr/>
<p>This however isn&#39;t a statement execution by itself which is what I wanted to track in Kviklet. An execution always consists of a Parse Message, followed by a Bind message that binds specific parameters. Only once this has been done an Execute message is sent.</p>
<p>Now the fact that the statement is first send with placeholder params which are later binded is a bit problematic for me. Afterall I want to add the whole statement to the auditlog with all the parameters filled not just &#34;?&#34; placeholders.</p>
<p>So I also need to parse the Bind message:</p>
<hr/>
<blockquote>
<p>Byte1(&#39;B&#39;)
Identifies the message as a Bind command.</p>
</blockquote>
<blockquote>
<p>Int32
Length of message contents in bytes, including self.</p>
</blockquote>
<blockquote>
<p>String
The name of the destination portal (an empty string selects the unnamed portal).</p>
</blockquote>
<blockquote>
<p>String
The name of the source prepared statement (an empty string selects the unnamed prepared statement).</p>
</blockquote>
<blockquote>
<p>Int16
The number of parameter format codes that follow (denoted C below). This can be zero to indicate that there are no parameters or that the parameters all use the default format (text); or one, in which case the specified format code is applied to all parameters; or it can equal the actual number of parameters.</p>
</blockquote>
<blockquote>
<p>Int16[C]
The parameter format codes. Each must presently be zero (text) or one (binary).</p>
</blockquote>
<blockquote>
<p>Int16
The number of parameter values that follow (possibly zero). This must match the number of parameters needed by the query.</p>
</blockquote>
<blockquote>
<p>Next, the following pair of fields appear for each parameter:</p>
</blockquote>
<blockquote>
<p>Int32
The length of the parameter value, in bytes (this count does not include itself). Can be zero. As a special case, -1 indicates a NULL parameter value. No value bytes follow in the NULL case.</p>
</blockquote>
<blockquote>
<p>Byten
The value of the parameter, in the format indicated by the associated format code. n is the above length.</p>
</blockquote>
<blockquote>
<p>After the last parameter, the following fields appear:</p>
</blockquote>
<blockquote>
<p>Int16
The number of result-column format codes that follow (denoted R below). This can be zero to indicate that there are no result columns or that the result columns should all use the default format (text); or one, in which case the specified format code is applied to all result columns (if any); or it can equal the actual number of result columns of the query.</p>
</blockquote>
<blockquote>
<p>Int16[R]
The result-column format codes. Each must presently be zero (text) or one (binary).</p>
</blockquote>
<hr/>
<p>Oof this is getting complicated. So we have parameters and for each parameter we can get the Object ID of the type from the Parse message.<!-- -->
<!-- --></p>

<p>Now this is relevant because in the Bind message the docs refer to the params formatter
codes. If the code is 1 the format is binary. Meaning I don&#39;t get the UTF-8 version
of the parameter but instead just a binary value. I need to know what kind of type
the parameter is so that I can transform it to a string.</p>
<p>Since my code is kotlin the formatting for that looks like this:</p>
<div><div><pre tabindex="0"><code><span><span>&#34;bool&#34;</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>(</span><span>bytes</span><span>[</span><span>0</span><span>]</span><span> </span><span>==</span><span> </span><span>0x01</span><span>.</span><span>toByte</span><span>(</span><span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><span>&#34;char&#34;</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    bytes</span><span>[</span><span>0</span><span>]</span><span>.</span><span>toInt</span><span>(</span><span>)</span><span>.</span><span>toChar</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><span>&#34;name&#34;</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    bytes</span><span>.</span><span>toHexString</span><span>(</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><span>&#34;int8&#34;</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    ByteBuffer</span><span>.</span><span>wrap</span><span>(</span><span>bytes</span><span>)</span><span>.</span><span>long</span><span>.</span><span>toString</span><span>(</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div>
<p>With this decyphering done I can now print a query when I receive the Execute Message. This is fun since I can now see all the introspection and settings commands that datagrip executes:
<img loading="lazy" alt="datagrip introspection" src="https://kviklet.dev/blog/assets/images/datagrip_introspection-945b9e7bce4b4a6ddc5cdf5e31d233ba.png" width="1736" height="1206"/></p>
<p>Now for my purpose that wasn&#39;t quite enough. Just proxying the traffic is only useful if the engineer already has the password to production. However we want to avoid this since this often leads to password sharing and thereby access inflation over time.</p>
<p>Instead I want to integrate my proxy with the kviklet user management, which could also be an SSO provider (google or keycloak). For this I had to implement the login process of the postgres protocol.</p>
<p>Postgres supports a miriad different ways of login in, there is the old way of just sending a username and password via plaintext, there is an md5 hashed version and there is newer options like SCRAM which is defined in <a href="https://datatracker.ietf.org/doc/html/rfc7677" target="_blank" rel="noopener noreferrer">RFC-7677</a>.
Since this is a beta and I want to add SSL later anyways, I simply went with the md5 version, this is also what my locally hosted postgres instance was using so it was easier to reimplement.</p>
<p>The flow is the following:</p>
<ol>
<li>The client sends a startup message containing a user a desired database and a bunch of meta information.</li>
<li>The server responds with an Authentication Request that contains a salt.</li>
<li>The client hashes the username + password + salt and sends it to the server.</li>
<li>If everything is correct the server respondsw with AuthenticationOK + ReadyForQuery messages.</li>
</ol>
<p>After this flow I can again forward all messages to my original postgres connection. This one I btw manage directly via jdbc so I don&#39;t have to implement any of the authentication logic on that side.</p>
<p>The exact flow is a bit more complex but you can look at the details in the code if you&#39;d like to:
<a href="https://github.com/kviklet/kviklet/blob/main/backend/src/main/kotlin/dev/kviklet/kviklet/proxy/PostgresProxy.kt#L188" target="_blank" rel="noopener noreferrer">https://github.com/kviklet/kviklet/blob/main/backend/src/main/kotlin/dev/kviklet/kviklet/proxy/PostgresProxy.kt#L188</a></p>
<p>With this implemented I can now generate a random password that is only valid for 1 hour, start the proxy with it and forward all traffic to e.g. the root user. All without having to share the password for the root user and with all statements logged in our auditlog. Pretty cool right?</p>
<p>Note this is all quite experimental and still needs some further work before I&#39;d call it production ready. But feel free to play around with it and let me know if you find any problems in a github issue!</p></div></div>
  </body>
</html>
