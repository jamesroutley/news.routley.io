<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mxgmn/MarkovJunior">Original</a>
    <h1>MarkovJunior: Probabilistic PL based on pattern matching and constraint prop</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">MarkovJunior is a probabilistic programming language where programs are combinations of rewrite rules and inference is performed via constraint propagation. MarkovJunior is named after mathematician <a href="https://en.wikipedia.org/wiki/Andrey_Markov,_Jr." rel="nofollow">Andrey Andreyevich Markov</a>, who defined and studied what is now called <a href="https://en.wikipedia.org/wiki/Markov_algorithm" rel="nofollow">Markov algorithms</a>.</p>
<p dir="auto">
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/top-iso.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/top-iso.gif" data-animated-image=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/top-mv.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/top-mv.gif" data-animated-image=""/></a>
</p>
<p dir="auto">In its basic form, a MarkovJunior program is an ordered list of rewrite rules. For example, <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeBacktracker.xml">MazeBacktracker</a> (animation on the left below) is a list of 2 rewrite rules:</p>
<ol dir="auto">
<li><code>RBB=GGR</code> or &#34;replace red-black-black with green-green-red&#34;.</li>
<li><code>RGG=WWR</code> or &#34;replace red-green-green with white-white-red&#34;.</li>
</ol>
<p dir="auto">On each execution step MJ interpreter finds the first rule in the list that has a match on the grid, finds all matches for that rule and applies that rule for a random match. In the <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#Depth-first_search" rel="nofollow">maze backtracker</a> example, interpreter first applies a bunch of <code>RBB=GGR</code> rules. But eventually the green self-avoiding walk gets stuck. At this point the first rule has no matches, so interpreter applies the second rule <code>RGG=WWR</code> until the walk gets unstuck. Then it can apply the first rule again, and so on. Interpreter stops when there are no matches for any rule.</p>
<p dir="auto">
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/MazeBacktracker.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/MazeBacktracker.gif" data-animated-image=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/multisokoban.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/multisokoban.gif" data-animated-image=""/></a>
</p>
<p dir="auto">Probabilistic inference in MarkovJunior allows to impose constraints on the future state, and generate only those runs that lead to the constrained future. For example, inference in Sokoban rules <code>{RWB=BRW RB=BR}</code> makes a group of (red) agents organize (white) crates into specified shapes.</p>
<p dir="auto">Using these ideas, we construct <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models">many probabilistic generators</a> of dungeons, architecture, puzzles and fun simulations.</p>
<p dir="auto"><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/top-1764.png"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/top-882.png"/></a></p>
<p dir="auto">Higher resolution screenshots and more seeds: <a href="https://github.com/mxgmn/Blog/blob/master/ModernHouse.md">ModernHouse</a>, <a href="https://github.com/mxgmn/Blog/blob/master/SeaVilla.md">SeaVilla</a>, <a href="https://github.com/mxgmn/Blog/blob/master/Apartemazements.md">Apartemazements</a>, <a href="https://github.com/mxgmn/Blog/blob/master/CarmaTower.md">CarmaTower</a>, <a href="https://github.com/mxgmn/Blog/blob/master/Escheresque.md">Escheresque</a>, <a href="https://github.com/mxgmn/Blog/blob/master/PillarsOfEternity.md">PillarsOfEternity</a>, <a href="https://github.com/mxgmn/Blog/blob/master/RandomSurface.md">Surface</a>, <a href="https://twitter.com/ExUtumno/status/895688856304992256" rel="nofollow">Knots</a>.</p>
<h2 dir="auto"><a id="user-content-markov-algorithms" aria-hidden="true" href="#markov-algorithms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Markov algorithms</h2>
<p dir="auto">A Markov algorithm over an alphabet <code>A</code> is an ordered list of rules. Each rule is a string of the form <code>x=y</code>, where <code>x</code> and <code>y</code> are words in <code>A</code>, and some rules may be marked as halt rules. Application of a Markov algorithm to a word <code>w</code> proceeds as follows:</p>
<ol dir="auto">
<li>Find the first rule <code>x=y</code> where <code>x</code> is a substring of <code>w</code>. If there are no such rules, then halt.</li>
<li>Replace the leftmost <code>x</code> in <code>w</code> by <code>y</code>.</li>
<li>If the found rule was a halt rule, then halt. Otherwise, go to step 1.</li>
</ol>
<p dir="auto">For example, consider this Markov algorithm in the alphabet <code>{0, 1, x}</code> (ε is the empty word):</p>

<p dir="auto">If we apply it to the string <code>110</code> we get this sequence of strings:</p>
<div data-snippet-clipboard-copy-content="110 -&gt; 0x10 -&gt; 0x0x0 -&gt; 00xxx0 -&gt; 00xx0xx -&gt; 00x0xxxx -&gt; 000xxxxxx -&gt; 00xxxxxx -&gt; 0xxxxxx -&gt; xxxxxx"><pre><code>110 -&gt; 0x10 -&gt; 0x0x0 -&gt; 00xxx0 -&gt; 00xx0xx -&gt; 00x0xxxx -&gt; 000xxxxxx -&gt; 00xxxxxx -&gt; 0xxxxxx -&gt; xxxxxx
</code></pre></div>
<p dir="auto">In general, this algorithm converts a binary representation of a number into its unary representation.</p>
<p dir="auto">Markov&#39;s student <a href="https://lv.wikipedia.org/wiki/Vilnis_Detlovs" rel="nofollow">Vilnis Detlovs</a> <a href="http://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;jrnid=tm&amp;paperid=1293" rel="nofollow">proved</a> that for any Turing machine there exists a Markov algorithm that computes the same function. In comparison, grammars are unordered sets of rewrite rules and L-systems are rewrite rules that are applied in parallel. For more interesting examples of Markov algorithms check <a href="http://www.mathnet.ru/links/1543dd6e347b444e6f3e108fafaf9f2a/tm1178.pdf" rel="nofollow">Markov&#39;s book</a> or see the greatest common divisor example in the <a href="https://github.com/mxgmn/test#comments">comment section</a> or <a href="https://en.wikipedia.org/wiki/Markov_algorithm#Description" rel="nofollow">multiplication example</a> on Wikipedia.</p>
<p dir="auto">How would one generalize Markov algorithms to multiple dimensions? First, in multiple dimensions there are no natural ways to insert a string into another string, so the lefts and rights of our rewrite rules should have the same size. Second, there are no natural ways to choose <em>the leftmost</em> match. Possible options are:</p>
<ul dir="auto">
<li>Choose a random match. This is what MJ&#39;s <code>(exists)</code> nodes do.</li>
<li>Choose all matches. There is a problem with this option however because different matches can overlap and have conflicts. Possible solutions are:
<ul dir="auto">
<li>Greedily choose a maximal subset of non-conflicting matches. This is what MJ&#39;s <code>{forall}</code> nodes do.</li>
<li>Consider all matches in superposition. That is, instead of separate values, keep waves in each grid cell - boolean vectors that tell which spacetime patterns are forbidden and which are not. And this is how MJ performs inference.</li>
</ul>
</li>
</ul>
<p dir="auto">We lose Turing completeness because our new procedure is not deterministic, but practice shows that this formalism still allows to describe a huge range of interesting random processes.</p>
<h2 dir="auto"><a id="user-content-rewrite-rules" aria-hidden="true" href="#rewrite-rules"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Rewrite rules</h2>
<p dir="auto">The simplest MarkovJunior program is probably <code>(B=W)</code>. It contains just a single rule <code>B=W</code>. On each turn, this program converts a random black square into a white square.</p>
<p dir="auto">
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Basic.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/Basic.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Growth.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/Growth.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeGrowth.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/MazeGrowth.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeGrowth.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/MazeGrowth.png"/></a></p>
<p dir="auto"><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Growth.xml">Growth</a> model <code>(WB=WW)</code> is more interesting. On each turn it replaces a black-white pair of adjacent cells <code>BW</code> with a white-white pair <code>WW</code>. In other words, on each turn it picks a random black cell adjacent to some white cell and color it into white. This model is almost identical to the <a href="http://digitalassets.lib.berkeley.edu/math/ucb/text/math_s4_v4_article-15.pdf" rel="nofollow">Eden growth model</a>: on each turn both models choose among the same set of black cells. They differ only in probability distributions: a uniform distribution over black cells adjacent to white cells is not the same as a uniform distribution over pairs of adjacent black and white cells.</p>
<p dir="auto">Model <code>(WBB=WAW)</code> generates a maze, with a single line of code! Compare it with an <a href="https://bl.ocks.org/mbostock/70a28267db0354261476" rel="nofollow">implementation</a> in a conventional language. Any MarkovJunior model can be run in any number of dimensions without changes. On the right you can see the end result of <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeGrowth.xml">MazeGrowth</a> in 3d, rendered in <a href="https://ephtracy.github.io/" rel="nofollow">MagicaVoxel</a>. By default, we use <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/resources/palette.xml">PICO-8 palette</a>:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/palette.png"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/palette.png"/></a></p>
<p dir="auto">Model <code>(RBB=WWR)</code> is a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk" rel="nofollow">self-avoiding random walk</a>. Note that self-avoiding walks in 3d are longer on average than in 2d. In general, comparing the behaviors of similar random processes in different dimensions is a fascinating topic. A <a href="https://sites.math.washington.edu/~morrow/336_19/papers19/Legrand.pdf" rel="nofollow">classic result</a> of George Pólya says that a random walk in 2d returns to its initial position with probability one, while in 3d this is no longer the case.</p>
<p dir="auto">
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/RegularSAW.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/RegularSAW.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/LoopErasedWalk.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/LoopErasedWalk.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Trail.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/Trail.gif" data-animated-image=""/></a></p>
<p dir="auto">We can put several rules into one <strong>rulenode</strong>. For example, <code>(RBB=WWR RBW=GWP PWG=PBU UWW=BBU UWP=BBR)</code> is a <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk" rel="nofollow">loop-erased random walk</a>. Trail model <code>(RB=WR RW=WR)</code> generates <a href="https://blog.jrheard.com/procedural-dungeon-generation-drunkards-walk-in-clojurescript" rel="nofollow">decent connected caves</a>.</p>
<p dir="auto">Model <code>(RBB=WWR R*W=W*R)</code> is known as the <a href="http://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm" rel="nofollow">Aldous-Broder maze generation algorithm</a>. The <strong>wildcard</strong> symbol <code>*</code> in the input means that <em>any</em> color is allowed to be in the square. The wildcard symbol in the output means that the color doesn&#39;t change after the application of the rule. Aldous-Broder algorithm takes much more turns on average to generate a maze than MazeGrowth, for example, but it has a nice property that MazeGrowth doesn&#39;t have: each maze has the same probability to be generated. In other words, MazeTrail is an unbiased maze generation algorithm, or it samples mazes (or spanning trees) with the uniform distribution. <a href="http://web.stanford.edu/~yuvalwig/math/teaching/UniformSpanningTrees.pdf" rel="nofollow">Wilson&#39;s algorithm</a> is a more efficient unbiased maze generation algorithm. Compare its <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/Wilson.gif">MarkovJunior</a> <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Wilson.xml">implementation</a> with an <a href="https://bl.ocks.org/mbostock/11357811" rel="nofollow">implementation</a> in a conventional language!</p>
<h2 dir="auto"><a id="user-content-combining-rulenodes" aria-hidden="true" href="#combining-rulenodes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Combining rulenodes</h2>
<p dir="auto">We can put several rulenodes into a <strong>sequence node</strong>, to be run one after the other. In the <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/River.xml">River</a> model we first construct a stochastic <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Voronoi.xml">Voronoi</a> diagram with 2 sources, and use the boundary between the formed regions as a base for a river. Then we spawn a couple more Voronoi seeds to grow forests and simultaneously grow grass from the river. As a result, we get random river valleys!</p>
<p dir="auto">
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/River.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/River.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Apartemazements.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/Apartemazements.gif" data-animated-image=""/></a>
</p>
<p dir="auto">In <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Apartemazements.xml">Apartemazements</a> we start with a WFC node and then do constructive postprocessing with rulenodes:</p>
<ol dir="auto">
<li>Prepare constraints: mark bottom cells with a separate bottom color, mark the remaining border cells (sides and top) with a separate border color. Border cells should map to Empty, bottom cells should map to all tiles except Down.</li>
<li>Run WFC <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/resources/tilesets/Path.xml">Paths</a> tileset to generate closed stairy cycles.</li>
<li>Randomize light sources.</li>
<li>Drop columns from corners of flat tiles.</li>
<li>Retract double columns, columns that touch ground and columns that touch stairs, except columns growing from corners of the Turn tiles.</li>
<li>Grow windows between neighboring columns.</li>
<li>Merge windows into bigger rectangles. We do this in several steps:
<ol dir="auto">
<li>Detect uneven patterns of windows when window corners touch window midpoints.</li>
<li>Mark these patterns and propagate the markings through the whole lengths of window sides.</li>
<li>Merge unmarked pairs of window sides.</li>
</ol>
</li>
<li>Turn the remaining 1x1 windows into walls.</li>
</ol>
<p dir="auto">A more interesting way to combine nodes is to put them into a <strong>Markov node</strong>. Markov nodes substantially expand what we can do, because they allow to return to past nodes. When a Markov node is active, interpreter finds its first child node that matches and applies it. On the next turn, it finds the first matching node in the list again, and so on. The simplest example of the Markov node use is <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/MazeBacktracker.xml">MazeBacktracker</a> explained in the top section.</p>
<p dir="auto">
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/NystromDungeon.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/NystromDungeon.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Flowers.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/Flowers.gif" data-animated-image=""/></a>
</p>
<p dir="auto">One of my favorite examples that motivated the development of MarkovJunior is <a href="https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/" rel="nofollow">Bob Nystrom&#39;s dungeon generation algorithm</a>. It goes as follows:</p>
<ol dir="auto">
<li>Draw a grid <code>{PBB=**P}</code>.</li>
<li>Spawn a bunch of rooms <code>(room.png)</code>.</li>
<li>Generate a maze on the rest of the grid. We can use any maze generation algorithm, but <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/MazeBacktracker.xml">MazeBacktracker</a> is preferred because it produces fewer branching points.</li>
<li>Make the resulting configuration of rooms and corridors connected. This can be elegantly done with a Markov node <code>({GWW=**G}(GBW=*WG))</code>.</li>
<li>Make some additional connections <code>(GBG=*W* #5)</code>, so the resulting dungeon has cycles. Dungeons without cycles are pretty boring, since the player has to return through already explored zones.</li>
<li>Retract dead ends <code>{BBB/BWB=BBB/BBB}</code>.</li>
</ol>
<p dir="auto">
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Circuit.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/Circuit.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/DungeonGrowth.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/DungeonGrowth.gif" data-animated-image=""/></a>
</p>
<p dir="auto">Like in REFAL, Markov nodes can be nested: once we go into a child node, we ignore outer nodes until the child branch completes.</p>
<h2 dir="auto"><a id="user-content-inference" aria-hidden="true" href="#inference"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Inference</h2>
<p dir="auto">Probabilistic inference in MarkovJunior allows to impose constraints on the future state, and generate only those runs that lead to the constrained future. In other words, inference connects 2 given states (or partially observed states) with a chain of rewrite rules.</p>
<p dir="auto">The simplest example of inference use is connecting 2 points with a path. In the self-avoiding walk model <code>(RBB=WWR)</code> we can <strong>observe</strong> a given square on the grid to become <code>R</code> red. Then the interpreter would generate only those walks that lead to the observed square. We can set the interpreter to follow the goal more strictly or less strictly by varying the <strong>temperature</strong> parameter. By default, temperature is set to zero.</p>
<p dir="auto">
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/coldest.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/coldest.gif" data-animated-image=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/cold.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/cold.gif" data-animated-image=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/hot.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/hot.gif" data-animated-image=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/hottest.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/hottest.gif" data-animated-image=""/></a></p>
<p dir="auto">Another thing we can do is to observe <em>all</em> odd grid squares becoming white or red. Then the interpreter would generate self-avoiding walks that cover the entire grid.</p>
<p dir="auto">
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/CompleteSAW.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/CompleteSAW.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/CrossCountry.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/CrossCountry.gif" data-animated-image=""/></a>
<a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/SokobanLevel1.xml"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/SokobanLevel1.gif" data-animated-image=""/></a>
</p>
<p dir="auto">We can engage inference for any rewrite rules. For example, inference for <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/StairsPath3D.xml">stair-drawing rules</a> connects 2 points with a stairy path. Inference for rule <code>R**/**B=B**/**R</code> generates paths that a chess knight can take. Inference in the <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/CrossCountry.xml">CrossCountry</a> model connects 2 points with a path taking terrain costs into account. Inference for the Sokoban ruleset <code>{RB=BR RWB=BRW}</code> solves Sokoban puzzles or even <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/multisokoban.gif">multiagent Sokoban puzzles</a>!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/StairsPath.gif"><img src="https://xcorr.net/mxgmn/MarkovJunior/raw/main/images/StairsPath.gif" data-animated-image=""/></a></p>
<p dir="auto">Inference in MarkovJunior is done via unidirectional (fast) or bidirectional (slow, but more powerful) constraint propagation. Unidirectional constraint propagation for rewrite rules can be described equivalently in terms of <strong>rule propagation</strong> fields which generalize Dijkstra fields for arbitrary rewrite rules. Dijkstra fields is a popular technique in grid-based procedural generation (<a href="https://groups.google.com/forum/#!topic/rec.games.roguelike.development/6yNIuhSerpM" rel="nofollow">1</a>, <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps" rel="nofollow">2</a>, <a href="http://www.roguebasin.com/index.php?title=Dijkstra_Maps_Visualized" rel="nofollow">3</a>). They in turn generalize <a href="https://iquilezles.org/www/articles/distfunctions/distfunctions.htm" rel="nofollow">distance fields</a> used in computer graphics.</p>
<p dir="auto">If constraint propagation completes it doesn&#39;t necessarily mean that the goal state is achievable. But if the propagation fails then we know for sure that the goal is not achievable. This allows to catch states where a crate is pushed to the wrong wall in Sokoban, or where the grid-covering walk splits the grid into 2 disconnected parts. In addition to this boolean heuristic, it&#39;s worth looking at the minimal number of turns required for constraint propagation to complete. This integer-valued heuristic is <a href="https://en.wikipedia.org/wiki/Admissible_heuristic" rel="nofollow">admissible</a>, and we use it in A* search to sample paths made of rewrite rules between 2 given states.</p>
<h2 dir="auto"><a id="user-content-open-problems" aria-hidden="true" href="#open-problems"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Open problems</h2>
<ol dir="auto">
<li><strong>Program synthesis for procedural generation</strong>. William Chyr&#39;s talk <a href="https://youtu.be/ed2zmmcEryw?t=1298" rel="nofollow">&#34;Level Design in Impossible Geometry&#34;</a> is not at all about procedural generation, yet I find <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/images/ps-for-procgen.jpg">one slide</a> to be very characteristic for pcg practice. William compares his earlier and later approaches to level design. The earlier one produced chaotic levels, while the later approach produced more structured, more intentional levels based on one central idea. Later levels weren&#39;t simpler, yet they were more memorable and easier for players to perceive. To me, the left level looks like it was generated procedurally! It has a very similar feel to my <a href="https://twitter.com/ExUtumno/status/971031987304763393" rel="nofollow">procedural voxel puzzles</a>. Can we make generators that produce levels that are more like the one on the right? This problem may seem AI-complete. But I&#39;d argue it is very similar to classic genetic programming problems like <a href="https://pdfs.semanticscholar.org/555e/13cc2dd246e3d63ceb00590605f3ff59593d.pdf" rel="nofollow">Koza&#39;s lawnmower problem</a>. For example, take a simple procgen task of <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/CompleteSAW.xml">generating Hamiltonian paths on the grid</a>. Even for small grid sizes like 29x29 this task is already computationally demanding. But do we really need to sample from all possible paths in practice? If we give this task to a human, they would probably draw a spiral or a zigzag curve - these are much more memorable and intentional designs than a random Hamiltonian path, plus they generalize to any grid sizes. To summarize, we can ask the system either to find a random Hamiltonian path or to find a short program that generates Hamiltonian paths. In the first case the result would look like the left level on the slide, and in the second case like the right level. Solving the latter program synthesis problem would create more memorable and intentional generators.</li>
<li><strong>Model synthesis from examples</strong>. Markov algorithms seem to be a perfect environment for program/model synthesis: no variables, ifs or whiles, nodes can be easily moved around without breaking correctness, models are easy to make differentiable. Random MJ programs are often fun and can produce human-relatable results and behaviors.
<ol dir="auto">
<li>Can we synthesize a MJ model from a result, or a set of results?</li>
<li>Given a maze, is it possible to determine (or assign probabilities) whether it was generated by <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeGrowth.xml">MazeGrowth</a> or <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeBacktracker.xml">MazeBacktracker</a>?</li>
<li>Solve the <a href="https://www.kaggle.com/c/abstraction-and-reasoning-challenge" rel="nofollow">Abstraction and Reasoning Challenge</a> by inferring MarkovJunior models. Adjoint problem: use insights from the ARC challenge to build a better DSL for procedural generation on a grid.</li>
</ol>
</li>
<li><strong>Custom algorithms that run in the wave space</strong>. To unite the advantages of constructive and constrained-based procedural generation. Related: custom algorithms (MJ rewrite rules) with custom energy functions like Ising energy or ConvChain energy.</li>
<li>Generalize the notion of a pattern.</li>
<li>Investigate MJ-like processes on other (possibly nonregular) grids or arbitrary graphs.</li>
<li>Experiment with interactive extensions of Markov algorithms. It&#39;s possible to turn any MJ model into a game by assigning specific rewrite rules or nodes to key presses.</li>
<li>Push the state of the art in grid-based procedural generation. <a href="https://twitter.com/ExUtumno/status/1141354217774428160" rel="nofollow">ModernHouse</a> does not yet reach the structural variety of human-designed houses like <a href="https://www.thesimsresource.com/downloads/browse/category/sims2-lots/featured/1/search/modern%20house/" rel="nofollow">Sims 2 houses</a>. Use more subtle constraints.</li>
</ol>
<h2 dir="auto"><a id="user-content-comments" aria-hidden="true" href="#comments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Comments</h2>
<p dir="auto">Compared to Turing machines and lambda calculus, Markov algorithms is probably the shortest and simplest way to rigorously define what an algorithm is.</p>
<p dir="auto">Exercise: prove that the following Markov algorithm finds the greatest common divisor of 2 numbers written in a unary representation. For example, if we apply it to <code>111111*1111111111</code> we get <code>11</code>.</p>
<div data-snippet-clipboard-copy-content="1a=a1
1*1=a*
1*=*b
b=1
a=c
c=1
*=ε (halt)"><pre><code>1a=a1
1*1=a*
1*=*b
b=1
a=c
c=1
*=ε (halt)
</code></pre></div>
<p dir="auto">Fast pattern matching. MarkovJunior interpreter samples matches uniformly, but it doesn&#39;t scan the whole grid every turn. To keep pattern matching fast, the interpreter remembers previously found matches and searches only around the places that got changed. When a rulenode is encountered for the first time, MJ interpreter uses a multidimensional version of the <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm" rel="nofollow">Boyer–Moore algorithm</a>.</p>
<p dir="auto">Stochastic relaxation. Markov nodes have a very nice representations as limits of differentiable nodes. Consider an unordered set of rewrite rules where each rule <code>r</code> is assigned a weight <code>w(r)</code>. On each step the interpreter finds all matches for all rules and chooses a random match according to the Boltzmann distribution <code>p(r) ~ exp(-w(r)/t)</code>. Then in the freezing limit <code>t-&gt;0</code> we get a Markov node, ordered by weights. What&#39;s good about this construction, is that for any <code>t&gt;0</code> and for a typical score function, score&#39;s average on multiple runs would be a continuous (and smooth for practical purposes) function of weights. This means that one can find the optimal weights by gradient descent and then freeze the system to get the final discrete program.</p>
<p dir="auto">Read this <a href="https://www.jstor.org/stable/27641983" rel="nofollow">essay</a> by <a href="https://en.wikipedia.org/wiki/Boris_Kushner_(mathematician)" rel="nofollow">Boris Kushner</a> about A. A. Markov and his work in constructive mathematics.</p>
<h2 dir="auto"><a id="user-content-used-work" aria-hidden="true" href="#used-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Used work</h2>
<p dir="auto">Main used work:</p>
<ol dir="auto">
<li>Andrey A. Markov, <a href="http://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;jrnid=tm&amp;paperid=1117&amp;option_lang=eng" rel="nofollow">The Theory of Algorithms</a>, 1951. Markov used these ideas earlier in 1947 in his proof of the algorithmic undecidability of the word problem in semigroups. See also a later <a href="http://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;jrnid=tm&amp;paperid=1178&amp;option_lang=eng" rel="nofollow">book</a> with a more detailed treatment. I would be grateful for links to English translations in open access.</li>
<li>Guilherme S. Tows, <a href="https://zaratustra.itch.io/imagegram" rel="nofollow">Imagegram</a>, 2009. MarkovJunior takes forall-nodes from Imagegram.</li>
<li>Valentin Turchin, <a href="http://fprog.ru/2011/issue7/practice-fp-7-screen.pdf" rel="nofollow">REFAL language</a>, 1968. MJ takes the idea of nested Markov nodes from REFAL.</li>
<li>Brian Walker et al., <a href="https://groups.google.com/forum/#!topic/rec.games.roguelike.development/6yNIuhSerpM" rel="nofollow">The incredible power of Dijkstra maps</a>, 2010. A discussion in the the roguelike community that contains many techniques of using Dijkstra maps/distance fields for procedural generation and NPC AI. Later writeups: <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps" rel="nofollow">1</a>, <a href="http://www.roguebasin.com/index.php?title=Dijkstra_Maps_Visualized" rel="nofollow">2</a>. We generalize Dijkstra maps to arbitrary rewrite rules.</li>
<li>Pavlos S. Efraimidis, Paul Spirakis, <a href="https://utopia.duth.gr/~pefraimi/research/data/2007EncOfAlg.pdf" rel="nofollow">Weighted Random Sampling</a>, 2005.</li>
<li>Work used in custom nodes: <a href="http://graphics.stanford.edu/~pmerrell/thesis.pdf" rel="nofollow">Model Synthesis</a>, <a href="https://github.com/mxgmn/WaveFunctionCollapse">Wave Function Collapse Algorithm</a>, <a href="https://github.com/mxgmn/ConvChain">ConvChain Algorithm</a>.</li>
<li>Classic algorithms: <a href="https://en.wikipedia.org/wiki/Local_consistency" rel="nofollow">constraint propagation</a>, <a href="https://www.cs.ubc.ca/~mack/Publications/AI77.pdf" rel="nofollow">constraint solving algorithms</a>, <a href="https://en.wikipedia.org/wiki/Graph_traversal" rel="nofollow">graph traversal</a>, <a href="https://www.cs.auckland.ac.nz/courses/compsci709s2c/resources/Mike.d/astarNilsson.pdf" rel="nofollow">A* search</a>.</li>
</ol>
<p dir="auto">Related work:</p>
<ol dir="auto">
<li>Daniel Ritchie, <a href="https://dritchie.github.io/pdf/thesis.pdfv" rel="nofollow">Probabilistic Programming for Procedural Modeling and Design</a>, 2016.</li>
<li>Lingfeng Yang, <a href="https://stacks.stanford.edu/file/druid:kq822ym0815/et2si-reduced-opt-augmented.pdf" rel="nofollow">From Execution Traces to Specialized Inference</a>, 2015.</li>
</ol>
<p dir="auto">Sources of examples:</p>
<ol dir="auto">
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/BasicKeys.xml">BasicKeys</a> and <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/Keys.xml">Keys</a> are adaptations of graph grammars formulated by Joris Dormans, <a href="https://www.illc.uva.nl/Research/Publications/Dissertations/DS-2012-12.text.pdf" rel="nofollow">Engineering Emergence: Applied Theory for Game Design</a>, 2012. Which in turn are development of the earlier work by David Adams, <a href="https://pdfs.semanticscholar.org/2502/0f8d955aee07b7dd49a3ec23b1f2a8cf1d06.pdf" rel="nofollow">Automatic Generation of Dungeons for Computer Games</a>, 2002. I use a variation of these models to generate key-lock-bridge puzzles in <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/SeaVilla.xml">SeaVilla</a>.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/CarmaTower.xml">CarmaTower</a> is a proceduralization of a <a href="https://twitter.com/Sir_carma/status/851883489628704768" rel="nofollow">voxel scene</a> by Antoine Lendrevie.</li>
<li>The <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/NystromDungeon.xml">NystromDungeon</a> model is a MarkovJunior port of <a href="https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/" rel="nofollow">Bob Nystrom&#39;s dungeon generator</a>.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/HamiltonianPath.xml">HamiltonianPath</a> algorithm is adapted from <a href="http://aip.scitation.org/doi/pdf/10.1063/1.443937" rel="nofollow">this</a> article. Compare it with an <a href="http://clisby.net/projects/hamiltonian_path/hamiltonian_path_v1.html" rel="nofollow">implementation</a> in a conventional language.</li>
<li>Room shapes in <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/DungeonGrowth.xml">DungeonGrowth</a> are taken from the <a href="https://old.reddit.com/r/proceduralgeneration/comments/3pa8a1/my_take_at_a_roguelike_level_generator_ft/" rel="nofollow">r/proceduralgeneration post</a>. Note that MJ interpreter automatically performs the optimizations described in the post.</li>
<li>The <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Wilson.xml">Wilson</a> model is a rewrite rule formulation of the <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk#Uniform_spanning_tree" rel="nofollow">Wilson&#39;s algorithm</a>. Compare it with an <a href="https://bl.ocks.org/mbostock/11357811" rel="nofollow">implementation</a> in a conventional language.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/MazeGrowth.xml">MazeGrowth</a> model is also known as maze generation via random traversal. Compare it with an <a href="https://bl.ocks.org/mbostock/70a28267db0354261476" rel="nofollow">implementation</a> in a conventional language.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/Growth.xml">Growth</a> is closely related to the <a href="http://digitalassets.lib.berkeley.edu/math/ucb/text/math_s4_v4_article-15.pdf" rel="nofollow">Eden growth model</a>.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/BernoulliPercolation.xml">BernoulliPercolation</a> is a well studied model in a <a href="https://en.wikipedia.org/wiki/Percolation_theory" rel="nofollow">percolation theory</a>.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/NestedGrowth.xml">NestedGrowth</a> is taken from <a href="https://zaratustra.itch.io/imagegram" rel="nofollow">Imagegram</a>.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/SmoothTrail.xml">SmoothTrail</a> is adapted from <a href="https://twitter.com/128_mhz/status/953847394403205120" rel="nofollow">128_mhz&#39;s tweet</a>.</li>
<li><a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/SokobanLevel1.xml">SokobanLevel1</a> seems to be the first level from Hiroyuki Imabayashi&#39;s Sokoban puzzle. <a href="https://xcorr.net/mxgmn/MarkovJunior/blob/main/models/SokobanLevel2.xml">SokobanLevel2</a> is the <a href="https://www.sokobanonline.com/play/web-archive/razorflame/ionic-catalysts-xi/58022_ionic-catalysts-xi-452" rel="nofollow">level 452</a> from Ionic Catalysts XI set.</li>
</ol>
<p dir="auto">Voxel scenes were rendered in <a href="https://ephtracy.github.io/" rel="nofollow">MagicaVoxel</a> by <a href="https://github.com/ephtracy">ephtracy</a>. Special thanks to <a href="https://github.com/unormal">Brian Bucklew</a> for demonstrating the power of Dijkstra fields to me in roguelike level generation and <a href="https://github.com/kchapelier">Kevin Chapelier</a> for a number of good suggestions. The font used in GUI is <a href="https://github.com/sunaku/tamzen-font">Tamzen</a>.</p>
<h2 dir="auto"><a id="user-content-how-to-build" aria-hidden="true" href="#how-to-build"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How to build</h2>
<p dir="auto">MarkovJunior interpreter is a console application that depends only on the standard library. Get <a href="https://dotnet.microsoft.com/download" rel="nofollow">.NET Core</a> for Windows, Linux or macOS and run</p>
<div data-snippet-clipboard-copy-content="dotnet run --configuration Release MarkovJunior.csproj"><pre><code>dotnet run --configuration Release MarkovJunior.csproj
</code></pre></div>
<p dir="auto">Alternatively, download and run the latest <a href="https://github.com/mxgmn/MarkovJunior/releases">release</a> for Windows.</p>
<p dir="auto">Generated results are put into the <code>output</code> folder. Edit <code>models.xml</code> to change model parameters. Open <code>.vox</code> files with <a href="https://ephtracy.github.io/" rel="nofollow">MagicaVoxel</a>.</p>
<h2 dir="auto"><a id="user-content-funding" aria-hidden="true" href="#funding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Funding</h2>
<p dir="auto">MarkovJunior development was <a href="https://github.com/users/mxgmn/sponsorship">funded</a> by</p>
<ol dir="auto">
<li><strong><a href="https://www.embark-studios.com/" rel="nofollow">Embark Studios</a></strong></li>
<li><a href="https://twitter.com/OskSta" rel="nofollow">Oskar Stålberg</a></li>
<li><a href="https://store.steampowered.com/app/333640/Caves_of_Qud/" rel="nofollow">Freehold Games</a></li>
<li><a href="https://bobburrough.com/" rel="nofollow">Bob Burrough</a></li>
</ol>
</article>
          </div></div>
  </body>
</html>
