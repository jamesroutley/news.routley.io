<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pkolaczk.github.io/memory-consumption-of-async/">Original</a>
    <h1>How Much Memory Do You Need to Run 1M Concurrent Tasks?</h1>
    
    <div id="readability-page-1" class="page"><article>
  <header>
  
  <time datetime="2023-05-21T00:00:00+00:00">May 21, 2023</time>
</header>

  <p>In this blog post, I delve into the comparison of memory consumption between asynchronous and multi-threaded programming across popular languages like Rust, Go, Java, C#, Python, Node.js and Elixir.</p>

<!--more-->
<p>Some time ago I had to compare performance of a few computer programs designed to handle
a large number of network connections. I saw huge differences in memory consumption of those programs, even exceeding 20x. Some programs consumed little over 100 MB, but the others
reached almost 3 GB at 10k connections. Unfortunately those programs were quite complex and
differed also in features, so it would be hard to compare them directly and draw some meaningful
conclusions, as that wouldn’t be an apple-to-apple comparison.
This led me to an idea of creating a synthetic benchmark instead.</p>


<p>I created the following program in various programming languages:</p>

<blockquote>
  <p>Let’s launch N concurrent tasks, where each task waits for 10 seconds and then the program exists
after all tasks finish. The number of tasks is controlled by the command line argument.</p>
</blockquote>

<p>With a little help of ChatGPT I could write such program in a few minutes, even in programming languages I don’t use every day. For your convenience, all benchmark code is <a href="https://github.com/pkolaczk/async-runtimes-benchmarks">available on my GitHub</a>.</p>

<h2 id="rust">Rust</h2>
<p>I created 3 programs in Rust. The first one uses traditional threads.
Here is the core of it:</p>
<div><div><pre><code><span>let</span> <span>mut</span> <span>handles</span> <span>=</span> <span>Vec</span><span>::</span><span>new</span><span>();</span>
<span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>num_threads</span> <span>{</span>
    <span>let</span> <span>handle</span> <span>=</span> <span>thread</span><span>::</span><span>spawn</span><span>(||</span> <span>{</span>
        <span>thread</span><span>::</span><span>sleep</span><span>(</span><span>Duration</span><span>::</span><span>from_secs</span><span>(</span><span>10</span><span>));</span>
    <span>});</span>
    <span>handles</span><span>.push</span><span>(</span><span>handle</span><span>);</span>
<span>}</span>
<span>for</span> <span>handle</span> <span>in</span> <span>handles</span> <span>{</span>
    <span>handle</span><span>.join</span><span>()</span><span>.unwrap</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>The two other versions use async, one with <code>tokio</code> and the other one <code>async-std</code>.
Here is the core of the <code>tokio</code> variant:</p>

<div><div><pre><code><span>let</span> <span>mut</span> <span>tasks</span> <span>=</span> <span>Vec</span><span>::</span><span>new</span><span>();</span>
<span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>num_tasks</span> <span>{</span>
    <span>tasks</span><span>.push</span><span>(</span><span>task</span><span>::</span><span>spawn</span><span>(</span><span>async</span> <span>{</span>
        <span>time</span><span>::</span><span>sleep</span><span>(</span><span>Duration</span><span>::</span><span>from_secs</span><span>(</span><span>10</span><span>))</span><span>.await</span><span>;</span>
    <span>}));</span>
<span>}</span>
<span>for</span> <span>task</span> <span>in</span> <span>tasks</span> <span>{</span>
    <span>task</span><span>.await</span><span>.unwrap</span><span>();</span>
<span>}</span>
</code></pre></div></div>
<p>The <code>async-std</code> variant is very similar, so I won’t quote it here.</p>

<h2 id="go">Go</h2>
<p>In Go, goroutines are the building block for concurrency.
We don’t await them separately, but we use a <code>WaitGroup</code> instead:</p>

<div><div><pre><code><span>var</span> <span>wg</span> <span>sync</span><span>.</span><span>WaitGroup</span>
<span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numRoutines</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
    <span>wg</span><span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span>
    <span>go</span> <span>func</span><span>()</span> <span>{</span>
        <span>defer</span> <span>wg</span><span>.</span><span>Done</span><span>()</span>
        <span>time</span><span>.</span><span>Sleep</span><span>(</span><span>10</span> <span>*</span> <span>time</span><span>.</span><span>Second</span><span>)</span>
    <span>}()</span>
<span>}</span>
<span>wg</span><span>.</span><span>Wait</span><span>()</span>
</code></pre></div></div>

<h2 id="java">Java</h2>
<p>Java traditionally uses threads, but JDK 21 offers a preview of virtual threads, which
are a similar concept to goroutines. Therefore I created two variants of the benchmark.
I was also curious how Java threads compare to Rust’s threads.</p>

<div><div><pre><code><span>List</span><span>&lt;</span><span>Thread</span><span>&gt;</span> <span>threads</span> <span>=</span> <span>new</span> <span>ArrayList</span><span>&lt;&gt;();</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numTasks</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>Thread</span> <span>thread</span> <span>=</span> <span>new</span> <span>Thread</span><span>(()</span> <span>-&gt;</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>10</span><span>));</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>e</span><span>)</span> <span>{</span>
        <span>}</span>
    <span>});</span>
    <span>thread</span><span>.</span><span>start</span><span>();</span>
    <span>threads</span><span>.</span><span>add</span><span>(</span><span>thread</span><span>);</span>
<span>}</span>
<span>for</span> <span>(</span><span>Thread</span> <span>thread</span> <span>:</span> <span>threads</span><span>)</span> <span>{</span>
    <span>thread</span><span>.</span><span>join</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>And here is the variant with virtual threads. Note how similar it is! Almost identical!</p>
<div><div><pre><code><span>List</span><span>&lt;</span><span>Thread</span><span>&gt;</span> <span>threads</span> <span>=</span> <span>new</span> <span>ArrayList</span><span>&lt;&gt;();</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numTasks</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>Thread</span> <span>thread</span> <span>=</span> <span>Thread</span><span>.</span><span>startVirtualThread</span><span>(()</span> <span>-&gt;</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>10</span><span>));</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>e</span><span>)</span> <span>{</span>
        <span>}</span>
    <span>});</span>
    <span>threads</span><span>.</span><span>add</span><span>(</span><span>thread</span><span>);</span>
<span>}</span>
<span>for</span> <span>(</span><span>Thread</span> <span>thread</span> <span>:</span> <span>threads</span><span>)</span> <span>{</span>
    <span>thread</span><span>.</span><span>join</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<h2 id="c">C#</h2>
<p>C#, similar to Rust, has first-class support for async/await:</p>
<div><div><pre><code><span>List</span><span>&lt;</span><span>Task</span><span>&gt;</span> <span>tasks</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>Task</span><span>&gt;();</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numTasks</span><span>;</span> <span>i</span><span>++)</span>
<span>{</span>
    <span>Task</span> <span>task</span> <span>=</span> <span>Task</span><span>.</span><span>Run</span><span>(</span><span>async</span> <span>()</span> <span>=&gt;</span>
    <span>{</span>
        <span>await</span> <span>Task</span><span>.</span><span>Delay</span><span>(</span><span>TimeSpan</span><span>.</span><span>FromSeconds</span><span>(</span><span>10</span><span>));</span>
    <span>});</span>
    <span>tasks</span><span>.</span><span>Add</span><span>(</span><span>task</span><span>);</span>
<span>}</span>
<span>await</span> <span>Task</span><span>.</span><span>WhenAll</span><span>(</span><span>tasks</span><span>);</span>
</code></pre></div></div>

<h2 id="nodejs">Node.JS</h2>
<p>So does Node.JS:</p>
<div><div><pre><code><span>const</span> <span>delay</span> <span>=</span> <span>util</span><span>.</span><span>promisify</span><span>(</span><span>setTimeout</span><span>);</span>
<span>const</span> <span>tasks</span> <span>=</span> <span>[];</span>

<span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numTasks</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>tasks</span><span>.</span><span>push</span><span>(</span>
        <span>(</span><span>async</span> <span>()</span> <span>=&gt;</span> <span>{</span>
            <span>await</span> <span>delay</span><span>(</span><span>10000</span><span>);</span>
        <span>})()</span>
    <span>);</span>
<span>}</span>

<span>await</span> <span>Promise</span><span>.</span><span>all</span><span>(</span><span>tasks</span><span>);</span>
</code></pre></div></div>
<h2 id="python">Python</h2>
<p>And Python added async/await in 3.5, so we can write:</p>
<div><div><pre><code><span>tasks</span> <span>=</span> <span>[]</span>

<span>for</span> <span>task_id</span> <span>in</span> <span>range</span><span>(</span><span>num_tasks</span><span>):</span>
    <span>task</span> <span>=</span> <span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>await</span> <span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>10</span><span>))</span>
    <span>tasks</span><span>.</span><span>append</span><span>(</span><span>task</span><span>)</span>

<span>await</span> <span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>*</span><span>tasks</span><span>)</span>
</code></pre></div></div>

<h2 id="elixir">Elixir</h2>
<p>Elixir is famous for its async capabilities as well:</p>

<div><div><pre><code><span>tasks</span> <span>=</span>
    <span>for</span> <span>_</span> <span>&lt;-</span> <span>1</span><span>..</span><span>num_tasks</span> <span>do</span>
        <span>Task</span><span>.</span><span>async</span><span>(</span><span>fn</span> <span>-&gt;</span>
            <span>:timer</span><span>.</span><span>sleep</span><span>(</span><span>10000</span><span>)</span>
        <span>end</span><span>)</span>
    <span>end</span>

<span>Task</span><span>.</span><span>await_many</span><span>(</span><span>tasks</span><span>,</span> <span>:infinity</span><span>)</span>
</code></pre></div></div>


<ul>
  <li>Hardware: Intel(R) Xeon(R) CPU E3-1505M v6 @ 3.00GHz</li>
  <li>OS: Ubuntu 22.04 LTS, Linux p5520 5.15.0-72-generic</li>
  <li>Rust: 1.69</li>
  <li>Go: 1.18.1</li>
  <li>Java: OpenJDK “21-ea” build 21-ea+22-1890</li>
  <li>.NET: 6.0.116</li>
  <li>Node.JS: v12.22.9</li>
  <li>Python: 3.10.6</li>
  <li>Elixir: Erlang/OTP 24 erts-12.2.1, Elixir 1.12.2</li>
</ul>

<p>All programs were launched using the release mode if available.
Other options were left default.</p>




<p>Let’s start from something small. Because some runtimes require some memory
for themselves, let’s first launch only one task.</p>



<div>
    
    
    <p><span> Fig.1: Peak memory needed to launch one task</span>
</p></div>

<p>We can see there are certainly two groups of programs.
Go and Rust programs, compiled statically to native binaries, need very little memory.
The other programs running on managed platforms or through interpreters consume way more memory.
There is over an order of magnitude difference in memory consumption between those two groups.</p>

<p>It is a surprise to me that .NET somehow has the worst footprint, but I guess
this can be tuned with some settings maybe. Let me know in the comments if there are
any tricks. I haven’t seen much difference between the debug and release modes.</p>

<h2 id="10k-tasks">10k Tasks</h2>

<div>
    
    
    <p><span> Fig.2: Peak memory needed to launch 10,000 tasks</span>
</p></div>

<p>A few surprises here! Everybody probably expected that threads would be a big loser of this
benchmark. And this is true for Java threads, which indeed consumed almost 250 MB of RAM.
But native Linux threads used from Rust seem to be lightweight enough that at 10k threads the memory consumption is still lower than the idle memory consumption of many other runtimes. Async tasks or virtual (green) threads might be lighter than native threads, but we won’t see that advantage at only 10k tasks. We need more tasks.</p>

<p>Another surprise here is Go. Goroutines are supposed to be very lightweight, but they
actually consumed more than 50% of RAM required by Rust threads. Honestly, I was expecting
much bigger difference in favor of Go. Hence, I conclude that at 10k concurrent tasks, threads are still quite a competitive alternative. Linux kernel definitely does something right here.</p>

<p>Go has also lost its tiny advantage it had over Rust async
in the previous benchmark and now it consumes over 6x more memory than the best Rust program.
Actually, it hasn’t even won with Python (the difference between those two is very small, let’s consider it a tie).</p>

<p>And the final surprise is that at 10k tasks the memory consumption for some of the runtimes
didn’t significantly go up from the idle memory use. This is e.g. true for C# and Python.
Probably those managed runtimes just use preallocated memory. Or their idle memory use
is so high that 10k tasks is just too few to matter.</p>

<h2 id="100k-tasks">100k Tasks</h2>
<p>I could not launch 100,000 threads on my system, so the threads benchmarks had to be excluded.
Probably this could be somehow tweaked byt changing system settings,
but after trying for an hour I gave up. So at 100k tasks you probably don’t want to use threads.</p>

<p>Python also gave up with
<code>TypeError: a coroutine was expected, got None</code> error.</p>

<div>
    
    
    <p><span> Fig.3: Peak memory needed to launch 100,000 tasks</span>
</p></div>

<p>At this point the Go program has been beaten up not only by Rust, but also by Java, C# and Node.JS.</p>

<p>And Linux .NET likely cheats because its memory use still didn’t go up. ;) I had to double check if it really launches the right number of tasks, but indeed, it does. And it still exits after about 10 seconds, so it doesn’t block the main loop. Magic! Good job, .NET.</p>

<h2 id="1-million-tasks">1 Million Tasks</h2>
<p>Let’s go extreme now.</p>

<p>At 1 million tasks, Elixir gave up with <code>** (SystemLimitError) a system limit has been reached</code>.
The others still stayed in the game, though.</p>

<div>
    
    
    <p><span> Fig.4: Peak memory needed to launch 1 million tasks</span>
</p></div>

<p>Finally we see the increase in memory consumption of a C# program. But it is still
very competitive. It even managed to slightly beat one of the Rust runtimes!</p>

<p>The distance between Go and others increased. Now Go loses over 12x to the winner. It also
loses over 2x to Java, which contradicts the general perception of JVM
being a memory hog and Go being lightweight.</p>

<p>Rust <code>tokio</code> remained unbeatable. This isn’t surprising after seeing how it did at 100k tasks.</p>


<p>As we have observed, a high number of concurrent tasks can consume a significant amount of memory, even if they do not perform complex operations. Different language runtimes have varying trade-offs, with some being lightweight and efficient for a small number of tasks but scaling poorly with hundreds of thousands of tasks. Conversely, other runtimes with high initial overhead  can handle high workloads effortlessly. It is important to note that not all runtimes were even capable of handling a very large number of concurrent tasks with default settings.</p>

<p>This comparison focused solely on memory consumption, while other factors such as task launch time and communication speed are equally important. Notably, at 1 million tasks, I observed that the overhead of launching tasks became evident, and most programs required more than 12 seconds to complete. Stay tuned for upcoming benchmarks, where I will explore additional aspects in depth.</p>


  





  
    <hr/>
    
        
      
      
       
    
    
  
</article></div>
  </body>
</html>
