<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eta.st/2023/01/31/rail-tickets.html">Original</a>
    <h1>Reversing UK mobile rail tickets</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>The UK has used small credit-card sized tickets to pay for train travel for years and years, since long before I was born — originally the
<a href="https://en.wikipedia.org/wiki/APTIS_ticket_features">APTIS ticket</a><sup id="fnref:aptis" role="doc-noteref"><a href="#fn:aptis" rel="footnote">1</a></sup>,
which later got replaced by a
<a href="https://en.wikipedia.org/wiki/2014_National_Rail_ticket_features">slightly easier to read version</a> printed onto the same stock.</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/ticket.jpg" alt="a National Rail paper ticket"/></p>

<p>Nowadays, the industry would very much like you to ditch your paper ticket in favour of a fancy mobile barcode one (or
an <a href="https://en.wikipedia.org/wiki/ITSO_Ltd">ITSO</a> smartcard<sup id="fnref:itso" role="doc-noteref"><a href="#fn:itso" rel="footnote">2</a></sup>); not
only do they not have to spend money on printing tickets but they also gain the ability to more precisely track the ticket’s usage across the network
and minimise fraud.</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/why-mobile.png" alt="promotional material about the benefits of mobile ticketing"/></p>

<p>There are obvious benefits for the user too — I’m willing to bet most people use the mobile tickets anyway, since they’re just easier
if you’re booking your train travel in an app like <a href="https://www.thetrainline.com/">Trainline</a>.</p>

<p>But what data is inside the barcode of a mobile ticket, and how do they work? Could people who aren’t ticket inspectors get the data out of them?
It turns out that the answer is a bit more interesting than I initially expected!</p>

<h2 id="initial-explorations">Initial explorations</h2>

<p>A mobile ticket is just an <a href="https://en.wikipedia.org/wiki/Aztec_Code">Aztec barcode</a>, either displayed inside an app or on a PDF you can print out:</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/initial-ticket.png" alt="image of a Trainline ticket barcode, from Cathays (CYS) to Cardiff Queen St (CDQ), UTN TTDNQMCQF6S"/></p>

<p>Googling around for prior work people had done decoding mobile tickets, I found
<a href="https://de.wikipedia.org/w/index.php?title=Diskussion:Online-Ticket&amp;oldid=198973306#Barcode">a bunch of discussion</a> (German-language link) about UIC 918.3,
a specification used by the German railway company Deutsche Bahn for their e-tickets. These also use the Aztec barcode format and looked superficially
similar — and some people had already written code to read them. Maybe this could work?</p>

<p>(Why would I expect this to work? Well, the UIC is the international standards body for railways — in Europe at least —
so it’s reasonable to assume they might’ve used a standard format here.)</p>

<p>However, the formats are sadly nothing alike — decoding our UK barcode using <a href="https://github.com/zxing/zxing">zxing</a>, we get:</p>

<pre>06DNQL4XHVK00TTRCGPUQWNTHPGHWBPOUTKRWXAJKGHFBAPBCTOGUZQVTZTKKDEBQXPGRWZJRJBXJZPOHNJGIPDJWEGYWJXLVPGEEZBCUUELIJMOINPRZMSDQCZJGLIZLUTQHXMTPKWCMJISUXQLORAOVYXSOLGXXGMVUDXTMHAYMBLUTKPUPFCRNNTDBBDLNWSBPDUXYKSIMJSBYBURSCPUMFBZPEUTECHTIOXAH
</pre>

<p>…which looks nothing like you might expect a UIC barcode to look, given the latter are supposed to start with “#UT”
(according to the discussion in German earlier).</p>

<p>In fact, this is a custom standard that is only used inside the UK, as the “06” at the start of the data hints at; this is an “RSP-6” ticket
(as in RSP for <a href="https://en.wikipedia.org/wiki/Rail_Settlement_Plan">Rail Settlement Plan</a>), which Google doesn’t seem to know much about.
It is possible to find a <a href="https://www.whatdotheyknow.com/request/rsp_6_specification_for_barcodes_2">Freedom of Information Act request</a> someone made
asking for the spec that never got a response — sadly the Rail Delivery Group (RDG), technically a private company, doesn’t actually have to respond
to such requests, so I’d have to figure this out myself.</p>

<h2 id="a-friendly-wolf-comes-to-help">A friendly wolf comes to help</h2>

<p>At this point, I basically had no idea how to continue. Comparing multiple tickets, the data seemed to be mostly random apart from some fixed headers,
suggesting that it was probably encrypted in some way — I couldn’t just get lots of tickets and hope to find similarities between them.</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/binwalk.png" alt="photo of &#39;binwalk -W cdq-cys.bin pad-aml.bin&#39;, showing no shared data apart from a few random bytes and some headers"/></p>

<p><em>image: output of <code>binwalk -W cdq-cys.bin pad-aml.bin</code>, which highlights similarities and differences between two tickets<sup id="fnref:binwalk" role="doc-noteref"><a href="#fn:binwalk" rel="footnote">3</a></sup></em></p>

<p>My friend Harley (“<a href="https://lobi.to/">unlobito</a>”) had noticed me complaining about tickets in a shared group chat and had a clue for me:
the word “masabi”, which turned out to be the name of <a href="https://www.masabi.com/">a ticketing company</a>.</p>

<p>Masabi’s website has <a href="https://www.masabi.com/justride-uk-rail/">this lovely page</a> where they explain all about how they invented mobile
ticketing in the UK in 2007 and how the RSP6 national standard was actually written by them! They also boast about how their
“JustRide Inspect” suite of apps can be used to decode these tickets.</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/justride-web.png" alt="Masabi promotional copy about their Inspect app"/></p>

<p>We sadly can’t just get this app off the Play Store. However, after some googling around you can totally get it from one of those less
than official APK rehosting websites.</p>

<p>With the APK in hand there are a number of things we can do. We can just install it on an Android device and see whether it’ll give up
anything interesting that way; we can also try to “decompile” it, to get a better idea of how the app (and the ticket parser) works.</p>

<h2 id="running-the-app">Running the app</h2>

<p>Since I didn’t have any spare throwaway Android phones and that the APK might be malware, my first step was to just run it
inside an 
<a href="https://developer.android.com/studio/run/managing-avds">Android Virtual Device</a> (using the emulator in Android Studio).
I reckoned this would be a bit safer than just installing it on my main Android phone.<sup id="fnref:avd" role="doc-noteref"><a href="#fn:avd" rel="footnote">4</a></sup></p>

<p>After a bit of fiddling about, I had it doing something:</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/app-screen1.png" alt="Inspect app showing &#34;Scan config barcode&#34; screen"/></p>

<p>Unfortunately, this wasn’t very useful — it wouldn’t scan standard ticket barcodes in this form. The “Login manually” button lets you
choose a Train Operating Company (TOC) to sign in as (some of the companies mentioned don’t even exist any more!), which was pretty
interesting but not useful for our goals:</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/app-screen2.png" alt="Inspect app showing list of TOCs"/></p>

<p>I don’t work for a train operating company, so clearly it wasn’t going to be possible for me to proceed<sup id="fnref:notoc" role="doc-noteref"><a href="#fn:notoc" rel="footnote">5</a></sup>.
Maybe examining the app another way could get us somewhere?</p>

<h2 id="decompiling-the-app">Decompiling the app</h2>

<p>You can point Android Studio at an APK and have it analyse what’s inside. Sort of.</p>

<p>If you try this (via the 3-dot menu in the project chooser → “Profile or Debug APK”), you get something that’s not entirely useful:
a bunch of weird looking “smali” files.</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/smalis.png" alt="Android Studio showing debug view of the APK"/></p>

<p>This is because the APK only contains compiled bytecode, rather than any useful source code; as the yellow warning banner notes,
this is stored inside the APK in <a href="https://source.android.com/docs/core/runtime/dex-format">.dex format</a>
(“Dalvik Executable”, where Dalvik is the name of the Android VM), and
<a href="https://github.com/JesusFreke/smali">smali</a> is just a human-readable representation someone invented for this format (like Assembly).</p>

<p>What we ideally need is something that can turn the bytecode all the way back into Java. Such a tool exists in the form of
<a href="https://github.com/skylot/jadx">jadx</a>, a very handy tool that not only does just that, but can also do a bunch of other
cool stuff like outputting a project Android Studio can load (and theoretically compile)!</p>

<pre>$ jadx --deobf -e -d out ~/Downloads/justride-inspect.apk
INFO  - loading ...
INFO  - processing ...
INFO  - done                                                 
$ ls out/
app  build.gradle  settings.gradle
</pre>

<h2 id="making-sense-of-the-decompiled-output">Making sense of the decompiled output</h2>

<p>When I looked in jadx’s output directory I found a perfect copy of the original source code that Masabi had written,
and my job was then very easy. Wait, no, that’s a lie.</p>

<p>Before shipping an APK to the end user, Android app developers usually run it through a number of steps to make it smaller
including “obfuscation” — turning long class and member names like “mContext” into the smallest string they can get away with, like “a”.
This means that the code jadx generated is rather hard to make sense of:</p>

<figure><pre><code data-lang="java"><span>public</span> <span>class</span> <span>TicketInspectActivity</span> <span>extends</span> <span>BaseActivity</span> <span>implements</span> <span>InterfaceC2526a</span> <span>{</span>

   <span>/* renamed from: c */</span>
   <span>private</span> <span>ViewPager</span> <span>f4615c</span><span>;</span>

   <span>/* JADX INFO: Access modifiers changed from: private */</span>
   <span>/* renamed from: h */</span>
   <span>public</span> <span>C2496p</span> <span>m1419h</span><span>()</span> <span>{</span>
       <span>return</span> <span>(</span><span>C2496p</span><span>)</span> <span>this</span><span>.</span><span>f4615c</span><span>.</span><span>getAdapter</span><span>();</span>
   <span>}</span>

   <span>@Override</span> <span>// com.masabi.app.android.ticketcheck.activities.BaseActivity</span>
   <span>/* renamed from: a */</span>
   <span>public</span> <span>final</span> <span>void</span> <span>mo1410a</span><span>()</span> <span>{</span>
       <span>super</span><span>.</span><span>mo1410a</span><span>();</span>
       <span>if</span> <span>(</span><span>isFinishing</span><span>())</span> <span>{</span>
           <span>return</span><span>;</span>
       <span>}</span>
       <span>m1419h</span><span>().</span><span>m1467a</span><span>(</span><span>this</span><span>.</span><span>f4615c</span><span>.</span><span>getCurrentItem</span><span>());</span>
   <span>}</span>
   <span>/* ... */</span>
<span>}</span></code></pre></figure>

<p>Mmm yes, I knew exactly what they meant when they named their class <code>C2496p</code>. Of course! We just need to trace the execution
of <code>void mo1410a()</code> and then we’ll figure it all out!<sup id="fnref:jadx" role="doc-noteref"><a href="#fn:jadx" rel="footnote">6</a></sup></p>

<p>Despite this looking daunting at first it’s actually quite okay with the tools Android Studio gives us. Not everything is completely obfuscated:
some class names need to be left deobfuscated, such as activities (like this <code>TicketInspectActivity</code>). That lets us get some idea of
where to start. The code also occasionally contains error messages that give away what the classes and methods are supposed to be:</p>

<figure><pre><code data-lang="java"><span>/* renamed from: com.masabi.c.a */</span>
<span>/* loaded from: classes.dex */</span>
<span>public</span> <span>final</span> <span>class</span> <span>C2666a</span> <span>{</span>
   <span>/* renamed from: a */</span>
   <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>m552a</span><span>(</span><span>Calendar</span> <span>calendar</span><span>)</span> <span>{</span>
       <span>if</span> <span>(</span><span>calendar</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
           <span>System</span><span>.</span><span>err</span><span>.</span><span>println</span><span>(</span><span>&#34;DateTimeUtils.packDate() ERROR - Attempt to pack a null date!&#34;</span><span>);</span>
       <span>}</span>
       <span>return</span> <span>(</span><span>C2668c</span><span>.</span><span>m542a</span><span>(</span><span>calendar</span><span>)</span> <span>&lt;&lt;</span> <span>16</span><span>)</span> <span>|</span> <span>(</span><span>C2667b</span><span>.</span><span>m548a</span><span>(</span><span>calendar</span><span>)</span> <span>&amp;</span> <span>65535</span><span>);</span>
   <span>}</span>
   <span>/* ... */</span>
<span>}</span></code></pre></figure>

<p>In this case, the log line lets us instantly rename <code>C2666a</code> → <code>DateTimeUtils</code>, and <code>m552a</code> → <code>packDate</code>.</p>

<p>Android Studio also has excellent support for doing renames across an entire codebase at once, so after a long afternoon
picking things apart it quickly started to take shape and our obfuscated code began to look something like the original source code
might have looked<sup id="fnref:osource" role="doc-noteref"><a href="#fn:osource" rel="footnote">7</a></sup>.</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/refactor-this.png" alt="the Refactor → Rename menu in Android Studio"/></p>

<h2 id="interesting-uses-of-rsa">Interesting uses of RSA</h2>

<p>My investigations into the app confirmed my suspicions that the data was indeed encrypted — well, not quite. Technically, the ticket data
is actually <em>signed</em> with RSA and <a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS#1</a> (I think). Ticket issuers generate a payload containing the
ticket data, pad it a bit, and then use their RSA private key to create a signed message they put into the barcode. A ticket scanner has a set
of the issuers’ public keys on hand to verify the signature and read the original payload.</p>

<p>As a more concrete example, some vague Rust code to do the verification and reading steps looks a bit like this:</p>

<figure><pre><code data-lang="rust"><span>// BigUint is an arbitrary size unsigned integer.</span>
<span>// The ticket is base26 encoded, so we need to undo that first:</span>
<span>let</span> <span>ticket</span><span>:</span> <span>BigUint</span> <span>=</span> <span>base26_decode</span><span>(</span><span>&amp;</span><span>ticket_str</span><span>[</span><span>15</span><span>..</span><span>]);</span>
<span>// this is doing “S^e mod N”;</span>
<span>// i.e. part of RSA signature verification</span>
<span>let</span> <span>message</span> <span>=</span> <span>ticket</span><span>.modpow</span><span>(</span><span>&amp;</span><span>key</span><span>.public_exponent</span><span>,</span> <span>&amp;</span><span>key</span><span>.modulus</span><span>);</span>
<span>// convert big integer into raw bytes (big-endian)</span>
<span>let</span> <span>message</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>=</span> <span>message</span><span>.to_bytes_be</span><span>();</span>
<span>// attempt to strip PKCS#1 padding; if it fails, the key is wrong</span>
<span>if</span> <span>let</span> <span>Some</span><span>(</span><span>unpadded</span><span>)</span> <span>=</span> <span>strip_padding</span><span>(</span><span>&amp;</span><span>message</span><span>)</span> <span>{</span>
   <span>eprintln!</span><span>(</span><span>&#34;[+] decrypt done: {:?}&#34;</span><span>,</span> <span>unpadded</span><span>);</span>
<span>}</span></code></pre></figure>

<p>I’m not a cryptographer, so this was all somewhat new to me! I was used to signatures being a <a href="https://en.wikipedia.org/wiki/Hash_function">hash</a>
of the original message (i.e. you’d send the plaintext, and then <code>sign(hash(plaintext))</code> along with it), which is usually done
so that you can <a href="https://crypto.stackexchange.com/questions/9896/how-does-rsa-signature-verification-work">sign messages longer than the size of your keys</a>.
In this case, they’ve put the <em>whole</em> message inside the signature to save space on the barcode, meaning you need the public keys to read the message at all.</p>

<p>You also can’t make your own fraudulent tickets using this scheme; you’d need the RSA private key of one of the ticket issuers to do that,
or to have a custom public key added to the network of gate readers and ticket inspectors’ apps, neither of which seem easy to do.</p>

<details>
<summary>Some further details on the cryptography (click to expand)</summary>
<div>
<p>How can you tell that the ticket payload was unwrapped correctly? The payload is padded in a way that I think corresponds to some of the
algorithms in PKCS#1 (see <a href="https://www.rfc-editor.org/rfc/rfc8017">RFC 8017</a>); it&#39;ll either be</p>

<p>
Scheme 1: <code>padded = [0x00, 0x01, padding-string, 0x00, message]</code></p>

<p>
or
</p>

<p>
Scheme 2: <code>padded = [0x00, 0x02, padding-string, 0x00, message]</code></p>

<p>If the payload doesn&#39;t look like either of these, the RSA operation failed, so you probably have the wrong key and should try another one.</p>
</div>
</details>

<p>So the public keys are required knowledge for actually being able to decode these tickets. Where do we get those from?</p>

<h2 id="obtaining-the-elusive-public-keys">Obtaining the elusive public keys</h2>

<p>The public keys aren’t really published anywhere obvious, and reversing the Masabi app seems to indicate that it downloads the keys from a
configuration server once you scan the config barcode mentioned earlier.</p>

<figure><pre><code data-lang="java"><span>Global</span><span>.</span><span>logger</span><span>.</span><span>log</span><span>(</span><span>getClass</span><span>().</span><span>getSimpleName</span><span>(),</span> <span>&#34;loadAllKeys() - Fetched &#34;</span> <span>+</span> <span>barcodeKeysList</span><span>.</span><span>length</span> <span>+</span> <span>&#34; barcode keys from metadata&#34;</span><span>);</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>barcodeKeysList</span><span>.</span><span>length</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
   <span>AbstractJSONObject</span> <span>key</span> <span>=</span> <span>(</span><span>barcodeKeysList</span><span>[</span><span>i2</span><span>];</span>
   <span>if</span> <span>(</span><span>ExtendedGlobal2</span><span>.</span><span>clock</span><span>.</span><span>getCurrentTime</span><span>()</span> <span>&lt;</span> <span>Global</span><span>.</span><span>f4949d</span><span>.</span><span>mo915a</span><span>(</span><span>key</span><span>.</span><span>getString</span><span>(</span><span>&#34;expiryDate&#34;</span><span>))</span> <span>*</span> <span>1000</span> <span>&amp;&amp;</span>
           <span>(</span><span>decoder</span> <span>=</span> <span>makeDecoder</span><span>(</span><span>key</span><span>.</span><span>getString</span><span>(</span><span>&#34;issuerId&#34;</span><span>),</span> <span>key</span><span>.</span><span>getString</span><span>(</span><span>&#34;ticketType&#34;</span><span>),</span> <span>key</span><span>.</span><span>getString</span><span>(</span><span>&#34;modulus&#34;</span><span>),</span> <span>key</span><span>.</span><span>getString</span><span>(</span><span>&#34;exponent&#34;</span><span>),</span> <span>key</span><span>.</span><span>getLong</span><span>(</span><span>&#34;mQ&#34;</span><span>)))</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
       <span>decoders</span><span>.</span><span>addElement</span><span>(</span><span>decoder</span><span>);</span>
   <span>}</span>
<span>}</span></code></pre></figure>

<p>You’d think this would be a dead end, since we don’t have any login credentials — but they also just left some keys inside the APK
as well. As far as I can tell no part of the app actually reads these; maybe it did in the past, or maybe they used them for testing and
forgot to take them out of the production version of the app.</p>

<pre>$ find . | grep &#39;keys&#39; | grep rsp6
./app/src/main/assets/keys/rsp6_rsa_ao.dat
./app/src/main/assets/keys/rsp6_rsa_ua.dat
./app/src/main/assets/keys/rsp6_rsa_tt-qa.dat
./app/src/main/assets/keys/rsp6_rsa_tt.dat
./app/src/main/assets/keys/rsp6_rsa_t3.dat
./app/src/main/assets/keys/rsp6_rsa_t2.dat
</pre>

<p>The keys are split up by ticket issuer, a 2-character code that forms the first part of the ticket ID. This ticket from earlier was issued
by Trainline, who have issuer code <strong>TT</strong>…</p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/initial-barcode.png" alt="barcode of the earlier ticket"/></p>

<p>…and the keys to decode this ticket are in <code>rsp6_rsa_<b>tt</b>.dat</code>. Nice!<sup id="fnref:datfile" role="doc-noteref"><a href="#fn:datfile" rel="footnote">8</a></sup></p>

<p>This is only a subset of all the keys that are being used today though, as I quickly discovered when
<a href="https://lobi.to/">unlobito</a> gave me an <a href="https://www.avantiwestcoast.co.uk/">Avanti West Coast</a> ticket to decode.
The copy of the app I have is only from 2016 and a bunch more TOCs have started issuing mobile tickets since then!</p>

<h2 id="ttkmobile">ttkMobile</h2>

<p>Around when I was figuring all of this out <a href="https://twitter.com/puckipedia">puck</a> pointed me towards the website for
<a href="http://info.theticketkeeper.com/">The Ticket Keeper</a>, another firm who makes ticket validation and issuance tooling.
They have an iOS app for ticket inspectors called <strong>ttkMobile</strong>, which you can just
<a href="https://apps.apple.com/gb/app/ttkmobile/id921166994">download straight off the App Store</a> and use to start validating tickets at home!<sup id="fnref:ttk" role="doc-noteref"><a href="#fn:ttk" rel="footnote">9</a></sup></p>

<p><img src="https://www.geoffreylitt.com/assets/img/rsp6/ttkmobile.jpg" alt="screenshot of ttkMobile"/></p>

<details>
<summary>Important note if you actually intend to use this app (click to expand)</summary>
<p>Be warned!</p>

<p>If you install this app, you can’t ever uninstall it and expect it to work after a reinstall.
On first load it registers your device UUID with some server and generates a random password that it stores in local storage.
Uninstalling the app removes the password, but your device UUID doesn’t change, so next time you reinstall, it won’t be able
to authenticate and it’ll be useless (since it needs to grab keys and stuff to work).</p>

<p>(“But wait,” I hear you cry, “isn’t getting a persistent device ID exactly what Apple don’t want you to do?” And you’d be right! Technically, I believe
the device UUID actually <i>does</i> change between installs, but they store a copy in the device keychain, which doesn’t get wiped
when you remove the app. This is stupid, and almost certainly a contravention of App Store policy.)</p>
</details>

<p>I don’t have an iPhone, but some of my friends do. unlobito and another friend,
Eva (“<a href="https://muffinti.me/">thejsa</a>”), had a poke around and managed to get me a DRM-free<sup id="fnref:nodrm" role="doc-noteref"><a href="#fn:nodrm" rel="footnote">10</a></sup> <a href="https://en.wikipedia.org/wiki/.ipa"><code>.ipa</code></a>
containing the app, which I could unwrap and decompile with the help of <a href="https://ghidra-sre.org/">Ghidra</a>.
This let me figure out some of the pieces of the ticket that the Masabi app didn’t look at.</p>

<p><a href="https://muffinti.me/">thejsa</a> also spent some time running the app through a proxy in order to find out how it
communicates with the server<sup id="fnref:thejsa" role="doc-noteref"><a href="#fn:thejsa" rel="footnote">11</a></sup>, and it turns out there’s just an endpoint where you can get all of the public keys:</p>

<pre>$ curl &#39;https://device.theticketkeeper.com/download_keys?device_name=abc&#39; | jq .
{
  &#34;return_code&#34;: &#34;ok&#34;,
  &#34;message&#34;: null,
  &#34;keys&#34;: {
    &#34;AA&#34;: [
      {
        &#34;valid_from&#34;: &#34;20000101000000&#34;,
        &#34;valid_until&#34;: &#34;29991231000000&#34;,
        &#34;public_exponent_hex&#34;: &#34;10001&#34;,
        &#34;modulus_hex&#34;: &#34;9140AA61F7D9A2E943C0510BACA5FA9CA7D12D78E301A36D640F2D28D8C0AA4D6A7102555CECF138E467730B797509EC1AB5BBA77CA6384BC8F483F609B121E75AE42660EDFE15EF91ADD4DA68C355F830FAAC6FFB25FBCFE1E61C7AF37C4AE8C85E264C151BD9C9AA4DE41D2756A9E260C0CC89AE2ADDD19E452A675E88DA47&#34;,
        &#34;public_key_x509&#34;: null,
        &#34;test_only&#34;: &#34;N&#34;,
        &#34;updated&#34;: &#34;20200313175331&#34;
      },
[etc]
</pre>

<p>As I mentioned earlier, this is crucial information to be able to decode tickets at all,
so thanks go to The Ticket Keeper developers for making it available so easily!</p>

<h3 id="brief-aside-on-freedom-of-information">Brief aside on freedom of information</h3>

<p>I don’t know whether people in the industry (e.g. the Rail Delivery Group)
will be upset with me publishing this information or not.
I hope they won’t be: I really think the public keys should be made available to the public, along with the official specifications for decoding.
The tickets are signed, so it’s not as if there’s any practical danger — people can’t use this to start forging tickets en masse, for example —
and there are lots of potential innovative uses for this data. Imagine for example a journey logger that used ticket scans to track where you’d
been automatically, or an expenses system that used the price information encoded in the ticket to automatically log expense requests!</p>

<p>The railways might be run by a consortium of private companies, but they are in effect a public service owned and controlled
by the Government<sup id="fnref:erma" role="doc-noteref"><a href="#fn:erma" rel="footnote">12</a></sup> (as of Jan 2023), so they really should be subject to the same Freedom of Information Act provisions as other public bodies.</p>

<p>Some people in the industry already have the right idea; in conversation with one of the Ticket Keeper developers over email,
I was made aware that the ttkMobile app being public along with some of this data is actually an intentional choice, which is really nice to see!</p>

<h3 id="bonus-etvd-logs">Bonus: eTVD logs</h3>

<p>The website also tells you how they have an electronic Ticket Validation Database (<a href="http://info.theticketkeeper.com/services/etvd/">eTVD</a>)
that has a copy of all ticket scans at gatelines and by people using their app. This is the anti-fraud thing I mentioned at the very start; this sort
of data is presumably very useful to revenue protection staff trying to figure out systematic fare evasion, like short-faring<sup id="fnref:shortfare" role="doc-noteref"><a href="#fn:shortfare" rel="footnote">13</a></sup>.</p>

<p>What it doesn’t tell you, though, is that the app will also give you this information unauthenticated, with nothing more than a ticket’s ID (!).</p>

<p>
This was reported to the developers as a possible security issue / data leak on 2023-01-19. They confirmed it was intended behaviour, but
agreed that it would probably be a good idea to restrict it; I&#39;m told this will happen soon.
</p>

<p>This information can be quite disturbingly detailed, even pinpointing the exact username of the inspector who scanned you,
where you were scanned, on what exact train service you were scanned, whether it succeeded, and a bunch more stuff.
Helpfully it’ll also sometimes give you the entire barcode data, and what the ticket server thinks it decodes as, too!</p>

<pre># getting scan history information for ticket CBCZSCDPVFF
# (this is massively cut down; there are more fields in reality)
$ curl &#39;https://device.theticketkeeper.com/get_ticket_details?device_name=abc&amp;utn=CBCZSCDPVFF&#39; | jq &#39;.[&#34;ticket_detail&#34;][&#34;scans&#34;]&#39;
[
  {
    &#34;event_time_iso&#34;: &#34;2022-06-10T18:30:47&#34;,
    &#34;created&#34;: &#34;2022-06-10T18:30:48&#34;,
    &#34;device_type&#34;: &#34;ttkMobile&#34;,
    &#34;device_id&#34;: 1001,
    &#34;device_name&#34;: &#34;f95396f5-da22-47f9-8e85-dff4b2294a5d&#34;,
    &#34;device_alias&#34;: &#34;2021-TK10212&#34;,
    &#34;username&#34;: &#34;JLazlo01&#34;,
    &#34;action_name&#34;: &#34;Accepted&#34;,
    &#34;rsp_action_code&#34;: 4001,
    &#34;event_trigger&#34;: &#34;scan&#34;,
    &#34;scan_mode&#34;: &#34;clip&#34;,
    &#34;scan_nlc&#34;: &#34;2728&#34;,
    &#34;validation_result&#34;: &#34;warning&#34;,
    &#34;message_displayed&#34;: &#34;16-25 Railcard&#34;,
    &#34;gate_id&#34;: &#34;OPN-3002i[021502]&#34;,
    &#34;latitude&#34;: 51.7824963,
    &#34;longitude&#34;: -0.2141781,
    &#34;device_scan_id&#34;: 74402,
    &#34;train_uid&#34;: &#34;L77572&#34;,
    &#34;departure_date&#34;: &#34;2022-06-10&#34;,
    &#34;barcode&#34;: &#34;06CZSCDPVFF00…&#34;,
    &#34;train_info&#34;: &#34;Fr1803 KGX-SKI 1D26/GR2600&#34;,
    # etc
  },
  # etc
]
</pre>

<p>So yeah, your ticket barcode — or its ID, which is often written below the code in plain text —
might let someone access a surprising amount of detailed tracking information as to where you are and what trains you’re taking!
(Rather like
<a href="https://mango.pdf.zone/finding-former-australian-prime-minister-tony-abbotts-passport-number-on-instagram">the booking reference they send you when you book a flight</a>.)</p>

<h2 id="trying-this-out-for-yourself">Trying this out for yourself</h2>

<p>With the decompiled Masabi app and the ttkMobile app together, it wasn’t too hard to work out a vague idea of what the ticket format
was like. I’ve put together <a href="https://git.eta.st/eta/rsp6-decoder">a small repository</a> with a Rust tool to decode a ticket,
as well as a small spec with my best guess on what all the fields mean.</p>

<p>There’s also a <a href="https://eta.st/tickets/">funky web tool</a> I threw together in an evening or so that’ll let you point your phone at
a barcode (or upload a screenshot of one) and give you a relatively nice readout of what data’s inside.
<a href="https://eta.st/tickets/">Give it a try!</a> (If you need a barcode, feel free to scroll up and use the one from this post!)</p>

<video controls="" autoplay="" loop="" muted="">
    <source src="/assets/img/rsp6/demo.mp4" type="video/mp4"/>

    Sorry, your browser doesn&#39;t support embedded videos.
</video>

<p>Do feel free to <a href="https://www.geoffreylitt.com/#contact">get in touch</a> if you find anything interesting or need help understanding something about the format!</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Thanks to <a href="https://lobi.to/">unlobito</a>, <a href="https://twitter.com/puckipedia">puck</a>, and <a href="https://muffinti.me/">thejsa</a> (and assorted others
in various chatrooms) for their help with all of this; go check those people out, too!</p>

<hr/>





  </div>
  

</article>


      </div>
    </div></div>
  </body>
</html>
