<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spin.atomicobject.com/2021/03/22/makefiles-vs-package-json-scripts/">Original</a>
    <h1>Why I Prefer Makefiles over Package.json Scripts</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">

						<p>On any moderately-sized Node.js project you’ve likely already outgrown the package.json “scripts” section. But because the growth was gradual, with no single acute pain point, you might not have noticed. There’s a better way.<span id="more-165078"></span></p>

<h2>What Are NPM Scripts?</h2>

<p>In most Node.js projects you’ll find a <a href="https://docs.npmjs.com/cli/v7/using-npm/scripts">scripts</a> section in the package.json file, containing convenient shortcuts like “build” and “test”:</p>

<pre><code>
&#34;scripts&#34;:{
    &#34;build&#34;:&#34;tsc&#34;,
    &#34;test&#34;:&#34;jest -w 1&#34;
}
</code></pre>

<p>These can be run with e.g. <code>npm run build</code> or <code>yarn test</code>.</p>

<p>In addition, there are special meanings behind scripts with certain names, like “install” or “prepublish” (<a href="https://docs.npmjs.com/cli/v7/using-npm/scripts#life-cycle-scripts">npm</a>,<a href="https://classic.yarnpkg.com/en/docs/package-json#scripts-">yarn</a>).
<!--more--></p>

<p>On a new project it usually starts out innocent enough, with a small collection of simple, self-explanatory commands. But then…</p>

<h2>Common Patterns</h2>

<p>One pattern that I see come up often in NPM scripts is multiple variations on a single script:</p>

<pre><code>
    &#34;go&#34;: &#34;node go.js --do-some-stuff&#34;,
    &#34;go:debug&#34;: &#34;echo debugging..; DEBUG=1 yarn go&#34;,
    &#34;go:there&#34;: &#34;yarn go --to=\&#34;over there\&#34;&#34;
</code></pre>

<p>This is reasonably readable, but check out the same thing in <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a>:</p>

<pre><code>
GO_DO_STUFF=node go.js --do-some-stuff

go:
    ${GO_DO_STUFF}

go-debug:
    echo debugging..
    DEBUG=1 ${GO_DO_STUFF}

go-there:
    # watch out for the space in that argument:
    ${GO_DO_STUFF} --to=&#34;over there&#34;
</code></pre>

<p>Variables. Multiple lines. No more escaped quotation marks. <em>Comments.</em></p>

<p>Another pattern that comes up — and this is a more sinister one — is the chain of dependencies:</p>

<pre><code>
  &#34;shared-prereq&#34;: &#34;echo shared prereq!&#34;,
  &#34;another-prereq&#34;: &#34;echo another prereq!&#34;,
  &#34;task-one&#34;: &#34;yarn shared-prereq &amp;&amp; echo doing task one..&#34;,
  &#34;task-two&#34;: &#34;yarn shared-prereq &amp;&amp; yarn another-prereq ; echo doing task two..&#34;
</code></pre>

<p>What if your build tool’s syntax had a way to express dependencies?</p>

<pre><code>
shared-prereq:
    @echo shared prereq!

another-prereq:
    @echo another prereq!

task-one: shared-prereq
    @echo doing task one..

task-two: shared-prereq another-prereq
    @echo doing task two..
</code></pre>

<p>Amazing. But wait, it gets better…</p>

<h2>Avoid Extra Work</h2>

<p>In the above example we have a series of <em>always-run</em> steps, asking only of Make what we asked of our NPM scripts. But Make can do better.</p>

<p>If your commands are reading and writing a predictable set of files, then Make can track them and avoid redundant work.</p>

<p>This is a perfect fit for code generators (plug for <a href="https://github.com/dotansimha/graphql-code-generator">graphql-code-generator</a>, <a href="https://github.com/drwpow/openapi-typescript">openapi-typescript</a>, and <a href="https://github.com/bcherny/json-schema-to-typescript">json-schema-to-typescript</a>).</p>

<p>Here’s an example of using Make to describe the operations of a code generator:</p>

<pre><code>
JSON_SCHEMAS = $(shell find schemas -type f -name &#39;*.schema.json&#39;)
JSON_SCHEMA_DST = $(JSON_SCHEMAS:%.schema.json=%.schema.gen.ts)

JSON2TS = yarn run json2ts

schemas/%.schema.gen.ts: schemas/%.schema.json
    $(JSON2TS) -i $&lt; -o $@

CODEGEN_DST = ${JSON_SCHEMA_DST}

codegen: ${CODEGEN_DST}

build: ${CODEGEN_DST}
    @echo &#34;I depend on those generated files!&#34;

clean:
    find schemas -type f -name &#34;*.gen.*&#34; -delete
</code></pre>

<p>It&#39;s a little arcane, so here&#39;s what it does:</p>

<ul>
<li>The first time you run <code>make build</code>, it will find all the <code>.schema.json</code> files, generate a <code>.gen.ts</code> for each one, and then continue building the app.</li>
<li>The second time you run <code>make build</code>, Make will see that the generated files are up-to-date, skip the generator, and build your app.</li>
<li>If you edit one of the schema files, Make will notice that <em>just that file</em> changed, run the generator for it, then build your app.</li>
</ul>

<p>Can your build tool do that?</p>

<h2>Discoverability / Organization</h2>

<p>On a large project, you can sprinkle multiple Makefiles in different directories, where they&#39;ll offer discoverable shortcuts related to that area of the application.</p>

<p>It&#39;s even more discoverable if your shell has smart tab completion: for example, on my current project, if you enter the <code>aws/</code> directory and type <code>make&lt;TAB&gt;</code>, you&#39;ll see a list that includes things like <code>docker-login</code>, <code>deploy-dev</code> and <code>destroy-sandbox</code>.</p>

<h2>Bonus: It&#39;s Faster</h2>

<p>This speaks for itself:</p>

<pre><code>
bash-3.2$ time yarn task-two
yarn run v1.22.5
$ yarn shared-prereq &amp;&amp; yarn another-prereq ; echo doing task two..
$ echo shared prereq!
shared prereq!
$ echo another prereq!
another prereq!
doing task two..
✨  Done in 0.63s.

real    0m0.814s
user    0m0.508s
sys 0m0.138s

bash-3.2$ time make task-two
shared prereq!
another prereq!
doing task two..

real    0m0.021s
user    0m0.008s
sys 0m0.010s
</code></pre>

<p>Admittedly the tool overhead won&#39;t matter if your command takes any meaningful amount of time, but you&#39;ll feel the difference if you happen to have any scripts that execute instantly.</p>

<h2>The Straw That Broke the Camel&#39;s Back</h2>

<p>JSON was meant for serializing objects. It&#39;s a <a href="https://spin.atomicobject.com/2019/05/20/document-package-json/">lousy config format</a>, and it&#39;s even worse at expressing a complicated build.</p>

<p>As you pile more complexity into your NPM scripts, it never feels like <em>you&#39;re</em> the one placing the straw that breaks the camel&#39;s back. But please, take a step back, look at your poor camel, and consider using another tool.</p>

<p>I don&#39;t even care if it&#39;s Make. Use <em>something</em> else. Maybe your language ecosystem has a sweet build tool that can do all of the above. I&#39;d love to be proven wrong, but as far as I know in Node.js (especially with Typescript), there isn&#39;t.</p>

<p>If you have more than a handful of extremely simple npm scripts, try Makefiles!</p>

<p>Further reading:
</p><ul>
  <li><a href="https://spin.atomicobject.com/2016/03/28/automation-with-make/">Reduce Cognitive Overhead by Automating with GNU Make</a></li>
  <li><a href="https://spin.atomicobject.com/2016/08/26/makefile-c-projects/">A Super-Simple Makefile for Medium-Sized C/C++ Projects</a></li>
</ul>

							
					</div></div>
  </body>
</html>
