<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/guide-terminal-shell-console/">Original</a>
    <h1>A Guide to the Terminal, Console, and Shell</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/what_is_tty.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/what_is_tty.jpg" alt="What is the TTY?"/></picture><p>This is a boring morning for every employee of MegaCorpMoneyMaker, the famous E-commerce. You are no exception: only dragging yourself out of your bed to crawl to your office required some superhuman efforts.</p><p>Dave, your colleague developer, loudly explain to an intern what she should do to connect to one of the company’s Kubernetes cluster. “So, now, you need to open your virtual shell for your terminal to request information from your console using Bash. Does it make sense?”.</p><p>Mesmerized by the nonsensical discourse of your colleague, you begin to wonder what’s the deep purpose of your life. Suddenly, this question found a clear answer: you see Davina, another of your colleague, stand up, take a Banjo from nowhere, and begin to sing a poem, like a troubadour lightening the ignorance of some middle-age peasants.</p><blockquote><p>Once upon a time, as far as I can tell,
There was the console, the terminal, and the shell.
Let me tell you the story of these divine tools,
For you to stop looking like ignorant fools.</p></blockquote><p>Everybody gathers around Davina to hear her story. Her music sounds ancient and magical, and they soon have the feeling to slide in an ancient time…</p><p>Why does Davina want her colleagues to know more about the virtual consoles, the terminal, and the shell?</p><p>I don’t know any developer who doesn’t use a terminal, a shell, and some CLIs. I definitely use them all the time. They are the central building bricks of my <a href="https://thevaluable.dev/mouseless-development-environment/" target="_blank" rel="noopener">Mouseless Development Environment</a>.</p><p>So, since it’s so useful, let’s look a bit deeper what’s this shell, console, and terminal. More precisely, we’ll see, in this article:</p><ul><li>The legacy of physical teletypes in Unix-based systems.</li><li>What are virtual consoles (TTY).</li><li>What are pseudoterminals.</li><li>What’s the shell.</li><li>How to customize a terminal.</li></ul><p>This article is the result of a reader asking me to write about the terminal. Don’t hesitate to subscribe to the <a href="https://thevaluable.dev/page/newsletter/">newsletter</a> to ask me what you’d like to read in The Valuable Dev!</p><p>In this article, I’ll mostly speak about terminals in the context of a Linux-based system; that said, they can also be applied to Unix-based systems at large (including macOS).</p><p>Strap on in the time machine, this will be a wild ride. The terminal carry a lot of baggage from devices of forgotten eras, so let’s come back in time!</p><h2 id="from-the-telegraph-to-the-video-terminal">From the Telegraph to the Video Terminal</h2><p>Internet wasn’t only the result of some military project in the 70s. As far as history can remember, humanity was always compelled to send long distance messages. Many different cultures tried different ways to do so: smoke, pigeons, or even <a href="https://en.wikipedia.org/wiki/Drums_in_communication" target="_blank" rel="noopener">drum beats</a>.</p><p>One of the biggest accomplishment in this quest was the invention of the telegraph. That’s our first stop to understand why the Unix terminal is an intertwined set of different ideas glued together.</p><h3 id="the-telegraph">The Telegraph</h3><p>The history of the telegraph goes back from the 17th and 18th century. At that time, there were already some ways to send telegraphs on long distances! The technology jumped forward in the 18th century: during the french revolution, there was suddenly an urgent need for the telegraph; after all, the French monarchy (and the king’s head) was on the line. That’s why the telegraph expanded quickly in France first, and then in Europe.</p><p>To send a telegraph, you needed two persons on each side of the line (emission and reception): the operators. At the time, it was not possible to send messages in plain text, so the operators had to encrypt them; for example in the famous Morse system, but not only.</p><p>Let’s say that you’re a respectable citizen from Berlin in the 19th century, and you want to send a telegraph to your best friend in Paris. You would need to go to the telegraph office in Berlin, and give your message (in plain text) to the operator there. He would encrypt it, and send it to Paris. There, a second operator would decode your message, write it somewhere, and give it to Dave, your best friend.</p><p>flowchart LR
subgraph Berlin
A[&#34;Emitter&#34;]--&gt;B[&#34;Operator 1&#34;]
end
subgraph Paris
B-- &#34;encrypt &amp; send&#34; --&gt;C[&#34;Operator 2&#34;]
    C-- decrypt --&gt;D[&#34;Receptor&#34;]
end</p><p>There were many types of telegraph invented throughout the 18th and 19th century. The most famous was the electric telegraph, but there were many other variants too; it eventually led to the invention of the telephone.</p><p>For example, there were also the optical telegram, the helograph telegram, even wireless telegraphy was a thing.</p><h3 id="the-teleprinter-teletype-or-tty">The Teleprinter, Teletype, or TTY</h3><p>Throughout the decades, the traffic of telegrams increased worldwide. Many were thinking about possible solutions to automate the whole process. The need for trained operators able to encrypt and decrypt messages were getting bigger and bigger, leading to the invention of the teleprinter.</p><figure><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/1931_teleprinter.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/1931_teleprinter.jpg" alt="A Creed Model 7 teleprinter, 1931"/></picture><figcaption>A Creed Model 7 teleprinter, 1931 - <a href="https://commons.wikimedia.org/wiki/File:Bundesarchiv_Bild_183-2008-0516-500,_Fernschreibmaschine_mit_Telefonanschluss.jpg" target="_blank" rel="noopener">source</a></figcaption></figure><p>As you can see, it was a physical device composed of a keyboard and a printer. With a teleprinter, you could type your message in plain text; it would then be encrypted automatically, and sent. On the other side, a teletype could decrypt the message, and print it.</p><p>flowchart LR
subgraph Berlin
A[&#34;Emitter&#34;]--&gt;B[&#34;Teleprinter 1&#34;]
end
subgraph Paris
B-- &#34;codify &amp; send&#34; --&gt;C[&#34;Teleprinter 2&#34;]
    C-- decode --&gt;D[&#34;Receptor&#34;]
end</p><p>With the adoption of the teleprinter, the Morse system wasn’t the best code to send messages anymore; it wasn’t really machine friendly. That’s where the Baudot code entered the chat: each character had the same length, making it easier for the teleprinters to handle. It could also encrypt more characters! Five bit sequential of binary code, allowing 32 (2^5) possible characters in your messages. Even better: a “shift” key (or FIGS, for “figure shift”) was allowing numbers and special characters in the messages for the first time.</p><p>The Baudot code had also some early control characters (CR). For example, let’s say that you wanted to send a message, but you made a typo: you could use the “DEL” code to say that you wanted the character before it to be deleted. When the message was received, the teleprinter in charge of printing back the message wouldn’t print the “DEL” code, but instead it would skip the character just before it. That’s also why control characters are also called non-printable characters.</p><p>In 1925, the Baudot code was improved, and became the Murray code. More control characters were included: the carriage return for example (CR), to move the carriage (the “cursor” of the teleprinter) back to the left margin of the same line. You also had the line feed (LF), to advance the carriage to the same column of the next line.</p><p>These control characters are still used today. We’ll come back to them below in this article.</p><p>Fast-forward to the early 1930: a new network, composed of teleprinters, was invented in Europe (more specifically in Germany): the telex. AT&amp;T launched its own version in the US in 1931. It was the cheaper way at the time to send long-distance telegrams. The speed of the network was measured in baud; in Europe, it was of 50 bauds, which was around 66 words per minute.</p><p>And guess what: you can still display the speed in baud of your terminal. It doesn’t mean anything anymore, but it shows the roots of the terminal coming back to the teleprinter.</p><p>In 1961, the American Standard Association created a new code for teleprinters, called the ASCII code. It’s a 7 bits codes, allowing to send bigger messages than with the Baudot (or the Murray) code, even including the luxe of lowercase and uppercase letters.</p><p>It was a great step toward standardisation, too. Until then, many different codes to encrypt messages were still used, even if some more than others. With the ASCII code, teleprinters in the US were using the same set of characters to send messages.</p><p>That said, the control characters themselves weren’t properly standardized. Two different teletypes could use different characters for the same control.</p><p>The telegram began to decline as soon as 1920, mostly because of the telephone. It’s estimated that, at its pick, in 1929, there were about 200 millions telegrams sent worldwide! Journalists never stopped using them until the 90s, when the Internet came into the picture.</p><p>Last thing: the teleprinter is the official name for the device. Teletype was a major brand producing teleprinters, that’s why “teletype” became a synonym of “teleprinter”. The abbreviation of <code>t</code>ele<code>ty</code>pe is TTY.</p><h3 id="computers-and-ttys">Computers and TTYs</h3><p>In the middle of the 50s, there were already a bunch of computers available. These mainframes were massive computers taking a lot of space, many of them built by IBM. At that time, teletypes were all over the world, so it was only natural to use them to send messages to a computer.</p><p>Early computers could be categorized in two types:</p><ul><li>Batch computers (IBM and Univac computers).</li><li>Interactive computers (like the Bendix G-15, the Librascope LGP-30, or the IBM 610).</li></ul><p>To run a bunch (a batch) of programs together on batch computers, you needed to:</p><ol><li>Type your code using a teletype on punch cards.</li><li>Feed the different punch cards to the mainframe computer as input.</li><li>Get the output on a punch card.</li><li>Insert this output into a tabulating machine, to decode it in a human-readable format.</li></ol><figure><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/ibm_mainframe.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/ibm_mainframe.jpg" alt="IBM mainframes"/></picture><figcaption>IBM mainframes with a teleprinter - <a href="https://www.flickr.com/photos/thomaspurves/2333225275/in/photolist-4ybozZ-2jnfwcc-2jngzir-5Z71Y2-YZM4gp-9HxSVd-5ZbegP-4fo9xH-4FWRwZ-9iEV83-4SVevS-4SVev1-9CgsVu-77zxVy-KQQwN2-2kYyq9s-YtrZ7F-4BvkZz-4BzEx3-2a7QAGb-9z5Ezn-8DRs27-P5DwGA-4BvnaB-4BzAds-4BvjWH-4Bvpfz-2iAYJTH-2jheSRk-s8wu5N-5YyaGH-Uq9B-7nzzKy-2a7QBDS-7nzAYY-MstiBk-6Fjcin-6yodKa-9u5NHx-9Znfpi-9u5NJr-5gJRf4-9u5ReB-9u5Rf2-9u5NJT-mMuSX-WUtJuV-29Q1csP-9u5Rf6-bgRwSK" target="_blank" rel="noopener">source</a></figcaption></figure><p>The rise of interactive computers changed this workflow. You could then directly send your input to the machine using a teletype. More specifically, you needed to:</p><ol><li>Type your input on a teletype, which would be printed on paper for you to see what you were typing.</li><li>The teletype was also sending the characters (including the control characters) to the computer.</li><li>The computer was sending back the output to the teletype, which was also printed on paper (or punch cards).</li></ol><figure><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/BendixG15-2015.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/BendixG15-2015.jpg" alt="A Bendix G-15"/></picture><figcaption>A Bendix G-15 - <a href="https://commons.wikimedia.org/wiki/File:BendixG15-2015.JPG" target="_blank" rel="noopener">source</a></figcaption></figure><p>These teletypes were connected to the computer using a serial port. Two wires were necessary: one to send the data to the computer, another one to receive it.</p><p>The ASR-33 (introduced in 1963) was a widely used teletype at the time. It was one of the first teletype using the ASCII standard, which was also the common encryption used by more and more “minicomputers” to transmit information. These computers are not mini by today standards, but they were smaller than massive mainframes.</p><figure><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/teletype_model_33.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/teletype_model_33.jpg" alt="An ASR-33"/></picture><figcaption>An ASR-33 - <a href="https://www.flickr.com/photos/stiefkind/48930224272/in/photolist-2hxNbYq-2niSrJW-2gGRrMX-4jyUbA-2k17oB8-mCWwW9-8Lz2b5-R9ehqF-RxTW5Y-K1haQs-SAD6U9-JJwvn9-RxSSVU-R9ehne-TvKr91-u4AMT8-t7KMvz-SfaJyW-H7B29r-25F5xD7-xLpdxP-tM1bDC-qYQzuF-2maA8jt-f9Z1kB-f8Di2D-fbs3Jm/" target="_blank" rel="noopener">source</a></figcaption></figure><p>As we saw, there were a handful of control characters available to do some “non-printable” actions. Now that teletypes were interacting with a computer, the users needed more control characters. The ASCII introduced the <code>ESC</code> key, and “control sequences” were invented. Instead of a single key for performing an action, a sequence of key were used, often prefixed with the <code>ESC</code> character. That’s why control sequences are also called escape sequences. This prefix was not a standard however, but widely used nonetheless.</p><p>It’s interesting to note that, at the beginning, the interactive computers would only allow one user to connect and interact with it. In 1959, the development of time-sharing allowed multiprogramming. Later, the concept of time-sharing shifted: it meant then that multiple users could interact to a single computer at the same time.</p><p>We’ve here the origin of the command-line interface: a text-only interface allowing users to communicate with a computer. Everything was printed, input as well as output.</p><p>What if we replace the sheet of paper with a screen?</p><h3 id="video-terminals">Video Terminals</h3><p>In 1960, IBM began to experiment with a new way to interact with computers, the “glass teletype”, a terminal with screen. The video terminal was born.</p><p>It was similar to a teletype. Instead of printing the input and output (which was slow and, due to the mechanical nature of teletypes, quite loud), a video terminal would display everything on a screen.</p><p>This video terminal was still an external device to the computer itself, including both a screen and a keyboard. Like most invention, it was very expensive at the beginning, limiting its adoption. The price dropped in the middle of the 70s, and the success of Video terminal rose.</p><figure><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/dec_vt_100.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/dec_vt_100.jpg" alt="A DEC VT100 video terminal"/></picture><figcaption>A DEC VT100 video terminal - <a href="https://www.flickr.com/photos/stiefkind/15272092560/in/photolist-pgxt3G-N8L66P-qzwu1x-2nYG67G-2o33cg8-ov2RNX-ovj7ke-ov2TfK-2o2LXmF-2nZHgti-2o1CpGZ-2o1UJSg-2o3Ebqh-2nXJpCd-2o1fdhy-ovj778-odQnu6-odPwhv-odPyuL-othcFm-odPxUh-odPtJz-odPwVy-othbRL-odQoT8-2nWTLoT-2o24i6K-2o3gurK-2o35ccw-2nX46PP" target="_blank" rel="noopener">source</a></figcaption></figure><p>The video terminals were also called “console”, or simply “terminal”.</p><p>The DEC VT100 (for <code>V</code>ideo <code>T</code>erminal) was one of the most popular choice. Released in 1978, it was one of the first video terminal supporting a new set of escape sequences, the <a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="noopener">ANSI escape codes</a>. When connected to a computer, this terminal was called a “controlling terminal”, because it was controlling the computer.</p><h2 id="unix-system-in-att">Unix System in AT&amp;T</h2><p>Now that we have video terminals to use on minicomputers, what did the programmers in the 70s did with them?</p><h3 id="the-birth-of-unix">The Birth of Unix</h3><p>In 1970, Dennis Ritchie and Ken Thompson develop the UNIX operating system on a DEC PDP-11, a popular minicomputer series at the time. It was an interactive computer, easier to program than the competitors. It influenced not only modern CPUs (like the Intel x87) but also other operating systems, like the CP/M, the ancestor of MS-DOS (the base of Windows for many years).</p><figure><picture><source srcset="https://thevaluable.dev/images/2022/terminal_console_shell/ken_thompson_dennis_ritchie_pdp_11.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/terminal_console_shell/ken_thompson_dennis_ritchie_pdp_11.jpg" alt="Ken Thompson (sitting) and Dennis Ritchie on a PDP-11"/></picture><figcaption>Ken Thompson (sitting) and Dennis Ritchie on a PDP-11 - <a href="https://commons.wikimedia.org/wiki/File:Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg" target="_blank" rel="noopener">source</a></figcaption></figure><p>Unix was created for AT&amp;T needs, and their creators were influenced by the long time they spent on teletypes.</p><p>With Unix, almost everything is represented by a file. External devices are no exception: when you were connecting a teletype (or a video terminal) to a machine running Unix, it would represent the device with a file prefixed by “tty”. This file was an interface between the external terminal and the computer.</p><p>For example, in a multi-user context, if three teletypes were connected to your computer, you would have the file <code>/dev/tty1</code> assigned to the first one, <code>/dev/tty2</code> to the second one, and <code>/dev/tty3</code> to the third one.</p><p>The file <code>/dev/tty0</code> always represent the current terminal.</p><p>We can now transmit commands to the computer thanks to these external devices. But how the computer knows what to do with them?</p><p>It’s what the shell is good for.</p><h3 id="the-shell">The Shell</h3><p>When you think about it, teleprinters and video terminals were quite dumb:</p><ol><li>They take your sweet input, and display it.</li><li>They pass it to the computer.</li><li>Some program, running on the computer, interprets the input, and send back the output.</li><li>They display the output to your impressed face.</li></ol><p>But what program are we talking about, here? What can <em>interpret</em> our commands? That’s where the shell shines.</p><p>Imagine that you’re an AT&amp;T employee working with Dennis Ritchie. You’re writing <code>ls</code> on your video terminal, and send it to the computer by hitting the control character Carriage Return (the <code>ENTER</code> key on our modern keyboards). The shell, running on the computer, receives the command, interprets it, and understands that you want to execute the program <code>ls</code>. As a result, it might send some system call to the kernel (we’ll come back to that soon), creates a new process <code>ls</code> (a process is simply a program being executed), and send back the output of this process to the terminal to display it.</p><p>The shell can also interpret a list of commands described in a shell script.</p><p><a href="https://www.youtube.com/watch?v=tc4ROCJYbm0&amp;t=296s" target="_blank" rel="noopener">Here’s what you always wanted to see</a>: a fancy 3D animation followed by <a href="https://de.wikipedia.org/wiki/Brian_W._Kernighan" target="_blank" rel="noopener">Brian Kernighan</a> explaining casually what the kernel and the shell are to one another, with the keyboard of a fancy video terminal on his laps, the feet on the desk. That’s charisma right there.</p><p>If you can, watch the whole video. It’s awesome.</p><h2 id="types-of-terminal-emulators">Types of Terminal Emulators</h2><p>As time went on, with the development of OS (Operating Systems) like Unix and CP/M, the video terminals began to be <a href="https://thevaluable.dev/abstraction-type-software-example/" target="_blank" rel="noopener">abstracted away</a>.</p><p>With computers getting smaller and smaller, more and more “personal” (the first widely adopted microcomputer was the <a href="https://en.wikipedia.org/wiki/Apple_II" target="_blank" rel="noopener">Apple II</a> in 1977), why needing a physical external device when you can emulate the system in software?</p><p>That’s where the TTY began to be emulated.</p><p>When we speak about terminal nowadays, we think about a piece of software which allows us to write some commands. This terminal is an emulation, trying to recreate, in software, the video terminal. That’s why we speak about <em>terminal emulators</em>. This emulation is still called the <em>TTY device</em>, somehow making teletypes still part of our lives.</p><p>We can distinguish two families of terminal emulators: virtual consoles and pseudoterminals.</p><h3 id="virtual-consoles-tty">Virtual Consoles (TTY)</h3><p>Before graphical interfaces took over the computer world, virtual consoles were the only ways to interact with these OSes growing in popularity. A virtual console is a terminal emulator running in the kernel.</p><p>Imagine that you just threw away your big video terminal. You only have a screen and a keyboard attached to a computer now, and this time the computer take your input from your keyboard, and display the output on the screen. No need of a video terminal anymore!</p><p>Now, when you start your computer, you’re first greeted with a login screen. You log in with your favorite user, and then the shell will display a prompt, inviting you to enter some commands. You can type these commands in your virtual console and press <code>ENTER</code>, to send them to the shell, where they will be interpreted. The output appears on your screen. You can even start other processes, like your favorite editor, which is obviously <a href="https://thevaluable.dev/vim-commands-beginner/">Vim</a>.</p><p>But, without a video terminal, what allows us to type our commands, see them on a screen, and pass them to the shell (or any of its child process), and only when we type <code>ENTER</code>? What is giving our output back? Your virtual console of course! Even if you threw away your actual physical console, it’s still there, doing the same job as before.</p><p>When you log in a virtual console, a shell process will be attached to the output of the terminal emulator (specifically the file representing the terminal, something like <code>/dev/tty</code>, as we already saw). The shell will give you a prompt, and everything you type will go directly to the TTY device.</p><p>The virtual console itself runs in the kernel, and your shell as well as its child processes run in user land. Wait, what?</p><h4 id="kernel-and-user-land">Kernel and User Land</h4><p>Let’s go on a tangent here. If you didn’t know, there are two “spaces” where programs can run: the kernel and user land (also called user space).</p><p>Part of the kernel’s job is to ensure that no program will mess up with the hardware, and also that one program can’t access the memory of another one. To ensure this level of security, most programs you run as a user will be a process in user land.</p><p>If the process needs to ask the kernel to use some hardware (like writing on the hard disk, or using the RAM, for example), it will send a <em>system call</em> to the kernel. The kernel will receive the system call, enable some more protections (on the CPU for example), and it will try to handle what the process wants.</p><h4 id="linux-virtual-consoles">Linux Virtual Consoles</h4><p>Virtual consoles fell out of fashion when desktops were being implemented in most common OS (but in very different ways). No need to have a text-based interface anymore: with desktops, we have now fancy windows, icons, status bars, and the like.</p><p>As a result, not many OSes give us the chance to interact with virtual consoles nowadays; but Linux-based systems still have them.</p><p>The Linux kernel was developed with multi-users in mind from the beginning, giving us multiple virtual consoles where different users could log in in parallel.</p><p>When you launch some Linux distribution (like <a href="https://thevaluable.dev/mouseless-development-environment/" target="_blank" rel="noopener">Arch Linux</a>, by the way) without any desktop installed, you’ll be greeted with a logging screen.</p><ol><li>First, a program called “getty” runs.</li><li>The process “getty” gets a TTY; this process is then replaced with another one called “login”, to give the user a login prompt.</li><li>After logging in, the user will get write permissions on the file representing the TTY (<code>/dev/tty&lt;tty_number&gt;</code>).</li><li>The file <code>/etc/passwd</code> will be read to decide what shell to run for this specific user. The shell will then replaces the login process.</li><li>The shell will display a prompt for the user to type commands.</li></ol><p><strong>TODO</strong> screenshot of a loggin screen</p><p>If you have a desktop (like Gnome, KDE, i3, or whatever else), there will be a display server (like X or wayland) called after getting the TTY (or after the login process starts), which will in turn display the desktop. The TTY itself still runs under the hood.</p><p>I was saying that Linux-based systems allow us to have multiple virtual consoles. With most Linux distros, if you’re in a virtual console already, you can use the <code>ALT</code> key with one of the F-key (like F1, F2… up to F6, or more) to switch between them. If you’re already running a desktop on top of one of your TTY, you can use <code>CTRL+ALT</code> followed by one of the F-key.</p><p>On Linux, the files <code>/dev/tty1</code> to <code>/dev/tty63</code> represents the different virtual consoles you can access (you might not be able to open all of them, depending on your configuration). You can actually play with that: if you’re logged with the same user on the TTY 1 and 2 (to have write permissions on the <code>/dev/tty</code> files), you can send some data from the TTY 1 to the TTY 2 by running:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>echo</span> <span>&#34;I&#39;m the first TTY&#34;</span> &gt; /dev/tty2
</span></span></code></pre></div><p>If you switch to the second virtual console, you’ll see your input displayed on the screen.</p><p>If you try to read the files themselves (using <code>cat</code> for example), you won’t see anything in there; they’re just used as interface to pass data from terminals to processes, and from processes to terminals.</p><p>You can also use the CLI <code>chvt</code> to switch to different virtual consoles: <code>chvt 2</code> will switch to the second virtual console for example.</p><p>Even nowadays, virtual consoles can be handy for different reasons:</p><ol><li>If your graphical desktop freeze or crash, you can switch to another virtual console to debug the problem.</li><li>If your graphical desktop crash at startup, you can also switch to a virtual console and try to solve the problem.</li><li>If you access a remote server (or an embedded device) without any graphical interface, you’ll only have the virtual console to work with; better knowing how it works in these cases!</li></ol><p>The virtual console is considered as the controlling terminal of all the process you can run in it (including the shell). You can display the controlling terminals for each process by using one of the following command:</p><ul><li><code>tty</code> - Show the actual controlling terminal.</li><li><code>who</code> - Show all the users logged in a controlling terminal.</li><li><code>ps -eF</code> (with GNU ps), <code>ps aux</code> (with BSD ps) - Show the controlling terminals of all processes (if any); look at the “TTY” column.</li></ul><p>Not all group of processes have a controlling terminal. For example, daemons started when the OS boots don’t need any terminal to control them; they operate on their own.</p><p>Here’s a diagram showing the first virtual console of a Linux-based system. We can imagine that you’ve typed “vim” in the first virtual console, followed by the <code>ENTER</code> key:</p><p>flowchart LR
G[&#34;User input (vim)&#34;]--&gt;A
subgraph Kernel
A[&#34;Terminal (/dev/tty1)&#34;]
end
subgraph User land
A&lt;--&gt;C[shell]
C&lt;--&gt;D[vim]
end</p><p>If virtual consoles are not as popular as before, what kind of terminals we run in our windows, on our comfy desktops?</p><h3 id="pseudoterminals-or-pty">Pseudoterminals, or PTY</h3><p>A virtual console is running in the kernel. A pseudoterminal (or “PTY”) is a terminal running in user land. Any terminal you launch from a graphical interface (like a desktop) is a PTY.</p><p>How does it work?</p><p>Let’s imagine that you open three terminal emulators in your favorite graphical environment, like <a href="https://invisible-island.net/xterm/" target="_blank" rel="noopener">xterm</a> for example. On Linux-based systems, it will first open the file <code>/dev/ptmx</code>, which will then open two other files:</p><ol><li>A file descriptor for the PTY master (or “PTM”).</li><li>A file <code>/dev/pts/&lt;pty_number&gt;</code> for the PTY slave (or “PTS”). The <code>&lt;number&gt;</code> is incremented each time you launch another pseudoterminal.</li></ol><p>To come back to our example, the third pseudoterminal you open will be represented by the PTS file <code>/dev/pts/3</code> on Linux-based systems. The PTM is only a file descriptor (a number in a table); you won’t find it in the filesystem.</p><p>Then, a shell will be attached to the PTS, receiving its input from the PTS file. When you’re trying to run some commands in your pseudoterminal, the input will first flow from the PTM to the PTS, and then from the PTS to the shell. The shell’s output will take the same path back.</p><p>Here’s a diagram summarizing the process:</p><p>flowchart
G[User input]--&gt;A[&#34;Terminal emulator (xterm)&#34;]
subgraph Kernel
B[&#34;PTM (file descriptor)&#34;]&lt;--&gt;C[&#34;PTS (/dev/pt2)&#34;]
end
subgraph User land
A&lt;--&gt;B
C&lt;--&gt;D[shell]
D&lt;--&gt;E[process 1]
D&lt;--&gt;F[process 2]
end</p><p>A pseudoterminal is similar to a virtual console, with two important differences:</p><ol><li>The terminal is running in user land, not in the kernel.</li><li>Instead of having one file (<code>/dev/tty</code>) representing the whole TTY device, you have two (the PTM and the PTS).</li></ol><p>Coming back to physical teletypes, we’ve seen above that they were connected by a pair of wires to a computer. You can see the master file “PTM” as the emulation of the physical pair of wire connecting the physical terminal to the computer. Here, it connects the terminal in user land to the kernel. The slave file “PTS” has the same role as the TTY (<code>/dev/tty&lt;tty_number&gt;</code>) file of a virtual console: it’s an interface between the terminal and the different processes using our commands, like the shell.</p><p>Again, you can use the CLI <code>tty</code> in your terminal emulator to see what PTS file you’re writing to. You can also try to write to another PTS (for example <code>echo &#34;hello third PTY&#34; &gt; /dev/pts/3</code>), you’ll see in the third pseudoterminal what you’ve written.</p><h2 id="how-terminal-emulators-work">How Terminal Emulators Work</h2><p>Now that we’ve seen the basics of teletypes, consoles, virtual consoles, shells, and the pseudoterminals, let’s look at how terminal emulators work in general.</p><p>We’ve represented the TTY device as a black box until now, but there’s more to it. We can divide it in three parts: the TTY core, the line discipline, and the TTY drivers.</p><h4 id="the-tty-core">The TTY core</h4><p>The TTY core responsibility is to get the user input and pass it to the line discipline. You have the choice between multiple line disciplines; the one by default normally handle input from a terminal, but some others can manage mouse or whatever else can be plugged to a serial port.</p><h4 id="the-line-discipline">The Line Discipline</h4><p>Thanks to the TTY core, you can write some commands in your terminal. These commands are then send to the line discipline, which can also intercept control characters and escape sequences. For example, as we already observed, the control sequence “^[[3~” will be send to the line discipline if I hit the key “DEL” in my terminal; as a result, the line discipline will get back your input with a character deleted. This control sequence is also called escape sequence, because the character <code>^[</code> represents the <code>ESC</code> key.</p><p>We were saying above that a terminal is quite dumb. The line discipline makes it a bit smarter, because it already interprets some of your input. It’s a very basic editor, if you will.</p><p>The line discipline can be in different modes:</p><ul><li>The <em>canonical mode</em>: the input is processed when a line is terminated by a carriage return (a control character), created when you hit <code>ENTER</code>, or a line feed. At that point, the command will be passed to the process in the foreground.</li><li>The <em>noncanonical mode</em>: each character is directly sent to the line discipline and the TTY drivers, and to the foreground process. No need of line feed anymore.</li><li>The <em>cooked mode</em>: the terminal “cooks” (transform) the input you give to the terminal, as well as the potential output from the processes attached. It’s basically the canonical mode will all the default control characters and control sequences enabled.</li><li>The <em>raw mode</em>: the line discipline doesn’t do anything anymore. It just passes whatever you give to the TTY drivers. It’s basically the noncanonical mode with many control characters and control sequences disabled.</li></ul><p>Many applications (like Vim for example) use the “noncanonical” mode to get all the characters you type directly, instead of waiting for you to hit <code>ENTER</code> to finally receive them. That’s how Vim can display the characters you’re typing one by one.</p><p>With early computers, you didn’t have much choice: you had to use the line discipline. Its buffer was useful to store characters, instead of using the very limited RAM. But nowadays, with our crazy computers, it’s not a problem anymore.</p><h4 id="tty-drivers">TTY Drivers</h4><p>When the line discipline is done processing your input, your command (or individual characters, depending on the mode you’re in) is then sent to the TTY drivers. They will interact with the hardware directly (the role of a driver), and also pass the different characters to the processes, like the shell.</p><p>The possible output goes through the TTY drivers again, then back to the line discipline, which might convert some other control sequences. For example, on Unix systems, it converts the line feeds (LF) from the output to the combo carriage return/line feed (CR/LF), simply because the line feed only advance the carriage return to the same column on the next line, not on the first column on the next line.</p><p>We’ll see how to change the behavior of the line discipline in the next section. For now, here’s a diagram for a whole TTY device:</p><p>flowchart LR
A[User input]--&gt;B
subgraph &#34;TTY Device&#34;
B[TTY core]
B &lt;--&gt; D[Line discipline]
D &lt;--&gt; E[TTY driver]
end
E&lt;--&gt;G[hardware]
E&lt;--&gt;F[shell]</p><p>It’s more or less the same for a pseudoterminal, except that the line discipline sits on top of the PTS.</p><h2 id="customizing-the-terminal-emulator">Customizing the Terminal Emulator</h2><p>Now that we have a high level view on what the TTY device is doing, let’s see how to customize your terminal experience.</p><h3 id="line-discipline-and-tty-drivers-settings">Line Discipline and TTY Drivers Settings</h3><p>We can actually configure our line discipline and TTY drivers with the command <code>stty</code>. Let’s try to run the following in a shell:</p><p>It will output the different settings you can configure for the line discipline of any terminal emulator (pseudoterminal or virtual console).</p><p>Here’s what I get on one of my pseudoterminal:</p><pre tabindex="0"><code>speed 38400 baud; rows 45; columns 105; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel
iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho
-extproc
</code></pre><p>Let’s look at the output in details, beginning by the first line:</p><pre tabindex="0"><code>speed 38400 baud; rows 45; columns 105; line = 0;
</code></pre><p>The speed is another artifact from the bygone era when physical teletypes were ruling the computer world. The rows, columns, and line of the terminal are not always accurate either.</p><p>The second and third lines are more interesting:</p><pre tabindex="0"><code>intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
</code></pre><p>They describe the different control characters and control sequences you can configure. For example <code>intr = ^C</code> means that you can use the control sequence <code>CTRL+c</code> to send an interrupt signal.</p><p>We can configure these control sequences as we see fit. For example, if we want to send an interrupt signal with <code>CTRL+r</code>, we can run:</p><p>You can use here the hat notation for representing <code>CTRL+r</code>: a carret <code>^</code> represents here the <code>CTRL</code> key. You can also type the actual control character <code>^R</code> by first hitting <code>CTRL+v</code>, followed by <code>CTRL+r</code>.</p><p>In general, you can use <code>CTRL+v</code> followed by a control character to get its raw value.</p><p>You can also run <code>stty --help</code> to learn more about all these bindings. Here are the most interesting to me:</p><table><tbody><tr><th>Control</th><th>Description</th><th>Default</th></tr><tr><td><code>intr</code></td><td>Send an interrupt signal.</td><td><code>^C</code> (<code>CTRL+C</code>)</td></tr><tr><td><code>eof</code></td><td>Send end of file, terminating the input.</td><td><code>^D</code> (<code>CTRL+D</code>)</td></tr><tr><td><code>erase</code></td><td>Erase the character before the cursor.</td><td><code>^?</code> (<code>BACKSPACE</code>)</td></tr><tr><td><code>werase</code></td><td>Erase the word before the cursor.</td><td><code>^W</code> (<code>CTRL+w</code>)</td></tr><tr><td><code>kill</code></td><td>Erase the current line.</td><td><code>^U</code> (<code>CTRL+u</code>)</td></tr><tr><td><code>susp</code></td><td>Send a stop signal (suspend a process which can be later resumed).</td><td><code>^Z</code> (<code>CTRL+z</code>)</td></tr><tr><td><code>stop</code></td><td>Stop the output (including echoing what’s your typing).</td><td><code>^S</code> (<code>CTRL+s</code>)</td></tr><tr><td><code>start</code></td><td>Start the output after it was previously stopped. Everything which was stored in the buffer is sent to the terminal.</td><td><code>^Q</code> (<code>CTRL+q</code>)</td></tr></tbody></table><p>You can also use <code>undef</code> to disable a control character. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>stty start undef
</span></span><span><span>stty stop undef
</span></span></code></pre></div><p>Let’s go back to the output of <code>stty -a</code>. Next, we have a list of options:</p><pre tabindex="0"><code>-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel
iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho
-extproc
</code></pre><p>A minus before a setting means that it’s disabled; no minus means it’s enabled. Not all options are boolean, however. In that case, the minus will have slightly different meanings. You can look at the manual page of stty (by running <code>man stty</code>) to have more information.</p><p>The name of these settings are quite obscure. The first letter can help guess what they stand for: when the settings are about the output of the TTY, they will begin with an <code>o</code>. Same for input: they will begin with an <code>i</code>.</p><p>To disable settings, you can simply give them as argument to stty. For example:</p><p>This will disable the setting <code>opost</code>, and enable the setting <code>tostop</code>.</p><p>Here are a couple settings of interest:</p><table><tbody><tr><th>Setting</th><th>Description</th><th>Default</th></tr><tr><td><code>igncr</code></td><td>Ignore carriage return (the <code>ENTER</code> key). Great if you don’t want anybody to execute a command. You can still use a newline character for the same effect, by hitting <code>CTRL+j</code>.</td><td><code>-igncr</code></td></tr><tr><td><code>opost</code></td><td>Let the line discipline post-process the output.</td><td><code>opost</code></td></tr><tr><td><code>echo</code></td><td>Output your input characters back to the terminal.</td><td><code>echo</code></td></tr><tr><td><code>ctlecho</code> or <code>echoctl</code></td><td>Echo control sequences in hat notation.</td><td><code>ctlecho</code></td></tr><tr><td><code>onlcr</code></td><td>Transform the line feeds from the output with the combination of carriage return / line feed.</td><td><code>onlcr</code></td></tr><tr><td><code>tostop</code></td><td>Stop background jobs that try to write to the terminal.</td><td><code>-tostop</code></td></tr></tbody></table><p>For example, to ignore carriage returns, you can run:</p><p>Now, you can’t send any command to your shell anymore… but you can still use <code>CTRL+j</code> to send a line feed control character, which is equivalent to the carriage return.</p><p>There are other “combination of options” we can use to disable or enable a bunch of options at once:</p><table><tbody><tr><th>Setting</th><th>Equivalent</th></tr><tr><td><code>cooked</code> or <code>-raw</code></td><td><code>brkint</code>, <code>ignpar</code>, <code>istrip</code>, <code>icrnl</code>, <code>ixon</code>, <code>opost</code>, <code>isig</code>, <code>icanon</code>, <code>eof</code> and <code>eol</code> with default values.</td></tr><tr><td><code>raw</code> or <code>-cooked</code></td><td><code>-ignbrk</code>, <code>-brkint</code>, <code>-ignpar</code>, <code>-parmrk</code>, <code>-inpck</code>, <code>-istrip</code>, <code>-inlcr</code>, <code>-igncr</code>, <code>-icrnl</code>, <code>-ixon</code>, <code>-ixoff</code>, <code>-icanon</code>, <code>-opost</code>, <code>-isig</code>, <code>-iuclc</code>, <code>-ixany</code>, <code>-imaxbel</code>, <code>-xcase</code>, <code>min 1</code>, and <code>time 0</code>.</td></tr><tr><td><code>sane</code></td><td><code>-ignbrk</code>, <code>brkint</code>, <code>-inlcr</code>, <code>-igncr</code>, <code>icrnl</code>, <code>icanon</code>, <code>iexten</code>, <code>echo</code>, <code>echoe</code>, <code>echok</code>, and <code>-echonl</code>.</td></tr></tbody></table><p>If you try to disable some of these options, they might be automatically reset after you type <code>ENTER</code> to send your command to the shell.</p><p>It’s because the line editor of your shell might reset some TTY options automatically, because it can’t work with (or without) these options.</p><p>For example, in Zsh, if I do the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>stty -echo
</span></span><span><span>stty -a <span>|</span> grep <span>&#34;echo&#34;</span>
</span></span></code></pre></div><p>The output will show me that the option <code>echo</code> is still enabled. It was disabled when I sent the first command to the shell, but then ZLE (Zsh’s line editor) enabled it again.</p><p>If you really want to enable or disable some settings without your shell’s line editor to interfere, you have two choices:</p><ol><li>Disable these options, but only for a couple of commands, all on the same command-line.</li><li>Disable the line editor.</li></ol><p>For the first, you can run for example the following:</p><p>Here, the semi-column <code>;</code> allows us to execute two commands on the same command line.</p><p>The option <code>echo</code> will be disabled for the new <code>cat</code> process (which means that you’ll only see the output of <code>cat</code>, not the input you’re giving to the terminal), but then when <code>cat</code> ends, ZLE will automatically enable <code>echo</code> back.</p><p>If you really want to only use the terminal editing power without any line editing, you can also turn down readline (for Bash) or ZLE (for Zsh) respectively with these commands:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>bash --noediting
</span></span><span><span>unsetopt zle
</span></span></code></pre></div><p>The first command will create a new Bash process with readline (Bash’s line editor) disabled, the second one will only switch off ZLE. To switch it back on, you can run <code>setopt zle</code>.</p><p>Last thing: we can also fetch the terminal settings for another TTY. For example, on Linux:</p><p>If your system is Unix based, try the following:</p><h2 id="a-selection-of-terminal-emulators">A Selection of Terminal Emulators</h2><p>It wouldn’t be fair to speak about terminal emulators without recommending some. Here are my favorites:</p><table><tbody><tr><th>Terminal emulator</th><th>Description</th></tr><tr><td><a href="https://github.com/exg/rxvt-unicode" target="_blank" rel="noopener">Urxvt</a></td><td>An old but fast terminal emulator. Can be extended with Perl plugins.</td></tr><tr><td><a href="https://st.suckless.org/" target="_blank" rel="noopener">st</a></td><td>A very simple (and fast) terminal emulator.</td></tr><tr><td><a href="https://github.com/alacritty/alacritty" target="_blank" rel="noopener">Alacritty</a></td><td>A more modern, fast (GPU-accelerated) terminal emulator.</td></tr><tr><td><a href="https://sw.kovidgoyal.net/kitty/" target="_blank" rel="noopener">Kitty</a></td><td>A complete and fast (GPU-accelerated) terminal emulator which can do a lot. It can be extended with plugins.</td></tr></tbody></table><p>As you can see, I like fast and lightweight terminal emulators. This is a very short list, but there are <a href="https://github.com/cdleon/awesome-terminals" target="_blank" rel="noopener">many more available out there</a>.</p><h2 id="this-beast-of-terminal-unraveled">This Beast of Terminal Unraveled</h2><p>That was quite a ride! Terminal emulators seem convoluted internally, mostly due to their long history. Some <a href="https://github.com/withoutboats/notty" target="_blank" rel="noopener">new terminal emulators</a> try nowadays to go away from this legacy, but they’re not widely adopted yet.</p><p>What did we see in this article?</p><ul><li>Teleprinters (or teletypes, abbreviated TTY) were useful to encrypt and decrypt telegrams.</li><li>When the first computers appeared, teletypes were used to send some input and receive output.</li><li>Teleprinters were displaying input and output on paper. Video terminal were doing the same, but on a screen.</li><li>As computers got more powerful, video terminals were emulated in software.</li><li>There are two types of terminal emulators: virtual consoles and pseudoterminals.</li><li>Virtual consoles are not available anymore in most OS, except Linux-based ones.</li><li>A shell is a program interpreting the commands received from a terminal (physical or emulated one).</li><li>A virtual console interfaces with the difference programs running (processes), including the shell, thanks to the file <code>/dev/tty&lt;virtual_console_number&gt;</code> in Linux.</li><li>A pseudoterminal use two files; the one interfacing with the processes is <code>/dev/pts/&lt;terminal_number&gt;</code> on Linux.</li><li>The CLI “stty” can help you configure your terminal, by changing the control sequences, or enabling / disabling some settings.</li></ul><p>I believe that knowing how the terminal and most common shells work gives you an edge, especially when your terminal don’t behave as you want it to. This is a complex but particularly useful tool.</p></section></article></div></div>
  </body>
</html>
