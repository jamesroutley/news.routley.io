<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zig.news/aransentin/analysis-of-the-overhead-of-a-minimal-zig-program-4lg0">Original</a>
    <h1>Analysis of the overhead of a minimal Zig program</h1>
    
    <div id="readability-page-1" class="page"><div>

          <div data-article-id="102" id="article-body">
            <p>If you wanted to make a minimal x86-64 Linux program that did nothing, how would you write it? You&#39;d probably whip out an assembler and type something like this:<br/>
</p>

<div>
<pre><code>mov    eax, 60 ; sys_exit
xor    edi, edi
syscall
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>Letting <a href="https://lld.llvm.org/">LLD</a> link it for us nets us a binary that&#39;s 600 bytes large. Aggressively stripping out all the unnecessary trash that the linker puts into it makes it 297 bytes — but we&#39;re not interested in linker overhead right now, so let&#39;s use 600 as a baseline.</p>

<p>If we write a minimal Zig program that does the same thing, will it be just as small? Probably not. Let&#39;s go through every assembly instruction of the Zig binary and see what&#39;s up!</p>

<p>First, let&#39;s write that program:<br/>
</p>

<div>
<pre><code><span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{}</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>Building it with <code>-O ReleaseSmall --strip -fsingle-threaded</code> results in a 5.4KiB binary. The very first thing we realize is that all the debug symbols aren&#39;t stripped, because the Zig strip flag <a href="https://github.com/ziglang/zig/issues/351">isn&#39;t completely functional yet</a> and is waiting for the stage 2 compiler. No matter, we just do it manually (with <code>strip -s</code>), shrinking it to 1.7KiB.</p>

<p>What does all that code do? When we <code>objdump</code> it and take a look, we find 208 lines of assembly consuming 715 bytes. In addition, it uses 128 bytes for read-only data and 12624 bytes of <code>.bss</code> zero-initialized static data, only taking up space in a running program and not in the binary itself.</p>

<p>Let&#39;s go through each line of assembly to see what&#39;s going on. First, we have this:<br/>
</p>

<div>
<pre><code>xor    rbp,rbp
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>I.e. <code>rbp</code> is cleared. If we take a look in <code>std/start.zig</code> we can see that this is from inline assembly that zig runs immediately on <code>_start()</code>. Why? Presumably because the <a href="https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf">x86-64 ABI</a> mandates it:</p>

<blockquote>
<p>The content of this register is unspecified at process initialization time, but the user code should mark the deepest stack frame by setting the frame pointer to zero</p>
</blockquote>

<p>I&#39;ll allow it. ABI compliance is a very good reason for &#34;wasting&#34; 3 bytes of code, and should arguably be added to our original assembly program. Now, let&#39;s check the next line:<br/>
</p>

<div>
<pre><code>mov    QWORD PTR [rip+0x1e1e],rsp
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>What&#39;s this for? Turns out Zig always saves the initial value of <code>rsp</code>, since it starts out pointing to the <a href="http://articles.manugarg.com/aboutelfauxiliaryvectors.html">auxiliary vector</a>, which you need to parse the program arguments. We&#39;re not looking at that though, so this is at first glance a completely unnecessary waste of 7 bytes. </p>

<p>Next up:<br/>
</p>

<div>
<pre><code>2011e2: call   0x2011e7
2011e7: push   rbp
2011e8: [...]
2011f4: and    rsp,0xfffffffffffffff0
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>So, we&#39;re instantly calling a function located directly on the next byte. Looking around the code, we find that this is the only place it&#39;s called from. Why? From reading <code>start.zig</code> we find the answer: </p>

<blockquote>
<p>If LLVM inlines stack variables into _start, they will overwrite the command line argument data.</p>
</blockquote>

<p>So, the reason it&#39;s not inlined is because it&#39;s called with <code>never_inline</code>, because otherwise LLVM can put things that messes up <code>rsp</code> before the inline assembly that stashed <code>rsp</code> away. Makes sense, except it&#39;d be nicer if there was a non-hacky way of solving it. In any case we don&#39;t need <code>rsp</code> so ideally we shouldn&#39;t have to pay for this anyway.</p>

<p>What&#39;s up with the <code>and rsp,0xfffffffffffffff0</code>? That&#39;s because the function manually aligns the stack to the next 16-byte boundary. I&#39;m not sure why the stdlib does this. The SystemV ABI (§2.3.1) guarantees an initial alignment of 16 already, both for <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">x86-64</a> and <a href="https://www.uclibc.org/docs/psABI-i386.pdf">i386</a>, so it should be superfluous. From looking around a little, <a href="https://github.com/runtimejs/musl-libc/blob/master/crt/x86_64/crt1.s#L11">musl does the same alignment</a>, <a href="https://github.com/bminor/glibc/blob/595c22ecd8e87a27fd19270ed30fdbae9ad25426/sysdeps/x86_64/start.S#L89-L90">as does glibc</a>, but not <a href="https://github.com/ensc/dietlibc/blob/master/x86_64/start.S">dietlibc</a>.</p>

<p>Next up, the code is parsing the auxiliary vector. Not only is this needed for <em>argv</em>, but it also contains the program header which the program uses for <a href="https://en.wikipedia.org/wiki/Position-independent_code">PIE relocations</a> (if applicable, which it isn&#39;t for us). It also contains the stack size, which if not set to the default of 8MiB Zig asks the kernel to resize (it&#39;s not done automatically). This seems superfluous; if we compiled the program ourselves and used our own linker we should be able to hardcode the stack size resize at compile-time if necessary, not store it in some roundabout program header. Since Zig is working on <a href="https://github.com/ziglang/zig/issues/157">automatically calculating the maximum stack size required</a> as well, this information could be directly available to the compiler in the future and used here.</p>

<p>Lastly, the data is also needed to initialize the static <a href="https://en.wikipedia.org/wiki/Thread-local_storage">TLS</a> memory. This is for static threadlocal variables that should have an unique copy for each thread, like <code>errno</code>. &#34;But we are using <code>-fsingle-threaded</code>,&#34; you may ask, &#34;Why shouldn&#39;t the compiler turn all the thread-local variables to normal static ones and strip out the TLS section?&#34;. The reason is that you could export a threadlocal symbol to another program that&#39;s <em>actually</em> threaded, so we can&#39;t just remove them willy-nilly.</p>

<p>Moreover, since the TLS initialization calls <code>mmap</code> if the size is large enough, it can fail, which calls <code>abort()</code>. <code>abort()</code> in turn calls <code>raise(SIG.ABRT)</code>, and <code>raise</code> in turn masks out all the signals with <code>sigprocmask</code>. It&#39;s this call that uses the 128 bytes of readonly data we saw previously. It&#39;s fairly large as it needs to contains the entire set of possible signals.</p>

<p>The TLS initialization is also the explanation for much of the wasted <code>.bss</code> data as well; it uses an 8448 byte static buffer when the TLS data is small enough to fit it.</p>

<p>Tangentially we can see that avoiding TLS when it&#39;s not needed is an open issue: <a href="https://github.com/ziglang/zig/issues/2432">#2432</a>, so it&#39;s something that&#39;s in the pipeline to be handled.</p>

<p>In any case, since we don&#39;t use TLS, PIE, argv, nor env variables, all of this is just a waste of space. Let&#39;s try commenting all of that out; in <code>start.zig</code> we remove everything that depends on <code>argc</code>, then everything that depends on those lines and so on. After that&#39;s done we&#39;re more or less back at our initial ideal program size, just with the minor cruft I mentioned at the start:<br/>
</p>

<div>
<pre><code>xor    rbp,rbp
mov    QWORD PTR [rip+0x1016],rsp
call   0x201167
push   rbp ; @ 0x201167
mov    rbp,rsp
and    rsp,0xfffffffffffffff0
push   0x3c
pop    rax
xor    edi,edi
syscall 
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>Now, what was the point of all this? I think there are several benefits to minimizing overhead for simple programs:</p>

<ul>
<li><p>Having minimal overhead for tiny programs is actually relevant for system performance. Many scripts, for example, work by chaining together common Unix programs, so you&#39;re potentially having the same startup code running tens of thousands of times in a short duration. <a href="http://ryanhileman.info/posts/lib43">This can get fairly significant!</a> Right now Linux ameliorates the performance hit from this by either writing built-in copies of the most common tools directly into the shell (like Bash does), or having a single fat binary that you stuff a ton of programs into (like BusyBox) so you don&#39;t have to store the same initialization code across hundreds of programs.</p></li>
<li><p>The very first thing anybody interested in Zig will attempt to do is compile a &#34;Hello World!&#34; program and look at it. Having it being an order of magnitude smaller than the equivalent C program would be really impressive, and first impressions count for a lot. I&#39;ve watched friends try Go and immediately uninstall the compiler when they see that the resulting no-op demo program is larger than 2 MiB.</p></li>
<li><p>Overhead breeds complacency — if your program is already several megabytes in size, what&#39;s a few extra bytes wasted? Such thinking leads to atrocities like writing desktop text editors bundled on top of an entire web browser, and I think it would be nice to have a language that pushes people to be a bit more mindful of the amount of resources they&#39;re using.</p></li>
</ul>


          </div>

        </div></div>
  </body>
</html>
