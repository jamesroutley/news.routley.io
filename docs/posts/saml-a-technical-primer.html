<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ssoready.com/docs/saml/saml-technical-primer">Original</a>
    <h1>SAML: A Technical Primer</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><p>If you just want to start integrating SAML right away, check out the <a href="https://gianluca.ai/docs/saml/saml-quickstart">SAML
quickstart</a>. You can get a SAML integration
working end-to-end within a few hours.</p><p>This article is for folks who want to understand SAML at a deeper technical
level, or how they could implement SAML without using an open-source library
like SSOReady.</p></div></div></div></div>
<p><a target="_blank" rel="noreferrer" href="https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language">SAML<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>
(“Security Assertion Markup Language”) is a source of a lot of confusion for
developers. This article is a technical primer on some of the most common
questions engineers and other technical folks have about SAML:</p>
<ol>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#what-is-the-point-of-saml">Why do businesses want their software vendors to support SAML</a>? In other
words, how does SAML fit into my customer’s business? Why do end users and C-level executives at my customer care about SAML?</li>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#fitting-saml-into-your-existing-software">How should I fit SAML into my exiting software</a>? What parts of my software stack
need to be “SAML-aware”? How lightweight can I make my integration? (The answer: quite lightweight. Only a small part of your codebase needs to know about SAML at all.)</li>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-at-a-technical-level">At a technical level, how does SAML even work</a>? What does the SAML protocol
even do? What kinds of security guarantees does it give me, or what assumptions can I make about it?</li>
</ol>

<p>You care about supporting SAML because your customer wants your product to
support SAML. This is sound reasoning on your part. But why does your customer
want SAML support?</p>
<h2 id="one-click-to-login-why-your-users-like-saml" data-state="closed">One click to login: why your users like SAML</h2>
<p>Your users probably don’t know what SAML is. What they do know about is their
company’s <em>identity provider</em>. The most popular one is called
<a target="_blank" rel="noreferrer" href="https://www.okta.com/customer-identity/single-sign-on/">Okta<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>; other common
competitors to Okta include <a target="_blank" rel="noreferrer" href="https://www.microsoft.com/en-us/security/business/identity-access/microsoft-entra-id">Microsoft
Entra<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>
(formerly “Azure Active Directory”) and <a target="_blank" rel="noreferrer" href="https://workspace.google.com/">Google
Workspace<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>. There are dozens more vendors in this
space (big companies often build their own internal alternatives), and they all
use the SAML protocol.</p>
<p>Even though your users don’t know what SAML or what an identity provider is,
they do love what it gives them: one-click login experience for every SaaS tool
they use at work, a so-called <em>Single Sign-On</em> (SSO) experience.</p>
<p>For example, here’s what Okta looks like for your users. When your user opens
their computer at work in the morning, this is what they see:</p>
<figure><figcaption>A screenshot of Okta. Every app they use at work gets a &#39;tile&#39;. Click on a tile, and you&#39;re now logged into it.</figcaption></figure>
<p>At work, your users only need one password: their identity provider password.
They don’t need to set up or remember passwords anywhere. They might find
logging into Okta itself a bit annoying, because their IT team requires
two-factor authentication to log into Okta, but logging into everything else is
a breeze.</p>
<h2 id="one-click-to-fire-why-your-customers-ciso-likes-saml" data-state="closed">One click to fire: why your customer’s CISO likes SAML</h2>
<figure><figcaption>A screenshot of an IT admin deprovisioning an Okta user. CISOs love SAML because it lets them lock down all of an employee&#39;s accounts from a single place.</figcaption></figure>
<p>Your customer’s
<a target="_blank" rel="noreferrer" href="https://www.cisco.com/c/en/us/products/security/what-is-ciso.html">CISO<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a> (Chief
Information Security Officer) is in charge of making sure company data is
secure. Concretely, the biggest things they worry about is:</p>
<ul>
<li>Employees accidentally leaking data, because they use the same password
everywhere and that password got breached</li>
<li>Employees intentionally leaking data, because they were fired and want revenge</li>
</ul>
<p>CISOs love vendors that support SAML because they can put those vendor’s apps
inside the corporate identity provider, e.g. Okta. From there:</p>
<ul>
<li>
<p>Employees don’t need to have a password for that vendor. They just log in
using the identity provider. The identity provider uses the SAML protocol to
securely log the employee into the vendor’s app.</p>
</li>
<li>
<p>When the company fires someone, an IT admin doesn’t have to manually go in and delete that employee’s
account from the vendor. Once you remove an employee from Okta, then
Okta will stop letting that employee do SAML-based logins into <em>anything</em> (every
identity provider works like this). The fired employee is locked out of every
work application.</p>
</li>
</ul>
<p>But none of this works if your application doesn’t implement SAML. SAML is the
protocol that powers single-sign on, which lets identity providers like Okta log
employees into your app without using a password.</p>
<p>This is why many CISOs will go as far as to <em>require</em> SAML support out of all
vendors. Many companies have regulatory, contractual, or compliance obligations
to ensure employees don’t use insecure passwords and are properly off-boarded
after being fired. CISOs meet those obligations using SAML.</p>

<div><div><div><div><p>If you read <a target="_blank" rel="noreferrer" href="https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">the SAML
specification<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>,
or look at <a target="_blank" rel="noreferrer" href="https://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html">documentation written about SAML<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>
(especially if those docs were written in the early 2000s), it might seem like
SAML is a framework that can subsume or replace all of auth. Don’t do this.</p><p>”SAML solves everything” was a hot idea in 2002, but the industry has
moved away from this. The contemporary consensus is that SAML isn’t a great
protocol. Just use SAML as a way to securely find out what a corporate
user’s email address is.</p></div></div></div></div>
<p>You should think of SAML as a self-contained login method. You probably already
let your users log into your product using things like username+password, email
magic links, “Log in with Google”, etc. Think of SAML as another login method.</p>
<p>SAML is a protocol that lets your customer’s employees securely prove to you
what their email address is, without you having to worry about sending them
confirmation emails, verifying they’re still employed at the company, or that
they belong to the right team at the company.</p>
<p>Roughly speaking, only two parts of your overall system need to know about SAML:</p>
<ol>
<li>
<p>Your login page needs to know that SAML is a login option for a customer.
There are a couple common UI flows for doing this. We cover these in depth in
the <a href="https://gianluca.ai/docs/saml/integrating-saml-into-your-login-ui">Integrating SAML with your Login
UI</a> guide.</p>
<p>Ultimately, your login page will, at a technical level, <a href="https://gianluca.ai/docs/saml/saml-technical-primer#initiating-a-saml-login">initiate a SAML
login</a>.</p>
</li>
<li>
<p>Your login backend system needs to be able to <a href="https://gianluca.ai/docs/saml/saml-technical-primer#handling-a-saml-assertion">handle SAML
assertions</a>. We cover this in depth in the <a href="https://gianluca.ai/docs/saml/handling-saml-logins-jit-provisioning">Handling
SAML Logins</a> guide.</p>
<p>Ultimately your backend runs an HTTP endpoint, and your user’s web browsers
will POST SAML payloads there. You verify those payloads, and use your
normal session system (the same one you use for other kinds of logins) to
create a session for the email you securely extracted from the SAML
payload.</p>
</li>
</ol>
<p>If you don’t use an open-source library like SSOReady to help implement SAML,
the lack of structure that SAML imposes on you — as well as historical baggage
from the early days of SAML — can lead you astray in two common
ways:</p>
<ol>
<li>
<p>SAML supports the idea of putting “metadata” on a login session,
configuring “conditional access”, and lots of other fancy functionality. It
might seem like supporting SAML means having your entire system be able to honor
these advanced SAML-specific features.</p>
<p>Without getting into too much detail on what
that functionality was meant to achieve in 2002, suffice it to say that most
modern software systems don’t use this functionality at all.</p>
<p>If you treat SAML as just a way to get a user’s email, you will be in line
with almost all other SAML-supporting software your customer is used to.
CISOs expect, and will be satisfied with, this kind of simple integration.</p>
</li>
<li>
<p>SAML is, unfortunately, much more annoying to configure than any other login
method you already support. The technical details of these SAML settings are
covered later in this article <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">here</a>.</p>
<p>You and your customer need to exchange settings about one another before a SAML
login can even begin. But that configuration
happens “offline” — if you’re not using SSOReady, you’ll implement it by
exchanging informal emails with your customer. If you do use SSOReady, you can
have your customer <a href="https://gianluca.ai/docs/idp-configuration/enabling-self-service-configuration-for-your-customers">self-serve configure their SAML
setup</a>.</p>
<p>You don’t typically have to write
any UI or backend code related to configuring SAML configuration, beyond having
some way for your engineers to store the SAML settings you got from your
customer. You just need to store three small pieces on your backend (two strings
plus an X.509 certificate), and those settings change very infrequently.</p>
</li>
</ol>

<div><div><div><div><p>This section gets quite technical. You don’t need to understand this
material to understand how to use SSOReady. This section is, in a way, a
high-level overview of everything SSOReady abstracts away for you.</p></div></div></div></div>
<p>At the end of the day, SAML is a protocol that lets one of your users tell you
(“assert”) their email address using a payload (an “assertion”) that is
self-contained. When you get a SAML payload, you can securely know:</p>
<ol>
<li>Which of your corporate customers sent you the payload,</li>
<li>What email address, according to that corporate customer, this user has</li>
<li>That the corporate customer wants you to log this user in right away</li>
</ol>
<p>The tricky part about SAML is that you need to watch out for:</p>
<ol>
<li>Forged SAML assertions, wherein an attacker pretends to be one of your
corporate customers</li>
<li>Malicious or misconfigured corporate customers sending assertions about other
company’s employees, e.g. EvilCorp (<code>evilcorp.com</code>) telling you to log someone
in as the CEO of AcmeCorp (<code>ceo@acmecorp.com</code>).</li>
</ol>
<p>If you use SSOReady, these issues are both automatically covered by you.
Otherwise, you’ll typically need to implement (2) yourself, and you may want to
audit your SAML
dependency to make sure they adequately handle (1). Sadly, securely
authenticating SAML is tricky, and many libraries <a target="_blank" rel="noreferrer" href="https://nvd.nist.gov/vuln/detail/CVE-2024-45409">don’t do it
right<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>.</p>
<h2 id="the-saml-flow" data-state="closed">The SAML Flow</h2>
<p>There are three actors involved in a SAML flow:</p>
<ol>
<li>
<p>You are the <strong>service provider</strong> (“SP”). The service provider is software
product being logged into via SAML.</p>
</li>
<li>
<p>Your customer’s Okta/Entra/Google/etc is the <strong>identity provider</strong> (“IDP”).
The identity provider is responsible for knowing whether a user is a real
employee that wants to log into a product, and for telling service providers
about that information using SAML.</p>
</li>
<li>
<p>The <strong>user</strong> is mostly just along for the ride. In SAML, the SP and the IDP will
redirect the user to each other. The user’s browser is responsible for carrying
messages back and forth between the SP and IDP.</p>
</li>
</ol>
<figure><figcaption>A sequence diagram of a successful SAML login flow.</figcaption></figure>
<p>Logging in via SAML has five high-level steps:</p>
<ol>
<li>You and your customer agree, offline, on some settings about how you’re going
to do SAML.</li>
<li>When it’s time to log in via SAML, you have the user POST a SAML
<code>AuthnRequest</code> to your customer’s identity provider. This is called “initiating”
a SAML login.</li>
<li>Your customer’s identity provider handles making sure the user really has
valid corporate credentials. This step is entirely outside your app’s
control.</li>
<li>The identity provider has the user POST a SAML <code>Assertion</code> to your HTTP server.</li>
<li>You authenticate that the assertion is legitimate, and then log the user into
your product.</li>
</ol>
<div><div><div><div><p>If you’re familiar with OAuth, this flow might sound familiar. The biggest
difference between SAML and OAuth is how you verify the user after they get
redirected back to your application.</p><p>In OAuth, your backend server typically takes a <code>code</code> from the user, and
asks the identity provider if this <code>code</code> is legitimate, and what the
underlying user’s details are if it is.</p><p>In SAML, your backend server never talks directly to the identity provider.
You have to look at the assertion and use public-key cryptography to tell if
the identity provider cryptographically signed the message.</p></div></div></div></div>
<p>Step (1) is important conceptually, but doesn’t require any code. That’s covered
in the next section: <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">SAML Configuration</a>. Steps (2) and
(5) are the ones you have to write code for. They’re covered in <a href="https://gianluca.ai/docs/saml/saml-technical-primer#initiating-a-saml-login">Initiating a
SAML Login</a> and <a href="https://gianluca.ai/docs/saml/saml-technical-primer#handling-a-saml-assertion">Handling a SAML
Assertion</a>.</p>
<h3 id="sp--vs-idp-initiated-saml-flows" data-state="closed">SP- vs IDP-initiated SAML flows</h3>
<p>The discussion above illustrates the “SP-initiated” SAML flow, where your
application (the SP) decides to kick off the SAML flow.</p>
<p>SAML also supports “IDP-initiated” flows, where the IDP kicks off the SAML flow,
and just directly sends the user to your ACS URL with an assertion.</p>
<figure><figcaption>A sequence diagram of a successful IDP-initiated flow.</figcaption></figure>
<p>The only difference between an SP- and an IDP-initiated flow is that
IDP-initiated flows won’t require you to <a href="https://gianluca.ai/docs/saml/saml-technical-primer#initiating-a-saml-login">initiate
them</a>, and as a result don’t have <a href="https://gianluca.ai/docs/saml/saml-technical-primer#including-a-relaystate">a <code>RelayState</code></a>. Both
are widely used in
practice.
When you use SSOReady, you get both SP- and IDP-initiated SAML support
automatically.</p>
<h2 id="saml-configuration" data-state="closed">SAML Configuration</h2>
<p>For each of your customers, you will have five settings associated with the SAML
connection you have with them. These settings are:</p>
<ul>
<li>
<p>An <strong>Assertion Consumer Service (“ACS”) URL</strong>. You assign this value. It’s a
URL where you run an HTTP endpoint that’s ready to <a href="https://gianluca.ai/docs/saml/saml-technical-primer#handling-a-saml-assertion">handle SAML
assertions</a>. When the identity provider redirects
the user back to your application, they’ll send the user to the ACS URL.</p>
</li>
<li>
<p>An <strong>SP Entity ID</strong>. You assign this value, and it must be unique for every
customer. It’s a generic string, but
conventionally it’s formatted as a URL. The identity provider will include this SP
Entity ID in the
assertions it sends you, and you’ll use it to ensure the assertion was meant
for <em>you</em> and not some other application.</p>
</li>
<li>
<p>An <strong>IDP Redirect URL</strong>. The IDP assigns this value. When you <a href="https://gianluca.ai/docs/saml/saml-technical-primer#initiating-a-saml-login">initiate a SAML
login</a>, this is the URL you redirect the user to.</p>
</li>
<li>
<p>An <strong>IDP Entity ID</strong>. The IDP assigns this value. It’s a generic string, but
conventionally it’s formatted as a URL. When you initiate a SAML
login, you include this value so the IDP knows which application is starting
the login. The IDP will include this IDP Entity ID in the assertions it sends
you, and you’ll use it to make sure the assertion is coming from the right
identity provider.</p>
</li>
<li>
<p>An <strong>IDP Certificate</strong>. The IDP assigns this value. The IDP will use this certificate to
cryptographically sign the assertions it sends you. You will use
this certificate to authenticate that the identity provider really generated the
assertion, and that it wasn’t forged or tampered with.</p>
</li>
</ul>
<p>Once you have all of these settings in place, you can begin doing SAML logins.</p>
<h2 id="initiating-a-saml-login" data-state="closed">Initiating a SAML Login</h2>
<p>Initiating a SAML login concretely consists of having your user’s web browser
send a POST request with a payload that looks like this:</p>

<p>The <code>Issuer</code> needs to be equal to the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">SP Entity ID</a>.</p>
<p>That POST request needs to be pointed at the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">IDP Redirect
URL</a>. The POST request needs to be a standard HTTP form,
with the <code>AuthnRequest.xml</code> being base64-encoded and set as a form field called
<code>SAMLRequest</code>.</p>
<p>You can’t use a normal HTTP redirect to have your user POST a form to another
URL. The typical workaround is to render your user a form that self-submits
using JavaScript:</p>
<div><div><div><div><p><span>Self-Submitting SAML Initiation Form</span></p></div></div></div><pre tabindex="0"></pre></div>
<h3 id="including-a-relaystate" data-state="closed">Including a <code>RelayState</code></h3>
<p>When initiating a SAML login, you can optionally include a <code>RelayState</code>
parameter. You include this data as an additional parameter in the POST request:</p>
<div><div><div><div><p><span>Self-Submitting SAML Initiation Form with a RelayState</span></p></div></div></div><pre tabindex="0"></pre></div>
<p>Whatever you put in <code>RelayState</code> will be echoed back to you when you <a href="https://gianluca.ai/docs/saml/saml-technical-primer#handling-a-saml-assertion">handle the
SAML assertion</a>. The HTTP POST you receive will
contain, alongside the usual <code>SAMLResponse</code> entry, a <code>RelayState</code> entry.</p>
<p>The typical use-case for <code>RelayState</code> is to keep track of what page your user
was on before forced them to log in with SAML. Then, once they’re done logging
in with SAML, you redirect the user back to the page they were previously on.</p>
<div><div><div><div><p>You can’t trust that the <code>RelayState</code> you get back from an identity provider
is the same as the one you chose when initiating the SAML login. An attacker
can always send you a request with their own <code>RelayState</code> instead.</p><p>The most common security risk associated with <code>RelayState</code> is when you store
a URL in that <code>RelayState</code>, but don’t authenticate its legitimacy. If the
<code>RelayState</code> is allowed to redirect to a URL outside of your web
application, then you have an <a target="_blank" rel="noreferrer" href="https://cwe.mitre.org/data/definitions/601.html">open redirect
vulnerability<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>.</p><p>The safest solution is to cryptographically sign the <code>RelayState</code> value you
include in your request using a secret key. When you use SSOReady, every
<code>RelayState</code> is cryptographically authenticated; you do not need to worry
about the <a href="https://gianluca.ai/docs/ssoready-concepts/saml-login-flows#state"><code>state</code>
parameter</a> being tampered
with.</p></div></div></div></div>
<h2 id="handling-a-saml-assertion" data-state="closed">Handling a SAML Assertion</h2>
<p>After you <a href="https://gianluca.ai/docs/saml/saml-technical-primer#initiating-a-saml-login">initiate a SAML login</a>, the user is now on
the identity provider’s website. The user then identifies
themselves to the identity provider. Exactly how this works is outside of your
control.</p>
<div><div><div><div><p>Typically, an identity provider will ask for a user’s password, and
then may do multi-factor authentication checks. The point of SAML is that your
customer’s IT admin decides on their corporate security policy, and their
identity provider implements the logic. Your application doesn’t need to worry
about it.</p></div></div></div></div>
<p>If the identity provider decides to not proceed — maybe the user is fired, or
maybe hasn’t been internally authorized to use your application (e.g. your
customer only wants engineers using your app, but the employee works in sales),
then from your perspective, nothing happens. You’ll never hear back from the
login attempt. SAML doesn’t have a “login attempt failed” mechanism.</p>
<p>But if the login succeeds, then your user’s web browser will be redirected back
to your <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">SAML ACS URL</a>. The user will POST you a standard
set of HTML form data. That form data will contain up to two values:</p>
<ul>
<li>A <code>SAMLResponse</code> element, containing a base64-encoded XML document. This is
the SAML assertion.</li>
<li>A <code>RelayState</code>. This is only included if you <a href="https://gianluca.ai/docs/saml/saml-technical-primer#including-a-relaystate">included a <code>RelayState</code> in your
initiation request</a>.</li>
</ul>
<p>The job of “handling a SAML login” consists of three steps:</p>
<ol>
<li>Authenticating the legitimacy of the SAML payload</li>
<li>Deciding whether you want to honor the SAML request</li>
<li>Logging the user in</li>
</ol>
<p>To do any of this, you first need to parse the SAML assertion, and make sense of
its contents.</p>

<h3 id="anatomy-of-a-saml-assertion" data-state="closed">Anatomy of a SAML assertion</h3>
<p>The previous section discusses how your <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">ACS URL</a> will
receive an HTML form with a <code>SAMLResponse</code>. Here’s a real example of such a
<code>SAMLResponse</code>, base64-decoded, that came from Okta:</p>

<p>When we later <a href="https://gianluca.ai/docs/saml/saml-technical-primer#cryptographically-authenticating-a-saml-assertion">authenticate the SAML
assertion</a>, this is the
payload we will be authenticating. Whitespace matters.</p>
<p>But for the purposes of human legibility, let’s look at it in a prettier form:</p>
<div><div><div><div><p><span>assertion.xml (Pretty-Indented)</span></p></div></div></div><pre tabindex="0"></pre></div>
<p>The most important pieces of information are:</p>
<ul>
<li>
<p>The assertion <strong>issuer</strong> lives in <code>&lt;saml2:Issuer&gt;</code></p>

</li>
<li>
<p>The assertion <strong>signature</strong> lives in <code>&lt;ds:Signature&gt;</code> (specifically the one
inside <code>&lt;saml2:Assertion&gt;</code>). The most important parts are the</p>
<ul>
<li>Canonicalization <code>Algorithm</code> on <code>&lt;ds:CanonicalizationMethod&gt;</code></li>
<li>Signature <code>Algorithm</code> on <code>&lt;ds:SignatureMethod&gt;</code></li>
<li>Digest <code>Algorithm</code> on <code>&lt;ds:DigestMethod&gt;</code></li>
<li>The digest hash in <code>&lt;ds:DigestValue&gt;</code></li>
<li>The signature value in <code>&lt;ds:SignatureValue&gt;</code></li>
</ul>

</li>
<li>
<p>The assertion <strong>subject ID</strong> lives in <code>&lt;saml2:NameID&gt;</code></p>

</li>
<li>
<p>The assertion’s <strong>validity window</strong> is specified by the <code>NotBefore</code> and <code>NotOnOrAfter</code> on <code>&lt;saml2:Conditions&gt;</code></p>

</li>
<li>
<p>The assertion’s <strong>audience</strong> lives in <code>&lt;saml2:Audience&gt;</code></p>

</li>
</ul>
<p>Validating the assertion signature is what <a href="https://gianluca.ai/docs/saml/saml-technical-primer#cryptographically-authenticating-a-saml-assertion">cryptographically authenticating a
SAML assertion</a> is all
about. Validating all the other pieces of information — the issuer, the subject
ID, the validity window, the audience — happens when you <a href="https://gianluca.ai/docs/saml/saml-technical-primer#deciding-whether-to-honor-a-saml-login">decide whether to
honor the login</a>.</p>
<h3 id="cryptographically-authenticating-a-saml-assertion" data-state="closed">Cryptographically authenticating a SAML assertion</h3>
<div><div><div><div><p>Cryptographically authenticating SAML assertions is the most perilous part
of implementing SAML. This is the step where the most security-critical
mistakes happen.</p><p>If you choose to implement this yourself, you’re going to at minimum have to
handle untrusted XML payloads. Make sure your code (and its
dependencies) aren’t susceptible to generic XML vulnerabilities like
<a target="_blank" rel="noreferrer" href="https://cwe.mitre.org/data/definitions/776.html">billion laughs<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a> and <a target="_blank" rel="noreferrer" href="https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing">XML
entity expansion
attacks<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>.</p><p>From there, you’ll need to implement <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xmldsig-core/">XML Signature (aka
XMLDsig)<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>. This section will call out
many of the more common vulnerabilities with XML Signature implementations.</p></div></div></div></div>
<p>Before you can process a SAML assertion, you need to verify that it was really
sent by your customer’s identity provider. You <strong>must</strong> do this, because the
SAML assertion comes from an untrusted source: a user’s browser. How do you know
the user’s request contains a SAML assertion that was really produced by your
customer’s identity provider?</p>
<div><div><div><div><p>Make sure your SAML implementation can’t be tricked into skipping the
process of cryptographically authenticating SAML assertions.</p><p>Many SAML implementations can have such checks trivially bypassed by, for
example, just removing the <code>&lt;ds:Signature /&gt;</code> elements in an assertion. This
attack works most often when code contains logic that merely asks “are there
any invalid signatures in this XML payload?“. A SAML assertion without any
signatures trivially passes such a check.</p><p><a href="https://gianluca.ai/docs/ssoready-concepts/saml-login-flows#unsigned-assertion">SSOReady always requires that SAML assertions be
signed</a>. This
functionality cannot be disabled.</p></div></div></div></div>
<p>SAML implements cryptographic authentication using <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xmldsig-core/">XML
Signature<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>, which is a very complicated
standard that tries to anticipate dozens of different ways to sign XML messages.
Thankfully, the SAML specification does restrict what parts of XML Signature can
be used in a SAML assertion:</p>
<blockquote>
<p>5.4 XML Signature Profile</p>
<p>[…] This section details constraints on these facilities so that SAML processors do not
have to deal with the full generality of XML Signature processing.</p>
</blockquote>
<p>The restrictions SAML imposes on XML Signature are:</p>
<ul>
<li>XML Signature supports many different ways for where to put a signature
relative to what it signs. SAML assertions are signed using <em>enveloped</em>
signatures. This means the
<code>&lt;ds:Signature /&gt;</code> elements in a SAML assertion are placed <em>inside</em> the assertion.</li>
</ul>
<div><div><div><div><p>The same section of the specification reads:</p><blockquote>
<p>SAML processors SHOULD support the use of RSA signing and verification for public key
operations in accordance with the algorithm identified by <code>http://www.w3.org/2000/09/xmldsig#rsa-sha1</code>.</p>
</blockquote><p>Do not implement this requirement. Require <code>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</code> instead.</p><p>SHA1 was still considered secure when SAML 2.0 was drafted, but it is not
considered secure today. In practice, all modern identity providers support
RSA-SHA256 at minimum instead.</p></div></div></div></div>
<ul>
<li>
<p>XML Signature supports many different ways for a signature to indicate what
it’s signing. SAML stipulates that every assertion must have an <code>ID=&#34;...&#34;</code>
attribute, and that the signature points at it using <code>URI=&#34;#...&#34;</code>.</p>
</li>
<li>
<p>XML Signature supports many <em>canonicalization</em> algorithms (more on these
later). SAML assertions always use <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xml-exc-c14n/">Exclusive XML
Canonicalization<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>.</p>
</li>
</ul>
<p>SAML authenticates data in a three-step process: a subset of the SAML assertion
gets <em>canonicalized</em> and then <em>digested</em> (i.e. hashed). The hash is then
<em>signed</em> using RSA.</p>
<p>More concretely, the steps are to:</p>
<ol>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#extracting-the-saml-assertion-to-authenticate">Extract out the data that we want to canonicalize</a></li>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#canonicalizing-a-saml-assertion">Canonicalize that data</a></li>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#verifying-the-digest-of-the-canonicalized-assertion">Verify the digest (i.e. hash) of the canonicalized data</a></li>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#extracting-the-signedinfo-to-sign">Extract out the data we want to sign</a></li>
<li><a href="https://gianluca.ai/docs/saml/saml-technical-primer#authenticating-the-signedinfo">Verify the RSA signature of that data</a></li>
</ol>

<p>The data to authenticate is the <code>&lt;saml2:Assertion&gt;</code> inside the overall
<code>&lt;saml2p:Response&gt;</code> payload, but with the <code>&lt;ds:Signature&gt;</code> element removed.
However, you may need to copy over namespace declarations from the top-level
<code>&lt;saml2p:Response&gt;</code>; for instance, the identity provider
<a target="_blank" rel="noreferrer" href="https://www.keycloak.org/">Keycloak<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a> shapes its
assertions like so:</p>

<p>You don’t sign <code>&lt;saml:Assertion&gt;...&lt;/saml:Assertion&gt;</code>. You have to copy over all
namespaces “above” the XML assertion that are <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xml-exc-c14n/#def-visibly-utilizes">“visibly
utilized”<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>, including
in this case the <code>xmlns:saml</code> declaration:</p>

<p>With this data in hand, you are ready to canonicalize the assertion.</p>
<h4 id="canonicalizing-a-saml-assertion" data-state="closed">Canonicalizing a SAML assertion</h4>
<p>From there, you have to carry out the <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xml-exc-c14n/">Exclusive XML
Canonicalization<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a> algorithm on the
assertion. This algorithm is hairy in the details, but at a high level it is
there to make operations like “remove the <code>&lt;Signature&gt;</code> element from the
<code>&lt;Assertion&gt;</code>” be something that two parties can carry out, and still end up
with exactly the same set of bytes. Canonicalization (“c14n”) is an XML-to-bytes
algorithm.</p>
<div><div><div><div><p>Many XML libraries have abstractions that make it impossible to implement
XML canonicalization. You may need to write your own XML parser.</p><p>You need to use a library that exposes where XML namespaces are declared
(i.e. <code>xmlns:</code> attributes), and which lets you see what namespace prefixes
(i.e. the <code>foo</code> in <code>foo:bar</code>, not just what <code>foo</code> resolves to) that elements
and attributes use. These details are often abstracted away, because they
don’t affect message semantics.</p></div></div></div></div>
<p>Exclusive XML Canonicalization builds on top of <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xml-c14n11/">Canonical
XML<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>, aka “XML Canonicalization” or just “XML
c14n”.</p>
<p>XML Canonicalization is rather involved, but the basic idea is to make details
that don’t affect message semantics always resolve to the same thing:</p>
<ul>
<li>Empty elements (<code>&lt;foo /&gt;</code>) are converted to start/end pairs (<code>&lt;foo&gt;&lt;/foo&gt;</code>)</li>
<li>Element attributes are sorted by resolved namespace URI, ties broken
alphabetically. Namespace declarations come first.</li>
<li>Whitespace within elements is removed, but whitespace in text nodes is preserved</li>
</ul>
<div><div><div><div><p>The XML canonicalization spec is written to <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/2001/REC-xml-c14n-20010315#Example-Entities">require support for entity
expansion<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>,
for instance requiring that this document:</p><div><div><div><div><p><span>Input.xml (from the XML Canonicalization specification)</span></p></div></div></div><pre tabindex="0"></pre></div><p>Canonicalize to:</p><p><strong>Do not honor this requirement.</strong> You will be vulnerable to <a target="_blank" rel="noreferrer" href="https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing">XML Entity
Expansion
(“XXE”)<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>
attacks. The specification here is simply inappropriate for systems that
handle untrusted user input, such as SAML. In the real world, no SAML
systems rely on entity expansion. This part of the spec is irrelevant and
actively insecure in practice.</p></div></div></div></div>
<p>What makes XML Exclusive Canonicalization different from ordinary XML
Canonicalization is in how XML namespaces are handled. In particular, XML
Canonicalization stipulates that you only include XML namespaces that are
<a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xml-exc-c14n/#def-visibly-utilizes"><em>visibly utilized</em><svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>.</p>
<p>In other words, you take every namespace declaration (e.g. a <code>xmlns:foo=&#34;bar&#34;</code>
attribute), and you scan through everything “inside” that element. If they use
the declared namespace prefix (e.g. <code>&lt;foo /&gt;</code> or <code>foo:lorem=&#34;ipsum&#34;</code>), then you
keep the namespace declaration. Otherwise, you omit it from the output. If a
namespace declaration is “shadowed” (i.e. redeclared by a child element), then
you need to make sure it’s not the child declaration that’s being used. If two
prefixes resolve to the same URI (e.g. <code>&lt;lorem xmlns:a=&#34;xxx&#34; xmlns:b=&#34;xxx&#34;&gt;</code>),
you need to track the prefixes independently.</p>
<p>XML Exclusive Canonicalization permits for an <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xml-exc-c14n/#def-InclusiveNamespaces-PrefixList"><code>InclusiveNamespaces PrefixList</code><svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>
parameter. You need to support this. In SAML, that parameter gets passed in a
<code>InclusiveNamespaces</code> attribute under the <code>ds:Transform</code> element for
canonicalization in the signature:</p>

<p>What this element concretely does is say that any declaration of <code>xs</code> (e.g.
<code>xmlns:xs=&#34;...&#34;</code>) is always treated as being visibly used.</p>
<div><div><div><div><p>The XML Exclusive Canonicalization spec has a bunch of discussion about
special-casing <code>xmlns=&#34;&#34;</code>. You don’t need to worry about this; it’s written
to make the spec easier to implement using XPath, which has a hard time
“seeing” <code>xmlns=&#34;&#34;</code> declarations. But such declarations are never used in
practice in SAML.</p><p>You do, however, need to handle checking whether default (i.e. unprefixed)
namespace declarations are visibly used. Many identity providers send
assertions that declare default namespaces. Not all of these declarations
are always visibly used.</p></div></div></div></div>
<p>When you’re done with this step, you’ve converted the SAML payload into a
precise sequence of bytes, representing a normalized (i.e. canonicalized)
representation of the payload’s <code>&lt;Assertion&gt;</code> with the <code>&lt;Signature&gt;</code> removed.
Now, we can move on to doing cryptography.</p>
<h4 id="verifying-the-digest-of-the-canonicalized-assertion" data-state="closed">Verifying the digest of the canonicalized assertion</h4>
<p>After converting the SAML assertion into a set of canonicalized bytes, SAML
requires that those bytes be put through a digest — i.e. cryptographic hash
— algorithm.</p>
<p>The SAML specification does not put constraints on what digest algorithm be
used, but you can limit yourself to supporting SHA-256; it’s secure and widely
supported by modern identity providers.</p>
<div><div><div><div><p>As with the prior warning regarding RSA-SHA1, we recommend against
implementing SHA1. It is not generally considered secure today.</p><p>SHA1 is a legal digest algorithm for a SAML implementation to use, but its
use has since been formally discouraged by later revisions of the XML
Signature specification:
<a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/xmldsig-core1/#sec-MessageDigests">https://www.w3.org/TR/xmldsig-core1/#sec-MessageDigests<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a></p><p>In practice, all modern identity providers support SHA256 at minimum instead.</p></div></div></div></div>
<p>You will compare the SHA-256 sum of the canonicalized bytes against the
<code>&lt;ds:DigestValue /&gt;</code> element of the signature. If your computed SHA-256 doesn’t
equal the digest value in the assertion, then the message is invalid /
inauthentic.</p>
<p>One quirk here is that <code>&lt;ds:DigestValue /&gt;</code> contains the base64-encoded bytes
from SHA-256, not the more common hex encoding typically used for the output of
SHA-256.</p>
<div><div><div><div><p>Do <strong>not</strong> stop here. All you have done to this point is make sure the
<code>Signature</code> you’re looking at is meant for the assertion you want to
process. You still do not know that the assertion was actually generated by
the identity provider.</p><p>It is trivial for an attacker to generate a correct SHA-256 digest for an
assertion. You have jumped through a hoop SAML introduces, but you have not
yet done any meaningful cryptographic authentication.</p></div></div></div></div>

<p>SAML relies on RSA to cryptographically sign (and authenticate) assertions. The
SHA-256 digest of the assertion, which we verified in the previous section, is
not what gets signed. Instead, an XML element <em>containing</em> the digest is signed.</p>
<p>SAML requires that the RSA-SHA256 signature be over the <code>SignedInfo</code>, an XML
element that contains the digest:</p>
<div><div><div><div><p><span>SignedInfo (Pretty-Indented)</span></p></div></div></div><pre tabindex="0"></pre></div>
<p>To make matters a bit more complicated, this payload isn’t what gets signed; you
need to copy over all XML namespaces that this <code>SignedInfo</code> payload visibly
uses, so in this case we need to define <code>xmlns:ds</code> on the <code>SignedInfo</code> before
signing:</p>
<div><div><div><div><p><span>SignedInfo with namespaces copied in (Pretty-Indented)</span></p></div></div></div><pre tabindex="0"></pre></div>
<p>This is the data that you need to verify with RSA-SHA256.</p>
<h4 id="authenticating-the-signedinfo" data-state="closed">Authenticating the <code>SignedInfo</code></h4>
<p>The correct signature is stored in the <code>&lt;SignatureValue&gt;</code> of the <code>&lt;Signature&gt;</code>
element:</p>
<div><div><div><div><p><span>SignatureValue (Pretty-Indented)</span></p></div></div></div><pre tabindex="0"></pre></div>
<p>As with the digest information, this <code>SignatureValue</code> contains base64 data. You
verify that it is an RSA PKCS #1 v1.5 signature for the XML payload you
extracted in the previous section.</p>
<p>Verifying an RSA signature requires an RSA public key. You <strong>must</strong> use the RSA
public key inside the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">IDP’s X.509 certificate</a> to verify
the signature. Do not use any other key.</p>
<div><div><div><div><p>Every SAML assertion contains a <code>KeyInfo</code> element, which contains an X.509
certificate. <strong>Do not use this key.</strong> An attacker can trivially replace that
<code>KeyInfo</code> with a key they control. From there, they can generate valid
signatures easily.</p><p>Many open-source SAML libraries get this wrong. You should audit this. Any
SAML library that doesn’t take an RSA public key as a required parameter to
verify a SAML assertion is probably vulnerable.</p><p>To determine what the correct IDP certificate is, you must do so
out-of-band. See the section on <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">SAML configuration</a> in
this article. If you use SSOReady, you can have your customer securely
upload their IDP certificate using a <a href="https://gianluca.ai/docs/idp-configuration/enabling-self-service-configuration-for-your-customers">self-serve configuration
UI</a>
without any work or coding on your part.</p></div></div></div></div>
<div><div><div><div><p>You can optionally check that the contents of that <code>KeyInfo</code> equal the
one-and-only key that you trust. You can use that check to gracefully detect
if your customer has rotated their IDP certificate without first giving you
the new certificate.</p><p>If you use SSOReady, your customers will get such a <a href="https://gianluca.ai/docs/ssoready-concepts/saml-login-flows#bad-certificate">graceful warning about
incorrect
certificates</a> out
of the box. This is just a convenience feature for your customer; SSOReady
never trusts the <code>KeyInfo</code> on a user-provided assertion.</p></div></div></div></div>
<p>Once you have verified this signature (using the correct key), you have now
established that your customer’s identity provider really generated this
assertion. It is now your job to decide whether to honor this SAML login.</p>
<h3 id="deciding-whether-to-honor-a-saml-login" data-state="closed">Deciding whether to honor a SAML login</h3>
<div><div><div><div><p>Do <strong>not</strong> skip this step. Just because a SAML assertion was really
generated by your customer’s identity provider doesn’t mean you should honor it.</p><p>An attacker could be  performing a replay attack. You also need to guard
against the possibility of a customer <a href="https://gianluca.ai/docs/saml/saml-technical-primer#handling-malicious-identity-providers">maliciously configuring their
identity provider</a> to send you
assertions designed to log in as another one of your customers.</p></div></div></div></div>
<p>After authenticating a SAML login, you now need to take the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#canonicalizing-a-saml-assertion">authenticated
payload</a> (<strong>not</strong> the original,
pre-canonicalization assertion) and carry out a few checks on the data.</p>
<div><div><div><div><p>Once you’ve <a href="https://gianluca.ai/docs/saml/saml-technical-primer#authenticating-the-signedinfo">authenticated</a> the SAML
assertion, you need to only work with the canonicalized payload from then
on. The XML Signature specification <a target="_blank" rel="noreferrer" href="https://www.w3.org/TR/2002/REC-xmldsig-core-20020212/#sec-See">puts it this
way<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>:</p><blockquote>
<p>automated mechanism that trust the validity of a transformed document on
the basis of a valid signature should operate over the data that was
transformed (including canonicalization) and signed, not the original
pre-transformed data</p>
</blockquote><p>Concretely, the sort of vulnerability you need to worry about is that these
two messages:</p><p>Both canonicalize to the same thing, and so have the same signature. So if
your code does this:</p><p>Then with the second payload (the one with the attacker-inserted comment),
your code will be tricked into thinking the identity provider signed
<code>abraham.lincoln@whitehouse.gov</code>. In both examples, <code>validated_payload</code> are
equal, but in the second example, the pre-canonicalization <code>saml_payload</code> is
represented as:</p><p>The SAML assertion’s signature only testifies to the post-canonicalization
payload, and in this case an attacker found a way to make the semantics of a
payload be affected by something that goes away during canonicalization* (a
comment). The fix is to work with the canonicalized payload.</p><p>If you use SSOReady, the code you write does not need to handle XML payloads
at all. Internally, SSOReady implements controls against
canonicalization-related attacks.</p></div></div></div></div>
<p>You should check that:</p>
<ul>
<li>
<p>The assertion’s <strong>audience</strong> equals the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">SP Entity ID</a>
you assigned.</p>

<div><div><div><div><p>Verifying the assertion’s audience defends against replay attacks.</p><p>An attacker may take a legitimate assertion meant for one application,
and replay it to your application in order to do privilege escalation.</p><p>For example, many universities use the same IDP for all professors and
students. Many large organizations use the same IDP for executives and
for temporary employees.</p><p>The IDP might give out SAML assertions to anyone on staff to access the
internal company documentation hub. What if an employee takes a SAML
assertion meant for the documentation hub’s SP Entity ID, but sends it
to your (much more sensitive) application instead?</p><p>You might assume that checking the X.509 certificate on the assertion
would make sure the payload is meant for you. In fact, many IDPs use the
same certificate for every application.
<a target="_blank" rel="noreferrer" href="https://shibboleth.atlassian.net/wiki/spaces/IDP5/overview">Shibboleth<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a>,
in particular, is popular in higher education and is typically
configured this way.</p><p><a href="https://gianluca.ai/docs/ssoready-concepts/saml-login-flows#bad-audience">SSOReady always verifies assertion
audiences</a>. This
functionality cannot
be disabled.</p></div></div></div></div>
</li>
<li>
<p>The assertion’s <strong>validity window</strong> is valid against the current time, i.e.
hasn’t expired:</p>

<div><div><div><div><p>Verifying the assertion’s validity window defends against replay
attacks.</p><p>In the example above, Okta generated a SAML assertion that’s only valid
for 10 minutes. The intention here is that if a victim’s SAML assertion
were somehow leaked to an attacker, the attacker would have less than 10
minutes to carry out an attack. This doesn’t solve every problem, but it
does greatly limit the impact of, for example, leaks of network logs or
other historical data.</p><p>Do not try to implement your own validity window logic on top of SAML
assertions. That way, your customers can choose how tight they want to
make their assertion expirations, depending on their security posture.</p><p>SSOReady always verifies assertion expiration. This functionality cannot
be disabled.</p></div></div></div></div>
</li>
<li>
<p>The assertion <strong>issuer</strong> equals the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#saml-configuration">IDP Entity ID</a>:</p>

<div><div><div><div><p>Compared to verifying the assertion’s audience, verifying the issuer is
less critical.</p><p>Authenticating the assertion’s signature using the IDP’s certificate is
what does the heavy lifting of making sure the IDP really issued the
assertion. Checking the issuer is more for helping to debug SAML
misconfiguration.</p><p>Some identity providers don’t use unique IDP entity IDs;
<a target="_blank" rel="noreferrer" href="https://jumpcloud.com/">JumpCloud<svg width="1.5em" height="1.5em" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg" color="currentColor"><path d="M21 3L15 3M21 3L12 12M21 3V9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5C3 3.89543 3.89543 3 5 3H11" stroke="currentColor" stroke-linecap="round"></path></svg></a> defaults to setting the IDP Entity
ID to <code>JumpCloud</code> for all applications.</p><p><a href="https://gianluca.ai/docs/ssoready-concepts/saml-login-flows#bad-issuer">SSOReady always verifies assertion
issuers</a>. This
functionality cannot be
disabled.</p></div></div></div></div>
</li>
</ul>
<p>Once you have done these checks, you have now established that:</p>
<ul>
<li>The SAML assertion was really issued by your customer’s identity provider</li>
<li>The SAML assertion was really meant to be consumed by your application</li>
<li>The SAML assertion was recently issued, and hasn’t expired</li>
</ul>
<p>There is now only one major validation you need to worry about: what if the
customer’s identity provider is being malicious?</p>
<h4 id="handling-malicious-identity-providers" data-state="closed">Handling malicious identity providers</h4>
<p>Identity providers will diligently issue any assertion that the relevant IT
admin tells them to. When your customer’s Okta sends you an assertion, the
contents of that assertion are vouched for <em>only</em> by that customer. It’s <strong>not</strong>
vouched for by Okta itself.</p>
<p>To make this concrete: <a href="https://ssoready.com/blog/engineering/abraham-lincoln-and-the-malicious-saml-idp/">it’s trivial to create an Okta account for
<code>abraham.lincoln@whitehouse.gov</code>.</a>,
even if you don’t work at the White House. You don’t have to verify an email or
do anything like that. You can just stick whatever you want in <em>any</em> IDP,
including the popular ones like Okta.</p>
<p>So your final security step in handling SAML is this:</p>
<blockquote>
<p>AcmeCorp just told me to log a user in as <code>bob@acmecorp.com</code>. Is
<code>bob@acmecorp.com</code> a user that AcmeCorp “owns” in my product?</p>
</blockquote>
<p>There are a few ways you can do this, but the simplest way to start is to make
an allowlist of domains, which you (not your customer) control, associated with
every SAML-using customer. Only honor SAML logins for users whose email are in
that allowlist.</p>
<p>Effectively, this approach makes it possible for each of your customers to “own”
domains in your system. Unless they’re marked as owning a domain — something
<em>you</em> control, not your customer — then they can’t do SAML logins into that
domain.</p>

<p>The biggest vulnerability you should worry about is one customer putting another
customer’s email address into their identity provider, and then trying to log in
as them. A whitelist is a simple, reliable way to stop this.</p>
<p>You do not need to worry about an identity provider being “wrong” about its own
employees. The entire point of SAML is to let you delegate one company’s logins
to an identity provider that company controls. It’s beyond your control to
prevent an identity provider from “attacking itself”. It is in your control, and
it is your responsibility, to make sure you don’t accidentally delegate one company’s logins
to another company’s identity provider.</p>
<h3 id="logging-the-user-in" data-state="closed">Logging the user in</h3>
<p>You can now proceed to log the user in. Take whatever system you normally use to
log users in (such as if they logged in via password, or “Log in with Google”,
etc.), and give the user’s web browser a login session in your normal way — be
it a cookie, a JWT bearer token, or anything else.</p>
<div><div><div><div><p>When you were <a href="https://gianluca.ai/docs/saml/saml-technical-primer#deciding-whether-to-honor-a-saml-login">deciding whether to honor a SAML
login</a>, you had to validate whether
the SAML assertion is expired. Engineers sometimes think they need to make
their application sessions last just as long as the SAML assertion is valid.
This is not the case.</p><p>You don’t need to make the <code>NotOnOrAfter</code> of a SAML assertion affect how
long your application sessions last. It’s typical for IDPs to make
assertions very short-lived (Okta defaults to 10 minutes), because the goal
is to make it harder for attackers to intercept and replay SAML assertions. But your
application’s sessions can be much longer, because they aren’t communicated
across multiple trust boundaries like SAML assertions are.</p><p>In other words: don’t worry about this. Just give the user a session as
usual, with your usual session duration.</p></div></div></div></div>
<p>You should <strong>strongly</strong> consider implementing an audit log of every SAML
assertion you receive, and whether you decide to honor it or not. You should log
the entire SAML assertion; if one of your XML-related dependencies has a new
vulnerability discovered, you will need these logs to determine if that
vulnerability has been exploited against you.</p>
<div><div><div><div><p>If you use SSOReady, you will have <a href="https://gianluca.ai/docs/ssoready-concepts/saml-login-flows">an audit log event for every SAML
login</a>. These include a timestamp,
a complete record of the assertion, and details on any errors that may have
made the SAML assertion invalid.</p></div></div></div></div>
<p>Beyond this, you may want to give your customers a way to disable non-SAML
logins. This doesn’t affect how you handle a SAML login; rather, making SAML
logins mandatory for a customer gives that customer the guarantee that nobody is
going around the <a href="https://gianluca.ai/docs/saml/saml-technical-primer#one-click-to-fire-why-your-customers-ciso-likes-saml">benefits of SAML to your customer’s
CISO</a>.</p></div></div>
  </body>
</html>
