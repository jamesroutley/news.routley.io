<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lucavall.in/blog/how-to-structure-c-projects-my-experience-best-practices">Original</a>
    <h1>How to Structure C Projects: These Best Practices Worked for Me</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>I recently worked on two different C projects, and I wanted to structure them in a way that would make them easy to maintain and understand. I also wanted to make sure that the projects were easy to build and test. In this post, I will share my experience and the best practices I found for structuring C projects.</p><p>You can find the source code for the projects I worked on in the following repositories:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/lucavallin/barco">lucavallin/barco</a>: Linux containers from scratch in C.</li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/lucavallin/gnaro">lucavallin/gnaro</a>: A proto-database inspired by SQLite for educational purposes.</li></ul><p>Because of my limited experience with C - I hadn&#39;t written any in 10 years - I had to do a lot of research to find out what the current consensus is when it comes to directory layout. I found a lot of useful information on GitHub, Reddit, and Stack Overflow. I also looked at the source code of some popular open-source C projects to see how they were structured. I found that most of the projects I looked at followed a similar layout, and I decided to use that as a starting point.</p><h2 id="what-the-internet-people-say"><a aria-hidden="true" tabindex="-1" href="#what-the-internet-people-say"><span></span></a>What The Internet People Say</h2><p>If you Google for &#34;c project structure best pratices&#34; you&#39;ll get about 583.000.000 results - no need to worry about doing your own research - I read all of those pages, twice. While opinions vary, there are some common themes that come up again and again. Two approaches are particularly popular:</p><ul><li><strong>The &#34;modular&#34; approach</strong>: This is the most common approach for large projects. The idea is to split the project into multiple directories, each containing a different module of the project. Each module has its own header files, source files, and tests. This approach makes it easy to find the code you&#39;re looking for and makes it easy to test individual modules in isolation. This is the way the <a target="_blank" rel="noopener noreferrer" href="https://github.com/torvalds/linux">Linux kernel</a> is structured, for example.</li><li><strong>The &#34;flat&#34; approach</strong>: This approach is more common for small projects and it focuses on keeping the project as simple as possible and yet well-organized.</li></ul><p>Since the projects I worked on were relatively small, I decided to use the &#34;flat&#34; approach, which I am going to describe next.</p><h2 id="my-approach-to-structuring-c-projects"><a aria-hidden="true" tabindex="-1" href="#my-approach-to-structuring-c-projects"><span></span></a>My Approach to Structuring C Projects</h2><p>After going through all the 583.000.000 results twice, I settled on the following directory layout for my projects:</p><div><pre><code><span>├── .devcontainer           configuration for GitHub Codespaces
</span><span>├── .github                 configuration GitHub Actions and other GitHub features
</span><span>├── .vscode                 configuration for Visual Studio Code
</span><span>├── bin                     the executable (created by make)
</span><span>├── build                   intermediate build files e.g. *.o (created by make)
</span><span>├── docs                    documentation
</span><span>├── include                 header files
</span><span>├── lib                     third-party libraries
</span><span>├── scripts                 scripts for setup and other tasks
</span><span>├── src                     C source files
</span><span>│   ├── main.c             (main) Entry point for the CLI
</span><span>│   └── *.c
</span><span>├── tests                   contains tests
</span><span>├── .clang-format           configuration for the formatter
</span><span>├── .clang-tidy             configuration for the linter
</span><span>├── .gitignore
</span><span>├── compile_commands.json   compilation database for clang tools
</span><span>├── LICENSE
</span><span>├── Makefile
</span><span>└── README.md
</span></code></pre></div><p>Let&#39;s dive deeper into this layout. We can ignore <code>.devcontainer</code>, <code>.github</code>, <code>.vscode</code> and <code>scripts</code> for now, as they are specific to my development environment and not relevant to the project structure. The files <code>.clang-format</code> and <code>.clang-tidy</code> are configuration files for the <a target="_blank" rel="noopener noreferrer" href="https://clang.llvm.org/">Clang</a> formatter and linter, respectively. The <code>compile_commands.json</code> file is a compilation database for Clang tools. These files are not strictly necessary, but they can be useful if you want to use Clang tools in your project. <code>LICENSE</code> and <code>README.md</code> are self-explanatory, and <code>Makefile</code> needs no introduction either, although you can read more about how I wrote mine in <a href="https://www.lucavall.in/blog/crafting-clean-maintainable-understandable-makefile-for-c-project">Crafting a Clean, Maintainable, and Understandable Makefile for a C Project</a>.</p><p>Before we get into the more important details, let&#39;s get a few more directories out-of-the-way:</p><ul><li>The <code>bin</code> directory contains the executable that is created when you run <code>make</code>.</li><li>The <code>build</code> directory contains the intermediate build files, such as <code>.o</code> files.</li><li>The <code>docs</code> directory contains the documentation for the project.</li></ul><p>Let&#39;s spend some time on the <code>src</code>, <code>include</code>, <code>lib</code>, and <code>tests</code> directories.</p><h3 id="the-src-directory"><a aria-hidden="true" tabindex="-1" href="#the-src-directory"><span></span></a>The <code>src</code> Directory</h3><p>The <code>src</code> directory contains the C source files for the project, and you will spend most of your time here. I decided to keep it simple using a flat layout. Besides the <code>main.c</code> file which works as the entry file of the program, I split the rest of the code based on &#34;concerns&#34; and data-structures. For example, in the <code>gnaro</code> project:</p><ul><li><code>btree.c</code>: contains the implementation of a B-tree data structure.</li><li><code>cursor.c</code>: contains the implementation of a cursor for reading and writing to the database.</li><li><code>database.c</code>: contains the implementation of the database.</li><li><code>pager.c</code>: contains the implementation of the pager.</li><li><code>row.c</code>: contains the implementation of a row in the database.</li><li><code>input.c</code>, <code>meta.c</code> and <code>statement.c</code>: contain logic needed to parse and prepare user input.</li></ul><p>I found this simple layout to be easy to understand and navigate. It also makes it easy to find the code you&#39;re looking for, as long as you make an active effort to keep the files small and focused. The downside of this approach is that you will need to keep the <code>Makefile</code> updated with the new files you add to the project so that they are compiled and linked correctly. Given the small size of the projects I worked on, I didn&#39;t find this to be a problem, but it could be a problem for others.</p><h3 id="the-include-directory"><a aria-hidden="true" tabindex="-1" href="#the-include-directory"><span></span></a>The <code>include</code> Directory</h3><p>The <code>include</code> directory contains the header files for the project. Most if not all of the <code>.c</code> files in the <code>src</code> directory will have a corresponding <code>.h</code> file in the <code>include</code> directory. The header files should contain the public API for the module, and the source files should contain the implementation. This makes it easy to see what the module does without having to look at the implementation. It also makes it easy to test the module in isolation, as you can just include the header file in your test file.</p><p>Once again, using the <code>gnaro</code> project as an example:</p><ul><li><code>btree.h</code>: included in <code>src/btree.c</code>, defines the public API for the B-tree data structure.</li><li><code>cursor.h</code>: included in <code>src/cursor.c</code>, defines the public API for the cursor used to read and write from and to the database.</li><li><code>database.h</code>: included in <code>src/database.c</code>, defines the public API for the database implementation.</li><li><code>pager.h</code>: included in <code>src/pager.c</code>, defines the public API for the paging logic.</li><li><code>row.h</code>: included in <code>src/row.c</code>, defines the public API for the database&#39;s row structure.</li><li><code>input.h</code>, <code>meta.h</code> and <code>statement.h</code>: included in <code>src/input.c</code> and in <code>src/meta.c</code> and in <code>src/statement.c</code>, defines the public API for handling user input.</li></ul><p>Just like the <code>src</code> directory, the downside of this layout is that header files should be referenced in the <code>Makefile</code> so that they are included in the compilation process.</p><h3 id="the-lib-directory"><a aria-hidden="true" tabindex="-1" href="#the-lib-directory"><span></span></a>The <code>lib</code> Directory</h3><p>The <code>lib</code> directory contains third-party libraries that the project depends on. For example, <a target="_blank" rel="noopener noreferrer" href="https://github.com/lucavallin/gnaro">lucavallin/gnaro</a> makes use of the <a target="_blank" rel="noopener noreferrer" href="https://www.argtable.org">argtable</a> and <a target="_blank" rel="noopener noreferrer" href="https://github.com/rxi/log.c">log.c</a> libraries for parsing CLI arguments and logging, respectively.</p><p>There is not much to say about this directory. It&#39;s just a place to put your dependencies. Again, don&#39;t forget to include these in the <code>Makefile</code> as well, by the way.</p><h3 id="the-tests-directory"><a aria-hidden="true" tabindex="-1" href="#the-tests-directory"><span></span></a>The <code>tests</code> Directory</h3><p>The <code>tests</code> directory contains the tests for the project. I used the <a target="_blank" rel="noopener noreferrer" href="https://cunit.sourceforge.net">CUnit</a> library for testing, and I found it to be a good fit for my needs. The <code>tests</code> directory contains a test file for each module in the <code>src</code> directory. For example, in the <code>gnaro</code> project, the <code>tests</code> directory cointains <code>gnaro_test.c</code> file which is meant to test whatever logic defined in <code>src/gnaro.c</code>.</p><p>At this time, in pratice, the file only contains the code needed to setup the tests as recommended by the <a target="_blank" rel="noopener noreferrer" href="https://cunit.sourceforge.net">CUnit</a> documentation. While the tests run, I actually never followed-up on writing useful checks for <code>gnaro</code> and <code>barco</code> since they&#39;re just side-, hobby-projects.</p><h2 id="conclusion"><a aria-hidden="true" tabindex="-1" href="#conclusion"><span></span></a>Conclusion</h2><p>Thanks for reading this far! I hope you found this article useful. I know that the project layout I&#39;ve described is not the only way to organize a C project, but it&#39;s the way that I&#39;ve found to be the most effective for me. The <code>bin</code>, <code>build</code>, <code>docs</code>, <code>script</code>, and &#34;.something&#34; directories are helpful for development purposes, but it is in the <code>src</code>, <code>include</code>, <code>lib</code>, and <code>tests</code> directories where the real work happens.</p><ul><li><code>src</code>: contains the C source files for the project.</li><li><code>include</code>: contains the header files for the project, included by <code>.c</code> files in <code>src</code>.</li><li><code>lib</code>: contains third-party libraries that the project depends on.</li><li><code>tests</code>: contains the tests for the project.</li></ul><p>The <code>Makefile</code> is the glue that holds everything together and it must be updated to include new files and dependencies. While more modern build systems like CMake and Meson are available, I found that a simple <code>Makefile</code> was sufficient for my needs.</p><p>I hope that you can take some of the ideas I&#39;ve presented here and apply them to your own projects. If you have any questions or comments, feel free to reach out!</p></div></div></div></div>
  </body>
</html>
