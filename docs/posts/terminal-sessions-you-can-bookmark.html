<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://poor.dev/blog/building-zellij-web-terminal/">Original</a>
    <h1>Terminal sessions you can bookmark</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><a href="https://zellij.dev">Zellij</a> is a terminal workspace and multiplexer. One of the unique traits of terminal multiplexers is their ability to keep sessions alive in the background without a terminal attached to them. In the <a href="https://zellij.dev/news/web-client-multiple-pane-actions/">recent Zellij version</a> we released a built-in web client, allowing users to attach to these sessions from the browser - essentially making a dedicated terminal application optional.</p>
<p>In this post we’re going to take a look at how we built the Zellij Web Terminal: which technologies we used, how we architected the solution and some challenges we faced along the way.</p>
<h2 id="what-we-have">What we have</h2>
<p>Keeping sessions alive in the background involves a client/server architecture. The client runs in the user’s terminal like any other program and communicates over IPC with a server holding the state of the terminal session (open programs, pane and tab layout, etc.)</p>
<p>When Zellij first starts, the client spawns a new server process and daemonizes it so that it keeps running independently in the background. The client passes user input (keystrokes and mouse events) to the server, and the server passes render instructions to the client. When the client detaches from the server, the server remains alive until the client connects again.</p>
<h2 id="the-goal">The Goal</h2>
<p>To allow the browser to act as a Zellij client, we would need:</p>
<ol>
<li>A terminal emulator able to run inside the browser</li>
<li>A web-server able to both serve this emulator and interact with the Zellij server</li>
</ol>
<h2 id="architecting-the-solution">Architecting the solution</h2>
<p><img alt="architecture diagram - showing the many-to-many relationship between the Zellij web server and terminal sessions" src="https://clarionsong.substack.com/img/web-terminal/architecture.png"/></p>
<p>We elected to have a single web-server per machine, able to serve multiple sessions to multiple clients. Reusing the Zellij client code per connection, serving as a translation layer between the browser’s websockets and the Zellij server’s IPC channels. This would mean that there’s only one web-server per machine - making administration easier while still allowing multiple-session operations per browser client.</p>
<p>Since browser clients - through the web-server - will be connected to the same IPC channels as terminal clients, they appear as regular users inside a terminal session: blurring the distinction between the two user interfaces.</p>
<h2 id="building-the-web-server">Building the web server</h2>
<p><img alt="web-server diagram - demonstrating the relationship between the browser and the Zellij web server" src="https://clarionsong.substack.com/img/web-terminal/web-server-diagram.png"/></p>
<h4 id="url-scheme">URL scheme</h4>
<p>Zellij sessions are namespaced: their names being unique per the machine they are running on. When integrating with web technologies, we get an opportunity: we can tie this uniqueness to our URL scheme. Meaning that a session called “backend-code” will always be accessible through <code>https://127.0.0.1/backend-code</code>. Here’s how it works:</p>
<ol>
<li>If we enter a session’s URL in our browser and the session is running, we attach to it - viewing and interacting with its running processes.</li>
<li>If the session is not currently running but has existed in the past (eg. before a reboot) we <a href="https://zellij.dev/documentation/session-resurrection.html">resurrect it</a>: Zellij will re-create this session for us from its serialized metadata so that we can keep working where we left off.</li>
<li>If this is a completely new session, Zellij creates a session with this name and drops us into it.</li>
</ol>
<p>This has the effect of essentially giving our terminal a URL bar: we can bookmark entire sessions (eg. <code>prod</code>, <code>frontend</code>, <code>backend</code>), have a one-click peak into a running logfile or even be more creative and bookmark a session that atomically opens our <code>$EDITOR</code> pointed to a specific file (maybe <code>shopping-list.md</code> or <code>TODO</code>).</p>
<h4 id="connection-and-bi-directional-communication">Connection and bi-directional communication</h4>
<p>The initial handshake between web-client and server is performed through http(s). In this handshake, the client authenticates itself with a special token (generated manually by the user through Zellij - more on the security measures below). This handshake also serves to establish which session the client will initially connect to. Using the URL path as explained above.</p>
<p>Once the client is authenticated and the connection established, two websocket channels are established: a terminal channel and a control subchannel.</p>
<p>The terminal channel is used by the server to send <code>STDOUT</code> bytes to the client (essentially <a href="https://poor.dev/blog/terminal-anatomy/">ANSI instructions</a> representing renders) and by the client to send <code>STDIN</code> bytes to the server (keypresses and mouse events). The control subchannel is used by the client side to send window resizes to the server and by the server side to send configuration changes, log messages and switch-session instructions to the client.</p>
<p>The reason these two are separated is two-fold: first so that they don’t end up blocking each other and second as a performance consideration to allow the potentially-heavy-throughput <code>STDOUT</code> not to be serialized/deserialized to distinguish it from control messages. We initially thought this would also allow us to apply backpressure from the browser all the way to the terminal application in order to batch up messages until they are fully processed, but this ended up not being necessary (as this is done well enough on the <a href="https://poor.dev/blog/performance/">Zellij application side</a> before it reaches the web server).</p>
<h4 id="security-model">Security model</h4>
<p>Since terminals are a sensitive interface to any machine, we were conscious about including built-in security measures with the solution. To log in, users need to generate a login-token from within a Zellij session (either from the command-line or from the Zellij UI).</p>
<p>Special care has been taken for this token never to be saved in its clear form in any storage. On the server-side, it is hashed and kept in a local SQLite database where it cannot be retrieved, only revoked. On the client-side, it is initially sent through the POST parameters of the handshake and then exchanged for a temporary session-token. This session-token is saved as an “http only” cookie so that the client-side code cannot access it. On the server side it is read from the http-headers.</p>
<p>The Zellij web-server enforces the use of HTTPS with a user-supplied certificate when listening on external interfaces. HTTP is only allowed when listening on localhost. We believe this is a reasonable compromise between security and user-friendliness. Allowing users to try the web capabilities locally first without forcing them to create an HTTPS certificate, but requiring one for terminal traffic passing over the wire.</p>
<p>Authenticated users are considered trusted, since by definition they have the same permissions and access as the web-server itself.</p>
<h4 id="server-side-technologies">Server side technologies</h4>
<p>Since Zellij is written in Rust, we naturally decided to use Rust to develop the web-server as well.</p>
<p>We chose <a href="https://docs.rs/axum/latest/axum/"><code>axum</code></a> as our webserver because we liked its mix-and-match approach - allowing us to plug in custom technology implementations and middleware (eg. the tower ecosystem for cookie and CORS handling), or use its built-in options when possible. We liked that it integrates seamlessly with tokio (our async runtime) and that it provides a “native” websocket implementation (using tokio-tungstenite under the hood). We also liked its declarative rather than macro-like routing system, even though we believe this last is mostly an aesthetic choice.</p>
<p>With <code>axum</code>, our web routes look like this (simplified):</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>app</span><span> </span><span>=</span><span> </span><span>Router</span>::<span>new</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>route</span><span>(</span><span>&#34;/ws/control&#34;</span><span>,</span><span> </span><span>any</span><span>(</span><span>ws_handler_control</span><span>))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>route</span><span>(</span><span>&#34;/ws/terminal&#34;</span><span>,</span><span> </span><span>any</span><span>(</span><span>ws_handler_terminal</span><span>))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>route_layer</span><span>(</span><span>middleware</span>::<span>from_fn</span><span>(</span><span>auth_middleware</span><span>))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>route</span><span>(</span><span>&#34;/&#34;</span><span>,</span><span> </span><span>get</span><span>(</span><span>serve_html</span><span>))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>route</span><span>(</span><span>&#34;/{session}&#34;</span><span>,</span><span> </span><span>get</span><span>(</span><span>serve_html</span><span>))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>route</span><span>(</span><span>&#34;/assets/{*path}&#34;</span><span>,</span><span> </span><span>get</span><span>(</span><span>get_static_asset</span><span>))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>with_state</span><span>(</span><span>state</span><span>);</span><span>
</span></span></span></code></pre></div><p>Here we are able to protect the websocket routes (them being the ones who actually end up creating, attaching and communicating with the Zellij sessions) with an authentication middleware, while serving static assets in routes not protected by authentication.</p>
<p>We chose <a href="https://github.com/rustls/rustls"><code>rustls</code></a> for serving the client with HTTPS rather than relying on openssl. Elsewhere in the app we made the opposite choice and found that this creates a great deal of complexity when packaging Zellij for third-parties (eg. linux distributions and crates.io). We hope to use this decision as a crutch to slowly migrate the rest of the app to do the same, rather than doubling-down on a decision that ended up causing us trouble. The trade-off is mostly binary-size, but in this day and age we believe this is not an issue in the vast majority of environments.</p>
<p>For static assets, we use rust’s <a href="https://docs.rs/include_dir/latest/include_dir/"><code>include_dir!</code></a> macro, packaging them as part of the executable. This is a must for us as a distributable application rather than a managed web-server.</p>
<h5 id="handling-daemonization">Handling daemonization</h5>
<p>Given our architecture, there are a few occasions in which we need to daemonize the web-server - it being implemented as a separate process that serves all sessions on the machine. We do this with the <a href="https://docs.rs/daemonize/latest/daemonize/"><code>daemonize</code></a> crate, which gives a split interface: one branch for the child (the web server instance in our case) and one branch for the parent (the process invoking the web-server - for example the Zellij command line or another Zellij process).
One challenge in this approach is error reporting. If the web-server failed to start for one reason or another, we need to be able to let the invoking process know so that we can display a proper error to the user (eg. <code>Permission denied</code>, <code>Address in use</code>, etc.)</p>
<p>To do this, we use the <code>privileged_action</code> method of the daemonize crate, allowing us to run code in the child process after the fork but before it detaches itself from the parent process’s environment. In this method we run as much error prone operations as possible, creating the necessary entities (runtime, TLS config, TCP listener) for the child if successful. We then use a Unix pipe to let the parent process know the result of these operations (in the form of an <code>exit_code</code>) as well as provide a relevant textual error if the operation was not successful.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>daemonize_web_server</span><span>()</span><span> </span>-&gt; <span>(</span><span>/* server_resources */</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Create pipes for parent-child communication
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>(</span><span>mut</span><span> </span><span>exit_message_tx</span><span>,</span><span> </span><span>exit_message_rx</span><span>)</span><span> </span><span>=</span><span> </span><span>pipe</span><span>().</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>(</span><span>mut</span><span> </span><span>exit_status_tx</span><span>,</span><span> </span><span>mut</span><span> </span><span>exit_status_rx</span><span>)</span><span> </span><span>=</span><span> </span><span>pipe</span><span>().</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>daemonization_outcome</span><span> </span><span>=</span><span> </span><span>daemonize</span>::<span>Daemonize</span>::<span>new</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>privileged_action</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>/* server_resources */</span><span>,</span><span> </span><span>String</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// Perform error-prone operations before full daemonization:
</span></span></span><span><span><span></span><span>            </span><span>// - Create async runtime
</span></span></span><span><span><span></span><span>            </span><span>// - Load TLS certificates
</span></span></span><span><span><span></span><span>            </span><span>// - Bind TCP listener
</span></span></span><span><span><span></span><span>            </span><span>// Convert all errors to strings for IPC
</span></span></span><span><span><span></span><span>        </span><span>})</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>execute</span><span>();</span><span>
</span></span></span><span><span><span>        
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>daemonization_outcome</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Outcome</span>::<span>Parent</span><span>(</span><span>Ok</span><span>(</span><span>parent</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// Parent waits for child&#39;s initialization result
</span></span></span><span><span><span></span><span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>;</span><span> </span><span>1</span><span>];</span><span>
</span></span></span><span><span><span>            </span><span>exit_status_rx</span><span>.</span><span>read_exact</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>buf</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>exit_status</span><span> </span><span>=</span><span> </span><span>buf</span><span>[</span><span>0</span><span>]</span><span> </span><span>as</span><span> </span><span>i32</span><span>;</span><span>
</span></span></span><span><span><span>            
</span></span></span><span><span><span>            </span><span>// Read error message if any
</span></span></span><span><span><span></span><span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>message</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>reader</span><span> </span><span>=</span><span> </span><span>BufReader</span>::<span>new</span><span>(</span><span>exit_message_rx</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>reader</span><span>.</span><span>read_line</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>message</span><span>);</span><span>
</span></span></span><span><span><span>            
</span></span></span><span><span><span>            </span><span>// Display result and exit with child&#39;s status
</span></span></span><span><span><span></span><span>            </span><span>if</span><span> </span><span>exit_status</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>println!</span><span>(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> </span><span>message</span><span>.</span><span>trim</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>eprintln!</span><span>(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> </span><span>message</span><span>.</span><span>trim</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>            </span><span>std</span>::<span>process</span>::<span>exit</span><span>(</span><span>exit_status</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>},</span><span>
</span></span></span><span><span><span>        </span><span>Outcome</span>::<span>Child</span><span>(</span><span>Ok</span><span>(</span><span>child</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>match</span><span> </span><span>child</span><span>.</span><span>privileged_action_result</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>Ok</span><span>(</span><span>server_resources</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>// Success: notify parent and continue as daemon
</span></span></span><span><span><span></span><span>                </span><span>exit_status_tx</span><span>.</span><span>write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>]);</span><span>
</span></span></span><span><span><span>                </span><span>writeln!</span><span>(</span><span>exit_message_tx</span><span>,</span><span> </span><span>&#34;Web Server started&#34;</span><span>);</span><span>
</span></span></span><span><span><span>                </span><span>server_resources</span><span>
</span></span></span><span><span><span>            </span><span>},</span><span>
</span></span></span><span><span><span>            </span><span>Err</span><span>(</span><span>error</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>// Failure: send error to parent and exit
</span></span></span><span><span><span></span><span>                </span><span>exit_status_tx</span><span>.</span><span>write_all</span><span>(</span><span>&amp;</span><span>[</span><span>2</span><span>]);</span><span>
</span></span></span><span><span><span>                </span><span>writeln!</span><span>(</span><span>exit_message_tx</span><span>,</span><span> </span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>error</span><span>);</span><span>
</span></span></span><span><span><span>                </span><span>std</span>::<span>process</span>::<span>exit</span><span>(</span><span>2</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>},</span><span>
</span></span></span><span><span><span>        </span><span>},</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h4 id="client-side-technologies">Client side technologies</h4>
<p>The client-side includes a fully featured terminal: the excellent <a href="https://xtermjs.org/"><code>xterm.js</code></a>. xterm.js has been around for many years and is used among other places as the terminal emulator in VSCode. It is battle tested and feature rich. xterm.js performs most of the work on the client side (terminal rendering and user input), but we had to write some custom integrations to make it fit with our use-case.</p>
<p>A prime example: at the time of writing xterm.js does not support mouse AnyEvent tracking, which Zellij heavily relies on. In this terminal mouse mode, mouse motions are sent to the terminal along with other events (eg. press and release). To work around this, we listen to the browser “mousemove” event, translate it to an ANSI instruction and send it to the server. Since mouse AnyEvent works with columns/rows rather than coordinates, we use an internal xterm.js function to make the translation. Not ideal, but works in a pinch.</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>terminal_element</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;mousemove&#34;</span><span>,</span> <span>function</span> <span>(</span><span>event</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>event</span><span>.</span><span>buttons</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>// this means no mouse buttons are pressed and this is just a mouse movement
</span></span></span><span><span><span></span>        <span>let</span> <span>{</span> <span>col</span><span>,</span> <span>row</span> <span>}</span> <span>=</span> <span>term</span><span>.</span><span>_core</span><span>.</span><span>_mouseService</span><span>.</span><span>getMouseReportCoords</span><span>(</span>
</span></span><span><span>            <span>event</span><span>,</span>
</span></span><span><span>            <span>terminal_element</span>
</span></span><span><span>        <span>);</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>prev_col</span> <span>!=</span> <span>col</span> <span>||</span> <span>prev_row</span> <span>!=</span> <span>row</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>sendFunction</span><span>(</span><span>`\x1b[&lt;35;</span><span>${</span><span>col</span> <span>+</span> <span>1</span><span>}</span><span>;</span><span>${</span><span>row</span> <span>+</span> <span>1</span><span>}</span><span>M`</span><span>);</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>prev_col</span> <span>=</span> <span>col</span><span>;</span>
</span></span><span><span>        <span>prev_row</span> <span>=</span> <span>row</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>});</span>
</span></span></code></pre></div><p>Another example involves window titles. When working with a standard dedicated terminal application, it is often the case where the window title reflects the current working directory or the program name. This is done with an ANSI instruction called “OSC 0”. You can try it yourself: <code>echo -e &#34;\033]0;my awesome title\007&#34;</code> (note: you might want to add an <code>&amp;&amp; sleep 10</code> afterwards because some shell prompts will change it back immediately). Zellij uses this instruction to display both the session name and the title of the currently focused pane to the terminal. We would of course like this to also be the case for the browser - and more crucially, to the browser tab. To make this work, we intercept this instruction in the rendered bytes with a regex, changing the document.title to match:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>wsTerminal</span><span>.</span><span>onmessage</span> <span>=</span> <span>function</span> <span>(</span><span>event</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    <span>let</span> <span>data</span> <span>=</span> <span>event</span><span>.</span><span>data</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>titleRegex</span> <span>=</span> <span>/\x1b\]0;([^\x07\x1b]*?)(?:\x07|\x1b\\)/g</span><span>;</span>
</span></span><span><span>    <span>let</span> <span>match</span><span>;</span>
</span></span><span><span>    <span>while</span> <span>((</span><span>match</span> <span>=</span> <span>titleRegex</span><span>.</span><span>exec</span><span>(</span><span>data</span><span>))</span> <span>!==</span> <span>null</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>document</span><span>.</span><span>title</span> <span>=</span> <span>match</span><span>[</span><span>1</span><span>];</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span><span>};</span>
</span></span></code></pre></div><h4 id="why-not-typescript">Why not Typescript?</h4>
<p>While our client-side implementation leans heavily toward simple no-dependency solutions, coming from a strongly typed language like Rust we appreciate the value of being able to define data types for our interfaces. Typescript could offer significant benefits for our use-case, especially with regards to the various websocket message types.</p>
<p>On the other hand, Typescript comes with the heavy tax of an extra build-step. A tax particularly significant in our case since otherwise our client-side code does not have a build step at all.</p>
<p>While we could have implemented the build-step as part of the Zellij build-system (using the excellent <a href="https://github.com/matklad/cargo-xtask">cargo xtask</a>), we were wary of the extra build complexity (the usual “Are my changes failing because of issues in my code or in the build system?”)</p>
<p>We ultimately decided against it. Reasoning that since our client-side code is relatively small, the complexity of introducing another build-step is more error prone than not using types at all. Time will tell if we made the right choice, and we might revisit it again as our client-side code expands.</p>
<h3 id="whats-next">What’s next?</h3>
<p>The Zellij web client is a small step forward in the larger scheme of things. It is a first-class interface into another medium.</p>
<p>In the upcoming Zellij versions I plan to expand the web  interface to include native rendering of UI components. I plan to allow blending multiple Zellij sessions with full-fledged read/write permissions, blurring the distinction between different machines on the UI level. I plan to follow up with hosted solutions for multiplayer terminal sessions.</p>
<p>If you are interested, the best way to follow along is to become a Zellij user and help build upon this infrastructure. We’re just getting started.</p>
<h2 id="please-sponsor-me-and-zellij-development-">Please Sponsor Me and Zellij Development ❤️</h2>
<p>Zellij is developed and maintained as a labor of love, but love does not pay the bills.</p>
<p>Zellij will always be free and open-source. Zellij will never contain ads or collect your data.</p>
<p>If you are able, consider sponsoring the Zellij creator and lead developer with <a href="https://github.com/sponsors/imsnif">a recurring monthly donation</a>. There are Zellij stickers in it for you!</p>

  </div></div>
  </body>
</html>
