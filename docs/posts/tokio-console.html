<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tokio.rs/blog/2021-12-announcing-tokio-console">Original</a>
    <h1>Tokio Console</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div><p>Today, we, the Tokio team, are announcing the initial release of Tokio Console
(<a href="https://github.com/tokio-rs/console">Github</a>), enabling Rust developers to gain deeper
insight into the runtime behavior of their applications.</p><blockquote><p>And just like that, we get to peek under the hood.
<a href="https://niedzejkob.p4.team/amos-nerdsniped-me/">—<!-- -->niedzejkob</a></p></blockquote><p>Tokio Console is a diagnostics and debugging tool for asynchronous Rust
programs. It gives you a live, easy-to-navigate view into the program&#39;s tasks
and resources, summarizing both their current status and their historical
behavior.</p><p>Until now, understanding the state of an async runtime has required developers
to interpret event logs. Frameworks like <a href="https://crates.io/crates/tracing"><code>tracing</code></a> provide tools for
instrumenting programs and querying the resulting output, but it is non-trivial
to know what queries to use, and how to interpret the output. For example, if
you are not familiar with the source code of Tokio, you won&#39;t necessarily know
which <code>tracing</code> events to look for, nor what those events mean.</p><p><code>tokio-console</code> solves this problem by providing a presentation of the async
runtime that is described in terms already familiar to the async developer: the
set of tasks being polled by the async runtime, and the resources that each task
acquires or releases as it services requests. You do not need to write any new
instrumentation logic: just one line of code to enable Tokio Console suffices,
and after that, you use the provided terminal tool to observe the async runtime.</p><p><code>tokio-console</code> brings odd behaviors to the forefront. You can sort the tasks by
metrics such as total busy time or number of polls. The console helps out by
highlighting big differences, such as shifts from milliseconds to seconds.</p><p><img alt="tasks list screenshot" src="https://raw.githubusercontent.com/tokio-rs/console/main/assets/tasks_list.png"/></p><p>In addition to displaying data, the console implements a &#34;warnings&#34; system. You
can think of this as like <a href="https://github.com/rust-lang/rust-clippy">clippy</a> for async code. By monitoring the runtime
operation of tasks in the application, the console can detect patterns of
behavior that <em>might</em> suggest a bug or performance issue, and highlight them for
the user to analyse. This allows us to detect things like <a href="https://ryhl.io/blog/async-what-is-blocking/">tasks that have run
for a very long time without yielding</a>, tasks that have woken
themselves more times than they&#39;ve been woken by other tasks, and more. All of
these behaviors are impossible to detect at compile-time <!-- -->—<!-- --> there&#39;s no way
for clippy or <code>rustc</code> to add lints for them <!-- -->—<!-- --> but by watching runtime
behavior, we can detect them very easily.</p><p><img alt="warnings screenshot" src="https://raw.githubusercontent.com/tokio-rs/console/main/assets/warnings.png"/></p><p>Adding the <a href="https://crates.io/crates/console-subscriber"><code>console-subscriber</code></a> crate exposes the instrumentation already
built into the Tokio runtime, so you do not need to write any new
instrumentation logic. (Of course, you can tailor the console output <!-- -->—<!-- --> for
example, by explicitly naming your tasks <!-- -->—<!-- --> if desired.) After
initialization, you can use the <code>tokio-console</code> terminal application to directly
see what tasks are running and how they are being scheduled by the async
runtime.</p><p>We can use this data to view extremely rich data about each individual task,
such as a histogram of <code>poll</code> durations:</p><p><img alt="task details" src="https://raw.githubusercontent.com/tokio-rs/console/main/assets/details2_crop.png"/></p><p>Tokio Console goes beyond just listing tasks. It will also instrument resources,
such as async <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html">mutexes</a> and <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Semaphore.html">semaphores</a>. Tokio Console&#39;s resource details view
shows you which tasks have entered a critical section, and which tasks are
waiting to obtain access.</p><p><img alt="resource details" src="https://raw.githubusercontent.com/tokio-rs/console/main/assets/resource_details2.png"/></p><p>The devs at <a href="https://www.datadoghq.com/">Datadog</a>, working on
<a href="https://vector.dev/">Vector</a>, have already successfully been using pre-release
versions of Tokio Console to help debug issues. <a href="https://github.com/tobz">Toby Lawrence</a>
says:</p><blockquote><p>While debugging a particularly mysterious issue related to a task not making
progress as expected, <code>tokio-console</code> was able to immediately surface that a
lack of wake-ups was the cause, providing insight that ultimately lead to
discovering unexpected scheduling behavior with Tokio.</p></blockquote><p>To get started with the console, run <code>cargo install tokio-console</code>, then follow
the instructions to <a href="https://docs.rs/console-subscriber/latest/console_subscriber/">add <code>console-subscriber</code></a> to your async
application:</p><pre><code><span>#[tokio::main]</span>
<span>async</span> <span><span>fn</span> <span>main</span></span>() {
   console_subscriber::init();
   
}</code></pre><p>Once your application is running, you can connect to it by running
<code>tokio-console</code> in a terminal.</p><pre><code><span>%</span><span> tokio-console</span></code></pre><p>See the <a href="https://docs.rs/tokio-console/latest/tokio_console/#getting-started"><code>tokio-console</code> documentation</a> for details on how to use
the console terminal application.</p><p>Because this is an early release, the instrumentation of the Tokio runtime has
not yet been stabilized. You can enable it by compiling Tokio with the unstable
environment variable set: <code>RUSTFLAGS=&#34;--cfg tokio_unstable&#34; cargo build</code>. See
the <a href="https://docs.rs/console-subscriber/latest/console_subscriber/">subscriber documentation</a> for more details.</p><p>This release of Tokio Console is just the beginning. While we think it already
is very useful to help debug async Rust applications, we have much more planned
(e.g. <a href="https://github.com/tokio-rs/console/issues/96">#96</a>, <a href="https://github.com/tokio-rs/console/issues/130">#130</a>, <a href="https://github.com/tokio-rs/console/issues/155">#155</a>, and <a href="https://github.com/tokio-rs/console/issues/161">#161</a>). First, we will be adding more
instrumentation, both in Tokio and other ecosystem libraries. This will help you
get even more insight into your applications. We also want to improve the
warning system: adding more warnings, and adding searchable, online
documentation describing various warnings and how they can be solved (<a href="https://github.com/tokio-rs/console/issues/181">#181</a>,
<a href="https://github.com/tokio-rs/console/issues/148">#148</a>). Furthermore, there is a lot more we can do with the data the console
collects now: we would love to add new visualizations, like a tree of tasks and
their parents (<a href="https://github.com/tokio-rs/console/issues/155">#155</a>) or a timeline of the program&#39;s execution (<a href="https://github.com/tokio-rs/console/issues/129">#129</a>).</p><p>To do all this, however, we need you to start using Tokio Console and provide
feedback. In particular, we want to gather as much information as possible about
the problems people are using the console to debug, and what tools we can
provide to help. We would also love to get you involved in helping us build the
future of runtime diagnostics for Rust, so be sure to say hi in the <code>#console</code>
channel on <a href="https://discord.gg/tokio">Discord</a> and always feel free to jump in
on <a href="https://github.com/tokio-rs/console">issues</a> and send pull requests our way!</p><ul><li>Sean McArthur</li><li>Zahari Dichev</li><li>@gnieto</li><li>Felix S Klock II</li><li>Gus Wynn</li><li>Oğuz Bilgener </li><li>@memoryruins</li><li>Luna Razzaghipour </li><li>@daladim</li><li>@hatoo</li><li>Adam Gleave</li><li>Jacob Rothstein </li><li>David Barsky</li><li>@Milo123459</li><li>Wu Aoxiang </li><li>Yusuf Bera Ertan</li><li>@battlmonstr</li><li>Artem Vorotnikov</li></ul><p>Also, a very special thank-you to Matthias Prechtl (<a href="https://github.com/matprec">@matprec</a>), whose <a href="https://github.com/tokio-rs/console-gsoc">2019
Google Summer of Code project</a> to implement an initial console prototype paved
the way for the current Tokio Console release!</p><p><code>tokio-console</code> is built upon a foundation laid by the <a href="https://tokio.rs/blog/2019-08-tracing">Tracing</a> and <a href="https://tokio.rs/blog/2021-07-tonic-0-5">Tonic</a>
libraries.</p><p>We are indebted to everyone who has contributed to this project, and to all our
early users who have been trying it out in your applications and giving us
invaluable feedback!</p><p>If you want to help us make <code>tokio-console</code> even better, take a look at our
<a href="https://github.com/tokio-rs/console">github repository</a>, or come talk to us at
the <code>#console</code> channel on Tokio&#39;s <a href="https://discord.gg/4A5K8WD4">Discord</a>!</p><p>— Eliza Weisman (<a href="https://github.com/hawkw">@hawkw</a>)</p></div></div></section></div></div>
  </body>
</html>
