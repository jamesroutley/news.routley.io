<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mega-awry.io/">Original</a>
    <h1>MEGA: Malleable Encryption Goes Awry</h1>
    
    <div id="readability-page-1" class="page">
    <nav id="mainNav">
    
    <!-- /.container-fluid -->
</nav>

    <header>
    
</header>

    
<section id="background">
    <div>
        <div>
            <div>
                <h2>Background</h2>
                <hr/>
                <p><a href="https://mega.io/">MEGA</a> is a cloud storage and collaboration platform founded in 2013 offering <q>secure storage and communication</q> services.
With over 250 million registered users, 10 million daily active users and 1000 PB of stored data, MEGA is a significant player in the consumer domain.
What sets them apart from their competitors such as DropBox, Google Drive, iCloud and Microsoft OneDrive is the claimed security guarantees:
MEGA advertise themselves as <q>the privacy company</q> and promise <strong>U</strong>ser-<strong>C</strong>ontrolled end-to-end <strong>E</strong>ncryption (UCE).</p>

<p>We challenge these security claims and show that an adversarial service provider, or anyone controlling MEGA’s core infrastructure, can break the confidentiality and integrity of user data.</p>

<h3 id="key-hierarchy">Key Hierarchy</h3>

<p>At the root of a MEGA client’s key hierarchy, illustrated in <a href="#key-hierarchy">the figure below</a>, is the password chosen by the user.
From this password, the MEGA client derives an authentication key and an encryption key.
The authentication key is used to identify users to MEGA.
The encryption key encrypts a randomly generated master key, which in turn encrypts other key material of the user.</p>

<p>For every account, this key material includes a set of asymmetric keys consisting of an RSA key pair (for sharing data with other users), a Curve25519 key pair (for exchanging chat keys for MEGA’s chat functionality), and a Ed25519 key pair (for signing the other keys).
Furthermore, for every file or folder uploaded by the user, a new symmetric encryption key called a <em>node key</em> is generated.
The private asymmetric keys and the node keys are encrypted by the client with the master key using AES-ECB and stored on MEGA’s servers to support access from multiple devices.
A user on a new device can enter their password, authenticate to MEGA, fetch the encrypted key material, and decrypt it with the encryption key derived from the password.</p>

<picture>
    <source media="(max-width: 1000px)" srcset="img/key_hierarchy_portrait.svg"/>
    <img id="key-hierarchy" alt="MEGA&#39;s key hierarchy" src="https://blog.zulip.com/2022/06/21/zulip-server-5-3-security-release/img/key_hierarchy.svg"/>
</picture>

            </div>
        </div>
    </div>
</section>

    <section id="attacks">
    
    <div>
        <div>
            
            
            <div>
                <div>
                    <a href="#rsa-key-recovery">
                        <i></i>
                        <h3>RSA Key Recovery Attack</h3>
                    </a>
                    <p>MEGA can recover a user&#39;s RSA private key by maliciously tampering with 512 login attempts.</p>
                </div>
            </div>
            
            <div>
                <div>
                    <a href="#pt-recovery">
                        <i></i>
                        <h3>Plaintext Recovery</h3>
                    </a>
                    <p>MEGA can decrypt other key material, such as node keys, and use them to decrypt all user communication and files.</p>
                </div>
            </div>
            
            <div>
                <div>
                    <a href="#framing-attack">
                        <i></i>
                        <h3>Framing Attack</h3>
                    </a>
                    <p>MEGA can insert arbitrary files into the user&#39;s file storage which are indistinguishable from genuinely uploaded ones.</p>
                </div>
            </div>
            
        </div>
        <div>
            
            
            <div>
                <div>
                    <a href="#integrity-attack">
                        <i data-wow-delay=".3s"></i>
                        <h3>Integrity Attack</h3>
                    </a>
                    <p>The impact of this attack is the same as that of the framing attack, trading off less stealthiness for easier pre-requisites.</p>
                </div>
            </div>
            
            
            
        </div>
    </div>
</section>




<section id="rsa-key-recovery">
    <div>
        <div>
            <div>
                <h3>RSA Key Recovery Attack</h3>
                <p>MEGA uses RSA encryption for sharing node keys between users, to exchange a session ID with the user at login and in a legacy key transfer for the MEGA chat.
Each user has a public RSA key \(pk_{share}\) used by other users or MEGA to encrypt data for the owner, and a private key \(sk_{share}\) used by the user themselves to decrypt data shared with them.
The private RSA key is stored for the user in encrypted form on MEGA’s servers.
Key recovery means that an attacker successfully gets possession of the private key of a user, allowing them to decrypt ciphertexts intended for the user.</p>

<p>We discovered a practical attack to recover a user’s RSA private key by exploiting the lack of integrity protection of the encrypted keys stored for users on MEGA’s servers.
An entity controlling MEGA’s core infrastructure can tamper with the encrypted RSA private key and deceive the client into leaking information about one of the prime factors of the RSA modulus during the session ID exchange.
More specifically, the session ID that the client decrypts with the mauled private key and sends to the server will reveal whether the prime is smaller or greater than an adversarially chosen value.
This information enables a binary search for the prime factor, with one comparison per client login attempt, allowing the adversary to recover the private RSA key after 1023 client logins.
Using lattice cryptanalysis, the number of login attempts required for the attack can be reduced to 512.</p>

<h3 id="proof-of-concept-attack">Proof of Concept Attack</h3>

<p>Since the server code is not published, we cannot implement a Proof-of-Concept (PoC) in which the adversary actually controls MEGA.
Instead, we implemented a MitM attack by installing a bogus TLS root certificate on the victim.
This setup allows the attacker to impersonate MEGA towards the user while using the real servers to execute the server code (which is unknown to us).
Server responses can be patched on the fly since they do not rely on secrets stored by the server, allowing the attack to be performed in real time as the victim interacts with MEGA.</p>

<p>The following video shows how our attack recovers the first byte of the RSA private key.
Afterward, we abort the attack to avoid any adverse impact on MEGA’s production servers.
For each recovered bit, the attack consists of the following steps:</p>
<ol>
  <li>The victim logs in.</li>
  <li>The adversary hijacks the login and replaces the correct session ID with their probe for the next secret bit.</li>
  <li>Based on the client’s response, the adversary updates its interval for the binary search of the RSA prime factor.</li>
  <li>The login fails for the victim. This is only a limitation of the MitM setup, since the correct SID is lost. An adversarial cloud storage provider can simply accept the returned SID.</li>
</ol>

<p>Note that after aborting the attack, the search interval is <code>[0xe03ff...f, 0xe07ff...f]</code>.
The secret prime factor \(q\) of the RSA modulus starts with <code>0xe06...</code>.
This value is within the search interval and the adversary already recovered the first byte <code>0xe0</code>.
Using all of \(q\), the adversary can recover the RSA private key \((d, N)\) using the public key \((e, N)\) as \(p = N / q\) and \(d = e^{-1} \mod (p-1)(q-1)\).</p>

<p>
    <video controls="" muted="">
        <source src="videos/rsa_key_recovery_poc.mp4" type="video/mp4"/>
        Unsupported video tag, please try another browser to view the PoC video.
    </video>
</p>

            </div>
        </div>
    </div>
</section>


<section id="pt-recovery">
    <div>
        <div>
            <div>
                <h3>Plaintext Recovery</h3>
                <p>As shown in the <a href="#key-hierarchy">key hierarchy</a> MEGA clients encrypt the private keys for sharing, chat key transfer, and signing with the master key using AES-ECB.
Furthermore, file and folder keys also use the same encryption.
A plaintext recovery attack lets the adversary compute the plaintext from a given ciphertext.
In this specific attack, MEGA can decrypt AES-ECB ciphertexts created with a user’s master key.
This gives the attacker access to the aforementioned and highly sensitive key material encrypted in this way.
With the sharing, chat, signing, and node keys of a user, the adversary can decrypt the victim’s data or impersonate them.</p>

<p>This attack exploits the lack of key separation for the master key and knowledge of the recovered RSA private key (e.g., from the <a href="#rsa-key-recovery">RSA key recovery attack</a>).
The decryption oracle again arises during authentication, when the encrypted RSA private key and the session ID (SID), encrypted with the RSA public key, is sent from MEGA’s servers to the user.
MEGA can overwrite part of the RSA private key ciphertext in the SID exchange with two target ciphertext blocks.
It then uses the SID returned by the client to recover the plaintext for the two target blocks.
Since all key material is protected with AES-ECB under the master key, an attacker exploiting this vulnerability can decrypt node keys, the victim’s Ed25519 signature key, its Curve25519 chat key, and, thus, also all exchanged chat keys.
Given that the private RSA key has been recovered, one client login suffices to recover 32 bytes of encrypted key material, corresponding, for instance, to one full node key.</p>

            </div>
        </div>
    </div>
</section>


<section id="framing-attack">
    <div>
        <div>
            <div>
                <h3>Framing Attack</h3>
                <p>This attack allows MEGA to forge data in the name of the victim and place it in the target’s cloud storage.
While the previous attacks already allow an adversary to modify existing files using the compromised keys, this attack allows the adversary to preserve existing files or add more documents than the user currently stores.
For instance, a conceivable attack might frame someone as a whistle-blower and place an extensive collection of internal documents in the victim’s cloud storage.
Such an attack might gain credibility when it preserves the user’s original cloud content.</p>

<p>To create a new file key, the attacker makes use of the particular format that MEGA uses for node keys.
Before they are encrypted, node keys are encoded into a so called <q>obfuscated key</q> object, which consists of a reversible combination of the node key and information used for decryption of the file or folder.
(Specifically, a nonce and a truncated MAC tag.)
Since none of our attacks allow an attacker to encrypt values of their choosing with AES-ECB under the master key, the attacker works in the reverse direction to create a new valid obfuscated key object.
That is, it first obtains an obfuscated key by decrypting a randomly sampled key ciphertext using the <a href="#pt-recovery">plaintext recovery attack</a>.
Note that this ciphertext can really be randomly sampled from the set of all bit strings of the length of one encrypted obfuscated key object.
Decryption will always succeed, since the AES-ECB encryption mode used to encrypt key material does not provide any means of checking the integrity of a ciphertext.
The resulting string is not under the control of the adversary and will be random-looking, but can regardless be used as a valid obfuscated key object since both file keys and the integrity information (nonces and MAC tags) can be arbitrary strings.
Hence, the adversary parses the decrypted string into a file key, a nonce and MAC tag.
It then modifies the target file which is to be inserted into the victim’s cloud such that it passes the integrity check when the file key and integrity information from the obfuscated key is used.
The attacker achieves this by inserting a single AES block in the file at a chosen location.
Finally, the adversary uses the known file key to encrypt the file and uploads the result to the victim’s cloud.</p>

<p><img src="https://blog.zulip.com/2022/06/21/zulip-server-5-3-security-release/img/forged_img.png" alt="Forged image" id="forged-img"/></p>

<p>Many standard file formats such as PNG and PDF tolerate 128 injected bits (for instance, in the file’s metadata, as trailing data, or in unused structural components) without affecting the displayed content.
The image above shows the file our proof of concept inserts in the victim account.
Our attack added the highlighted bytes to satisfy the integrity check.
Due to the structure of PNG files, these bytes do not change the displayed pixels, i.e., it is visually identical to the unmodified image.</p>



<h3 id="proof-of-concept-attack">Proof-of-Concept Attack</h3>

<p>The PoC shows our framing attack in the MitM setting described in the <a href="#rsa-key-recovery">RSA private key recovery attack</a>.</p>

<p>The video shows the following steps:</p>
<ol>
  <li>The victim logs into their account without any attack running. There are only three files in the cloud storage and none of them is called <code>hacker-cat.png</code>.</li>
  <li>The victim logs out and the adversary runs the <a href="#pt-recovery">plaintext recovery attack</a> once. This involves the following steps:
    <ul>
      <li>The adversary hijacks the victim’s login attempt and replaces the encrypted SID with the encrypted key that it picked for the file forgery.</li>
      <li>The victim’s client responds with the decrypted SID, from which the adversary can recover the plaintext for the injected ciphertext blocks.</li>
      <li>The log in attempt fails, which is only a limitation of the MitM setting. A malicious cloud provider can perform this attack without the user noticing.</li>
    </ul>
  </li>
  <li>The adversary uses the key recovered in the previous step to forge an encrypted file.</li>
  <li>The victim logs in again.</li>
  <li>The adversary injects the forged file into the loaded file tree.</li>
  <li>The victim’s cloud now displays four files, including a new file called <code>hacker-cat.png</code>.</li>
  <li>When the user views this file in the browser, it correctly decrypts and shows the image.</li>
</ol>

<p>
    <video controls="" muted="">
        <source src="videos/framing_attack_poc.mp4" type="video/mp4"/>
        Unsupported video tag, please try another browser to view the PoC video.
    </video>
</p>

            </div>
        </div>
    </div>
</section>


<section id="integrity-attack">
    <div>
        <div>
            <div>
                <h3>Integrity Attack</h3>
                <p>This attack exploits the peculiar structure of MEGA’s obfuscated key objects to manipulate an encrypted node key such that the decrypted key consists of all zero bytes.
Since the attacker now knows the key, this key manipulation can be used to forge a file in a manner similar to the <a href="#framing-attack">framing attack</a>.
Unlike for the framing attack (which requires the ability to decrypt arbitrary AES-ECB ciphertexts), for this attack the adversary only needs access to a single plaintext block and the corresponding ciphertext encrypted with AES-ECB under the master key.
For instance, the attacker can use MEGA’s protocol for public file sharing to obtain the pair: when a user shares a file or folder publicly, they create a link containing the obfuscated key in plaintext.
Hence, a malicious cloud provider who obtains such a link knows both the plaintext and the corresponding ciphertext for the node key, since the latter is uploaded to MEGA when the file was created (before being shared).
This can then be used as the starting point for the key manipulation and allows a forged file ciphertext to be uploaded into the victim’s cloud, just as for the framing attack.
However, this attack is less surreptitious than the framing attack because of the low probability of the all-zero key appearing in an honest execution, meaning that an observant user who inspects the file keys stored in their account could notice that the attack has been performed.</p>

            </div>
        </div>
    </div>
</section>


<section id="gap-bleichenbacher">
    <div>
        <div>
            <div>
                <h3>GaP-Bleichenbacher Attack</h3>
                <p>This attack is a novel variant of <a href="https://doi.org/10.1007/BFb0055716">Bleichenbacher’s attack on PKCS#1 v1.5 padding</a>.
We call it a <em>Guess-and-Purge</em> (GaP) Bleichenbacher attack.
MEGA can use this attack to decrypt RSA ciphertexts by exploiting a padding oracle in the fallback chat key exchange of MEGA’s chat functionality.
The vulnerable RSA encryption is used for sharing node keys between users, to exchange a session ID with the user at login and in a legacy key transfer for the MEGA chat.
As shown in the <a href="#key-hierarchy">key hierarchy</a>, each user has a public RSA key used by other users or MEGA to encrypt data for the owner, and a private key used by the user themselves to decrypt data shared with them.
With this attack, MEGA can decrypt these RSA ciphertexts, albeit requiring an impractical number of login attempts.</p>

<p><strong>Attack idea:</strong></p>

<p>MEGA uses a custom padding scheme which is less rigid than PKCS#1 v1.5.
This makes it challenging to apply Bleichenbacher’s attack, because a successful unpadding no longer corresponds to a single solution interval.
Instead many disjoint intervals are possible, depending on the value of an unknown prefix in MEGA’s padding scheme.
Our attack devices a new Guess-and-Purge strategy that <em>guesses</em> the unknown prefix and quickly <em>purges</em> wrong guesses.
This enables us to perform a search for the decryption of a ciphertext in \(2^{16.9}\) client login attempts on average.</p>

<p>Although this attack is weaker than the <a href="#rsa-key-recovery">RSA key recovery attack</a> (in the sense that a key recovery implies plaintext recovery), it is complementary in the vulnerabilities that it exploits and requires different attacker capabilities.
It attacks the legacy chat key decryption of RSA encryption instead of the session ID exchange and can be performed by a slightly weaker adversary since no key-overwriting is necessary.</p>

<p>The details of the GaP-Bleichenbacher attack are intricate.
For a full description, see Appendix B of <a href="#paper">the paper</a>.</p>

            </div>
        </div>
    </div>
</section>


    
<section id="mitigation">
    <div>
        <div>
            <div>
                <h2>Mitigation</h2>
                <hr/>
                <h3 id="disclosure">Responsible Disclosure</h3>

<p>We contacted MEGA to inform them of the vulnerabilities in their system and to suggest three different levels of mitigation (immediate, minimal, and recommended) on March 24, 2022.
MEGA acknowledged the attacks, confirmed that the system is vulnerable and needs patching, and awarded us a bug bounty.
We agreed to a 90-day disclosure window.</p>

<h3 id="our-mitigation">Our Proposed Countermeasures</h3>

<p>The scale of MEGA poses many practical challenges for both MEGA and customers, such as the load and traffic implications of re-encrypting over 1000 petabytes of user data.
Furthermore, backwards compatibility is a significant issue as disruptive changes render some customer data inaccessible, while legacy code is a security risk.</p>

<p>Due to these significant practical challenges, we organize our proposed mitigations in three levels:</p>
<ol>
  <li><a href="#imm-countermeasures">Immediate countermeasures</a>: Backwards compatible and non-invasive mitigations which complicate the attacks sufficiently to temporarily protect users from the most severe security breaches.</li>
  <li><a href="#min-countermeasures">Minimal countermeasures</a>: More substantial changes that better address the attacks while avoiding the most expensive modifications (such as file re-encryption).</li>
  <li><a href="#general-recs">General recommendations</a>: Long-term goals for redesigning the cryptographic architecture to address the root causes of the attacks and adhere to best practices.</li>
</ol>

<p>A visual overview of how the proposed mitigation steps change the key hierarchy is <a href="https://blog.zulip.com/2022/06/21/zulip-server-5-3-security-release/img/mitigation_key_hierarchy.png" target="_blank">here</a>.</p>

<h4 id="imm-countermeasures">Immediate Countermeasures</h4>

<ul>
  <li><em>Key separation for the master key:</em> following the key separation principle, we propose to introduce a derivation key and derive different keys to protect the RSA Sharing, Chat, Sign, and Node Keys, instead of using a single master key to encrypt them all.</li>
  <li><em>Ad hoc integrity protection:</em> we propose to use HMAC on top of the existing ciphertexts to protect the integrity of key ciphertexts.</li>
  <li><em>Fixing the RSA padding prefix:</em> we propose to enforce stricter client-side checks of MEGA’s RSA padding scheme to increase the number of queries needed for the <a href="#gap-bleichenbacher">GaP-Bleichenbacher attack</a> and further reduce the practicality of the attack.</li>
</ul>

<p>These measures protect against our first four attacks.
However, they should only be considered as temporary measures that can be deployed quickly.
They do not address the root flaws in the cryptographic design.</p>

<h4 id="min-countermeasures">Minimal Countermeasures</h4>

<ul>
  <li><em>AES-GCM for key ciphertexts:</em> instead of the ad hoc integrity protection proposed as part of the immediate countermeasures, we suggest replacing AES-ECB with an authenticated encryption scheme, namely AES-GCM.</li>
  <li><em>RSA-OAEP for sharing:</em> we recommend replacing MEGA’s padding scheme by a standardized padding mechanism for RSA encryption. Additionally, we suggest using different RSA key pairs for sharing node keys and for the legacy chat key transfer to improve key separation.</li>
</ul>

<p>These measures address our attacks more adequately at the cost of losing backwards compatibility.</p>

<h4 id="general-recs">General Recommendations</h4>

<ul>
  <li><em>File encryption:</em> we propose a thorough redesign of MEGA’s system. This includes protecting node keys with AES-GCM and using separate keys for file encryption and for protecting their attributes. Furthermore, we propose to replace MEGA’s custom variant of AES-CCM for file encryption with the well-analyzed AES-GCM.</li>
  <li><em>Augmented PAKE for authentication:</em> we recommend the usage of <a href="https://eprint.iacr.org/2018/163.pdf">OPAQUE</a> to avoid targeted dictionary attacks on user passwords by MEGA.</li>
</ul>

<p>The proposed measures in this section require users to re-encrypt their files because the key material is derived differently, and new primitives are used.
According to our estimates, this process would take more than half a year, even in the ideal setting where all customers are reachable and have the computational resources to re-encrypt up to hundreds of gigabytes of data.
While this needs to be planned carefully, the long-term goal should, in our opinion, be to replace insecure legacy code and temporary patches.
The immediate and minimal countermeasures are only temporary suggestions and are not unlikely vulnerable to more attacks themselves due to the extensive key reuse and non-standard combination of primitives.</p>

<h3 id="mega-mitigation">MEGA’s Patch</h3>

<p>MEGA decided to introduce additional client-side checks on the format of RSA private keys to protect against our first attack.
They are explained in more detail in <a href="https://blog.mega.io/mega-security-update/" target="_blank">MEGA’s blog post</a>.
While these checks directly prevent the RSA key recovery attack, and hence by extension the attacks that depend on it, this fix significantly differs from our proposed countermeasures.</p>


            </div>
        </div>
    </div>
</section>

    

    


    <section id="questions">
    
    <div>
        <div>
            <div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#aes-enough">
                            MEGA uses AES for End-to-End Encryption (E2EE), why isn&#39;t that enough?
                        </h4>
                    </p>
                    <div id="aes-enough">
                        <div>
                            <p>Unfortunately, the use of secure primitives alone does not guarantee security.
The overall system design is crucial.
For instance, this includes key derivation and management, the support of advanced features (like file-sharing or a chat), and how the primitives are used and combined.</p>

<p>Our attacks exploit unintended interactions between ciphertexts resulting from key reuse.
Furthermore, MEGA uses the ECB mode of AES for some encryptions, which does not protect the integrity of ciphertexts.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#apply-to-others">
                            Can your attacks be applied to other services?
                        </h4>
                    </p>
                    <div id="apply-to-others">
                        <div>
                            <p>The attacks rely on details of the architecture and implementation of MEGA.
Therefore, they cannot be directly applied to other services.</p>

<p>Nevertheless, some of our observations are generalizable.
For instance, the <a href="#rsa-key-recovery">RSA key recovery attack</a> shows that the missing integrity protection of ciphertexts does not only fail to provide IND-CCA security but can also lead to powerful attacks in practice.
Other services with malleable key ciphertexts might be vulnerable to similar attacks.</p>

<p>Moreover, the <a href="#gap-bleichenbacher">GaP-Bleichenbacher attack</a> is a new variant of Bleichenbacher’s attack on PKCS#1 v1.5 that makes the attack applicable to other custom implementations of the RSA padding.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#change-pw">
                            Does changing my password ensure I am safe?
                        </h4>
                    </p>
                    <div id="change-pw">
                        <p>Not entirely.
Changing the password will derive new authentication and encryption keys for your account.
However, your master key will not be updated, only re-encrypted with the new password.
Furthermore, existing asymmetric keys, including the RSA private key that could have been recovered using our <a href="#rsa-key-recovery">first attack</a>, as well as the symmetric file and folder keys are not changed.
We are not aware of any functionality to re-new these keys using MEGA’s standard clients.</p>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#detect-compromise">
                            Can I detect whether any of your attacks was exploited on my account?
                        </h4>
                    </p>
                    <div id="detect-compromise">
                        <div>
                            <p>No, almost all of our attacks do not leave persistent traces.
Only the integrity attack may result in files with an unusual structure.
However, this is not a guaranteed indicator of compromise and could be further hidden.</p>

<p>Nevertheless, on the clients that we analyzed, all attacks would have required a substantial number of manual login attempts (i.e., the user entering the password).
Since clients usually cache the credentials, users often stay logged in, minimizing the number of logins performed and thereby increasing the difficulty of the attacks.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#further-vulns">
                            Could there be further vulnerabilities?
                        </h4>
                    </p>
                    <div id="further-vulns">
                        <div>
                            <p>Yes, with a system as large and complex as MEGA’s, there is always a possibility for vulnerabilities.
Furthermore, our analysis showed that MEGA uses non-standardized cryptographic primitives in unusual ways in several places in their system.
Some of these might be vulnerable to attacks, although we did not exploit them in the attacks presented here.</p>

<p>In the <a href="#mitigation">mitigation section</a> we outline the changes to MEGA’s cryptographic architecture that we consider advisable.
Our recommendations include a transition to well-analyzed and standardized algorithms and would ensure that MEGA follows current best practices.
Implementing these changes would give confidence that no further vulnerabilities are possible that, e.g., exploit interactions between primitives due to key reuse.</p>

<p>However, some of the proposed changes would be very expensive to perform in practice.
Please refer to the <a href="#mega-mitigation">section on MEGA’s patch</a> for information on the changes implemented by them.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#impact">
                            What is the impact of your attacks?
                        </h4>
                    </p>
                    <div id="impact">
                        <div>
                            <p>MEGA or any entity controlling the core infrastructure of MEGA can achieve the following with our attacks:</p>
<ul>
  <li>Decrypt all files and folders owned by or shared with the victim.</li>
  <li>Decrypt all chat messages exchanged with the victim.</li>
  <li>Forge files that are indistinguishable from genuinely uploaded ones and place them in the victim’s cloud storage.</li>
</ul>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#int-framing-difference">
                            Both the framing and integrity attack forge files — what&#39;s the difference between them?
                        </h4>
                    </p>
                    <div id="int-framing-difference">
                        <div>
                            <p>They differ in the assumed attacker capabilities and the stealthiness of the created files.</p>

<p>Framing attack:</p>
<ul>
  <li><em>Capabilities:</em> the adversary needs access to an AES decryption oracle, i.e., it needs to be able to decrypt arbitrary ciphertexts encrypted with AES-ECB under the master key. (The <a href="#pt-recovery">plaintext recovery attack</a>, provides exactly this.)</li>
  <li><em>Stealthiness:</em> the resulting file encryption uses a uniformly random key just like genuinely uploaded files.</li>
</ul>

<p>Integrity attack:</p>
<ul>
  <li><em>Capabilities:</em> the adversary only needs to know a single ciphertext-plaintext pair for AES-ECB under the master key. This is easier to achieve than a decryption oracle.</li>
  <li><em>Stealthiness:</em> the encrypted file uses a key of all zero bytes, which is very unlikely to happen for genuinely uploaded files. However, the user needs some technical expertise to extract the decrypted file key from their MEGA client in order to detect the attack.</li>
</ul>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#mega-patches">
                            Do MEGA&#39;s patches protect me?
                        </h4>
                    </p>
                    <div id="mega-patches">
                        <div>
                            <p>The <a href="#mitigation">mitigation section</a> discusses countermeasures in more detail.</p>

<p>MEGA decided to address our attacks with different measures than those that we proposed.
Their patch is less invasive than our recommendations, but in turn maintains the non-standard use of cryptographic primitives.
It suffices to protect against the <a href="#rsa-key-recovery">RSA key recovery</a> and <a href="#pt-recovery">plaintext recovery</a> attacks.
Hence, it also protects against the chain of attacks up to the <a href="#framing-attack">framing attack</a> that we present here.
(That is, it removes the access to the AES-ECB decryption oracle needed for the framing attack, which we instantiated with the <a href="#pt-recovery">plaintext recovery attack</a>.)</p>

<p>However, their patch does not directly protect against the framing attack, nor the integrity attack.
If the prerequisites can be fulfilled in a different way (see e.g. the discussion on publicly shared files and folders in the <a href="#integrity-attack">integrity attack</a> section), these attacks could still be mounted.
Furthermore, the patch introduced by MEGA does not protect against the <a href="#gap-bleichenbacher">GaP-Bleichenbacher attack</a>, although the latter is arguably too inefficient to be practically exploitable.</p>

<p>We did not analyze whether MEGA’s patches can be bypassed or if they introduce new vulnerabilities.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#are-there-pocs">
                            Are there Proof-of-Concept implementations of your attacks?
                        </h4>
                    </p>
                    
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#practicality">
                            Are your attacks practical?
                        </h4>
                    </p>
                    <div id="practicality">
                        <div>
                            <p>Yes, sufficiently motivated attackers could perform the <a href="#rsa-key-recovery">RSA key recovery attack</a>.</p>

<p>The bottleneck of the attack is the required 512 user login attempts.
If users frequently log out of their account, the attack could recover their RSA private key within a few months.</p>

<p>However, users stay logged in by default on the MEGA clients that we examined.
Nevertheless, as the attacker in our threat model controls the core infrastructure of MEGA, they could make the attack much more practical with an inconspicuous code update.
Currently, MEGA clients cache the old session ID and user’s secret key material by default.
Therefore, a new SID is only exchanged when users manually terminate their session and re-enter their password.
An adversary could push an update to MEGA’s clients such that they transparently re-negotiate a new session ID (SID) on every new access.
Afterwards, the adversary can perform the 512 queries within hours or days without the user noticing.</p>

<p>The adversary can use a recovered RSA key to perform the <a href="#pt-recovery">plaintext recovery</a>, <a href="#framing-attack">framing</a>, and <a href="#integrity-attack">integrity</a> attacks.</p>

<p>The <a href="#integrity-attack">integrity attack</a> can additionally be performed without the RSA key if the attacker knows a single AES-ECB plaintext-ciphertext pair under the master key.
Such a pair can for example be obtained by MEGA from a link to a publicly shared user file or folder.</p>

<p>Finally, the <a href="#gap-bleichenbacher">GaP-Bleichenbacher attack</a> is of a more theoretical nature since \(2^{16.9}\) interactions with the client are very expensive.
However, attacks only improve over time, and this attack shows a fundamental flaw in the use of RSA encryption.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#threat-model">
                            Isn&#39;t this threat model assuming too strong an adversary?
                        </h4>
                    </p>
                    <div id="threat-model">
                        <div>
                            <p>We think the threat model is consistent with the security claims made by MEGA.
For instance, the following quote from their website showcases that MEGA advertise confidentiality of user data even against themselves:</p>
<blockquote>
  <p>MEGA does not have access to your password or your data. Using a strong and unique password will ensure that your data is protected from being hacked and gives you total confidence that your information will remain just that – yours.</p>
</blockquote>

<p>Moreover, we must consider the possibility that even if MEGA is not adversarial, their systems may have been compromised by malicious third parties, for example nation state security agencies or hacking groups, who wish to gain access to users’ data and files.
Indeed, the sheer size of MEGA – and the likelihood of it attracting users who wish to protect highly sensitive data precisely because of the security the service claims to offer – surely make MEGA an attractive target.</p>

                        </div>
                    </div>
                </div>
                
                <div>
                    <p>
                        <h4 data-toggle="collapse" data-target="#whos-affected">
                            Who is affected by these vulnerabilities?
                        </h4>
                    </p>
                    <div id="whos-affected">
                        <div>
                            <p>We looked at the official MEGA Web Client v. 4.11.2 and the MEGA SDK v. 3.9.15.</p>

<p>However, the vulnerabilities are fundamental issues in the cryptographic design.
Clients have only limited implementation flexibility because they need to remain compatible with the server code of MEGA.
Thus, we expect them to be present in all current clients, as well as older versions.</p>

                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div> 
</section>

    <section id="contact">
    
</section>

    <!-- jQuery -->


<!-- Bootstrap Core JavaScript -->


<!-- Plugin JavaScript -->




<!-- Custom Theme JavaScript -->








</div>
  </body>
</html>
