<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://george.mand.is/2024/03/leap-years-lost-days-and-coding-calendars-a-javascript-adventure/">Original</a>
    <h1>Leap Years, Lost Days, and Coding Calendars: A JavaScript Adventure</h1>
    
    <div id="readability-page-1" class="page"><div><article><section><header><p><time datetime="2024-03-03">March 3rd, 2024</time> • ~900 words • 4 minute read</p></header><p>Dates are hard and JavaScript is odd. Two universal truths.</p><p>In belated honor of 2024 being a leap year, here&#39;s a story about how I learned 2011 was not a leap year, ISO 8601, proleptic Gregorian calendars and forking Node.</p><p>To belatedly commemorate the leap year of 2024, here is a story about how I discovered of 2011 wasn&#39;t a leap year, dove into the intricacies of ISO 8601, the concept of proleptic Gregorian calendars, and decided to fork Node on a whim.</p><ul><li><a href="#understanding-the-proleptic-gregorian-calendar">Understanding the Proleptic Gregorian Calendar</a></li><li><a href="#quirks-of-javascript-date-handling">Quirks of JavaScript Date Handling</a></li><li><a href="#11ty-and-leap-years">11ty and leap years</a></li><li><a href="#apple-nscalendar-and-sticklers-for-reality">Apple, NSCalendar and sticklers for reality</a></li><li><a href="#lets-fork-node">Let&#39;s fork Node!</a></li></ul><hr/><h2>Understanding the Proleptic Gregorian Calendar</h2><p>JavaScript implements (best as I can tell) the <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> standard to avoid ambiguous date/time expressions. This includes an adherence to something called the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>.</p><p>The <a href="https://en.wikipedia.org/wiki/Gregorian_calendar">Gregorian calendar</a> is more or less the calendar system we all use today and was established on Friday, October 15th, 1582. The curious thing about this is that it came immediately after Thursday, October 4th. They had to do this to synchronize with the switch from the Julian calendar. As are a result, those ten days never happened.</p><p>The proleptic Gregorian calendar attempts to make this less confusing by basically pretending the Gregorian calendar has <em>always</em> been in use. In this world, when looking back at dates that happened prior to the switch, a date like October 7th, 1582 can exist. This is a modern convention to help with historical consistency.</p><p>JavaScript is happy help here:</p><pre><code>new Date(&#34;October 11 1582&#34;)
// 1582-10-11T04:56:02.000Z
</code></pre><h2>Quirks of JavaScript Date Handling</h2><p>However, JavaScript has some quirks. It <em>does</em> care about <em>some</em> days that make no sense and could never happen:</p><pre><code>new Date(&#34;October 33 1979&#34;)
// Invalid Date
</code></pre><p>But it doesn&#39;t care about <em>all</em> the days that could never happen:</p><pre><code>new Date(&#34;February 31 2024&#34;)
// 2024-03-02T05:00:00.000Z
</code></pre><p>It doesn&#39;t throw an <code>Invalid Date</code> even thought February 31 could never possibly exist. It&#39;s actually returning March 2nd, 2024 in this example!</p><p>If you dive in the source you can see it takes a (somewhat lazy) assumption by checking the days first and assuming 1 to 31 can always be valid. It then checks the month to see if it has that many days. Instead of throwing an error if it doesn&#39;t, it just substracts the max number of days from that month and uses the remainder to figure out which day it is in the <em>next</em> month.</p><h2>11ty and leap years</h2><p>Something funny happened when I <a href="https://george.mand.is/2023/10/obligatory-blog-refresh-post-a-twist-and-a-tiny-homage/">resurrected some old blog posts from 2011</a>. The tool I use to build this site (<a href="https://11ty.io">11ty</a>) started throwing errors. I assumed there was some weird piece of misformatted metadata in one of the posts, but what I found was a lot stranger.</p><p><img src="https://developer.chrome.com/media/revamp/leap-year-2011-oops-3.jpg" alt="Invalid Date appearing in the RSS feed"/></p><p>The offending post was written on February 29th, 2011. It turns out that day never existed—it&#39;s only a leap year if it is divisible by 4, except for end-of-century years which must be divisible by 400.</p><p><img src="https://developer.chrome.com/media/revamp/leap-year-2011-oops-2.jpg" alt="Me asking Google if 2011 was a leap year because I am too lazy to do math"/></p><p><img src="https://developer.chrome.com/media/revamp/leap-year-2011-oops-1.jpg" alt="Finally finding the culprit—a file from 2011 on a day that did not exist"/></p><p>While JavaScript itself doesn&#39;t care, some package in the 11ty stack trying to parse and understand dates must care. I&#39;m curious which one it is, though I never went looking.</p><p>In a nut-shell, because I&#39;d written this date down wrong over a decade ago, and because something in 11ty is a stickler for real dates, I had to change the date to fix my blog. The funny part is I had no way of knowing, 10+ years later, if I&#39;d actually written it on March 1st or February 28th.</p><h2>Apple, NSCalendar and sticklers for reality</h2><p>It bothers me (irrationally) that JavaScript would try to coerce February 31, 2024 into a real date but lazily stand-buy and be fine with October 7th, 1582. I am reminded once again that software—like all human constructs—really just boils down to a mishmash of people&#39;s opinions in the moment.</p><p>It makes sense to me that the company whose founder gave <a href="https://www.youtube.com/watch?v=zOlRWg_iyWY">so much thought about typography</a> in early computing would take the time to put thought into their standard calendar class to account for the Julian to Gregorian transition in a more nuanced and historically-accurate way.</p><ul><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DatesAndTimes/Articles/dtHist.html">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DatesAndTimes/Articles/dtHist.html</a></li></ul><p>In <code>NSCalendar</code>, similar to how JavaScript will move February 31st into the next month, any days that fall between October 4th and 15th in 1582 will automatically get moved forward 10 days.</p><p>One of the more fun macOS easter eggs live sin the Calendar app. If you go back to October 1582 you can see Thursday, October 4th immediately followed by Friday, October 15th.</p><p><img src="https://developer.chrome.com/media/october-1582-macos-calendar.jpg" alt="macOS Calendar app showing October 1582 and how the 10 days are missing"/></p><h2>Let&#39;s fork Node!</h2><p>I like the way NSCalendar handles this situation better. So I did what any sensible person would do: I dusted off my C++ brain and forked Node.</p><ul><li><a href="https://github.com/georgemandis/node">https://github.com/georgemandis/node</a></li></ul><p>I&#39;d never built Node from scratch, let alone fork an entire language just to make such a silly, opinionated tweak to a standard model. The documentation is clear though, and the project is soundly structured. After some hunting, pecking and reading I found the place to introduce my change:</p><ul><li>https://github.com/georgemandis/node/blob/0663467e521627523f3dae908bf9eafe02377beb/deps/v8/src/date/date.cc#L96</li></ul><p>Voila.</p><p><img src="https://developer.chrome.com/media/node-better-gregorian.jpg" alt="My forked version of Node with different opinions around date handling in 1582"/></p><p>If you&#39;ve found any of this nonsense helpful or intriguing—and particularly if you have your own silly explorations to share—please feel free to <a href="https://developer.chrome.com/contact">reach out</a>! I love a good goofy deep-dive into the inane.</p></section></article></div></div>
  </body>
</html>
