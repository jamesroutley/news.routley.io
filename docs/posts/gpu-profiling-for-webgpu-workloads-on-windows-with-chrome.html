<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frguthmann.github.io/posts/profiling_webgpu/">Original</a>
    <h1>GPU profiling for WebGPU workloads on Windows with Chrome</h1>
    
    <div id="readability-page-1" class="page"><div>
      



<p>If you’ve read the article already and/or want to jump straight to profiling, go to the <a href="#TL_DR">TL;DR</a> section.</p>



<p>WebGPU is not a native graphics API, as in no hardware vendor provides specific drivers for their GPUs targeting this API. Instead, WebGPU runtimes like web browsers must implement backends for WebGPU using modern native APIs such as DirectX12, Vulkan or Metal. Those APIs are widely used, in particular for video games, and hardware vendors have developed great profiling tools for them.</p>

<p>Sadly those GPU profilers don’t work out of the box with WebGPU workloads executed by Chrome. The main reason for this is that while Chrome does execute such workloads using the aformentioned graphics APIs, it doesn’t present the rendered content on screen using those APIs. There are good reasons for this and the technical details are not important here, the point is GPU profilers wouldn’t work and it made me sad.</p>

<p>The good news is I found a way to work around that limitation! It’s a terrible hack but in practice it works well. All you need to do is download a DLL I wrote and put it in the correct location to get both AMD’s Radeon GPU Profiler and Nvidia’s Nsight to work! See the details in the next section. Also, while this only works on Windows I have seen this <a href="https://gist.github.com/slimbuck/ec4500afaec6b2c5368c22a37153826d" target="_blank" rel="noopener noreferrer">gist</a> floating around for Apple, but I have nothing for Linux :/.</p>

<p>If you are interested in what was missing, how I fixed it and what this mysterious DLL is doing, please read the following companion blog post <a href="https://frguthmann.github.io/posts/shimming_d3d12/" target="_blank" rel="noopener noreferrer">Shimming d3d12.dll for fun and profit</a>. I would also like to thank <a href="https://mastodon.gamedev.place/@theWarhelm" target="_blank" rel="noopener noreferrer">Marco Castorina</a> and <a href="https://x.com/raydey" target="_blank" rel="noopener noreferrer">Ray Dey</a> without whom this hack probably wouldn’t exist :).</p>



<blockquote>
<p>⚠ <strong>Before anything else, please remember that this is a hacky solution and that you should not browse the open web with that DLL attached. It should only be used for a GPU profiling session and removed afterwards. It also conflicts with PIX, so you should remove it before attempting to take a capture. I would recommend adding that DLL to a specific flavor of Chrome ( Dev, Canary, etc. ) that you would only use for GPU profiling.</strong></p>
</blockquote>

<h2 id="getting-the-dll">Getting the DLL</h2>

<p>Go to the <a href="https://github.com/frguthmann/d3d12_webgpu_shim" target="_blank" rel="noopener noreferrer">following repository</a> and either download <code>d3d12.dll</code> from the release section or download the repository and build it yourself. Place the DLL in the Chrome folder where <code>chrome.exe</code> exists, for instance:
<code>C:\Program Files\Google\Chrome\Application</code></p>

<h2 id="chrome-command-line-arguments">Chrome command line arguments</h2>

<p>The way you should launch Chrome depends on the profiler you will be using. However, the command line arguments required are mostly the same as the ones used to capture a frame with PIX as described in
<a href="https://toji.dev/webgpu-profiling/pix.html#running-chrome-in-pix" target="_blank" rel="noopener noreferrer">Tojiro’s blog</a>.</p>

<p>For reference, here are the arguments I use:</p>

<ol>
<li><code>--disable-gpu-sandbox --disable-gpu-watchdog</code></li>
<li><code>--enable-dawn-features=emit_hlsl_debug_symbols,disable_symbol_renaming</code></li>
<li><code>--no-sandbox</code></li>
<li><code>--disable-direct-composition</code></li>
</ol>

<p>The first arguments are the minimum required to capture a frame. The second ones are convenience arguments that let you inspect shader source with the original variable names. The third one is required by Nvidia Nsight to function properly, I have no idea why. The last argument used to be required to capture Chrome with PIX so I keep it around just in case.</p>

<h2 id="enabling-debug-markers">Enabling debug markers</h2>

<p>To enable debug markers, we’ll again refer to <a href="https://toji.dev/webgpu-profiling/pix.html#enabling-debug-markers" target="_blank" rel="noopener noreferrer">Tojiro’s blog</a>. The gist of it is to copy <code>WinPixEventRuntime.dll</code> from <code>https://www.nuget.org/packages/WinPixEventRuntime</code> into <code>&lt;Chrome Dir&gt;\&lt;Version Number&gt;</code>.</p>

<p>Unfortunately, the Radeon tools don’t support PIX markers out of the box. No problem, I wrote a modified version of <code>WinPixEventRuntime.dll</code> that is supported by the Radeon tools. This DLL is hardware vendor agnostic and will only enhance the PIX markers on AMD hardware. The process to get it is exactly the same as getting the modified <code>d3d12.dll</code>. Simply go the <a href="https://github.com/frguthmann/PixEventsAMD" target="_blank" rel="noopener noreferrer">following repository</a> and either download <code>WinPixEventRuntime.dll</code> from the release section or clone the repository and build it yourself.</p>

<h2 id="capturing-a-frame-with-rdp">Capturing a frame with RDP</h2>

<p>To profile with AMD’s Radeong GPU Profiler, you need to download the Radeon Developer Tool Suite from <a href="https://gpuopen.com/introducing-radeon-developer-tool-suite/" target="_blank" rel="noopener noreferrer">GPUOpen</a>. Download the package and unzip it at any location you see fit, all the apps are portable.</p>

<p>Double-click on the Radeon Developer Panel’s exe to start it. If this is the first time you’re using it, you will likely need to select a feature you would like to use from the top left corner. In our case, we would like to profile the GPU so we will select <code>Profiling</code>.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/rdp_features.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/rdp_features.png" alt="An image showing the available features in RDP"/>

</a></p>

<p>Please note the green dot on left of the connection tab. If that dot is red, you might need to go to that tab and hit the connect button in the bottom right corner but normally it should connect automatically.</p>

<p>When the Radeon Developer Panel is open, connected and has the <code>Profiling</code> feature selected, any DirectX12, Vulkan, OpenCL or HIP application that you launch from now on will be automatically detected and attached to. This means we are now ready to launch Chrome.</p>

<p>Since RDP doesn’t need to launch the app for you, feel free to open your favorite terminal and to launch Chrome from there using the previously mentioned CLI arguments. The overall command line should look something like this:</p>

<p>Now open a WebGPU app in a tab and if everything is working properly you should see RDP’s <code>Profiling</code> tab change from <code>Status: Offline</code> to <code>Status: Ready</code>.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/rdp_ready.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/rdp_ready.png" alt="An image showing what the profiling tab of RDP should look like when connected."/>

</a></p>

<p>You can now hit the <code>Capture profile</code> button or use the configurable hot key <code>Ctrl+Alt+C</code> to capture your WebGPU app. The profile should appear on the right side of the app under <code>Recently collected profiles</code>.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/recently_collected_profiles.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/recently_collected_profiles.png" alt="An image showing the recently collected profile table in RDP"/>

</a></p>

<p>Simply double-click any of the files to open the Radeon GPU profiler. If that doesn’t work, you might need to configure that path manually by hitting the cog-wheel in the top right hand corner of your screen.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/rgp.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/rgp.png" alt="An image showing the events tab of a RGP capture."/>

</a></p>

<p>And voila, you are ready to explore the performance of your app using RGP. How to use RGP itself is outside the scope of this post but another one might follow ;). In the meantime, feel free to explore the following resources.</p>

<ul>
<li><a href="https://gpuopen.com/rgp/" target="_blank" rel="noopener noreferrer">RGP Documentation</a></li>
<li><a href="https://www.youtube.com/watch?v=NWUodnjCYpg" target="_blank" rel="noopener noreferrer">GDC 2024 - Game Optimization with the Radeon™ Developer Tool Suite (YT video)</a></li>
<li><a href="https://gpuopen.com/gdc-presentations/2024/GDC2024_Game_Optimization_with_The_Radeon_Developer_Tool_Suite.pdf" target="_blank" rel="noopener noreferrer">GDC 2024 - Game Optimization with the Radeon™ Developer Tool Suite (slides)</a></li>
<li><a href="https://gpuopen.com/learn/occupancy-explained/" target="_blank" rel="noopener noreferrer">Occupancy Explained (shameless plug) </a></li>
</ul>

<h2 id="capturing-a-frame-with-nsight">Capturing a frame with Nsight</h2>

<p>To profile with Nvidia hardware, first download and install <a href="https://developer.nvidia.com/nsight-graphics/get-started" target="_blank" rel="noopener noreferrer">Nsight Graphics</a>. Much like PIX, Nsight must launch an app itself to be able to profile it. So open Nsight, click the connect button in the top left corner and select <code>GPU Trace Profiler</code> from the <code>Activity</code> tab.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/nsight_setup.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/nsight_setup.png" alt="An image showing how to setup the GPU trace mode of Nsight"/>

</a></p>

<p>Select your Chrome executable in the <code>Application Executable</code> field, the path should look something like <code>C:\Program Files\Google\Chrome\Application\chrome.exe</code>. Don’t forget to fill the <code>Command Line Arguments</code> field with the relevant arguments, including the required <code>--no-sandbox</code>. The field should look something like <code>--no-sandbox --disable-gpu-sandbox --disable-gpu-watchdog --disable-direct-composition --enable-dawn-features=emit_hlsl_debug_symbols,disable_symbol_renaming</code>.</p>

<p>Once those fields are filled, just hit the <code>Launch GPU Trace</code> button in the bottom right corner and watch Chrome start. Open a tab with a WebGPU workload to make Nsight connect automatically. If the operation succeeded the app’s layout should change and a new <code>Collect GPU Trace</code> button should appear.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/nsight_capture_button.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/nsight_capture_button.png" alt="An image showing where the capture button is in the Nsight interface"/>

</a></p>

<p>Once you’ve hit that button, a message box should inform you that the capture succeeded. Just press the <code>Open</code> button to access the capture.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/nsight_capture_finished.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/nsight_capture_finished.png" alt="An image showing the message box after Nsight finished capturing a frame."/>

</a></p>

<p>You should now see the following view and should be able to explore the performance of your app.</p>

<p><a href="https://frguthmann.github.io/images/profiling_webgpu/nsight_main_view.png" target="_blank" rel="noopener noreferrer">
  <img src="https://frguthmann.github.io/images/profiling_webgpu/nsight_main_view.png" alt="An image showing the main interface of Nsight"/>

</a></p>

<p>How to use Nsight itself is outside the scope of this post but feel free to explore the following resources.</p>

<ul>
<li><a href="https://developer.nvidia.com/nsight-graphics/get-started#documentation" target="_blank" rel="noopener noreferrer">Nsight Documentation</a></li>
<li><a href="https://developer.nvidia.com/blog/harness-powerful-shader-insights-using-shader-debug-info-with-nvidia-nsight-graphics/" target="_blank" rel="noopener noreferrer">Powerful Shader Insights: Using Shader Debug Info with NVIDIA Nsight Graphics</a></li>
<li><a href="https://developer.nvidia.com/blog/identifying-shader-limiters-with-the-shader-profiler-in-nvidia-nsight-graphics/" target="_blank" rel="noopener noreferrer">Identifying Shader Limiters with the Shader Profiler in NVIDIA Nsight Graphics</a></li>
<li><a href="https://developer.nvidia.com/blog/optimizing-vk-vkr-and-dx12-dxr-applications-using-nsight-graphics-gpu-trace-advanced-mode-metrics/" target="_blank" rel="noopener noreferrer">Optimizing VK/VKR and DX12/DXR Applications Using Nsight Graphics: GPU Trace Advanced Mode Metrics</a><br/></li>
</ul>



<p>The solution provided here is a terrible hack that happens to trigger both RDP and Nsight at the time of writing this article. It’s entirely possible that this breaks tomorrow and there isn’t much I can do about it.</p>

<p>That being said, at this time it is also the only available option to properly profile the GPU for WebGPU on Windows / Chrome. This was my biggest pain point when working daily with WebGL, along with the lack of a proper graphics debugger. Now WebGPU has both through PIX and RGP/Nsight. To me that makes it a much more viable option for serious graphics programming. Performance doesn’t have to be about mythical knowledge and voodoo optimizing blindfolded with both hands tied in the back anymore. Fire up that profiler and look at some actual metrics!</p>





<blockquote>
<p>⚠ <strong>Before anything else, please remember that this is a hacky solution and that you should not browse the open web with that DLL attached. It should only be used for a GPU profiling session and removed afterwards. It also conflicts with PIX, so you should remove it before attempting to take a capture. I would recommend adding that DLL to a specific flavor of Chrome ( Dev, Canary, etc. ) that you would only use for GPU profiling.</strong></p>
</blockquote>

<h2 id="instructions">Instructions</h2>

<ol>
<li>Download <code>d3d12.dll</code> from the release section of <a href="https://github.com/frguthmann/d3d12_webgpu_shim" target="_blank" rel="noopener noreferrer">this repository</a>.

<ul>
<li>Place the DLL into the <code>\Google\Chrome\Application</code> folder.</li>
</ul></li>
<li>On AMD, download <code>WinPixEventRuntime.dll</code> from the release section of <a href="https://github.com/frguthmann/PixEventsAMD" target="_blank" rel="noopener noreferrer">that repository</a>.

<ul>
<li>Place it into the <code>\Google\Chrome\Application\&lt;Version Number&gt;</code> folder.</li>
</ul></li>
<li>When launching Chrome, use the following command line arguments:

<ul>
<li><code>--no-sandbox --disable-gpu-sandbox --disable-gpu-watchdog --disable-direct-composition --enable-dawn-features=emit_hlsl_debug_symbols,disable_symbol_renaming</code></li>
</ul></li>
<li>Use your favorite GPU profiler as usual.<br/></li>
</ol>

    </div></div>
  </body>
</html>
