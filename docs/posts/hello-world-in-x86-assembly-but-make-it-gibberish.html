<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/phoreverpheebs/gibberish">Original</a>
    <h1>Show HN: &#39;Hello, World &#39; in x86 assembly, but make it gibberish</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><code>gibberish</code> is a <strong>simple</strong> &#39;Hello, World!&#39; program written in x86 assembly, which
doesn&#39;t reuse instructions and barely makes any sense. We have branched off a version
of <code>gibberish</code>, which defines the &#39;Hello, World!&#39; string directly in the source and
compiled binary instead of scattering its bytes all over, before and during execution.
This branch also spends more time explaining the process of its creation and techniques
we can use to offset execution to keep the program&#39;s doings secret.
(<a href="https://github.com/phoreverpheebs/gibberish/tree/defined-string">The defined-string branch</a>).</p>
<p dir="auto">This repository is to demonstrate ways we can obfuscate a binary from being
read through a simple <code>objdump</code> or other disassembly tools. Though, this method
is not perfect, as simply tracking all <code>call</code> and <code>jmp</code> instructions could lead
to a reliable reconstruction of the execution flow, we still may observe that
running <code>strings</code> on this binary does not show any signs of an encoded <code>Hello, World!</code>
string, since we use various methods to encode these in instructions, or increment
and decrement previous values to get the character we need.</p>
<p dir="auto">We also demonstrate how certain actions may be performed in redundant ways, so
as to confuse the average reverse engineer (e.g. the print procedure uses four
total instructions to zero the <code>eax</code> register).</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-sigsegv" aria-hidden="true" href="#the-sigsegv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The SIGSEGV</h2>
<p dir="auto"><code>gibberish.asm</code> (at least on my machine) runs into a segmentation fault about
50% of the time, which to me raises an interesting question that will lead me
to look into how memory is laid out at the beginning of a processes execution
on a standard Linux system. In <code>gdb</code>, the memory seems to be allocated in a
consistent manner, which causes the exception to never occur, though in normal
execution it seems to be slightly different.</p>
</article>
          </div></div>
  </body>
</html>
