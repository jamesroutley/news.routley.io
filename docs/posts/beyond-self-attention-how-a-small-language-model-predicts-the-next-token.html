<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shyam.blog/posts/beyond-self-attention/">Original</a>
    <h1>Beyond self-attention: How a small language model predicts the next token</h1>
    
    <div id="readability-page-1" class="page"><div><section id="single"><p><time datetime="2024-01-29 17:25:21 -0700 -0700">Jan 29, 2024</time>
<span>¬∑</span>
<span>17754 words</span>
<span>¬∑</span>
<span>84 minute read</span></p><div><p>I trained a small (~10 million parameter) <a href="https://en.wikipedia.org/wiki/Transformer_%28machine_learning_model%29" target="_blank" rel="noopener">transformer</a> following <a href="https://karpathy.ai/" target="_blank" rel="noopener">Andrej Karpathy</a>‚Äôs excellent tutorial, <a href="https://www.youtube.com/watch?v=kCc8FmEb1nY" target="_blank" rel="noopener">Let‚Äôs build GPT: from scratch, in code, spelled out</a>. After getting it working, I wanted to understand, as deeply as possible, what it was doing internally and how it produced its results.</p><p>The <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">original paper</a>, as well every transformer tutorial I found, focuses primarily on <a href="https://machinelearningmastery.com/the-transformer-attention-mechanism/" target="_blank" rel="noopener">multi-head self-attention</a>, the mechanism by which transformers learn multiple relationships between tokens without relying on recurrences or convolution. But none of the papers or tutorials I encountered give a satisfying explanation of what happens <em>after attention</em>: <strong>how exactly do the results of the attention computation turn into accurate predictions for the next token?</strong></p><p>I thought I could run a few example prompts through the small but working transformer I‚Äôd trained, examine the internal states, and figure this out. What I thought would be a quick investigation turned out to be a 6-month deep dive, but yielded some results I think are worth sharing. Specifically, I have a working theory that explains how the transformer produces its predictions and some empirical evidence that suggests this explanation is at least plausible.</p><p>For those readers familiar with transformers and eager for the punchline, here it is: Each transformer block (containing a multi-head self-attention layer and feed-forward network) learns weights that associate a given prompt with a class of strings found in the training corpus. <strong>The distribution of tokens that follow those strings in the training corpus is, approximately, what the block outputs as its predictions for the next token.</strong> Each block may associate the same prompt with a different class of training corpus strings, resulting in a different distribution of next tokens and thus different predictions. The final transformer output is a linear combination of each block‚Äôs predictions.</p><p>I implemented imperative code that does what I‚Äôm proposing the transformer is doing. It produces outputs very similar to the transformer, which I‚Äôll review in detail in a <a href="#evaluating-the-approximation">later section</a>.</p><p>In this post, I‚Äôm going to briefly introduce the model and training data, demo some evidence for my proposed explanation, give a detailed walkthrough of the imperative code implementation of it, and present the supporting evidence I have for my theory. I‚Äôve tried to keep the main narrative succinct, with links to relevant technical details and justifications in the <a href="#appendices">appendices</a> or other notebooks in the <a href="%28https://github.com/spather/transformer-experiments%29">repo</a>.</p><blockquote><p>This project is my first foray into this type of open-ended ML research. I‚Äôm sure I have made errors or omissions that would be obvious to more experienced researchers. I welcome any feedback on this work at <code>shyam.pather at gmail dot com</code>.</p></blockquote><h2 id="the-model-and-setup">The Model and Setup <a href="#the-model-and-setup">üîó</a></h2><blockquote><h3 id="disclaimer">Disclaimer <a href="#disclaimer">üîó</a></h3><p>I want to start by saying upfront: the code for the model I trained isn‚Äôt mine. It came from <a href="https://karpathy.ai/" target="_blank" rel="noopener">Andrej Karpathy</a>‚Äôs video, <a href="https://www.youtube.com/watch?v=kCc8FmEb1nY" target="_blank" rel="noopener">Let‚Äôs build GPT: from scratch, in code, spelled out</a> (highly recommend).</p><p>I typed in the code by copying what I saw on the screen as I watched the video. For things that weren‚Äôt clear onscreen, I referenced the <a href="https://github.com/karpathy/ng-video-lecture" target="_blank" rel="noopener">GitHub repo for the video</a> and the <a href="https://github.com/karpathy/nanoGPT" target="_blank" rel="noopener">nanoGPT repo</a>. After getting it working, I made only minor changes to make it work with the rest of the code in/structure of <a href="https://github.com/spather/transformer-experiments" target="_blank" rel="noopener">my repository</a>, resulting in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/models/transformer.ipynb" target="_blank" rel="noopener">this implementation</a>. In summary: the core language model is Andrej Karpathy‚Äôs work, not mine. The analysis and all the supporting code behind it are my original contributions. I‚Äôll acknowledge and cite influential papers, posts, tutorials, and other resources in the relevant places.</p></blockquote><h3 id="model-overview">Model Overview <a href="#model-overview">üîó</a></h3><p>The model is a 6-block, decoder-only <a href="https://en.wikipedia.org/wiki/Transformer_%28machine_learning_model%29" target="_blank" rel="noopener">transformer</a>:</p><p><img src="https://payments.posthaven.com/images/a9f2adc6c1c25ebb263caf42df37f4429c4ed44eda0a0a228cba52b7a00aeb9d.png" alt=""/></p><p>It‚Äôs trained on the <a href="https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt" target="_blank" rel="noopener">TinyShakespeare data set</a> which contains 40,000 lines of Shakespeare‚Äôs plays. After about an hour of training on an RTX 4000 GPU, it is able to produce reasonable-looking faux Shakespeare.</p><p>Given a prompt, the model predicts tokens that it thinks should follow. Let‚Äôs look at an example: starting with the prompt, <code>ROMEO:</code>, and sampling 500 tokens from the model‚Äôs predictions, we get:</p><pre tabindex="0"><code>ROMEO:
If thou wilt triumphant be virtue, and since from any
bold virtue that is made a bawd of earth, then the
duke desires of patience and perish:
take up the other husband, dislike his tent
back.

First Citizen:
Ourself goes, go back: you have no consul, but the disguised gods.

Second Citizen:
We choose him in the world, he did runk itself.

First Citizen:
Sir, I am I a man changed him and thriving, I have heard the
king.

CORIOLANUS:
Consider him!

AUFIDIUS:
Most gracious irice, and you must danc
</code></pre><p>It‚Äôs not Shakespeare but structurally, it‚Äôs plausible Shakespeare. It looks like the script for a play, the language sounds archaic, the character names/titles come from real Shakespeare plays. Most of the words are English words. Punctuation and capitalization are mostly sensible. Clearly, none of the text actually makes sense, but still, it‚Äôs not bad for an hour of training.</p><p>The <strong>tokens in the model are characters</strong>, not words. Given a prompt, the model predicts a probability distribution for the next character. For example, given the prompt <code>&#39;my most gr</code>, the model predicts these probabilities for the next token:</p><pre tabindex="0"><code>&#39;a&#39; 0.819
&#39;e&#39; 0.081
&#39;i&#39; 0.059
&#39;o&#39; 0.036
&#39;u&#39; 0.004
&#39;y&#39; 0.001
&#39;w&#39; 0.000
&#39;r&#39; 0.000
&#39;g&#39; 0.000
&#39;s&#39; 0.000
</code></pre><p><a href="#i-model-details">Appendix I</a> provides a few more details about the model. Beyond that, if you want to know more, <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/models/transformer.ipynb" target="_blank" rel="noopener">the code</a> and <a href="https://www.youtube.com/watch?v=kCc8FmEb1nY" target="_blank" rel="noopener">Andrej‚Äôs video</a> are the best resources.</p><h3 id="transformer-block-structure">Transformer Block Structure <a href="#transformer-block-structure">üîó</a></h3><p>Each of the 6 blocks in the architecture diagram above contains two significant sub-components: a multi-head self-attention layer and a feed-forward network, wired together via a mix of direct and residual connections as follows:</p><p><img src="https://payments.posthaven.com/images/72a30adc39ebf5f278c0a257fb46f26e6d666d113736e36ce394db587110260c.png" alt=""/></p><p>The <code>Block</code> module implements this wiring in PyTorch:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Block</span>(nn<span>.</span>Module):
</span></span><span><span>    <span>&#34;&#34;&#34;One transformer block&#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> __init__(self, n_embed, n_head):
</span></span><span><span>        super()<span>.</span>__init__()
</span></span><span><span>        head_size <span>=</span> n_embed <span>//</span> n_head
</span></span><span><span>        self<span>.</span>sa <span>=</span> MultiHeadAttention(n_head, head_size)
</span></span><span><span>        self<span>.</span>ffwd <span>=</span> FeedForward(n_embed)
</span></span><span><span>        self<span>.</span>ln1  <span>=</span> nn<span>.</span>LayerNorm(n_embed)
</span></span><span><span>        self<span>.</span>ln2 <span>=</span> nn<span>.</span>LayerNorm(n_embed)
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>forward</span>(self, x):
</span></span><span><span>        x <span>=</span> x <span>+</span> self<span>.</span>sa(self<span>.</span>ln1(x)) <span># The `x +` part is a skip connection</span>
</span></span><span><span>        x <span>=</span> x <span>+</span> self<span>.</span>ffwd(self<span>.</span>ln2(x)) <span># The `x +` part is a skip connection</span>
</span></span><span><span>
</span></span><span><span>        <span>return</span> x
</span></span></code></pre></div><p>While many words have been written and spoken about multi-head attention, comparatively little has been said about the feed-forward network because, it seems, comparatively little is known:</p><p><img src="https://payments.posthaven.com/images/b8214cdd1f6c9466bb984529984c757d780148fb4fe44bfed7714216e12bff73.png" alt=""/></p><p>Screenshot from <a href="https://stats.stackexchange.com/q/485910">https://stats.stackexchange.com/q/485910</a></p><p>I started this investigation wondering what comes after attention. Literally, the feed-forward network does. In the transformer I studied, across all 6 blocks, the feed-forward networks comprise over 65% of the total trainable parameters, so they must play some important role.</p><p>As I‚Äôll show <a href="#transformation-via-vector-addition">later</a>, it turns out that the output of the feed-forward network is the primary factor that determines how a block transforms its input into its output.</p><h2 id="demo-my-proposal-in-action">Demo: My Proposal In Action <a href="#demo-my-proposal-in-action">üîó</a></h2><p>In this section, I‚Äôm going to show an example that illustrates what I‚Äôm proposing the transformer is doing. In the next section, I‚Äôll go into detail about how this is implemented.</p><p>Imagine we did the following:</p><ul><li>Ran the prompt, <code>&#39;And only l&#39;</code>, through the model and extracted the output value of the feed-forward network in the first transformer block.</li><li>Went back to the training corpus, found all substrings of the same length as our prompt (10-characters), ran all of them through the model, and filtered out just the ones whose feed-forward network outputs in the first block have a cosine similarity of 0.95 or greater when compared to that of the prompt, <code>&#39;And only l&#39;</code>.</li></ul><p>We‚Äôd come up with this set of strings:</p><pre tabindex="0"><code>&#39;hat only l&#39;    &#39;s sickly l&#39;    &#39; as\nthey l&#39;   &#39;r kingly l&#39;    &#39;re; they l&#39;
&#39;eby they l&#39;    &#39;ar, they l&#39;    &#39;im, only l&#39;    &#39;ling any l&#39;    &#39;life may l&#39;
&#39;nobility l&#39;    &#39;e\nBy any l&#39;   &#39; as they l&#39;    &#39;, if any l&#39;    &#39; hastily l&#39;
&#39;tly they l&#39;    &#39; ghastly l&#39;    &#39;\nMy only l&#39;   &#39;For many l&#39;    &#39;r in any l&#39;
&#39; till my l&#39;    &#39;all they l&#39;    &#39;hen they l&#39;    &#39;at Henry l&#39;    &#39;oolishly l&#39;
&#39;er:\nThey l&#39;   &#39;may they l&#39;    &#39;or stony l&#39;    &#39;ur Henry l&#39;    &#39;l gladly l&#39;
&#39;yet they l&#39;    &#39;y;\nDelay l&#39;   &#39;e, on my l&#39;    &#39;or Henry l&#39;    &#39;I dearly l&#39;
&#39; if they l&#39;    &#39; she may l&#39;    &#39;t\nfairly l&#39;   &#39;ould say l&#39;    &#39;d all my l&#39;
&#39;her they l&#39;    &#39; Stanley l&#39;    &#39; and may l&#39;    &#39;uld they l&#39;    &#39;u all my l&#39;
&#39;friendly l&#39;    &#39;h gently l&#39;    &#39;e deadly l&#39;    &#39;f all my l&#39;    &#39;n all my l&#39;
&#39;Ere they l&#39;    &#39;steel my l&#39;    &#39; tell my l&#39;    &#39;e kingly l&#39;    &#39;learn my l&#39;
&#39;d he say l&#39;    &#39;t basely l&#39;    &#39;Thursday l&#39;    &#39;iciously l&#39;    &#34; &#39;if any l&#34;
&#39; as many l&#39;    &#39;hy glory l&#39;    &#39;not very l&#39;    &#39;a goodly l&#39;    &#39;e surely l&#39;
&#39;quiously l&#39;    &#39;, fairly l&#39;    &#39;lord! my l&#39;    &#39;entle my l&#39;    &#39;, he may l&#39;
&#39;our holy l&#39;    &#39; worldly l&#39;    &#39; my only l&#39;    &#39; all, my l&#39;
&#39;ul, they l&#39;    &#39;o lately l&#39;    &#39;s in any l&#39;    &#39; no lady l&#39;
&#39;ter many l&#39;    &#39;Our holy l&#39;    &#39;t vainly l&#39;    &#39;e\nA lady l&#39;
&#39; you may l&#39;    &#39;y greedy l&#39;    &#39;untimely l&#39;    &#39;directly l&#39;
&#39;er on my l&#39;    &#39;e wistly l&#39;    &#39;ng Henry l&#39;    &#39;And only l&#39;
&#39;s kindly l&#39;    &#39;KE:\nThey l&#39;   &#39; of many l&#39;    &#39;o, on my l&#39;
</code></pre><p>There‚Äôs a clear pattern across these: they all end in <code>y l</code> and several of them end in <code>ly l</code>. Similarity in the space of feed-forward network outputs seems to correspond to human-interpretable patterns.</p><p>Next, imagine we went back to the training corpus, found each of these strings and built a distribution of all the characters that came after them. We‚Äôd find, for example:</p><ul><li><code>&#39;hat only l&#39;</code> is followed by <code>i</code> (‚ÄúT<code>hat only l</code><strong>i</strong>ke a gulf it did remain‚Äù)</li><li><code>&#39;l gladly l&#39;</code> is followed by <code>e</code> (‚ÄúI‚Äôl<code>l gladly l</code><strong>e</strong>arn.‚Äù)</li><li><code>&#39;n all my l&#39;</code> is followed by both <code>a</code> and <code>i</code> (‚ÄúI<code>n all my l</code><strong>a</strong>nds and leases whatsoever‚Äù and ‚Äúnever saw you before i<code>n all my l</code><strong>i</strong>fe‚Äù)</li></ul><p>Doing this for the complete set of 94 strings, we‚Äôd end up with this distribution:</p><p><img src="https://payments.posthaven.com/images/170aed320bd4ab2e2647d8d1ef50b499b215ce1905cff1b5db6fe78dd83c3df3.png" alt=""/></p><p>The various tokens in our model‚Äôs vocabulary appear on the x-axis and the normalized frequency of occurrence on the y-axis. This plot shows that <code>i</code> was the most frequent, then <code>o</code>, then <code>a</code>, and finally, <code>e</code>.</p><p>Now let‚Äôs look at the final output of the transformer as a whole when given <code>And only l</code> as a prompt:</p><p><img src="https://payments.posthaven.com/images/08cb64e75759e2a329a0a296931433b06c02c2fb92b6dd0bb440af807cde1d86.png" alt=""/></p><p>This is a probability distribution representing the model‚Äôs predictions for the next token. Notice that it‚Äôs strikingly similar to the normalized frequency distribution shown in the previous plot!</p><p>We can quantify how similar they are. <a href="https://en.wikipedia.org/wiki/Hellinger_distance" target="_blank" rel="noopener">Hellinger distance</a> is a measure of overlap between probability distributions. Given distributions \(P\) and \(Q\), the Hellinger distance between them is:</p><p>$$
H(P, Q) = \frac{1}{\sqrt{2}} \sqrt{\sum_{i=1}^n (\sqrt{p_i} - \sqrt{q_i})^2}
$$</p><p>Or, in code:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>hellinger_distance</span>(
</span></span><span><span>    p: torch<span>.</span>Tensor,
</span></span><span><span>    q: torch<span>.</span>Tensor,
</span></span><span><span>):
</span></span><span><span>    <span>return</span> ((p<span>.</span>sqrt() <span>-</span> q<span>.</span>sqrt())<span>**</span><span>2</span>)<span>.</span>sum(dim<span>=-</span><span>1</span>)<span>.</span>sqrt() <span>/</span> math<span>.</span>sqrt(<span>2</span>)
</span></span></code></pre></div><p>Hellinger distance of 0 means the two distributions are identical and 1 means they have no overlap.</p><p>The Hellinger distance between the two distributions above - the distribution formed from the tokens that follow the strings with similar feed-forward network outputs and the distribution the model predicts - is 0.07: very nearly identical.</p><p>For the sake of keeping the demo brief, I chose an example where the first block‚Äôs similar strings alone are enough to produce a distribution that closely matches the final output of the transformer. Typically, we‚Äôd need to need to do the same exercise - finding the strings in the training corpus that produce similar feed-forward network outputs to the prompt and building a distribution from the tokens that succeed them - for all 6 transformer blocks, and then calculate a weighted sum of the resulting distributions in order to get a good match. We‚Äôll do that in the next section and see that <strong>across a sample of 20,000 prompts, the average Hellinger distance between distributions computed this way and the corresponding transformer output was just 0.17</strong>.</p><p>This small average Hellinger distances suggests the results produced by this approach are a good approximation for the transformer‚Äôs outputs. In addition, as I‚Äôll explain in the <a href="#interpretation-why-does-the-approximation-work">interpretation</a> section, I think the approach itself is a reasonable approximation of what the transformer is actually doing.</p><h2 id="implementation-approximating-the-transformer-output-with-feed-forward-network-outputs">Implementation: Approximating the Transformer Output with Feed-forward Network Outputs <a href="#implementation-approximating-the-transformer-output-with-feed-forward-network-outputs">üîó</a></h2><p>In this section, I‚Äôm going to walk through in some detail and with code, the exact procedure I used to approximate the transformer‚Äôs output using strings that produced similar feed-forward network outputs. If you‚Äôre not interested in the implementation, skip this section and proceed to the <a href="#evaluating-the-approximation">evaluation</a> section.</p><p>To recap, this is the procedure to compute the approximation:</p><ol><li>Run a prompt through the model and save the feed-forward network outputs for each block.</li><li>For each block:<ul><li>Find the strings in the training corpus that produce the most similar feed-forward network outputs to the prompt for that block.</li><li>For each string found, build a frequency distribution of the tokens that come after it in the training corpus.</li><li>Sum the frequency distributions for all strings found for the current block.</li></ul></li><li>Compute a weighted sum of the frequency distributions for each block computed in the previous step.</li><li>Normalize the weighted sum to get a probability distribution.</li></ol><h3 id="procedure-setup">Procedure Setup <a href="#procedure-setup">üîó</a></h3><p>The first step of the procedure - running a prompt through the model and saving the feed-forward network outputs for each block - is straightforward to accomplish with some basic PyTorch hooks. But the first part of step two - finding the strings in the training corpus that produce similar feed-forward network outputs - requires some additional machinery to do efficiently.</p><p>I did all the analysis with length 10 strings for compute and storage efficiency (but I also observed that the results hold for both shorter and longer strings). The 1,115,394-character long training corpus contains 858,923 unique, length 10 substrings. Each feed-forward network output is a 384-dimensional vector of <code>float32</code> values and the model produces 6 of them (one for each block). Comparing the 6 384-dimensional feed-forward outputs for any prompt to 6 * 858,923 = 5,153,538 feed-forward outputs from all the other strings takes a long time. To able to work with this data, I had to pre-compute things. I built the following pipeline:</p><ol><li>I chose 20,000 length 10 strings from the training corpus at random to use as prompts in this experiment.</li><li>Overnight, I ran a process to compute the cosine similarity between the feed-forward network outputs the model produced for the 20,000 prompts and those it produced for the 858,923 unique length 10 substrings of the training corpus. I did this in batches and saved the results to disk.</li><li>Even after pre-computing the cosine similarity results, searching through all of them to find the closest matches took a long time. Experiments showed matches of interest never had a cosine similarity below 0.7, so I ran another step to pre-filter the results of step 2 to just those entries with cosine similarity &gt;= 0.7. This greatly reduced the number of entries to search through.</li></ol><p>The code for this pre-computation and pre-filtering is too much to include in this post, but the implementation is available in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/experiments/cosine-sims.ipynb" target="_blank" rel="noopener">the <code>cosine-sims</code> experiment notebook</a>.</p><h3 id="procedure-walkthrough">Procedure Walkthrough <a href="#procedure-walkthrough">üîó</a></h3><p>In this section, we‚Äôll build up the code step by step and run it on one prompt at a time and for just one block. Over the following sections, we‚Äôll extend it to additional blocks, run it across a large number of prompts, and examine the results.</p><p>First, we need to grab 20,000 length 10 strings from the training corpus to use as prompts:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># Get all the unique substrings in the text</span>
</span></span><span><span>strings10 <span>=</span> all_unique_substrings(text<span>=</span>ts<span>.</span>text, substring_length<span>=</span><span>10</span>)
</span></span><span><span>
</span></span><span><span>n_prompts <span>=</span> <span>20000</span>
</span></span><span><span>
</span></span><span><span>torch<span>.</span>manual_seed(<span>1337</span>)
</span></span><span><span>indices <span>=</span> torch<span>.</span>randperm(len(strings10))[:n_prompts]
</span></span><span><span>prompts <span>=</span> [strings10[i<span>.</span>item()] <span>for</span> i <span>in</span> indices]
</span></span></code></pre></div><p>As described in the <a href="#procedure-setup">Procedure Setup</a> section, I previously ran all these strings through the model, grabbed the feed-forward network outputs for each block, and pre-computed the cosine similarities to all the unique length 10 substrings in the training corpus. And then I pre-filtered the results to just those with cosine similarity &gt;= 0.7.</p><p>The <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/experiments/cosine-sims.ipynb" target="_blank" rel="noopener">the <code>cosine-sims</code> experiment notebook</a> that implements all this also exports a helper function, <code>filter_on_prefiltered_results()</code>, that we can use to find the most similar strings to a given prompt by searching over the pre-filtered results.</p><blockquote><p>If you‚Äôre curious about how this works, check out the notebook. It‚Äôs pretty straightforward and the unit test provides a simple example that illustrates the shape of the inputs and outputs.</p></blockquote><p>To use <code>filter_on_prefiltered_results()</code>, we just need to tell it how to find the prefiltered files:</p><div><pre tabindex="0"><code data-lang="python"><span><span>prefiltered_threshold<span>=</span><span>0.7</span>
</span></span><span><span>prefiltered_results_folder <span>=</span> environment<span>.</span>data_root <span>/</span> <span>&#39;cosine_sim_results/large_files/slen10&#39;</span> <span>/</span> <span>f</span><span>&#39;prefiltered_</span><span>{</span>prefiltered_threshold<span>}</span><span>&#39;</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>prefiltered_filename</span>(block_idx: int, q_idx: int) <span>-&gt;</span> Path:
</span></span><span><span>    <span>return</span> prefiltered_results_folder <span>/</span> <span>f</span><span>&#39;cosine_sim_ffwd_out_</span><span>{</span>q_idx<span>:</span><span>05d</span><span>}</span><span>_</span><span>{</span>block_idx<span>:</span><span>02d</span><span>}</span><span>.pt&#39;</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>load_prefiltered_data</span>(block_idx: int, q_idx: int):
</span></span><span><span>    <span>return</span> torch<span>.</span>load(prefiltered_filename(block_idx, q_idx))
</span></span></code></pre></div><blockquote><p>Note on the use of <code>q_idx</code> here and in the rest of the code: <code>q_idx</code> refers to ‚Äúquery index‚Äù. The job that pre-computes all the cosine similarities takes a set of ‚Äúqueries‚Äù or values to compare to. These queries are the feed-forward network outputs the model produces for the prompts. There is a 1:1 correspondence between queries and prompts and so I‚Äôve used the terms interchangeably in the code.</p></blockquote><p>To start, we‚Äôll use the same prompt - <code>&#39;And only l&#39;</code> - we used in the earlier demo. It happens to be the prompt at index 57:</p><pre tabindex="0"><code>&#39;And only l&#39;
</code></pre><p>We‚Äôll find the strings whose feed-forward network outputs in block 0 had a cosine similarity of 0.95 or greater when compared to the block 0 feed forward network output of the prompt.</p><div><pre tabindex="0"><code data-lang="python"><span><span>block_idx <span>=</span> <span>0</span>
</span></span><span><span>similarity_threshold<span>=</span><span>0.95</span>
</span></span><span><span>q_idx <span>=</span> <span>57</span>
</span></span><span><span>similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>    load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>    q_idx_start<span>=</span>q_idx,
</span></span><span><span>    q_idx_end<span>=</span>q_idx<span>+</span><span>1</span>,
</span></span><span><span>    filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_threshold
</span></span><span><span>)
</span></span><span><span>similar_strings <span>=</span> [
</span></span><span><span>    [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>    <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>]
</span></span><span><span>len(similar_strings[<span>0</span>])
</span></span></code></pre></div><pre tabindex="0"><code>94
</code></pre><p>This produced the 94 similar strings we saw in the demo. We can print them again to be sure:</p><div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;Original string: </span><span>{</span>repr(prompts[q_idx])<span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>&#34;Similar strings: </span><span>\n</span><span>&#34;</span>)
</span></span><span><span>
</span></span><span><span>data_columns<span>=</span>[
</span></span><span><span>    [repr(s) <span>for</span> s <span>in</span> similar_strings[<span>0</span>][i : i <span>+</span> <span>20</span>]] <span>for</span> i <span>in</span> range(<span>0</span>, len(similar_strings[<span>0</span>]), <span>20</span>)
</span></span><span><span>]
</span></span><span><span>
</span></span><span><span>print(text_table(
</span></span><span><span>    headers<span>=</span>[],
</span></span><span><span>    data_columns<span>=</span>data_columns,
</span></span><span><span>    col_widths<span>=</span>[<span>18</span> <span>for</span> _ <span>in</span> data_columns]
</span></span><span><span>))
</span></span></code></pre></div><pre tabindex="0"><code>Original string: &#39;And only l&#39;
Similar strings:

&#39;hat only l&#39;      &#39;s sickly l&#39;      &#39; as\nthey l&#39;     &#39;r kingly l&#39;      &#39;re; they l&#39;
&#39;eby they l&#39;      &#39;ar, they l&#39;      &#39;im, only l&#39;      &#39;ling any l&#39;      &#39;life may l&#39;
&#39;nobility l&#39;      &#39;e\nBy any l&#39;     &#39; as they l&#39;      &#39;, if any l&#39;      &#39; hastily l&#39;
&#39;tly they l&#39;      &#39; ghastly l&#39;      &#39;\nMy only l&#39;     &#39;For many l&#39;      &#39;r in any l&#39;
&#39; till my l&#39;      &#39;all they l&#39;      &#39;hen they l&#39;      &#39;at Henry l&#39;      &#39;oolishly l&#39;
&#39;er:\nThey l&#39;     &#39;may they l&#39;      &#39;or stony l&#39;      &#39;ur Henry l&#39;      &#39;l gladly l&#39;
&#39;yet they l&#39;      &#39;y;\nDelay l&#39;     &#39;e, on my l&#39;      &#39;or Henry l&#39;      &#39;I dearly l&#39;
&#39; if they l&#39;      &#39; she may l&#39;      &#39;t\nfairly l&#39;     &#39;ould say l&#39;      &#39;d all my l&#39;
&#39;her they l&#39;      &#39; Stanley l&#39;      &#39; and may l&#39;      &#39;uld they l&#39;      &#39;u all my l&#39;
&#39;friendly l&#39;      &#39;h gently l&#39;      &#39;e deadly l&#39;      &#39;f all my l&#39;      &#39;n all my l&#39;
&#39;Ere they l&#39;      &#39;steel my l&#39;      &#39; tell my l&#39;      &#39;e kingly l&#39;      &#39;learn my l&#39;
&#39;d he say l&#39;      &#39;t basely l&#39;      &#39;Thursday l&#39;      &#39;iciously l&#39;      &#34; &#39;if any l&#34;
&#39; as many l&#39;      &#39;hy glory l&#39;      &#39;not very l&#39;      &#39;a goodly l&#39;      &#39;e surely l&#39;
&#39;quiously l&#39;      &#39;, fairly l&#39;      &#39;lord! my l&#39;      &#39;entle my l&#39;      &#39;, he may l&#39;
&#39;our holy l&#39;      &#39; worldly l&#39;      &#39; my only l&#39;      &#39; all, my l&#39;
&#39;ul, they l&#39;      &#39;o lately l&#39;      &#39;s in any l&#39;      &#39; no lady l&#39;
&#39;ter many l&#39;      &#39;Our holy l&#39;      &#39;t vainly l&#39;      &#39;e\nA lady l&#39;
&#39; you may l&#39;      &#39;y greedy l&#39;      &#39;untimely l&#39;      &#39;directly l&#39;
&#39;er on my l&#39;      &#39;e wistly l&#39;      &#39;ng Henry l&#39;      &#39;And only l&#39;
&#39;s kindly l&#39;      &#39;KE:\nThey l&#39;     &#39; of many l&#39;      &#39;o, on my l&#39;
</code></pre><p>Next, we‚Äôll need to build a frequency distribution for the tokens that came after these strings in the text. To make this easy and efficient (we‚Äôll eventually be doing many times), we can pre-compute the next token frequency distributions for all the unique length 10 substrings in the training corpus. The helper function <code>build_next_token_map()</code>, implemented in the <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/common/text-analysis.ipynb" target="_blank" rel="noopener">text-analysis module</a>, does this.</p><div><pre tabindex="0"><code data-lang="python"><span><span>next_token_map10 <span>=</span> build_next_token_map(
</span></span><span><span>    text<span>=</span>ts<span>.</span>text,
</span></span><span><span>    prefix_len<span>=</span><span>10</span>,
</span></span><span><span>    vocab_size<span>=</span>tokenizer<span>.</span>vocab_size,
</span></span><span><span>    stoi<span>=</span>tokenizer<span>.</span>stoi
</span></span><span><span>)
</span></span></code></pre></div><p>The return value stored in <code>next_token_map10</code> is a dictionary that maps each unique length 10 substring in the training corpus to a frequency distribution of the tokens that come after it. Conceptually, it looks something like this:</p><div><pre tabindex="0"><code data-lang="python"><span><span>{
</span></span><span><span>    <span>&#39;the common&#39;</span>: {
</span></span><span><span>        <span>&#39; &#39;</span>: <span>12</span>, <span>&#34;&#39;&#34;</span>: <span>1</span>, <span>&#39;,&#39;</span>: <span>1</span>, <span>&#39;?&#39;</span>: <span>1</span>, <span>&#39;a&#39;</span>: <span>1</span>, <span>&#39;s&#39;</span>: <span>5</span>, <span>&#39;w&#39;</span>: <span>3</span>
</span></span><span><span>    },
</span></span><span><span>    <span>&#39; the gods &#39;</span>: {
</span></span><span><span>        <span>&#39;b&#39;</span>: <span>1</span>, <span>&#39;c&#39;</span>: <span>1</span>, <span>&#39;d&#39;</span>: <span>2</span>, <span>&#39;f&#39;</span>: <span>1</span>, <span>&#39;g&#39;</span>: <span>1</span>, <span>&#39;h&#39;</span>: <span>2</span>, <span>&#39;k&#39;</span>: <span>2</span>, <span>&#39;s&#39;</span>: <span>2</span>, <span>&#39;t&#39;</span>: <span>1</span>, <span>&#39;w&#39;</span>: <span>2</span>
</span></span><span><span>    },
</span></span><span><span>    <span>&#39; authority&#39;</span>: {
</span></span><span><span>        <span>&#39;</span><span>\n</span><span>&#39;</span>: <span>1</span>, <span>&#39; &#39;</span>: <span>5</span>, <span>&#39;,&#39;</span>: <span>5</span>, <span>&#39;:&#39;</span>: <span>2</span>, <span>&#39;;&#39;</span>: <span>1</span>
</span></span><span><span>    },
</span></span><span><span>    <span>...</span>
</span></span><span><span>}
</span></span></code></pre></div><p>In reality, the values are actually tensors of shape <code>(vocab_size,)</code> where <code>vocab_size</code> is the number of unique tokens the vocabulary (65, in our case). The item at index <code>i</code> in the tensor is the count of occurrences of the <code>i</code>th token after the string in that entry‚Äôs key. So it looks more like:</p><div><pre tabindex="0"><code data-lang="python"><span><span>{
</span></span><span><span>      <span>&#39;the common&#39;</span>: torch<span>.</span>tensor([
</span></span><span><span>            <span>0</span>, <span>12</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>            <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>            <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>            <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>5</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>3</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>
</span></span><span><span>      ]),
</span></span><span><span>      <span>&#39; the gods &#39;</span>: torch<span>.</span>tensor([
</span></span><span><span>            <span>0</span>, <span>12</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>            <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>            <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>            <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>5</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>3</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>
</span></span><span><span>      ]),
</span></span><span><span>      <span>&#39; authority&#39;</span>: torch<span>.</span>tensor([
</span></span><span><span>          <span>0</span>, <span>12</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>          <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>          <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>1</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,
</span></span><span><span>          <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>5</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>,  <span>3</span>,  <span>0</span>,  <span>0</span>,  <span>0</span>
</span></span><span><span>      ]),
</span></span><span><span>    <span>...</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Next, we need to sum the frequency distributions for all the strings we found to have similar feed-forward network outputs to our prompt. Because <code>next_token_map10</code> stores the individual frequency distributions as tensors, this is easy to accomplish:</p><div><pre tabindex="0"><code data-lang="python"><span><span>total_freq_distribution <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    next_token_map10[string] <span>for</span> string <span>in</span> similar_strings[<span>0</span>]
</span></span><span><span>])<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span></code></pre></div><p>We stack up the distributions for each similar string into a single tensor and then sum across all of them. We can now turn this into a probability distribution by dividing each entry by the sum of all the entries:</p><div><pre tabindex="0"><code data-lang="python"><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum()
</span></span></code></pre></div><p>Finally, we can visualize this distribution:</p><div><pre tabindex="0"><code data-lang="python"><span><span>plot_prob_distribution_for_tokens(prob_distribution, title<span>=</span><span>&#39;Probability distribution using only block 0 similar strings&#39;</span>)
</span></span></code></pre></div><p><img src="https://payments.posthaven.com/images/c04c3fbe83a543ea834691f8ef6c5ecdee18522f3e3e456cd9ea81209eb60b00.png" alt=""/></p><p>It‚Äôs the same distribution we saw in the demo.</p><p>Now let‚Äôs code the comparison to the model output:</p><div><pre tabindex="0"><code data-lang="python"><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>logits<span>.</span>plot_probs(title<span>=</span><span>&#39;Probability distribution from model&#39;</span>)
</span></span></code></pre></div><p><img src="https://payments.posthaven.com/images/08cb64e75759e2a329a0a296931433b06c02c2fb92b6dd0bb440af807cde1d86.png" alt=""/></p><p>Again, the two distributions look very similar, and in this example, the approximation uses only values from the first block. To better compare them, we can look at the distributions in text form:</p><div><pre tabindex="0"><code data-lang="python"><span><span>approx_top_tokens <span>=</span> top_nonzero_tokens(prob_distribution, tokenizer<span>.</span>itos)
</span></span><span><span>model_top_tokens <span>=</span> logits<span>.</span>topk_tokens(k<span>=</span><span>10</span>)[<span>0</span>][<span>-</span><span>1</span>]
</span></span><span><span>
</span></span><span><span>print_distribution_comparison(approx_top_tokens, model_top_tokens)
</span></span></code></pre></div><pre tabindex="0"><code>Model Predictions   Approximation Predictions
-----------------   -------------------------
i: 0.437            i: 0.389
o: 0.204            o: 0.250
a: 0.195            a: 0.222
e: 0.160            e: 0.139
</code></pre><p>Finally, we can also compare the Hellinger distance between these distributions:</p><div><pre tabindex="0"><code data-lang="python"><span><span>hellinger_distance(prob_distribution, logits<span>.</span>probs()[<span>0</span>][<span>-</span><span>1</span>])
</span></span></code></pre></div><pre tabindex="0"><code>tensor(0.0711)
</code></pre><p>By combining the next token frequency distributions of the similar strings from just the first layer of the model, we are able to pretty closely approximate the output of the transformer. Of course, I chose an example that works particularly well.</p><p>Here‚Äôs an example where the frequency distribution from just the first layer doesn‚Äôt work well:</p><pre tabindex="0"><code>&#39;hing tremb&#39;
</code></pre><p>Using the same method, we can identify 57 strings from the training corpus that produce similar feed-forward network outputs to the prompt:</p><div><pre tabindex="0"><code data-lang="python"><span><span>block_idx <span>=</span> <span>0</span>
</span></span><span><span>similarity_threshold<span>=</span><span>0.95</span>
</span></span><span><span>similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>    load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>    q_idx_start<span>=</span>q_idx,
</span></span><span><span>    q_idx_end<span>=</span>q_idx<span>+</span><span>1</span>,
</span></span><span><span>    filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_threshold
</span></span><span><span>)
</span></span><span><span>similar_strings <span>=</span> [
</span></span><span><span>    [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>    <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>]
</span></span><span><span>len(similar_strings[<span>0</span>])
</span></span></code></pre></div><pre tabindex="0"><code>57
</code></pre><p>We can look up, sum, and normalize the frequency distributions of tokens that follow these strings in the training corpus, and compare the result to the model outputs, as we did before:</p><div><pre tabindex="0"><code data-lang="python"><span><span>total_freq_distribution <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    next_token_map10[string] <span>for</span> string <span>in</span> similar_strings[<span>0</span>]
</span></span><span><span>])<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum()
</span></span><span><span>
</span></span><span><span>approx_top_tokens <span>=</span> top_nonzero_tokens(prob_distribution, tokenizer<span>.</span>itos)
</span></span><span><span>
</span></span><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>model_top_tokens <span>=</span> logits<span>.</span>topk_tokens(k<span>=</span><span>10</span>)[<span>0</span>][<span>-</span><span>1</span>]
</span></span><span><span>
</span></span><span><span>print_distribution_comparison(approx_top_tokens, model_top_tokens)
</span></span></code></pre></div><pre tabindex="0"><code>Model Predictions   Approximation Predictions
-----------------   -------------------------
l: 0.999            e: 0.543
e: 0.000            l: 0.343
r: 0.000            r: 0.114
</code></pre><p>Unlike the previous example, these distributions are quite different. The top 3 tokens are the same in each, but they‚Äôre in the wrong order and their probabilities are far apart. These differences contribute to a large Hellinger distance:</p><div><pre tabindex="0"><code data-lang="python"><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>hellinger_distance(prob_distribution, logits<span>.</span>probs()[<span>0</span>][<span>-</span><span>1</span>])
</span></span></code></pre></div><pre tabindex="0"><code>tensor(0.6305)
</code></pre><p>For the prompt, <code>&#39;hing tremb&#39;</code>, just using the values from the first block results in a poor approximation of the transformer‚Äôs output. We‚Äôll soon add the contributions from other blocks and when we do, we‚Äôll get the Hellinger distance between the approximation and the real transformer output for this prompt down from 0.63 to just 0.02.</p><h3 id="similarity-thresholds">Similarity Thresholds <a href="#similarity-thresholds">üîó</a></h3><p>In the preceding examples, I used a similarity threshold of 0.95: I searched for strings whose feed-forward network outputs in block 0 produced values with a cosine similarity of 0.95 or greater when compared to the feed-forward network output of the prompt.</p><p>A different threshold would have yielded different results. For example, doing the same exercise for prompt id 57 (<code>&#39;And only l&#39;</code>) with a threshold of 0.90 finds 612 similar strings, vs the 94 we had before:</p><div><pre tabindex="0"><code data-lang="python"><span><span>block_idx <span>=</span> <span>0</span>
</span></span><span><span>similarity_threshold<span>=</span><span>0.90</span>
</span></span><span><span>q_idx <span>=</span> <span>57</span>
</span></span><span><span>similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>    load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>    q_idx_start<span>=</span>q_idx,
</span></span><span><span>    q_idx_end<span>=</span>q_idx<span>+</span><span>1</span>,
</span></span><span><span>    filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_threshold
</span></span><span><span>)
</span></span><span><span>similar_strings <span>=</span> [
</span></span><span><span>    [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>    <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>]
</span></span><span><span>len(similar_strings[<span>0</span>])
</span></span></code></pre></div><pre tabindex="0"><code>612
</code></pre><p>If we do the rest of the approximation procedure, we see different (and worse) results:</p><div><pre tabindex="0"><code data-lang="python"><span><span>total_freq_distribution <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    next_token_map10[string] <span>for</span> string <span>in</span> similar_strings[<span>0</span>]
</span></span><span><span>])<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum()
</span></span><span><span>
</span></span><span><span>approx_top_tokens <span>=</span> top_nonzero_tokens(prob_distribution, tokenizer<span>.</span>itos)
</span></span><span><span>
</span></span><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>model_top_tokens <span>=</span> logits<span>.</span>topk_tokens(k<span>=</span><span>10</span>)[<span>0</span>][<span>-</span><span>1</span>]
</span></span><span><span>
</span></span><span><span>print_distribution_comparison(approx_top_tokens, model_top_tokens)
</span></span></code></pre></div><pre tabindex="0"><code>Model Predictions   Approximation Predictions
-----------------   -------------------------
i: 0.437            o: 0.584
o: 0.204            i: 0.251
a: 0.195            a: 0.095
e: 0.160            e: 0.066
u: 0.004            u: 0.002
l: 0.000            y: 0.001
</code></pre><p>The top 5 tokens are the same, but when ranked by probability, the approximation has a different ordering than the model. The Hellinger distance is also higher:</p><div><pre tabindex="0"><code data-lang="python"><span><span>hellinger_distance(prob_distribution, logits<span>.</span>probs()[<span>0</span>][<span>-</span><span>1</span>])
</span></span></code></pre></div><pre tabindex="0"><code>tensor(0.2856)
</code></pre><p>Loosening the similarity threshold introduced strings into the calculation that resulted in a worse approximation. Tightening beyond 0.95 also produces worse results than we got with 0.95, presumably because we‚Äôre excluding strings that were needed to produce a good approximation:</p><div><pre tabindex="0"><code data-lang="python"><span><span>block_idx <span>=</span> <span>0</span>
</span></span><span><span>similarity_threshold<span>=</span><span>0.97</span>
</span></span><span><span>q_idx <span>=</span> <span>57</span>
</span></span><span><span>similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>    load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>    q_idx_start<span>=</span>q_idx,
</span></span><span><span>    q_idx_end<span>=</span>q_idx<span>+</span><span>1</span>,
</span></span><span><span>    filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_threshold
</span></span><span><span>)
</span></span><span><span>similar_strings <span>=</span> [
</span></span><span><span>    [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>    <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>]
</span></span><span><span>len(similar_strings[<span>0</span>])
</span></span></code></pre></div><pre tabindex="0"><code>33
</code></pre><div><pre tabindex="0"><code data-lang="python"><span><span>total_freq_distribution <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    next_token_map10[string] <span>for</span> string <span>in</span> similar_strings[<span>0</span>]
</span></span><span><span>])<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum()
</span></span><span><span>
</span></span><span><span>approx_top_tokens <span>=</span> top_nonzero_tokens(prob_distribution, tokenizer<span>.</span>itos)
</span></span><span><span>
</span></span><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>model_top_tokens <span>=</span> logits<span>.</span>topk_tokens(k<span>=</span><span>10</span>)[<span>0</span>][<span>-</span><span>1</span>]
</span></span><span><span>
</span></span><span><span>print_distribution_comparison(approx_top_tokens, model_top_tokens)
</span></span></code></pre></div><pre tabindex="0"><code>Model Predictions   Approximation Predictions
-----------------   -------------------------
i: 0.437            o: 0.278
o: 0.204            i: 0.250
a: 0.195            a: 0.250
e: 0.160            e: 0.222
</code></pre><div><pre tabindex="0"><code data-lang="python"><span><span>hellinger_distance(prob_distribution, logits<span>.</span>probs()[<span>0</span>][<span>-</span><span>1</span>])
</span></span></code></pre></div><pre tabindex="0"><code>tensor(0.1498)
</code></pre><p>For the first block, 0.95 appears to be a sweet spot. I came up with this threshold through manual tuning: trying different values and binary searching towards one that produced the best results. The full history of this tuning exercise is in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/40_widening_similar_space.ipynb" target="_blank" rel="noopener">the similar space analysis notebook</a>.</p><p>In the end, I found the following thresholds produce the best results for each block:</p><table><thead><tr><th>Block</th><th>Similarity Threshold</th></tr></thead><tbody><tr><td>0</td><td>0.95</td></tr><tr><td>1</td><td>0.94</td></tr><tr><td>2</td><td>0.85</td></tr><tr><td>3</td><td>0.76</td></tr><tr><td>4</td><td>0.81</td></tr><tr><td>5</td><td>0.89</td></tr></tbody></table><blockquote><p>When I first started exploring this space, I assumed the approximation would get better the more similarity I could find. I tried a number of techniques, including experimenting with Euclidean distance vs cosine similarity, searching across strings of different lengths, etc. Every time I succeeded in finding strings with more similar feed-forward network outputs to use in the approximation, the results got worse. I realized that, at least for some blocks, including <em>less</em> similar values in the mix produced better approximations, probably because those blocks had learned to map prompts to broader classes of strings in the training corpus.</p></blockquote><h3 id="going-beyond-the-first-block">Going Beyond the First Block <a href="#going-beyond-the-first-block">üîó</a></h3><p>Thus far, we‚Äôve only considered feed-forward network outputs from the first block. Now we‚Äôll incorporate the contributions from the other blocks.</p><p>First, let‚Äôs find the strings that produce similar feed-forward network outputs in each block, using the similarity thresholds listed above. For now, we‚Äôll do this for just one query (index 57, <code>&#39;And only l&#39;</code>):</p><div><pre tabindex="0"><code data-lang="python"><span><span>similarity_thresholds<span>=</span>[<span>0.95</span>, <span>0.94</span>, <span>0.85</span>, <span>0.76</span>, <span>0.81</span>, <span>0.89</span>]
</span></span><span><span>q_idx <span>=</span> <span>57</span>
</span></span><span><span>
</span></span><span><span>similar_strings_per_block <span>=</span> []
</span></span><span><span>
</span></span><span><span><span>for</span> block_idx <span>in</span> range(n_layer):
</span></span><span><span>    similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>        load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>        q_idx_start<span>=</span>q_idx,
</span></span><span><span>        q_idx_end<span>=</span>q_idx<span>+</span><span>1</span>,
</span></span><span><span>        filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_thresholds[block_idx]
</span></span><span><span>    )
</span></span><span><span>    similar_strings <span>=</span> [
</span></span><span><span>        [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>        <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>    ]
</span></span><span><span>    similar_strings_per_block<span>.</span>append(similar_strings)
</span></span></code></pre></div><p>Let‚Äôs summarize how many strings we found for each block based on these thresholds:</p><div><pre tabindex="0"><code data-lang="python"><span><span>print(text_table(
</span></span><span><span>    headers<span>=</span>[<span>&#34;Block Index&#34;</span>, <span>&#34;Similarity Threshold&#34;</span>, <span>&#34;# of Similar Strings&#34;</span>],
</span></span><span><span>    data_columns<span>=</span>[
</span></span><span><span>        [<span>f</span><span>&#34;</span><span>{</span>block_idx<span>:</span><span>&gt;10</span><span>}</span><span>&#34;</span> <span>for</span> block_idx <span>in</span> range(n_layer)],
</span></span><span><span>        [<span>f</span><span>&#34;</span><span>{</span>threshold<span>:</span><span>&gt;19</span><span>}</span><span>&#34;</span> <span>for</span> threshold <span>in</span> similarity_thresholds],
</span></span><span><span>        [<span>f</span><span>&#34;</span><span>{</span>len(similar_strings[<span>0</span>])<span>:</span><span>&gt;19</span><span>}</span><span>&#34;</span> <span>for</span> similar_strings <span>in</span> similar_strings_per_block],
</span></span><span><span>    ],
</span></span><span><span>    col_widths<span>=</span>[<span>14</span>, <span>23</span>, <span>23</span>]
</span></span><span><span>))
</span></span></code></pre></div><pre tabindex="0"><code>Block Index   Similarity Threshold   # of Similar Strings
-----------   --------------------   --------------------
         0                   0.95                     94
         1                   0.94                     47
         2                   0.85                     70
         3                   0.76                    108
         4                   0.81                    175
         5                   0.89                   2237
</code></pre><p>Now that we‚Äôve identified the right strings for each block, we can do the next step of the approximation procedure: build the frequency distributions for the tokens that follow those strings, and sum them up. We‚Äôre going to be doing this several times over, so let‚Äôs define a function for it:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>frequency_distribution_from_similar_strings</span>(
</span></span><span><span>    similar_strings_per_block: Sequence[Sequence[Sequence[str]]],
</span></span><span><span>    next_token_map: Dict[str, torch<span>.</span>Tensor],
</span></span><span><span>) <span>-&gt;</span> torch<span>.</span>Tensor:
</span></span><span><span>    <span># freqs_per_block_per_query is a list of lists of tensors. The outer list has</span>
</span></span><span><span>    <span># one item per block. The inner list has one item per query. Each</span>
</span></span><span><span>    <span># tensor is the next token frequency distribution for a particular</span>
</span></span><span><span>    <span># block and query.</span>
</span></span><span><span>    freqs_per_block_per_query: List[List[torch<span>.</span>Tensor]] <span>=</span> [[] <span>for</span> _ <span>in</span> range(n_layer)]
</span></span><span><span>
</span></span><span><span>    <span>for</span> block_idx <span>in</span> range(n_layer):
</span></span><span><span>        <span>for</span> similar_strings <span>in</span> similar_strings_per_block[block_idx]:
</span></span><span><span>            freqs_per_block_per_query[block_idx]<span>.</span>append(
</span></span><span><span>                torch<span>.</span>stack([next_token_map[string] <span>for</span> string <span>in</span> similar_strings])<span>.</span>sum(
</span></span><span><span>                    dim<span>=</span><span>0</span>
</span></span><span><span>                )
</span></span><span><span>            )
</span></span><span><span>
</span></span><span><span>    <span># Stack all frequency tensors into a single tensor of shape</span>
</span></span><span><span>    <span># (n_layer, n_queries, vocab_size)</span>
</span></span><span><span>    freqs <span>=</span> torch<span>.</span>stack(
</span></span><span><span>        [
</span></span><span><span>            torch<span>.</span>stack(freqs_per_block_per_query[block_idx])
</span></span><span><span>            <span>for</span> block_idx <span>in</span> range(n_layer)
</span></span><span><span>        ]
</span></span><span><span>    )
</span></span><span><span>
</span></span><span><span>    <span>return</span> freqs
</span></span></code></pre></div><p>This function, <code>frequency_distribution_from_similar_strings()</code>, does the equivalent of this code we looked at earlier:</p><div><pre tabindex="0"><code data-lang="python"><span><span>total_freq_distribution <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    next_token_map10[string] <span>for</span> string <span>in</span> similar_strings[<span>0</span>]
</span></span><span><span>])<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span></code></pre></div><p>But with two key differences:</p><ul><li>It does this calculation for all the blocks, using the similar strings we found for each block above.</li><li>It allows for more than one query. In the code we‚Äôve looked at so far, we only evaluated the approximation for a single prompt. In the next section, we‚Äôll be running it for lots of prompts so I‚Äôve written the code in a more general form to a allow for this. Specifically, the code allows for <code>similar_strings_per_block</code> to contain not just a single list of strings per block but multiple: one for each query.</li></ul><p>Let‚Äôs run this on the <code>similar_strings_per_block</code> we constructed earlier:</p><div><pre tabindex="0"><code data-lang="python"><span><span>freq_distribution <span>=</span> frequency_distribution_from_similar_strings(
</span></span><span><span>    similar_strings_per_block,
</span></span><span><span>    next_token_map10,
</span></span><span><span>)
</span></span><span><span>freq_distribution<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([6, 1, 65])
</code></pre><p>It produces a tensor of shape <code>(6, 1, 65)</code>: 6 blocks, 1 query, 65 tokens in the vocabulary. If we‚Äôd been working with more queries, the middle dimension would be larger.</p><p>So now we have a frequency distribution for each block, based on the strings found for each block using the similarity thresholds. We now need to turn this into a probability distribution.</p><p>Earlier, when we just had a single frequency distribution for a single block, we just normalized it. But now we have multiple frequency distributions - one for each block - and need to combine them. In my experiments, I found that a weighted sum of these distributions produced the best results.</p><p>As with the similarity thresholds, I was able to find a set of good weights by trial and error. I also tried a deep-learning approach to find weights, but did not get better results than with the hand-tuned approach. The procedure for both hand-tuning and learning weights is implemented in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/40_widening_similar_space.ipynb" target="_blank" rel="noopener">the similar space notebook</a>, the same one used for tuning thresholds.</p><p>For now, let‚Äôs use the optimal weights I found:</p><div><pre tabindex="0"><code data-lang="python"><span><span>weights <span>=</span> torch<span>.</span>tensor([<span>0.01</span>, <span>0.01</span>, <span>0.1</span>, <span>1.5</span>, <span>6</span>, <span>0.01</span>])<span>.</span>unsqueeze(dim<span>=</span><span>1</span>)<span>.</span>unsqueeze(dim<span>=</span><span>2</span>) <span># (n_layer, 1, 1)</span>
</span></span><span><span>total_freq_distribution <span>=</span> (freq_distribution <span>*</span> weights)<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum(dim<span>=-</span><span>1</span>, keepdim<span>=</span><span>True</span>)
</span></span></code></pre></div><p>We multiply the frequency distributions by the weights, sum across all blocks, and then normalize into a probability distribution. We can now look at how the approximation‚Äôs distribution compares to the model‚Äôs.</p><blockquote><p>Note: in the code below, we have to index into the <code>prob_distribution</code> tensor with <code>[0]</code> because its first dimension is the number of queries. We‚Äôre only working with a single query, so we can just take the first element.</p></blockquote><div><pre tabindex="0"><code data-lang="python"><span><span>approx_top_tokens <span>=</span> top_nonzero_tokens(prob_distribution[<span>0</span>], tokenizer<span>.</span>itos)
</span></span><span><span>
</span></span><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>model_top_tokens <span>=</span> logits<span>.</span>topk_tokens(k<span>=</span><span>10</span>)[<span>0</span>][<span>-</span><span>1</span>]
</span></span><span><span>
</span></span><span><span>print_distribution_comparison(approx_top_tokens, model_top_tokens)
</span></span></code></pre></div><pre tabindex="0"><code>Model Predictions   Approximation Predictions
-----------------   -------------------------
i: 0.437            i: 0.363
o: 0.204            o: 0.265
a: 0.195            a: 0.213
e: 0.160            e: 0.147
u: 0.004            u: 0.011
l: 0.000            y: 0.000
</code></pre><div><pre tabindex="0"><code data-lang="python"><span><span>hellinger_distance(prob_distribution[<span>0</span>], logits<span>.</span>probs()[<span>0</span>][<span>-</span><span>1</span>])
</span></span></code></pre></div><pre tabindex="0"><code>tensor(0.0731)
</code></pre><p>In this particular case, adding the other layers didn‚Äôt change the approximation much (if anything, it‚Äôs very slightly worse based on Hellinger distance). But let‚Äôs look at the example that didn‚Äôt work well when we considered just the first layer: prompt id 40 (<code>&#39;hing tremb&#39;</code>).</p><div><pre tabindex="0"><code data-lang="python"><span><span>similarity_thresholds<span>=</span>[<span>0.95</span>, <span>0.94</span>, <span>0.85</span>, <span>0.76</span>, <span>0.81</span>, <span>0.89</span>]
</span></span><span><span>q_idx <span>=</span> <span>40</span>
</span></span><span><span>
</span></span><span><span>similar_strings_per_block <span>=</span> []
</span></span><span><span>
</span></span><span><span><span>for</span> block_idx <span>in</span> range(n_layer):
</span></span><span><span>    similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>        load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>        q_idx_start<span>=</span>q_idx,
</span></span><span><span>        q_idx_end<span>=</span>q_idx<span>+</span><span>1</span>,
</span></span><span><span>        filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_thresholds[block_idx]
</span></span><span><span>    )
</span></span><span><span>    similar_strings <span>=</span> [
</span></span><span><span>        [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>        <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>    ]
</span></span><span><span>    similar_strings_per_block<span>.</span>append(similar_strings)
</span></span><span><span>
</span></span><span><span>freq_distribution <span>=</span> frequency_distribution_from_similar_strings(
</span></span><span><span>    similar_strings_per_block,
</span></span><span><span>    next_token_map10,
</span></span><span><span>)
</span></span><span><span>weights <span>=</span> torch<span>.</span>tensor([<span>0.01</span>, <span>0.01</span>, <span>0.1</span>, <span>1.5</span>, <span>6</span>, <span>0.01</span>])<span>.</span>unsqueeze(dim<span>=</span><span>1</span>)<span>.</span>unsqueeze(dim<span>=</span><span>2</span>) <span># (n_layer, 1, 1)</span>
</span></span><span><span>total_freq_distribution <span>=</span> (freq_distribution <span>*</span> weights)<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum(dim<span>=-</span><span>1</span>, keepdim<span>=</span><span>True</span>)
</span></span><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_string(prompts[q_idx])
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>
</span></span><span><span>approx_top_tokens <span>=</span> top_nonzero_tokens(prob_distribution[<span>0</span>], tokenizer<span>.</span>itos)
</span></span><span><span>model_top_tokens <span>=</span> logits<span>.</span>topk_tokens(k<span>=</span><span>10</span>)[<span>0</span>][<span>-</span><span>1</span>]
</span></span><span><span>
</span></span><span><span>print_distribution_comparison(approx_top_tokens, model_top_tokens)
</span></span></code></pre></div><pre tabindex="0"><code>Model Predictions   Approximation Predictions
-----------------   -------------------------
l: 0.999            l: 0.997
e: 0.000            e: 0.002
r: 0.000            r: 0.000
</code></pre><div><pre tabindex="0"><code data-lang="python"><span><span>hellinger_distance(prob_distribution, logits<span>.</span>probs()[<span>0</span>][<span>-</span><span>1</span>])
</span></span></code></pre></div><pre tabindex="0"><code>tensor([0.0233])
</code></pre><p>Remember that for this example, when we used just the first layer‚Äôs similar strings, the approximation was quite different from the model‚Äôs prediction and had a Hellinger distance of &gt;0.63. Now it‚Äôs nearly identical and has a Hellinger distance of 0.02. So using the rest of the layers really helped this example.</p><p>In the next section, we‚Äôll extend the code to evaluate the approximation over the whole set of 20,000 prompts. The section after that will look at how well the approximation does across all the prompts.</p><h3 id="extending-to-all-20000-prompts">Extending to All 20,000 Prompts <a href="#extending-to-all-20000-prompts">üîó</a></h3><p>We now have all the pieces we need to run the approximation procedure for all 20,000 prompts. First, let‚Äôs find the strings with similar feed-forward network outputs for all the prompts, for all blocks:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># Takes about 7 minutes to run</span>
</span></span><span><span>
</span></span><span><span>similarity_thresholds<span>=</span>[<span>0.95</span>, <span>0.94</span>, <span>0.85</span>, <span>0.76</span>, <span>0.81</span>, <span>0.89</span>]
</span></span><span><span>
</span></span><span><span>similar_strings_per_block <span>=</span> []
</span></span><span><span>
</span></span><span><span><span>for</span> block_idx <span>in</span> range(n_layer):
</span></span><span><span>    similar_indices <span>=</span> filter_on_prefiltered_results(
</span></span><span><span>        load_prefiltered<span>=</span><span>lambda</span> q_idx: load_prefiltered_data(block_idx, q_idx),
</span></span><span><span>        q_idx_start<span>=</span><span>0</span>,
</span></span><span><span>        q_idx_end<span>=</span>n_prompts,
</span></span><span><span>        filter_fn<span>=</span><span>lambda</span> values: values <span>&gt;</span> similarity_thresholds[block_idx]
</span></span><span><span>    )
</span></span><span><span>    similar_strings <span>=</span> [
</span></span><span><span>        [strings10[i] <span>for</span> i <span>in</span> indices]
</span></span><span><span>        <span>for</span> indices <span>in</span> similar_indices
</span></span><span><span>    ]
</span></span><span><span>    similar_strings_per_block<span>.</span>append(similar_strings)
</span></span></code></pre></div><p>Next, we compute the frequency distributions for each query based on the strings we found, perform the weighted sum, and normalize to produce a probability distribution.</p><div><pre tabindex="0"><code data-lang="python"><span><span>freq_distribution <span>=</span> frequency_distribution_from_similar_strings(
</span></span><span><span>    similar_strings_per_block,
</span></span><span><span>    next_token_map10,
</span></span><span><span>)
</span></span><span><span>weights <span>=</span> torch<span>.</span>tensor([<span>0.01</span>, <span>0.01</span>, <span>0.1</span>, <span>1.5</span>, <span>6</span>, <span>0.01</span>])<span>.</span>unsqueeze(dim<span>=</span><span>1</span>)<span>.</span>unsqueeze(dim<span>=</span><span>2</span>) <span># (n_layer, 1, 1)</span>
</span></span><span><span>total_freq_distribution <span>=</span> (freq_distribution <span>*</span> weights)<span>.</span>sum(dim<span>=</span><span>0</span>)
</span></span><span><span>prob_distribution <span>=</span> total_freq_distribution <span>/</span> total_freq_distribution<span>.</span>sum(dim<span>=-</span><span>1</span>, keepdim<span>=</span><span>True</span>)
</span></span><span><span>prob_distribution<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([20000, 65])
</code></pre><p>The output is a tensor of shape (20000, 65): one 65-entry distribution for each of 20,000 prompts.</p><p>In order to compare, we need to run all the prompts through the model and get the output probability distributions the model predicts:</p><div><pre tabindex="0"><code data-lang="python"><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_strings(prompts)
</span></span><span><span>logits, _ <span>=</span> m(tokens)
</span></span><span><span>logits <span>=</span> LogitsWrapper(logits<span>.</span>detach(), tokenizer)
</span></span><span><span>model_probs <span>=</span> logits<span>.</span>probs()
</span></span><span><span>model_probs <span>=</span> model_probs[:, <span>-</span><span>1</span>, :] <span># We&#39;re only interested in the last token</span>
</span></span></code></pre></div><p>Now we have outputs from the approximation and from the model for all prompts. In the next section, we‚Äôll measure the Hellinger distance between them and evaluate the results.</p><h2 id="evaluating-the-approximation">Evaluating the Approximation <a href="#evaluating-the-approximation">üîó</a></h2><p>In earlier sections, we compared output from the approximation to output from the model for individual prompts. Now that we have both outputs for all prompts, we can compare them and look at aggregate results.</p><p>First, we can compute the Hellinger distance between the approximation and the model‚Äôs prediction for each prompt:</p><div><pre tabindex="0"><code data-lang="python"><span><span>h <span>=</span> hellinger_distance(prob_distribution, model_probs)
</span></span><span><span>h<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([20000])
</code></pre><p>This produced 20,000 Hellinger distance scores, one for each prompt. We can start by looking at some basic stats:</p><div><pre tabindex="0"><code data-lang="python"><span><span>h<span>.</span>mean(), h<span>.</span>std(), h<span>.</span>min(), h<span>.</span>max()
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(0.1677), tensor(0.1215), tensor(0.0013), tensor(0.9994))
</code></pre><p>The average Hellinger distance is just below 0.17, with a standard deviation of around 0.12, suggesting a distribution that skews low (a good thing). We‚Äôve also got at least one really excellent sample (a min of 0.0013) and at least one really terrible one (max of 0.9994).</p><p>Let‚Äôs look at the distribution:</p><p><img src="https://payments.posthaven.com/images/e9c543696d0748c74bccfac0780e9e6a5cd7610dafc6e650fb5dab2192fc8399.png" alt=""/></p><p>Indeed, the distribution is skewed left, indicating most queries have Hellinger distance scores on the lower end.</p><p>The numbers and the distribution graph look promising, but is the approximation really a good one? It‚Äôs hard to say without something to compare against and it‚Äôs not obvious what a good comparison might be.</p><p>A thought experiment: let‚Äôs imagine that for some prompt, the model produced a distribution that looked like this:</p><p><img src="https://payments.posthaven.com/images/d01e3755f6278cc6f19ae5656ab3ba6fd7b4ecb59c69303db814b6cc43fb0435.png" alt=""/></p><p>The tokens <code>b</code> and <code>d</code> have nearly the same predicted probability (0.49 vs 0.51). The model predicts an approximately equal chance of these tokens coming next. Now imagine our approximation, or another model, predicted this distribution:</p><p><img src="https://payments.posthaven.com/images/02bddd27aedd082ab84a2b5dd45dacae4e745dc49ed363df5725916e4b370844.png" alt=""/></p><p>Nearly the same, but the probabilities are reversed: <code>b</code> has probability 0.51 and <code>d</code> has 0.49. Would we care about this difference? Clearly both distributions are saying that <code>b</code> and <code>d</code> are about equally likely. If used for inference, either distribution would probably produce acceptable results. For most use cases I could imagine, the difference would just be noise.</p><p>The Hellinger distance between the two imagined distributions above is 0.0141. Not zero, but we‚Äôre saying it doesn‚Äôt matter for practical purposes. If 0.0141 is a Hellinger distance that doesn‚Äôt matter much, what about 0.02? Or 0.025? We can imagine there is some threshold Hellinger distance below which we wouldn‚Äôt care and above which we would consider distributions to be meaningfully different. What is that threshold value?</p><p>If we knew it, then we could look at how close the average Hellinger distance between our approximation‚Äôs predictions and model‚Äôs come to this threshold. That would be a measure of the goodness of the approximation.</p><p>I did an experiment to estimate what the threshold is. I trained the same transformer architecture three more times, starting with a different random seed each time and stopping at approximately the same training and validation loss as I did for the original model. This gave me three alternative transformers with roughly the same performance, but with different weights due to the different random initial starting points:</p><table><thead><tr><th>Model</th><th>Seed</th><th>Est. Training Loss</th><th>Est. Validation Loss</th></tr></thead><tbody><tr><td>Original Model</td><td>1337</td><td>0.9334</td><td>1.5063</td></tr><tr><td>Alternate 1</td><td>1442</td><td>0.9293</td><td>1.5038</td></tr><tr><td>Alternate 2</td><td>88</td><td>0.9294</td><td>1.4991</td></tr><tr><td>Alternate 3</td><td>99999</td><td>0.9339</td><td>1.4941</td></tr></tbody></table><blockquote><p>I used the same training/validation sets, hyperparameters, optimizer, etc. for the three alternate models as for the original model. The training code and output for the alternate models is in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/experiments/alternate-models.ipynb" target="_blank" rel="noopener">the <code>alternate-models</code> experiment notebook</a>. Training code for the original model is at the end of <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/models/transformer.ipynb" target="_blank" rel="noopener">the main transformer notebook</a>.</p></blockquote><p>I then ran the same 20,000 prompts through the alternative models and calculated the Hellinger distance between their outputs and that of the original model. <a href="#ii-evaluation-of-main-model-vs-3-alternate-models">Appendix II</a> shows the code used to do this. The table below shows the aggregate results.</p><table><thead><tr><th>Comparison</th><th>Mean Hellinger Distance</th></tr></thead><tbody><tr><td>Original vs Alternate 1</td><td>0.1064 ¬± 0.0823</td></tr><tr><td>Original vs Alternate 2</td><td>0.1057 ¬± 0.0817</td></tr><tr><td>Original vs Alternate 3</td><td>0.1053 ¬± 0.0828</td></tr></tbody></table><p>The original model and the three alternate models are ‚Äúequivalent‚Äù in the sense that they perform about equally well in terms of training and validation loss. I could have used any of them as the basis for this post. In other words, the differences between them likely aren‚Äôt meaningful - just noise.</p><p>Across all three alternate models, the average Hellinger distance was ~0.11 ¬± 0.08. We only have 3 data points, so it‚Äôs not a perfect measure, but ~0.11 is probably a reasonable lower bound for the threshold Hellinger distance we are looking for.</p><p>For comparison, the average Hellinger distance between the model and the approximation was ~0.17. A little higher than 0.11, but within a standard deviation.</p><p>Plotting the distributions of the various Hellinger distances shows this nicely:</p><p><img src="https://payments.posthaven.com/images/d82fe84ec51461c861f5fbc1c2c273935d4d8ac8ceceaeeb292d79cd5fb9ee19.png" alt=""/></p><p>There is clearly less deviation between the alternates and the original model than between the approximation and the original model, but it‚Äôs not wildly different. I think this result suggests the approximation is quite good. Most of the difference is within the ‚Äúacceptable noise‚Äù threshold.</p><h2 id="interpretation-why-does-the-approximation-work">Interpretation: Why Does the Approximation Work? <a href="#interpretation-why-does-the-approximation-work">üîó</a></h2><p>The analysis in the previous section shows that the outputs of the approximation are quite similar to the transformer‚Äôs outputs. But that doesn‚Äôt necessarily mean that the approximation procedure is similar to what the transformer is actually doing. The approximation and the transformer might just represent two different ways of computing the same result.</p><p>My intuition is that this is not the case: <strong>I think the approximation is at least something like what the transformer is doing</strong>. In this section, I‚Äôll break down <em>how</em> I think the transformer computes something similar to the approximation and then present some supporting evidence.</p><p>The key ideas are:</p><ul><li>The transformer, as its name suggests*, performs a series of transformations on its embedded input. The transformer blocks transform embeddings within embedding space and the final linear layer at the end transforms from embedding space to logit space.</li><li>Within each transformer block, the transformation from input to output embedding is done via vector addition: the block‚Äôs output embedding is its input embedding plus the output of the self-attention layer, plus the output of the feed-forward network. Of the two added components, the feed-forward network output value is dominant in determining the final output.</li><li>Within embedding space, subspaces exist that correspond to specific tokens. An embedding within the subspace for a particular token produces an output distribution in which all the probability is concentrated on that token (that token has probability near 1 and all other tokens have probability near 0). Embeddings that lie between the subspaces for multiple tokens result in outputs that distribute all the probability across those tokens.</li><li>The feed-forward network output at each block is an ‚Äúadjustment vector‚Äù that orients the block output towards the subspaces for the tokens that the approximation procedure would predict: those that follow the strings in the training corpus that produce similar feed-forward network outputs at that block.</li></ul><p>In the subsections below, I‚Äôll go into each of these ideas in more detail.</p><blockquote><p>*It‚Äôs unclear whether the name ‚Äútransformer‚Äù alludes to transforming an input sequence to an output sequence (the use case in the original paper was machine translation) or the transformations within the layers of the model.</p></blockquote><h3 id="the-model-is-a-series-of-transformations">The Model is a Series of Transformations <a href="#the-model-is-a-series-of-transformations">üîó</a></h3><p>Once the input to the model has been embedded, we can view the model as a series of transformations:</p><p><img src="https://payments.posthaven.com/images/c0b6c591002c7e1f931a0bcc794b88454aab02158d1125bef2f8422dbc0e8264.png" alt=""/></p><p>The sequence of 6 transformer blocks takes a tensor in embedding space (\(\mathbb{R}^{384}\), since <code>n_embed=384</code>) as input and outputs another tensor in embedding space. In this sense, represents a transformation <em>within</em> embedding space. In fact, each transformer block is itself a transformation within embedding space and the stack of all 6 blocks composes these individual transformations. It isn‚Äôt literally implemented this way in code, but its equivalent to:</p><div><pre tabindex="0"><code data-lang="python"><span><span>output_embedding <span>=</span> block6(block5(block4(block3(block2(block1(input_embedding))))))
</span></span></code></pre></div><p>At the end of the sequence of blocks, the model sends the output embedding through a LayerNorm operation and then a linear layer that transforms from embedding space into logit space (\(\mathbb{R}^{65}\), since <code>vocab_size=65</code>). Finally, the softmax layer at the end turns the logits into probabilities for the next token.</p><h3 id="transformation-via-vector-addition">Transformation via Vector Addition <a href="#transformation-via-vector-addition">üîó</a></h3><p>We looked at the internal logic within a transformer block in the earlier <a href="#transformer-block-structure">Transformer Block Structure</a> section. To recap, the <code>forward()</code> method of the <code>Block</code> module looks like this:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Block</span>(nn<span>.</span>Module):
</span></span><span><span>    <span>&#34;&#34;&#34;One transformer block&#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>forward</span>(self, x):
</span></span><span><span>        x <span>=</span> x <span>+</span> self<span>.</span>sa(self<span>.</span>ln1(x)) <span># The `x +` part is a skip connection</span>
</span></span><span><span>        x <span>=</span> x <span>+</span> self<span>.</span>ffwd(self<span>.</span>ln2(x)) <span># The `x +` part is a skip connection</span>
</span></span><span><span>
</span></span><span><span>        <span>return</span> x
</span></span></code></pre></div><p><a id="block-logic-with-intermediates"></a>
This is equivalent to the following code, which, by using some intermediate local variables, clarifies what‚Äôs really going on:</p><div><pre tabindex="0"><code data-lang="python"><span><span>    <span>def</span> <span>forward</span>(self, x):
</span></span><span><span>        sa_out <span>=</span> self<span>.</span>sa(self<span>.</span>ln1(x))
</span></span><span><span>        ffwd_out <span>=</span> self<span>.</span>ffwd(self<span>.</span>ln2(x <span>+</span> sa_out))
</span></span><span><span>
</span></span><span><span>        <span>return</span> x <span>+</span> sa_out <span>+</span> ffwd_out
</span></span></code></pre></div><p><strong>The output of the block is equal to the input (<code>x</code>), plus the self-attention output (<code>sa_out</code>), plus the feed forward network output (<code>ffwd_out</code>).</strong> We can think of the block as taking the input embedding, and then making two adjustments to it.</p><p>These values being added together are vectors in \(\mathbb{R}^{384}\). If we imagine the embedding space reduced to just two dimensions, it might look something like this:</p><p><img src="https://payments.posthaven.com/images/12e04e2fdd477aaa55660b4020a4ae6b9a72c55038f98009049330cfecfc4291.png" alt=""/></p><p>The red vector represents the input embedding. The green vector represents the self-attention output (<code>sa_out</code> in code), and the blue vector represents the feed-forward network output (<code>ffwd_out</code> in code). The gray arrow represent the final sum, or the output of the first block: where you end up when you arrange the individual vectors tip to tail.</p><p>The plot above shows the additions that happen within just one block. Subsequent blocks add their self-attention outputs and feed-forward network outputs, starting from the output of this block. If we add the vectors from those other blocks to the diagram, it looks like this:</p><p><img src="https://payments.posthaven.com/images/24b90fb31e5e330043b12b6a3b0bf9e8bed15bbd4cd57e98f0cbdc4b393fc71f.png" alt=""/></p><p>Again, the red arrow represents the input vector, each green arrow represents one block‚Äôs self-attention output, each blue arrow represents one block‚Äôs feed-forward network output. Arranged tip to tail, their endpoint represents the final output from the stack of 6 blocks, depicted by the gray arrow.</p><p>Though it‚Äôs only in two dimensions, the diagram above is based on real data and is drawn ‚Äúto scale‚Äù, in a way: the length of each 2D vector is the same as the \(\mathbb{R}^{384}\) vector it represents for a real query (index 57). In addition, the cosine similarity between each 2D blue / green arrow and the sum of the arrows that precede it is the same as the cosine similarity between the corresponding self-attention/feed-forward network output and the block input in the real data.</p><blockquote><p>Code to generate the 2D representation from real data is in the <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/70_embedding_adjustments.ipynb" target="_blank" rel="noopener">embedding adjustments analysis notebook</a>.</p></blockquote><p>We can observe two interesting patterns:</p><ul><li>The feed-forward network outputs are generally longer than the self-attention outputs (the vectors have larger norms)</li><li>Within a given block, the feed-forward network output and the self-attention output point in roughly the same direction.</li></ul><p>Look at what happens when we eliminate the self-attention outputs from the vector sum, leaving just the feed-forward network outputs:</p><p><img src="https://payments.posthaven.com/images/7fff50753ede8a54541e69eaf00215ea285f523817e8361d1fe08ac5e0c6cd8a.png" alt=""/></p><p>The inner blue curve in the above plot represents the sum of the input vector and only the feed-forward network outputs from each block. The tip to tail arrangement of these vectors ends at a point far from where the previous arrangement (including the self-attention outputs) ended. But notice that the feed-forward-only endpoint (shorter gray arrow) is quite closely aligned in <em>direction</em> with the original endpoint (longer gray arrow).</p><p>This plot shows values for only one query and we lose a lot of information dropping from 384 dimensions to 2. But the pattern does seem to hold in general and in the full, high-dimensional embedding space. The <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/70_embedding_adjustments.ipynb" target="_blank" rel="noopener">embedding adjustments analysis notebook</a> provides a deep-dive into this phenomenon across all 20,000 queries.</p><p>The takeaway is that <strong>simplifying the transformation performed by the blocks to just the contributions of the feed-forward networks results in an output vector that is shorter (has a smaller norm) than the original output but points in roughly the same direction</strong>. And the difference in norms would have no impact on the transformer‚Äôs final output, because of the LayerNorm operation after the stack of blocks. That LayerNorm step will adjust the norm of any input vector to similar value regardless of its initial magnitude; the final linear layer that follows it will always see inputs of approximately the same norm (see <a href="#iii-the-output-embeddings-norm-doesnt-matter-because-of-the-final-layernorm">Appendix III</a> for a walk-through of this).</p><p>An important clarification: I‚Äôm not suggesting that we could remove the self attention computation from the transformer. The feed-forward networks take the self-attention output as part of their input (<code>ffwd_out = self.ffwd(self.ln2(x + </code><strong><code>sa_out</code></strong><code>))</code>); they would compute very different values were the self-attention outputs removed. What I am saying is that, after all block processing has been completed as normal including the self-attention computations, we get roughly the same result if we consider only the feed-forward network contributions, as our approximation does. This is probably because the feed-forward network outputs pass on some of the information they receive as input from the self-attention output.</p><p>For some additional evidence that an approximation based only on feed-forward network outputs can produce similar outputs to the transformer, see <a href="#iv-summary-of-experiment-on-relative-impact-of-self-attention-and-feed-forward-network-outputs">Appendix IV</a>.</p><h3 id="token-subspaces">Token Subspaces <a href="#token-subspaces">üîó</a></h3><p>In the examples we‚Äôve seen so far, the model outputs have been distributions that include significant non-zero probabilities for several tokens. For example:</p><p><img src="https://payments.posthaven.com/images/a90c56ba1e72733d29a614671ad61789b5196562087c1464273da469843cb54d.png" alt=""/></p><p>Though we haven‚Äôt seen one yet, we might wonder whether <strong>specific inputs</strong> exist that compel the model to predict a <strong>single token</strong> with <strong>near certainty</strong>. In other words, do some inputs cause the model to output a probability distribution in which just one token has probability very near 1 and all other tokens very near zero? Such a distribution might look like this:</p><p><img src="https://payments.posthaven.com/images/ecc30428196c016ef2970ee406b6ea46a79a2a24c1521d8843c2dc90f83ffc83.png" alt=""/></p><p>In fact, we can ask this question about any stage of the model. ‚ÄúInput‚Äù doesn‚Äôt have to refer to the initial input to the model, but could be the input to any layer within the model. For example, consider only the layers that transform the final block‚Äôs output embedding to logit space (the final LayerNorm and linear layers):</p><p><img src="https://payments.posthaven.com/images/4c4339d5f6612480cf52b0d34f2c1732c99485033c1196076543f86ec0925af5.png" alt=""/></p><p>Is there some embedding block 6 might emit that would yield an output probability distribution in which some token, say the letter <code>a</code>, has probability very near 1?</p><h4 id="learning-token-subspaces">Learning Token Subspaces <a href="#learning-token-subspaces">üîó</a></h4><p>With the right math, it may be possible to find this embedding analytically. But it‚Äôs also possible to ‚Äúlearn‚Äù (in the sense of deep learning) such an embedding. Here‚Äôs the basic idea:</p><ul><li>Pick a point in the transformer where the input to subsequent layers is an embedding. This could be the input to any of the transformer blocks, or the point right after the final block (as shown in the diagram above).</li><li>Pick a token to learn an embedding for.</li><li>Create an embedding tensor and initialize it with random values. This tensor is the parameter the learning algorithm will optimize; the weights of the transformer are fixed.</li><li>Execute a forward pass by evaluating the transformer from the selected point, using the embedding as input. This will produce some set of logits.</li><li>Compute <a href="https://ljvmiranda921.github.io/notebook/2017/08/13/softmax-and-the-negative-log-likelihood/#nll" target="_blank" rel="noopener">negative log likelihood loss</a> relative to the token we‚Äôre learning an embedding for.</li><li>Do a backward pass, updating the embedding tensor according to the gradients.</li></ul><p>My implementation of this is in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/experiments/learn-embeddings.ipynb" target="_blank" rel="noopener">the learned embeddings notebook</a>. I used it to learn embeddings for all tokens at various stages of the model and saved them. We can load one - a learned embedding that produces a distribution giving token <code>a</code> probability almost 1 - and check that it does what we expect when given to the part of the model shown in the diagram above:</p><p><img src="https://payments.posthaven.com/images/0dce2cb6b27518fe0a1a26685995c9050cf791b48cc4e407a080182039905dca.png" alt=""/></p><p>As expected, all the probability mass is concentrated on <code>a</code>. Inference using this distribution would generate <code>a</code> with near certainty.</p><p>The same procedure can learn embeddings for use at other parts of the model. If we wanted to find an embedding for <code>a</code> that could be input to block 6, we could run the same learning algorithm but use this part of the transformer in the forward pass:</p><p><img src="https://payments.posthaven.com/images/37991d03eeb45809255009149e32de771715221bb9d315efb6e2aa78b26a897c.png" alt=""/></p><p>It‚Äôs more computationally expensive to learn embeddings at earlier stages of the model because the optimizer has to contend with a larger computation graph involving operations from all included blocks. Thankfully, as I‚Äôll explain <a href="#use-only-final-subspaces">shortly</a>, we need only the embeddings learned for the part of the transformer after all the blocks (embeddings that go straight into the final LayerNorm layer) to show how the transformer operates like the approximation.</p><h4 id="from-embeddings-to-subspaces">From Embeddings to Subspaces <a href="#from-embeddings-to-subspaces">üîó</a></h4><p>For any token, the procedure described in the previous section can learn an embedding that makes the model predict that token with probability near 1. It turns out <strong>there isn‚Äôt just one such embedding for each token.</strong> We can learn many different embeddings that all produce probability distributions that assign a given token nearly all the probability mass. It was easy to learn thousands of unique embeddings for every token in the vocabulary.</p><p>I think <strong>the model has learned a complex, non-linear embedding subspace corresponding to each token</strong>. Any embedding within that subspace results in an output distribution that assigns the token near certain probability. Each embedding I was able to learn is probably a point in the embedding subspace for the corresponding token.</p><p>If we imagine the full embedding space (\(\mathbb{R}^{384}\)) reduced to \(\mathbb{R}^3\) (and the complex subspaces reduced to 2D planes), it might look something like this:</p><p><img src="https://payments.posthaven.com/images/04a243b63386cc0e853d350cb0177eeb33f2c15d2aacdaf59ddb4dc38f48b444.png" alt=""/></p><p>I don‚Äôt know how to determine the exact subspaces for each token mathematically. But I do know how to get a workable approximation of them <strong>if we‚Äôre willing to pretend that they are linear</strong>. They are almost certainly not linear, even at the end of the model, because of the non-linear LayerNorm operation. But they are likely <em>closer</em> to linear near the end of the model because the LayerNorm is the only non-linearity. Earlier in the model, each feed-forward network introduces an additional non-linearity via its ReLU operation.</p><blockquote><p><a href="https://www.lesswrong.com/posts/jfG6vdJZCwTQmG7kb/re-examining-layernorm" target="_blank" rel="noopener">This post on LessWrong</a> illustrates of the non-linearity of LayerNorm clearly.</p></blockquote><p>Pretending the subspaces are linear actually works quite well for the part of the model after the transformer blocks. And that is the only part of the model we need to consider for this analysis (as I‚Äôll explain <a href="#use-only-final-subspaces">soon</a>).</p><h4 id="linear-approximations-for-subspaces">Linear Approximations for Subspaces <a href="#linear-approximations-for-subspaces">üîó</a></h4><p>The idea is quite simple: for a given token, we can learn a whole lot of different embeddings, treating each one as a data point. Then we can determine the best fitting line, plane, or other low-dimensional linear subspace that fits the data.</p><p>Again, if we imagine our embedding space reduced to just 3 dimensions, it might look something like the following diagram. The blue dots each represent a learned embedding and the red arrow is the line that minimizes projected distance from each point.</p><p><img src="https://payments.posthaven.com/images/a32cb4b311513c8c1bbb0af5cae1d68b1e96efeddfbde076f8e9fca02772d605.png" alt=""/></p><p>We can use Singular Value Decomposition (SVD) to find the best fitting linear subspace for the learned embeddings.</p><blockquote><p>To learn more about singular value decomposition in this context, I recommend reading Jeremy Kun‚Äôs excellent two-part post. <a href="https://jeremykun.com/2016/04/18/singular-value-decomposition-part-1-perspectives-on-linear-algebra/" target="_blank" rel="noopener">Part 1</a> <a href="https://jeremykun.com/2016/05/16/singular-value-decomposition-part-2-theorem-proof-algorithm/" target="_blank" rel="noopener">Part 2</a>.</p></blockquote><p><a href="#v-performing-svd-to-get-a-linear-approximation-of-a-token-subspace">Appendix V</a> walks through the code that uses SVD to find a linear approximation for the subspace corresponding to one token. I did this for all tokens, using the embeddings I learned for the final stages of the transformer. In every case, I was able to find a single vector (1-D subspace) that approximates the token subspace quite well.</p><blockquote><p>For completeness, I also tried this at earlier stages of the transformer and found, as expected, that the linear approximations, even at higher dimensions, didn‚Äôt fit the data as well. The relevant experiments are in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/50_approximation_details.ipynb" target="_blank" rel="noopener">the approximation details notebook</a></p></blockquote><h4 id="mixing-subspace-approximations">Mixing Subspace Approximations <a href="#mixing-subspace-approximations">üîó</a></h4><p>By learning a large number of embeddings for each token and then using SVD on them, we can find one vector for each token that approximates its subspace. Given one of these vectors, any embedding that falls on its span will produce an output distribution that concentrates all the probability mass on the corresponding token. But many of the real transformer outputs we‚Äôve seen distribute the probability mass across several tokens. How do we get from subspaces for individual tokens to embeddings that produce these more diverse distributions?</p><p>We can create embeddings that produce probability distributions where several tokens have substantial probability via linear combinations of the subspace approximation vectors for those tokens. This is the distribution we get when we create an embedding by simply adding the approximation vectors for the subspaces for <code>a</code> and <code>b</code>:</p><p><img src="https://payments.posthaven.com/images/211fa3aed3f5cbbe1a5adf41e014e27068c39ffaf21aff36c833a851b500e211.png" alt=""/></p><p>The sum of subspace approximations vectors for two tokens is an embedding somewhere in between the two subspaces, which results in a final distribution that is the combination of the two tokens.</p><p>Sadly, adding the approximation vectors for <code>a</code> and <code>b</code>, without weighting either one, results in not quite a 50-50 distribution across the two tokens (as shown above). I think there are three reasons for this:</p><ol><li>The approximation vectors are just approximations and not perfect representations of their subspaces.</li><li>The subspace approximation vectors are not perfectly orthogonal. To the extent that <code>a</code>‚Äôs vector has a small component that points in the direction of <code>b</code>, the sum results in an overweighting of <code>b</code>.</li><li>The final linear layer of the model produces logits of different magnitudes for different tokens. For example, given the approximation for <code>a</code>, the logit for <code>a</code> is ~18.2. The logit for <code>b</code> from its approximation is ~19.5.</li></ol><p>Together, these errors accumulate and the softmax function at the very end exaggerates even small differences. For more analysis on the reasoning behind the differences and how they might be compensated for, see <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/60_combining_token_subspaces.ipynb" target="_blank" rel="noopener">the combining token subspaces notebook</a>.</p><p>These imperfections aside, I think we can conclude that <strong>it‚Äôs possible to derive an embedding that produces a distribution for multiple tokens via a linear combination of the approximation vectors for those tokens‚Äô subspaces</strong>.</p><h3 id="putting-it-all-together">Putting it All Together <a href="#putting-it-all-together">üîó</a></h3><p>To summarize where we are, the preceding sections have shown:</p><ul><li>The transformer blocks perform a series of transformations in embedding space.</li><li>Those transformations can be thought of as moving from one point in embedding space to another by adding the feed-forward network output vector to the input embedding.</li><li>Embedding space contains subspaces corresponding to predicting particular tokens and embeddings between subspaces for multiple tokens result in predictions including all those tokens.</li></ul><p>This section adds the final piece, which is the correspondence between what the transformer is doing and what the approximation is doing:</p><ul><li>Within a block, adding the feed-forward network output vector to the input produces an output embedding that better aligns with the embedding subspaces of specific tokens. And <strong>those tokens are the same ones predicted in the approximation</strong>: they‚Äôre the tokens that follow the strings in the training corpus that yield similar feed-forward network outputs to the current prompt.</li></ul><p>Let‚Äôs look at an example that shows this. The following is the output distribution predicted by the approximation for the prompt, <code>med me Aut</code> (query index 33), using only the feed-forward network outputs from the final block:</p><p><img src="https://payments.posthaven.com/images/0a46316fd1ec97000bed4b44242e7aad0809b16acd65a98507ff1b987e313291.png" alt=""/></p><p>Based on the strings in the training corpus with similar feed-forward network outputs at the final block, the approximation predicts <code>o</code> is the most likely next token and <code>h</code> is next.</p><p>Next, we need to look at the feed-forward network output for the prompt in this block and determine which token subspaces it‚Äôs most oriented towards. I‚Äôm going to show a little code here, because I think it‚Äôs the best way to explain what‚Äôs going on. Readers who aren‚Äôt interested in the implementation can focus only on the output.</p><p>First we need to actually grab the feed-forward outputs (we haven‚Äôt needed them so far because we‚Äôve been working with precomputed/prefiltered similarity data). We‚Äôll use some <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/models/transformer-helpers.ipynb" target="_blank" rel="noopener">helper functions</a> that provide easy access to the transformer‚Äôs intermediate representations:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># Tokenize the strings</span>
</span></span><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_strings(prompts)
</span></span><span><span>
</span></span><span><span><span># Embed the tokens</span>
</span></span><span><span>embeddings <span>=</span> accessors<span>.</span>embed_tokens(tokens)
</span></span><span><span>
</span></span><span><span><span># Instantiate TransformerAccessors</span>
</span></span><span><span>accessors <span>=</span> TransformerAccessors(m, device)
</span></span><span><span>
</span></span><span><span><span># Run them through the model with hooks attached that let us look at</span>
</span></span><span><span><span># intermediate values</span>
</span></span><span><span>_, io_accessors <span>=</span> accessors<span>.</span>run_model(embeddings)
</span></span><span><span>
</span></span><span><span><span># Grab the outputs of the ffwd networks at each layer</span>
</span></span><span><span>ffwd_outs <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    io_accessors[block_idx]<span>.</span>output(<span>&#39;ffwd&#39;</span>)[:, <span>-</span><span>1</span>, :]<span>.</span>clone()
</span></span><span><span>    <span>for</span> block_idx <span>in</span> range(n_layer)
</span></span><span><span>])
</span></span><span><span>
</span></span><span><span><span># Free up some memory</span>
</span></span><span><span><span>del</span> io_accessors
</span></span><span><span>_ <span>=</span> gc<span>.</span>collect()
</span></span><span><span>
</span></span><span><span>ffwd_outs<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([6, 20000, 384])
</code></pre><p>To determine which token subspaces the feed-forward network output aligns with, we‚Äôll project it onto the subspace approximation for each token, then determine which projections are most similar to the original vector. To do this, we‚Äôll need to get the projection matrix for the rank 1 approximation to each token subspace:</p><blockquote><p>The code below uses the <code>projection_matrix_for_rank_k_approximation()</code> helper function, defined in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/common/svd-helpers.ipynb" target="_blank" rel="noopener">the SVD helpers notebook</a>.</p></blockquote><blockquote><p>In the case of a rank 1 approximation, the projection isn‚Äôt really necessary. We could just take the cosine similarity with the approximation vector, but I wanted to keep this code general because I tried out higher-dimensional approximations in <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/50_approximation_details.ipynb" target="_blank" rel="noopener">other places</a>.</p></blockquote><div><pre tabindex="0"><code data-lang="python"><span><span>filename_for_token <span>=</span> FilenameForToken(tokenizer)
</span></span><span><span>subspace_dims <span>=</span> <span>1</span>
</span></span><span><span>projection_matrices <span>=</span> torch<span>.</span>stack([
</span></span><span><span>    projection_matrix_for_rank_k_approximation(
</span></span><span><span>        original_matrix<span>=</span>torch<span>.</span>load(
</span></span><span><span>            learned_embeddings_dir <span>/</span>  <span>&#39;no_blocks&#39;</span> <span>/</span> <span>f</span><span>&#34;</span><span>{</span>filename_for_token(token)<span>}</span><span>.pt&#34;</span>,
</span></span><span><span>            map_location<span>=</span>device,
</span></span><span><span>        )[:, <span>0</span>, :],
</span></span><span><span>        k<span>=</span>subspace_dims,
</span></span><span><span>    )
</span></span><span><span>    <span>for</span> token <span>in</span> tokenizer<span>.</span>chars
</span></span><span><span>])
</span></span></code></pre></div><p>Now we‚Äôll perform the projections and find the top 5 most similar ones to the original feed-forward output vector:</p><div><pre tabindex="0"><code data-lang="python"><span><span>projections <span>=</span> projection_matrices <span>@</span> ffwd_outs[block_idx, q_idx, :]
</span></span><span><span>values, indices <span>=</span> torch<span>.</span>topk(
</span></span><span><span>    F<span>.</span>cosine_similarity(projections, ffwd_outs[block_idx][q_idx], dim<span>=-</span><span>1</span>),
</span></span><span><span>    k<span>=</span><span>5</span>,
</span></span><span><span>    dim<span>=</span><span>0</span>,
</span></span><span><span>)
</span></span><span><span>tokens <span>=</span> [tokenizer<span>.</span>chars[i<span>.</span>item()] <span>for</span> i <span>in</span> indices]
</span></span><span><span>list(zip(tokens, values<span>.</span>tolist()))
</span></span></code></pre></div><pre tabindex="0"><code>[(&#39;o&#39;, 0.5074884295463562),
 (&#39;h&#39;, 0.40787822008132935),
 (&#39;i&#39;, 0.26926180720329285),
 (&#39;u&#39;, 0.22823508083820343),
 (&#39;y&#39;, 0.20325089991092682)]
</code></pre><p>It turns out that <code>o</code> and <code>h</code> are the most similar, indicating that the feed-forward network output is most oriented towards the subspaces for these tokens. And these are the same tokens that the approximation predicted from the strings with similar feed-forward network outputs (see the distribution above).</p><p>Another example, this time looking at query index 36 (<code>if and thy</code>), but staying in the final block:</p><p><img src="https://payments.posthaven.com/images/fb2e608eb48c085de00f28831641ff4d49f7f3fd63b198fc3fc08d02a3cc7c45.png" alt=""/></p><div><pre tabindex="0"><code data-lang="python"><span><span>projections <span>=</span> projection_matrices <span>@</span> ffwd_outs[block_idx, q_idx, :]
</span></span><span><span>values, indices <span>=</span> torch<span>.</span>topk(
</span></span><span><span>    F<span>.</span>cosine_similarity(projections, ffwd_outs[block_idx][q_idx], dim<span>=-</span><span>1</span>),
</span></span><span><span>    k<span>=</span><span>5</span>,
</span></span><span><span>    dim<span>=</span><span>0</span>,
</span></span><span><span>)
</span></span><span><span>tokens <span>=</span> [tokenizer<span>.</span>chars[i<span>.</span>item()] <span>for</span> i <span>in</span> indices]
</span></span><span><span>list(zip(tokens, values<span>.</span>tolist()))
</span></span></code></pre></div><pre tabindex="0"><code>[(&#39; &#39;, 0.5869003534317017),
 (&#39;s&#39;, 0.47689366340637207),
 (&#39;\n&#39;, 0.38412901759147644),
 (&#39;$&#39;, 0.23048195242881775),
 (&#39;a&#39;, 0.21783535182476044)]
</code></pre><p>Here <code></code>(space), <code>s</code>, and <code>\n</code> (newline) were the tokens predicted from what follows the strings with similar feed-forward outputs, and indeed these are the token subspaces most aligned with the prompt‚Äôs feed-forward output.</p><h4 id="aggregate-performance">Aggregate Performance <a href="#aggregate-performance">üîó</a></h4><p>In the previous section, I purposely picked examples that exhibit strong correlation between the approximation‚Äôs predictions and the most aligned subspaces, to illustrate the point most clearly. Of course, there are other examples for which the correlation is less strong. Rather than looking at specific cases, let‚Äôs try to get a sense of how well the correlation holds up across all 20,000 prompts.</p><p>This immediately leads to a question: what is the right measure of aggregate performance? Unfortunately, even if the hypothesis - that the prompt‚Äôs feed-forward output aligns with the subspaces for tokens predicted from the strings with similar feed forward outputs - is true, a few practical issues make it difficult to demonstrate objectively:</p><ul><li>We don‚Äôt have exact definitions of the token subspaces, just imperfect, linear approximations.</li><li>Magnitudes don‚Äôt line up: the tokens with the most probability mass in the approximation‚Äôs predictions don‚Äôt always correspond to the subspaces with the greatest cosine similarity (because of the imperfect approximations, because the adjustment required may be bigger or smaller for some tokens vs others based on the input embedding‚Äôs current alignment, because, as explained in the <a href="#mixing-subspace-approximations">Mixing Subspace Approximations</a> section, the model is more ‚Äúsensitive‚Äù to some tokens than others).</li></ul><p>Given these impediments, we can‚Äôt just do something simple like normalizing the cosine similarities and computing Hellinger distance with the predicted probability distribution.</p><p>Instead, we need to devise a criterion on which to judge whether the data from a particular prompt supports the hypothesis or not. Then we can evaluate aggregate performance by how many of the 20,000 prompts satisfy the criterion. I experimented with several different approaches and in the end came up with this candidate criterion:</p><p>High-level description: <em>Do the subspaces for the tokens containing 90% of the probability mass in the approximation‚Äôs predictions appear in the top half of all token subspaces when ranked by cosine similarity with the prompt‚Äôs feed-forward output vector?</em></p><p>Exact definition:</p><ul><li>Define <code>top_n</code> as the number of tokens required to cover at least 90% of the probability mass in the approximation‚Äôs predictions for this prompt.</li><li>Define <code>n_subspaces</code> as <code>tokenizer.vocab_size // 2</code> (32, based on our 65-token vocabulary).</li><li>Determine: Are the subspaces for the first <code>top_n</code> tokens predicted by the approximation in the first <code>n_subspaces</code> subspaces ranked by cosine similarity with the prompt‚Äôs feed-forward output vector?</li></ul><p>Admittedly, this is an arbitrary definition and reasonable people could debate any of the specifics. But I do think it gives as an indication of whether the data from a particular example prompt supports the hypothesis, while allowing for some of the measurement challenges noted above.</p><p>I evaluated this criteria at three places: the outputs of blocks 6, 5, and 4, using projection matrices derived from learned embeddings at each of these places.</p><blockquote><p>I didn‚Äôt evaluate at earlier blocks because the GPU time required to learn embeddings at those blocks became prohibitive. The further back in the model, the bigger the computation graph that the learning algorithm needs to optimize over.</p></blockquote><p>The table below shows the results:</p><blockquote><p>The code that produced these results appears at the end of <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/50_approximation_details.ipynb" target="_blank" rel="noopener">the approximation details notebook</a></p></blockquote><table><thead><tr><th>Block</th><th># of Prompts Satisfying Criterion</th></tr></thead><tbody><tr><td>6</td><td>16357 (81.78%)</td></tr><tr><td>5</td><td>10142 (50.71%)</td></tr><tr><td>4</td><td>7760 (38.80%)</td></tr></tbody></table><p>These numbers aren‚Äôt exactly a ringing endorsement. As expected, they get worse the further back we go, probably due to the increased non-linearity.</p><p><a id="use-only-final-subspaces"></a>
What if we always used the subspace approximations from the very end of the transformer (which are likely to be the most linear), even when comparing against feed-forward network outputs from earlier blocks? The results get better:</p><table><thead><tr><th>Block</th><th># of Prompts Satisfying Criterion</th></tr></thead><tbody><tr><td>6</td><td>16357 (81.78%)</td></tr><tr><td>5</td><td>13652 (68.26%)</td></tr><tr><td>4</td><td>11630 (58.15%)</td></tr><tr><td>3</td><td>11469 (57.34%)</td></tr><tr><td>2</td><td>10404 (52.02%)</td></tr><tr><td>1</td><td>9942 (49.71%)</td></tr></tbody></table><blockquote><p>Like many good findings, this one resulted from a bug. I accidentally ran the analysis using the projection matrices for the final part of the transformer with the feed-forward network outputs from earlier blocks and was surprised when the numbers turned out to be so good.</p></blockquote><p>It‚Äôs valid to use the subspace approximations (and corresponding projection matrices) from the end of the transformer at earlier stages. All blocks operate in the same embedding space and each one seems to make a small refinement on the output of its predecessors, rather than wild changes in direction. So if any block‚Äôs feed-forward network output adjusts an embedding towards the subspaces for a set of tokens as defined at the end of the transformer, it is likely also adjusting it towards whatever the subspaces would be for those same tokens at the block where it operates.</p><blockquote><p>The <a href="https://www.lesswrong.com/posts/AcKRB8wDpdaN6v6ru/interpreting-gpt-the-logit-lens" target="_blank" rel="noopener">logit lens post</a>, in the section ‚Äúwhy? / is this surprising?‚Äù provides an explanation that supports this idea. In summary, the residual connections encourage the transformer to learn weights that operate within the same basis across blocks and the use of weight decay in training results in a computation that‚Äôs spread out over as many layers as possible, with each layer making only a small, incremental change.</p></blockquote><p>To put these numbers in perspective, I investigated how likely it would be for the criterion I‚Äôve defined here to be satisfied by chance. In other words, if we assume the hypothesis is false and that the cosine similarities between the feed-forward network output and the token subspace approximation vectors are random, rather than expressing meaningful relationships, how likely would it be for the criterion to still be satisfied?</p><p>I ran a simulation of this, taking care to ensure that the distribution of randomly generated cosine similarities matches the real data, among other details. The implementation is at the end of <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/50_approximation_details.ipynb" target="_blank" rel="noopener">the approximation details notebook</a>. The final results are:</p><table><thead><tr><th>Block</th><th>Likely % of Prompts Satisfying Criteria By Chance</th></tr></thead><tbody><tr><td>6</td><td>20.76% ¬± 0.25%</td></tr><tr><td>5</td><td>20.55% ¬± 0.26%</td></tr><tr><td>4</td><td>18.37% ¬± 0.24%</td></tr><tr><td>3</td><td>18.20% ¬± 0.24%</td></tr><tr><td>2</td><td>17.04% ¬± 0.23%</td></tr><tr><td>1</td><td>16.31% ¬± 0.23%</td></tr></tbody></table><p>So the best performance numbers we have are clearly much better than chance. But in fairness, they‚Äôre still not a slam dunk.</p><p>Even when we use approximations for the most linear subspaces we have, I think there is still a lot of noise in the measurement, for all the reasons outlined earlier in this section. Personally, I take the numbers to be overall supportive of the hypothesis, at least directionally, though I wish the evidence was more conclusive.</p><h3 id="final-summary-of-correspondence-between-transformer-and-approximation">Final Summary of Correspondence Between Transformer and Approximation <a href="#final-summary-of-correspondence-between-transformer-and-approximation">üîó</a></h3><p>The analyses in this post point towards two ideas. First, that the approximation and the transformer produce similar outputs. Second, that there is a correspondence between the approximation procedure and what the transformer is doing. I think the evidence for the first idea is quite strong. The evidence for the second is less clear cut, but still suggests it‚Äôs probably at least partially right.</p><p>To close, I want to provide a high-level summary of what I think that correspondence is, even if I can‚Äôt yet demonstrate it more definitively:</p><table><thead><tr><th>Concept</th><th>Transformer</th><th>Approximation</th></tr></thead><tbody><tr><td>Prompts map to classes of strings in the training corpus.</td><td>The transformer learns an embedding scheme, along with weights in its self-attention and feed-forward networks, that cause strings in the training corpus with similar characteristics to produce similar output values. Prompts that share those characteristics also produce similar output values.</td><td>The approximation performs the same mapping as the transformer by examining the feed-forward network outputs from all substrings in the training corpus and identifying the ones similar to the outputs from a given prompt.</td></tr><tr><td>Predictions for the tokens likely to follow a prompt derive from the frequency distribution of tokens that follow strings in the training corpus that produce feed-forward network output values similar to those of the prompt.</td><td>A feed-forward network output is a compressed, latent representation, in the embedding space, of the frequency distribution of the tokens that follow strings in the training corpus that produce similar outputs. The weights in the final linear layer map the latent representation into logit space such that it become the correct probability distribution after applying the softmax operation.</td><td>The approximation reconstructs the same frequency distribution manually, by looking up the strings identified as having similar outputs in the training corpus and counting the tokens that follow them. Normalizing the frequency distribution turns it into a probability distribution.</td></tr><tr><td>Final output is a weighted sum of predictions from each block.</td><td>As shown <a href="#transformation-via-vector-addition">earlier</a>, the transformer output is roughly the vector sum of all feed-forward network outputs and the input embedding. The learned weights in the layers within a block determine the magnitude and direction of the output and thus how much it influences the overall direction of the final sum.</td><td>The approximation performs a weighted sum of the distributions determined for each block. The weights control the degree of influence of any given block and are manually selected to produce results as close to the transformer‚Äôs as possible.</td></tr></tbody></table><h3 id="what-about-attention">What About Attention? <a href="#what-about-attention">üîó</a></h3><p>I began this post by observing that most explanations of how transformers work focus on attention but don‚Äôt say how attention results turn into the final predictions. I may be guilty of the opposite: I‚Äôve written at length about how the transformers produce their output probabilities and said very little about attention.</p><p>To wrap up the analysis, I‚Äôd like to rectify this with a few words about attention. In the mechanism I‚Äôve laid out, whether executed in the form of the approximation or the transformer, a key operation is mapping the prompt to a class of strings from the training corpus at each block. Predictions for the next token follow directly from the distribution of tokens that follow those strings in the training corpus. <strong>Making good predictions depends on mapping the prompt to the right class of training corpus strings. And that is the job of self-attention.</strong></p><p>The self-attention layers learn to identify patterns across the tokens that make up a prompt. Those patterns might be simple, such as a common sequence appearing at the beginning or end of the prompt (for example, as we saw <a href="#demo-my-proposal-in-action">earlier</a>, strings that end in ‚Äòy l‚Äô). They can also be more general: instead of matching specific tokens, they might match <em>kinds</em> of tokens, such as vowels or capitals, in specific places. The learned weights in the attention heads determine which patterns they respond to, and thus which strings in the training corpus produce similar values. The output of the self-attention heads, when passed through the feed-forward network, yield representations in embedding space that encode information about the distribution of tokens in the training corpus that follow those strings.</p><p>Because the transformer has multiple blocks and each block has multiple attention heads (6 blocks and 6 heads per block in the one we looked at), it‚Äôs possible to evaluate each prompt against a large number of different potential patterns. The richness and diversity of the patterns that the attention heads can identify gives the transformer its predictive power.</p><h2 id="closing-thoughts">Closing Thoughts <a href="#closing-thoughts">üîó</a></h2><p>I started this project because I wanted to understand the transformer architecture. It‚Äôs given me a satisfying explanation of what at least one transformer is doing, but has been even more fruitful as an exercise in learning how to learn. This was my first foray into an open-ended ML research project on my own. It taught me how to interrogate the internals of models, how to set up experiments to answer questions, and, perhaps most importantly, how to keep moving the project forward when I felt stuck.</p><p>Language models have always seemed magical to me, from the first time I used ChatGPT. I wondered if finding a reductive explanation for what happens internally would rob them of their magic. In fact, I think the opposite has happened. I‚Äôve come to appreciate the beauty in an elegantly simple mechanism that produces such rich complexity in its outputs.</p><p>I don‚Äôt know whether the results I found here have any generality beyond the small transformer I trained or if any of it will be of use to anyone else. Regardless, it‚Äôs been a joy to do this work and I‚Äôm grateful to have had the things I needed along the way: time, resources, and endless support from my family and mentors.</p><h2 id="appendices">Appendices <a href="#appendices">üîó</a></h2><h3 id="i-model-details">I: Model Details <a href="#i-model-details">üîó</a></h3><p>Some notable specs:</p><ul><li>Vocabulary size: 65 (the unique characters in the TinyShakespeare dataset)</li><li>Embedding size (<code>n_embed</code>): 384</li><li>Number of transformer blocks (<code>n_layer</code>): 6</li><li>Number of attention heads (<code>n_head</code>): 6</li><li>Context window size (<code>block_size</code>): 256</li></ul><p>The feed-forward networks comprise over 65% of the total trainable parameters:</p><div><pre tabindex="0"><code data-lang="python"><span><span>all_trainable_params <span>=</span> [p <span>for</span> p <span>in</span> m<span>.</span>parameters() <span>if</span> p<span>.</span>requires_grad]
</span></span><span><span>n_all_trainable_params <span>=</span> sum([np<span>.</span>prod(p<span>.</span>size()) <span>for</span> p <span>in</span> all_trainable_params])
</span></span><span><span>
</span></span><span><span>ffwd_trainable_params <span>=</span> [
</span></span><span><span>    p
</span></span><span><span>    <span>for</span> block_idx <span>in</span> range(n_layer)
</span></span><span><span>    <span>for</span> p <span>in</span> m<span>.</span>blocks[block_idx]<span>.</span>ffwd<span>.</span>parameters()
</span></span><span><span>    <span>if</span> p<span>.</span>requires_grad
</span></span><span><span>]
</span></span><span><span>n_ffwd_trainable_params <span>=</span> sum([np<span>.</span>prod(p<span>.</span>size()) <span>for</span> p <span>in</span> ffwd_trainable_params])
</span></span><span><span>
</span></span><span><span>print(
</span></span><span><span>    <span>f</span><span>&#34;</span><span>{</span>n_ffwd_trainable_params<span>:</span><span>,</span><span>}</span><span> ffwd params out of </span><span>{</span>n_all_trainable_params<span>:</span><span>,</span><span>}</span><span> total params (</span><span>{</span>n_ffwd_trainable_params <span>/</span> n_all_trainable_params<span>:</span><span>.2%</span><span>}</span><span>)&#34;</span>
</span></span><span><span>)
</span></span></code></pre></div><pre tabindex="0"><code>7,089,408 ffwd params out of 10,788,929 total params (65.71%)
</code></pre><h3 id="ii-evaluation-of-main-model-vs-3-alternate-models">II: Evaluation of Main Model vs 3 Alternate Models <a href="#ii-evaluation-of-main-model-vs-3-alternate-models">üîó</a></h3><p>As described in the <a href="#evaluating-the-approximation">Evaluation section</a>, I trained the same transformer architecture used for the main model in this post three additional times, starting from a different random seed each time. This appendix shows the code used to measure the average Hellinger distance between the output of the main models and each of the three alternates, across the 20,000 sample prompts. The results provide a plausible lower bound for the threshold Hellinger distance that indicates a meaningful change in an output probability distribution.</p><p>First, we instantiate the three alternate models from their saved weights:</p><div><pre tabindex="0"><code data-lang="python"><span><span>alt_models_dir <span>=</span> environment<span>.</span>data_root <span>/</span> <span>&#39;alternate-models/model-training/20240112-training/outputs/&#39;</span>
</span></span><span><span><span>assert</span> alt_models_dir<span>.</span>exists(), <span>&#34;Alternate models directory does not exist. Run the training code in ../experiments/alternate-models.ipynb.&#34;</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># Instantiate the three alternative trained models</span>
</span></span><span><span>m_alt1, _ <span>=</span> create_model_and_tokenizer(
</span></span><span><span>    saved_model_filename<span>=</span>alt_models_dir <span>/</span> <span>&#39;shakespeare-20240112-1.pt&#39;</span>,
</span></span><span><span>    dataset<span>=</span>ts,
</span></span><span><span>    device<span>=</span>device,
</span></span><span><span>)
</span></span><span><span>m_alt2, _ <span>=</span> create_model_and_tokenizer(
</span></span><span><span>    saved_model_filename<span>=</span>alt_models_dir <span>/</span> <span>&#39;shakespeare-20240112-2.pt&#39;</span>,
</span></span><span><span>    dataset<span>=</span>ts,
</span></span><span><span>    device<span>=</span>device,
</span></span><span><span>)
</span></span><span><span>m_alt3, _ <span>=</span> create_model_and_tokenizer(
</span></span><span><span>    saved_model_filename<span>=</span>alt_models_dir <span>/</span> <span>&#39;shakespeare-20240112-3.pt&#39;</span>,
</span></span><span><span>    dataset<span>=</span>ts,
</span></span><span><span>    device<span>=</span>device,
</span></span><span><span>)
</span></span></code></pre></div><p>Next, we feed the input tokens into the original model and the three alternate models and get their output probability distributions:</p><div><pre tabindex="0"><code data-lang="python"><span><span>tokens <span>=</span> encoding_helpers<span>.</span>tokenize_strings(prompts)
</span></span><span><span>
</span></span><span><span>model_probs <span>=</span> get_model_probs(m, tokens)
</span></span><span><span>alt_model_probs1 <span>=</span> get_model_probs(m_alt1, tokens)
</span></span><span><span>alt_model_probs2 <span>=</span> get_model_probs(m_alt2, tokens)
</span></span><span><span>alt_model_probs3 <span>=</span> get_model_probs(m_alt3, tokens)
</span></span></code></pre></div><p>Now we can compute the Hellinger distance between the outputs from the three alternative models and the outputs from the original model. Remember that each of the model probabilities tensors (<code>model_probs</code> and <code>alt_model_probs*</code>) is a 20,000x65 tensor i.e. 20,000 probability distributions of 65 elements each.</p><p>We‚Äôre computing the Hellinger distance between those probability distributions. So for each alternative model, we end up with 20,000 Hellinger distance values. These values tell us, for each prompt, how the probability distribution for the next token predicted by one of the alternate models differed from the probability distribution predicted by the original model.</p><div><pre tabindex="0"><code data-lang="python"><span><span>h_alt1 <span>=</span> hellinger_distance(model_probs, alt_model_probs1)
</span></span><span><span>h_alt2 <span>=</span> hellinger_distance(model_probs, alt_model_probs2)
</span></span><span><span>h_alt3 <span>=</span> hellinger_distance(model_probs, alt_model_probs3)
</span></span></code></pre></div><p>With the Hellinger distances computed, we can look at aggregate stats:</p><div><pre tabindex="0"><code data-lang="python"><span><span>h_alts <span>=</span> torch<span>.</span>stack([h_alt1, h_alt2, h_alt3], dim<span>=</span><span>1</span>)
</span></span><span><span>h_alts<span>.</span>mean(dim<span>=</span><span>0</span>), h_alts<span>.</span>std(dim<span>=</span><span>0</span>), h_alts<span>.</span>min(dim<span>=</span><span>0</span>)<span>.</span>values, h_alts<span>.</span>max(dim<span>=</span><span>0</span>)<span>.</span>values
</span></span></code></pre></div><pre tabindex="0"><code>(tensor([0.1064, 0.1057, 0.1053]),
 tensor([0.0823, 0.0817, 0.0828]),
 tensor([0.0005, 0.0008, 0.0008]),
 tensor([0.8351, 0.7881, 0.8743]))
</code></pre><p>For all three alternate models, the average Hellinger distance was ~0.11 ¬± 0.08. All had very small minimums (&lt;= 0.0008) and maximums around ~0.80.</p><h3 id="iii-the-output-embeddings-norm-doesnt-matter-because-of-the-final-layernorm">III: The Output Embedding‚Äôs Norm Doesn‚Äôt Matter Because of the Final LayerNorm <a href="#iii-the-output-embeddings-norm-doesnt-matter-because-of-the-final-layernorm">üîó</a></h3><p>This appendix demonstrates the assertion from the <a href="#transformation-via-vector-addition">Transformation via Vector Addition</a> that the norm of the output embeddings from the final transformer block does not matter, because of the LayerNorm before the final linear layer.</p><p>To begin, let‚Äôs grab the final block outputs for the first 1000 prompts:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># Get the block outputs for the first 1000 prompts</span>
</span></span><span><span>
</span></span><span><span>tokens_sample <span>=</span> encoding_helpers<span>.</span>tokenize_strings(prompts[:<span>1000</span>])
</span></span><span><span>_, io_accessors_sample <span>=</span> accessors<span>.</span>run_model(accessors<span>.</span>embed_tokens(tokens_sample))
</span></span><span><span>
</span></span><span><span>final_block_outputs <span>=</span> io_accessors_sample[<span>-</span><span>1</span>]<span>.</span>output(<span>&#39;.&#39;</span>)[:, <span>-</span><span>1</span>, :]<span>.</span>clone()
</span></span><span><span>
</span></span><span><span><span>del</span> io_accessors_sample
</span></span><span><span>_ <span>=</span> gc<span>.</span>collect()
</span></span><span><span>
</span></span><span><span>final_block_outputs<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([1000, 384])
</code></pre><p>Next, let‚Äôs create a copy of those outputs scaled by a factor of 10:</p><div><pre tabindex="0"><code data-lang="python"><span><span>scaled_final_block_outputs <span>=</span> final_block_outputs <span>*</span> <span>10</span>
</span></span><span><span>scaled_final_block_outputs<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([1000, 384])
</code></pre><p>Comparing average norms, we see that those of the scaled outputs indeed are 10 times bigger:</p><div><pre tabindex="0"><code data-lang="python"><span><span>final_block_outputs<span>.</span>norm(dim<span>=-</span><span>1</span>)<span>.</span>mean(), scaled_final_block_outputs<span>.</span>norm(dim<span>=-</span><span>1</span>)<span>.</span>mean()
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(22.8909), tensor(228.9091))
</code></pre><p>Now, let‚Äôs put both the original and scaled outputs through the final LayerNorm of the model and calculate the average norm of the results:</p><div><pre tabindex="0"><code data-lang="python"><span><span>layer_normed_original <span>=</span> m<span>.</span>ln_f(final_block_outputs)<span>.</span>detach()
</span></span><span><span>layer_normed_scaled <span>=</span> m<span>.</span>ln_f(scaled_final_block_outputs)<span>.</span>detach()
</span></span><span><span>
</span></span><span><span>layer_normed_original<span>.</span>norm(dim<span>=-</span><span>1</span>)<span>.</span>mean(), layer_normed_scaled<span>.</span>norm(dim<span>=-</span><span>1</span>)<span>.</span>mean()
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(23.1262), tensor(23.1263))
</code></pre><p>They‚Äôre virtually identical.</p><p>In the preceding example, the output norms were so close to identical because the two inputs differed only in scale: they had the same direction, or cosine similarity of 1. Vectors that have different norms and different directions will emerge from the LayerNorm with norms that are still quite similar but a little further apart.</p><p>To see an example, we can add a little noise to one of the vectors and then scale it:</p><div><pre tabindex="0"><code data-lang="python"><span><span>original_vector <span>=</span> final_block_outputs[<span>0</span>]
</span></span><span><span>
</span></span><span><span><span># Add some random noise to the original vector</span>
</span></span><span><span>torch<span>.</span>manual_seed(<span>42</span>) <span># keep the noise consistent</span>
</span></span><span><span>comparison_vector <span>=</span> original_vector <span>+</span> torch<span>.</span>randn_like(original_vector) <span>*</span> <span>0.1</span>
</span></span><span><span>
</span></span><span><span><span># And scale it</span>
</span></span><span><span>comparison_vector <span>=</span> comparison_vector <span>/</span> comparison_vector<span>.</span>norm()
</span></span><span><span>comparison_vector <span>*=</span> <span>10</span> <span>*</span> original_vector<span>.</span>norm()
</span></span><span><span>
</span></span><span><span>original_vector<span>.</span>norm(), comparison_vector<span>.</span>norm(), F<span>.</span>cosine_similarity(original_vector, comparison_vector, dim<span>=-</span><span>1</span>)
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(23.7909), tensor(237.9092), tensor(0.9967))
</code></pre><p>The <code>comparison_vector</code>‚Äôs norm is exactly 10x that of <code>original_vector</code>, but they‚Äôre not perfectly aligned in direction, though still quite close.</p><div><pre tabindex="0"><code data-lang="python"><span><span>m<span>.</span>ln_f(original_vector)<span>.</span>detach()<span>.</span>norm(), m<span>.</span>ln_f(comparison_vector)<span>.</span>detach()<span>.</span>norm()
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(23.1496), tensor(23.1671))
</code></pre><p>Their norms after layer norm are close but further apart than in the previous example.</p><p>If we add a lot more noise, we‚Äôll end up with two vectors with quite different directions:</p><div><pre tabindex="0"><code data-lang="python"><span><span>original_vector <span>=</span> final_block_outputs[<span>0</span>]
</span></span><span><span>
</span></span><span><span><span># Add some random noise to the original vector</span>
</span></span><span><span>torch<span>.</span>manual_seed(<span>4211</span>) <span># keep the noise consistent</span>
</span></span><span><span>comparison_vector <span>=</span> original_vector <span>+</span> torch<span>.</span>randn_like(original_vector) <span>*</span> <span>2</span>
</span></span><span><span>
</span></span><span><span><span># And scale it</span>
</span></span><span><span>comparison_vector <span>=</span> comparison_vector <span>/</span> comparison_vector<span>.</span>norm()
</span></span><span><span>comparison_vector <span>*=</span> <span>10</span> <span>*</span> original_vector<span>.</span>norm()
</span></span><span><span>
</span></span><span><span>original_vector<span>.</span>norm(), comparison_vector<span>.</span>norm(), F<span>.</span>cosine_similarity(original_vector, comparison_vector, dim<span>=-</span><span>1</span>)
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(23.7909), tensor(237.9093), tensor(0.5178))
</code></pre><p>But their norms after layer norm are only a little more divergent:</p><div><pre tabindex="0"><code data-lang="python"><span><span>m<span>.</span>ln_f(original_vector)<span>.</span>detach()<span>.</span>norm(), m<span>.</span>ln_f(comparison_vector)<span>.</span>detach()<span>.</span>norm()
</span></span></code></pre></div><pre tabindex="0"><code>(tensor(23.1496), tensor(23.0546))
</code></pre><p>So in summary:</p><ul><li>The LayerNorm will remove substantial differences in input norms.</li><li>Norms of the outputs from the LayerNorm will vary a little depending on how closely aligned the input vectors were.</li></ul><h3 id="iv-summary-of-experiment-on-relative-impact-of-self-attention-and-feed-forward-network-outputs">IV: Summary of Experiment on Relative Impact of Self-Attention and Feed Forward Network Outputs <a href="#iv-summary-of-experiment-on-relative-impact-of-self-attention-and-feed-forward-network-outputs">üîó</a></h3><p>The <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/70_embedding_adjustments.ipynb" target="_blank" rel="noopener">embedding adjustments analysis notebook</a> contains the implementation of an experiment to understand the relative impact of the self-attention outputs and the feed-forward network outputs on the final output of the transformer. This appendix summarizes the experiment and the results.</p><p>Experiment procedure:</p><ul><li>I ran all 20,000 prompts through the model and captured the final output probability distributions as well as the intermediate self-attention outputs, feed-forward network outputs, and final block outputs for each block.</li><li>For each block, I then ran two tests. First, instead of sending the block output as normally implemented (<code>x + sa_out + ffwd_out</code>, as shown <a href="#block-logic-with-intermediates">earlier</a>) to the next stage of the model, I sent a version that omits the self-attention output i.e. just <code>x + ffwd_out</code>, and saved the final output probability distribution that resulted. Then, I did the same thing but removed the feed-forward network output instead, sending on just <code>x + sa_out</code>.</li><li>I then calculated the Hellinger distance between the probability distribution produced with the regular block output and that produced by each of the two modifications.</li></ul><p>The table below shows the results, averaged across all 20,000 prompts:</p><blockquote><p>For the implementation of this analysis, see <a href="https://github.com/spather/transformer-experiments/blob/master/nbs/analyses/70_embedding_adjustments.ipynb" target="_blank" rel="noopener">embedding adjustments analysis notebook</a></p></blockquote><table><thead><tr><th>Block</th><th>H(output(<code>x+sa_out+ffwd_out</code>), output(<code>x+ffwd_out</code>))</th><th>H(output(<code>x+sa_out+ffwd_out</code>), output(<code>x+sa_out</code>))</th></tr></thead><tbody><tr><td>1</td><td>0.11 ¬± 0.07</td><td>0.70 ¬± 0.17</td></tr><tr><td>2</td><td>0.07 ¬± 0.04</td><td>0.19 ¬± 0.11</td></tr><tr><td>3</td><td>0.09 ¬± 0.07</td><td>0.15 ¬± 0.10</td></tr><tr><td>4</td><td>0.06 ¬± 0.05</td><td>0.13 ¬± 0.10</td></tr><tr><td>5</td><td>0.04 ¬± 0.03</td><td>0.14 ¬± 0.10</td></tr><tr><td>6</td><td>0.03 ¬± 0.03</td><td>0.17 ¬± 0.10</td></tr></tbody></table><blockquote><p>Remember that Hellinger distance ranges between 0 and 1, with 0 meaning identical and 1 meaning no overlap. A larger Hellinger distance in this table means a larger divergence between the experiment output and the normal transformer output.</p></blockquote><p>The effect is most pronounced in the first block: omitting the feed-forward network output results in an almost completely different probability distribution (H = 0.70) but omitting the self-attention output results in a very similar distribution (H = 0.11). Across the rest of the layers, the difference is less dramatic, but the feed-forward network output always has the larger impact.</p><blockquote><p>Though I think these results support the notion that an approximation based only on feed-forward network outputs can produce similar results to the transformer, it would be interesting to see if the approximation would improve if we include the self-attention outputs, particularly for some of the intermediate layers. But I‚Äôm leaving that as an area for future investigation.</p></blockquote><h3 id="v-performing-svd-to-get-a-linear-approximation-of-a-token-subspace">V: Performing SVD to Get a Linear Approximation of a Token Subspace <a href="#v-performing-svd-to-get-a-linear-approximation-of-a-token-subspace">üîó</a></h3><p>This appendix walks through an example of how we can find a linear approximation for a token subspace using SVD. First, let‚Äôs load all the embeddings learned for the token <code>a</code> at the output of the last block of the transformer (input to the final layer norm and linear layer):</p><div><pre tabindex="0"><code data-lang="python"><span><span>learned_embeddings_dir <span>=</span> environment<span>.</span>data_root <span>/</span> <span>&#39;learned_embeddings&#39;</span>
</span></span><span><span>multi_emb_a <span>=</span> torch<span>.</span>load(learned_embeddings_dir <span>/</span> <span>&#39;no_blocks&#39;</span> <span>/</span> <span>&#39;lower_a.pt&#39;</span>, map_location<span>=</span>device)
</span></span><span><span>multi_emb_a<span>.</span>shape
</span></span></code></pre></div><pre tabindex="0"><code>torch.Size([100, 1, 384])
</code></pre><p>We‚Äôve got 100 different 384-dimensional embedding vectors. Each one, when given as input to the final blocks in the transformer, produces an output distribution that assigns nearly all the probability mass to the token, <code>a</code>. Each one can be thought of as a point in the subspace for token <code>a</code>.</p><p>We can stack these embeddings form a 100x384 matrix:</p><p>$$
\begin{bmatrix}
e_{1,1} &amp; e_{1,2} &amp; \dots &amp; e_{1,384} \\
e_{2,1} &amp; e_{2,2} &amp; \dots &amp; e_{2,384} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
e_{100,1} &amp; e_{100,2} &amp; \dots &amp; e_{100,384}
\end{bmatrix}
$$</p><p>Next, we can run SVD on this matrix:</p><div><pre tabindex="0"><code data-lang="python"><span><span>_, S, V <span>=</span> torch<span>.</span>linalg<span>.</span>svd(multi_emb_a[:, <span>-</span><span>1</span>, :])
</span></span></code></pre></div><p>For this analysis, we‚Äôre only interested in the singular values (<code>S</code>) and the right singular vectors (<code>V</code>). We can plot the singular values:</p><div><pre tabindex="0"><code data-lang="python"><span><span>_ <span>=</span> plt<span>.</span>plot(S<span>.</span>numpy(), <span>&#39;-o&#39;</span>)
</span></span></code></pre></div><p><img src="https://payments.posthaven.com/images/ec5755d7859f77e55c3bf34a432c33226741616e9b493b5eec96c716ac1e7fe5.png" alt=""/></p><p>The first singular value is much larger (over 6x) than the next, which suggests the first right singular vector alone might be a good approximation for the subspace that predicts token <code>a</code>. We can test what gets predicted when we use this first right singular vector as an embedding:</p><div><pre tabindex="0"><code data-lang="python"><span><span>v0a <span>=</span> adjust_singular_vector_sign(V[<span>0</span>], multi_emb_a[:, <span>-</span><span>1</span>, :])
</span></span><span><span>logits <span>=</span> LogitsWrapper(accessors<span>.</span>logits_from_embedding(unsqueeze_emb(v0a)), tokenizer)
</span></span><span><span>logits<span>.</span>plot_probs(title<span>=</span><span>&#39;Next Token Probability Distribution from First Right Singular Vector of embeddings for Token &#34;a&#34;&#39;</span>)
</span></span></code></pre></div><p><img src="https://payments.posthaven.com/images/968e8e424522937d5366586abd902715e1cdf771fddbb2d4a36144cbe07746e2.png" alt=""/></p><p>In this distribution, <code>a</code> has probability near 1 and every other token has probability near 0. So the first right singular vector is effectively another embedding that produces an output predicting <code>a</code> with near certainty.</p><p>But it‚Äôs different from the other 100 learned embeddings in an important way: it‚Äôs the vector that is best aligned with <em>all</em> of them. More formally, it‚Äôs the vector that minimizes the squared distance to all 100 other embedding vectors. In this way, the first right singular vector is like a good summary of the embedding vectors we started from.</p><p>The first right singular vector is a unit vector (as are all the singular vectors):</p><pre tabindex="0"><code>tensor(1.0000)
</code></pre><p>Any vector along its span will produce an output distribution predicting <code>a</code>, similar to the one above (see <a href="#iii-the-output-embeddings-norm-doesnt-matter-because-of-the-final-layernorm">Appendix III</a> for an explanation of why the transformer output is invariant to the scale of the final embedding). So the span of this vector is a good, linear approximation to the subspace for token <code>a</code>.</p><p>The same results we saw here for token <code>a</code> hold for the other tokens too. For each, if we stack all the learned embeddings and perform SVD, we find that the first right singular vector forms a good linear approximation of the token subspace.</p></div></section></div></div>
  </body>
</html>
