<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/phoenix-files/a-liveview-is-a-process/">Original</a>
    <h1>A LiveView Is a Process</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/jason.webp" alt="Jason Stiebs" srcset=""/> <dl> <dt>Name</dt> <dd> Jason Stiebs </dd> <dt>Social Media</dt> <dd> <a href="https://twitter.com/peregrine" target="_blank" rel="noopener noreferrer"> <span aria-hidden="true">@peregrine</span> <span>View Twitter Profile</span> </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/phoenix-files/2023-06-14/process-cover.webp" alt=""/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p> We&#39;re Fly.io. We run apps for our users on hardware we host around the world. This post is about Elixir Processes and how they work as Phoenix LiveViews. Fly.io happens to be a great place to run Phoenix applications. Check out how to <a href="https://fly.io/docs/elixir/">get started</a>!</p><p>LiveView lets users get up to speed quickly by being easy to learn, especially with the familiar mount, render and event handler system that React developers will immediately recognize. But LiveView differs from other front-end frameworks in one very consequential way:</p> <blockquote> <p>A LiveView is a process.</p> </blockquote> <p>And even though the LiveView docs <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">immediately</a> call out that fact:</p> <blockquote> <p>A LiveView is a process that receives events, updates its state, and render updates to a page as diffs.</p> </blockquote> <p>This fact sets LiveView apart from almost every other front-end framework and is so important that I think it could use a little reiteration.</p> <h2 id="elixir-has-processes"><a href="#elixir-has-processes" aria-label="Anchor"></a>Elixir has Processes</h2><p>In Elixir and Erlang, &#39;processes&#39; do not refer to operating system processes or threads. They are what&#39;s sometimes called <a href="https://en.wikipedia.org/wiki/Green_thread">green threads</a> or actors. On a single core CPU they run concurrently and are scheduled and managed by the Erlang Virtual Machine; on multiple cores they run in parallel. Each process in Elixir and Erlang needs ~300 words of memory, and takes microseconds to start, so they are incredibly cheap. In the Erlang Virtual Machine, <em>everything</em> that executes code is running in a process.</p> <p>I highly recommend you check out <a href="https://elixir-lang.org/getting-started/processes.html">this excellent guide</a> from the Elixir website that goes into some of the details about processes. We&#39;re going to keep it slightly higher level here.</p> <p>Each Process can execute code, it has a first-in-first-out mailbox that <em>any</em> other process can send messages to, and it can also send messages. Each process is sequential, meaning it can only handle one message at a time. The Erlang VM operates kind of like an Operating System scheduler, where it can start and pause or &#34;preempt&#34; work whenever it wants. While it is waiting for a message, your process is completely ignored by the scheduler and doesn&#39;t burn up precious resources.</p> <p>When we work with GenServers, which are higher level abstractions on top of processes, our flow looks kind of like this:</p> <p><img src="https://fly.io/phoenix-files/2023-06-14/process.svg?center" alt="Flowchart showing how a basic process works"/></p> <p>A process starts and sets its initial state, then it waits for a message. When it receives a message it handles it, gets a new state and returns to waiting. This is an important thing to understand: a process is only able to execute if it receives a message. When it is started or initialized a process executes some code, then it waits for a message. This means an idle process won&#39;t consume resources. There are also some messages that are handled internally by GenServers for you, but that&#39;s outside the scope for this post.</p> <p>Since an individual process is sequential, if the message handling function takes a long time to execute, the mailbox or queue may back up. If the process is not expecting a ton of new messages this can be okay. While using a Task it is okay to do a costly calculation because those processes don&#39;t expect more messages. While in the case of a LiveView process, a user will see a page that&#39;s unable to respond to events or render updates, this is bad.</p> <h2 id="the-liveview-process"><a href="#the-liveview-process" aria-label="Anchor"></a>The LiveView Process</h2><p>Just like any other process, LiveView follows a specific lifecycle. Here&#39;s a simplified flow chart to illustrate this:</p> <p><img src="https://fly.io/phoenix-files/2023-06-14/liveview-process.svg?center" alt="Flowchart showing how a LiveView process works."/></p> <p>Where assigns is our state and event is a special case of a message we make special callbacks for. Every user event or params event is a message being handled by our callbacks. So let&#39;s think through some of the implications of this.</p> <h2 id="every-user-has-their-own-process"><a href="#every-user-has-their-own-process" aria-label="Anchor"></a>Every user has their own Process.</h2><p>Despite each user having their own process, it&#39;s not an issue due to the lightweight nature of these processes. The benefits we gain in terms of performance and scalability make it well worth it. To be clear: if you do a normal HTTP request using Phoenix controllers that <em>connection</em> gets its own Process too, it just is immediately killed once you&#39;ve sent the response and closed it. In LiveView we keep that process alive.</p> <h2 id="liveview-lifecycle-functions-need-to-respond-quickly"><a href="#liveview-lifecycle-functions-need-to-respond-quickly" aria-label="Anchor"></a>LiveView lifecycle functions need to respond quickly.</h2><p>Every message is handled sequentially, meaning we need to make sure that handle_event, mount, handle_params, and handle_info functions return quickly since they could be blocking a user interaction.</p> <p>If you have some slow job, query or calculation you should use the built-in async primitives, such as Tasks. Berenice wrote an <em>excellent</em> post showing an example of doing that just in her recent <a href="https://fly.io/phoenix-files/liveview-async-task/">Async Processing in LiveView</a> post.</p> <h2 id="be-careful-of-what-you-put-into-assigns"><a href="#be-careful-of-what-you-put-into-assigns" aria-label="Anchor"></a>Be careful of what you put into assigns.</h2><p>Assigns are kept for the entire lifetime of the page for every user, and you can quickly chew up memory by shoving a ton of stuff into it. It is okay to re-query stuff you need, and look into using <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream/4">streams</a> when you have a long list of items.</p> <h2 id="wrap-up"><a href="#wrap-up" aria-label="Anchor"></a>Wrap up</h2><p>In conclusion, the process is the heart of the Erlang VM, making programming in Elixir a uniquely fast, resilient, and special experience. On purpose, this is only scratching the surface of what a Process is because if the Phoenix team is doing their job right, you shouldn&#39;t <em>need</em> to know much more to be productive and effective at building scalable applications.</p> <p>When you are ready to learn more, here are two great resources:</p> <ul> <li><a href="https://elixir-lang.org/getting-started/processes.html">Elixir Website Guides: Process</a> </li><li><a href="https://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency">Learn You Some Erlang: The Hitchhiker&#39;s Guide to Concurrency</a> </li></ul> <figure> <figcaption> <p> Fly.io is a great way to run your Phoenix LiveView app close to your users. It&#39;s really easy to get started. You can be running in minutes.</p><p><a href="https://fly.io/docs/elixir/"> Deploy a Phoenix app today!  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/static/images/cta-kitty.webp" srcset="/static/images/cta-kitty@2x.webp 2x" alt=""/></p></figure>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/phoenix-files/adding-dialyzer-without-the-pain/"> Adding Dialyzer without the Pain </a> </dd> </dl> </article></div>
  </body>
</html>
