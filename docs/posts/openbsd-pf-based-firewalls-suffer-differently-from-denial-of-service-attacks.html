<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/OpenBSDPfStatesAndDoS">Original</a>
    <h1>OpenBSD PF-based firewalls suffer differently from denial of service attacks</h1>
    
    <div id="readability-page-1" class="page"><div><h2>OpenBSD PF-based firewalls suffer differently from denial of service attacks</h2>

	<p><small>October 13, 2023</small></p>
</div><div><p>Suppose, hypothetically, that you have some DNS servers that are
exposed to the Internet behind an OpenBSD PF-based firewall. Since
you&#39;re a sensible person, you have various rate limits set in your
DNS servers to prevent or at least mitigate various forms of denial
of service attacks. One day, your DNS servers become extremely
popular for whatever reason, your rate limits kick in, and your
firewall abruptly stops allowing new connections in or out. What
on earth happened?</p>

<p>The answer is that you ran out of room in the PF state table.
<a href="https://utcc.utoronto.ca/~cks/space/blog/unix/OpenBSDPfctlStates">OpenBSD PF mostly works through state table entries</a>,
and when a rule that normally would create a new state table entry
is unable to do so, the packet is dropped. This is somewhat documented
in places like <a href="https://man.openbsd.org/pf.conf#max">the <code>max</code> option for stateful rules</a>:</p>

<blockquote><p>Limits the number of concurrent states the rule may create. When this
limit is reached, further packets that would create state are dropped
until existing states time out.</p>
</blockquote>

<p>(That this is more or less explicitly documented is <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/OpenBSDPfMaxNotes">better than it
once was</a>.)</p>

<p>One of the reasons that you can run out of state table entries
despite your DNS servers dutifully rate-limiting their responses
is that DNS is primarily UDP based and so PF doesn&#39;t really know
if a given UDP &#39;connection&#39; is &#39;closed&#39; and so should have its state
table entries cleaned up more aggressively. Instead, all PF does
for UDP is <a href="https://man.openbsd.org/pf.conf#udp.first">guess timeouts based on packet counts</a>, and those packet counts
are for each unique set of source IP, source port, destination IP,
and destination port. If your DNS query sources vary their source
port for each query, this can add up fast.</p>

<p>(<a href="https://utcc.utoronto.ca/~cks/space/blog/unix/OpenBSDPfStateBits">As we&#39;ve seen, even TCP connections can linger in the state table
for some time after they&#39;re closed</a>.)</p>

<p>The current OpenBSD 7.3 manual page for <a href="https://man.openbsd.org/pf.conf">pf.conf</a> says that the default maximum
size of the state table is only 100,000 entries, which is often
effectively 50,000 &#39;connections&#39; (it&#39;s not uncommon for each
connection to create two state table entries). It doesn&#39;t take a
huge amount of bandwidth or a huge packets per second rate to exhaust
that many state table entries, and it mostly doesn&#39;t matter whether
or not your DNS servers actually respond to the queries.</p>

<p>That may sound odd so let&#39;s cover it explicitly. PF has three states
for UDP traffic; &#39;first&#39; if the source has only sent one packet,
&#39;multiple&#39; if both ends have sent packets, ie your DNS server
responded, and &#39;single&#39; if the source has sent multiple packets
(with the same source port) without a response, ie your DNS server
is dropping their queries and they&#39;re retrying. The first two states
default to 60 second timeouts and the third defaults to a 30 second
timeout, and that&#39;s after packets stop flowing. A DNS query source
that keeps re-sending its query every fifteen seconds (with the
same source port) will keep even a &#39;single&#39; state entry alive
forever.</p>

<p>As far as I can see, the only really good way to limit states created
by UDP traffic is to set a <a href="https://man.openbsd.org/pf.conf#max"><code>max</code> option</a> on the rules involved. Often
this will cover only half of the states created by this traffic
(for reasons covered in <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/OpenBSDPfctlStates">my entry on state table entries</a>). You can try to limit the number of source
IPs and states per IP that can be created (and do so across relevant
rules), but it&#39;s hard to come up with sensible numbers for both
that won&#39;t block legitimate traffic while also not letting people
blow out your state table.</p>

<p>(I assume without checking that you can set all of <code>max</code>,
<code>max-src-nodes</code>, and <code>max-src-states</code>, and then have the total number
of state entries limited by <code>max</code> instead of the product of the latter
two. This could be useful if you want some per-IP firewall limits in
addition to the total state limit, perhaps to insure that one or a few
IPs can&#39;t eat up all of the total allowed states.)</p>

<p>All of this is surprising if you&#39;re thinking of rate limiting and
denial of service issues from the normal perspective of services
on your hosts (such as DNS servers, or even web servers). In the
host services world, if you reject or drop traffic through rate
limiting, you&#39;re done with the traffic and you don&#39;t need to worry
further (okay, yes, <a href="https://en.wikipedia.org/wiki/SYN_cookies">SYN cookies for TCP connection attempt traffic
floods</a>, but most things
do that automatically today). But your OpenBSD PF firewall is still
keeping state for that traffic your host rate-limited or dropped,
and that state can (and will) add up, especially for UDP traffic.</p>
</div></div>
  </body>
</html>
