<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lamarrr.github.io/STX/">Original</a>
    <h1>STX – C&#43;&#43;17 and C&#43;&#43; 20 error-handling and utility extensions</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<p>STX is a collection of libraries and utilities designed to make working with C++ easier and less error-prone. This includes but is not limited to well-proven and widely adopted paradigms, data-structures, and designs from other prominent projects and programming languages accross the software engineering community.</p>
<p>At the core, all STX libraries are <code>no_std</code> . No RTTI, memory allocation, nor exceptions.</p>

<h2>Panic Library</h2>
<p>See guide on <a href="https://lamarrr.github.io/STX/Panicking.html">Panicking</a></p>
<p>The panic library provides:</p>
<ul>
<li>panicking:<ul>
<li><code><a href="https://lamarrr.github.io/STX/namespacestx.html#ab30ac58d45acea6e2f513446d245e62e">stx::panic</a></code> : signals an abnormal flow/error in the program.</li>
</ul>
</li>
<li>runtime panic hooks<ul>
<li><code><a href="https://lamarrr.github.io/STX/namespacestx.html#ae665459dd656d01fbba3db15a8294661">stx::take_panic_hook</a></code> , <code><a href="https://lamarrr.github.io/STX/namespacestx.html#a6dcdb760094ff41ef8cc186ff9eb7b85">stx::attach_panic_hook</a></code> , and <code><a href="https://lamarrr.github.io/STX/namespacestx.html#ab773ac393ac1bed763cef3d30ea74ee2">stx::panic_hook_visible</a></code></li>
</ul>
</li>
<li>panic backtraces (see the <a href="https://github.com/lamarrr/STX/tree/master/examples"><code>panic_backtrace</code></a> example project)</li>
<li>error reporting (see <code><a href="https://lamarrr.github.io/STX/classstx_1_1FixedReport.html">stx::FixedReport</a></code> and <code><a href="https://lamarrr.github.io/STX/classstx_1_1SpanReport.html">stx::SpanReport</a></code>)</li>
<li>panic handlers:<ul>
<li><code><a href="https://lamarrr.github.io/STX/namespacestx.html#aea57bab011ea9d8d29338e59717d72a5">stx::panic_default</a></code> : The default panic handler that prints the error message and panic location data, and afterwards aborts the program.</li>
<li><code><a href="https://lamarrr.github.io/STX/namespacestx.html#a5d216eab794f0940fde701b640cb27b3">stx::panic_halt</a></code> : A panic handler that causes the current calling thread, to halt by entering an infinite loop.</li>
<li><code><a href="https://lamarrr.github.io/STX/namespacestx.html#a2c3889fa68ce826dd9786a63252ca3bc" title="Causes the abort instruction to be executed. ">stx::panic_abort</a></code> : A panic handler that causes the abort instruction to be executed.</li>
</ul>
</li>
</ul>
<h2>Error and Optional-Value Handling Library</h2>
<p>These monadic types not only make error handling easier but also make the paths more obvious to the compiler for optimizations. Monads can be simply thought of as abstract types of actions. Their monadic nature makes it easy to operate on them as pipelines and in the process eliminate redundant error-handling logic code.</p>
<ul>
<li><code><a href="https://lamarrr.github.io/STX/structstx_1_1Result.html">stx::Result</a>&lt;T, E&gt;</code> : Type for relaying the result of a function that can fail or succeed (with monadic extensions)</li>
<li><code><a href="https://lamarrr.github.io/STX/structstx_1_1Option.html">stx::Option</a>&lt;T&gt;</code> : Type for <b>safe</b> optional values (with monadic extensions)</li>
</ul>
<h2>Backtracing Library</h2>
<p>The backtracing library is useful for manually querying/viewing information of active stack frames. It makes debugging easier by making it easier to get stackframe information programmartically or automatically (via panics) without having to inspect core dumps or step into a debugger in which errors might not be reproducible (especially for embedded systems). The backtrace library is disabled by default as not all platforms support them, It can be enabled by setting <code>STX_ENABLE_BACKTRACE</code> to <code>ON</code> in the CMakeLists.txt file, this is demonstrated in the <a href="https://github.com/lamarrr/STX/tree/master/examples"><code>panic_backtrace</code></a> example project.</p>
<ul>
<li>Fatal signal backtraces for <code>SIGSEGV</code> , <code>SIGFPE</code> , and <code>SIGILL</code> (<code><a href="https://lamarrr.github.io/STX/namespacestx_1_1backtrace.html#ad2dc56c0a5c73aaa3d6e75c78e6d7e95">stx::backtrace::handle_signal</a></code>)</li>
<li>Manual stack backtraces (<code><a href="https://lamarrr.github.io/STX/namespacestx_1_1backtrace.html#a908839a2af8bdec79ba9bef62f1f9703">stx::backtrace::trace</a></code>)</li>
</ul>

<p>STX is primarilly an effort to bring a more convenient and usable error-handling model to the C++ ecosystem. Whilst also sampling ideas from various error-handling model implementations duplicated across the community, Most of the basic facilities for which STX&#39;s libraries aims to provide.</p>
<p>Here is a list of C++ projects with a similar error-handling model:</p>
<ul>
<li><a href="https://blog.salkinium.com/xpccs-error-model/">XPCC&#39;s Error Model</a> (Abandonment)</li>
<li>Boost&#39;s <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf"><code>expected</code></a> and <a href="https://www.boost.org/doc/libs/1_70_0/libs/outcome/doc/html/index.html"><code>outcome</code></a></li>
<li>Simon Brand&#39;s <a href="https://github.com/TartanLlama/optional"><code>tl::optional</code></a></li>
<li>Abseil&#39;s <a href="https://github.com/abseil/abseil-cpp/tree/master/absl/status"><code>Status</code> , <code>StatusCode</code></a>, and <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/internal/raw_logging.cc"><code>RawLog</code></a></li>
<li>Tensorflow Lite Micro&#39;s <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/core/api/error_reporter.h"><code>ErrorReporter</code></a></li>
<li>Tensorflow&#39;s <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/status.h"><code>Status</code> , <code>Code</code></a>, <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/default/logging.cc"><code>Logging</code></a>, <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/status.h"><code>ENSURE_OK</code> , <code>CHECK_OK</code> , <code>DCHECK_OK</code> , <code>QCHECK_OK</code></a>, and other error handling macros</li>
<li>Mozilla&#39;s <a href="https://searchfox.org/mozilla-central/source/mfbt/Result.h"><code>Result&lt;T, E&gt;</code></a>, <a href="https://searchfox.org/mozilla-central/source/mfbt/Maybe.h"><code>Maybe&lt;T&gt;</code></a>, <a href="https://searchfox.org/mozilla-central/source/mfbt/MaybeOneOf.h"><code>MaybeOneOf&lt;A, B&gt;</code></a>, and <a href="https://searchfox.org/mozilla-central/source/mfbt/NotNull.h"><code>NotNull&lt;T*&gt;</code></a></li>
<li>Google Pigweed&#39;s <a href="https://pigweed.googlesource.com/pigweed/pigweed/+/refs/heads/master/pw_result/"><code>Result&lt;T, Status&gt;</code></a>, <a href="https://pigweed.googlesource.com/pigweed/pigweed/+/refs/heads/master/pw_status/"><code>Status</code></a></li>
<li>Simdjson&#39;s <a href="https://github.com/simdjson/simdjson/blob/master/include/simdjson/error.h"><code>error_code</code> , <code>result</code></a></li>
<li>MBED OS&#39; <a href="https://github.com/ARMmbed/mbed-os/blob/master/platform/source/mbed_error.c"><code>Error</code></a></li>
<li>LLVM&#39;s <a href="https://github.com/llvm/llvm-project/blob/master/llvm/include/llvm/Support/Error.h"><code>Error</code> , <code>Expected</code></a>, <a href="https://github.com/llvm/llvm-project/blob/master/llvm/include/llvm/Support/ErrorOr.h"><code>ErrorOr</code></a>, <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Support/ErrorHandling.cpp"><code>ErrorHandling</code></a></li>
<li>Fuchsia OS - Zircon Common Library&#39; s <a href="https://fuchsia.googlesource.com/fuchsia/+/HEAD/zircon/system/public/zircon/assert.h"><code>ZX_PANIC</code></a>, <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/master/zircon/system/ulib/zxc/"><code>Result</code></a>, <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/master/zircon/system/ulib/fs/include/fs/vfs.h"><code>OpenResult</code></a>, <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/master/zircon/system/ulib/intel-hda/include/intel-hda/utils/status_or.h"><code>StatusOr</code></a>, and <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/master/zircon/system/ulib/zxc/"><code>Status</code></a></li>
<li>P-ranav&#39;s <a href="https://github.com/p-ranav/result/blob/master/include/result/result.hpp"><code>Result&lt;T, E&gt;</code></a></li>
<li>Mum4k&#39;s Arduino Error Classes: <a href="https://github.com/mum4k/arduino_error/blob/master/error_or.h"><code>ErrorOr</code></a>, <a href="https://github.com/mum4k/arduino_error/blob/master/error.h"><code>Error</code></a>, and <a href="https://github.com/mum4k/arduino_error/blob/master/error_macros.h">Error Macros</a></li>
</ul>

<ul>
<li>Why not exceptions?</li>
</ul>
<p>These reasons are a bit biased, but based on my team&#39;s experience:</p>
<ul>
<li>Exceptions are really great, but present implementations are not so great for fail-often functions</li>
<li>Some embedded systems toolchains don&#39;t have a conformant exception implementation and throwing an exception resorts to an immediate abort</li>
<li>Currently, Exceptions are not deterministic in both space and time</li>
<li>You never know which function throws which exception and you never know when the callee code&#39;s API changes the exception type which can have extremely serious effects that&#39;ll go unnoticed</li>
<li>Exceptions are implicitly and automatically propagated up the call stack until it finds a function to handle it which you might not want as <b>error-handling is very very contextual</b></li>
<li>Exception-handling code gets messy easily</li>
<li>Exceptions are essentially for exceptional cases</li>
<li>Exceptions require RTTI</li>
<li>Some custom exception implementations make use of dynamic memory allocation (many using std::string especially)</li>
<li>There&#39;s nothing stopping you from catching exceptions you are not meant to catch</li>
</ul>

<ul>
<li>Joe Duffy: <a href="http://joeduffyblog.com/2016/02/07/the-error-model/">The Error Model</a></li>
</ul>
<h2>Relatable Excerpts</h2>
<blockquote>
<p>This problem isn’t theoretical. I’ve encountered numerous bugs caused by ignoring return codes and I’m sure you have too. Indeed, in the development of this very Error Model, my team encountered some fascinating ones. For example, when we ported Microsoft’s Speech Server to Midori, we found that 80% of Taiwan Chinese (zh-tw) requests were failing. Not failing in a way the developers immediately saw, however; instead, clients would get a gibberish response. At first, we thought it was our fault. But then we discovered a silently swallowed HRESULT in the original code. Once we got it over to Midori, the bug was thrown into our faces, found, and fixed immediately after porting. This experience certainly informed our opinion about error codes. </p>
</blockquote>
<blockquote>
<p>In the exception model, any function call – and sometimes any statement – can throw an exception, transferring control non-locally somewhere else. Where? Who knows. There are no annotations or type system artifacts to guide your analysis. As a result, it’s difficult for anyone to reason about a program’s state at the time of the throw, the state changes that occur while that exception is propagated up the call stack – and possibly across threads in a concurrent program – and the resulting state by the time it gets caught or goes unhandled. </p>
</blockquote>
<blockquote>
<p>Bugs Aren’t Recoverable Errors! </p>
</blockquote>
<ul>
<li>Herb Sutter: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf">Zero Overhead Deterministic Exceptions</a></li>
</ul>

<blockquote>
<p>Many projects ban exceptions. In <a href="https://isocpp.org/blog/2018/03/results-summary-cpp-foundation-developer-survey-lite-2018-02">SC++F 2018</a>, 52% of C++ developers reported that exceptions were banned in part or all of their project code i.e., most are not allowed to freely use C++’s primary recommended error-handling model that is required to use the C++ standard language and library. </p>
</blockquote>
<blockquote>
<p>A programming bug or abstract machine corruption is never an &#34;error&#34; (both are not programmatically recoverable, so report bugs to the human programmer using <b>contract</b> violations that default to <b>fail-fast</b> and report abstract machine corruption using fail-fast). Programming bugs (e.g., out-of-bounds access, null dereference) and abstract machine corruption cause a corrupted state that cannot be recovered from programmatically, and so <b>should never</b> be reported to the calling code as errors that code could somehow handle. </p>
</blockquote>
<p>Note here that exceptions also don&#39;t fit this fail-fast procedure as they can be caught by any function on the stack! and try to continue the program!!! (for fail-fast: STX provides <code><a href="https://lamarrr.github.io/STX/namespacestx.html#ab30ac58d45acea6e2f513446d245e62e">stx::panic</a></code>, and for recoverable errors: <code><a href="https://lamarrr.github.io/STX/structstx_1_1Result.html">stx::Result</a></code>). There should be no reason to continue the program or propagate a programming bug.</p>
<blockquote>
<p>Today&#39;s dynamic exception handling is not deterministic (run-time space and time determinism). This is the primary reason exceptions are banned in many real-time and/or safety-critical environments (for example, many games, coding standards like JSF++ <a href="http://www.stroustrup.com/JSF-AV-rules.pdf">[JSF++2005]</a>, and environments like the Mars Rover flight software <a href="https://github.com/CppCon/CppCon2014/blob/master/Presentations/C%2B%2B%20on%20Mars%20-%20Incorporating%20C%2B%2B%20into%20Mars%20Rover%20Flight%20Software/C%2B%2B%20On%20Mars%20-%20Mark%20Maimone%20-%20CppCon%202014.pdf">[Maimone 2014]</a>). </p>
</blockquote>
<blockquote>
<p>We cannot accept that &#34;Standard C++ is not applicable for real-time systems&#34; – that would be an admission of defeat in C++&#39;s core mission as an efficient systems programming language. Therefore we know we cannot live with today&#39;s model unchanged. </p>
</blockquote>
<blockquote>
<p>&#34;[In CLU] We rejected this approach [propagating dynamic exceptions] because it did not fit our ideas about modular program construction. We wanted to be able to call a procedure knowing just its specification, not its implementation.&#34; – <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.127.8460&amp;rep=rep1&amp;type=pdf">[Liskov 1992]</a> </p>
</blockquote>
<blockquote>
<p>&#34;By allowing multi-level propagation of exceptions, C++ loses one aspect of static checking. One cannot simply look at a function to determine which exceptions it may throw.&#34; – [Stroustrup 1994] p. 395</p>
</blockquote>
</div></div></div>
  </body>
</html>
