<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lesswrong.com/posts/gTZ2SxesbHckJ3CkF/transformers-represent-belief-state-geometry-in-their">Original</a>
    <h1>Transformers Represent Belief State Geometry in Their Residual Stream</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div id="postBody"><div><p>Crossposted from the <a href="https://alignmentforum.org/posts/gTZ2SxesbHckJ3CkF/transformers-represent-belief-state-geometry-in-their">AI Alignment Forum</a>. May contain more technical jargon than usual.</p><div><div><div><p id="block0"><i>Produced while being an affiliate at PIBBSS</i><span data-footnote-reference="" data-footnote-index="1" data-footnote-id="nla6r2hm9te" role="doc-noteref" id="fnrefnla6r2hm9te"><sup><a href="#fnnla6r2hm9te">[1]</a></sup></span><i>. The work was done initially with funding from a Lightspeed Grant, and then continued while at PIBBSS. Work done in collaboration with </i><a href="https://www.lesswrong.com/users/paul-riechers?mention=user"><i>@Paul Riechers</i></a><i>, </i><a href="https://www.lesswrong.com/users/lucas-teixeira?mention=user"><i>@Lucas Teixeira</i></a><i>, </i><a href="https://www.lesswrong.com/users/alexander-gietelink-oldenziel?mention=user"><i>@Alexander Gietelink Oldenziel</i></a><i>, and </i><a href="https://www.sarahmarzen.com/"><i>Sarah Marzen</i></a><i>. Paul was a MATS scholar during some portion of this work. Thanks to Paul, Lucas, Alexander, Sarah, and </i><a href="https://www.lesswrong.com/users/guillaume-corlouer?mention=user"><i>@Guillaume Corlouer</i></a><i> for suggestions on this writeup.</i></p><p id="block1">What computational structure are we building into LLMs when we train them on next-token prediction? In this post we present evidence that this structure is given by the <strong>meta-dynamics of belief updating over hidden states of the data-generating process</strong>. We&#39;ll explain exactly what this means in the post. We are excited by these results because</p><ul><li id="block2">We have a formalism that <strong>relates training data to internal structures in LLMs</strong>.</li><li id="block3">Conceptually, our results mean that <strong>LLMs synchronize to their internal world model</strong> as they move through the context window. </li><li id="block4">The computation associated with synchronization can be formalized with a framework called <strong>Computational Mechanics</strong>. In the parlance of Computational Mechanics, we say that LLMs represent the Mixed-State Presentation of the data generating process. </li><li id="block5">The structure of synchronization is, in general, richer than the world model itself. In this sense, <strong>LLMs learn more than a world model</strong>.</li><li id="block6">We have increased hope that <strong>Computational Mechanics can be leveraged for interpretability and AI Safety more generally</strong>.</li><li id="block7">There&#39;s just something inherently cool about making a non-trivial prediction - in this case that the transformer will represent a specific fractal structure - and then verifying that the prediction is true. Concretely, <strong>we are able to use Computational Mechanics to make an </strong><i><strong>a priori </strong></i><strong> and specific theoretical prediction about the geometry of residual stream activations (below on the left), and then show that this prediction holds true empirically (below on the right).</strong></li></ul><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/ij47kjsc989zu9tok94c" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/wnzlhsdxxkxin6lvfpss 100w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/l2338y9xxipazyunwztj 200w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/r3z1pgc2t7nraxc6la23 300w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/slh5hwwahb6nozygh6vl 400w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/u80mdsrl4j5qd2ffdgdu 500w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/rfs6zucg7qh8sztizfme 600w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/dnbosxwbxqdm5yeox0eb 700w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/rbxyibhle0rkfdubwimp 800w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/rcvkua8le75y4fqb5nxc 900w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/hgbez2heh7wg80uem5zt 960w"/></figure><p id="block8">In this post we will operationalize training data as being generated by a Hidden Markov Model (HMM)<span data-footnote-reference="" data-footnote-index="2" data-footnote-id="2msn39e4jk" role="doc-noteref" id="fnref2msn39e4jk"><sup><a href="#fn2msn39e4jk">[2]</a></sup></span>. An HMM has a set of hidden states and transitions between them. The transitions are labeled with a probability and a token that it emits. Here are some example HMMs and data they generate.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/zfiwwdsjgproadhz6scj" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/cns8clvd7zrhincase02 170w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/zzcpjup8aslm4qph4vb5 340w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/dk3ovbbwctbshbtd9jef 510w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/c8l6yjccgsto57mtu0oj 680w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/djwczjf26uisnpm8koez 850w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/sh3rweb0e2kilhh9fsl3 1020w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/rpbpjwj1gxpyba0jcpkn 1190w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/xfktfjy6rmkkbmcmtgtv 1360w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/d7lepeyezjjq4kmlcpg8 1530w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/lxzz7s5p96apo1abqzue 1606w"/></figure><p id="block9"><span>Consider the relation a transformer has to an HMM that produced the data it was trained on. This is general - any dataset consisting of sequences of tokens can be represented as having been generated from an HMM.</span> Through the discussion of the theoretical framework, let&#39;s assume a simple HMM with the following structure, which we will call the <i>Z1R process</i><span data-footnote-reference="" data-footnote-index="3" data-footnote-id="k20y92iwuuf" role="doc-noteref" id="fnrefk20y92iwuuf"><sup><a href="#fnk20y92iwuuf">[3]</a></sup></span> (for &#34;zero one random&#34;). </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/kkewuoy28onjlo1u7vom" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/ovwuujbzsrktaoykpe8t 120w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/dgafmtyreqynr4jp2ali 240w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/j8t6bu8mhidwqc62tghy 360w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/jt7b6tdjx6bbkzmepjrz 480w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/a2rhfjdwxzlh7yyncogu 600w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/fpgkihnadttrgkb4nncj 720w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/kcxaabbzza9hxvaaptgc 840w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/epgn4gc4tesrg24et5i4 960w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/xehnsonguge6f3lbne2n 1080w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/spabc1yrazybqunl2vbd 1178w"/></figure><p id="block10">The Z1R process has 3 hidden states, <span><span><span><span aria-label="S_0, S_1,"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>0</span></span></span></span><span><span>,</span></span><span><span><span><span>S</span></span></span><span><span><span>1</span></span></span></span><span><span>,</span></span></span></span></span></span></span> and <span><span><span><span aria-label="S_R"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span></span></span></span></span></span>. Arrows of the form <span><span><span><span aria-label="S_x \xrightarrow{\textbf{a}\hspace{.25em}:\hspace{.25em}p\%} S_y"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>x</span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>a</span></span></span></span><span></span><span><span>:</span></span><span></span><span><span>p</span></span><span><span>%</span></span></span></span><span></span></span></span></span><span><span><span><span>−</span><span>−−</span><span>→</span></span></span></span></span></span><span><span><span><span>S</span></span></span><span><span><span>y</span></span></span></span></span></span></span></span></span> denote <span><span><span><span aria-label="P(S_y,\textbf{a}|S_x)=p\%"><span aria-hidden="true"><span><span>P</span></span><span><span>(</span></span><span><span><span><span>S</span></span></span><span><span><span>y</span></span></span></span><span><span>,</span></span><span><span><span><span>a</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>S</span></span></span><span><span><span>x</span></span></span></span><span><span>)</span></span><span><span>=</span></span><span><span>p</span></span><span><span>%</span></span></span></span></span></span></span>, that the probability of moving to state <span><span><span><span aria-label="S_y"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>y</span></span></span></span></span></span></span></span></span> and emitting the token <span><span><span><span aria-label="\textbf{a}"><span aria-hidden="true"><span><span><span><span>a</span></span></span></span></span></span></span></span></span>, given that the process is in state <span><span><span><span aria-label="S_x"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>x</span></span></span></span></span></span></span></span></span>, is <span><span><span><span aria-label="p\%"><span aria-hidden="true"><span><span>p</span></span><span><span>%</span></span></span></span></span></span></span>. In this way, taking transitions between the states stochastically generates binary strings of the form <code>...01R01R...</code> where <code>R</code> is a random 50/50 sample from {<code>0</code>, <code>1</code>}. </p><p id="block11">The HMM structure <i>is not </i>directly given by the data it produces. Think of the difference between the list of strings this HMM emits (along with their probabilities) and the hidden structure itself<span data-footnote-reference="" data-footnote-index="4" data-footnote-id="tdn1ya9cw6d" role="doc-noteref" id="fnreftdn1ya9cw6d"><sup><a href="#fntdn1ya9cw6d">[4]</a></sup></span>. Since the transformer only has access to the strings of emissions from this HMM, and <i>not</i> any information about the hidden states directly, if the transformer learns anything to do with the hidden structure, then it has to do the work of <i>inferring </i>it from the training data. </p><p id="block12">What we will show is that when they predict the next token well,<strong> transformers are doing even more computational work than inferring the hidden data generating process!</strong></p><h2 id="Do_Transformers_Learn_a_Model_of_the_World_">Do Transformers Learn a Model of the World?</h2><p id="block13">One natural intuition would be that the transformer must represent the hidden structure of the data-generating process (ie the &#34;world&#34;<span data-footnote-reference="" data-footnote-index="2" data-footnote-id="2msn39e4jk" role="doc-noteref" id="fnref2msn39e4jk"><sup><a href="#fn2msn39e4jk">[2]</a></sup></span>). In this case, this would mean the three hidden states and the transition probabilities between them. </p><p id="block14">This intuition often comes up (and is argued about) in discussions about what LLM&#39;s &#34;really understand.&#34; For instance, <a href="https://www.youtube.com/watch?v=YEUclZdj_Sc">Ilya Sutskever has said</a>:</p><blockquote id="block15"><p id="block16">Because if you think about it, what does it mean to predict the next token well enough? It&#39;s actually a much deeper question than it seems. <strong>Predicting the next token well means that you understand the underlying reality that led to the creation of that token.</strong> It&#39;s not statistics. Like it is statistics but what is statistics? In order to understand those statistics to compress them, you need to understand what is it about the world that creates this set of statistics.</p></blockquote><p id="block17">This type of intuition is natural, but it is not formal. <a href="https://arxiv.org/abs/cond-mat/9907176">Computational Mechanics</a> is a formalism that was developed in order to study the limits of prediction in chaotic and other hard-to-predict systems, and has since expanded to a deep and rigorous theory of computational structure for any process. One of its many contributions is in providing a rigorous answer to what structures are necessary to perform optimal prediction. Interestingly, Computational Mechanics shows that <i>prediction is substantially more complicated than generation</i>. What this means is that we should expect a transformer trained to predict the next token well should have <i>more structure </i>than the data generating process!</p><h2 id="The_Structure_of_Belief_State_Updating">The Structure of Belief State Updating</h2><p id="block18">But what is that structure exactly?</p><p id="block19">Imagine you know, exactly, the structure of the HMM that produces <code>...01R...</code> data. You go to sleep, you wake up, and you see that the HMM has emitted a <code>1</code>. What state is the HMM in now? It is possible to generate a <code>1</code> both from taking the deterministic transition  <span><span><span><span aria-label="S_1 \xrightarrow{\textbf{1}\hspace{.25em}:\hspace{.25em}100\%} S_R"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>1</span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>1</span></span></span></span><span></span><span><span>:</span></span><span></span><span><span>100</span></span><span><span>%</span></span></span></span><span></span></span></span></span><span><span><span><span>−</span><span>−−−−</span><span>→</span></span></span></span></span></span><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span></span></span></span></span></span> or from taking  the stochastic transition <span><span><span><span aria-label="S_R \xrightarrow{\textbf{1}\hspace{.25em}:\hspace{.25em}50\%} S_0"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>1</span></span></span></span><span></span><span><span>:</span></span><span></span><span><span>50</span></span><span><span>%</span></span></span></span><span></span></span></span></span><span><span><span><span>−</span><span>−−−</span><span>→</span></span></span></span></span></span><span><span><span><span>S</span></span></span><span><span><span>0</span></span></span></span></span></span></span></span></span>. Since the deterministic transition is twice as likely as the 50% one, the best you can do is to have some belief distribution over the current states of the HMM, in the case <span><span><span><span aria-label="P([S_0, S_1, S_R])=[\frac{1}{3},0,\frac{2}{3}]"><span aria-hidden="true"><span><span>P</span></span><span><span>(</span></span><span><span>[</span></span><span><span><span><span>S</span></span></span><span><span><span>0</span></span></span></span><span><span>,</span></span><span><span><span><span>S</span></span></span><span><span><span>1</span></span></span></span><span><span>,</span></span><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span><span><span>]</span></span><span><span>)</span></span><span><span>=</span></span><span><span>[</span></span><span><span><span><span><span>1</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span><span><span>,</span></span><span><span>0</span></span><span><span>,</span></span><span><span><span><span><span>2</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span><span><span>]</span></span></span></span></span></span></span><span data-footnote-reference="" data-footnote-index="5" data-footnote-id="s5abv4693vb" role="doc-noteref" id="fnrefs5abv4693vb"><sup><a href="#fns5abv4693vb">[5]</a></sup></span>. </p><figure><table><tbody><tr><td> </td><td><code> </code></td><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td><td><code>1...</code></td></tr><tr><td>P(<span><span><span><span aria-label="S_0"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>0</span></span></span></span></span></span></span></span></span>)</td><td><span><span><span><span aria-label="\frac{1}{3}"><span aria-hidden="true"><span><span><span><span><span>1</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="\frac{1}{3}"><span aria-hidden="true"><span><span><span><span><span>1</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="1"><span aria-hidden="true"><span><span>1</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0"><span aria-hidden="true"><span><span>0</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0..."><span aria-hidden="true"><span><span>0...</span></span></span></span></span></span></span></td></tr><tr><td>P(<span><span><span><span aria-label="S_1"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>1</span></span></span></span></span></span></span></span></span>)</td><td><span><span><span><span aria-label="\frac{1}{3}"><span aria-hidden="true"><span><span><span><span><span>1</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0"><span aria-hidden="true"><span><span>0</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0"><span aria-hidden="true"><span><span>0</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="1"><span aria-hidden="true"><span><span>1</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0..."><span aria-hidden="true"><span><span>0...</span></span></span></span></span></span></span></td></tr><tr><td>P(<span><span><span><span aria-label="S_R"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span></span></span></span></span></span>)</td><td><span><span><span><span aria-label="\frac{1}{3}"><span aria-hidden="true"><span><span><span><span><span>1</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="\frac{2}{3}"><span aria-hidden="true"><span><span><span><span><span>2</span></span></span><span><span><span>3</span></span></span><span></span></span><span></span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0"><span aria-hidden="true"><span><span>0</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="0"><span aria-hidden="true"><span><span>0</span></span></span></span></span></span></span></td><td><span><span><span><span aria-label="1..."><span aria-hidden="true"><span><span>1...</span></span></span></span></span></span></span></td></tr></tbody></table></figure><p id="block20">If now you see another <code>1</code> emitted, so that in total you&#39;ve seen <code>11</code>, you can now use your previous belief about the HMM state (read: prior), and your knowledge of the HMM structure alongside the emission you just saw (read: likelihood), in order to generate a new belief state (read: posterior). An exercise for the reader: What is the equation for updating your belief state given a previous belief state, an observed token, and the transition matrix of the ground-truth HMM?<span data-footnote-reference="" data-footnote-index="6" data-footnote-id="j5n5l9mkvlr" role="doc-noteref" id="fnrefj5n5l9mkvlr"><sup><a href="#fnj5n5l9mkvlr">[6]</a></sup></span> In this case, there is only one way for the HMM to generate <code>11</code>, <span><span><span><span aria-label="S_1 \xrightarrow{\textbf{1}\hspace{.25em}:\hspace{.25em}100\%} S_R \xrightarrow{\textbf{1}\hspace{.25em}:\hspace{.25em}50\%} S_0"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>1</span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>1</span></span></span></span><span></span><span><span>:</span></span><span></span><span><span>100</span></span><span><span>%</span></span></span></span><span></span></span></span></span><span><span><span><span>−</span><span>−−−−</span><span>→</span></span></span></span></span></span><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>1</span></span></span></span><span></span><span><span>:</span></span><span></span><span><span>50</span></span><span><span>%</span></span></span></span><span></span></span></span></span><span><span><span><span>−</span><span>−−−</span><span>→</span></span></span></span></span></span><span><span><span><span>S</span></span></span><span><span><span>0</span></span></span></span></span></span></span></span></span>, so you know for certain that the HMM is now in state <span><span><span><span aria-label="S_0"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>0</span></span></span></span></span></span></span></span></span>. From now on, whenever you see a new symbol, you will know exactly what state the HMM is in, and we say that you have <i>synchronized </i>to the HMM.</p><p id="block21">In general, as you observe increasing amounts of data generated from the HMM, you can continually update your belief about the HMM state. Even in this simple example there is non-trivial structure in these belief updates. For instance, it is not always the case that seeing 2 emissions is enough to synchronize to the HMM. If instead of <code>11...</code> you saw <code>10...</code> you still wouldn&#39;t be synchronized, since there are two different paths through the HMM that generate <code>10</code>. </p><p id="block22">The structure of belief-state updating is given by the <i>Mixed-State Presentation.</i></p><h2 id="The_Mixed_State_Presentation">The Mixed-State Presentation</h2><p id="block23">Notice that just as the data-generating structure is an HMM - at a given moment <i><strong>the process</strong></i> is in a hidden state, then, given an emission, <i><strong>the process</strong></i> move to another hidden state - so to is your belief updating! <i><strong>You</strong></i> are in<i> </i>some belief state, then given an emission that you observe, <i><strong>you</strong></i> move to some other belief state<i>. </i></p><figure><table><thead><tr><th> </th><th>Data Generating Process</th><th>Belief State Process</th></tr></thead><tbody><tr><th>States belong to</th><td>The data generating mechanism</td><td>The observer of the outputs of the data generating process</td></tr><tr><th>States are</th><td>Sets of sequences that constrain the future in particular ways</td><td>The observer&#39;s beliefs over the states of the data generating process</td></tr><tr><th>Sequences of hidden states emit</th><td>Valid sequences of data</td><td>Valid sequences of data</td></tr><tr><th>Interpretation of emissions</th><td>The observables/tokens the data generating process emits</td><td>What the observer sees from the data generating process </td></tr></tbody></table></figure><p id="block24">The meta-dynamics of belief state updating are formally another HMM, where the hidden states are your <i>belief states</i>. This meta-structure is called the <i>Mixed-State Presentation (MSP) </i>in Computational Mechanics.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/fsbygfxftowo6e1oewpq" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/yfmusscfpe2v0t63217k 240w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/skgbhc9ip8hiy8q0rjki 480w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/dbzuwsad6p7wuuhyunnb 720w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/l4xvoqoj5cgtv57ljxqk 960w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/mxm6gptophpaulstmrsa 1200w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/llwf4u8kvwegblv0xnij 1440w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/cxhk8f2sx5mcvhqielx6 1680w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/glq0uoshzsrmm8a2o1vu 1920w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/kmpi7uk2lx8de7xzvewz 2160w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/okvkujvz6pkfvj975gg1 2312w"/></figure><p id="block25">Note that the MSP has transitory states (in green above) that lead to a recurrent set of belief states that are isomorphic to the data-generating process - this always happens, though there might be infinite transitory states. <i>Synchronization </i>is the process of moving through the transitory states towards convergence to the data-generating process.</p><p id="block26">A lesson from Computational Mechanics is that in order to perform optimal prediction of the next token based on observing a finite-length history of tokens, one must implement the Mixed-State Presentation (MSP). That is to say, to predict the next token well one should know what state the data-generating process is in as best as possible, and to know what state the data-generating process is in, implement the MSP.</p><p id="block27"><strong>The MSP has a geometry associated with it</strong>, given by plotting the belief-state values on a simplex. In general, if our data generating process has N states, then probability distributions over <span><span><span><span aria-label=""><span aria-hidden="true"></span></span></span></span></span>those states will have <span><span><span><span aria-label="N-1"><span aria-hidden="true"><span><span>N</span></span><span><span>−</span></span><span><span>1</span></span></span></span></span></span></span> degrees of freedom, and since all probabilities must be between 0 and 1, all possible belief distributions lie on an <span><span><span><span aria-label="N-1"><span aria-hidden="true"><span><span>N</span></span><span><span>−</span></span><span><span>1</span></span></span></span></span></span></span> simplex. In the case of Z1R, that means a 2-simplex (i.e. a triangle). We can plot each of our possible belief states in this 2-simplex, as shown on the right below.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/lqcujxu34q0ulj2nxuxz" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/aqfazwsxpyp9z91qleul 230w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/e0snbuzi3jfkrka3wlc8 460w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/cdrtxfplagebu8ucjymv 690w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/roetai8tzyys3dzgctxx 920w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/c3jovk5qy9kiqrpfagc2 1150w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/tkgazp6pimhr8y8hoafu 1380w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/sfdqrikd2fru9kfdgr2m 1610w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/mftf0hfq8phdfnpqxlx9 1840w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/hjrtc6owkolfeyxqowfs 2070w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/yxnpzxhgzjpgillzjryo 2226w"/></figure><p id="block28">What we show in this post is that when we train a transformer to do next token prediction on data generated from the 3-state HMM, we can find a linear representation of the MSP geometry in the residual stream. This is surprising! Note that the points on the simplex, the belief states, <i>are not the next token probabilities. </i>In fact, multiple points here have literally the same next token predictions. In particular, in this case, <span><span><span><span aria-label="\eta_{10}"><span aria-hidden="true"><span><span><span><span>η</span></span></span><span><span><span><span><span>10</span></span></span></span></span></span></span></span></span></span></span>, <span><span><span><span aria-label="\eta_{S}"><span aria-hidden="true"><span><span><span><span>η</span></span></span><span><span><span><span><span>S</span></span></span></span></span></span></span></span></span></span></span>, and <span><span><span><span aria-label="\eta_{101}"><span aria-hidden="true"><span><span><span><span>η</span></span></span><span><span><span><span><span>101</span></span></span></span></span></span></span></span></span></span></span>, all have the same optimal next token predictions.</p><p id="block29">Another way to think about this claim is that <strong>transformers keep track of distinctions in anticipated distribution over the entire future, beyond distinctions in next token predictions, even though the <span>transformer is only trained explicitly on next token prediction!</span></strong>  That means the transformer is keeping track of extra information than what is necessary just for the local next token prediction.</p><p id="block30">Another way to think about our claim is that <strong>transformers perform two types of inference</strong>: one to infer the structure of the data-generating process, and another meta-inference to update it&#39;s internal beliefs over which state the data-generating process is in, given some history of finite data (ie the context window).  This second type of inference can be thought of as the algorithmic or computational structure of synchronizing to the hidden structure of the data-generating process.</p><p id="block31">A final theoretical note about Computational Mechanics and the theory presented here: because Computational Mechanics is not contingent on the specifics of transformer architectures and is a well-developed first-principles framework, we can apply this framework to any optimal predictor, not just transformers<span data-footnote-reference="" data-footnote-index="7" data-footnote-id="ml5xeq780ap" role="doc-noteref" id="fnrefml5xeq780ap"><sup><a href="#fnml5xeq780ap">[7]</a></sup></span>.</p><h2 id="Experimental_Design">Experimental Design</h2><p id="block32">To repeat the question we are trying to answer: </p><blockquote id="block33"><p id="block34">What computational structure are we building into LLMs when we train them on next-token prediction?</p></blockquote><p id="block35">To test our theoretical predictions, we designed an experiment with the following steps:</p><ol><li id="block36">Generate training data from a known HMM structure, specifically the 3-state HMM described in the  &#34;Data-Generating Process and MSP&#34; section below.</li><li id="block37">Train a transformer on this data to perform next-token prediction. In the experiments shown here we use a 4-layer transformer with 64 dimensional residual stream, and 4 attention heads per layer.</li><li id="block38">Analyze the final layer of the transformer&#39;s residual stream to look for a linear subspace with a geometry matching the predicted fractal structure of the Mixed-State Presentation (MSP).</li></ol><p id="block39">By controlling the structure of the training data using an HMM, we can make concrete, falsifiable predictions about the computational structure the transformer should implement during inference. <a href="https://arxiv.org/abs/cond-mat/9907176">Computational Mechanics</a>, as presented in the &#34;Theoretical Framework&#34; section above, provides the framework for making these predictions based on the HMM&#39;s structure.</p><p id="block40">The specific HMM we chose has an MSP with an infinite fractal geometry, serving as a highly non-trivial prediction about what we should find in the transformer&#39;s residual stream activations if our theory is correct.</p><h2 id="The_Data_Generating_Process_and_MSP">The Data-Generating Process and MSP</h2><p id="block41">For this experiment we trained a transformer on data generated by a simple HMM, called the Mess3 Process, that has just 3 hidden states<span data-footnote-reference="" data-footnote-index="8" data-footnote-id="czx8aongmnn" role="doc-noteref" id="fnrefczx8aongmnn"><sup><a href="#fnczx8aongmnn">[8]</a></sup></span>. Moving between the 3 hidden states according to the emission probabilities on the edges generates strings over a 3-token vocabulary: {<code>A</code>, <code>B</code>, <code>C</code>}. The HMM for this data-generating process is given on the left of the figure below.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/xppfd3veqbcmfvkjyimr"/><figcaption><strong> (Left)</strong> The data-generating process has 3 hidden states and outputs data made of a token-vocabulary of {A, B, C}. <strong>(Bottom) </strong>Paths through this structure generate training data, by sampling the token distributions of edges leaving a hidden state. We use this data to then train a transformer.<strong> (Right) </strong>The Mess3 MSP of internal states of a system that predicts future tokens of the data generating process based on observing previous tokens. Points in this space correspond to probability distributions over the hidden states of the data generating process, and thus lie in a 2D plane, since probability distributions over 3 objects are 2D. <strong>Importantly, <u>this structure is not the structure of the next-token predictions! It is instead the meta-structure of an observer&#39;s belief updates over the hidden states of the generating structure!</u> </strong>The middle point of the triangle corresponds to maximum uncertainty over the 3 hidden states, while corners correspond to total certainty in one of the hidden states. Colors are assigned by treating the 3D probability distributions as RGB values. </figcaption></figure><p id="block42">Our approach allows us to make rigorous and testable predictions about the internal structures of transformers. In the case of this HMM, the theory (outlined above) says that transformers trained on this data should instantiate the computational structure associated with the fractal geometry shown on the right of the figure above. Every colored point in the simplex on the above right panel is a distinct belief state.</p><p id="block43">We chose the Mess3 HMM because it&#39;s MSP has an infinite fractal structure, and thus acts as a highly-nontrivial prediction about what geometry we should find in the residual stream.</p><h2 id="The_Results_">The Results!</h2><p id="block44">We train a transformer on data generated by the Mess3 HMM. <span>We look in the final layer of the residual stream and find a linear 2D subspace where activations have a structure remarkably similar to that of our predicted fractal. </span><span>We do this by performing standard linear regression from the residual stream activations (64 dimensional vectors) to the belief distributions (3 dimensional vectors) which associated with them in the MSP.</span></p><figure><span></span><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/carhbn6o5qsly3ztguna"/><span></span><figcaption><span></span><strong>(Left) </strong>The prediction we make for the internal geometry of the trained transformer, as shown in Figure 1. <strong>(Right) </strong>The experimental results. We find a 2D linear projection of the final residual stream activations of our trained transformer whose geometry recapitulates our theoretical prediction! Colors are assigned according to the ground truth belief distributions (as shown on the left).</figcaption></figure><p id="block45">We can also look at how this structure emerges over training, which shows (1) that the structure we find is not trivial<span data-footnote-reference="" data-footnote-index="9" data-footnote-id="44sjyzxh34y" role="doc-noteref" id="fnref44sjyzxh34y"><sup><a href="#fn44sjyzxh34y">[9]</a></sup></span> since it doesn’t exist in detail early in training, and (2) the step-wise refinement of the transformers activations to the fractal structure we predict. </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/gTZ2SxesbHckJ3CkF/ndoowbnucwc34fgrtf8"/><figcaption>Over training we see the restructuring of the transformers internal activations in the residual stream refine to the fractal geometry predicted by our framework.</figcaption></figure><p id="block46"><u>A movie of this process is shown below. Because we used Stochastic Gradient Descent for training, the 2D projection of the activations wiggles, even after training has converged. In this wiggling you can see that fractal structures remain intact.</u></p><figure><div data-oembed-url="https://www.youtube.com/watch?v=HkjnRSmMfxc"><p><iframe src="https://www.youtube.com/embed/HkjnRSmMfxc" allow="autoplay; encrypted-media" allowfullscreen=""></iframe></p></div></figure><h2 id="Limitations">Limitations</h2><ul><li id="block47">Presented here was one simple data structure given by an HMM with 3 states, with a vocab size of 3. In practice, the LLMs that currently exist are much larger, have vocab sizes of &gt;50,000, and natural language has infinite Markov order. Though we&#39;ve tested this theory on other HMMs and everything continues to work, all tests so far have been on similarly small examples. How this relates to larger, more complicated, and more realistic settings is unknown (but we have ideas!). </li><li id="block48">Though we haven&#39;t focused on it in this post, the MSP is an input-driven dynamical system. For each possible input in the system, we have dynamics that determine where in the belief simplex one should move to given the current belief. We have not explicitly tested that the LLM instantiates these dynamics, and instead have only tested that the belief states and their geometry is represented in the transformer.</li><li id="block49">Computational Mechanics is primarily a story about <i>optimal </i>prediction. LLMs in practice won&#39;t be literally optimal. A number of papers exist studying near-optimality, non-optimality, and rate-distortion phenomenon from the point of view of Computational Mechanics, but applying that to LLMs has not been done.</li><li id="block50">We have focused on ergodic and stationary processes in the work presented here. Computational Mechanics can relax those assumptions, but again, we have not applied those (very interesting!) extensions of Computational Mechanics to LLMs. Non-ergodicity, in particular, is likely at the heart of in-context learning.</li><li id="block51">In the experiment presented in this post we focussed on the final layer of the residual stream, right before the unembedding. <span>In other experiments we&#39;ve run (not presented here), the MSP is not well-represented in the final layer but is instead spread out amongst earlier layers. </span><span>We think this occurs because in general there are groups of belief states that are degenerate in the sense that they have the same next-token distribution. In that case, the formalism presented in this post says that even though the distinction between those states must be represented in the transformers internal, the transformer is able to lose those distinctions for the purpose of predicting the next token (in the local sense), which occurs most directly right before the unembedding.</span></li><span></span></ul><h2 id="Next_Steps">Next Steps</h2><ul><li id="block52">We are hopeful that the framing presented in this post provides a formal handle on data structure, internal network structure, and network behavior. </li><li id="block53">There are many open questions about how this work relates to other technical AI Safety work. I&#39;ll list a few ideas very quickly, and expand on these and more in future posts. In particular:<ul><li id="block54">What is the relationship between <i>features </i>and <i>circuits</i>, as studied in Mechanistic Interpretability, and the Mixed-State Geometry?</li><li id="block55">Is there a story about superposition and compression of the MSP in cases where the residual stream is too small to &#34;fit&#34; the MSP.</li><li id="block56">Can we relate the development of MSP geometric structure over training to phenomenon in SLT? see <a href="https://www.lesswrong.com/posts/TjaeCWvLZtEDAS5Ex/towards-developmental-interpretability">Towards Developmental Interpretability</a> </li><li id="block57">Can we use our formalism to operationalize particular capabilities (in-context learning, out-of-distribution generalization, situational awareness, sleeper agents, etc.) and study them in toy models from our framework?</li><li id="block58">Can we use our formalism to understand task structure and how distinct tasks relate to each other? see <a href="https://www.lesswrong.com/posts/exp4JGPJu46g6sdRp/a-starting-point-for-making-sense-of-task-structure-in">A starting point for making sense of task structure (in machine learning)</a> </li></ul></li><li id="block59">As mentioned in the Limitations section, how MSP structures in transformers divide across the layers of the transformer, and how the functional form of the attention mechanism relates to that is an obvious next step.</li><li id="block60">We will be releasing a python library soon to be able to perform these types of experiments. Here is the <a href="https://github.com/adamimos/epsilon-transformers/">github repo</a>.</li><li id="block61">Computational Mechanics is a well-developed framework, and this post has only focused on one small section of it. In the future we hope to bring other aspects of it to bear on neural networks and safety issues, and also to expand Computational Mechanics and combine it with other methods and frameworks. </li><li id="block62">If you&#39;re interested in learning more about Computational Mechanics, we recommend starting with these papers: <a href="https://arxiv.org/abs/cond-mat/9907176">Shalizi and Crutchfield (2000)</a>, <a href="https://arxiv.org/abs/1705.08042">Riechers and Crutchfield (2018a)</a>, and <a href="https://arxiv.org/abs/1706.00883">Riechers and Crutchfield (2018b)</a></li><li id="block63">We (Paul and Adam) have received funding to start a<strong> new AI Safety research org, called </strong><a href="https://www.simplexaisafety.com"><strong>Simplex</strong></a><strong>! </strong>Presented here was one small facet of the type of work we hope to do, and very much only the beginning. Stay tuned for posts that outline our broader vision in the future.</li><li id="block64">In about a month we will be teaming up with Apart to run a <a href="https://www.apartresearch.com/event/compmech">Hackathon</a>! We will post about that soon as well, alongside an open problems post, and some more resources to run experiments.</li><li id="block65">There&#39;s a lot of work to do going forward! This research plan has many parts that span the highly mathematical/theoretical to experimental. If you are interested in being a part of this please have a low threshold for reaching out! </li></ul><ol data-footnote-section="" role="doc-endnotes"><li data-footnote-item="" data-footnote-index="1" data-footnote-id="nla6r2hm9te" role="doc-endnote" id="fnnla6r2hm9te"><span data-footnote-back-link="" data-footnote-id="nla6r2hm9te"><sup><strong><a href="#fnrefnla6r2hm9te">^</a></strong></sup></span><p id="block67"><a href="https://www.lesswrong.com/posts/e6YukTAMzB7krHxRW/pibbss-is-hiring-in-a-variety-of-roles-alignment-research">PIBBSS is hiring</a>! I wholeheartedly recommend them as an organization. </p></li><li data-footnote-item="" data-footnote-index="2" data-footnote-id="2msn39e4jk" role="doc-endnote" id="fn2msn39e4jk"><span data-footnote-back-link="" data-footnote-id="2msn39e4jk"><sup><strong><a href="#fnref2msn39e4jk">^</a></strong></sup></span><p id="block69">One way to conceptualize this is to think of &#34;the world&#34; as having some hidden structure (initially unknown to you), that emits observables. Our task is then to take sequences of observables and infer the hidden structure of the world - maybe in the service of optimal future prediction, but also maybe just because figuring out how the world works is inherently interesting. Inside of us, we have a &#34;world model&#34; that serves as the internal structure that let&#39;s us &#34;understand&#34; the hidden structure of the world. The term world model is contentious and nothing in this post depends on that concept much. However, one motivation for this work is to formalize and make concrete statements about peoples intuitions and arguments regarding neural networks and world models - which are often handwavy and ill-defined.</p></li><li data-footnote-item="" data-footnote-index="3" data-footnote-id="k20y92iwuuf" role="doc-endnote" id="fnk20y92iwuuf"><span data-footnote-back-link="" data-footnote-id="k20y92iwuuf"><sup><strong><a href="#fnrefk20y92iwuuf">^</a></strong></sup></span><p id="block71">Technically speaking, the term <i>process </i>refers to a probability distribution over infinite strings of tokens, while a <i>presentation </i>refers to a particular HMM that produces strings according to the probability distribution. A process has an infinite number of presentations.</p></li><li data-footnote-item="" data-footnote-index="4" data-footnote-id="tdn1ya9cw6d" role="doc-endnote" id="fntdn1ya9cw6d"><span data-footnote-back-link="" data-footnote-id="tdn1ya9cw6d"><sup><strong><a href="#fnreftdn1ya9cw6d">^</a></strong></sup></span><p id="block73">Any HMM defines a probability distribution over infinite sequences of the emissions.</p></li><li data-footnote-item="" data-footnote-index="5" data-footnote-id="s5abv4693vb" role="doc-endnote" id="fns5abv4693vb"><span data-footnote-back-link="" data-footnote-id="s5abv4693vb"><sup><strong><a href="#fnrefs5abv4693vb">^</a></strong></sup></span><p id="block75">Our initial belief distribution, in this particular case, is the uniform distribution over the 3 states of the data generating process. However this is not always the case. In general the initial belief distribution is given by the stationary distribution of the data generating HMM.</p></li><li data-footnote-item="" data-footnote-index="6" data-footnote-id="j5n5l9mkvlr" role="doc-endnote" id="fnj5n5l9mkvlr"><span data-footnote-back-link="" data-footnote-id="j5n5l9mkvlr"><sup><strong><a href="#fnrefj5n5l9mkvlr">^</a></strong></sup></span></li><li data-footnote-item="" data-footnote-index="7" data-footnote-id="ml5xeq780ap" role="doc-endnote" id="fnml5xeq780ap"><span data-footnote-back-link="" data-footnote-id="ml5xeq780ap"><sup><strong><a href="#fnrefml5xeq780ap">^</a></strong></sup></span><p id="block79">There is work in Computational Mechanics that studies non-optimal or near-optimal prediction, and the tradeoffs one incurs when relaxing optimality. This is likely relevant to neural networks in practice. See <a href="https://arxiv.org/pdf/1702.08565.pdf">Marzen and Crutchfield 2021</a> and <a href="https://arxiv.org/abs/1412.2859">Marzen and Crutchfield 2014</a>.</p></li><li data-footnote-item="" data-footnote-index="8" data-footnote-id="czx8aongmnn" role="doc-endnote" id="fnczx8aongmnn"><span data-footnote-back-link="" data-footnote-id="czx8aongmnn"><sup><strong><a href="#fnrefczx8aongmnn">^</a></strong></sup></span></li><li data-footnote-item="" data-footnote-index="9" data-footnote-id="44sjyzxh34y" role="doc-endnote" id="fn44sjyzxh34y"><span data-footnote-back-link="" data-footnote-id="44sjyzxh34y"><sup><strong><a href="#fnref44sjyzxh34y">^</a></strong></sup></span><p id="block83">We&#39;ve also run another control where we retain the ground truth fractal structure but shuffle which inputs corresponds to which points in the simplex (you can think of this as shuffling the colors in the ground truth plot). In this case when we run our regression we get that every residual stream activation is mapped to the center point of the simplex, which is the center of mass of all the points.</p></li></ol></div></div></div></div></div></div><p><span><span><div><div><div><div><div id="cQx3e7rZrCnBBkFgX"><div><div><div><div><div><div><p>Is it accurate to summarize the headline result as follows?</p><ul><li>Train a Transformer to predict next tokens on a distribution generated from an HMM.</li><li>One optimal predictor for this data would be to maintain a belief over which of the three HMM states we are in, and perform Bayesian updating on each new token. That is, it maintains <span><span><span><span aria-label="p(\text{hidden state}=H_i)"><span aria-hidden="true"><span><span>p</span></span><span><span>(</span></span><span><span>hidden state</span></span><span><span>=</span></span><span><span><span><span>H</span></span></span><span><span><span>i</span></span></span></span><span><span>)</span></span></span></span></span></span></span>.</li><li><strong>Key result:</strong> A linear probe on the residual stream is able to reconstruct <span><span><span><span aria-label="p(\text{hidden state} = H_i)"><span aria-hidden="true"><span><span>p</span></span><span><span>(</span></span><span><span>hidden state</span></span><span><span>=</span></span><span><span><span><span>H</span></span></span><span><span><span>i</span></span></span></span><span><span>)</span></span></span></span></span></span></span>.</li></ul><p>(I don&#39;t know what Computational Mechanics or MSPs are so this could be totally off.)</p><p>EDIT: Looks like yes. From <a href="https://www.lesswrong.com/posts/mBw7nc4ipdyeeEpWs/why-would-belief-states-have-a-fractal-structure-and-why">this post</a>:</p><blockquote><p>Part of what this all illustrates is that the fractal shape is kinda… baked into any Bayesian-ish system tracking the hidden state of the Markov model. So in some sense, it’s not very surprising to find it linearly embedded in activations of a residual stream; all that really means is that the probabilities for each hidden state are linearly represented in the residual stream.</p></blockquote></div></div></div></div></div></div><div><div><div id="jFttdRxN7MeuabbEi"><p><span><div><div><p><span>3</span><span>eggsyntax</span><span><time datetime="2024-04-19T17:20:30.379Z">1mo</time></span></p><p>As well as inferring the HMM itself from the data.</p></div></div></span></p></div></div></div></div></div><div><div id="oNt6hJcenwFmoLX4h"><div><div><div><div><div><div><p>&#34;The structure of synchronization is, in general, richer than the world model itself. In this sense, LLMs learn more than a world model&#34; given that I expect this is the statement that will catch a lot of people&#39;s attention.</p><p>Just in case this claim caught anyone else&#39;s attention, what they mean by this is that it contains:</p></div></div></div></div></div></div><div><div><div id="LFmGxTBxCDTWimrA7"><p><span><div><div><p><span>3</span><span>snewman</span><span><time datetime="2024-05-01T21:54:39.944Z">1mo</time></span></p><p>I am trying to wrap my head around the high-level implications of this statement. I can come up with two interpretations:

 1. What LLMs are doing is similar to what people do as they go about their day. When I walk down the street, I am simultaneously using visual and other input to assess the state of the world around me (&#34;that looks like a car&#34;), running a world model based on that assessment (&#34;the car is coming this way&#34;), and then using some other internal mechanism to decide what to do (&#34;I&#39;d better move to the sidewalk&#34;).
 2. What LLMs are doing is harder than what people do. When I converse with someone, I have some internal state, and I run some process in my head – based on that state – to generate my side of the conversation. When an LLM converses with someone, instead of maintaining internal state, needs to maintain a probability distribution over possible states, make next-token predictions according to that distribution, and simultaneously update the distribution.

(2) seems more technically correct, but my intuition dislikes the conclusion, for reasons I am struggling to articulate. ...aha, I think this may be what is bothering me: I have glossed over the distinction between input and output tokens. When an LLM is processing input tokens, it is working to synchronize its state to the state of the generator. Once it switches to output mode, there is no functional benefit to continuing to synchronize state (what is it synchronizing to?), so ideally we&#39;d move to a simpler neural net that does not carry the weight of needing to maintain and update a probability distribution of possible states. (Glossing over the fact that LLMs as used in practice sometimes need to repeatedly transition between input and output modes.) LLMs need the capability to ease themselves into any conversation without knowing the complete history of the participant they are emulating, while people have (in principle) access to their own complete history and so don&#39;t need to be able t</p></div></div></span></p><div><div><div id="3n4SLt6pebFGvtnRu"><p><span><div><div><p><span>2</span><span>AlbertGarde</span><span><time datetime="2024-05-13T17:59:37.941Z">19d</time></span></p><p>You are drawing a distinction between agents that maintain a probability distribution over possible states and those that don&#39;t and you&#39;re putting humans in the latter category. It seems clear to me that all agents are always doing what you describe in (2), which I think clears up what you don&#39;t like about it. 

It also seems like humans spend varying amounts of energy on updating probability distributions vs. predicting within a specific model, but I would guess that LLMs can learn to do the same on their own.</p></div></div></span></p><div><div><div id="KdYRTfy9kbCtqibd6"><p><span><div><div><p><span>2</span><span>snewman</span><span><time datetime="2024-05-13T18:05:52.986Z">19d</time></span></p><p>As I go about my day, I need to maintain a probability distribution over states of the world. If an LLM tries to imitate me (i.e. repeatedly predict my next output token), it needs to maintain a probability distribution, not just over states of the world, but also over my internal state (i.e. the state of the agent whose outputs it is predicting). I don&#39;t need to keep track of multiple states that I myself might be in, but the LLM does. Seems like that makes its task more difficult?

Or to put an entirely different frame on the the whole thing: the job of a traditional agent, such as you or me, is to make intelligent decisions. An LLM&#39;s job is to make the exact same intelligent decision that a certain specific actor being imitated would make. Seems harder?</p></div></div></span></p><div><div><div id="jKwF8taAnfdqPHp37"><p><span><div><div><p><span>1</span><span>Brent</span><span><time datetime="2024-05-23T21:05:15.874Z">9d</time></span></p><p>I agree with you that the LLM&#39;s job is harder, but I think that has a lot to do with the task being given to the human vs. LLM being different in kind. The internal states of a human (thoughts, memories, emotions, etc) can be treated as inputs in the same way vision and sound are. A lot of the difficulty will come from the LLM being given less information, similar to how a human who is blindfolded will have a harder time performing a task where vision would inform what state they are in. I would expect if an LLM was given direct access to the same memories, physical senations, emotions, etc of a human (making the task more equivalent) it could have a much easier time emulating them.

Another analogy for what I&#39;m trying to articulate, imagine a set of twins swapping jobs for the day, they would have a much harder time trying to imitate the other than imitate themselves. Similarly, a human will have a harder time trying to make the same decisions an LLM would make, than the LLM just being itself. The extra modelling of missing information will always make things harder. Going back to your Einstein example, this has the interesting implication that the computational task of an LLM emulating Einstein may be a harder task than an LLM just being a more intelligent agent than Einstein.</p></div></div></span></p><div><div><div id="ihgsudxpPnG2aFftH"><p><span><div><div><p><span>1</span><span>snewman</span><span><time datetime="2024-05-24T00:19:11.365Z">9d</time></span></p><p>I think we&#39;re saying the same thing? &#34;The LLM being given less information [about the internal state of the actor it is imitating]&#34; and &#34;the LLM needs to maintain a probability distribution over possible internal states of the actor it is imitating&#34; seem pretty equivalent.</p></div></div></span></p></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div><div id="2G9XTAyGz5j4eAkCK"><div><div><div><div><div><div><p>[EDIT: I no longer endorse this response, see thread.]</p><p>(This comment is mainly for people other than the authors.)</p><p>If your reaction to this post is &#34;hot damn, look at that graph&#34;, then I think you should probably dial back your excitement somewhat. IIUC the fractal structure is largely an artifact of how the data is visualized, which means the results visually look more striking than they really are.</p><p>It is still a cool piece of work, and the visuals are beautiful. The correct amount of excitement is greater than zero.</p></div></div></div></div></div></div><div><div><div id="fCKgs7rFAAzjhLEc5"><div><div><div><div><div><div><p>To me the consequences of this response were more valuable than the-post-without-this-response, since it led to the <a href="https://www.lesswrong.com/posts/gTZ2SxesbHckJ3CkF/transformers-represent-belief-state-geometry-in-their?commentId=bucADWtEiRM2cG53M">clarification</a> by the post&#39;s author on a crucial point that wasn&#39;t clear in the post and reframed it substantially. And once that clarification arrived, this thread ceased being highly upvoted, which seems the opposite of the right thing to happen.</p>
<blockquote>
<p>I no longer endorse this response</p>
</blockquote>
<p>(So it&#39;s a case where value of content in hindsight disagrees with value of the consequences of its existence. Doesn&#39;t even imply there was originally an error, without the benefit of hindsight.)</p>
</div></div></div></div></div></div></div></div><div><div id="jTBKrhDjCsJznkDCi"><div><div><div><div><div><div><p>Can you elaborate on how the fractal is an artifact of how the data is visualized?</p><p>Though it should be said that an HMM with a fractal MSP is a quite generic choice. It&#39;s remarkably easy to get such fractal structures. If you randomly chose an HMM from the space of HMMs for a given number of states and vocab size, you will often get synchronizations structures with infinite transient states and fractals.</p><p>This isn&#39;t a proof of that previous claim, but here are some examples of fractal MSPs from https://arxiv.org/abs/2102.10487:</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/jTBKrhDjCsJznkDCi/wnzqglx235d3xywuyjmj"/></figure></div></div></div></div></div></div><div><div><div id="tBmARgTfHMyY77Mg8"><p><span><div><div><p><span>6</span><span>johnswentworth</span><span><time datetime="2024-04-17T02:18:30.450Z">2mo</time></span></p><p>I don&#39;t know the details of the MSP, but my current understanding is that it&#39;s a general way of representing stochastic processes, and the MSP representation typically looks quite fractal. If we take two approximately-the-same stochastic processes, then they&#39;ll produce visually-similar fractals.

But the &#34;fractal-ness&#34; is mostly an artifact of the MSP as a representation-method IIUC; the stochastic process itself is not especially &#34;naturally fractal&#34;.

(As I said I don&#39;t know the details of the MSP very well; my intuition here is instead coming from some background knowledge of where fractals which look like those often come from, specifically chaos games.)

A thing which is highly cruxy for me here, which I did not fully understand from the post: what exactly is the function which produces the fractal visual from the residual activations? My best guess from reading the post was that the activations are linearly regressed onto some kind of distribution, and then the distributions are represented in a particular way which makes smooth sets of distributions look fractal. If there&#39;s literally a linear projection of the residual stream into two dimensions which directly produces that fractal, with no further processing/transformation in between &#34;linear projection&#34; and &#34;fractal&#34;, then I would change my mind about the fractal structure being mostly an artifact of the visualization method.</p></div></div></span></p><div><div><div id="bucADWtEiRM2cG53M"><div><div><div><div><div><div><p>Responding in reverse order:</p><blockquote><p>If there&#39;s literally a linear projection of the residual stream into two dimensions which directly produces that fractal, with no further processing/transformation in between &#34;linear projection&#34; and &#34;fractal&#34;, then I would change my mind about the fractal structure being mostly an artifact of the visualization method.</p></blockquote><p>There is literally a linear projection (<s>well, we allow a constant offset actually, so affine</s>) of the residual stream into two dimensions which directly produces that fractal. There&#39;s no distributions in the middle or anything. I<s> suspect the offset is not necessary but I haven&#39;t checked ::adding to to-do list:: </s></p><p>edit: the offset isn&#39;t necessary. There is literally a linear projection of the residual stream into 2D which directly produces the fractal.</p><blockquote><p>But the &#34;fractal-ness&#34; is mostly an artifact of the MSP as a representation-method IIUC; the stochastic process itself is not especially &#34;naturally fractal&#34;.</p><p>(As I said I don&#39;t know the details of the MSP very well; my intuition here is instead coming from some background knowledge of where fractals which look like those often come from, specifically <a href="https://en.wikipedia.org/wiki/Chaos_game">chaos games</a>.)</p></blockquote><p>I&#39;m not sure I&#39;m following, but... <span>(read more)</span></p></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div><div id="fGAidtrkZsRoj9cyr"><div><div><div><div><div><div><p>We&#39;re now working through understanding all the pieces of this, and we&#39;ve calculated an MSP which doesn&#39;t <i>quite</i> look like the one in the post:</p><p>(Ignore the skew, David&#39;s still fiddling with the projection into 2D. The important noticeable part is the absence of &#34;overlap&#34; between the three copies of the main shape, compared to the fractal from the post.)</p><p>Specifically, each point in that visual corresponds to a distribution <span><span><span><span aria-label="(P[H^t = H_0|O^{&lt;t}], P[H^t = H_1|O^{&lt;t}], P[H^t = H_2|O^{&lt;t}])"><span aria-hidden="true"><span><span>(</span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>=</span></span><span><span><span><span>H</span></span></span><span><span><span>0</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>&lt;</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span><span><span>,</span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>=</span></span><span><span><span><span>H</span></span></span><span><span><span>1</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>&lt;</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span><span><span>,</span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>=</span></span><span><span><span><span>H</span></span></span><span><span><span>2</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>&lt;</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span><span><span>)</span></span></span></span></span></span></span> for some value of the observed symbols <span><span><span><span aria-label="O"><span aria-hidden="true"><span><span>O</span></span></span></span></span></span></span>. The image itself is of the points on the probability simplex. From looking at a couple of Crutchfield papers, it sounds like that&#39;s what the MSP is supposed to be.</p><p>The update equations are:</p><ul><li><span><span><span><span aria-label="P[H^{t+1} | O^{\leq t}] = \sum_{H^t} P[H^{t+1}|H^t] P[H^t| O^{\leq t}]"><span aria-hidden="true"><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span><span><span>t</span></span><span><span>+</span></span><span><span>1</span></span></span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>≤</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span><span><span>=</span></span><span><span><span><span>∑</span></span></span><span><span><span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span></span></span></span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span><span><span>t</span></span><span><span>+</span></span><span><span>1</span></span></span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>]</span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>≤</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span></span></span></span></span></span></li><li><span><span><span><span aria-label="P[H^t|O^{\leq t}] = \frac{1}{Z} P[O^t | H^t] P[H^t | O^{&lt;t}]"><span aria-hidden="true"><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>≤</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span><span><span>=</span></span><span><span><span><span><span>1</span></span></span><span><span><span>Z</span></span></span><span></span></span><span></span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>O</span></span></span><span><span><span>t</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>]</span></span><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>O</span></span></span><span><span><span><span><span>&lt;</span></span><span><span>t</span></span></span></span></span></span><span><span>]</span></span></span></span></span></span></span></li></ul><p>with <span><span><span><span aria-label="P[H^{t+1}|H^t]"><span aria-hidden="true"><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span><span><span>t</span></span><span><span>+</span></span><span><span>1</span></span></span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>]</span></span></span></span></span></span></span> given by the transition probabilities, <span><span><span><span aria-label="P[O^t | H^t]"><span aria-hidden="true"><span><span>P</span></span><span><span>[</span></span><span><span><span><span>O</span></span></span><span><span><span>t</span></span></span></span><span><span><span><span>|</span></span></span></span><span><span><span><span>H</span></span></span><span><span><span>t</span></span></span></span><span><span>]</span></span></span></span></span></span></span> given by the observation probabilities, and <span><span><span><span aria-label="Z"><span aria-hidden="true"><span><span>Z</span></span></span></span></span></span></span> a normalizer. We generate the image above by running initializing some random distribution <span><span><span><span aria-label="P[H^0]"><span aria-hidden="true"><span><span>P</span></span><span><span>[</span></span><span><span><span><span>H</span></span></span><span><span><span>0</span></span></span></span><span><span>]</span></span></span></span></span></span></span>, then iterating the equations and plotting each point.</p><p>Off the top of your head, any idea what might account for the mismatch (other than a bug in our code, which we&#39;re alread... <span>(read more)</span></p></div></div></div></div></div></div><div><div><div id="twEXLaWtBcjGSYsvF"><div><div><div><div><div><div><p>Everything looks right to me! This is the annoying problem that people forget to write the actual parameters they used in their work (sorry).</p><p>Try x=0.05, alpha=0.85. I&#39;ve edited the footnote with this info as well.</p></div></div></div></div></div></div><div><div><div id="ayCH6RtgLZs6tkWCK"><p><span><div><div><p><span>3</span><span>johnswentworth</span><span><time datetime="2024-04-17T22:25:12.060Z">1mo</time></span></p><p>Yup, that was it, thankyou!</p></div></div></span></p></div></div></div></div></div><div><div id="bnDW7hqqbLqExAAwK"><p><span><div><div><p><span>5</span><span>Adam Shai</span><span><time datetime="2024-04-17T22:13:09.078Z">1mo</time></span></p><p>Oh wait one thing that looks not quite right is the initial distribution. Instead of starting randomly we begin with the optimal initial distribution, which is the steady-state distribution. Can be computed by finding the eigenvector of the transition matrix that has an eigenvalue of 1. Maybe in practice that doesn&#39;t matter that much for mess3, but in general it could.</p></div></div></span></p><div><div><div id="yRbAB6XYpnpza39sC"><p><span><div><div><p><span>1</span><span>Jett</span><span><time datetime="2024-05-17T09:47:28.554Z">15d</time></span></p><p>For the two sets of mess3 parameters I checked the stationary distribution was uniform.</p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="kdQMgD5P57jaoxdd3"><div><div><div><div><div><p>This is such a cool result! I tried to reproduce it in <a href="https://colab.research.google.com/drive/1qwFGCCG1CMC-ngj2NRsEnXE0qSB_QA38?usp=sharing">this notebook</a></p></div></div></div></div></div></div></div><div><div id="mMvq339M52KBG7q2s"><div><div><div id="oTyyCsKbEudtH2g2q"><p><span><div><div><p><span>2</span><span>Adam Shai</span><span><time datetime="2024-04-17T15:39:13.118Z">1mo</time></span></p><p>this looks highly relevant! thanks!</p></div></div></span></p><div><div><div id="z9JM9XL8doZJKMkPm"><p><span><div><div><p><span>2</span><span>Ran W</span><span><time datetime="2024-04-18T15:53:24.655Z">1mo</time></span></p><p>This reminds me of the paper Chris linked as well. I think there&#39;s very solid evidence on the relationship between the kind of meta learning Transformers go through and Bayesian inference (e.g., see this, this, and this). The main question I have been thinking about is what is a state for language and how that can be useful if so discovered in this way? For state-based RL/control tasks this seems relatively straightforward (e.g., see this and this), but this is much less clear for more abstract tasks. It&#39;d be great to hear your thoughts!</p></div></div></span></p><div><div><div id="7i53hPryA6tsFjeeM"><p><span><div><div><p><span>7</span><span>gwern</span><span><time datetime="2024-05-09T01:59:04.185Z">24d</time></span></p><p>My earlier comment on meta-learning and Bayesian RL/inference for background: https://www.lesswrong.com/posts/TiBsZ9beNqDHEvXt4/how-we-picture-bayesian-agents?commentId=yhmoEbztTunQMRzJx

The way I would put it is that &#39;state&#39; is misleading you here. It makes you think that it must be some sort of little Turing machine or clockwork, where it has a &#39;state&#39;, like the current state of the Turing machine tape or the rotations of each gear in a clockwork gadget, where the goal is to infer that. This is misleading, and it is a coincidence in these simple toy problems, which are so simple that there is nothing to know beyond the actual state.

As Ortega et al highlights in those graphs, what you are really trying to define is the sufficient statistics: the summary of the data (history) which is 100% adequate for decision making, and where additionally knowing the original raw data doesn&#39;t help you.

In the coin flip case, the sufficient statistics are simply the 2-tuple (heads,tails), and you define a very simple decision over all of the possible observed 2-tuples. Note that the sufficient statistic is less information than the original raw &#34;the history&#34;, because you throw out the ordering. (A 2-tuple like &#39;(3,1)&#39; is simpler than all of the histories it summarizes, like &#39;[1,1,1,0]&#39;, &#39;[0,1,1,1]&#39;. &#39;[1,0,1,1]&#39;, etc.) From the point of view of decision making, these all yield the same posterior distribution over the coin flip probability parameter, which is all you need for decision making (optimal action: &#39;bet on the side with the higher probability&#39;), and so that&#39;s the sufficient statistic. If I tell you the history as a list instead of a 2-tuple, you cannot make better decisions. It just doesn&#39;t matter if you got a tails first and then all heads, or all heads first then tails, etc.

It is not obvious that this is true: a priori, maybe that ordering was hugely important, and those correspond to different games. But the RNN there has learned that the differences are not impor</p></div></div></span></p></div></div></div></div></div></div></div></div></div></div></div><div><div id="HzHHjSfF9rJSiGduK"><div><div><div><div><div><div><p>This is very cool! I’m excited to see where it goes :)</p><p>A couple questions (mostly me grappling with what the implications of this work might be):</p><ul><li>Given a dataset of sequences of tokens, how do you find the HMM that could have generated it, and can this be done automatically? Also, is the mapping from dataset to HMM unique?</li><li>This question is possibly more confused on my end, sorry if so. I’m trying to get at something like “how interpretable will these simplexes be with much larger models?” Like, if I’m imagining that each state is a single token, and the HMM is capable of generating the totality of data the model sees, then I’m imagining something quite unwieldy, i.e., something with about the amount of complexity and interpretability as, e.g., the signaling cascade networks in a cell. Is this imagination wrong? Or is it more like, you start with this unwieldy structure (but which has some nice properties nonetheless), and then from there you try to make the initial structure more parse-able? Maybe a more straightforward way to ask: you say you’re interested in formalizing things like situational awareness with these tools—how might that work?</li></ul></div></div></div></div></div></div><div><div><div id="vcX2AxdJZQXygeaWk"><div><div><div><div><div><div><p>Thanks!</p><ul><li>one way to construct an HMM is by finding all past histories of tokens that condition the future tokens with the same probablity distribution, and make that equivalence class a hidden state in your HMM. Then the conditional distributions determine the arrows coming out of your state and which state you go to next. This is called the &#34;epsilon machine&#34; in Comp Mech, and it is unique. It is one <i>presentation</i> of the data generating process, but in general there are an infinite number of HMM presntations that would generate the same data. The epsilon machine is a particular type of HMM presentation - it is the smallest one where the hidden states are the minimal sufficient statistics for predicting the future based on the past. The epsilon machine is one of the most fundamental things in Comp Mech but I didn&#39;t talk about it in this post. In the future we plan to make a more generic Comp Mech primer that will go through these and other concepts.</li><li>The interpretability of these simplexes is an issue that&#39;s in my mind a lot these days. The short answer is I&#39;m still wrestling with it. We have a rough experimental plan to go about studying this issue but for now, here are some related que</li></ul><p>... <span>(read more)</span></p></div></div></div></div></div></div><div><div><div id="irvCxgPh6Hov2Fxcs"><p><span><div><div><p><span>1</span><span>lillybaeum</span><span><time datetime="2024-04-22T11:01:33.958Z">1mo</time></span></p><p>The following is text from Claude Opus 3. I generally find people just dumping answers from LLMs to be kind of cringe, but in this case, as I was using it to try to understand the post and your comments better, I came across some really genuinely insightful-feeling stuff and felt as though Claude&#39;s input might be helpful to you in some way, and that it would be remiss not to share it. I&#39;m sorry if it&#39;s nonsensical, I&#39;m not informed enough on the topic to know.

&#34;Regarding the relationship between belief states and &#34;features&#34;, I think there are a few important connections:

 * Belief states can be thought of as the &#34;true features&#34; that optimally compress the information needed for prediction. In the simplex visualizations, each point corresponds to a unique belief state - a particular probabilistic weighting of the possible hidden states of the generator at that point in the sequence. These belief states are the most parsimonious representation of the relevant information for predicting the future.

 * The &#34;features&#34; often discussed in mech interp (e.g. as visualized in attribution maps or extracted by probing classifiers) can be seen as approximations or projections of these true belief states. When we probe an LM&#39;s activations and find that certain neurons or directions correspond to interpretable features like &#34;noun-ness&#34; or &#34;sentiment&#34;, we&#39;re effectively discovering linear projections that approximate some aspect of the true belief state.

 * The topology and geometry of the belief state simplex can give us intuitions about the structure of these feature spaces. For example, the fact that belief states are constrained to a simplex (rather than an unbounded space) suggests that there may be inherent trade-offs or dependencies between different features. The trajectories of belief states through the simplex as a sequence evolves could also inform us about the dynamics of how features interact and compose.

So in a sense, belief states provide a principled foundatio</p></div></div></span></p><div><div><div id="fFCxBtuxhLg6AeFSt"><p><span><div><div><p><span>4</span><span>Alexander Gietelink Oldenziel</span><span><time datetime="2024-04-22T11:22:11.309Z">1mo</time></span></p><p>Not at all cringe! This is the age of AI. We either channel its immense power or ignore it at our own peril.

There is no human alive today that is utilizing even last-generation&#39;s LLMs at their full potential. We should all be copying, delegating and cyborging much more from, to and with LLM - not less.</p></div></div></span></p></div></div></div></div></div></div></div></div></div></div></div><div><div id="X5nhTsmBNWJqBXoJT"><div><div><div><div><div><div><blockquote><p>transformer is only trained explicitly on next token prediction!</p></blockquote><p>I find myself understanding language/multimodal transformer capabilities better when I think about the whole document (up to context length) as a mini-batch for calculating the gradient in transformer (pre-)training, so I imagine it is minimizing the document-global prediction error, it wasn&#39;t trained to optimize for just a single-next token accuracy...</p></div></div></div></div></div></div><div><div><div id="mTnJE7rhsKBQdArzG"><div><div><div><div><div><div><p><a href="https://arxiv.org/abs/2404.00859">There is evidence</a> that transformers are <em>not</em> in fact even implicitly, internally, optimized for reducing global prediction error (except insofar as comp-mech says they must in order to do well on the task they are optimized for).</p>
<blockquote>
<p>Do transformers &#34;think ahead&#34; during inference at a given position? It is known transformers prepare information in the hidden states of the forward pass at t that is then used in future forward passes t+τ. We posit two explanations for this phenomenon: pre-caching, in which off-diagonal gradient terms present in training result in the model computing features at t irrelevant to the present inference task but useful for the future, and breadcrumbs, in which features most relevant to time step t are already the same as those that would most benefit inference at time t+τ. We test these hypotheses by training language models without propagating gradients to past timesteps, a scheme we formalize as myopic training. In a synthetic data setting, we find clear evidence for pre-caching. In the autoregressive language modeling setting, our experiments are more suggestive of the breadcrumbs hypothesis.</p>
</blockquote>
</div></div></div></div></div></div><div><div><div id="yiSFtg8jxuRdGgjTD"><div><div><div><div><div><div><p>I think that paper is some evidence that there&#39;s typically no huge effect from internal activations being optimized for predicting future tokens (on natural language). But I don&#39;t think it&#39;s much (if any) evidence that this doesn&#39;t happen to some small extent or that it couldn&#39;t be a huge effect on certain other natural language tasks.</p><p>(In fact, I think the myopia gap is probably the more relevant number than the local myopia bonus, in which case I&#39;d argue the paper actually shows a pretty non-trivial effect, kind of contrary to how the authors interpret it. But I haven&#39;t read the paper super closely.)</p><p>Also, sounds like you&#39;re aware of this, but I&#39;d want to highlight more that the paper does demonstrate internal activations being optimized for predicting future tokens on synthetic data where this is necessary. So, arguably, the main question is to what extent natural language data incentivizes this rather than being specifically about what transformers can/tend to do.</p><p>In that sense, thinking of transformer internals as &#34;trying to&#34; minimize the loss on an entire document might be exactly the right intuition empirically (and the question is mainly how different that is from being myopic on a given dataset). Given that the internal states are optimized for this, that would also make sense theoretically IMO.</p></div></div></div></div></div></div><div><div><div id="tFxzHK6oGksdKC8gM"><p><span><div><div><p><span>7</span><span>ryan_greenblatt</span><span><time datetime="2024-04-18T03:02:08.677Z">1mo</time></span></p><p>+1 to this comment, also I expect the importance of activations being optimized for predicting future tokens to increase considerably with scale. (E.g., GPT-4 level compute maybe just gets you a GPT-3 level model if you enforce no such optimization with a stop grad.)</p></div></div></span></p></div></div></div></div></div><div><div id="4jRXmKwwgNPMNj3eK"><p><span><div><div><p><span>5</span><span>Aleksey Bykhun</span><span><time datetime="2024-04-23T03:10:44.081Z">1mo</time></span></p><p>I have tried to play with Claude – I would ask it to think of a number, drop the hint, and only then print the number. It should have test the ability to have &#34;hidden memory&#34; that&#39;s outside the text.

I expected it to be able to do that, but the hints to be too obvious. Instead, actually it failed multiple times in a row!

Sharing cause I liked the experiment but wasn&#39;t sure if I executed it properly. There might be a way to do more of this.

P.S. I have also tried &#34;print hash, and then preimage&#34; – but this turned out to be even harder for him</p></div></div></span></p><div><div><div id="mb7MJ3WLJgxegn9BH"><p><span><div><div><p><span>2</span><span>Garrett Baker</span><span><time datetime="2024-04-23T03:22:15.095Z">1mo</time></span></p><p>Post the chat logs?</p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="Kc3bjpyhByydT3n3X"><p><span><div><div><p><span>2</span><span>Adam Shai</span><span><time datetime="2024-04-17T18:42:32.194Z">1mo</time></span></p><p>That&#39;s an interesting framing. From my perspective that is still just local next-token accuracy (cross-entropy more precisely), but averaged over all subsets of the data up to the context length. That is distinct from e.g. an objective function that explicitly mentioned not just next-token prediction, but multiple future tokens in what was needed to minimize loss. Does that distinction make sense?

One conceptual point I&#39;d like to get across is that even though the equation for the predictive cross-entropy loss only has the next token at a given context window position in it, the states internal to the transformer have the information for predictions into the infinite future.

This is a slightly different issue than how one averages over training data, I think.</p></div></div></span></p><div><div><div id="qaJjtz6gf8Cbe4wEe"><p><span><div><div><p><span>1</span><span>Aprillion (Peter Hozák)</span><span><time datetime="2024-04-18T14:12:57.483Z">1mo</time></span></p><p>To me as a programmer and not a mathematitian, the distinction doesn&#39;t make practical intuitive sense.

If we can create 3 functions f, g, h so that they &#34;do the same thing&#34; like f(a, b, c) == g(a)(b)(c) == average(h(a), h(b), h(c)), it seems to me that cross-entropy can &#34;do the same thing&#34; as some particular objective function that would explicitly mention multiple future tokens.

My intuition is that cross-entropy-powered &#34;local accuracy&#34; can approximate &#34;global accuracy&#34; well enough in practice that I should expect better global reasoning from larger model sizes, faster compute, algorithmic improvements, and better data.

Implications of this intuition might be:

 * myopia is a quantity not a quality, a model can be incentivized to be more or less myopic, but I don&#39;t expect it will be proven possible to enforce it &#34;in the limit&#34;
 * instruct training on longer conversations outght to produce &#34;better&#34; overall conversations if the model simulates that it&#39;s &#34;in the middle&#34; of a conversation and follow-up questions are better compared to giving a final answer &#34;when close to the end of this kind of conversation&#34;

What nuance should I consider to understand the distinction better?</p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="PbafAEQPwgKszqbed"><div><div><div><div><div><div><p>Promoted to curated: Formalizing what it means for transformers to learn &#34;the underlying world model&#34; when engaging in next-token prediction tasks seems pretty useful, in that it&#39;s an abstraction that I see used all the time when discussing risks from models where the vast majority of the compute was spent in pre-training, where the details usually get handwaived. It seems useful to understand what exactly we mean by that in more detail. </p><p>I have not done a thorough review of this kind of work, but it seems to me that also others thought the basic ideas in the work hold up, and I thought reading this post gave me crisper abstractions to talk about this kind of stuff in the future.</p></div></div></div></div></div></div></div></div><div><div id="ibBRwoNnBLsB3N4yo"><div><div><div><div><div><div><p>I really enjoyed reading this post! It&#39;s quite well-written. Thanks for writing it.</p><p>One question: If you optimize the representation in the residual stream such that it corresponds to a particular chosen belief state, does the transformer than predict the next token <i>as if</i> in that belief state? I.e., does the transformer use the belief state for making predictions?</p></div></div></div></div></div></div><div><div><div id="xMpLt8JjkzxwyqzuR"><p><span><div><div><p><span>1</span><span>Adam Shai</span><span><time datetime="2024-04-17T18:26:48.089Z">1mo</time></span></p><p>Thanks! I appreciate the critique. From this comment and from John&#39;s it seems correct and I&#39;ll keep it in mind for the future.

On the question, by optimize the representation do you mean causally intervene on the residual stream during inference (e.g. a patching experiment)? Or do you mean something else that involves backprop? If the first, then we haven&#39;t tried, but definitely want to! It could be something someone does at the Hackathon, if interested ;)</p></div></div></span></p><div><div><div id="JELpE5RJ9wM8cPCrn"><p><span><div><div><p><span>1</span><span>Leon Lang</span><span><time datetime="2024-04-17T20:46:26.981Z">1mo</time></span></p><p>Yes the first! Thanks for the link!</p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="3TsYjB7Q7FjYCAJiY"><div><div><div><div><div><p>I have maybe a naive question. What information is needed to find the MSP image within the neural network? Do we have to know the HMM to begin with? Or could it be feasible someday to inspect a neural network, find something that looks like an MSP image, and infer the HMM from it?</p></div></div></div></div></div></div></div><div><div id="vnG3Xk4Pn2eyedok9"><div><div><div><div><div><div><p>I struggled with the notation on the figures; this comment tries to clarify a few points for anyone else who may be confused by it.</p><ul><li>There are three main diagrams to pay attention to in order to understand what&#39;s going on here:<ul><li>The Z1R Process (this is a straightforward Hidden Markov Model diagram, look them up if it&#39;s unclear).</li><li>The Z1R Mixed-State Presentation, representing the belief states of a model as it learns the underlying structure.</li><li>The Z1R Mixed-State Simplex. Importantly, unlike the other two this is a graph and spatial placement is meaningful.</li></ul></li><li>It&#39;s b</li></ul><p>... <span>(read more)</span></p></div></div></div></div></div></div><div><div><div id="JjKYpsmy4KhMP5eCD"><p><span><div><div><p><span>1</span><span>Adam Shai</span><span><time datetime="2024-04-20T01:47:05.424Z">1mo</time></span></p><p>This all looks correct to me! Thanks for this.</p></div></div></span></p></div></div></div></div></div><div><div id="ML5j9ziW3TALbM9m6"><div><div><div><div><div><p>I&#39;m curious how much space is left after learning the MSP in the network.  Does representing the MSP take up the full bandwidth of the model (even if it is represented inefficiently)?  Could you maintain performance of the model by subtracting out the contributions of anything else that isn&#39;t part of the MSP?</p></div></div></div></div></div><div><div><div id="WoNjwscjXvTAhRiF3"><p><span><div><div><p><span>1</span><span>Adam Shai</span><span><time datetime="2024-04-17T18:24:27.366Z">1mo</time></span></p><p>Cool question. This is one of the things we&#39;d like to explore more going forward. We are pretty sure this is pretty nuanced and has to do with the relationship between the (minimal) state of the generative model, the token vocab size, and the residual stream dimensionality.

One your last question, I believe so but one would have to do the experiment! It totally should be done. check out the Hackathon if you are interested ;)</p></div></div></span></p></div></div></div></div></div><div><div id="JkgjmtAijcugDvn2T"><div><div><div><div><div><p>This is extremely cool! Can you go into more detail about the step used to project the 64 dimensional residual stream to 3 dimensional space? Did you do a linear fit over a few test points and then used it on all the others?</p></div></div></div></div></div></div></div><div><div id="3WJHLoz5c7LsYRJow"><div><div><div><div><div><div><p>This is really cool work!!</p><blockquote><p>In other experiments we&#39;ve run (not presented here), the MSP is not well-represented in the final layer but is instead spread out amongst earlier layers. We think this occurs because in general there are groups of belief states that are degenerate in the sense that they have the same next-token distribution. In that case, the formalism presented in this post says that even though the distinction between those states must be represented in the transformers internal, the transformer is able to lose those distinctions for the purpose</p></blockquote><p>... <span>(read more)</span></p></div></div></div></div></div></div><div><div><div id="nugAMar9DqnCjewtg"><p><span><div><div><p><span>1</span><span>Adam Shai</span><span><time datetime="2024-04-19T23:39:02.362Z">1mo</time></span></p><p>Thanks! I&#39;ll have more thorough results to share about layer-wise reprsentations of the MSP soon. I&#39;ve already run some of the analysis concatenating over all layers residual streams with RRXOR process and it is quite interesting. It seems there&#39;s a lot more to explore with the relationship between number of states in the generative model, number of layers in the transformer, residual stream dimension, and token vocab size. All of these (I think) play some role in how the MSP is represented in the transformer. For RRXOR it is the case that things look crisper when concatenating. 

Even for cases where redundant info is discarded, we should be able to see the distinctions somewhere in the transformer. One thing I&#39;m keen on really exploring is such a case, where we can very concretely follow the path/circuit through which redundant info is first distinguished and then is collapsed.</p></div></div></span></p></div></div></div></div></div><div><div id="TsLydz4kHJsSHAYf3"><div><div><div><div><div><div><blockquote><p>We do this by performing standard linear regression from the residual stream activations (64 dimensional vectors) to the belief distributions (3 dimensional vectors) which associated with them in the MSP.</p></blockquote></div></div></div></div></div></div><div><div><div id="xAN7Pzuvy7jKb3Z5z"><p><span><div><div><p><span>3</span><span>Adam Shai</span><span><time datetime="2024-04-17T22:10:34.911Z">1mo</time></span></p><p>I should have explained this better in my post.

For every input into the transformer (of every length up to the context window length), we know the ground truth belief state that comp mech says an observer should have over the HMM states. In this case, this is 3 numbers. So for each input we have a 3d ground truth vector.  Also, for each input we have the residual stream activation (in this case a 64D vector). To find the projection we just use standard Linear Regression (as implemented in sklearn) between the 64D residual stream vectors and the 3D (really 2D) ground truth vectors. Does that make sense?</p></div></div></span></p><div><div><div id="upQghYKctwLzb4Fem"><p><span><div><div><p><span>2</span><span>dr_s</span><span><time datetime="2024-04-20T12:12:47.891Z">1mo</time></span></p><p>Given that the model eventually outputs the next token, shouldn&#39;t the final embedding matrix be exactly your linear fit matrix multiplied by the probability of each state to output a given token? Could you use that?</p></div></div></span></p></div></div><div><div id="o4XEzmLXxX3pdsAkA"><p><span><div><div><p><span>1</span><span>Sandi</span><span><time datetime="2024-04-18T18:20:56.883Z">1mo</time></span></p><p>Yep, that&#39;s what I was trying to describe as well. Thanks!</p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="5q3zgFKv3e29oQzNj"><div><div><div><div><div><div><blockquote><p>We look in the final layer of the residual stream and find a linear 2D subspace where activations have a structure remarkably similar to that of our predicted fractal. We do this by performing standard linear regression from the residual stream activations (64 dimensional vectors) to the belief distributions (3 dimensional vectors) which associated with them in the MSP.</p></blockquote><p>Naive technical question, but can I ask for a more detailed description of how you go from the activations in the residual stream to the map you have here? Or like, can someone point m... <span>(read more)</span></p></div></div></div></div></div></div></div></div><div><div id="XDkKeNc2RYdceZeDB"><div><div><div><div><div><p>I thought that the part about models needing to keep track of a more complicated mix-state presentation as opposed to just the world model is one of those technical insights that&#39;s blindingly obvious once someone points it out to you (i.e., the best type of insight :)). I love how the post starts out by describing the simple ZIR example to help us get a sense of what these mixed state presentations are like. Bravo!</p></div></div></div></div></div><div><div><div id="ivzZawimH2Lh5NYDD"><p><span><div><div><p><span>1</span><span>Adam Shai</span><span><time datetime="2024-05-26T03:39:39.422Z">7d</time></span></p><p>Thanks! In my experience Computational Mechanics has many of those types of technical insights. My background is in neuroscience and in that context it really helped me think about computation in brains, and design experiments. Now I&#39;m excited to use Comp Mech in a more concrete and deeper way to understand how artificial neural network internal structures relate to their behavior. Hopefully this is just the start!</p></div></div></span></p></div></div></div></div></div><div><div id="ef4q3dZq8HkJNkFM7"><div><div><div><div><div><p>This might be an adjacent question but assuming this is true and comprehensively explains the belief updating process. What does it say, if anything, about whether transformers can produce new (undiscovered) knowledge/states? If they can&#39;t observe a novel state - something that doesn&#39;t exist in the data - can they never discover new knowledge on their own?</p></div></div></div></div></div><div><div><div id="Bc5gknsoqPYAxvydn"><p><span><div><div><p><span>1</span><span>Adam Shai</span><span><time datetime="2024-05-03T01:31:50.937Z">1mo</time></span></p><p>This is a great question, and one of the things I&#39;m most excited about using this framework to study in the future! I have a few ideas but nothing to report yet.

But I will say that I think we should be able to formalize exactly what it would mean for a transformer to create/discover new knowledge, and also to apply the structure from one dataset and apply it to another, or to mix two abstract structures together, etc. I want to have an entire theory of cognitive abilities and the geometric internal structures that support them.</p></div></div></span></p><div><div><div id="ZjChoitkhBwhHtd2w"><p><span><div><div><p><span>1</span><span>Moughees Ahmed</span><span><time datetime="2024-05-03T15:03:09.574Z">1mo</time></span></p><p>Excited to see what you come up with! 

Plausibly, one could think that if a model, trained on the entirety of human output, should be able to decipher more hidden states - ones that are not obvious to us - but might be obvious in latent space. It could mean that models might be super good at augmenting our existing understanding of fields but might not create new ones from scratch. </p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="FJx8daqjQBm7TJ7ER"><div><div><div><div><div><div><p>The <a href="https://www.lesswrong.com/bestoflesswrong">LessWrong Review</a> runs every year to select the posts that have most stood the test of time. This post is not yet eligible for review, but will be at the end of 2025. The top fifty or so posts are featured prominently on the site throughout the year. Will this post make the top fifty?</p><figure><div data-oembed-url="https://manifold.markets/LessWrong/will-transformers-represent-belief">
        
      </div></figure>
  </div></div></div></div></div></div></div></div><div><div id="6qwzbKcvbHH6JKoNC"><div><div><div><div><div><p>If I understand this right, you train a transformer on data generated from a hidden markov process, of the form {0,1,R} and find that there is a mechanism for tracking when R occurs in the residual stream, as well as that the transformer learns the hidden markov process. is that correct?</p></div></div></div></div></div><div><div><div id="dg9vLpG7afNpvPC5F"><p><span><div><div><p><span>4</span><span>Keenan Pepper</span><span><time datetime="2024-04-20T23:50:32.543Z">1mo</time></span></p><p>No, the actual hidden Markov process used to generate the awesome triangle fractal image is not the {0,1,random} model but a different one, which is called &#34;Mess3&#34; and has a symmetry between the 3 hidden states.

Also, they&#39;re not claiming the transformer learns merely the hidden states of the HMM, but a more complicated thing called the &#34;mixed state presentation&#34;, which is not the states that the HMM can be in but the (usually much larger number of) belief states which an ideal prediction process trying to &#34;sync&#34; to it might go thru.</p></div></div></span></p></div></div></div></div></div><div><div id="dj95PxdwFzXpYAEbr"><div><div><div><div><div><p>If I understand correctly, the next-token prediction of Mess3 is related to the current-state prediction by a nonsingular linear transformation. So a linear probe showing &#34;the meta-structure of an observer&#39;s belief updates over the hidden states of the generating structure&#34; is equivalent to one showing &#34;the structure of the next-token predictions&#34;, no?</p></div></div></div></div></div><div><div><div id="566xYa5gjmHiFCqFX"><p><span><div><div><p><span>3</span><span>Nisan</span><span><time datetime="2024-04-18T17:05:57.156Z">1mo</time></span></p><p>I suppose if you had more hidden states than observables, you could distinguish hidden-state prediction from next-token prediction by the dimension of the fractal.</p></div></div></span></p></div></div></div></div></div><div><div id="xyhkka5Zq5jfhzFn4"><div><div><div><div><div><div><p>This reminds me a lot of a toy project I have in the back of my mind but will probably never get around to: </p><p>Which is to train a transformer on the sequences generated by the logic models from the apperception engine paper (which in the paper are inferred by the apperception engine from the sequences) with the aim of predicting the logic model. </p></div></div></div></div></div></div><div><div><div id="MncH5zwwbH2FLdTWp"><p><span><div><div><p><span>2</span><span>Adam Shai</span><span><time datetime="2024-04-17T20:53:40.104Z">1mo</time></span></p><p>That sounds interesting. Do you have a link to the apperception paper?</p></div></div></span></p><div><div><div id="RJz9mmqy7XR7LrBKD"><p><span><div><div><p><span>3</span><span>p.b.</span><span><time datetime="2024-04-18T17:36:27.989Z">1mo</time></span></p><p>https://www.sciencedirect.com/science/article/pii/S0004370220301855#se0050

https://www.sciencedirect.com/science/article/pii/S0004370221000722</p></div></div></span></p></div></div><div><div id="NxH9XC4WQ6PT4pru7"><p><span><div><div><p><span>3</span><span>MondSemmel</span><span><time datetime="2024-04-18T06:53:12.429Z">1mo</time></span></p><p>This book chapter and this paper, maybe?</p></div></div></span></p><div><div><div id="wJsnTixjsMs2zyfsw"><p><span><div><div><p><span>1</span><span>p.b.</span><span><time datetime="2024-04-18T17:38:29.114Z">1mo</time></span></p><p>Hah, I didn&#39;t see your answer but our links complement nicely. 

I think my first link was the paper that was making some waves when it came out.</p></div></div></span></p></div></div></div></div></div></div></div></div></div></div></div><div><div id="h4rbcqeskgjfcnxvM"><div><div><div><div><div><p>This is interesting as commentary on superposition, where activation vectors with N dimensions can be used to represent many more concepts, since the N-dimensional space/sphere can be partitioned into many more regions than N, each with its own meaning. If similar fractal structure substantially occurs in the original activation bases (such as the Vs of attention, as in the V part of KV-cache) and not just after having been projected to dramatically fewer dimensions, this gives a story for role of nuance that improves with scale that&#39;s different from it be... <span>(read more)</span></p></div></div></div></div></div></div></div><div><div id="zAbDEcxbKqvkA5CCL"><div><div><div><div><div><p>Can you help me understand a minor labeling convention that puzzles me? I can see how we can label <span><span><span><span aria-label="S_R"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>R</span></span></span></span></span></span></span></span></span> from the Z1R process as <span><span><span><span aria-label="η_{11}"><span aria-hidden="true"><span><span><span><span><span><span>η</span></span></span></span></span><span><span><span><span><span>11</span></span></span></span></span></span></span></span></span></span></span> in MSP because we observe 11 to get there, but why <span><span><span><span aria-label="S_1"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>1</span></span></span></span></span></span></span></span></span> is labeled as <span><span><span><span aria-label="η_{01}"><span aria-hidden="true"><span><span><span><span><span><span>η</span></span></span></span></span><span><span><span><span><span>01</span></span></span></span></span></span></span></span></span></span></span> after observing either 100 or 00, please?</p></div></div></div></div></div><div><div><div id="iYBJnkh3hMqCv6jo7"><p><span><div><div><p><span>2</span><span>Adam Shai</span><span><time datetime="2024-04-17T07:10:35.249Z">1mo</time></span></p><p>Good catch! That should be eta_00, thanks! I&#39;ll change it tomorrow.</p></div></div></span></p></div></div></div></div></div><div><div id="FvpHbwSvuQGfMEFQy"><div><div><div><div><div><p>What is the shape predicted by compmech under a generation setting, and do you expect it instead of the fractal shape to show up under, say, a GAN loss? If so, and if their shapes are sufficiently distinct from the controls that are run to make sure the fractals aren&#39;t just a visualization artifact, that would be further evidence in favor of the applicability of compmech in this setup.</p></div></div></div></div></div><div><div><div id="kKnAHm8s2o2cnn6gt"><p><span><div><div><p><span>2</span><span>Adam Shai</span><span><time datetime="2024-04-17T03:26:06.510Z">2mo</time></span></p><p>Cool idea! I don&#39;t know enough about GANs and their loss so I don&#39;t have a prediction to report right now. If it is the case that GAN loss should really give generative and not predictive structure, this would be a super cool experiment.

The structure of generation for this particular process has just 3 points equidistant from eachother, no fractal. But in general the shape of generation is a pretty nuanced issue because it&#39;s nontrivial to know for sure that you have the minimal structure of generation. There&#39;s a lot more to say about this but @Paul Riechers knows these nuances more than I do so I will leave it to him!</p></div></div></span></p></div></div></div></div></div><div><div id="vfLfAfKztJKE6Jj58"><div><div><div><div><div><div><p>Thanks for the post, it&#39;s neat to see the fields and terms existing for these questions.</p><p>I have two questions for hope of using this type of analysis in my work to analyze a lack of transfer between two distinct datasets A and B. (I see this is in your future work?) </p><p>1. Where does OOD data project, or data that is implausible for the model?</p><p>2. For more complex data, might we expect this MSP to most clearly show in places other than the final layer?</p><p>re: transfer, my hypothesis is that we might be able to see, having trained on A and B, that during inferenc... <span>(read more)</span></p></div></div></div></div></div></div></div></div><div><div id="N85KnZdNiMSpMD8tZ"><div><div><div><div><div><p>this post seems like a win for PIBBSS gee</p></div></div></div></div></div></div></div><div><div id="JrREAMhkpKuqsdmSA"><div><div><div><div><div><p>This is very interesting work, showing the fractal graph is a good way to visualize the predictive model being learned. I&#39;ve had many conversations with folks who struggle with the idea &#39;the model is just predicting the next token, how can it be doing anything interesting&#39;?. My standard response had been that conceptually the transformer model matches up tokens at the first layer (using the key and query vectors), then matches up sentences a few layers up, and then paragraphs a few layers above that; hence the model, when presented with an input, was not j... <span>(read more)</span></p></div></div></div></div></div></div></div><div><div id="Gx2CrfAkcpPLvWDvJ"><div><div><div><div><div><div><blockquote>
<p>We think this occurs because in general there are groups of belief states that are degenerate in the sense that they have the same next-token distribution. In that case, the formalism presented in this post says that even though the distinction between those states must be represented in the transformers internal, the transformer is able to lose those distinctions for the purpose of predicting the next token (in the local sense), which occurs most directly right before the unembedding.</p>
</blockquote>
<p>I wonder if you could force the Mixed-State Presentation to be &#34;conse... <span>(read more)</span></p></div></div></div></div></div></div></div></div><div><div id="ueizEMKQqt4PJiFAh"><div><div><div><div><div><p>Fascinating. But are these diagrams really showing HMMs? I thought each state in an HMM had a set of transition probabilities and another set of emission probabilities, which at each step are sampled independently. In these diagrams, the two processes are coupled. If &#34;Even Ys&#34; were a conventional HMM, <span><span><span><span aria-label="S_E"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>E</span></span></span></span></span></span></span></span></span> would sometimes emit X and transition to <span><span><span><span aria-label="S_O"><span aria-hidden="true"><span><span><span><span>S</span></span></span><span><span><span>O</span></span></span></span></span></span></span></span></span>, which would result in some even and some odd runs of Y. Are these a special variant of HMM, or some other type of state machine? And would these results apply to conventional HMMs with separate tr... <span>(read more)</span></p></div></div></div></div></div></div></div><div><div id="pd8bNL7xYv8dN4McC"><div><div><div><div><div><div><p>Nice explanation of MSP and good visuals.</p>
<blockquote>
<p>This is surprising!</p>
</blockquote>
<p>Were you in fact surprised? If so, why? (This is a straightforward consequence of the good regulator theorem<sup><a href="#fn-wcbhjC2q7m3LPvySd-1" id="fnref-wcbhjC2q7m3LPvySd-1">[1]</a></sup>.)</p><p>In general I&#39;d encourage you to carefully track claims about transformers, HMM-predictors, and LLMs, and to distinguish between trained NNs and the training process. In this writeup, all of these are quite blended.</p>
<hr/>
<section>
<ol>
<li id="fn-wcbhjC2q7m3LPvySd-1"><p><a href="https://www.lesswrong.com/posts/Dx9LoqsEh3gHNJMDk/fixing-the-good-regulator-theorem">John has a good explication here</a> <a href="#fnref-wcbhjC2q7m3LPvySd-1">↩︎</a></p>
</li>
</ol>
</section></div></div></div></div></div></div><div><div><div id="pv3GQgZBSWaNmz4pf"><p><span><div><div><p><span>5</span><span>kave</span><span><time datetime="2024-05-02T22:32:23.921Z">1mo</time></span></p><p>IIUC, the good regulator theorem doesn&#39;t say anything about how the model of the system should be represented in the activations of the residual stream. I think the potentially surprising part is that the model is recoverable with a linear probe.</p></div></div></span></p></div></div><div><div id="smLPCJPzDtmvnnGAB"><p><span><div><div><p><span>3</span><span>Adam Shai</span><span><time datetime="2024-05-03T01:25:45.484Z">1mo</time></span></p><p>It&#39;s surprising for a few reasons:

 * The structure of the points in the simplex is NOT
   * The next token prediction probabilities (ie. the thing we explicitly train the transformer to do)
   * The structure of the data generating model (ie. the thing the good regulator theorem talks about, if I understand the good regulator theorem, which I might not)

The first would be not surprising because it&#39;s literally what our loss function asks for, and the second might not be that surprising since this is the intuitive thing people often think about when we say &#34;model of the world.&#34; But the MSP structure is neither of those things. It&#39;s the structure of inference over the model of the world, which is quite a different beast than the model of the world.

Others might not find it as surprising as I did - everyone is working off their own intuitions.

edit: also I agree with what Kave said about the linear representation.</p></div></div></span></p><div><div><div id="dsJaSw7feGJZ7vcSb"><p><span><div><div><p><span>2</span><span>Oliver Sourbut</span><span><time datetime="2024-05-03T10:50:26.729Z">1mo</time></span></p><p>I guess my question would be &#39;how else did you think a well-generalising sequence model would achieve this?&#39; Like, what is a sufficient world model but a posterior over HMM states in this case? This is what GR theorem asks. (Of course, a poorly-fit model might track extraneous detail or have a bad posterior.)

From your preamble and your experiment design, it looks like you correctly anticipated the result, so this should not have been a surprise (to you). In general I object to being sold something as surprising which isn&#39;t (it strikes me as a lesser-noticed and perhaps oft-inadvertent rhetorical dark art and I see it on the rise on LW, which is sad).

That said, since I&#39;m the only one objecting here, you appear to be more right about the surprisingness of this!

----------------------------------------

The linear probe is new news (but not surprising?) on top of GR, I agree. But the OP presents the other aspects as the surprises, and not this.</p></div></div></span></p><div><div><div id="F9jB9vDCN4Sepg3GQ"><p><span><div><div><p><span>7</span><span>Alexander Gietelink Oldenziel</span><span><time datetime="2024-05-03T14:30:24.648Z">1mo</time></span></p><p>I agree with you that the new/surprising thing is the linearity of the probe. Also I agree that not entirely clear how surprising &amp; new linearity of the probe is.

If you understand how the causal states construction &amp; the MSP works in computational mechanics the experimental results isn&#39;t surprising. Indeed, it can&#39;t be any other way! That&#39;s exactly the magic of the definition of causal states.

What one person might find surprising or new another thinks trivial. The subtle magic of the right theoretical framework is that it makes the complex simple, surprising phenomena apparent.

Before learning about causal states I would have not even considered that there is a unique (!) optimal minimal predictor canonical constructible from the data. Nor that the geometry of synchronizing belief states is generically a fractal. Of course, once one has properly internalized the definitions this is almost immediate. Pretty pictures can be helpful in building that intuition !

Adam and I (and many others) have been preaching the gospel of computational mechanics for a while now. Most of it has fallen on deaf ears before. Like you I have been (positively!) surprised and amused by the sudden outpouring of interest. No doubt it&#39;s in part a the testimony to the Power of the Visual! Never look a gift horse in the mouth ! _

I would say the parts of computational mechanics I am really excited are a little deeper - downstream of causal states &amp; the MSP. This is just a taster.

I&#39;m confused &amp; intrigued by your insistence that this is follows from the good regulator theorem. Like Adam I don&#39;t understand it. It is my understanding is that the original &#39;theorem&#39; was wordcelled nonsense but that John has been able to formulate a nontrivial version of the theorem. My experience is that it the theorem is often invoked in a handwavey way that leaves me no less confused than before. No doubt due to my own ignorance !

I would be curious to hear a *precise * statement why the result here follows</p></div></div></span></p><div><div><div id="h2AagrLdwEaLLQttB"><p><span><div><div><p><span>1</span><span>Oliver Sourbut</span><span><time datetime="2024-05-06T09:18:30.200Z">1mo</time></span></p><p>Lol! I guess if there was a more precise theorem statement in the vicinity gestured, it wasn&#39;t nonsense? But in any case, I agree the original presentation is dreadful. John&#39;s is much better.

A quick go at it, might have typos.

Suppose we have

 * X (hidden) state
 * Y output/observation

and a predictor

 * S (predictor) state
 * ^Y predictor output
 * R the reward or goal or what have you (some way of scoring &#39;was ^Y right?&#39;)

with structure

X→YX→RY→S→^Y→R

Then GR trivially says S (predictor state) should model the posterior P(X|Y).

Now if these are all instead processes (time-indexed), we have HMM

 * Xt (hidden) states
 * Yt observations

and predictor process

 * St (predictor) states
 * ^Yt predictions
 * Rt rewards

with structure

Xt→Xt+1Xt→YtSt−1→StYt→St→^Yt+1→Rt+1Yt+1→Rt+1

Drawing together (Xt+1,Yt+1,^Yt+1,Rt+1) as Gt the &#39;goal&#39;, we have a GR motif

Xt→YtYt→St→GtSt−1→StXt→Gt

so St must model P(Xt|St−1,Yt); by induction that is P(Xt|S0,Y1,...,Yt).</p></div></div></span></p></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div><div id="REqWB2nm4rFadSPeg"><div><div><div><div><div><div><p>Thank you for the insightful post! You mentioned that:</p><blockquote><p>Consider the relation a transformer has to an HMM that produced the data it was trained on. This is general - any dataset consisting of sequences of tokens can be represented as having been generated from an HMM.</p></blockquote><p>and the linear projection consists of:</p><blockquote><p>Linear regression from the residual stream activations (64 dimensional vectors) to the belief distributions (3 dimensional vectors).</p></blockquote><p>Given any natural language dataset, if we didn&#39;t have the ground truth belief distribution, is it possible to reverse engineer... <span>(read more)</span></p></div></div></div></div></div></div><div><div><div id="MTBcwckDJ59nSW5bg"><p><span><div><div><p><span>2</span><span>Adam Shai</span><span><time datetime="2024-05-03T01:28:23.738Z">1mo</time></span></p><p>If I&#39;m understanding your question correctly, then the answer is yes, though in practice it might be difficult (I&#39;m actually unsure how computationally intensive it would be, haven&#39;t tried anything along these lines yet). This is definitely something to look into in the future!</p></div></div></span></p></div></div></div></div></div><div><div id="DrKgX4E4fPyyDDLfs"><div><div><div><div><div><p>Is there some theoretical result along the lines of &#34;A sufficiently large transformer can learn any HMM&#34;?</p></div></div></div></div></div><div><div><div id="pNtAa46C35odbJFcd"><p><span><div><div><p><span>3</span><span>Alexander Gietelink Oldenziel</span><span><time datetime="2024-04-24T12:29:08.471Z">1mo</time></span></p><p>Depending on what one means by &#39;learn&#39; this is provably impossible. The reason has nothing to do with the transformer architecture (which one shouldn&#39;t think of as a canonical architecture in the grand scheme of things anyway).

There is a 2-state generative HMM such that the optimal predictor of the output of said generative model provably requires an infinite number of states. This is for any model of computation, any architecture.

Of course, that&#39;s maybe not what you intend by &#39;learn&#39;. If you mean by &#39;learn&#39; express the underlying function of an HMM then the answer is yes by the Universal Approximation Theorem (a very fancy name for a trivial application of the Stone-Weierstrass theorem).

Hope this helped. 😄</p></div></div></span></p><div><div><div id="mYJmB6obyaxgKZo8v"><p><span><div><div><p><span>1</span><span>Niclas Kupper</span><span><time datetime="2024-04-28T08:24:08.390Z">1mo</time></span></p><p>Where can I read about this 2-state HMM? By learn I just mean approximate via an algorithm. The UAT is not sufficient as it talks about learning a known function. Baum-Welch is such an algorithm, but as a far as I am aware it gives no guarantees on anything really.</p></div></div></span></p></div></div></div></div></div></div></div></div><div><div id="xsRJkuekJxyttiyE7"><div><div><div><div><div><p>Speaking of next steps, I&#39;d love to see a transformer that was trained to manipulate those states (given target state and interactor&#39;s tokens, would emit its own tokens for interleaving)! I believe this would look even cooler, and may be useful in detecting if AI starts to manipulate someone.</p></div></div></div></div></div></div></div><div><div id="upewyNE8KPe5ymKHu"><div><div><div><div><div><p>Can you share the hyperparameters used to make this figure?</p></div></div></div></div></div><div><div><div id="EoFCyQhGaWjJ82brA"><p><span><div><div><p><span>1</span><span>Keenan Pepper</span><span><time datetime="2024-04-20T23:51:59.187Z">1mo</time></span></p><p>Ah, never mind, I believe I found the relevant hyperparameters here: https://github.com/adamimos/epsilon-transformers/blob/main/examples/msp_analysis.ipynb

In particular, the stuff I needed was that it has only a single attention head per layer, and 4 layers.</p></div></div></span></p><div><div><div id="rhuASMuE2c38Nmpfb"><p><span><div><div><p><span>1</span><span>Keenan Pepper</span><span><time datetime="2024-04-23T00:21:39.887Z">1mo</time></span></p><p>Actually I would still really appreciate the training hyperparameters like batch size, learning rate schedule...</p></div></div></span></p><div><div><div id="NJp6gaSak59Lgkpgx"><p><span><div><div><p><span>1</span><span>tropea@gwu.edu</span><span><time datetime="2024-05-01T22:34:37.830Z">1mo</time></span></p><p>A simple suggestion on word usage: from &#34;belief state&#34; to &#34;interpretive state.&#34;  This would align your comments better with disciplines more concerned with behavior than cognition.         JL Tropea.
 </p></div></div></span></p><div><div><div id="nqihfa2ARmDmScAsE"><p><span><div><div><p><span>1</span><span>Keenan Pepper</span><span><time datetime="2024-05-13T10:24:01.861Z">19d</time></span></p><p>I think you may have meant this as a top-level comment rather than a reply to my comment?</p></div></div></span></p></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></span></span></p></div></div></div></div>
  </body>
</html>
