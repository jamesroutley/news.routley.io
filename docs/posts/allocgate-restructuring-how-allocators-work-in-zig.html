<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pithlessly.github.io/allocgate.html">Original</a>
    <h1>Allocgate: Restructuring how allocators work in Zig</h1>
    
    <div id="readability-page-1" class="page">
  

  <p>Date: 2021-12-15</p>

  <p>Version 0.9 of <a href="https://ziglang.org">the Zig programming language</a> is planned to release in about a week. One of the major changes coming in this release is a restructuring of how allocators work, which has been termed <a href="https://github.com/ziglang/zig/issues/10052">Allocgate</a>. This is a breaking change to the <code>Allocator</code> API provided by the standard library, so pretty much any code that uses allocators will have to be updated in response. I hope to use this article to explain the justification for this change and what steps you need to take to adjust your code.</p>

  <p>The TL;DR is:</p>
  <ul>
    <li>Where you previously passed around <code>*Allocator</code> to functions that need to allocate, you now pass around <code>Allocator</code> directly. <code>Allocator</code> is now a struct, which is the size of two pointers.</li>
    <li>When you construct an allocator (such as <code>var gpa: std.heap.GeneralPurposeAllocator(.{});</code>), you call <code>gpa.allocator()</code> to get the type-erased allocator implementation rather than writing <code>&amp;gpa.allocator</code>.</li>
  </ul>
  <p>Unless you are writing your own allocator, this should be all you need to change.</p>

  <h2>Two ways to approach polymorphism</h2>

  <p>Zig&#39;s allocators rely on dynamic dispatch. The choice of allocation and deallocation functions is not known until runtime, so if you want to write code that is agnostic to the user&#39;s choice of allocator (and you generally do when writing library code), you need to accept these functions as a parameter in some way. Most languages use a structure called a <em>virtual function table</em> (vtable) which stores the addresses of each dynamically-known function. Zig&#39;s standard library provides a variety of allocators (such as <code>ArenaAllocator</code> and <code>GeneralPurposeAllocator</code>), each of which has some associated state along with a set of functions (<code>alloc</code>, <code>resize</code>, and <code>free</code>) which operate on that state to work as a memory allocator. The addresses of these three functions are collected into an &#34;allocator vtable.&#34;</p>
  <p>Any polymorphic object&#39;s state needs to be passed along with its vtable somehow. One way to do it is to represent an object as a pair of pointers: one to the object&#39;s fields, and one to a vtable which knows how to operate on those fields. I&#39;ll follow Rust&#39;s terminology and call this <code>(impl, vtable)</code> pair a &#34;fat pointer.&#34;</p>

<pre> Dynamic           Object
----------        ----------
| impl   | -----&gt; | fields |
|--------|        | ...    |
| vtable | ---.   ----------
----------    |
              |    Vtable
              |   ----------
              `-&gt; | alloc  |
                  | resize |
                  | free   |
                  ----------
</pre>

  <p>Another way would be to store a separate copy of the vtable in every object. By knowing its address, the vtable&#39;s functions would be able to deduce the address of the struct containing them, an operation sometimes called <code>container_of</code> in C and provided by Zig under the name <code>@fieldParentPtr</code>. Indeed, this is such a common use of this builtin that the technique is commonly described as just &#34;the <code>@fieldParentPtr</code> idiom.&#34;</p>

<pre>                   Object
                  --------------
                  | fields     |
 Dynamic          | ...        |
----------        | ---------- |
| vtable | --------&gt;| alloc  | |
----------        | | resize | |
                  | | free   | |
                  | ---------- |
                  | ...        |
                  --------------
</pre>

  <p>(We could also imagine a third solution in which the object contains a pointer to the vtable in its fields, and we pass around a pointer to that pointer. This has the advantage of sharing vtables, while still requiring only a single pointer to be passed around. However, this also means we would need a double indirection to access the vtable, which would be more expensive.)</p>

  <h2>Polymorphic allocators in Zig</h2>

  <p>Without stooping so low as to actually <em>benchmark</em>, what might the respective advantages of these two approaches be?</p>
  <ul>
    <li>Using fat pointers, we get to make fewer copies of the vtable. Every polymorphic value can point to the same one, which saves memory and allows dynamic objects to be smaller.</li>
    <li>With the <code>@fieldParentPtr</code> approach, we&#39;re able to pass a dynamic object around as just a single pointer. This improves performance and saves memory for any struct that needs to hold a dynamic allocator (notably, most <code>std</code> containers).</li>
  </ul>

  <p>In the case of allocators, it might seem like the <code>@fieldParentPtr</code> approach would win out. After all, the average program passes relatively many pointers to relatively few different allocators, so making the latter large at the expense of keeping the former small is a sensible trade-off.</p>

  <p>However, as it turns out, this approach has a performance problem with has to do with devirtualization. Virtual function calls are more expensive than calls to known functions for a number of reasons, so LLVM would like to rewrite them to static calls anywhere it can prove that a function pointer always has a particular value. This becomes more difficult when the function pointer lives inside a structure like <code>GeneralPurposeAllocator</code>. Zig&#39;s <code>struct</code>s don&#39;t even have compile-time encapsulation, much less runtime encapsulation. There is nothing stopping you from reaching into your <code>GeneralPurposeAllocator</code> and changing the vtable functions to do something else. It would definitely be against <code>std</code>&#39;s contract, but it wouldn&#39;t immediately cause undefined behavior. This means any code which reads vtables out of the embedded <code>Allocator</code> has to be defensive against the possibility that the vtable was modified, making devirtualization impossible.</p>
  <p>In contrast, when using fat pointers, the vtables are shared constant objects, and a new fat pointer is constructed on every call to <code>gpa.allocator()</code>. So while we incur the cost of passing around a larger fat pointer, the allocation and deallocation functions potentially become much faster to call.</p>

  <h2>Allocgate</h2>

  <p>As far as I can tell, the performance issues of the <code>@fieldParentPtr</code> approach were first noticed <a href="https://github.com/ziglang/zig/issues/10037">about two months ago</a> in the <code>std.rand</code> API, which uses a similar approach to allow code to be polymorphic over the caller&#39;s choice of RNG algorithm (perhaps the performance issues were more apparent here because RNG algorithms are designed to have high throughput, so the relative overhead of indirect calls is larger). It was noted in that issue that any other code using this approach would suffer the same problem.</p>

  <p>With Allocgate, the <code>std.mem.Allocator</code> API was also changed from embedded vtables to fat pointers. This is the reason behind the two API changes I mentioned at the beginning of the article: <code>Allocator</code> was changed from holding the vtable itself to being a fat pointer struct, and you call <code>gpa.allocator()</code> instead of <code>&amp;gpa.allocator</code> because the vtable is no longer a field of the allocator and you instead need to construct a fat pointer.</p>

  <p>This also happens to address a specific failure mode I have run into before, where instead of writing</p>

<pre><code>var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const alloc = &amp;gpa.allocator;</code></pre>

  <p>the user writes:</p>

<pre><code>var gpa = std.heap.GeneralPurposeAllocator(.{}){};
var alloc = gpa.allocator;</code></pre>

  <p>This <em>copies</em> the allocator out of its parent struct and then attempts to call methods like <code>alloc.alloc()</code>. This will generally compile correctly (since Zig will automatically take the address of an object when calling a method that takes <code>self</code> by pointer), but causes undefined behavior at runtime because <code>alloc</code> attempts to use <code>@fieldParentPtr</code> despite no longer being contained in the struct it expects to be in. Post-Allocgate, this code instead becomes:</p>

<pre><code>var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const alloc = gpa.allocator();</code></pre>

  <p>â€¦ which is pretty much impossible to silently get wrong.</p>

  <h2>What&#39;s next for vtable-based polymorphism?</h2>

  <p>Allocgate has been <a href="https://github.com/ziglang/zig/pull/10055">merged into Zig&#39;s master branch</a> and should ship in Zig 0.9. This involved an impressive amount of work, with much of the standard library needing to be changed. It should hopefully yield better performance for code that uses any of the standard library&#39;s allocator abstractions. Zig&#39;s contributors have gone back and forth on the specifics of the change, and looked at a number of benchmarks, but I&#39;m sure they would welcome additional data on this.</p>

  <p>I think this is a great example of the kind of ecosystem-wide improvements Zig can make as a relatively young language that has yet to tie itself to any stability guarantees. It sucks for language users who will have to change their code, of course, but hopefully they knew what they were getting into. One of Zig&#39;s principles is &#34;avoid local maxima,&#34; which, at this point in the language&#39;s evolution, means to be willing to move to a better solution even if it means breaking backwards compatibility.</p>

  <p>A number of topics are also being discussed that have the potential to further improve the performance and ergonomics of runtime polymorphism. For example, it could be that improvements to Zig or LLVM&#39;s aliasing model will make it easier to optimize virtual function calls (for example, by making it possible to mark a particular field of a struct as immutable). Zig&#39;s developers have also expressed some interest in having first-class support for interfaces in the standard library or even the language itself, which would make it easier for the user and reduce the burden of having to modify every API in the standard library when changes like this are made.</p>

  <h2>Credit for the change</h2>

  <p>I had no personal involvement in Allocgate. I am simply an outsider who is interested in Zig and thought others might benefit from an explanation of this change. Instead, I ought to credit:</p>

  <ul>
    <li>Andrew Kelley (<a href="https://github.com/andrewrk">@andrewrk</a>), creator of Zig and initial designer of the allocator API;</li>
    <li><a href="https://github.com/ominitay">@ominitay</a>, who first diagnosed the problem in <code>std.rand</code> and provided benchmarks;</li>
    <li>Martin Wickham (<a href="https://github.com/SpexGuy">@SpexGuy</a>), who discovered the optimization problems with LLVM and the need to move away from <code>@fieldParentPtr</code>-based APIs;</li>
    <li>Lee Cannon (<a href="https://github.com/leecannon">@leecannon</a>), who implemented the bulk of the change to <code>Allocator</code>, including updating the entire standard library;</li>
    <li>and everyone else who contributed feedback, bug fixes, and benchmarks on the PR.</li>
  </ul>


</div>
  </body>
</html>
