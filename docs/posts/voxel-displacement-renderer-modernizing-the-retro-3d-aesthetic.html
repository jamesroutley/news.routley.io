<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.danielschroeder.me/2024/05/voxel-displacement-modernizing-retro-3d/">Original</a>
    <h1>Voxel Displacement Renderer – Modernizing the Retro 3D Aesthetic</h1>
    
    <div id="readability-page-1" class="page"><div>
<figure><img fetchpriority="high" decoding="async" width="1280" height="720" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/cover_intro_02_1280_b.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/cover_intro_02_1280_b.jpg 1280w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/cover_intro_02_1280_b-300x169.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/cover_intro_02_1280_b-1024x576.jpg 1024w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/cover_intro_02_1280_b-768x432.jpg 768w" sizes="(max-width: 1280px) 100vw, 1280px"/></figure>



<p><em>This is the first of two posts about a renderer I have been developing, focusing on what I’ve built and how it works. The <a href="https://blog.danielschroeder.me/2024/05/voxel-displacement-where-this-goes/">second post</a> discusses why I’ve built it and my plans for the future.</em></p>



<p>I’ve been developing a custom real-time renderer which uses very small voxels to produce a distinctive visual style that modernizes the look and feel of classic 90’s 3D games. By approaching the problem of rendering voxels in an unusual way, I’m able to produce these visuals from conventional art assets — low-poly triangle meshes and textures — that are familiar and efficient to create.</p>



<p>Before going further, a video is worth a thousand words. (Set quality to 1440p and view full-screen for best results.)</p>



<figure><p>
<iframe title="I made a *tiny* voxel renderer" width="500" height="281" src="https://www.youtube.com/embed/1xFEbXWstCM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p></figure>



<p>Read on for more information about the chosen visual style, how I approach it at a technical level, what this means for creating art assets and environments, and where I’m going from here.</p>



<h2>Aesthetic motivation</h2>



<p>Early-to-mid 90’s 3D games like Doom, Quake, and Duke Nukem were immensely influential for their technology and gameplay. More recently, the limitations of their visuals have taken on a retro appeal. Environment geometry was simple and imaginative, and textures were displayed with sharp pixel boundaries. I see this as 3D’s counterpart to the stylized abstraction of 2D pixel art. This has become a popular aesthetic for modern retro-inspired games, and 3D indie titles more broadly.</p>



<figure><img decoding="async" width="1000" height="700" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/doom_btsx_e2_02_crop_b.png" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/doom_btsx_e2_02_crop_b.png 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/doom_btsx_e2_02_crop_b-300x210.png 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/doom_btsx_e2_02_crop_b-768x538.png 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>BTSX Episode 2, a community-made level set for Doom 2 featuring custom textures.</figcaption></figure>



<p>I started this work with a simple question: what if, instead of blocky two-dimensional details, the surfaces in these environments had blocky three-dimensional details — voxels, instead of pixels? For example, a cobblestone wall could pop with geometric depth while retaining a pixelated look when viewed up close.</p>



<p>As I fleshed out this idea and built the renderer you see in the video, I aimed for the visuals to have a foot in both worlds between the look of 90’s games and something more modern. To put it another way: this is what Doom looked like to me when I was young.</p>



<h2>How voxels usually work</h2>



<p>Before getting into how I model and render this voxel aesthetic, it’s worth reviewing how voxels are typically used in games, and some of the consequences this has. (Or, skip ahead to “<a href="#what-ive-built">what I’ve built</a>.”)</p>



<p>A voxel mesh is a three-dimensional grid where every cube-shaped cell is filled in or empty. These cubes may be large and textured, like in Minecraft, or small and solid-colored, like in Teardown<sup data-fn="3df8fcd1-5190-4c11-9b55-219ba5038a7c"><a href="#3df8fcd1-5190-4c11-9b55-219ba5038a7c" id="3df8fcd1-5190-4c11-9b55-219ba5038a7c-link">1</a></sup>. To build a large environment with voxels, you can place all the geometry on a shared grid (Minecraft), or position many independent voxel meshes into the same space (Teardown). Regardless, once you decide your game world will be formed with voxels, you have to create this voxel geometry, and your rendering and gameplay logic needs to operate in terms of voxels.</p>



<figure><img loading="lazy" decoding="async" width="1000" height="500" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/voxels_minecraft_teardown_01b.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/voxels_minecraft_teardown_01b.jpg 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/voxels_minecraft_teardown_01b-300x150.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/voxels_minecraft_teardown_01b-768x384.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>Big voxels, little voxels. (Minecraft, Teardown.)</figcaption></figure>



<p>Software exists to author voxel meshes directly, but the process is <a href="https://www.youtube.com/watch?v=9tr6Qzd83Co">time-consuming</a> and often limited to creating smaller meshes. You can create larger environments by modeling building blocks, like tileable sections of wall or floor, and assembling them into larger structures. This works well for grid-aligned buildings but poorly for free-flowing terrain.</p>



<p>Many voxel games instead opt for procedural generation, which works great for natural environments and can be used to combine building blocks like the ones mentioned above automatically. But procedural generation brings its own <a href="https://www.gamedeveloper.com/design/the-pros-and-cons-of-procedural-generation-in-i-overland-i-">headaches</a>, and is only suitable for certain kinds of games.</p>



<p>It’s also possible to create voxel geometry by modeling the object or terrain that you want as a conventional triangle mesh and then <a href="https://teardowngame.com/voxtool/">rasterizing it to a voxel grid</a>. This is a powerful technique, though it does mean that all the resulting geometry occupies a single voxel grid, which may not be desirable aesthetically. For example, if one face in the triangle mesh is axis-aligned and another is at a 45-degree angle, the first face will become a flat slab of voxels, while the second will look like a staircase.</p>



<p>Whatever method you use to create your voxel geometry, because your scene is canonically represented in terms of voxels, your rendering and game logic need to operate at the voxel level. Especially if the voxels are small, this may mean having to implement your own physics, character controller, NPC pathfinding, etc., as well as rendering.</p>



<p>On the plus side, it’s easy to add or remove geometry from voxel meshes; games like Minecraft and Teardown take full advantage of this strength.</p>



<h2>How displacement usually works</h2>



<p>In my case, I simply want to add voxel-like surface detailing to the kinds of environments found in classic 3D games. Those environments consist of largely static, texture-mapped triangle meshes. So what about solving the problem with displacement mapping?</p>



<p>For folks who aren’t familiar with it, displacement mapping pairs your textures with displacement maps that define how far each pixel of the texture should extend inwards or outwards from the surface of the mesh. This can be a very fast way for artists to add detail to geometry.</p>



<p>3D modeling software can apply displacement maps to geometry by subdividing the mesh and then displacing the new vertices, so the displacement from the texture becomes real geometry, even affecting the silhouette of the object. The resulting meshes have radically higher polygon counts, however, and input meshes that have hard edges or corners <a href="https://blender.stackexchange.com/questions/143529/displacement-map-creates-gaps-on-the-corners-of-a-wall">must be modified</a> to produce good results.</p>



<figure><img loading="lazy" decoding="async" width="800" height="400" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_displacement_03b.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_displacement_03b.jpg 800w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_displacement_03b-300x150.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_displacement_03b-768x384.jpg 768w" sizes="(max-width: 800px) 100vw, 800px"/><figcaption>An example of displacement mapping as used in 3D modeling, showing an albedo map (top left), a corresponding displacement map (top right), and a mesh that has been subdivided and displaced accordingly (bottom, showing triangle edges on the right). <a href="https://polyhaven.com/a/gray_rocks">Material</a> by Dimitrios Savva, CC0 license.</figcaption></figure>



<p>For real-time graphics, displacement maps are sometimes used with surface shading effects like parallax occlusion mapping to create the <em>appearance</em> of fine geometric details on meshes without actually changing their physical shape. These effects can look good on large floors and walls, but the illusion breaks down along the edges of objects, where the geometry remains flat<sup data-fn="d595a0f7-12f6-41df-bee5-af4fcd195195"><a href="#d595a0f7-12f6-41df-bee5-af4fcd195195" id="d595a0f7-12f6-41df-bee5-af4fcd195195-link">2</a></sup>.</p>



<figure><img loading="lazy" decoding="async" width="1000" height="455" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_pom_01_1k.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_pom_01_1k.jpg 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_pom_01_1k-300x137.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/example_pom_01_1k-768x349.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>An example of parallax occlusion mapping, showing a mesh before and after applying the effect. The edges of the object are unaffected by the apparent 3D detailing. Screenshots are from a <a href="https://doc.babylonjs.com/features/featuresDeepDive/materials/using/parallaxMapping">babylon.js demo</a>.</figcaption></figure>



<p>A method known as <a href="https://dl.acm.org/doi/10.1145/1073204.1073239">shell mapping</a> provides something of a middle ground between the two approaches above, making it possible to see displacement even along the silhouette of an object without having to form a highly subdivided mesh. However, it struggles with areas where the input mesh has high curvature<sup data-fn="aa04bf3b-8d6d-42e3-8304-f245d3dde63b"><a href="#aa04bf3b-8d6d-42e3-8304-f245d3dde63b" id="aa04bf3b-8d6d-42e3-8304-f245d3dde63b-link">3</a></sup>; this makes it hard to adapt input meshes that have hard edges or corners for use with the technique.</p>



<h2 id="what-ive-built">What I’ve built — mixing voxels and displacement mapping</h2>



<p>For my purposes, I wanted to use conventional low-poly meshes to model environments like those of classic 3D games, apply displacement maps to define voxel-scale surface details, and render a result that truly looks like it was built from voxels. These environments are full of sharp edges, like the corner of a building. Conventional displacement mapping already struggles with these regions; in my case, I also wanted the results to look like voxels.</p>



<figure><img loading="lazy" decoding="async" width="1000" height="1000" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/mesh_before_after_01b_1k.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/mesh_before_after_01b_1k.jpg 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/mesh_before_after_01b_1k-300x300.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/mesh_before_after_01b_1k-150x150.jpg 150w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/mesh_before_after_01b_1k-768x768.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>A section of the demo environment before and after displacement. The brown stone arches are created as triangle meshes and then displaced, but the results look like they are assembled from voxels, even along the edges of the original mesh.</figcaption></figure>



<p>Solving this problem was very, <em>very</em> hard, and involved building a lot of custom machinery. (For now, this is a standalone C++ / Vulkan project; more about that below.) This infrastructure performs three main tasks:</p>



<ul>
<li>Taking the triangle meshes that define the environment, plus limited information about the displacement maps, and converting them into the geometry data that the renderer will load onto the GPU to draw the displaced versions of the meshes<sup data-fn="46d44723-d9bf-4a96-94e2-b3b2d3f913e9"><a href="#46d44723-d9bf-4a96-94e2-b3b2d3f913e9" id="46d44723-d9bf-4a96-94e2-b3b2d3f913e9-link">4</a></sup>. This process runs on the CPU before any frames have been rendered. In a shipped game, you could bake the results to disk, though this isn’t too expensive; for the demo environment in the video, converting the entire scene on a single thread takes half a second.</li>



<li>Pre-processing the textures to generate other information needed during rendering, such as normal maps. This work is pretty basic, but it is slow, so you’d definitely bake the results.</li>



<li>Using the mesh and texture state generated above to draw the voxel-displacement geometry. This happens on the GPU with almost no CPU involvement per frame.</li>
</ul>



<p>While there’s room for further optimization, it already performs well: on a Radeon RX 5700 XT (which was considered a 1440p card when it launched in 2019), the demo sequence seen in the YouTube video renders at 1440p with frame times from 4 to 9 ms (250 to 110 FPS). On a Steam Deck OLED at its native 800p, the sequence stays above 60 FPS, with many areas locked at 90.</p>



<h2>Creating art assets and environments</h2>



<p>So, the tech exists; what does it look like to make content for it? There are two kinds of assets to create: textures and meshes.</p>



<p>I author each texture as an albedo map and a displacement map. For the albedo, I’ve found that imitating the limited palette of retro games helps to sell the visual style. The displacement maps look very standard, providing fine-grained height values that you can rescale in the renderer to make the displacement more or less intense. In this case, the units for the rescaled height values are how many voxels inward or outward to move the surface. The renderer only displaces to the nearest whole number of voxels, but it uses the exact heights to calculate a normal map, so that features less than a voxel tall can still affect the lighting.</p>



<figure><img loading="lazy" decoding="async" width="1000" height="1000" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/albedo_and_fine_01b.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/albedo_and_fine_01b.jpg 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/albedo_and_fine_01b-300x300.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/albedo_and_fine_01b-150x150.jpg 150w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/albedo_and_fine_01b-768x768.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>Albedo and displacement maps for the gray stone block material, and the rendered result. Large changes in displacement become voxel-scale geometry; subtler changes, like the ridges on the surface of each stone, may not become voxels but do affect how the surface is lit.</figcaption></figure>



<p>Next are the meshes. These are conventional low-poly texture-mapped triangle meshes with shading normals. The normals indicate which sections of the mesh represent smoothly curving surfaces and which edges are supposed to be sharp; as mentioned above, my renderer has to do extra work for sharp edges to produce good-looking results. For the sake of the visual style, I try to keep the size of the voxels consistent when mapping the textures, but this isn’t a hard requirement.</p>



<figure><img loading="lazy" decoding="async" width="1000" height="1000" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/model_and_render_01b.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/model_and_render_01b.jpg 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/model_and_render_01b-300x300.jpg 300w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/model_and_render_01b-150x150.jpg 150w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/model_and_render_01b-768x768.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>A cave, as modeled in Blender and in my renderer. I modeled the area as two meshes — the cave walls, and the floor. The entrance on the left has hard edges, as visible in the Blender screenshot. In the renderer, these edges become detailed according to the displacement of the stone texture.</figcaption></figure>



<p>There <em>are</em> limitations on how you structure the meshes and how you map the textures to them. Some of these limitations I can remove in the future, and others are unavoidable because of how the renderer works<sup data-fn="2e063aae-9d7c-4427-95ee-e548eec95905"><a href="#2e063aae-9d7c-4427-95ee-e548eec95905" id="2e063aae-9d7c-4427-95ee-e548eec95905-link">5</a></sup>. That said, because these are triangle meshes, not some purpose-built geometric representation, it’s possible to use many different tools to create them. I’ve used Blender to model my demo environment, but to illustrate the point, the current export format from Blender to my demo is literally just an OBJ file.</p>



<h2>Benefits of this approach</h2>



<p>Approaching the voxel aesthetic in this way has some noteworthy benefits. As described above, you get to use a familiar workflow to create content, rather than having to use specialized voxel-editing software. Authoring good textures can be challenging (at least for me), but once you’ve done so, they’re easy to reuse across a range of geometry without having to do further voxel-scale work. For example, a large fraction of the demo geometry in the video uses a single texture (the stone blocks, in three different colors).</p>



<p>So far, what I’ve been building is just a demo of a renderer. But some of the most interesting consequences of solving the problem this way go beyond rendering to the other components of a game. Because the environment is authored as triangle meshes, with the voxel features being only surface decoration, <em>you can treat the environment as being polygonal geometry whenever it’s convenient to do so</em>.</p>



<p>In my demo application, you can move around the environment from a first-person perspective with full collision, walking up stairs and being blocked by walls, but I didn’t have to write my own physics engine or character controller; I integrated an open-source <a href="https://github.com/jrouwe/JoltPhysics">physics library</a> and simply used the original triangle meshes as the collision geometry. Similarly, problems like enemy movement and pathing could be solved in terms of the same meshes. Only select gameplay systems would need to care about the voxels; for example, in a first person shooter, you could implement a displacement-aware raycast function so that bullets can respect the exact shapes of the displaced geometry.</p>



<p>Many voxel-based games use their own engines, because so many gameplay systems have to be customized. This project is <em>currently</em> a standalone codebase using C++ and Vulkan, but as I’ve argued, most of the logic outside of rendering doesn’t need to know or care about the voxel-scale details. As a result, I think the most realistic path to using this rendering technique in a game would be to integrate it into an existing engine to benefit from all the other provided systems. But that’s getting into the topic of the next post.</p>



<h2>Where this goes from here</h2>



<p>So, where am I going from here?</p>



<p>For the renderer itself, there are several features I’d like to add or improve. What I’ve built so far is a great way to create level geometry, but game environments also feature smaller objects, decorations, and dynamic elements like enemies. I have ideas for how to integrate smaller or animated objects into this art style in the future. While the lighting in the demo already looks good, the current implementation is limited to a small number of lights, and lacks shadows, ambient occlusion, or other fancier features. Because this renderer is meant for the largely static environments that most games have, rather than the highly dynamic geometry of typical voxel games, there’s a lot of flexibility to handle lighting in different ways (including baked approaches), depending on the needs of a particular application. The renderer currently has no anti-aliasing, which becomes noticeable on distant floors in particular; there are some interesting possibilities for dealing with this.</p>



<p>Zooming out further: where does this <em>project</em> go? What am I planning to do with it? For more on that, especially if you’re a developer or studio who finds this work intriguing, please see the <a href="https://blog.danielschroeder.me/2024/05/voxel-displacement-where-this-goes/">second post</a>. And thank you for reading!</p>



<figure><img loading="lazy" decoding="async" width="1000" height="1400" src="https://blog.danielschroeder.me/wp-content/uploads/2024/04/twisty_pillar_materials_02_1k.jpg" alt="" srcset="https://blog.danielschroeder.me/wp-content/uploads/2024/04/twisty_pillar_materials_02_1k.jpg 1000w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/twisty_pillar_materials_02_1k-214x300.jpg 214w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/twisty_pillar_materials_02_1k-731x1024.jpg 731w, https://blog.danielschroeder.me/wp-content/uploads/2024/04/twisty_pillar_materials_02_1k-768x1075.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption>Three different textures applied to the same input mesh, a twisted pillar. The inset shows the input mesh, with the sharp edges in black.</figcaption></figure>


</div></div>
  </body>
</html>
