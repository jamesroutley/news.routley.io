<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiki.gentoo.org/wiki/User:Sakaki/Sakaki%27s_EFI_Install_Guide/Disabling_the_Intel_Management_Engine">Original</a>
    <h1>Disabling the Intel Management Engine</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div><p><span id="me_cleaner_ops">In this mini-guide,</span> I&#39;ll run through the process of <b>disabling</b> the IME on your target PC.<sup id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> To do so, we will use Nicola Corna&#39;s <a rel="nofollow" href="https://github.com/corna/me_cleaner"><span>me_cleaner</span></a>. This software operates on the firmware stored in your PC&#39;s BIOS chip (where the bulk of the ME&#39;s code resides), and does two things:
</p>
<ul><li>sets the &#39;High Assurance Program&#39; bit, an ME &#39;kill switch&#39; that the US government reportedly<sup id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup> had incorporated for PCs used in sensitive applications<sup id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup><sup id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup>;</li>
<li>removes the vast majority of the ME&#39;s software modules (including network stack, RTOS and Java VM), leaving only the essential &#39;bring up&#39; components (the latter being necessary because, on modern systems, if the IME fails to initialize, either the machine startup will be completely halted at that point, or startup will <i>appear</i> to complete, only for a watchdog timer to reset the whole PC 30 minutes later<sup id="cite_ref-14"><a href="#cite_note-14">[14]</a></sup>).</li></ul>
<p>This combined &#39;belt-and-braces&#39; approach means that the ME <i>ought</i> to cleanly enter a self-induced null state (after resetting the 30-minute watchdog timer) but, should that not work, it will nevertheless enter a failed state shortly thereafter (as the majority of its core software modules have been purged).
</p>

 
<p>The process we will be following is as follows:
</p>
<ul><li>ensuring you have the necessary components available;</li>
<li>locating (and identifying) the BIOS flash chip on your target PC;</li>
<li>setting up a Raspberry Pi 3 Model B (or B+) (&#39;RPi3&#39;) or Pi 4 Model B (&#39;RPi4&#39;) as an in-system flash programmer;</li>
<li>reading the original firmware from the BIOS flash chip (and validating this), using the RPi3/4;</li>
<li>creating a modified copy of this firmware using <span>me_cleaner</span>;</li>
<li>writing the modified copy of the firmware back to your PC&#39;s BIOS flash chip, again using the RPi3/4;</li>
<li>restarting your PC, and verifying that the IME has been disabled.</li></ul>
<p>Although some systems <i>do</i> allow the full contents of the BIOS flash chip to be reprogrammed using software tools only (so called <a rel="nofollow" href="https://github.com/corna/me_cleaner/wiki/Internal-flashing-with-OEM-firmware">&#39;internal flashing&#39;</a>), on most PCs this facility is either completely unavailable, <i>or</i> can only write to the unprotected areas of the flash filesystem (<i>excluding</i> the ME area), <i>or</i> will only write vendor-signed images. Accordingly, we will describe the approach of using &#39;external&#39; flashing in this guide, as that is the most reliable.
</p>

<p>If you are ready, let&#39;s go!
</p>


<h2><span id="Prerequisites"><span id="prerequisites">Prerequisites</span></span></h2>
<p>To proceed, you will require the following:
</p>
<ul><li>an Intel-CPU-based target PC — that does <i>not</i> have <a rel="nofollow" href="https://github.com/corna/me_cleaner/wiki/Intel-Boot-Guard">Boot Guard</a> enabled — on which you wish to disable the IME;
<ul><li>the target PC may be running an OEM BIOS (such as AMI, Dell etc.), or <a rel="nofollow" href="https://www.coreboot.org/">coreboot</a>;</li></ul></li>
<li>a <a href="https://tech.michaelaltfield.net/wiki/Raspberry_Pi" title="Raspberry Pi">Raspberry Pi 3 Model B or B+, or Pi 4 Model B</a> single board computer (&#39;RPi3&#39; or &#39;RPi4&#39;), for use as an external flash programmer;</li>
<li>a spare &gt;= 8GB microSD card (to hold the 64-bit Gentoo O/S image we will use for the RPi3/4);</li>
<li>an appropriate IC clip for your target PC&#39;s flash chip, e.g.:
<ul><li>a Pomona 5250 for SOIC-8 chips;</li>
<li>a Pomona 5208 for unsocketed DIP-8 chips, or</li>
<li>a Pomona 5252 for SOIC-16 chips;</li></ul></li>
<li>8 female-female connector wires (to attach the appropriate clip to the RPi3/4&#39;s GPIO header);</li>
<li>a maintenance manual for your target PC, where available, to assist in safe disassembly / reassembly; and
<ul><li>whatever tools are stipulated in the above.</li></ul></li></ul>





<p>In the text, I will run through the process of reflashing the BIOS-chip firmware on a specific machine, namely the long-suffering <b>Panasonic CF-AX3 Ultrabook</b> used in the main body of this guide. This has a SOIC-8 BIOS flash chip, so we will be using a Pomona 5250 clip. Of course, you should adapt the following instructions to match your specific setup, flash chip type etc.
</p>
<h2><span id="Locating_(and_Identifying)_the_Target_PC&#39;s_BIOS_Flash_Chip"></span><span id="Locating_.28and_Identifying.29_the_Target_PC.27s_BIOS_Flash_Chip"><span id="locate_chip">Locating</span> (and Identifying) the Target PC&#39;s BIOS Flash Chip</span></h2>
<p>To begin — always observing <a rel="nofollow" href="https://www.computerhope.com/esd.htm">good ESD practices</a>, and following the instructions given in your target system&#39;s maintenance manual — <i>disconnect</i> any external power sources and removable batteries, and then expose your target PC&#39;s motherboard.
</p><p>For desktop machines, gaining access to the motherboard is generally easy, but for laptops the disassembly process is often quite fiddly. However, the Panasonic CF-AX3 is refreshingly straightforward in this regard — after removing the main battery and removing 19 small screws on the bottom-side, the rear panel of the laptop lifts off easily. With this done, a second (internal) li-ion battery must be disconnected, after which the mainboard is ready for inspection. Obviously, the approach required for your system will be different.
</p>


<p>Once you have your target PC&#39;s motherboard exposed, locate its BIOS flash chip. On many machines, the BIOS chip will be marked with a sticker or paint dot. Laptops will generally have 8-pin or 16-pin <a href="https://en.wikipedia.org/wiki/Small_Outline_Integrated_Circuit" title="wikipedia:Small Outline Integrated Circuit">SOIC</a> packages;on desktop machines, 8-pin socketed (and unsocketed) <a href="https://en.wikipedia.org/wiki/Dual_in-line_package" title="wikipedia:Dual in-line package">DIP</a> packages are also common.
</p>

<p>The CF-AX3 has a SOIC-8 flash IC, as shown:
</p>
<div><div><p><a href="https://tech.michaelaltfield.net/wiki/File:Flash_chip_location2.jpg"><img alt="" src="https://tech.michaelaltfield.net/images/thumb/f/f5/Flash_chip_location2.jpg/600px-Flash_chip_location2.jpg" decoding="async" width="600" height="484" srcset="/images/f/f5/Flash_chip_location2.jpg 1.5x"/></a></p><div><p>Location of the SOIC-8 Flash Chip on a Panasonic CF-AX3 Laptop; Pin 1 on Bottom Left</p></div></div></div>
<p>Once you have located the BIOS flash chip, with the help of a magnifying glass (good apps for this are available for IOS and Android phones) or digital camera, read off the maker&#39;s name and model number from the device. Then, use a search engine to locate the device&#39;s datasheet.
</p><p>For example, as the above photo shows, the CF-AX3 has a Winbond W25Q64FV IC; its datasheet may be found <a rel="nofollow" href="http://www.winbond.com/resource-files/w25q64fv%20revs%2007182017.pdf">here</a>. This part uses a very commonly seen pinout, <span id="flash_8_pinout">as follows (note how the pins are numbered counter-clockwise):</span>
</p>
<div><div><p><a href="https://tech.michaelaltfield.net/wiki/File:Flash_8_pinout.png"><img alt="" src="https://tech.michaelaltfield.net/images/c/c7/Flash_8_pinout.png" decoding="async" width="386" height="232"/></a></p><div><p>Pinout of a Typical SOIC-8 / DIP-8 BIOS Flash Chip</p></div></div></div>

<p>Note that on DIP packages, the top of the chip will generally be marked by a semicircular indent; on SOIC packages, a small circle or indent will mark pin 1 (NB, do not confuse this with any paint blobs the manufacturer may have used to highlight the flash chip, as for example with the blue paint blob used on the CF-AX3.)
</p><p>Write down the pinout for your device, if it differs from that shown in the above diagram.
</p>

<h2><span id="Setting_up_the_RPi3/4_as_an_External_Flash_Programmer"></span><span id="Setting_up_the_RPi3.2F4_as_an_External_Flash_Programmer"><span id="setup_rpi3.22">Setting up the RPi3/4 as an External Flash Programmer</span></span></h2>
<p>Next, we will set up a Raspberry Pi 3 Model B / B+ (&#39;RPi3&#39;) or Pi 4 Model B (&#39;RPi4&#39;) single board computer as an external flash programmer, running 64-bit Gentoo Linux as its operating system. For convenience we will use a pre-built image.
</p>
<h3><span id="Software_Configuration"><span id="setup_rpi3_software.22">Software Configuration</span></span></h3>
<p>Download, write and boot the Gentoo image provided <a rel="nofollow" href="https://github.com/sakaki-/gentoo-on-rpi-64bit">here</a> on your RPi3/4 (following the instructions given on that page).
</p>


<p>The image starts up directly into an Xfce4 desktop, pre-logged in as the <span>demouser</span> account. When the boot has completed, open a terminal window on (or <span>ssh</span> in to) the RPi3/4 and become root:
</p>
<div><p><code>demouser@pi64 <span>~ $</span></code><span></span><code>sudo su --login root
</code></p></div>
<p>If you have not modified the default image settings, no password will be required for this step.
</p><p>Next, note that if you are using version &gt;=1.2.0 of the <span>gentoo-on-rpi3-64bit</span> image, <i>all</i> the required software now comes pre-installed for convenience, so you can <a href="#setup_rpi3_hardware">skip directly to the &#34;Hardware Configuration&#34; section</a> now. Otherwise, keep reading.
</p><p>Then, modify the <span>/boot/config.txt</span> file so that the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus" title="wikipedia:Serial Peripheral Interface Bus">SPI interface</a> (used to communicate with the flash chip) is available via the RPi&#39;s GPIO pins. As root, issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>nano -w /boot/config.txt
</code></p></div>
<p>and modify that file, <i>uncommenting</i> the following line (if not already done):
</p>
<p><span>FILE</span> <strong><code>/boot/config.txt</code></strong><strong>Enable the SPI interface on your RPi</strong></p><pre></pre>
<p>Leave the rest of the file as-is. Save, and exit <span>nano</span>.
</p>

<p>Next, fetch up-to-date copies of the <a rel="nofollow" href="https://github.com/sakaki-/sakaki-tools"><span>sakaki-tools</span></a> and <a rel="nofollow" href="https://github.com/sakaki-/genpi64-overlay"><span>genpi64</span></a> ebuild repositories (&#39;overlays&#39;) on the RPi3/4. Ensure your RPi has a valid network connection (you can easily setup a WiFi or Ethernet connection via the bundled <span>NetworkManager</span> applet, just click on the network icon in the status bar), then issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>emaint sync --repo sakaki-tools
</code></p><p><code>pi64 <span>~ #</span></code><span></span><code>emaint sync --repo genpi64
</code></p></div>

<p>Next, we need to install the <a rel="nofollow" href="https://packages.gentoo.org/packages/sys-apps/flashrom">sys-apps/flashrom</a> software, which will allow us to read and write the flash chip over the SPI interface. Issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>emerge --ask --verbose sys-apps/flashrom
</code></p><pre>... additional output suppressed ...
Would you like to merge these packages? [Yes/No] &lt;press y, then press Enter&gt;
... additional output suppressed ...
</pre></div>
<p>Because it will fetch and then check the <a rel="nofollow" href="https://github.com/sakaki-/gentoo-on-rpi-64bit#binhost">binhost</a> packages metadata file, this command may take 3-4 minutes before prompting you whether to proceed, so please be patient. The actual package itself is available as a binary and will install quickly (with no local compilation required), once confirmed.
</p>

<p>Then, we need to emerge the <span>coreboot-utils</span> package, which provides <span>ifdtool</span> (a utility to parse and modify the structure of Intel firmware flash dumps). The package has an ebuild in the <a rel="nofollow" href="https://github.com/sakaki-/sakaki-tools"><span>sakaki-tools</span></a> repository (aka &#39;overlay&#39;) used on the image, so issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>emerge --ask --verbose sys-apps/coreboot-utils
</code></p><pre>... additional output suppressed ...
Would you like to merge these packages? [Yes/No] &lt;press y, then press Enter&gt;
... additional output suppressed ...
</pre></div>


<p>The next step is to install Nicola Corna&#39;s <span>me_cleaner</span> software itself. This also has an ebuild in the <a rel="nofollow" href="https://github.com/sakaki-/sakaki-tools"><span>sakaki-tools</span></a> repo, so issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>emerge --ask --verbose sys-apps/me_cleaner
</code></p><pre>... additional output suppressed ...
Would you like to merge these packages? [Yes/No] &lt;press y, then press Enter&gt;
... additional output suppressed ...
</pre></div>

<p><span>me_cleaner</span> is a reasonably straightforward Python script. Nevertheless, it is good hygiene to review scripts prior to running them (particularly when they impact such security-critical areas as the IME and BIOS), so do so now. Issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>less /usr/lib/python-exec/python3.6/me_cleaner
</code></p></div>
<p>Use <kbd>Page Down</kbd> and <kbd>Page Up</kbd> to navigate within the file, and press <kbd>q</kbd> to quit, when done.
</p><p>Lastly, we&#39;ll pull in the <span>pigpio</span> library (and accompanying <span>pigs</span> utility and <span>pigpiod</span> server), which will be used to set the GPIO pins on the header not directly controlled by <span>flashrom</span>). This has an ebuild in the <a rel="nofollow" href="https://github.com/sakaki-/genpi64-overlay"><span>genpi64</span></a> repo used on the image, so issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>emerge --ask --verbose dev-libs/pigpio
</code></p><pre>... additional output suppressed ...
Would you like to merge these packages? [Yes/No] &lt;press y, then press Enter&gt;
... additional output suppressed ...
</pre></div>


<p>Once installed, start the <span>pigpiod</span> daemon, and ensure that this is automatically started each boot; issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>rc-service pigpiod start
</code></p><p><code>pi64 <span>~ #</span></code><span></span><code>rc-update add pigpiod default
</code></p></div>
<h3><span id="Hardware_Configuration"><span id="setup_rpi3_hardware.22">Hardware Configuration</span></span></h3>
<p>With the necessary software prepared, we can proceed to attach the appropriate IC clip to the RPi&#39;s GPIO (general purpose input-output) header.
</p><p>Cleanly shutdown your RPi3/4:
</p>

<p>Physically remove the RPi3/4&#39;s power connector once the shutdown sequence has completed. 
</p><p>With your RPi powered off, locate its 40-pin GPIO header, and connect one end of each of the 8 female-female cables to the appropriate RPi GPIO pin as shown in (the inner, light green section of) the diagram <span id="pin_mapping">below</span>:
</p>

<div><div><p><a href="https://tech.michaelaltfield.net/wiki/File:Rpi_gpio_header_ic_flash.png"><img alt="" src="https://tech.michaelaltfield.net/images/thumb/c/c1/Rpi_gpio_header_ic_flash.png/500px-Rpi_gpio_header_ic_flash.png" decoding="async" width="500" height="395" srcset="/images/c/c1/Rpi_gpio_header_ic_flash.png 1.5x"/></a></p><div><p>Pin mapping from RPi3/4 GPIO Header to Typical 8-Pin Flash Chip</p></div></div></div>
<p>Here is a photo showing these connections in place on an actual RPi3 (in an official 7&#34; touchscreen enclosure; this is of course not necessary in order to use the board). Disregard the wires on the left-hand side, they are for the touchscreen. With the RPi oriented as it is in this picture, pin 1 is at the extreme left position on the nearer row, and pin 40 at the extreme right position on the farther row. The colours of the jumper wires used match those in the above <a href="#pin_mapping">pin mapping</a> and <a href="#flash_8_pinout">flash chip pinout</a><span id="wiring_photo">.</span>
</p>
<div><div><p><a href="https://tech.michaelaltfield.net/wiki/File:Rpi3_wiring2.jpg"><img alt="" src="https://tech.michaelaltfield.net/images/thumb/8/82/Rpi3_wiring2.jpg/600px-Rpi3_wiring2.jpg" decoding="async" width="600" height="565" srcset="/images/thumb/8/82/Rpi3_wiring2.jpg/900px-Rpi3_wiring2.jpg 1.5x, /images/thumb/8/82/Rpi3_wiring2.jpg/1200px-Rpi3_wiring2.jpg 2x"/></a></p><div><p>An RPi3 with GPIO/SPI Connected for Flash Programming to a Pomona 5250 IC Clip (Click to Zoom)</p></div></div></div>

<p>The other end of the 8 wires you should connect to an appropriate IC test clip, per the outer (lilac) section of the <a href="#pin_mapping">above pin mapping diagram</a>. The photo above shows a 5250 clip attached (as is appropriate for the SOIC-8 flash chip in the Panasonic CF-AX3); obviously, adapt as required. The important thing is to look at your flash IC&#39;s pin names / functions (as given by its datasheet), and ensure that these are connected to the appropriate header wire from the RPi3/4. For example, with the Winbond W25Q64FV chip in a SOIC-8 package, as here, we have:
</p>
<table>

<tbody><tr>
<th>IC Pin</th>
<th>IC Name</th>
<th>Wire Colour</th>
<th>RPi3/4 Pin</th>
<th>RPi3/4 Name</th>
<th>Function
</th></tr>
<tr>
<td>1</td>
<td>/CS</td>
<td>White</td>
<td>24</td>
<td>SPI_CE0_N</td>
<td>Chip select; drive low to enable device
</td></tr>
<tr>
<td>2</td>
<td>DO</td>
<td>Grey</td>
<td>21</td>
<td>SPI_MISO</td>
<td>Standard SPI data output (from chip)
</td></tr>
<tr>
<td>3</td>
<td>/WP</td>
<td>Blue</td>
<td>16</td>
<td>GPIO23 / GPIO_GEN4</td>
<td>Write protect; drive high to enable status registers to be written
</td></tr>
<tr>
<td>4</td>
<td>GND</td>
<td>Black</td>
<td>25</td>
<td>Ground</td>
<td>Ground
</td></tr>
<tr>
<td>5</td>
<td>DI</td>
<td>Orange</td>
<td>19</td>
<td>SPI_MOSI</td>
<td>Standard SPI data input (to chip)
</td></tr>
<tr>
<td>6</td>
<td>CLK</td>
<td>Yellow</td>
<td>23</td>
<td>SPI_CLK</td>
<td>SPI clock
</td></tr>
<tr>
<td>7</td>
<td>/HOLD</td>
<td>Green</td>
<td>18</td>
<td>GPIO24 / GPI_GEN5</td>
<td>Hold; drive low to pause device while actively selected
</td></tr>
<tr>
<td>8</td>
<td>VCC</td>
<td>Red</td>
<td>17</td>
<td>3.3v</td>
<td>Power supply (NB do <i>not</i> use 5v)
</td></tr></tbody></table>

<p>With the test clip connected, hardware setup of your RPi as a in-circuit flash programmer is complete.
</p>
<h2><span id="Reading_and_Verifying_the_Original_Contents_of_your_BIOS_Flash_Chip"><span id="read_verify_flash.22">Reading and Verifying the Original Contents of your BIOS Flash Chip</span></span></h2>
<p>Power the RPi back up, wait for Gentoo to boot, and then and open a terminal window (or, at your option, log in over <span>ssh</span>). As before, become root:
</p>
<div><p><code>demouser@pi64 <span>~ $</span></code><span></span><code>sudo su --login root
</code></p></div>
<p><span id="pullup">Then,</span> as root, ensure that <span>/WP</span> and <span>/HOLD</span> are both pulled high. Issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>pigs pud 23 u
</code></p><p><code>pi64 <span>~ #</span></code><span></span><code>pigs pud 24 u
</code></p></div>
<p>These commands (using the <span>pigs</span> client from <span>pigpio</span>) activates the RPi3/4&#39;s internal pull-up resistors on <span>GPIO23</span> (RPi pin 16 → <span>/WP</span>) and <span>GPIO24</span> (RPi pin 18 → <span>/HOLD</span>) respectively.
</p>


<p>Next, observing proper <a rel="nofollow" href="https://www.computerhope.com/esd.htm">proper ESD precautions</a> (and after double-checking that you have all external power supplies and batteries removed), <b>attach the IC clip to your target PC&#39;s BIOS flash chip</b>.
</p><p>For example, the photo below shows the same RPi3 as shown <a href="#wiring_photo">earlier</a> attached to the BIOS chip of the CF-AX3 laptop, using a Pomona 5250 test clip:
</p>
<div><div><p><a href="https://tech.michaelaltfield.net/wiki/File:Flash_reprogramming2.jpg"><img alt="" src="https://tech.michaelaltfield.net/images/thumb/4/4e/Flash_reprogramming2.jpg/600px-Flash_reprogramming2.jpg" decoding="async" width="600" height="538" srcset="/images/thumb/4/4e/Flash_reprogramming2.jpg/900px-Flash_reprogramming2.jpg 1.5x, /images/thumb/4/4e/Flash_reprogramming2.jpg/1200px-Flash_reprogramming2.jpg 2x"/></a></p><div><p>Using an RPi3 for In-Circuit BIOS Chip Reflashing of a CF-AX3 (Click to Zoom)</p></div></div></div>

<p>With the clip attached, request that <span>flashrom</span> &#39;probe&#39; to see if it can identify your BIOS flash chip:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=8000
</code></p><pre>flashrom v0.9.9-r1955 on Linux 4.10.17-v8-9411792647f6+ (aarch64)
flashrom is free software, get the source code at https://flashrom.org

Calibrating delay loop... OK.
Found Winbond flash chip &#34;W25Q64.V&#34; (8192 kB, SPI) on linux_spi.
No operations were specified.
</pre></div>
<p>Obviously the output will reflect your particular version of flashrom, kernel and flash chip, but if you see something like the above, you are good to proceed.
</p>

<p>However, if instead you got an output containing <code>No EEPROM/flash device found</code>, then you have a problem. Double-check the wiring to your RPi3/4 and the IC clip, and make sure your RPi&#39;s <a rel="nofollow" href="https://www.raspberrypi.org/forums/viewtopic.php?f=63&amp;t=138636">power supply is sufficient</a>. If that all looks good, re-seat the IC clip on your flash chip, and try again. The clips are tricky to get seated properly, so it is not unusual for a few tries to be required before <span>flashrom</span> can successfully connect.
</p>


<p>Once you have a successful probe, leaving the clip in place, <span id="backup_firmware">dump a copy of your existing firmware</span>:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=8000 -r original.rom
</code></p><pre>flashrom v0.9.9-r1955 on Linux 4.10.17-v8-9411792647f6+ (aarch64)
flashrom is free software, get the source code at https://flashrom.org

Calibrating delay loop... OK.
Found Winbond flash chip &#34;W25Q64.V&#34; (8192 kB, SPI) on linux_spi.
Reading flash... done.
</pre></div>

<p>Make another copy of the original firmware:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=8000 -r original2.rom
</code></p></div>
<p>And check that both copies are identical (this is a useful check to ensure that neither image has been corrupted):
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>diff original{,2}.rom
</code></p></div>
<p>This should produce no output, indicating that the dumped images are identical.
</p>

<p>Next, assuming the <span>diff</span> check passes, run <span>ifdtool</span> on one of the images, to ensure that it has a valid structure:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>ifdtool -d original.rom
</code></p></div>
<p>Your output will obviously be system-specific, but should resemble something like that shown <a rel="nofollow" href="https://gist.github.com/corna/66322fb938dedd93d2aaa1d59b27341d">here</a> (at least in broad outline).
</p>

<p>Finally, check that the dumped image has a structure that the <span>me_cleaner</span> tool understands, and can work with. To do so, issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>me_cleaner --check original.rom
</code></p></div>
<p>As before, your output will be system-specific, but should pass all checks as for example shown <a rel="nofollow" href="https://gist.github.com/corna/92df16e65248c63a258fdbdac5cb0923">here</a>.
</p>

<h2><span id="Modifying_Firmware_using_me_cleaner,_to_Disable_the_IME"></span><span id="Modifying_Firmware_using_me_cleaner.2C_to_Disable_the_IME"><span id="run_me_cleaner">Modifying Firmware using <span>me_cleaner</span>, to Disable the IME</span></span></h2>
<p>With all tests passed, you can now run <span>me_cleaner</span> on your firmware image. Issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>me_cleaner --soft-disable original.rom --output modified.rom
</code></p><pre>Full image detected
The ME/TXE region goes from 0x3000 to 0x280000
Found FPT header at 0x3010
Found 21 partition(s)
Found FTPR header: FTPR partition spans from 0x4e000 to 0xd4000
ME/TXE firmware version 9.5.3.1520
Removing extra partitions...
Removing extra partition entries in FPT...
Removing EFFS presence flag...
Correcting checksum (0xe3)...
Reading FTPR modules list...
 UPDATE           (LZMA   , 0x0b1e05 - 0x0b1f0f): removed
 ROMP             (Huffman, fragmented data    ): NOT removed, essential
 BUP              (Huffman, fragmented data    ): NOT removed, essential
 KERNEL           (Huffman, fragmented data    ): removed
 POLICY           (Huffman, fragmented data    ): removed
 FTPM             (LZMA   , 0x0b1f0f - 0x0bfbe1): removed
 HOSTCOMM         (LZMA   , 0x0bfbe1 - 0x0c81af): removed
 TDT              (LZMA   , 0x0c81af - 0x0cd4ed): removed
 FPF              (LZMA   , 0x0cd4ed - 0x0ceff8): removed
The ME minimum size should be 430080 bytes (0x69000 bytes)
The ME region can be reduced up to:
 00003000:0006bfff me
Setting the AltMeDisable bit in PCHSTRP10 to disable Intel ME...
Checking the FTPR RSA signature... VALID
Done! Good luck!
</pre></div>
<p>Your output will obviously differ (and in particular, if you are using a more modern PC than the CF-AX3 you may see a larger number of modules listed (and on a server-class machine, many fewer); see the <span>me_cleaner</span> <a rel="nofollow" href="https://github.com/corna/me_cleaner/issues/3">success reports</a>, for examples of the sort of output that may be produced).
</p>

<p>The resulting image is saved to the file <span>modified.rom</span>; the original firmware files are left untouched.
</p>
<h2><span id="Writing_Back_the_Modified_Firmware"><span id="reflash">Writing Back the Modified Firmware</span></span></h2>
<p>We can now write back (&#39;reflash&#39;) the system firmware we have just modified. With the IC clip still in place, issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=8000 -w modified.rom
</code></p><pre>flashrom v0.9.9-r1955 on Linux 4.10.17-v8-9411792647f6+ (aarch64)
flashrom is free software, get the source code at https://flashrom.org

Calibrating delay loop... OK.
Found Winbond flash chip &#34;W25Q64.V&#34; (8192 kB, SPI) on linux_spi.
Reading old flash chip contents... done.
Erasing and writing flash chip... Erase/write done.
Verifying flash... VERIFIED.
</pre></div>
<p>As before, your output will most likely differ somewhat, depending on the specifics of your setup.
</p>

<p>Once the flash has been successfully programmed, disconnect the IC-clip (or, if you are using a socketed chip and have it e.g. mounted on a solderless breadboard, remove the flash chip and place it back carefully in its socket on your PC).
</p>
<h2><span id="Restarting_your_PC_and_Verifying_the_IME_is_Disabled"><span id="restart_and_test">Restarting</span> your PC and Verifying the IME is Disabled</span></h2>
<p>Reassemble your target PC, following instructions given in your vendor&#39;s maintenance manual where available (and as always taking care to observe proper <a rel="nofollow" href="https://www.computerhope.com/esd.htm">proper ESD protective measures</a>). Ensure any batteries or power supplies are reconnected, and then try booting it up (into Gentoo) using your regular procedure.
</p><p>If you experience serious problems upon restart — for example, the machine will not <a href="https://en.wikipedia.org/wiki/Power-on_self-test" title="wikipedia:Power-on self-test">POST</a>, or you are unable to enter the BIOS setup GUI after boot — then jump <a href="#recovery">here</a> for instructions on how to recover (by reflashing your original firmware again).
</p><p><span id="renga_janai">However, in the more likely case</span> that your machine appears to start up correctly into Linux (after you enter your <span>LUKS</span> passphrase etc.), you can run the <span>intelmetool</span> to check the status of the ME. This is available as part of the <span>coreboot-utils</span> package on the <span>sakaki-tools</span> ebuild repository (aka &#39;overlay&#39;) which we already set up <a href="https://tech.michaelaltfield.net/wiki/User:Sakaki/Sakaki%27s_EFI_Install_Guide/Building_the_Gentoo_Base_System_Minus_Kernel#prep_for_parallel_emerge" title="User:Sakaki/Sakaki&#39;s EFI Install Guide/Building the Gentoo Base System Minus Kernel">earlier in the guide</a>, so, to install it, open a terminal (on your target PC), become root, and issue:
</p>
<div><p><code>koneko <span>~ #</span></code><span></span><code>emaint sync --repo sakaki-tools
</code></p><p><code>koneko <span>~ #</span></code><span></span><code>mkdir -p -v /etc/portage/package.unmask
</code></p><p><code>koneko <span>~ #</span></code><span></span><code>echo &#34;sys-apps/coreboot-utils::sakaki-tools&#34; &gt;&gt; /etc/portage/package.unmask/coreboot-utils
</code></p><p><code>koneko <span>~ #</span></code><span></span><code>emerge --ask --verbose sys-apps/coreboot-utils
</code></p><pre>... additional output suppressed ...
Would you like to merge these packages? [Yes/No] &lt;press y, then press Enter&gt;
... additional output suppressed ...
</pre></div>



<p><span id="imt_check">Then issue:</span>
</p>
<div><p><code>koneko <span>~ #</span></code><span></span><code>intelmetool --show
</code></p><p><span>Bad news, you have a `8 Series LPC Controller` so you have ME hardware on board
<p>and you can&#39;t control or disable it, continuing...
</p>
<pre>MEI was hidden on PCI, now unlocked
MEI found: [8086:9c3a] 8 Series HECI #0

ME Status   : 0x1e020191
ME Status 2 : 0x104d0142

ME: FW Partition Table      : OK
ME: Bringup Loader Failure  : NO
ME: Firmware Init Complete  : NO
ME: Manufacturing Mode      : YES
ME: Boot Options Present    : NO
ME: Update In Progress      : NO
ME: Current Working State   : Initializing
ME: Current Operation State : Bring up
ME: Current Operation Mode  : Debug
ME: Error Code              : No Error
ME: Progress Phase          : BUP Phase
ME: Power Management Event  : Clean Moff-&gt;Mx wake
ME: Progress Phase State    : 0x4d

ME: Extend SHA-256: &lt;hash&gt;

ME: failed to become ready
ME: failed to become ready
ME: GET FW VERSION message failed
ME: failed to become ready
ME: failed to become ready
ME: GET FWCAPS message failed
Re-hiding MEI device...done
</pre></span></p></div>
<p>Again, the output on your system will probably differ from this. You can safely ignore the ominous sounding <span>Bad news...</span> message, as that actually only indicates that the very low-level status registers of the ME are visible over PCI. The <i>real</i> indications that the ME is disabled are that you see (depending on your ME version) one or more of the below:
</p>
<ul><li><code>ME: Firmware Init Complete : NO</code> (as in the above);</li>
<li><code>ME: Error Code : Image Failure</code>;</li>
<li><code>ME: Current Working State : Initializing</code> (as in the above);</li>
<li><code>ME: Current Operation Mode : (null)</code>;</li>
<li><code>ME: Current Operation State : Bring up</code> (as in the above);</li>
<li><code>ME: Progress Phase : Uncategorized Failure</code>;</li>
<li><code>ME: Progress Phase : BUP Phase</code> (as in the above);</li>
<li><code>ME: Progress Phase State : Check to see if straps say ME DISABLED</code>;</li>
<li><code>ME: Progress Phase State : 0x4d</code> (as in the above);</li>
<li><code>ME: Progress Phase State : Unknown 0x40</code>;</li>
<li><code>ME: has a broken implementation on your board with this BIOS</code>;</li>
<li><code>ME: GET FW VERSION message failed</code> (as in the above); or</li>
<li><code>ME: GET FWCAPS message failed</code> (as in the above).</li></ul>


<p>You can also browse through the <span>me_cleaner</span> <a rel="nofollow" href="https://github.com/corna/me_cleaner/issues/3">success reports</a>, to see the sort of output that may be produced on different platforms.
</p><p>Next, wait for 30 minutes of wall time to elapse, and ensure that your target PC does not reset itself (thereby proving that the watchdog timer has been properly cleared).
</p>

<p>If all that worked, congratulations! You have disabled the ME on your PC — click <a href="#next_steps">here</a> to skip to the next step.
</p><p>If however you experience a problem booting (and cannot e.g. start Windows either, assuming you are dual-booting), then continue reading <a href="#recovery">immediately below</a>, to restore the original firmware image again.
</p>
<h3><span id="Recovery_in_Case_of_Error"><span id="recovery">Recovery in Case of Error</span></span></h3>
<p>The <span>me_cleaner</span> process just described does not work on all machines. Fortunately, since you <a href="#backup_firmware">saved a copy</a> of your original firmware earlier, and have a functional flash reprogrammer (the RPi3/4) to hand, it is straightforward to roll things back.
</p>

<p><span id="restore_image">To restore the original firmware image,</span> simply follow the previous instructions to power down your PC, expose the system motherboard, and (re)connect the RPi flash programmer&#39;s IC clip. Then on the RPi, working as root, issue:
</p>
<div><p><code>pi64 <span>~ #</span></code><span></span><code>pigs pud 23 u
</code></p><p><code>pi64 <span>~ #</span></code><span></span><code>pigs pud 24 u
</code></p><p><code>pi64 <span>~ #</span></code><span></span><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=8000 -w original.rom
</code></p><pre>... additional output suppressed ...
Verifying flash... VERIFIED.
</pre></div>
<p>to write the original firmware image back again. When done (make sure you see the <code>Verifying flash... VERIFIED</code> output), follow the earlier procedure to disconnect the IC clip, reassemble your target PC, and boot it up.
</p><p>In this case, unfortunately it appears that the IME cannot be disabled on your system at this time.
</p>
<h2><span id="Next_Steps"><span id="next_steps">Next Steps</span></span></h2>
<p>If you were <b>successful</b> restarting your system after running <span>me_cleaner</span> (and it passed the <a href="#imt_check"><code>intelmetool --show</code> test</a>), please consider posting details of your system <a rel="nofollow" href="https://github.com/corna/me_cleaner/issues/3">here</a>, to assist others.
</p><p>However, if you <b>experienced a problem</b> during the process, please take the time to post an <a rel="nofollow" href="https://github.com/corna/me_cleaner/issues/new">new issue</a> here.
</p><p>Finally, to rejoin the main guide, please click <a href="https://tech.michaelaltfield.net/wiki/User:Sakaki/Sakaki%27s_EFI_Install_Guide/Using_Your_New_Gentoo_System#additional_mini_guides" title="User:Sakaki/Sakaki&#39;s EFI Install Guide/Using Your New Gentoo System">here (<span>systemd</span>)</a> or <a href="https://tech.michaelaltfield.net/wiki/User:Sakaki/Sakaki%27s_EFI_Install_Guide/Using_Your_New_Gentoo_System_under_OpenRC#additional_mini_guides" title="User:Sakaki/Sakaki&#39;s EFI Install Guide/Using Your New Gentoo System under OpenRC">here (<span>OpenRC</span>)</a>.
</p>
<h2><span id="Notes"><span id="notes">Notes</span></span></h2>
<div>
<div><ol>
<li id="cite_note-1"><span><a href="#cite_ref-1">↑</a></span> <span>Skochinsky, Igor. <a rel="nofollow" href="http://me.bios.io/images/c/ca/Rootkit_in_your_laptop.pdf"><i>Rootkit in your Laptop</i></a>. Breakpoint 2012</span>
</li>
<li id="cite_note-2"><span><a href="#cite_ref-2">↑</a></span> <span>Skochinsky, Igor. <a rel="nofollow" href="https://recon.cx/2014/slides/Recon%202014%20Skochinsky.pdf"><i>Intel ME Secrets</i></a>. Recon 2014</span>
</li>
<li id="cite_note-3"><span><a href="#cite_ref-3">↑</a></span> <span>Positive Technologies <a rel="nofollow" href="https://www.troopers.de/downloads/troopers17/TR17_ME11_Static.pdf"><i>Intel ME: The Way of the Static Analysis</i></a>. TROOPERS17</span>
</li>
<li id="cite_note-zeronights-4"><span>↑ <sup><a href="#cite_ref-zeronights_4-0">4.0</a></sup> <sup><a href="#cite_ref-zeronights_4-1">4.1</a></sup></span> <span>Ermolov, Alexander. <a rel="nofollow" href="https://2016.zeronights.ru/wp-content/uploads/2017/03/Intel-BootGuard.pdf"><i>Safeguarding rootkits: Intel BootGuard</i></a>. ZERONIGHTS 2016</span>
</li>
<li id="cite_note-libreboot_me-5"><span><a href="#cite_ref-libreboot_me_5-0">↑</a></span> <span>libreboot FAQ: <a rel="nofollow" href="https://libreboot.org/faq.html#intelme">&#34;Intel Management Engine&#34;</a></span>
</li>
<li id="cite_note-6"><span><a href="#cite_ref-6">↑</a></span> <span>Purism Inc. Blog: <a rel="nofollow" href="https://puri.sm/learn/intel-me/">&#34;Intel&#39;s Management Engine&#34;</a></span>
</li>
<li id="cite_note-7"><span><a href="#cite_ref-7">↑</a></span> <span>Demerjian, Charlie. <a rel="nofollow" href="https://semiaccurate.com/2017/05/01/remote-security-exploit-2008-intel-platforms/">&#34;Remote security exploit in all 2008+ Intel platforms &#34;</a></span>
</li>
<li id="cite_note-8"><span><a href="#cite_ref-8">↑</a></span> <span>The Register: <a rel="nofollow" href="https://www.theregister.co.uk/2017/05/01/intel_amt_me_vulnerability/">&#34;Red alert! Intel patches remote execution hole that&#39;s been hidden in chips since 2010&#34;</a></span>
</li>
<li id="cite_note-9"><span><a href="#cite_ref-9">↑</a></span> <span>The Register: <a rel="nofollow" href="https://www.theregister.co.uk/2017/11/20/intel_flags_firmware_flaws/">&#34;Intel Finds Critical Holes in Secret Management Engine Hidden in Tons of Desktop, Server Chipsets&#34;</a></span>
</li>
<li id="cite_note-10"><span><a href="#cite_ref-10">↑</a></span> <span>For avoidance of doubt, in this guide &#39;disabled&#39; has the same meaning as &#39;neutralized and disabled&#39; in the Purism Inc. Blog: <a rel="nofollow" href="https://puri.sm/posts/deep-dive-into-intel-me-disablement/">&#34;Deep Dive into Intel Management Engine Disablement&#34;</a></span>
</li>
<li id="cite_note-11"><span><a href="#cite_ref-11">↑</a></span> <span>PT Security Blog <a rel="nofollow" href="http://blog.ptsecurity.com/2017/08/disabling-intel-me.html#more">&#34;Disabling Intel ME 11 via undocumented mode&#34;</a></span>
</li>
<li id="cite_note-12"><span><a href="#cite_ref-12">↑</a></span> <span>Corna, Nicola, <i>me_cleaner wiki</i>, <a rel="nofollow" href="https://github.com/corna/me_cleaner/wiki/HAP-AltMeDisable-bit">&#34;HAP AltMeDisable bit&#34;</a></span>
</li>
<li id="cite_note-13"><span><a href="#cite_ref-13">↑</a></span> <span>The HAP bit is available for ME version 11 (Skylake) and following. Earlier versions include a similar-function <span>AltMeDisable</span> bit (discovered by Igor Skochinsky) which <span>me_cleaner</span> will automatically set instead, where appropriate; however, this <span>AltMeDisable</span> bit is technically unassociated with the High Assurance Program <i>per se</i>.</span>
</li>
<li id="cite_note-14"><span><a href="#cite_ref-14">↑</a></span> <span>Benchoff, Brian. <a rel="nofollow" href="https://hackaday.com/2016/11/28/neutralizing-intels-management-engine/">&#34;Neutralizing Intel&#39;s Management Engine&#34;</a></span>
</li>
<li id="cite_note-15"><span><a href="#cite_ref-15">↑</a></span> <span>Corna, Nicola, <i>me_cleaner wiki</i>, <a rel="nofollow" href="https://github.com/corna/me_cleaner/wiki/How-does-it-work%3F">&#34;How does it work?&#34;</a></span>
</li>
<li id="cite_note-libreboot_psp-16"><span><a href="#cite_ref-libreboot_psp_16-0">↑</a></span> <span>libreboot FAQ: <a rel="nofollow" href="https://libreboot.org/faq.html#amd-platform-security-processor-psp">&#34;AMD Platform Security Processor (PSP)&#34;</a></span>
</li>
<li id="cite_note-17"><span><a href="#cite_ref-17">↑</a></span> <span>Henderson, Gordon, <i>wiringPi Blog</i>, <a rel="nofollow" href="http://wiringpi.com/wiringpi-deprecated/">&#34;wiringPi – deprecated…&#34;</a></span>
</li>
</ol></div></div>
<!-- 
NewPP limit report
Cached time: 20221026035952
Cache expiry: 86400
Dynamic content: false
Complications: []
[SMW] In‐text annotation parser time: 0.016 seconds
CPU time usage: 0.742 seconds
Real time usage: 0.757 seconds
Preprocessor visited node count: 4987/1000000
Post‐expand include size: 134673/2097152 bytes
Template argument size: 61829/2097152 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 11900/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  169.623      1 -total
 26.26%   44.551     25 Template:RootCmd
 25.88%   43.903     27 Template:GenericCmd
 23.27%   39.465      1 Template:Reflist
 18.05%   30.611     30 Template:Note
 14.96%   25.380     30 Template:Note/core
  7.93%   13.453     38 Template:GenericCmd/Line
  6.69%   11.348      2 Template:Cmd
  5.04%    8.541      9 Template:Warning
  4.62%    7.835      5 Template:Tip
-->

<!-- Saved in parser cache with key gentoo?hwiki:pcache:idhash:219264-0!canonical and timestamp 20221026035951 and revision id 887379
 -->
</div></div></div>
  </body>
</html>
