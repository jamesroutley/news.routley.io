<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gianluca.ai/devlog-llmpossible/">Original</a>
    <h1>DevLog: llmpossible</h1>
    
    <div id="readability-page-1" class="page"><div><p>The <a href="https://www.recurse.com/">Recurse Center (RC)</a> hosts “Impossible Stuff Day” once per batch. It’s a whole day to spend working on something well beyond the edge of your abilities that feels totally impossible. The <a href="https://purplesyringa.moe/rc-weeknotes-03/#doing-the-impossible">last one</a> wasn’t productive for me, but I’m taking a different approach this time around.</p><hr/><p>UPDATE: I came back after taking a break to embed all the screenshots I took, write the metadata for this post, link to some things I didn’t find at the time, and do a light proofread. But the actual post was written in real time as I was building. I didn’t know where I would end up when I began.</p><hr/><p>16:00: I’m going to directly record my notes into this blog post as I go, with minimal filtering. I’m curious if that workflow will be helpful and fun compared to what I normally do — writing scrappy notes in Obsidian.</p><h2 id="idea-dump">Idea dump</h2><p>16:15: I have a running note with lists of goals, resources, and project ideas (big and small) to tackle <a href="https://purplesyringa.moe/tags/rc-fall-24/">during Recurse</a>. I’m pulling out some that feel most interesting to me today and are most “impossible day” appropriate.</p><h3 id="big-and-impossible-ideas">Big and impossible ideas</h3><ul><li>Fine-tune and tweak local LLM for my workflows</li><li>The AI coding assistant that makes you a better programmer</li><li>LLM-enhanced news feed based on RSS from multiple sources, semantic filtering, summarisation, etc.</li><li>Embedding-to-vision/3D models to make any data easy to explore as vibes. Worlds full of characters instead of charts and spreadsheets. The “Blindsight” thing.</li><li>Figure out how to get large models running locally on MacBook, with acceleration.</li><li>Make an audio-only game from scratch (in Rust?)</li><li>Multimodal (vision + LLM) assistant for querying personal health data (e.g. HealthKit), spotting trends, making suggestions, etc. Ideally on-device.</li></ul><h3 id="small-and-highly-possible-side-quests">Small and highly possible side quests</h3><ul><li>Flesh out the functionality of <a href="https://github.com/gianlucatruda/tai">tai</a> (terminal AI) in Rust.</li><li>Try getting <a href="https://github.com/black-forest-labs/flux">flux.1</a> model running on Apple Silicon with <code>mps</code>. See some issues on GH already.</li><li>Fork <a href="https://github.com/simonw/llm/pull/571">llm</a> and just tailor it to myself. (If I keep the upstream stuff I can probably benefit from later improvements, whilst also optimising it for my own use cases.)</li><li>Run whisper.cpp server locally, transcribe all <a href="https://podtangent.com">Bit of a Tangent</a> episodes (and make an LLM that RAGs / embeds them?)</li><li>Try Mojo and use it to optimise <em>something</em>. <a href="https://purplesyringa.moe/table-diffusion">TableDiffusion</a>?</li><li>OpenAI/GPT-based systems for automatically transcribing, organising, and actioning voicenotes I record on the go.</li><li>Build my own version of <a href="https://gist.github.com/karpathy/1dd0294ef9567971c1e4348a90d69285">Git Commit Message AI</a>.</li></ul><hr/><h2 id="picking-a-topic-and-scaling-the-scope-to-impossible">Picking a topic and scaling the scope to impossible</h2><p>It’s 16:40, I’ve just finished the RC Zoom call for the Impossible Stuff Day kickoff, slammed a cup of coffee, and put the Social Network <a href="https://open.spotify.com/track/50CgC2wKmbWm4WLQKY87oP?si=08a6975836674151">soundtrack</a> on. You know <a href="https://youtu.be/KdtPNRzuKrk">the scene</a>. Things are about to get built!</p><p>It’s 16:43 on a rainy Tuesday afternoon. I’m a little over-caffeinated, I’m not gonna lie. <a href="https://youtu.be/KdtPNRzuKrk?t=52">I need to do something to take my mind off things</a>. Easy enough, except I need an idea…</p><p>A unifying theme in the brain dump above: running foundation models locally on my MacBook, fine-tuning/contextualising them with my data, integrating them into useful workflows, and then optimising for performance.</p><p>Doing all that in under 5 hours certainly feels ambitious, but not quite “impossible.”</p><p>16:48: One of the idea clusters I’ve been exploring in recent conversations has been focussed on the major limitation of frontier LLMs being that they’re trained to solve all the tasks in all the ways on all the data. The regression to the mean of human-created data on the internet + the entropy-minimising training regime means you get a bit of a midwit. Then you RLFH the capabilities away to make the model “safer” and more of a “friendly, helpful assistant.” Throw in some borderline-unethical human annotations <a href="https://simonwillison.net/2024/Apr/18/delve/">coming from niche populations in developing nations</a> and you get something that doesn’t feel quite as useful to me.</p><p>But what if that’s just a skill issue on my part? What if I should just be rolling my own bespoke assistant? Can I offset the <a href="http://www.incompleteideas.net/IncIdeas/BitterLesson.html">value of scale</a> by personalising and contextualising?</p><p>16:54: Adding in that exploratory goal (which will require “<a href="https://www.theguardian.com/technology/2024/apr/16/techscape-ai-gadgest-humane-ai-pin-chatgpt">delving</a>” into the weeds of LoRA, MoE, Metal/MPS, Llama, etc.) certainly upgrades the ambitious idea to a near-impossible one.</p><p>We’ve calibrated the scope. Let’s clarify what I’m actually trying to do here. What would outright victory entail?</p><h3 id="the-impossible-target">The impossible target</h3><p>A capable multi-modal LLM of at least 1B parameters running on my M2 MacBook (with GPU/ANE acceleration), fine-tuned/RLHFed to behave according to my preferences and goals, with my personal data, previous work, and current projects as context. And it would be running from a powerful and modular command line interface that supports UNIXy workflows (piping to stdin and from stdout, CL arguments, config dotfile, Vim integration).</p><h3 id="subgoals">Subgoals</h3><p>17:10: Let’s break that down into chunks:</p><ul><li>(1) A capable multi-modal LLM of at least 1B parameters running on my M2 MacBook<ul><li>(1a) GPU/ANE acceleration</li><li>(1b) Fine-tuned/RLHFed to behave according to my preferences and goals</li></ul></li><li>(2) My personal data, previous work, and current projects as context</li><li>(3) Running from a powerful and modular command line interface that supports UNIXy workflows<ul><li>piping to stdin and from stdout, CL arguments, config dotfile, Vim integration, etc.</li></ul></li></ul><hr/><h2 id="tactics-for-achieving-the-impossible">Tactics for achieving the impossible</h2><p>17:15: Okay, that’s nice structure. What makes this achievable in a short timeframe? This has to be <a href="https://purplesyringa.moe/tags/hackathon/">hackathon</a> rules. I’m obviously doing this to learn and develop skills/experience, but writing boilerplate and scouring library docs is a waste of time and attention until I’ve validated an approach.</p><p>When I encounter that, LLMs seem like the right lever to apply: codegen the boilerplate with Supermaven/Cursor, ask <code>o1-preview</code> for recommendations and reviews.</p><p>Moreover, forking/incorporating existing open-source code is probably going to help me here. But I’m going to do it in the most modular way possible. That way, once I’ve validated that something works as desired as a black box, I can hot-swap it with my own version (or at least make a note to return later to dig deeper and roll my own).</p><p>It’s also my biannual occasion to give <a href="https://www.cursor.com/">Cursor</a> another try, so let me install that and add an API key.</p><p>17:22: In the meanwhile, I’m going to feed this entire post so far into <a href="https://purplesyringa.moe/what-o1-means/">o1-preview</a> and have it give me some tips and suggestions.</p><h3 id="pairing-with-o1-preview">Pairing with o1-preview</h3><div><pre tabindex="0"><code data-lang="bash"><span><span>llm --model o1-preview <span>&#34;I&#39;m an ML engineer who is highly capable at Python (Pandas, PyTorch, NumPy), moderately skilled at JavaScript and Bash, and about 20h into learning Rust. I understand Transformers and use LLMs daily. I mainly work in the terminal (bash, neovim, grep, etc.) on my M2 MacBook Pro. What follows is my plan for Impossible Day. Your task is to review the plan, help mebreak it down into smaller tasks, and advise me on what techniques and technologies best enable me to tackle this problem in a few hours:\n`cat ~/2-Areas/Blog/content/posts/rc-impossible-day-oct24/index.md`&#34;</span> <span>|</span> tee ~/0-Inbox/impossible-o1-<span>$(</span>ecdt<span>)</span>.md
</span></span></code></pre></div><p>That gives this post to <code>o1-preview</code> via the <a href="https://github.com/simonw/llm">llm</a> CLI app, then <code>tee</code> both prints the response to stdout and writes it to a file. The <code>ecdt</code> call is a custom <a href="https://github.com/gianlucatruda/dotfiles/blob/4a25623d9a2fea8525f327734ae6979de9d775fe/.config/.aliases#L25">alias</a> I wrote to “echo current date time”. It’s handy for ensuring unique file names and having timestamps to refer back to later.</p><p>17:40: <code>o1-preview</code> had great structure in the response, breaking my subgoals down further. Having lots of good keywording in this post probably helped. The context about me, my skills, and my hardware also seemed to guide it to more specific recommendations.</p><p>Useful tips it gave:</p><ul><li>Leverage Apple’s Metal Performance Shaders (MPS) for GPU acceleration in PyTorch.</li><li>Explore tools like <code>llama.cpp</code> or <code>ggml</code> which offer optimized performance on Apple Silicon.</li><li>Utilize libraries like <code>peft</code> (Parameter-Efficient Fine-Tuning) in PyTorch.</li><li>CLI Frameworks:<ul><li>Use <code>argparse</code> or <code>click</code> in Python for command-line argument parsing.</li><li>For Rust, consider <code>clap</code> or <code>structopt</code>.</li></ul></li><li>Use Vim’s <code>system()</code> function to send and receive data from your CLI application.</li></ul><p>Most of the rest of its response was just re-wording what I’ve already written above in a more structured format combined with kinda banal suggestions like “regularly test each component as you develop to catch issues early.” Gee thanks.</p><hr/><h3 id="setting-up-cursor">Setting up Cursor</h3><p>17:54: Installed Cursor. Major improvements to the setup and onboarding flow since I last used it. It allowed me to enable Vim keybinds and privacy mode off the bat, but then squandered that by forcing me to log in (which meant I had to go create and verify an account) only for me to then give it my own OpenAI API key anwyay. Also their defensibility and value-add is largely from their own custom models, which I will have limited/no access to. I also had to manually add <code>o1-preview</code> and <code>o1-mini</code> as viable models. Still not sure if this will work. And god damn there are so many annoying poppup things and calls-to-action and I want to run away back to my cozy neovim setup already…</p><p>18:10: I’ve just been on a whole tangent in Cursor trying to get it to help me modify my Hugo blog setup so that my code snippets have line wrapping, as it’s something that’s been bugging me and I figured this is a good test for Cursor. So far I’m not hugely impressed. It’s done a lot of bullshitting in the chat window and made bad recommendations. But the inline completion stuff was pretty good, especially once I was in the process of making the change. After I created a new <code>.css</code> file, it then knew what code to add to it (based on its suggestion) and then when I navigated to the header partial it knew to complete the linking to that new <code>.css</code> file. Of course, it didn’t actually achieve the desired result.</p><p>I then tried to ask it again using <code>o1-preview</code>, which I was surprised worked as I had just added that manually as a model option.</p><p>18:18: Great… now I’m back in the same feedback loop of LLMs suggesting code, the code causing an error, pasting the error back, the LLM re-writing the code, a new error, etc. This isn’t a better workflow…</p><p><img loading="lazy" src="https://purplesyringa.moe/blog/we-built-the-best-bad-apple-in-minecraft/images/cursor-window-error.png" alt="cursor-window-error"/></p><p>18:23: Dogshit! Wasted nearly an hour on this crap. <code>git restore .</code> and moving on…</p><hr/><h2 id="a-capable-multi-modal-llm-of-at-least-1b-parameters-running-on-my-m2-macbook">A capable multi-modal LLM of at least 1B parameters running on my M2 MacBook</h2><p>18:25: Okay, the first part to tackle is finding a suitable base LLM (preferably multimodal) that I can run locally. I think there was a new Llama release last week that has multiple model sizes and multimodal support. There are some asterisks around licensing, but “<a href="https://protos.com/former-coinbase-employee-accused-of-stealing-code-for-pearai/">we busy building rn can’t be bothered with legal</a>.”</p><p>18:31: Firstly, Meta’s <a href="https://www.llama.com/">llama webpage</a> is so full of scripts and Facebook trackers that my hardened browser literally just rendered a blank page. We live in an enshittified hellscape. I’ll throw it into my sacrificial Chromium instance to progress.</p><blockquote><p>Llama 3.2 is a collection of large language models (LLMs) pretrained and fine-tuned in 1B and 3B sizes that are multilingual text only, and 11B and 90B sizes that take both text and image inputs and output text.</p></blockquote><p>Okay, based on some things I read recently and a few Fermi estimates, I believe you need about 2x the parameter count worth of memory for LLM inference (so call it 7GB for the 3B model and 25GB for the 11B model) and 4x for training. Obviously it’s less for finetuning with adaptors as you don’t need to keep a full set of gradients, but I’ll use that as an upper bound heuristic.</p><p>My over-specced-indulgence of a MacBook has 96GB of unified memory (shared between the GPU and CPU cores) and at least half of that sits idle when I’m writing prose, coding simple things, or just browsing. So I can probably get away with using the 11B model comfortably. But is multimodal support worth waiting on the download and the added complexity under my time constraints today? I dunno, but I can always fall back to the 3B text-only model.</p><p>18:41: Fuck you, Meta! I have to give you my personal information to download your “open” weights? Piss off! I can’t believe you’re doing this after I channeled 2003 Zuck energy earlier!</p><p><img loading="lazy" src="https://purplesyringa.moe/blog/we-built-the-best-bad-apple-in-minecraft/images/meta-data-wall.png" alt="Meta data wall"/></p><p>18:46: It seems like I can download the model <a href="https://huggingface.co/meta-llama/Llama-3.2-11B-Vision-Instruct">from Huggingface</a>, but I’ll still have to log in and “agree to share your contact information to access this model.” Hawk tuah!</p><p>But I’ll likely want to use HF’s <code>transformers</code> package to work with the model in Python/PyTorch for this project, so I guess that’s the lesser of evils. Plus the HF repo has more info about the models (context length 128k, knowledge cutoff Dec 2023, etc.) on those model cards.</p><p>JFC even when logged in it’s the same form!!! Why do you need my full date of birth Meta!?!?!</p><p>18:51: “Your country and region (based on approximate Internet address) will be shared with the model owner.” Honestly, I should have known better. So now I’m <a href="https://huggingface.co/models?pipeline_tag=image-text-to-text&amp;sort=trending">searching for alternatives on Hugginface</a>.</p><p>18:58: <a href="https://huggingface.co/allenai/Molmo-7B-D-0924">Molmo 7B-D</a> seems like it might fit the bill. 8B parameters, vision-text-to-text. Let’s see.</p><h3 id="setting-up-a-project">Setting up a project</h3><div><pre tabindex="0"><code data-lang="bash"><span><span>uv init llmpossible
</span></span><span><span><span>cd</span> llmpossible
</span></span><span><span>uv add einops torch torchvision transformers
</span></span></code></pre></div><p>And let’s make sure <a href="https://pytorch.org/docs/stable/notes/mps.html">mps</a> will work:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;</span> <span>uv</span> <span>run</span> <span>python</span>
</span></span><span><span><span>Python</span> <span>3.10.14</span> <span>(</span><span>main</span><span>,</span> <span>Aug</span> <span>14</span> <span>2024</span><span>,</span> <span>05</span><span>:</span><span>14</span><span>:</span><span>46</span><span>)</span> <span>[</span><span>Clang</span> <span>18.1.8</span> <span>]</span> <span>on</span> <span>darwin</span>
</span></span><span><span><span>Type</span> <span>&#34;help&#34;</span><span>,</span> <span>&#34;copyright&#34;</span><span>,</span> <span>&#34;credits&#34;</span> <span>or</span> <span>&#34;license&#34;</span> <span>for</span> <span>more</span> <span>information</span><span>.</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>import</span> <span>torch</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>torch</span><span>.</span><span>backends</span><span>.</span><span>mps</span><span>.</span><span>is_available</span><span>()</span>
</span></span><span><span><span>True</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>torch</span><span>.</span><span>backends</span><span>.</span><span>mps</span><span>.</span><span>is_built</span><span>()</span>
</span></span><span><span><span>True</span>
</span></span></code></pre></div><p>19:08: Running short on time. Who knew that the “impossible” part of Impossible Day was due to spending ages fighting with annoying signups and trying to defend my right to privacy.</p><p>Let’s use the recommended Python boilerplate on Molmo’s Huggingface repo to get the weights downloading, then I’ll probably need to update it to use <code>mps</code> backend instead of <code>cuda</code>. It may not even work.</p><p>19:14: No dice. It fails early:</p><div><pre tabindex="0"><code data-lang="markdown"><span><span>ImportError: Using <span>`low_cpu_mem_usage=True`</span> or a <span>`device_map`</span> requires Accelerate: <span>`pip install &#39;accelerate&gt;=0.26.0&#39;`</span>
</span></span></code></pre></div><p>19:17: I commented-out the two <code>device_map=&#39;auto&#39;</code> lines and now it seems to be downloading the weights. Now I just have to wait around 18 mins. But cool to see that they’re <a href="https://github.com/huggingface/safetensors">safetensors</a>. That’s been one major safety and usability improvement to open deep learning models in the past couple years.</p><p>In the meantime, I asked gpt-4-turbo to re-write the boilerplate with <code>mps</code> compatability:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>pbpaste <span>|</span> llm -s <span>&#34;Re-write this code to use the mps backend so it runs effectively on Apple Silicon.&#34;</span> <span>|</span> tee /dev/tty <span>|</span> glow
</span></span></code></pre></div><p>That pastes from my clipboard as the prompt to the <code>llm</code> tool, then uses the system prompt (with the <code>-s</code> flag) for my instructions. I pipe the output to <code>glow</code> (a nice markdown rendered for the terminal) via <code>/dev/tty</code> which means I see the response stream in as plaintext so I can check it’s not doing something stupid before it finally gets sent to glow for pretty rendering.</p><p>The response wasn’t great, as it decided to also re-write half the code in a different way that seemingly has no bearing on <code>mps</code> support. But I’ll have to wait to find out if the key portion is correct. Honestly I could have just written the key bits myself, just add the line:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>device</span> <span>=</span> <span>&#34;mps&#34;</span> <span>if</span> <span>torch</span><span>.</span><span>backends</span><span>.</span><span>mps</span><span>.</span><span>is_available</span><span>()</span> <span>else</span> <span>&#34;cpu&#34;</span>
</span></span></code></pre></div><p>and then <code>.to(device)</code> on the model.</p><h3 id="downloading-model-weights">Downloading model weights</h3><p>19:34: I’m worried. Initially, the download progress bar seemed reasonable. It looked like 5GB file, which passed the sniff test for a 8B parameter model (with compression?), but I now see that that’s shard 1 of 7. Why would the model be so big? Overall that’s over 30GB.</p><p>Ohhh I see. Actually, that makes perfect sense for <em>f32</em> weights: 8B x 32-bit (4-byte) floats is roughly 32GB. My 2x heuristic earlier was based on the assumption of f16 weights, which are commonly used for on-device LLMs. I should have read the small print. Also, it may not be trivial to do that conversion, but regardless I’m now limited by my download bandwidth and this won’t finish in time. Shit.</p><p>19:46: I was worried when I started on this earlier that downloading weights was going to be a bottleneck, but I handwaved away the 2-4x coefficient and didn’t expect so many delays on the road to actually getting a model downloading. Time to reassess.</p><h3 id="finding-an-alternative-model">Finding an alternative model</h3><p>20:00: The <a href="https://huggingface.co/spaces/open-llm-leaderboard/open_llm_leaderboard">OpenLLM Leaderboard</a> on HuggingFace allows filtering by parameter size and reveals some interesting candidates in the 1–4B parameter range. I don’t have the time to look deeply into this now, but a small text-to-text model is something I might conceivably get running in the next hour.</p><p>20:05: Microsoft’s <a href="https://huggingface.co/microsoft/Phi-3.5-mini-instruct">Phi-3.5-mini-instruct</a> might do the job here. It’s 128k-context, 3.8B parameters in <a href="https://www.exxactcorp.com/blog/hpc/what-is-fp64-fp32-fp16">BF16</a>, which is under 8GB to download. TIL, check the files section on HuggingFace to see the number and size of the <code>.safetensor</code> files beforehand.</p><p>20:22: It’s nearly finished downloading the first of the two safetensor files, so I’ve been using <code>o1-preview</code> to help me whip up a simple CLI (using <a href="https://pypi.org/project/rich/">rich</a> and <a href="https://pypi.org/project/argparse/">argparse</a>) in the meanwhile that I can wrap around the LLM if/when it’s ready.</p><p>20:37: I got a nice CLI working (man, <code>rich</code> is such a great and easy library) that takes piped stdin and can pretty print or plaintext print to stdout. In the meanwhile, the download finished and the Phi test worked! But then I ran it again with <a href="https://github.com/vladkens/macmon">macmon</a> open and it’s running on the CPU? But that’s solvable, I think. It’s also complaining:</p><p><img loading="lazy" src="https://purplesyringa.moe/blog/we-built-the-best-bad-apple-in-minecraft/images/phi-kinda-works.png" alt="phi-model-working"/></p><h3 id="gpu-acceleration-with-mps-backend">GPU acceleration with mps backend</h3><p>20:47: I fiddled around a bit with adding <code>to(device)</code> where <code>device=&#39;mps&#39;</code> and now it seems to be doing at least something on the GPU, but there’s still a massive CPU spike as well. The memory footprint also goes up by around 13GB, which checks out (2 x 8B estimate from earlier for 16-bit weights).</p><p>Naturally, I’m loading up and processing the model weights every time to run the single query. In an improved implementation, there would be a background process running when the model is likely to be needed, keeping the weights in memory and the model ready to go when the CLI process makes a request. A lot of the CPU hit and latency is probably from that. Not sure I’ll have time for that in the next 30 mins thought.</p><p>20:53: I’m going to try to evaluate that hypothesis by just running a bigger generation. That way, I’ll see a split between the load-setup phase and the generation phase of the LLM. (Ideally, I’d like to have the LLM stream it’s responses too. I’m going to do some digging into the <code>transformers</code> library to see if that’s reasonably easy to quickly implement.)</p><p>21:00: 30-minutes left of the official Impossible Stuff Day period. Whilst waiting on the LLM to spit out some stuff with my (and GPT-4-turbo’s) broken token streaming code, I looked into the flash attention warning and noticed on the HuggingFace page for Phi:</p><blockquote><p>Note that by default, the Phi-3.5-mini-instruct model uses flash attention, which requires certain types of GPU hardware to run. We have tested on the following GPU types: NVIDIA A100, NVIDIA A6000, NVIDIA H100</p></blockquote><p>This is a bit of a spanner in the works in terms of this being a good model in the long run. But whatever, I can switch models when I have overnight hours to download weights. The main goal was just to get this working at all.</p><p>21:07: Quick hack, I just manually forced <code>device = &#39;cpu&#39;</code> and monitored what happened. Now there’s sky-high CPU usage, absolutely no GPU usage, and the whole thing is much much slower. So the <code>mps</code> was at least doing something. What’s peculiar is that there was seemingly no memory footprint on that run. Does that mean it was lazy-loading weights from storage? Surely not.</p><p>21:15: With a bit of fiddling, I have token-by-token output working. It starts off around 2 tokens per second (by my mental count), but then seems to slow to around 1 token per second. The memory footprint also creeps up and up. That would make sense, as nothing is getting collected or dumped from the process until the generation is complete and the script exits.</p><h2 id="running-from-a-powerful-and-modular-command-line-interface-that-supports-unixy-workflows">Running from a powerful and modular command line interface that supports UNIXy workflows</h2><p>21:29: With little time to go, I did some context-powered prompt-yoloing with <code>o1-preview</code> and it actually worked! It was able to help me convert the LLM code into a simple async server daemon and update the CLI accordingly to use that as the source of queries. So now things stay in memory!</p><p>21:50: Just finished doing a 90-second demo to the rest of the Recursers who participated in Impossible Stuff Day. It worked!</p><p><img loading="lazy" src="https://purplesyringa.moe/blog/we-built-the-best-bad-apple-in-minecraft/images/demo.png" alt="demo-to-rc"/></p><hr/><h2 id="reflecting-on-5-hours-of-attempting-the-impossible">Reflecting on 5 hours of attempting the impossible</h2><p>At around 17:00, I had clarified the idea and broken it down into subgoals. Let’s review those as of 22:00.</p><p>I didn’t get a multi-modal model working, but that was mainly bottlenecked by privacy invasions and internet bandwidth. But I did get a capable 3B-parameter LLM (Phi-3.5-mini-instruct) running on my MacBook with GPU acceleration. I didn’t have time to do any fine-tuning or RLHF for subgoal 1b, but I have a great foundation to build on when I tackle that.</p><p>I also got everything wrapped up into a useable CLI tool that allows piping in and out (this means it would technically work from within vim too). It allows the user to toggle the rich text rendering with the <code>--no-rich</code> flag. That meets most of the criteria of subgoal 3.</p><ul><li> (1) A capable multi-modal LLM of at least 1B parameters running on my M2 MacBook<ul><li> (1a) GPU/ANE acceleration</li><li> (1b) Fine-tuned/RLHFed to behave according to my preferences and goals</li></ul></li><li> (2) My personal data, previous work, and current projects as context</li><li> (3) Running from a powerful and modular command line interface that supports UNIXy workflows<ul><li> piping to stdin and from stdout</li><li> CL arguments</li><li> config dotfile</li><li> Vim integration</li></ul></li></ul><p>Overall, I’d call that a pretty good success. Despite taking the time to write this devlog as I went, wasting time trying to make use of Cursor, and burning over an hour finding an open LLM that didn’t want to harvest my organs or destroy my router, I managed to get the most important and foundational aspects of this “impossible” project completed.</p><p>This is huge! I’ve been meaning to revisit local models and dig deper on them for nearly a year now, but there was friction and analysis paralysis. The structure and accountability of Impossible Stuff Day was the nudge I needed. And I’m delighted that this attempt went so much better than the last one. I’m satisfied with today and looking forward to building on this work in coming weeks.</p><h3 id="notes-on-llms-as-levers">Notes on LLMs as levers</h3><p>Earlier, in <a href="#tactics-for-achieving-the-impossible">tactics for achieving the impossible</a>, I reasoned that using LLMs for code generation would be a key lever to actually achieving “impossible” goals in only a few hours. The plan being to make use of Cursor and <code>o1-preview</code> to write boilerplate or cut down on the time required to utilise unfamiliar libraries. How did that hold up?</p><p>It was mixed. Cursor turned out to be a big time suck on set up (and sign up) and fiddling to figure out the changes since I last tried it and how to integrate it into my workflow.</p><p>Using <code>o1-preview</code> via the command line with <code>llm</code> turned out to be invaluable and probably saved me an hour of stressful integrations at the end by oneshotting a working daemon to serve the model to the CLI. I was impressed and relieved that that worked, but I’m not surprised. It probably cost $2 or $3 and I literally gave it this entire blog post and all my code and a detailed prompt as context:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>llm --model o1-preview <span>&#34;You will help me write a finished piece of code. The following is my project plan:\n `cat ~/2-Areas/Blog/content/posts/rc-impossible-day-oct24/index.md` \n---\n And here is my code: `cat pyproject.toml main.py cli.py` \n---\n Write the integration between the local LLM model and the CLI. The model should be loaded (with mps) and stored in memory when a daemon process is started. Then the cli tool should merely invoke a generation. Also make any reasonable improvements and performance tweaks so this runs reliably and quickly on my M2 MacBook. &#34;</span><span>|</span> tee ~/0-Inbox/impossible-o1-<span>$(</span>ecdt<span>)</span>.md
</span></span></code></pre></div><p>If you’re using (neo)vim and are living on the command line, this is just a way more powerful and flexible and scrutable way to interact with these tools.</p><p>And being able to Perplexity search for quick answers (and then following the sources) massively cut down on the time required to pivot and change plans. It’s how I discovered the OpenLLM Leaderboard and thus a good fallback model.</p><p>These tools didn’t suppress my learning in this case. I know how to write basic CLI tools in Python and how to spin up a pair of processes in a client-server pair. But what I didn’t know was a lot of the tacit hands-on stuff about actually downloading SOTA LLMs from HuggingFace and spinning them up on a non-standard accelerator backend with <code>transformers</code>. And those things I was able to develop a knack for.</p><p>But you’d best believe I’ll be wading into the depths of the code myself now that the time pressure is off. Sprint, recover, assess, optimise, orient, repeat.</p><h2 id="next-steps">Next steps</h2><p>There’s a lot I could do from here. These seem like the most pressing and interesting tasks to tackle next in this project:</p><ul><li>Figure out why the model actually seems to work fine despite the flash-attention warnings.</li><li>Find a more appropriate base model (ideally multimodal and fully permissive) to build on.</li><li>Dig deeper into the <code>mps</code> support and perhaps look at writing bespoke <a href="https://github.com/ml-explore/mlx">mlx</a> code to fully take advantage of the hardware (ANE + GPU).</li><li>Improve the daemon.</li><li>Get response streaming to work and detokenize nicely.</li><li>Implement LoRA finetuning.</li></ul><hr/><p>You’re still here? Still reading this? Aww shucks!</p><p>Please reach out and tell me what you thought of this DevLog-style post and what I worked on. I’d love to hear from you, even if you just have scathing critiques.</p></div></div>
  </body>
</html>
