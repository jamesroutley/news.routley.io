<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://davepeck.org/2025/04/11/pythons-new-t-strings/">Original</a>
    <h1>Python&#39;s new t-strings</h1>
    
    <div id="readability-page-1" class="page"><div> <p>Template strings, also known as t-strings, have been <a href="https://peps.python.org/pep-0750/">officially accepted</a> as a feature in Python 3.14, which will ship in late 2025. ðŸŽ‰</p>
<p>Iâ€™m excited; t-strings open the door to safer more flexible string processing in Python.</p>
<h4 id="whats-the-big-idea-with-t-strings">Whatâ€™s the big idea with t-strings?</h4>
<p>Since they were introduced in Python 3.6, <a href="https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals">f-strings</a> have become a <em>very</em> popular way to format strings. They are concise, readable, and powerful.</p>
<p>In fact, theyâ€™re <em>so</em> delightful that many developers use f-strings for everythingâ€¦ even when they shouldnâ€™t!</p>
<p>Alas, f-strings are often dangerously (mis)used to format strings that contain user input. Iâ€™ve seen f-strings used for SQL (<code>f&#34;SELECT * FROM users WHERE name = &#39;{user_name}&#39;&#34;</code>) and for HTML (<code>f&#34;&lt;div&gt;{user_name}&lt;/div&gt;&#34;</code>). These are not safe! If <code>user_name</code> contains a malicious value, it can lead to <a href="https://owasp.org/www-community/attacks/SQL_Injection">SQL injection</a> or <a href="https://owasp.org/www-community/attacks/xss/">cross-site scripting</a>.</p>
<p>Template strings are a <em>generalization</em> of Pythonâ€™s f-strings. Whereas f-strings immediately become a string, t-strings evaluate to a new type, <code>string.templatelib.Template</code>:</p>
<pre tabindex="0" data-language="python"><code><span><span>from</span><span> string.templatelib </span><span>import</span><span> Template</span></span>
<span><span>name </span><span>=</span><span> &#34;World&#34;</span></span>
<span><span>template: Template </span><span>=</span><span> t</span><span>&#34;Hello </span><span>{name}</span><span>!&#34;</span></span>
<span></span></code></pre>
<p>Importantly, <code>Template</code> instances are <em>not</em> strings. The <code>Template</code> type does not provide its own <code>__str__()</code> implementation, which is to say that calling <code>str(my_template)</code> does not return a useful value. Templates <em>must</em> be processed before they can be used; that processing code can be written by the developer or provided by a library and can safely escape the dynamic content.</p>
<p>We can imagine a library that provides an <code>html()</code> function that takes a <code>Template</code> and returns a safely escaped string:</p>
<pre tabindex="0" data-language="python"><code><span><span>evil </span><span>=</span><span> &#34;&lt;script&gt;alert(&#39;bad&#39;)&lt;/script&gt;&#34;</span></span>
<span><span>template </span><span>=</span><span> t</span><span>&#34;&lt;p&gt;</span><span>{evil}</span><span>&lt;/p&gt;&#34;</span></span>
<span><span>safe </span><span>=</span><span> html(template)</span></span>
<span><span>assert</span><span> safe </span><span>==</span><span> &#34;&lt;p&gt;&amp;lt;script&amp;gt;alert(&#39;bad&#39;)&amp;lt;/script&amp;gt;&lt;/p&gt;&#34;</span></span>
<span></span></code></pre>
<p>Of course, t-strings are useful for more than just safety; they also allow for more flexible string processing. For example, that <code>html()</code> function could return a new type, <code>HTMLElement</code>. It could also accept all sorts of useful substitutions in the HTML itself:</p>
<pre tabindex="0" data-language="python"><code><span><span>attributes </span><span>=</span><span> {</span><span>&#34;src&#34;</span><span>: </span><span>&#34;roquefort.jpg&#34;</span><span>, </span><span>&#34;alt&#34;</span><span>: </span><span>&#34;Yum&#34;</span><span>}</span></span>
<span><span>template </span><span>=</span><span> t</span><span>&#34;&lt;img </span><span>{attributes}</span><span> /&gt;&#34;</span></span>
<span><span>element </span><span>=</span><span> html(template)</span></span>
<span><span>assert</span><span> str</span><span>(element) </span><span>==</span><span> &#34;&lt;img src=&#39;roquefort.jpg&#39; alt=&#39;Yum&#39; /&gt;&#34;</span></span>
<span></span></code></pre>
<p>If youâ€™ve worked with JavaScript, t-strings may feel familiar. They are the pythonic parallel to JavaScriptâ€™s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">tagged templates</a>.</p>
<h4 id="how-do-i-work-with-t-strings">How do I work with t-strings?</h4>
<p>To support processing, <code>Template</code>s give developers access to the string and its interpolated values <em>before</em> they are combined into a final string.</p>
<p>The <code>.strings</code> and <code>.values</code> properties of a <code>Template</code> return tuples:</p>
<pre tabindex="0" data-language="python"><code><span><span>name </span><span>=</span><span> &#34;World&#34;</span></span>
<span><span>template </span><span>=</span><span> t</span><span>&#34;Hello </span><span>{name}</span><span>!&#34;</span></span>
<span><span>assert</span><span> template.strings </span><span>==</span><span> (</span><span>&#34;Hello &#34;</span><span>, </span><span>&#34;!&#34;</span><span>)</span></span>
<span><span>assert</span><span> template.values </span><span>==</span><span> (name,)</span></span>
<span></span></code></pre>
<p>There is always one more (possibly empty) string than value. That is, <code>t&#34;&#34;.strings == (&#34;&#34;,)</code> and <code>t&#34;{name}&#34;.strings == (&#34;&#34;, &#34;&#34;)</code>.</p>
<p>As a shortcut, itâ€™s also possible to iterate over a <code>Template</code>:</p>
<pre tabindex="0" data-language="python"><code><span><span>name </span><span>=</span><span> &#34;World&#34;</span></span>
<span><span>template </span><span>=</span><span> t</span><span>&#34;Hello </span><span>{name}</span><span>!&#34;</span></span>
<span><span>contents </span><span>=</span><span> list</span><span>(template)</span></span>
<span><span>assert</span><span> contents[</span><span>0</span><span>] </span><span>==</span><span> &#34;Hello &#34;</span></span>
<span><span>assert</span><span> contents[</span><span>1</span><span>].value </span><span>==</span><span> name</span></span>
<span><span>assert</span><span> contents[</span><span>2</span><span>] </span><span>==</span><span> &#34;!&#34;</span></span>
<span></span></code></pre>
<p>Developers writing complex processing code can also access the gory details of each interpolation:</p>
<pre tabindex="0" data-language="python"><code><span><span>name </span><span>=</span><span> &#34;World&#34;</span></span>
<span><span>template </span><span>=</span><span> t</span><span>&#34;Hello </span><span>{name</span><span>!s:&gt;8</span><span>}</span><span>!&#34;</span></span>
<span><span>assert</span><span> template.interpolations[</span><span>0</span><span>].value </span><span>==</span><span> name</span></span>
<span><span>assert</span><span> template.interpolations[</span><span>0</span><span>].expression </span><span>==</span><span> &#34;name&#34;</span></span>
<span><span>assert</span><span> template.interpolations[</span><span>0</span><span>].conversion </span><span>==</span><span> &#34;s&#34;</span></span>
<span><span>assert</span><span> template.interpolations[</span><span>0</span><span>].format_spec </span><span>==</span><span> &#34;&gt;8&#34;</span></span>
<span></span></code></pre>
<p>In addition to supporting the literal (<code>t&#34;foo&#34;</code>) form, <code>Template</code>s can also be instantiated directly:</p>
<pre tabindex="0" data-language="python"><code><span><span>from</span><span> string.templatelib </span><span>import</span><span> Template, Interpolation</span></span>
<span><span>template </span><span>=</span><span> Template(</span></span>
<span><span>	&#34;Hello &#34;</span><span>,</span></span>
<span><span>	Interpolation(</span><span>value</span><span>=</span><span>&#34;World&#34;</span><span>, </span><span>expression</span><span>=</span><span>&#34;name&#34;</span><span>),</span></span>
<span><span>	&#34;!&#34;</span></span>
<span><span>)</span></span>
<span></span></code></pre>
<p>Strings and interpolations can be provided to the <code>Template</code> constructor in any order.</p>
<h4 id="a-simple-t-string-example">A simple t-string example</h4>
<p>Letâ€™s say we wanted to write code to convert all substituted words into pig latin. All it takes is a simple function:</p>
<pre tabindex="0" data-language="python"><code><span><span>def</span><span> pig_latin</span><span>(template: Template) -&gt; </span><span>str</span><span>:</span></span>
<span><span>	&#34;&#34;&#34;Convert a Template to pig latin.&#34;&#34;&#34;</span></span>
<span><span>	result </span><span>=</span><span> []</span></span>
<span><span>	for</span><span> item </span><span>in</span><span> template:</span></span>
<span><span>		if</span><span> isinstance</span><span>(item, </span><span>str</span><span>):</span></span>
<span><span>			result.append(item)</span></span>
<span><span>		else</span><span>:</span></span>
<span><span>			word </span><span>=</span><span> item.value</span></span>
<span><span>			if</span><span> word </span><span>and</span><span> word[</span><span>0</span><span>] </span><span>in</span><span> &#34;aeiou&#34;</span><span>:</span></span>
<span><span>				result.append(word </span><span>+</span><span> &#34;yay&#34;</span><span>)</span></span>
<span><span>			else</span><span>:</span></span>
<span><span>				result.append(word[</span><span>1</span><span>:] </span><span>+</span><span> word[</span><span>0</span><span>] </span><span>+</span><span> &#34;ay&#34;</span><span>)</span></span>
<span><span>	return</span><span> &#34;&#34;</span><span>.join(result)</span></span>
<span></span>
<span><span>name </span><span>=</span><span> &#34;world&#34;</span></span>
<span><span>template </span><span>=</span><span> t</span><span>&#34;Hello </span><span>{name}</span><span>!&#34;</span></span>
<span><span>assert</span><span> pig_latin(template) </span><span>==</span><span> &#34;Hello orldway!&#34;</span></span>
<span></span></code></pre>
<p>This is a goofy example; if youâ€™d like to see some <em>less</em> silly examples, check out the <a href="https://github.com/davepeck/pep750-examples/">PEP 750 examples repository</a>.</p>
<h4 id="whats-next-once-t-strings-ship">Whatâ€™s next once t-strings ship?</h4>
<p>T-strings are a powerful new feature that will make Python string processing safer and more flexible. I hope to see them used in all sorts of libraries and frameworks, especially those that deal with user input.</p>
<p>In addition, I hope that the tooling ecosystem will adapt to support t-strings. For instance, Iâ€™d love to see <code>black</code> and <code>ruff</code> format t-string <em>contents</em>, and <code>vscode</code> <em>color</em> those contents, if theyâ€™re a common type like HTML or SQL.</p>
<p>Itâ€™s been fun to get to know and work with <a href="https://github.com/jimbaker">Jim</a>, <a href="https://github.com/pauleveritt">Paul</a>, <a href="https://github.com/koxudaxi">Koudai</a>, <a href="https://github.com/lysnikolaou">Lysandros</a>, and <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum">Guido</a> on this project and to interact with <a href="https://discuss.python.org/t/pep750-template-strings-new-updates/71594">many more members of the Python community</a> online without whose input PEP 750 simply wouldnâ€™t have come together. I canâ€™t wait to see what developers build with t-strings once they ship!</p> </div></div>
  </body>
</html>
