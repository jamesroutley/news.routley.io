<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/story.md">Original</a>
    <h1>Making my first robot as a software engineer</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text"><p dir="auto">I recently made this a vision-controlled pen plotter:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/demo.gif"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/demo.gif" alt="demo" width="800" data-animated-image=""/></a></p>
<p dir="auto">People seemed to like it and were asking about it, so I thought I&#39;d write about it here!</p>

<p dir="auto">I recently started working as a computer vision software engineer at a <a href="https://www.monumental.co/" rel="nofollow">robotics company</a>.</p>
<p dir="auto">This is my first time working in the robotics industry, and I&#39;ve been thoroughly enjoying it.
I&#39;ve found it to be insanely satisfying to write code that translates into real-world, physical machines completing tasks intelligently.</p>
<p dir="auto">Of course, this is facilitated by physical machines - hardware. Motors, electronics, springs, power converters, 3D printed creative designs, and all kinds of stuff I have never worked with before. Absolutely fascinating.</p>
<p dir="auto">So, I decided I&#39;d take a stab at this hardware stuff in my free time.</p>
<p dir="auto">The project I decided to go with was building a robotic pen plotter.</p>
<p dir="auto">Ok, so I want to make a pen plotter. The rough idea in my head was that I&#39;d make a robotic arm with two rotating joints, like a double pendulum:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/first_sketch.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/first_sketch.jpg" alt="sketch" width="500"/></a></p>
<p dir="auto">How to get started?</p>
<p dir="auto">Well, as a starter, it&#39;s going to need motors.</p>
<p dir="auto">Turns out, not all motors are made equal.</p>
<p dir="auto">The three main options are:</p>
<ul dir="auto">
<li>DC motors - On an interface level, these motors just spin at a speed approximately linearly correlated to the amount of current you feed them.</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/dc_motor.jpeg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/dc_motor.jpeg" alt="dc_motor" width="500"/></a></p>
<ul dir="auto">
<li>Servo motors - You can command these motors to turn the shaft to a certain angle relatively precisely.</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/servo_motor.webp"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/servo_motor.webp" alt="servo_motor" width="500"/></a></p>
<ul dir="auto">
<li>Stepper motors - These motors divide each rotation of the shaft into a number of steps. Then you can tell the motor to turn the shaft an exact number of steps, and it will.</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/stepper.webp"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/stepper.webp" alt="stepper_motor" width="500"/></a></p>
<p dir="auto">I asked around at work, and turns out they had a couple of stepper motors that I could have for the project!
Stepper motors should be a fine fit because I should be able to get the motor to move <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$x$</math-renderer> degrees by figuring out how many steps add up to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$x$</math-renderer>.</p>
<p dir="auto">The specific motors that I now had in my hands were two of these Nema 17 stepper motors:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/big_nema_17.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/big_nema_17.jpg" alt="big_nema" width="500"/></a></p>
<p dir="auto">Awesome, I got motors!</p>
<p dir="auto">Next step must be to sketch up a basic design of the arm that works with these motors.
Of course, the arm cannot rest on the table.
It has to be connected to some kind of base which is then attached to some flat surface.
I decided it should look something like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_sketch.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_sketch.jpg" alt="base_sketch" width="500"/></a></p>
<p dir="auto">Great! Now I need to make this design a little more precise, and somehow bring it into the physical world.</p>
<p dir="auto">At work, a lot of components are 3D printed.
I thought &#34;Ok, let&#39;s make this a real hobby, and buy a 3D printer&#34;!
So I asked around, and my coworker recommended the BambuLab A1, so I ordered one!</p>
<p dir="auto">While I was waiting for it to be delivered, I could work on actually making the design that I was going to print with it.
I was going to need to use Computer-Aided Design, CAD for short - something I had no experience with whatsoever.</p>
<p dir="auto">Again, I asked around and my coworker recommended I use <a href="https://www.onshape.com/en/" rel="nofollow">Onshape</a>, a web-based CAD program that you can use for free, given that you don&#39;t mind your designs being public for the world to see.</p>
<p dir="auto">So, I went ahead and started to play around with it. Of course, I ventured to the YouTube tutorials and followed along.
Designing components in CAD felt quite natural - it had that problem-solving flow I am so used to in programming.
After fiddling around for a while and iterating the design, I got a basic design going for the base of my robot!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_top.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_top.png" alt="base_bottom" width="500"/></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_bottom.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_bottom.png" alt="base_sketch" width="500"/></a></p>
<p dir="auto">The idea was that the motor would go into the base, and be hidden from view.
It would be screwed into the bottom, and the shaft would pop out from the top, ready to control the arm.
I also added an opening for wires, and some screw holes so I could screw the base onto some kind of flat surface on which the plotter would draw.</p>
<p dir="auto">Around this time, my 3D printer arrived! I assembled it - what a beauty!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/printer.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/printer.jpg" alt="printer" width="500"/></a></p>
<p dir="auto">How on earth do I use this thing?
Turns out I need something called a &#34;slicer&#34; to get my model ready for printing.
I look up which slicer I should use, and it turns out BambuLab had one of their own - Bambu studio!
I exported my part from Onshape, and loaded it into the slicer:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_slicer.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_slicer.png" alt="base_in_slicer" width="500"/></a></p>
<p dir="auto">Turns out you can&#39;t print this part without using support structures - I turned them on, and just pressed print.
Apparently, 3D printing has come a long way, and the print went perfectly! Sadly, I did not take a photo of the freshly printed part, but I promise you&#39;ll see it a bit further down. I screwed the motor into place, and it fit perfectly! But of course, that was by design.</p>
<p dir="auto">Now for the arms. At work, my colleagues advised me to use aluminum extrusions for the arms - these things:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/aluminum_extrusion.jpeg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/aluminum_extrusion.jpeg" alt="aluminum_extrusion" width="500"/></a></p>
<p dir="auto">Apparently, these are super useful when prototyping.
They cut two 15cm pieces of these things for me.</p>
<p dir="auto">I decided the next step was then to make a part that would fasten onto the motor shaft, and have a connector for the first aluminum extrusion - that would be the upper arm!
The rough idea was something like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_connector.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_connector.jpg" alt="base_connector" width="500"/></a></p>
<p dir="auto">Time to put on my CAD hat and design it! This was the outcome:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_connector_cad.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_connector_cad.png" alt="base_connector_cad_top" width="500"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_connector_bottom.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_connector_bottom.png" alt="base_connector_cad_top" width="500"/></a></p>
<p dir="auto">I printed this bad boy and assembled the parts - looks good!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/base_connector_assembled.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/base_connector_assembled.jpg" alt="base_connector_assembled" width="500"/></a></p>
<p dir="auto">Now it&#39;s time to get this motor moving. This is a part I had a lot of trouble with!</p>
<p dir="auto">First, the motors need electricity to move - specifically 12V. I don&#39;t have a power supply for that! So, I asked around at work, and my colleague just found a random power adapter that read 12V, cut the connector off it, stripped the wires, put some clips onto it, and handed it to me. It looked like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/power_supply.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/power_supply.jpg" alt="power_supply" width="500"/></a></p>
<p dir="auto">Apparently I could just connect this directly to the power terminals of the motor. I didn&#39;t know you could do that! But if it works, it works.</p>
<p dir="auto">Now that we have power, we need to actually interface with the motor and control it. Along with the motors, my colleague gave me motor drivers. Or motor controllers, not sure which one this is. Either way, it looks like this, screwed onto the motor:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/mks_servo_42c.avif"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/mks_servo_42c.avif" alt="servo42c" width="500"/></a></p>
<p dir="auto">I had no idea how to use this thing, so I found some tutorials, and looked at the documentation.
This thing apparently reads the shaft position using a magnet that is glued onto the bottom of the shaft, between the driver and the motor.
It has a PID controller (something that should be able to control the motor smoothly using the feedback of the magnet sensor), and should have a friendly interface for moving the shaft to specific positions smoothly.</p>
<p dir="auto">So, the first step was to glue the magnet onto the shaft. Of course that went terribly, as I did not have any pliers or other handy tools available - I even destroyed one of the motors by letting glue into its mechanism.</p>
<p dir="auto">After gluing the magnet onto the shaft, you need to use the little screen to tell the motor to calibrate:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/calibrate.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/calibrate.png" alt="calibrate" width="500"/></a></p>
<p dir="auto">During calibration, the shaft should rotate slowly. Mine didn&#39;t - it just jerked back and forth. Then it threw an error at me: &#34;Reverse lookup error!&#34;. Damn.</p>
<p dir="auto">I looked online, and found this in the documentation:</p>
<div data-snippet-clipboard-copy-content="* err4“Phase Line Error！”

  if it keeps show “Phase Line Error”,please adjust the 4pin motor cable wiring sequence."><pre><code>* err4“Phase Line Error！”

  if it keeps show “Phase Line Error”,please adjust the 4pin motor cable wiring sequence.
</code></pre></div>
<p dir="auto">See that little connector cable on the left in the image of the driver? Turns out I needed to reverse the connections of the two middle wires. Took me quite a while to figure out.</p>
<p dir="auto">Ok, I&#39;ve swapped the wires, let&#39;s calibrate! I connect the motor to the power supply, press &#34;Cal&#34;, and the shaft rotates!
After about a minute, ...it still gave me the same error -_-.</p>
<p dir="auto">I went into &#34;screw with it until it works&#34; mode. I took it apart, re-applied the magnet, swapped wires around, did all kinds of stuff.
After a while of this, the error finally went away! No idea why though.</p>
<p dir="auto">But I finally got it assembled, powered up, and calibrated! Of course, the next step is then to try to control it.
Looking at the documentation, there are three ways the motor can operate:</p>
<ul dir="auto">
<li><code>CR_OPEN</code>: Means open-loop mode - in this mode, the magnet sensor and PID controller are not used - you just tell the motor to move a certain number of steps and hope for the best.</li>
<li><code>CR_vFOC</code>: In this mode, you still tell the motor to move a certain number of steps, but the driver uses the PID controller to make sure the motor moves smoothly and ends up where you want it to.</li>
<li><code>CR_UART</code>: This is Serial mode - you use a binary communication protocol to send all kinds of commands to the motor, like &#34;move to this position at this speed&#34;, or you can ask it about the motor shaft position.</li>
</ul>
<p dir="auto">Of course, Serial mode sounds the best - I only have to supply high-level commands and the motor does what I want to!</p>
<p dir="auto">But there&#39;s a problem. The Arduino Uno, the microcontroller I had, only had one serial interface, and I was using that for communication with my laptop - it&#39;s the interface you use to flash your programs onto the microcontroller, and communicate with it while it runs its program. Damn!</p>
<p dir="auto">I told my colleague about this, and he provided me with an ESP32 development board:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/esp32.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/esp32.jpg" alt="esp32" width="500"/></a></p>
<p dir="auto">Apparently, this thing has not one, but three serial ports - great!</p>
<p dir="auto">I figure out which pins on the board correspond to a serial interface, and wire it up to my motor.</p>
<p dir="auto">Of course, some software is required to communicate with the motor over the serial interface. I go ahead and download an Arduino library for usage with the motor driver (<a href="https://docs.arduino.cc/libraries/mks_servo42/" rel="nofollow">link</a>), and fire up a test program. It worked! I could control the motor shaft in my firmware!</p>
<p dir="auto">At this point I was super happy. I just need to design the elbow and upper arm, and I should have a two-jointed arm I can control!</p>
<p dir="auto">So, I start dreaming up designs for how the elbow will work. How do I put a stepper motor into the elbow to drive the forearm?</p>
<p dir="auto">I know! I&#39;ll attach a little seat to the lower arm with a hole in the bottom for the shaft - then I can put the motor shaft-down into the seat, and attach the forearm under the seat!
This is sort of what I had in mind:</p>
<p dir="auto">I put on my CAD hat again and design both the seat and the forearm attachment. The prints came out like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/elbow_forearm.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/elbow_forearm.jpg" alt="elbow_forearm" width="500"/></a></p>
<p dir="auto">Looking pretty good! Let&#39;s get the second motor working and assemble!</p>
<p dir="auto">I install the driver onto the second motor. This went better than the other one as I had learned a few lessons, but I still had to do a bit of magic fiddling I still don&#39;t understand.</p>
<p dir="auto">Of course, I want to know that I can also control the second motor before assembling the whole thing. I connect it to my ESP32, and ... it doesn&#39;t work. No matter what I do, the library just prints &#34;Invalid response from motor driver&#34;. Damn.</p>
<p dir="auto">I spend a lot of time debugging this. Some things I thought were wrong were:</p>
<ul dir="auto">
<li>The motor driver was broken</li>
<li>The power supply was not connected to the microcontroller&#39;s ground, which I don&#39;t understand the consequences of.</li>
<li>The serial interface pins were sharing the same interface with the one I was using to communicate with my laptop.</li>
</ul>
<p dir="auto">However, none of these issues were present with the first motor.</p>
<p dir="auto">Eventually (with a lot of debugging), I figure out that the drivers on the motors had different firmware versions installed - the base motor has version V1.1, but the elbow motor has version V1.0! The serial interface protocol was changed between the versions, and the library is configured to use V1.1. No wonder that the elbow motor was not working.</p>
<p dir="auto">What I did to solve this was to patch the library to be compatible with both versions - with my modified version, you just need to specify the firmware version your driver is using.</p>
<p dir="auto">Now I can finally control both motors, so let&#39;s assemble the thing! This is the result:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/v1_assembled.png"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/v1_assembled.png" alt="v1_assembled" width="500"/></a></p>
<p dir="auto">Amazing! I whipped up a simple program that would move both motors a bit back and forth, and it did - the arm moved back and forth!</p>
<p dir="auto">As you see in the picture, I am holding the base - this is because at this point, I hadn&#39;t found a plate to attach the base to. The initial idea was that I&#39;d figure out some flat surface that I&#39;d simply screw the base to. But now I needed to find a plate. I asked around at work, and they had nothing to spare that worked.</p>
<p dir="auto">So, I looked around at home - we had just moved into a place in Amsterdam, and the previous tenant left some random stuff in the apartment - maybe they left something I could use as a base plate? Yes! In the storage room, there was a stack of some kind of glass-plastic plates, about 70cmx50cm. That should work!</p>
<p dir="auto">However, I could not drill holes into the thing - I don&#39;t have a drill, nor do I know whether the plate would actually handle it. There must be another solution to stick the base onto the plate.</p>
<p dir="auto">Of course! I could make these things called &#34;snap rivets&#34;. What I designed looks like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/snap_rivets.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/snap_rivets.jpg" alt="snap_rivets" width="500"/></a></p>
<p dir="auto">I&#39;d glue four of these to the plate, and the base would just snap stuck onto them! Great, right? Not really - they work, but they were constantly breaking when I wanted to remove the base to access the motor! When that happened, I couldn&#39;t get the rest of the rivet off as I had superglued them onto the plate! At the end of the project, the base looks like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/broken_snap_rivets.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/broken_snap_rivets.jpg" alt="broken_snap_rivets" width="500"/></a></p>
<p dir="auto">Screw it, it works.</p>
<p dir="auto">The next step was to see if I could do a little more than move the motors randomly - was it stable? Could I control it precisely? Nope. It moved super janky, wiggling back and forth a lot.</p>
<p dir="auto">I conjectured that the motor on the elbow was way too heavy, putting a lot of leveraged force on the base shaft. I asked around at work, and they had a &#34;pancake&#34; version of the Nema 17 motor on hand:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/pancake_nema_17.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/pancake_nema_17.jpg" alt="pancake" width="500"/></a></p>
<p dir="auto">This one was much lighter, so it should be a better choice. I swapped the motor driver onto it, and redesigned the elbow connector for the smaller motor.</p>
<p dir="auto">I assembled the updated design, and again told the motors to do some stuff. But they were still super wobbly! Turns out it couldn&#39;t have been because of the weight because the forearm was also moving wobbly, and there was no real weight on it. Sometimes the motors would even start spinning uncontrollably, messing everything up around them!</p>
<p dir="auto">After a bunch of screwing around with the motors and their settings, I figured that the PID controller in the driver was just not working correctly.</p>
<p dir="auto">Why do I even need a PID controller? Can&#39;t I just use the open interface and tell the motor how many steps I want it to go?</p>
<p dir="auto">I rewired the design for the open interface, modified the software, and BAM it worked - the arm was moving pretty smooth. Screw this closed-loop PID bullshit.</p>
<p dir="auto">So, now I had an arm with two rotational joints that I could control pretty precisely. What next?</p>
<p dir="auto">Let&#39;s make the end-effector - the attachment for the pen!</p>
<p dir="auto">I tried to think ahead - if I just put stick the pen onto the end of the arm, the plate needs to be super flat, and the arm absolutely straight - otherwise the pen will press too hard on the plate in some areas, and maybe even lift off the plate in some areas. So let&#39;s make it spring-mounted!</p>
<p dir="auto">I don&#39;t have any springs - what about trying to make a 3D printed design that works like a spring?
I ended up with this design:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/spring_mount.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/spring_mount.jpg" alt="spring_mount" width="500"/></a></p>
<p dir="auto">Pretty cool, right? The thin pieces press against the circle, and push it down. We can then attach the pen to the mount, and we have a spring-mounted pen attachment!</p>
<p dir="auto">To attach a pen, I made these holes in the side to use zip-ties to attach a pen:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/ziptie_mount.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/ziptie_mount.jpg" alt="ziptie_mount" width="500"/></a></p>
<p dir="auto">Don&#39;t mind the tattered-up pen - I&#39;ve put it on and removed it a couple of times. But this way, I could adjust and swap out pens of different shapes and sizes (at the cost of destroying some zip-ties).</p>
<p dir="auto">I attached this onto the end of the forearm, and I finally had a pen plotter! Well, only the hardware though. There was no good way for me to tell it what to draw, and how to do it. It&#39;s software time!</p>
<p dir="auto">If we want to be able to draw anything, we need to understand the relationship between the location of the pen, and the angle of the motors. That is, we need to work out the <em>kinematics</em> of the robot. Be warned, this is going to require some mathematics!</p>
<p dir="auto">Let&#39;s say the center of rotation is the origin, and create a coordinate system:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/kinematics_1.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/kinematics_1.jpg" alt="robot_in_coordinate_system" width="500"/></a></p>
<p dir="auto">Of course, we don&#39;t need such a detailed drawing of the robot in our model - let&#39;s reduce it down to a sick model:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/kinematics_noodle.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/kinematics_noodle.jpg" alt="kinematics_noodle" width="500"/></a></p>
<p dir="auto">So we need to know where the end of the forearm (the pen) is in the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$x$</math-renderer>-$y$ plane, based on the angles of the motors.</p>
<p dir="auto">A common method to do this is to place coordinate systems called <em>reference frames</em> on each of the joints:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/reference_frames.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/reference_frames.jpg" alt="reference_frames" width="500"/></a></p>
<p dir="auto">Here I&#39;ve marked three frames. First, we have the <em>base frame</em> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$B$</math-renderer> as the frame of the base motor - it is the same as our <em>world frame</em>, our main coordinate system. Next, there is the <em>elbow frame</em> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer> as the frame of the elbow motor. Finally, we have the <em>pen frame</em>, which is centered at the pen.</p>
<p dir="auto">Let&#39;s also add the motor angles and the arm lengths into the picture:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/angles_and_lengths.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/angles_and_lengths.jpg" alt="angles_and_lengths" width="500"/></a></p>
<p dir="auto">The next step here is to figure out how we go from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$B$</math-renderer> to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer>, and from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer> to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$P$</math-renderer>. This involves a bit of linear algebra, but the gist is that to get from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$B$</math-renderer> to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer>, we can first rotate the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$B$</math-renderer> frame by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\theta_1$</math-renderer>, and then move it by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$l_1$</math-renderer> along its (new) <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$x$</math-renderer>-axis. Similarly, we can get from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer> to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$P$</math-renderer> by rotating <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer> by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\theta_2$</math-renderer>, and moving <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$l_2$</math-renderer> along the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$x$</math-renderer>-axis of the updated <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$E$</math-renderer> frame.</p>
<p dir="auto">Working through the math, the final result is that the pen location <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$p$</math-renderer>, the center of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$P$</math-renderer>, is
$$
p = \begin{bmatrix}
l_1 \cos(\theta_1) \sin(\theta_2) - l_1 \sin(\theta_1) \sin(\theta_1) + l_2 \cos(\theta_1)\
l_1 \sin(\theta_1) \cos(\theta_2) + l_1 \cos(\theta_1) \sin(\theta_1) + l_2 \sin(\theta_1)\
\end{bmatrix}
$$</p>
<p dir="auto">A bit of a mouthful, but we have it!</p>
<p dir="auto">Now I can pick a value for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\theta_1$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\theta_2$</math-renderer>, and know where the robot will end up! The values of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\theta_1$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\theta_2$</math-renderer>, concatenated into a vector <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$\boldsymbol{\theta}$</math-renderer> is called the <em>configuration</em> of the robot, and the function from the configuration to the position of the pen is called the <em>forward kinematics</em>.</p>
<p dir="auto">Here is an implementation of the forward kinematics in a python function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="def forward_kinematics(configuration: np.ndarray, l1: float, l2: float) -&gt; np.ndarray:
    theta_1, theta_2 = configuration

    return np.array(
        [
            L1 * np.cos(theta) * np.cos(phi) - L1 * np.sin(theta) * np.sin(phi) + L2 * np.cos(theta),
            L1 * np.sin(theta) * np.cos(phi) + L1 * np.cos(theta) * np.sin(phi) + L2 * np.sin(theta),
        ]
    )"><pre><span>def</span> <span>forward_kinematics</span>(<span>configuration</span>: <span>np</span>.<span>ndarray</span>, <span>l1</span>: <span>float</span>, <span>l2</span>: <span>float</span>) <span>-&gt;</span> <span>np</span>.<span>ndarray</span>:
    <span>theta_1</span>, <span>theta_2</span> <span>=</span> <span>configuration</span>

    <span>return</span> <span>np</span>.<span>array</span>(
        [
            <span>L1</span> <span>*</span> <span>np</span>.<span>cos</span>(<span>theta</span>) <span>*</span> <span>np</span>.<span>cos</span>(<span>phi</span>) <span>-</span> <span>L1</span> <span>*</span> <span>np</span>.<span>sin</span>(<span>theta</span>) <span>*</span> <span>np</span>.<span>sin</span>(<span>phi</span>) <span>+</span> <span>L2</span> <span>*</span> <span>np</span>.<span>cos</span>(<span>theta</span>),
            <span>L1</span> <span>*</span> <span>np</span>.<span>sin</span>(<span>theta</span>) <span>*</span> <span>np</span>.<span>cos</span>(<span>phi</span>) <span>+</span> <span>L1</span> <span>*</span> <span>np</span>.<span>cos</span>(<span>theta</span>) <span>*</span> <span>np</span>.<span>sin</span>(<span>phi</span>) <span>+</span> <span>L2</span> <span>*</span> <span>np</span>.<span>sin</span>(<span>theta</span>),
        ]
    )</pre></div>
<p dir="auto">This is not too useful on its own - I don&#39;t want to go from angles to locations, I want to input a pen location, and get a configuration that puts the pen in the correct place! This is called the <em>inverse kinematics</em>.</p>
<p dir="auto">I think the simplest way to do this is to use optimization. I&#39;ll define a cost function that accepts a configuration and a target location, and spits out how far the pen is from the target location:</p>
<div dir="auto" data-snippet-clipboard-copy-content="def objective(configuration: np.ndarray, target: np.ndarray, l1: float, l2: float) -&gt; float:
    pen_location = forward_kinematics(configuration, l1, l2)
    return np.linalg.norm(pen_location - target)"><pre><span>def</span> <span>objective</span>(<span>configuration</span>: <span>np</span>.<span>ndarray</span>, <span>target</span>: <span>np</span>.<span>ndarray</span>, <span>l1</span>: <span>float</span>, <span>l2</span>: <span>float</span>) <span>-&gt;</span> <span>float</span>:
    <span>pen_location</span> <span>=</span> <span>forward_kinematics</span>(<span>configuration</span>, <span>l1</span>, <span>l2</span>)
    <span>return</span> <span>np</span>.<span>linalg</span>.<span>norm</span>(<span>pen_location</span> <span>-</span> <span>target</span>)</pre></div>
<p dir="auto">Then I just use <code>scipy.optimize</code> to optimize this objecctive!</p>
<div dir="auto" data-snippet-clipboard-copy-content="def inverse_kinematics(target: np.ndarray, l1: float, l2: float) -&gt; np.ndarray:
    result = minimize(
        objective,
        np.array([0, 0]),  # dumb initial guess
        args=(target, l1, l2),
        method=&#34;SLSQP&#34;,
        bounds=[(-np.pi / 2, np.pi / 2), (-3 * np.pi / 4, 3 * np.pi / 4)],  # Joint limits
    )

    return result.x "><pre><span>def</span> <span>inverse_kinematics</span>(<span>target</span>: <span>np</span>.<span>ndarray</span>, <span>l1</span>: <span>float</span>, <span>l2</span>: <span>float</span>) <span>-&gt;</span> <span>np</span>.<span>ndarray</span>:
    <span>result</span> <span>=</span> <span>minimize</span>(
        <span>objective</span>,
        <span>np</span>.<span>array</span>([<span>0</span>, <span>0</span>]),  <span># dumb initial guess</span>
        <span>args</span><span>=</span>(<span>target</span>, <span>l1</span>, <span>l2</span>),
        <span>method</span><span>=</span><span>&#34;SLSQP&#34;</span>,
        <span>bounds</span><span>=</span>[(<span>-</span><span>np</span>.<span>pi</span> <span>/</span> <span>2</span>, <span>np</span>.<span>pi</span> <span>/</span> <span>2</span>), (<span>-</span><span>3</span> <span>*</span> <span>np</span>.<span>pi</span> <span>/</span> <span>4</span>, <span>3</span> <span>*</span> <span>np</span>.<span>pi</span> <span>/</span> <span>4</span>)],  <span># Joint limits</span>
    )

    <span>return</span> <span>result</span>.<span>x</span> </pre></div>
<p dir="auto">With slight modifications to make sure the robot takes the shortest path to each next point, I could generate some points, and find where the plotter needs to go to draw the points!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/animation.gif"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/animation.gif" alt="draw_animation" width="500" data-animated-image=""/></a></p>
<p dir="auto">I copied the list of configurations into the Arduino code, and it worked!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/heart_drawing.gif"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/heart_drawing.gif" alt="draw_animation" width="500" data-animated-image=""/></a></p>
<p dir="auto">As you can see, I&#39;m drawing on a piece of paper, which is pretty lame. Ideally, the whole plate area would be a whiteboard the plotter could draw on.</p>
<p dir="auto">This was not so complex to solve - I just bought some whiteboard film, and stuck it on the plate:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/whiteboard_film.jpg"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/whiteboard_film.jpg" alt="whiteboard_film" width="500"/></a></p>
<p dir="auto">Now the robot has much more room to draw! I played a lot with the robot in this state, copying and pasting angles into the firmware for the robot to draw.</p>
<p dir="auto">An annoying thing now is that the robot cannot lift the pen. The whole drawing has to be done in one pen stroke. Let&#39;s fix this!
I had a small servo motor on hand, and thought it would be perfect to lift the pen! I redesigned the pen holder to accommodate a servo motor that could lift the pen up - this is the result:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Robertleoj/pen_plotter_robot/blob/main/media/pen_up_down.gif"><img src="https://github.com/Robertleoj/pen_plotter_robot/raw/main/media/pen_up_down.gif" alt="pen_up_down" width="500" data-animated-image=""/></a></p>
<p dir="auto">The mechanism is simple - I put a plate on the stick that the servo pushes up to lift the pen, and releases to put the pen down. This actually did not take me very long, which was a pleasant surprise!</p>
<p dir="auto">As you can also see, I also removed the &#34;spring&#34; mount - turns out the weight of the pen is enough downwards pressure.</p>
<p dir="auto">The only problem here was that the servo required 5V, but I only had 12V from my power supply, and 3.3V from my ESP32. However, the only reason I switched to the ESP32 in the first place was that I needed the extra serial ports that I was not using anymore. So, I switched back to the Arduino, which has a 5V output pin!</p>
<p dir="auto">To be able to draw interesting things, created a communication protocol over serial that I could use to stream some commands to the Arduino from my laptop. <code>PD</code> and <code>PU</code> mean &#34;pen down&#34; and &#34;pen up&#34;, <code>M a b</code> mean &#34;move to configuration <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="dfaf904a79f28708b3ae5dd443145ea1">$[a, b]$</math-renderer>&#34;, and <code>H</code> means &#34;go to home position&#34;, which is straight forward with pen up.</p>
<p dir="auto">Now was the question: what should I tell the plotter to draw? I don&#39;t want to sit here and define a sequence of points by hand, so how can we generate drawings for the robot?</p>
<p dir="auto">I decided it would be cool if I could draw in the air with my fingers, and the robot would actually draw the same drawing on the whiteboard!</p>
<p dir="auto">I can use my webcam to capture my finger air drawings, but I&#39;ll need a way to know where my hands are. For this, we can use an out-of-the box solution: <a href="https://mediapipe.readthedocs.io/en/latest/solutions/hands.html" rel="nofollow">MediaPipe hand detection</a>. To draw, I decided that I&#39;d draw with my right index finger, and indicate when I wanted the pen down by touching my left index finger to my thumb. I also wanted to signify the end of a drawing - touching the fingertips of your index fingers should do.</p>
<p dir="auto">I whipped up a script that implemented this, and voila! We get the result you see at the top of the post!</p>
<p dir="auto">For anyone interested, here is a <a href="https://cad.onshape.com/documents/bdb48f7c4f70c2571c2f3ed1/w/ffb41e5567e0a03980d31e0f/e/92ed5e044ae3405a64fbbf65?renderMode=0&amp;uiState=6758c448b9d28f2f0c499b29" rel="nofollow">link</a> to my CAD design in Onshape.</p>
</article></div></section></div></div></div></div>
  </body>
</html>
