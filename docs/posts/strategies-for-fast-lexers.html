<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xnacly.me/posts/2025/fast-lexer-strategies/">Original</a>
    <h1>Strategies for Fast Lexers</h1>
    
    <div id="readability-page-1" class="page"><div><p>In this blog post I’ll explain strategies I used to make the purple garden
lexer really fast.</p><blockquote><p><a href="https://github.com/xNaCly/purple-garden">purple-garden</a> is an s-expr based
language I am currently developing for myself. Its my attempt at building a
language I like, with a battery included approach, while designing it with
performance in mind.</p></blockquote><p>This doesn’t mean all approaches are feasible for your use case, architecture
and design. I tried to bring receipts for my performance claims, so
watch out for these blocks at the end of chapters:</p><p id="callout"><h3>Info - Benchmark</h3></p><p>A lexer (often also referred to as a tokeniser) is the easiest part of any compilation and
language pipeline. The idea is to convert a list of characters into a list of
tokens in which each token conveys some meaning. This list of tokens can then
be used by the parser to generate an abstract syntax tree (AST), which the
compiler consumes, converting it to bytecode, which the vm executes.</p><h2 id="a-compilation-pipeline">A compilation pipeline</h2><p>As an overview:</p><pre tabindex="0"><code>┌───────────────────┐
│                   │
│       Lexer       │ &lt;- we are here
│                   │
└─────────┬─────────┘
          │
          │ Tokens &lt;- and here
          │
┌─────────▼─────────┐
│                   │
│       Parser      │
│                   │
└─────────┬─────────┘
          │
          │ AST
          │
┌─────────▼─────────┐
│                   │
│      Compiler     │
│                   │
└─────────┬─────────┘
          │
          │ Bytecode
          │
┌─────────▼─────────┐
│                   │
│  Virtual Machine  │
│                   │
└───────────────────┘</code></pre><p>For a list of characters, lets say <code>(@std.fmt.println &#34;my pi is: &#34; 3.1415)</code>:</p><ol><li><p>Input to the lexer:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>(@std.fmt.println &#34;my pi is: &#34; 3.1415)</span></span></code></pre></div></li><li><p>As characters:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>(
</span></span><span><span> 2</span><span>@
</span></span><span><span> 3</span><span>s
</span></span><span><span> 4</span><span>t
</span></span><span><span> 5</span><span>d
</span></span><span><span> 6</span><span>.
</span></span><span><span> 7</span><span>f
</span></span><span><span> 8</span><span>m
</span></span><span><span> 9</span><span>t
</span></span><span><span>10</span><span>// ....
</span></span><span><span>11</span><span>)</span></span></code></pre></div></li><li><p>As pseudo tokens:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>(
</span></span><span><span>2</span><span>@std
</span></span><span><span>3</span><span>.
</span></span><span><span>4</span><span>fmt
</span></span><span><span>5</span><span>.
</span></span><span><span>6</span><span>println
</span></span><span><span>7</span><span>&#34;my pi is: &#34;
</span></span><span><span>8</span><span>3.1415
</span></span><span><span>9</span><span>)</span></span></code></pre></div></li></ol><p>The above is just an example and I’ll go into detail below:</p><h2 id="defining-purple-gardens-tokens">Defining purple garden’s Tokens</h2><p>A token is not only a set characters it can be mapped to, but it also holds:</p><ul><li>A token type, to easily distinguish between tokens</li><li>Positional information:<ul><li>start point</li><li>end or length</li><li>line number</li></ul></li></ul><p>Purple garden keeps it as minimal as possible and just has a String and a token type:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>typedef</span> <span>enum</span> {
</span></span><span><span> 2</span><span>  <span>// (
</span></span></span><span><span> 3</span><span><span></span>  T_DELIMITOR_LEFT <span>=</span> <span>1</span>,
</span></span><span><span> 4</span><span>  <span>// +
</span></span></span><span><span> 5</span><span><span></span>  T_PLUS <span>=</span> <span>2</span>,
</span></span><span><span> 6</span><span>  <span>// -
</span></span></span><span><span> 7</span><span><span></span>  T_MINUS <span>=</span> <span>3</span>,
</span></span><span><span> 8</span><span>  <span>// *
</span></span></span><span><span> 9</span><span><span></span>  T_ASTERISKS <span>=</span> <span>4</span>,
</span></span><span><span>10</span><span>  <span>// /
</span></span></span><span><span>11</span><span><span></span>  T_SLASH <span>=</span> <span>5</span>,
</span></span><span><span>12</span><span>  <span>// =
</span></span></span><span><span>13</span><span><span></span>  T_EQUAL <span>=</span> <span>6</span>,
</span></span><span><span>14</span><span>  <span>// )
</span></span></span><span><span>15</span><span><span></span>  T_DELIMITOR_RIGHT,
</span></span><span><span>16</span><span>  <span>// [
</span></span></span><span><span>17</span><span><span></span>  T_BRAKET_LEFT,
</span></span><span><span>18</span><span>  <span>// ]
</span></span></span><span><span>19</span><span><span></span>  T_BRAKET_RIGHT,
</span></span><span><span>20</span><span>  <span>// anything between &#34;&#34;
</span></span></span><span><span>21</span><span><span></span>  T_STRING,
</span></span><span><span>22</span><span>  <span>// true
</span></span></span><span><span>23</span><span><span></span>  T_TRUE,
</span></span><span><span>24</span><span>  <span>// false
</span></span></span><span><span>25</span><span><span></span>  T_FALSE,
</span></span><span><span>26</span><span>  <span>// floating point numbers
</span></span></span><span><span>27</span><span><span></span>  T_DOUBLE,
</span></span><span><span>28</span><span>  <span>// whole numbers
</span></span></span><span><span>29</span><span><span></span>  T_INTEGER,
</span></span><span><span>30</span><span>  <span>// builtins in the format @&lt;builtin&gt;
</span></span></span><span><span>31</span><span><span></span>  T_BUILTIN,
</span></span><span><span>32</span><span>  <span>// any identifier
</span></span></span><span><span>33</span><span><span></span>  T_IDENT,
</span></span><span><span>34</span><span>  <span>// end marker
</span></span></span><span><span>35</span><span><span></span>  T_EOF,
</span></span><span><span>36</span><span>} TokenType;
</span></span><span><span>37</span><span>
</span></span><span><span>38</span><span><span>typedef</span> <span>struct</span> {
</span></span><span><span>39</span><span>  TokenType type;
</span></span><span><span>40</span><span>  <span>// stores all values for T_STRING,T_IDENT,T_INTEGER and T_DOUBLE
</span></span></span><span><span>41</span><span><span></span>  Str string;
</span></span><span><span>42</span><span>} Token;</span></span></code></pre></div><h2 id="architecting-a-minimal-lexer">Architecting a minimal Lexer</h2><p>As explained in <a href="#a-compilation-pipeline">A compilation pipeline</a>, the lexer
iterates over the characters in the input and attempts to match found
characters to sets of characters, like keywords, numbers and symbols. For this
we will need to keep some state, even if though its not much:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>typedef</span> <span>struct</span> {
</span></span><span><span>2</span><span>  Str input; <span>// &lt;- String view over the input
</span></span></span><span><span>3</span><span><span></span>  <span>size_t</span> pos; <span>// &lt;- current position in the input
</span></span></span><span><span>4</span><span><span></span>} Lexer;</span></span></code></pre></div><blockquote><p><code>Str</code> as an abstraction is introduced in <a href="#operating-on-zero-copy-zero-alloc-string-windows">Operating on zero copy, zero alloc string windows</a>.</p></blockquote><p>A naive approach would be:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>#define SINGLE_TOK(t) ((Token){.type = t})
</span></span></span><span><span> 2</span><span><span></span>
</span></span><span><span> 3</span><span>Lexer <span>Lexer_new</span>(Str str) {
</span></span><span><span> 4</span><span>    <span>return</span> {
</span></span><span><span> 5</span><span>        .input<span>=</span>str,
</span></span><span><span> 6</span><span>        .pos<span>=</span><span>0</span>
</span></span><span><span> 7</span><span>    };
</span></span><span><span> 8</span><span>}
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span>Token <span>Lexer_next</span>(Lexer <span>*</span>l) {
</span></span><span><span>11</span><span>    <span>if</span> (l<span>-&gt;</span>input.len <span>==</span> <span>0</span> <span>||</span> l<span>-&gt;</span>pos <span>&gt;=</span> l<span>-&gt;</span>input.len) {
</span></span><span><span>12</span><span>        <span>return</span> <span>SINGLE_TOK</span>(T_EOF)
</span></span><span><span>13</span><span>    }
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>    Token t;
</span></span><span><span>16</span><span>    <span>switch</span>(<span>Str_get</span>(l<span>-&gt;</span>input, l<span>-&gt;</span>pos)) {
</span></span><span><span>17</span><span>        <span>case</span> <span>&#39;+&#39;</span><span>:</span>
</span></span><span><span>18</span><span>            t <span>=</span> <span>SINGLE_TOK</span>(T_PLUS);
</span></span><span><span>19</span><span>            <span>break</span>;
</span></span><span><span>20</span><span>        <span>case</span> <span>&#39;-&#39;</span><span>:</span>
</span></span><span><span>21</span><span>            t <span>=</span> <span>SINGLE_TOK</span>(T_MINUS);
</span></span><span><span>22</span><span>            <span>break</span>;
</span></span><span><span>23</span><span>        <span>case</span> <span>&#39;*&#39;</span><span>:</span>
</span></span><span><span>24</span><span>            t <span>=</span> <span>SINGLE_TOK</span>(T_ASTERISKS);
</span></span><span><span>25</span><span>            <span>break</span>;
</span></span><span><span>26</span><span>        <span>case</span> <span>&#39;/&#39;</span><span>:</span>
</span></span><span><span>27</span><span>            t <span>=</span> <span>SINGLE_TOK</span>(T_SLASH);
</span></span><span><span>28</span><span>            <span>break</span>;
</span></span><span><span>29</span><span>        <span>// ... thinks like strings, quoted symbols, numbers, comments, whitespace :^)
</span></span></span><span><span>30</span><span><span></span>        <span>default</span><span>:</span>
</span></span><span><span>31</span><span>            t <span>=</span> <span>SINGLE_TOK</span>(T_EOF);
</span></span><span><span>32</span><span>            <span>break</span>;
</span></span><span><span>33</span><span>    }
</span></span><span><span>34</span><span>    l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>35</span><span>    <span>return</span> t;
</span></span><span><span>36</span><span>}</span></span></code></pre></div><p>And one could consume the api as follows (even with a little type-&gt;string
lookup for debugging):</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>const</span> <span>char</span><span>*</span> TOKEN_TYPE_MAP[] <span>=</span> {
</span></span><span><span> 2</span><span>    [T_PLUS] <span>=</span> <span>&#34;T_PLUS&#34;</span>,
</span></span><span><span> 3</span><span>    [T_MINUS] <span>=</span> <span>&#34;T_MINUS&#34;</span>,
</span></span><span><span> 4</span><span>    [T_ASTERISKS] <span>=</span> <span>&#34;T_ASTERISKS&#34;</span>,
</span></span><span><span> 5</span><span>    [T_SLASH] <span>=</span> <span>&#34;T_SLASH&#34;</span>,
</span></span><span><span> 6</span><span>    [T_EOF] <span>=</span> <span>&#34;T_EOF&#34;</span>
</span></span><span><span> 7</span><span>};
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>Str s <span>=</span> <span>STRING</span>(<span>&#34;+-*/&#34;</span>);
</span></span><span><span>10</span><span>Lexer l <span>=</span> <span>Lexer_new</span>(s);
</span></span><span><span>11</span><span><span>while</span>(l.pos <span>&lt;</span> l.input.len) {
</span></span><span><span>12</span><span>    Token t <span>=</span> <span>Lexer_next</span>(<span>&amp;</span>l);
</span></span><span><span>13</span><span>    <span>puts</span>(TOKEN_TYPE_MAP[t.type]);
</span></span><span><span>14</span><span>}</span></span></code></pre></div><div id="callout"><h3>Tip - Designated initializers</h3><p>Designated initializers (<code>[&lt;int&gt;] = &lt;value&gt;</code>) are allowed by ISO C99, while
designated initializers with ranges (<code>[&lt;int&gt; .. &lt;int&gt;] = &lt;value&gt;</code>) are a gnu
extension, see <a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">6.2.11 Designated Initializers
</a>.</p></div><p>Lets get into some optimisations and strategies for creating a clean, minimal
and especially fast lexer.</p><h2 id="computed-gotos-or-threaded-lexing">Computed gotos, or: Threaded Lexing</h2><p><code>Threaded Lexing</code> is a reference to <em>Threaded code</em>, see
<a href="https://en.wikipedia.org/wiki/Threaded_code">wikipedia</a>. The idea is to
replace the switch statement with a jump to a block inside of the lexer. The
easiest way I could think of implementing this was to:</p><ol><li><p>Define a jump table mapping lexeme start characters to their respective blocks</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>void</span> <span>*</span>jump_table[<span>256</span>] <span>=</span> {
</span></span><span><span> 2</span><span>  <span>// first bind all possible bytes to the unkown label, so there are no out
</span></span></span><span><span> 3</span><span><span></span>  <span>// of bound reads
</span></span></span><span><span> 4</span><span><span></span>  [<span>0</span> ... <span>255</span>] <span>=</span> <span>&amp;&amp;</span>unknown,
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>  <span>// replace all known bytes with correct jump labels
</span></span></span><span><span> 7</span><span><span></span>  [<span>&#39;(&#39;</span>] <span>=</span> <span>&amp;&amp;</span>delimitor_left,
</span></span><span><span> 8</span><span>  [<span>&#39;)&#39;</span>] <span>=</span> <span>&amp;&amp;</span>delimitor_right,
</span></span><span><span> 9</span><span>  [<span>&#39;[&#39;</span>] <span>=</span> <span>&amp;&amp;</span>braket_left,
</span></span><span><span>10</span><span>  [<span>&#39;]&#39;</span>] <span>=</span> <span>&amp;&amp;</span>braket_right,
</span></span><span><span>11</span><span>  [<span>&#39;@&#39;</span>] <span>=</span> <span>&amp;&amp;</span>builtin,
</span></span><span><span>12</span><span>  [<span>&#39;+&#39;</span>] <span>=</span> <span>&amp;&amp;</span>plus,
</span></span><span><span>13</span><span>  [<span>&#39;-&#39;</span>] <span>=</span> <span>&amp;&amp;</span>minus,
</span></span><span><span>14</span><span>  [<span>&#39;/&#39;</span>] <span>=</span> <span>&amp;&amp;</span>slash,
</span></span><span><span>15</span><span>  [<span>&#39;*&#39;</span>] <span>=</span> <span>&amp;&amp;</span>asterisks,
</span></span><span><span>16</span><span>  [<span>&#39;=&#39;</span>] <span>=</span> <span>&amp;&amp;</span>equal,
</span></span><span><span>17</span><span>  [<span>&#39; &#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span>18</span><span>  [<span>&#39;\t&#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span>19</span><span>  [<span>&#39;\n&#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span>20</span><span>  [<span>&#39;;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>comment,
</span></span><span><span>21</span><span>  [<span>&#39;.&#39;</span>] <span>=</span> <span>&amp;&amp;</span>number,
</span></span><span><span>22</span><span>  [<span>&#39;0&#39;</span> ... <span>&#39;9&#39;</span>] <span>=</span> <span>&amp;&amp;</span>number,
</span></span><span><span>23</span><span>  [<span>&#39;a&#39;</span> ... <span>&#39;z&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span>24</span><span>  [<span>&#39;A&#39;</span> ... <span>&#39;Z&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span>25</span><span>  [<span>&#39;\&#39;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>quoted,
</span></span><span><span>26</span><span>  [<span>&#39;_&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span>27</span><span>  [<span>&#39;&#34;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>string,
</span></span><span><span>28</span><span>
</span></span><span><span>29</span><span>  <span>// handle the edgecase of being at the end of the input
</span></span></span><span><span>30</span><span><span></span>  [<span>0</span>] <span>=</span> <span>&amp;&amp;</span>end,
</span></span><span><span>31</span><span>};</span></span></code></pre></div></li><li><p>Create a macro for jumping to the label</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>#define JUMP_TARGET goto *jump_table[(int8_t)l-&gt;input.p[l-&gt;pos]]</span></span></span></code></pre></div></li><li><p>At the start of the lexer, call the macro</p><p><span>C</span></p></li></ol><p>Putting it all together lets us build the following threaded lexer:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>size_t</span> <span>Lexer_all</span>(Lexer <span>*</span>l, Allocator <span>*</span>a, Token <span>**</span>out) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(out <span>!=</span> NULL, <span>&#34;Failed to allocate token list&#34;</span>);
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>  <span>// empty input
</span></span></span><span><span> 5</span><span><span></span>  <span>if</span> (l<span>-&gt;</span>input.len <span>==</span> <span>0</span>) {
</span></span><span><span> 6</span><span>    <span>return</span> <span>1</span>;
</span></span><span><span> 7</span><span>  }
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>  <span>static</span> <span>void</span> <span>*</span>jump_table[<span>256</span>] <span>=</span> {
</span></span><span><span>10</span><span>      [<span>0</span> ... <span>255</span>] <span>=</span> <span>&amp;&amp;</span>unknown,
</span></span><span><span>11</span><span>      [<span>&#39;(&#39;</span>] <span>=</span> <span>&amp;&amp;</span>delimitor_left,
</span></span><span><span>12</span><span>      [<span>&#39;)&#39;</span>] <span>=</span> <span>&amp;&amp;</span>delimitor_right,
</span></span><span><span>13</span><span>      [<span>&#39;[&#39;</span>] <span>=</span> <span>&amp;&amp;</span>braket_left,
</span></span><span><span>14</span><span>      [<span>&#39;]&#39;</span>] <span>=</span> <span>&amp;&amp;</span>braket_right,
</span></span><span><span>15</span><span>      [<span>&#39;@&#39;</span>] <span>=</span> <span>&amp;&amp;</span>builtin,
</span></span><span><span>16</span><span>      [<span>&#39;+&#39;</span>] <span>=</span> <span>&amp;&amp;</span>plus,
</span></span><span><span>17</span><span>      [<span>&#39;-&#39;</span>] <span>=</span> <span>&amp;&amp;</span>minus,
</span></span><span><span>18</span><span>      [<span>&#39;/&#39;</span>] <span>=</span> <span>&amp;&amp;</span>slash,
</span></span><span><span>19</span><span>      [<span>&#39;*&#39;</span>] <span>=</span> <span>&amp;&amp;</span>asterisks,
</span></span><span><span>20</span><span>      [<span>&#39;=&#39;</span>] <span>=</span> <span>&amp;&amp;</span>equal,
</span></span><span><span>21</span><span>      [<span>&#39; &#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span>22</span><span>      [<span>&#39;\t&#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span>23</span><span>      [<span>&#39;\n&#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span>24</span><span>      [<span>&#39;;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>comment,
</span></span><span><span>25</span><span>      [<span>&#39;.&#39;</span>] <span>=</span> <span>&amp;&amp;</span>number,
</span></span><span><span>26</span><span>      [<span>&#39;0&#39;</span> ... <span>&#39;9&#39;</span>] <span>=</span> <span>&amp;&amp;</span>number,
</span></span><span><span>27</span><span>      [<span>&#39;a&#39;</span> ... <span>&#39;z&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span>28</span><span>      [<span>&#39;A&#39;</span> ... <span>&#39;Z&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span>29</span><span>      [<span>&#39;\&#39;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>quoted,
</span></span><span><span>30</span><span>      [<span>&#39;_&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span>31</span><span>      [<span>&#39;&#34;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>string,
</span></span><span><span>32</span><span>      [<span>0</span>] <span>=</span> <span>&amp;&amp;</span>end,
</span></span><span><span>33</span><span>  };
</span></span><span><span>34</span><span>
</span></span><span><span>35</span><span><span>#define JUMP_TARGET goto *jump_table[(int8_t)l-&gt;input.p[l-&gt;pos]]
</span></span></span><span><span>36</span><span><span></span>
</span></span><span><span>37</span><span>  JUMP_TARGET;
</span></span><span><span>38</span><span>
</span></span><span><span>39</span><span><span>delimitor_left</span>:
</span></span><span><span>40</span><span>  JUMP_TARGET;
</span></span><span><span>41</span><span>
</span></span><span><span>42</span><span><span>delimitor_right</span>:
</span></span><span><span>43</span><span>  JUMP_TARGET;
</span></span><span><span>44</span><span>
</span></span><span><span>45</span><span><span>braket_left</span>:
</span></span><span><span>46</span><span>  JUMP_TARGET;
</span></span><span><span>47</span><span>
</span></span><span><span>48</span><span><span>braket_right</span>:
</span></span><span><span>49</span><span>  JUMP_TARGET;
</span></span><span><span>50</span><span>
</span></span><span><span>51</span><span><span>builtin</span>:
</span></span><span><span>52</span><span>  JUMP_TARGET;
</span></span><span><span>53</span><span>
</span></span><span><span>54</span><span><span>plus</span>:
</span></span><span><span>55</span><span>  JUMP_TARGET;
</span></span><span><span>56</span><span>
</span></span><span><span>57</span><span><span>minus</span>:
</span></span><span><span>58</span><span>  JUMP_TARGET;
</span></span><span><span>59</span><span>
</span></span><span><span>60</span><span><span>slash</span>:
</span></span><span><span>61</span><span>  JUMP_TARGET;
</span></span><span><span>62</span><span>
</span></span><span><span>63</span><span><span>equal</span>:
</span></span><span><span>64</span><span>  JUMP_TARGET;
</span></span><span><span>65</span><span>
</span></span><span><span>66</span><span><span>asterisks</span>:
</span></span><span><span>67</span><span>  JUMP_TARGET;
</span></span><span><span>68</span><span>
</span></span><span><span>69</span><span><span>number</span>:
</span></span><span><span>70</span><span>  JUMP_TARGET;
</span></span><span><span>71</span><span>
</span></span><span><span>72</span><span><span>ident</span>:
</span></span><span><span>73</span><span>  JUMP_TARGET;
</span></span><span><span>74</span><span>
</span></span><span><span>75</span><span><span>quoted</span>:
</span></span><span><span>76</span><span>  JUMP_TARGET;
</span></span><span><span>77</span><span>
</span></span><span><span>78</span><span><span>string</span>:
</span></span><span><span>79</span><span>  JUMP_TARGET;
</span></span><span><span>80</span><span>
</span></span><span><span>81</span><span><span>comment</span>:
</span></span><span><span>82</span><span>  JUMP_TARGET;
</span></span><span><span>83</span><span>
</span></span><span><span>84</span><span><span>whitespace</span>:
</span></span><span><span>85</span><span>  JUMP_TARGET;
</span></span><span><span>86</span><span>
</span></span><span><span>87</span><span><span>unknown</span>:
</span></span><span><span>88</span><span>  <span>return</span> <span>1</span>;
</span></span><span><span>89</span><span>
</span></span><span><span>90</span><span><span>end</span>:
</span></span><span><span>91</span><span>  <span>return</span> <span>0</span>;
</span></span><span><span>92</span><span>}</span></span></code></pre></div><p>Replacing the switch with an array index and a jump. The latter is
significantly faster than the former due to:</p><ul><li>Better <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture#Code_density">code density</a></li><li>Less cache misses, better branch prediction</li></ul><div id="callout"><h3>Warning</h3><p>There are two downsides to this approach:</p><ol><li>It is not supported by MSVC toolchain (clang, gcc only)</li><li>It makes reading and debugging the lexer far more complicated</li></ol></div><h2 id="abstracting-allocations-via-the-allocator-interface">Abstracting allocations via the Allocator interface</h2><p>I want to allow the user of purple-garden to choose between allocation
strategies like my garbage collectors and a bump allocator. For this I need an
interface to marry several backing implementations into a singular api:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>#ifndef MEM_H
</span></span></span><span><span> 2</span><span><span>#define MEM_H
</span></span></span><span><span> 3</span><span><span></span>
</span></span><span><span> 4</span><span><span>#include</span> <span>&lt;stddef.h&gt;</span><span>
</span></span></span><span><span> 5</span><span><span></span>
</span></span><span><span> 6</span><span><span>#ifdef DEBUG
</span></span></span><span><span> 7</span><span><span>#if DEBUG
</span></span></span><span><span> 8</span><span><span>#define VERBOSE_ALLOCATOR 1
</span></span></span><span><span> 9</span><span><span>#endif
</span></span></span><span><span>10</span><span><span>#else
</span></span></span><span><span>11</span><span><span>#define VERBOSE_ALLOCATOR 0
</span></span></span><span><span>12</span><span><span>#endif
</span></span></span><span><span>13</span><span><span></span>
</span></span><span><span>14</span><span><span>// 1MB
</span></span></span><span><span>15</span><span><span></span><span>#define GC_MIN_HEAP 1024 * 1024
</span></span></span><span><span>16</span><span><span></span>
</span></span><span><span>17</span><span><span>typedef</span> <span>struct</span> {
</span></span><span><span>18</span><span>  <span>size_t</span> current;
</span></span><span><span>19</span><span>  <span>size_t</span> allocated;
</span></span><span><span>20</span><span>} Stats;
</span></span><span><span>21</span><span>
</span></span><span><span>22</span><span><span>// CALL is used to emulate method calls by calling a METHOD on SELF with
</span></span></span><span><span>23</span><span><span>// SELF-&gt;ctx and __VA_ARGS__, this is useful for interface interaction, such as
</span></span></span><span><span>24</span><span><span>// Allocator, which reduces alloc_bump.request(alloc_bump.ctx, 64); to
</span></span></span><span><span>25</span><span><span>// CALL(alloc_bump, request, 64), removing the need for passing the context in
</span></span></span><span><span>26</span><span><span>// manually
</span></span></span><span><span>27</span><span><span></span><span>#if VERBOSE_ALLOCATOR
</span></span></span><span><span>28</span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span>29</span><span><span>#define CALL(SELF, METHOD, ...)                                                \
</span></span></span><span><span>30</span><span><span>  (fprintf(stderr, &#34;[ALLOCATOR] %s@%s::%d: %s-&gt;%s(%s)\n&#34;, __FILE__, __func__,  \
</span></span></span><span><span>31</span><span><span>           __LINE__, #SELF, #METHOD, #__VA_ARGS__),                            \
</span></span></span><span><span>32</span><span><span>   (SELF)-&gt;METHOD((SELF)-&gt;ctx, ##__VA_ARGS__))
</span></span></span><span><span>33</span><span><span>#else
</span></span></span><span><span>34</span><span><span>#define CALL(SELF, METHOD, ...) (SELF)-&gt;METHOD((SELF)-&gt;ctx, ##__VA_ARGS__)
</span></span></span><span><span>35</span><span><span>#endif
</span></span></span><span><span>36</span><span><span></span>
</span></span><span><span>37</span><span><span>// Allocator defines an interface abstracting different allocators, so the
</span></span></span><span><span>38</span><span><span>// runtime of the virtual machine does not need to know about implementation
</span></span></span><span><span>39</span><span><span>// details, can be used like this:
</span></span></span><span><span>40</span><span><span>//
</span></span></span><span><span>41</span><span><span>//
</span></span></span><span><span>42</span><span><span>//  #define ALLOC_HEAP_SIZE = 1024
</span></span></span><span><span>43</span><span><span>//  Allocator alloc_bump = bump_init(ALLOC_HEAP_SIZE);
</span></span></span><span><span>44</span><span><span>//
</span></span></span><span><span>45</span><span><span>//  size_t some_block_size = 16;
</span></span></span><span><span>46</span><span><span>//  void *some_block = alloc_bump.request(alloc_bump.ctx, some_block_size);
</span></span></span><span><span>47</span><span><span>//
</span></span></span><span><span>48</span><span><span>//  alloc_bump.destroy(alloc_bump.ctx);
</span></span></span><span><span>49</span><span><span>//
</span></span></span><span><span>50</span><span><span></span><span>typedef</span> <span>struct</span> {
</span></span><span><span>51</span><span>  <span>// Allocator::ctx refers to an internal allocator state and owned memory
</span></span></span><span><span>52</span><span><span></span>  <span>// areas, for instance, a bump allocator would attach its meta data (current
</span></span></span><span><span>53</span><span><span></span>  <span>// position, cap, etc) here
</span></span></span><span><span>54</span><span><span></span>  <span>void</span> <span>*</span>ctx;
</span></span><span><span>55</span><span>
</span></span><span><span>56</span><span>  <span>// Allocator::stats is expected to return the current statistics of the
</span></span></span><span><span>57</span><span><span></span>  <span>// underlying allocator
</span></span></span><span><span>58</span><span><span></span>  <span>Stats</span> (<span>*</span>stats)(<span>void</span> <span>*</span>ctx);
</span></span><span><span>59</span><span>  <span>// Allocator::request returns a handle to a block of memory of size `size`
</span></span></span><span><span>60</span><span><span></span>  <span>void</span> <span>*</span>(<span>*</span>request)(<span>void</span> <span>*</span>ctx, <span>size_t</span> size);
</span></span><span><span>61</span><span>  <span>// Allocator::destroy cleans state up and deallocates any owned memory areas
</span></span></span><span><span>62</span><span><span></span>  <span>void</span> (<span>*</span>destroy)(<span>void</span> <span>*</span>ctx);
</span></span><span><span>63</span><span>} Allocator;
</span></span><span><span>64</span><span>
</span></span><span><span>65</span><span>Allocator <span>*</span><span>bump_init</span>(<span>size_t</span> size);
</span></span><span><span>66</span><span>Allocator <span>*</span><span>xcgc_init</span>(<span>size_t</span> size, <span>void</span> <span>*</span>vm);
</span></span><span><span>67</span><span>
</span></span><span><span>68</span><span><span>#endif</span></span></span></code></pre></div><p>For instance: this allocator is then passed to the virtual machine. The vm uses
<code>Allocator-&gt;request(Allocator-&gt;ctx, sizeof(Value))</code> to allocate a new runtime
value.</p><p>I included a <code>CALL</code> macro for cleaning this duplicated context passing up:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span>Allocator <span>*</span>a <span>=</span> <span>bump_init</span>(<span>1024</span>);
</span></span><span><span>2</span><span>
</span></span><span><span>3</span><span><span>// before:
</span></span></span><span><span>4</span><span><span></span><span>void</span> <span>*</span>block <span>=</span> a<span>-&gt;</span><span>request</span>(a<span>-&gt;</span>ctx, <span>512</span>);
</span></span><span><span>5</span><span>a<span>-&gt;</span><span>destroy</span>(a<span>-&gt;</span>ctx)
</span></span><span><span>6</span><span>
</span></span><span><span>7</span><span><span>// after:
</span></span></span><span><span>8</span><span><span></span><span>void</span> <span>*</span>block <span>=</span> <span>CALL</span>(a, request, <span>512</span>);
</span></span><span><span>9</span><span><span>CALL</span>(a, destroy)</span></span></code></pre></div><p>This macro also enables verbose allocation insights for debugging purposes:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>[ALLOCATOR] vm.c@freelist_preallocate::59: fl-&gt;alloc-&gt;request(sizeof(Frame))
</span></span><span><span>2</span><span>[ALLOCATOR] main.c@main::245: vm.alloc-&gt;stats()
</span></span><span><span>3</span><span>[ALLOCATOR] main.c@main::255: pipeline_allocator-&gt;destroy()
</span></span><span><span>4</span><span>[ALLOCATOR] vm.c@Vm_destroy::283: vm-&gt;alloc-&gt;destroy()</span></span></code></pre></div><p>The implementation of said interface is straightforward:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// Bump allocator header
</span></span></span><span><span> 2</span><span><span></span><span>typedef</span> <span>struct</span> {
</span></span><span><span> 3</span><span>  <span>// points to the start of the allocated block from which Allocator::request
</span></span></span><span><span> 4</span><span><span></span>  <span>// will hand out aligned chunks
</span></span></span><span><span> 5</span><span><span></span>  <span>void</span> <span>*</span>block;
</span></span><span><span> 6</span><span>  <span>// the size of said allocated block
</span></span></span><span><span> 7</span><span><span></span>  <span>size_t</span> len;
</span></span><span><span> 8</span><span>  <span>// the current amount of bytes in use
</span></span></span><span><span> 9</span><span><span></span>  <span>size_t</span> pos;
</span></span><span><span>10</span><span>} BumpCtx;
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span><span>void</span> <span>*</span><span>bump_request</span>(<span>void</span> <span>*</span>ctx, <span>size_t</span> size) {
</span></span><span><span>13</span><span>  BumpCtx <span>*</span>b_ctx <span>=</span> (BumpCtx <span>*</span>)ctx;
</span></span><span><span>14</span><span>  <span>size_t</span> align <span>=</span> <span>sizeof</span>(<span>void</span> <span>*</span>);
</span></span><span><span>15</span><span>  b_ctx<span>-&gt;</span>pos <span>=</span> (b_ctx<span>-&gt;</span>pos <span>+</span> align <span>-</span> <span>1</span>) <span>&amp;</span> <span>~</span>(align <span>-</span> <span>1</span>);
</span></span><span><span>16</span><span>  <span>ASSERT</span>(b_ctx<span>-&gt;</span>pos <span>+</span> size <span>&lt;=</span> b_ctx<span>-&gt;</span>len, <span>&#34;OOM :( with %zu&#34;</span>, b_ctx<span>-&gt;</span>len);
</span></span><span><span>17</span><span>  <span>void</span> <span>*</span>block_entry <span>=</span> (<span>char</span> <span>*</span>)b_ctx<span>-&gt;</span>block <span>+</span> b_ctx<span>-&gt;</span>pos;
</span></span><span><span>18</span><span>  b_ctx<span>-&gt;</span>pos <span>+=</span> size;
</span></span><span><span>19</span><span>  <span>return</span> block_entry;
</span></span><span><span>20</span><span>}
</span></span><span><span>21</span><span>
</span></span><span><span>22</span><span><span>void</span> <span>bump_destroy</span>(<span>void</span> <span>*</span>ctx) {
</span></span><span><span>23</span><span>  <span>ASSERT</span>(ctx <span>!=</span> NULL, <span>&#34;bump_destroy on already destroyed allocator&#34;</span>);
</span></span><span><span>24</span><span>  BumpCtx <span>*</span>b_ctx <span>=</span> (BumpCtx <span>*</span>)ctx;
</span></span><span><span>25</span><span>  <span>// madvise(2):
</span></span></span><span><span>26</span><span><span></span>  <span>// The  application  no  longer requires the pages in the range
</span></span></span><span><span>27</span><span><span></span>  <span>// specified by addr and len. The kernel can thus  free  these
</span></span></span><span><span>28</span><span><span></span>  <span>// pages,  but  the freeing could be delayed until memory pres‐
</span></span></span><span><span>29</span><span><span></span>  <span>// sure occurs.
</span></span></span><span><span>30</span><span><span></span>  <span>madvise</span>(b_ctx<span>-&gt;</span>block, b_ctx<span>-&gt;</span>len, MADV_FREE);
</span></span><span><span>31</span><span>  <span>int</span> res <span>=</span> <span>munmap</span>(b_ctx<span>-&gt;</span>block, b_ctx<span>-&gt;</span>len);
</span></span><span><span>32</span><span>  <span>ASSERT</span>(res <span>==</span> <span>0</span>, <span>&#34;munmap failed&#34;</span>);
</span></span><span><span>33</span><span>  <span>free</span>(ctx);
</span></span><span><span>34</span><span>}
</span></span><span><span>35</span><span>
</span></span><span><span>36</span><span>Stats <span>bump_stats</span>(<span>void</span> <span>*</span>ctx) {
</span></span><span><span>37</span><span>  BumpCtx <span>*</span>b_ctx <span>=</span> (BumpCtx <span>*</span>)ctx;
</span></span><span><span>38</span><span>  <span>return</span> (Stats){.allocated <span>=</span> b_ctx<span>-&gt;</span>len, .current <span>=</span> b_ctx<span>-&gt;</span>pos};
</span></span><span><span>39</span><span>}
</span></span><span><span>40</span><span>
</span></span><span><span>41</span><span>Allocator <span>*</span><span>bump_init</span>(<span>size_t</span> size) {
</span></span><span><span>42</span><span>  <span>long</span> page_size <span>=</span> <span>sysconf</span>(_SC_PAGESIZE);
</span></span><span><span>43</span><span>  size <span>=</span> (size <span>+</span> page_size <span>-</span> <span>1</span>) <span>&amp;</span> <span>~</span>(page_size <span>-</span> <span>1</span>);
</span></span><span><span>44</span><span>
</span></span><span><span>45</span><span>  <span>void</span> <span>*</span>b <span>=</span> <span>mmap</span>(NULL, size, PROT_READ <span>|</span> PROT_WRITE,
</span></span><span><span>46</span><span>                 MAP_PRIVATE <span>|</span> MAP_ANONYMOUS, <span>-</span><span>1</span>, <span>0</span>);
</span></span><span><span>47</span><span>  <span>ASSERT</span>(b <span>!=</span> MAP_FAILED, <span>&#34;failed to mmap allocator buffer&#34;</span>);
</span></span><span><span>48</span><span>
</span></span><span><span>49</span><span>  BumpCtx <span>*</span>ctx <span>=</span> <span>malloc</span>(<span>sizeof</span>(BumpCtx));
</span></span><span><span>50</span><span>  <span>ASSERT</span>(ctx <span>!=</span> NULL, <span>&#34;failed to bump allocator context&#34;</span>);
</span></span><span><span>51</span><span>  ctx<span>-&gt;</span>len <span>=</span> size;
</span></span><span><span>52</span><span>  ctx<span>-&gt;</span>pos <span>=</span> <span>0</span>;
</span></span><span><span>53</span><span>  ctx<span>-&gt;</span>block <span>=</span> b;
</span></span><span><span>54</span><span>
</span></span><span><span>55</span><span>  Allocator <span>*</span>a <span>=</span> <span>malloc</span>(<span>sizeof</span>(Allocator));
</span></span><span><span>56</span><span>  <span>ASSERT</span>(ctx <span>!=</span> NULL, <span>&#34;failed to alloc bump allocator&#34;</span>);
</span></span><span><span>57</span><span>  a<span>-&gt;</span>ctx <span>=</span> (<span>void</span> <span>*</span>)ctx;
</span></span><span><span>58</span><span>  a<span>-&gt;</span>destroy <span>=</span> bump_destroy;
</span></span><span><span>59</span><span>  a<span>-&gt;</span>request <span>=</span> bump_request;
</span></span><span><span>60</span><span>  a<span>-&gt;</span>stats <span>=</span> bump_stats;
</span></span><span><span>61</span><span>
</span></span><span><span>62</span><span>  <span>return</span> a;
</span></span><span><span>63</span><span>}</span></span></code></pre></div><div id="callout"><h3>Info - Benchmarks</h3><p>This reduced the total runtime by like 24ms or made it 1.58x faster, see
<a href="https://github.com/xNaCly/purple-garden/commit/4251b6b9fd701d7e1f7fd9a6e783000aa465f8ff"><code>4251b6b</code></a>.</p><p><em>The separate parsing stage was due to me experimenting with attaching the
parser to the compiler, but this made the whole thing a bit slower than just
finishing parsing before compiling</em></p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>mem+main+cc: replace dynamic alloc with bump allocator (~1.6x faster)
</span></span><span><span> 2</span><span>- preallocated 4MB for bytecode and 256KB for the global pool to improve memory management.
</span></span><span><span> 3</span><span>- cc now takes an allocator to omit inline memory allocations for global
</span></span><span><span> 4</span><span>  pool entries and bytecode creation
</span></span><span><span> 5</span><span>- with previous changes shaving off 24ms
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>Old perf (before b59737a)
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>    [    0.0070ms] main::Args_parse: Parsed arguments
</span></span><span><span>10</span><span>    [    0.0080ms] io::IO_read_file_to_string: mmaped input
</span></span><span><span>11</span><span>    [   41.2460ms] parser::Parser_run: Transformed source to AST
</span></span><span><span>12</span><span>    [   20.7330ms] cc::cc: Flattened AST to byte code
</span></span><span><span>13</span><span>    [    0.9640ms] mem::Allocator::destroy: Deallocated AST memory space
</span></span><span><span>14</span><span>    [    2.1270ms] vm::Vm_run: Walked and executed byte code
</span></span><span><span>15</span><span>    [    0.5560ms] vm::Vm_destroy: Deallocated global pool and bytecode list
</span></span><span><span>16</span><span>
</span></span><span><span>17</span><span>New:
</span></span><span><span>18</span><span>
</span></span><span><span>19</span><span>    [    0.0050ms] main::Args_parse: Parsed arguments
</span></span><span><span>20</span><span>    [    0.0120ms] io::IO_read_file_to_string: mmaped input
</span></span><span><span>21</span><span>    [   37.8600ms] cc::cc: Flattened AST to byte code
</span></span><span><span>22</span><span>    [    2.3540ms] vm::Vm_run: Walked and executed byte code
</span></span><span><span>23</span><span>    [    0.7380ms] mem::Allocator::destroy: Deallocated AST memory space
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>    $ hyperfine &#34;./purple_garden examples/bench.garden&#34; &#34;../purple_garden_old/purple_garden examples/bench.garden&#34;
</span></span><span><span>26</span><span>    Benchmark 1: ./purple_garden examples/bench.garden
</span></span><span><span>27</span><span>      Time (mean ± σ):      42.2 ms ±   0.7 ms    [User: 28.0 ms, System: 13.8 ms]
</span></span><span><span>28</span><span>      Range (min … max):    41.3 ms …  45.8 ms    70 runs
</span></span><span><span>29</span><span>
</span></span><span><span>30</span><span>    Benchmark 2: ../purple_garden_old/purple_garden examples/bench.garden
</span></span><span><span>31</span><span>      Time (mean ± σ):      66.6 ms ±   1.1 ms    [User: 45.9 ms, System: 20.2 ms]
</span></span><span><span>32</span><span>      Range (min … max):    64.8 ms …  69.8 ms    43 runs
</span></span><span><span>33</span><span>
</span></span><span><span>34</span><span>    Summary
</span></span><span><span>35</span><span>      ./purple_garden examples/bench.garden ran
</span></span><span><span>36</span><span>        1.58 ± 0.04 times faster than ../purple_garden_old/purple_garden examples/bench.garden</span></span></code></pre></div><p>Before I also made the parser use the block allocator, see
<a href="https://github.com/xNaCly/purple-garden/commit/032405134150b4fb6669812320089f1851c3cb8b"><code>0324051</code></a>:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>parser: allocate with bump alloc (2x faster parse, 26x faster clean)
</span></span><span><span> 2</span><span>I replaced the inline allocation logic for the growing of Node.children with
</span></span><span><span> 3</span><span>the bump allocator from the allocator abstraction in mem::Allocator
</span></span><span><span> 4</span><span>(mem::bump_*). This results in 2x faster parsing and 27x faster AST cleanup:
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>- [   89.4830ms/41.7840ms=02.1417x faster] parser::Parser_run: Transformed
</span></span><span><span> 7</span><span>  source to AST
</span></span><span><span> 8</span><span>- [   22.3900ms/00.8440ms=26.5284x faster] parser::Node_destroy: Deallocated
</span></span><span><span> 9</span><span>  AST Nodes renamed to mem::Allocator::destroy
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>Old:
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>    $ make bench PG=examples/bench.garden
</span></span><span><span>14</span><span>    [    0.0050ms] main::Args_parse: Parsed arguments
</span></span><span><span>15</span><span>    [    0.0110ms] io::IO_read_file_to_string: mmaped input
</span></span><span><span>16</span><span>    [   89.4830ms] parser::Parser_run: Transformed source to AST
</span></span><span><span>17</span><span>    [   18.8010ms] cc::cc: Flattened AST to byte code
</span></span><span><span>18</span><span>    [   22.3900ms] parser::Node_destroy: Deallocated AST Nodes
</span></span><span><span>19</span><span>    [    2.3200ms] vm::Vm_run: Walked and executed byte code
</span></span><span><span>20</span><span>    [    0.4670ms] vm::Vm_destroy: Deallocated global pool and bytecode list
</span></span><span><span>21</span><span>
</span></span><span><span>22</span><span>New:
</span></span><span><span>23</span><span>
</span></span><span><span>24</span><span>    $ make bench PG=examples/bench.garden
</span></span><span><span>25</span><span>    [    0.0050ms] main::Args_parse: Parsed arguments
</span></span><span><span>26</span><span>    [    0.0100ms] io::IO_read_file_to_string: mmaped input
</span></span><span><span>27</span><span>    [   41.7840ms] parser::Parser_run: Transformed source to AST
</span></span><span><span>28</span><span>    [   21.2160ms] cc::cc: Flattened AST to byte code
</span></span><span><span>29</span><span>    [    0.8440ms] mem::Allocator::destroy: Deallocated AST memory space
</span></span><span><span>30</span><span>    [    2.2510ms] vm::Vm_run: Walked and executed byte code
</span></span><span><span>31</span><span>    [    0.7590ms] vm::Vm_destroy: Deallocated global pool and bytecode list</span></span></code></pre></div></div><h2 id="operating-on-zero-copy-zero-alloc-string-windows">Operating on zero copy, zero alloc string windows</h2><p>Our lexer doesn’t require mutable strings, C does not come with a string
abstraction out of the box and I wanted to attach metadata to strings - so I
came up with a small string abstraction:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// str is a simple stack allocated wrapper around C char arrays, providing
</span></span></span><span><span> 2</span><span><span>// constant time length access and zero allocation+copy interactions for all
</span></span></span><span><span> 3</span><span><span>// methods except Str_to
</span></span></span><span><span> 4</span><span><span></span><span>typedef</span> <span>struct</span> {
</span></span><span><span> 5</span><span>  <span>// store the pointer to the underlying char
</span></span></span><span><span> 6</span><span><span></span>  <span>const</span> <span>uint8_t</span> <span>*</span>p;
</span></span><span><span> 7</span><span>  <span>// hash of the input, do not expect it to be filled, has to be computed via
</span></span></span><span><span> 8</span><span><span></span>  <span>// Str_hash or inline in the lexer
</span></span></span><span><span> 9</span><span><span></span>  <span>uint64_t</span> hash;
</span></span><span><span>10</span><span>  <span>// length of the input without a zero terminator
</span></span></span><span><span>11</span><span><span></span>  <span>size_t</span> len;
</span></span><span><span>12</span><span>} Str;</span></span></code></pre></div><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>#define STRING(str) ((Str){.len = sizeof(str) - 1, .p = (const uint8_t *)str})
</span></span></span><span><span>2</span><span><span>#define STRING_EMPTY ((Str){.len = 0, .p = NULL})</span></span></span></code></pre></div><p>Creating a <code>Str</code> from a c style <code>const char*</code> can be done by passing it into
the <code>STRING</code> macro, gcc can evaluate all operations inside of it at compile
time. Since the view doesnt own its underlying data, its cheap to copy and
create slices by just pointing new views to the underlying buffer.</p><p>I use this struct throughout the whole codebase, but specifically inside of the
lexer to create views over the original input that point to the contents of
some tokens:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// example inside of handling strings in the lexer:
</span></span></span><span><span> 2</span><span><span></span>
</span></span><span><span> 3</span><span><span>// dummy values for start and hash
</span></span></span><span><span> 4</span><span><span></span><span>size_t</span> start <span>=</span> <span>3</span>;
</span></span><span><span> 5</span><span><span>size_t</span> hash <span>=</span> <span>0xAFFEDEAD</span>;
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>Token <span>*</span>t <span>=</span> <span>&amp;</span>(Token){};
</span></span><span><span> 8</span><span>t<span>-&gt;</span>type <span>=</span> T_STRING;
</span></span><span><span> 9</span><span>t<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>10</span><span>    .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>11</span><span>    .len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start,
</span></span><span><span>12</span><span>    .hash <span>=</span> hash,
</span></span><span><span>13</span><span>};</span></span></code></pre></div><p>Due to the window nature of this struct I had to reimplement some things
myself, such as slicing, concatination, equality checking, hashing and
converting to <code>int64</code> and <code>double</code>:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>char</span> <span>Str_get</span>(<span>const</span> Str <span>*</span>str, <span>size_t</span> index);
</span></span><span><span>2</span><span>Str <span>Str_from</span>(<span>const</span> <span>char</span> <span>*</span>s);
</span></span><span><span>3</span><span>Str <span>Str_slice</span>(<span>const</span> Str <span>*</span>str, <span>size_t</span> start, <span>size_t</span> end);
</span></span><span><span>4</span><span>Str <span>Str_concat</span>(<span>const</span> Str <span>*</span>a, <span>const</span> Str <span>*</span>b, Allocator <span>*</span>alloc);
</span></span><span><span>5</span><span><span>bool</span> <span>Str_eq</span>(<span>const</span> Str <span>*</span>a, <span>const</span> Str <span>*</span>b);
</span></span><span><span>6</span><span><span>void</span> <span>Str_debug</span>(<span>const</span> Str <span>*</span>str);
</span></span><span><span>7</span><span><span>size_t</span> <span>Str_hash</span>(<span>const</span> Str <span>*</span>str);
</span></span><span><span>8</span><span><span>int64_t</span> <span>Str_to_int64_t</span>(<span>const</span> Str <span>*</span>str);
</span></span><span><span>9</span><span><span>double</span> <span>Str_to_double</span>(<span>const</span> Str <span>*</span>str);</span></span></code></pre></div><p>Lets quickly go over the interesting ones, specifically slicing and converting
to other data types. Slicing is super easy, since we just move the start and
the end to the new slice start and end.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span>Str <span>Str_slice</span>(<span>const</span> Str <span>*</span>str, <span>size_t</span> start, <span>size_t</span> end) {
</span></span><span><span>2</span><span>  <span>ASSERT</span>(end <span>&gt;=</span> start, <span>&#34;Str_slice: Invalid slice range: end must be &gt;= start&#34;</span>);
</span></span><span><span>3</span><span>  <span>ASSERT</span>(end <span>&lt;=</span> str<span>-&gt;</span>len, <span>&#34;Str_slice: Slice range exceeds string length&#34;</span>);
</span></span><span><span>4</span><span>
</span></span><span><span>5</span><span>  <span>return</span> (Str){
</span></span><span><span>6</span><span>      .p <span>=</span> str<span>-&gt;</span>p <span>+</span> start,
</span></span><span><span>7</span><span>      .len <span>=</span> end <span>-</span> start,
</span></span><span><span>8</span><span>  };
</span></span><span><span>9</span><span>}</span></span></code></pre></div><p>Converting to <code>int64</code> is also fairly uncomplicated, since the lexer is expected
to make sure all characters are in the integer set. The algorithm consists of
converting the character representation of an integer component into its
literal value by subtracting <code>&#39;0&#39;</code> from it. The resulting value is added to the
product of the previous iteration and 10, since we are working in the decimal
system.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>int64_t</span> <span>Str_to_int64_t</span>(<span>const</span> Str <span>*</span>str) {
</span></span><span><span> 2</span><span>  <span>int64_t</span> r <span>=</span> <span>0</span>;
</span></span><span><span> 3</span><span>  <span>ASSERT</span>(str<span>-&gt;</span>len <span>&gt;</span> <span>0</span>, <span>&#34;Cant convert empty string into int64_t&#34;</span>);
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>  <span>for</span> (<span>size_t</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> str<span>-&gt;</span>len; i<span>++</span>) {
</span></span><span><span> 6</span><span>    <span>int</span> digit <span>=</span> str<span>-&gt;</span>p[i] <span>-</span> <span>&#39;0&#39;</span>;
</span></span><span><span> 7</span><span>    <span>ASSERT</span>(r <span>&lt;</span> (INT64_MAX <span>-</span> digit) <span>/</span> <span>10</span>,
</span></span><span><span> 8</span><span>           <span>&#34;int64_t number space overflow: `%.*s`&#34;</span>, (<span>int</span>)str<span>-&gt;</span>len, str<span>-&gt;</span>p)
</span></span><span><span> 9</span><span>    r <span>=</span> r <span>*</span> <span>10</span> <span>+</span> digit;
</span></span><span><span>10</span><span>  }
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>  <span>return</span> r;
</span></span><span><span>13</span><span>}</span></span></code></pre></div><p>Doubles are represented differently, specifcally by their mantiassa and
exponent, requiring a slightly more sophisticated conversion algorithm. In the
same vain as <code>Str_to_int64_t</code>, validating is already done by the lexer to the
extend of only allowing any of <code>.1234567890</code>.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>double</span> <span>Str_to_double</span>(<span>const</span> Str <span>*</span>str) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(str<span>-&gt;</span>len <span>&gt;</span> <span>0</span>, <span>&#34;Can&#39;t convert empty string into double&#34;</span>);
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>  <span>const</span> <span>char</span> <span>*</span>p <span>=</span> (<span>const</span> <span>char</span> <span>*</span>)str<span>-&gt;</span>p;
</span></span><span><span> 5</span><span>  <span>size_t</span> len <span>=</span> str<span>-&gt;</span>len;
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>  <span>uint64_t</span> mantissa <span>=</span> <span>0</span>;
</span></span><span><span> 8</span><span>  <span>int</span> exponent <span>=</span> <span>0</span>;
</span></span><span><span> 9</span><span>  <span>bool</span> seen_dot <span>=</span> false;
</span></span><span><span>10</span><span>  <span>bool</span> has_digits <span>=</span> false;
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>  <span>// we dont check that all chars are numbers here, since the lexer already does
</span></span></span><span><span>13</span><span><span></span>  <span>// that
</span></span></span><span><span>14</span><span><span></span>  <span>for</span> (<span>size_t</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> len; i<span>++</span>) {
</span></span><span><span>15</span><span>    <span>char</span> c <span>=</span> p[i];
</span></span><span><span>16</span><span>
</span></span><span><span>17</span><span>    <span>if</span> (c <span>==</span> <span>&#39;.&#39;</span>) {
</span></span><span><span>18</span><span>      seen_dot <span>=</span> true;
</span></span><span><span>19</span><span>      <span>continue</span>;
</span></span><span><span>20</span><span>    }
</span></span><span><span>21</span><span>
</span></span><span><span>22</span><span>    has_digits <span>=</span> true;
</span></span><span><span>23</span><span>    <span>short</span> digit <span>=</span> c <span>-</span> <span>&#39;0&#39;</span>;
</span></span><span><span>24</span><span>    <span>ASSERT</span>(mantissa <span>&lt;=</span> (UINT64_MAX <span>-</span> digit) <span>/</span> <span>10</span>, <span>&#34;Mantissa overflow&#34;</span>);
</span></span><span><span>25</span><span>    mantissa <span>=</span> mantissa <span>*</span> <span>10</span> <span>+</span> digit;
</span></span><span><span>26</span><span>    <span>if</span> (seen_dot) {
</span></span><span><span>27</span><span>      exponent <span>-=</span> <span>1</span>;
</span></span><span><span>28</span><span>    }
</span></span><span><span>29</span><span>  }
</span></span><span><span>30</span><span>
</span></span><span><span>31</span><span>  <span>// if there were no digits after the &#39;.&#39;
</span></span></span><span><span>32</span><span><span></span>  <span>ASSERT</span>(has_digits, <span>&#34;Can&#39;t parse `%.*s` into a double&#34;</span>, (<span>int</span>)len, p);
</span></span><span><span>33</span><span>
</span></span><span><span>34</span><span>  <span>double</span> result <span>=</span> (<span>double</span>)mantissa;
</span></span><span><span>35</span><span>  <span>// skip exponent computation for &lt;mantissa&gt;.0, since these are just the
</span></span></span><span><span>36</span><span><span></span>  <span>// mantissa
</span></span></span><span><span>37</span><span><span></span>  <span>if</span> (exponent <span>!=</span> <span>0</span>) {
</span></span><span><span>38</span><span>    result <span>*=</span> <span>pow</span>(<span>10.0</span>, exponent);
</span></span><span><span>39</span><span>  }
</span></span><span><span>40</span><span>
</span></span><span><span>41</span><span>  <span>return</span> result;
</span></span><span><span>42</span><span>}</span></span></code></pre></div><div id="callout"><h3>Info - Benchmarks</h3><p>1.4x Speedup by using the above abstraction in a non allocating way, see
<a href="https://github.com/xNaCly/purple-garden/commit/b19088a61ec5f5e723036fe8cd1161c3a1fecc44"><code>b19088a</code></a>:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>common: make String methods 0 alloc (~1.4x faster)
</span></span><span><span> 2</span><span>- String_slice no longer requires a malloc, now just returns a window into its
</span></span><span><span> 3</span><span>  argument
</span></span><span><span> 4</span><span>- String_to no longer returns just the underlying pointer (String.p) but
</span></span><span><span> 5</span><span>  allocates a new char*
</span></span><span><span> 6</span><span>- new String_debug method to print the window
</span></span><span><span> 7</span><span>- lexer::num no longer allocates and frees for its string window, instead uses
</span></span><span><span> 8</span><span>  a stack buffer
</span></span><span><span> 9</span><span>- parser::Node_destroy no longer calls Token_destroy
</span></span><span><span>10</span><span>- Token_destroy no longer needed, since the lexer no longer allocates
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>Main improvements in runtime while parsing (less allocations and frees for
</span></span><span><span>13</span><span>ident, string and double handling) and in cleanup (no more deallocations for
</span></span><span><span>14</span><span>tokens)
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>With 250k loc of &#34;hello world&#34;:
</span></span><span><span>17</span><span>
</span></span><span><span>18</span><span>- Parsing went from 20.9ms to 13.8ms =&gt; 1.51x faster
</span></span><span><span>19</span><span>- Cleanup went from 3.6ms to 0.83ms =&gt; 4.34x faster
</span></span><span><span>20</span><span>
</span></span><span><span>21</span><span>Old:
</span></span><span><span>22</span><span>
</span></span><span><span>23</span><span>    [BENCH] (T-0.0060ms): parsed arguments
</span></span><span><span>24</span><span>    [BENCH] (T-0.0420ms): read file to String
</span></span><span><span>25</span><span>    [BENCH] (T-20.8780ms): parsed input
</span></span><span><span>26</span><span>    [BENCH] (T-6.8080ms): compiled input
</span></span><span><span>27</span><span>    [BENCH] (bc=500002|globals=250001)
</span></span><span><span>28</span><span>    [BENCH] (T-0.3440ms): ran vm
</span></span><span><span>29</span><span>    [BENCH] (T-3.5960ms): destroyed Nodes, vm and input
</span></span><span><span>30</span><span>
</span></span><span><span>31</span><span>New:
</span></span><span><span>32</span><span>
</span></span><span><span>33</span><span>    [BENCH] (T-0.0060ms): parsed arguments
</span></span><span><span>34</span><span>    [BENCH] (T-0.0410ms): read file to String
</span></span><span><span>35</span><span>    [BENCH] (T-13.8280ms): parsed input
</span></span><span><span>36</span><span>    [BENCH] (T-7.9410ms): compiled input
</span></span><span><span>37</span><span>    [BENCH] (bc=500002|globals=250001)
</span></span><span><span>38</span><span>    [BENCH] (T-0.3490ms): ran vm
</span></span><span><span>39</span><span>    [BENCH] (T-0.8280ms): destroyed Nodes, vm and input</span></span></code></pre></div></div><h2 id="hashing-everything">Hashing everything</h2><p>I want to distinguish atoms (strings, numbers, idents) from other atoms for
interning purposes and faster comparisons in the pipeline. This can be done via
hashes, especially since we already “visit” each member of said atoms while
converting them to tokens. Hashing them is therefore just a matter of
computations while walking the atoms underlying bytes.</p><p>For instance strings: before this, the lexer just advanced until it hit the closing delimitor or EOF:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>size_t</span> <span>Lexer_all</span>(Lexer <span>*</span>l, Allocator <span>*</span>a, Token <span>**</span>out) {
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span>    <span>// ...
</span></span></span><span><span> 4</span><span><span></span>
</span></span><span><span> 5</span><span><span>string</span>: {
</span></span><span><span> 6</span><span>  <span>// skip &#34;
</span></span></span><span><span> 7</span><span><span></span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span> 8</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span> 9</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> cc <span>!=</span> <span>&#39;&#34;&#39;</span>; l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {}
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>  <span>if</span> (<span>UNLIKELY</span>(<span>cur</span>(l) <span>!=</span> <span>&#39;&#34;&#39;</span>)) {
</span></span><span><span>12</span><span>    Str slice <span>=</span> <span>Str_slice</span>(<span>&amp;</span>l<span>-&gt;</span>input, l<span>-&gt;</span>pos, l<span>-&gt;</span>input.len);
</span></span><span><span>13</span><span>    <span>fprintf</span>(stderr, <span>&#34;lex: Unterminated string near: &#39;%.*s&#39;&#34;</span>, (<span>int</span>)slice.len,
</span></span><span><span>14</span><span>            slice.p);
</span></span><span><span>15</span><span>    out[count<span>++</span>] <span>=</span> INTERN_EOF;
</span></span><span><span>16</span><span>  } <span>else</span> {
</span></span><span><span>17</span><span>    Token <span>*</span>t <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>18</span><span>    t<span>-&gt;</span>type <span>=</span> T_STRING;
</span></span><span><span>19</span><span>    t<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>20</span><span>        .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>21</span><span>        .len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start,
</span></span><span><span>22</span><span>    };
</span></span><span><span>23</span><span>    out[count<span>++</span>] <span>=</span> t;
</span></span><span><span>24</span><span>    <span>// skip &#34;
</span></span></span><span><span>25</span><span><span></span>    l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>26</span><span>  }
</span></span><span><span>27</span><span>  JUMP_TARGET;
</span></span><span><span>28</span><span>}
</span></span><span><span>29</span><span>
</span></span><span><span>30</span><span>    <span>// ...
</span></span></span><span><span>31</span><span><span></span>
</span></span><span><span>32</span><span>}</span></span></code></pre></div><p>Adding hashing to this is fairly easy:</p><p><span>DIFF</span></p><div><pre tabindex="0"><code data-lang="diff"><span><span> 1</span><span><span>diff --git a/lexer.c b/lexer.c
</span></span></span><span><span> 2</span><span><span>index 316a494..2280a6b 100644
</span></span></span><span><span> 3</span><span><span></span><span>--- a/lexer.c
</span></span></span><span><span> 4</span><span><span></span><span>+++ b/lexer.c
</span></span></span><span><span> 5</span><span><span></span><span>@@ -286,10 +286,7 @@ string: {
</span></span></span><span><span> 6</span><span><span></span>   // skip &#34;
</span></span><span><span> 7</span><span>   l-&gt;pos++;
</span></span><span><span> 8</span><span>   size_t start = l-&gt;pos;
</span></span><span><span> 9</span><span><span>+  size_t hash = FNV_OFFSET_BASIS;
</span></span></span><span><span>10</span><span><span></span>   for (char cc = cur(l); cc &gt; 0 &amp;&amp; cc != &#39;&#34;&#39;; l-&gt;pos++, cc = cur(l)) {
</span></span><span><span>11</span><span><span>+    hash ^= cc;
</span></span></span><span><span>12</span><span><span>+    hash *= FNV_PRIME;
</span></span></span><span><span>13</span><span><span></span>   }
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>   if (UNLIKELY(cur(l) != &#39;&#34;&#39;)) {
</span></span><span><span>16</span><span><span>@@ -303,7 +300,6 @@ string: {
</span></span></span><span><span>17</span><span><span></span>     t-&gt;string = (Str){
</span></span><span><span>18</span><span>         .p = l-&gt;input.p + start,
</span></span><span><span>19</span><span>         .len = l-&gt;pos - start,
</span></span><span><span>20</span><span><span>+        .hash = hash,
</span></span></span><span><span>21</span><span><span></span>     };
</span></span><span><span>22</span><span>     out[count++] = t;
</span></span><span><span>23</span><span>     // skip &#34;
</span></span></code></pre></div><p>Numbers, identifiers and builtins are all also being hashed, I omitted this
here for clearity and since we will revisit this topic again in this article.</p><h2 id="interning-tokens">Interning Tokens</h2><p>Most of the tokens we will encounter are constant, we know:</p><ul><li>their size</li><li>their type</li></ul><p>We can use this knowledge, statically allocate these and use their pointers to
reduce memory pressure:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// we can &#34;intern&#34; these, since all of them are the same, regardless of position
</span></span></span><span><span> 2</span><span><span></span>Token <span>*</span>INTERN_DELIMITOR_LEFT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_DELIMITOR_LEFT);
</span></span><span><span> 3</span><span>Token <span>*</span>INTERN_DELIMITOR_RIGHT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_DELIMITOR_RIGHT);
</span></span><span><span> 4</span><span>Token <span>*</span>INTERN_BRAKET_LEFT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_BRAKET_LEFT);
</span></span><span><span> 5</span><span>Token <span>*</span>INTERN_BRAKET_RIGHT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_BRAKET_RIGHT);
</span></span><span><span> 6</span><span>Token <span>*</span>INTERN_MINUS <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_MINUS);
</span></span><span><span> 7</span><span>Token <span>*</span>INTERN_PLUS <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_PLUS);
</span></span><span><span> 8</span><span>Token <span>*</span>INTERN_ASTERISKS <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_ASTERISKS);
</span></span><span><span> 9</span><span>Token <span>*</span>INTERN_SLASH <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_SLASH);
</span></span><span><span>10</span><span>Token <span>*</span>INTERN_FALSE <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_FALSE);
</span></span><span><span>11</span><span>Token <span>*</span>INTERN_TRUE <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_TRUE);
</span></span><span><span>12</span><span>Token <span>*</span>INTERN_EQUAL <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_EQUAL);
</span></span><span><span>13</span><span>Token <span>*</span>INTERN_EOF <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_EOF);
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span><span>// size_t Lexer_all(Lexer *l, Allocator *a, Token **out)
</span></span></span></code></pre></div><p><code>SINGLE_TOK</code> is just:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>#define SINGLE_TOK(t) ((Token){.type = t})</span></span></span></code></pre></div><h2 id="prehashing-keywords-for-comparisons">Prehashing keywords for comparisons</h2><p>As introduced in the previous chapters, all identifers are hashed, thus we can
also hash the known keywords at startup and make comparing them very fast.</p><p>Lets take a look at <code>true</code> and <code>false</code>, both are known keywords and we will
need to compare found identifers to them.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>ident</span>: {
</span></span><span><span> 2</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span> 3</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span> 4</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>is_alphanum</span>(cc); l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {
</span></span><span><span> 5</span><span>    hash <span>^=</span> cc;
</span></span><span><span> 6</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span> 7</span><span>  }
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>  <span>size_t</span> len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start;
</span></span><span><span>10</span><span>  Token <span>*</span>t;
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>  <span>// comparing to the keywords is now just a number comparison
</span></span></span><span><span>13</span><span><span></span>  <span>if</span> (hash <span>==</span> true_hash) {
</span></span><span><span>14</span><span>    t <span>=</span> INTERN_TRUE;
</span></span><span><span>15</span><span>  } <span>else</span> <span>if</span> (hash <span>==</span> false_hash) {
</span></span><span><span>16</span><span>    t <span>=</span> INTERN_FALSE;
</span></span><span><span>17</span><span>  } <span>else</span> {
</span></span><span><span>18</span><span>    t <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>19</span><span>    t<span>-&gt;</span>type <span>=</span> T_IDENT;
</span></span><span><span>20</span><span>    t<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>21</span><span>        .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>22</span><span>        .len <span>=</span> len,
</span></span><span><span>23</span><span>        .hash <span>=</span> hash,
</span></span><span><span>24</span><span>    };
</span></span><span><span>25</span><span>  }
</span></span><span><span>26</span><span>  out[count<span>++</span>] <span>=</span> t;
</span></span><span><span>27</span><span>  JUMP_TARGET;
</span></span><span><span>28</span><span>}</span></span></code></pre></div><p>Both <code>true_hash</code> and <code>false_hash</code> are computed at startup of <code>Lexer_all</code>:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>size_t</span> <span>Lexer_all</span>(Lexer <span>*</span>l, Allocator <span>*</span>a, Token <span>**</span>out) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(out <span>!=</span> NULL, <span>&#34;Failed to allocate token list&#34;</span>);
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>  <span>// empty input
</span></span></span><span><span> 5</span><span><span></span>  <span>if</span> (l<span>-&gt;</span>input.len <span>==</span> <span>0</span>) {
</span></span><span><span> 6</span><span>    out[<span>0</span>] <span>=</span> INTERN_EOF;
</span></span><span><span> 7</span><span>    <span>return</span> <span>1</span>;
</span></span><span><span> 8</span><span>  }
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span>  <span>size_t</span> true_hash <span>=</span> <span>Str_hash</span>(<span>&amp;</span><span>STRING</span>(<span>&#34;true&#34;</span>));
</span></span><span><span>11</span><span>  <span>size_t</span> false_hash <span>=</span> <span>Str_hash</span>(<span>&amp;</span><span>STRING</span>(<span>&#34;false&#34;</span>));
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>  <span>// [...]
</span></span></span><span><span>14</span><span><span></span>}</span></span></code></pre></div><div id="callout"><h3>Tip - is_alphanum performance deep dive</h3><blockquote><p>I know this function shouldn’t be called <code>is_alphanum</code> because it allows <code>[A-Za-z0-9_-]</code></p></blockquote><p>A naive check of <code>is_alphanum</code> can be:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>bool</span> <span>is_alphanum</span>(<span>char</span> cc) {
</span></span><span><span>2</span><span>    <span>return</span> (cc <span>&gt;=</span> <span>&#39;a&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;z&#39;</span>) <span>||</span> (cc <span>&gt;=</span> <span>&#39;A&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;Z&#39;</span>)
</span></span><span><span>3</span><span>        <span>||</span> (cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>) <span>||</span> cc <span>==</span> <span>&#39;_&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>
</span></span><span><span>4</span><span>}</span></span></code></pre></div><p>We know we can omit the uppercase check by converting the character to its
lowercase representation, so lets fold the character, since ASCII upper and
lowercase characters only differ by a single bit:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>bool</span> <span>is_alphanum</span>(<span>char</span> cc) {
</span></span><span><span>2</span><span>  <span>uint8_t</span> lower <span>=</span> cc <span>|</span> <span>0x20</span>;
</span></span><span><span>3</span><span>  <span>bool</span> is_alpha <span>=</span> (lower <span>&gt;=</span> <span>&#39;a&#39;</span> <span>&amp;&amp;</span> lower <span>&lt;=</span> <span>&#39;z&#39;</span>);
</span></span><span><span>4</span><span>  <span>bool</span> is_digit <span>=</span> (cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>);
</span></span><span><span>5</span><span>  <span>return</span> is_alpha <span>||</span> is_digit <span>||</span> cc <span>==</span> <span>&#39;_&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>;
</span></span><span><span>6</span><span>}</span></span></code></pre></div><p>In benchmarks I was able to measure <code>inline</code> and parameter type <code>uint8_t</code> have a
reproducible impact of reducing the runtime by 1-5% for identifier heavy
inputs, so I marked the function as “private” <code>static inline</code>:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>__attribute__</span>((always_inline)) <span>inline</span> <span>static</span> <span>bool</span> <span>is_alphanum</span>(<span>uint8_t</span> cc) {
</span></span><span><span>2</span><span>  <span>uint8_t</span> lower <span>=</span> cc <span>|</span> <span>0x20</span>;
</span></span><span><span>3</span><span>  <span>bool</span> is_alpha <span>=</span> (lower <span>&gt;=</span> <span>&#39;a&#39;</span> <span>&amp;&amp;</span> lower <span>&lt;=</span> <span>&#39;z&#39;</span>);
</span></span><span><span>4</span><span>  <span>bool</span> is_digit <span>=</span> (cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>);
</span></span><span><span>5</span><span>  <span>return</span> is_alpha <span>||</span> is_digit <span>||</span> cc <span>==</span> <span>&#39;_&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>;
</span></span><span><span>6</span><span>}</span></span></code></pre></div><p>There are some other ways that could be more efficient, but I haven’t benchmarked these:</p><ol><li><p>statically allocated lookup table like:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>const</span> <span>bool</span> is_alphanum_lookup[<span>128</span>] <span>=</span> {
</span></span><span><span> 2</span><span>    [<span>&#39;0&#39;</span> ... <span>&#39;9&#39;</span>] <span>=</span> true,
</span></span><span><span> 3</span><span>    [<span>&#39;A&#39;</span> ... <span>&#39;Z&#39;</span>] <span>=</span> true,
</span></span><span><span> 4</span><span>    [<span>&#39;a&#39;</span> ... <span>&#39;z&#39;</span>] <span>=</span> true,
</span></span><span><span> 5</span><span>    [<span>&#39;_&#39;</span>] <span>=</span> true,
</span></span><span><span> 6</span><span>    [<span>&#39;-&#39;</span>] <span>=</span> true,
</span></span><span><span> 7</span><span>};
</span></span><span><span> 8</span><span><span>__attribute__</span>((always_inline)) <span>inline</span> <span>static</span> <span>bool</span> <span>is_alphanum</span>(<span>uint8_t</span> cc) {
</span></span><span><span> 9</span><span>    <span>return</span> cc <span>&lt;</span> <span>128</span> <span>&amp;&amp;</span> is_alphanum_lookup[cc];
</span></span><span><span>10</span><span>}</span></span></code></pre></div></li><li><p>weird bit sets:</p><blockquote><p>I don’t fully understand this one and it sucks to read, so no thanks</p></blockquote><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>static</span> <span>const</span> <span>uint64_t</span> table1 <span>=</span> <span>0x03ff000000000000</span>
</span></span><span><span>2</span><span><span>static</span> <span>const</span> <span>uint64_t</span> table2 <span>=</span> <span>0x07fffffe07fffffe</span>
</span></span><span><span>3</span><span>
</span></span><span><span>4</span><span> <span>__attribute__</span>((always_inline)) <span>inline</span> <span>static</span> <span>bool</span> <span>is_alphanum</span>(<span>uint8_t</span> cc) {
</span></span><span><span>5</span><span>    <span>if</span> (cc <span>&gt;=</span> <span>128</span>) <span>return</span> false;
</span></span><span><span>6</span><span>    <span>return</span> cc <span>&lt;</span> <span>64</span> <span>?</span> (table1 <span>&gt;&gt;</span> cc) <span>&amp;</span> <span>1</span> <span>:</span> (table2 <span>&gt;&gt;</span> (cc <span>-</span> <span>64</span>)) <span>&amp;</span> <span>1</span>;
</span></span><span><span>7</span><span>}</span></span></code></pre></div></li></ol></div><h2 id="on-demand-double-and-int64_t-parsing">On demand double and int64_t parsing</h2><p>Let’s revisit hashing numbers: as introduced before, all atoms are hashed,
therefore I am able to use this hash for and while interning. This way the
compiler converts all duplicated integers and doubles into their numerical
representation only once (in the compiler).</p><p>The lexer therefore only needs to store the window of the atoms input. While
verifying all characters in this window are valid arguments for <code>Str_to_double</code>
and <code>Str_to_int64_t</code>. In a later chapter I’ll show the compiler doing on demand
parsing with the token we created here in the lexer.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>number</span>: {
</span></span><span><span> 2</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span> 3</span><span>  <span>size_t</span> i <span>=</span> start;
</span></span><span><span> 4</span><span>  <span>bool</span> is_double <span>=</span> false;
</span></span><span><span> 5</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span> 6</span><span>  <span>for</span> (; i <span>&lt;</span> l<span>-&gt;</span>input.len; i<span>++</span>) {
</span></span><span><span> 7</span><span>    <span>char</span> cc <span>=</span> l<span>-&gt;</span>input.p[i];
</span></span><span><span> 8</span><span>    hash <span>^=</span> cc;
</span></span><span><span> 9</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span>10</span><span>    <span>if</span> (cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>)
</span></span><span><span>11</span><span>      <span>continue</span>;
</span></span><span><span>12</span><span>    <span>if</span> (cc <span>==</span> <span>&#39;.&#39;</span>) {
</span></span><span><span>13</span><span>      <span>ASSERT</span>(<span>!</span>is_double, <span>&#34;Two dots in double&#34;</span>);
</span></span><span><span>14</span><span>      is_double <span>=</span> true;
</span></span><span><span>15</span><span>      <span>continue</span>;
</span></span><span><span>16</span><span>    }
</span></span><span><span>17</span><span>    <span>break</span>;
</span></span><span><span>18</span><span>  }
</span></span><span><span>19</span><span>
</span></span><span><span>20</span><span>  l<span>-&gt;</span>pos <span>=</span> i;
</span></span><span><span>21</span><span>  Token <span>*</span>n <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>22</span><span>  n<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>23</span><span>      .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>24</span><span>      .len <span>=</span> i <span>-</span> start,
</span></span><span><span>25</span><span>      .hash <span>=</span> hash,
</span></span><span><span>26</span><span>  };
</span></span><span><span>27</span><span>  <span>if</span> (is_double) {
</span></span><span><span>28</span><span>    n<span>-&gt;</span>type <span>=</span> T_DOUBLE;
</span></span><span><span>29</span><span>  } <span>else</span> {
</span></span><span><span>30</span><span>    n<span>-&gt;</span>type <span>=</span> T_INTEGER;
</span></span><span><span>31</span><span>  }
</span></span><span><span>32</span><span>
</span></span><span><span>33</span><span>  out[count<span>++</span>] <span>=</span> n;
</span></span><span><span>34</span><span>  JUMP_TARGET;
</span></span><span><span>35</span><span>}</span></span></code></pre></div><p>Normaly one would consume a file in C by</p><ol><li>open file descriptor: <code>fopen</code></li><li>fread the buffer into a malloced space</li><li>zero terminate</li><li>close file: <code>fclose</code></li></ol><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// https://stackoverflow.com/questions/14002954/c-how-to-read-an-entire-file-into-a-buffer
</span></span></span><span><span> 2</span><span><span></span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span> 3</span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span> 4</span><span><span></span>
</span></span><span><span> 5</span><span><span>int</span> <span>main</span>(<span>void</span>) {
</span></span><span><span> 6</span><span>    FILE <span>*</span>f <span>=</span> <span>fopen</span>(<span>&#34;textfile.txt&#34;</span>, <span>&#34;rb&#34;</span>);
</span></span><span><span> 7</span><span>    <span>fseek</span>(f, <span>0</span>, SEEK_END);
</span></span><span><span> 8</span><span>    <span>long</span> fsize <span>=</span> <span>ftell</span>(f);
</span></span><span><span> 9</span><span>    <span>fseek</span>(f, <span>0</span>, SEEK_SET);
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>    <span>char</span> <span>*</span>string <span>=</span> <span>malloc</span>(fsize <span>+</span> <span>1</span>);
</span></span><span><span>12</span><span>    <span>fread</span>(string, fsize, <span>1</span>, f);
</span></span><span><span>13</span><span>    <span>fclose</span>(f);
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>    string[fsize] <span>=</span> <span>0</span>;
</span></span><span><span>16</span><span>    <span>free</span>(string);
</span></span><span><span>17</span><span>    <span>return</span> EXIT_SUCCESS;
</span></span><span><span>18</span><span>}</span></span></code></pre></div><p>However, you can also do the whole thing a lot faster by instructing the kernel
to dump the whole file into our virtual memory via
<a href="https://www.man7.org/linux/man-pages/man3/mmap.3p.html"><code>mmap</code></a> (Just not
walking a file two times is already faster).</p><p>After opening the file (opening a file with <code>O_RDONLY</code> and mapping it with
<code>PROT_READ</code> can be faster than making it mutable), we need it’s type (we dont’t
want to open or dump a directory) and it’s size (the api wants a mapping block
size). <a href="https://www.man7.org/linux/man-pages/man3/fstat.3p.html"><code>fstat</code></a> helps
us with filling a struct with meta data containing exactly the info we need:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// taken from https://www.commandlinux.com/man-page/man2/fstat.2.html
</span></span></span><span><span> 2</span><span><span></span><span>struct</span> stat {
</span></span><span><span> 3</span><span>    <span>dev_t</span>     st_dev;     <span>/* ID of device containing file */</span>
</span></span><span><span> 4</span><span>    <span>ino_t</span>     st_ino;     <span>/* inode number */</span>
</span></span><span><span> 5</span><span>    <span>mode_t</span>    st_mode;    <span>/* protection */</span>
</span></span><span><span> 6</span><span>    <span>nlink_t</span>   st_nlink;   <span>/* number of hard links */</span>
</span></span><span><span> 7</span><span>    <span>uid_t</span>     st_uid;     <span>/* user ID of owner */</span>
</span></span><span><span> 8</span><span>    <span>gid_t</span>     st_gid;     <span>/* group ID of owner */</span>
</span></span><span><span> 9</span><span>    <span>dev_t</span>     st_rdev;    <span>/* device ID (if special file) */</span>
</span></span><span><span>10</span><span>    <span>off_t</span>     st_size;    <span>/* total size, in bytes */</span>
</span></span><span><span>11</span><span>    <span>blksize_t</span> st_blksize; <span>/* blocksize for file system I/O */</span>
</span></span><span><span>12</span><span>    <span>blkcnt_t</span>  st_blocks;  <span>/* number of 512B blocks allocated */</span>
</span></span><span><span>13</span><span>    <span>time_t</span>    st_atime;   <span>/* time of last access */</span>
</span></span><span><span>14</span><span>    <span>time_t</span>    st_mtime;   <span>/* time of last modification */</span>
</span></span><span><span>15</span><span>    <span>time_t</span>    st_ctime;   <span>/* time of last status change */</span>
</span></span><span><span>16</span><span>};</span></span></code></pre></div><p>I use
<a href="https://www.gnu.org/software/libc/manual/html_node/Testing-File-Type.html#index-S_005fISREG"><code>S_ISREG</code></a>:
to check if the handled is a regular file. After mmapping with the size stored
in <code>stat.st_size</code> I do a bookkeeping, see the combined snippet below:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>#include</span> <span>&lt;fcntl.h&gt;</span><span>
</span></span></span><span><span> 2</span><span><span>#include</span> <span>&lt;sys/mman.h&gt;</span><span>
</span></span></span><span><span> 3</span><span><span>#include</span> <span>&lt;sys/stat.h&gt;</span><span>
</span></span></span><span><span> 4</span><span><span>#include</span> <span>&lt;unistd.h&gt;</span><span>
</span></span></span><span><span> 5</span><span><span></span>
</span></span><span><span> 6</span><span><span>#include</span> <span>&#34;common.h&#34;</span><span>
</span></span></span><span><span> 7</span><span><span>#include</span> <span>&#34;io.h&#34;</span><span>
</span></span></span><span><span> 8</span><span><span></span>
</span></span><span><span> 9</span><span>Str <span>IO_read_file_to_string</span>(<span>char</span> <span>*</span>path) {
</span></span><span><span>10</span><span>  <span>ASSERT</span>(path <span>!=</span> NULL, <span>&#34;path was NULL&#34;</span>);
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>  <span>int</span> fd <span>=</span> <span>open</span>(path, O_RDONLY);
</span></span><span><span>13</span><span>  <span>ASSERT</span>(fd <span>!=</span> <span>-</span><span>1</span>, <span>&#34;failed to open input file&#34;</span>);
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>  <span>struct</span> stat s;
</span></span><span><span>16</span><span>  <span>fstat</span>(fd, <span>&amp;</span>s);
</span></span><span><span>17</span><span>  <span>ASSERT</span>(<span>S_ISREG</span>(s.st_mode), <span>&#34;path is not a file&#34;</span>);
</span></span><span><span>18</span><span>
</span></span><span><span>19</span><span>  <span>long</span> length <span>=</span> s.st_size;
</span></span><span><span>20</span><span>  <span>if</span> (length <span>&lt;</span> <span>0</span>) {
</span></span><span><span>21</span><span>    <span>close</span>(fd);
</span></span><span><span>22</span><span>    <span>ASSERT</span>(length <span>&gt;</span> <span>0</span>, <span>&#34;input is empty&#34;</span>)
</span></span><span><span>23</span><span>  }
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>  <span>char</span> <span>*</span>buffer <span>=</span> <span>0</span>;
</span></span><span><span>26</span><span>  <span>if</span> (length <span>!=</span> <span>0</span>) {
</span></span><span><span>27</span><span>    buffer <span>=</span> <span>mmap</span>(NULL, length, PROT_READ, MAP_PRIVATE, fd, <span>0</span>);
</span></span><span><span>28</span><span>  }
</span></span><span><span>29</span><span>
</span></span><span><span>30</span><span>  <span>ASSERT</span>(<span>close</span>(fd) <span>==</span> <span>0</span>, <span>&#34;failed to close file&#34;</span>);
</span></span><span><span>31</span><span>  <span>ASSERT</span>(buffer <span>!=</span> MAP_FAILED, <span>&#34;failed to mmap input&#34;</span>)
</span></span><span><span>32</span><span>  <span>return</span> (Str){.len <span>=</span> length, .p <span>=</span> (<span>const</span> <span>uint8_t</span> <span>*</span>)buffer};
</span></span><span><span>33</span><span>}</span></span></code></pre></div><div id="callout"><h3>Info - Benchmarks</h3><p>In my benchmark this made the stage before even starting lexing 6x-35x
faster, see
<a href="https://github.com/xNaCly/purple-garden/commit/a2cae881e8d1668d82b918b2554465c0f510e3e0"><code>a2cae88</code></a>:</p><p><em>Please excuse the ugly debug info, I have reworked this till then. Also,
lexing and parsing was a single stage back then.</em></p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>io: use mmap to make IO_read_file_to_string 6x-35x faster
</span></span><span><span> 2</span><span>For 5k lines with 4 atoms each (20k atoms), the initial string read was
</span></span><span><span> 3</span><span>reduced from 0.4390ms to 0.0730ms (6x faster):
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>Old:
</span></span><span><span> 6</span><span>    [BENCH] (T-0.1620ms): parsed arguments
</span></span><span><span> 7</span><span>    [BENCH] (T-0.4390ms): read file to String
</span></span><span><span> 8</span><span>    [BENCH] (T-10.2020ms): parsed input
</span></span><span><span> 9</span><span>    [BENCH] (T-1.2820ms): compiled input
</span></span><span><span>10</span><span>    [BENCH] (bc=40008|globals=20004)
</span></span><span><span>11</span><span>    [BENCH] (T-0.1620ms): ran vm
</span></span><span><span>12</span><span>    [BENCH] (T-0.6190ms): destroyed Nodes, vm and input
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span>New:
</span></span><span><span>15</span><span>    [BENCH] (T-0.1510ms): parsed arguments
</span></span><span><span>16</span><span>    [BENCH] (T-0.0730ms): read file to String
</span></span><span><span>17</span><span>    [BENCH] (T-10.1350ms): parsed input
</span></span><span><span>18</span><span>    [BENCH] (T-1.3210ms): compiled input
</span></span><span><span>19</span><span>    [BENCH] (bc=40008|globals=20004)
</span></span><span><span>20</span><span>    [BENCH] (T-0.1710ms): ran vm
</span></span><span><span>21</span><span>    [BENCH] (T-0.6460ms): destroyed Nodes, vm and input
</span></span><span><span>22</span><span>
</span></span><span><span>23</span><span>For larger files, such as 250k lines with 4 atoms each (1mio atoms), the
</span></span><span><span>24</span><span>initial string read was reduced from 3.472ms to 0.0980ms (35x faster):
</span></span><span><span>25</span><span>
</span></span><span><span>26</span><span>Old:
</span></span><span><span>27</span><span>    [BENCH] (T-0.1430ms): parsed arguments
</span></span><span><span>28</span><span>    [BENCH] (T-3.4720ms): read file to String
</span></span><span><span>29</span><span>    [BENCH] (T-434.8770ms): parsed input
</span></span><span><span>30</span><span>    [BENCH] (T-30.7538ms): compiled input
</span></span><span><span>31</span><span>    [BENCH] (bc=2040408|globals=1020204)
</span></span><span><span>32</span><span>    [BENCH] (T-7.5610ms): ran vm
</span></span><span><span>33</span><span>    [BENCH] (T-37.2170ms): destroyed Nodes, vm and input
</span></span><span><span>34</span><span>
</span></span><span><span>35</span><span>New:
</span></span><span><span>36</span><span>    [BENCH] (T-0.1490ms): parsed arguments
</span></span><span><span>37</span><span>    [BENCH] (T-0.0980ms): read file to String
</span></span><span><span>38</span><span>    [BENCH] (T-437.4770ms): parsed input
</span></span><span><span>39</span><span>    [BENCH] (T-30.8820ms): compiled input
</span></span><span><span>40</span><span>    [BENCH] (bc=2040408|globals=1020204)
</span></span><span><span>41</span><span>    [BENCH] (T-7.4540ms): ran vm
</span></span><span><span>42</span><span>    [BENCH] (T-36.9500ms): destroyed Nodes, vm and input</span></span></code></pre></div></div><p>As introduced in <a href="#on-demand-double-and-int64_t-parsing">On demand double and int64_t
parsing</a>, the lexer does not perform
string to numerical conversions, but rather stores a hash and a window of said
string. The compiler converts any tokens with this hash only once and refers
any duplicates to the global pool index of this number.</p><blockquote><p>The compiler itself will probably be the topic of a future blog article, but I kept it simple at this time.</p></blockquote><p><code>token_to_value</code> is called for all unique (not encountered before and thus not interned) atoms:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// token_to_value converts tokens, such as strings, idents and numbers to
</span></span></span><span><span> 2</span><span><span>// runtime values
</span></span></span><span><span> 3</span><span><span></span><span>inline</span> <span>static</span> Value <span>*</span><span>token_to_value</span>(Token <span>*</span>t, Allocator <span>*</span>a) {
</span></span><span><span> 4</span><span>  Value <span>*</span>v <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Value));
</span></span><span><span> 5</span><span>  <span>switch</span> (t<span>-&gt;</span>type) {
</span></span><span><span> 6</span><span>  <span>case</span> <span>T_STRING</span>:
</span></span><span><span> 7</span><span>  <span>case</span> <span>T_IDENT</span>:
</span></span><span><span> 8</span><span>    v<span>-&gt;</span>type <span>=</span> V_STR;
</span></span><span><span> 9</span><span>    v<span>-&gt;</span>string <span>=</span> t<span>-&gt;</span>string;
</span></span><span><span>10</span><span>    <span>break</span>;
</span></span><span><span>11</span><span>  <span>case</span> <span>T_INTEGER</span>:
</span></span><span><span>12</span><span>    v<span>-&gt;</span>type <span>=</span> V_INT;
</span></span><span><span>13</span><span>    v<span>-&gt;</span>integer <span>=</span> <span>Str_to_int64_t</span>(<span>&amp;</span>t<span>-&gt;</span>string);
</span></span><span><span>14</span><span>    <span>break</span>;
</span></span><span><span>15</span><span>  <span>case</span> <span>T_DOUBLE</span>:
</span></span><span><span>16</span><span>    v<span>-&gt;</span>type <span>=</span> V_DOUBLE;
</span></span><span><span>17</span><span>    v<span>-&gt;</span>floating <span>=</span> <span>Str_to_double</span>(<span>&amp;</span>t<span>-&gt;</span>string);
</span></span><span><span>18</span><span>    <span>break</span>;
</span></span><span><span>19</span><span>  <span>default</span><span>:</span>
</span></span><span><span>20</span><span>    <span>ASSERT</span>(<span>0</span>, <span>&#34;Unsupported value for token_to_value&#34;</span>);
</span></span><span><span>21</span><span>    <span>break</span>;
</span></span><span><span>22</span><span>  }
</span></span><span><span>23</span><span>  <span>return</span> v;
</span></span><span><span>24</span><span>}</span></span></code></pre></div><p>Note the missing cases for <code>T_FALSE</code> and <code>T_TRUE</code>? They are omitted, because
there are hard coded entries <code>0</code> and <code>1</code> in the global pool (<code>@None</code> is the
same, its bound to index <code>2</code>).</p><div id="callout"><h3>Info - Benchmarks</h3><p>This resulted in crazy 15ms/64% faster total runtime results for number and
duplicate heavy test inputs, see
<a href="https://github.com/xNaCly/purple-garden/commit/a55a19050d0a496123a27492c5bd9c674221a322"><code>a55a190</code></a>.</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>lexer+cc: move Str_to_(double|int64_t) parsing from lexer to cc
</span></span><span><span> 2</span><span>This change omits all integer and number parsing from the pipeline but
</span></span><span><span> 3</span><span>the first occurence of each unique integer or number by storing a hash
</span></span><span><span> 4</span><span>of the string representation of said values. At the interning stage in
</span></span><span><span> 5</span><span>the compiler only the first occurence of any hash of a double or integer
</span></span><span><span> 6</span><span>is parsed via Str_to_int64_t or Str_to_double, which reduces the
</span></span><span><span> 7</span><span>theoretically workload for any duplicated number of integers and doubles
</span></span><span><span> 8</span><span>from N to 1.
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span>For a double and integer heavy benchmark (250k loc with 250k duplicated
</span></span><span><span>11</span><span>doubles and integers) results in:
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>    - 15ms faster
</span></span><span><span>14</span><span>    - 64% faster
</span></span><span><span>15</span><span>    - ~2.8x faster
</span></span><span><span>16</span><span>
</span></span><span><span>17</span><span>Prev commit:
</span></span><span><span>18</span><span>    ./build/bench +V examples/bench.garden
</span></span><span><span>19</span><span>    [    0.0000ms] main::Args_parse: Parsed arguments
</span></span><span><span>20</span><span>    [    0.0120ms] io::IO_read_file_to_string: mmaped input of size=2500090B
</span></span><span><span>21</span><span>    [    0.0050ms] mem::init: Allocated memory block of size=153092096B
</span></span><span><span>22</span><span>    [   23.8300ms] lexer::Lexer_all: lexed tokens count=1000033
</span></span><span><span>23</span><span>    [   12.5190ms] parser::Parser_next created AST with node_count=250003
</span></span><span><span>24</span><span>    [    9.2090ms] cc::cc: Flattened AST to byte code/global pool length=1500048/4
</span></span><span><span>25</span><span>    [   36.3060ms] vm::Vm_run: executed byte code
</span></span><span><span>26</span><span>    [    0.3730ms] mem::Allocator::destroy: Deallocated memory space
</span></span><span><span>27</span><span>    [    0.0410ms] vm::Vm_destroy: teared vm down
</span></span><span><span>28</span><span>    [    0.0000ms] munmap: unmapped input
</span></span><span><span>29</span><span>
</span></span><span><span>30</span><span>New:
</span></span><span><span>31</span><span>    ./build/bench +V examples/bench.garden
</span></span><span><span>32</span><span>    [    0.0000ms] main::Args_parse: Parsed arguments
</span></span><span><span>33</span><span>    [    0.0170ms] io::IO_read_file_to_string: mmaped input of size=2500090B
</span></span><span><span>34</span><span>    [    0.0060ms] mem::init: Allocated memory block of size=153092096B
</span></span><span><span>35</span><span>    [    8.5270ms] lexer::Lexer_all: lexed tokens count=1000033
</span></span><span><span>36</span><span>    [   12.2070ms] parser::Parser_next created AST with node_count=250003
</span></span><span><span>37</span><span>    [    9.4020ms] cc::cc: Flattened AST to byte code/global pool length=1500048/4
</span></span><span><span>38</span><span>    [   36.9900ms] vm::Vm_run: executed byte code
</span></span><span><span>39</span><span>    [    0.3960ms] mem::Allocator::destroy: Deallocated memory space
</span></span><span><span>40</span><span>    [    0.0480ms] vm::Vm_destroy: teared vm down
</span></span><span><span>41</span><span>    [    0.0010ms] munmap: unmapped input</span></span></code></pre></div></div><p>So I created, what i would consider a fairly heavy lexer benchmark:</p><p><span>SCHEME</span></p><div><pre tabindex="0"><code data-lang="scheme"><span><span> 1</span><span>(<span>@Some</span> (<span>@Some</span> (<span>@Some</span> (<span>@None</span>))))
</span></span><span><span> 2</span><span><span>true</span> <span>false</span> <span>true</span> <span>false</span>
</span></span><span><span> 3</span><span><span>3.1415</span> <span>22222222222</span> <span>.</span><span>12345</span>
</span></span><span><span> 4</span><span><span>&#34;string me this, string me that&#34;</span>
</span></span><span><span> 5</span><span><span>&#39;quoted-strings-is-a-must-do</span>
</span></span><span><span> 6</span><span>(<span>@let</span> <span>unquoted-strings-are-just-idents</span> (<span>@None</span>))
</span></span><span><span> 7</span><span><span>unquoted-strings-are-just-idents</span>
</span></span><span><span> 8</span><span>(<span>@None</span>) (<span>+</span>) (<span>-</span>) (<span>*</span>) (<span>/</span>) (<span>=</span>)
</span></span><span><span> 9</span><span><span>;; COMMENT COMMENT COMMENT</span>
</span></span><span><span>10</span><span><span>;; COMMENT COMMENT COMMENT</span>
</span></span><span><span>11</span><span><span>;; COMMENT COMMENT COMMENT with whitespace for 3 lines</span>
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span><span>;; whitespace end</span></span></span></code></pre></div><p>And I typed <code>VggyG66666p</code> to fill 1mio lines (<code>1000005</code>).</p><h2 id="on-a-laptop">On a Laptop</h2><p><span>Terminal</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>System:
</span></span><span><span>  Host: ************* Kernel: 6.11.0-28-generic arch: x86_64 bits: 64
</span></span><span><span>  Desktop: i3 v: 4.23 Distro: Ubuntu 24.04.2 LTS (Noble Numbat)
</span></span><span><span>Machine:
</span></span><span><span>  Type: Laptop System: LENOVO product: 21F8002TGE v: ThinkPad T14s Gen 4
</span></span><span><span>    serial: &lt;superuser required&gt;
</span></span><span><span>  Mobo: LENOVO model: 21F8002TGE v: SDK0T76530 WIN
</span></span><span><span>    serial: &lt;superuser required&gt; UEFI: LENOVO v: R2EET41W (1.22 )
</span></span><span><span>    date: 09/22/2024
</span></span><span><span>CPU:
</span></span><span><span>  Info: 8-core model: AMD Ryzen 7 PRO 7840U w/ Radeon 780M Graphics bits: 64
</span></span><span><span>    type: MT MCP cache: L2: 8 MiB
</span></span><span><span>  Speed (MHz): avg: 883 min/max: 400/5132 cores: 1: 1388 2: 400 3: 1396
</span></span><span><span>    4: 400 5: 400 6: 400 7: 1374 8: 400 9: 1331 10: 400 11: 1357 12: 400
</span></span><span><span>    13: 1357 14: 1346 15: 1393 16: 400
</span></span></code></pre></div><p>With the above components.</p><p><span>Terminal</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>./build/bench +V examples/bench.garden
</span></span><span><span>[    0.0000ms] main::Args_parse: Parsed arguments
</span></span><span><span>[    0.0150ms] io::IO_read_file_to_string: mmaped input of size=25466794B
</span></span><span><span>[    0.0060ms] mem::init: Allocated memory block of size=929537981B
</span></span><span><span>[   43.9190ms] lexer::Lexer_all: lexed tokens count=3133350
</span></span><span><span>[   48.8460ms] parser::Parser_next created AST with node_count=1200006
</span></span><span><span>[   18.2070ms] cc::cc: Flattened AST to byte code/global pool length=2666680/8
</span></span><span><span>[    8.9970ms] vm::Vm_run: executed byte code
</span></span><span><span>[   26.7470ms] mem::Allocator::destroy: Deallocated memory space
</span></span><span><span>[    1.0180ms] vm::Vm_destroy: teared vm down
</span></span><span><span>[    0.0000ms] munmap: unmapped input
</span></span></code></pre></div><p>I can confidently say I do a million lines or 25,466,794 Bytes in 44ms. Let’s do some math:</p><p>$$
\begin{align}
44 \textrm{ms} &amp;\triangleq 25,466,749 \mathrm{B} \\
1 \textrm{ms} &amp;\triangleq 578,789.75 \mathrm{B} \\
1000 \textrm{ms} &amp;\triangleq 578,789,750 \mathrm{B} \\
&amp;= \underline{578,79 \mathrm{MB}/\textrm{s}}
\end{align}
$$</p><p>In token:</p><p>$$
\begin{align}
44 \textrm{ms} &amp;\triangleq 3,133,350 \mathrm{T} \\
1 \textrm{ms} &amp;\triangleq 71212.5 \mathrm{T} \\
1000 \textrm{ms} &amp;\triangleq 71,212,500 \mathrm{T} \\
&amp;= \underline{71,212,500 \mathrm{T}/\textrm{s}}
\end{align}
$$</p><p>That’s pretty fast, but SIMD can probably do a lot better at this point.
However, I haven’t started that experiment yet.</p><h2 id="on-a-tower">On a Tower</h2><p><span>Terminal</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>System:
</span></span><span><span>  Host: comfyputer Kernel: 6.15.4-arch2-1 arch: x86_64
</span></span><span><span>    bits: 64
</span></span><span><span>  Desktop: i3 v: 4.24 Distro: Arch Linux
</span></span><span><span>Machine:
</span></span><span><span>  Type: Desktop Mobo: ASUSTeK model: PRIME B450-PLUS
</span></span><span><span>    v: Rev X.0x serial: &lt;superuser required&gt;
</span></span><span><span>    UEFI: American Megatrends v: 2008 date: 12/06/2019
</span></span><span><span>CPU:
</span></span><span><span>  Info: 8-core model: AMD Ryzen 7 3700X bits: 64
</span></span><span><span>    type: MT MCP cache: L2: 4 MiB
</span></span><span><span>  Speed (MHz): avg: 4052 min/max: 2200/4979 cores:
</span></span><span><span>    1: 4052 2: 4052 3: 4052 4: 4052 5: 4052 6: 4052
</span></span><span><span>    7: 4052 8: 4052 9: 4052 10: 4052 11: 4052 12: 4052
</span></span><span><span>    13: 4052 14: 4052 15: 4052 16: 4052
</span></span></code></pre></div><p>So we are around 14ms faster on my tower.</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>./build/bench +V examples/bench.garden
</span></span><span><span> 2</span><span>[    0.0000ms] main::Args_parse: Parsed arguments
</span></span><span><span> 3</span><span>[    0.0070ms] io::IO_read_file_to_string: mmaped input of size=25400127B
</span></span><span><span> 4</span><span>[    0.0030ms] mem::init: Allocated memory block of size=927104635B
</span></span><span><span> 5</span><span>[   30.9930ms] lexer::Lexer_all: lexed tokens count=3133350
</span></span><span><span> 6</span><span>[   22.6340ms] parser::Parser_next created AST with node_count=1200006
</span></span><span><span> 7</span><span>[   10.1480ms] cc::cc: Flattened AST to byte code/global pool length=2666680/8
</span></span><span><span> 8</span><span>[    7.4800ms] vm::Vm_run: executed byte code
</span></span><span><span> 9</span><span>[    0.7520ms] mem::Allocator::destroy: Deallocated memory space
</span></span><span><span>10</span><span>[    0.0620ms] vm::Vm_destroy: teared vm down
</span></span><span><span>11</span><span>[    0.0000ms] munmap: unmapped input</span></span></code></pre></div><p>The same math as above, just with 30ms instead of 44ms:</p><p>$$
\begin{align}
30 \textrm{ms} &amp;\triangleq 25,466,749 \mathrm{B} \\
1 \textrm{ms} &amp;\triangleq 848,891.633333 \mathrm{B} \\
1000 \textrm{ms} &amp;\triangleq 848,891,633.333 \mathrm{B} \\
&amp;= \underline{848.89 \mathrm{MB}/\textrm{s}}
\end{align}
$$</p><p>In token:</p><p>$$
\begin{align}
30 \textrm{ms} &amp;\triangleq 3,133,350 \mathrm{T} \\
1 \textrm{ms} &amp;\triangleq 104,445 \mathrm{T} \\
1000 \textrm{ms} &amp;\triangleq 104,445,000 \mathrm{T} \\
&amp;= \underline{104,445,000 \mathrm{T}/\textrm{s}}
\end{align}
$$</p><h2 id="benchmark-contexts">Benchmark contexts</h2><p>For a C input of 7.5 mio loc, which is of course more complex to tokenize then
my language, see <a href="https://nothings.org/computer/lexing.html"><em>Some Strategies For Fast Lexical Analysis when Parsing
Programming Languages</em></a>. The
following numbers are available and I added the performance the purple-garden
lexer has for 7.5mio lines lexer heavy benchmark inputs.</p><table><thead><tr><th>lexer</th><th>performance</th></tr></thead><tbody><tr><td>flex (default)</td><td>13.56 s</td></tr><tr><td>stb_lex (w/symbol hashing)</td><td>4.84 s</td></tr><tr><td>stb_lex</td><td>4.23 s</td></tr><tr><td>flex -F (fast)</td><td>3.07 s</td></tr><tr><td>flex -f (full)</td><td>2.92 s</td></tr><tr><td>handcoded</td><td>2.45 s</td></tr><tr><td>handcoded mmap</td><td>2.14 s</td></tr><tr><td>wc</td><td>1.73 s</td></tr><tr><td></td><td></td></tr><tr><td>purple-garden (laptop)</td><td>0.308s</td></tr><tr><td>purple-garden (tower)</td><td>0.150s</td></tr></tbody></table><p>A summary what I implemented in this article:</p><ul><li>Jump table for direct threading</li><li>0 copy and window based tokens</li><li>interned and stateless tokens</li><li>bump allocator for unique tokens</li><li>inline hashing for atoms that need it (strings, idents, numeric)</li><li>fast paths for true and false</li></ul><p>While 580-848 MB/s is already pretty fast, I want to go further, some things I have planned:</p><ul><li>use the absurd bit set based <code>is_alphanum</code> checks</li><li>use SIMD for comments and whitespace</li><li>use SIMD as a preprocessing step to find markers for tokens 16 bytes at a time</li><li>replace FNV-1a with a faster hashing algorithm, something like <a href="https://xxhash.com/">xxHash</a></li><li>prefetch some amount of bytes to reduce L1 &amp; L2 latency</li><li>mmap larger inputs with <code>MAP_HUGETLB</code></li><li>maybe align mmap to 64 byte boundaries for SIMD</li></ul><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>  1</span><span><span>#include</span> <span>&#34;lexer.h&#34;</span><span>
</span></span></span><span><span>  2</span><span><span>#include</span> <span>&#34;common.h&#34;</span><span>
</span></span></span><span><span>  3</span><span><span>#include</span> <span>&#34;mem.h&#34;</span><span>
</span></span></span><span><span>  4</span><span><span>#include</span> <span>&#34;strings.h&#34;</span><span>
</span></span></span><span><span>  5</span><span><span>#include</span> <span>&lt;stddef.h&gt;</span><span>
</span></span></span><span><span>  6</span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span>  7</span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span>  8</span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span>  9</span><span><span></span>
</span></span><span><span> 10</span><span><span>#define SINGLE_TOK(t) ((Token){.type = t})
</span></span></span><span><span> 11</span><span><span></span>
</span></span><span><span> 12</span><span>Str TOKEN_TYPE_MAP[] <span>=</span> {[T_DELIMITOR_LEFT] <span>=</span> <span>STRING</span>(<span>&#34;T_DELIMITOR_LEFT&#34;</span>),
</span></span><span><span> 13</span><span>                        [T_DELIMITOR_RIGHT] <span>=</span> <span>STRING</span>(<span>&#34;T_DELIMITOR_RIGHT&#34;</span>),
</span></span><span><span> 14</span><span>                        [T_BRAKET_LEFT] <span>=</span> <span>STRING</span>(<span>&#34;T_BRAKET_LEFT&#34;</span>),
</span></span><span><span> 15</span><span>                        [T_BRAKET_RIGHT] <span>=</span> <span>STRING</span>(<span>&#34;T_BRAKET_RIGHT&#34;</span>),
</span></span><span><span> 16</span><span>                        [T_STRING] <span>=</span> <span>STRING</span>(<span>&#34;T_STRING&#34;</span>),
</span></span><span><span> 17</span><span>                        [T_TRUE] <span>=</span> <span>STRING</span>(<span>&#34;T_TRUE&#34;</span>),
</span></span><span><span> 18</span><span>                        [T_FALSE] <span>=</span> <span>STRING</span>(<span>&#34;T_FALSE&#34;</span>),
</span></span><span><span> 19</span><span>                        [T_DOUBLE] <span>=</span> <span>STRING</span>(<span>&#34;T_DOUBLE&#34;</span>),
</span></span><span><span> 20</span><span>                        [T_INTEGER] <span>=</span> <span>STRING</span>(<span>&#34;T_INTEGER&#34;</span>),
</span></span><span><span> 21</span><span>                        [T_BUILTIN] <span>=</span> <span>STRING</span>(<span>&#34;T_BUILTIN&#34;</span>),
</span></span><span><span> 22</span><span>                        [T_IDENT] <span>=</span> <span>STRING</span>(<span>&#34;T_IDENT&#34;</span>),
</span></span><span><span> 23</span><span>                        [T_PLUS] <span>=</span> <span>STRING</span>(<span>&#34;T_PLUS&#34;</span>),
</span></span><span><span> 24</span><span>                        [T_MINUS] <span>=</span> <span>STRING</span>(<span>&#34;T_MINUS&#34;</span>),
</span></span><span><span> 25</span><span>                        [T_ASTERISKS] <span>=</span> <span>STRING</span>(<span>&#34;T_ASTERISKS&#34;</span>),
</span></span><span><span> 26</span><span>                        [T_SLASH] <span>=</span> <span>STRING</span>(<span>&#34;T_SLASH&#34;</span>),
</span></span><span><span> 27</span><span>                        [T_EQUAL] <span>=</span> <span>STRING</span>(<span>&#34;T_EQUAL&#34;</span>),
</span></span><span><span> 28</span><span>                        [T_EOF] <span>=</span> <span>STRING</span>(<span>&#34;T_EOF&#34;</span>)};
</span></span><span><span> 29</span><span>
</span></span><span><span> 30</span><span>Lexer <span>Lexer_new</span>(Str input) {
</span></span><span><span> 31</span><span>  <span>return</span> (Lexer){
</span></span><span><span> 32</span><span>      .input <span>=</span> input,
</span></span><span><span> 33</span><span>      .pos <span>=</span> <span>0</span>,
</span></span><span><span> 34</span><span>  };
</span></span><span><span> 35</span><span>}
</span></span><span><span> 36</span><span>
</span></span><span><span> 37</span><span><span>#define cur(L) (L-&gt;input.p[L-&gt;pos])
</span></span></span><span><span> 38</span><span><span></span>
</span></span><span><span> 39</span><span><span>__attribute__</span>((always_inline)) <span>inline</span> <span>static</span> <span>bool</span> <span>is_alphanum</span>(<span>uint8_t</span> cc) {
</span></span><span><span> 40</span><span>  <span>uint8_t</span> lower <span>=</span> cc <span>|</span> <span>0x20</span>;
</span></span><span><span> 41</span><span>  <span>bool</span> is_alpha <span>=</span> (lower <span>&gt;=</span> <span>&#39;a&#39;</span> <span>&amp;&amp;</span> lower <span>&lt;=</span> <span>&#39;z&#39;</span>);
</span></span><span><span> 42</span><span>  <span>bool</span> is_digit <span>=</span> (cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>);
</span></span><span><span> 43</span><span>  <span>return</span> is_alpha <span>||</span> is_digit <span>||</span> cc <span>==</span> <span>&#39;_&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>;
</span></span><span><span> 44</span><span>}
</span></span><span><span> 45</span><span>
</span></span><span><span> 46</span><span><span>// we can &#34;intern&#34; these, since all of them are the same, regardless of position
</span></span></span><span><span> 47</span><span><span></span>Token <span>*</span>INTERN_DELIMITOR_LEFT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_DELIMITOR_LEFT);
</span></span><span><span> 48</span><span>Token <span>*</span>INTERN_DELIMITOR_RIGHT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_DELIMITOR_RIGHT);
</span></span><span><span> 49</span><span>Token <span>*</span>INTERN_BRAKET_LEFT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_BRAKET_LEFT);
</span></span><span><span> 50</span><span>Token <span>*</span>INTERN_BRAKET_RIGHT <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_BRAKET_RIGHT);
</span></span><span><span> 51</span><span>Token <span>*</span>INTERN_MINUS <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_MINUS);
</span></span><span><span> 52</span><span>Token <span>*</span>INTERN_PLUS <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_PLUS);
</span></span><span><span> 53</span><span>Token <span>*</span>INTERN_ASTERISKS <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_ASTERISKS);
</span></span><span><span> 54</span><span>Token <span>*</span>INTERN_SLASH <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_SLASH);
</span></span><span><span> 55</span><span>Token <span>*</span>INTERN_FALSE <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_FALSE);
</span></span><span><span> 56</span><span>Token <span>*</span>INTERN_TRUE <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_TRUE);
</span></span><span><span> 57</span><span>Token <span>*</span>INTERN_EQUAL <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_EQUAL);
</span></span><span><span> 58</span><span>Token <span>*</span>INTERN_EOF <span>=</span> <span>&amp;</span><span>SINGLE_TOK</span>(T_EOF);
</span></span><span><span> 59</span><span>
</span></span><span><span> 60</span><span><span>size_t</span> <span>Lexer_all</span>(Lexer <span>*</span>l, Allocator <span>*</span>a, Token <span>**</span>out) {
</span></span><span><span> 61</span><span>  <span>ASSERT</span>(out <span>!=</span> NULL, <span>&#34;Failed to allocate token list&#34;</span>);
</span></span><span><span> 62</span><span>
</span></span><span><span> 63</span><span>  <span>// empty input
</span></span></span><span><span> 64</span><span><span></span>  <span>if</span> (l<span>-&gt;</span>input.len <span>==</span> <span>0</span>) {
</span></span><span><span> 65</span><span>    out[<span>0</span>] <span>=</span> INTERN_EOF;
</span></span><span><span> 66</span><span>    <span>return</span> <span>1</span>;
</span></span><span><span> 67</span><span>  }
</span></span><span><span> 68</span><span>
</span></span><span><span> 69</span><span>  <span>size_t</span> true_hash <span>=</span> <span>Str_hash</span>(<span>&amp;</span><span>STRING</span>(<span>&#34;true&#34;</span>));
</span></span><span><span> 70</span><span>  <span>size_t</span> false_hash <span>=</span> <span>Str_hash</span>(<span>&amp;</span><span>STRING</span>(<span>&#34;false&#34;</span>));
</span></span><span><span> 71</span><span>
</span></span><span><span> 72</span><span>  <span>size_t</span> count <span>=</span> <span>0</span>;
</span></span><span><span> 73</span><span>  <span>static</span> <span>void</span> <span>*</span>jump_table[<span>256</span>] <span>=</span> {
</span></span><span><span> 74</span><span>      [<span>0</span> ... <span>255</span>] <span>=</span> <span>&amp;&amp;</span>unknown,
</span></span><span><span> 75</span><span>      [<span>&#39; &#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span> 76</span><span>      [<span>&#39;\t&#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span> 77</span><span>      [<span>&#39;\n&#39;</span>] <span>=</span> <span>&amp;&amp;</span>whitespace,
</span></span><span><span> 78</span><span>      [<span>&#39;;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>comment,
</span></span><span><span> 79</span><span>      [<span>&#39;(&#39;</span>] <span>=</span> <span>&amp;&amp;</span>delimitor_left,
</span></span><span><span> 80</span><span>      [<span>&#39;)&#39;</span>] <span>=</span> <span>&amp;&amp;</span>delimitor_right,
</span></span><span><span> 81</span><span>      [<span>&#39;@&#39;</span>] <span>=</span> <span>&amp;&amp;</span>builtin,
</span></span><span><span> 82</span><span>      [<span>&#39;.&#39;</span>] <span>=</span> <span>&amp;&amp;</span>number,
</span></span><span><span> 83</span><span>      [<span>&#39;0&#39;</span> ... <span>&#39;9&#39;</span>] <span>=</span> <span>&amp;&amp;</span>number,
</span></span><span><span> 84</span><span>      [<span>&#39;a&#39;</span> ... <span>&#39;z&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span> 85</span><span>      [<span>&#39;A&#39;</span> ... <span>&#39;Z&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span> 86</span><span>      [<span>&#39;_&#39;</span>] <span>=</span> <span>&amp;&amp;</span>ident,
</span></span><span><span> 87</span><span>      [<span>&#39;\&#39;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>quoted,
</span></span><span><span> 88</span><span>      [<span>&#39;&#34;&#39;</span>] <span>=</span> <span>&amp;&amp;</span>string,
</span></span><span><span> 89</span><span>      [<span>&#39;+&#39;</span>] <span>=</span> <span>&amp;&amp;</span>plus,
</span></span><span><span> 90</span><span>      [<span>&#39;-&#39;</span>] <span>=</span> <span>&amp;&amp;</span>minus,
</span></span><span><span> 91</span><span>      [<span>&#39;/&#39;</span>] <span>=</span> <span>&amp;&amp;</span>slash,
</span></span><span><span> 92</span><span>      [<span>&#39;*&#39;</span>] <span>=</span> <span>&amp;&amp;</span>asterisks,
</span></span><span><span> 93</span><span>      [<span>&#39;=&#39;</span>] <span>=</span> <span>&amp;&amp;</span>equal,
</span></span><span><span> 94</span><span>      [<span>&#39;[&#39;</span>] <span>=</span> <span>&amp;&amp;</span>braket_left,
</span></span><span><span> 95</span><span>      [<span>&#39;]&#39;</span>] <span>=</span> <span>&amp;&amp;</span>braket_right,
</span></span><span><span> 96</span><span>      [<span>0</span>] <span>=</span> <span>&amp;&amp;</span>end,
</span></span><span><span> 97</span><span>  };
</span></span><span><span> 98</span><span>
</span></span><span><span> 99</span><span><span>#define JUMP_TARGET goto *jump_table[(int32_t)l-&gt;input.p[l-&gt;pos]]
</span></span></span><span><span>100</span><span><span></span>
</span></span><span><span>101</span><span>  JUMP_TARGET;
</span></span><span><span>102</span><span>
</span></span><span><span>103</span><span><span>delimitor_left</span>:
</span></span><span><span>104</span><span>  out[count<span>++</span>] <span>=</span> INTERN_DELIMITOR_LEFT;
</span></span><span><span>105</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>106</span><span>  JUMP_TARGET;
</span></span><span><span>107</span><span>
</span></span><span><span>108</span><span><span>delimitor_right</span>:
</span></span><span><span>109</span><span>  out[count<span>++</span>] <span>=</span> INTERN_DELIMITOR_RIGHT;
</span></span><span><span>110</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>111</span><span>  JUMP_TARGET;
</span></span><span><span>112</span><span>
</span></span><span><span>113</span><span><span>braket_left</span>:
</span></span><span><span>114</span><span>  out[count<span>++</span>] <span>=</span> INTERN_BRAKET_LEFT;
</span></span><span><span>115</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>116</span><span>  JUMP_TARGET;
</span></span><span><span>117</span><span>
</span></span><span><span>118</span><span><span>braket_right</span>:
</span></span><span><span>119</span><span>  out[count<span>++</span>] <span>=</span> INTERN_BRAKET_RIGHT;
</span></span><span><span>120</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>121</span><span>  JUMP_TARGET;
</span></span><span><span>122</span><span>
</span></span><span><span>123</span><span><span>builtin</span>: {
</span></span><span><span>124</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>125</span><span>  <span>// not an ident after @, this is shit
</span></span></span><span><span>126</span><span><span></span>  <span>if</span> (<span>!</span><span>is_alphanum</span>(<span>cur</span>(l))) {
</span></span><span><span>127</span><span>    out[count<span>++</span>] <span>=</span> INTERN_EOF;
</span></span><span><span>128</span><span>  }
</span></span><span><span>129</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span>130</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span>131</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>is_alphanum</span>(cc); l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {
</span></span><span><span>132</span><span>    hash <span>^=</span> cc;
</span></span><span><span>133</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span>134</span><span>  }
</span></span><span><span>135</span><span>
</span></span><span><span>136</span><span>  <span>size_t</span> len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start;
</span></span><span><span>137</span><span>  Str s <span>=</span> (Str){
</span></span><span><span>138</span><span>      .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>139</span><span>      .len <span>=</span> len,
</span></span><span><span>140</span><span>      .hash <span>=</span> hash,
</span></span><span><span>141</span><span>  };
</span></span><span><span>142</span><span>  Token <span>*</span>b <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>143</span><span>  b<span>-&gt;</span>string <span>=</span> s;
</span></span><span><span>144</span><span>  b<span>-&gt;</span>type <span>=</span> T_BUILTIN;
</span></span><span><span>145</span><span>  out[count<span>++</span>] <span>=</span> b;
</span></span><span><span>146</span><span>  JUMP_TARGET;
</span></span><span><span>147</span><span>}
</span></span><span><span>148</span><span>
</span></span><span><span>149</span><span><span>plus</span>:
</span></span><span><span>150</span><span>  out[count<span>++</span>] <span>=</span> INTERN_PLUS;
</span></span><span><span>151</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>152</span><span>  JUMP_TARGET;
</span></span><span><span>153</span><span>
</span></span><span><span>154</span><span><span>minus</span>:
</span></span><span><span>155</span><span>  out[count<span>++</span>] <span>=</span> INTERN_MINUS;
</span></span><span><span>156</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>157</span><span>  JUMP_TARGET;
</span></span><span><span>158</span><span>
</span></span><span><span>159</span><span><span>slash</span>:
</span></span><span><span>160</span><span>  out[count<span>++</span>] <span>=</span> INTERN_SLASH;
</span></span><span><span>161</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>162</span><span>  JUMP_TARGET;
</span></span><span><span>163</span><span>
</span></span><span><span>164</span><span><span>equal</span>:
</span></span><span><span>165</span><span>  out[count<span>++</span>] <span>=</span> INTERN_EQUAL;
</span></span><span><span>166</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>167</span><span>  JUMP_TARGET;
</span></span><span><span>168</span><span>
</span></span><span><span>169</span><span><span>asterisks</span>:
</span></span><span><span>170</span><span>  out[count<span>++</span>] <span>=</span> INTERN_ASTERISKS;
</span></span><span><span>171</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>172</span><span>  JUMP_TARGET;
</span></span><span><span>173</span><span>
</span></span><span><span>174</span><span><span>number</span>: {
</span></span><span><span>175</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span>176</span><span>  <span>size_t</span> i <span>=</span> start;
</span></span><span><span>177</span><span>  <span>bool</span> is_double <span>=</span> false;
</span></span><span><span>178</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span>179</span><span>  <span>for</span> (; i <span>&lt;</span> l<span>-&gt;</span>input.len; i<span>++</span>) {
</span></span><span><span>180</span><span>    <span>char</span> cc <span>=</span> l<span>-&gt;</span>input.p[i];
</span></span><span><span>181</span><span>    hash <span>^=</span> cc;
</span></span><span><span>182</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span>183</span><span>    <span>if</span> (cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>)
</span></span><span><span>184</span><span>      <span>continue</span>;
</span></span><span><span>185</span><span>    <span>if</span> (cc <span>==</span> <span>&#39;.&#39;</span>) {
</span></span><span><span>186</span><span>      <span>ASSERT</span>(<span>!</span>is_double, <span>&#34;Two dots in double&#34;</span>);
</span></span><span><span>187</span><span>      is_double <span>=</span> true;
</span></span><span><span>188</span><span>      <span>continue</span>;
</span></span><span><span>189</span><span>    }
</span></span><span><span>190</span><span>    <span>break</span>;
</span></span><span><span>191</span><span>  }
</span></span><span><span>192</span><span>
</span></span><span><span>193</span><span>  l<span>-&gt;</span>pos <span>=</span> i;
</span></span><span><span>194</span><span>  Token <span>*</span>n <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>195</span><span>  n<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>196</span><span>      .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>197</span><span>      .len <span>=</span> i <span>-</span> start,
</span></span><span><span>198</span><span>      .hash <span>=</span> hash,
</span></span><span><span>199</span><span>  };
</span></span><span><span>200</span><span>  <span>if</span> (is_double) {
</span></span><span><span>201</span><span>    n<span>-&gt;</span>type <span>=</span> T_DOUBLE;
</span></span><span><span>202</span><span>  } <span>else</span> {
</span></span><span><span>203</span><span>    n<span>-&gt;</span>type <span>=</span> T_INTEGER;
</span></span><span><span>204</span><span>  }
</span></span><span><span>205</span><span>
</span></span><span><span>206</span><span>  out[count<span>++</span>] <span>=</span> n;
</span></span><span><span>207</span><span>  JUMP_TARGET;
</span></span><span><span>208</span><span>}
</span></span><span><span>209</span><span>
</span></span><span><span>210</span><span><span>ident</span>: {
</span></span><span><span>211</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span>212</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span>213</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>is_alphanum</span>(cc); l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {
</span></span><span><span>214</span><span>    hash <span>^=</span> cc;
</span></span><span><span>215</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span>216</span><span>  }
</span></span><span><span>217</span><span>
</span></span><span><span>218</span><span>  <span>size_t</span> len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start;
</span></span><span><span>219</span><span>  Token <span>*</span>t;
</span></span><span><span>220</span><span>  <span>if</span> (hash <span>==</span> true_hash) {
</span></span><span><span>221</span><span>    t <span>=</span> INTERN_TRUE;
</span></span><span><span>222</span><span>  } <span>else</span> <span>if</span> (hash <span>==</span> false_hash) {
</span></span><span><span>223</span><span>    t <span>=</span> INTERN_FALSE;
</span></span><span><span>224</span><span>  } <span>else</span> {
</span></span><span><span>225</span><span>    t <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>226</span><span>    t<span>-&gt;</span>type <span>=</span> T_IDENT;
</span></span><span><span>227</span><span>    t<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>228</span><span>        .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>229</span><span>        .len <span>=</span> len,
</span></span><span><span>230</span><span>        .hash <span>=</span> hash,
</span></span><span><span>231</span><span>    };
</span></span><span><span>232</span><span>  }
</span></span><span><span>233</span><span>  out[count<span>++</span>] <span>=</span> t;
</span></span><span><span>234</span><span>  JUMP_TARGET;
</span></span><span><span>235</span><span>}
</span></span><span><span>236</span><span>
</span></span><span><span>237</span><span><span>// same as string but only with leading &#39;
</span></span></span><span><span>238</span><span><span></span><span>quoted</span>: {
</span></span><span><span>239</span><span>  <span>// skip &#39;
</span></span></span><span><span>240</span><span><span></span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>241</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span>242</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span>243</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>is_alphanum</span>(cc); l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {
</span></span><span><span>244</span><span>    hash <span>^=</span> cc;
</span></span><span><span>245</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span>246</span><span>  }
</span></span><span><span>247</span><span>
</span></span><span><span>248</span><span>  <span>size_t</span> len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start;
</span></span><span><span>249</span><span>  Token <span>*</span>t;
</span></span><span><span>250</span><span>  t <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>251</span><span>  t<span>-&gt;</span>type <span>=</span> T_STRING;
</span></span><span><span>252</span><span>  t<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>253</span><span>      .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>254</span><span>      .len <span>=</span> len,
</span></span><span><span>255</span><span>      .hash <span>=</span> hash,
</span></span><span><span>256</span><span>  };
</span></span><span><span>257</span><span>  out[count<span>++</span>] <span>=</span> t;
</span></span><span><span>258</span><span>  JUMP_TARGET;
</span></span><span><span>259</span><span>}
</span></span><span><span>260</span><span>
</span></span><span><span>261</span><span><span>string</span>: {
</span></span><span><span>262</span><span>  <span>// skip &#34;
</span></span></span><span><span>263</span><span><span></span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>264</span><span>  <span>size_t</span> start <span>=</span> l<span>-&gt;</span>pos;
</span></span><span><span>265</span><span>  <span>size_t</span> hash <span>=</span> FNV_OFFSET_BASIS;
</span></span><span><span>266</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> cc <span>!=</span> <span>&#39;&#34;&#39;</span>; l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {
</span></span><span><span>267</span><span>    hash <span>^=</span> cc;
</span></span><span><span>268</span><span>    hash <span>*=</span> FNV_PRIME;
</span></span><span><span>269</span><span>  }
</span></span><span><span>270</span><span>
</span></span><span><span>271</span><span>  <span>if</span> (<span>UNLIKELY</span>(<span>cur</span>(l) <span>!=</span> <span>&#39;&#34;&#39;</span>)) {
</span></span><span><span>272</span><span>    Str slice <span>=</span> <span>Str_slice</span>(<span>&amp;</span>l<span>-&gt;</span>input, l<span>-&gt;</span>pos, l<span>-&gt;</span>input.len);
</span></span><span><span>273</span><span>    <span>fprintf</span>(stderr, <span>&#34;lex: Unterminated string near: &#39;%.*s&#39;&#34;</span>, (<span>int</span>)slice.len,
</span></span><span><span>274</span><span>            slice.p);
</span></span><span><span>275</span><span>    out[count<span>++</span>] <span>=</span> INTERN_EOF;
</span></span><span><span>276</span><span>  } <span>else</span> {
</span></span><span><span>277</span><span>    Token <span>*</span>t <span>=</span> <span>CALL</span>(a, request, <span>sizeof</span>(Token));
</span></span><span><span>278</span><span>    t<span>-&gt;</span>type <span>=</span> T_STRING;
</span></span><span><span>279</span><span>    t<span>-&gt;</span>string <span>=</span> (Str){
</span></span><span><span>280</span><span>        .p <span>=</span> l<span>-&gt;</span>input.p <span>+</span> start,
</span></span><span><span>281</span><span>        .len <span>=</span> l<span>-&gt;</span>pos <span>-</span> start,
</span></span><span><span>282</span><span>        .hash <span>=</span> hash,
</span></span><span><span>283</span><span>    };
</span></span><span><span>284</span><span>    out[count<span>++</span>] <span>=</span> t;
</span></span><span><span>285</span><span>    <span>// skip &#34;
</span></span></span><span><span>286</span><span><span></span>    l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>287</span><span>  }
</span></span><span><span>288</span><span>  JUMP_TARGET;
</span></span><span><span>289</span><span>}
</span></span><span><span>290</span><span>
</span></span><span><span>291</span><span><span>comment</span>:
</span></span><span><span>292</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> <span>cur</span>(l); cc <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> cc <span>!=</span> <span>&#39;\n&#39;</span>; l<span>-&gt;</span>pos<span>++</span>, cc <span>=</span> <span>cur</span>(l)) {
</span></span><span><span>293</span><span>  }
</span></span><span><span>294</span><span>  JUMP_TARGET;
</span></span><span><span>295</span><span>
</span></span><span><span>296</span><span><span>whitespace</span>:
</span></span><span><span>297</span><span>  l<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>298</span><span>  JUMP_TARGET;
</span></span><span><span>299</span><span>
</span></span><span><span>300</span><span><span>unknown</span>: {
</span></span><span><span>301</span><span>  <span>uint8_t</span> c <span>=</span> <span>cur</span>(l);
</span></span><span><span>302</span><span>  <span>ASSERT</span>(<span>0</span>, <span>&#34;Unexpected byte &#39;%c&#39; (0x%X) in input&#34;</span>, c, c)
</span></span><span><span>303</span><span>}
</span></span><span><span>304</span><span>
</span></span><span><span>305</span><span><span>end</span>:
</span></span><span><span>306</span><span>  out[count<span>++</span>] <span>=</span> INTERN_EOF;
</span></span><span><span>307</span><span>  <span>return</span> count;
</span></span><span><span>308</span><span>}
</span></span><span><span>309</span><span>
</span></span><span><span>310</span><span><span>#undef SINGLE_TOK</span></span></span></code></pre></div><p>Thank you for reading this far. If you have any suggestions or feedback, feel
free to send me an email at <a href="mailto:contact@xnacly.me">contact@xnacly.me</a> or:</p><blockquote><p><code>contact@xnacly.me</code></p></blockquote></div></div>
  </body>
</html>
