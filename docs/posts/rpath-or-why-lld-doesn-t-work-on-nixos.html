<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io//2022/03/14/rpath-or-why-lld-doesnt-work-on-nixos.html">Original</a>
    <h1>Rpath, or why lld doesn’t work on NixOS</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Ok, what’s now?
Now, let’s understand why the first example, with <code>ld</code> rather than <code>lld</code>, can’t work :-)</p>
<p>As a reminder, we use NixOS, so there’s no global folder a-la <code>/usr/lib</code> where all shared libraries are stored.
Coming back to our <code>pkgconfig</code> example,</p>
<div>
<div>
<pre><code data-lang="bash"><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>$ </span>pkg-config <span>--libs</span> libevdev
<span>-L</span>/nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib <span>-levdev</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>the <code>libevdev.so</code> is well-hidden behind the hash.
So we need a <code>pkg-config</code> binary at compile time to get from <code>libevdev</code> name to actual location.</p>
<p>However, as this is a dynamic library, we need it not only during compilation, but during runtime as well.
And at runtime loader (also known as dynamic linker (its binary name is something like <code>ld-linux-x86-64.so</code>, but despite the <code>.so</code> suffix, it’s an executable (I kid you not, this stuff is indeed this confusing))) loads the executable together with shared libraries required by it.
Normally, the loader looks for libraries in well-known locations, like the aforementioned <code>/usr/lib</code> or <code>LD_LIBRARY_PATH</code>.
So we need <em>something</em> which would tell the loader that <code>libevdev</code> lives at <code>/nix/store/$HASH/lib</code>.</p>
<p>That something is rpath (also known as RUNPATH) — this is more or less <code>LD_LIBRARY_PATH</code>, just hard-coded into the executable.
We can use <code>readelf</code> to inspect program’s rpath.</p>
<p>When the binary is linked with the default linker, the result is as follows (lightly edited for clarity):</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre>λ readelf -d target/debug/examples/evtest | rg PATH
 0x000000000000001d (RUNPATH)            Library runpath: [
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib64
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib
    /nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib
    /nix/store/z56jcx3j1gfyk4sv7g8iaan0ssbdkhz1-glibc-2.33-56/lib
    /nix/store/c9f15p1kwm0mw5p13wsnvd1ixrhbhb12-gcc-10.3.0-lib/lib
]
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>And sure, we see path to <code>libevdev</code> right there!</p>
<p>With <code>rustflags = [&#34;-Clink-arg=-fuse-ld=lld&#34;]</code>, the result is different, the library is missing from rpath:</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre>0x000000000000001d (RUNPATH)            Library runpath: [
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib64
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib
]
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>At this point, I think we know what’s going on.
To recap:</p>
<div>
<ul>
<li>
<p>With both <code>ld</code> and <code>lld</code>, we don’t have problems at compile time, because <code>pkg-config</code> helps the compiler to find the library.</p>
</li>
<li>
<p>At runtime, the library linked with <code>lld</code> fails to find the shared library, while the one linked with <code>ld</code> works.</p>
</li>
<li>
<p>The difference between the two binaries is the value of rpath in the binary itself.
<code>ld</code> somehow manages to include rpath which contains path to the library.
This rpath is what allows the loader to locate the library at runtime.</p>
</li>
</ul>
</div>
<p>Curious observation: dynamic linking on NixOS is not <em>entirely</em> dynamic.
Because executables expect to find shared libraries in specific locations marked with hashes of the libraries themselves, it’s not possible to <em>just</em> upgrade <code>.so</code> on disk for all the binaries to pick it up.</p>
</div></div>
  </body>
</html>
