<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aws.amazon.com/blogs/aws/announcing-aws-lambda-function-urls-built-in-https-endpoints-for-single-function-microservices/">Original</a>
    <h1>AWS Lambda Function URLs: Built-In HTTPS Endpoints for Lambda</h1>
    
    <div id="readability-page-1" class="page"><section property="articleBody"> 
       <div id="amazon-polly-audio-tab"> 
            
            
            
           <p><a href="https://aws.amazon.com/polly/" target="_blank" rel="noopener noreferrer"><img src="https://a0.awsstatic.com/aws-blog/images/Voiced_by_Amazon_Polly_EN.png" width="554" height="56"/></a> 
           </p> </div> 
       <p>Organizations are adopting microservices architectures to build resilient and scalable applications using <a href="https://aws.amazon.com/lambda/">AWS Lambda</a>. These applications are composed of multiple serverless functions that implement the business logic. Each function is mapped to API endpoints, methods, and resources using services such as <a href="http://aws.amazon.com/apigateway">Amazon API Gateway</a> and <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html" title="alb">Application Load Balancer</a>.</p> 
       <p>But sometimes all you need is a simple way to configure an HTTPS endpoint in front of your function without having to learn, configure, and operate additional services besides Lambda. For example, you might need to implement a webhook handler or a simple form validator that runs within an individual Lambda function.</p> 
       <p>Today, I’m happy to announce the general availability of Lambda Function URLs, a new feature that lets you add HTTPS endpoints to any Lambda function and optionally configure <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing (CORS) headers</a>.</p> 
       <p>This lets you focus on what matters while we take care of configuring and monitoring a highly available, scalable, and secure HTTPS service.</p> 
       <p><span><strong>How Lambda Function URLs Work</strong></span></p> 
       <p>For example, if you map a function URL to your <code>$LATEST</code> version, each code update will be available immediately via the function URL. On the other hand, I’d recommend mapping a function URL to an alias, so you can safely deploy new versions, perform some integration tests, and then update the alias when you’re ready. This also lets you implement <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">weighted traffic shifting</a> and <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/automating-updates-to-serverless-apps.html">safe deployments</a>.</p> 
       <p>Function URLs are natively supported by the Lambda API, and you can start using it via the <a href="https://console.aws.amazon.com">AWS Management Console</a> or <a href="https://aws.amazon.com/tools/">AWS SDKs</a>, as well as infrastructure as code(IaC) tools such as <a href="https://aws.amazon.com/cloudformation/">AWS CloudFormation</a>, <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html">AWS SAM</a>, or <a href="https://aws.amazon.com/cdk/">AWS Cloud Development Kit (AWS CDK)</a>.</p> 
       <p><span><strong>Lambda Function URLs in Action</strong></span></p> 
       <p>When creating a new function, I check <strong>Enable function URL</strong> in <strong>Advanced Settings</strong>.</p> 
       <p>Here, I select Auth type: <strong>AWS_IAM</strong> or <strong>NONE</strong>. My webhook will use custom authorization logic based on a signature provided in the HTTP headers. Therefore, I’ll choose AuthType None, which means Lambda won’t check for any AWS IAM Sigv4 signatures before invoking my function. Instead, I’ll extract and validate a custom header in my function handler for authorization.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2022/03/30/lambda-url-create-function-1024x470.png" alt="AWS Lambda URLs - Create Function" width="1024" height="470"/></p> 
       <p>Please note that when using AuthType None, my function’s resource-based policy must still explicitly allow for public access. Otherwise, unauthenticated requests will be rejected. You can add permissions programmatically using the <em>AddPermission</em> API. In this case, the Lambda console automatically adds the necessary policy for me, as the IAM role I’m using is authorized to call the <em>AddPermission</em> API in my account.</p> 
       <p>With one click, I can also enable CORS. The default CORS configuration will allow all origins. Then, I’ll add more granular controls after creating the function. In case you’re not familiar with CORS, it’s a header-based security mechanism implemented by browsers to make sure that only certain hosts are allowed to load resources and invoke APIs. If a website is allowed to consume your API, you’ll need to include a few CORS headers that declare which origins, methods, and custom headers are allowed. The new function URLs take care of it for you, so you don’t have to implement all of this in your Lambda handler.</p> 
       <p>A few seconds later, the function URL is available. I can also easily find and copy it in the Lambda console.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2022/03/30/lambda-url-console-1024x321.png" alt="AWS Lambda URLs - Console URL" width="1024" height="321"/></p> 
       <p>The function code that handles my webhook in Node.js looks like this:</p> 
       <pre><code>exports.handler = async (event) =&gt; {
    
    // (optional) fetch method and querystring
    const method = event.requestContext.http.method;
    const queryParam = event.queryStringParameters.myCustomParameter;
    console.log(`Received ${method} request with ${queryParam}`)
    
    // retrieve signature and payload
    const webhookSignature = event.headers.SignatureHeader;
    const webhookPayload = JSON.parse(event.body);
    
    try {
        validateSignature(webhookSignature); // throws if invalid signature
        handleEvent(webhookPayload); // throws if processing error
    } catch (error) {
        console.error(error)
        return {
            statusCode: 400,
            body: `Cannot process event: ${error}`,
        }
    }

    return {
        statusCode: 200, // default value
        body: JSON.stringify({
            received: true,
        }),
    };
};
</code></pre> 
       <p>The code is extracting a few parameters from the request headers, query string, and body. If you’re already familiar with the event structure provided by API Gateway or Application Load Balancer, this should look very familiar.</p> 
       <p>After updating the code, I decide to test the function URL with an HTTP client.</p> 
       <p>For example, here’s how I’d do it with <code>curl</code>:</p> 
       <pre><code>$ curl &#34;https://4iykoi7jk2kp5hhd5irhbdprn40yxest.lambda-url.us-west-2.on.aws/?myCustomParameter=squirrel&#34;
    -X POST
    -H &#34;SignatureHeader: XYZ&#34;
    -H &#34;Content-type: application/json&#34;
    -d &#39;{&#34;type&#34;: &#34;payment-succeeded&#34;}&#39;</code></pre> 
       <p>Or with a Python script:</p> 
       <pre><code>import json
import requests

url = &#34;https://4iykoi7jk2kp5hhd5irhbdprn40yxest.lambda-url.us-west-2.on.aws/&#34;
headers = {&#39;SignatureHeader&#39;: &#39;XYZ&#39;, &#39;Content-type&#39;: &#39;application/json&#39;}
payload = json.dumps({&#39;type&#39;: &#39;payment-succeeded&#39;})
querystring = {&#39;myCustomParameter&#39;: &#39;squirrel&#39;}

r = requests.post(url=url, params=querystring, data=payload, headers=headers)
print(r.json())</code></pre> 
       <p>Don’t forget to set the request’s <code>Content-type</code> to <code>application/json</code> or <code>text/*</code> in your tests, otherwise, the body will be base64-encoded by default, and you’ll need to decode it in the Lambda handler.</p> 
       <p>Of course, in this case we’re talking about a webhook, so this function will receive requests directly from the external system that I’m integrating with. I only need to provide them with the public function URL and start receiving events.</p> 
       <p>For this specific use case, I don’t need any CORS configuration. In other cases where the function URL is called from the browser, I’d need to configure a few more CORS parameters such as <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, and <code>Access-Control-Expose-Headers</code>. I can easily review and edit these CORS parameters in the Lambda console or in my IaC templates. Here’s what it looks like in the console:</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2022/03/30/lambda-url-cors-1-1024x457.png" alt="AWS Lambda URLs - CORS" width="1024" height="457"/></p> 
       <p>Also, keep in mind that each function URL is unique and mapped to a specific alias or the <code>$LATEST</code> version of your function. This lets you define multiple URLs for the same function. For example, you can define one for testing the <code>$LATEST</code> version during development and one for each stage or alias, such as <code>staging</code>, <code>production</code>, and so on.</p> 
       <p><span><strong>Support for Infrastructure as Code (IaC)</strong></span></p> 
       <p>For example, here’s how to define a Lambda function and its public URL with AWS SAM, including the alias mapping:</p> 
       <pre><code>WebhookFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: webhook/
      Handler: index.handler
      Runtime: nodejs14.x
      AutoPublishAlias: live
      FunctionUrlConfig:
        AuthType: NONE
        Cors:
            AllowOrigins:
                - &#34;https://example.com&#34;</code></pre> 
       <p>If you have existing Lambda functions in your IaC templates, you can define a new function URL with a few lines of code.</p> 
       <p><span><strong>Function URL Pricing</strong></span></p> 
       <p><span><strong>When to use Function URLs vs. Amazon API Gateway</strong></span></p> 
       <p><a href="http://aws.amazon.com/apigateway">Amazon API Gateway</a> is a fully managed service that makes it easy for you to create, publish, maintain, monitor, and secure APIs at any scale. Use API Gateway to take advantage of capabilities like JWT/custom authorizers, request/response validation and transformation, usage plans, built-in AWS WAF support, and so on.</p> 
       <p><span><strong>Generally Available Today</strong></span></p> 
       <p>I’m looking forward to hearing how you’re using this new functionality to simplify your serverless architectures, especially in single-function use cases where you want to keep things simple and cost-optimized.</p> 
       <p><a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-urls.html">Check out the new Lambda Function URLs documentation</a>.</p> 
       <p>— <a href="https://twitter.com/alex_casalboni">Alex</a></p> 
       <!-- '"` --> 
      </section></div>
  </body>
</html>
