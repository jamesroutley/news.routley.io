<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://op-co.de/blog/posts/samsung_wb850f_firmware/">Original</a>
    <h1>Samsung WB850F Firmware Reverse Engineering</h1>
    
    <div id="readability-page-1" class="page"><div class="page">









<div id="pagebody">

<div id="content" role="main">
<p><span>Georg Lukas, <span>2024-05-24 17:30</span></span></p>
<p>Samsung&#39;s <a href="https://news.samsung.com/global/ces-2012-cameras-for-any-situation-with-wi-fi-and-long-zoom">WB850F compact camera</a>
was the first model to combine the DRIMeIII SoC with WiFi. Together with the
EX2F it features an uncompressed firmware binary where Samsung helpfully added
a <code>partialImage.o.map</code> file with a full linker dump and all symbol names into
the firmware ZIP. We are using this gift to reverse-engineer the main SoC
firmware, so that we can make it pass the WiFi hotspot detection and use
<a href="https://github.com/ge0rg/samsung-nx-emailservice">samsung-nx-emailservice</a>.</p>

<p>This is a follow-up to the
<a href="http://iafisher.com/blog/posts/samsung_wifi_cameras/">Samsung WiFi cameras</a>
article and part of the <a href="http://iafisher.com/blog/tags/samsung-nx/">Samsung NX series</a>.</p>




<h2><a name="index1h2"></a><code>WB850F_FW_210086.zip</code> - the outer container</h2>

<p>The WB850F is one of the few models where Samsung still publishes
<a href="https://www.samsung.com/at/support/model/EC-WB850FBPBE3/">firmware and support files</a>
after discontinuing the iLauncher application.</p>

<p>The <code>WB850F_FW_210086.zip</code> archive we can get there contains quite a few files
(as identified by <code>file</code>):</p>

<div><pre>GPS_FW<span>/</span>BASEBAND_FW_Flash.mbin<span>:</span> data
GPS_FW<span>/</span>BASEBAND_FW_Ram.mbin<span>:</span>   data
GPS_FW<span>/</span>Config.BIN<span>:</span>             data
GPS_FW<span>/</span>flashBurner.mbin<span>:</span>       data
FWUP<span>:</span>                          ASCII text<span>,</span> with CRLF line terminators
partialImage.o.map<span>:</span>            ASCII text
WB850-FW-SR-210086.bin<span>:</span>        data
wb850f_adj.txt<span>:</span>                ASCII text<span>,</span> with CRLF line terminators
</pre></div>


<p>The <code>FWUP</code> file just contains the string <code>upgrade all</code> which is a script for
the firmware testing/automation module. The <code>wb850f_adj.txt</code> file is a similar
but more complex script to upgrade the GPS firmware and delete the respective
files. Let&#39;s skip the GPS-related script and <code>GPS_FW</code> folder for now.</p>

<h3><a name="index1h3"></a><code>partialImage.o.map</code> - the linker dump</h3>

<p>The <code>partialImage.o.map</code> is a text file with &gt;300k lines, containing the
linker output for <code>partialImage.o</code>, including a full memory map of the linked
file:</p>

<div><pre>output          input           virtual
section         section         address         size     <span>file</span>

.text                           <span>00000000        01301444</span>
                .text           <span>00000000        000001</span>a4 sysALib.o
                             <span>$a</span> <span>00000000        00000000</span>
                        sysInit <span>00000000        00000000</span>
                   L<span>$_Good_Boot</span> <span>00000090        00000000</span>
                    archPwrDown <span>00000094   00000000</span>
...
           DevHTTPResponseStart <span>00321</span>a84        <span>000002</span>a4
            DevHTTPResponseData <span>00321</span>d28        <span>00000100</span>
             DevHTTPResponseEnd <span>00321</span>e28        <span>00000170</span>
...
.data                           <span>00000000        004</span>ed40c
                .data           <span>00000000        00000874</span> sysLib.o
                         sysBus <span>00000000        00000004</span>
                         sysCpu <span>00000004        00000004</span> 
                    sysBootLine <span>00000008        00000004</span>
</pre></div>


<p>This goes on and on and on, and it&#39;s a real treasure map! Now we just need to
find the island that it belongs to.</p>

<h3><a name="index2h3"></a><code>WB850-FW-SR-210086.bin</code> - header analysis</h3>

<p>Looking into <code>WB850-FW-SR-210086.bin</code> with <code>binwalk</code> yields a long list of
file headers (HTML, PNG, JPEG, ...), a VxWorks header, quite a number of Unix
paths, but nothing that looks like partitions or filesystems.</p>

<p>Let&#39;s hex-dump the first kilobyte instead:</p>

<div><pre><span>00000000</span><span>:</span> <span>3231 3030 3836 0006 4657 5</span>f55 <span>502</span>f <span>4</span>f4e  <span>210086</span>..FW_UP<span>/</span>ON
<span>00000010</span><span>:</span> <span>424</span>c <span>312</span>e <span>6269 6</span>e00 <span>0000 0000 0000 0000</span>  BL1.bin.........
<span>00000020</span><span>:</span> <span>0000 0000 0000 0000</span> c400 <span>0000 0008 0000</span>  ................
<span>00000030</span><span>:</span> <span>4</span>f4e <span>424</span>c <span>3100 0000 0000 0000 0000 0000</span>  ONBL1...........
<span>00000040</span><span>:</span> <span>0000 0000 4657 5</span>f55 <span>502</span>f <span>4</span>f4e <span>424</span>c <span>322</span>e  ....FW_UP<span>/</span>ONBL2.
<span>00000050</span><span>:</span> <span>6269 6</span>e00 <span>0000 0000 0000 0000 0000 0000</span>  bin.............
<span>00000060</span><span>:</span> <span>0000 0000 30</span>b6 <span>0000</span> c408 <span>0000 4</span>f4e <span>424</span>c  ...<span>.0</span>.......ONBL
<span>00000070</span><span>:</span> <span>3200 0000 0000 0000 0000 0000 0000 0000  2</span>...............
<span>00000080</span><span>:</span> <span>5</span>b57 <span>4238 3530 5</span>d44 <span>5343 5</span>f35 <span>4</span>b45 <span>595</span>f  <span>[</span>WB850<span>]</span>DSC_5KEY_
<span>00000090</span><span>:</span> <span>5742 3835 3000 0000 0000 0000 0000 0000</span>  WB850...........
<span>000000</span>a0<span>:</span> <span>38</span>f4 d101 f4be <span>0000 4</span>d61 <span>696</span>e <span>5</span>f49 <span>6</span>d61  <span>8</span>.......Main_Ima
<span>000000</span>b0<span>:</span> <span>6765 0000 0000 0000 0000 0000 526</span>f <span>6</span>d46  ge..........RomF
<span>000000</span>c0<span>:</span> <span>532</span>f <span>5350 4944 2</span>e52 <span>6</span>f6d <span>0000 0000 0000</span>  S<span>/</span>SPID.Rom......
<span>000000</span>d0<span>:</span> <span>0000 0000 0000 0000 0000 0000 00</span>ac f402  ................
<span>000000</span>e0<span>:</span> <span>2</span>cb3 d201 <span>5265 736</span>f <span>7572 6365 0000 0000</span>  <span>,</span>...Resource....
<span>000000</span>f0<span>:</span> <span>0000 0000 0000 0000 4657 5</span>f55 <span>502</span>f <span>5742</span>  ........FW_UP<span>/</span>WB
<span>00000100</span><span>:</span> <span>3835 302</span>e <span>4845 5800 0000 0000 0000 0000  850</span>.HEX.........
<span>00000110</span><span>:</span> <span>0000 0000 0000 0000 864</span>d <span>0000 2</span>c5f c704  .........M..<span>,</span>_..
<span>00000120</span><span>:</span> <span>4</span>f49 <span>5300 0000 0000 0000 0000 0000 0000</span>  OIS.............
<span>00000130</span><span>:</span> <span>0000 0000 4657 5</span>f55 <span>502</span>f <span>736</span>b <span>696</span>e <span>2</span>e62  ....FW_UP<span>/</span>skin.b
<span>00000140</span><span>:</span> <span>696</span>e <span>0000 0000 0000 0000 0000 0000 0000</span>  <span>in</span>..............
<span>00000150</span><span>:</span> <span>0000 0000 48</span>d0 <span>2</span>f02 b2ac c704 <span>534</span>b <span>494</span>e  ....H.<span>/</span>.....SKIN
<span>00000160</span><span>:</span> <span>0000 0000 0000 0000 0000 0000 0000 0000</span>  ................
<span>*</span>
<span>000003</span>f0<span>:</span> <span>0000 0000 0000 0000 0000 0000 5041 5254</span>  ............PART
</pre></div>


<p>This looks very interesting. It starts with the firmware version, <code>210086</code>,
then <code>0x00 0x06</code>, directly followed by <code>FW_UP/ONBL1.bin</code> at the offset
<code>0x008</code>, which very much looks like a file name. The next file name,
<code>FW_UP/ONBL2.bin</code> comes at <code>0x044</code>, so this is probably a 60-byte &#34;partition&#34;
record:</p>

<div><pre><span>00000008</span><span>:</span> <span>4657 5</span>f55 <span>502</span>f <span>4</span>f4e <span>424</span>c <span>312</span>e <span>6269 6</span>e00  FW_UP<span>/</span>ONBL1.bin.
<span>00000018</span><span>:</span> <span>0000 0000 0000 0000 0000 0000 0000 0000</span>  ................
<span>00000028</span><span>:</span> c400 <span>0000 0008 0000 4</span>f4e <span>424</span>c <span>3100 0000</span>  ........ONBL1...
<span>00000038</span><span>:</span> <span>0000 0000 0000 0000 0000 0000</span>            ............
</pre></div>


<p>After the file name, there is quite a bunch of zeroes (making up a 32-byte
zero-padded string), followed by two little-endian integers <code>0xc4</code> and
<code>0x800</code>, followed by a 20-byte zero-padded string <code>ONBL1</code>, which is
probably the respective partition name. After that, the next records of the
same structure follow. The integers in the second record (<code>ONBL2</code>) are
<code>0xb630</code> and <code>0x8c4</code>, so we can assume the first number is the length, and the
second one is the offset in the file (the offset of one record is always
offset+length of the previous one).</p>

<p>In total, there are six records, so the <code>0x00 0x06</code> between the version string
and the first record is probably a termination or pading byte for the firmware
version and a one-byte number of partitions.</p>

<p>With this knowledge, we can reconstruct the partition table as follows:</p>

<table>
    <thead>
        <tr>
            <th>File name</th>
            <th>size</th>
            <th>offset</th>
            <th>partition name</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>FW_UP/ONBL1.bin</td>
            <td>196 (0xc4)</td>
            <td><code>0x0000800</code></td>
            <td>ONBL1</td>
        </tr>
        <tr>
            <td>FW_UP/ONBL2.bin</td>
            <td>46 KB (0xb630)</td>
            <td><code>0x00008c4</code></td>
            <td>ONBL2</td>
        </tr>
        <tr>
            <td>[WB850]DSC_5KEY_WB850</td>
            <td>30 MB (0x1d1f438)</td>
            <td><code>0x000bef4</code></td>
            <td>Main_Image</td>
        </tr>
        <tr>
            <td>RomFS/SPID.Rom</td>
            <td>48 MB (0x2f4ac00)</td>
            <td><code>0x1d2b32c</code></td>
            <td>Resource</td>
        </tr>
        <tr>
            <td>FW_UP/WB850.HEX</td>
            <td>19 KB (0x4d86)</td>
            <td><code>0x4c75f2c</code></td>
            <td>OIS</td>
        </tr>
        <tr>
            <td>FW_UP/skin.bin</td>
            <td>36 MB (0x22fd048)</td>
            <td><code>0x4c7acb2</code></td>
            <td>SKIN</td>
        </tr>
    </tbody>
</table>


<p>Let&#39;s write a
<a href="https://github.com/ge0rg/samsung-nx-hacks/blob/master/tools/drime3-firmware.py">tool to extract DRIMeIII firmware partitions</a>, and use it!</p>

<h3><a name="index3h3"></a><code>WB850-FW-SR-210086.bin</code> - code and data partitions</h3>

<p>The tool is extracting partitions based on their partition names, appending
<code>&#34;.bin&#34;</code> respectively. Running <code>file</code> on the output is not very helpful:</p>

<div><pre>ONBL1.bin<span>:</span>      data
ONBL2.bin<span>:</span>      data
Main_Image.bin<span>:</span> OpenPGP Secret Key
Resource.bin<span>:</span>   MIPSEB-LE MIPS-III ECOFF executable stripped <span>-</span> version <span>0.0</span>
OIS.bin<span>:</span>        data
SKIN.bin<span>:</span>       data
</pre></div>


<ul>
<li><p><code>ONBL1</code> and <code>ONBL2</code> are probably the stages 1 and 2 of the bootloader (as
confirmed by a string in <code>Main_Image</code>: <code>&#34;BootLoader(ONBL1, ONBL2) Update
Done&#34;</code>).</p></li>
<li><p><code>Main_Image</code> is the actual firmware: the OpenPGP Secret Key is a false
positive, <code>binwalk -A</code> reports quite a number of ARM function prologues in
this file.</p></li>
<li><p><code>Resource</code> and <code>SKIN</code> are pretty large containers, maybe provided by the SoC
manufacturer to &#34;skin&#34; the camera UI?</p></li>
<li><p><code>OIS</code> is not really hex as claimed by its file name, but it might
be the firmware for a dedicated
<a href="https://en.wikipedia.org/wiki/Image_stabilization#Optical_image_stabilization">optical image stabilizer</a>.</p></li>
</ul>


<p>Of all these, <code>Main_Image</code> is the most interesting one.</p>

<h2><a name="index2h2"></a>Loading the code in Ghidra</h2>

<p>The three partitions <code>ONBL1</code>, <code>ONBL2</code> and <code>Main_Image</code> contain actual ARM code.
A typical ARM firmware will contain the
<a href="https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/vector-table">reset vector table</a>
at address <code>0x0000000</code> (usually the beginning of flash / ROM), which is a
series of jump instructions. All three binaries however contain actual linear
code at their respective beginning, so most probably they need to be
re-mapped to some yet unknown address.</p>

<p>To find out how and why the camera is mis-detecting a hotspot, we need to:</p>

<ol>
<li>Find the right memory address to map <code>Main_Image</code> to</li>
<li>Load the symbol names from <code>partialImage.o.map</code> into Ghidra</li>
<li>Find and analyze the function that is mis-firing the hotspot login</li>
</ol>


<h3><a name="index4h3"></a>Loading and mapping <code>Main_Image</code></h3>

<p>By default, Ghidra will assume that the binary loads to address <code>0x0000000</code>
and try to analyze it this way. To get the correct memory address, we need to
find a function that accesses some known value from the binary using an
absolute address. Given that there are 77k functions, we can start with
something that&#39;s close to task #3, and search in the &#34;Defined Strings&#34; tab of
Ghidra for <code>&#34;yahoo&#34;</code>:</p>

<p><img src="http://iafisher.com/blog/posts/samsung_wb850f_firmware/ghidra-wb850f-yahoo-strings.png" alt="Screenshot of Ghidra with some Yahoo!  strings"/></p>

<p>Excellent! Ghidra identified a few strings that look like an annoyed
developer&#39;s printf debugging, probably from a function called
<code>DevHTTPResponseStart()</code>, and it seems to be the function that checks whether
the camera can properly access Yahoo, Google or Samsung:</p>

<pre><code>0139f574    DevHTTPResponseStart: url=%s, handle=%x, status=%d\n, headers=%s\r\n
0139f5b8    DevHTTPResponseStart: This is YAHOO check !!!\r\n
0139f5f4    DevHTTPResponseStart: THIS IS GOOGLE/YAHOO/SAMSUNG PAGE!!!! 111\n\n\n
0139f638    DevHTTPResponseStart: 301/302/307! cannot find yahoo!  safapi_is_browser_framebuffer_on : %d , safapi_is_browser_authed(): %d  \r\n
</code></pre>

<p>According to <code>partialImage.o.map</code>, a function with that name actually exists
at address <code>0x321a84</code>, and Ghidra also found a function at <code>0x321a84</code>. There
are some more matching function offsets between the map and the binary, so we
can assume that the <code>.text</code> addresses from the map file actually correspond
1:1 to <code>Main_Image</code>! We found the right island for our map!</p>

<p>Here&#39;s the beginning of that function:</p>

<div><pre><span>bool</span> <span>FUN_00321a84</span><span>(</span>undefined4 param_1<span>,</span>ushort param_2<span>,</span><span>int</span> param_3<span>,</span><span>int</span> param_4<span>) {</span>
  <span>/* snip variable declarations */</span>
  <span>FUN_0031daec</span><span>(*(</span>DAT_00321fd4 <span>+</span> <span>0x2c</span><span>),</span>DAT_00322034<span>,</span>param_3<span>,</span>param_1<span>,</span>param_2<span>,</span>param_4<span>);</span>
  <span>FUN_0031daec</span><span>(*(</span>DAT_00321fd4 <span>+</span> <span>0x2c</span><span>),</span>DAT_00322038<span>);</span>
  <span>FUN_00326f84</span><span>(</span><span>0x68</span><span>);</span>
</pre></div>


<p>It starts with two calls to <code>FUN_0031daec()</code> with different
numbers of parameters - this smells very much of <code>printf</code> debugging again.
According to the memory map, it&#39;s called <code>opd_printf()</code>! The first parameter
is some sort of context / destination, and the second one must be a reference
to the format string. The two <code>DAT_</code> values are detected by Ghidra as 32-bit
undefined values:</p>

<pre><code>DAT_00322034:
    74 35 3a c1     undefined4 C13A3574h
DAT_00322038:
    b8 35 3a c1     undefined4 C13A35B8h
</code></pre>

<p>However, the respective last three digits match the <code>&#34;DevHTTPResponseStart: &#34;</code>
debug strings encountered earlier:</p>

<ul>
<li><code>0xc13a3574 - 0x0139f574 = 0xc0004000</code> (first format string with four parameters)</li>
<li><code>0xc13a35b8 - 0x0139f5b8 = 0xc0004000</code> (second format strings without parameters)</li>
</ul>


<p>From that we can reasonably conclude that <code>Main_Image</code> needs to be loaded to
the memory address <code>0xc0004000</code>. This cannot be changed after the fact in
Ghidra, so we need to remove the binary from the project, re-import it, and
set the base address accordingly:</p>

<p><img src="http://iafisher.com/blog/posts/samsung_wb850f_firmware/ghidra-base-address.png" alt="Screenshot of Ghidra import options dialog"/></p>

<h3><a name="index5h3"></a>Loading function names from <code>partialImage.o.map</code></h3>

<p>Ghidra has a script to bulk-import data labels and function names from a text
table,
<a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Python/ghidra_scripts/ImportSymbolsScript.py">ImportSymbolScript.py</a>.
It expects each line to contain three variables, separated by arbitrary
amounts of whitespace (as determined by python&#39;s <code>string.split()</code>):</p>

<ol>
<li>symbol name</li>
<li>(hexadecimal) address</li>
<li>&#34;f&#34; for &#34;function&#34; or &#34;l&#34; for &#34;label&#34;</li>
</ol>


<p>Our symbol map contains multiple sections, but we are only interested in the
functions defined in <code>.text</code> (for now), which are mapped 1:1 to addresses in
<code>Main_Image</code>. Besides of function names, it also contains empty lines, object
file offsets (with <code>.text</code> as the label), labels (prefixed with <code>&#34;L$_&#34;</code>) and
local symbols (prefixed with <code>&#34;$&#34;</code>).</p>

<p>We need to limit our symbols to the <code>.text</code> section (everything after <code>.text</code>
and before <code>.debug_frame</code>), get rid of the empty lines and non-functions, then
add <code>0xc0004000</code> to each address so that we match up with the base address in
Ghidra. We can do this very obscurely with an awk one-liner:</p>

<div><pre><span>awk</span> <span>&#39;/^\.text /{t=1;next}/^\.debug_frame /{t=0} ; !/[$.]/ { if (t &amp;&amp;</span> <span>$1</span><span>) { printf &#34;%s %x f</span><span>\n</span><span>&#34;,</span> <span>$1</span><span>, (strtonum(&#34;0x&#34;</span><span>$2</span><span>)+0xc0004000) } }&#39;</span>
</pre></div>


<p>Or slightly less obscurely with a much slower shell loop:</p>

<div><pre><span>sed</span> <span>&#39;1,/^\.text /d;/^\.debug_frame /,</span><span>$d</span><span>&#39;</span> | <span>grep</span> <span>-v</span> <span>&#39;^$&#39;</span> | <span>grep</span> <span>-v</span> <span>&#39;[.$]&#39;</span> | \
<span>while</span> <span>read</span> sym addr f <span>;</span> <span>do</span>
    <span>printf</span> <span>&#34;%s %x f</span><span>\n</span><span>&#34;</span>  <span>$sym</span> $<span>((</span><span>0xc0004000</span> <span>+</span> <span>0</span>x<span>$addr</span><span>))</span>
<span>done</span>
</pre></div>


<p>Both will generate the same output that can be loaded
into Ghidra via &#34;Window&#34; / &#34;Script Manager&#34; / &#34;ImportSymbolsScript.py&#34;:</p>

<div><pre>sysInit c0004000 f
archPwrDown c0004094 f
MMU_WriteControlReg c00040a4 f
MMU_WritePageTableBaseReg c00040b8 f
MMU_WriteDomainAccessReg c00040d0 f
...
</pre></div>


<h3><a name="index6h3"></a>Reverse engineering <code>DevHTTPResponseStart</code></h3>

<p>Now that we have the function names in place, we need to manually set the type
of quite a few <code>DAT_</code> fields to &#34;pointer&#34;, rename the parameters according to
the debug string, and we get a reasonably usable decompiler output.</p>

<p>The following is a commented version, edited for better readability (inlined
the string references, rewrote some conditionals):</p>

<div><pre><span>bool</span> <span>DevHTTPResponseStart</span><span>(</span>undefined4 handle<span>,</span>ushort status<span>,</span><span>char</span> <span>*</span>url<span>,</span><span>char</span> <span>*</span>headers<span>) {</span>
  <span>bool</span> result<span>;</span>
  
  <span>opd_printf</span><span>(</span>ctx<span>,</span><span>&#34;DevHTTPResponseStart: url=%s, handle=%x, status=%d</span><span>\n</span><span>, headers=%s</span><span>\r\n</span><span>&#34;</span><span>,</span>
      url<span>,</span>handle<span>,</span>status<span>,</span>headers<span>);</span>
  <span>opd_printf</span><span>(</span>ctx<span>,</span><span>&#34;DevHTTPResponseStart: This is YAHOO check !!!</span><span>\r\n</span><span>&#34;</span><span>);</span>
  <span>safnotify_page_load_status</span><span>(</span><span>0x68</span><span>);</span>
  <span>if</span> <span>((</span>url <span>==</span> NULL<span>) || (</span>status <span>!=</span> <span>301</span> <span>&amp;&amp;</span> status <span>!=</span> <span>302</span> <span>&amp;&amp;</span> status <span>!=</span> <span>307</span><span>)) {</span>
    <span>/* this is not a HTTP redirect */</span>
    <span>if</span> <span>(</span>status <span>==</span> <span>200</span><span>) {</span>
      <span>/* HTTP 200 means OK */</span>
      <span>if</span> <span>(</span>headers <span>==</span> NULL <span>||</span>
          <span>(</span><span>strstr</span><span>(</span>headers<span>,</span><span>&#34;domain=.yahoo&#34;</span><span>) ==</span> NULL <span>&amp;&amp;</span>
           <span>strstr</span><span>(</span>headers<span>,</span><span>&#34;Domain=.yahoo&#34;</span><span>) ==</span> NULL <span>&amp;&amp;</span>
           <span>strstr</span><span>(</span>headers<span>,</span><span>&#34;domain=kr.yahoo&#34;</span><span>) ==</span> NULL <span>&amp;&amp;</span>
           <span>strstr</span><span>(</span>headers<span>,</span><span>&#34;Domain=kr.yahoo&#34;</span><span>) ==</span> NULL<span>)) {</span>
        <span>/* no response headers or no yahoo cookie --&gt; check fails! */</span>
        result <span>=</span> <span>true</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>/* we found a yahoo cookie bit in the headers */</span>
        <span>opd_printf</span><span>(</span>ctx<span>,</span><span>&#34;DevHTTPResponseData: THIS IS GOOGLE/YAHOO PAGE!!!! 3333</span><span>\n\n\n</span><span>&#34;</span><span>);</span>
        <span>*</span>p_request_ongoing <span>=</span> <span>0</span><span>;</span>
        <span>if</span> <span>(!</span><span>safapi_is_browser_authed</span><span>())</span>
          <span>safnotify_auth_ap</span><span>(</span><span>0</span><span>);</span>
        result <span>=</span> <span>false</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>else if</span> <span>(</span>status <span>&lt;</span> <span>0</span><span>) {</span>
      <span>/* negative status = aborted? */</span>
      result <span>=</span> <span>false</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>/* positive status, not a redirect, not &#34;OK&#34; */</span>
      result <span>= !</span><span>safapi_is_browser_framebuffer_on</span><span>();</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>/* this is a HTTP redirect */</span>
    <span>char</span> <span>*</span>match <span>=</span> <span>strstr</span><span>(</span>url<span>,</span><span>&#34;yahoo.&#34;</span><span>);</span>
    <span>if</span> <span>(</span>match <span>==</span> NULL <span>||</span> match <span>&gt; (</span>url<span>+</span><span>11</span><span>)) {</span>
      <span>opd_printf</span><span>(</span>ctx<span>,</span> <span>&#34;DevHTTPResponseStart: 301/302/307! cannot find yahoo! safapi_is_browser_framebuffer_on : %d , safapi_is_browser_authed(): %d</span>  <span>\r\n</span><span>&#34;</span><span>,</span>
          <span>safapi_is_browser_framebuffer_on</span><span>(),</span> <span>safapi_is_browser_authed</span><span>());</span>
      <span>if</span> <span>(!</span><span>safapi_is_browser_framebuffer_on</span><span>() &amp;&amp; !</span><span>safapi_is_browser_authed</span><span>()) {</span>
        <span>opd_printf</span><span>(</span>ctx<span>,</span><span>&#34;DevHTTPResponseStart: 302 auth failed!!! kSAFAPIAuthErrNotAuth!!</span> <span>\r\n</span><span>&#34;</span><span>);</span>
        <span>safnotify_auth_ap</span><span>(</span><span>1</span><span>);</span>
      <span>}</span>
      result <span>=</span> <span>false</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>/* found &#34;yahoo.&#34; in url */</span>
      <span>opd_printf</span><span>(</span>ctx<span>,</span> <span>&#34;DevHTTPResponseStart: THIS IS GOOGLE/YAHOO/SAMSUNG PAGE!!!! 111</span><span>\n\n\n</span><span>&#34;</span><span>);</span>
      <span>*</span>p_request_ongoing <span>=</span> <span>0</span><span>;</span>
      <span>if</span> <span>(!</span><span>safapi_is_browser_authed</span><span>())</span>
        <span>safnotify_auth_ap</span><span>(</span><span>0</span><span>);</span>
      result <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span>
</pre></div>


<h3><a name="index7h3"></a>Interpreting the hotspot detection</h3>

<p>So to summarize, the code in <code>DevHTTPResponseStart</code> will check for one of two
conditions and call <code>safnotify_auth_ap(0)</code> to mark the WiFi access point as
authenticated:</p>

<ol>
<li><p>on a HTTP 200 OK response, the server must set a cookie on the domain
<code>&#34;.yahoo<em>.something</em>&#34;</code> or <code>&#34;kr.yahoo<em>.something</em>&#34;</code></p></li>
<li><p>on a HTTP 301/302/307 redirect, the URL (presumably the redirect location?)
must contain <code>&#34;yahoo.&#34;</code> close to its beginning.</p></li>
</ol>


<p>If we manually contact the queried URL, <code>http://www.yahoo.co.kr/</code>, it will
redirect us to <code>https://www.yahoo.com/</code>, so everything is fine?</p>

<div><pre>GET <span>/</span> HTTP<span>/</span><span>1.1</span>
Host<span>:</span> www.yahoo.co.kr

HTTP<span>/</span><span>1.1 301</span> Moved Permanently
Location<span>:</span> https<span>://</span>www.yahoo.com<span>/</span>
</pre></div>


<p>Well, the substring <code>&#34;yahoo.&#34;</code> is on position 12 in the url
<code>&#34;https://www.yahoo.com/&#34;</code>, but the code is requiring it to be in one of the
first 11 positions. This check has been killed by TLS!</p>

<p>To pass the hotspot check, we must unwind ten years of HTTPS-everywhere, or
point the DNS record to a different server that will either HTTP-redirect to a
different, more yahooey name, or set a cookie on the yahoo domain.</p>

<p>After <a href="https://github.com/ge0rg/samsung-nx-emailservice/commit/2ede8d065bf5c9ea76d9c18484aab921814b2f71">patching samsung-nx-emailservice accordingly</a>,
the camera will actually connect and upload photos:</p>

<p><img src="http://iafisher.com/blog/posts/samsung_wb850f_firmware/wb850f-email-sending.jpg" alt="WB850F sending a photo"/></p>

<h2><a name="index3h2"></a>Summary: the real treasure</h2>

<p>This deep-dive allowed to understand and circumvent the hotspot detection in
Samsung&#39;s WB850F WiFi camera based on one reverse-engineered function. The
resulting patch was tiny, but guessing the workaround just from the packet
traces was impossible due to the &#34;detection method&#34; implemented by Samsung&#39;s
engineers. Once knowing what to look for, the same workaround was applied to
cameras asking for MSN.com, thus also
<a href="http://iafisher.com/blog/posts/samsung_wifi_cameras/#index2h2">adding EX2F, ST200F, WB3xF and WB1100F to the supported cameras list</a>.</p>

<p>However, the real treasure is still waiting! <code>Main_Image</code> contains over 77k
functions, so there is more than enough for a curious treasure hunter to
explore in order to better understand how digital cameras work.</p>

<hr/>

<p><em><a href="https://infosec.exchange/@ge0rg/112496790871724311">Discuss on Mastodon</a></em></p>

</div>









</div>



</div></div>
  </body>
</html>
