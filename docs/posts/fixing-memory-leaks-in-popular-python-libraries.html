<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.paulsprogrammingnotes.com/2021/12/python-memory-leaks.html">Original</a>
    <h1>Fixing Memory Leaks in Popular Python Libraries</h1>
    
    <div id="readability-page-1" class="page"><div><article><time datetime="2021-12-20T02:11:00+00:00">20 Dec 2021</time><p>I was recently able to make a <a href="https://github.com/celery/celery/issues/4843#issuecomment-988492732">minimal example</a> that reproduced a Celery memory leak. The memory leak would happen on the main Celery worker process that’s forked to make child processes, which makes the leak especially bad. Issue <a href="https://github.com/celery/celery/issues/4843">#4843</a> has been around for 3+ years and has 140+ comments, so this one has been causing a lot of problems for Celery users for a while.</p><p>The memory leak has been causing a lot of issues at my work too, and I was able to get some help resolving the issue during a work hackathon. My coworker Michael Lazar was able to find <a href="https://github.com/celery/celery/issues/4843#issuecomment-991394349">the root cause</a> of the issue and make a <a href="https://github.com/celery/py-amqp/pull/374">pull request</a> to fix it in py-amqp (a celery dependency when using RabbitMQ as a broker). The code with the issue was <a href="https://github.com/celery/py-amqp/blame/v5.0.5/amqp/connection.py#L469">10 years old</a>!</p><p>Here’s what the bug looks like:</p><div><div><pre><code>try:
    sock.shutdown(socket.SHUT_RDWR)
    sock.close()
except OSError:
    pass
</code></pre></div></div><p>The problem occurs when <code>socket.shutdown</code> fails on an <code>OSError</code> and doesn’t proceed to <code>socket.close</code> to clean up the socket and allow garbage collection to release the memory used for it. The <code>OSError</code> on <code>shutdown</code> can occur when the remote side of the connection closes the connection first.</p><p>The fixed example (with separate <code>try</code>/<code>except</code> blocks):</p><div><div><pre><code>try:
    sock.shutdown(socket.SHUT_RDWR)
except OSError:
    pass

try:
    sock.close()
except OSError:
    pass
</code></pre></div></div><p>I was able to make the same fix to a few other popular Python libraries too:</p><ul><li><a href="https://github.com/redis/redis-py/pull/1797">redis-py</a> (<a href="https://github.com/redis/redis-py/blame/v4.0.2/redis/connection.py#L682">11 year old code!</a>)</li><li><a href="https://github.com/Thriftpy/thriftpy2/pull/183">thriftpy2</a></li><li><a href="https://github.com/kovidgoyal/calibre/pull/1552">calibre</a></li></ul><p>I also found another way to reduce memory usage of <code>Connection</code>s in <a href="https://github.com/celery/py-amqp/pull/377">py-amqp</a> and <a href="https://github.com/celery/librabbitmq/pull/160">librabbitmq</a> by changing how active channel IDs are stored.</p></article><!-- Add Disqus comments. --> </div></div>
  </body>
</html>
