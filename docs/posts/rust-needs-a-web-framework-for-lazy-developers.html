<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rust-needs-a-web-framework-for-lazy-developers/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Rust needs a web framework for lazy developers</h1>
    
    <div id="readability-page-1" class="page"><div><p>I like to make silly things, and I also like to put in <em>minimal effort</em> for those silly things.
I also like to make things in Rust, mostly for the web, and this is where we run into a problem.</p>
<p>See, if I want to make something for the web, I could use Django but I don&#39;t want that.
I mean, Django is for building <a href="https://engineering.fb.com/2023/09/07/culture/threads-inside-story-metas-newest-social-app/">serious businesses</a>, not for building silly non-commercial things!
But using Rust, we have to do a <em>lot</em> more work than if we build it with Django or friends.</p>
<p>See, so far, there&#39;s no equivalent, and the Rust community leans heavily into the &#34;wire it up yourself&#34; approach.
As <a href="https://www.arewewebyet.org/">Are We Web Yet?</a> says, &#34;[...] you generally have to wire everything up yourself. Expect to put in a little bit of extra set up work to get started.&#34;</p>
<p>This undersells it, though.
It&#39;s more than a little bit of extra work to get started!
I know because I made a list of things to do to get started.</p>
<p>Rust needs something that <em>does</em> bundle this up for you, so that we can serve all web developers.
Having it would make it a lot easier to make the case to use Rust.
The benefits are there: you get wonderful type system, wonderful performance, and build times that give you back those coffee breaks you used to get while your code compiled.</p>

<p>There is a big pile of stuff that nearly every web app needs, no matter if it&#39;s big or small.
Here&#39;s a rough list of what seems pretty necessary to me:</p>
<ul>
<li>Routing/handlers: this is pretty obvious, but we have to be able to get an incoming request to some handler for it. Additionally, this routing needs to handle path parameters, ideally with type information, and we&#39;ll give bonus points for query parameters, forms, etc.</li>
<li>Templates: we&#39;ll need to generate, you know, HTML (and sometimes other content, like JSON or, if you&#39;re in the bad times still, XML). Usually I want these to have basic logic, like conditionals, match/switch, and loops.</li>
<li>Static file serving: we&#39;ll need to serve some assets, like CSS files. This can be done separately, but having it as part of the same web server is extremely handy for both local development and for small-time deployments that won&#39;t handle much traffic.</li>
<li>Logins: You almost always need some way to log in, since apps are usually multi-user or deployed on a public network. This is just annoying to wire up every time! It should be customizable and something you can opt out of, but it should be trivial to have logins from the start.</li>
<li>Permissions: You also need this for systems that have multiple users, since people will have different data they&#39;re allowed to access or different roles in the system. Permissions can be complicated but you can make something relatively simple that follows the <code>check(user, object, action)</code> pattern and get really far with it.</li>
<li>Database interface: You&#39;re probably going to have to store data for your app, so you want a way to do that. Something that&#39;s ORM-like is often nice, but something light is fine. Whatever you do here isn&#39;t the <em>only</em> way to interact with the database, but it&#39;ll be used for things like logins, permissions, and admin tools, so it&#39;s going to be a fundamental piece.</li>
<li>Admin tooling: This is <em>arguably</em> a quality-of-life issue, not a necessity, except that every time you setup your application in a local environment or in production you&#39;re going to have to bootstrap it with at least one user or some data. And you&#39;ll have to do admin actions sometimes! So I think having this built-in for at least some of the common actions is a necessity for a seamless experience.</li>
<li>WebSockets: I use WebSockets in a lot of my projects. They just let you do really fun things with pushing data out to connected users in a more real-time fashion!</li>
<li>Hot reloading: This is a <em>huge</em> one for developer experience, because you want to have the ability to see changes really quickly. When code or a template change, you need to see that reflected as soon as humanly possible (or as soon as the Rust compiler allows).</li>
</ul>
<p>Then we have a pile of things that are quality-of-life improvements, and I think are necessary for long-term projects but might not be as necessary upfront, so users are less annoyed at implementing it themselves because the cost is spread out.</p>
<ul>
<li>Background tasks: There needs to be a story for these! You&#39;re going to have features that have to happen on a schedule, and having a consistent way to do that is a big benefit and makes development easier.</li>
<li>Monitoring/observability: Only the smallest, least-critical systems should skip this. It&#39;s really important to have and it will make your life so much easier when you have it in that moment that you desperately need it.</li>
<li>Caching: There are a lot of ways to do this, and all of them make things more complicated and <em>maybe</em> faster? So this is nice to have a story for, but users can also handle it themselves.</li>
<li>Emails and other notifications: It&#39;s neat to be able to have password resets and things built-in, and this is probably a necessity if you&#39;re going to have logins, so you can have password resets. But other than that feature, it feels like it won&#39;t get used <em>that</em> much and isn&#39;t a big deal to add in when you need it.</li>
<li>Deployment tooling: Some consistent way to deploy <em>somewhere</em> is really nice, even if it&#39;s just an autogenerated Dockerfile that you can use with a host of choice.</li>
<li>CSS/JS bundling: In the time it is, we use JS and CSS everywhere, so you probably want a web tool to be aware of them so they can be included seamlessly. But does it really have to be integrated in? Probably not...</li>
</ul>
<p>So those are the things I&#39;d target in a framework if I were building one!
I might be doing that...</p>

<p>There&#39;s quite a bit out there already for building web things in Rust.
None of them quite hit what I want, which is intentional on their part: none of them <em>aspire</em> to be what I&#39;m looking for here.
I love what exists, and I think we&#39;re sorely missing what I want here (I don&#39;t think I&#39;m alone).</p>
<h2 id="web-frameworks">Web frameworks</h2>
<p>There are really two main groups of web frameworks/libraries right now: the minimalist ones, and the single-page app ones.</p>
<p>The minimalist ones are reminiscent of <a href="https://flask.palletsprojects.com/en/3.0.x/">Flask</a>, Sinatra, and other small web frameworks.
These include the excellent <a href="https://actix.rs/">actix-web</a> and <a href="https://docs.rs/axum/latest/axum/">axum</a>, as well as myriad <a href="https://www.arewewebyet.org/topics/frameworks/">others</a>.
There are so many of these, and they all bring a nice flavor to web development by leveraging Rust&#39;s type system!
But they don&#39;t give you much besides handlers; none of the extra functionality we want in a full for-lazy-developers framework.</p>
<p>Then there are the single-page app frameworks.
These fill a niche where you can build things with Rust on the backend and frontend, using WebAssembly for the frontend rendering.
These tend to be less mature, but good examples include <a href="https://dioxuslabs.com/learn/0.5/">Dioxus</a>, <a href="https://crates.io/crates/leptos">Leptos</a>, and <a href="https://yew.rs/">Yew</a>.
I used Yew to build a <a href="https://ntietz.com/blog/digital-vigil-for-tdor/">digital vigil</a> last year, and it was enjoyable but I&#39;m not sure I&#39;d want to do it in a &#34;real&#34; production setting.</p>
<p>Each of these is excellent for what it is—but what it is requires a lot of wiring up still.
Most of my projects would work well with the minimalist frameworks, but those require so much wiring up!
So it ends up being a chore to set that up each time that I want to do something.</p>
<h2 id="piles-of-libraries">Piles of libraries!</h2>
<p>The rest of the ecosystem is piles of libraries.
There are lots of template libraries!
There are some libraries for logins, and for permissions.
There are WebSocket libraries!</p>
<p>Often you&#39;ll find some projects and examples which integrate a couple of the things you&#39;re using, but you won&#39;t find something that integrates <em>all</em> the pieces you&#39;re using.
I&#39;ve run into some of the examples being out of date, which is to be expected in a fast-moving ecosystem.</p>
<p>The pile of libraries leaves a lot of friction, though.
It makes getting started, the &#34;just wiring it up&#34; part, very difficult and often an exercise in researching how things work, to understand them in depth enough to <em>do</em> the integration.</p>
<h2 id="what-i-ve-done-before">What I&#39;ve done before</h2>
<p>The way I&#39;ve handled this before is basically to pick a base framework (typically actix-web or axum) and then search out all the pieces I want on top of it.
Then I&#39;d wire them up, either all at the beginning or as I need them.</p>
<p>There are starter templates that could help me avoid some of this pain.
They can definitely help you skip some of the initial pain, but you still get all the maintenance burden.
You have to make sure your libraries stay up to date, even when there are breaking changes.
And you will drift from the template, so it&#39;s not really feasible to merge changes to it into your project.</p>
<p>For the projects I&#39;m working on, this means that instead of keeping one framework up to date, I have to keep <code>n</code> bespoke frameworks up to date across all my projects!</p>
<p>Eep!</p>
<p>I&#39;d much rather have a single web framework that handles it all, with clean upgrade instructions between versions.
There will be breaking changes sometimes, but this way they can be documented instead of coming about due to changes in the interactions between two components which don&#39;t even know they&#39;re going to be integrated together.</p>

<p>In an ideal world, there would be a framework for Rust that gives me all the features I listed above.
And it would also come with excellent documentation, changelogs, thoughtful versioning and handling of breaking changes, and maybe even a great community.
All the things I love about Django, could we have those for a Rust web framework so that we can reap the benefits of Rust without having to go needlessly slowly?</p>
<p>This doesn&#39;t exist right now, and I&#39;m not sure if anyone else is working on it.
All paths seem to lead me toward &#34;whoops I guess I&#39;m building a web framework.&#34;
I hope someone else builds one, too, so we can have multiple options.</p>
<p>To be honest, &#34;web framework&#34; sounds way too grandiose for what I&#39;m doing, which is simply wiring things together in an opinionated way, using (mostly) existing building blocks.
Instead of calling it a framework, I&#39;m thinking of it as a <em>web toolkit</em>: a bundle of tools tastefully chosen and arranged to make the artisan highly effective.</p>
<p>My toolkit is called <strong>nicole&#39;s web toolkit</strong>, or <strong><code>newt</code></strong>.
It&#39;s available in a <a href="https://git.sr.ht/~ntietz/newt">public repository</a>, but it&#39;s really not usable (the latest changes aren&#39;t even pushed yet).
It&#39;s not even usable for <em>me</em> yet—this isn&#39;t a launch post, more shipping my design doc (and hoping someone will do my work for me so I don&#39;t <em>have</em> to finish <code>newt</code> :D).</p>
<p>The goal for <code>newt</code> is to be able to create a new small web app and start on the actual project in minutes instead of days, bypassing the entire process of wiring things up.
I think the list of must-haves and quality-of-life features above will be a start, but by no means everything we need.
I&#39;m not ready to accept contributions, but I hope to be there at some point.</p>
<p>I think that Rust really needs this, and the whole ecosystem will benefit from it.
A healthy ecosystem will have multiple such toolkits, and I hope to see others develop as well.</p>
<p>* * *</p>
<p>If you want to follow along with mine, though, feel free to subscribe to my RSS feed or newsletter, or follow me on Mastodon.
I&#39;ll try to let people know in all those places when the toolkit is ready for people to try out.
Or I&#39;ll do a post-mortem on it, if it ends up that I don&#39;t get far with it!
Either way, this will be fun.</p>
<hr/>

</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://jakelazaroff.com/newsletter/">newsletter</a>. There is also an <a href="https://jakelazaroff.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
