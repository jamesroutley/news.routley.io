<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boinkor.net/2024/04/some-useful-types-for-database-using-rust-web-apps/">Original</a>
    <h1>Some useful types for database-using Rust web apps</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve been writing a little web app in rust lately, and in it I decided to try to do it without an ORM. Instead, I modeled data access in a way that resembles the <a href="https://en.wikipedia.org/wiki/Data_access_layer">Data Access Layer</a> pattern: You make a set of abstractions that maps the “business logic” to how the data is stored in the data store. Here are some types that I found useful in this journey so far.</p><h2 id="the-idtype-trait">The <code>IdType</code> trait
<span><a href="#the-idtype-trait"><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg></a></span></h2><p>The first item is a very subtle little thing that I wasn’t sure would work. But it does, and it’s really pleasing! Introducing <code>IdType</code>, a trait that marks a type used for database identifiers. Say you have a struct <code>Bookmark</code> in sqlite that is has a <code>u64</code> as a primary key. What prevents you from passing accidentally just about any <code>u64</code> (say, a user ID) into a struct and reading any bookmark in the database? Right, that’s why we make newtypes.</p><p>So you make a newtype that wraps <code>u64</code> and define your bookmark struct like so<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>BookmarkId</span>(<span>u64</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Bookmark</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>id: <span>BookmarkId</span>,<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>url: <span>Url</span>,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Sweet, but how do you create a new bookmark? Your database is what assigns these IDs, so do you make a second struct <code>BookmarkForInsertion</code> and sync struct fields? Or do you extract the ID fields and make a struct two layers deep? Pass all bookmark fields to an <code>add</code> function? All of these seemed unpleasant to me. Here’s what I do instead:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>trait</span><span> </span>IdType&lt;T&gt;: <span>Copy</span> +<span> </span>fmt::Display<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>type</span> <span>Id</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Returns the inner ID.
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>id</span>(self)<span> </span>-&gt; <span>Self</span>::Id;<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Debug, Clone, Copy, sqlx::Type)]</span><span>
</span></span></span><span><span><span></span><span>#[sqlx(transparent)]</span><span>
</span></span></span><span><span><span></span><span>#[serde(transparent)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>BookmarkId</span>(<span>i64</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>IdType&lt;BookmarkId&gt;<span> </span><span>for</span><span> </span>BookmarkId<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>type</span> <span>Id</span><span> </span>=<span> </span><span>i64</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>id</span>(self)<span> </span>-&gt; <span>Self</span>::Id<span> </span>{<span>
</span></span></span><span><span><span>        </span>self.<span>0</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>OK, so that’s more complicated. What does that allow us to do? Let’s update our Bookmark struct to use it:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>struct</span> <span>Bookmark</span>&lt;<span>ID</span>: <span>IdType</span>&lt;BookmarkId&gt;&gt;<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>id: <span>ID</span>,<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span>url: <span>Url</span>,<span>
</span></span></span><span><span><span>    </span><span>// ...
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>So what this does is, now you can handle “existing” bookmarks like before, but also you can specify that a bookmark doesn’t have an ID yet:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>update_bookmark</span>(bm: <span>Bookmark</span>&lt;BookmarkId&gt;)<span> </span>{<span> </span>...<span> </span>}<span>
</span></span></span><span><span><span></span><span>// and
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>create_bookmark</span>(bm: <span>Bookmark</span>&lt;NoId&gt;)<span> </span>-&gt; <span>Bookmark</span>&lt;BookmarkId&gt;<span> </span>{<span> </span>...<span> </span>}<span>
</span></span></span></code></pre></div><p>What’s more, the <code>IdTrait&lt;T&gt;</code> takes a type parameter that tells us what the expected ID type would be. That comes into play with the <code>NoId</code> type above: It’s a little empty type that just says “I’m not an ID yet”:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(PartialEq, Eq, Clone, Copy, Default, Serialize, Debug)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>NoId</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span>&lt;T&gt;<span> </span>IdType&lt;T&gt;<span> </span><span>for</span><span> </span>NoId<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>type</span> <span>Id</span><span> </span>=<span> </span>std::convert::Infallible;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>id</span>(self)<span> </span>-&gt; <span>Self</span>::Id<span> </span>{<span>
</span></span></span><span><span><span>        </span>unreachable!(<span>&#34;You mustn&#39;t try to access non-IDs.&#34;</span>);<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Some neat things in this: One, <code>NoId</code> is a generic placeholder for all ID types - meaning a function signature can always take a struct representation of a database object that doesn’t exist in the database yet. Neat thing two, the “inner” Id can not be retrieved from it. (It doesn’t exist, after all!) It’s <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html"><code>convert::Infallible</code></a>, the “never” type, meaning any attempt at retrieving that ID will fail at compile time. The compiler won’t let us look at the IDs of objects that haven’t gotten any yet! One day, when the <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>never</code> type</a> is stabilized, we can use that. In the meantime, this is equivalent enough!</p><p>What’s more, the NoId type tells serde to not expect an <code>id</code> field whenever you deserialize a Bookmark, say from JSON input on an API route:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// NoId can be deserialized from any source, even if the field is not
</span></span></span><span><span><span>/// present.
</span></span></span><span><span><span></span><span>impl</span>&lt;<span>&#39;de</span>&gt;<span> </span>Deserialize&lt;<span>&#39;de</span>&gt;<span> </span><span>for</span><span> </span>NoId<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>deserialize</span>&lt;D&gt;(_deserializer: <span>D</span>)<span> </span>-&gt; <span>Result</span>&lt;Self,<span> </span>D::Error&gt;<span>
</span></span></span><span><span><span>    </span><span>where</span><span>
</span></span></span><span><span><span>        </span>D: <span>Deserializer</span>&lt;<span>&#39;de</span>&gt;,<span>
</span></span></span><span><span><span>    </span>{<span>
</span></span></span><span><span><span>        </span><span>Ok</span>(NoId)<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>I didn’t expect this pattern to work so well, but it’s been extremely helpful in this CRUD app to not have to write multiple structs with the same (and then out-of-sync) fields in them; and it feels even better to do that with structures that feel like the business logic needs to feel - rather than how the database layout requires them to be.</p><p>But how do we use those structs? I thought we weren’t making an ORM?</p><h2 id="the-read-onlyread-write-transaction-pattern">The read-only/read-write transaction pattern
<span><a href="#the-read-onlyread-write-transaction-pattern"><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg></a></span></h2><p>My app is a really reasonably “normal” one where a logged-in user makes a request, and that triggers one or multiple database operations, and if everything went right, commits any changes. That’s a transaction! And what is a transaction other than a collection of business logic that gets applied to a data store?</p><p>Hence, the <code>Transaction</code> type. It wraps a lower-level (sqlite, in my case) Transaction handle that can’t be retrieved (so code can’t play with the database directly), and exposes methods that allow code to perform operations on the database:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Transaction</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>txn: <span>sqlx</span>::Transaction&lt;<span>&#39;static</span>,<span> </span>sqlx::sqlite::Sqlite&gt;,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>Transaction<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>/// Commit any changes made in the transaction.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>commit</span>(&amp;<span>mut</span><span> </span>self)<span> </span>{<span> </span>self.txn.commit().<span>await</span>;<span> </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Add a new bookmark and return its ID.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>add_bookmark</span>(<span>
</span></span></span><span><span><span>        </span>&amp;<span>mut</span><span> </span>self,<span>
</span></span></span><span><span><span>        </span>bm: <span>Bookmark</span>&lt;NoId&gt;,<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;BookmarkId,<span> </span>sqlx::Error&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Retrieve the bookmarks that belong to the current user.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>list_bookmarks</span>(<span>
</span></span></span><span><span><span>        </span>&amp;<span>mut</span><span> </span>self<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;<span>Vec</span>&lt;Bookmark&lt;BookmarkId&gt;&gt;&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>So that’s neat! But we can get something even neater. You may have seen this <a href="https://kerkour.com/sqlite-for-servers">article about running sqlite on a server</a>, and it recommends having two connection pools: One for read-only ops and one for read-write ops. Let’s make a read-only and a read-write transaction that gets created from each of these two pools:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>trait</span><span> </span>TransactionMode<span> </span>{}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>ReadOnly</span><span> </span>{}<span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>TransactionMode<span> </span><span>for</span><span> </span>ReadOnly<span> </span>{}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>ReadWrite</span><span> </span>{}<span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>TransactionMode<span> </span><span>for</span><span> </span>ReadWrite<span> </span>{}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Transaction</span>&lt;M: <span>TransactionMode</span><span> </span>=<span> </span>ReadWrite&gt;<span> </span>{<span>
</span></span></span><span><span><span>    </span>txn: <span>sqlx</span>::Transaction&lt;<span>&#39;static</span>,<span> </span>sqlx::sqlite::Sqlite&gt;,<span>
</span></span></span><span><span><span>    </span>marker: <span>PhantomData</span>&lt;M&gt;,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span>Connection<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>begin_for_user</span>(<span>
</span></span></span><span><span><span>        </span>&amp;self,<span>
</span></span></span><span><span><span>        </span>user: <span>User</span>&lt;UserId&gt;,<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;Transaction&lt;ReadWrite&gt;,<span> </span>sqlx::Error&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>begin_ro_for_user</span>(<span>
</span></span></span><span><span><span>        </span>&amp;self,<span>
</span></span></span><span><span><span>        </span>user: <span>User</span>&lt;UserId&gt;,<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;Transaction&lt;ReadOnly&gt;,<span> </span>RoTransactionError&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>So that gives us two methods - <code>Connection::begin</code> and <code>Connection::begin_ro</code>. And now, it’s pretty easy to split that Transaction implementation into two blocks, one for the read-only operation and one for the read-write one:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span>Transaction&lt;ReadWrite&gt;<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>/// Commit any changes made in the transaction.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>commit</span>(&amp;<span>mut</span><span> </span>self)<span> </span>{<span> </span>self.txn.commit().<span>await</span>;<span> </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Add a new bookmark and return its ID.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>add_bookmark</span>(<span>
</span></span></span><span><span><span>        </span>&amp;<span>mut</span><span> </span>self,<span>
</span></span></span><span><span><span>        </span>bm: <span>Bookmark</span>&lt;NoId&gt;,<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;BookmarkId,<span> </span>sqlx::Error&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span>&lt;M: <span>TransactionMode</span>&gt;<span> </span>Transaction&lt;M&gt;<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>/// Retrieve the bookmarks that belong to the current user.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>list_bookmarks</span>(<span>
</span></span></span><span><span><span>        </span>&amp;<span>mut</span><span> </span>self,<span>
</span></span></span><span><span><span>        </span>user_id: <span>UserId</span>,<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;<span>Vec</span>&lt;Bookmark&lt;BookmarkId&gt;&gt;&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>So the ReadWrite impl block looks reasonable, but why is the read-only block generic? That’s because the method is available in both - <code>ReadWrite</code> <em>and</em> <code>ReadOnly</code> modes. You could also define methods that <em>aren’t</em> available in read-write modes - say, if they’re heavyweight enough that blocking your single write-capable connection with them would be wasteful. Then you write a <code>impl Transaction&lt;ReadOnly&gt;</code> block and the compiler will take care of the rest - any method defined on the “wrong” transaction type is definitely not callable - the compiler won’t even be able to find it.</p><p>…but the compiler will tell you that you got the wrong mode. Here’s how an error looks like if I accidentally call <code>.commit()</code> on a read-only transaction:</p><div><pre tabindex="0"><code data-lang="console"><span><span><span>error[E0599]: no method named `commit` found for struct `DbTransaction` in the current scope
</span></span></span><span><span><span>  --&gt; src/lz-web/src/ui.rs:51:9
</span></span></span><span><span><span>   |
</span></span></span><span><span><span>51 |     txn.commit();
</span></span></span><span><span><span>   |         ^^^^^^ method not found in `DbTransaction`
</span></span></span><span><span><span>   |
</span></span></span><span><span><span>  ::: src/lz-web/src/db.rs:45:1
</span></span></span><span><span><span>   |
</span></span></span><span><span><span>45 | pub struct DbTransaction&lt;M: lz_db::TransactionMode = lz_db::ReadOnly&gt; {
</span></span></span><span><span><span>   | --------------------------------------------------------------------- method `commit` not found for this struct
</span></span></span><span><span><span>   |
</span></span></span><span><span><span>   = note: the method was found for
</span></span></span><span><span><span>           - `DbTransaction&lt;ReadWrite&gt;`
</span></span></span></code></pre></div><h3 id="a-neat-addition-keeping-extra-data-on-the-transaction">A neat addition: Keeping extra data on the transaction
<span><a href="#a-neat-addition-keeping-extra-data-on-the-transaction"><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg></a></span></h3><p>Every operation is made by a logged-in user, and so the transaction can encode <em>who</em> is making the request (since the authentication is checked as part of an <a href="https://docs.rs/axum/latest/axum/extract/index.html">axum extractor</a>). That gives us the opportunity to <em>always</em> know on whose behalf something is happening, and our data access methods can add restrictions to the query that ensures even faulty/manipulated input data doesn’t touch another user’s data!</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>struct</span> <span>Transaction</span>&lt;M: <span>TransactionMode</span><span> </span>=<span> </span>ReadWrite&gt;<span> </span>{<span>
</span></span></span><span><span><span>    </span>txn: <span>sqlx</span>::Transaction&lt;<span>&#39;static</span>,<span> </span>sqlx::sqlite::Sqlite&gt;,<span>
</span></span></span><span><span><span>    </span>user: <span>User</span>&lt;UserId&gt;,<span>  </span><span>// &lt;- this is new!
</span></span></span><span><span><span></span><span>    </span>marker: <span>PhantomData</span>&lt;M&gt;,<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>and… rework the methods that begin a transaction such that they require a username, and you can do stuff like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span>&lt;M: <span>TransactionMode</span>&gt;<span> </span>Transaction&lt;M&gt;<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>/// Retrieve the bookmarks that belong to the current user.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>list_bookmarks</span>(<span>
</span></span></span><span><span><span>        </span>&amp;<span>mut</span><span> </span>self<span>
</span></span></span><span><span><span>    </span>)<span> </span>-&gt; <span>Result</span>&lt;<span>Vec</span>&lt;Bookmark&lt;BookmarkId&gt;&gt;&gt;<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>        </span>query_builder.push(<span>&#34;WHERE user_id = &#34;</span>);<span>
</span></span></span><span><span><span>        </span>query_builder.push_bind(self.user.id);<span>
</span></span></span><span><span><span>        </span><span>// ...
</span></span></span><span><span><span></span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>All that, together, feels pretty neat (and honestly, not allllll that “clever”)! I have no doubt a sufficiently powerful ORM could have let me do these things too, with plugins and various other generics. But doing them this way feels somewhat more right - defining these structs and the logic operating on them allows for a lot of flexibility in coming up with efficient data representations &amp; queries, while the various niceties that the language gives us (automatic json representation/parsing with serde! Transaction rollback on early-return!) make it feel really easy to write and maintain. I’ve been through a bunch of refactors of this app already, and the basic structure has held up pretty nicely.</p><div role="doc-endnotes"><hr/><ol><li id="fn:1"><p>Please note that approximately none of the code listed here will compile out of the box. Very sorry - this post is meant to provide a basis for a dialog with the rust compiler, not to be an entirely copy/pasteable framework; that would require a bit more boilerplate and wouldn’t add much to the quality of the content. You are smart! You got this! <a href="#fnref:1" role="doc-backlink">↩︎</a></p></li></ol></div></div></div>
  </body>
</html>
