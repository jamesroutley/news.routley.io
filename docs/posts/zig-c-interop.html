<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tuple.app/blog/zig-cpp-interop">Original</a>
    <h1>Zig / C&#43;&#43; Interop</h1>
    
    <div id="readability-page-1" class="page"><div>  <div> <div>    <p><em>Note: this blog post is <a href="https://marler8997.github.io/blog/zig-cpp-interop/">cross-posted</a> from my personal blog</em></p>
<p>I’ve been writing <strong>Zig</strong> and <strong>C++</strong> that have to talk to each other. I want both languages to be able to store data types from the other in their own structs/classes.</p>
<pre tabindex="0" data-language="zig"><code><span><span>const</span><span> c</span><span> =</span><span> @cImport</span><span>({ </span><span>@cInclude</span><span>(</span><span>&#34;cppstuff.h&#34;</span><span>); });</span></span>
<span><span>const</span><span> MyZigType</span><span> =</span><span> struct</span><span> {</span></span>
<span><span>    foo</span><span>: </span><span>c</span><span>.</span><span>SharedPtrFoo</span><span>,</span></span>
<span><span>};</span></span></code></pre>
<pre tabindex="0" data-language="cpp"><code><span><span>#include</span><span> &lt;zigstuff.h&gt;</span></span>
<span><span>class</span><span> MyCppType</span><span> {</span></span>
<span><span>    ZigFoo foo;</span></span>
<span><span>};</span></span></code></pre>
<p>Keep in mind, I don’t want to just define all my Zig types as <code>extern</code> types. I want to use <strong>existing types from the standard library</strong> and be able to embed those inside my C++ types. I don’t want my choice of programming language to limit where I can put things in memory.</p>
<p>When you want to embed a type, you need its definition, but you don’t actually need the <strong>full definition</strong>. You just need the <strong>size/alignment</strong>. That tells the compiler where to offset it into the container type and how much space to reserve for it. In addition, both Zig and C++ can verify type sizes and alignment at compile time. So, we can replace needing the full type definition with a simple macro that provides an <strong>opaque type</strong> with the same size/alignment, and have the “home language” for that type verify it’s correct at compile time. Here’s such a macro:</p>
<pre tabindex="0" data-language="cpp"><code><span><span>#define</span><span> SIZED_OPAQUE</span><span>(</span><span>name</span><span>, </span><span>size</span><span>, </span><span>align</span><span>)                  </span><span>\</span></span>
<span><span>    typedef</span><span> struct</span><span> {                                     </span><span>\</span></span>
<span><span>        _Alignas</span><span>(</span><span>align</span><span>) </span><span>unsigned</span><span> char</span><span> _[size];           </span><span>\</span></span>
<span><span>    } </span><span>__attribute__((</span><span>aligned</span><span>(align)))</span><span> name;              </span><span>\</span></span>
<span><span>    enum</span><span> { name##Size = </span><span>size</span><span>, name##Align = </span><span>align</span><span> }</span></span>
<span></span>
<span><span>// Allows Zig to include fields that store a shared_ptr&lt;Foo&gt;</span></span>
<span><span>SIZED_OPAQUE</span><span>(SharedPtrFoo, </span><span>8</span><span>, </span><span>8</span><span>)</span></span>
<span></span>
<span><span>// Allows C++ to include fields that store a zig-native Foo struct</span></span>
<span><span>SIZED_OPAQUE</span><span>(ZigFoo, </span><span>120</span><span>, </span><span>4</span><span>)</span></span></code></pre>
<p>And both sides can verify the sizes at compile-time like this:</p>
<pre tabindex="0" data-language="zig"><code><span><span>const</span><span> c</span><span> =</span><span> @cImport</span><span>({</span><span>@cInclude</span><span>(</span><span>&#34;thestuff.h&#34;</span><span>)});</span></span>
<span><span>comptime</span><span> {</span></span>
<span><span>    if</span><span> (</span><span>@sizeOf</span><span>(</span><span>ZigFoo</span><span>) </span><span>!=</span><span> c</span><span>.</span><span>ZigFooSize</span><span>) {</span></span>
<span><span>        @compileError</span><span>(</span><span>std</span><span>.</span><span>fmt</span><span>.</span><span>comptimePrint</span><span>(</span><span>&#34;define ZigFoo size as: {}&#34;</span><span>, .{</span><span>@sizeOf</span><span>(</span><span>ZigFoo</span><span>)}));</span></span>
<span><span>    }</span></span>
<span><span>    if</span><span> (</span><span>@alignOf</span><span>(</span><span>ZigFoo</span><span>) </span><span>!=</span><span> c</span><span>.</span><span>ZigFooAlign</span><span>) {</span></span>
<span><span>        @compileError</span><span>(</span><span>std</span><span>.</span><span>fmt</span><span>.</span><span>comptimePrint</span><span>(</span><span>&#34;define ZigFoo align as: {}&#34;</span><span>, .{</span><span>@alignOf</span><span>(</span><span>ZigFoo</span><span>)}));</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<pre tabindex="0" data-language="cpp"><code><span><span>static_assert</span><span>(</span><span>sizeof</span><span>(SharedPtrFoo) </span><span>==</span><span> sizeof</span><span>(</span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>Foo</span><span>&gt;</span><span>));</span></span>
<span><span>static_assert</span><span>(</span><span>alignof</span><span>(SharedPtrFoo) </span><span>==</span><span> alignof</span><span>(</span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>Foo</span><span>&gt;</span><span>));</span></span></code></pre>
<p>One case where I’m using this is to store an instance of Zig’s <code>std.http.Client</code> in a C++ class. The size of that changes depending on the optimization mode, which looks like this:</p>
<pre tabindex="0" data-language="cpp"><code><span><span>#if</span><span> defined</span><span>(</span><span>ZIG_OPTIMIZE_DEBUG</span><span>)</span></span>
<span><span>    SIZED_OPAQUE</span><span>(HttpZig, </span><span>81152</span><span>, </span><span>8</span><span>);</span></span>
<span><span>#elif</span><span> defined</span><span>(ZIG_OPTIMIZE_SMALL)</span></span>
<span><span>    SIZED_OPAQUE</span><span>(HttpZig, </span><span>81136</span><span>, </span><span>8</span><span>);</span></span>
<span><span>#elif</span><span> defined</span><span>(ZIG_OPTIMIZE_SAFE)</span></span>
<span><span>    SIZED_OPAQUE</span><span>(HttpZig, </span><span>81144</span><span>, </span><span>8</span><span>);</span></span>
<span><span>#else</span></span>
<span><span>    #error</span><span> ZIG_OPTIMIZE_ not defined</span></span>
<span><span>#endif</span></span></code></pre>
<p>Maybe at some point I’ll make a build step that generates this info, but this is a simple starting point. Plus, it’s nice to see the actual sizes and get notified when they change.</p>
<p>Once you have the types, how do you use them? The short answer is <strong>pointers</strong>. For example, if you want to pass a <code>shared_ptr</code> to Zig, you need to pass a pointer to the shared pointer, like this:</p>
<pre tabindex="0" data-language="zig"><code><span><span>export</span><span> fn</span><span> takeMyString</span><span>(</span><span>from_cpp</span><span>: </span><span>*</span><span>c</span><span>.</span><span>SharedPtrStdString</span><span>) </span><span>void</span><span> {</span></span>
<span><span>    // DON&#39;T do this: you can&#39;t just copy a shared ptr without asking C++ for permission first</span></span>
<span><span>    // const bad_boi: c.SharedPtrStdString = from_cpp.*;</span></span>
<span></span>
<span><span>    // DO this: define methods to play with your C++ types</span></span>
<span><span>    var</span><span> my_string</span><span>: </span><span>c</span><span>.</span><span>SharedPtrStdString</span><span> =</span><span> undefined</span><span>;</span></span>
<span><span>    c</span><span>.</span><span>shared_ptr_std_string_move</span><span>(</span><span>&amp;</span><span>my_string</span><span>, </span><span>from_cpp</span><span>); </span><span>// Use C++ function to move</span></span>
<span></span>
<span><span>    const</span><span> data</span><span>: [</span><span>*</span><span>]</span><span>const</span><span> u8</span><span> =</span><span> c</span><span>.</span><span>shared_ptr_std_string_data</span><span>(</span><span>&amp;</span><span>my_string</span><span>);</span></span>
<span><span>    const</span><span> size</span><span>: </span><span>usize</span><span> =</span><span> c</span><span>.</span><span>shared_ptr_std_string_size</span><span>(</span><span>&amp;</span><span>my_string</span><span>);</span></span>
<span><span>    std</span><span>.</span><span>log</span><span>.</span><span>info</span><span>(</span><span>&#34;the string is &#39;{s}&#39;&#34;</span><span>, .{</span><span>data</span><span>[</span><span>0</span><span>..</span><span>size</span><span>]});</span></span>
<span></span>
<span><span>    giveBackToCpp</span><span>(</span><span>&amp;</span><span>my_string</span><span>);</span></span>
<span><span>}</span></span>
<span><span>extern</span><span> fn</span><span> giveBackToCpp</span><span>(</span><span>s</span><span>: </span><span>*const</span><span> c</span><span>.</span><span>SharedPtrStdString</span><span>) </span><span>void</span><span>;</span></span></code></pre>
<p>Notice that we’ve defined any function we need from C++ to move types around or access data. On the C++ side you’ll need a bunch of casting. However, I recently found a new pattern I quite like. In C++, if a type is defined by C++ then it’s “<strong>concrete</strong>,” otherwise it’s “<strong>opaque</strong>.” If you’re passing pointers to shared pointers and casting between them, you’ll find yourself with sore eyes from squinting too much, i.e.:</p>
<pre tabindex="0" data-language="cpp"><code><span><span>void</span><span> screen_video_sink_remove</span><span>(</span><span>const</span><span> SharedPtrScreenVideoSink</span><span>*</span><span> sink</span><span>, </span><span>const</span><span> SharedPtrTnPeer</span><span>*</span><span> peer</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    const</span><span> std</span><span>::shared_ptr</span><span>&lt;</span><span>ScreenVideoSink</span><span>&gt;&amp;</span><span> sink_cpp </span><span>=</span><span> *</span><span>((</span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>ScreenVideoSink</span><span>&gt;*</span><span>)sink);</span></span>
<span><span>    const</span><span> std</span><span>::shared_ptr</span><span>&lt;</span><span>tn</span><span>::Peer</span><span>&gt;&amp;</span><span> peer_cpp </span><span>=</span><span> *</span><span>(</span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>tn</span><span>::Peer</span><span>&gt;*</span><span>)peer;</span></span>
<span><span>    peer_cpp-&gt;</span><span>RemoveVideoSink</span><span>(sink_cpp, </span><span>tn</span><span>::</span><span>Peer</span><span>::</span><span>VideoSource</span><span>::Screen);</span></span>
<span><span>}</span></span></code></pre>
<p>The new pattern I’ve taken to is a macro that takes an opaque/concrete type pair and gives you the functions needed to convert them, i.e.</p>
<pre tabindex="0" data-language="cpp"><code><span><span>    // defines conversion functions between the &#34;opaque types&#34; used by Zig</span></span>
<span><span>    // and the concrete types in C++</span></span>
<span><span>    #define</span><span> DEFINE_OPAQUE_CONCRETE</span><span>(</span><span>Opaque</span><span>, </span><span>Concrete</span><span>) </span><span>\</span></span>
<span><span>        Opaque</span><span>*</span><span> opaque</span><span>(</span><span>Concrete</span><span>*</span><span> c</span><span>) { </span><span>return</span><span> reinterpret_cast&lt;</span><span>Opaque</span><span>*&gt;</span><span>(c); } </span><span>\</span></span>
<span><span>        const</span><span> Opaque</span><span>*</span><span> opaque</span><span>(</span><span>const</span><span> Concrete</span><span>*</span><span> c</span><span>) { </span><span>return</span><span> reinterpret_cast&lt;const</span><span> Opaque</span><span>*&gt;</span><span>(c); } </span><span>\</span></span>
<span><span>        Concrete</span><span>&amp;</span><span> concrete</span><span>(</span><span>Opaque</span><span>*</span><span> o</span><span>) { </span><span>return</span><span> *reinterpret_cast&lt;</span><span>Concrete</span><span>*&gt;</span><span>(o); } </span><span>\</span></span>
<span><span>        const</span><span> Concrete</span><span>&amp;</span><span> concrete</span><span>(</span><span>const</span><span> Opaque</span><span>*</span><span> o</span><span>) { </span><span>return</span><span> *reinterpret_cast&lt;const</span><span> Concrete</span><span>*&gt;</span><span>(o); }</span></span>
<span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(StdString, </span><span>std</span><span>::string)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(SharedPtrTnCall, </span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>tn</span><span>::Call</span><span>&gt;</span><span>)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(SharedPtrTnPeer, </span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>tn</span><span>::Peer</span><span>&gt;</span><span>)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(SharedPtrTnCallNotification, </span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>tn</span><span>::CallNotification</span><span>&gt;</span><span>)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(ClientAuthSessionOpaque, </span><span>tn</span><span>::</span><span>RestAPI</span><span>::ClientAuthSession)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(TnCurrentUser, </span><span>tn</span><span>::</span><span>RestAPI</span><span>::CurrentUser)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(WebrtcVideoFrameBuffer, </span><span>webrtc</span><span>::VideoFrameBuffer)</span></span>
<span><span>    DEFINE_OPAQUE_CONCRETE</span><span>(SharedPtrScreenVideoSink, </span><span>std</span><span>::shared_ptr</span><span>&lt;</span><span>ScreenVideoSink</span><span>&gt;</span><span>)</span></span></code></pre>
<p>And our code above now becomes:</p>
<pre tabindex="0" data-language="cpp"><code><span><span>void</span><span> screen_video_sink_remove</span><span>(</span><span>const</span><span> SharedPtrScreenVideoSink</span><span>*</span><span> sink</span><span>, </span><span>const</span><span> SharedPtrTnPeer</span><span>*</span><span> peer</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    concrete</span><span>(peer)-&gt;</span><span>RemoveVideoSink</span><span>(</span><span>concrete</span><span>(sink), </span><span>tn</span><span>::</span><span>Peer</span><span>::</span><span>VideoSource</span><span>::Screen);</span></span>
<span><span>}</span></span></code></pre>
<p>This is much improved as we’ve now pre-ordained the right conversions up-front and no longer have to re-audit the casts for every single conversion.</p>   </div> </div>  </div></div>
  </body>
</html>
