<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2022/05/14/">Original</a>
    <h1>A lock-free, concurrent, generic queue in 32 bits</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
  
  <time datetime="2022-05-14">
    May 14, 2022
  </time>
  <p>
    nullprogram.com/blog/2022/05/14/
  </p>

  <p><em>This article was discussed <a href="https://news.ycombinator.com/item?id=31384602">on Hacker News</a>.</em></p>

<p>While considering concurrent queue design I came up with a generic,
lock-free queue that fits in a 32-bit integer. The queue is “generic” in
that a single implementation supports elements of any arbitrary type,
despite an implementation in C. It’s lock-free in that there is guaranteed
system-wide progress. It can store up to 32,767 elements at a time — more
than enough for message queues, which <a href="https://nullprogram.com/blog/2020/05/24/">must always be bounded</a>. I
will first present a single-consumer, single-producer queue, then expand
support to multiple consumers at a cost. Like <a href="https://nullprogram.com/blog/2022/03/13/">my lightweight barrier</a>,
I’m not presenting this as a packaged solution, but rather as a technique
you can apply when circumstances call.</p>

<!--more-->

<p>How can the queue store so many elements when it’s just 32 bits? It only
handles the indexes of a circular buffer. The <a href="https://nullprogram.com/blog/2018/06/10/">caller is responsible</a>
for allocating and manipulating the queue’s storage, which, in the
single-consumer case, doesn’t require anything fancy. Synchronization is
managed by the queue.</p>

<p>Like a typical circular buffer, it has a head index and a tail index. The
head is the next element to be pushed, and the tail is the next element to
be popped. The queue storage must have a power-of-two length, but the
capacity is one less than the length. If the head and tail are equal then
the queue is empty. This “wastes” one element, which is why the capacity
is one less than the length of the storage. So already there are some
notable constraints imposed by this design, but I believe the main use
case for such a queue — a job queue for CPU-bound jobs — has no problem
with these constraints.</p>

<p>Since this is a concurrent queue it’s worth noting “ownership” of storage
elements. The consumer owns elements from the tail up to, but excluding,
the head. The producer owns everything else. Both pushing and popping
involve a “commit” step that transfers ownership of an element to the
other thread. No elements are accessed concurrently, which makes things
easy for either caller.</p>

<h3 id="queue-usage">Queue usage</h3>

<p>Pushing (to the front) and popping (from the back) are each a three-step
process:</p>

<ol>
  <li>Obtain the element index</li>
  <li>Access that element</li>
  <li>Commit the operation</li>
</ol>

<p>I’ll be using C11 atomics for my implementation, but it should be easy to
translate these into something else no matter the programming language. As
I mentioned, the queue fits in a 32-bit integer, and so it’s represented
by an <code>_Atomic uint32_t</code>. Here’s the entire interface:</p>

<div><div><pre><code><span>int</span>  <span>queue_pop</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>queue</span><span>,</span> <span>int</span> <span>exp</span><span>);</span>
<span>void</span> <span>queue_pop_commit</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>queue</span><span>);</span>

<span>int</span>  <span>queue_push</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>queue</span><span>,</span> <span>int</span> <span>exp</span><span>);</span>
<span>void</span> <span>queue_push_commit</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>queue</span><span>);</span>
</code></pre></div></div>

<p>Both <code>queue_pop</code> and <code>queue_push</code> return -1 if the queue is empty/full.</p>

<p>To create a queue, initialize an atomic 32-bit integer to zero. Also
choose a size exponent and allocate some storage. Here’s a 63-element
queue of jobs:</p>

<div><div><pre><code><span>#define EXP 6  // note; 2**6 == 64
</span><span>struct</span> <span>job</span> <span>slots</span><span>[</span><span>1</span><span>&lt;&lt;</span><span>EXP</span><span>];</span>
<span>_Atomic</span> <span>uint32_t</span> <span>q</span> <span>=</span> <span>0</span><span>;</span>
</code></pre></div></div>

<p>Rather than a length, the queue functions accept a base-2 exponent, which
is why I’ve defined <code>EXP</code>. If you don’t like this, you can just accept a
length in your own implementation, though remember it’s constrained to
powers of two. The producer might look like so:</p>

<div><div><pre><code><span>for</span> <span>(;;)</span> <span>{</span>
    <span>int</span> <span>i</span><span>;</span>
    <span>do</span> <span>{</span>
        <span>i</span> <span>=</span> <span>queue_push</span><span>(</span><span>&amp;</span><span>q</span><span>,</span> <span>EXP</span><span>);</span>
    <span>}</span> <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>0</span><span>);</span>  <span>// note: busy-wait while full</span>
    <span>slots</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>job_create</span><span>();</span>
    <span>queue_push_commit</span><span>(</span><span>&amp;</span><span>q</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This is a busy-wait loop, which makes for a simple illustration but isn’t
ideal. In a real program I’d have the producer run a job while it waits
for a queue slot, or just have it turn into a consumer (if this wasn’t a
single-consumer queue). Similarly, if the queue is empty, then maybe a
consumer turns into the producer. It all depends on the context.</p>

<p>The consumer might look like so:</p>

<div><div><pre><code><span>for</span> <span>(;;)</span> <span>{</span>
    <span>int</span> <span>i</span><span>;</span>
    <span>do</span> <span>{</span>
        <span>i</span> <span>=</span> <span>queue_pop</span><span>(</span><span>&amp;</span><span>q</span><span>,</span> <span>EXP</span><span>);</span>
    <span>}</span> <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>0</span><span>);</span>  <span>// note: busy-wait while empty</span>
    <span>struct</span> <span>job</span> <span>job</span> <span>=</span> <span>slots</span><span>[</span><span>i</span><span>];</span>
    <span>queue_pop_commit</span><span>(</span><span>&amp;</span><span>q</span><span>);</span>
    <span>job_run</span><span>(</span><span>job</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>In either case it’s important that neither touches the element after
committing since that transfers ownership away.</p>

<h3 id="pop-operation">Pop operation</h3>

<p>The queue is actually a pair of 16-bit integers, head and tail, each
stored in the low and high halves of the 32-bit integer. So the first
thing to do is atomically load the integer, then extract these “fields.”</p>

<p>If for some reason a capacity of 32,767 is insufficient, you can trivially
upgrade your queue to an Enterprise Queue: a 64-bit integer with a
capacity of over 2 billion elements. I’m going to stick with the 32-bit
queue.</p>

<p>Starting with the pop operation since it’s simpler:</p>

<div><div><pre><code><span>int</span> <span>queue_pop</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>q</span><span>,</span> <span>int</span> <span>exp</span><span>)</span>
<span>{</span>
    <span>uint32_t</span> <span>r</span> <span>=</span> <span>*</span><span>q</span><span>;</span>  <span>// consider &#34;acquire&#34;</span>
    <span>int</span> <span>mask</span> <span>=</span> <span>(</span><span>1u</span> <span>&lt;&lt;</span> <span>exp</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>int</span> <span>head</span> <span>=</span> <span>r</span>     <span>&amp;</span> <span>mask</span><span>;</span>
    <span>int</span> <span>tail</span> <span>=</span> <span>r</span><span>&gt;&gt;</span><span>16</span> <span>&amp;</span> <span>mask</span><span>;</span>
    <span>return</span> <span>head</span> <span>==</span> <span>tail</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>tail</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>If the indexes are equal, the queue is empty. Otherwise return the tail
field. The <code>*q</code> is an atomic load since it’s qualified <code>_Atomic</code>. The load
might be more efficient if this were an explicit “acquire” operation,
which is what I used in some of my tests.</p>

<p>To complete the pop, atomically increment the tail index so that the
element falls out of the range of elements owned by the consumer. The tail
is the high half of the integer so add <code>0x10000</code> rather than just 1.</p>

<div><div><pre><code><span>void</span> <span>queue_pop_commit</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>q</span><span>)</span>
<span>{</span>
    <span>*</span><span>q</span> <span>+=</span> <span>0x10000</span><span>;</span>  <span>// consider &#34;release&#34;</span>
<span>}</span>
</code></pre></div></div>

<p>It’s harmless if this overflows since it’s congruent with the power-of-two
storage length, and an overflow won’t affect the head index. The increment
might be more efficient if this were an explicit “release” operation,
which, again, is what I used in some of my tests.</p>

<h3 id="push-operation">Push operation</h3>

<p>Pushing is a little more complex. As is typical with circular buffers,
before doing anything it must ensure the result won’t ambiguously create
an empty queue.</p>

<div><div><pre><code><span>int</span> <span>queue_push</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>q</span><span>,</span> <span>int</span> <span>exp</span><span>)</span>
<span>{</span>
    <span>uint32_t</span> <span>r</span> <span>=</span> <span>*</span><span>q</span><span>;</span>  <span>// consider &#34;acquire&#34;</span>
    <span>int</span> <span>mask</span> <span>=</span> <span>(</span><span>1u</span> <span>&lt;&lt;</span> <span>exp</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>int</span> <span>head</span> <span>=</span> <span>r</span>     <span>&amp;</span> <span>mask</span><span>;</span>
    <span>int</span> <span>tail</span> <span>=</span> <span>r</span><span>&gt;&gt;</span><span>16</span> <span>&amp;</span> <span>mask</span><span>;</span>
    <span>int</span> <span>next</span> <span>=</span> <span>(</span><span>head</span> <span>+</span> <span>1u</span><span>)</span> <span>&amp;</span> <span>mask</span><span>;</span>
    <span>if</span> <span>(</span><span>r</span> <span>&amp;</span> <span>0x8000</span><span>)</span> <span>{</span>  <span>// avoid overflow on commit</span>
        <span>*</span><span>q</span> <span>&amp;=</span> <span>~</span><span>0x8000</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>next</span> <span>==</span> <span>tail</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>head</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>It’s important that incrementing the head field won’t overflow into the
tail field, so it atomically clears the high bit if set, giving the
increment overhead into which it can overflow.</p>

<div><div><pre><code><span>void</span> <span>queue_push_commit</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>q</span><span>)</span>
<span>{</span>
    <span>*</span><span>q</span> <span>+=</span> <span>1</span><span>;</span>  <span>// consider &#34;release&#34;</span>
<span>}</span>
</code></pre></div></div>

<h3 id="multiple-consumers">Multiple-consumers</h3>

<p>The single producer and single consumer didn’t require locks nor atomic
accesses to the storage array since the queue guaranteed that accesses at
the specified index were not concurrent. However, this is not the case
with multiple-consumers. Consumers race when popping. The loser’s access
might occur after the winner’s commit, making its access concurrent with
the producer. Both producer and consumers must account for this.</p>

<div><div><pre><code><span>_Atomic</span> <span>struct</span> <span>job</span> <span>slots</span><span>[</span><span>1</span><span>&lt;&lt;</span><span>EXP</span><span>];</span>
</code></pre></div></div>

<p>To prepare for multiple consumers, the array now has an atomic qualifier:
one of the costs of multiple consumers. Fortunately these new atomic
accesses can use a “relaxed” ordering since there are no required ordering
constraints. Even if it wasn’t atomic, and <a href="https://lwn.net/Articles/793253/">the load was torn</a>, we’d
detect it when attempting to commit. It’s simply against the rules to have
a data race, and I don’t know how else to avoid it other than dropping
into assembly.</p>

<p>The next cost is that committing can fail. Another consumer might have won
the race, which means you must start over. Here’s my multiple-consumer
interface, which I’ve uncreatively called <code>mpop</code> (“multiple-consumer
pop”). Besides a <code>_Bool</code> for indicating failure, the main change is a new
<code>save</code> parameter:</p>

<div><div><pre><code><span>int</span>   <span>queue_mpop</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>,</span> <span>int</span><span>,</span> <span>uint32_t</span> <span>*</span><span>save</span><span>);</span>
<span>_Bool</span> <span>queue_mpop_commit</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>,</span> <span>uint32_t</span> <span>save</span><span>);</span>
</code></pre></div></div>

<p>The caller must carry some temporary state (<code>save</code>), which is how failures
are detected, ultimately communicated by that <code>_Bool</code> return.</p>

<div><div><pre><code><span>for</span> <span>(;;)</span> <span>{</span>
    <span>int</span> <span>i</span><span>;</span>
    <span>int32_t</span> <span>save</span><span>;</span>
    <span>struct</span> <span>job</span> <span>job</span><span>;</span>
    <span>do</span> <span>{</span>
        <span>do</span> <span>{</span>
            <span>i</span> <span>=</span> <span>queue_mpop</span><span>(</span><span>&amp;</span><span>q</span><span>,</span> <span>EXP</span><span>,</span> <span>&amp;</span><span>save</span><span>);</span>
        <span>}</span> <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>0</span><span>);</span>  <span>// note: busy-wait while empty</span>
        <span>job</span> <span>=</span> <span>slots</span><span>[</span><span>i</span><span>];</span>
    <span>}</span> <span>while</span> <span>(</span><span>!</span><span>queue_mpop_commit</span><span>(</span><span>&amp;</span><span>q</span><span>,</span> <span>save</span><span>));</span>
    <span>job_run</span><span>(</span><span>job</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>It’s important that the consumer doesn’t attempt to use <code>job</code> until a
successful commit, since it might not be valid. As noted, that load could
be relaxed (what a mouthful):</p>

<div><div><pre><code><span>job</span> <span>=</span> <span>atomic_load_explicit</span><span>(</span><span>slots</span><span>+</span><span>i</span><span>,</span> <span>memory_order_relaxed</span><span>);</span>
</code></pre></div></div>

<p>Here’s the pop implementation:</p>

<div><div><pre><code><span>int</span> <span>queue_mpop</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>q</span><span>,</span> <span>int</span> <span>exp</span><span>,</span> <span>uint32_t</span> <span>*</span><span>save</span><span>)</span>
<span>{</span>
    <span>uint32_t</span> <span>r</span> <span>=</span> <span>*</span><span>save</span> <span>=</span> <span>*</span><span>q</span><span>;</span>
    <span>int</span> <span>mask</span> <span>=</span> <span>(</span><span>1u</span> <span>&lt;&lt;</span> <span>exp</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>int</span> <span>head</span> <span>=</span> <span>r</span>     <span>&amp;</span> <span>mask</span><span>;</span>
    <span>int</span> <span>tail</span> <span>=</span> <span>r</span><span>&gt;&gt;</span><span>16</span> <span>&amp;</span> <span>mask</span><span>;</span>
    <span>return</span> <span>head</span> <span>==</span> <span>tail</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>tail</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>So far it’s exactly the same, except it stores a full snapshot of the
queue state in <code>*save</code>. This is needed for a compare-and-swap (CAS) in the
commit, which checks that the queue hasn’t been modified concurrently
(i.e. by another consumer):</p>

<div><div><pre><code><span>_Bool</span> <span>queue_mpop_commit</span><span>(</span><span>_Atomic</span> <span>uint32_t</span> <span>*</span><span>q</span><span>,</span> <span>uint32_t</span> <span>save</span><span>)</span>
<span>{</span>
    <span>return</span> <span>atomic_compare_exchange_strong</span><span>(</span><span>q</span><span>,</span> <span>&amp;</span><span>save</span><span>,</span> <span>save</span><span>+</span><span>0x10000</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>As always with CAS, we must be wary of <a href="https://nullprogram.com/blog/2014/09/02/">the ABA problem</a>. Imagine
that between starting to pop and this CAS that the producer and another
consumer looped over the entire queue and ended up back at exactly the
same spot as where we started. The queue would look like we expect, and
the commit would “succeed” despite reading a garbage value.</p>

<p>Fortunately this matches the entire 32-bit state, and so a small queue
capacity is not at a greater risk. The tail counter is always 16 bits, and
the head counter is 15 bits (due to keeping the 16th clear for overflow).
The chance of them landing at exactly the same count is low. Though if
those odds aren’t low enough, as mentioned you can always upgrade to the
64-bit Enterprise Queue with larger counters.</p>

<p>There’s a notable performance defect with this particular design. If the
producer concurrently pushes a new value, the commit will fail even if
there was no real race since only the head field changed. It would be
better if the head field was isolated from the tail field…</p>

<h3 id="a-less-cheeky-design">A less cheeky design</h3>

<p>You might have noticed that there’s little reason to pack two 16-bit
counters into a 32-bit integer. These could just be fields in a structure:</p>

<div><div><pre><code><span>struct</span> <span>queue</span> <span>{</span>
    <span>_Atomic</span> <span>uint16_t</span> <span>head</span><span>;</span>
    <span>_Atomic</span> <span>uint16_t</span> <span>tail</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>While this entire structure can be atomically loaded just like the 32-bit
integer, C11 (and later) do not permit non-atomic accesses to these atomic
fields in an unshared copy loaded from an atomic. So I’d either use
compiler-specific built-ins for atomics — much more flexible, and what I
prefer anyway — or just load them individually:</p>

<div><div><pre><code><span>int</span> <span>queue_pop</span><span>(</span><span>struct</span> <span>queue</span> <span>*</span><span>q</span><span>,</span> <span>int</span> <span>exp</span><span>,</span> <span>uint16_t</span> <span>*</span><span>save</span><span>)</span>
<span>{</span>
    <span>int</span> <span>mask</span> <span>=</span> <span>(</span><span>1u</span> <span>&lt;&lt;</span> <span>exp</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>int</span> <span>head</span> <span>=</span> <span>q</span><span>-&gt;</span><span>head</span> <span>&amp;</span> <span>mask</span><span>;</span>
    <span>int</span> <span>tail</span> <span>=</span> <span>(</span><span>*</span><span>save</span> <span>=</span> <span>q</span><span>-&gt;</span><span>tail</span><span>)</span> <span>&amp;</span> <span>mask</span><span>;</span>
    <span>return</span> <span>head</span> <span>==</span> <span>tail</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>tail</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Technically with two loads this could extract a <code>head</code>/<code>tail</code> pair that
were never contemporaneous. The worst case is the queue appears empty even
if it was never actually empty.</p>

<div><div><pre><code><span>_Bool</span> <span>queue_mpop_commit</span><span>(</span><span>struct</span> <span>queue</span> <span>*</span><span>q</span><span>,</span> <span>uint16_t</span> <span>save</span><span>)</span>
<span>{</span>
    <span>return</span> <span>atomic_compare_exchange_strong</span><span>(</span><span>&amp;</span><span>q</span><span>-&gt;</span><span>tail</span><span>,</span> <span>&amp;</span><span>save</span><span>,</span> <span>save</span><span>+</span><span>1</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Since the head index isn’t part of the CAS, the producer can’t interfere
with the commit. (Though there’s still certainly false sharing happening.)</p>

<h3 id="real-implementation-and-tests">Real implementation and tests</h3>

<p>If you want to try it out, especially with my tests: <a href="https://github.com/skeeto/scratch/blob/master/misc/queue.c"><strong>queue.c</strong></a>.
It has both single-consumer and multiple-consumer queues, and supports at
least:</p>

<ul>
  <li>atomics: C11, GNU, MSC</li>
  <li>threads: pthreads, win32</li>
  <li>compilers: GCC, Clang, MSC</li>
  <li>hosts: Linux, Windows, BSD</li>
</ul>

<p>Since I wanted to test across a variety of implementations, especially
under Thread Sanitizer (TSan). On a similar note, I also implemented a
concurrent queue shared between C and Go: <a href="https://github.com/skeeto/scratch/blob/master/misc/queue.go"><strong>queue.go</strong></a>.</p>



  
  <ol></ol>

  

  <nav>
  
    
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
