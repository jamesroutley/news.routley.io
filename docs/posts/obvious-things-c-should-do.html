<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.digitalmars.com/articles/Cobvious.html">Original</a>
    <h1>Obvious things C should do</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  
  
<p><small>January 8, 2025</small></p>

<p><small>written by <a href="https://x.com/WalterBright">Walter Bright</a></small></p>

<p>Standard C undergoes regular improvements, now at C23.
But there are baffling things that have not been fixed at all.
The Dlang community embedded a C compiler in the D programming language compiler so it could compile C.
This C compiler (aka <i>ImportC</i>) was built from scratch.
It provided the opportunity to use modern compiler technology to fix those shortcomings.
Why doesn’t Standard C fix them?
</p>


<ul><li>Evaluating Constant Expressions</li>
<li>Compile Time Unit Tests</li>
<li>Forward Referencing of Declarations</li>
<li>Importing Declarations</li>
</ul>



<h3>Evaluating <i>constant-expression</i></h3>

<p>Consider the following C code:
</p>

<pre>int sum(int a, int b) { return a + b; }

enum E { A = 3, B = 4, C = sum(5, 6) };
</pre>

<p>When compiled with gcc:
</p>

<pre>gcc -c test.c
test.c:3:20: error: enumerator value for C is not an integer constant
 enum E { A = 3, B, C = sum(5, 6) };
                    ^
</pre><p>

In other words, while C can compute at compile time a simple expression
by <i>constant folding</i>,
it cannot execute a function at compile time. But <i>ImportC</i> can.

</p><p>Everywhere a C <i>constant-expression</i> appears in the C grammar
the compiler should be able to execute functions at compile time, too,
as long as the functions do not do things like I/O, access mutable global
variables, make system calls, etc.</p>



<h3>Compile Time Unit Testing</h3>

<p>Once the C compiler can do compile time function evaluation (CTFE), suddenly
other things become possible.</p>

<p>For example, ever notice that seeing unit tests in C code is (unfortunately)
rather rare? The reason is simple - unittests require a separate target in the
build system, and must be built and run as a separate executable. Being a bit of a
nuisance means it just does not happen. (Maybe you are one of those people who
get up and jog a mile every morning, and you probably also carefully write unit
test setups! I know you exist out there - somewhere!)
</p>

<pre>int sum(int a, int b) { return a + b; }

_Static_assert(sum(3, 4) == 7, &#34;test #1&#34;);
</pre>

<pre>gcc -c test.c
test.c:3:16: error: expression in static assertion is not constant
_Static_assert(sum(3, 4) == 7, &#34;test #1&#34;);
               ^
</pre>

<p><i>ImportC</i> can compile it.</p>

<p>This enables unit tests of functions that can be run at compile
time. No separate build is required. No extra work is required. The unit tests
run <i>every time</i> the code is compiled. I use this extensively in the test suite
for <i>ImportC</i>.</p>




<h3>Forward Referencing of Declarations</h3>

<p>More code:</p>

<pre>int floo(int a, char *s) { return dex(s, a); }

char dex(char *s, int i) { return s[i]; }
</pre>

<pre>gcc -c test.c
test.c:4:6: error: conflicting types for dex
 char dex(char *s, int i) { return s[i]; }
      ^
test.c:2:35: note: previous implicit declaration of dex was here
 int floo(int a, char *s) { return dex(s, a); }
</pre>

<p>If the order of floo and dex are reversed, it compiles fine.
I.e. the compiler only knows about what lexically precedes it.
Forward references are not allowed.
Isn’t this stone age compiler design? Modern languages don’t have this
problem, why does it persist in C and C++? <i>ImportC</i> is not a modern language,
but it is a modern compiler and accepts arbitrary orders of the global
declarations.</p>

<p>Why does this matter? It usually means that every forward definition needs
an extra declaration:</p>

<pre>char dex(char *s, int i); // declaration

int floo(int a, char *s) { return dex(s, a); }

char dex(char *s, int i) { return s[i]; } // definition
</pre>

<p>It’s just purposeless busywork to do that. Not only is it a nuisance, it drives
programmers to lay out the declarations <i>backwards</i>. The leaf functions come first,
and the global interface functions are last. It’s like reading a newspaper article from
the bottom up. It makes no sense.</p>

<p><i>ImportC</i> can compile the declarations in any order.</p>



<h3>Importing Declarations</h3>

<p>Given three files, <tt>floo.d</tt>, <tt>dex.h</tt>, <tt>dex.c</tt>:</p>

<pre>// floo.c
#include &#34;dex.h&#34;
int floo(int a, char *s) { return dex(s, a); }
</pre>

<pre>// dex.h
char dex(char *s, int i);
</pre>

<pre>// dex.c
#include &#34;dex.h&#34;
char dex(char *s, int i) { return s[i]; }
</pre>

<p>Having to craft a <tt>.h</tt> file for each external module is a lot of busy work,
right? Even worse, if the <tt>.h</tt> file turns out to not exactly match the <tt>.c</tt> file, you are
in for a lot of time trying to figure out what went wrong.
</p>

<p>What’s the answer? Importing dex.c!</p>

<pre>// floo.c
__import dex;
int floo(int a, char *s) { return dexx(s, a); }
</pre>

<pre>// dex.c
char dexx(char *s, int i) { return s[i]; }
</pre>

<p>No need to even write a <tt>.h</tt> file at all. Of course, this also works with <i>ImportC</i>.</p>



<h3>References</h3>

<ul>
<li><a href="https://dlang.org/spec/importc.html"><i>ImportC</i></a> documentation</li>
<li><a href="https://dlang.org">D Language</a> documentation</li>

</ul>





  
<!-- Google ad -->


</div><p>

Copyright © 1999-2025 by Digital Mars ®, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</p></div>
  </body>
</html>
