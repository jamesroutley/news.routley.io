<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/first-regions-prototype">Original</a>
    <h1>Vale&#39;s First Prototype for Immutable Region Borrowing</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
    <div>
  

        <div>
          <div>
  

            <div>
    

              
    

              <p>Results and measurements!</p>
        

              <p><span>July 11, 2023</span>
        

                <span> — </span>
          

                
        

                  <span> — </span>
          

                  <span>Sponsor on <a href="https://github.com/sponsors/ValeLang">GitHub</a> 
                  or <a href="https://www.patreon.com/user/about?u=5018675">Patreon</a>!</span>
        

              </p>
      

            </div>
    
<section>
<p>
Three years, two states, and one pandemic ago, I wrote about a very weird idea: what if the type system could track which data existed before a pure call, to eliminate its memory safety overhead? <a href="#note0" data-noteid="0">0</a>
</p>

</section>
<section>
<p>
And a couple months later, another weird idea struck: what if we use generational indices as the foundation for an entire language?
</p>

</section>
<section>
<p>
These ideas evolved in <i>weird</i> ways. The first one evolved into a full <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">region-based borrowing system</a>. The second one became <a href="https://verdagon.dev/blog/generational-references">generational references</a>. Together, they looked like they could form an <b>entirely new approach</b> to memory safety, one that doesn&#39;t use reference counting, tracing garbage collection, nor borrow checking.
</p>

</section>
<section>
<p>
Basically, the coder writes their program in a normal C or C++ish way, and Vale&#39;s generational references keep everything memory safe. Then, the coder can use <span>pure</span> and <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-part-1-immutable-borrowing">region borrowing</a> to eliminate most generation check overhead. <a href="#note1" data-noteid="1">1</a> Add in some <a href="https://verdagon.dev/blog/linear-types-borrowing">linear style</a>, <a href="#note2" data-noteid="2">2</a> and we can get generation checks <b>down to zero</b> for any Vale code.
</p>

</section>
<section>
<p>
In other words, this could make our Vale code very, very fast.
</p>

</section>
<section>
<p>
The exciting part is that region borrowing is completely opt-in. We could write our code in a <b>normal, comfortable way,</b> and later add region borrowing for the parts that we want to optimize, almost like a more flexible, opt-in borrow checker. <a href="#note3" data-noteid="3">3</a> We could choose which parts of our program should be as flexible as Java, or as fast as Rust, or anywhere in-between.
</p>

</section>
<section>
<p>
But alas, it was all a theory. We couldn&#39;t play with it, because it wasn&#39;t real yet!
</p>

</section>

      </div>
  
<div>

      <nav>
      <p>Vale&#39;s First Prototype for Immutable Region Borrowing</p>
    


      </nav>
      
    

      <div>
        <div>
    
<div id="note0" data-noteid="0">
<p><span>0</span></p><section>
<p>
See the <a href="https://verdagon.dev/blog/zero-cost-refs-regions">original article here</a>, but keep in mind that was written before I came up with generational references!
</p>

</section>
</div>
<div id="note1" data-noteid="1">
<p><span>1</span></p><section>
<p>
A &#34;generation check&#34; happens whenever we dereference a generational reference. It checks to make sure the target object is still alive.
</p>

</section>
</div>
<div id="note2" data-noteid="2">
<p><span>2</span></p><section>
<p>
Linear style is where we never make a reference to something unless handing it into a pure function.
</p>

</section>
</div>
<div id="note3" data-noteid="3">
<p><span>3</span></p><section>
<p>
This is possible because it makes borrowing compose much better with shared mutability; you can do as much aliasing as you want and then turn the entire world immutable via <span>pure</span>.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="building-the-theory">
 Building the Theory</h2>

</section>
<section>
<p>
Most of my free time for the past few years has gone into building out the compiler&#39;s foundations so that it could support this unexplored approach.
</p>

</section>
<section>
<p>
It was <i>hard</i>. Any kind of borrowing system is already pretty complex, but they also require full generics, which are notoriously difficult. <a href="#note4" data-noteid="4">4</a> <a href="#note5" data-noteid="5">5</a>
</p>

</section>
<section>
<p>
On top of that, an entire new compiler stage was needed to get regions and generational references to work seamlessly together. <a href="#note6" data-noteid="6">6</a>
</p>

</section>
<section>
<p>
Finally, a few months ago, <b>the regions prototype was finished</b>. It&#39;s rough around the edges, <a href="#note7" data-noteid="7">7</a> but it successfully compiled something for the first time.
</p>

</section>
<section>
<p>
With that, I made the <a href="https://github.com/Verdagon/RegionsBenchmarks/blob/main/cellular-automata/CellularAutomata.vale">first ever zero-check Vale program</a>! <a href="#note8" data-noteid="8">8</a>
</p>
<p>
It was a program that uses <a href="https://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664">Cellular Automata</a> to generate a level for a roguelike game.
</p>

</section>
<section>



</section>
<section>
<p>
Of course, it didn&#39;t work perfectly at first. Compilers are tricky. The slightest misstep in the compiler code will add extra instructions to the resulting assembly, causing artificial overhead in the final program. And sometimes, there&#39;s extra little bits of information you need to pass to the optimizer (or the CPU itself!) to trick it into the most optimal behavior.
</p>

</section>
<section>
<p>
To help me track down the problems, I kept comparing its assembly to the assembly generated by Vale&#39;s &#34;unsafe&#34; modes:
</p>
<ul>
<li>
<span>unsafe_no_bounds</span> is similar to C; all memory-safety protections are turned off, and it only uses raw pointers for everything, rather than generational references.
</li>
<li>
<span>unsafe_with_bounds</span> then adds bounds checking for array accesses, similar to how Rust does it.
</li>
</ul>

</section>
<section>
<p>
After a couple months of tracking down differences, the resulting assembly looked nearly identical to Vale&#39;s <span>unsafe_with_bounds</span> mode! Every difference was expected <a href="#note9" data-noteid="9">9</a> and everything looked pretty reasonable.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note4" data-noteid="4">
<p><span>4</span></p><section>
<p>
Previously, Vale had templates (like C++), not full generics.
</p>

</section>
</div>
<div id="note5" data-noteid="5">
<p><span>5</span></p><section>
<p>
It took the Golang team a decade to figure out their generics, and I don&#39;t blame them at all for that, after this struggle with generics!
</p>

</section>
</div>
<div id="note6" data-noteid="6">
<p><span>6</span></p><section>
<p>
Under the hood, it reduces regions to &#34;pure height&#34; integers: negative for region generic parameters, zero for the default region, and increasing positive for every pure block.
</p>

</section>
</div>
<div id="note7" data-noteid="7">
<p><span>7</span></p><section>
<p>
For example, its compile errors are very, <i>very</i> verbose, and there are a lot of things that just trigger assertions in the compiler still. I&#39;ll be fixing all of these before merging it into the main branch.
</p>

</section>
</div>
<div id="note8" data-noteid="8">
<p><span>8</span></p><section>
<p>
You can count how many generation checks in a program via the <span>--print_mem_overhead true</span> compiler flag.
</p>

</section>
</div>
<div id="note9" data-noteid="9">
<p><span>9</span></p><section>
<p>
The only expected difference is that it put a pseudo-random generation number at the top of every allocation, though it never needed to read it for any generation checks. This is really just a monotonically increasing register under the hood, to keep things fast. We&#39;ll be able to remove this once we add <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-part-2-isolates">isolates</a> or <span>uni</span>que references.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="the-benchmarks">
 The Benchmarks</h2>
<p>
Finally, I benchmarked the program again:
</p>

</section>
<section>

    <div>
      
      <pre><code>Summary
  &#39;./build_unsafe_no_bounds/main&#39; ran
    1.18 ± 0.01 times faster than &#39;./build_unsafe_with_bounds/main&#39;
    1.18 ± 0.01 times faster than &#39;./build_safe_fastest/main&#39;</code></pre>
    </div>
  

</section>
<section>
<p>
Success! Vale&#39;s normal mode (<span>safe_fastest</span> here) showed no slowdowns compared to only bounds checking.
</p>

</section>
<section>
<p>
In other words, <b>this approach has no observable overhead.</b> <a href="#note10" data-noteid="10">10</a>
</p>

</section>
<section>
<p>
Finally seeing this was a shock, a relief, and almost surreal. No overhead! We knew it was possible in theory, but seeing it happen for real still felt very surprising.
</p>

</section>
<section>
<p>
Feel free to play with it! Just build from the <a href="https://github.com/Verdagon/Vale/tree/regions">regions branch</a>, check out the <a href="https://github.com/Verdagon/RegionsBenchmarks">benchmarking scripts</a>, and ask any questions in the <a href="https://discord.gg/SNB8yGH">discord server</a>.
</p>

</section>
<section>
<p>
And before we get too excited, let&#39;s keep these important details in mind:
</p>
<ul>
<li>
This is not benchmarking against languages like C and Rust directly. Those compilers have years of unrelated optimizations that would just confound the experiment, so I compare with <span>unsafe_no_bounds</span> and <span>unsafe_with_bounds</span> to isolate those variables and get a more accurate comparison of the memory safety approaches.
</li>
<li>
This was benchmarked on a Razer Blade 15&#34; 2018 (512GB SSD) running Ubuntu 22.04, using <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> inside a <a href="https://manpages.ubuntu.com/manpages/trusty/man1/cset-shield.1.html">cset shield</a>.
</li>
<li>
When I made larger programs, I observed quite a bit of optimizer noise, <a href="#note11" data-noteid="11">11</a> where a minor change in one area would swing the measurements one way or another. <a href="#note12" data-noteid="12">12</a> Benchmark results for the larger programs seemed rather fragile. We&#39;ll need a large set of benchmark programs to isolate away this optimizer noise.
</li>
<li>
In a larger program (a tiny roguelike game), I also observed that the optimizer didn&#39;t merge two identical branches of an if-statement, and missed a couple other obvious optimizations. I&#39;m not sure how the presence of an integer (especially unread!) would affect this. It could even be a bug in LLVM, which are pretty common.
</li>
</ul>

</section>
<section>
<p>
That last one hints that we might want our own Vale-specific pre-optimizer, similar to Rust&#39;s <a href="https://github.com/bytecodealliance/wasmtime/tree/main/cranelift">Cranelift</a>, since LLVM was designed more with C in mind. <a href="#note13" data-noteid="13">13</a>
</p>

</section>
<section>
<p>
Still, even with these details, these results are quite promising!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note10" data-noteid="10">
<p><span>10</span></p><section>
<p>
There could be overhead in theory, in the form of a nonatomic monotonically incrementing integer used for filling generations. It doesn&#39;t seem to affect the performance, likely because registers and simple arithmetic operations are so cheap on modern CPUs compared to the real bottleneck which is memory latency. The optimizer also often optimizes it out, since it sees nobody using these generations.
</p>

</section>
</div>
<div id="note11" data-noteid="11">
<p><span>11</span></p><section>
<p>
This is not the same thing as benchmark noise. This benchmarking setup reported very consistent run times (hence the <span>± 0.01</span> in the output).
</p>

</section>
</div>
<div id="note12" data-noteid="12">
<p><span>12</span></p><section>
<p>
In fact, when I switched the size of the generation numbers, it consistently had negative overhead (<span>1.13 ± 0.01</span>), which is a bit weird considering that there weren&#39;t that many generation numbers in the program anyway. It did change the register allocations, so I suspect that&#39;s dwarfing any performance differences from anything actually semantically different in the programs.
</p>

</section>
</div>
<div id="note13" data-noteid="13">
<p><span>13</span></p><section>
<p>
We might want this anyway, as I&#39;m pretty sure LLVM would treat generational references as undefined behavior, if it could figure out that we&#39;re intentionally accessing released memory.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="what-does-this-mean">
 What does this mean?</h2>
<p>
This means that generational references and regions combine to form a memory safety approach that is very, very fast.
</p>

</section>
<section>
<p>
It also means that this approach is actually viable, and could be desirable for quite a few software domains. A domain might desire this approach if:
</p>
<ul>
<li>
It wants more predictable latency than tracing garbage collection.
</li>
<li>
It wants better performance and cache friendliness than reference counting.
</li>
<li>
It wants to prototype and iterate more easily than with borrow checking.
</li>
</ul>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="where-does-vale-go-from-here">
 Where does Vale go from here?</h2>
<p>
The above benchmarks compared Vale&#39;s safe mode to Vale&#39;s unsafe modes, for a more accurate comparison of the memory safety approaches.
</p>

</section>
<section>
<p>
However, there are still a few things to do before Vale can really go toe-to-toe with languages like C and C++. <a href="#note14" data-noteid="14">14</a>
</p>
<ul>
<li>
I&#39;ll need to start a Vale-specific pre-optimizer, since LLVM&#39;s optimizer seems to have some problems reasoning about generations and immutability.
</li>
<li>
Vale still needs to support inline data, instead of putting all structs on the heap. (Note that that wouldn&#39;t affect the above benchmarks, which didn&#39;t use any structs.)
</li>
<li>
Regions are still just in the prototype phase. I&#39;ll need to smoothe out the rough edges, pay down a bit of tech debt, and merge this code in before doing anything else.
</li>
</ul>

</section>
<section>
<p>
After this is merged in, I&#39;ll be making the standard library use regions so that every user will benefit from them, even if their main program code doesn&#39;t use regions directly.
</p>

</section>
<section>
<p>
It&#39;s a pretty ambitious endeavor, so it&#39;s not clear how long this will take. With enough sponsorship I can work on this full-time, so if you believe in the direction we&#39;re heading, please consider sponsoring on <a href="https://github.com/sponsors/ValeLang">GitHub</a> or <a href="https://www.patreon.com/user/about?u=5018675">Patreon</a>!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note14" data-noteid="14">
<p><span>14</span></p><section>
<p>
 Easter egg, this note will disappear shortly!
</p>
<p>
<a href="https://en.wikipedia.org/wiki/Nils_Olav">Brigadier Sir Nils Olav III</a>, colonel-in-chief of the Norwegian King&#39;s Guard, is a widely celebrated national hero. A statue was erected in his honor in 2005, and he was even awarded a knighthood by <a href="https://en.wikipedia.org/wiki/Harald_V_of_Norway">King Harald V</a> himself.
</p>
<p>
Oh also, Nils Olav is a <a href="https://en.wikipedia.org/wiki/King_penguin">king penguin</a>.
</p>
<p>
During his knighting ceremony, the King declared that Nils was, as a penguin, &#34;in every way qualified to receive the honour and dignity of knighthood&#34;.
</p>
<p>
If you read this note, mention Nils Olav on <a href="https://news.ycombinator.com/item?id=36690556">HN</a> or <a href="https://www.reddit.com/r/programming/comments/14wu830/vales_first_prototype_for_immutable_region/">r/programming</a>! <a href="https://youtu.be/-UBgNREvlIo">Nobody will believe you</a>.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    
    <div>
      <div>
  
<section>
<h2 id="conclusion">
 Conclusion</h2>
<p>
It&#39;s been an epic and exciting journey to get to this point! And now, we <i>finally</i> have some measurements to show that zero-check programs are possible, and that they&#39;re as fast as we hoped.
</p>

</section>
<section>
<p>
I want to give a massive thanks to everyone that has helped with this endeavor, especially our contributors and sponsors! I definitely would not have made it to this point without your support.
</p>

</section>
<section>
<p>
Cheers!
</p>
<p>
- Evan Ovadia
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>


</section>
<section>
<p>
With your help, we can launch a language with <b>speed</b>, <b>safety</b>, <b>flexibility</b>, and <b>ease of use.</b>
</p>

</section>
<section>
<p>
We’re a very small team of passionate individuals, working on this on our own and not backed by any corporation.
</p>

</section>
<section>
<p>
If you want to support our work, please consider <a href="https://github.com/sponsors/ValeLang">sponsoring us on GitHub</a>!
</p>

</section>
<section>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor us on GitHub
  </a>
</center>


</section>
<section>
<p>
Those who sponsor us also get extra benefits, including:
</p>
<ul>
<li>
Early access to all of our articles!
</li>
<li>
A sneak peek at some of our more ambitious designs, such as memory-safe allocators based on algebraic effects, an async/await/goroutine hybrid that works without data coloring or function coloring, and more.
</li>
<li>
Your name on the <a href="https://vale.dev/">vale.dev</a> home page!
</li>
</ul>

</section>
<section>
<p>
With enough sponsorship, we can:
</p>
<ul>
<li>
Start a a 501(c)(3) non-profit organization to hold ownership of Vale. <a href="#note15" data-noteid="15">15</a>
</li>
<li>
Buy the necessary computers to support more architectures.
</li>
<li>
Work on this full-time.
</li>
<li>
Make Vale into a production-ready language, and push it into the mainstream!
</li>
</ul>

</section>
<section>
<p>
We have a strong <a href="https://vale.dev/roadmap">track record</a>, and during this quest we&#39;ve discovered and implemented a lot of completely new techniques:
</p>
<ul>
<li>
The <a href="https://verdagon.dev/blog/linear-types-borrowing">Linear-Aliasing Model</a> that lets us use linear types where we need speed, and <a href="https://verdagon.dev/blog/generational-references">generational references</a> where we need the flexibility of shared mutability.
</li>
<li>
<a href="https://verdagon.dev/blog/first-regions-prototype">Region Borrowing</a>, which makes it easier to write efficient code by composing shared mutability with the ability to temporarily freeze data.
</li>
<li>
<a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">Higher RAII</a>, where the language adds logic safety by enforcing that we eventually perform a specific future operation.
</li>
<li>
<a href="https://verdagon.dev/blog/perfect-replayability-prototyped">Perfect Replayability</a> makes debugging race conditions obsolete  by recording all inputs and replaying execution exactly.
</li>
</ul>

</section>
<section>
<p>
These have been successfully prototyped. With your sponsorship we can polish them, integrate them, and bring these techniques into the mainstream. <a href="#note16" data-noteid="16">16</a>
</p>

</section>
<section>
<p>
Our next steps are focused on making Vale more user-friendly by:
</p>
<ol>
<li>
Finalizing the compiler&#39;s error messages and improving compile speeds.
</li>
<li>
Polishing interop with other languages.
</li>
<li>
Growing the standard library and ecosystem!
</li>
</ol>

</section>
<section>
<p>
We aim to combine and add to the benefits of our favorite languages:
</p>
<ul>
<li>
The scalability of <a href="https://go.dev/">Go</a> and ergonomics of <a href="https://scala-lang.org/">Scala</a>, but using Vale&#39;s <a href="https://verdagon.dev/blog/linear-types-borrowing">linear-aliasing model</a> instead of garbage collection.
</li>
<li>
C++&#39;s single-ownership shared-mutability abilities with more <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">memory safety</a>, without sacrificing its flexibility.
</li>
<li>
The speed and safety of <a href="https://www.rust-lang.org/">Rust</a>, but with <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">easier borrowing rules</a>, more <a href="https://verdagon.dev/blog/higher-raii-7drl">compile time guarantees</a>, and better compatibility with <a href="https://verdagon.dev/blog/linear-types-borrowing">shared mutability</a>.
</li>
</ul>

</section>
<section>
<p>
<b>We need your help to make this happen!</b>
</p>

</section>
<section>
<p>
If you&#39;re impressed by our <a href="https://vale.dev/roadmap">track record</a> and believe in the direction we&#39;re heading, please consider sponsoring us:
</p>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor us on GitHub
  </a>
</center>


</section>
<section>
<p>
If you have any questions, always feel free to reach out via <a href="mailto:verdagon_epsa@verdagon.dev">email</a>, <a href="https://twitter.com/vale_pl">twitter</a>, <a href="https://discord.gg/SNB8yGH">discord</a>, or the <a href="https://reddit.com/r/vale">subreddit</a>. Cheers!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note15" data-noteid="15">
<p><span>15</span></p><section>
<p>
Tentatively named the Vale Software Foundation.
</p>

</section>
</div>
<div id="note16" data-noteid="16">
<p><span>16</span></p><section>
<p>
 <a href="https://verdagon.dev/blog/generational-references">Generational references</a>, the <a href="https://verdagon.dev/blog/linear-types-borrowing">linear-aliasing model</a>, and <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">higher RAII</a> are all complete, and <a href="https://verdagon.dev/blog/first-regions-prototype">region borrowing</a>, <a href="https://verdagon.dev/blog/fearless-ffi">fearless FFI</a>, and <a href="https://verdagon.dev/blog/perfect-replayability-prototyped">perfect replayability</a> have been successfully prototyped. Be sure to check out the experimental version of the compiler!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    
    
  

    </div>
  </div></div>
  </body>
</html>
