<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/first-regions-prototype">Original</a>
    <h1>Vale&#39;s First Prototype for Immutable Region Borrowing</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<section>
<h2 id="building-the-theory">
 Building the Theory</h2>

</section>
<section>
<p>
Most of my free time for the past few years has gone into building out the compiler&#39;s foundations so that it could support this unexplored approach.
</p>

</section>
<section>
<p>
It was <i>hard</i>. Any kind of borrowing system is already pretty complex, but they also requires full generics, which are notoriously difficult. <a href="#note4" data-noteid="4">4</a> <a href="#note5" data-noteid="5">5</a>
</p>

</section>
<section>
<p>
On top of that, an entire new compiler stage was needed to get regions and generational references to work seamlessly together. <a href="#note6" data-noteid="6">6</a>
</p>

</section>
<section>
<p>
Finally, a few months ago, <b>the regions prototype was finished</b>. It&#39;s rough around the edges, <a href="#note7" data-noteid="7">7</a> but it successfully compiled something for the first time.
</p>

</section>
<section>
<p>
With that, I made the <a href="https://github.com/Verdagon/RegionsBenchmarks/blob/main/cellular-automata/CellularAutomata.vale">first ever zero-check Vale program</a>! <a href="#note8" data-noteid="8">8</a>
</p>
<p>
It was a program that uses <a href="https://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664">Cellular Automata</a> to generate a level for a roguelike game.
</p>

</section>
<section>



</section>
<section>
<p>
Of course, it didn&#39;t work perfectly at first. Compilers are tricky. The slightest misstep in the compiler code will add extra instructions to the resulting assembly, causing artificial overhead in the final program. And sometimes, there&#39;s extra little bits of information you need to pass to the optimizer (or the CPU itself!) to trick it into the most optimal behavior.
</p>

</section>
<section>
<p>
To help me track down the problems, I kept comparing its assembly to the assembly generated by Vale&#39;s &#34;unsafe&#34; modes:
</p>
<ul>
<li>
<span>unsafe_no_bounds</span> is similar to C; all memory-safety protections are turned off, and it only uses raw pointers for everything, rather than generational references.
</li>
<li>
<span>unsafe_with_bounds</span> then adds bounds checking for array accesses, similar to how Rust does it.
</li>
</ul>

</section>
<section>
<p>
After a couple months of tracking down differences, the resulting assembly looked nearly identical to Vale&#39;s <span>unsafe_with_bounds</span> mode! Every difference was expected <a href="#note9" data-noteid="9">9</a> and everything looked pretty reasonable.
</p>

</section>
<section>
<h2 id="the-benchmarks">
 The Benchmarks</h2>
<p>
Finally, I benchmarked the program again:
</p>

</section>
<section>

    <div>
      
      <pre><code>Summary
  &#39;./build_unsafe_no_bounds/main&#39; ran
    1.18 ± 0.01 times faster than &#39;./build_unsafe_with_bounds/main&#39;
    1.18 ± 0.01 times faster than &#39;./build_safe_fastest/main&#39;</code></pre>
    </div>
  

</section>
<section>
<p>
Success! Vale&#39;s normal mode (<span>safe_fastest</span> here) showed no slowdowns compared to only bounds checking.
</p>

</section>
<section>
<p>
In other words, <b>this approach has no observable overhead.</b> <a href="#note10" data-noteid="10">10</a>
</p>

</section>
<section>
<p>
Finally seeing this was a shock, a relief, and almost surreal. No overhead! We knew it was possible in theory, but seeing it happen for real still felt very surprising.
</p>

</section>
<section>
<p>
Feel free to play with it! Just build from the <a href="https://github.com/Verdagon/Vale/tree/regions">regions branch</a>, check out the <a href="https://github.com/Verdagon/RegionsBenchmarks">benchmarking scripts</a>, and to ask any questions in the <a href="https://discord.gg/SNB8yGH">discord server</a>.
</p>

</section>
<section>
<p>
And before we get too excited, let&#39;s keep these important details in mind:
</p>
<ul>
<li>
This is not benchmarking against languages like C and Rust directly. Those compilers have years of unrelated optimizations that would just confound the experiment, so I compare with <span>unsafe_no_bounds</span> and <span>unsafe_with_bounds</span> to isolate those variables and get a more accurate comparison of the memory safety approaches.
</li>
<li>
This was benchmarked on a Razer Blade 15&#34; 2018 (512GB SSD) running Ubuntu 22.04, using <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> inside a <a href="https://manpages.ubuntu.com/manpages/trusty/man1/cset-shield.1.html">cset shield</a>.
</li>
<li>
When I made larger programs, I observed quite a bit of optimizer noise, <a href="#note11" data-noteid="11">11</a> where a minor change in one area would swing the measurements one way or another. <a href="#note12" data-noteid="12">12</a> Benchmark results for the larger programs seemed rather fragile. We&#39;ll need a large set of benchmark programs to isolate away this optimizer noise.
</li>
<li>
In a larger program (a tiny roguelike game), I also observed that the optimizer didn&#39;t merge two identical branches of an if-statement, and missed a couple other obvious optimizations. I&#39;m not sure how the presence of an integer (especially unread!) would affect this. It could even be a bug in LLVM, which are pretty common.
</li>
</ul>

</section>
<section>
<p>
That last one hints that we might want our own Vale-specific pre-optimizer, similar to Rust&#39;s <a href="https://github.com/bytecodealliance/wasmtime/tree/main/cranelift">Cranelift</a>, since LLVM was designed more with C in mind. <a href="#note13" data-noteid="13">13</a>
</p>

</section>
<section>
<p>
Still, even with these details, these results are quite promising!
</p>

</section>
<section>
<h2 id="what-does-this-mean">
 What does this mean?</h2>
<p>
This means that generational references and regions combine to form a memory safety approach that is very, very fast.
</p>

</section>
<section>
<p>
It also means that this approach is actually viable, and could be desirable for quite a few software domains. A domain might desire this approach if:
</p>
<ul>
<li>
It wants more predictable latency than tracing garbage collection.
</li>
<li>
It wants better performance and cache friendliness than reference counting.
</li>
<li>
It wants to prototype and iterate more easily than with borrow checking.
</li>
</ul>

</section>
<section>
<h2 id="where-does-vale-go-from-here">
 Where does Vale go from here?</h2>
<p>
The above benchmarks compared Vale&#39;s safe mode to Vale&#39;s unsafe modes, for a more accurate comparison of the memory safety approaches.
</p>

</section>
<section>
<p>
However, there are still a few things to do before Vale can really go toe-to-toe with languages like C and C++. <a href="#note14" data-noteid="14">14</a>
</p>
<ul>
<li>
I&#39;ll need to start a Vale-specific pre-optimizer, since LLVM&#39;s optimizer seems to have some problems reasoning about generations and immutability.
</li>
<li>
Vale still needs to support inline data, instead of putting all structs on the heap. (Note that that wouldn&#39;t affect the above benchmarks, which didn&#39;t use any structs.)
</li>
<li>
Regions are still just in the prototype phase. I&#39;ll need to smoothe out the rough edges, pay down a bit of tech debt, and merge this code in before doing anything else.
</li>
</ul>

</section>
<section>
<p>
After this is merged in, I&#39;ll be making the standard library use regions so that every user will benefit from them, even if their main program code doesn&#39;t use regions directly.
</p>

</section>
<section>
<p>
It&#39;s a pretty ambitious endeavor, so it&#39;s not clear how long this will take. With enough sponsorship I can work on this full-time, so if you believe in the direction we&#39;re heading, please consider sponsoring on <a href="https://github.com/sponsors/ValeLang">GitHub</a> or <a href="https://www.patreon.com/user/about?u=5018675">Patreon</a>!
</p>

</section>

      </div></div>
  </body>
</html>
