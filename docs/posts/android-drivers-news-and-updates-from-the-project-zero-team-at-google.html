<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2024/06/driving-forward-in-android-drivers.html">Original</a>
    <h1>Android Drivers - News and updates from the Project Zero team at Google</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3663024175311920488" itemprop="description articleBody">

 <p><span>Posted by Seth Jenkins, Google Project Zero</span></p><h2 id="h.czz0un3ls851"><span>Introduction</span></h2>
 <p><span>Android&#39;s open-source ecosystem has led to an incredible diversity of manufacturers and vendors developing software that runs on a broad variety of hardware. This hardware requires supporting drivers, meaning that many different codebases carry the potential to compromise a significant segment of Android phones. </span><span><a href="https://googleprojectzero.blogspot.com/2023/09/analyzing-modern-in-wild-android-exploit.html">There are recent public examples</a></span><span> of third-party drivers containing serious vulnerabilities that are exploited on Android. While there exists a well-established body of public (</span><span><a href="https://storage.googleapis.com/gweb-uniblog-publish-prod/documents/Year_in_Review_of_ZeroDays.pdf">and In-the-Wild</a></span><span>) security research</span><span> on Android GPU drivers</span><span>,</span><span> other chipset components may not be as frequently audited</span><span> so this research sought to explore those drivers in greater detail.</span></p><h2 id="h.pc76xm98zfq3"><span>Driver Enumeration: Not as Easy as it Looks</span></h2>
 <p><span>This research focused on three Android devices (chipset manufacturers in parentheses): </span></p>
 
 <p><span>- Google Pixel 7 (Tensor)</span></p>
 <p><span>- Xiaomi 11T (MediaTek)</span></p>
 <p><span>- Asus ROG 6D (MediaTek)</span></p>
 
 <p><span>In order to perform driver research on these devices I first had to find all of the kernel drivers that were accessible from an unprivileged context on each device; </span><span>a task complicated by the non-uniformity of kernel drivers (and their permissions structures) across different devices even within the same chipset manufacturer.</span><span> There are several different methodologies for discovering these drivers. The most straightforward technique is to search the associated filesystems looking for exposed driver device files. These files serve as the primary method by which userland can interact with the driver. Normally the “file” is </span><span>open</span><span>’d by a userland process, which then uses a combination of </span><span>read</span><span>, </span><span>write</span><span>, </span><span>ioctl</span><span>, or even </span><span>mmap</span><span> to interact with the driver. The driver then “translates” those interactions into manipulations of the underlying hardware device sending the output of that device back to userland as warranted. Effectively all drivers expose their interfaces through the ProcFS or DevFS filesystems, so I focused on the </span><span>/proc</span><span> and </span><span>/dev</span><span> directories while searching for viable attack surfaces. Theoretically, evaluating all the userland accessible drivers should be as simple as calling </span><span>find /dev</span><span> or </span><span>find /proc</span><span>, attempting to </span><span>open</span><span> every file discovered, and logging which </span><span>open</span><span> attempts were successful.</span></p>
 
 <p><span>However, there is one major roadblock that prevents this approach from being comprehensive - permissions! SELinux and traditional Linux Discretionary Access Control policies can prevent simple filesystem enumeration from discovering all of the accessible device drivers associated on the filesystem. For example, the </span><span>untrusted_app</span><span> SELinux context has </span><span>search</span><span> permissions on the </span><span>device</span><span> SELinux context for directories, but is not allowed to directly open the directory itself:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEioT3h0f4HwgQDI_0LTWJU6KJU3MwVqZ8zuQYgPhF0SXHNCeaw1ut_-WkpVwwqcqLytAsgahAjKshk8ugcbaCZyk8-Us3i8ZfRihE-EA3n8tRFIi0oPUntubw1dJ7y9l1LjTe4Zot7iFd-WJRQ0I1DPdsFA_sULQ5vLIQ8xgQerrz1hyphenhyphenwLj_2J8oC2VD0M/s790/image2.png"><img alt="sepolicy shows search permission on the &#34;device&#34; SELinux context" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEioT3h0f4HwgQDI_0LTWJU6KJU3MwVqZ8zuQYgPhF0SXHNCeaw1ut_-WkpVwwqcqLytAsgahAjKshk8ugcbaCZyk8-Us3i8ZfRihE-EA3n8tRFIi0oPUntubw1dJ7y9l1LjTe4Zot7iFd-WJRQ0I1DPdsFA_sULQ5vLIQ8xgQerrz1hyphenhyphenwLj_2J8oC2VD0M/s790/image2.png" title="sepolicy shows search permission on the &#34;device&#34; SELinux context"/></a></span></p>
 
 <p><span>This </span><span>search</span><span> permission (rather counterintuitively) does </span><span>not</span><span> allow the source context to list the contents of directories that have this SELinux target context. Instead, it simply allows such a directory to be in the ancestor directories of the file path that the source context attempts to </span><span>open</span><span>. In practice, this means that untrusted_app is allowed to open e.g. </span><span>/dev/mali0</span><span> but is usually </span><span>not </span><span>allowed to open </span><span>/dev</span><span> itself:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjbJAsOOwnE0RJ9O7yET8vhuVE-UmrzcyoUVoRP4z4kL7wYGXHHJob-ir9s2pgEDQFaxPmAT14n0hu81XpDrl6BaO7ltXE2jZJ-zIBoPa4hH9PYSSIc2KLk0ulZ_0xLjjaO4_VvhG69zIuqmtoGu1a7s_xn3Ru7_QZnjjLZS2sc8oL-yrwFR6LWUBm1EqA/s624/image6.png"><img alt="untrusted_app is unable to list /dev but can open files within it like /dev/mali0" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjbJAsOOwnE0RJ9O7yET8vhuVE-UmrzcyoUVoRP4z4kL7wYGXHHJob-ir9s2pgEDQFaxPmAT14n0hu81XpDrl6BaO7ltXE2jZJ-zIBoPa4hH9PYSSIc2KLk0ulZ_0xLjjaO4_VvhG69zIuqmtoGu1a7s_xn3Ru7_QZnjjLZS2sc8oL-yrwFR6LWUBm1EqA/s624/image6.png" title="untrusted_app is unable to list /dev but can open files within it like /dev/mali0"/></a></span></p>
 
 <p><span>In the case of </span><span>/dev</span><span>, the </span><span>shell</span><span> context </span><span>is </span><span>allowed to open and list the contents of </span><span>/dev</span><span>. That means that by first enumerating the </span><span>/dev</span><span> directory from the </span><span>shell</span><span> context, then attempting to open all discovered files from the </span><span>untrusted_app</span><span> context, a security researcher can understand what drivers are and are not </span><span>accessible</span><span> from an app context in the </span><span>/dev</span><span> directory. However, there are cases where certain directories are simply not listable from a debugging-accessible non-root context, particularly in </span><span>/proc</span><span>. One option to enumerate all these directories would be to root the phone, however, this is not always easily achievable.</span></p>
 
 <p><span>A strategy I found helpful in this regard was to examine publicly released kernel source code for the phone model or for similar phone models.</span><span> The location of this source code varies significantly from manufacturer to manufacturer, but the source code is </span><span>usually either hosted on Github or via the manufacturer website</span><span>. Device drivers create f</span><span>iles in </span><span>/proc</span><span> primarily</span><span> via the </span><span>proc_create()</span><span> </span><span>and </span><span>proc_mkdir()</span><span> function calls. A real-world example of this would be:</span></p>

 

 <p><span>        </span><span>parent</span><span> </span><span>=</span><span> </span><span>proc_mkdir(</span><span>&#34;perfmgr&#34;</span><span>,</span><span> </span><span>NULL</span><span>);</span></p>

 <p><span>        </span><span>perfmgr_root</span><span> </span><span>=</span><span> </span><span>parent;</span></p>

 

 <p><span>        </span><span>pe</span><span> </span><span>=</span><span> </span><span>proc_create(</span><span>&#34;perf_ioctl&#34;</span><span>,</span><span> </span><span>0664</span><span>,</span><span> </span><span>parent,</span><span> </span><span>&amp;Fops);</span></p>
 <p><span>        </span><span>...</span></p>
 <p><span>        </span><span>pe</span><span> </span><span>=</span><span> </span><span>proc_create(</span><span>&#34;eara_ioctl&#34;</span><span>,</span><span> </span><span>0664</span><span>,</span><span> </span><span>parent,</span><span> </span><span>&amp;eara_Fops);</span></p>
 <p><span>        </span><span>...</span></p>
 <p><span>        </span><span>pe</span><span> </span><span>=</span><span> </span><span>proc_create(</span><span>&#34;eas_ioctl&#34;</span><span>,</span><span> </span><span>0664</span><span>,</span><span> </span><span>parent,</span><span> </span><span>&amp;eas_Fops);</span></p>
 <p><span>        </span><span>...</span></p>
 <p><span>        </span><span>pe</span><span> </span><span>=</span><span> </span><span>proc_create(</span><span>&#34;xgff_ioctl&#34;</span><span>,</span><span> </span><span>0664</span><span>,</span><span> </span><span>parent,</span><span> </span><span>&amp;xgff_Fops);</span></p>
 <p><span>        </span><span>...</span></p>
 
 
 <p><span>Although these files cannot be directly enumerated, they </span><span>do</span><span> exist and are accessible from an untrusted context.</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgyj_BhXcb7qJCBlmypX0tZzSn75nUpANd16viDRspDEgRhdbE_l6t8p2XK1bHVC9NI6vPYIrV4o_sylWf4WaqrOc4sLVFKVTQRCKKz-BxvagFmwO0GBziHvTJUXBYbfb4c1YmgmcpM5Rt-bT2Ld8z15J2s8sxoi_Ed830F3wZnA3dL5uy-3yf4HNBrz4c/s497/image5.png"><img alt="/proc/perfmgr directory contents cannot be listed with ls, but can be open&#39;d" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgyj_BhXcb7qJCBlmypX0tZzSn75nUpANd16viDRspDEgRhdbE_l6t8p2XK1bHVC9NI6vPYIrV4o_sylWf4WaqrOc4sLVFKVTQRCKKz-BxvagFmwO0GBziHvTJUXBYbfb4c1YmgmcpM5Rt-bT2Ld8z15J2s8sxoi_Ed830F3wZnA3dL5uy-3yf4HNBrz4c/s497/image5.png" title="/proc/perfmgr directory contents cannot be listed with ls, but can be open&#39;d"/></a></span></p>
 
 <p><span>It would have otherwise required rooting the phone to discover this driver without analyzing the kernel source code.</span></p>
 
 <p><span>Another useful resource is the SELinux policy itself. Userland interacts with the drivers via a fairly typical set of VFS operations. This means that the SELinux policy </span><span>must</span><span> encapsulate the necessary permissions to perform those operations. This means that the SELinux policy generally reflects what the developers intend to be accessible from an untrusted context. Analysis of the policy can lead to the discovery of certain oddities and idiosyncrasies in the accessibility of certain drivers. For example, occasionally a file may not be directly openable via the filesystem, but there may be some alternative method by which an app can ask another more privileged process to open the file on its behalf and hand the associated </span><span>fd</span><span> back, after which the app </span><span>is </span><span>allowed to </span><span>read</span><span>/</span><span>write</span><span>/</span><span>ioctl</span><span> to the </span><span>fd</span><span> itself. One example of this behavior would be the EdgeTPU device on the Pixel 7:<br/></span></p>
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD4s4ms0da-AJFNNkpiEVi9yew1XcUIY852C3-WuI8Tqidiyl7Zy2rNdNDvyD0MI8RGPsuF6Y9DGo4js9o4r4iI9JHP25Ygrv2cYIiRjkhH8DI9rg0oe-nnxrXCtn23ROy3f3k8Sqp22Nz21TcfjQhyphenhyphenbg1Hj4FU4W7WnMCOPOFYMmksu5uYi-VZeFD8I8/s740/image9.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD4s4ms0da-AJFNNkpiEVi9yew1XcUIY852C3-WuI8Tqidiyl7Zy2rNdNDvyD0MI8RGPsuF6Y9DGo4js9o4r4iI9JHP25Ygrv2cYIiRjkhH8DI9rg0oe-nnxrXCtn23ROy3f3k8Sqp22Nz21TcfjQhyphenhyphenbg1Hj4FU4W7WnMCOPOFYMmksu5uYi-VZeFD8I8/s740/image9.png" title=""/></a></span></p>
 
 <p><span>Additional research suggests that </span><span>untrusted_app</span><span> can ask a privileged process for access to the EdgeTPU </span><span>driver </span><span>fd</span><span> itself </span><span>if it lands on an allowlist of certain applications.</span></p>
 
 <p><span>The performed surveys strongly imply that the GPU driver is the most consistently accessible driver from an untrusted application, which is expected. On the Google Pixel 7, I did not find much else that was accessible from an entirely unprivileged context. Nevertheless, inspired by </span><span><a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-22265.html">previous similar efforts on hardware like Samsung’s NPU</a></span><span>, I performed research on the EdgeTPU driver - Google’s tensor processing unit for doing ML related tasks on the Pixel series of devices. </span><span>This resulted</span><span> in the discovery of one significant </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2455">issue</a></span><span> - a race condition when registering memory with the EdgeTPU memory while vma’s are concurrently getting modified.</span></p>
 
 <p><span>Unlike the Pixel 7, the </span><span>MediaTek chipset phones </span><span>(Asus ROG 6D and Xiaomi 11T) contained several different drivers that could be accessed from unprivileged userland:</span></p>
 <ul><li><span>/proc/ged</span></li><li><span>/proc/mtk_jpeg</span></li><li><span>/proc/perfmgr/[eara_ioctl,eas_ioctl,perf_ioctl,xgff_ioctl]</span></li></ul>
 
 <p><span>These drivers represent significantly more interesting and complex attack surfaces than what was available on the Pixel 7 device. The ged driver contained numerous interesting and valuable exploitation primitives that we’ll discuss in detail a bit later. While the perfmgr driver presented several attack surfaces, I wasn’t able to find any security-relevant bugs. The mtk_jpeg driver however, yielded significant fruit that deserves a closer look.</span></p><h2 id="h.4bjr0190h2xa"><span>MediaTek JPEG Decoding Accelerator</span></h2>
 <p><span>The mtk_jpeg driver manages specialized hardware on MediaTek devices to perform jpeg decoding acceleration. </span><span><a href="https://github.com/torvalds/linux/blob/8f2c057754b25075aa3da132cd4fd4478cdab854/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.yaml#L12">Linux kernel documentation</a></span><span> notes that “Mediatek JPEG Decoder is the JPEG decode hardware present in Mediatek SoCs”.</span><span> More relevantly, from an attacker&#39;s point of view, this driver can be accessed (at least on the phones assessed) from the </span><span>untrusted_app</span><span> context (although curiously, it </span><span>cannot</span><span> be accessed from an unprivileged adb debugging context). This JPEG decoding accelerator and its associated driver is present on both the Xiaomi 11T and the Asus ROG 6D. However, based on open-source codebases for these different devices&#39; kernels, it appears MediaTek is actively maintaining several different trees for this driver, likely based on the associated kernel version, and these two devices use separate trees. </span></p>
 
 <p><span>I found two vulnerabilities in this driver. </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2471">CVE-2023-32837</a></span><span> was a textbook OOB read/write in an array of structs. Various different members of the struct were accessed and modified, creating several different possibilities for exploitation, but also making them significantly more challenging. Interestingly, MediaTek </span><span><a href="https://github.com/OnePlusOSS/android_kernel_5.10_oneplus_mt6983/commit/725e99c941caf985b25ef5595b2b4f632320d235">partially fixed</a></span><span> this bug in July 2021, although the exact date this patch went out to OEMs is unclear. From the commit message, it’s clear that MediaTek detected this issue with the Coverity static analysis tool, but</span><span> it appears unlikely that </span><span>the security impact was identified. Regardless, while the issue was fixed in some of the MediaTek kernel trees, it went unpatched in other versions of that same driver. This meant that while the Asus ROG 6D (running kernel 5.10) had received the patch for this vulnerability,</span><span> the </span><span>(otherwise fully patched and security supported) Xiaomi 11T </span><span>(running 4.14)</span><span> had not.</span></p>
 
 <p><span>Some background knowledge on how the jpeg driver works eases discussion of the other issue, </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2470">CVE-2023-32832</a></span><span>. The accelerator hardware has two separate “cores” that can perform JPEG decoding. When a process requests JPEG decoding work to be performed, it calls the ioctl </span><span>JPEG_DEC_IOCTL_HYBRID_START</span><span>, and the kernel decides which decoding core will perform that work inside of </span><span>jpeg_drv_hybrid_dec_lock()</span><span>(output has been colorized to ease following along):</span></p>
 
 <p><span> </span><span>static</span><span> </span><span>int</span><span> </span><span>jpeg_drv_hybrid_dec_lock(</span><span>int</span><span> </span><span>*hwid)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>int</span><span> </span><span>retValue</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>        </span><span>int</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>        </span><span>...</span></p>
 <p><span>        </span><span>mutex_lock(&amp;jpeg_hybrid_dec_lock);</span></p>
 <p><span>        </span><span>for</span><span> </span><span>(id</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>id</span><span> </span><span>&lt;</span><span> </span><span>HW_CORE_NUMBER;</span><span> </span><span>id++)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>if</span><span> </span><span>(dec_hwlocked[id])</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;jpeg dec HW core %d is busy&#34;</span><span>,</span><span> </span><span>id);</span></p>
 <p><span>                        </span><span>continue</span><span>;</span></p>
 <p><span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>*hwid</span><span> </span><span>=</span><span> </span><span>id;</span></p>
 <p><span>                        </span><span>dec_hwlocked[id]</span><span> </span><span>=</span><span> </span><span>true;</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;jpeg dec get %d HW core&#34;</span><span>,</span><span> </span><span>id);</span></p>
 <p><span>                        </span><span>_jpeg_hybrid_dec_int_status[id]</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>                        </span><span>jpeg_drv_hybrid_dec_power_on(id);</span></p>
 <p><span>                        </span><span>enable_irq(gJpegqDev.hybriddecIrqId[id]);</span></p>
 <p><span>                        </span><span>break</span><span>;</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>        </span><span>}</span></p>
 
 <p><span>        </span><span>mutex_unlock(&amp;jpeg_hybrid_dec_lock);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(id</span><span> </span><span>==</span><span> </span><span>HW_CORE_NUMBER)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;jpeg dec HW core all busy&#34;</span><span>);</span></p>
 <p><span>                </span><span>*hwid</span><span> </span><span>=</span><span> </span><span>-1;</span></p>
 <p><span>                </span><span>retValue</span><span> </span><span>=</span><span> </span><span>-EBUSY;</span></p>
 <p><span>        </span><span>}</span></p>
 
 <p><span>        </span><span>return</span><span> </span><span>retValue;</span></p>
 <p><span>}</span></p>
 <p><span>The array </span><span>dec_hwlocked</span><span> contains a boolean element for each core, with that element being set to </span><span>true</span><span> for locked cores, and </span><span>false</span><span> for unlocked cores. This array is also protected with a mutex to try and prevent concurrent calls to </span><span>jpeg_drv_hybrid_dec_lock</span><span>, or </span><span>jpeg_drv_hybrid_dec_unlock</span><span> from racing with each other. After locking the core, </span><span>jpeg_drv_hybrid_dec_start</span><span> sets up the data-structures to be utilized for the decoding operation:</span></p>
 
 <p><span> </span><span>switch </span><span>(cmd)</span><span> </span><span>{</span></p>
 <p><span>        case </span><span>JPEG_DEC_IOCTL_HYBRID_START:</span></p>
 <p><span>                if </span><span>(copy_from_user(</span></p>
 <p><span>                        </span><span>&amp;taskParams,</span><span> </span><span>(</span><span>void </span><span>*)arg,</span></p>
 <p><span>                        sizeof</span><span>(</span><span>struct </span><span>JPEG_DEC_DRV_HYBRID_TASK)))</span><span> </span><span>{</span></p>
 <p><span>                        return </span><span>-EFAULT;</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                </span><span>...</span></p>
 <p><span>                if </span><span>(</span><span>jpeg_drv_hybrid_dec_lock</span><span>(&amp;hwid)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>*pStatus</span><span> </span><span>=</span><span> </span><span>JPEG_DEC_PROCESS;</span></p>
 <p><span>                </span><span>}</span><span> else </span><span>{</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;jpeg_drv_hybrid_dec_lock failed (hw busy)&#34;</span><span>);</span></p>
 <p><span>                        return </span><span>-EBUSY;</span></p>
 <p><span>                </span><span>}</span></p>
 
 <p><span>                if </span><span>(</span><span>jpeg_drv_hybrid_dec_start</span><span>(taskParams.data,</span><span> </span><span>hwid,</span><span> </span><span>&amp;index_buf_fd)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>...</span></p>
 <p><span>                </span><span>}</span><span> else </span><span>{</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;jpeg_drv_dec_hybrid_start failed&#34;</span><span>);</span></p>
 <p><span>                        </span><span>jpeg_drv_hybrid_dec_unlock(hwid);</span></p>
 <p><span>                        return </span><span>-EFAULT;</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                break</span><span>;</span></p>
 <p><span>...</span></p>
 <p><span>}</span></p>
 <p><span>static</span><span> </span><span>int</span><span> </span><span>jpeg_drv_hybrid_dec_start(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>data[],</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>id,</span><span>int</span><span> </span><span>*index_buf_fd)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>u64</span><span> </span><span>ibuf_iova,</span><span> </span><span>obuf_iova;</span></p>
 <p><span>        </span><span>int</span><span> </span><span>ret;</span></p>
 <p><span>        </span><span>void</span><span> </span><span>*ptr;</span></p>
 <p><span>        </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>node_id;</span></p>
 
 <p><span>        </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;+ id:%d&#34;</span><span>,</span><span> </span><span>id);</span></p>
 <p><span>        </span><span>ret</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>        </span><span>ibuf_iova</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>        </span><span>obuf_iova</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>        </span><span>node_id</span><span> </span><span>=</span><span> </span><span>id</span><span> </span><span>/</span><span> </span><span>2</span><span>;</span></p>
 
 <p><span>        </span><span>bufInfo[id].o_dbuf</span><span> </span><span>=</span><span> </span><span>jpg_dmabuf_alloc(data[</span><span>20</span><span>],</span><span> </span><span>128</span><span>,</span><span> </span><span>0</span><span>);</span></p>
 <p><span>        </span><span>bufInfo[id].o_attach</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p>
 <p><span>        </span><span>bufInfo[id].o_sgt</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p>
 
 <p><span>        </span><span>bufInfo[id].i_dbuf</span><span> </span><span>=</span><span> </span><span>jpg_dmabuf_get(data[</span><span>7</span><span>]);</span></p>
 <p><span>        </span><span>bufInfo[id].i_attach</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p>
 <p><span>        </span><span>bufInfo[id].i_sgt</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(!bufInfo[id].o_dbuf)</span><span> </span><span>{</span></p>
 <p><span>            </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;o_dbuf alloc failed&#34;</span><span>);</span></p>
 <p><span>                </span><span>return</span><span> </span><span>-1;</span></p>
 <p><span>        </span><span>}</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(!bufInfo[id].i_dbuf)</span><span> </span><span>{</span></p>
 <p><span>            </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;i_dbuf null error&#34;</span><span>);</span></p>
 <p><span>                </span><span>return</span><span> </span><span>-1;</span></p>
 <p><span>        </span><span>}</span></p>
 
 <p><span>        </span><span>ret</span><span> </span><span>=</span><span> </span><span>jpg_dmabuf_get_iova(bufInfo[id].o_dbuf,</span><span> </span><span>&amp;obuf_iova,</span><span> </span><span>gJpegqDev.pDev[node_id],</span><span> </span><span>&amp;bufInfo[id].o_attach,</span><span> </span><span>&amp;bufInfo[id].o_sgt);</span></p>
 <p><span>        </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;obuf_iova:0x%llx lsb:0x%lx msb:0x%lx&#34;</span><span>,</span><span> </span><span>obuf_iova,</span></p>
 <p><span>                </span><span>(</span><span>unsigned</span><span> </span><span>long</span><span>)(</span><span>unsigned</span><span> </span><span>char</span><span>*)obuf_iova,</span></p>
 <p><span>                </span><span>(</span><span>unsigned</span><span> </span><span>long</span><span>)(</span><span>unsigned</span><span> </span><span>char</span><span>*)(obuf_iova&gt;&gt;</span><span>32</span><span>));</span></p>
 
 <p><span>        </span><span>ptr</span><span> </span><span>=</span><span> </span><span>jpg_dmabuf_vmap(bufInfo[id].o_dbuf);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(ptr</span><span> </span><span>!=</span><span> </span><span>NULL</span><span> </span><span>&amp;&amp;</span><span> </span><span>data[</span><span>20</span><span>]</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span></p>
 <p><span>                </span><span>memset(ptr,</span><span> </span><span>0</span><span>,</span><span> </span><span>data[</span><span>20</span><span>]);</span></p>
 <p><span>        </span><span>jpg_dmabuf_vunmap(bufInfo[id].o_dbuf,</span><span> </span><span>ptr);</span></p>
 <p><span>        </span><span>jpg_get_dmabuf(bufInfo[id].o_dbuf);</span></p>
 <p><span>        </span><span>// get obuf for adding reference count, avoid early release in userspace.</span></p>
 <p><span>        </span><span>*index_buf_fd</span><span> </span><span>=</span><span> </span><span>jpg_dmabuf_fd(bufInfo[id].o_dbuf);</span></p>
 
 <p><span>        </span><span>ret</span><span> </span><span>=</span><span> </span><span>jpg_dmabuf_get_iova(bufInfo[id].i_dbuf,</span><span> </span><span>&amp;ibuf_iova,</span><span> </span><span>gJpegqDev.pDev[node_id],</span><span> </span><span>&amp;bufInfo[id].i_attach,</span><span> </span><span>&amp;bufInfo[id].i_sgt);</span></p>
 <p><span>        </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;ibuf_iova 0x%llx lsb:0x%lx msb:0x%lx&#34;</span><span>,</span><span> </span><span>ibuf_iova,</span></p>
 <p><span>                </span><span>(</span><span>unsigned</span><span> </span><span>long</span><span>)(</span><span>unsigned</span><span> </span><span>char</span><span>*)ibuf_iova,</span></p>
 <p><span>                </span><span>(</span><span>unsigned</span><span> </span><span>long</span><span>)(</span><span>unsigned</span><span> </span><span>char</span><span>*)(ibuf_iova&gt;&gt;</span><span>32</span><span>));</span></p>
 
 <p><span>        </span><span>if</span><span> </span><span>(ret</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;get iova fail i:0x%llx o:0x%llx&#34;</span><span>,</span><span> </span><span>ibuf_iova,</span><span> </span><span>obuf_iova);</span></p>
 <p><span>                </span><span>return</span><span> </span><span>ret;</span></p>
 <p><span>        </span><span>}</span></p>
 
 <p><span>        </span><span>...</span></p>
 <p><span>        </span><span>return</span><span> </span><span>ret;</span></p>
 <p><span>}</span></p>
 
 
 <p><span>Finally, utilizing an ioctl call to </span><span>JPEG_DEC_IOCTL_HYBRID_WAIT</span><span> (which calls </span><span>jpeg_drv_hybrid_dec_unlock</span><span>)</span><span>, resources associated with the core are freed, and the core is released back to be used in future operations.</span></p>
 
 <p><span> </span><span>case </span><span>JPEG_DEC_IOCTL_HYBRID_WAIT</span><span>:</span></p>
 <p><span>                </span><span>...</span></p>
 <p><span>                if </span><span>(copy_from_user(</span></p>
 <p><span>                        </span><span>&amp;pnsParmas,</span><span> </span><span>(</span><span>void </span><span>*)arg,</span></p>
 <p><span>                        sizeof</span><span>(</span><span>struct </span><span>JPEG_DEC_DRV_HYBRID_P_N_S)))</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;Copy from user error&#34;</span><span>);</span></p>
 <p><span>                        return </span><span>-EFAULT;</span></p>
 <p><span>                </span><span>}</span></p>
 
 <p><span>                </span><span>/*</span><span> </span><span>set</span><span> </span><span>timeout</span><span> </span><span>*/</span></p>
 <p><span>                </span><span>timeout_jiff</span><span> </span><span>=</span><span> </span><span>msecs_to_jiffies(</span><span>3000</span><span>);</span></p>
 <p><span>                </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;JPEG Hybrid Decoder Wait Resume Time: %ld&#34;</span><span>,</span></p>
 <p><span>                                </span><span>timeout_jiff);</span></p>
 <p><span>                </span><span>hwid</span><span> </span><span>=</span><span> </span><span>pnsParmas.hwid;</span></p>
 <p><span>                if </span><span>(hwid</span><span> </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>hwid</span><span> </span><span>&gt;=</span><span> </span><span>HW_CORE_NUMBER)</span><span> </span><span>{ </span><span>//In other versions of the driver, this &gt;= check was omitted, which led to several different OOB accesses later aka CVE-2023-32837</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;get hybrid dec id failed&#34;</span><span>);</span></p>
 <p><span>                        return </span><span>-EFAULT;</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                </span><span>if </span><span>(!dec_hwlocked[hwid])</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;wait on unlock core %d\n&#34;</span><span>,</span><span> </span><span>hwid);</span></p>
 <p><span>                        return </span><span>-EFAULT;</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                if </span><span>(jpeg_isr_hybrid_dec_lisr(hwid)</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                        </span><span>long</span><span> </span><span>ret</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 <p><span>                        </span><span>int</span><span> </span><span>waitfailcnt</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p>
 
 <p><span>                        do </span><span>{</span></p>
 <p><span>                                </span><span>ret</span><span> </span><span>=</span><span> </span><span>wait_event_interruptible_timeout(</span></p>
 <p><span>                                        </span><span>hybrid_dec_wait_queue[hwid],</span></p>
 <p><span>                                        </span><span>_jpeg_hybrid_dec_int_status[hwid],</span></p>
 <p><span>                                        </span><span>timeout_jiff);</span></p>
 <p><span>                                </span><span>...</span></p>
 <p><span>                                if </span><span>(ret</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span></p>
 <p><span>                                        </span><span>waitfailcnt++;</span></p>
 <p><span>                                        </span><span>usleep_range(</span><span>10000</span><span>,</span><span> </span><span>20000</span><span>);</span></p>
 <p><span>                                </span><span>}</span></p>
 <p><span>                        </span><span>}</span><span> while </span><span>(ret</span><span> </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>waitfailcnt</span><span> </span><span>&lt;</span><span> </span><span>500</span><span>);</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                ...</span></p>
 <p><span>                if </span><span>(copy_to_user(pnsParmas.progress_n_status,</span><span> </span><span>&amp;progress_n_status,                        </span><span>        sizeof</span><span>(</span><span>int</span><span>)))</span><span> </span><span>{</span></p>
 <p><span>                        return </span><span>-EFAULT;</span></p>
 <p><span>                </span><span>}</span></p>
 <p><span>                </span><span>...</span></p>
 <p><span>                </span><span>jpeg_drv_hybrid_dec_unlock(hwid);</span></p>
 <p><span>                </span><span>break</span><span>;</span></p>
 <p><span>                ...</span></p>
 <p><span>}</span></p>
 <p><span>...</span></p>
 <p><span>static</span><span> </span><span>void</span><span> </span><span>jpeg_drv_hybrid_dec_unlock(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>hwid)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>mutex_lock(&amp;jpeg_hybrid_dec_lock);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(!dec_hwlocked[hwid])</span><span> </span><span>{</span></p>
 <p><span>                </span><span>JPEG_LOG(</span><span>0</span><span>,</span><span> </span><span>&#34;try to unlock a free core %d&#34;</span><span>,</span><span> </span><span>hwid);</span></p>
 <p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span></p>
 <p><span>                </span><span>dec_hwlocked[hwid]</span><span> </span><span>=</span><span> </span><span>false;</span></p>
 <p><span>                </span><span>JPEG_LOG(</span><span>1</span><span>,</span><span> </span><span>&#34;jpeg dec HW core %d is unlocked&#34;</span><span>,</span><span> </span><span>hwid);</span></p>
 <p><span>                </span><span>jpeg_drv_hybrid_dec_power_off(hwid);</span></p>
 <p><span>                </span><span>disable_irq(gJpegqDev.hybriddecIrqId[hwid]);</span></p>
 <p><span>                </span><span>jpg_dmabuf_free_iova(bufInfo[hwid].i_dbuf,</span></p>
 <p><span>                        </span><span>bufInfo[hwid].i_attach,</span></p>
 <p><span>                        </span><span>bufInfo[hwid].i_sgt);</span></p>
 <p><span>                </span><span>jpg_dmabuf_free_iova(bufInfo[hwid].o_dbuf,</span></p>
 <p><span>                        </span><span>bufInfo[hwid].o_attach,</span></p>
 <p><span>                        </span><span>bufInfo[hwid].o_sgt);</span></p>
 <p><span>                </span><span>jpg_dmabuf_put(bufInfo[hwid].i_dbuf);</span></p>
 <p><span>                </span><span>jpg_dmabuf_put(bufInfo[hwid].o_dbuf);</span></p>
 <p><span>                </span><span>// we manually add 1 ref count, need to put it.</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>        </span><span>mutex_unlock(&amp;jpeg_hybrid_dec_lock);</span></p>
 <p><span>}</span></p>
 
 <p><span> </span><span>jpeg_drv_hybrid_dec_unlock</span><span> is also called in the event that </span><span>jpeg_drv_hybrid_dec_start</span><span> fails.</span></p>
 
 <p><span>While the </span><span>jpeg_hybrid_dec_lock</span><span> mutex protects the direct core locking and unlocking, it does </span><span>not </span><span>protect the body of the </span><span>jpeg_drv_hybrid_dec_start</span><span> function. This means that while there cannot be concurrent calls to both </span><span>jpeg_drv_hybrid_dec_lock</span><span> and </span><span>jpeg_drv_hybrid_dec_unlock</span><span>, there </span><span>can</span><span> be concurrent calls to </span><span>jpeg_drv_hybrid_dec_start</span><span> and </span><span>jpeg_drv_hybrid_dec_unlock</span><span> which in practice is just as bad, as these two functions racily access the same global data structure </span><span>bufInfo</span><span>.</span></p>
 
 <p><span>One small added complication for this bug is that in order to reach the </span><span>jpeg_drv_hybrid_dec_unlock</span><span> in the </span><span>JPEG_DEC_IOCTL_HYBRID_WAIT</span><span> call, the core </span><span>must be locked before the timeout due to </span><span>a check to ensure that the core is locked before attempting to wait on the core.</span></p>
 
 <p><span>An example of this race in practice with two processes A and B would be (colorized respective to the above code):</span></p>
 <p><span>Process A:</span></p>
 <p><span>Calls ioctl </span><span>JPEG_DEC_IOCTL_HYBRID_START</span><span>, which </span><span>locks core 0</span><span> with </span><span>jpeg_drv_hybrid_dec_lock</span><span> and enters </span><span>jpeg_drv_hybrid_dec_start</span></p>
 <p><span>Process B:</span></p>
 <p><span>Calls ioctl </span><span>JPEG_DEC_IOCTL_HYBRID_WAIT</span><span>, which </span><span>confirms that core 0 is locked</span><span> then </span><span>begins a 3 second wait</span><span> for the core to send an interrupt denoting completion of the decoding request.</span></p>
 <p><span>Process A:</span></p>
 <p><span>Fails </span><span>jpeg_drv_hybrid_dec_start</span><span>, (</span><span>after initializing some of the data structures</span><span>), </span><span>calls jpeg_drv_hybrid_dec_unlock on core 0</span><span> </span><span>freeing any allocated resources</span><span>, and returns to userland.</span></p>
 <p><span>[wait ~3 seconds]</span></p>
 <p><span>Process A:</span></p>
 <p><span>Calls ioctl </span><span>JPEG_DEC_IOCTL_HYBRID_START</span><span>, which </span><span>locks core 0</span><span> with </span><span>jpeg_drv_hybrid_dec_lock</span><span> and enters </span><span>jpeg_drv_hybrid_dec_start</span></p>
 <p><span>Process B:<br/></span><span>3 second wait times out, and the </span><span>JPEG_DEC_IOCTL_HYBRID_WAIT</span><span> ioctl call unlocks core 0 with </span><span>jpeg_drv_hybrid_dec_unlock</span><span>.</span></p>
 <p><span>[Process A and B are now concurrently </span><span>initializing</span><span> and </span><span>freeing</span><span> the same data-structures]</span></p>
 
 <p><span>This can lead to a variety of use-after-free or double free conditions, depending on how process A and B race.</span></p>
 <h2 id="h.84nl0o7e1rz3"><span>The Journey to root</span></h2>
 <p><span>The next step was to try to exploit these issues. My first attempt targeted the OOB write issue, CVE-2023-32837. I was able to develop the primitive from an uncontrolled OOB read/write in the kernel .data region into a racy write of null bytes at a predetermined offset in a kernel task stack used by an attacker-controlled process. At this point it was possible to overwrite a kernel stack entry with nulls during any syscall which felt to me like enough flexibility to create a full exploit. However, despite my best efforts (including the creation of a tool to find where in an arbitrary backtrace the write would occur), I was unable to discover a technique to create a better primitive from this write.</span></p>
 
 <p><span>Failing that effort, I decided to take a look at the other issue in the same driver CVE-2023-32832. During the freeing step that races with </span><span>jpeg_drv_hybrid_dec_start</span><span>, </span><span>jpeg_drv_hybrid_dec_unlock</span><span> drops access to four separate resources:</span></p>
 
 <p><span> </span><span>jpg_dmabuf_free_iova(bufInfo[hwid].i_dbuf, bufInfo[hwid].i_attach,</span><span> </span><span>bufInfo[hwid].i_sgt); </span><span>//The input buffer virtual address mapping in the core</span></p>
 <p><span>jpg_dmabuf_free_iova(bufInfo[hwid].o_dbuf, bufInfo[hwid].o_attach,</span><span> </span><span>bufInfo[hwid].o_sgt); </span><span>//The output buffer virtual address mapping in the core</span></p>
 <p><span>jpg_dmabuf_put(bufInfo[hwid].i_dbuf); </span><span>//The input buffer file&#39;s refcount is decremented. This buffer was previously allocated by the attacker and is associated with a file descriptor.</span></p>
 <p><span>jpg_dmabuf_put(bufInfo[hwid].o_dbuf); </span><span>//The output buffer file&#39;s refcount is decremented. This buffer was previously allocated during jpeg_drv_hybrid_dec_start.</span></p>
 <p><span> </span><span>One critical behavior of the driver that enhanced exploitability was that although </span><span>jpeg_drv_hybrid_dec_unlock</span><span> properly drops the refcounts of </span><span>i_dbuf</span><span> and </span><span>o_dbuf</span><span>, it does </span><span>not</span><span> reinitialize those entries in the </span><span>bufInfo</span><span> global array to </span><span>NULL</span><span>. As it relates to the race, this means that if Process B’s racy </span><span>jpeg_drv_hybrid_dec_unlock</span><span> occurs before Process A’s second </span><span>jpeg_drv_hybrid_dec_start</span><span> reinitializes </span><span>i_dbuf</span><span> and </span><span>o_dbuf</span><span>, an extra refcount of </span><span>i_dbuf</span><span> and </span><span>o_dbuf</span><span> will be released. Since </span><span>i_dbuf</span><span> and </span><span>o_dbuf</span><span> are </span><span>struct file*</span><span>’s, this can lead directly to a </span><span>struct file</span><span> UAF. As the </span><span>i_dbuf</span><span> </span><span>struct</span><span> </span><span>file</span><span> comes directly from a </span><span>dmabuf</span><span> file descriptor passed into </span><span>jpeg_drv_hybrid_dec_start</span><span>, this leads to a </span><span>dangling file descriptor</span><span> with the </span><span>struct file</span><span> freed from underneath it. This is undoubtedly an exploitable bug.</span></p>
 
 <p><span>There are several different techniques for exploiting a dangling file descriptor. One widely used strategy is causing the backing slab page of the struct file to be freed and returned back to the page allocator, then reallocating that page </span><span>with pipe buffer</span><span> data pages in order to gain attacker control over the memory used for the struct file. Another well-known strategy would be to utilize the cross-cache technique to reallocate the memory as a different kind of kmalloc slab/object. However, in the future both of these techniques may be remediated if the </span><span><a href="https://www.google.com/url?q=https://lore.kernel.org/all/20230915105933.495735-15-matteorizzo@google.com/&amp;sa=D&amp;source=docs&amp;ust=1712947244908914&amp;usg=AOvVaw0WRxCpYz3NaM3wsC8DKyOp">SLAB_VIRTUAL mitigation</a></span><span><a href="https://www.google.com/url?q=https://lore.kernel.org/all/20230915105933.495735-15-matteorizzo@google.com/&amp;sa=D&amp;source=docs&amp;ust=1712947244908914&amp;usg=AOvVaw0WRxCpYz3NaM3wsC8DKyOp"> </a></span><span>comes into effect in the mainline Linux kernel. In the interest of exploring the future of Android kernel hacking, I sought a novel exploitation technique which did not involve cross-cache or slab-cache-&gt;page allocator heap shaping techniques.</span></p>
 <h3 id="h.5itga4usq4ih"><span>Some Other Novel Exploitation Technique</span></h3>
 <p><span>One of the most common UAF exploit techniques involves reallocating the first-order freed object with a new object of a different type, creating a type-confusion condition which leads to an improved memory corruption primitive. However the only type of object that can be allocated in a page designated for the </span><span>struct file</span><span> cache is the </span><span>struct file</span><span> type, so the options for creating a type confusion memory corruption condition using first-order object reclamation are limited. However, just because an object is freed does not preclude it from being usable under limited circumstances. When the kernel inserts an object onto a freelist, this </span><span>clobbers</span><span> </span><span><a href="https://lore.kernel.org/linux-mm/202003051624.AAAC9AECC@keescook/t/">the middle</a></span><span> of the object. The rest of the object however, remains in whatever state it was in at the moment it was freed, including pointers and any other member variables. Those stale pointers can (and in practice often do) point to other freed objects which may be allocated from a different slab cache entirely, potentially including the generic kmalloc slab-caches. </span><span>Note that under the </span><span><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152148">C-ism</a></span><span><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152148"> where pointers are set to </a></span><span><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152148">NULL</a></span><span><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152148"> after freeing</a></span><span>, these stale pointers wouldn’t exist.</span><span> However as the memory containing the pointer is getting freed anyway, setting these pointers to </span><span>NULL</span><span> is often seen as unnecessarily conservative (and in fact, </span><span><a href="https://www.cryptologie.net/article/419/zeroing-memory-compiler-optimizations-and-memset_s/">C compilers often throw away writes to objects that are about to be freed</a></span><span>).</span></p>
 
 <p><span>By continuing to use this freed </span><span>first-order</span><span> object, we can implicitly access freed </span><span>second-order</span><span> child objects. By reclaiming </span><span>those</span><span> objects, we can recreate a type-confusion memory corruption primitive, taking advantage of how the methods called on the first-order freed object implicitly access the second-order child object. Let’s see how we can apply this to our specific scenario.</span></p>
 
 <p><span>Linux kernel </span><span>struct file</span><span>s may represent many different types of files depending on the kind of opened file </span><span>such as ext4 files, procfs files, or even MediaTek JPEG decoding driver files. In order to represent all of these different types while also maintaining some commonality of structure for the universally needed members of an opened file, </span><span>struct file</span><span> contains a </span><span>private_data</span><span> member which references any type-specific data needed.</span></p>
 
 <p><span>As mentioned previously, the UAF’d </span><span>struct file</span><span> in this case is a </span><span>dmabuf</span><span> file. This means the </span><span>private_data</span><span> pointer points to a </span><span>struct dma_buf</span><span> object. The </span><span>dma_buf</span><span> object lifetime is implicitly tied to the lifetime of the associated </span><span>dmabuf</span><span> file struct. When the </span><span>dmabuf struct file</span><span> is freed, the </span><span>dma_buf</span><span> object is freed too. However </span><span>unlike</span><span> the </span><span>struct file</span><span>, </span><span>dma_buf</span><span> objects are allocated from the generic kmalloc slab caches</span><span>. This means that the </span><span>dma_buf</span><span> </span><span>can </span><span>be reclaimed with a different type object that comes from the same generic kmalloc slab cache.</span></p>
 
 <p><span>After a hypothetical reclamation by a new object, this new object can still be UAF referenced </span><span>as</span><span> a </span><span>dma_buf</span><span> through the freed but still very usable </span><span>dmabuf struct file</span><span> that </span><span>itself </span><span>is referenced via the dangling file descriptor! Thus we arrive at the following strategy:</span></p><ol start="1"><li><span>Free the file by using our race condition bug to drop an extra reference on </span><span>i_dbuf</span><span> (which also frees the </span><span>dma_buf</span><span>), leaving a dangling </span><span>fd</span><span> pointing to a freed </span><span>struct file</span><span> which still has a stale pointer to a freed </span><span>dma_buf</span></li><li><span>Reclaim the </span><span>dma_buf</span><span> WITHOUT reclaiming the </span><span>struct file</span></li><li><span>Call </span><span>dma_buf</span><span> operations on the dangling </span><span>fd</span></li></ol>
 
 <p><span>You may have astutely noted by this point that this strategy relies on a freed object (that is, the </span><span>struct file</span><span>) not being reclaimed as another object by the heap allocator. This is absolutely correct, and one would expect that in an exploit where exceptional reliability is a priority, it may be necessary to perform some heap shaping in order to bury this freed </span><span>struct file</span><span> deeply in the allocator freelists. In practice (and in my exploit), the freed </span><span>struct file</span><span> will rarely be on the percpu active slab so it’s unlikely to get reclaimed immediately, and my exploit generally runs fast enough that it doesn’t matter.</span></p>
 
 <p><span>At this point we now need to determine what object to use in order to reclaim the freed </span><span>dma_buf</span><span>, as well as what operation to call on the freed </span><span>dma_buf</span><span> file/object to develop a stronger primitive. I ended up finding the solutions to both of these problems in the GED driver.</span></p><h3 id="h.5y999iuz9knd"><span>The GED driver</span></h3>
 <p><span>The GED (GPU Extension Device) driver is a MediaTek-specific interface that provides userland with several supplementary GPU features, primarily for tuning purposes. Two of its “features” appeared particularly valuable. Feature number one, GED GE Buffers, presented a truly remarkable heap spray and reclamation primitive. This feature provides several requisite characteristics of a suitable heap spray primitive:</span></p><ul><li><span>Allocates buffers of a controlled size without causing undue noise for the rest of the heap.</span></li><li><span>Buffer data is fully attacker controlled, with no uncontrolled header at the beginning</span></li><li><span>Buffers can be freed at any time.</span></li></ul>
 <p><span>One standout characteristic that elevates this heap spray primitive above many of its peers however, is that even once allocated, the attacker can read and write to these buffers at will </span><span>while keeping the buffer allocated.</span><span> This is about as powerful a heap spray primitive as one could imagine. By reclaiming the UAF’d </span><span>dma_buf</span><span> struct with a GED GE buffer, we gain fully deterministic read/write over the </span><span>dma_buf</span><span> struct, including any pointers contained therein.</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjc09kF7Yn0WI8PNuSGP9V1mXoszwnxS_FSdSUgDBVeFuZJ4l_CNTFrqrmCBrCnrrQ43x_jrQEloAj5hHz8mIPLUW7KNWZC4TP39vBNgZHDNAT1gMjxYsCNXzGb0qU6aO8J4g4QrsvYBgnClQlm-I__4IWSCgZbWULq-zMZvBQPXlAU7qS83gj4fQPNrAk/s721/image7.png"><img alt="Graph showing the overlapping object hierarchy of a UAF&#39;d dma buffer struct file and a GE file" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjc09kF7Yn0WI8PNuSGP9V1mXoszwnxS_FSdSUgDBVeFuZJ4l_CNTFrqrmCBrCnrrQ43x_jrQEloAj5hHz8mIPLUW7KNWZC4TP39vBNgZHDNAT1gMjxYsCNXzGb0qU6aO8J4g4QrsvYBgnClQlm-I__4IWSCgZbWULq-zMZvBQPXlAU7qS83gj4fQPNrAk/s721/image7.png" title="Graph showing the overlapping object hierarchy of a UAF&#39;d dma buffer struct file and a GE file"/></a></span></p>
 
 <p><span>Feature number two is an alternate codepath to the same functionality as the </span><span>DMA_BUF_SET_NAME</span><span> ioctl, which is (very sensibly) used to set the name of a </span><span>dma_buf</span><span>. The biggest difference between these paths is the GED codepath’s lack of SELinux inode checks on the underlying </span><span>dma_buf</span><span> </span><span>fd</span><span>. These inode checks would normally crash the kernel when they run on a freed </span><span>struct file</span><span> - however because of the GED codepath, we can skip this inode check, and change the </span><span>dma_buf</span><span>’s name despite running on a freed </span><span>dma_buf</span><span> file! Normally, this code would free the pointer to the previous name within the </span><span>dma_buf</span><span> struct and allocate a new buffer for the name string. However, because of GED GE buffers we are able to control the entirety of the </span><span>dma_buf</span><span> struct. By combining these primitives, we can </span><span>kfree</span><span> an </span><span>arbitrary pointer</span><span> before setting a new name string.</span></p>
 
 <p><span> </span><span>long</span><span> </span><span>mtk_dma_buf_set_name(</span><span>struct</span><span> </span><span>dma_buf</span><span> </span><span>*dmabuf,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*buf)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>char</span><span> </span><span>*name</span><span> </span><span>=</span><span> </span><span>kstrndup(buf,</span><span> </span><span>DMA_BUF_NAME_LEN,</span><span> </span><span>GFP_KERNEL);</span></p>
 <p><span>        </span><span>...</span></p>
 <p><span>        </span><span>kfree(dmabuf-&gt;name); </span><span>//dmabuf is attacker controlled</span></p>
 <p><span>        </span><span>dmabuf-&gt;name</span><span> </span><span>=</span><span> </span><span>name; </span><span>//the name pointer is written to attacker controlled memory</span></p>
 <p><span>        </span><span>...</span></p>
 <p><span>}</span></p>
 <h3 id="h.l1p8heskmxsz"><span>Achieving arbitrary read</span></h3>
 <p><span>Innocuous </span><span>dmabuf</span><span> file operations become potent primitives now that we have precise control of the </span><span>dma_buf</span><span> struct. For example, this is the code backing /</span><span>proc/pid/fdinfo/n</span><span> for </span><span>dmabuf</span><span> files:</span></p>
 
 <p><span> </span><span>static</span><span> </span><span>void</span><span> </span><span>dma_buf_show_fdinfo(</span><span>struct</span><span> </span><span>seq_file</span><span> </span><span>*m,</span><span> </span><span>struct</span><span> </span><span>file</span><span> </span><span>*file)</span></p>
 <p><span>{</span></p>
 <p><span>        </span><span>struct</span><span> </span><span>dma_buf</span><span> </span><span>*</span><span>dmabuf</span><span> </span><span>=</span><span> </span><span>file-&gt;private_data;</span></p>
 
 <p><span>        </span><span>seq_printf(m,</span><span> </span><span>&#34;size:\t%zu\n&#34;</span><span>,</span><span> </span><span>dmabuf</span><span>-&gt;size);</span></p>
 <p><span>        </span><span>/*</span><span> </span><span>Don</span><span>&#39;</span><span>t</span><span> </span><span>count</span><span> </span><span>the</span><span> </span><span>temporary</span><span> </span><span>reference</span><span> </span><span>taken</span><span> </span><span>inside</span><span> </span><span>procfs</span><span> </span><span>seq_show</span><span> </span><span>*/</span></p>
 <p><span>        </span><span>seq_printf(m,</span><span> </span><span>&#34;count:\t%ld\n&#34;</span><span>,</span><span> </span><span>file_count(</span><span>dmabuf</span><span>-&gt;file)</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span></p>
 <p><span>        </span><span>seq_printf(m,</span><span> </span><span>&#34;exp_name:\t%s\n&#34;</span><span>,</span><span> </span><span>dmabuf</span><span>-&gt;exp_name);</span></p>
 <p><span>        </span><span>spin_lock(&amp;</span><span>dmabuf</span><span>-&gt;name_lock);</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>dmabuf</span><span>-&gt;name)</span></p>
 <p><span>                </span><span>seq_printf(m,</span><span> </span><span>&#34;name:\t%s\n&#34;</span><span>,</span><span> </span><span>dmabuf</span><span>-&gt;name);</span></p>
 <p><span>        </span><span>spin_unlock(&amp;</span><span>dmabuf</span><span>-&gt;name_lock);</span></p>
 <p><span>}</span></p>
 <p><span>There are several opportunities in this function for achieving arbitrary read, but the cleanest one is the </span><span>file_count()</span><span> call, which will dereference the passed pointer + a hardcoded offset, and print the read 8 byte value as a signed long. Normally in the context of this C function, </span><span>file == ((struct dma_buf*) file-&gt;private_data)-&gt;file</span><span> , but since we control the </span><span>dma_buf</span><span> struct that isn’t necessarily the case.</span></p>
 <h3 id="h.m3a0br51kkz"><span>Achieving arbitrary write</span></h3>
 <p><span>At this point we have three powerful primitives:</span></p><ul><li><span>Read/write UAF’d </span><span>dma_buf</span><span> struct memory (via GED GE buffers)</span></li><li><span>Arbitrary read (via </span><span>dma_buf_show_fdinfo</span><span>)</span></li><li><span>Arbitrary free (via </span><span>ged_dmabuf_set_name</span><span>)</span></li></ul>
 

<p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEilzJmXjC5MwoGnxuUe6-rqIyG5EXRaE_B0V8VCgMLkIqXExr7_70KBjmSunxcHwktChFADLZAzByhKhUZVFaps-ZvoyWrMCUCK2eEmbQdVLhQrtiJbSB4kW_WkPxjv_9xNWfj5VgBFOPxfIixfDAzf4OXZS58tY7GgSSWGZ8pf11uf1Z0KThjgxutlz_o/s721/image8.png"><img alt="Graph showing our arbitrary read and arbitrary free primitives via the UAF&#39;d dma buffer" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEilzJmXjC5MwoGnxuUe6-rqIyG5EXRaE_B0V8VCgMLkIqXExr7_70KBjmSunxcHwktChFADLZAzByhKhUZVFaps-ZvoyWrMCUCK2eEmbQdVLhQrtiJbSB4kW_WkPxjv_9xNWfj5VgBFOPxfIixfDAzf4OXZS58tY7GgSSWGZ8pf11uf1Z0KThjgxutlz_o/s721/image8.png" title="Graph showing our arbitrary read and arbitrary free primitives via the UAF&#39;d dma buffer"/></a></span></p>
 

 <p><span>There are many potential strategies that use these primitives to achieve an arbitrary write primitive. The technique I chose was to type-confuse a GE buffer with a GE buffer </span><span>array</span><span>. GED GE Buffers are tracked through a hierarchy of structs and arrays. A GE file’s </span><span>private_data</span><span> member points to an array of GE buffer pointers like so:</span></p>
 

<p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgSqvGA83iM6fq-D7sAnG4OCM6T_OdDGD5LpYKJBvE6xFxCciy51nIE4MBa3jERVONt_0tArpFf2YMFuxHE-LmT49UdX6fMgGlZ2kEPCc0sTKKeFE0F5BEphWMyZ9jWUF07vlEomRoxBgP9at8zPODEIPqTfPFlYzBTgShwo7TrlrNlEkieeDjxlWlRvWk/s611/image4.png"><img alt="Graph showing the object hierarchy of GE files within an fdtable down to GE buffers" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgSqvGA83iM6fq-D7sAnG4OCM6T_OdDGD5LpYKJBvE6xFxCciy51nIE4MBa3jERVONt_0tArpFf2YMFuxHE-LmT49UdX6fMgGlZ2kEPCc0sTKKeFE0F5BEphWMyZ9jWUF07vlEomRoxBgP9at8zPODEIPqTfPFlYzBTgShwo7TrlrNlEkieeDjxlWlRvWk/s611/image4.png" title="Graph showing the object hierarchy of GE files within an fdtable down to GE buffers"/></a></span></p>

 
 <p><span>I achieve this type-confusion by using the arbitrary-free primitive developed previously to free a GE buffer array, then reclaiming that array with a GE buffer from a second GE file. Since the GE buffer array (and GE buffers as well) come from generic kmalloc caches, the only requirement for this reclamation is allocating GE buffers that are the same size as a GE buffer array. If two GE files are referencing the same memory, one (GE file A) as a GE buffer, and one (GE file B) as a GE buffer </span><span>array, </span><span>I can modify the contents of a GE buffer array at will.</span></p>
 

 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEioaW3vdBverVpVB95IW7_vsrH8JdiB52ly8zRn5A0QYG9LF5XCNdmhK07LRTlACDxxvOII82zFoHHGnA15VjkDJiKVZXqyykk2KI3pzr1-LXJaYTF2igmf4l7zfs__LrnJ0BcTpRjMXOjS6cJNAR3bJAZ6O4nRG1kfHCQs1QySE689IW-iha9dxoOz28o/s731/image1.png"><img alt="Graph showing the overlapping object hierarchy of two GE files where one file&#39;s GE buffer is another file&#39;s GE buffer array" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEioaW3vdBverVpVB95IW7_vsrH8JdiB52ly8zRn5A0QYG9LF5XCNdmhK07LRTlACDxxvOII82zFoHHGnA15VjkDJiKVZXqyykk2KI3pzr1-LXJaYTF2igmf4l7zfs__LrnJ0BcTpRjMXOjS6cJNAR3bJAZ6O4nRG1kfHCQs1QySE689IW-iha9dxoOz28o/s731/image1.png" title="Graph showing the overlapping object hierarchy of two GE files where one file&#39;s GE buffer is another file&#39;s GE buffer array"/></a></span></p>

 
 <p><span>Then performing an arbitrary write to a virtual address X will be as simple as using GE file A’s GE buffer to change the contents of the array to point to the virtual address X, then writing to that address using GE file B which now thinks virtual address X is a GE buffer!</span></p>
 
 <p><span>This technique hinges on being able to use the arbitrary free primitive to free a GE buffer array. To do that, it’s necessary to find the </span><span>virtual address</span><span> of a GE buffer array first. Since we have an arbitrary read primitive already, </span><span>any</span><span> parent struct/object/array of a GE buffer array will be enough to find the virtual address of a GE buffer array itself. The hierarchy is as follows:</span></p><ol start="1"><li><span>GE arrays are referenced by a GE file</span></li><li><span>GE files are referenced by an </span><span>fdtable</span><span> as a file descriptor</span></li><li><span>An </span><span>fdtable</span><span> is referenced by a </span><span>task struct</span></li><li><span>Task structs</span><span> are referenced as part of the task list with the root node being the </span><span>init</span><span> task in the kernel image</span></li></ol>
 <p><span>The </span><span>fdtable</span><span> represents an attractive object to find, as it comes out of the same generic kmalloc cache as </span><span>dma_buf</span><span> name strings. We can find a </span><span>dma_buf</span><span> name string’s virtual address by using </span><span>dma_buf_set_name</span><span> (which we also use as our arbitrary free primitive) to insert a pointer to a </span><span>dma_buf</span><span> name string into the reclaimed UAF’d </span><span>dma_buf</span><span> object that is now a GE buffer. We then simply read it out of our GE buffer, free that </span><span>dma_buf</span><span> name string (again using </span><span>dma_buf_set_name</span><span>), and reclaim it with an </span><span>fdtable</span><span>. Creating </span><span>fdtable</span><span>s is fairly easy - we simply </span><span>fork</span><span> many processes ahead of time that share an </span><span>fdtable</span><span>, then </span><span>unshare(2)</span><span> the </span><span>fdtable</span><span> at the appropriate time to allocate new </span><span>fdtable</span><span>s. The full exploit strategy is as follows:</span></p><ol start="1"><li><span>Trigger a </span><span>dangling fd</span><span> of a </span><span>dmabuf</span><span> file</span><span> using our mtk-jpeg race condition bug</span></li><li><span>Reclaim</span><span> the underlying </span><span>dma_buf</span><span> leaving the parent </span><span>dmabuf</span><span> file </span><span>free</span><span> (but still referenced by a dangling file descriptor)</span></li><li><span>Use </span><span>ged_dmabuf_set_name</span><span> on our dangling file to place a new name pointer in the fake </span><span>dma_buf</span><span> struct</span></li><li><span>Read</span><span> the fake </span><span>dma_buf</span><span> struct (which is really a GE buffer) to get the </span><span>name pointer</span></li><li><span>Free</span><span> the </span><span>name pointer</span><span> by calling </span><span>ged_dmabuf_set_name</span><span> again</span></li><li><span>Reclaim</span><span> the name pointer as an </span><span>fdtable</span><span> with references to a GE fd with an array of GE buffers</span></li><li><span>Use the </span><span>arbitrary read</span><span> to find the GE buffer </span><span>array</span></li><li><span>Use the </span><span>arbitrary free</span><span> to free the GE buffer </span><span>array</span></li><li><span>Reclaim</span><span> the GE buffer </span><span>array</span><span> with another GE buffer</span></li></ol>
 
 <p><span>At the end of this process we’ll have a reliable arbitrary read/write!</span></p>
 <h3 id="h.2dekzwa3x6g5"><span>Getting a root shell</span></h3>
 <p><span>As a fun exercise, I decided to see how easy it was to disable SELinux and get root after achieving arbitrary read/write. Various manufacturers may implement certain tripping hazards to slow down exploit development efforts, but in my case (Asus ROG 6D), there were no hoops I needed to jump through at all. It was enough to simply write 0 to the </span><span>uid</span><span>/</span><span>gid</span><span> of my process’s </span><span>cred</span><span> struct to achieve root, and write 0 to the </span><span>selinux_enforcing</span><span> bit to turn off SELinux. After this I just </span><span>execlp(“/system/bin/sh”,...) </span><span>and out pops a root shell!</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgAy_jgDPyEiAmxQxmtSQXC1Q4eQ2alAYsJFiGXLUAFRi-OrljxWON-M1NBxe8LfwO9PWGBRdq-feWA8J3mKl5TTfhlHpAPVuFaH5WSSjCXVUKoj5840vfXf-iGNe1Q9QlFmOENGbYHZHwGqIPbLvAhbpATKcJ6VxhrXaAH3zsh7k_t3pH2so7Zs-QU8ro/s1422/image3.gif"><img alt="Getting root on an Android device with the exploit" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgAy_jgDPyEiAmxQxmtSQXC1Q4eQ2alAYsJFiGXLUAFRi-OrljxWON-M1NBxe8LfwO9PWGBRdq-feWA8J3mKl5TTfhlHpAPVuFaH5WSSjCXVUKoj5840vfXf-iGNe1Q9QlFmOENGbYHZHwGqIPbLvAhbpATKcJ6VxhrXaAH3zsh7k_t3pH2so7Zs-QU8ro/s1200/image3.gif" title="Getting root on an Android device with the exploit"/></a></span></p><h2 id="h.tb4jn1vwpqsi"><span>Conclusion</span></h2>
 <p><span>I discovered significant security vulnerabilities across all 3 of the evaluated devices. It is highly likely that reviewing more devices comprising a greater spread of chipset manufacturers would lead to the discovery of additional vulnerabilities. </span><span>Android regularly uses higher-privileged processes to liaise between applications and kernel drivers, meaning that most kernel drivers cannot be seen from an unprivileged app context (the GPU being the most obvious exception to this rule). Nevertheless, a determined attacker could use vulnerabilities in other more privileged processes to pivot into contexts from which the attack surface of these kernel drivers become reachable.</span><span> This pivot strategy could widen the attack surface beyond the scope of this research.</span></p>
 
 <p><span>As it becomes more difficult to find 0-days in core Android, third-party Linux kernel drivers continue to become a more and more attractive target for attackers. While the bulk of present-day detected ITW Android exploitation targets GPU drivers, it’s equally important that other third-party drivers are encouraged towards the same security standards.</span></p>
 
 <p><span>There is room for improvement in the patching process across all 3 of the bugs discovered. None of the patches for these bugs met Project Zero&#39;s 90-day deadline for patches reaching end-users. This appears to largely be a result of the propagation delay from when third-party driver developers issue patches to when downstream manufacturers can incorporate those patches into Android security updates. Shortening this propagation delay </span><span>(e.g. using </span><span><a href="https://source.android.com/docs/core/ota/apex">Android APEX</a></span><span> to ship updated kernel drivers)</span><span> would go a long way to minimizing the Android driver patch gap. In addition, one of these bugs was only partially patched and remained exploitable on some devices for an additional 2 years before the security impact of the bug was assessed and publicly reported.</span><span> </span><span>Developers should regularly consider the security impacts of bugs, especially those reported by static analysis tools designed to detect security-relevant issues.</span></p>
 
 <p><span>Finally, while cross-cache heap shaping mitigations significantly impede exploit development strategies, they don’t entirely prevent a determined attacker from exploiting kernel UAF vulnerabilities, even if the UAF’d object comes out of a dedicated slab cache. In this particular case, second-order allocations in a UAF’d object lead to powerful and exploitable primitives. </span><span>Developers may be able to mitigate this technique by setting pointers to NULL, even if the parent object is about to get freed anyway.</span><span> However, this exploit technique demonstrates that even well-designed mitigations (such as SLAB_VIRTUAL) come with limitations in an era where an attacker can achieve undetected memory corruption. It will take more fundamental mitigations that address the root issue of memory corruption, like MTE, in order to dramatically raise the bar for attackers.</span></p>
 <h2 id="h.ds4ya8k4hu83"><span>Resources</span></h2>
 <p><span>This research was presented at ShmooCon, a video is available here </span><span><a href="https://archive.org/details/shmoocon2024/Shmoocon2024-SethJenkins-Driving_Forward_in_Android_Drivers.mp4">https://archive.org/details/shmoocon2024/Shmoocon2024-SethJenkins-Driving_Forward_in_Android_Drivers.mp4</a></span></p>
 
 <p><span>The proof of concept exploit code developed and presented in this research is available at:</span></p>
 <p><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2470#c4">https://bugs.chromium.org/p/project-zero/issues/detail?id=2470#c4</a></span></p>

</div></div>
  </body>
</html>
