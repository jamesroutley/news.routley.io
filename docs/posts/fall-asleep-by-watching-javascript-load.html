<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/sarusso/bedtime">Original</a>
    <h1>Show HN: Fall asleep by watching JavaScript load</h1>
    
    <div id="readability-page-1" class="page"><div><p>Agent skills have been described as a game-changer. I do not dispute the
characterization, but they are also spoken about in rather mystical language,
and that does bother me a bit.</p>
<p>Rather than a complex technical breakthrough, they are another example of what
Claude Code has been getting right since the beginning: simple but powerful
tools (like “Read file”, “Grep”, “Bash”) combined with the model’s natural
helpfulness take you a very long way.</p>
<p><strong>In this post we will implement a skill system compatible with Anthropic’s
public skills in just over 100 lines of code.</strong></p>
<p>I wrote the original implementation in <a href="https://solve.it.com">Solve It</a>, a tool
and approach to learning by doing, while taking advantage of AI in a way that
accelerates your learning instead of replacing your understanding. Check out
the <a href="https://share.solve.it.com/d/a0d4351d40ec019b44059b2cb341b06d">dialog walking through my original implementation
process</a>.</p>
<h2>What is an Agent Skill?</h2>
<p>Agent skills are a shareable way of giving an agent a new capability. They
consist of a folder with a <code>SKILL.md</code> markdown file in it. The file contains a
name and a description that explains when it should be used. The rest of the
file is the actual instructions.</p>
<p>The key feature of skills is progressive disclosure. On load, agents are only
told about the names and descriptions of the skills. Only when they decide to
“activate” a particular skill do the instructions get loaded into the context.
The <code>SKILL.md</code> file can in turn reference other files with more instructions for
specialized use cases. And the skill can also bundle scripts to be executed
without having to be written by the LLM or read into context. Everything is
loaded just-in-time, conserving context as much as possible.</p>
<p>Skills were first introduced as a Claude Code feature, but they were quickly
made into an open standard by Anthropic. Agents like Copilot and ChatGPT
followed with support shortly after.</p>
<h2>Skill discovery</h2>
<p>The <a href="https://agentskills.io/integrate-skills">Agent Skill spec</a> has this to say
about skill structure:</p>
<blockquote>
<p>Skills are folders containing a <code>SKILL.md</code> file. Your agent should scan
configured directories for valid skills.</p>
</blockquote>
<p>The <code>SKILL.md</code> file must contain YAML frontmatter followed by Markdown content:</p>
<pre><code><span>---</span>
name: skill-name
<span>description: A description of what this skill does and when to use it.
<span>---</span></span>

Some skill instructions.
</code></pre>
<p>Let’s start by writing a <code>Skill</code> dataclass to load skills from a folder and
hold their data:</p>
<pre><code><span>from</span> dataclasses <span>import</span> dataclass
<span>from</span> pathlib <span>import</span> Path

<span>import</span> frontmatter


<span>@dataclass</span>
<span>class</span> <span>Skill</span><span>:</span>
    name<span>:</span> <span>str</span>
    description<span>:</span> <span>str</span>
    location<span>:</span> <span>str</span> <span>=</span> <span>None</span>

    <span>@classmethod</span>
    <span>def</span> <span>from_directory</span><span>(</span>cls<span>,</span> directory<span>)</span><span>:</span>
        location <span>=</span> <span>str</span><span>(</span><span>(</span>Path<span>(</span>directory<span>)</span> <span>/</span> <span>&#39;SKILL.md&#39;</span><span>)</span><span>.</span>resolve<span>(</span><span>)</span><span>)</span>
        post <span>=</span> frontmatter<span>.</span>load<span>(</span>location<span>)</span>

        <span>return</span> cls<span>(</span>
            name<span>=</span>post<span>[</span><span>&#39;name&#39;</span><span>]</span><span>,</span>
            description<span>=</span>post<span>[</span><span>&#39;description&#39;</span><span>]</span><span>,</span>
            location<span>=</span>location
        <span>)</span>

    <span>def</span> <span>instructions</span><span>(</span>self<span>)</span><span>:</span>
        post <span>=</span> frontmatter<span>.</span>load<span>(</span>self<span>.</span>location<span>)</span>
        <span>return</span> post<span>.</span>content
</code></pre>
<p>We used <a href="https://python-frontmatter.readthedocs.io/en/latest/"><code>frontmatter</code></a>
for parsing the YAML section. We are only getting the name and the description
from there, but the spec also describes <a href="https://agentskills.io/specification#skill-md-format">other optional
keys</a> that you might want
to check out. We stored the absolute path to the skill folder so the agent
knows where to look for more files. And we also added an <code>instructions</code> method
to fetch the entire skill file on demand.</p>
<p>Next let’s write a helper to find the skills in the “configured directories”,
so that later we can tell the agent about them.</p>
<pre><code><span>import</span> os
<span>from</span> typing <span>import</span> List

<span>def</span> <span>load_skills</span><span>(</span><span>)</span> <span>-</span><span>&gt;</span> List<span>[</span>Skill<span>]</span><span>:</span>
    <span>return</span> <span>[</span>
        Skill<span>.</span>from_directory<span>(</span>full_path<span>)</span>
        <span>for</span> skills_root <span>in</span> os<span>.</span>environ<span>.</span>get<span>(</span><span>&#39;SKILLS_PATH&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span><span>.</span>split<span>(</span><span>&#39;:&#39;</span><span>)</span>
        <span>for</span> directory <span>in</span> Path<span>(</span>skills_root<span>)</span><span>.</span>iterdir<span>(</span><span>)</span>
        <span>if</span> <span>(</span>full_path <span>:</span><span>=</span> Path<span>(</span>skills_root<span>)</span> <span>/</span> directory<span>)</span><span>.</span>is_dir<span>(</span><span>)</span>
    <span>]</span>
</code></pre>
<p>We expect a <code>PATH</code> style environment variable called <code>SKILLS_PATH</code> with a list
of <code>:</code> separated folders that contain skills, and we use <code>Skill.from_directory</code>
to load each one as a <code>Skill</code> object.</p>
<p>The spec also has some information about how to describe the skills to agents:</p>
<blockquote>
<p>For filesystem-based agents, include the location field with the absolute
path to the <code>SKILL.md</code> file. For tool-based agents, the location can be
omitted. Keep metadata concise. Each skill should add roughly 50-100 tokens
to the context.</p>
</blockquote>
<pre><code><span><span><span>&lt;</span>available_skills</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>skill</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>name</span><span>&gt;</span></span>pdf-processing<span><span><span>&lt;/</span>name</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>description</span><span>&gt;</span></span>Extracts text and tables from PDF files, fills forms, merges documents.<span><span><span>&lt;/</span>description</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>location</span><span>&gt;</span></span>/path/to/skills/pdf-processing/SKILL.md<span><span><span>&lt;/</span>location</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>skill</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>available_skills</span><span>&gt;</span></span>
</code></pre>
<p>Let’s write a function to load all of the skills and put them in the model’s
desired format:</p>
<pre><code><span>import</span> xml<span>.</span>etree<span>.</span>ElementTree <span>as</span> ET

<span>def</span> <span>available_skills</span><span>(</span><span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>
    <span>&#34;&#34;&#34;Returns a skill description block to be added to the system prompt&#34;&#34;&#34;</span>
    skills <span>=</span> load_skills<span>(</span><span>)</span>
    root <span>=</span> ET<span>.</span>Element<span>(</span><span>&#39;available_skills&#39;</span><span>)</span>
    <span>for</span> s <span>in</span> skills<span>:</span>
        skill_el <span>=</span> ET<span>.</span>SubElement<span>(</span>root<span>,</span> <span>&#39;skill&#39;</span><span>)</span>
        ET<span>.</span>SubElement<span>(</span>skill_el<span>,</span> <span>&#39;name&#39;</span><span>)</span><span>.</span>text <span>=</span> s<span>.</span>name
        ET<span>.</span>SubElement<span>(</span>skill_el<span>,</span> <span>&#39;description&#39;</span><span>)</span><span>.</span>text <span>=</span> s<span>.</span>description
        ET<span>.</span>SubElement<span>(</span>skill_el<span>,</span> <span>&#39;location&#39;</span><span>)</span><span>.</span>text <span>=</span> s<span>.</span>location
    ET<span>.</span>indent<span>(</span>root<span>)</span>
    <span>return</span> ET<span>.</span>tostring<span>(</span>root<span>,</span> encoding<span>=</span><span>&#39;unicode&#39;</span><span>)</span>
</code></pre>
<h2>The <code>skill</code> tool</h2>
<p>Now we can tie all the discovery helpers together into an agent tool.</p>
<pre><code><span>def</span> <span>skill</span><span>(</span>
    name<span>:</span> <span>str</span><span>,</span>  <span># The name of a skill to activate</span>
<span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>  <span># The contents of the skill&#39;s SKILL.md</span>
    <span>for</span> skills_root <span>in</span> os<span>.</span>environ<span>.</span>get<span>(</span><span>&#39;SKILLS_PATH&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span><span>.</span>split<span>(</span><span>&#34;:&#34;</span><span>)</span><span>:</span>
        skill_path <span>=</span> Path<span>(</span>skills_root<span>)</span> <span>/</span> name
        <span>if</span> skill_path<span>.</span>exists<span>(</span><span>)</span><span>:</span>
            <span>return</span> Skill<span>.</span>from_directory<span>(</span>skill_path<span>)</span><span>.</span>instructions<span>(</span><span>)</span>

skill<span>.</span>__doc__ <span>=</span> <span><span>f&#34;&#34;&#34;
Execute a skill within the main conversation

When users ask you to perform tasks, check if any of the available skills below
can help complete the task more effectively. Skills provide specialized
capabilities and domain knowledge.

How to use skills:
- Invoke skill using this tool with the skill name only (no arguments).
- When you invoke a skill, the skill&#39;s prompt will expand and provide
  detailed instructions on how to complete the task.

Important:
- Only use skills listed in &lt;available_skills&gt; below.
- Do not invoke a skill that is already running.

</span><span><span>{</span>available_skills<span>(</span><span>)</span><span>}</span></span><span>
&#34;&#34;&#34;</span></span>
</code></pre>
<p>We will be using <a href="https://claudette.answer.ai"><code>claudette</code></a> to test the
implementation, so we need to adhere to its tool format.</p>
<p>Python docstrings cannot be f-strings, so we set it separately. We needed
an f-string to be able to use <code>available_skills</code>.</p>
<p>Interestingly, Claude Code doesn’t say anything about skills in its system
prompt, leaving it up to the <code>Skill</code> <a href="https://mikhail.io/2025/10/claude-code-skills/#skill-tool-definition">tool
description</a>.
The above description is adapted from Claude Code’s by removing some parts to
make it more agent-agnostic. We are not doing any fancy context manipulation,
because I found that simply returning the context as a string result from the
tool works well enough.</p>
<h2>The <code>read</code> tool</h2>
<p>So far we could use single <code>.md</code> file skills, but to fully leverage progressive
disclosure the agent needs a way to read other files referenced in <code>SKILL.md</code>.
Let’s add a <code>read</code> tool to help with that.</p>
<pre><code><span>def</span> <span>is_valid_absolute_path</span><span>(</span>path<span>:</span> <span>str</span><span>)</span> <span>-</span><span>&gt;</span> <span>bool</span><span>:</span>
    path <span>=</span> Path<span>(</span>path<span>)</span>
    <span>if</span> <span>not</span> path<span>.</span>is_absolute<span>(</span><span>)</span><span>:</span>
        <span>return</span> <span>False</span>
    valid_roots <span>=</span> <span>[</span>Path<span>(</span>root<span>)</span> <span>for</span> root <span>in</span> os<span>.</span>environ<span>.</span>get<span>(</span><span>&#39;SKILLS_PATH&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span><span>.</span>split<span>(</span><span>&#34;:&#34;</span><span>)</span><span>]</span>
    <span>return</span> <span>any</span><span>(</span>path<span>.</span>is_relative_to<span>(</span>root<span>)</span> <span>for</span> root <span>in</span> valid_roots<span>)</span>

<span>def</span> <span>read</span><span>(</span>
    absolute_path<span>:</span> <span>str</span>  <span># Absolute path of the file to read</span>
<span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>  <span># Text contents of the read file</span>
    <span>&#34;&#34;&#34;Returns the text contents of the file at the given absolute path&#34;&#34;&#34;</span>
    <span>if</span> <span>not</span> is_valid_absolute_path<span>(</span>absolute_path<span>)</span><span>:</span>
        <span>raise</span> ValueError<span>(</span><span>&#34;The path is not absolute, or the agent is not authorized to read it&#34;</span><span>)</span>
    <span>with</span> <span>open</span><span>(</span>absolute_path<span>,</span> <span>&#39;r&#39;</span><span>)</span> <span>as</span> f<span>:</span>
        <span>return</span> f<span>.</span>read<span>(</span><span>)</span>
</code></pre>
<p>We started with a helper for making sure the agent knows which file it is
requesting, by checking it knows its absolute path and that it lies within a
skill folder. Remember that the agent is made aware of the skill folder’s
absolute path by the <code>location</code> property.</p>
<p>Next we have the actual <code>read</code> tool. If the helper validates the path, we
simply read the file at that location and return the contents. In the future we
could extend this tool with features like automatically encoding images, but it
works for now.</p>
<h2>The <code>run</code> tool</h2>
<p>Packaging executable code into the skill is very handy for token conservation.
You could put enough information in the instructions to help the model come up
with a one-off script by themselves, but that’s going to take a lot of tokens.
You could provide the pre-written script and that would save half of the tokens
by making the information directly accessible. But if you make it runnable, the
agent doesn’t need to spend any tokens on the implementation details at all.</p>
<p>The flip-side is that this is an awkward way to distribute software. It does
put the scripts in the context of a particular skill, but it’s missing key
features, like a way to express dependencies. I think it might be better to
install the scripts to your agent’s runtime environment through more
conventional means, and just refer to them in the skills as something that is
available in the system.</p>
<p>Time will tell, but in the meantime, let’s give it a try:</p>
<pre><code><span>import</span> subprocess
<span>import</span> sys

<span>@dataclass</span>
<span>class</span> <span>RunResult</span><span>:</span>
    stdout<span>:</span> <span>str</span>
    stderr<span>:</span> <span>str</span>
    return_code<span>:</span> <span>int</span>

<span>def</span> <span>run</span><span>(</span>
    absolute_path<span>:</span> <span>str</span><span>,</span>  <span># The path to a python script</span>
    arguments<span>:</span> List<span>[</span><span>str</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>,</span>  <span># A list of arguments for the script</span>
<span>)</span> <span>-</span><span>&gt;</span> RunResult<span>:</span>
    <span>&#34;&#34;&#34;Runs the python script at the given absolute path&#34;&#34;&#34;</span>
    <span>if</span> <span>not</span> is_valid_absolute_path<span>(</span>absolute_path<span>)</span><span>:</span>
        <span>raise</span> ValueError<span>(</span><span>&#34;The path is not absolute, or the agent is not authorized to read it&#34;</span><span>)</span>
    
    path <span>=</span> Path<span>(</span>absolute_path<span>)</span>
    <span>if</span> path<span>.</span>is_dir<span>(</span><span>)</span><span>:</span>
        <span>raise</span> ValueError<span>(</span><span>&#34;The path does not point to a script&#34;</span><span>)</span>
    
    result <span>=</span> subprocess<span>.</span>run<span>(</span>
        <span>[</span>sys<span>.</span>executable<span>,</span> <span>str</span><span>(</span>path<span>)</span><span>,</span> <span>*</span>arguments<span>]</span><span>,</span>
        capture_output<span>=</span><span>True</span><span>,</span>
        text<span>=</span><span>True</span><span>,</span>
        env<span>=</span><span>{</span><span>**</span>os<span>.</span>environ<span>,</span> <span>&#39;PYTHONPATH&#39;</span><span>:</span> <span>str</span><span>(</span>path<span>.</span>parent<span>)</span><span>}</span>
    <span>)</span>
    <span>return</span> RunResult<span>(</span>stdout<span>=</span>result<span>.</span>stdout<span>,</span> stderr<span>=</span>result<span>.</span>stderr<span>,</span> return_code<span>=</span>result<span>.</span>returncode<span>)</span>
</code></pre>
<p>We are creating a simple dataclass to hold the result of the subprocess call.
<code>claudette</code> will use it to explain to the agent what to expect.</p>
<p>The tool itself reuses the above helper to ensure the file is ok to run, and
then tries to run it as a python script.</p>
<p>In a production context this should probably look totally different, support
more than python scripts, and take isolation more seriously, but for
demonstration purposes:</p>
<ul>
<li>We use <code>sys.executable</code> to find the python executable that is running the
current module.</li>
<li>We capture output and return it as encoded text instead of raw bytes.</li>
<li>We manually ensure that the skill’s script directory is in the <code>PYTHONPATH</code>,
so that scripts can import their siblings. This is probably overkill for a
normal Python installation, but is there such a thing as a normal Python
installation?</li>
</ul>
<h2>Skills demo with <code>claudette</code></h2>
<p>Let’s put all of this together and build a tiny skill-capable agent with
<code>claudette</code>. We will need some actual skills to test, so check out <a href="https://github.com/anthropics/skills">Anthropic’s
public skill repository</a> and set your
<code>SKILLS_PATH</code> accordingly.</p>
<p>The agent is very simple to build:</p>
<pre><code><span>from</span> IPython <span>import</span> display
<span>from</span> claudette <span>import</span> <span>*</span>

chat <span>=</span> Chat<span>(</span><span>&#39;claude-haiku-4-5&#39;</span><span>,</span> tools<span>=</span><span>[</span>skill<span>,</span> read<span>,</span> run<span>]</span><span>)</span>

prompt <span>=</span> <span>&#34;How should I approach announcing in the company newsletter that we are launching a product?&#34;</span>
<span>for</span> o <span>in</span> chat<span>.</span>toolloop<span>(</span>prompt<span>)</span><span>:</span>
    <span>if</span> o<span>.</span>role <span>!=</span> <span>&#39;user&#39;</span><span>:</span>
        display<span>(</span>o<span>)</span>
    
    <span>if</span> <span>hasattr</span><span>(</span>o<span>,</span> <span>&#39;stop_reason&#39;</span><span>)</span> <span>and</span> o<span>.</span>stop_reason <span>==</span> <span>&#39;tool_use&#39;</span><span>:</span>
        <span>for</span> b <span>in</span> o<span>.</span>content<span>:</span>
            <span>if</span> b<span>.</span><span>type</span> <span>==</span> <span>&#39;tool_use&#39;</span><span>:</span>
                display<span>(</span><span><span>f&#34;Used </span><span><span>{</span>b<span>.</span>name<span>}</span></span><span> with args </span><span><span>{</span>b<span>.</span><span>input</span><span>}</span></span><span>&#34;</span></span><span>)</span>
</code></pre>
<p>If you are not familiar with <code>claudette</code>: <code>toolloop</code> takes care of the
necessary back and forth to have the model request the use of a tool, executing
it, and passing the result back to model.</p>
<p>We skip <code>user</code> role messages because those contain the verbose markdown
contents as tool results, and we highlight tool uses so we can see tools
in action.</p>
<p>The output looks like:</p>
<pre><code>I can help you craft an effective product launch announcement for your company
newsletter! Let me pull up the internal communications resources to guide you
through this.

&#34;Used skill with args {&#39;name&#39;: &#39;internal-comms&#39;}&#34;

Great! Let me pull up the company newsletter guidelines to show you the best
approach:

&#34;Used read with args {&#39;absolute_path&#39;: &#39;/app/data/skills/skills/internal-comms/examples/company-newsletter.md&#39;}&#34;

Perfect! Here&#39;s how you should approach announcing a product launch in your
company newsletter:

# Key Principles for a Product Launch Announcement

1. Make it a headline item

- Place it in a prominent section like :megaphone: Company Announcements at
  the top

... More stuff ...
</code></pre>
<p>It works! The agent is identifying which skill to use based on the description,
activating it, and reading extra files based on the instructions. And then it
uses all of that context to solve the user’s problem.</p>
<p>Let’s try one with <code>run</code>:</p>
<pre><code><span>from</span> claudette <span>import</span> <span>*</span>

chat <span>=</span> Chat<span>(</span><span>&#39;claude-sonnet-4-5&#39;</span><span>,</span> tools<span>=</span><span>[</span>skill<span>,</span> read<span>,</span> run<span>]</span><span>)</span>

prompt <span>=</span> <span>&#34;Can you check if the PDF form at /app/data/example.pdf has fillable fields?&#34;</span>
<span>for</span> o <span>in</span> chat<span>.</span>toolloop<span>(</span>prompt<span>)</span><span>:</span>
    <span>if</span> o<span>.</span>role <span>!=</span> <span>&#39;user&#39;</span><span>:</span>
        display<span>(</span>o<span>)</span>
    
    <span>if</span> <span>hasattr</span><span>(</span>o<span>,</span> <span>&#39;stop_reason&#39;</span><span>)</span> <span>and</span> o<span>.</span>stop_reason <span>==</span> <span>&#39;tool_use&#39;</span><span>:</span>
        <span>for</span> b <span>in</span> o<span>.</span>content<span>:</span>
            <span>if</span> b<span>.</span><span>type</span> <span>==</span> <span>&#39;tool_use&#39;</span><span>:</span>
                display<span>(</span><span><span>f&#34;Used </span><span><span>{</span>b<span>.</span>name<span>}</span></span><span> with args </span><span><span>{</span>b<span>.</span><span>input</span><span>}</span></span><span>&#34;</span></span><span>)</span>
</code></pre>
<p>Which outputs something like:</p>
<pre><code>I&#39;ll help you check if the PDF form has fillable fields. Let me use the PDF
skill to examine the document.

&#34;Used skill with args {&#39;name&#39;: &#39;pdf&#39;}&#34;

Now let me check the forms.md file to see how to detect fillable fields in
a PDF:

&#34;Used read with args {&#39;absolute_path&#39;: &#39;/app/data/skills/skills/pdf/forms.md&#39;}&#34;

Perfect! Now I can check if the PDF has fillable fields using the
provided script:

&#34;Used run with args {&#39;absolute_path&#39;: &#39;/app/data/skills/skills/pdf/scripts/check_fillable_fields.py&#39;, &#39;arguments&#39;: [&#39;/app/data/example.pdf&#39;]}&#34;

Great news! Yes, the PDF form at /app/data/example.pdf has fillable fields.
</code></pre>
<p>Notice that the agent was able to run the script without having to read
it first.</p>
<h2>Conclusion</h2>
<p>That’s it — around 100 lines of Python and three straightforward tools. The
skill system’s elegance is in what it doesn’t need: no special context window
manipulation, no complex orchestration. The skill tool’s docstring carries the
skill index, and everything else is just reading files and running scripts on
demand.</p>
<p>If you’re building agents, consider adding skill support. It’s a lightweight
way to organize prompts, and you might find it replaces some of the subagent
orchestration you thought you needed.</p></div></div>
  </body>
</html>
