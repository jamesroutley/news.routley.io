<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/lynnpepin/reso">Original</a>
    <h1>Show HN: I made a little digital circuit simulator that operates on PNGs</h1>
    
    <div id="readability-page-1" class="page"><div>


<main role="main">
  
<article itemscope="" itemtype="http://schema.org/BlogPosting">
  
  
  <section itemprop="articleBody">
    
<p>So for the past few days, I’ve been trying to build a <em>distributed highly scalable, no collision guaranteed URL shortening service</em>.</p>
<h2 id="the-architecture">The Architecture</h2>
<p>So if you pass in a long url called <code>https://longurl.com</code>, the backend will send you a short url that would be unique to each request, and the structure of the url would look something like: <code>https://shorturl.com/[slug]</code>.</p>
<p>The slug is our main component, it should always be unique.</p>
<p>Some things to note:</p>
<ul>
<li>
<p>The length of the slug depends on how many entries will there be.</p>
</li>
<li>
<p>So for 5 digit alphanumeric (also called Base-62) slug:</p>
<p>Possible combinations: 26 (small alphabets) + 26 (capital alphabets) + 10 (numbers) =&gt; 62.</p>
<p>So, for 5 digit base62 -&gt; 62^5 ~about 900 million possibilities.</p>
</li>
</ul>
<h2 id="what-choices-do-we-have-to-ensure-uniqueness-of-the-slug">What choices do we have to ensure uniqueness of the slug?</h2>
<ul>
<li>
<p>Random slug</p>
<p>-&gt; This can be any random alphanumeric characters.</p>
<p>-&gt; The problem here is that for a request, there can be two same random characters, which will eventually result in collisions.</p>
</li>
<li>
<p>Using MD5</p>
<p>-&gt; Collisions are possible here as well (although very rare, but we want no collision guarantee).</p>
</li>
<li>
<p>Time Stamp</p>
<p>-&gt; You can store time stamp of every request and encode it with base62, but this still can result in collisions.</p>
<p>-&gt; Just to give an example, if you generate 10 ids a second with a granularity of milliseconds, the probability of a collision is 1 in 23. On average, you’ll have a collision every 23 seconds. But it’s worse than that. The assumption in this math is that every possible birthday is equally likely. That’s not true for birthdays, more people on born in the spring. It’s also not going to be true for your timestamps. You are going to get much heavier on certain times of the day than others <sup><a href="https://softwareengineering.stackexchange.com/questions/305904/how-likely-are-collisions-of-timestamp-based-identifiers">1</a></sup>.</p>
</li>
<li>
<p>UUIDs</p>
<p>-&gt; UUID is part of the Distributed Computing Environment (DCE), standardized by the Open Software Foundation (OSF).</p>
<p>-&gt; How UUID is made:
<img src="https://i.stack.imgur.com/goiPw.png" alt="UUID architecture"/></p>
<p>-&gt; Also check out this amazing blog about collisions in UUIDs <a href="https://www.scaleyourapp.com/uuid-guid-oversimplified-are-they-really-unique/">here</a>.</p>
</li>
<li>
<p>Using a <u><strong>Counter</strong></u></p>
<p>-&gt; Counters are the only thing that can <strong>guarantee</strong> no collisions. This is true if we only use a single database, which is bad for scaling. For multiple distributed database, we again have a problem!</p>
</li>
</ul>

<p>For a no collision guarantee URL shortening system (single database), our unique id i.e our slug will be a counter.</p>
<p>For example:</p>
<ul>
<li>our first slug will be: 10000 =&gt; (2bI)<sub>base62</sub></li>
<li>second: 10001</li>
<li>third: 10002 and so on.</li>
</ul>
<p>Now the problem is when we want to horizontally scale and talk with multiple databases.</p>
<p>The different approaches with multi database counter will look like:</p>
<ul>
<li>
<p>One counter for all databases</p>
<p>-&gt; This will ensure atomicity, but will slow down response time</p>
</li>
<li>
<p>Different counter for different databases</p>
<p>-&gt; This approach will be faster, but the problem is how will we ensure that there are no collisions between two different counters?</p>
</li>
</ul>
<h2 id="problem-with-counter-synchronization">Problem with counter synchronization</h2>
<p>The problem with counter synchronization is that there can be two counters with same value.</p>
<p>Here comes our <a href="https://zookeeper.apache.org/">Apache zookeeper</a>.</p>
<p>What zookeeper would do is assign different counter ranges to different databases or servers.</p>
<p>For example:</p>
<ul>
<li>DB<sub>1</sub> is assigned counter range from 10000 to 20000</li>
<li>DB<sub>2</sub> is assigned counter range from 20001 to 30000</li>
<li>DB<sub>3</sub> is assigned counter range from 30001 to 40000</li>
<li>DB<sub>4</sub> is assigned counter range from 40001 to 50000 and so on.</li>
</ul>
<p>And zookeeper will also keep track of the counter usage so that it if a database exceeds the range, it is assigned a new range.</p>
<p>In conclusion, for our distributed no collision guaranteed url shortening service, we can use counters to guarantee no collisions and use apache zookeeper to synchronize the counters across databases.</p>
<p>P.S this article is still in development…</p>

  </section>
</article>

</main>

</div></div>
  </body>
</html>
