<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://peps.python.org/pep-0505/">Original</a>
    <h1>PEP 505 – None-aware operators (2015)</h1>
    
    <div id="readability-page-1" class="page"><section id="pep-content">

<dl>
<dt>Author<span>:</span></dt>
<dd>Mark E. Haase &lt;mehaase at gmail.com&gt;, Steve Dower &lt;steve.dower at python.org&gt;</dd>
<dt>Status<span>:</span></dt>
<dd>Deferred</dd>
<dt>Type<span>:</span></dt>
<dd>Standards Track</dd>
<dt>Created<span>:</span></dt>
<dd>18-Sep-2015</dd>
<dt>Python-Version<span>:</span></dt>
<dd>3.8</dd>
</dl>
<hr/>
<section id="contents">
<details><summary>Table of Contents</summary><ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#syntax-and-semantics">Syntax and Semantics</a><ul>
<li><a href="#specialness-of-none">Specialness of <code><span>None</span></code></a></li>
<li><a href="#grammar-changes">Grammar changes</a><ul>
<li><a href="#the-coalesce-rule">The coalesce rule</a></li>
<li><a href="#the-maybe-dot-and-maybe-subscript-operators">The maybe-dot and maybe-subscript operators</a></li>
</ul>
</li>
<li><a href="#reading-expressions">Reading expressions</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#standard-library">Standard Library</a></li>
<li><a href="#jsonify">jsonify</a></li>
<li><a href="#grab">Grab</a></li>
</ul>
</li>
<li><a href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a href="#no-value-protocol">No-Value Protocol</a></li>
<li><a href="#boolean-aware-operators">Boolean-aware operators</a></li>
<li><a href="#exception-aware-operators">Exception-aware operators</a></li>
<li><a href="#none-aware-function-call"><code><span>None</span></code>-aware Function Call</a></li>
<li><a href="#unary-postfix-operator"><code><span>?</span></code> Unary Postfix Operator</a></li>
<li><a href="#built-in-maybe">Built-in <code><span>maybe</span></code></a></li>
<li><a href="#just-use-a-conditional-expression">Just use a conditional expression</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>Several modern programming languages have so-called “<code><span>null</span></code>-coalescing” or
“<code><span>null</span></code>- aware” operators, including C# <a href="#id6" id="id1">[1]</a>, Dart <a href="#id7" id="id2">[2]</a>, Perl, Swift, and PHP
(starting in version 7). There are also stage 3 draft proposals for their
addition to ECMAScript (a.k.a. JavaScript) <a href="#id8" id="id3">[3]</a> <a href="#id9" id="id4">[4]</a>. These operators provide
syntactic sugar for common patterns involving null references.</p>
<ul>
<li>The “<code><span>null</span></code>-coalescing” operator is a binary operator that returns its left
operand if it is not <code><span>null</span></code>. Otherwise it returns its right operand.</li>
<li>The “<code><span>null</span></code>-aware member access” operator accesses an instance member only
if that instance is non-<code><span>null</span></code>. Otherwise it returns <code><span>null</span></code>. (This is also
called a “safe navigation” operator.)</li>
<li>The “<code><span>null</span></code>-aware index access” operator accesses an element of a collection
only if that collection is non-<code><span>null</span></code>. Otherwise it returns <code><span>null</span></code>. (This
is another type of “safe navigation” operator.)</li>
</ul>
<p>This PEP proposes three <code><span>None</span></code>-aware operators for Python, based on the
definitions and other language’s implementations of those above. Specifically:</p>
<ul>
<li>The “<code><span>None</span></code> coalescing” binary operator <code><span>??</span></code> returns the left hand side
if it evaluates to a value that is not <code><span>None</span></code>, or else it evaluates and
returns the right hand side. A coalescing <code><span>??=</span></code> augmented assignment
operator is included.</li>
<li>The “<code><span>None</span></code>-aware attribute access” operator <code><span>?.</span></code> (“maybe dot”) evaluates
the complete expression if the left hand side evaluates to a value that is
not <code><span>None</span></code></li>
<li>The “<code><span>None</span></code>-aware indexing” operator <code><span>?[]</span></code> (“maybe subscript”) evaluates
the complete expression if the left hand site evaluates to a value that is
not <code><span>None</span></code></li>
</ul>
<p>See the <a href="#grammar-changes">Grammar changes</a> section for specifics and examples of the required
grammar changes.</p>
<p>See the <a href="#examples">Examples</a> section for more realistic examples of code that could be
updated to use the new operators.</p>
</section>
<section id="syntax-and-semantics">
<h2><a href="#syntax-and-semantics" role="doc-backlink">Syntax and Semantics</a></h2>
<section id="specialness-of-none">
<h3><a href="#specialness-of-none" role="doc-backlink">Specialness of <code><span>None</span></code></a></h3>
<p>The <code><span>None</span></code> object denotes the lack of a value. For the purposes of these
operators, the lack of a value indicates that the remainder of the expression
also lacks a value and should not be evaluated.</p>
<p>A rejected proposal was to treat any value that evaluates as “false” in a
Boolean context as not having a value. However, the purpose of these operators
is to propagate the “lack of value” state, rather than the “false” state.</p>
<p>Some argue that this makes <code><span>None</span></code> special. We contend that <code><span>None</span></code> is
already special, and that using it as both the test and the result of these
operators does not change the existing semantics in any way.</p>
<p>See the <a href="#rejected-ideas">Rejected Ideas</a> section for discussions on alternate approaches.</p>
</section>
<section id="grammar-changes">
<h3><a href="#grammar-changes" role="doc-backlink">Grammar changes</a></h3>
<p>The following rules of the Python grammar are updated to read:</p>
<div><div><pre><span></span><span>augassign</span><span>:</span> <span>(</span><span>&#39;+=&#39;</span> <span>|</span> <span>&#39;-=&#39;</span> <span>|</span> <span>&#39;*=&#39;</span> <span>|</span> <span>&#39;@=&#39;</span> <span>|</span> <span>&#39;/=&#39;</span> <span>|</span> <span>&#39;%=&#39;</span> <span>|</span> <span>&#39;&amp;=&#39;</span> <span>|</span> <span>&#39;|=&#39;</span> <span>|</span> <span>&#39;^=&#39;</span> <span>|</span>
            <span>&#39;&lt;&lt;=&#39;</span> <span>|</span> <span>&#39;&gt;&gt;=&#39;</span> <span>|</span> <span>&#39;**=&#39;</span> <span>|</span> <span>&#39;//=&#39;</span> <span>|</span> <span>&#39;??=&#39;</span><span>)</span>

<span>power</span><span>:</span> <span>coalesce</span> <span>[</span><span>&#39;**&#39;</span> <span>factor</span><span>]</span>
<span>coalesce</span><span>:</span> <span>atom_expr</span> <span>[</span><span>&#39;??&#39;</span> <span>factor</span><span>]</span>
<span>atom_expr</span><span>:</span> <span>[</span><span>&#39;await&#39;</span><span>]</span> <span>atom</span> <span>trailer</span><span>*</span>
<span>trailer</span><span>:</span> <span>(</span><span>&#39;(&#39;</span> <span>[</span><span>arglist</span><span>]</span> <span>&#39;)&#39;</span> <span>|</span>
          <span>&#39;[&#39;</span> <span>subscriptlist</span> <span>&#39;]&#39;</span> <span>|</span>
          <span>&#39;?[&#39;</span> <span>subscriptlist</span> <span>&#39;]&#39;</span> <span>|</span>
          <span>&#39;.&#39;</span> <span>NAME</span> <span>|</span>
          <span>&#39;?.&#39;</span> <span>NAME</span><span>)</span>
</pre></div>
</div>
<section id="the-coalesce-rule">
<h4><a href="#the-coalesce-rule" role="doc-backlink">The coalesce rule</a></h4>
<p>The <code><span>coalesce</span></code> rule provides the <code><span>??</span></code> binary operator. Unlike most binary
operators, the right-hand side is not evaluated until the left-hand side is
determined to be <code><span>None</span></code>.</p>
<p>The <code><span>??</span></code> operator binds more tightly than other binary operators as most
existing implementations of these do not propagate <code><span>None</span></code> values (they will
typically raise <code><span>TypeError</span></code>). Expressions that are known to potentially
result in <code><span>None</span></code> can be substituted for a default value without needing
additional parentheses.</p>
<p>Some examples of how implicit parentheses are placed when evaluating operator
precedence in the presence of the <code><span>??</span></code> operator:</p>
<div><div><pre><span></span>a, b = None, None
def c(): return None
def ex(): raise Exception()

(a ?? 2 ** b ?? 3) == a ?? (2 ** (b ?? 3))
(a * b ?? c // d) == a * (b ?? c) // d
(a ?? True and b ?? False) == (a ?? True) and (b ?? False)
(c() ?? c() ?? True) == True
(True ?? ex()) == True
(c ?? ex)() == c()
</pre></div>
</div>
<p>Particularly for cases such as <code><span>a</span> <span>??</span> <span>2</span> <span>**</span> <span>b</span> <span>??</span> <span>3</span></code>, parenthesizing the
sub-expressions any other way would result in <code><span>TypeError</span></code>, as <code><span>int.__pow__</span></code>
cannot be called with <code><span>None</span></code> (and the fact that the <code><span>??</span></code> operator is used
at all implies that <code><span>a</span></code> or <code><span>b</span></code> may be <code><span>None</span></code>). However, as usual,
while parentheses are not required they should be added if it helps improve
readability.</p>
<p>An augmented assignment for the <code><span>??</span></code> operator is also added. Augmented
coalescing assignment only rebinds the name if its current value is <code><span>None</span></code>.
If the target name already has a value, the right-hand side is not evaluated.
For example:</p>
<div><div><pre><span></span>a = None
b = &#39;&#39;
c = 0

a ??= &#39;value&#39;
b ??= undefined_name
c ??= shutil.rmtree(&#39;/&#39;)    # don&#39;t try this at home, kids

assert a == &#39;value&#39;
assert b == &#39;&#39;
assert c == 0 and any(os.scandir(&#39;/&#39;))
</pre></div>
</div>
</section>
<section id="the-maybe-dot-and-maybe-subscript-operators">
<h4><a href="#the-maybe-dot-and-maybe-subscript-operators" role="doc-backlink">The maybe-dot and maybe-subscript operators</a></h4>
<p>The maybe-dot and maybe-subscript operators are added as trailers for atoms,
so that they may be used in all the same locations as the regular operators,
including as part of an assignment target (more details below). As the
existing evaluation rules are not directly embedded in the grammar, we specify
the required changes below.</p>
<p>Assume that the <code><span>atom</span></code> is always successfully evaluated. Each <code><span>trailer</span></code> is
then evaluated from left to right, applying its own parameter (either its
arguments, subscripts or attribute name) to produce the value for the next
<code><span>trailer</span></code>. Finally, if present, <code><span>await</span></code> is applied.</p>
<p>For example, <code><span>await</span> <span>a.b(c).d[e]</span></code> is currently parsed as
<code><span>[&#39;await&#39;,</span> <span>&#39;a&#39;,</span> <span>&#39;.b&#39;,</span> <span>&#39;(c)&#39;,</span> <span>&#39;.d&#39;,</span> <span>&#39;[e]&#39;]</span></code> and evaluated:</p>
<div><div><pre><span></span><span>_v</span> <span>=</span> <span>a</span>
<span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>b</span>
<span>_v</span> <span>=</span> <span>_v</span><span>(</span><span>c</span><span>)</span>
<span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>d</span>
<span>_v</span> <span>=</span> <span>_v</span><span>[</span><span>e</span><span>]</span>
<span>await</span> <span>_v</span>
</pre></div>
</div>
<p>When a <code><span>None</span></code>-aware operator is present, the left-to-right evaluation may be
short-circuited. For example, <code><span>await</span> <span>a?.b(c).d?[e]</span></code> is evaluated:</p>
<div><div><pre><span></span><span>_v</span> <span>=</span> <span>a</span>
<span>if</span> <span>_v</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>b</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>(</span><span>c</span><span>)</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>d</span>
    <span>if</span> <span>_v</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>_v</span> <span>=</span> <span>_v</span><span>[</span><span>e</span><span>]</span>
<span>await</span> <span>_v</span>
</pre></div>
</div>
<div>
<p>Note</p>
<p><code><span>await</span></code> will almost certainly fail in this context, as it would in
the case where code attempts <code><span>await</span> <span>None</span></code>. We are not proposing to add a
<code><span>None</span></code>-aware <code><span>await</span></code> keyword here, and merely include it in this
example for completeness of the specification, since the <code><span>atom_expr</span></code>
grammar rule includes the keyword. If it were in its own rule, we would have
never mentioned it.</p>
</div>
<p>Parenthesised expressions are handled by the <code><span>atom</span></code> rule (not shown above),
which will implicitly terminate the short-circuiting behaviour of the above
transformation. For example, <code><span>(a?.b</span> <span>??</span> <span>c).d?.e</span></code> is evaluated as:</p>
<div><div><pre><span></span><span># a?.b</span>
<span>_v</span> <span>=</span> <span>a</span>
<span>if</span> <span>_v</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>b</span>

<span># ... ?? c</span>
<span>if</span> <span>_v</span> <span>is</span> <span>None</span><span>:</span>
    <span>_v</span> <span>=</span> <span>c</span>

<span># (...).d?.e</span>
<span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>d</span>
<span>if</span> <span>_v</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>e</span>
</pre></div>
</div>
<p>When used as an assignment target, the <code><span>None</span></code>-aware operations may only be
used in a “load” context. That is, <code><span>a?.b</span> <span>=</span> <span>1</span></code> and <code><span>a?[b]</span> <span>=</span> <span>1</span></code> will raise
<code><span>SyntaxError</span></code>. Use earlier in the expression (<code><span>a?.b.c</span> <span>=</span> <span>1</span></code>) is permitted,
though unlikely to be useful unless combined with a coalescing operation:</p>

</section>
</section>
<section id="reading-expressions">
<h3><a href="#reading-expressions" role="doc-backlink">Reading expressions</a></h3>
<p>For the maybe-dot and maybe-subscript operators, the intention is that
expressions including these operators should be read and interpreted as for the
regular versions of these operators. In “normal” cases, the end results are
going to be identical between an expression such as <code><span>a?.b?[c]</span></code> and
<code><span>a.b[c]</span></code>, and just as we do not currently read “a.b” as “read attribute b
from a <em>if it has an attribute a or else it raises AttributeError</em>”, there is
no need to read “a?.b” as “read attribute b from a <em>if a is not None</em>”
(unless in a context where the listener needs to be aware of the specific
behaviour).</p>
<p>For coalescing expressions using the <code><span>??</span></code> operator, expressions should either
be read as “or … if None” or “coalesced with”. For example, the expression
<code><span>a.get_value()</span> <span>??</span> <span>100</span></code> would be read “call a dot get_value or 100 if None”,
or “call a dot get_value coalesced with 100”.</p>
<div>
<p>Note</p>
<p>Reading code in spoken text is always lossy, and so we make no attempt to
define an unambiguous way of speaking these operators. These suggestions
are intended to add context to the implications of adding the new syntax.</p>
</div>
</section>
</section>
<section id="examples">
<h2><a href="#examples" role="doc-backlink">Examples</a></h2>
<p>This section presents some examples of common <code><span>None</span></code> patterns and shows what
conversion to use <code><span>None</span></code>-aware operators may look like.</p>
<section id="standard-library">
<h3><a href="#standard-library" role="doc-backlink">Standard Library</a></h3>
<p>Using the <code><span>find-pep505.py</span></code> script[5]_ an analysis of the Python 3.7 standard
library discovered up to 678 code snippets that could be replaced with use of
one of the <code><span>None</span></code>-aware operators:</p>
<div><div><pre><span></span>$ find /usr/lib/python3.7 -name &#39;*.py&#39; | xargs python3.7 find-pep505.py
&lt;snip&gt;
Total None-coalescing `if` blocks: 449
Total [possible] None-coalescing `or`: 120
Total None-coalescing ternaries: 27
Total Safe navigation `and`: 13
Total Safe navigation `if` blocks: 61
Total Safe navigation ternaries: 8
</pre></div>
</div>
<p>Some of these are shown below as examples before and after converting to use the
new operators.</p>
<p>From <code><span>bisect.py</span></code>:</p>
<div><div><pre><span></span><span>def</span> <span>insort_right</span><span>(</span><span>a</span><span>,</span> <span>x</span><span>,</span> <span>lo</span><span>=</span><span>0</span><span>,</span> <span>hi</span><span>=</span><span>None</span><span>):</span>
    <span># ...</span>
    <span>if</span> <span>hi</span> <span>is</span> <span>None</span><span>:</span>
        <span>hi</span> <span>=</span> <span>len</span><span>(</span><span>a</span><span>)</span>
    <span># ...</span>
</pre></div>
</div>
<p>After updating to use the <code><span>??=</span></code> augmented assignment statement:</p>
<div><div><pre><span></span>def insort_right(a, x, lo=0, hi=None):
    # ...
    hi ??= len(a)
    # ...
</pre></div>
</div>
<p>From <code><span>calendar.py</span></code>:</p>
<div><div><pre><span></span><span>encoding</span> <span>=</span> <span>options</span><span>.</span><span>encoding</span>
<span>if</span> <span>encoding</span> <span>is</span> <span>None</span><span>:</span>
    <span>encoding</span> <span>=</span> <span>sys</span><span>.</span><span>getdefaultencoding</span><span>()</span>
<span>optdict</span> <span>=</span> <span>dict</span><span>(</span><span>encoding</span><span>=</span><span>encoding</span><span>,</span> <span>css</span><span>=</span><span>options</span><span>.</span><span>css</span><span>)</span>
</pre></div>
</div>
<p>After updating to use the <code><span>??</span></code> operator:</p>
<div><div><pre><span></span>optdict = dict(encoding=options.encoding ?? sys.getdefaultencoding(),
               css=options.css)
</pre></div>
</div>
<p>From <code><span>email/generator.py</span></code> (and importantly note that there is no way to
substitute <code><span>or</span></code> for <code><span>??</span></code> in this situation):</p>
<div><div><pre><span></span><span>mangle_from_</span> <span>=</span> <span>True</span> <span>if</span> <span>policy</span> <span>is</span> <span>None</span> <span>else</span> <span>policy</span><span>.</span><span>mangle_from_</span>
</pre></div>
</div>
<p>After updating:</p>
<div><div><pre><span></span>mangle_from_ = policy?.mangle_from_ ?? True
</pre></div>
</div>
<p>From <code><span>asyncio/subprocess.py</span></code>:</p>
<div><div><pre><span></span><span>def</span> <span>pipe_data_received</span><span>(</span><span>self</span><span>,</span> <span>fd</span><span>,</span> <span>data</span><span>):</span>
    <span>if</span> <span>fd</span> <span>==</span> <span>1</span><span>:</span>
        <span>reader</span> <span>=</span> <span>self</span><span>.</span><span>stdout</span>
    <span>elif</span> <span>fd</span> <span>==</span> <span>2</span><span>:</span>
        <span>reader</span> <span>=</span> <span>self</span><span>.</span><span>stderr</span>
    <span>else</span><span>:</span>
        <span>reader</span> <span>=</span> <span>None</span>
    <span>if</span> <span>reader</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>reader</span><span>.</span><span>feed_data</span><span>(</span><span>data</span><span>)</span>
</pre></div>
</div>
<p>After updating to use the <code><span>?.</span></code> operator:</p>
<div><div><pre><span></span>def pipe_data_received(self, fd, data):
    if fd == 1:
        reader = self.stdout
    elif fd == 2:
        reader = self.stderr
    else:
        reader = None
    reader?.feed_data(data)
</pre></div>
</div>
<p>From <code><span>asyncio/tasks.py</span></code>:</p>
<div><div><pre><span></span><span>try</span><span>:</span>
    <span>await</span> <span>waiter</span>
<span>finally</span><span>:</span>
    <span>if</span> <span>timeout_handle</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>timeout_handle</span><span>.</span><span>cancel</span><span>()</span>
</pre></div>
</div>
<p>After updating to use the <code><span>?.</span></code> operator:</p>
<div><div><pre><span></span>try:
    await waiter
finally:
    timeout_handle?.cancel()
</pre></div>
</div>
<p>From <code><span>ctypes/_aix.py</span></code>:</p>
<div><div><pre><span></span><span>if</span> <span>libpaths</span> <span>is</span> <span>None</span><span>:</span>
    <span>libpaths</span> <span>=</span> <span>[]</span>
<span>else</span><span>:</span>
    <span>libpaths</span> <span>=</span> <span>libpaths</span><span>.</span><span>split</span><span>(</span><span>&#34;:&#34;</span><span>)</span>
</pre></div>
</div>
<p>After updating:</p>
<div><div><pre><span></span>libpaths = libpaths?.split(&#34;:&#34;) ?? []
</pre></div>
</div>
<p>From <code><span>os.py</span></code>:</p>
<div><div><pre><span></span><span>if</span> <span>entry</span><span>.</span><span>is_dir</span><span>():</span>
    <span>dirs</span><span>.</span><span>append</span><span>(</span><span>name</span><span>)</span>
    <span>if</span> <span>entries</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>entries</span><span>.</span><span>append</span><span>(</span><span>entry</span><span>)</span>
<span>else</span><span>:</span>
    <span>nondirs</span><span>.</span><span>append</span><span>(</span><span>name</span><span>)</span>
</pre></div>
</div>
<p>After updating to use the <code><span>?.</span></code> operator:</p>
<div><div><pre><span></span>if entry.is_dir():
    dirs.append(name)
    entries?.append(entry)
else:
    nondirs.append(name)
</pre></div>
</div>
<p>From <code><span>importlib/abc.py</span></code>:</p>
<div><div><pre><span></span><span>def</span> <span>find_module</span><span>(</span><span>self</span><span>,</span> <span>fullname</span><span>,</span> <span>path</span><span>):</span>
    <span>if</span> <span>not</span> <span>hasattr</span><span>(</span><span>self</span><span>,</span> <span>&#39;find_spec&#39;</span><span>):</span>
        <span>return</span> <span>None</span>
    <span>found</span> <span>=</span> <span>self</span><span>.</span><span>find_spec</span><span>(</span><span>fullname</span><span>,</span> <span>path</span><span>)</span>
    <span>return</span> <span>found</span><span>.</span><span>loader</span> <span>if</span> <span>found</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>None</span>
</pre></div>
</div>
<p>After partially updating:</p>
<div><div><pre><span></span>def find_module(self, fullname, path):
    if not hasattr(self, &#39;find_spec&#39;):
        return None
    return self.find_spec(fullname, path)?.loader
</pre></div>
</div>
<p>After extensive updating (arguably excessive, though that’s for the style
guides to determine):</p>
<div><div><pre><span></span>def find_module(self, fullname, path):
    return getattr(self, &#39;find_spec&#39;, None)?.__call__(fullname, path)?.loader
</pre></div>
</div>
<p>From <code><span>dis.py</span></code>:</p>
<div><div><pre><span></span><span>def</span> <span>_get_const_info</span><span>(</span><span>const_index</span><span>,</span> <span>const_list</span><span>):</span>
    <span>argval</span> <span>=</span> <span>const_index</span>
    <span>if</span> <span>const_list</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>argval</span> <span>=</span> <span>const_list</span><span>[</span><span>const_index</span><span>]</span>
    <span>return</span> <span>argval</span><span>,</span> <span>repr</span><span>(</span><span>argval</span><span>)</span>
</pre></div>
</div>
<p>After updating to use the <code><span>?[]</span></code> and <code><span>??</span></code> operators:</p>
<div><div><pre><span></span>def _get_const_info(const_index, const_list):
    argval = const_list?[const_index] ?? const_index
    return argval, repr(argval)
</pre></div>
</div>
</section>
<section id="jsonify">
<h3><a href="#jsonify" role="doc-backlink">jsonify</a></h3>
<p>This example is from a Python web crawler that uses the Flask framework as its
front-end. This function retrieves information about a web site from a SQL
database and formats it as JSON to send to an HTTP client:</p>
<div><div><pre><span></span><span>class</span> <span>SiteView</span><span>(</span><span>FlaskView</span><span>):</span>
    <span>@route</span><span>(</span><span>&#39;/site/&lt;id_&gt;&#39;</span><span>,</span> <span>methods</span><span>=</span><span>[</span><span>&#39;GET&#39;</span><span>])</span>
    <span>def</span> <span>get_site</span><span>(</span><span>self</span><span>,</span> <span>id_</span><span>):</span>
        <span>site</span> <span>=</span> <span>db</span><span>.</span><span>query</span><span>(</span><span>&#39;site_table&#39;</span><span>)</span><span>.</span><span>find</span><span>(</span><span>id_</span><span>)</span>

        <span>return</span> <span>jsonify</span><span>(</span>
            <span>first_seen</span><span>=</span><span>site</span><span>.</span><span>first_seen</span><span>.</span><span>isoformat</span><span>()</span> <span>if</span> <span>site</span><span>.</span><span>first_seen</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>None</span><span>,</span>
            <span>id</span><span>=</span><span>site</span><span>.</span><span>id</span><span>,</span>
            <span>is_active</span><span>=</span><span>site</span><span>.</span><span>is_active</span><span>,</span>
            <span>last_seen</span><span>=</span><span>site</span><span>.</span><span>last_seen</span><span>.</span><span>isoformat</span><span>()</span> <span>if</span> <span>site</span><span>.</span><span>last_seen</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>None</span><span>,</span>
            <span>url</span><span>=</span><span>site</span><span>.</span><span>url</span><span>.</span><span>rstrip</span><span>(</span><span>&#39;/&#39;</span><span>)</span>
        <span>)</span>
</pre></div>
</div>
<p>Both <code><span>first_seen</span></code> and <code><span>last_seen</span></code> are allowed to be <code><span>null</span></code> in the
database, and they are also allowed to be <code><span>null</span></code> in the JSON response. JSON
does not have a native way to represent a <code><span>datetime</span></code>, so the server’s contract
states that any non-<code><span>null</span></code> date is represented as an ISO-8601 string.</p>
<p>Without knowing the exact semantics of the <code><span>first_seen</span></code> and <code><span>last_seen</span></code>
attributes, it is impossible to know whether the attribute can be safely or
performantly accessed multiple times.</p>
<p>One way to fix this code is to replace each conditional expression with an
explicit value assignment and a full <code><span>if</span></code>/<code><span>else</span></code> block:</p>
<div><div><pre><span></span><span>class</span> <span>SiteView</span><span>(</span><span>FlaskView</span><span>):</span>
    <span>@route</span><span>(</span><span>&#39;/site/&lt;id_&gt;&#39;</span><span>,</span> <span>methods</span><span>=</span><span>[</span><span>&#39;GET&#39;</span><span>])</span>
    <span>def</span> <span>get_site</span><span>(</span><span>self</span><span>,</span> <span>id_</span><span>):</span>
        <span>site</span> <span>=</span> <span>db</span><span>.</span><span>query</span><span>(</span><span>&#39;site_table&#39;</span><span>)</span><span>.</span><span>find</span><span>(</span><span>id_</span><span>)</span>

        <span>first_seen_dt</span> <span>=</span> <span>site</span><span>.</span><span>first_seen</span>
        <span>if</span> <span>first_seen_dt</span> <span>is</span> <span>None</span><span>:</span>
            <span>first_seen</span> <span>=</span> <span>None</span>
        <span>else</span><span>:</span>
            <span>first_seen</span> <span>=</span> <span>first_seen_dt</span><span>.</span><span>isoformat</span><span>()</span>

        <span>last_seen_dt</span> <span>=</span> <span>site</span><span>.</span><span>last_seen</span>
        <span>if</span> <span>last_seen_dt</span> <span>is</span> <span>None</span><span>:</span>
            <span>last_seen</span> <span>=</span> <span>None</span>
        <span>else</span><span>:</span>
            <span>last_seen</span> <span>=</span> <span>last_seen_dt</span><span>.</span><span>isoformat</span><span>()</span>

        <span>return</span> <span>jsonify</span><span>(</span>
            <span>first_seen</span><span>=</span><span>first_seen</span><span>,</span>
            <span>id</span><span>=</span><span>site</span><span>.</span><span>id</span><span>,</span>
            <span>is_active</span><span>=</span><span>site</span><span>.</span><span>is_active</span><span>,</span>
            <span>last_seen</span><span>=</span><span>last_seen</span><span>,</span>
            <span>url</span><span>=</span><span>site</span><span>.</span><span>url</span><span>.</span><span>rstrip</span><span>(</span><span>&#39;/&#39;</span><span>)</span>
        <span>)</span>
</pre></div>
</div>
<p>This adds ten lines of code and four new code paths to the function,
dramatically increasing the apparent complexity. Rewriting using the
<code><span>None</span></code>-aware attribute operator results in shorter code with more clear
intent:</p>
<div><div><pre><span></span>class SiteView(FlaskView):
    @route(&#39;/site/&lt;id_&gt;&#39;, methods=[&#39;GET&#39;])
    def get_site(self, id_):
        site = db.query(&#39;site_table&#39;).find(id_)

        return jsonify(
            first_seen=site.first_seen?.isoformat(),
            id=site.id,
            is_active=site.is_active,
            last_seen=site.last_seen?.isoformat(),
            url=site.url.rstrip(&#39;/&#39;)
        )
</pre></div>
</div>
</section>
<section id="grab">
<h3><a href="#grab" role="doc-backlink">Grab</a></h3>
<p>The next example is from a Python scraping library called <a href="https://github.com/lorien/grab/blob/4c95b18dcb0fa88eeca81f5643c0ebfb114bf728/grab/upload.py">Grab</a>:</p>
<div><div><pre><span></span><span>class</span> <span>BaseUploadObject</span><span>(</span><span>object</span><span>):</span>
    <span>def</span> <span>find_content_type</span><span>(</span><span>self</span><span>,</span> <span>filename</span><span>):</span>
        <span>ctype</span><span>,</span> <span>encoding</span> <span>=</span> <span>mimetypes</span><span>.</span><span>guess_type</span><span>(</span><span>filename</span><span>)</span>
        <span>if</span> <span>ctype</span> <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>&#39;application/octet-stream&#39;</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>ctype</span>

<span>class</span> <span>UploadContent</span><span>(</span><span>BaseUploadObject</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>content</span><span>,</span> <span>filename</span><span>=</span><span>None</span><span>,</span> <span>content_type</span><span>=</span><span>None</span><span>):</span>
        <span>self</span><span>.</span><span>content</span> <span>=</span> <span>content</span>
        <span>if</span> <span>filename</span> <span>is</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>filename</span> <span>=</span> <span>self</span><span>.</span><span>get_random_filename</span><span>()</span>
        <span>else</span><span>:</span>
            <span>self</span><span>.</span><span>filename</span> <span>=</span> <span>filename</span>
        <span>if</span> <span>content_type</span> <span>is</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>content_type</span> <span>=</span> <span>self</span><span>.</span><span>find_content_type</span><span>(</span><span>self</span><span>.</span><span>filename</span><span>)</span>
        <span>else</span><span>:</span>
            <span>self</span><span>.</span><span>content_type</span> <span>=</span> <span>content_type</span>

<span>class</span> <span>UploadFile</span><span>(</span><span>BaseUploadObject</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>path</span><span>,</span> <span>filename</span><span>=</span><span>None</span><span>,</span> <span>content_type</span><span>=</span><span>None</span><span>):</span>
        <span>self</span><span>.</span><span>path</span> <span>=</span> <span>path</span>
        <span>if</span> <span>filename</span> <span>is</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>filename</span> <span>=</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>split</span><span>(</span><span>path</span><span>)[</span><span>1</span><span>]</span>
        <span>else</span><span>:</span>
            <span>self</span><span>.</span><span>filename</span> <span>=</span> <span>filename</span>
        <span>if</span> <span>content_type</span> <span>is</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>content_type</span> <span>=</span> <span>self</span><span>.</span><span>find_content_type</span><span>(</span><span>self</span><span>.</span><span>filename</span><span>)</span>
        <span>else</span><span>:</span>
            <span>self</span><span>.</span><span>content_type</span> <span>=</span> <span>content_type</span>
</pre></div>
</div>
<p>This example contains several good examples of needing to provide default
values. Rewriting to use conditional expressions reduces the overall lines of
code, but does not necessarily improve readability:</p>
<div><div><pre><span></span><span>class</span> <span>BaseUploadObject</span><span>(</span><span>object</span><span>):</span>
    <span>def</span> <span>find_content_type</span><span>(</span><span>self</span><span>,</span> <span>filename</span><span>):</span>
        <span>ctype</span><span>,</span> <span>encoding</span> <span>=</span> <span>mimetypes</span><span>.</span><span>guess_type</span><span>(</span><span>filename</span><span>)</span>
        <span>return</span> <span>&#39;application/octet-stream&#39;</span> <span>if</span> <span>ctype</span> <span>is</span> <span>None</span> <span>else</span> <span>ctype</span>

<span>class</span> <span>UploadContent</span><span>(</span><span>BaseUploadObject</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>content</span><span>,</span> <span>filename</span><span>=</span><span>None</span><span>,</span> <span>content_type</span><span>=</span><span>None</span><span>):</span>
        <span>self</span><span>.</span><span>content</span> <span>=</span> <span>content</span>
        <span>self</span><span>.</span><span>filename</span> <span>=</span> <span>(</span><span>self</span><span>.</span><span>get_random_filename</span><span>()</span> <span>if</span> <span>filename</span>
            <span>is</span> <span>None</span> <span>else</span> <span>filename</span><span>)</span>
        <span>self</span><span>.</span><span>content_type</span> <span>=</span> <span>(</span><span>self</span><span>.</span><span>find_content_type</span><span>(</span><span>self</span><span>.</span><span>filename</span><span>)</span>
            <span>if</span> <span>content_type</span> <span>is</span> <span>None</span> <span>else</span> <span>content_type</span><span>)</span>

<span>class</span> <span>UploadFile</span><span>(</span><span>BaseUploadObject</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>path</span><span>,</span> <span>filename</span><span>=</span><span>None</span><span>,</span> <span>content_type</span><span>=</span><span>None</span><span>):</span>
        <span>self</span><span>.</span><span>path</span> <span>=</span> <span>path</span>
        <span>self</span><span>.</span><span>filename</span> <span>=</span> <span>(</span><span>os</span><span>.</span><span>path</span><span>.</span><span>split</span><span>(</span><span>path</span><span>)[</span><span>1</span><span>]</span> <span>if</span> <span>filename</span> <span>is</span>
            <span>None</span> <span>else</span> <span>filename</span><span>)</span>
        <span>self</span><span>.</span><span>content_type</span> <span>=</span> <span>(</span><span>self</span><span>.</span><span>find_content_type</span><span>(</span><span>self</span><span>.</span><span>filename</span><span>)</span>
            <span>if</span> <span>content_type</span> <span>is</span> <span>None</span> <span>else</span> <span>content_type</span><span>)</span>
</pre></div>
</div>
<p>The first ternary expression is tidy, but it reverses the intuitive order of
the operands: it should return <code><span>ctype</span></code> if it has a value and use the string
literal as fallback. The other ternary expressions are unintuitive and so
long that they must be wrapped. The overall readability is worsened, not
improved.</p>
<p>Rewriting using the <code><span>None</span></code> coalescing operator:</p>
<div><div><pre><span></span>class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return ctype ?? &#39;application/octet-stream&#39;

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = filename ?? self.get_random_filename()
        self.content_type = content_type ?? self.find_content_type(self.filename)

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = filename ?? os.path.split(path)[1]
        self.content_type = content_type ?? self.find_content_type(self.filename)
</pre></div>
</div>
<p>This syntax has an intuitive ordering of the operands. In <code><span>find_content_type</span></code>,
for example, the preferred value <code><span>ctype</span></code> appears before the fallback value.
The terseness of the syntax also makes for fewer lines of code and less code to
visually parse, and reading from left-to-right and top-to-bottom more accurately
follows the execution flow.</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<p>The first three ideas in this section are oft-proposed alternatives to treating
<code><span>None</span></code> as special. For further background on why these are rejected, see their
treatment in <a href="https://peps.python.org/pep-0531" title="PEP 531 – Existence checking operators">PEP 531</a> and
<a href="https://peps.python.org/pep-0532" title="PEP 532 – A circuit breaking protocol and binary operators">PEP 532</a> and the associated
discussions.</p>
<section id="no-value-protocol">
<h3><a href="#no-value-protocol" role="doc-backlink">No-Value Protocol</a></h3>
<p>The operators could be generalised to user-defined types by defining a protocol
to indicate when a value represents “no value”. Such a protocol may be a dunder
method <code><span>__has_value__(self)</span></code> that returns <code><span>True</span></code> if the value should be
treated as having a value, and <code><span>False</span></code> if the value should be treated as no
value.</p>
<p>With this generalization, <code><span>object</span></code> would implement a dunder method equivalent
to this:</p>
<div><div><pre><span></span><span>def</span> <span>__has_value__</span><span>(</span><span>self</span><span>):</span>
    <span>return</span> <span>True</span>
</pre></div>
</div>
<p><code><span>NoneType</span></code> would implement a dunder method equivalent to this:</p>
<div><div><pre><span></span><span>def</span> <span>__has_value__</span><span>(</span><span>self</span><span>):</span>
    <span>return</span> <span>False</span>
</pre></div>
</div>
<p>In the specification section, all uses of <code><span>x</span> <span>is</span> <span>None</span></code> would be replaced with
<code><span>not</span> <span>x.__has_value__()</span></code>.</p>
<p>This generalization would allow for domain-specific “no-value” objects to be
coalesced just like <code><span>None</span></code>. For example, the <code><span>pyasn1</span></code> package has a type
called <code><span>Null</span></code> that represents an ASN.1 <code><span>null</span></code>:</p>
<div><div><pre><span></span>&gt;&gt;&gt; from pyasn1.type import univ
&gt;&gt;&gt; univ.Null() ?? univ.Integer(123)
Integer(123)
</pre></div>
</div>
<p>Similarly, values such as <code><span>math.nan</span></code> and <code><span>NotImplemented</span></code> could be treated
as representing no value.</p>
<p>However, the “no-value” nature of these values is domain-specific, which means
they <em>should</em> be treated as a value by the language. For example,
<code><span>math.nan.imag</span></code> is well defined (it’s <code><span>0.0</span></code>), and so short-circuiting
<code><span>math.nan?.imag</span></code> to return <code><span>math.nan</span></code> would be incorrect.</p>
<p>As <code><span>None</span></code> is already defined by the language as being the value that
represents “no value”, and the current specification would not preclude
switching to a protocol in the future (though changes to built-in objects would
not be compatible), this idea is rejected for now.</p>
</section>
<section id="boolean-aware-operators">
<h3><a href="#boolean-aware-operators" role="doc-backlink">Boolean-aware operators</a></h3>
<p>This suggestion is fundamentally the same as adding a no-value protocol, and so
the discussion above also applies.</p>
<p>Similar behavior to the <code><span>??</span></code> operator can be achieved with an <code><span>or</span></code>
expression, however <code><span>or</span></code> checks whether its left operand is false-y and not
specifically <code><span>None</span></code>. This approach is attractive, as it requires fewer changes
to the language, but ultimately does not solve the underlying problem correctly.</p>
<p>Assuming the check is for truthiness rather than <code><span>None</span></code>, there is no longer a
need for the <code><span>??</span></code> operator. However, applying this check to the <code><span>?.</span></code> and
<code><span>?[]</span></code> operators prevents perfectly valid operations applying</p>
<p>Consider the following example, where <code><span>get_log_list()</span></code> may return either a
list containing current log messages (potentially empty), or <code><span>None</span></code> if logging
is not enabled:</p>
<div><div><pre><span></span>lst = get_log_list()
lst?.append(&#39;A log message&#39;)
</pre></div>
</div>
<p>If <code><span>?.</span></code> is checking for true values rather than specifically <code><span>None</span></code> and the
log has not been initialized with any items, no item will ever be appended. This
violates the obvious intent of the code, which is to append an item. The
<code><span>append</span></code> method is available on an empty list, as are all other list methods,
and there is no reason to assume that these members should not be used because
the list is presently empty.</p>
<p>Further, there is no sensible result to use in place of the expression. A
normal <code><span>lst.append</span></code> returns <code><span>None</span></code>, but under this idea <code><span>lst?.append</span></code> may
result in either <code><span>[]</span></code> or <code><span>None</span></code>, depending on the value of <code><span>lst</span></code>. As with
the examples in the previous section, this makes no sense.</p>
<p>As checking for truthiness rather than <code><span>None</span></code> results in apparently valid
expressions no longer executing as intended, this idea is rejected.</p>
</section>
<section id="exception-aware-operators">
<h3><a href="#exception-aware-operators" role="doc-backlink">Exception-aware operators</a></h3>
<p>Arguably, the reason to short-circuit an expression when <code><span>None</span></code> is encountered
is to avoid the <code><span>AttributeError</span></code> or <code><span>TypeError</span></code> that would be raised under
normal circumstances. As an alternative to testing for <code><span>None</span></code>, the <code><span>?.</span></code> and
<code><span>?[]</span></code> operators could instead handle <code><span>AttributeError</span></code> and <code><span>TypeError</span></code>
raised by the operation and skip the remainder of the expression.</p>
<p>This produces a transformation for <code><span>a?.b.c?.d.e</span></code> similar to this:</p>
<div><div><pre><span></span><span>_v</span> <span>=</span> <span>a</span>
<span>try</span><span>:</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>b</span>
<span>except</span> <span>AttributeError</span><span>:</span>
    <span>pass</span>
<span>else</span><span>:</span>
    <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>c</span>
    <span>try</span><span>:</span>
        <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>d</span>
    <span>except</span> <span>AttributeError</span><span>:</span>
        <span>pass</span>
    <span>else</span><span>:</span>
        <span>_v</span> <span>=</span> <span>_v</span><span>.</span><span>e</span>
</pre></div>
</div>
<p>One open question is which value should be returned as the expression when an
exception is handled. The above example simply leaves the partial result, but
this is not helpful for replacing with a default value. An alternative would be
to force the result to <code><span>None</span></code>, which then raises the question as to why
<code><span>None</span></code> is special enough to be the result but not special enough to be the
test.</p>
<p>Secondly, this approach masks errors within code executed implicitly as part of
the expression. For <code><span>?.</span></code>, any <code><span>AttributeError</span></code> within a property or
<code><span>__getattr__</span></code> implementation would be hidden, and similarly for <code><span>?[]</span></code> and
<code><span>__getitem__</span></code> implementations.</p>
<p>Similarly, simple typing errors such as <code><span>{}?.ietms()</span></code> could go unnoticed.</p>
<p>Existing conventions for handling these kinds of errors in the form of the
<code><span>getattr</span></code> builtin and the <code><span>.get(key,</span> <span>default)</span></code> method pattern established by
<code><span>dict</span></code> show that it is already possible to explicitly use this behaviour.</p>
<p>As this approach would hide errors in code, it is rejected.</p>
</section>
<section id="none-aware-function-call">
<h3><a href="#none-aware-function-call" role="doc-backlink"><code><span>None</span></code>-aware Function Call</a></h3>
<p>The <code><span>None</span></code>-aware syntax applies to attribute and index access, so it seems
natural to ask if it should also apply to function invocation syntax. It might
be written as <code><span>foo?()</span></code>, where <code><span>foo</span></code> is only called if it is not None.</p>
<p>This has been deferred on the basis of the proposed operators being intended
to aid traversal of partially populated hierarchical data structures, <em>not</em>
for traversal of arbitrary class hierarchies. This is reflected in the fact
that none of the other mainstream languages that already offer this syntax
have found it worthwhile to support a similar syntax for optional function
invocations.</p>
<p>A workaround similar to that used by C# would be to write
<code><span>maybe_none?.__call__(arguments)</span></code>. If the callable is <code><span>None</span></code>, the
expression will not be evaluated. (The C# equivalent uses <code><span>?.Invoke()</span></code> on its
callable type.)</p>
</section>
<section id="unary-postfix-operator">
<h3><a href="#unary-postfix-operator" role="doc-backlink"><code><span>?</span></code> Unary Postfix Operator</a></h3>
<p>To generalize the <code><span>None</span></code>-aware behavior and limit the number of new operators
introduced, a unary, postfix operator spelled <code><span>?</span></code> was suggested. The idea is
that <code><span>?</span></code> might return a special object that could would override dunder
methods that return <code><span>self</span></code>. For example, <code><span>foo?</span></code> would evaluate to <code><span>foo</span></code> if
it is not <code><span>None</span></code>, otherwise it would evaluate to an instance of
<code><span>NoneQuestion</span></code>:</p>
<div><div><pre><span></span><span>class</span> <span>NoneQuestion</span><span>():</span>
    <span>def</span> <span>__call__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>return</span> <span>self</span>

    <span>def</span> <span>__getattr__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>):</span>
        <span>return</span> <span>self</span>

    <span>def</span> <span>__getitem__</span><span>(</span><span>self</span><span>,</span> <span>key</span><span>):</span>
        <span>return</span> <span>self</span>
</pre></div>
</div>
<p>With this new operator and new type, an expression like <code><span>foo?.bar[baz]</span></code>
evaluates to <code><span>NoneQuestion</span></code> if <code><span>foo</span></code> is None. This is a nifty
generalization, but it’s difficult to use in practice since most existing code
won’t know what <code><span>NoneQuestion</span></code> is.</p>
<p>Going back to one of the motivating examples above, consider the following:</p>
<div><div><pre><span></span>&gt;&gt;&gt; import json
&gt;&gt;&gt; created = None
&gt;&gt;&gt; json.dumps({&#39;created&#39;: created?.isoformat()})
</pre></div>
</div>
<p>The JSON serializer does not know how to serialize <code><span>NoneQuestion</span></code>, nor will
any other API. This proposal actually requires <em>lots of specialized logic</em>
throughout the standard library and any third party library.</p>
<p>At the same time, the <code><span>?</span></code> operator may also be <strong>too general</strong>, in the sense
that it can be combined with any other operator. What should the following
expressions mean?:</p>
<div><div><pre><span></span>&gt;&gt;&gt; x? + 1
&gt;&gt;&gt; x? -= 1
&gt;&gt;&gt; x? == 1
&gt;&gt;&gt; ~x?
</pre></div>
</div>
<p>This degree of generalization is not useful. The operators actually proposed
herein are intentionally limited to a few operators that are expected to make it
easier to write common code patterns.</p>
</section>
<section id="built-in-maybe">
<h3><a href="#built-in-maybe" role="doc-backlink">Built-in <code><span>maybe</span></code></a></h3>
<p>Haskell has a concept called <a href="https://wiki.haskell.org/Maybe">Maybe</a> that
encapsulates the idea of an optional value without relying on any special
keyword (e.g. <code><span>null</span></code>) or any special instance (e.g. <code><span>None</span></code>). In Haskell, the
purpose of <code><span>Maybe</span></code> is to avoid separate handling of “something” and nothing”.</p>
<p>A Python package called <a href="https://pypi.org/p/pymaybe/">pymaybe</a> provides a
rough approximation. The documentation shows the following example:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>maybe</span><span>(</span><span>&#39;VALUE&#39;</span><span>)</span><span>.</span><span>lower</span><span>()</span>
<span>&#39;value&#39;</span>

<span>&gt;&gt;&gt; </span><span>maybe</span><span>(</span><span>None</span><span>)</span><span>.</span><span>invalid</span><span>()</span><span>.</span><span>method</span><span>()</span><span>.</span><span>or_else</span><span>(</span><span>&#39;unknown&#39;</span><span>)</span>
<span>&#39;unknown&#39;</span>
</pre></div>
</div>
<p>The function <code><span>maybe()</span></code> returns either a <code><span>Something</span></code> instance or a
<code><span>Nothing</span></code> instance. Similar to the unary postfix operator described in the
previous section, <code><span>Nothing</span></code> overrides dunder methods in order to allow
chaining on a missing value.</p>
<p>Note that <code><span>or_else()</span></code> is eventually required to retrieve the underlying value
from <code><span>pymaybe</span></code>’s wrappers. Furthermore, <code><span>pymaybe</span></code> does not short circuit any
evaluation. Although <code><span>pymaybe</span></code> has some strengths and may be useful in its own
right, it also demonstrates why a pure Python implementation of coalescing is
not nearly as powerful as support built into the language.</p>
<p>The idea of adding a builtin <code><span>maybe</span></code> type to enable this scenario is rejected.</p>
</section>
<section id="just-use-a-conditional-expression">
<h3><a href="#just-use-a-conditional-expression" role="doc-backlink">Just use a conditional expression</a></h3>
<p>Another common way to initialize default values is to use the ternary operator.
Here is an excerpt from the popular <a href="https://github.com/kennethreitz/requests/blob/14a555ac716866678bf17e43e23230d81a8149f5/requests/models.py#L212">Requests package</a>:</p>
<div><div><pre><span></span><span>data</span> <span>=</span> <span>[]</span> <span>if</span> <span>data</span> <span>is</span> <span>None</span> <span>else</span> <span>data</span>
<span>files</span> <span>=</span> <span>[]</span> <span>if</span> <span>files</span> <span>is</span> <span>None</span> <span>else</span> <span>files</span>
<span>headers</span> <span>=</span> <span>{}</span> <span>if</span> <span>headers</span> <span>is</span> <span>None</span> <span>else</span> <span>headers</span>
<span>params</span> <span>=</span> <span>{}</span> <span>if</span> <span>params</span> <span>is</span> <span>None</span> <span>else</span> <span>params</span>
<span>hooks</span> <span>=</span> <span>{}</span> <span>if</span> <span>hooks</span> <span>is</span> <span>None</span> <span>else</span> <span>hooks</span>
</pre></div>
</div>
<p>This particular formulation has the undesirable effect of putting the operands
in an unintuitive order: the brain thinks, “use <code><span>data</span></code> if possible and use
<code><span>[]</span></code> as a fallback,” but the code puts the fallback <em>before</em> the preferred
value.</p>
<p>The author of this package could have written it like this instead:</p>
<div><div><pre><span></span><span>data</span> <span>=</span> <span>data</span> <span>if</span> <span>data</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>[]</span>
<span>files</span> <span>=</span> <span>files</span> <span>if</span> <span>files</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>[]</span>
<span>headers</span> <span>=</span> <span>headers</span> <span>if</span> <span>headers</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>{}</span>
<span>params</span> <span>=</span> <span>params</span> <span>if</span> <span>params</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>{}</span>
<span>hooks</span> <span>=</span> <span>hooks</span> <span>if</span> <span>hooks</span> <span>is</span> <span>not</span> <span>None</span> <span>else</span> <span>{}</span>
</pre></div>
</div>
<p>This ordering of the operands is more intuitive, but it requires 4 extra
characters (for “not “). It also highlights the repetition of identifiers:
<code><span>data</span> <span>if</span> <span>data</span></code>, <code><span>files</span> <span>if</span> <span>files</span></code>, etc.</p>
<p>When written using the <code><span>None</span></code> coalescing operator, the sample reads:</p>
<div><div><pre><span></span>data = data ?? []
files = files ?? []
headers = headers ?? {}
params = params ?? {}
hooks = hooks ?? {}
</pre></div>
</div>
</section>
</section>
<section id="references">
<h2><a href="#references" role="doc-backlink">References</a></h2>

</section>
<section id="copyright">
<h2><a href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section></div>
  </body>
</html>
