<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://imiron.io/post/linkedin-queens/">Original</a>
    <h1>Solving LinkedIn Queens Using Haskell</h1>
    
    <div id="readability-page-1" class="page"><div><p>[Thanks to <a href="https://jameshaydon.github.io/">James Haydon</a> for his suggestions on improving the post and the code quality]</p><p>On LinkedIn, <a href="https://www.linkedin.com/games/queens">you can play</a> a variant of the <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">N-Queens</a> problem. A community version of the game (rather, puzzle) can be found <a href="https://queensgame.vercel.app/">here</a>.</p><p>Recently, we saw it solved using <a href="https://ryanberger.me/posts/queens/">SAT solvers</a>, using <a href="https://buttondown.com/hillelwayne/archive/solving-linkedin-queens-with-smt/">SMT Solvers</a>, using <a href="https://pitr.ca/2025-06-14-queens">APL</a> and <a href="https://zayenz.se/blog/post/linkedin-queens/">MiniZinc</a>. Today, I will try solving it using Haskell, a slightly more conventional language.</p><h2 id="the-puzzle">The Puzzle</h2><p>You are given a N-colored square-shaped board of size N. You must place N queens on the board such that:</p><ul><li>Each row, each column, and each color region has exactly one queen.</li><li>No two queens touch each other diagonally.</li></ul><p>Note that placing two queens in the same diagonal is acceptable, as long as they are not diagonally adjacent (unlike in Chess).</p><p>For instance, one can verify that the following is the only solution for the given colored board.</p><p><img src="https://imiron.io/images/post/queens/simple.svg"/></p><h3 id="haskell-setup">Haskell Setup</h3><p>We will use <code>Data.Array</code> from the <a href="https://hackage.haskell.org/package/array">array</a> library to represent the problem.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>Color</span> <span>=</span> <span>Int</span>
</span></span><span><span><span>type</span> <span>Row</span> <span>=</span> <span>Int</span>
</span></span><span><span><span>type</span> <span>Column</span> <span>=</span> <span>Int</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Problem</span> <span>=</span> <span>Array</span> (<span>Row</span>, <span>Column</span>) <span>Color</span>
</span></span><span><span>
</span></span><span><span><span>mkProblem</span> <span>::</span> [[<span>Color</span>]] <span>-&gt;</span> <span>Problem</span>
</span></span><span><span><span>mkProblem</span> colorsList <span>=</span>
</span></span><span><span>  <span>Array</span><span>.</span>array
</span></span><span><span>    ((<span>0</span>, <span>0</span>), (n <span>-</span> <span>1</span>, n <span>-</span> <span>1</span>))
</span></span><span><span>    [((i, j), color) <span>|</span> (i, row) <span>&lt;-</span> zip [<span>0</span> <span>..</span>] colorsList, (j, color) <span>&lt;-</span> zip [<span>0</span> <span>..</span>] row]
</span></span><span><span>  <span>where</span>
</span></span><span><span>    n <span>=</span> length colorsList
</span></span><span><span>
</span></span><span><span><span>size</span> <span>::</span> <span>Problem</span> <span>-&gt;</span> <span>Int</span>
</span></span><span><span><span>size</span> problem <span>=</span> n <span>+</span> <span>1</span>
</span></span><span><span>  <span>where</span>
</span></span><span><span>    ((<span>_</span>, <span>_</span>), (<span>_</span>, n)) <span>=</span> <span>Array</span><span>.</span>bounds problem
</span></span><span><span>
</span></span><span><span><span>problem1</span> <span>::</span> <span>Problem</span>
</span></span><span><span><span>problem1</span> <span>=</span>
</span></span><span><span>  mkProblem
</span></span><span><span>    [ [<span>0</span>, <span>1</span>, <span>1</span>, <span>1</span>, <span>1</span>],
</span></span><span><span>      [<span>2</span>, <span>3</span>, <span>2</span>, <span>1</span>, <span>2</span>],
</span></span><span><span>      [<span>2</span>, <span>3</span>, <span>2</span>, <span>1</span>, <span>2</span>],
</span></span><span><span>      [<span>2</span>, <span>2</span>, <span>2</span>, <span>4</span>, <span>4</span>],
</span></span><span><span>      [<span>2</span>, <span>2</span>, <span>2</span>, <span>2</span>, <span>2</span>]
</span></span><span><span>    ]
</span></span></code></pre></div><p>The problem shown above is encoded as <code>problem1</code> in the code. I have encoded a few larger examples in <a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Problem.hs">this file</a>.</p><h2 id="backtracking-soundness-and-completeness">Backtracking, Soundness and Completeness</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt0.hs">Source Code for Attempt 0</a></strong>]</p><p>We will tackle the problem using a backtracking approach. This means, we will place a queen on a plausible cell on the board; check if the current configuration can be extended to a full solution; continue if so, and <em>backtrack</em> otherwise, finding a different plausible cell to put the queen on.</p><p>To aid our discussion, let us introduce some terminology.</p><ul><li>A <strong>partial placement</strong> is a set of positions on the board.</li><li>A partial placement is <strong>sound</strong> if it does not violate any of the constraints of the problem, i.e., no two queens are in the same row, column, color region, or are diagonally adjacent. We usually refer to such placements as <em>partial solutions</em>.</li><li>If a partial placement has N queens, it is <strong>complete</strong>.</li><li>A partial solution <code>p</code> <strong>extends</strong> <code>q</code> if <code>p</code> has all the queens placed in <code>q</code>, and possibly more.</li></ul><p>We can describe our backtracking algorithm using this terminology. The algorithm maintains a partial solution. It extends the partial solution by placing additional queens at each step, until enough queens have been placed (i.e, the solution is <em>complete</em>). At the end, we check to see if the solution is also sound. One can see that a sound and complete partial solution solves the given problem, in the sense defined in the previous section.</p><p>We represent partial solutions using a <code>Set (Row, Column)</code>, the set of currently placed queens. The definition of soundness and completeness can be encoded as a Boolean predicate as follows.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>Partial</span> <span>=</span> <span>Set</span> (<span>Row</span>, <span>Column</span>)
</span></span><span><span>
</span></span><span><span><span>sound</span> <span>::</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> <span>Bool</span>
</span></span><span><span><span>sound</span> problem partial <span>=</span> soundRows <span>&amp;&amp;</span> soundColumns <span>&amp;&amp;</span> soundColors <span>&amp;&amp;</span> soundCorners
</span></span><span><span>  <span>where</span>
</span></span><span><span>    soundRows <span>=</span> all (soundRow partial) [<span>0</span> <span>..</span> size problem <span>-</span> <span>1</span>]
</span></span><span><span>    soundColumns <span>=</span> all (soundColumn partial) [<span>0</span> <span>..</span> size problem <span>-</span> <span>1</span>]
</span></span><span><span>    soundColors <span>=</span> all (soundColor problem partial) [<span>0</span> <span>..</span> size problem <span>-</span> <span>1</span>]
</span></span><span><span>    soundCorners <span>=</span> all (soundCorner partial) partial
</span></span><span><span>
</span></span><span><span><span>complete</span> <span>::</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> <span>Bool</span>
</span></span><span><span><span>complete</span> problem partial <span>=</span> <span>Set</span><span>.</span>size partial <span>==</span> size problem
</span></span></code></pre></div><p>We encode our backtracking computations using <code>MonadLogic</code> monads from the <a href="https://hackage.haskell.org/package/logict">LogicT</a> library. This is a generalization of the list monad, <a href="https://stackoverflow.com/questions/20638893/how-can-non-determinism-be-modeled-with-a-list-monad">which can be used to</a> encode non-deterministic (i.e, branching) computation. Since <code>LogicT</code> is a monad transformer rather than a monad (like the list monad), it can also be composed with other monadic effects. The <code>LogicT</code> library also provides a few additional sophisticated ways of weaving together non-deterministic computations: it makes available <code>interleave</code>, a <em>fair</em> disjunction, which guarantees that the second computation will make progress even if the first computation is non-terminating. This can also be useful in some cases even if the computations are finite, since an interleaved exploration strategy wouldn’t have to exhaust the first branch before exploring the second one. The library comes with a few instances of monads (and monad transformers) which satisfy <code>MonadLogic</code> including <a href="https://hackage.haskell.org/package/list-t-1.0.5.7/docs/ListT.html#t:ListT"><code>ListT</code></a>(certain older versions of ListT were <a href="https://stackoverflow.com/questions/12617916/why-is-listt-monad-transformer-considered-buggy-what-monad-laws-it-breaks">implemented incorrectly</a>), <a href="https://hackage.haskell.org/package/logict-sequence-0.2.0.2/docs/Control-Monad-Logic-Sequence.html#t:SeqT"><code>SeqT</code></a> and <a href="https://hackage.haskell.org/package/streamt-0.5.0.1/docs/Control-Monad-Stream.html#t:StreamT"><code>StreamT</code></a>.</p><p>For the purpose of the most naïve solution, we will simply pick <code>N</code> queens and check if the placement is sound. Potential positions for new queens are generated by the <code>candidate</code> computation. If such a candidate is available, we add it into the partial solution; otherwise, we return the current placement of queens. A <code>guard</code> placed in the computation will discard a branch if the condition is not met. Thanks to the monadic interface, we do not need to handle the backtracking control-flow directly.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>candidate</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m (<span>Row</span>, <span>Column</span>)
</span></span><span><span><span>candidate</span> problem partial <span>=</span> <span>do</span>
</span></span><span><span>  <span>let</span> n <span>=</span> size problem
</span></span><span><span>  x <span>&lt;-</span> choose [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>]
</span></span><span><span>  y <span>&lt;-</span> choose [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>]
</span></span><span><span>  <span>-- this cell should not have been already picked</span>
</span></span><span><span>  guard <span>$</span> (x, y) `<span>Set</span><span>.</span>notMember` partial
</span></span><span><span>  pure (x, y)
</span></span><span><span>
</span></span><span><span><span>-- do an action n times</span>
</span></span><span><span><span>repeatM</span> <span>::</span> (<span>Monad</span> m) <span>=&gt;</span> <span>Int</span> <span>-&gt;</span> (a <span>-&gt;</span> m a) <span>-&gt;</span> a <span>-&gt;</span> m a
</span></span><span><span><span>repeatM</span> n f <span>=</span> foldr (<span>&gt;=&gt;</span>) pure (replicate n f)
</span></span><span><span>
</span></span><span><span><span>extend</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m <span>Partial</span>
</span></span><span><span><span>extend</span> problem partial <span>=</span> <span>do</span>
</span></span><span><span>  pos <span>&lt;-</span> candidate problem partial
</span></span><span><span>  <span>-- place a queen on the candidate cell</span>
</span></span><span><span>  pure <span>$</span> <span>Set</span><span>.</span>insert pos partial
</span></span><span><span>
</span></span><span><span><span>solution</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> m [(<span>Row</span>, <span>Column</span>)]
</span></span><span><span><span>solution</span> problem <span>=</span> <span>do</span>
</span></span><span><span>  endState <span>&lt;-</span> repeatM (size problem) (extend problem) <span>Set</span><span>.</span>empty
</span></span><span><span>  guard <span>$</span> sound problem endState
</span></span><span><span>  pure (<span>Set</span><span>.</span>toList endState)
</span></span></code></pre></div><h3 id="running-logict">Running LogicT</h3><p>An instance of <code>LogicMonad</code> is the monad <code>Logic</code>, also included in the <code>LogicT</code> library. One can use the <code>observe :: Logic a -&gt; a</code> to read off the first value of the computation.</p><p>This version of the solution solves the <code>5x5</code> puzzle shown above in around quarter of a second.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> <span>:</span>l src<span>/</span><span>Attempt0</span><span>.</span>hs 
</span></span><span><span><span>...</span>
</span></span><span><span><span>ghci</span><span>&gt;</span> <span>:</span>set <span>+</span>s
</span></span><span><span><span>ghci</span><span>&gt;</span> observe <span>$</span> solution problem1
</span></span><span><span>[(<span>0</span>,<span>0</span>),(<span>1</span>,<span>3</span>),(<span>2</span>,<span>1</span>),(<span>3</span>,<span>4</span>),(<span>4</span>,<span>2</span>)]
</span></span><span><span>(<span>0.24</span> secs, <span>337</span>,<span>664</span>,<span>536</span> bytes)
</span></span></code></pre></div><h2 id="simple-elimination">Simple Elimination</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt1.hs">Source Code for Attempt 1</a></strong>]</p><p>The original version of this game allows marking cells as <em>eliminated</em>, as a convenience to the user. For example, after placing the queen in the cell shown below, we could mark the others as ’eliminated&#39;.</p><p><img src="https://imiron.io/images/post/queens/elimination.svg"/></p><p>To improve our solution, we will start marking certain cells as <em>eliminated</em>. We adapt the <code>Partial</code> data structure to accomodate these marks. Note that our use of <code>Map</code> means we can have cells which neither have a queen, nor are marked as eliminated.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>data</span> <span>Attempt</span> <span>=</span> <span>HasQueen</span> <span>|</span> <span>Eliminated</span>
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Partial</span> <span>=</span> <span>Map</span> (<span>Row</span>, <span>Column</span>) <span>Attempt</span>
</span></span></code></pre></div><p>From now on, we will ensure that our algorithms always deal with sound partial solutions. The <code>Eliminated</code> marks can be used for this. When we place a queen at a cell, we will mark the cells in the same row, same column, of the same color, and around the corners as eliminated. Then, when we generate candidates, we will ignore candidates which are marked as <code>Eliminated</code>.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>placeQueen</span> <span>::</span> <span>Problem</span> <span>-&gt;</span> (<span>Row</span>, <span>Column</span>) <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> <span>Partial</span>
</span></span><span><span><span>placeQueen</span> problem (x, y) partial <span>=</span>
</span></span><span><span>  elimCorners (x, y) problem
</span></span><span><span>    <span>.</span> elimColumn y problem
</span></span><span><span>    <span>.</span> elimRow x problem
</span></span><span><span>    <span>.</span> elimColor color problem
</span></span><span><span>    <span>$</span> newBoard
</span></span><span><span>  <span>where</span>
</span></span><span><span>    newBoard <span>=</span> <span>Map</span><span>.</span>insert (x, y) <span>HasQueen</span> partial
</span></span><span><span>    color <span>=</span> problem <span>!</span> (x, y)
</span></span><span><span>
</span></span><span><span><span>candidate</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m (<span>Row</span>, <span>Column</span>)
</span></span><span><span><span>candidate</span> problem partial <span>=</span> <span>do</span>
</span></span><span><span>  <span>let</span> n <span>=</span> size problem
</span></span><span><span>  x <span>&lt;-</span> choose [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>]
</span></span><span><span>  y <span>&lt;-</span> choose [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>]
</span></span><span><span>  <span>-- only pick unmarked cells</span>
</span></span><span><span>  guard (isNothing (<span>Map</span><span>.</span>lookup (x, y) partial))
</span></span><span><span>  pure (x, y)
</span></span></code></pre></div><p>The backtracking code can be simplified slightly. We no longer need to check for soundness explicitly.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>extend</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m <span>Partial</span>
</span></span><span><span><span>extend</span> problem partial <span>=</span> <span>do</span>
</span></span><span><span>  pos <span>&lt;-</span> candidate problem partial
</span></span><span><span>  <span>-- place a queen on the candidate cell</span>
</span></span><span><span>  pure <span>$</span> placeQueen problem pos partial
</span></span><span><span>
</span></span><span><span><span>queenView</span> <span>::</span> <span>Partial</span> <span>-&gt;</span> [(<span>Row</span>, <span>Column</span>)]
</span></span><span><span><span>queenView</span> partial <span>=</span> [(x, y) <span>|</span> ((x, y), status) <span>&lt;-</span> <span>Map</span><span>.</span>toList partial, status <span>==</span> <span>HasQueen</span>]
</span></span><span><span>
</span></span><span><span><span>solution</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> m [(<span>Row</span>, <span>Column</span>)]
</span></span><span><span><span>solution</span> problem <span>=</span> <span>do</span>
</span></span><span><span>  endState <span>&lt;-</span> repeatM (size problem) (extend problem) <span>Map</span><span>.</span>empty
</span></span><span><span>  pure <span>$</span> queenView endState
</span></span></code></pre></div><p>This version of the code solves the <code>5x5</code> puzzle an order of magintude more quickly.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> <span>:</span>l src<span>/</span><span>Attempt1</span><span>.</span>hs 
</span></span><span><span><span>...</span>
</span></span><span><span><span>ghci</span><span>&gt;</span> <span>:</span>set <span>+</span>s
</span></span><span><span><span>ghci</span><span>&gt;</span> observe <span>$</span> solution problem1
</span></span><span><span>[(<span>0</span>,<span>0</span>),(<span>1</span>,<span>3</span>),(<span>2</span>,<span>1</span>),(<span>3</span>,<span>4</span>),(<span>4</span>,<span>2</span>)]
</span></span><span><span>(<span>0.02</span> secs, <span>1</span>,<span>060</span>,<span>264</span> bytes)
</span></span></code></pre></div><p>However, it still has trouble with the <code>8x8</code> puzzles. It takes 150 seconds to solve <a href="https://queensgame.vercel.app/level/1">this puzzle</a>.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> observe <span>$</span> solution problem2
</span></span><span><span>[(<span>0</span>,<span>3</span>),(<span>1</span>,<span>5</span>),(<span>2</span>,<span>1</span>),(<span>3</span>,<span>7</span>),(<span>4</span>,<span>0</span>),(<span>5</span>,<span>2</span>),(<span>6</span>,<span>6</span>),(<span>7</span>,<span>4</span>)]
</span></span><span><span>(<span>151.08</span> secs, <span>266</span>,<span>889</span>,<span>169</span>,<span>608</span> bytes)
</span></span></code></pre></div><h2 id="detecting-dead-ends-early">Detecting Dead Ends Early</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt2.hs">Source Code for Attempt 2</a></strong>]</p><p>Our first serious attempt at improving the algorithm is to realize that in certain cases we may be able to tell early that a certain partial solution cannot be extended to a full solution, and thus we should avoid exploring the subtree in such cases.</p><p>Let us call a partial solution a <strong>dead end</strong> if it cannot be extended to a full solution. We want to find a predicate <code>pred</code> on partial solutions which can detect dead ends, i.e, <code>pred(p) =&gt; deadEnd(p)</code>. To do so, it is often helpful to maintain additional information which makes computing the predicate easier. (Note that some partial solution <code>p</code> may be a dead end even if it doesn’t satisfy <code>pred(p)</code>. We need to strike a balance between how expensive it is to compute <code>pred</code>, and the accuracy with which it detects dead ends.)</p><p>Here, we will track the number of uneliminated cells in each row, column and color region. If we have a row with no queens and all cells eliminated, then we know that no queens placed in the future can be a complete solution.</p><p>We ammend our <code>Partial</code> type to track this information.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>data</span> <span>Remaining</span> <span>=</span> <span>Satisfied</span> <span>|</span> <span>AvailableCandidates</span> <span>Int</span>
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span><span><span>
</span></span><span><span><span>data</span> <span>Partial</span> <span>=</span> <span>Partial</span>
</span></span><span><span>  { attempts <span>::</span> <span>Map</span> (<span>Row</span>, <span>Column</span>) <span>Attempt</span>,
</span></span><span><span>    rowCandidates <span>::</span> <span>Map</span> <span>Row</span> <span>Remaining</span>,
</span></span><span><span>    columnCandidates <span>::</span> <span>Map</span> <span>Column</span> <span>Remaining</span>,
</span></span><span><span>    colorCandidates <span>::</span> <span>Map</span> <span>Color</span> <span>Remaining</span>
</span></span><span><span>  }
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span><span><span>
</span></span><span><span><span>decrease</span> <span>::</span> (<span>MonadLogic</span> m, <span>Ord</span> k) <span>=&gt;</span> k <span>-&gt;</span> <span>Map</span> k <span>Remaining</span> <span>-&gt;</span> m (<span>Map</span> k <span>Remaining</span>)
</span></span><span><span><span>decrease</span> key candidates <span>=</span>
</span></span><span><span>  <span>case</span> <span>Map</span><span>.</span>lookup key candidates <span>of</span>
</span></span><span><span>    <span>Just</span> (<span>AvailableCandidates</span> n) <span>-&gt;</span> <span>do</span>
</span></span><span><span>      <span>-- Note: the condition is (n &gt; 1)</span>
</span></span><span><span>      <span>-- we do not want to be left with 0 candidates</span>
</span></span><span><span>      guard (n <span>&gt;</span> <span>1</span>)
</span></span><span><span>      pure <span>$</span> <span>Map</span><span>.</span>insert key (<span>AvailableCandidates</span> (n <span>-</span> <span>1</span>)) candidates
</span></span><span><span>    <span>_</span> <span>-&gt;</span> pure candidates
</span></span></code></pre></div><p>Every time we eliminate a cell, we use the <code>decrease</code> function to update the available candidates for that row, column or color region. If we do have a queen placed in a row, column or color region already, we mark it as <code>Satisfied</code>, and this does not count towards the bad scenario where the subtree is abandoned. Precisely stated, if <code>r = rowCandidates ! i</code> and <code>r = AvailableCandidates m</code>, then there are <code>m</code> values of <code>j</code> such that <code>lookup attempts (i, j) = Nothing</code>. Similar invariants for columns and colors apply.</p><p>Note that this function performs a computation in a <code>MonadLogic m</code>, and it discards the branch if the number of candidates go to zero. Thus, the signature of <code>placeQueen</code> has to also be updated to do a monadic computation instead.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>placeQueen</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> (<span>Row</span>, <span>Column</span>) <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m <span>Partial</span>
</span></span><span><span><span>placeQueen</span> problem (x, y) partial <span>=</span> elimAll newPartial
</span></span><span><span>  <span>where</span>
</span></span><span><span>    newAttempts <span>=</span> <span>Map</span><span>.</span>insert (x, y) <span>HasQueen</span> partial<span>.</span>attempts
</span></span><span><span>    newRowCandidates <span>=</span> <span>Map</span><span>.</span>insert x <span>Satisfied</span> partial<span>.</span>rowCandidates
</span></span><span><span>    newColumnCandidates <span>=</span> <span>Map</span><span>.</span>insert y <span>Satisfied</span> partial<span>.</span>columnCandidates
</span></span><span><span>    color <span>=</span> problem <span>!</span> (x, y)
</span></span><span><span>    newColorCandidates <span>=</span> <span>Map</span><span>.</span>insert color <span>Satisfied</span> partial<span>.</span>colorCandidates
</span></span><span><span>    newPartial <span>=</span>
</span></span><span><span>      <span>Partial</span>
</span></span><span><span>        { attempts <span>=</span> newAttempts,
</span></span><span><span>          rowCandidates <span>=</span> newRowCandidates,
</span></span><span><span>          columnCandidates <span>=</span> newColumnCandidates,
</span></span><span><span>          colorCandidates <span>=</span> newColorCandidates
</span></span><span><span>        }
</span></span><span><span>    elimAll <span>=</span>
</span></span><span><span>      elimCorners (x, y) problem
</span></span><span><span>        <span>&gt;=&gt;</span> elimColumn y problem
</span></span><span><span>        <span>&gt;=&gt;</span> elimRow x problem
</span></span><span><span>        <span>&gt;=&gt;</span> elimColor color problem
</span></span></code></pre></div><p>With this version, we can solve 8x8 puzzles in reasonable time, but the algorithm can still be tuned further.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> <span>:</span>l src<span>/</span><span>Attempt2</span><span>.</span>hs 
</span></span><span><span><span>...</span>
</span></span><span><span><span>ghci</span><span>&gt;</span> observe <span>$</span> solution problem2
</span></span><span><span>[(<span>0</span>,<span>3</span>),(<span>1</span>,<span>5</span>),(<span>2</span>,<span>1</span>),(<span>3</span>,<span>7</span>),(<span>4</span>,<span>0</span>),(<span>5</span>,<span>2</span>),(<span>6</span>,<span>6</span>),(<span>7</span>,<span>4</span>)]
</span></span><span><span>(<span>1.67</span> secs, <span>2</span>,<span>821</span>,<span>798</span>,<span>576</span> bytes)
</span></span></code></pre></div><h2 id="generating-candidates-carefully">Generating Candidates Carefully</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt3.hs">Source Code for Attempt 3</a></strong>]</p><p>So far, we have been generating candidates simply by looking for the first uneliminated cell. Instead, we could track potential candidates for each row, column and color more directly, and pick from the remaining candidates.</p><p>To do this, we update our <code>Partial</code> type once again. The function <code>remove</code> now plays the same role as that of <code>decrease</code> before.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>data</span> <span>Remaining</span> a <span>=</span> <span>Satisfied</span> <span>|</span> <span>AvailableCandidates</span> (<span>Set</span> a)
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span><span><span>
</span></span><span><span><span>data</span> <span>Partial</span> <span>=</span> <span>Partial</span>
</span></span><span><span>  { attempts <span>::</span> <span>Map</span> (<span>Row</span>, <span>Column</span>) <span>Attempt</span>,
</span></span><span><span>    rowCandidates <span>::</span> <span>Map</span> <span>Row</span> (<span>Remaining</span> <span>Column</span>),
</span></span><span><span>    columnCandidates <span>::</span> <span>Map</span> <span>Column</span> (<span>Remaining</span> <span>Row</span>),
</span></span><span><span>    colorCandidates <span>::</span> <span>Map</span> <span>Color</span> (<span>Remaining</span> (<span>Row</span>, <span>Column</span>))
</span></span><span><span>  }
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span><span><span>
</span></span><span><span><span>remove</span> <span>::</span> (<span>MonadLogic</span> m, <span>Ord</span> k, <span>Ord</span> a) <span>=&gt;</span> k <span>-&gt;</span> a <span>-&gt;</span> <span>Map</span> k (<span>Remaining</span> a) <span>-&gt;</span> m (<span>Map</span> k (<span>Remaining</span> a))
</span></span><span><span><span>remove</span> key a candidates <span>=</span> <span>do</span>
</span></span><span><span>  <span>case</span> <span>Map</span><span>.</span>lookup key candidates <span>of</span>
</span></span><span><span>    <span>Just</span> (<span>AvailableCandidates</span> s) <span>-&gt;</span> <span>do</span>
</span></span><span><span>      <span>-- Note: the condition is (|s| &gt; 1)</span>
</span></span><span><span>      <span>-- we do not want to be left with 0 candidates</span>
</span></span><span><span>      guard (<span>Set</span><span>.</span>size s <span>&gt;</span> <span>1</span>)
</span></span><span><span>      <span>let</span> newSet <span>=</span> <span>Set</span><span>.</span>delete a s
</span></span><span><span>      pure <span>$</span> <span>Map</span><span>.</span>insert key (<span>AvailableCandidates</span> newSet) candidates
</span></span><span><span>    <span>_</span> <span>-&gt;</span> pure candidates
</span></span></code></pre></div><p>The following function generates candidates based on candidates for each row.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>rowCandidate</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Partial</span> <span>-&gt;</span> m (<span>Row</span>, <span>Column</span>)
</span></span><span><span><span>rowCandidate</span> partial <span>=</span> <span>do</span>
</span></span><span><span>  (r, remaining) <span>&lt;-</span> choose <span>$</span> <span>Map</span><span>.</span>toList partial<span>.</span>rowCandidates
</span></span><span><span>  s <span>&lt;-</span> <span>case</span> remaining <span>of</span>
</span></span><span><span>    <span>AvailableCandidates</span> s&#39; <span>-&gt;</span> pure s&#39;
</span></span><span><span>    <span>Satisfied</span> <span>-&gt;</span> empty
</span></span><span><span>  c <span>&lt;-</span> choose s
</span></span><span><span>  pure (r, c)
</span></span></code></pre></div><p>One could also define <code>columnCandidate</code> or <code>colorCandidate</code> similarly. Now, we could set <code>candidate</code> to be either of these three. There is no need to try all of them. Indeed, consider the case in which there are no candidates available from <code>rowCandidate</code>; this means that any candidate from <code>columnCandidate</code> or <code>colorCandidate</code> would definitely violate the row constraints.</p><p>This version is slightly better, but the computation still takes substantial time.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> <span>:</span>l src<span>/</span><span>Attempt3</span><span>.</span>hs
</span></span><span><span><span>...</span>
</span></span><span><span><span>ghci</span><span>&gt;</span> observe <span>$</span> solution problem2
</span></span><span><span>[(<span>0</span>,<span>3</span>),(<span>1</span>,<span>5</span>),(<span>2</span>,<span>1</span>),(<span>3</span>,<span>7</span>),(<span>4</span>,<span>0</span>),(<span>5</span>,<span>2</span>),(<span>6</span>,<span>6</span>),(<span>7</span>,<span>4</span>)]
</span></span><span><span>(<span>1.42</span> secs, <span>2</span>,<span>175</span>,<span>494</span>,<span>584</span> bytes)
</span></span></code></pre></div><h2 id="ranking-candidates">Ranking Candidates</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt4.hs">Source Code for Attempt 4</a></strong>]</p><p>If we consider the following puzzle (<code>problem2</code>, from before), we immediately notice that we must place a queen in the marked square. That’s because this color has exactly one square, and thus the queen of that color must be placed there.</p><p><img src="https://imiron.io/images/post/queens/ranking.svg"/></p><p>We can formalize this intuition as follows. Let’s fix a partial solution <code>p</code>. Call a set of candidate cells <code>X</code> a <strong>strategy</strong> (w.r.t. the partial solution <code>p</code>) if every complete solution <code>q</code> that is an extension of <code>p</code> exactly one queen with <code>X</code>. In other words, a strategy is a set of candidate cells at least one of which must be ‘correct’.</p><p>Initially, we know that each color, column and row must each contain exactly one queen, which makes them strategies (for the empty partial solution). For each (sound) partial solution, some subset of these regions (rows, colors or columns) would continue to be strategies.</p><p>In our algorithm, the <code>Remaining</code> type associated with each row, column or color tracks strategies for each partial solution, for the same reason.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>Strategy</span> <span>=</span> <span>Set</span> (<span>Row</span>, <span>Column</span>)
</span></span><span><span>
</span></span><span><span><span>strategies</span> <span>::</span> <span>Partial</span> <span>-&gt;</span> [<span>Strategy</span>]
</span></span><span><span><span>strategies</span> partial <span>=</span>
</span></span><span><span>  [<span>Set</span><span>.</span>fromList [(r, c) <span>|</span> c <span>&lt;-</span> <span>Set</span><span>.</span>toList s] <span>|</span> (r, <span>AvailableCandidates</span> s) <span>&lt;-</span> <span>Map</span><span>.</span>toList partial<span>.</span>rowCandidates]
</span></span><span><span>    <span>++</span> [<span>Set</span><span>.</span>fromList [(r, c) <span>|</span> r <span>&lt;-</span> <span>Set</span><span>.</span>toList s] <span>|</span> (c, <span>AvailableCandidates</span> s) <span>&lt;-</span> <span>Map</span><span>.</span>toList partial<span>.</span>columnCandidates]
</span></span><span><span>    <span>++</span> [<span>Set</span><span>.</span>fromList [(i, j) <span>|</span> (i, j) <span>&lt;-</span> <span>Set</span><span>.</span>toList s] <span>|</span> (<span>_</span>, <span>AvailableCandidates</span> s) <span>&lt;-</span> <span>Map</span><span>.</span>toList partial<span>.</span>colorCandidates]
</span></span></code></pre></div><p>When we have a strategy with exactly one candidate <code>(i, j)</code>, we should prefer to immediately place a queen at <code>(i, j)</code>. By the definition of a strategy, this guarantees that unless the original partial solution was a dead end, we will not be backtracking this decision.</p><p>Given a strategy with <code>m</code> candidates, we may have to backtrack <code>m - 1</code> times before we succeed. To increase the chances that we backtrack as little as possible, we should prefer strategies with fewer candidates.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>candidate</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Partial</span> <span>-&gt;</span> m (<span>Row</span>, <span>Column</span>)
</span></span><span><span><span>candidate</span> partial
</span></span><span><span>  <span>|</span> null availableStrategies <span>=</span> empty
</span></span><span><span>  <span>|</span> otherwise <span>=</span> choose bestStrategy
</span></span><span><span>  <span>where</span>
</span></span><span><span>    availableStrategies <span>=</span> strategies partial
</span></span><span><span>    <span>-- We choose the strategy with the least number of candidates</span>
</span></span><span><span>    bestStrategy <span>=</span> minimumBy (compare `on` <span>Set</span><span>.</span>size) availableStrategies
</span></span></code></pre></div><p>This version of the code is quite fast.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> <span>:</span>l src<span>/</span><span>Attempt4</span><span>.</span>hs
</span></span><span><span><span>...</span>
</span></span><span><span><span>ghci</span><span>&gt;</span> observe <span>$</span> solution problem2
</span></span><span><span>[(<span>0</span>,<span>3</span>),(<span>1</span>,<span>5</span>),(<span>2</span>,<span>1</span>),(<span>3</span>,<span>7</span>),(<span>4</span>,<span>0</span>),(<span>5</span>,<span>2</span>),(<span>6</span>,<span>6</span>),(<span>7</span>,<span>4</span>)]
</span></span><span><span>(<span>0.01</span> secs, <span>1</span>,<span>948</span>,<span>544</span> bytes)
</span></span></code></pre></div><h2 id="simplification-and-further-optimizations">Simplification and Further Optimizations</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt5Set.hs">Source Code for Attempt 5</a></strong>]</p><p>After the previous attempt, we always generate candidates from the set of strategies. After placing each new queen, we update the strategies to remove elements which we mark as <em>eliminated</em>. Therefore, the <code>Eliminated</code> marks are no longer necessary, since we implicitly track them in the strategies. Formally, if a cell <code>(i, j)</code> is in one of the strategies we have maintained, then <code>(i, j)</code> can be added to the partial solution without violating soundness. So, we can have our partial solution track only <code>queens :: Set (Row, Column)</code>.</p><p>Next, we observe that we traverse the set of strategies every time we generate a candidate to find the smallest ones. Instead, we could employ a data structure to maintain them in sorted order. Conveniently, Haskell’s <code>Data.Set</code> is already such a structure. It comes with <code>lookupMin</code> which can return the smallest element. Thus, we endow <code>Strategy</code> with an <code>Ord</code> instance, to allow us to use <code>Set</code> on them directly.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>newtype</span> <span>Strategy</span> <span>=</span> <span>Strategy</span> {unStrategy <span>::</span> <span>Set</span> (<span>Row</span>, <span>Column</span>)}
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span><span><span>
</span></span><span><span><span>instance</span> <span>Ord</span> <span>Strategy</span> <span>where</span>
</span></span><span><span>  compare (<span>Strategy</span> s1) (<span>Strategy</span> s2) <span>=</span>
</span></span><span><span>    <span>-- prefer smaller sets first</span>
</span></span><span><span>    <span>case</span> compare (<span>Set</span><span>.</span>size s1) (<span>Set</span><span>.</span>size s2) <span>of</span>
</span></span><span><span>      <span>EQ</span> <span>-&gt;</span> compare s1 s2
</span></span><span><span>      other <span>-&gt;</span> other
</span></span><span><span>
</span></span><span><span><span>data</span> <span>Partial</span> <span>=</span> <span>Partial</span>
</span></span><span><span>  { queens <span>::</span> <span>Set</span> (<span>Row</span>, <span>Column</span>),
</span></span><span><span>    strategies <span>::</span> <span>Set</span> <span>Strategy</span>
</span></span><span><span>  }
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span></code></pre></div><p>The <code>candidate</code> function uses <code>lookupMin</code> as discussed.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>candidate</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Partial</span> <span>-&gt;</span> m (<span>Row</span>, <span>Column</span>)
</span></span><span><span><span>candidate</span> partial <span>=</span> <span>do</span>
</span></span><span><span>  <span>-- choose the strategy with the smallest set of candidates</span>
</span></span><span><span>  <span>Strategy</span> s <span>&lt;-</span> <span>case</span> <span>Set</span><span>.</span>lookupMin partial<span>.</span>strategies <span>of</span>
</span></span><span><span>    <span>Just</span> strat <span>-&gt;</span> pure strat
</span></span><span><span>    <span>Nothing</span> <span>-&gt;</span> empty <span>-- no strategies left, fail</span>
</span></span><span><span>    <span>-- choose a queen from the strategy</span>
</span></span><span><span>  choose s
</span></span></code></pre></div><p>When we place a queen at <code>(i, j)</code>, we now need to update the strategies carefully.</p><ol><li>We remove all the strategies which contain <code>(i, j)</code>. They have already been satisfied.</li><li>From each remaining strategy, we remove the cells directly attacked (i.e., the cells in the same row, column, color region, and around the corners) by the queen at <code>(i, j)</code>.</li><li>If some strategy is now empty, we fail.</li></ol><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>placeQueen</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> (<span>Row</span>, <span>Column</span>) <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m <span>Partial</span>
</span></span><span><span><span>placeQueen</span> problem (x, y) partial <span>=</span> <span>do</span>
</span></span><span><span>  <span>-- add a queen to the board</span>
</span></span><span><span>  <span>let</span> newQueens <span>=</span> <span>Set</span><span>.</span>insert (x, y) partial<span>.</span>queens
</span></span><span><span>  <span>-- remove all the strategies which contains the new queen</span>
</span></span><span><span>  <span>let</span> strat1 <span>=</span> <span>Set</span><span>.</span>filter (<span>Set</span><span>.</span>notMember (x, y) <span>.</span> (<span>.</span>unStrategy)) partial<span>.</span>strategies
</span></span><span><span>  <span>-- from each strategy, remove the directly attacked candidates</span>
</span></span><span><span>  <span>let</span> attacked <span>=</span> directlyAttacked (x, y) problem
</span></span><span><span>  <span>let</span> newStrategies <span>=</span> <span>Set</span><span>.</span>map (eliminateFromStrategy attacked) strat1
</span></span><span><span>  <span>-- fail if this makes some strategies empty</span>
</span></span><span><span>  <span>-- then we are out of candidates</span>
</span></span><span><span>  guard <span>$</span> <span>Set</span><span>.</span>notMember (<span>Strategy</span> <span>Set</span><span>.</span>empty) newStrategies
</span></span><span><span>  pure <span>$</span>
</span></span><span><span>    <span>Partial</span>
</span></span><span><span>      { queens <span>=</span> newQueens,
</span></span><span><span>        strategies <span>=</span> newStrategies
</span></span><span><span>      }
</span></span></code></pre></div><p>This simplification gives us a modest performance improvement, and simplifies the code.</p><h3 id="further-optimizations">Further Optimizations</h3><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt6.hs">Source Code for Attempt 6</a></strong>]</p><p>Call a set of candidates <code>X</code> a <strong>coronation</strong> (w.r.t a partial solution <code>p</code>) if every cell in <code>X</code> appears in every completion of <code>p</code>. Each singleton strategy is a coronation. If we take the union of all singleton strategies, we also get a coronation.</p><p>When we have a coronation, we could merge a few executions of <code>solve</code> into one by placing all the queens in the coronation at once. Rather than iteratively filtering candidates in strategies, a lot of the updates and checks can be combined.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>coronation</span> <span>::</span> <span>Partial</span> <span>-&gt;</span> <span>Set</span> (<span>Row</span>, <span>Column</span>)
</span></span><span><span><span>coronation</span> partial <span>=</span> <span>Set</span><span>.</span>unions <span>$</span> <span>Set</span><span>.</span>map (<span>.</span>unStrategy) <span>$</span> <span>Set</span><span>.</span>takeWhileAntitone (<span>\</span>(<span>Strategy</span> s) <span>-&gt;</span> <span>Set</span><span>.</span>size s <span>==</span> <span>1</span>) partial<span>.</span>strategies
</span></span><span><span>
</span></span><span><span><span>solve</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m <span>Partial</span>
</span></span><span><span><span>solve</span> problem partial <span>=</span> <span>do</span>
</span></span><span><span>  <span>let</span> super <span>=</span> coronation partial
</span></span><span><span>  <span>if</span> not <span>$</span> <span>Set</span><span>.</span>null super
</span></span><span><span>    <span>then</span> <span>do</span>
</span></span><span><span>      <span>-- if there are super strategies, place all queens from them</span>
</span></span><span><span>      newPartial <span>&lt;-</span> placeManyQueens problem super partial
</span></span><span><span>      solve problem newPartial
</span></span><span><span>    <span>else</span>
</span></span><span><span>      <span>-- otherwise, continue with the usual candidate selection</span>
</span></span><span><span>      ifte
</span></span><span><span>        (candidate partial)
</span></span><span><span>        ( <span>\</span>pos <span>-&gt;</span> <span>do</span>
</span></span><span><span>            newPartial <span>&lt;-</span> placeQueen pos partial
</span></span><span><span>            solve problem newPartial
</span></span><span><span>        )
</span></span><span><span>        ( <span>do</span>
</span></span><span><span>            <span>-- Completeness: ensure enough queens were placed</span>
</span></span><span><span>            guard <span>$</span> <span>Set</span><span>.</span>size partial<span>.</span>queens <span>==</span> size problem
</span></span><span><span>            pure partial
</span></span><span><span>        )
</span></span><span><span>
</span></span><span><span><span>solution</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> m [(<span>Row</span>, <span>Column</span>)]
</span></span><span><span><span>solution</span> problem <span>=</span> <span>do</span>
</span></span><span><span>  endState <span>&lt;-</span> solve problem (mkPartial problem)
</span></span><span><span>  pure (<span>Set</span><span>.</span>toList endState<span>.</span>queens)
</span></span></code></pre></div><p>Here, we write an explicitly recursive function <code>solve</code>, since we may place more than one queen at a time. Note the use of the <code>ifte</code> from the <code>LogicT</code> library. We cannot do this easily using the usual <code>if _ then _ else</code> construct, since there is no associated <code>Bool</code> to check. In the event that there are no candidates avaiable, we check using the guard if enough queens have been placed.</p><p>By virtue of maintaining soundness, we can guarantee that our algorithm never encounters a partial solution with more than N queens, either. If we did place more than N queens, there would be at least one row (or column, or color region) with more than one queen, violating soundness.</p><p>The function <code>placeManyQueens</code> is similar to <code>placeQueen</code>, except that it handles a set of queens at once. Note that we do have to check whether this set of queens in the coronation is sound, i.e, if they attack each other.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>placeManyQueens</span> <span>::</span> (<span>MonadLogic</span> m) <span>=&gt;</span> <span>Problem</span> <span>-&gt;</span> <span>Set</span> (<span>Row</span>, <span>Column</span>) <span>-&gt;</span> <span>Partial</span> <span>-&gt;</span> m <span>Partial</span>
</span></span><span><span><span>placeManyQueens</span> problem positions partial <span>=</span> <span>do</span>
</span></span><span><span>  <span>-- check if the set is sound</span>
</span></span><span><span>  guard <span>$</span> sound problem positions
</span></span><span><span>  <span>-- remove all the strategies which contains any of the new queens</span>
</span></span><span><span>  <span>let</span> strat1 <span>=</span> <span>Set</span><span>.</span>filter (<span>Set</span><span>.</span>disjoint positions <span>.</span> (<span>.</span>unStrategy)) partial<span>.</span>strategies
</span></span><span><span>  <span>-- from each strategy, remove the directly attacked candidates</span>
</span></span><span><span>  <span>let</span> attacked <span>=</span> <span>Set</span><span>.</span>unions <span>$</span> <span>Set</span><span>.</span>map (partial<span>.</span>directlyAttacked <span>!</span>) positions
</span></span><span><span>  <span>let</span> newStrategies <span>=</span> <span>Set</span><span>.</span>map (eliminateFromStrategy attacked) strat1
</span></span><span><span>  <span>-- fail if this makes some strategies empty</span>
</span></span><span><span>  <span>-- then we are out of candidates</span>
</span></span><span><span>  guard <span>$</span> <span>Set</span><span>.</span>notMember (<span>Strategy</span> <span>Set</span><span>.</span>empty) newStrategies
</span></span><span><span>  pure <span>$</span>
</span></span><span><span>    partial
</span></span><span><span>      { queens <span>=</span> <span>Set</span><span>.</span>union positions partial<span>.</span>queens,
</span></span><span><span>        strategies <span>=</span> newStrategies
</span></span><span><span>      }
</span></span></code></pre></div><p>We use another optimization to speed up the computation of <code>placeQueen</code> and <code>placeManyQueens</code>. We precompute the set of cells directly attacked by each cell in the problem. The type <code>Partial</code> for this version is as follows.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>data</span> <span>Partial</span> <span>=</span> <span>Partial</span>
</span></span><span><span>  { queens <span>::</span> <span>Set</span> (<span>Row</span>, <span>Column</span>),
</span></span><span><span>    strategies <span>::</span> <span>Set</span> <span>Strategy</span>,
</span></span><span><span>    directlyAttacked <span>::</span> <span>Array</span> (<span>Row</span>, <span>Column</span>) (<span>Set</span> (<span>Row</span>, <span>Column</span>))
</span></span><span><span>  }
</span></span><span><span>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</span></span></code></pre></div><p>This version of the code is consistently faster, but the improvement is very small.</p><h3 id="heaps-vs-sets">Heaps vs Sets</h3><p>Strictly speaking, rather than maintaining the strategies in sorted order, we only need to be able to efficiently find the smallest strategy. This is exactly what a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a> does. We can use a heap to maintain the strategies, and use <code>insert</code> and <code>deleteMin</code> to add and remove strategies efficiently.</p><p>We implemented a <a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt5Heap.hs">version of the algorithm</a> using <code>Data.Heap</code> (from the <a href="https://hackage.haskell.org/package/heaps">heaps</a> library). Unfortunately, this version is slightly slower.</p><p>A couple of things we observed about <code>Heap</code> vs <code>Set</code>:</p><ul><li><code>Set</code> automatically deduplicates elements. With <code>Heap</code>, one has to call <code>Heap.nub</code> to remove duplicates.</li><li>A monadic version of <code>map</code>, <code>Heap.mapM</code> is available in the <code>Heap</code> library. In the <code>Set</code> library, there is no <code>Set.mapM</code>. Thus, in <code>Set</code>, we cannot use the pattern of using a guard to fail immediately when we find an empty strategy.</li></ul><h2 id="smt-solvers">SMT Solvers</h2><p>[<strong><a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/SMT.hs">Source Code for SMT Encoding</a></strong>]</p><p>SMT solvers, such as <a href="https://github.com/Z3Prover/z3">Z3</a>, can solve constraint satisfaction problems involving a number of domains (called <em>theories</em>) including boolean logic, arithmetic, and arrays. Using the <a href="https://hackage.haskell.org/package/sbv">sbv</a> library, we can encode our problem as constraints for Z3 in a straightforward manner.</p><p>We pick <code>N</code> symbolic integers. The <code>i</code>-th integer represents the column <code>j</code> in which the queen of row <code>i</code> is placed. The constraints can be exressed as follows:</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>-- for each row, the column where the queen is placed</span>
</span></span><span><span><span>-- ranges from 0 to n-1</span>
</span></span><span><span><span>rangeConstraints</span> <span>::</span> [<span>SInteger</span>] <span>-&gt;</span> <span>SBool</span>
</span></span><span><span><span>rangeConstraints</span> js <span>=</span> sAll (<span>\</span>y <span>-&gt;</span> y <span>.&gt;=</span> <span>0</span> <span>.&amp;&amp;</span> y <span>.&lt;</span> n) js
</span></span><span><span>  <span>where</span>
</span></span><span><span>    n <span>=</span> fromIntegral <span>$</span> length js
</span></span><span><span>
</span></span><span><span><span>-- no two queens are in the same column</span>
</span></span><span><span><span>columnConstraints</span> <span>::</span> [<span>SInteger</span>] <span>-&gt;</span> <span>SBool</span>
</span></span><span><span><span>columnConstraints</span> js <span>=</span> 
</span></span><span><span>  sAll 
</span></span><span><span>    (<span>\</span>(a, b) <span>-&gt;</span> a <span>./=</span> b) 
</span></span><span><span>    [(a, b) <span>|</span> (i, a) <span>&lt;-</span> zip [(<span>0</span> <span>::</span> <span>Int</span>) <span>..</span>] js, (j, b) <span>&lt;-</span> zip [<span>0</span> <span>..</span>] js, i <span>&lt;</span> j]
</span></span><span><span>
</span></span><span><span><span>-- no two queens are touching corners</span>
</span></span><span><span><span>-- queen[i] - queen[i+1] != 1 or -1</span>
</span></span><span><span><span>cornerConstraints</span> <span>::</span> [<span>SInteger</span>] <span>-&gt;</span> <span>SBool</span>
</span></span><span><span><span>cornerConstraints</span> js <span>=</span>
</span></span><span><span>  sAll
</span></span><span><span>    (<span>\</span>(a, b) <span>-&gt;</span> a <span>-</span> b <span>./=</span> <span>1</span> <span>.&amp;&amp;</span> a <span>-</span> b <span>./=</span> <span>-</span><span>1</span>)
</span></span><span><span>    [(a, b) <span>|</span> (a, b) <span>&lt;-</span> zip js (drop <span>1</span> js)]
</span></span><span><span>
</span></span><span><span><span>-- no two queens are in the same color region</span>
</span></span><span><span><span>-- for each pair of cells (i, j) and (k, l),</span>
</span></span><span><span><span>-- color ! (i, j) == color ! (k, l) ==&gt; not (queen[i] = j &amp;&amp; queen[k] = l)</span>
</span></span><span><span><span>colorConstraints</span> <span>::</span> <span>Problem</span> <span>-&gt;</span> [<span>SInteger</span>] <span>-&gt;</span> <span>SBool</span>
</span></span><span><span><span>colorConstraints</span> problem queens <span>=</span> 
</span></span><span><span>    sAll 
</span></span><span><span>      f 
</span></span><span><span>      [(i, j, k, l) <span>|</span> 
</span></span><span><span>        i <span>&lt;-</span> [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>], 
</span></span><span><span>        j <span>&lt;-</span> [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>], 
</span></span><span><span>        k <span>&lt;-</span> [i <span>..</span> n <span>-</span> <span>1</span>], 
</span></span><span><span>        l <span>&lt;-</span> [<span>0</span> <span>..</span> n <span>-</span> <span>1</span>], 
</span></span><span><span>        (i <span>/=</span> k <span>||</span> j <span>&lt;</span> l)]
</span></span><span><span>  <span>where</span>
</span></span><span><span>    n <span>=</span> size problem
</span></span><span><span>    f (i, j, k, l) <span>=</span> 
</span></span><span><span>      (fromBool <span>$</span> problem <span>!</span> (i, j) <span>==</span> problem <span>!</span> (k, l)) 
</span></span><span><span>        <span>.=&gt;</span> sNot (queens <span>!!</span> i <span>.==</span> fromIntegral j <span>.&amp;&amp;</span> queens <span>!!</span> k <span>.==</span> fromIntegral l)
</span></span></code></pre></div><p>We observe that our solution is orders of magnitude faster than calling the SMT solver. However, it is instructive to keep in mind that our benchmark includes the time it takes to compute the constraints, do interprocess communication with <code>z3</code>, and so on. As suggested by the blogpost involving approaching this problem with <a href="https://zayenz.se/blog/post/linkedin-queens/">MiniZinc</a>, the actual solving time is much smaller.</p><h2 id="benchmarks">Benchmarks</h2><p>We ran our benchmarks using the <a href="https://hackage.haskell.org/package/tasty-bench">tasty-bench</a> library. For the two problems discussed above, the time taken are as follows.</p><table><thead><tr><th>Problem</th><th>Attempt 0</th><th>Attempt 1</th><th>Attempt 2</th><th>Attempt 3</th><th>Attempt 4</th><th>Attempt 5 (Heap)</th><th>Attempt 5 (Set)</th><th>Attempt 6</th><th>SMT Solver (Z3)</th></tr></thead><tbody><tr><td><strong>Problem 1</strong></td><td>17.6 ms</td><td>19.1 μs</td><td>21.7 μs</td><td>20.0 μs</td><td>20.5 μs</td><td>22.3 μs</td><td>11.7 μs</td><td>10.8 μs</td><td>5.18 ms</td></tr><tr><td><strong>Problem 2</strong></td><td>-</td><td>17.057 s</td><td>193 ms</td><td>172 ms</td><td>65.5 μs</td><td>101 μs</td><td>52.2 μs</td><td>48.6 μs</td><td>13.4 ms</td></tr></tbody></table><p>Next, we benchmarked our code on the <a href="https://github.com/samimsu/queens-game-linkedin/tree/main/src/utils/levels">puzzles</a> available in the <a href="https://queensgame.vercel.app/">community version</a> of the game. They contain puzzles of board sizes ranging from 7 to 11. We ran our algorithms on all puzzles of size <code>N</code> at a time. The times shown are the average time taken to solve a puzzle of size <code>N</code>. For some of the entries in the table, we timed out. This means that completing <em>all</em> the problems together and doing them multiple times as required by <code>tasty-bench</code> took more than 60 seconds.</p><table><thead><tr><th>Size</th><th>Attempt 1</th><th>Attempt 2</th><th>Attempt 3</th><th>Attempt 4</th><th>Attempt 5 (Heap)</th><th>Attempt 5 (Set)</th><th>Attempt 6</th><th>SMT Solver (Z3)</th></tr></thead><tbody><tr><td><strong>7</strong> (48 problems)</td><td>269.66 ms</td><td>5.15 ms</td><td>4.75 ms</td><td>189 μs</td><td>214 μs</td><td>168 μs</td><td>159 μs</td><td>11.02 ms</td></tr><tr><td><strong>8</strong> (145 problems)</td><td>-</td><td>81.11 ms</td><td>72.12 ms</td><td>197 μs</td><td>269 μs</td><td>166 μs</td><td>152 μs</td><td>20.62 ms</td></tr><tr><td><strong>9</strong> (137 problems)</td><td>-</td><td>-</td><td>-</td><td>310 μs</td><td>448 μs</td><td>275 μs</td><td>243 μs</td><td>32.03 ms</td></tr><tr><td><strong>10</strong> (60 problems)</td><td>-</td><td>-</td><td>-</td><td>463 μs</td><td>664 μs</td><td>430 μs</td><td>376 μs</td><td>51 ms</td></tr><tr><td><strong>11</strong> (17 problems)</td><td>-</td><td>-</td><td>-</td><td>682 μs</td><td>900 μs</td><td>652 μs</td><td>605 μs</td><td>67 ms</td></tr></tbody></table><h2 id="conclusion">Conclusion</h2><p>This is an instance of a <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">constraint-satisfaction problem</a>, similar to other puzzles like Sudoku, or the original N-Queens. This is what makes them a great candidate for solution via SAT or SMT solvers, as noted by <a href="https://ryanberger.me/posts/queens/">previous</a> <a href="https://buttondown.com/hillelwayne/archive/solving-linkedin-queens-with-smt/">bloggers</a>. There are a few knobs we can tweak to make our algorithm perform better:</p><ul><li>How do we decide where to place the next queen?</li><li>When there are multiple options to do so, in which order do we explore them?</li><li>How can we quickly decide that a partial solution cannot be extended to a full solution?</li></ul><p>Furthermore, computing each of the heuristics above can be expensive. Therefore, we have to strike a balance between the time spent on computing sophisticated heuriststics, and the time spent on actually exploring the search tree.</p><p>In the general case, these problems can be <a href="https://en.wikipedia.org/wiki/List_of_NP-complete_problems#Games_and_puzzles">very hard</a> to solve. However, we can hope that the instances which appear on LinkedIn would be easier. Since these puzzles would be supposed to be enjoyable for humans, there are likely reasonable heuristics one can pick to solve them. In particular, if we do so, we can hope to detect bad branches early, and backtrack quickly.</p><p>We obtained a solution which is <a href="https://github.com/Agnishom/linkedin-queens/blob/main/src/Attempt5Set.hs">less than 150 lines of Haskell</a>, and is arguably quite fast. We have heavily used <code>Set</code> and <code>Map</code>, which are <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structures</a>, making it easy to access ‘older’ versions of our computation state, when we backtrack.</p></div></div>
  </body>
</html>
