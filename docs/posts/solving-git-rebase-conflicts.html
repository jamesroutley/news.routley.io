<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://onestepcode.com/solving-git-rebase-conflicts/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=solving-git-rebase-conflicts">Original</a>
    <h1>Solving git rebase conflicts</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>Let’s see how to solve merge conflicts that may arise when applying <code>git rebase</code>.</p>



<h2>Why <code>git rebase</code>?</h2>



<p>One of the main uses of <code><a href="https://git-scm.com/docs/git-rebase">git rebase</a></code> is to keep a linear commit history. Let’s say that you branch off of <code>master</code> and make new modifications in the new branch <code>feature</code>. During this process, new changes could be added to <code>master</code>.</p>



<p>In the example below, we created the branch <code>feature</code> at commit <code>initial commit</code>. We submitted two commits to the feature branch. Meanwhile, <code>master</code> has diverged from its initial state and was added a new commit: <code>master: new commit</code>.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">* e6b1706 (HEAD -&gt; master) master: new commit
| * d05f6db (feature) feature: second commit
| * f787560 feature: first commit
|/  
* f578e2b initial commit</pre>



<p>If we wanted to merge <code>feature</code> into <code>mater</code>, we would get the following commit history:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">*   e03514e (HEAD -&gt; master) Merge branch &#39;feature&#39;
|\  
| * d05f6db (feature) feature: second commit
| * f787560 feature: first commit
* | e6b1706 master: new commit
|/  
* f578e2b initial commit</pre>



<p>This commit history isn’t very clear. Specially if <code>master</code> has diverged too much from the branch point of <code>feature</code>.</p>



<h2>A linear commit history</h2>



<p>Let’s go back to our previous example, right before merging <code>feature</code> into <code>master</code>.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">* e6b1706 (HEAD -&gt; master) master: new commit
| * d05f6db (feature) feature: second commit
| * f787560 feature: first commit
|/  
* f578e2b initial commit</pre>



<p>We can <code>rebase</code> the feature branch to achieve a linear commit history when merging.</p>



<p>What <code>git rebase</code> does is to move all of the commits in <code>feature</code> to a new base commit. In this case, we want to change the <code>feature</code> base to <code>master</code>‘s current reference (<code>e6b1706</code>). We can do so with the following command.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ git rebase master feature</pre>



<p>Or:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ git rebase master</pre>



<p>If the current branch is <code>feature</code>.</p>



<p>After doing so, the new commit history will look as follows:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">* 1c4b251 (HEAD -&gt; feature) feature: second commit
* b7c3fbb feature: first commit
* e6b1706 (master) master: new commit
* f578e2b initial commit</pre>



<p> <code>feature</code> now branches off of <code>master</code>‘s most recent commit.</p>



<p>If we merge <code>feature</code> to <code>master</code> (using the  <code>--no-ff</code> option), we’ll get the following commit history:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">*   5f2d014 (HEAD -&gt; master) Merge branch &#39;feature&#39;
|\  
| * 1c4b251 (feature) feature: second commit
| * b7c3fbb feature: first commit
|/  
* e6b1706 master: new commit
* f578e2b initial commit</pre>



<p>This commit history is much clearer. Additionally, if a bug was introduced during merging, we can be sure that it was introduced by the commits in  <code>feature</code>. Without a linear commit history, we don’t know if the bug was introduced by the <code>feature</code> branch or by the commit <code>e6b1706</code>:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">*   e03514e (HEAD -&gt; master) Merge branch &#39;feature&#39;
|\  
| * d05f6db (feature) feature: second commit
| * f787560 feature: first commit
* | e6b1706 master: new commit
|/  
* f578e2b initial commit</pre>



<h2><code>git rebase</code> merge conflicts</h2>



<p>While it’s great to have a linear commit history, we can run across merge conflicts when running <code>git rebase</code>. Let’s see an example.</p>



<p>We start on branch <code>master</code> that contains file <code>mycode</code> with the following content and commit history:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// mycode
a
</pre>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">* f578e2b (HEAD -&gt; master) initial commit</pre>



<p>Next, we create the new branch <code>feature</code> and modify <code>mycode</code> with the following changes.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// mycode
a
b
c</pre>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">* d05f6db (feature) feature: second commit
* f787560 feature: first commit 
* f578e2b (master) initial commit</pre>



<p>The second line <code>b</code> was added by commit <code>f787560</code> and <code>c</code> was added by commit <code>d05f6db</code>. At this point, we’re ready to merge!</p>



<p>However, during that period a co-worker has submitted new changes to <code>master</code>, modifying <code>mycode</code>:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// mycode
a
aa</pre>



<p>The commit history now looks like so:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">* e6b1706 (HEAD -&gt; master) master: new commit
| * d05f6db (feature) feature: second commit
| * f787560 feature: first commit
|/  
* f578e2b initial commit</pre>



<p>When trying to rebase, we’ll get a conflict message.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ git rebase master feature
Auto-merging file
CONFLICT (content): Merge conflict in mycode
error: could not apply f787560... feature: first commit</pre>



<p>What happened here is that both <code>master</code>  and <code>feature</code> added modifications to the same part of <code>mycode</code> and git does not know which modification to choose. Rebase applies all commits that were present in <code>feature</code> to a new branch with base <code>master</code>. In case of conflict, the process is halted before applying the conflicting commit.</p>



<p>Opening file <code>mycode</code> we’ll see its contents have changed:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// mycode
a
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
aa
=======
b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; f787560 (feature: first commit)</pre>



<p>It may look a bit cryptical at first, but it’s quite simple. The current state of the conflicting portion of <code>mycode</code> starts just after <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> and continues all the way down to <code>=======</code>. Below the <code>=</code> line and all the way down to <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; f787560</code>, we have the new changes that <code>git rebase</code> wants to apply. </p>



<p>Basically, git is asking, <em>which modification should I choose </em><code>aa</code> <em>or </em><code>b</code><em>?</em></p>



<p>The answer depends on what you want your code to do. Maybe we have to choose either <code>aa</code> or <code>b</code>. Or maybe we want both to coexist. </p>



<p>Let’s imagine we want to keep <code>aa</code>, but we need to modify <code>b</code> to <code>bb</code> to be compatible with it. To resolve the conflict, we need to erase all of the lines added by git and then leave <code>mycode</code> in the state that we want.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// mycode
a
aa
bb</pre>



<p>After that’s done, be sure to save the new changes to <code>mycode</code>. Then, we run <code>git commit -a</code>. </p>



<p>What we’re doing here is applying a new commit instead of the conflicting commit <code>f787560</code>. We can lave the commit message as it was or modify it to reflect the new changes.</p>



<p>  Once that’s done, the rebase operation can be resumed by running <code>git rebase --continue</code>. </p>



<p>The rebase operation will apply the new commit that we just created and continue with the remaining commits that we had in <code>feature</code>.</p>



<p>New merge conflicts may arise, and they are solved in the same way. This process is continued until you see a successful rebase message:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ git rebase --continue
Successfully rebased and updated refs/heads/feature.</pre>



<h2>Verifying changes and modifications with <code>git range-diff</code></h2>



<p>A handy command to check how the commits changed after the rebase operation is <code><a href="https://git-scm.com/docs/git-range-diff">git range-diff</a></code>:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">$ git range-diff feature@{1}...feature</pre>



<p><code><a href="https://git-scm.com/docs/gitrevisions#Documentation/gitrevisions.txt-emltrefnamegtltngtemegemmaster1em">feature@{1}</a></code> is the previous reference of <code>feature</code> (that is, before rebasing). It is compared to the current reference of <code>feature</code>. </p>



<p>The output displays how the commits between both references differ:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">1:  f787560 &lt; -:  ------- feature: first commit
2:  d05f6db &lt; -:  ------- feature: second commit
-:  ------- &gt; 1:  9ab5dc4 master: new commit
-:  ------- &gt; 2:  b1c4fd1 feature: first commit
-:  ------- &gt; 3:  34a3583 feature: second commit
</pre>



<p>In this case, it shows that the two original commits have been replaced. </p>



<p>In the hypothetical case that the rebase operation had not raised any conflicts, the output would look like so:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">-:  ------- &gt; 1:  020882b master: new commit
1:  f787560 = 2:  1091dbd feature: first commit
2:  d05f6db = 3:  8e94b28 feature: second commit
</pre>



<p>This is very helpful because it verifies for us that the two commits that were part of the <code>feature</code> branch did not change after the rebase operation. Or, in case of changes, it shows us how they are different.</p>
					</div></div>
  </body>
</html>
