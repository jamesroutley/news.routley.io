<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tratt.net/laurie/blog/2022/making_rust_a_better_fit_for_cheri_and_other_platforms.html">Original</a>
    <h1>Making Rust a Better Fit for Cheri and Other Platforms</h1>
    
    <div id="readability-page-1" class="page"><div id="article-body"><p>



Recently, Aria Beingessner published an interesting essay &#34;<a href="https://gankra.github.io/blah/fix-rust-pointers/">Rust&#39;s Unsafe Pointer
Types Need An Overhaul</a>&#34;. There are several parts to this essay, all of
which address issues which cause me pain in Rust, and which I would love to see
fixed. I want to focus on one issue: Rust&#39;s <code>usize</code> conflates
address, data, and object widths into a single static type. While this conflation is
unproblematic on many major platforms, it causes problems on others such as <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a>. In my
essay from last year on <a href="https://tratt.net/laurie/essays/entries/static_integer_types.html">static integer
types</a>, I went into some depth on this, and you might find the motivation
therein a useful additional explainer to Aria&#39;s essay.

</p><p>The basic problem with Rust and CHERI is that <em>capabilities</em> –
think &#34;an address alongside additional data&#34; – require additional room
over traditional pointers, which contain just an address. Modern CHERI
capabilities are typically twice the width of what is often called the &#34;native machine
word size&#34;. However, Rust&#39;s integer type hierarchy mandates that
<code>usize</code> must be wide enough to allow any pointer type to be cast
into it without information loss. That means that the obvious way of making
Rust work with CHERI is to double the width of <code>usize</code> so that
capabilities can be cast to a <code>usize</code> — but this wastes 50% of
bits when <code>usize</code> is used to represent sizes or addresses alone.

</p><p>Aria then makes an intriguing suggestion for how to push Rust in the right
direction. The basic idea is to: break the link between pointers and
<code>usize</code> so one can not directly cast 
between the two; make <code>*mut ()</code> the root of the integer/pointer part
of the type system (in other words, as well as being a pointer type, <code>*mut ()</code> also serves roughly the
same purpose as C&#39;s <code>uintptr_t</code>); and to make the address portion of a pointer a
<code>usize</code> to allow bit-fiddling operations on that portion. On common
platforms (e.g. x86_64) this scheme makes everything work much as it does now, but on
systems like CHERI, pointers can now be wider than <code>usize</code>.

</p><p>There are several clever aspects of this proposal. Most importantly,
the proposal is pragmatic: it allows Rust to support more hardware platforms
,
but does so in a way that doesn&#39;t require radical changes. By
breaking the link between <code>usize</code> and pointers, it makes issues
around pointer provenance simpler to think about. It also provides a
plausible migration path for existing Rust code. In essence, one would first
add deprecation warnings to casts, so that code like <code>0x12345678 as
*const()</code> will become a warning (I think one would also need to do the
same for at least <code>transmute</code>). This would allow people to
systematically identify many of the major parts of their code where
now-incorrect assumptions about pointers and <code>usize</code> are made.
A future Rust edition would then make such casts a hard error and
formally break the link between <code>usize</code> and pointers in the
language&#39;s semantics. Any code opting into that edition  would have to respect those new semantics or be at
risk of entering the badlands of undefined behaviour.

</p><p>It&#39;s important to note that the cast warnings (or errors) are not enough on
their own to help make code correct: additional auditing will be required.
However, at the very least, this will give programmers
a good idea of where to start auditing their code . Some people might choose not to adapt their code, or find it too
difficult to do so, but my guess is that most people will choose to do so.

</p><p>However, I don&#39;t think Aria&#39;s proposal is quite the end of the road for two
minor, and one major, reasons.

</p><p>The first minor reason is that on a platform like CHERI one needs to be able
to access the non-address parts of a pointer. CHERI&#39;s C API provides various
accessor functions which give access to these bits (e.g. <code>cheri_length_get</code> returns
the number of bytes of memory a capability can access), and Rust will also need
to provide similar methods for CHERI . Although
it&#39;s a niche use case I also think that to fully support techniques like pointer
tagging  the new <code>*mut ()</code> API
needs to provide methods which give raw access to loading and storing the non-address bits
of a pointer. A problem with this is that, by definition, the number of
non-address bits is platform specific. Perhaps the easiest way is to allow the
loading / storing of an
array of <code>usize</code> where the size of the array is a compile-time
constant along the lines of <code>load_non_addr(&amp;self) -&gt; [usize;
NON_ADDR_USIZES]</code> . On, say, x86, <code>NON_ADDR_USIZE</code> would
be 0; on pure capability CHERI (more on that below...) it would be 1. The
challenge for this API on CHERI is that storing all the non-address bits will
invalidate the capability, which sometimes one will be OK with, but not
always. That suggests that one might also want to expose a way of saying
something like &#34;store as many non-address bits as possible without
invalidating the capability.&#34; I must admit that I&#39;m not immediately sure
what a good API for that might look like.

</p><p>The second minor reason is that CHERI capabilities are not contiguous in
memory. For example on Morello (CHERI for Arm), addresses are 64 bits, but
capabilities are conceptually 129 bits — the &#34;extra&#34; bit simply confirms
whether the &#34;main&#34; 128 bits form a valid capability or not . This validity bit is stored somewhere secret by the hardware:
you can read it (indirectly), but you can never set it. Fortunately, because the
validity bit can&#39;t be set, it means that we don&#39;t have to worry about pointer
tagging schemes having access to the bit, so the final sentence of the
preceding paragraph is safe. That means that all that Rust-for-CHERI would
need to add to <code>*mut ()</code> is a <code>is_valid() -&gt; bool</code> method.

</p><p>The major issue is, in my opinion, much more surprising. In essence,
most (all?) CHERI devices allow traditional (single width) pointers
to be used alongside (double width) capabilities. Conventionally a
program which uses only capabilities is said to be compiled and
running in &#34;pure capability mode&#34; while a program which uses both
traditional pointers and capabilities is said to be compiled and
running in &#34;hybrid mode&#34; . Most discussion
around CHERI presupposes pure capability mode, but the lesser known hybrid mode
has many uses . Hybrid mode does,
however, mean that we can no longer assume that all pointers are capabilities.

</p><p>Fortunately, I believe that Aria&#39;s proposal can be adapted such that a Rust-for-CHERI
can cope with both pure capability and hybrid modes. In essence, one needs explicit, separate, types for
both traditional pointers and capabilities. <code>*mut ()</code> suffices for the
former and a wrapper of some sort, e.g. <code>Cap&lt;*mut ()&gt;</code> for the
latter. Conceptually this means that <code>*mut ()</code> is no longer the root
of the integer/pointer type system, because one cannot convert <code>Cap&lt;*mut
()&gt;</code> to <code>*mut ()</code> without losing information (the
capability&#39;s extra bits). My gut feeling is that
in practice, most code can treat <code>*mut ()</code> as the root of the
integer/pointer type system, and only code which really cares about capabilities need
know of <code>Cap</code>&#39;s existence. An additional nice property is
that one will be able to write Rust code in a way that can be agnostic about pure
capability mode (where <code>size_of::&lt;*mut ()&gt;() ==
size_of::&lt;Cap&lt;*mut ()&gt;&gt;()</code>) and hybrid mode (where
<code>size_of::&lt;*mut ()&gt;() &lt; size_of::&lt;Cap&lt;*mut ()&gt;&gt;()</code>).

</p><p>There are a number of different ways one might design the resulting API,
and while I&#39;ve sketched out several in my mind, I&#39;m not going to pretend that
I&#39;ve fully thought through all the trade-offs of each. A high-level version of the
API that I&#39;m currently inclined towards looks as follows. On all platforms (CHERI and
non-CHERI):

</p><pre>impl&lt;T: ?Sized&gt; *mut T {
  // These two methods as per Aria&#39;s proposal
  fn addr(self) -&gt; usize;
  fn with_addr(self, addr: usize) -&gt; Self;

  // Allow access to the non-address parts of a pointer.
  // PTR_NON_ADDR_USIZES is a constant (e.g. x86_64: 0, AArch64: 0,
  //   CHERI hybrid: 0, CHERI pure cap: 1)
  fn non_addr(self) -&gt; [usize; PTR_NON_ADDR_USIZES];
  fn with_non_addr(self, non_addr: [usize; PTR_NON_ADDR_USIZES] -&gt; Self;
}
</pre><p>

On Rust-for-CHERI (both pure capability and hybrid modes) additionally
an explicit wrapper for capabilities:

</p><pre>// A wrapper type for capabilities, only on Rust-for-CHERI.
#[derive(Clone, Copy)]
struct Cap&lt;T&gt; {
  cap: u128, // Assuming 128 (well, 129...) bit capabilities
  phantom: PhantomData&lt;T&gt;
}

impl&lt;T: ?Sized&gt; Cap&lt;*mut T&gt; {
  // These two methods as per Aria&#39;s proposal
  fn addr(self) -&gt; usize;
  fn with_addr(self, addr: usize) -&gt; Self;

  // Allow access to the non-address parts of a capability.
  // CAP_NON_ADDR_USIZES is a constant (1 on most CHERI devices).
  fn non_addr(self) -&gt; [usize; CAP_NON_ADDR_USIZES];
  fn with_non_addr(self, non_addr: [usize; CAP_NON_ADDR_USIZES] -&gt; Self;

  fn is_valid(self) -&gt; bool; // Is this capability valid?
  fn bounds_len(self) -&gt; usize; // How many bytes do the bounds span?
}
</pre><p>

We then need a mechanism for casting pointers to capabilities. Additionally in
pure capability mode we trivially add a method which is effectively a
non-bit-changing transmute:

</p><pre>impl&lt;T: ?Sized&gt; *mut T {
  fn as_cap(self) -&gt; Cap&lt;*mut T&gt;;
}
</pre><p>

However in hybrid mode, where do the extra capability bits come from? For
example, casting from <code>void *</code> to <code>void * __capability</code>
in CHERI hybrid C takes capability provenance from the global DDC register, but you might
perhaps want to take capability provenance from a different capability. I would
prefer the user to have to specify which capability those extra bits fome
from, meaning that the following method would additionally be available
in both pure capability and hybrid modes:

</p><pre>impl&lt;T: ?Sized&gt; *mut T {
  fn as_cap_with_perms_from(self, othercap: Cap&lt;*mut ()&gt;) -&gt; Cap&lt;*mut T&gt;;
}
</pre><p>

I&#39;m not going to pretend that this API is perfect (e.g. should there be
separate <code>Cap</code> and <code>CapMut</code> wrappers? what are the
provenance implications if we cast a capability into a <code>u128</code>?), but
I hope it gives a rough idea of what might be possible.

</p><p>There is also another implication in some of what I&#39;ve written above, and it&#39;s
contained in the awkward &#34;Rust-for-CHERI&#34; name. I think Aria&#39;s proposal (with
the first minor tweak I suggested above) is an unqualified improvement on
existing Rust and benefits all platforms. However, the
<code>Cap&lt;...&gt;</code> wrapper is something quite specific to CHERI:
because of the (minor but noticeable)
complexity it adds to the language, I&#39;m not sure every Rust programmer should
be forced to know of its existence. That implies that there might be a
fork or conditionally compiled version of <code>rustc</code> that
exposes this feature only when producing a compiler for CHERI&#39;s hybrid mode.
There is, though, a disadvantage to this: library authors who want to do
something clever for CHERI&#39;s hybrid mode will also have to conditionally
compile all references to <code>Cap&lt;...&gt;</code>. Exactly what the right
trade-off would be I&#39;m unsure.

</p><p>In summary, I think that Aria&#39;s proposal will make Rust a better target for
a variety of platforms, including CHERI. With some additional tweaks, it can
support both of CHERI&#39;s modes. My suggestions above are one possible way of
doing so, but there are definitely other, possibly better, ways of achieving
the same outcome.

</p><p><b>Acknowledgements</b>: Thanks to Jacob Bramley for many ideas and
comments. Any errors and infelicities are my own.

</p>



<h3>Footnotes</h3>
<table>
<tbody><tr><td><a name="83810137">[1]</a></td><td>
I think <code>as</code> style casting Rust is unfortunate and I&#39;d prefer it was
removed entirely, but that&#39;s perhaps a more general point!
</td></tr>
<tr><td><a name="34013334">[2]</a></td><td>
Altering Rust to support the same variety of platforms that C does is, I
believe, infeasible: it would require such radical changes to the language that
they would stand no chance of being accepted. As I said in the <a href="https://tratt.net/laurie/essays/entries/static_integer_types.html">static integer
types</a> essay, my belief is that unless one thinks about these things early
in a language&#39;s design, it&#39;s not possible to fully fix them later without
breaking too much code in too many subtle ways.
</td></tr>
<tr><td><a name="84544495">[3]</a></td><td>
I can see reasonable arguments for making the cast
warnings part of an existing edition (so the &#34;full&#34; change can happen in the
next edition), or part of a future edition (so the &#34;full&#34; change takes at least
two editions), but I consider this a minor issue either way.
</td></tr>
<tr><td><a name="75014263">[4]</a></td><td>
To some extent I&#39;m feeling slightly smug about this, as I&#39;ve long believed that
Rust&#39;s <code>usize</code> assumptions were unfortunate — I&#39;ve embedded
lots of static and dynamic assertions in code I&#39;ve written in case this
assumption is changed. However, I&#39;m feeling slightly less smug than I&#39;d like,
because my experience is that the sort of code that embeds such assumption is
invariably much more fiddly than average, with extensive use of
<code>unsafe</code>. I guarantee that I&#39;ve missed some assertions and that I&#39;ll
make some subtle mistakes when adapting it.
</td></tr>
<tr><td><a name="63531965">[5]</a></td><td>
My experience is that CHERI&#39;s current standard C API is rather confusing for
newcomers: it might be possible to tidy this up a bit in a Rust context.
</td></tr>
<tr><td><a name="13762670">[6]</a></td><td>
One doesn&#39;t necessarily have to actually tag a pointer, but the term &#34;pointer
tagging&#34; is so commonly used that there&#39;s little point fighting against it.
</td></tr>
<tr><td><a name="78056211">[7]</a></td><td>
Using this approach, it would also be easy to allow access to <em>all</em> the
bits of a pointer (address and non-address) in one go.
</td></tr>
<tr><td><a name="86706471">[8]</a></td><td>
Unfortunately CHERI calls this the &#34;tag&#34; bit, which confuses people in the
context of &#34;pointer tagging&#34;. I&#39;m hoping the community will call it the
&#34;validity&#34; bit (or something similar).
</td></tr>
<tr><td><a name="38725886">[9]</a></td><td>
I&#39;m choosing my terms as carefully as I can because, in a sense, &#34;pure
capability&#34; and &#34;hybrid&#34; modes are a fiction. They have implications for things
like the size of pointer and integer types, which is why there are two CHERI C
compilers, one for &#34;purecap&#34; and another for &#34;hybrid&#34;.

<p>Different CHERI processors might then run programs in special or generic
modes. For example, Morello can run in either: A64 mode, with a mostly
traditional Arm instruction set, and normal width pointers; or C64 mode, with a
CHERIfied instruction set, and double width capabilities. Not only can you
switch the entire processor from A64 to C64 mode on-the-fly, but in A64 mode
you can access double width capabilities alongside normal width pointers (e.g.
A64 mode not only allows access to traditional 64-bit registers but also the
processors&#39;s capability 129-bit registers), and in C64 mode you can access
normal pointers. Morello&#39;s two modes have different trade-offs, but as this
might suggest, the distinction between pure capability and hybrid modes is more
fluid than it may at first seem.
</p></td></tr>
<tr><td><a name="46756324">[10]</a></td><td>
The &#34;obvious&#34; use case is to make it possible to run existing systems on a
CHERI system without fully porting them to full capabilities. Personally I
think a more important use case is that you can use special registers (e.g.
the DDC and PCC) to create sub-process like compartments on code running in
non-capability mode: this concept has only partly been explored in existing
work, and I think there&#39;s going to be a lot of mileage in exploring it further.

<p>In the context of Rust, it&#39;s also worth asking whether it&#39;s worth making
<em>all</em> pointers double width (which, though perhaps small, will
undoubtedly have measurable memory and performance costs). After all, most Rust
code is safe, and the compiler can guarantee that pointers can&#39;t be easily
misused for things like buffer overruns. Rather, I see the main utility for a
language like Rust being to impose various &#34;sub-process&#34; like compartments,
with only relatively small portions of the code needing to use capabilities explicitly.
</p></td></tr></tbody></table>


<h3>Comments</h3>



</div></div>
  </body>
</html>
