<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/clibraries/array-algorithms">Original</a>
    <h1>A header-only C implementation of C&#43;&#43; &lt;algorithm&gt;</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Unintrusive algorithms for C arrays OR a C implementation of &lt;algorithm&gt; from C++</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-pitch" aria-hidden="true" href="#pitch"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Pitch</h2>
<p dir="auto">The C++ STL is one of the most complete and reusable algorithm libraries available.
This single header file brings 80% of that functionality to C99 in a non-intrusive way.
There are no new data structures. Just include the library and call functions on C arrays.</p>
<p dir="auto">Features:</p>
<ul dir="auto">
<li>Sets (intersection, union, subset, etc)</li>
<li>Heaps (priority queues)</li>
<li>Binary search (lower bound, upper bound, etc)</li>
<li>Sorts (insertion sort, quick sort, merge/stable sort, heap sort, partial sort, etc)</li>
<li>Partitioning (partition, unique, etc)</li>
<li>Predicates (all of, any of, none of, etc)</li>
<li>Uniform random sampling and shuffling</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">This library uses the preprocessor to implement generic functions.
Each time you include the library, you will need to define the array element type and a function prefix:</p>
<div data-snippet-clipboard-copy-content="#define ARRAY_ALG_TYPE int
#define ARRAY_ALG_PREFIX intv_
#include &#34;array_alg.h&#34;"><pre><code>#define ARRAY_ALG_TYPE int
#define ARRAY_ALG_PREFIX intv_
#include &#34;array_alg.h&#34;
</code></pre></div>
<p dir="auto">The above will only generate the declarations.
In at least one C file, you will also need to generate implementations.
To generate implementations, define <code>ARRAY_ALG_IMPLEMENTATION</code> in a C file and include the library:</p>
<div data-snippet-clipboard-copy-content="#define ARRAY_ALG_TYPE int
#define ARRAY_ALG_PREFIX intv_
#define ARRAY_ALG_IMPLEMENTATION
#include &#34;array_alg.h&#34;"><pre><code>#define ARRAY_ALG_TYPE int
#define ARRAY_ALG_PREFIX intv_
#define ARRAY_ALG_IMPLEMENTATION
#include &#34;array_alg.h&#34;
</code></pre></div>
<p dir="auto">Alternatively, add <code>#define ARRAY_ALG_STATIC</code> before the original declaration
to avoid the need for separate implementations.</p>
<p dir="auto">Repeat this process for each array type you want to use.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">Remove duplicate entries:</p>
<div data-snippet-clipboard-copy-content="#define ARRAY_ALG_TYPE int
#define ARRAY_ALG_PREFIX intv_
#include &#34;array_alg.h&#34;

int compare_int(const int *a, const int *b, void *ctx) {
    return *a - *b;
}

...

int nums[100] = ...;
intv_sort(nums, nums + 100, compare_int, NULL);
int* end = intv_unique(nums, nums + 100, compare_int, NULL);"><pre><code>#define ARRAY_ALG_TYPE int
#define ARRAY_ALG_PREFIX intv_
#include &#34;array_alg.h&#34;

int compare_int(const int *a, const int *b, void *ctx) {
    return *a - *b;
}

...

int nums[100] = ...;
intv_sort(nums, nums + 100, compare_int, NULL);
int* end = intv_unique(nums, nums + 100, compare_int, NULL);
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-design" aria-hidden="true" href="#design"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Design</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-1-iterators-and-arrays" aria-hidden="true" href="#1-iterators-and-arrays"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>1. Iterators and Arrays</h3>
<p dir="auto">The C++ STL is designed around the concept of iterators.
With iterators, one algorithm can be reused not just for multiple types, but also for many data structures.
This is an ingenious design.
However, in practice, this capability is rarely needed.
The vast majority of real world &lt;algorithm&gt; invocations are on contiguous arrays/vectors.</p>
<p dir="auto">For those cases where you do have a fancy data structure (graphs, trees, etc),
copy its contents to an array, perform the algorithm, and then copy the contents back.
This will often help it perform better anyway!</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-2-bounds-vs-counted-ranges" aria-hidden="true" href="#2-bounds-vs-counted-ranges"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2. Bounds vs counted ranges</h3>
<p dir="auto">STL algorithms typically operate on half-open ranges bounded by iterators [first, last).
This convention is not used as often in C, but we think it offers some benefits.
Internally, the functions can maintain less state by simply incrementing pointers
rather than keeping track of pointers, indices, and counts.</p>
<p dir="auto">Operations also compose a little easier.
When a pointer is returned to an element of interest,
that same pointer can be used as an argument for another algorithm.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-3-whats-left-out" aria-hidden="true" href="#3-whats-left-out"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3. What&#39;s left out</h3>
<p dir="auto">Because it&#39;s a bit verbose to define a C closure (function pointer and context), some STL algorithms are less useful in C.
If an algorithm can be written as a simple for loop with no additional state or control flow, this library doesn&#39;t implement it.</p>
<div data-snippet-clipboard-copy-content="transform -&gt; for (int i = 0; i &lt; n; ++i) out[i] = f(in[i])
fill -&gt; for (int i = 0; i &lt; n; ++i) out[i] = x;
iota -&gt; for (int i = 0; i &lt; n; ++i) out[i] = i;
generate -&gt; for (int i = 0; i &lt; n; ++i) out[i] = f();"><pre><code>transform -&gt; for (int i = 0; i &lt; n; ++i) out[i] = f(in[i])
fill -&gt; for (int i = 0; i &lt; n; ++i) out[i] = x;
iota -&gt; for (int i = 0; i &lt; n; ++i) out[i] = i;
generate -&gt; for (int i = 0; i &lt; n; ++i) out[i] = f();
</code></pre></div>
<p dir="auto">The algorithms which rely on ordered types always require a comparison function.
We do not include any variants that operate on the <code>==</code> operator, as operators cannot be overloaded in C.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-4-generics-vs-void" aria-hidden="true" href="#4-generics-vs-void"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>4. Generics vs <code>void*</code></h3>
<p dir="auto">Including a header multiple times with various <code>#define</code>s is a little cumbersome.
However, we think it&#39;s a superior way to achieve C generics compared to the <code>void*</code> style used by <code>qsort</code> and <code>bsearch</code>.
The preprocessor approach provides:</p>
<ul dir="auto">
<li>
<p dir="auto">Better type safety and avoids verbose casting logic.</p>
</li>
<li>
<p dir="auto">Better peformance (as <code>void*</code> functions are difficult to optimize).</p>
<p dir="auto">Note: The C compiler can only create one non-inlined version of each function.
For example, it could not choose to use <code>int</code> instructions, even if it knew the type at compile time.
With the single header approach you get a new instance of each function optimized for each application.</p>
</li>
</ul>
</article>
          </div></div>
  </body>
</html>
