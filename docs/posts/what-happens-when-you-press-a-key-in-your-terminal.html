<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/07/20/pseudoterminals/">Original</a>
    <h1>What happens when you press a key in your terminal?</h1>
    
    

<p>I&rsquo;ve been confused about what&rsquo;s going on with terminals for a long time.</p>

<p>But this past week I was using <a href="https://xtermjs.org/">xterm.js</a> to display an
interactive terminal in a browser and I finally thought to ask a pretty basic
question: when you press a key on your keyboard in a terminal (like <code>Delete</code>, or <code>Escape</code>, or <code>a</code>), which
bytes get sent?</p>

<p>As usual we&rsquo;ll answer that question by doing some experiments and seeing what happens :)</p>

<h3 id="remote-terminals-are-very-old-technology">remote terminals are very old technology</h3>

<p>First, I want to say that displaying a terminal in the browser with <code>xterm.js</code>
might seem like a New Thing, but it&rsquo;s really not. In the 70s, computers were
expensive. So many employees at an institution would share a single computer,
and each person could have their own &ldquo;terminal&rdquo; to that computer.</p>

<p>For example, here&rsquo;s a photo of a VT100 terminal from the 70s or 80s. This looks like
it could be a computer (it&rsquo;s kind of big!), but it&rsquo;s not &ndash; it just displays
whatever information the actual computer sends it.</p>

<p><a title="Jason Scott, CC BY 2.0 &lt;https://creativecommons.org/licenses/by/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:DEC_VT100_terminal.jpg"><img width="512" alt="DEC VT100 terminal" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/DEC_VT100_terminal.jpg/512px-DEC_VT100_terminal.jpg"></a></p>

<p>Of course, in the 70s they didn&rsquo;t use websockets for this, but the information
being sent back and forth is more or less the same as it was then.</p>

<p><small>
(the terminal in that photo is from the <a href="https://livingcomputers.org/">Living Computer Museum</a> in Seattle which I got to visit once and write FizzBuzz in <code>ed</code> on a very old Unix system, so it&rsquo;s possible that I&rsquo;ve actually used that machine or one of its siblings! I really hope the Living Computer Museum opens again, it&rsquo;s very cool to get to play with old computers.)
</small></p>

<h3 id="what-information-gets-sent">what information gets sent?</h3>

<p>It&rsquo;s obvious that if you want to connect to a remote computer (with <code>ssh</code> or
using <code>xterm.js</code> and a websocket, or anything else), then some information
needs to be sent between the client and the server.</p>

<p>Specifically:</p>

<ul>
<li>the <strong>client</strong> needs to send the keystrokes that the user typed in (like <code>ls -l</code>)</li>
<li>the <strong>server</strong> needs to tell the client what to display on the screen</li>
</ul>

<p>Let&rsquo;s look at a real program that&rsquo;s running a remote terminal in a browser and see what information gets sent back and forth!</p>

<h3 id="we-ll-use-goterm-to-experiment">we&rsquo;ll use <code>goterm</code> to experiment</h3>

<p>I found this tiny program on GitHub called
<a href="https://github.com/freman/goterm">goterm</a> that runs a Go server that lets you
interact with a terminal in the browser using <code>xterm.js</code>. This program is very insecure but it&rsquo;s simple and great for learning.</p>

<p>I <a href="https://github.com/jvns/goterm">forked it</a> to make it work with the latest xterm.js,
since it was last updated 6 years ago. Then I added some logging statements to
print out every time bytes are sent/received over the websocket.</p>

<p>Let&rsquo;s look at sent and received during a few different terminal interactions!</p>

<h3 id="example-ls">example: <code>ls</code></h3>

<p>First, let&rsquo;s run <code>ls</code>. Here&rsquo;s what I see on the <code>xterm.js</code> terminal:</p>

<pre><code>bork@kiwi:/play$ ls
file
bork@kiwi:/play$
</code></pre>

<p>and here&rsquo;s what gets sent and received: (in my code, I log <code>sent: [bytes]</code> every time the client sends bytes and <code>recv: [bytes]</code> every time it receives bytes from the server)</p>

<pre><code>sent: &quot;l&quot;
recv: &quot;l&quot;
sent: &quot;s&quot;
recv: &quot;s&quot;
sent: &quot;\r&quot;
recv: &quot;\r\n\x1b[?2004l\r&quot;
recv: &quot;file\r\n&quot;
recv: &quot;\x1b[?2004hbork@kiwi:/play$ &quot;
</code></pre>

<p>I noticed 3 things in this output:</p>

<ol>
<li>Echoing: The client sends <code>l</code> and then immediately receives an <code>l</code> sent
back. I guess the idea here is that the client is really dumb &ndash; it doesn&rsquo;t
know that when I type an <code>l</code>, I want an <code>l</code> to be echoed back to the screen.
It has to be told explicitly by the server process to display it.</li>
<li>The newline: when I press enter, it sends a <code>\r</code> (carriage return) symbol and not a <code>\n</code> (newline)</li>
<li>Escape sequences: <code>\x1b</code> is the ASCII escape character, so <code>\x1b[?2004h</code> is
telling the terminal to display something or other. I think this is a colour
sequence but I&rsquo;m not sure. We&rsquo;ll talk a little more about escape sequences later.</li>
</ol>

<p>Okay, now let&rsquo;s do something slightly more complicated.</p>

<h3 id="example-ctrl-c">example: <code>Ctrl+C</code></h3>

<p>Next, let&rsquo;s see what happens when we interrupt a process with <code>Ctrl+C</code>. Here&rsquo;s what I see in my terminal:</p>

<pre><code>bork@kiwi:/play$ cat
^C
bork@kiwi:/play$
</code></pre>

<p>And here&rsquo;s what the client sends and receives.</p>

<pre><code>sent: &quot;c&quot;
recv: &quot;c&quot;
sent: &quot;a&quot;
recv: &quot;a&quot;
sent: &quot;t&quot;
recv: &quot;t&quot;
sent: &quot;\r&quot;
recv: &quot;\r\n\x1b[?2004l\r&quot;
sent: &quot;\x03&quot;
recv: &quot;^C&quot;
recv: &quot;\r\n&quot;
recv: &quot;\x1b[?2004h&quot;
recv: &quot;bork@kiwi:/play$ &quot;
</code></pre>

<p>When I press <code>Ctrl+C</code>, the client sends <code>\x03</code>. If I look up an ASCII table,
<code>\x03</code> is &ldquo;End of Text&rdquo;, which seems reasonable. I thought this was really cool
because I&rsquo;ve always been a bit confused about how Ctrl+C works &ndash; it&rsquo;s good to
know that it&rsquo;s just sending an <code>\x03</code> character.</p>

<p>I believe the reason <code>cat</code> gets interrupted when we press <code>Ctrl+C</code> is that the
Linux kernel on the server side receives this <code>\x03</code> character, recognizes that
it means &ldquo;interrupt&rdquo;, and then sends a <code>SIGINT</code> to the process that owns the
pseudoterminal&rsquo;s process group. So it&rsquo;s handled in the kernel and not in
userspace.</p>

<h3 id="example-ctrl-d">example: <code>Ctrl+D</code></h3>

<p>Let&rsquo;s try the exact same thing, except with <code>Ctrl+D</code>. Here&rsquo;s what I see in my terminal:</p>

<pre><code>bork@kiwi:/play$ cat
bork@kiwi:/play$
</code></pre>

<p>And here&rsquo;s what gets sent and received:</p>

<pre><code>sent: &quot;c&quot;
recv: &quot;c&quot;
sent: &quot;a&quot;
recv: &quot;a&quot;
sent: &quot;t&quot;
recv: &quot;t&quot;
sent: &quot;\r&quot;
recv: &quot;\r\n\x1b[?2004l\r&quot;
sent: &quot;\x04&quot;
recv: &quot;\x1b[?2004h&quot;
recv: &quot;bork@kiwi:/play$ &quot;
</code></pre>

<p>It&rsquo;s very similar to <code>Ctrl+C</code>, except that <code>\x04</code> gets sent instead of <code>\x03</code>.
Cool! <code>\x04</code> corresponds to ASCII &ldquo;End of Transmission&rdquo;.</p>

<h3 id="what-about-ctrl-another-letter">what about Ctrl + another letter?</h3>

<p>Next I got curious about &ndash; if I send <code>Ctrl+e</code>, what byte gets sent?</p>

<p>It turns out that it&rsquo;s literally just the number of that letter in the alphabet, like this:</p>

<ul>
<li><code>Ctrl+a</code> =&gt; 1</li>
<li><code>Ctrl+b</code> =&gt; 2</li>
<li><code>Ctrl+c</code> =&gt; 3</li>
<li><code>Ctrl+d</code> =&gt; 4</li>
<li>&hellip;</li>
<li><code>Ctrl+z</code> =&gt; 26</li>
</ul>

<p>Also, <code>Ctrl+Shift+b</code> does the exact same thing as <code>Ctrl+b</code> (it writes <code>0x2</code>).</p>

<p>What about other keys on the keyboard? Here&rsquo;s what they map to:</p>

<ul>
<li>Tab -&gt; 0x9 (same as Ctrl+I, since I is the 9th letter)</li>
<li>Escape -&gt; <code>\x1b</code><br /></li>
<li>Backspace -&gt; <code>\x7f</code></li>
<li>Home -&gt; <code>\x1b[H</code></li>
<li>End: <code>\x1b[F</code></li>
<li>Print Screen: <code>\x1b\x5b\x31\x3b\x35\x41</code></li>
<li>Insert: <code>\x1b\x5b\x32\x7e</code></li>
<li>Delete -&gt; <code>\x1b\x5b\x33\x7e</code></li>
<li>My <code>Meta</code> key does nothing at all</li>
</ul>

<p>What about Alt? From my experimenting (and some Googling), it seems like <code>Alt</code>
is literally the same as &ldquo;Escape&rdquo;, except that pressing <code>Alt</code> by itself doesn&rsquo;t
send any characters to the terminal and pressing <code>Escape</code> by itself does. So:</p>

<ul>
<li>alt + d =&gt; <code>\x1bd</code> (and the same for every other letter)</li>
<li>alt + shift + d =&gt; <code>\x1bD</code> (and the same for every other letter)</li>
<li>etcetera</li>
</ul>

<p>Let&rsquo;s look at one more example!</p>

<h3 id="example-nano">example: <code>nano</code></h3>

<p>Here&rsquo;s what gets sent and received when I run the text editor <code>nano</code>:</p>

<pre><code>recv: &quot;\r\x1b[Kbork@kiwi:/play$ &quot;
sent: &quot;n&quot; [[]byte{0x6e}]
recv: &quot;n&quot;
sent: &quot;a&quot; [[]byte{0x61}]
recv: &quot;a&quot;
sent: &quot;n&quot; [[]byte{0x6e}]
recv: &quot;n&quot;
sent: &quot;o&quot; [[]byte{0x6f}]
recv: &quot;o&quot;
sent: &quot;\r&quot; [[]byte{0xd}]
recv: &quot;\r\n\x1b[?2004l\r&quot;
recv: &quot;\x1b[?2004h&quot;
recv: &quot;\x1b[?1049h\x1b[22;0;0t\x1b[1;16r\x1b(B\x1b[m\x1b[4l\x1b[?7h\x1b[39;49m\x1b[?1h\x1b=\x1b[?1h\x1b=\x1b[?25l&quot;
recv: &quot;\x1b[39;49m\x1b(B\x1b[m\x1b[H\x1b[2J&quot;
recv: &quot;\x1b(B\x1b[0;7m  GNU nano 6.2 \x1b[44bNew Buffer \x1b[53b \x1b[1;123H\x1b(B\x1b[m\x1b[14;38H\x1b(B\x1b[0;7m[ Welcome to nano.  For basic help, type Ctrl+G. ]\x1b(B\x1b[m\r\x1b[15d\x1b(B\x1b[0;7m^G\x1b(B\x1b[m Help\x1b[15;16H\x1b(B\x1b[0;7m^O\x1b(B\x1b[m Write Out   \x1b(B\x1b[0;7m^W\x1b(B\x1b[m Where Is    \x1b(B\x1b[0;7m^K\x1b(B\x1b[m Cut\x1b[15;61H&quot;
</code></pre>

<p>You can see some text from the UI in there like &ldquo;GNU nano 6.2&rdquo;, and these
<code>\x1b[27m</code> things are escape sequences. Let&rsquo;s talk about escape sequences a bit!</p>

<h3 id="ansi-escape-sequences">ANSI escape sequences</h3>

<p>These <code>\x1b[</code> things above that <code>nano</code> is sending the client are called &ldquo;escape sequences&rdquo; or &ldquo;escape codes&rdquo;.
This is because they all start with <code>\x1b</code>, the &ldquo;escape&rdquo; character. .  They change the
cursor&rsquo;s position, make text bold or underlined, change colours, etc. <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">Wikipedia has some history</a> if you&rsquo;re interested.</p>

<p>As a simple example: if you run</p>

<pre><code>echo -e '\e[0;31mhi\e[0m there'
</code></pre>

<p>in your terminal, it&rsquo;ll print out &ldquo;hi there&rdquo; where &ldquo;hi&rdquo; is in red and &ldquo;there&rdquo;
is in black. <a href="https://misc.flogisoft.com/bash/tip_colors_and_formatting">This page</a> has some nice
examples of escape codes for colors and formatting.</p>

<p>I think there are a few different standards for escape codes, but my
understanding is that the most common set of escape codes that people use on
Unix come from the VT100 (that old terminal in the picture at the top of the
blog post), and hasn&rsquo;t really changed much in the last 40 years.</p>

<p>Escape codes are why your terminal can get messed up if you <code>cat</code> a bunch of binary to
your screen &ndash; usually you&rsquo;ll end up accidentally printing a bunch of random
escape codes which will mess up your terminal &ndash; there&rsquo;s bound to be a <code>0x1b</code>
byte in there somewhere if you <code>cat</code> enough binary to your terminal.</p>

<h3 id="can-you-type-in-escape-sequences-manually">can you type in escape sequences manually?</h3>

<p>A few sections back, we talked about how the <code>Home</code> key maps to <code>\x1b[H</code>. Those 3 bytes are <code>Escape + [ + H</code> (because Escape is
<code>\x1b</code>).</p>

<p>And if I manually type Escape, then [, then H in the
<code>xterm.js</code> terminal, I end up at the beginning of the line, exactly the same as if I&rsquo;d pressed <code>Home</code>.</p>

<p>I noticed that this didn&rsquo;t work in <code>fish</code> on my computer though &ndash; if I typed
<code>Escape</code> and then <code>[</code>, it just printed out <code>[</code> instead of letting me continue the
escape sequence. I asked my friend Jesse who has written <a href="https://github.com/doy/vt100-rust">a bunch of Rust
terminal code</a> about this and Jesse told me
that a lot of programs implement a <strong>timeout</strong> for escape codes &ndash; if you don&rsquo;t
press another key after some minimum amount of time, it&rsquo;ll decide that it&rsquo;s
actually not an escape code anymore.</p>

<p>Apparently this is configurable in fish with <code>fish_escape_delay_ms</code>, so I ran
<code>set fish_escape_delay_ms 1000</code> and then I was able to type in escape codes by
hand. Cool!</p>

<h3 id="terminal-encoding-is-kind-of-weird">terminal encoding is kind of weird</h3>

<p>I want to pause here for a minute here and say that the way the keys you get
pressed get mapped to bytes is pretty weird. Like, if we were designing
the way keys are encoded from scratch today, we would probably not set it up so
that:</p>

<ul>
<li><code>Ctrl + a</code> does the exact same thing as <code>Ctrl + Shift + a</code></li>
<li><code>Alt</code> is the same as <code>Escape</code></li>
<li>control sequences (like colours / moving the cursor around) use the same byte
as the <code>Escape</code> key, so that you need to rely on timing to determine if it
was a control sequence of the user just meant to press <code>Escape</code></li>
</ul>

<p>But all of this was designed in the 70s or 80s or something and then needed
to stay the same forever for backwards compatibility, so that&rsquo;s what we get :)</p>

<h3 id="changing-window-size">changing window size</h3>

<p>Not everything you can do in a terminal happens via sending bytes back and
forth. For example, when the terminal gets resized, we have to tell Linux that the window size has
changed in a different way.</p>

<p>Here&rsquo;s what the Go code in
<a href="https://github.com/freman/goterm/blob/a644c10e180ce8af789ea3e4e4892dcf078e97e2/main.go#L110-L115">goterm</a>
to do that looks like:</p>

<pre><code>syscall.Syscall(
    syscall.SYS_IOCTL,
    tty.Fd(),
    syscall.TIOCSWINSZ,
    uintptr(unsafe.Pointer(&amp;resizeMessage)),
)
</code></pre>

<p>This is using the <code>ioctl</code> system call. My understanding of <code>ioctl</code> is that it&rsquo;s
a system call for a bunch of random stuff that isn&rsquo;t covered by other system
calls, generally related to IO I guess.</p>

<p><code>syscall.TIOCSWINSZ</code> is an integer constant which which tells <code>ioctl</code> which
particular thing we want it to to in this case (change the window size of a
terminal).</p>

<h3 id="this-is-also-how-xterm-works">this is also how xterm works</h3>

<p>In this post we&rsquo;ve been talking about remote terminals, where the client and
the server are on different computers. But actually if you use a terminal
emulator like <code>xterm</code>, all of this works the exact same way, it&rsquo;s just harder
to notice because the bytes aren&rsquo;t being sent over a network connection.</p>

<h3 id="that-s-all-for-now">that&rsquo;s all for now!</h3>

<p>There&rsquo;s defimitely a lot more to know about terminals (we could talk more about
colours, or raw vs cooked mode, or unicode support, or the Linux pseudoterminal
interface) but I&rsquo;ll stop here because it&rsquo;s 10pm, this is getting kind of long,
and I think my brain cannot handle more new information about terminals today.</p>

<p><small>
Thanks to <a href="https://github.com/doy/">Jesse Luehrs</a> for answering a billion of my questions about terminals, all the mistakes are mine :)
</small></p>

  </body>
</html>
