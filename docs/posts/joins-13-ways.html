<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinjaffray.com/joins-13-ways/?a=b">Original</a>
    <h1>Joins 13 Ways</h1>
    
    <div id="readability-page-1" class="page"><div>
    

<p><small>03 Jul 2023</small></p><p>Relational (inner) joins are really common in the world of databases, and one
weird thing about them is that it seems like everyone has a different idea of
what they are.  In this post I’ve aggregated a bunch of different definitions,
ways of thinking about them, and ways of implementing them that will hopefully
be interesting.
They’re not without redundancy, some of them are arguably the same, but I think
they’re all interesting perspectives nonetheless.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#a-join-is-a-lookup">A join is a lookup</a></li>
<li><a href="#a-join-is-a-nested-loop-over-rows">A join is a nested loop over rows</a></li>
<li><a href="#a-join-is-a-nested-loop-over-columns">A join is a nested loop over columns</a></li>
<li><a href="#a-join-is-compatible-alternate-realities">A join is compatible alternate realities</a></li>
<li><a href="#a-join-is-flatmap">A join is flatMap</a></li>
<li><a href="#a-join-is-the-solution-to-the-n1-problem">A join is the solution to the N+1 problem</a></li>
<li><a href="#a-join-is-paths-through-a-graph">A join is paths through a graph</a></li>
<li><a href="#a-join-is-a-minimal-model">A join is a minimal model</a></li>
<li><a href="#a-join-is-typechecking">A join is typechecking</a></li>
<li><a href="#a-join-is-an-operation-in-the-set-monad">A join is an operation in the Set monad</a></li>
<li><a href="#a-join-is-the-biggest-acceptable-relation">A join is the biggest acceptable relation</a></li>
<li><a href="#a-join-is-ajoin">A join is a…join</a></li>
<li><a href="#a-join-is-a-ring-product">A join is a ring product</a></li>
</ul>
<h2 id="a-join-is-a-lookup">A join is a lookup</h2>
<p>The first and most practical way to see a join is that it’s “looking something up,” or adorning some data with some additional, redundant data.</p>
<p>I think the first place people typically encounter joins is when some guy on the internet has told them to normalize their tables. Meaning they’ve been told to stop storing data like this:</p>
<table>
<thead>
<tr>
<th>user</th>
<th>country</th>
<th>country_code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smudge</td>
<td>Canada</td>
<td>CA</td>
</tr>
<tr>
<td>Sissel</td>
<td>Canada</td>
<td>CA</td>
</tr>
<tr>
<td>Petee</td>
<td>United States</td>
<td>US</td>
</tr>
</tbody>
</table>
<p>This is “bad,” because there’s redundancy: <code>country_code</code> doesn’t change between rows with the same <code>country</code>. If we were storing something more volatile than this, we’d have to make sure that any changes to the data were reflected everywhere, which is error prone and inefficient.</p>
<p>The correct way to do this is to <em><strong><strong><strong><strong>normalize</strong></strong></strong></strong></em> the table. Create a table which only relates <code>country</code> and <code>country_code</code>:</p>
<table>
<thead>
<tr>
<th>country_id</th>
<th>country</th>
<th>country_code</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Canada</td>
<td>CA</td>
</tr>
<tr>
<td>2</td>
<td>United States</td>
<td>US</td>
</tr>
</tbody>
</table>
<p>and then reference that in the “fact table:”</p>
<table>
<thead>
<tr>
<th>user</th>
<th>country_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smudge</td>
<td>1</td>
</tr>
<tr>
<td>Sissel</td>
<td>1</td>
</tr>
<tr>
<td>Petee</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Then a join is the operation that lets us recover the original table, which we might want to do some computations: to join these two tables we’d write:</p>
<div><pre><code data-lang="sql"><span>SELECT</span><span> </span><span>user</span>,<span> </span>country,<span> </span>country_code<span> </span><span>FROM</span><span>
</span><span>    </span>users<span>
</span><span>      </span><span>INNER</span><span> </span><span>JOIN</span><span>
</span><span>    </span>countries<span>
</span><span>      </span><span>ON</span><span> </span>users.country_id<span> </span><span>=</span><span> </span>countries.country_id<span>
</span></code></pre></div><p>Going forward, we will often adopt that convention that we implicitly join “on” any columns of the two relations that have the same name.
But we will play a bit fast and loose with this, don’t sweat the details too much.</p>
<h2 id="a-join-is-a-nested-loop-over-rows">A join is a nested loop over rows</h2>
<p>Given some predicate <code>p</code>, the join of two sets <code>R</code> and <code>S</code> is:</p>
<div><pre><code data-lang="python"><span>def</span> <span>join</span>(R, S, p):
  output <span>=</span> []
	<span>for</span> r <span>in</span> R:
      <span>for</span> s <span>in</span> S:
		<span>if</span> p(r, s):
          output<span>.</span>push((r, s))
  <span>return</span> output
</code></pre></div><p>If the cross product of two collections is all concatenations of rows from the two of them, their join is a subset of that.</p>
<h2 id="a-join-is-a-nested-loop-over-columns">A join is a nested loop over columns</h2>
<p>The <strong><strong><strong>domain</strong></strong></strong> of a column is the set of possible values that can appear in it.</p>
<p>If I have a relation <code>R</code> whose columns are <code>a</code> and <code>b</code>, and <code>S</code> whose columns are <code>b</code> and <code>c</code>, then the join of <code>R</code> and <code>S</code> is:</p>
<div><pre><code data-lang="python"><span>def</span> <span>join</span>(R, S):
  output <span>=</span> []
  <span>for</span> a <span>in</span> domain(a):
    <span>for</span> b <span>in</span> domain(b):
      <span>for</span> c <span>in</span> domain(c):
        <span>if</span> R<span>.</span>contains(a, b) <span>and</span> S<span>.</span>contains(b, c):
		  output<span>.</span>push([a, b, c])
  <span>return</span> output
</code></pre></div><h2 id="a-join-is-compatible-alternate-realities">A join is compatible alternate realities</h2>
<p>Here’s our first weird one.</p>
<p>John and Sally are standing around the corner from each other, each has a pet, and each can see a stray animal on the corner, but they can’t see each other.</p>
<p><img src="https://mikeenglish.net/images/joins_4.png"/>
</p>
<p>John and Sally both exist in a handful of alternate realities at once. For instance, there’s one reality where John has a dog, and another where he has a cat. We can summarize the realities that are possible for John in a relation:</p>
<table>
<thead>
<tr>
<th>john’s pet</th>
<th>stray</th>
</tr>
</thead>
<tbody>
<tr>
<td>dog</td>
<td>dog</td>
</tr>
<tr>
<td>cat</td>
<td>dog</td>
</tr>
<tr>
<td>cat</td>
<td>mouse</td>
</tr>
</tbody>
</table>
<p>Similarly, Sally also has a pet, and can also see the stray:</p>
<table>
<thead>
<tr>
<th>sally’s pet</th>
<th>stray</th>
</tr>
</thead>
<tbody>
<tr>
<td>dog</td>
<td>mouse</td>
</tr>
<tr>
<td>cat</td>
<td>mouse</td>
</tr>
<tr>
<td>mouse</td>
<td>dog</td>
</tr>
</tbody>
</table>
<p>We only have this imperfect information, because John can’t see Sally’s pet, and Sally can’t see John’s pet.</p>
<p>We can still make some inferences though: it can’t be the case that John has a dog while Sally has a cat, because then they would disagree on what the stray was (whenever John has a dog, the stray is a dog, but whenever Sally has a cat, the stray is a mouse).</p>
<p>By this logic, we can list out all the combinations that might exist:</p>
<table>
<thead>
<tr>
<th>john’s pet</th>
<th>stray</th>
<th>sally’s pet</th>
</tr>
</thead>
<tbody>
<tr>
<td>dog</td>
<td>dog</td>
<td>mouse</td>
</tr>
<tr>
<td>cat</td>
<td>dog</td>
<td>mouse</td>
</tr>
<tr>
<td>cat</td>
<td>mouse</td>
<td>dog</td>
</tr>
<tr>
<td>cat</td>
<td>mouse</td>
<td>cat</td>
</tr>
</tbody>
</table>
<p>This is the join of the two tables on <code>stray</code>.</p>
<h2 id="a-join-is-flatmap">A join is flatMap</h2>
<p>The <code>flatMap</code> function in many programming languages operates on arrays.
It computes a new array for every element of the original, and concatenates the results.</p>
<div><pre><code data-lang="javascript"><span>&gt;</span> [<span>1</span>, <span>2</span>, <span>3</span>].flatMap(x =&gt; <span>new</span> <span>Array</span>(x).fill(x))
[ <span>1</span>, <span>2</span>, <span>2</span>, <span>3</span>, <span>3</span>, <span>3</span> ]
</code></pre></div><p>This can implement a join.
This:</p>
<div><pre><code data-lang="sql"><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span>r<span> </span><span>INNER</span><span> </span><span>JOIN</span><span> </span>s<span> </span><span>ON</span><span> </span>p<span>
</span></code></pre></div><p>becomes this:</p>
<div><pre><code data-lang="jsx">r.flatMap(x =&gt; s.filter(y =&gt; p(x, y)))
</code></pre></div><p>Some SQL variants support a <code>LATERAL</code> construction which turns joins into flatMaps:</p>
<div><pre><code data-lang="sql">pg<span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span>
</span><span>  </span>(<span>VALUES</span><span> </span>(<span>1</span>),<span> </span>(<span>2</span>),<span> </span>(<span>3</span>))<span> </span>r(x),<span>
</span><span>  </span><span>LATERAL</span><span> </span>(<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span>generate_series(<span>1</span>,<span> </span>x))<span> </span>u;<span>
</span><span> </span>x<span> </span><span>|</span><span> </span>generate_series<span>
</span><span></span><span>---+-----------------
</span><span></span><span> </span><span>1</span><span> </span><span>|</span><span>               </span><span>1</span><span>
</span><span> </span><span>2</span><span> </span><span>|</span><span>               </span><span>1</span><span>
</span><span> </span><span>2</span><span> </span><span>|</span><span>               </span><span>2</span><span>
</span><span> </span><span>3</span><span> </span><span>|</span><span>               </span><span>1</span><span>
</span><span> </span><span>3</span><span> </span><span>|</span><span>               </span><span>2</span><span>
</span><span> </span><span>3</span><span> </span><span>|</span><span>               </span><span>3</span><span>
</span><span></span>(<span>6</span><span> </span><span>rows</span>)<span>
</span></code></pre></div><p>Whenever the right-hand side of such a flatMap doesn’t contain any references to the left-hand side, it’s equivalent to a cross product (this is the crux of how query decorrelation is done, utilizing successive rewrites to remove column references from the right-hand side).</p>
<h2 id="a-join-is-the-solution-to-the-n1-problem">A join is the solution to the N+1 problem</h2>
<p>A common problem that occurs when using ORMs is called the “N+1 problem.”
This happens when you need to do a query for each row in a result set.
It ends up looking something like this:</p>
<div><pre><code data-lang="python">pets <span>=</span> run_query(<span>&#34;SELECT * FROM users&#34;</span>)
<span>for</span> pet <span>in</span> pets:
  country_code <span>=</span> run_query(
    <span>&#34;SELECT country_code FROM countries WHERE country_id = </span><span>%d</span><span>&#34;</span> <span>%</span> pet<span>.</span>country_id
  )
  <span>print</span>(pet<span>.</span>name, country_code)
</code></pre></div><p>This is a really common problem that shows up when people aren’t yet used to using relational databases.
The problem is that in databases that use connections, like Postgres (this is not so much of a problem for in-process databases like Sqlite),
there’s a high fixed cost to an individual query.
Thus, you might want a way to tell the database “please do all these lookups for me,” and the result turns out to be exactly a join:</p>
<div><pre><code data-lang="sql"><span>SELECT</span><span> </span>name,<span> </span>country_code<span> </span><span>FROM</span><span>
</span><span>  </span>users<span> </span><span>INNER</span><span> </span><span>JOIN</span><span> </span>countries<span> </span><span>ON</span><span> </span>users.country_id<span> </span><span>=</span><span> </span>countries.id<span>
</span></code></pre></div><h2 id="a-join-is-paths-through-a-graph">A join is paths through a graph</h2>
<p>A <em>relation</em> is so named because it “relates” two sets.
In the case of our <code>users</code> table,
it relates the set of usernames with the set of country IDs.
We can visualize this relationship as a <em>graph</em>:</p>
<p><img src="https://mikeenglish.net/images/joins_1.png"/>
</p>
<p>And similarly, we relate the set of country IDs to the set of two-letter country codes:</p>
<p><img src="https://mikeenglish.net/images/joins_2.png"/>
</p>
<p>Since the right-hand side of the first graph, and the left-hand side of the
second graph share a vertex set, it makes sense to consider them together:</p>
<p><img src="https://mikeenglish.net/images/joins_3.png"/>
</p>
<p>If we enumerate all the paths that start in the left set of this graph, go to a
vertex in the middle set, and end on a vertex in the right set, we will
construct exactly the join of these two relations.</p>
<h2 id="a-join-is-a-minimal-model">A join is a minimal model</h2>
<p>In formal logic, a <em><strong><strong>model</strong></strong></em> of a set of sentences is a set of facts which make all of the sentences true. In this setting, a relation is a <em><strong><strong><strong><strong>predicate</strong></strong></strong></strong></em>. The <code>users</code> relation is the predicate that satisfies the following:</p>
<pre><code data-lang="datalog">users(&#34;Smudge&#34;, 1).
users(&#34;Sissel&#34;, 1).
users(&#34;Petee&#34;, 2).
</code></pre><p>and the <code>country</code> relation is the predicate that satisfies:</p>
<pre><code data-lang="datalog">country(1, &#34;Canada&#34;, &#34;CA&#34;).
country(2, &#34;United States&#34;, &#34;US&#34;).
</code></pre><p>Now consider the following implication:</p>
<p>\[
\texttt{users}(a, b) \wedge \texttt{countries}(b, c, d) \rightarrow \texttt{Q}(a, b, c, d)
\]</p>
<p>read “whenever <code>users(A, B)</code> and <code>countries(B, C, D)</code>, then <code>Q(A, B, C, D)</code>.&#34; A model of this sentence is a set of facts which <code>Q</code> is true for such that this sentence is true.</p>
<p>One possible model is:</p>
<pre><code data-lang="datalog">Q(&#34;Smudge&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Smudge&#34;, 2, &#34;United States&#34;, &#34;US&#34;).
Q(&#34;Sissel&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Sissel&#34;, 2, &#34;United States&#34;, &#34;US&#34;).
Q(&#34;Petee&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Petee&#34;, 2, &#34;United States&#34;, &#34;US&#34;).
</code></pre><p>Another is</p>
<pre><code data-lang="datalog">Q(&#34;Smudge&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Smudge&#34;, 2, &#34;United States&#34;, &#34;US&#34;).
Q(&#34;Sissel&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Sissel&#34;, 2, &#34;United States&#34;, &#34;US&#34;).
Q(&#34;Petee&#34;, 2, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Petee&#34;, 1, &#34;United States&#34;, &#34;US&#34;).
Q(&#34;Banana&#34;, 1, &#34;Banana&#34;, &#34;Banana&#34;).
</code></pre><p>It’s not particularly satisfying that this definition means we can have multiple possible models.
We want something canonical.
That’s why we ask for the <strong><strong><strong><strong>smallest</strong></strong></strong></strong> model that works.
It turns out that for sentences like this, such a model always exists, and it’s the intersection of all models.</p>
<p>Here it’s</p>
<pre><code data-lang="datalog">Q(&#34;Smudge&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Sissel&#34;, 1, &#34;Canada&#34;, &#34;CA&#34;).
Q(&#34;Petee&#34;, 2, &#34;United States&#34;, &#34;US&#34;).
</code></pre><p>which is the join of <code>users</code> and <code>country</code>.</p>
<h2 id="a-join-is-typechecking">A join is typechecking</h2>
<p>ML-style type systems bear a lot of similarities to joins (mostly because they very strongly resemble Prolog and Datalog).
First, let’s define our relations as Rust traits:</p>
<div><pre><code data-lang="rust"><span>trait</span><span> </span>Users<span> </span>{}<span>
</span><span></span><span>trait</span><span> </span>CountryCode<span> </span>{}<span>
</span></code></pre></div><p>Now define our values, they’re Rust concrete types:</p>
<div><pre><code data-lang="rust"><span>struct</span> <span>Smudge</span>;<span>
</span><span></span><span>struct</span> <span>Sissel</span>;<span>
</span><span></span><span>struct</span> <span>Petee</span>;<span>
</span><span>
</span><span></span><span>struct</span> <span>Canada</span>;<span>
</span><span></span><span>struct</span> <span>UnitedStates</span>;<span>
</span><span>
</span><span></span><span>struct</span> <span>CA</span>;<span>
</span><span></span><span>struct</span> <span>US</span>;<span>
</span></code></pre></div><div><pre><code data-lang="rust"><span>impl</span><span> </span>Users<span> </span><span>for</span><span> </span>(Smudge,<span> </span>Canada)<span> </span>{}<span>
</span><span></span><span>impl</span><span> </span>Users<span> </span><span>for</span><span> </span>(Sissel,<span> </span>Canada)<span> </span>{}<span>
</span><span></span><span>impl</span><span> </span>Users<span> </span><span>for</span><span> </span>(Petee,<span> </span>UnitedStates)<span> </span>{}<span>
</span><span>
</span><span></span><span>impl</span><span> </span>CountryCode<span> </span><span>for</span><span> </span>(Canada,<span> </span>CA)<span> </span>{}<span>
</span><span></span><span>impl</span><span> </span>CountryCode<span> </span><span>for</span><span> </span>(UnitedStates,<span> </span>US)<span> </span>{}<span>
</span></code></pre></div><p>Now we define the join itself.
A triple <code>(A, B, C)</code> is in the join when <code>(A, B)</code> is in <code>Users</code>, and <code>(B, C)</code> is in <code>CountryCode</code>.</p>
<div><pre><code data-lang="rust"><span>trait</span><span> </span>UserCountryCode<span> </span>{}<span>
</span><span>
</span><span></span><span>impl</span><span>&lt;</span>A,<span> </span>B,<span> </span>C<span>&gt;</span><span> </span>UserCountryCode<span> </span><span>for</span><span> </span>(A,<span> </span>B,<span> </span>C)<span>
</span><span></span><span>where</span><span>
</span><span>    </span>(A,<span> </span>B): <span>Users</span>,<span>
</span><span>    </span>(B,<span> </span>C): <span>CountryCode</span>,<span>
</span><span></span>{<span>
</span><span></span>}<span>
</span></code></pre></div><p>Finally, we can check if something is in the join if our program typechecks.
This typechecks:</p>
<div><pre><code data-lang="rust"><span>fn</span> <span>test</span><span>&lt;</span>X: <span>UserCountryCode</span><span>&gt;</span>()<span> </span>{}<span>
</span><span>
</span><span></span><span>fn</span> <span>main</span>()<span> </span>{<span>
</span><span>    </span>test::<span>&lt;</span>(Smudge,<span> </span>_,<span> </span>CA)<span>&gt;</span>()<span>
</span><span></span>}<span>
</span></code></pre></div><p>While this doesn’t:</p>
<div><pre><code data-lang="rust"><span>fn</span> <span>test</span><span>&lt;</span>X: <span>UserCountryCode</span><span>&gt;</span>()<span> </span>{}<span>
</span><span>
</span><span></span><span>fn</span> <span>main</span>()<span> </span>{<span>
</span><span>    </span>test::<span>&lt;</span>(Smudge,<span> </span>_,<span> </span>US)<span>&gt;</span>()<span>
</span><span></span>}<span>
</span></code></pre></div><pre><code>error[E0277]: the trait bound `(Canada, US): CountryCode` is not satisfied
  --&gt; src/main.rs:32:12
   |
32 |     test::&lt;(Smudge, _, US)&gt;()
   |            ^^^^^^^^^^^^^^^ the trait `CountryCode` is not implemented for `(Canada, US)`
   |
   = help: the following other types implement trait `CountryCode`:
             (Canada, CA)
             (UnitedStates, US)
note: required for `(Smudge, Canada, US)` to implement `UserCountryCode`
  --&gt; src/main.rs:22:15
   |
22 | impl&lt;A, B, C&gt; UserCountryCode for (A, B, C)
   |               ^^^^^^^^^^^^^^^     ^^^^^^^^^
...
25 |     (B, C): CountryCode,
   |             ----------- unsatisfied trait bound introduced here
note: required by a bound in `test`
  --&gt; src/main.rs:29:12
   |
29 | fn test&lt;X: UserCountryCode&gt;() {}
   |            ^^^^^^^^^^^^^^^ required by this bound in `test`
</code></pre><h2 id="a-join-is-an-operation-in-the-set-monad">A join is an operation in the Set monad</h2>
<p>Let’s define an option type (in JavaScript).</p>
<div><pre><code data-lang="javascript"><span>let</span> Some <span>=</span> x =&gt; ({
    map<span>:</span> f =&gt; Some(f(x)),
    <span>// Sometimes called `bind`.
</span><span></span>    andThen<span>:</span> f =&gt; f(x),
    inspect<span>:</span> () =&gt; <span>`Some(</span><span>${</span>JSON.stringify(x)<span>}</span><span>)`</span>,
});

<span>let</span> None <span>=</span> () =&gt; ({
    map<span>:</span> () =&gt; None(),
    andThen<span>:</span> () =&gt; None(),
    inspect<span>:</span> () =&gt; <span>`None()`</span>,
});
</code></pre></div><p>Now, say we have some records, but they’re all optional. As in, we might not
have them, so we have to wrap them in <code>Some</code>:</p>
<div><pre><code data-lang="javascript"><span>let</span> user <span>=</span> Some({ name<span>:</span> <span>&#39;Smudge&#39;</span>, country<span>:</span> <span>&#39;Canada&#39;</span> });
<span>let</span> country1 <span>=</span> Some({ country<span>:</span> <span>&#39;Canada&#39;</span>, code<span>:</span> <span>&#39;CA&#39;</span> });
<span>let</span> country2 <span>=</span> Some({ country<span>:</span> <span>&#39;United States&#39;</span>, code<span>:</span> <span>&#39;US&#39;</span> });
</code></pre></div><p>Now we’ll write a function that takes two of these records and returns <code>Some</code> of their merging if they’re compatible, and <code>None</code> otherwise:</p>
<div><pre><code data-lang="javascript"><span>let</span> merge <span>=</span> (user, country) =&gt; {
    <span>if</span> (user.country <span>===</span> country.country) {
        <span>return</span> Some({ name<span>:</span> user.name, country<span>:</span> user.country, code<span>:</span> country.code });
    } <span>else</span> {
        <span>return</span> None();
    }
}
</code></pre></div><p>But since our actual records are optional, we need to wrap them in calls to <code>andThen</code>:</p>
<div><pre><code data-lang="javascript"><span>let</span> combine <span>=</span> (user, country) =&gt; {
    <span>return</span> user.andThen(user =&gt; {
        <span>return</span> country.andThen(country =&gt; {
            <span>return</span> merge(user, country);
        })
    });
}
</code></pre></div><p>Now we can see the results of calling this function with various values:</p>
<div><pre><code data-lang="javascript">console.log(combine(user, country1).inspect());
console.log(combine(user, country2).inspect());
console.log(combine(None(), country1).inspect());
console.log(combine(user, None()).inspect());
</code></pre></div><p>One interesting thing about the way we’ve set this up is that we can implement
our “container” type differently, but keep the implementation.</p>
<p>Let’s implement a different container, called <code>Rel</code>, which stores a set of records.
Now our <code>map</code> operates on every row, and our <code>andThen</code> returns another relation,
which all get concatenated to the new relation.</p>
<div><pre><code data-lang="javascript"><span>let</span> Rel <span>=</span> x =&gt; ({
    map<span>:</span> f =&gt; Rel(x.map(f)),
    andThen<span>:</span> f =&gt; Rel(x.flatMap(v =&gt; f(v).list())),
    list<span>:</span> () =&gt; x,
})
</code></pre></div><p>Now we can instantiate some data:</p>
<div><pre><code data-lang="javascript"><span>let</span> users <span>=</span> Rel([
    { name<span>:</span> <span>&#39;Smudge&#39;</span>, country<span>:</span> <span>&#39;Canada&#39;</span> },
    { name<span>:</span> <span>&#39;Sissel&#39;</span>, country<span>:</span> <span>&#39;Canada&#39;</span> },
    { name<span>:</span> <span>&#39;Petee&#39;</span>, country<span>:</span> <span>&#39;United States&#39;</span> },
]);

<span>let</span> countries <span>=</span> Rel([
    { country<span>:</span> <span>&#39;Canada&#39;</span>, code<span>:</span> <span>&#39;CA&#39;</span> },
    { country<span>:</span> <span>&#39;United States&#39;</span>, code<span>:</span> <span>&#39;US&#39;</span> },
]);
</code></pre></div><p>And try running the same function <code>combine</code> from before:</p>
<div><pre><code data-lang="javascript">console.log(combine(users, countries).list());
</code></pre></div><p>And we get the join of the two relations:</p>
<div><pre><code data-lang="javascript">[
  { name<span>:</span> <span>&#39;Smudge&#39;</span>, country<span>:</span> <span>&#39;Canada&#39;</span>, code<span>:</span> <span>&#39;CA&#39;</span> },
  { name<span>:</span> <span>&#39;Sissel&#39;</span>, country<span>:</span> <span>&#39;Canada&#39;</span>, code<span>:</span> <span>&#39;CA&#39;</span> },
  { name<span>:</span> <span>&#39;Petee&#39;</span>, country<span>:</span> <span>&#39;United States&#39;</span>, code<span>:</span> <span>&#39;US&#39;</span> }
]
</code></pre></div><h2 id="a-join-is-the-biggest-acceptable-relation">A join is the biggest acceptable relation</h2>
<p>For two relations \(R\) and \(S\), say a third relation \(T\) which has
all the columns from both is “acceptable” if it doesn’t invent any new
information.</p>
<p>By that I mean, if you look at any row in \(T\) and restrict it to just the
columns in \(R\), the resulting row exists in \(R\), and the same is true
for \(S\).</p>
<p>For instance, say our tables are:</p>
<h3 id="r">\(R\)</h3>
<table>
<thead>
<tr>
<th>user</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smudge</td>
<td>Canada</td>
</tr>
<tr>
<td>Sissel</td>
<td>Canada</td>
</tr>
<tr>
<td>Petee</td>
<td>United States</td>
</tr>
</tbody>
</table>
<h3 id="s">\(S\)</h3>
<table>
<thead>
<tr>
<th>country</th>
<th>country_code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Canada</td>
<td>CA</td>
</tr>
<tr>
<td>United States</td>
<td>US</td>
</tr>
</tbody>
</table>
<p>This \(T\) is unacceptable:</p>
<table>
<thead>
<tr>
<th>user</th>
<th>country</th>
<th>country_code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smudge</td>
<td>Canada</td>
<td>US</td>
</tr>
</tbody>
</table>
<p>Because if we restrict to the columns of \(S\),
\(\langle \texttt{country}, \texttt{country\_code} \rangle \), we get</p>
<table>
<thead>
<tr>
<th>country</th>
<th>country_code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Canada</td>
<td>US</td>
</tr>
</tbody>
</table>
<p>Which doesn’t exist in \(S\).</p>
<p>Notably, the empty relation is acceptable.
The <em>largest</em> acceptable relation, here, is</p>
<table>
<thead>
<tr>
<th>user</th>
<th>country</th>
<th>country_code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smudge</td>
<td>Canada</td>
<td>CA</td>
</tr>
<tr>
<td>Sissel</td>
<td>Canada</td>
<td>CA</td>
</tr>
<tr>
<td>Petee</td>
<td>United States</td>
<td>US</td>
</tr>
</tbody>
</table>
<p>This is the join of the two relations.</p>
<h2 id="a-join-is-ajoin">A join is a…join</h2>
<p>A <em>partial order</em> is a set equipped with a binary relation \(\le\) satisfying the following properties:</p>
<ol>
<li>Reflexivity: \(a \le a\) for all \(a\),</li>
<li>Antisymmetry: If \(a \le b\) and \(b \le a\), then \(a = b\), and</li>
<li>Transitivity: If \(a \le b\) and \(b \le c\), then \(a \le c\).</li>
</ol>
<p>(I provide this definition to be complete, but if it’s new to you, don’t
expect the above to give you the intuition you’d need to actually be able to
think about it.)</p>
<p>In a partial order, if two elements \(a, b\) always have a <em>least upper bound</em>
(that is, a smallest \(x\) which \(a\) and \(b\) are both \(\le\)), then
that is called their <em>join</em> and is written \(a \vee b\).</p>
<p>Define the following partial order on relations: \(R \le Q\) if:</p>
<ol>
<li>\(Q\) contains all the columns in \(R\), and</li>
<li>restricting any row in \(Q\) to just the columns in \(R\) gives a row in \(R\).</li>
</ol>
<p>Then for two relations \(R\) and \(S\), \(R \vee S\) exists, and it’s their join (in both senses of the word).</p>
<h2 id="a-join-is-a-ring-product">A join is a ring product</h2>
<p>You might know from high school how to manipulate polynomials. If \(a\), \(b\), and \(c\) are all unknowns, the following expressions are all equivalent:</p>
<p>\[
a(b + c) = ab + ac = ba +ca = ca + ba = (c + b)a
\]</p>
<p>We can represent a relation algebraically in this way. A row is the product of its columns. We represent the row</p>
<table>
<thead>
<tr>
<th>user</th>
<th>country_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smudge</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>as the product of two (column name, column value) pairs:</p>
<p>\[
[\text{user}=\texttt{Smudge}]
[\text{country\_id}=\texttt{1}]
\]</p>
<p>A relation is the sum of its rows:</p>
<p>\[
R = \begin{aligned}
&amp;[\text{user}=\texttt{Smudge}][\text{country\_id}=\texttt{1}] \cr
+&amp;[\text{user}=\texttt{Sissel}][\text{country\_id}=\texttt{1}] \cr
+&amp;[\text{user}=\texttt{Petee}][\text{country\_id}=\texttt{2}] \cr
\end{aligned}
\]</p>
<p>We also have the special value 1, satisfying \(1x = x\) for all \(x\).</p>
<p>We then add the following rules for simplifying these expressions:</p>
<p>Idempotence:</p>
<p>$$
[x = y][x = y] = [x = y]
$$</p>
<p>and Contradiction:</p>
<p>$$
[x = y][x = z] = 0 \text{ if }y \not= z.
$$</p>
<p>our lookup table here is</p>
<p>\[
S = \begin{aligned}
&amp;[\text{country\_id}=\texttt{1}][\text{country}=\texttt{Canada}][\text{country\_code}=\texttt{CA}] \cr
+&amp;[\text{country\_id}=\texttt{2}][\text{country}=\texttt{United States}][\text{country\_code}=\texttt{US}] \cr
\end{aligned}
\]</p>
<p>Then something interesting happens if we take the product of these two expressions, obeying the normal rules of polynomial rewriting such as distributivity:</p>
<p>\[
\begin{aligned}
&amp;RS = \cr &amp;\left(\begin{aligned}
&amp;[\text{user}=\texttt{Smudge}][\text{country\_id}=\texttt{1}] \cr
+&amp;[\text{user}=\texttt{Sissel}][\text{country\_id}=\texttt{1}]\cr
+&amp;[\text{user}=\texttt{Petee}][\text{country\_id}=\texttt{2}] \cr
\end{aligned}\right) \cr
&amp;\left(
\begin{aligned}
&amp;[\text{country\_id}=\texttt{1}][\text{country}=\texttt{Canada}][\text{country\_code}=\texttt{CA}] \cr
+&amp;[\text{country\_id}=\texttt{2}][\text{country}=\texttt{United States}][\text{country\_code}=\texttt{US}] \cr
\end{aligned}
\right)
\end{aligned}
\]</p>
<p>If you apply the laws of distributivity and commutativity here, you’ll wind up with the following:</p>
<p>\[
\begin{aligned}
&amp;[\text{user}=\texttt{Smudge}][\text{country\_id}=\texttt{1}]
[\text{country}=\texttt{Canada}]
[\text{country\_code}=\texttt{CA}] \cr
+&amp;[\text{user}=\texttt{Sissel}][\text{country\_id}=\texttt{1}][\text{country}=\texttt{Canada}]
[\text{country\_code}=\texttt{CA}]\cr
+&amp;[\text{user}=\texttt{Petee}][\text{country\_id}=\texttt{2}][\text{country}=\texttt{United States}]
[\text{country\_code}=\texttt{US}] \cr
\end{aligned}
\]</p>
<p>Which is precisely the join of the two relations (I’m told this is a tensor contraction).</p>


  </div></div>
  </body>
</html>
