<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://plbrault.com/blog-posts/i-coded-something-dumb-and-im-proud-of-it-en/">Original</a>
    <h1>I coded something dumb and I&#39;m proud of it</h1>
    
    <div id="readability-page-1" class="page"><div><p>I recently got back into the development of an open source game I released last summer, <em><a href="https://plbrault.com/blog-posts/i-created-the-nerdierst-game-ever-en/">You&#39;re the OS!</a></em>. It is a browser game, written in Python and compiled to WebAssembly, in which, as the title indicates, you are the operating system of a computer. As such, you have to manage processes, memory and I/O events.</p>
<p>In case you haven&#39;t played the game, here is a very short summary of its core mechanics: you have some CPU cores, and you have a list of processes with varying levels of starvation, and you have to make them take turns on CPU cores and make sure none of them starves.</p>
<p>
    <img alt="A glimpse of the game" src="https://plbrault.com/blog-images/youre-the-os.png"/>
</p>
<p>Recently, I added a power-up to the game: after 6 minutes of playing, you get a <code>Sort</code> button that, when clicked, sorts idle processes in decreasing order of starvation. I decided that the game would show the sorting algorithm being executed, by moving around processes as it happens. The sorting algorithm I wanted to use is <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a>. In order for it to work like I wanted, there was 2 problems to overcome:</p>
<p>1 - This is a game, with a main loop that completely redraws everything on the screen 60 times per second. Therefore, it was not just a matter of writing a Quicksort function that performs an animation between each recursion. I needed to somehow create a function that performs a single step of the algorithm, then gives back control to the main loop (which ironically sounds just like an OS&#39; preemptive scheduling) for the duration of the animation frames, before being executed again from where it was interrupted.</p>
<p>2 - Just to make it more complicated, the list can change <em>while</em> it is being sorted, as processes can be killed, assigned to a CPU core, or removed from a CPU core.</p>
<p>Now, I want to share a comment from my code, detailing the solution that I came up with. I am quite proud of my solution, but not because it is particularly clever — on the contrary, <strong>I like it precisely because it is dumb</strong>:</p>
<blockquote>
<p><em>This method creates the visual illusion that the next recursion of the quicksort algorithm is performed on the idle processes. In reality, the algorithm is always performed from the beginning, and stops as soon as a recursion that actually changes the array has happened. This way, the intended in-game result is achieved while avoiding the need to keep track of the algorithm&#39;s state, and a correct end result is ensured even when the idle process list changes between recursions.</em></p>
</blockquote>
<p>To try and better explain what the comment means, here is the code of my Quicksort function that stops as soon as an actual change to the array is detected:</p>

<pre><code><span>def</span> <span>simulate_next_sort_step</span>(<span>arr</span>: [<span>Process</span>]):
    
    <span>if</span> <span>len</span>(<span>arr</span>) <span>&lt;=</span> <span>1</span>:
        <span>return</span> <span>arr</span>
    <span>pivot</span> = <span>arr</span>[<span>len</span>(<span>arr</span>) <span>//</span> <span>2</span>]
    <span>left</span> = [<span>process</span> <span>for</span> <span>process</span> <span>in</span> <span>arr</span> <span>if</span> <span>process</span>.<span>sort_key</span> <span>&lt;</span> <span>pivot</span>.<span>sort_key</span>]
    <span>middle</span> = [<span>process</span> <span>for</span> <span>process</span> <span>in</span> <span>arr</span> <span>if</span> <span>process</span>.<span>sort_key</span> <span>==</span> <span>pivot</span>.<span>sort_key</span>]
    <span>right</span> = [<span>process</span> <span>for</span> <span>process</span> <span>in</span> <span>arr</span> <span>if</span> <span>process</span>.<span>sort_key</span> <span>&gt;</span> <span>pivot</span>.<span>sort_key</span>]

    
    <span>if</span> (<span>left</span> <span>+</span> <span>middle</span> <span>+</span> <span>right</span>) <span>==</span> <span>arr</span>:
        <span>return</span> <span>simulate_next_sort_step</span>(<span>left</span>) <span>+</span> <span>middle</span> <span>+</span> <span>simulate_next_sort_step</span>(<span>right</span>)
    <span>return</span> <span>left</span> <span>+</span> <span>middle</span> <span>+</span> <span>right</span>
</code></pre>
<p>You see, I realized along the way that the premise of my first problem described above was mistaken: my need was not, in fact, to implement a function that only executes the next recursion in the quicksort algorithm. My need was to implement an animation that <em>pretends</em> to only execute the next recursion in the quicksort algorithm. My solution does exactly that, in a stateless manner. It is a stupid, inefficient solution — but it is a solution that works, and completely avoids the corner case stated in my second problem: if the content of the array changes along the way, it will naturally cause the illusion of backtracking in the algorithm.</p>
<p>Of course, I could have gone through the trouble of actually figuring out a version of Quicksort that resumes from the previous function call and only executes one recursion. This would have been way more efficient, algorithmically speaking. But it would have also been way more complex, would have produced code that was harder to understand, and would have required addressing corner cases.</p>
<p>The thing is: I did not need the efficiency. This is a terrible implementation of Quicksort, but that terribleness does not really make a dent in the game&#39;s performance, knowing that the number of processes that need to be sorted at all times will never exceed 42 — which is a lot for the players of my game, but is nothing for an actual computer.</p>
<p>This solution that I came up with is a testament to the KISS principle (<em>&#34;Keep It Simple, Stupid&#34;</em>). It is also a good reminder that part of finding a good solution to a problem is to make sure that the problem is correctly identified.</p></div></div>
  </body>
</html>
