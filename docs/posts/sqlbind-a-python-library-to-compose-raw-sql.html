<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/baverman/sqlbind">Original</a>
    <h1>Show HN: Sqlbind a Python library to compose raw SQL</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>sqlbind</strong> allows to bind parameters in text based raw SQL queries.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q = sqlbind.Dialect.default()
&gt;&gt;&gt; email = &#39;some@domain.com&#39;
&gt;&gt;&gt; sql = f&#39;SELECT * FROM users WHERE email = {q/email}&#39;
&gt;&gt;&gt; sql
&#39;SELECT * FROM users WHERE email = ?&#39;
&gt;&gt;&gt; q
[&#39;some@domain.com&#39;]
&gt;&gt;&gt; data = connection.execute(sql, q)
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>default</span>()
<span>&gt;&gt;</span><span>&gt;</span> <span>email</span> <span>=</span> <span>&#39;some@domain.com&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>sql</span> <span>=</span> <span>f&#39;SELECT * FROM users WHERE email = <span><span>{</span><span>q</span><span>/</span><span>email</span><span>}</span></span>&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>sql</span>
<span>&#39;SELECT * FROM users WHERE email = ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>
[<span>&#39;some@domain.com&#39;</span>]
<span>&gt;&gt;</span><span>&gt;</span> <span>data</span> <span>=</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">Supports all <a href="https://peps.python.org/pep-0249/#paramstyle" rel="nofollow">DBAPI parameter styles</a>. Isn&#39;t limited by DBAPI compatible drivers and
could be used with anything accepting raw SQL query and parameters in some way. For example
<strong>sqlbind</strong> could be used with <a href="https://docs.sqlalchemy.org/en/20/core/sqlelement.html#sqlalchemy.sql.expression.text" rel="nofollow">SQLAlchemy textual queries</a>. Or with <a href="https://clickhouse-driver.readthedocs.io/en/latest/quickstart.html#selecting-data" rel="nofollow">clickhouse-driver</a>&#39;s
non-DBAPI interface.</p>



<p dir="auto">ORMs are great and could be used effectively for a huge number of tasks. But
after many years with SQLAlchemy I&#39;ve noticed some repeating patterns:</p>
<ul dir="auto">
<li>
<p dir="auto">It&#39;s really not an easy task to decipher complex SQLAlchemy expression back into SQL.
Especially when CTEs, sub-queries, nested queries or self-referential queries
are involved. It composes quite well but it takes too much effort to write
and read SQLAlchemy queries. For novices it could be a hard time to deal
with it.</p>
</li>
<li>
<p dir="auto">Most of reporting queries are big enough already not to be bothered with ORMs and
use raw SQL anyway. This kind of SQL often requires dynamic constructs and becomes
string fiddling contraption.</p>
</li>
<li>
<p dir="auto">For a few tasks ORMs bring too much overhead and the only solution is to get
down to raw DBAPI connection and raw SQL.</p>
</li>
<li>
<p dir="auto">(<em>Minor personal grudge, please ignore it</em>) For some ORMs (like Django ORM) your
SQL intuition could be useless and requires deep ORM understanding. To the
side: sqlalchemy hybrid properties, cough.</p>
</li>
</ul>
<p dir="auto">It boils down to one thing: from time to time you have to write raw
SQL queries. I could highlight 3 types of queries:</p>
<ol dir="auto">
<li>
<p dir="auto">Fixed queries. They don&#39;t contain any parameters. For example
<code>SELECT id, name FROM users ORDER BY registered DESC LIMIT 10</code>.
In general fixed queries or fixed query parts compose well and don&#39;t require any
special treatment. Python&#39;s f-strings are enough.</p>
</li>
<li>
<p dir="auto">Static queries. They contain parameters but structure is fully known beforehand.
For example <code>SELECT id, name FROM users WHERE email = :email LIMIT 1</code>. They
are also could be composed without large issues, especially for connection
drivers supporting named parameters (<code>:param</code>, <code>%(param)s</code>) and accepting dicts as parameters.
Although for positional connection drivers (<code>%s</code>, <code>?</code>) composition requires careful
parameter tracking and queries could be fragile to change.</p>
</li>
<li>
<p dir="auto">Dynamic queries. Query part presence could depend on parameter value or
external condition. For example to provide result on input filter you have
to add CTE and corresponding JOIN to a query. Or add filters only for non
<code>None</code> input values. ORMs are effective for composing such queries. Using
raw SQL are almost impossible for abstraction and leads to a complex
boilerplate heavy code.</p>
</li>
</ol>
<p dir="auto">Note: here and in following sections I deliberately use simple examples. In real life
there is no need to use <strong>sqlbind</strong> for such kind of queries.</p>
<p dir="auto">Note: by composing I mean ability to assemble a final query from parts which could be
abstracted and reused.</p>
<p dir="auto"><strong>sqlbind</strong> tries to address issues with static and dynamic query types. It tracks
parameter binds and could help with dynamic query parts.</p>

<p dir="auto">Some things to consider:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>sqlbind</strong> tries to provide an API for a simple composition of raw SQL. Most
operations return string-like objects ready to be inserted in the final query.
<strong>sqlbind</strong> does trivial things and is easy to reason about.</p>
</li>
<li>
<p dir="auto">There is a large set of functions/methods to address dynamic queries but you
haven&#39;t use it inline in a single query string. You could use variables to
keep query parts and stitch resulted SQL from these parts.</p>
</li>
<li>
<p dir="auto">This README misses large portions of API. Feel free to explore doc strings
with examples of fully strictly type-hinted <strong>sqlbind</strong>&#39;s source code!</p>
</li>
</ul>
<p dir="auto">General use case looks like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# a global alias to a dialect used by connection backend, see `sqlbind.Dialect`
QParams = sqlbind.Dialect.some_dialect

def get_my_data(value1, value2):
    # Construct empty fresh sqlbind.QueryParams
    q = QParams()

    # Use `q` to bind parameter values in SQL string.
    sql = f&#39;SELECT * FROM table WHERE field1 = {q/value1} AND field2 &gt; {q/value2}&#39;

    # Pass query and parameters into connection&#39;s execute.
    return get_connection().execute(sql, q).fetchall()"><pre><span># a global alias to a dialect used by connection backend, see `sqlbind.Dialect`</span>
<span>QParams</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>some_dialect</span>

<span>def</span> <span>get_my_data</span>(<span>value1</span>, <span>value2</span>):
    <span># Construct empty fresh sqlbind.QueryParams</span>
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span># Use `q` to bind parameter values in SQL string.</span>
    <span>sql</span> <span>=</span> <span>f&#39;SELECT * FROM table WHERE field1 = <span><span>{</span><span>q</span><span>/</span><span>value1</span><span>}</span></span> AND field2 &gt; <span><span>{</span><span>q</span><span>/</span><span>value2</span><span>}</span></span>&#39;</span>

    <span># Pass query and parameters into connection&#39;s execute.</span>
    <span>return</span> <span>get_connection</span>().<span>execute</span>(<span>sql</span>, <span>q</span>).<span>fetchall</span>()</pre></div>

<p dir="auto">For queries or query parts with a known structure the most simple way to bind a parameter is to
use bind operator <code>/</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; date = &#34;2023-01-01&#34;
&gt;&gt;&gt; q = sqlbind.Dialect.default()
&gt;&gt;&gt; f&#39;SELECT * FROM users WHERE registered &gt; {q/date}&#39;
&#39;SELECT * FROM users WHERE registered &gt; ?&#39;
&gt;&gt;&gt; q
[&#39;2023-01-01&#39;]
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>date</span> <span>=</span> <span>&#34;2023-01-01&#34;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>default</span>()
<span>&gt;&gt;</span><span>&gt;</span> <span>f&#39;SELECT * FROM users WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>date</span><span>}</span></span>&#39;</span>
<span>&#39;SELECT * FROM users WHERE registered &gt; ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>
[<span>&#39;2023-01-01&#39;</span>]</pre></div>
<p dir="auto">Or for named style parameters:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; date = &#34;2023-01-01&#34;
&gt;&gt;&gt; q = sqlbind.Dialect.default_named()
&gt;&gt;&gt; f&#39;SELECT * FROM users WHERE registered &gt; {q/date}&#39;
&#39;SELECT * FROM users WHERE registered &gt; :p0&#39;
&gt;&gt;&gt; q
{&#39;p0&#39;: &#39;2023-01-01&#39;}
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>date</span> <span>=</span> <span>&#34;2023-01-01&#34;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>default_named</span>()
<span>&gt;&gt;</span><span>&gt;</span> <span>f&#39;SELECT * FROM users WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>date</span><span>}</span></span>&#39;</span>
<span>&#39;SELECT * FROM users WHERE registered &gt; :p0&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>
{<span>&#39;p0&#39;</span>: <span>&#39;2023-01-01&#39;</span>}</pre></div>
<p dir="auto">There is no any magic. Bind operator returns a string with a placeholder for a
corresponding dialect and adds parameter&#39;s value to <code>q</code> object. That&#39;s all.
<code>q</code> object is inherited from a <code>dict</code> or a <code>list</code> depending from a used
dialect.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; value = 10
&gt;&gt;&gt; q = sqlbind.Dialect.default()
&gt;&gt;&gt; q/value
&#39;?&#39;
&gt;&gt;&gt; q
[10]
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>value</span> <span>=</span> <span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>default</span>()
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span><span>/</span><span>value</span>
<span>&#39;?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>
[<span>10</span>]</pre></div>
<p dir="auto">Note: there is no much value in <strong>sqlbind</strong> if you have only static
queries and use connection backends accepting named parameters.</p>

<p dir="auto">Here begins a fun part. We can&#39;t use simple binds for dynamic queries.
For example we have a function returning recently registered users:</p>
<div dir="auto" data-snippet-clipboard-copy-content="def get_fresh_users(registered_since: datetime):
    q = QParams()  # an alias to some dialect to construct sqlbind.QueryParams instance
    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()  <span># an alias to some dialect to construct sqlbind.QueryParams instance</span>
    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">And later there is a new requirement for the function. It should return only
enabled or only disabled users if corresponding argument is passed.</p>
<div dir="auto" data-snippet-clipboard-copy-content="def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    if enabled is not None:
        enabled_filter = f&#39; AND enabled = {q/enabled}&#39;
    else:
        enabled_filter = &#39;&#39;

    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since} {enabled_filter}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>if</span> <span>enabled</span> <span>is</span> <span>not</span> <span>None</span>:
        <span>enabled_filter</span> <span>=</span> <span>f&#39; AND enabled = <span><span>{</span><span>q</span><span>/</span><span>enabled</span><span>}</span></span>&#39;</span>
    <span>else</span>:
        <span>enabled_filter</span> <span>=</span> <span>&#39;&#39;</span>

    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span> <span><span>{</span><span>enabled_filter</span><span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">It looks almost pretty. See how <code>q/enabled</code> helped to track additional parameter.
But you can predict where we are going. Another one or two
additional filters and it would be a complete mess. Take note how <code>WHERE</code> lost <code>AND</code>
between two filters.</p>

<p dir="auto">In reality bind operator <code>/</code> is a sugar on top of generic <strong>sqlbind</strong>&#39;s API to
bind parameters via q-templates.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q = sqlbind.Dialect.default()
&gt;&gt;&gt; q(&#39;field BETWEEN {} AND {}&#39;, 10, 20)
&#39;field BETWEEN ? AND ?&#39;
&gt;&gt;&gt; q
[10, 20]
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>default</span>()
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>(<span>&#39;field BETWEEN {} AND {}&#39;</span>, <span>10</span>, <span>20</span>)
<span>&#39;field BETWEEN ? AND ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>
[<span>10</span>, <span>20</span>]</pre></div>
<p dir="auto"><code>QueryParams</code> <code>q</code> object is also a callable accepting a template with <code>{}</code>
placeholders and following parameters to substitute. <code>q/value</code> is same as calling
<code>q(&#39;{}&#39;, value)</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q/10
&#39;?&#39;
&gt;&gt;&gt; q(&#39;{}&#39;, 10)
&#39;?&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span><span>/</span><span>10</span>
<span>&#39;?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>(<span>&#39;{}&#39;</span>, <span>10</span>)
<span>&#39;?&#39;</span></pre></div>
<p dir="auto">You could use q-templates to bind parameters in complex SQL expressions.</p>

<p dir="auto"><code>q.cond</code> could render a q-template as an empty string based on some condition.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; enabled = True
&gt;&gt;&gt; q.cond(enabled is not None, &#39; AND enabled = {}&#39;, enabled)
&#39; AND enabled = ?&#39;
&gt;&gt;&gt; enabled = None
&gt;&gt;&gt; q.cond(enabled is not None, &#39; AND enabled = {}&#39;, enabled)
&#39;&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>enabled</span> <span>=</span> <span>True</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>cond</span>(<span>enabled</span> <span>is</span> <span>not</span> <span>None</span>, <span>&#39; AND enabled = {}&#39;</span>, <span>enabled</span>)
<span>&#39; AND enabled = ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>enabled</span> <span>=</span> <span>None</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>cond</span>(<span>enabled</span> <span>is</span> <span>not</span> <span>None</span>, <span>&#39; AND enabled = {}&#39;</span>, <span>enabled</span>)
<span>&#39;&#39;</span></pre></div>
<p dir="auto"><code>q.cond</code> is a generic form. To remove a repetition (<code>enabled is not None</code>/<code>enabled</code>) when value is used both in a condition and as a parameter
value there are two helpers for most common cases:</p>
<ul dir="auto">
<li><code>q.not_none</code>: to check value is not None.</li>
<li><code>q.truthy</code>: to check value&#39;s trueness (<code>bool(value) is True</code>). <code>not_empty</code>
could be used as an alias to <code>truthy</code>.</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; enabled = True
&gt;&gt;&gt; q.not_none(&#39; AND enabled = {}&#39;, enabled)
&#39; AND enabled = ?&#39;
&gt;&gt;&gt; enabled = None
&gt;&gt;&gt; q.not_none(&#39; AND enabled = {}&#39;, enabled)
&#39;&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>enabled</span> <span>=</span> <span>True</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>not_none</span>(<span>&#39; AND enabled = {}&#39;</span>, <span>enabled</span>)
<span>&#39; AND enabled = ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>enabled</span> <span>=</span> <span>None</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>not_none</span>(<span>&#39; AND enabled = {}&#39;</span>, <span>enabled</span>)
<span>&#39;&#39;</span></pre></div>
<p dir="auto">Let&#39;s try it in the function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    enabled_filter = q.not_none(&#39; AND enabled = {}&#39;, enabled)

    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since} {enabled_filter}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>enabled_filter</span> <span>=</span> <span>q</span>.<span>not_none</span>(<span>&#39; AND enabled = {}&#39;</span>, <span>enabled</span>)

    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span> <span><span>{</span><span>enabled_filter</span><span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">Hmm. But really nothing was changed. You could write previous code with ternary
if/else and it would look the same from semantic standpoint. May be use it
inline?</p>
<div dir="auto" data-snippet-clipboard-copy-content="def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since}
              {q.not_none(&#39; AND enabled = {}&#39;, enabled)}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span></span>
<span>              <span><span>{</span><span>q</span>.<span>not_none</span>(<span>&#39; AND enabled = {}&#39;</span>, <span>enabled</span>)<span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">Ugh. Abomination, to say at least.</p>
<ul dir="auto">
<li><code>AND</code> in the middle of a cryptic expression.</li>
<li><code>q.not_none</code> and <code>enabled</code> are far away and it&#39;s not obvious they are connected</li>
<li>expression is too long and noisy</li>
</ul>
<p dir="auto">Let&#39;s tackle issues bit by bit.</p>

<p dir="auto">Prependers could render non-empty inputs with corresponding prefixes and empty
string otherwise.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; AND_(&#39;field1 &gt; 1&#39;, &#39;field2 &lt; 1&#39;)
&#39;AND field1 &gt; 1 AND field2 &lt; 1&#39;
&gt;&gt;&gt; OR_(&#39;field1 &gt; 1&#39;, &#39;field2 &lt; 1&#39;)
&#39;OR field1 &gt; 1 OR field2 &lt; 1&#39;
&gt;&gt;&gt; AND_(q.not_none(&#39;enabled = {}&#39;, True))
&#39;AND enabled = ?&#39;
&gt;&gt;&gt; AND_(q.not_none(&#39;enabled = {}&#39;, None))
&#39;&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>AND_</span>(<span>&#39;field1 &gt; 1&#39;</span>, <span>&#39;field2 &lt; 1&#39;</span>)
<span>&#39;AND field1 &gt; 1 AND field2 &lt; 1&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>OR_</span>(<span>&#39;field1 &gt; 1&#39;</span>, <span>&#39;field2 &lt; 1&#39;</span>)
<span>&#39;OR field1 &gt; 1 OR field2 &lt; 1&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>AND_</span>(<span>q</span>.<span>not_none</span>(<span>&#39;enabled = {}&#39;</span>, <span>True</span>))
<span>&#39;AND enabled = ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>AND_</span>(<span>q</span>.<span>not_none</span>(<span>&#39;enabled = {}&#39;</span>, <span>None</span>))
<span>&#39;&#39;</span></pre></div>
<p dir="auto">Our function with prependers:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from sqlbind import AND_

def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since}
              {AND_(q.not_none(&#39;enabled = {}&#39;, enabled))}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>from</span> <span>sqlbind</span> <span>import</span> <span>AND_</span>

<span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span></span>
<span>              <span><span>{</span><span>AND_</span>(<span>q</span>.<span>not_none</span>(<span>&#39;enabled = {}&#39;</span>, <span>enabled</span>))<span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">At least AND is almost on it&#39;s place in SQL structure.</p>

<p dir="auto">Conditional markers <code>sqlbind.not_none</code>/<code>sqlbind.truthy</code>/<code>sqlbind.cond</code> allows to tie conditionals
with a value via <code>/</code> operator:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q(&#39;enabled = {}&#39;, sqlbind.not_none/10)
&#39;enabled = ?&#39;
&gt;&gt;&gt; q(&#39;enabled = {}&#39;, sqlbind.not_none/None)
&#39;&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span>(<span>&#39;enabled = {}&#39;</span>, <span>sqlbind</span>.<span>not_none</span><span>/</span><span>10</span>)
<span>&#39;enabled = ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>(<span>&#39;enabled = {}&#39;</span>, <span>sqlbind</span>.<span>not_none</span><span>/</span><span>None</span>)
<span>&#39;&#39;</span></pre></div>
<p dir="auto">Conditional markers return value itself or special UNDEFINED object.
UNDEFINED parameters force expressions to be rendered as empty strings.</p>
<p dir="auto"><strong><code>sqlbind.not_none</code></strong> returns <code>UNDEFINED</code> if value is <code>None</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; sqlbind.not_none/10
10
&gt;&gt;&gt; sqlbind.not_none/None is sqlbind.UNDEFINED
True
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>not_none</span><span>/</span><span>10</span>
<span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>not_none</span><span>/</span><span>None</span> <span>is</span> <span>sqlbind</span>.<span>UNDEFINED</span>
<span>True</span></pre></div>
<p dir="auto"><strong><code>sqlbind.truthy</code></strong> or <code>sqlbind.not_empty</code> returns <code>UNDEFINED</code> if <code>bool(value) != True</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; sqlbind.truthy/10
10
&gt;&gt;&gt; sqlbind.not_empty/10
10
&gt;&gt;&gt; sqlbind.truthy/0 is sqlbind.UNDEFINED
True
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>truthy</span><span>/</span><span>10</span>
<span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>not_empty</span><span>/</span><span>10</span>
<span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>truthy</span><span>/</span><span>0</span> <span>is</span> <span>sqlbind</span>.<span>UNDEFINED</span>
<span>True</span></pre></div>
<p dir="auto"><strong><code>sqlbind.cond</code></strong> returns <code>UNDEFINED</code> if condition is False:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; sqlbind.cond(True)/10
10
&gt;&gt;&gt; sqlbind.cond(False)/10 is sqlbind.UNDEFINED
True
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>cond</span>(<span>True</span>)<span>/</span><span>10</span>
<span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>sqlbind</span>.<span>cond</span>(<span>False</span>)<span>/</span><span>10</span> <span>is</span> <span>sqlbind</span>.<span>UNDEFINED</span>
<span>True</span></pre></div>
<p dir="auto">Note: <code>sqlbind.cond</code> is almost always awkward to use inline in real life and exists largely for symmetry with <code>q.cond</code>.</p>
<p dir="auto">Rewritten function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from sqlbind import AND_, not_none

def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since}
              {AND_(q(&#39;enabled = {}&#39;, not_none/enabled))}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>from</span> <span>sqlbind</span> <span>import</span> <span>AND_</span>, <span>not_none</span>

<span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span></span>
<span>              <span><span>{</span><span>AND_</span>(<span>q</span>(<span>&#39;enabled = {}&#39;</span>, <span>not_none</span><span>/</span><span>enabled</span>))<span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">Almost there. May be there is a way to reduce number of quotes inside <code>AND_</code>?</p>

<p dir="auto">q-expressions allow to generate templated results with infix operators.</p>
<p dir="auto">Any unknown attribute access to <code>q</code> object returns <code>QExpr</code> which has str
conversion as an attribute name:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; str(q.field)
&#39;field&#39;
&gt;&gt;&gt; str(q.table.field)
&#39;table.field&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>str</span>(<span>q</span>.<span>field</span>)
<span>&#39;field&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>str</span>(<span>q</span>.<span>table</span>.<span>field</span>)
<span>&#39;table.field&#39;</span></pre></div>
<p dir="auto"><code>q</code> has a number of attributes itself those names could conflict with existing
DB tables/columns. To resolve conflicts you could use <code>q._.</code> (stare) expression:</p>

<p dir="auto">Real DB tables/columns could use quite peculiar names. You could youse <code>q._</code>
(pirate) expression to construct <code>QExpr</code> from any string:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; str(q._(&#39;&#34;weird table&#34;.&#34;weird column&#34;&#39;))
&#39;&#34;weird table&#34;.&#34;weird column&#34;&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>str</span>(<span>q</span>.<span>_</span>(<span>&#39;&#34;weird table&#34;.&#34;weird column&#34;&#39;</span>))
<span>&#39;&#34;weird table&#34;.&#34;weird column&#34;&#39;</span></pre></div>
<p dir="auto"><code>QExpr</code> object knows about parent <code>q</code> object and defines a set of infix operators
allowing to bind a right value:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q.field &gt; 10
&#39;field &gt; ?&#39;
&gt;&gt;&gt; q.table.field == 20
&#39;table.field = ?&#39;
&gt;&gt;&gt; q._.table.field == None
&#39;table.field IS NULL&#39;
&gt;&gt;&gt; q._(&#39;&#34;my column&#34;&#39;) != None
&#39;&#34;my column&#34; IS NOT NULL&#39;
&gt;&gt;&gt; q.field &lt;= not_none/None  # conditional marks also work!
&#39;&#39;
&gt;&gt;&gt; q.field.IN(not_none/[10]) # BTW sqlbind has workaround for SQLite to deal with arrays in IN
&#39;field IN ?&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>field</span> <span>&gt;</span> <span>10</span>
<span>&#39;field &gt; ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>table</span>.<span>field</span> <span>==</span> <span>20</span>
<span>&#39;table.field = ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>_</span>.<span>table</span>.<span>field</span> <span>==</span> <span>None</span>
<span>&#39;table.field IS NULL&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>_</span>(<span>&#39;&#34;my column&#34;&#39;</span>) <span>!=</span> <span>None</span>
<span>&#39;&#34;my column&#34; IS NOT NULL&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>field</span> <span>&lt;=</span> <span>not_none</span><span>/</span><span>None</span>  <span># conditional marks also work!</span>
<span>&#39;&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>.<span>field</span>.<span>IN</span>(<span>not_none</span><span>/</span>[<span>10</span>]) <span># BTW sqlbind has workaround for SQLite to deal with arrays in IN</span>
<span>&#39;field IN ?&#39;</span></pre></div>
<p dir="auto">It could look like a hack and feel ORM-ish but there is no any
expression trees and tree compilation passes. q-expressions
are immediately rendered as strings and simple to reason about.</p>
<p dir="auto">Also set of operations is really small it includes only comparisons and <code>QExpr.IN</code>.</p>
<p dir="auto">Let&#39;s use q-expressions with the function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from sqlbind import AND_, not_none

def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    sql = f&#39;&#39;&#39;\
        SELECT * FROM users
        WHERE registered &gt; {q/registered_since}
              {AND_(q.enabled == not_none/enabled)}
        ORDER BY registered
    &#39;&#39;&#39;
    return connection.execute(sql, q)"><pre><span>from</span> <span>sqlbind</span> <span>import</span> <span>AND_</span>, <span>not_none</span>

<span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>sql</span> <span>=</span> <span>f&#39;&#39;&#39;<span>\</span></span>
<span><span></span>        SELECT * FROM users</span>
<span>        WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span></span>
<span>              <span><span>{</span><span>AND_</span>(<span>q</span>.<span>enabled</span> <span>==</span> <span>not_none</span><span>/</span><span>enabled</span>)<span>}</span></span></span>
<span>        ORDER BY registered</span>
<span>    &#39;&#39;&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">I have no any other tricks. It&#39;s the final inline version. I can&#39;t make it
more pretty or readable. It&#39;s true, inline expressions looks a bit noisy and to
make it manageable try to extract as much logic and use only <code>not_none</code> conditional marker.</p>
<p dir="auto">IMHO instead of</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; now = None
&gt;&gt;&gt; show_only_enabled = True
&gt;&gt;&gt; f&#39;SELECT * FROM users WHERE registered &gt; {q/((now or datetime.utcnow()) - timedelta(days=30))} {AND_(q.enabled == cond(show_only_enabled)/1)}&#39;
&#39;SELECT * FROM users WHERE registered &gt; ? AND enabled = ?&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>now</span> <span>=</span> <span>None</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>show_only_enabled</span> <span>=</span> <span>True</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>f&#39;SELECT * FROM users WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span>((<span>now</span> <span>or</span> <span>datetime</span>.<span>utcnow</span>()) <span>-</span> <span>timedelta</span>(<span>days</span><span>=</span><span>30</span>))<span>}</span></span> <span><span>{</span><span>AND_</span>(<span>q</span>.<span>enabled</span> <span>==</span> <span>cond</span>(<span>show_only_enabled</span>)<span>/</span><span>1</span>)<span>}</span></span>&#39;</span>
<span>&#39;SELECT * FROM users WHERE registered &gt; ? AND enabled = ?&#39;</span></pre></div>
<p dir="auto">please consider to use:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; now = None
&gt;&gt;&gt; show_only_enabled = True
&gt;&gt;&gt; registered_since = (now or datetime.utcnow()) - timedelta(days=30)
&gt;&gt;&gt; enabled = 1 if show_only_enabled else None
&gt;&gt;&gt; f&#39;SELECT * FROM users WHERE registered &gt; {q/registered_since} {AND_(q.enabled == not_none/enabled)}&#39;
&#39;SELECT * FROM users WHERE registered &gt; ? AND enabled = ?&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>now</span> <span>=</span> <span>None</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>show_only_enabled</span> <span>=</span> <span>True</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>registered_since</span> <span>=</span> (<span>now</span> <span>or</span> <span>datetime</span>.<span>utcnow</span>()) <span>-</span> <span>timedelta</span>(<span>days</span><span>=</span><span>30</span>)
<span>&gt;&gt;</span><span>&gt;</span> <span>enabled</span> <span>=</span> <span>1</span> <span>if</span> <span>show_only_enabled</span> <span>else</span> <span>None</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>f&#39;SELECT * FROM users WHERE registered &gt; <span><span>{</span><span>q</span><span>/</span><span>registered_since</span><span>}</span></span> <span><span>{</span><span>AND_</span>(<span>q</span>.<span>enabled</span> <span>==</span> <span>not_none</span><span>/</span><span>enabled</span>)<span>}</span></span>&#39;</span>
<span>&#39;SELECT * FROM users WHERE registered &gt; ? AND enabled = ?&#39;</span></pre></div>
<p dir="auto">Also there is a possibility to construct filters out of line via <code>WHERE</code>
prepender.</p>

<p dir="auto">It could be useful to extract filters outside of f-strings and use <code>sqlbind.WHERE</code>
prepender. It can help with readability of long complex filters.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from sqlbind import not_none, WHERE

def get_fresh_users(registered_since: datetime, enabled: Optional[bool] = None):
    q = QParams()

    filters = [
        q.registered &gt; registered_since,
        q.enabled == not_none/enabled,
    ]

    sql = f&#39;SELECT * FROM users {WHERE(*filters)} ORDER BY registered&#39;
    return connection.execute(sql, q)"><pre><span>from</span> <span>sqlbind</span> <span>import</span> <span>not_none</span>, <span>WHERE</span>

<span>def</span> <span>get_fresh_users</span>(<span>registered_since</span>: <span>datetime</span>, <span>enabled</span>: <span>Optional</span>[<span>bool</span>] <span>=</span> <span>None</span>):
    <span>q</span> <span>=</span> <span>QParams</span>()

    <span>filters</span> <span>=</span> [
        <span>q</span>.<span>registered</span> <span>&gt;</span> <span>registered_since</span>,
        <span>q</span>.<span>enabled</span> <span>==</span> <span>not_none</span><span>/</span><span>enabled</span>,
    ]

    <span>sql</span> <span>=</span> <span>f&#39;SELECT * FROM users <span><span>{</span><span>WHERE</span>(<span>*</span><span>filters</span>)<span>}</span></span> ORDER BY registered&#39;</span>
    <span>return</span> <span>connection</span>.<span>execute</span>(<span>sql</span>, <span>q</span>)</pre></div>
<p dir="auto">There are also other prependers: <code>WITH</code>, <code>LIMIT</code>, <code>OFFSET</code>, <code>GROUP_BY</code>,
<code>ORDER_BY</code>, <code>SET</code>. They all omit empty parts or are rendered as
empty string if all parts are empty.</p>
<p dir="auto">Also you could use <code>&amp;</code> operator to join filters to assemble condition expression without a list:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; filters = (q.registered &gt; &#39;2023-01-01&#39;) &amp; (q.enabled == not_none/True)
&gt;&gt;&gt; WHERE(filters)
&#39;WHERE (registered &gt; ? AND enabled = ?)&#39;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>filters</span> <span>=</span> (<span>q</span>.<span>registered</span> <span>&gt;</span> <span>&#39;2023-01-01&#39;</span>) <span>&amp;</span> (<span>q</span>.<span>enabled</span> <span>==</span> <span>not_none</span><span>/</span><span>True</span>)
<span>&gt;&gt;</span><span>&gt;</span> <span>WHERE</span>(<span>filters</span>)
<span>&#39;WHERE (registered &gt; ? AND enabled = ?)&#39;</span></pre></div>
<p dir="auto">â€” &#34;Wait a minute. How does it work? You said there is no expression trees and compilation! And
all operations return strings!&#34;</p>

<p dir="auto">Well, technically they are strings. Almost all methods and functions return <code>sqlbind.Expr</code>. It&#39;s a very shallow
descendant of <code>str</code> with only <code>__or__</code>, <code>__and__</code> and <code>__invert__</code> overrides.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q(&#39;enabled&#39;) &amp; q(&#39;registered&#39;)
&#39;(enabled AND registered)&#39;
&gt;&gt;&gt; type(q(&#39;enabled&#39;))
&lt;class &#39;sqlbind.Expr&#39;&gt;
&gt;&gt;&gt; type(q.enabled == True)
&lt;class &#39;sqlbind.Expr&#39;&gt;
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span>(<span>&#39;enabled&#39;</span>) <span>&amp;</span> <span>q</span>(<span>&#39;registered&#39;</span>)
<span>&#39;(enabled AND registered)&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>type</span>(<span>q</span>(<span>&#39;enabled&#39;</span>))
<span>&lt;</span><span>class</span> <span>&#39;sqlbind.Expr&#39;</span><span>&gt;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>type</span>(<span>q</span>.<span>enabled</span> <span>==</span> <span>True</span>)
<span>&lt;</span><span>class</span> <span>&#39;sqlbind.Expr&#39;</span><span>&gt;</span></pre></div>
<p dir="auto">All Expr instances could be composed with <code>&amp;</code>, <code>|</code> and <code>~</code> (negate) operations.
Sadly due to python&#39;s&#39; precedence rules you have to wrap expressions into
additional parens to make it work.</p>

<p dir="auto">It&#39;s a matter of preference and team code agreements. Personally I don&#39;t see anything
criminal in inline expressions. But it could be a huge red flag for other
person and it&#39;s ok. <strong>sqlbind</strong> gives a choice to use inline or out of line
approach.</p>
<p dir="auto">But take a note. For positional dialects (like qmark style) out of line
rendering has a major drawback. You should take care on part ordering. Binding
and part usage should be synchronised. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; q = sqlbind.Dialect.default()
&gt;&gt;&gt; filter1 = q.registered &gt; &#39;2023-01-01&#39;
&gt;&gt;&gt; filter2 = q.enabled == 1
&gt;&gt;&gt; f&#39;SELECT * FROM users WHERE {filter2} AND {filter1}&#39;
&#39;SELECT * FROM users WHERE enabled = ? AND registered &gt; ?&#39;
&gt;&gt;&gt; q  # parameter ordering mismatches placeholders
[&#39;2023-01-01&#39;, 1]
"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>q</span> <span>=</span> <span>sqlbind</span>.<span>Dialect</span>.<span>default</span>()
<span>&gt;&gt;</span><span>&gt;</span> <span>filter1</span> <span>=</span> <span>q</span>.<span>registered</span> <span>&gt;</span> <span>&#39;2023-01-01&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>filter2</span> <span>=</span> <span>q</span>.<span>enabled</span> <span>==</span> <span>1</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>f&#39;SELECT * FROM users WHERE <span><span>{</span><span>filter2</span><span>}</span></span> AND <span><span>{</span><span>filter1</span><span>}</span></span>&#39;</span>
<span>&#39;SELECT * FROM users WHERE enabled = ? AND registered &gt; ?&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>q</span>  <span># parameter ordering mismatches placeholders</span>
[<span>&#39;2023-01-01&#39;</span>, <span>1</span>]</pre></div>
<p dir="auto">It&#39;s a largely artificial example but for complex queries composed from
multiple parts it could be an issue. To reduce chance you could abstract composition
parts in a way to contain bindings and SQL construction in one go to be
fully synchronised.</p>
<p dir="auto">BTW, you could already noticed but out of line variants of <code>get_fresh_users</code>
from <a href="#dynamic-queries">Dynamic queries</a> and <a href="#conditionals">Conditionals</a> have
the same ordering bug: inline and out of line approaches mix quite bad. Always
use named style Dialect if your connection backend allows it.</p>
</article></div></div>
  </body>
</html>
