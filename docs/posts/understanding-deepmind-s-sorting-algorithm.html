<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/sorting/">Original</a>
    <h1>Understanding DeepMind&#39;s Sorting Algorithm</h1>
    
    <div id="readability-page-1" class="page">

<p>
June 12<sup>th</sup>, 2023 @ <a href="https://justine.lol/index.html">justine&#39;s web page</a>
</p>

<img src="https://justine.lol/sorting/deepmind.png" alt="[DeepMind Logo]" width="334" height="316"/>
<p>
A few days ago, DeepMind published a
<a href="https://www.deepmind.com/blog/alphadev-discovers-faster-sorting-algorithms">blog
post</a> talking about a
<a href="https://www.nature.com/articles/s41586-023-06004-9">paper</a>
they wrote, where they discovered tinier kernels for sorting algorithms.
They did this by taking their deep learning wisdom, which they gained by
building AlphaGo, and applying it to the discipline of
of <a href="https://en.wikipedia.org/wiki/Superoptimization">superoptimization</a>.
That piqued my interest, since as a C library author, I&#39;m always looking
for opportunities to curate the best stuff. In some ways that&#39;s really
the whole purpose of the C library. There are so many functions that we
as programmers take for granted, which are the finished product of
decades of research, distilled into plain and portable code.

</p><p>
DeepMind earned a fair amount of well-deserved attention for this
discovery, but unfortunately they could have done a much better job
explaining it. Let&#39;s start with the assembly code they published for
sorting an array with three items, translated from pseudo-assembly into
assembly:

</p><table>
<tbody><tr><td>
<pre><span>/	move37.S</span>
	<span>.equ</span>	P,<span>%rax</span>
	<span>.equ</span>	Q,<span>%rcx</span>
	<span>.equ</span>	R,<span>%rdx</span>
	<span>.equ</span>	S,<span>%rsi</span>
<span>move37</span>:	<span>mov</span>	(<span>%rdi</span>),P
	<span>mov</span>	8(<span>%rdi</span>),Q
	<span>mov</span>	16(<span>%rdi</span>),R
	<span>mov</span>	R,S
	<span>cmp</span>	P,R
	<span>cmovg</span>	P,R
	<span>cmovl</span>	P,S
	<span>cmp</span>	S,Q
	<span>cmovg</span>	Q,P
	<span>cmovg</span>	S,Q
	<span>mov</span>	R,(<span>%rdi</span>)
	<span>mov</span>	Q,8(<span>%rdi</span>)
	<span>mov</span>	P,16(<span>%rdi</span>)
	<span>ret</span>
	<span>.type</span>	move37,<span>@function</span>
	<span>.size</span>	move37,.-move37
	<span>.globl</span>	move37
</pre>
</td><td>
<pre><span>// deepsort1.c</span>
<span>#include</span> &lt;stdio.h&gt;

<span>void</span> <span>move37</span>(<span>long</span> *);

<span>int</span> <span>main</span>() {
  <span>long</span> A[3] = {3, 1, 2};
  move37(A);
  printf(<span>&#34;%d %d %d\n&#34;</span>, A[0], A[1], A[2]);
}
</pre>
</td></tr></tbody></table>

<p>
I named this function <code>move37()</code> because the DeepMind blog
post compares it to the 37th move AlphaGo made during its second
<a href="https://en.wikipedia.org/wiki/AlphaGo_versus_Lee_Sedol">match
with Lee Sedol</a> back in 2016. That&#39;s the move which stunned the
experts who thought AlphaGo had made a mistake, but they were wrong,
because the machine ultimately did achieve
<a href="https://www.goratings.org/en/players/5.html">victory</a>
against its opponent, who saw himself as the Hector of humanity. So if
we run the DeepMind code:

</p><pre><span># run this on the shell</span>
cc -o deepsort1 deepsort1.c move37.S
./deepsort1
2 1 3
</pre>

<p>
That looks like a mistake to me. The array we gave it was {3, 1, 2} but
<code>move37()</code> sorted it into {2, 1, 3}. DeepMind must be
trolling us, because I don&#39;t believe that 2 comes before 1. Let&#39;s take a
look at the
<a href="https://reviews.llvm.org/D118029">open source contribution they
made to LLVM libcxx</a> which should hopefully clarify things:

</p><pre><span>// Ensures that *__x, *__y and *__z are ordered according to the comparator __c,</span>
<span>// under the assumption that *__y and *__z are already ordered.</span>
<span>template</span> &lt;<span>class</span> _Compare, <span>class</span> _RandomAccessIterator&gt;
<span>inline</span> _LIBCPP_HIDE_FROM_ABI <span>void</span> <span>__partially_sorted_swap</span>(
    _RandomAccessIterator __x, _RandomAccessIterator __y,
    _RandomAccessIterator __z, _Compare __c) {
  <span>using</span> value_type = <span>typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type;
  <span>bool</span> __r = __c(*__z, *__x);
  value_type __tmp = __r ? *__z : *__x;
  *__z = __r ? *__x : *__z;
  __r = __c(__tmp, *__y);
  *__x = __r ? *__x : *__y;
  *__y = __r ? *__y : __tmp;
}
</pre>

<p>
Now it makes sense. So <code>move37()</code> isn&#39;t actually a sorting
function. It&#39;s a sorting <em>kernel</em> that&#39;s intended to be used as
the building block of the <code>sort3()</code> function. It would have
been nice if the paper and blog post had mentioned that, since it made
me feel quite confused for the briefest of moments. Here&#39;s a better
version of the code, which includes the missing swap operation.

</p><pre><span>sort3</span>:	<span>mov</span>	(<span>%rdi</span>),<span>%rcx</span>
	<span>mov</span>	8(<span>%rdi</span>),<span>%rdx</span>
	<span>mov</span>	16(<span>%rdi</span>),<span>%rsi</span>
	<span>mov</span>	<span>%rdx</span>,<span>%rax</span>
	<span>cmp</span>	<span>%rdx</span>,<span>%rsi</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rax</span>
	<span>cmovl</span>	<span>%rdx</span>,<span>%rsi</span>
	<span>mov</span>	<span>%rcx</span>,<span>%rdx</span>
	<span>cmp</span>	<span>%rcx</span>,<span>%rsi</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rdx</span>
	<span>cmovl</span>	<span>%rcx</span>,<span>%rsi</span>
	<span>cmp</span>	<span>%rax</span>,<span>%rdx</span>
	<span>cmovge</span>	<span>%rax</span>,<span>%rcx</span>
	<span>cmovl</span>	<span>%rax</span>,<span>%rdx</span>
	<span>mov</span>	<span>%rcx</span>,(<span>%rdi</span>)
	<span>mov</span>	<span>%rdx</span>,8(<span>%rdi</span>)
	<span>mov</span>	<span>%rsi</span>,16(<span>%rdi</span>)
	<span>ret</span>
	<span>.globl</span>	sort3
	<span>.size</span>	sort3,.-sort3
</pre>

<p>
To explain why their code is important, let&#39;s consider how this
algorithm works at a high level. When I first tried to solve
the <code>sort3()</code> problem on my own, I came up with this:

</p><pre>	<span>// sorts [a,b,c]</span>
	<span>if</span> (a &gt; b) SWAP(a, b);
	<span>if</span> (a &gt; c) SWAP(a, c);
	<span>if</span> (b &gt; c) SWAP(b, c);
</pre>

<p>
Then I looked at libcxx and found out they were doing the same thing.
The issue with the code above is that compilers aren&#39;t very good at
optimizing it. If you try to compile the above code, you&#39;ll notice that
your compiler inserts a lot of branch instructions. This is what
DeepMind sought to improve upon with their LLVM contribution, because
cleverer ways exist to code this sort of thing. However those techniques
tend to be less understandable. I actually like my naive code, since if
we squint our eyes a bit, we can see a pattern exists where it shares
the same basic idea as DeepMind&#39;s state of the art assembly code. That
idea is this problem essentially boils down into being just three
compare and swap operations:

</p><pre>	<span>mov</span>	<span>%rdx</span>,<span>%rax</span>		<span>// create temporary</span>
	<span>cmp</span>	<span>%rdx</span>,<span>%rsi</span>		<span>// compare</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rax</span>		<span>// conditional move</span>
	<span>cmovl</span>	<span>%rdx</span>,<span>%rsi</span>		<span>// conditional move</span>
<span>/	<em>repeat thrice</em></span>
</pre>

<p>
The above code was the state of the art beforehand for sorting networks.
Now here&#39;s where DeepMind&#39;s novel discovery came into play. They found
out that sometimes the <code>mov</code> instruction above is
unnecessary.

</p><pre><span>sort3</span>:	<span>mov</span>	(<span>%rdi</span>),<span>%rcx</span>
	<span>mov</span>	8(<span>%rdi</span>),<span>%rdx</span>
	<span>mov</span>	16(<span>%rdi</span>),<span>%rsi</span>
	<span>mov</span>	<span>%rdx</span>,<span>%rax</span>
	<span>cmp</span>	<span>%rdx</span>,<span>%rsi</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rax</span>
	<span>cmovl</span>	<span>%rdx</span>,<span>%rsi</span>
	<span>mov</span>	<span>%rcx</span>,<span>%rdx</span>
	<span>cmp</span>	<span>%rcx</span>,<span>%rsi</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rdx</span>
	<span>cmovl</span>	<span>%rcx</span>,<span>%rsi</span>
	<span><span>mov</span>	<span>%rdx</span>,<span>%rcx</span></span>		<span>// &lt;-- wrekt by AlphaDev</span>
	<span>cmp</span>	<span>%rax</span>,<span>%rdx</span>
	<span>cmovge</span>	<span>%rax</span>,<span>%rcx</span>
	<span>cmovl</span>	<span>%rax</span>,<span>%rdx</span>
	<span>mov</span>	<span>%rcx</span>,(<span>%rdi</span>)
	<span>mov</span>	<span>%rdx</span>,8(<span>%rdi</span>)
	<span>mov</span>	<span>%rsi</span>,16(<span>%rdi</span>)
	<span>ret</span>
</pre>

<p>
If you try running the above code, then you&#39;ll see it&#39;s 100% correct
with or without the striked-out line. The line of code looks like it&#39;s
doing something, but it&#39;s actually doing nothing. So it doesn&#39;t surprise
me that something like this could have gone unnoticed by computer
science for decades. It should also become clearer now how AlphaDev
works. DeepMind basically built an artificial intelligence that fiddles
around with assembly code and deletes stuff at random to see if it
breaks. I&#39;m not saying this to dismiss AlphaDev&#39;s intelligence, since
I&#39;d be lying if I said I wasn&#39;t doing the same thing.

</p><pre><span>sort3</span>:	<span>mov</span>	(<span>%rdi</span>),<span>%rcx</span>
	<span>mov</span>	8(<span>%rdi</span>),<span>%rdx</span>
	<span>mov</span>	16(<span>%rdi</span>),<span>%rsi</span>
	<strong><span>mov</span>	<span>%rdx</span>,<span>%rax</span></strong>		<span>// can it go?</span>
	<span>cmp</span>	<span>%rdx</span>,<span>%rsi</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rax</span>
	<span>cmovl</span>	<span>%rdx</span>,<span>%rsi</span>
	<strong><span>mov</span>	<span>%rcx</span>,<span>%rdx</span></strong>		<span>// can it go?</span>
	<span>cmp</span>	<span>%rcx</span>,<span>%rsi</span>
	<span>cmovl</span>	<span>%rsi</span>,<span>%rdx</span>
	<span>cmovl</span>	<span>%rcx</span>,<span>%rsi</span>
	<span><span>mov</span>	<span>%rdx</span>,<span>%rcx</span></span>		<span>// &lt;-- wrekt by AlphaDev</span>
	<span>cmp</span>	<span>%rax</span>,<span>%rdx</span>
	<span>cmovge</span>	<span>%rax</span>,<span>%rcx</span>
	<span>cmovl</span>	<span>%rax</span>,<span>%rdx</span>
	<span>mov</span>	<span>%rcx</span>,(<span>%rdi</span>)
	<span>mov</span>	<span>%rdx</span>,8(<span>%rdi</span>)
	<span>mov</span>	<span>%rsi</span>,16(<span>%rdi</span>)
	<span>ret</span>
</pre>

<p>
DeepMind also left some meat on the table. There&#39;s still two more
<code>mov</code> instructions in the above code we could potentially
shave away. One of the ways we might do that is by using the ARM64
instruction set, which yields tinier code for problems like these. Here
we see that we don&#39;t need any instructions for creating temporary
variables:

</p><pre><span>sort4</span>:	<span>ldp</span>	x1,x2,[x0]
	<span>ldr</span>	x3,[x0,16]
	<span>cmp</span>	x2,x3
	<span>csel</span>	x4,x2,x3,le
	<span>csel</span>	x2,x2,x3,ge
	<span>cmp</span>	x2,x1
	<span>csel</span>	x3,x2,x1,le
	<span>csel</span>	x2,x2,x1,ge
	<span>cmp</span>	x4,x3
	<span>csel</span>	x5,x1,x4,gt
	<span>csel</span>	x4,x4,x3,ge
	<span>stp</span>	x5,x4,[x0]
	<span>str</span>	x2,[x0,16]
	<span>ret</span>
</pre>

<p>
Arm is all the rage these days, and I imagine the example above serves
as evidence of why they&#39;ve earned their fame. Arm Limited is also one of
the most benevolent companies in open source right now. For example,
their <a href="https://github.com/Mbed-TLS/mbedtls">MbedTLS</a> library
is one of the most underrated gems I&#39;ve seen so far. When I started
using it, I originally had this scheme of modifying Arm&#39;s code to work
better on x86 hardware instead. I wrote all these tricked out assembly
optimizations bringing it to the same realm of performance as OpenSSL on
x86. MbedTLS is plain, portable, hackable C code, so this is good news
for anyone wanting a crypto library that isn&#39;t assembly generated by
Perl. I told the folks at Arm what I was doing, and instead of finding
it subversive they were very kind and encouraging, since that&#39;s the kind
of people they are. One day I hope to find time to do what DeepMind did,
and upstream my modifications. Arm is also prolific for
their <a href="https://github.com/ARM-software/optimized-routines/">Optimized
Routines</a> library, which is up there with
<a href="https://github.com/google/double-conversion">double-conversion</a>
in terms of impeccable quality. It&#39;s of particular interest to C
libraries, since for decades the open source community has subsisted off
math functions written by Sun Microsystems back in the early 90&#39;s. Arm
found a way to improve upon several of them, such
as <code>pow(x,y)</code>. That&#39;s a very high impact thing to do,
considering it&#39;s a one of the most fundamental operations in math. For
example, if you use Arm&#39;s solution in pure software to
implement <code>pow(x,y)</code> on an x86 machine, then it&#39;ll go 5x
faster than Intel&#39;s native x87 instructions for doing the same thing.

</p><p>
Since we&#39;re so fortunate to have DeepMind entering this game too, I&#39;ve
taken the liberty of translating their libcxx diff into plain readable C
code, so that everyone can appreciate its beauty. It&#39;s another thing I
would have liked to see included in the paper and blog post, because in
this code you&#39;ll find the canonical trick that experts use for getting
compilers to generate branchless <code>MOVcc</code> instructions.

</p><pre><span>// sorts [a,b]</span>
<span>static inline</span> <span>void</span> <span>Sort2</span>(<span>long</span> *a, <span>long</span> *b) {
  <span>int</span> r = *a &lt; *b;
  <span>long</span> t = r ? *a : *b;
  *b = r ? *b : *a;
  *a = t;
}

<span>// sorts [a,b,c] assuming [b,c] is already sorted</span>
<span>static inline</span> <span>void</span> <span>PartialSort3</span>(<span>long</span> *a, <span>long</span> *b, <span>long</span> *c) {
  <span>int</span> r = *c &lt; *a;
  <span>long</span> t = r ? *c : *a;
  *c = r ? *a : *c;
  r = t &lt; *b;
  *a = r ? *a : *b;
  *b = r ? *b : t;
}

<span>// sorts [a,b,c]</span>
<span>static inline</span> <span>void</span> <span>Sort3</span>(<span>long</span> *a, <span>long</span> *b, <span>long</span> *c) {
  Sort2(b, c);
  PartialSort3(a, b, c);
}
</pre>

<pre><span>// sorts [a,b,c,d]</span>
<span>static inline</span> <span>void</span> <span>Sort4</span>(<span>long</span> *a, <span>long</span> *b, <span>long</span> *c, <span>long</span> *d) {
  Sort2(a, c);
  Sort2(b, d);
  Sort2(a, b);
  Sort2(c, d);
  Sort2(b, c);
}
</pre>

<pre><span>// sorts [a,b,c,d,e]</span>
<span>static inline</span> <span>void</span> <span>Sort5</span>(<span>long</span> *a, <span>long</span> *b, <span>long</span> *c, <span>long</span> *d, <span>long</span> *e) {
  Sort2(a, b);
  Sort2(d, e);
  PartialSort3(c, d, e);
  Sort2(b, e);
  PartialSort3(a, c, d);
  PartialSort3(b, c, d);
}
</pre>

<p>
Once I saw the <code>Sort5()</code> function, I felt like I had gained a
better understanding of what had motivated DeepMind&#39;s research. If you
compile the <code>Sort5()</code> function on ARM64, then your compiler
will produce a function juggling 11 registers. If you were reasoning
about a mathematical equation, then would you be able to hold eleven
variables in your working memory at once? Probably not, which is why
having a nice kernel function like <code>PartialSort3</code> is so
useful. As sentient creatures, human beings aren&#39;t that much different
from the monkeys we once were. The main thing that makes us intelligent
is our ability to take hard problems and break them down into smaller
ones. So it&#39;s nice to see deep learning being applied to turbocharging
our abstractions.

</p><p>
It&#39;s also worth mentioning that <code>Sort3()</code>
and <code>Sort5()</code> are kernels themselves, since they&#39;re intended
to be building blocks for a conventional sorting function. The blog post
covers this topic, but I thought it&#39;d be useful to share something
that&#39;s actually portable and executable.

</p><pre><span>static inline</span> <span>void</span> <span>InsertionSort</span>(<span>long</span> *A, <span>long</span> n) {
  <span>long</span> i, j, t;
  <span>for</span> (i = 1; i &lt; n; i++) {
    t = A[i];
    j = i - 1;
    <span>while</span> (j &gt;= 0 &amp;&amp; A[j] &gt; t) {
      A[j + 1] = A[j];
      j = j - 1;
    }
    A[j + 1] = t;
  }
}

<span>void</span> <span>longsort</span>(<span>long</span> *A, <span>long</span> n) {
  <span>long</span> t, p, i, j;
  <span>switch</span> (n) {
    <span>case</span> 0:
      <span>return</span>;
    <span>case</span> 1:
      <span>return</span>;
    <span>case</span> 2:
      <span>return</span> Sort2(A, A + 1);
    <span>case</span> 3:
      <span>return</span> Sort3(A, A + 1, A + 2);
    <span>case</span> 4:
      <span>return</span> Sort4(A, A + 1, A + 2, A + 3);
    <span>case</span> 5:
      <span>return</span> Sort5(A, A + 1, A + 2, A + 3, A + 4);
    <span>default:</span>
      <span>if</span> (n &lt;= 32) {
        InsertionSort(A, n);
      } <span>else</span> {
        <span>for</span> (p = A[n &gt;&gt; 1], i = 0, j = n - 1;; i++, j--) {
          <span>while</span> (A[i] &lt; p) i++;
          <span>while</span> (A[j] &gt; p) j--;
          if (i &gt;= j) <span>break</span>;
          t = A[i];
          A[i] = A[j];
          A[j] = t;
        }
        LongSort(A, i);
        LongSort(A + i, n - i);
      }
      <span>break</span>;
  }
}
</pre>

<p>
The above algorithm shows what the new and improved libcxx is doing.
It&#39;s basically quicksort except it switches to the sorting kernels and
insertion sort when recursing into smaller slices. With libcxx I think
they even took the added step of schlepping in heapsort, which is kind
of slow, but prevents adversaries from smashing your stack.

</p><p>
The main thing you may be wondering at this point is, can I use this? Do
these sorting network kernels actually make sorting go faster? I would
say yes and no. When all you want is to sort ascending longs, the code
above will go 2x faster than the standard <code>qsort()</code> function
provided by your C library. Except you don&#39;t need the kernels to do
that. What I&#39;ve determined so far is that, on my personal computer
(which has an Intel Core i9-12900KS) the above function sorts longs at
255 megabytes per second. However if I comment out the sorting kernels:

</p><pre><span>void</span> <span>longsort</span>(<span>long</span> *A, <span>long</span> n) {
  <span>long</span> t, p, i, j;
  <span>switch</span> (n) {
    <span>case</span> 0:
      <span>return</span>;
    <span>case</span> 1:
      <span>return</span>;
    <span>/* case 2: */</span>
    <span>/*   return Sort2(A, A + 1); */</span>
    <span>/* case 3: */</span>
    <span>/*   return Sort3(A, A + 1, A + 2); */</span>
    <span>/* case 4: */</span>
    <span>/*   return Sort4(A, A + 1, A + 2, A + 3); */</span>
    <span>/* case 5: */</span>
    <span>/*   return Sort5(A, A + 1, A + 2, A + 3, A + 4); */</span>
    <span>default:</span>
      <span>if</span> (n &lt;= 32) {
        InsertionSort(A, n);
      } <span>else</span> {
        <span>for</span> (p = A[n &gt;&gt; 1], i = 0, j = n - 1;; i++, j--) {
          <span>while</span> (A[i] &lt; p) i++;
          <span>while</span> (A[j] &gt; p) j--;
          if (i &gt;= j) <span>break</span>;
          t = A[i];
          A[i] = A[j];
          A[j] = t;
        }
        LongSort(A, i);
        LongSort(A + i, n - i);
      }
      <span>break</span>;
  }
}
</pre>

<p>
Then my <code>longsort()</code> function goes 275 megabytes per second.
I achieved 7% better performance by dumbing down the algorithm. I say
let Intel do the damage. This is the function cosmopolitan libc uses to
sort elf symbol tables when loading your executables. The nice thing
about <code>long</code> is it&#39;s long enough to store an <code>int</code>
key value pair. Being able to sort map entries fast is useful trick to
have. Blending naive quicksort with naive insertion sort is the best
solution I&#39;ve found so far, in terms of striking a balance between
tininess and performance that&#39;s just right for my use case. The above
function compiles down to just 181 bytes of x86-64 machine code. Since
DeepMind&#39;s <code>sort3()</code> is only 42 bytes, I was hoping I could
trade away some size to gain a performance advantage. Since the next
best algorithm I&#39;ve found so far would be switching to radix sort, which
goes 400 MB/s but needs a whopping 763 bytes of binary footprint, in
addition to depending on <code>malloc()</code>. So it would have been
nice to see these kernels do better.

</p><p>
That&#39;s not to imply DeepMind&#39;s ideas don&#39;t have merit. I think it&#39;s
important to note that DeepMind was generous enough to give us their
<a href="https://opensource.googleblog.com/2022/06/Vectorized%20and%20performance%20portable%20Quicksort.html">vectorized
quicksort</a> library last year (back when they were called Google
Brain) and in doing so achieved a sorting supremacy that can never be
challenged. Vqsort literally sorts longs at 1155 MB/s on my computer. It
even marginally outperforms
<a href="https://sorting.cr.yp.to/">djbsort</a>, which is one of the
most beloved libraries in the open source community even though it never
generalized to more data types than <code>int</code>. The way both
implementations pulled it off is by vectorizing sorting networks. I
think that&#39;s where the sorting network technique truly shines. I imagine
AlphaDev would have done that if it weren&#39;t still a toddler as far as
intelligent entities go. When you&#39;re starting from first principles, the
baseline instruction set alone is enormously difficult to support. If we
wait, then I think we can expect to see great things from AlphaDev in
the future, as it works its way up to more formidable challenges.

</p><p>
I also just love the fact that DeepMind is making algorithms tinier,
since that&#39;s something I don&#39;t see very often. Size coding is one of my
favorite hobbies. On this blog I&#39;ve published
a <a href="https://justine.lol/lambda/">383 byte virtual machine for
lambda calculus</a> and
a <a href="https://justine.lol/sectorlisp2/">lisp machine with garbage
collection in 436 bytes</a>. I&#39;ve also blogged about
the <a href="https://justine.lol/sizetricks/">size optimization
tricks</a> I&#39;ve used for
the <a href="https://github.com/jart/cosmopolitan">cosmpolitan c
library</a>. I love DeepMind&#39;s parent company too, since Google
<a href="https://opensource.googleblog.com/2023/05/google-open-source-peer-bonus-program-announces-first-group-of-winners-2023.html">awarded
me an open source peer bonus</a> a few weeks ago, and it&#39;s nice to see
them sharing my passion for making software smaller. It&#39;d be great to
see them using it to improve vectorized quicksort. I would love nothing
more than to have the world&#39;s best longsort not be a C++ monster that
adds 24kB of binary footprint. It&#39;s 23,000 lines of assembly for
ascending long sort alone. Those are the lines of code I can&#39;t wait to
see AlphaDev ravage someday.

</p><p>
Finally, I like the idea of an artificial intelligence company building
machines that write code in machine language. Why wouldn&#39;t they? It&#39;s in
a machine&#39;s nature to be a machine. As a builder I find that much less
triggering than the future OpenAI is creating, where they&#39;ve built a
great big paternalistic machine that competes with every builder on
earth in a zero-sum economy, and then enticing the rent-seekers of the
world to take control of that machine through government regulation. I
don&#39;t think it&#39;s progress that OpenAI is promising to automate all the
tasks I love doing most, like coding. What I want is to be able to
control a machine that&#39;s able to do the things I&#39;m not able to do on my
own, like discovering sorting kernels. That&#39;s the real kind of progress
that&#39;s going to help humanity enrich itself, and I view every line of
assembly we can shave away as a step in a positive direction towards
that dream.

</p>
<img src="https://ipv4.games/claim?name=jart"/>
</div>
  </body>
</html>
