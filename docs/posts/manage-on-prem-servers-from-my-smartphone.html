<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/c100k/rebootx-on-prem">Original</a>
    <h1>Show HN: Manage on-prem servers from my smartphone</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/c100k/rebootx-on-prem/actions/workflows/quality.yml/badge.svg"><img src="https://github.com/c100k/rebootx-on-prem/actions/workflows/quality.yml/badge.svg" alt="CI"/></a></p>

<p dir="auto"><strong>RebootX On-Prem</strong> is an open source specification for defining a custom server in order to manage on-premise <em>runnables</em> in the <a href="https://c100k.eu/p/rebootx" rel="nofollow">RebootX</a> app.</p>
<p dir="auto">A <em>Runnable</em> is anything that <em>runs</em>, can be <em>stopped</em> and <em>rebooted</em>. For instance, Virtual Machines (VMs), Dedicated servers, Containers, PaaS Applications, Databases... are all valid concretions of a <em>runnable</em>.</p>
<p dir="auto">If you have already used the <a href="https://c100k.eu/p/rebootx" rel="nofollow">RebootX</a> app, you are already familiar with how it works when you connect public cloud providers like Amazon Web Services (AWS), Microsoft Azure, Clever Cloud, Google Cloud (GCP), OVH or Scaleway.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/c100k/rebootx-on-prem/blob/master/cover.png"><img width="460" src="https://github.com/c100k/rebootx-on-prem/raw/master/cover.png"/></a>
</p>
<p dir="auto">Why should you use this specification ?</p>
<p dir="auto">It provides the solution if you are in one of these cases :</p>
<ul dir="auto">
<li>You have servers in your local network that you want to manage via an app</li>
<li>You hack around small devices like the Raspberry Pi and you want to manage it via an app</li>
<li>You have dedicated servers in a datacenter that do not have a central administration console and you want to manage them via an app</li>
</ul>
<p dir="auto">Of course, these are only examples and the only limit is your imagination.</p>

<p dir="auto">The specification is as simple as the following endpoints : <code>list</code>, <code>reboot</code>, <code>stop</code>. Of course, it will evolve overtime.</p>
<p dir="auto">It follows the <a href="https://swagger.io/specification" rel="nofollow">OpenAPI Specification</a> allowing a high level of compatibility with existing tools.</p>
<p dir="auto">You can play with it by loading it locally in <a href="https://swagger.io/tools/swagger-ui" rel="nofollow">SwaggerUI</a> with <a href="https://docs.docker.com/compose" rel="nofollow">Docker Compose</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Generate swagger.json (optional since it&#39;s already present in the repository)
docker run --rm -v $(pwd):/app oven/bun run /app/spec/generate-swagger.ts
yarn lint

# Generate Go code with OpenAPI Generator
docker run --rm \
-v $(pwd):/app \
openapitools/openapi-generator-cli:v7.4.0 generate \
-i /app/spec/_generated/swagger.json \
-g go \
-o /app/impl/http-server-go/vendor/openapi

# Run Swagger UI calling the Go server
docker-compose up"><pre><span><span>#</span> Generate swagger.json (optional since it&#39;s already present in the repository)</span>
docker run --rm -v <span><span>$(</span>pwd<span>)</span></span>:/app oven/bun run /app/spec/generate-swagger.ts
yarn lint

<span><span>#</span> Generate Go code with OpenAPI Generator</span>
docker run --rm \
-v <span><span>$(</span>pwd<span>)</span></span>:/app \
openapitools/openapi-generator-cli:v7.4.0 generate \
-i /app/spec/_generated/swagger.json \
-g go \
-o /app/impl/http-server-go/vendor/openapi

<span><span>#</span> Run Swagger UI calling the Go server</span>
docker-compose up</pre></div>
<p dir="auto">You can then access <a href="http://localhost:9002" rel="nofollow">http://localhost:9002</a> via your browser and test the endpoints. See <code>docker-compose.yml</code> to have the <code>apiKey</code>.</p>
<p dir="auto">You can also directly test the server with cURL:</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -v -H &#34;Authorization: &lt;apiKey&gt;&#34; http://localhost:9001/cd5331ba/runnables
curl -v -X POST -H &#34;Authorization: &lt;apiKey&gt;&#34; http://localhost:9001/cd5331ba/runnables/self/reboot
curl -v -X POST -H &#34;Authorization: &lt;apiKey&gt;&#34; http://localhost:9001/cd5331ba/runnables/self/stop"><pre>curl -v -H <span><span>&#34;</span>Authorization: &lt;apiKey&gt;<span>&#34;</span></span> http://localhost:9001/cd5331ba/runnables
curl -v -X POST -H <span><span>&#34;</span>Authorization: &lt;apiKey&gt;<span>&#34;</span></span> http://localhost:9001/cd5331ba/runnables/self/reboot
curl -v -X POST -H <span><span>&#34;</span>Authorization: &lt;apiKey&gt;<span>&#34;</span></span> http://localhost:9001/cd5331ba/runnables/self/stop</pre></div>

<p dir="auto">You can develop your own server to fit your personal needs and keep control on everything that runs on your infra.</p>
<p dir="auto">As long as you respect the specification, you can use the language of your choice. To speed things up, you can generate some code using <a href="https://github.com/OpenAPITools/openapi-generator">OpenAPI Generator</a>.</p>
<p dir="auto">For instance, you can generate <a href="https://www.rust-lang.org" rel="nofollow">Rust</a> code with the following command :</p>
<div dir="auto" data-snippet-clipboard-copy-content="docker run --rm \
-v $(pwd):/app \
openapitools/openapi-generator-cli generate \
-i /app/spec/_generated/swagger.json \
-g rust \
-o /app/impl/http-server-rust/openapi"><pre>docker run --rm \
-v <span><span>$(</span>pwd<span>)</span></span>:/app \
openapitools/openapi-generator-cli generate \
-i /app/spec/_generated/swagger.json \
-g rust \
-o /app/impl/http-server-rust/openapi</pre></div>
<p dir="auto">Although it can be handful, we do not recommend relying on all the generated code for a <strong>production server</strong>, because it contains too much boilerplate, making it harder to maintain. It&#39;s fine to use the generated <code>structs</code>, <code>interfaces</code>, <code>enums</code>, <code>traits</code>, though. That being said, it&#39;s up to you.</p>
<p dir="auto">Once ready, your server should get your <em>runnables</em> from a local file, another API, network calls or a database (remote or local). Once again, it&#39;s up to you.</p>
<p dir="auto">It should be deployed to an independent location, accessible by the phone you want to use : Internet if you want access from anywhere / LAN if local access is enough for your use case.</p>
<p dir="auto">Of course, except in some cases, you must serve it with <code>HTTPS</code> to secure the connection between the app and your server.</p>


<p dir="auto">This is the implementation used in the <code>docker-compose</code> command above, made in Go. You can browse the code at <a href="https://github.com/c100k/rebootx-on-prem/blob/master/impl/http-server-go">impl/http-server-go</a>.</p>
<p dir="auto">If you don&#39;t want or cannot build your own server, you can use this one.</p>
<p dir="auto">You can download the latest release from the <a href="https://github.com/c100k/rebootx-on-prem/releases">releases</a> page or build it yourself from source.</p>
<p dir="auto">The server can run in different modes depending on your use case :</p>
<ul dir="auto">
<li><code>noop</code> (default) : it does nothing except returning empty payloads</li>
<li><code>self</code> : it returns the host as a <em>runnable</em>. Be careful if you run this on a machine as a privileged user. It relies on <a href="https://pkg.go.dev/syscall" rel="nofollow">syscall</a> and <a href="https://pkg.go.dev/os/exec" rel="nofollow">exec</a> so it can actually <code>reboot</code> or <code>stop</code> the machine for real</li>
<li><code>fileJson</code> : it reads the <em>runnables</em> from a JSON file that must respect the schema in order to be unmarshalled into an array of <code>Runnable</code> (see <a href="https://github.com/c100k/rebootx-on-prem/blob/master/data/servers.example.json">servers.example.json</a>)</li>
</ul>
<p dir="auto">To override the default behavior, see <code>docker-compose.yml</code> or <code>config.go</code> and update the appropriate environment variables accordingly.</p>

<p dir="auto">We welcome all kind of contributions to show examples in other languages. Feel free to reach out to us or to publish a PR. It must be clean and self contained in its own directory in <a href="https://github.com/c100k/rebootx-on-prem/blob/master/impl">./impl</a>.</p>
<p dir="auto">Please read the <a href="https://github.com/c100k/rebootx-on-prem/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> guide first.</p>
</article></div></div>
  </body>
</html>
