<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thenumb.at/Hashtables/">Original</a>
    <h1>Optimizing Open Addressing</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Your default hash table should be open-addressed, using Robin Hood linear probing with backward-shift deletion. 
When prioritizing deterministic performance over memory efficiency, two-way chaining is also a good choice.</p>

<p><em>Code for this article may be found on <a href="https://github.com/TheNumbat/hashtables">GitHub</a>.</em></p>

<ul>
  <li><a href="#open-addressing-vs-separate-chaining">Open Addressing vs. Separate Chaining</a></li>
  <li><a href="#benchmark-setup">Benchmark Setup</a></li>
  <li><a href="#discussion">Discussion</a>
    <ul>
      <li><a href="#separate-chaining">Separate Chaining</a></li>
      <li><a href="#linear-probing">Linear Probing</a></li>
      <li><a href="#quadratic-probing">Quadratic Probing</a></li>
      <li><a href="#double-hashing">Double Hashing</a></li>
      <li><a href="#robin-hood-linear-probing">Robin Hood Linear Probing</a></li>
      <li><a href="#two-way-chaining">Two Way Chaining</a></li>
    </ul>
  </li>
  <li><a href="#unrolling-prefetching-and-simd">Unrolling, Prefetching, and SIMD</a></li>
  <li><a href="#benchmark-data">Benchmark Data</a></li>
</ul>



<p>Most people first encounter hash tables implemented using <em>separate chaining</em>, a model simple to understand and analyze mathematically.
In separate chaining, a hash function is used to map each key to one of \(K\) <em>buckets</em>. 
Each bucket holds a linked list, so to retrieve a key, one simply traverses its corresponding bucket.</p>

<p><img src="https://thenumb.at/assets/hashtables/chaining.svg"/></p>

<p>Given a hash function drawn from a <a href="https://en.wikipedia.org/wiki/Universal_hashing">universal family</a>, inserting \(N\) keys into a table with \(K\) buckets results in an expected bucket size of \(\frac{N}{K}\), a quantity also known as the table’s <em>load factor</em>. 
Assuming (reasonably) that \(\frac{N}{K}\) is bounded by a constant, all operations on such a table can be performed in expected constant time.</p>

<p>Unfortunately, this basic analysis doesn’t consider the myriad factors that go into implementing an efficient hash table on a real computer. 
In practice, hash tables based on <em>open addressing</em> can provide superior performance, and their limitations can be worked around in nearly all cases.</p>

<h2 id="open-addressing">Open Addressing</h2>

<p>In an open-addressed table, each bucket only contains a single key. 
Collisions are handled by placing additional keys elsewhere in the table. 
For example, in linear probing, a key is placed in the first open bucket starting from the index it hashes to.</p>

<p><img src="https://thenumb.at/assets/hashtables/linear.svg"/></p>

<p>Unlike in separate chaining, open-addressed tables may be represented in memory as a single flat array. 
<em>A priori</em>, we should expect operations on flat arrays to offer higher performance than those on linked structures due to more coherent memory accesses.<sup id="fnref:cacheusage" role="doc-noteref"><a href="#fn:cacheusage" rel="footnote">1</a></sup></p>

<p>However, if the user wants to insert more than \(K\) keys into an open-addressed table with \(K\) buckets, the entire table must be resized.
Typically, a larger array is allocated and all current keys are moved to the new table. 
The size is grown by a constant factor (e.g. 2x), so insertions occur in <em>amortized</em> constant time.</p>

<h2 id="why-not-separate-chaining">Why Not Separate Chaining?</h2>

<p>In practice, the standard libraries of many languages provide separately chained hash tables, such as C++’s <code>std::unordered_map</code>.
At least in C++, this choice is now considered to have been a mistake—it violates C++’s principle of not paying for features you didn’t ask for.</p>

<p>Separate chaining still has some purported benefits, but they seem unconvincing:</p>

<ul>
  <li>
    <p><em>Separately chained tables don’t require any linear-time operations.</em></p>

    <p>First, this isn’t true. 
To maintain a constant load factor, separate chaining hash tables <em>also</em> have to resize once a sufficient number of keys are inserted, though the limit can be greater than \(K\).
Most separately chained tables, including <code>std::unordered_map</code>, only provide amortized constant time insertion.</p>

    <p>Second, open-addressed tables can be incrementally resized. 
When the table grows, there’s no reason we have to move all existing keys <em>right away</em>. 
Instead, every subsequent operation can move a fixed number of old keys into the new table. 
Eventually, all keys will have been moved and the old table may be deallocated. 
This technique incurs overhead on every operation during a resize, but none will require linear time.</p>
  </li>
  <li>
    <p><em>When each (key + value) entry is allocated separately, entries can have stable addresses. External code can safely store pointers to them, and large entries never have to be copied.</em></p>

    <p>This property is easy to support by adding a single level of indirection. That is, allocate each entry separately, but use an open-addressed table to map 
keys to pointers-to-entries. In this case, resizing the table only requires copying pointers, rather than entire entries.</p>
  </li>
  <li>
    <p><em>Lower memory overhead.</em></p>

    <p>It’s possible for a separately chained table to store the same data in less space than an open-addressed equivalent, since flat tables necessarily waste space storing empty buckets.
However, matching <a href="#robin-hood-linear-probing">high-quality</a> open addressing schemes (especially when storing entries indirectly) requires a load factor greater than one, degrading query performance. 
Further, individually allocating nodes wastes memory due to heap allocator overhead and fragmentation.</p>
  </li>
</ul>

<p>In fact, the only situation where open addressing truly doesn’t work is when the table cannot allocate <em>and</em> entries cannot be moved.
These requirements can arise when using <a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">intrusive linked lists</a>, a common pattern in kernel data structures and embedded systems with no heap.</p>



<p>For simplicity, let us only consider tables mapping 64-bit integer keys to 64-bit integer values. 
Results will not take into account the effects of larger values or non-trivial key comparison, but should still be representative, as keys can often be represented in 64 bits and values are often pointers.</p>

<p>We will evaluate tables using the following metrics:</p>
<ul>
  <li>Time to insert \(N\) keys into an empty table.</li>
  <li>Time to erase \(N\) existing keys.</li>
  <li>Time to look up \(N\) existing keys.</li>
  <li>Time to look up \(N\) missing keys<sup id="fnref:missingelements" role="doc-noteref"><a href="#fn:missingelements" rel="footnote">2</a></sup>.</li>
  <li>Average probe length for existing &amp; missing keys.</li>
  <li>Maximum probe length for existing &amp; missing keys.</li>
  <li>Memory amplification in a full table (total size / size of data).</li>
</ul>

<p>Each open-addressed table was benchmarked at 50%, 75%, and 90% load factors. 
Every test targeted a table capacity of 8M entries, setting \(N = \lfloor 8388608 * \text{Load Factor} \rfloor - 1\). 
Fixing the table capacity allows us to benchmark behavior at exactly the specified load factor, avoiding misleading results from tables that have recently grown.
The large number of keys causes each test to unpredictably traverse a data set much larger than L3 cache (128MB+), so the CPU<sup id="fnref:mycpu" role="doc-noteref"><a href="#fn:mycpu" rel="footnote">3</a></sup> cannot effectively cache or prefetch memory accesses.</p>

<h2 id="table-sizes">Table Sizes</h2>

<p>All benchmarked tables use exclusively power-of-two sizes. 
This invariant allows us to translate hashes to array indices with a fast bitwise AND operation, since:</p>
<div><div><pre><code>h % 2**n == h &amp; (2**n - 1)
</code></pre></div></div>
<p>Power-of-two sizes also admit a neat virtual memory trick<sup id="fnref:vmem" role="doc-noteref"><a href="#fn:vmem" rel="footnote">4</a></sup>, but that optimization is not included here.</p>

<p>However, power-of-two sizes can cause pathological behavior when paired with some hash functions, since indexing simply throws away the hash’s high bits.
An alternative strategy is to use <em>prime</em> sized tables, which are significantly more robust to the choice of hash function. 
For the purposes of this post, we have a fixed hash function, so prime sizes were not used<sup id="fnref:prime" role="doc-noteref"><a href="#fn:prime" rel="footnote">5</a></sup>.</p>

<h2 id="hash-function">Hash Function</h2>

<p>All benchmarked tables use the <code>squirrel3</code> hash function, a fast integer hash that (as far as I can tell) only exists in <a href="https://www.youtube.com/watch?v=LWFzPP8ZbdU">this GDC talk on noise-based RNG</a>.</p>

<p>Here, it is adapted to 64-bit integers by choosing three large 64-bit primes:</p>
<div><div><pre><code><span>uint64_t</span> <span>squirrel3</span><span>(</span><span>uint64_t</span> <span>at</span><span>)</span> <span>{</span>
    <span>constexpr</span> <span>uint64_t</span> <span>BIT_NOISE1</span> <span>=</span> <span>0x9E3779B185EBCA87ULL</span><span>;</span>
    <span>constexpr</span> <span>uint64_t</span> <span>BIT_NOISE2</span> <span>=</span> <span>0xC2B2AE3D27D4EB4FULL</span><span>;</span>
    <span>constexpr</span> <span>uint64_t</span> <span>BIT_NOISE3</span> <span>=</span> <span>0x27D4EB2F165667C5ULL</span><span>;</span>
    <span>at</span> <span>*=</span> <span>BIT_NOISE1</span><span>;</span>
    <span>at</span> <span>^=</span> <span>(</span><span>at</span> <span>&gt;&gt;</span> <span>8</span><span>);</span>
    <span>at</span> <span>+=</span> <span>BIT_NOISE2</span><span>;</span>
    <span>at</span> <span>^=</span> <span>(</span><span>at</span> <span>&lt;&lt;</span> <span>8</span><span>);</span>
    <span>at</span> <span>*=</span> <span>BIT_NOISE3</span><span>;</span>
    <span>at</span> <span>^=</span> <span>(</span><span>at</span> <span>&gt;&gt;</span> <span>8</span><span>);</span>
    <span>return</span> <span>at</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>I make no claims regarding the quality or robustness of this hash function, but observe that it’s cheap, it produces the expected number of collisions in power-of-two tables, and it passes <a href="https://github.com/rurban/smhasher">smhasher</a> when applied bytewise.</p>

<h2 id="other-benchmarks">Other Benchmarks</h2>

<p>Several less interesting benchmarks were also run, all of which exhibited identical performance across equal-memory open-addressed tables and <strong>much</strong> worse performance for separate chaining.</p>
<ul>
  <li>Time to look up each element by following a <a href="https://danluu.com/sattolo/">Sattolo cycle</a><sup id="fnref:sattolo" role="doc-noteref"><a href="#fn:sattolo" rel="footnote">6</a></sup> (2-4x).</li>
  <li>Time to clear the table (100-200x).</li>
  <li>Time to iterate all values (3-10x).</li>
</ul>



<h2 id="separate-chaining">Separate Chaining</h2>

<p>To get our bearings, let’s first <a href="https://github.com/TheNumbat/hashtables/blob/main/code/chaining.h">implement</a> a simple separate chaining table and benchmark it at various load factors.</p>

<table>
<tbody><tr><td rowspan="2"><strong>Separate Chaining</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>100% Load</strong></td><td colspan="2"><strong>200% Load</strong></td><td colspan="2"><strong>500% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">120</td><td colspan="2">130</td><td colspan="2">130</td><td colspan="2">151</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">112</td><td colspan="2">135</td><td colspan="2">179</td><td colspan="2">305</td></tr>
<tr><td>Lookup (ns/key)</td><td>28</td><td>28</td><td>36</td><td>41</td><td>51</td><td>69</td><td>103</td><td>186</td></tr>
<tr><td>Average Probe</td><td>1.25</td><td>0.50</td><td>1.50</td><td>1.00</td><td>2.00</td><td>2.00</td><td>3.50</td><td>5.00</td></tr>
<tr><td>Max Probe</td><td>7</td><td>7</td><td>10</td><td>10</td><td>12</td><td>12</td><td>21</td><td>21</td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.50</td><td colspan="2">2.00</td><td colspan="2">1.75</td><td colspan="2">1.60</td></tr>
</tbody></table>

<p>These are respectable results, especially lookups at 100%: the CPU is able to hide much of the memory latency. 
Insertions and erasures, on the other hand, are pretty slow—they involve allocation.</p>

<p>Technically, the reported memory amplification in an <em>underestimate</em>, as it does not include heap allocator overhead. 
However, we should not <em>directly</em> compare memory amplification against the coming open-addressed tables, as storing larger values would improve separate chaining’s ratio.</p>

<h3 id="stdunordered_map"><code>std::unordered_map</code></h3>

<p>Running these benchmarks on <code>std::unordered_map&lt;uint64_t,uint64_t&gt;</code> produces results roughly equivalent to the 100% column, just with marginally slower insertions and faster clears.
Using <code>squirrel3</code> with <code>std::unordered_map</code> additionally makes insertions slightly slower and lookups slightly faster. 
Further comparisons will be relative to these results, since exact performance numbers for <code>std::unordered_map</code> depend on one’s standard library distribution (here, Microsoft’s).</p>

<h2 id="linear-probing">Linear Probing</h2>

<p>Next, let’s <a href="https://github.com/TheNumbat/hashtables/blob/main/code/linear.h">implement</a> the simplest type of open addressing—linear probing.</p>

<p>In the following diagrams, assume that each letter hashes to its alphabetical index. The skull denotes a <em>tombstone</em>.</p>

<ul>
  <li>
    <p>Insert: starting from the key’s index, place the key in the first empty or tombstone bucket.</p>

    <p><img src="https://thenumb.at/assets/hashtables/linear_insert.svg"/></p>
  </li>
  <li>
    <p>Lookup: starting from the key’s index, probe buckets in order until finding the key, reaching an empty non-tombstone bucket, or exhausting the table.</p>

    <p><img src="https://thenumb.at/assets/hashtables/linear_find.svg"/></p>
  </li>
  <li>
    <p>Erase: lookup the key and replace it with a tombstone.</p>

    <p><img src="https://thenumb.at/assets/hashtables/linear_erase.svg"/></p>
  </li>
</ul>

<p>The results are surprisingly good, considering the simplicity:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Linear Probing</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">47</td><td colspan="2">60</td><td colspan="2">73</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">21</td><td colspan="2">36</td><td colspan="2">47</td></tr>
<tr><td>Lookup (ns/key)</td><td>21</td><td>86</td><td>35</td><td>122</td><td>47</td><td>291</td></tr>
<tr><td>Average Probe</td><td>0.50</td><td>6.04</td><td>1.49</td><td>29.49</td><td>4.46</td><td>222.04</td></tr>
<tr><td>Max Probe</td><td>43</td><td>85</td><td>181</td><td>438</td><td>1604</td><td>2816</td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>For existing keys, we’re already beating the separately chained tables, and with lower memory overhead! 
Of course, there are also some obvious problems—looking for missing keys takes much longer, and the worst-case probe lengths are quite scary, even at 50% load factor. 
But, we can do much better.</p>

<h3 id="erase-rehashing">Erase: Rehashing</h3>

<p>One simple optimization is automatically recreating the table once it accumulates too many tombstones.
Erase now occurs in <em>amortized</em> constant time, but we already tolerate that for insertion, so it shouldn’t be a big deal.
Let’s <a href="https://github.com/TheNumbat/hashtables/blob/main/code/linear_with_rehashing.h">implement</a> a table that re-creates itself after erase has been called \(\frac{N}{2}\) times.</p>

<p>Compared to <strong>naive linear probing</strong>:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Linear Probing</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">46</td><td colspan="2">57</td><td colspan="2">70</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">23 <strong>(+8.3%)</strong></td><td colspan="2">27 <strong>(-24.6%)</strong></td><td colspan="2">28 <strong>(-39.7%)</strong></td></tr>
<tr><td>Lookup (ns/key)</td><td>20</td><td>84</td><td>34</td><td>89 <strong>(-26.8%)</strong></td><td>46</td><td>142 <strong>(-51.2%)</strong></td></tr>
<tr><td>Average Probe</td><td>0.50</td><td>6.04</td><td>1.49</td><td>9.34 <strong>(-68.3%)</strong></td><td>4.46</td><td>57.84 <strong>(-74.0%)</strong></td></tr>
<tr><td>Max Probe</td><td>43</td><td>85</td><td>181</td><td>245 <strong>(-44.1%)</strong></td><td>1604</td><td>1405 <strong>(-50.1%)</strong></td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>Clearing the tombstones dramatically improves missing key queries, but they are still pretty slow. 
It also makes erase slower at 50% load—there aren’t enough tombstones to make up for having to recreate the table.
Rehashing also does nothing to mitigate long probe sequences for existing keys.</p>

<h3 id="erase-backward-shift">Erase: Backward Shift</h3>

<p>Actually, who says we need tombstones? There’s a little-taught, but very simple algorithm for erasing keys that doesn’t degrade performance <em>or</em> have to recreate the table.</p>

<p>When we erase a key, we don’t know whether the lookup algorithm is relying on our bucket being filled to find keys later in the table. 
Tombstones are one way to avoid this problem. 
Instead, however, we can guarantee that traversal is never disrupted by simply <em>removing and reinserting all following keys</em>, up to the next empty bucket.</p>

<p>Note that despite the name, we are not simply shifting the following keys backward. Any keys that are already at their optimal index will not be moved.
For example:</p>

<p><img src="https://thenumb.at/assets/hashtables/linear_deletion.svg"/></p>

<p>After <a href="https://github.com/TheNumbat/hashtables/blob/main/code/linear_with_deletion.h">implementing</a> backward-shift deletion, we can compare it to <strong>linear probing with rehashing</strong>:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Linear Probing</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">48</td><td colspan="2">60</td><td colspan="2">73</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">47 <strong>(+107%)</strong></td><td colspan="2">83 <strong>(+208%)</strong></td><td colspan="2">149 <strong>(+425%)</strong></td></tr>
<tr><td>Lookup (ns/key)</td><td>20</td><td>38 <strong>(-55.1%)</strong></td><td>36</td><td>89</td><td>46</td><td>134</td></tr>
<tr><td>Average Probe</td><td>0.50</td><td>1.50 <strong>(-75.2%)</strong></td><td>1.49</td><td>7.46 <strong>(-20.1%)</strong></td><td>4.46</td><td>49.7 <strong>(-14.1%)</strong></td></tr>
<tr><td>Max Probe</td><td>43</td><td>50 <strong>(-41.2%)</strong></td><td>181</td><td>243</td><td>1604</td><td>1403</td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>Naturally, erasures become significantly slower, but queries on missing keys now have reasonable behavior, especially at 50% load.
In fact, at 50% load, this table already beats the performance of equal-memory separate chaining in all four metrics.
But, we can still do better: a 50% load factor is unimpressive, and max probe lengths are still very high compared to separate chaining.</p>

<p><em>You might have noticed that neither of these upgrades improved average probe length for existing keys. 
That’s because it’s not possible for linear probing to have any other average! 
Think about why that is—it’ll be interesting later.</em></p>

<h2 id="quadratic-probing">Quadratic Probing</h2>

<p>Quadratic probing is a common upgrade to linear probing intended to decrease average and maximum probe lengths.</p>

<p>In the linear case, a probe of length \(n\) simply queries the bucket at index \(h(k) + n\). 
Quadratic probing instead queries the bucket at index \(h(k) + n^2\). 
Each table operation must be updated to use this new probe sequence, but the logic is otherwise almost identical.</p>

<p><img src="https://thenumb.at/assets/hashtables/quad_insert.svg"/></p>

<p>There are also a couple subtle caveats to quadratic probing:</p>
<ul>
  <li>A quadratic probe sequence will not necessarily touch every bucket in the table, so insertions can fail despite there being an empty bucket. In this case, the table must grow and the insertion is retried.</li>
  <li>There actually <em>is</em> a <a href="https://epubs.siam.org/doi/pdf/10.1137/1.9781611975062.3">true deletion algorithm for quadratic probing</a>, but it’s a bit more involved than the linear case and hence not reproduced here. We will again use tombstones and rehashing.</li>
</ul>

<p>After <a href="https://github.com/TheNumbat/hashtables/blob/main/code/quadratic.h">implementing</a> our quadratic table, we can compare it to <strong>linear probing with rehashing</strong>:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Quadratic Probing</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">50</td><td colspan="2">60</td><td colspan="2">72</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">31 <strong>(+36.6%)</strong></td><td colspan="2">36 <strong>(+32.0%)</strong></td><td colspan="2">38 <strong>(+32.0%)</strong></td></tr>
<tr><td>Lookup (ns/key)</td><td>21</td><td>86</td><td>32</td><td>97 <strong>(+8.0%)</strong></td><td>43</td><td>179 <strong>(+25.8%)</strong></td></tr>
<tr><td>Average Probe</td><td>0.43 <strong>(-13.9%)</strong></td><td>4.75 <strong>(-21.4%)</strong></td><td>0.97 <strong>(-35.2%)</strong></td><td>5.15 <strong>(-44.9%)</strong></td><td>1.79 <strong>(-59.9%)</strong></td><td>17.53 <strong>(-69.7%)</strong></td></tr>
<tr><td>Max Probe</td><td>19 <strong>(-55.8%)</strong></td><td>56 <strong>(-34.1%)</strong></td><td>47 <strong>(-74.0%)</strong></td><td>87 <strong>(-64.5%)</strong></td><td>112 <strong>(-93.0%)</strong></td><td>289 <strong>(-79.4%)</strong></td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>As expected, quadratic probing dramatically reduces both the average and worst case probe lengths, especially at high load factors. 
These gains are not <em>quite</em> as impressive when compared to the linear table with backshift deletion, but are still very significant.</p>

<p>Reducing the average probe length improves the average performance of all queries. 
Here, however, query performance has regressed slightly, as quadratic probing itself requires more computation and accesses memory less predictably.
That’s not necessarily a deal breaker—performance is lower variance—but it’s not ideal.</p>

<h2 id="double-hashing">Double Hashing</h2>

<p>Double hashing purports to provide even better behavior than quadratic probing. 
Instead of using the same probe sequence for every key, double hashing determines the probe stride by hashing the key a second time.
That is, a probe of length \(n\) queries the bucket at index \(h_1(k) + n*h_2(k)\)</p>

<ul>
  <li>If \(h_2\) is always co-prime to the table size, insertions always succeed, since the probe sequence will touch every bucket. That might sound difficult to assure, but since our table sizes are always a power of two, we can simply make \(h_2\) always return an odd number.</li>
  <li>Unfortunately, there is no true deletion algorithm for double hashing. We will again use tombstones and rehashing.</li>
</ul>

<p>Let’s <a href="https://github.com/TheNumbat/hashtables/blob/main/code/double.h">implement</a> a table with a slightly modified <code>squirrel3</code> as the second hash. 
The results, compared to <strong>quadratic probing with rehashing</strong>:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Double Hashing</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">72 <strong>(+42.8%)</strong></td><td colspan="2">77 <strong>(+28.9%)</strong></td><td colspan="2">87 <strong>(+20.8%)</strong></td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">30</td><td colspan="2">40 <strong>(+11.4%)</strong></td><td colspan="2">49 <strong>(+31.8%)</strong></td></tr>
<tr><td>Lookup (ns/key)</td><td>28 <strong>(+33.2%)</strong></td><td>90</td><td>38 <strong>(+18.6%)</strong></td><td>92</td><td>47</td><td>180</td></tr>
<tr><td>Average Probe</td><td>0.39 <strong>(-10.1%)</strong></td><td>4.38 <strong>(-7.7%)</strong></td><td>0.85 <strong>(-12.3%)</strong></td><td>4.72 <strong>(-8.3%)</strong></td><td>1.56 <strong>(-13.0%)</strong></td><td>16.25 <strong>(-7.3%)</strong></td></tr>
<tr><td>Max Probe</td><td>17</td><td>62 <strong>(+10.7%)</strong></td><td>42</td><td>66 <strong>(-24.1%)</strong></td><td>116</td><td>344 <strong>(+19.0%)</strong></td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>Double hashing succeeds in further reducing average probe lengths, but max lengths are more of a mixed bag. 
Unfortunately, the additional overhead of hashing every key twice makes most queries significantly slower, so double hashing does not seem worth it.</p>

<h2 id="robin-hood-linear-probing">Robin Hood Linear Probing</h2>

<p>So far, quadratic probing and double hashing have provided low probe lengths, but their raw query performance lags linear probing with backward shift deletion—at least at low load factors.
Enter <em><a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">Robin Hood</a> linear probing</em>. 
This strategy drastically reins in maximum probe lengths while maintaining high query performance.</p>

<p>The key difference is that when inserting a key, we are allowed to steal the position of an existing key if it is closer to its ideal index (“richer”) than the new key is. 
When this occurs, we simply swap the old and new keys and carry on inserting the old key in the same manner. This results in a more equitable distribution of probe lengths.</p>

<p><img src="https://thenumb.at/assets/hashtables/rh_insert.svg"/></p>

<p>This insertion method turns out to be so effective that we can entirely ignore rehashing as long as we keep track of the maximum probe length.
Lookups will simply probe until either finding the key or exhausting the maximum probe length.</p>

<p><a href="https://github.com/TheNumbat/hashtables/blob/main/code/robin_hood.h">Implementing</a> this table, compared to <strong>linear probing with backshift deletion</strong>:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Robin Hood</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">55  <strong>(+14.6%)</strong></td><td colspan="2">85  <strong>(+41.8%)</strong></td><td colspan="2">128 <strong>(+74.5%)</strong></td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">20 <strong>(-58.3%)</strong></td><td colspan="2">31 <strong>(-63.0%)</strong></td><td colspan="2">78 <strong>(-47.7%)</strong></td></tr>
<tr><td>Lookup (ns/key)</td><td>20 </td><td>58 <strong>(+54.5%)</strong></td><td>32 <strong>(-11.3%)</strong></td><td>109 <strong>(+23.1%)</strong></td><td>81 <strong>(+74.4%)</strong></td><td>148 <strong>(+9.9%)</strong></td></tr>
<tr><td>Average Probe</td><td>0.50</td><td>13 <strong>(+769%)</strong></td><td>1.49</td><td>28</td><td>4.46</td><td>67 <strong>(+34.9%)</strong></td></tr>
<tr><td>Max Probe</td><td>12 <strong>(-72.1%)</strong></td><td>13 <strong>(-74.0%)</strong></td><td>24 <strong>(-86.7%)</strong></td><td>28</td><td>58 <strong>(-96.4%)</strong></td><td>67 <strong>(-95.2%)</strong></td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>Maximum probe lengths improve <em>dramatically</em>, undercutting even quadratic probing and double hashing. 
This solves the main problem with open addressing.</p>

<p>However, performance gains are less clear-cut:</p>
<ul>
  <li>Insertion performance suffers across the board.</li>
  <li>Existing lookups are slightly faster at low load, but much slower at 90%.</li>
  <li>Missing lookups are maximally pessimistic.</li>
</ul>

<p>Fortunately, we’ve got one more trick up our sleeves.</p>

<h3 id="erase-backward-shift-1">Erase: Backward Shift</h3>

<p>When erasing a key, we can run a very similar backshift deletion algorithm. 
There are just two differences:</p>
<ul>
  <li>We can stop upon finding a key that is already in its optimal location. No further keys could have been pushed past it—they would have stolen this spot during insertion.</li>
  <li>We don’t have to re-hash—since we stop at the first optimal key, all keys before it can simply be shifted backward.</li>
</ul>

<p><img src="https://thenumb.at/assets/hashtables/rh_deletion.svg"/></p>

<p>With backshift deletion, we no longer need to keep track of the maximum probe length.</p>

<p><a href="https://github.com/TheNumbat/hashtables/blob/main/code/robin_hood_with_deletion.h">Implementing</a> this table, compared to <strong>naive robin hood probing</strong>:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Robin Hood</strong></td><td colspan="2"><strong>50% Load</strong></td><td colspan="2"><strong>75% Load</strong></td><td colspan="2"><strong>90% Load</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">55</td><td colspan="2">82</td><td colspan="2">125</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">32 <strong>(+64.0%)</strong></td><td colspan="2">48 <strong>(+54.2%)</strong></td><td colspan="2">60 <strong>(-22.8%)</strong></td></tr>
<tr><td>Lookup (ns/key)</td><td>20</td><td>34 <strong>(-42.0%)</strong></td><td>32</td><td>76 <strong>(-30.9%)</strong></td><td>80</td><td>114 <strong>(-22.8%)</strong></td></tr>
<tr><td>Average Probe</td><td>0.50</td><td>0.75 <strong>(-94.2%)</strong></td><td>1.49</td><td>1.87 <strong>(-93.3%)</strong></td><td>4.46</td><td>4.95 <strong>(-92.6%)</strong></td></tr>
<tr><td>Max Probe</td><td>12</td><td>12 <strong>(-7.7%)</strong></td><td>24</td><td>25 <strong>(-10.7%)</strong></td><td>58</td><td>67</td></tr>
<tr><td>Memory Amplification</td><td colspan="2">2.00</td><td colspan="2">1.33</td><td colspan="2">1.11</td></tr>
</tbody></table>

<p>We again regress the performance of erase, but we finally achieve reasonable missing-key behavior.
Given the excellent maximum probe lengths and overall query performance, Robin Hood probing with backshift deletion should be your default choice of hash table.</p>

<p><em>You might notice that at 90% load, lookups are significantly slower than basic linear probing. 
This gap actually isn’t concerning, and explaining why is an interesting exercise<sup id="fnref:slowerat90" role="doc-noteref"><a href="#fn:slowerat90" rel="footnote">7</a></sup>.</em></p>

<h2 id="two-way-chaining">Two-Way Chaining</h2>

<p>So, you’re still not satisfied with a maximum observed probe length of 12—you want to <em>provably</em> never iterate more than a constant number of buckets.
Another class of hash tables based on <em>Cuckoo hashing</em> can provide this guarantee.
Here, we will examine a particularly practical formulation known as <em>Two-Way Chaining</em>.</p>

<p>Our table will still consist of a flat array of buckets, but each bucket will be able to hold a small handful of keys.
When inserting an element, we will hash the key with <em>two different</em> functions, placing it into whichever corresponding bucket has more space. 
If both buckets happen to be filled, the entire table will grow and the insertion is retried.</p>

<p><img src="https://thenumb.at/assets/hashtables/two_way_insert.svg"/></p>

<p>You might think this is crazy—in separate chaining, the expected maximum probe length scales with \(O(\frac{\lg N}{\lg \lg N})\), so wouldn’t this waste copious amounts of memory growing the table?
It turns out adding a second hash function reduces the expected maximum to \(O(\lg\lg N)\), for reasons <a href="https://www.cs.cmu.edu/afs/cs/project/pscico-guyb/realworld/www/slidesS14/load-balancing.pdf">explored elsewhere</a>. 
That makes it practical to cap the maximum bucket size at a relatively small number.</p>

<p>Let’s <a href="https://github.com/TheNumbat/hashtables/blob/main/code/two_way.h">implement</a> a flat two-way chained table. We can measure how it performs with various bucket capacities:</p>

<table>
<tbody><tr><td rowspan="2"><strong>Two-Way</strong></td><td colspan="2"><strong>Capacity 2</strong></td><td colspan="2"><strong>Capacity 4</strong></td><td colspan="2"><strong>Capacity 8</strong></td></tr>
<tr><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td><td>Existing</td><td>Missing</td></tr>
<tr><td>Insert (ns/key)</td><td colspan="2">165</td><td colspan="2">126</td><td colspan="2">123</td></tr>
<tr><td>Erase (ns/key)</td><td colspan="2">33</td><td colspan="2">42</td><td colspan="2">54</td></tr>
<tr><td>Lookup (ns/key)</td><td>32</td><td>31</td><td>41</td><td>35</td><td>46</td><td>46</td></tr>
<tr><td>Average Probe</td><td>0.07</td><td>0.47</td><td>0.75</td><td>2.73</td><td>3.60</td><td>8.96</td></tr>
<tr><td>Max Probe</td><td>3</td><td>4</td><td>6</td><td>8</td><td>12</td><td>14</td></tr>
<tr><td>Memory Amplification</td><td colspan="2">16.00</td><td colspan="2">4.00</td><td colspan="2">2.00</td></tr>
</tbody></table>

<p>Since every key can be found in one of two possible buckets, query times become essentially deterministic.
Lookup times are especially impressive, only slightly lagging the Robin Hood table and having no penalty on missing keys. 
The average probe lengths indicate that most buckets are approximately half full, and the max probe lengths are strictly bounded by two times the bucket size. 
Memory efficiency does suffer at small bucket capacities (and hence insertion is slower on average due to growing the table), but is still reasonable for memory unconstrained use cases.</p>

<p>Overall, two-way chaining is another good choice of hash table, at least when memory efficiency is not the highest priority.
In the next section, we’ll also see how lookups can even further accelerated with prefetching and SIMD operations.</p>

<p><em>Remember that deterministic queries might not matter if you haven’t already implemented incremental table growth.</em></p>

<h3 id="cuckoo-hashing">Cuckoo Hashing</h3>

<p><a href="https://www.brics.dk/RS/01/32/BRICS-RS-01-32.pdf">Cuckoo hashing</a> involves storing keys in two separate tables, each of which holds one key per bucket. 
This scheme will guarantee that every key is stored in its ideal bucket in one of the two tables.</p>

<p>Each key is hashed with two different functions and inserted using the following procedure:</p>
<ol>
  <li>If at least one table’s bucket is empty, the key is inserted there.</li>
  <li>Otherwise, the key is inserted anyway, evicting one of the existing keys.</li>
  <li>The evicted key is transferred to the opposite table at its other possible position.</li>
  <li>If doing so evicts another existing key, go to 3.</li>
</ol>

<p>If the loop ends up evicting the key we’re trying to insert, we know it has found a cycle and hence must grow the table.</p>

<p><img src="https://thenumb.at/assets/hashtables/cuckoo_insert.svg"/></p>

<p>Because Cuckoo hashing does not strictly bound the insertion sequence length, I didn’t benchmark it here, but it’s still an interesting option.</p>



<p>So far, the lookup benchmark has been implemented roughly like this:</p>
<div><div><pre><code><span>for</span><span>(</span><span>uint64_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>N</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
  <span>assert</span><span>(</span><span>table</span><span>.</span><span>find</span><span>(</span><span>keys</span><span>[</span><span>i</span><span>])</span> <span>==</span> <span>values</span><span>[</span><span>i</span><span>]);</span>
<span>}</span>
</code></pre></div></div>
<p>Naively, this loop runs one lookup at a time. 
However, you might have noticed that we’ve been able to find keys <em>faster than the CPU can load data from main memory</em>—so something more complex must be going on.</p>

<p>In reality, modern out-of-order CPUs can execute several iterations in parallel.
Expressing the loop as a dataflow graph lets us build a simplified mental model of how it actually runs: the CPU is able to execute a computation whenever its dependencies are available.</p>

<p>Here, green nodes are resolved, in-flight nodes are yellow, and white nodes have not begun:</p>

<p><img src="https://thenumb.at/assets/hashtables/dataflow.svg"/></p>

<p>In this example, we can see that each iteration’s root node (<code>i++</code>) only requires the value of <code>i</code> from the previous step—<strong>not</strong> the result of <code>find</code>.
Therefore, the CPU can run several <code>find</code> nodes in parallel, hiding the fact that each one takes ~100ns to fetch data from main memory.</p>

<h2 id="unrolling">Unrolling</h2>

<p>There’s a common optimization strategy known as <em>loop unrolling</em>.
Unrolling involves explicitly writing out the code for several <em>semantic</em> iterations inside each <em>actual</em> iteration of a loop.
When each inner pseudo-iteration is independent, unrolling explicitly severs them from the loop iterator dependency chain.</p>

<p>Most modern x86 CPUs can keep track of ~10 simultaneous pending loads, so let’s try manually unrolling our benchmark 10 times. 
The new code looks like the following, where <code>index_of</code> hashes the key but doesn’t do the actual lookup.</p>
<div><div><pre><code><span>uint64_t</span> <span>indices</span><span>[</span><span>10</span><span>];</span>
<span>for</span><span>(</span><span>uint64_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>N</span><span>;</span> <span>i</span> <span>+=</span> <span>10</span><span>)</span> <span>{</span>
  <span>for</span><span>(</span><span>uint64_t</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>10</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
    <span>indices</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>table</span><span>.</span><span>index_of</span><span>(</span><span>keys</span><span>[</span><span>i</span> <span>+</span> <span>j</span><span>]);</span>
  <span>}</span>
  <span>for</span><span>(</span><span>uint64_t</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>10</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
    <span>assert</span><span>(</span><span>table</span><span>.</span><span>find_index</span><span>(</span><span>indices</span><span>[</span><span>j</span><span>])</span> <span>==</span> <span>values</span><span>[</span><span>i</span> <span>+</span> <span>j</span><span>]);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>This isn’t true unrolling, since the inner loops introduce dependencies on <code>j</code>. 
However, it doesn’t matter in practice, as computing <code>j</code> is never a bottleneck.
In fact, our compiler can automatically unroll the inner loop for us (<code>clang</code> in particular does this).</p>

<table>
<tbody><tr><td><strong>Lookups (ns/find)</strong></td><td>Naive</td><td>Unrolled</td></tr>
<tr><td>Separate Chaining (100%)</td><td>36</td><td>35</td></tr>
<tr><td>Linear (75%)</td><td>35</td><td>35</td></tr>
<tr><td>Quadratic (75%)</td><td>32</td><td>32</td></tr>
<tr><td>Double (75%)</td><td>38</td><td>37</td></tr>
<tr><td>Robin Hood (75%)</td><td>32</td><td>32</td></tr>
<tr><td>Two-Way Chaining (x4)</td><td>41</td><td>45 <strong>(+11.4%)</strong></td></tr>
</tbody></table>

<p>Explicit unrolling has basically no effect, since the CPU was already able to saturate its pending load buffer.
However, manual unrolling now lets us introduce <em>software prefetching</em>.</p>

<h2 id="software-prefetching">Software Prefetching</h2>

<p>When traversing memory in a predictable pattern, the CPU is able to preemptively load data for future accesses.
This capability, known as <em>hardware prefetching</em>, is the reason our flat tables are so fast to iterate. 
However, hash table <em>lookups</em> are inherently unpredictable: the address to load is determined by a hash function. 
That means hardware prefetching cannot help us.</p>

<p>Instead, we can explicitly ask the CPU to prefetch address(es) we will load from in the near future. 
Doing so can’t speed up an individual lookup—we’d immediately wait for the result—but software prefetching can accelerate batches of queries.
Given several keys, we can compute where each query <em>will</em> access the table, tell the CPU to prefetch those locations, and <strong>then</strong> start actually accessing the table.</p>

<p>To do so, let’s make <code>table.index_of</code> prefetch the location(s) examined by <code>table.find_indexed</code>:</p>
<ul>
  <li>In open-addressed tables, we prefetch the slot the key hashes to.</li>
  <li>In two-way chaining, we prefetch <em>both</em> buckets the key hashes to.</li>
</ul>

<p>Importantly, prefetching requests the entire cache line for the given address, i.e. the aligned 64-byte chunk of memory containing that address.
That means surrounding data (e.g. the following keys) may also be loaded into cache.</p>

<table>
<tbody><tr><td><strong>Lookups (ns/find)</strong></td><td>Naive</td><td>Unrolled</td><td>Prefetched</td></tr>
<tr><td>Separate Chaining (100%)</td><td>36</td><td>35</td><td>27 <strong>(-25.6%)</strong></td></tr>
<tr><td>Linear (75%)</td><td>35</td><td>35</td><td>23 <strong>(-35.5%)</strong></td></tr>
<tr><td>Quadratic (75%)</td><td>32</td><td>32</td><td>24 <strong>(-24.8%)</strong></td></tr>
<tr><td>Double (75%)</td><td>38</td><td>37</td><td>31 <strong>(-17.4%)</strong></td></tr>
<tr><td>Robin Hood (75%)</td><td>32</td><td>32</td><td>23 <strong>(-28.3%)</strong></td></tr>
<tr><td>Two-Way Chaining (x4)</td><td>41</td><td>45 <strong>(+11.4%)</strong></td><td>29 <strong>(-29.1%)</strong></td></tr>
</tbody></table>

<p>Prefetching makes a big difference!</p>

<ul>
  <li>Separate chaining benefits from prefetching the unpredictable initial load<sup id="fnref:chainprefetch" role="doc-noteref"><a href="#fn:chainprefetch" rel="footnote">8</a></sup>.</li>
  <li>Linear tables with a low average probe length greatly benefit from prefetching.</li>
  <li>Quadratic and double-hashed probe sequences quickly leave the cache line (and require more computation), making prefetching a bit less effective.</li>
  <li>In two-way chaining, keys can <em>always</em> be found in a prefetched cache line—but each lookup requires fetching two locations, consuming extra load buffer slots.</li>
</ul>

<h2 id="simd">SIMD</h2>

<p>Modern CPUs provide SIMD (single instruction, multiple data) instructions that process multiple values at once.
These operations are useful for probing: for example, we can load a batch of \(N\) keys and compare them with our query in parallel. 
In the best case, a SIMD probe sequence could run \(N\) times faster than checking each key individually.</p>

<p><img src="https://thenumb.at/assets/hashtables/simd_find.svg"/></p>

<p>Let’s <a href="https://github.com/TheNumbat/hashtables/blob/main/code/two_way_simd.h">implement</a> SIMD-accelerated lookups for linear probing and two-way chaining, with \(N=4\):</p>

<table>
<tbody><tr><td><strong>Lookups (ns/find)</strong></td><td>Naive</td><td>Unrolled</td><td>Prefetched</td></tr>
<tr><td>Linear (75%)</td><td>35</td><td>35</td><td>23</td></tr>
<tr><td>SIMD Linear (75%)</td><td>40 <strong>(+13.7%)</strong></td><td>43 <strong>(+20.7%)</strong></td><td>27 <strong>(+20.1%)</strong></td></tr>
<tr><td>Two-Way Chaining (x4)</td><td>41</td><td>45</td><td>29</td></tr>
<tr><td>SIMD Two-Way Chaining (x4)</td><td>34 <strong>(-17.2%)</strong></td><td>35 <strong>(-21.9%)</strong></td><td>19 <strong>(-34.8%)</strong></td></tr>
</tbody></table>

<p>Unfortunately, SIMD lookups are <em>slower</em> for the linearly probed table—an average probe length of \(1.5\) meant the overhead of setting up an (unaligned) SIMD comparison wasn’t worth it. 
Two-way chaining, on the other hand, gets quite a bit faster. Buckets are on average half full, and we can find a key using at most two (aligned) SIMD comparisons.</p>



<ul>
  <li>The linear and Robin Hood tables use backshift deletion.</li>
  <li>The two-way SIMD table has capacity-4 buckets and uses AVX2 256-bit SIMD operations.</li>
  <li>Insert, erase, find, find unrolled, find prefetched, and find missing report nanoseconds per operation.</li>
  <li>Average probe, max probe, average missing probe, and max missing probe report number of iterations.</li>
  <li>Clear and iterate report milliseconds for the entire operation.</li>
  <li>Memory reports the ratio of allocated memory to size of stored data.</li>
</ul>

<table id="summary">
<tbody><tr><td><strong>Table</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr><td>Chaining 50</td>
<td>120</td>
<td>112</td>
<td>28</td>
<td>27</td>
<td>21</td>
<td>1.2</td>
<td>7</td>
<td>28</td>
<td>0.5</td>
<td>7</td>
<td>117.1</td>
<td>16.4</td>
<td>2.5</td>
</tr>
<tr><td>Chaining 100</td>
<td>130</td>
<td>135</td>
<td>36</td>
<td>35</td>
<td>27</td>
<td>1.5</td>
<td>10</td>
<td>41</td>
<td>1.0</td>
<td>9</td>
<td>120.1</td>
<td>14.0</td>
<td>2.0</td>
</tr>
<tr><td>Chaining 200</td>
<td>130</td>
<td>179</td>
<td>51</td>
<td>51</td>
<td>38</td>
<td>2.0</td>
<td>12</td>
<td>69</td>
<td>2.0</td>
<td>13</td>
<td>133.7</td>
<td>14.6</td>
<td>1.8</td>
</tr>
<tr><td>Chaining 500</td>
<td>151</td>
<td>305</td>
<td>103</td>
<td>109</td>
<td>77</td>
<td>3.5</td>
<td>21</td>
<td>186</td>
<td>5.0</td>
<td>21</td>
<td>157.2</td>
<td>22.9</td>
<td>1.6</td>
</tr>
<tr><td>Linear 50</td>
<td>48</td>
<td>47</td>
<td>20</td>
<td>20</td>
<td>16</td>
<td>0.5</td>
<td>43</td>
<td>38</td>
<td>1.5</td>
<td>50</td>
<td>1.1</td>
<td>4.8</td>
<td>2.0</td>
</tr>
<tr><td>Linear 75</td>
<td>60</td>
<td>83</td>
<td>36</td>
<td>36</td>
<td>23</td>
<td>1.5</td>
<td>181</td>
<td>89</td>
<td>7.5</td>
<td>243</td>
<td>0.8</td>
<td>2.4</td>
<td>1.3</td>
</tr>
<tr><td>Linear 90</td>
<td>73</td>
<td>149</td>
<td>46</td>
<td>46</td>
<td>30</td>
<td>4.5</td>
<td>1604</td>
<td>134</td>
<td>49.7</td>
<td>1403</td>
<td>0.6</td>
<td>1.0</td>
<td>1.1</td>
</tr>
<tr><td>Quadratic 50</td>
<td>50</td>
<td>31</td>
<td>21</td>
<td>20</td>
<td>16</td>
<td>0.4</td>
<td>19</td>
<td>86</td>
<td>4.7</td>
<td>56</td>
<td>1.1</td>
<td>5.2</td>
<td>2.0</td>
</tr>
<tr><td>Quadratic 75</td>
<td>60</td>
<td>36</td>
<td>32</td>
<td>32</td>
<td>24</td>
<td>1.0</td>
<td>47</td>
<td>97</td>
<td>5.1</td>
<td>87</td>
<td>0.7</td>
<td>2.1</td>
<td>1.3</td>
</tr>
<tr><td>Quadratic 90</td>
<td>72</td>
<td>38</td>
<td>43</td>
<td>43</td>
<td>32</td>
<td>1.8</td>
<td>112</td>
<td>179</td>
<td>17.5</td>
<td>289</td>
<td>0.6</td>
<td>1.0</td>
<td>1.1</td>
</tr>
<tr><td>Double 50</td>
<td>72</td>
<td>31</td>
<td>28</td>
<td>28</td>
<td>24</td>
<td>0.4</td>
<td>17</td>
<td>90</td>
<td>4.4</td>
<td>62</td>
<td>1.1</td>
<td>5.6</td>
<td>2.0</td>
</tr>
<tr><td>Double 75</td>
<td>77</td>
<td>41</td>
<td>38</td>
<td>37</td>
<td>31</td>
<td>0.8</td>
<td>42</td>
<td>92</td>
<td>4.7</td>
<td>66</td>
<td>0.7</td>
<td>2.3</td>
<td>1.3</td>
</tr>
<tr><td>Double 90</td>
<td>87</td>
<td>46</td>
<td>47</td>
<td>48</td>
<td>42</td>
<td>1.6</td>
<td>116</td>
<td>180</td>
<td>16.2</td>
<td>344</td>
<td>0.6</td>
<td>0.9</td>
<td>1.1</td>
</tr>
<tr><td>Robin Hood 50</td>
<td>55</td>
<td>32</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>0.5</td>
<td>12</td>
<td>34</td>
<td>0.7</td>
<td>12</td>
<td>1.1</td>
<td>4.8</td>
<td>2.0</td>
</tr>
<tr><td>Robin Hood 75</td>
<td>82</td>
<td>48</td>
<td>32</td>
<td>32</td>
<td>22</td>
<td>1.5</td>
<td>24</td>
<td>76</td>
<td>1.9</td>
<td>25</td>
<td>0.7</td>
<td>2.1</td>
<td>1.3</td>
</tr>
<tr><td>Robin Hood 90</td>
<td>125</td>
<td>60</td>
<td>80</td>
<td>78</td>
<td>41</td>
<td>4.5</td>
<td>58</td>
<td>114</td>
<td>5.0</td>
<td>67</td>
<td>0.6</td>
<td>1.2</td>
<td>1.1</td>
</tr>
<tr><td>Two-way x2</td>
<td>165</td>
<td>33</td>
<td>32</td>
<td>30</td>
<td>19</td>
<td>0.1</td>
<td>3</td>
<td>31</td>
<td>0.5</td>
<td>4</td>
<td>9.0</td>
<td>11.8</td>
<td>16.0</td>
</tr>
<tr><td>Two-way x4</td>
<td>126</td>
<td>42</td>
<td>41</td>
<td>45</td>
<td>29</td>
<td>0.7</td>
<td>6</td>
<td>35</td>
<td>2.7</td>
<td>8</td>
<td>2.3</td>
<td>3.6</td>
<td>4.0</td>
</tr>
<tr><td>Two-way x8</td>
<td>123</td>
<td>54</td>
<td>46</td>
<td>50</td>
<td>40</td>
<td>3.6</td>
<td>12</td>
<td>46</td>
<td>9.0</td>
<td>14</td>
<td>1.1</td>
<td>1.5</td>
<td>2.0</td>
</tr>
<tr><td>Two-way SIMD</td>
<td>152</td>
<td>62</td>
<td>34</td>
<td>35</td>
<td>19</td>
<td>0.3</td>
<td>1</td>
<td>25</td>
<td>1.0</td>
<td>1</td>
<td>2.2</td>
<td>3.6</td>
<td>4.0</td>
</tr>
</tbody></table>









  </div></div>
  </body>
</html>
