<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emschwartz.me/psa-write-transactions-are-a-footgun-with-sqlx-and-sqlite/">Original</a>
    <h1>PSA: Write Transactions are a Footgun with SQLx and SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    

    
        

        <p>
            <i>
                <time datetime="2026-02-17T18:31Z">
    17 Feb, 2026
</time>
            </i>
        </p>
    

    <p>Write transactions can lead to lock starvation and serious performance degradation when using SQLite with <a href="https://crates.io/crates/sqlx">SQLx</a>, the popular async Rust SQL library. In retrospect, I feel like this should have been obvious, but it took a little more staring at suspiciously consistent &#34;slow statement&#34; logs than I&#39;d like to admit, so I&#39;m writing it up in case it helps others avoid this footgun.</p>
<h2 id="sqlite-locking-and-transactions">SQLite Locking and Transactions</h2><p>SQLite is single-writer. In WAL mode, it can support concurrent reads and writes (or, technically &#34;write&#34; singular), but no matter the mode there is only ever one writer at a time. Before writing, a process needs to obtain an <a href="https://sqlite.org/lockingv3.html">EXCLUSIVE lock</a> on the database.</p>
<p>If you start a read transaction with a SELECT and then perform a write in the same transaction, the transaction will need to be upgraded to write transaction with an exclusive lock:</p>
<blockquote>
<p>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &#34;write statements&#34;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to a write transaction if possible. (<a href="https://sqlite.org/lang_transaction.html">source</a>)</p>
</blockquote>
<p>Transactions started with <code>BEGIN IMMEDIATE</code> or <code>BEGIN EXCLUSIVE</code> also take the exclusive write lock as soon as they are started.</p>
<h2 id="async-transactions-with-sqlx">Async Transactions with SQLx</h2><p>Transactions in SQLx look like this:</p>
<div><pre><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>tx</span><span> </span><span>=</span><span> </span><span>db_connection</span><span>.</span><span>begin</span><span>().</span><span>await</span><span>?</span><span>;</span>

<span>let</span><span> </span><span>read_value</span><span> </span><span>=</span><span> </span><span>sqlx</span><span>::</span><span>query</span><span>(</span><span>&#34;SELECT * FROM table WHERE id = $1&#34;</span><span>)</span>
<span>	</span><span>.</span><span>bind</span><span>(</span><span>1</span><span>)</span>
<span>	</span><span>.</span><span>fetch_one</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>*</span><span>tx</span><span>)</span>
<span>	</span><span>.</span><span>await</span><span>?</span><span>;</span>
<span>	</span>
<span>sqlx</span><span>::</span><span>query</span><span>(</span><span>&#34;UPDATE table SET some_field = $1 WHERE id = $2&#34;</span><span>)</span>
<span>	</span><span>.</span><span>bind</span><span>(</span><span>&#34;hello&#34;</span><span>)</span>
<span>	</span><span>.</span><span>bind</span><span>(</span><span>1</span><span>)</span>
<span>	</span><span>.</span><span>execute</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>*</span><span>tx</span><span>)</span>
<span>	</span><span>.</span><span>await</span><span>?</span><span>;</span>
<span>	</span>
<span>tx</span><span>.</span><span>commit</span><span>().</span><span>await</span><span>?</span><span>;</span>
</pre></div>
<p>This type of transaction where you read and then write is completely fine. The transaction starts as a read transaction and then is upgraded to a write transaction for the <code>UPDATE</code>.</p>
<h2 id="lock-starvation-with-multiple-writes">Lock Starvation with Multiple Writes</h2><p>The problem arises when you call <code>await</code> within a write transaction. For example, this could happen if you call multiple write statements within a transaction:</p>
<div><pre><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>tx</span><span> </span><span>=</span><span> </span><span>db_connection</span><span>.</span><span>begin</span><span>().</span><span>await</span><span>?</span><span>;</span>

<span>for</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>value</span><span>)</span><span> </span><span>in</span><span> </span><span>values</span><span> </span><span>{</span>
<span>	</span><span>sqlx</span><span>::</span><span>query</span><span>(</span><span>&#34;INSERT INTO table (id, some_field) VALUES ($1, $2)&#34;</span><span>)</span>
<span>		</span><span>.</span><span>bind</span><span>(</span><span>id</span><span>)</span>
<span>		</span><span>.</span><span>bind</span><span>(</span><span>value</span><span>)</span>
<span>		</span><span>.</span><span>execute</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>*</span><span>tx</span><span>)</span>
<span>		</span><span>.</span><span>await</span><span>?</span><span>;</span>
<span>}</span>

<span>tx</span><span>.</span><span>commit</span><span>().</span><span>await</span><span>?</span><span>;</span>
</pre></div>
<p>This code will cause serious performance degradation if you have multiple concurrent tasks that might be trying this operation, or any other write, at the same time.</p>
<p>When the program reaches the first <code>INSERT</code> statement, the transaction is upgraded to a write transaction with an exclusive lock. However, when you call <code>await</code>, the task yields control back to the async runtime. The runtime may schedule another task before returning to this one. The problem is that this task is now holding an exclusive lock on the database. All other writers must wait for this one to finish. If the newly scheduled task tries to write, it will simply wait until it hits the <a href="https://docs.rs/sqlx/latest/sqlx/sqlite/struct.SqliteConnectOptions.html#method.busy_timeout"><code>busy_timeout</code></a> and returns a busy timeout error. The original task <em>might</em> be able to make progress if no other concurrent writers are scheduled before it, but under higher load you might continuously have new tasks that block the original writer from progressing.</p>
<p>Starting a transaction with <code>BEGIN IMMEDIATE</code> will also cause this problem, because you will immediately take the exclusive lock and then yield control with <code>await</code>.</p>
<h2 id="identifying-this-problem-in-logs">Identifying this Problem in Logs</h2><p>In practice, you can spot this issue in your production logs if you see a lot of SQLx warnings that say <code>slow statement: execution time exceeded alert threshold</code> where the <code>elapsed</code> time is very close to your <a href="https://docs.rs/sqlx/latest/sqlx/sqlite/struct.SqliteConnectOptions.html#method.busy_timeout"><code>busy_timeout</code></a> (which is 5 seconds by default). This is the result of other tasks being scheduled by the runtime and then trying and failing to obtain the exclusive lock they need to write to the database while being blocked by a parked task.</p>
<h2 id="partial-solution-batched-writes">Partial Solution: Batched Writes</h2><p>We could safely replace the example code above with this snippet that uses a bulk insert to avoid the lock starvation problem:</p>
<div><pre><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>builder</span><span> </span><span>=</span><span> </span><span>sqlx</span><span>::</span><span>QueryBuilder</span><span>::</span><span>new</span><span>(</span>
<span>	</span><span>&#34;INSERT INTO table (id, some_field)&#34;</span>
<span>);</span>

<span>builder</span><span>.</span><span>push_values</span><span>(</span><span>values</span><span>,</span><span> </span><span>|</span><span>mut</span><span> </span><span>b</span><span>,</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>value</span><span>)</span><span>|</span><span> </span><span>{</span>
<span>	</span><span>b</span><span>.</span><span>push_bind</span><span>(</span><span>*</span><span>id</span><span>).</span><span>push_bind</span><span>(</span><span>*</span><span>value</span><span>);</span>
<span>});</span>

<span>builder</span><span>.</span><span>build</span><span>()</span>
<span>	</span><span>.</span><span>persistent</span><span>(</span><span>false</span><span>)</span><span> </span><span>// see note below</span>
<span>	</span><span>.</span><span>execute</span><span>(</span><span>&amp;</span><span>db_connection</span><span>)</span>
<span>	</span><span>.</span><span>await</span><span>?</span><span>;</span>
</pre></div>
<p>Note that if you do this with different numbers of values, you should call <code>.persistent(false)</code>. By default, SQLx caches prepared statements. However, each version of the query with a different number of arguments will be cached separately, which may thrash the cache.</p>
<h2 id="raw-sql-for-atomic-writes-to-multiple-tables">Raw SQL for Atomic Writes to Multiple Tables</h2><p>Unfortunately, the fix for atomic writes to multiple tables is uglier and potentially very dangerous. To avoid holding an exclusive lock across an <code>await</code>, you need to use the <a href="https://docs.rs/sqlx/latest/sqlx/fn.raw_sql.html"><code>raw_sql</code></a> interface to execute a transaction in one shot:</p>
<div><pre><span></span><span>sqlx</span><span>::</span><span>raw_sql</span><span>(</span><span> </span><span>// this is implicitly wrapped in a transaction</span>
<span>	</span><span>&#34;UPDATE table1 SET foo = &#39;bar&#39;;</span>
<span>	UPDATE table2 SET baz = &#39;qux&#39;;&#34;</span>
<span>).</span><span>execute</span><span>(</span><span>&amp;</span><span>db_connection</span><span>)</span>
<span>.</span><span>await</span><span>?</span><span>;</span>
</pre></div>
<p>However, this can lead to catastrophic SQL injection attacks if you use this for user input, because <code>raw_sql</code> does not support binding and sanitizing query parameters.</p>
<p>Note that you can technically run a transaction with multiple statements in a <a href="https://docs.rs/sqlx/latest/sqlx/fn.query.html"><code>query</code></a> call but the docs say:</p>
<blockquote>
<p>The query string may only contain a single DML statement: SELECT, INSERT, UPDATE, DELETE and variants. The SQLite driver does not currently follow this restriction, but that behavior is deprecated.</p>
</blockquote>
<p>If you find yourself needing atomic writes to multiple tables with SQLite and Rust, you might be better off rethinking your schema to combine those tables or switching to a synchronous library like <a href="https://crates.io/crates/rusqlite"><code>rusqlite</code></a> with a single writer started with <a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html"><code>spawn_blocking</code></a>.</p>
<h2 id="could-rusts-type-system-save-us">Could Rust&#39;s Type System Save Us?</h2><p>Maybe, but it probably won&#39;t. If SQLx differentiated between read and write statements, a write <a href="https://docs.rs/sqlx/latest/sqlx/struct.Transaction.html"><code>Transaction</code></a> could be <code>!Send</code> like <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html#impl-Send-for-MutexGuard%3C%27_,+T%3E"><code>std::sync::MutexGuard</code></a>, which would prevent it from being held across an <code>await</code> point.</p>
<p>However, SQLx is not an ORM and it probably isn&#39;t worth it for the library to have different methods for read versus write statements. Without that, there isn&#39;t a way to prevent write transaction locks from being held across <code>await</code>s while allowing safe read transactions to be used across <code>await</code>s.</p>
<p>So, in lieu of type safety to prevent this footgun, I wrote up this blog post and <a href="https://github.com/launchbadge/sqlx/pull/4166">this pull request</a> to include a warning about this in the docs.</p>
<hr/>
<p>Discuss on <a href="https://www.reddit.com/r/rust/comments/1r7eh9v/psa_write_transactions_are_a_footgun_with_sqlx/">r/rust</a> and <a href="https://news.ycombinator.com/item?id=47051153">Hacker News</a>.</p>
<hr/>


    

    
        
            <p>
                
                    <a rel="nofollow" href="https://emschwartz.me/blog/?q=rust">#rust</a>
                
                    <a rel="nofollow" href="https://emschwartz.me/blog/?q=scour">#scour</a>
                
            </p>
        

        
            


        

        
            
        
    


  </div></div>
  </body>
</html>
