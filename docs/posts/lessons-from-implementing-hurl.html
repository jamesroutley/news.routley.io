<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/lessons-from-implementing-hurl/">Original</a>
    <h1>Lessons from implementing Hurl</h1>
    
    <div id="readability-page-1" class="page"><div><p>I&#39;m proud to announce that Hurl is officially released and done!
You can check out the docs on <a href="https://hurl.wtf">hurl.wtf</a>.</p>
<p>The language itself came out of an interesting question: Python <em>sometimes</em> uses exceptions for control flow, so could we implement a language that eschews normal control flow and <em>only</em> uses exceptions?
The answer is yes, and it produces a language that&#39;s less bad to use than I expected!</p>
<p>In the process of implementing it, I learned a lot.
Next year I&#39;m going to try to make another language to learn about type systems, and that one should be more normal (but no promises).
Here are a few of my main takeaways from building Hurl.</p>

<p>I thought it would be totally mind bending to work without ordinary control flow.
The first couple of programs <em>were</em> mind bending but then you just learn the common patterns.
If you need to do an if-else, that&#39;s a <code>catch (true) ... catch (false)</code>.
Looping is harder to wrap your head around but it&#39;s also not so bad.</p>
<p>And the thing is, this is a general purpose programming language, so we can <em>build</em> this control flow.
I ended up with a function called <code>if</code> that takes a condition function and a body function as variables, and it runs those.
So you can write code like:</p>
<pre data-lang="hurl"><code data-lang="hurl">if(func() {
  hurl year == 2023;
}, func() {
  println(&#34;Hurl was written in 2023!&#34;);
});
</code></pre>
<p>It&#39;s not as clean as an <code>if</code> in reasonable languages, but it&#39;s also cleaner than I expected.
Part of this is also because I used dynamic scope, not lexical scope, so functions can operate more easily over outer scopes, but it would be doable either way with minor changes.</p>
<p>This has me really excited to explore things like <a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a>.
I&#39;ve been really intimidated by it my entire career, feeling inadequate and all the usual impostor feelings.
But now I can see concretely that eschewing normal control flow won&#39;t be a problem in itself.
I&#39;ve had <a href="http://www.riscvbook.com/">The RISC-V Reader</a> on my desk for a while and now it seems more approachable.</p>
<p>An unexpected lesson for me, but I&#39;ll take it.
So expect to see some RISC-V content next year!</p>

<p>My ambitions for Hurl were larger than my skills and time allowed for, and I had to pare it back.
The things that got cut were any of the tools that would make the language fairly nice to use, and error messages unfortunately went by the wayside.</p>
<p>I realized this would be harder than expected when I started <a href="https://eliseshaffer.com/blog/writing-basic-code-formatter/">writing the formatter</a> and then I started to rethink some of the other ambitions I had.</p>
<p>In a future language I <em>will</em> come back to some of these things.
I&#39;d love to write a slightly more sophisticated formatter that makes things a little prettier (though having one at all is an accomplishment I&#39;m proud of).
And I am really interested in exploring writing a <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">language server</a> for a homemade language next year, but this year I just could not work on it.</p>
<p>The big thing I have a lot of appreciation for now is the quality of error messages and debugging support in other languages.
Generating error messages that point to where the error happened in the executing program requires that you track all the line information at run time!
And that means you have to design it in from the beginning.
Guess who didn&#39;t realize that and made some mistakes that would&#39;ve been trouble to fix later?</p>
<p>Yeah, all those things that make a language nice to use are just a <em>lot</em> of work.
And my promise (to myself, to you) is that my next language will work at these and the goal will to be fairly pleasant to use as far as educational language projects go.</p>

<p>After working through <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> in 2022 where we implemented the tokenizer and parser from hand, I left with the impression that this was an intentional choice for instruction but perhaps not how we&#39;d do it for real.
Since then I&#39;ve learned that a great many languages <em>do</em> roll their own tokenizers and parsers, and I still wasn&#39;t sure why.</p>
<p>I used <a href="https://pest.rs">pest</a> to generate my parser for Hurl, and in a lot of ways it was pleasant to use.
But on the other hand, it felt fairly restrictive and it was a lot to learn.
In the end, I&#39;m not sure that I saved time over writing my own parser.</p>
<p>If you write your own tokenizer and parser, you get full control and you avoid adding another dependency.
They&#39;re also not that difficult to write (but there are a lot of details to get right, so they&#39;re tricky to get fully correct).</p>
<p>I would probably use <code>pest</code> again for a real project and it&#39;s used by some quite respectable projects like <a href="https://github.com/rust-lang/mdBook">mdbook</a>.
But for for my next language, I&#39;m going to write my own tokenizer and parser again.
It&#39;s pretty fun, I don&#39;t think it&#39;ll cost me much time, and yeah why not?</p>

<p>I implemented a tree-walk interpreter, and recursion is the only way you get looping, which results in a problem: as you loop, you push onto the stack and you get stack overflows.
And it&#39;s the <em>OS</em> provided stack for the <em>interpreter</em> which you end up blowing, so this isn&#39;t something we can just patch in Hurl itself.
This isn&#39;t something I thought through critically before deciding to do a tree-walk interpreter.
I knew that these are limited in some ways, but forgot how it would impact Hurl.</p>
<p>One solution here would be to migrate to a bytecode interpreter.
That&#39;s a big project and would be a rewrite of the whole interpreter, so it&#39;s not in the cards.
There might also be a way to optimize out some of the recursion here and create a loop from something tail recursive, but I don&#39;t know.</p>
<p>Another solution would be to add a new language construct.
I&#39;m not sure which language construct would help us out here, so it&#39;s an undetermined thing at the moment.</p>
<p>In the future, I&#39;ll make sure to account for this from the beginning and use a bytecode interpreter approach, or transpile to another language.</p>

<p>Software licenses don&#39;t have a reputation for being particularly, uh, exciting.
But they don&#39;t have to be boring!
They can be an opportunity for play, too.</p>
<p>Part of creating Hurl is art, and the license choice is a big part of that.
The <em>best</em> license choice would have been an OSS license and then later do a rug pull and <a href="https://www.hashicorp.com/blog/hashicorp-adopts-business-source-license">relicense as BSL</a>, but that would imply that this project would get any attention.
The <em>second</em> best license choice was to lean into my values intentionally.
I ultimately decided to pick a license that would:</p>
<ul>
<li>permit funny outcomes</li>
<li>allow educational use</li>
<li>reflect my morality and ethics</li>
</ul>
<p>And to do this I settled on not just a license.
Not dual licenses.
No, that would make sense.</p>
<p>Hurl is <em>triple</em> licensed.</p>
<p>You can choose which of the licenses applies.
You&#39;ve got the standard AGPL-3.0 (no &#34;or later&#34; here, I don&#39;t want to be bound to the FSF).
You&#39;ve also got the choice to buy a commercial license (serious inquiries only 😉).
Or you can use it under GAL-1.0 (the Gay Agenda License 1.0).
Here&#39;s that license, in its full glory:</p>
<pre data-lang="text"><code data-lang="text"># Gay Agenda License - 1.0

Copyright (c) 2023 Nicole Tietz-Sokolskaya &lt;me@ntietz.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &#34;Software&#34;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  - The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
  - The grantee shall actively support rights for all LGBTQ+ people, respecting
    their gender identities.
  - The grantee shall say &#34;be gay, do crime&#34; at least once during use of the
    software.

The license is immediately revoked if the grantee supports restricting the
rights of LGBTQ+ people.

If the grantee is found to not have said &#34;be gay, do crime&#34; during use of the
software, the grantee has thirty (30) days to remediate this violation without
loss of the license. If it is not remediated, then the grantee&#39;s grants via
this license are premanently retracted.

THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<p>Feel free to use this software for your own projects, with a few caveats.
It was modified from the MIT license, so most of it is boilerplate, with a couple of additions to it.
The main thing to note if you do for some reason decide to use this license is that it is <em>not tested</em> and I would probably be surprised if it&#39;s enforceable.
No lawyer has been involved or harmed in its creation.</p>
<p>At the end of the day, though, what license <em>is</em> enforceable if you don&#39;t have the money to fight Amazon on it?</p>

<p>This was the biggest takeaway.
It&#39;s not new to me, and I&#39;ve written before that you should <a href="https://eliseshaffer.com/blog/write-more-useless-software/">write more &#34;useless&#34; software</a>.
It was a great reminder of the joy and learning that can come from a long project that&#39;s <em>just</em> for fun and that has no practical value.</p>
<p>Along the way, I had a lot of fun.
I&#39;m not sure if I made friends or enemies.
And I sure did learn a <em>lot</em>.
Some of what I learned, I can apply at work starting this week!
And some of it is just added context for why certain things are hard, and makes me more deeply appreciate the tools that our dear language teams give us ❤️.</p>
<p>Go forth and write some playful code!</p>
<hr/>








</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://eliseshaffer.com/newsletter">newsletter</a> or use the <a href="https://eliseshaffer.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
