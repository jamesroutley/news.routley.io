<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cedardb.com/blog/doomql/">Original</a>
    <h1>Building a DOOM-like multiplayer shooter in pure SQL</h1>
    
    <div id="readability-page-1" class="page"><div><section id="post-hero" data-component="post-hero"><header><p><span data-anim="lines">September 8, 2025</span> <span data-anim="lines">•</span> <span data-anim="lines">12 minutes</span></p></header></section></div><div><section><section><p>I recently stumbled across Patrick’s excellent <a href="https://www.hey.earth/posts/duckdb-doom">DOOM clone</a> running in a browser powered by DuckDB-WASM.
Ever since I’ve read that, I wanted to push his awesome idea to the logical extreme: Build a <strong>multiplayer</strong> DOOM-like shooter <strong>entirely</strong> in SQL with CedarDB doing all the heavy lifting.
During a month of parental leave (i.e., a lot of sleepless nights), I tried exactly that.</p><p>Here’s a sneak peek at DOOMQL:</p><video controls="">
<source src="doomql.mp4" type="video/mp4"/>Your browser does not support the video tag.</video><p>DOOMQL in action</p><p>Okay, with the flashy demo out of the way, let’s talk about details.
What follows is a tour of the architecture, the SQL rendering pipeline, the game loop, and the fun metagame of cheating by issuing SQL commands against the database.</p></section><h2 id="why-even-do-this">Why even do this?</h2><section>Playing DuckDB DOOM in your browser is fun, but some things bugged me:
First of all, having parts of the rendering pipeline in Javascript felt like cheating. It worked well for DuckDB-Doom where everything is contained in a single HTML page, but I wanted to see if I could do everything in SQL. DuckDB-Doom is also a little bit stuttery with just 8 frames per second and has a pretty tiny viewport. I wanted to see if I could speed that up by switching over to CedarDB. I also wanted real sprites with transparency and they should move around believably in 3D space.
And most importantly, making the game multi-player should not just be possible, but easy, right? I got nerd-sniped by the perceived similarity of a database server to a traditional game server: <strong>Databases exist to synchronize shared state across clients.</strong> Thanks to transaction isolation, each player has a consistent view of the game world, no matter what the other clients are doing. Why not lean into that?
I would love to lie to you and claim I did it all to push CedarDB as an awesome database system but to be honest the database nerd in me just wanted to turn all knobs up to 11 and see what breaks.</section><h2 id="architectural-overview">Architectural overview</h2><section><p>At a high level</p><ul><li>State lives in tables (map, players, mobs, inputs, configs, sprites, …)</li><li>Rendering is a stack of SQL views that implement raycasting and sprite projection</li><li>The game loop is a tiny shell script that executes a SQL file ~ 30 times per second.</li><li>The client is ~ 150 lines of Python: It polls for input and queries the database for your 3D view.</li></ul><p>You can play, observe other players and even cheat (by sending raw SQL).</p></section><h2 id="game-state-or-lets-store-everything-in-the-database">Game state, or: Let’s store everything in the database</h2><section><p>With a database at hand, it’s natural to store all game configuration, state, and static data in the database:</p><p><strong>Config</strong>:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>CREATE</span><span> </span><span>TABLE</span><span> </span>config(<span>
</span></span></span><span><span><span>  </span>player_move_speed<span> </span><span>NUMERIC</span><span> </span><span>DEFAULT</span><span> </span><span>0</span>.<span>3</span>,<span> 
</span></span></span><span><span><span>  </span>player_turn_speed<span> </span><span>NUMERIC</span><span> </span><span>DEFAULT</span><span> </span><span>0</span>.<span>2</span>,<span>
</span></span></span><span><span><span>  </span>ammo_max<span> </span><span>INT</span><span> </span><span>DEFAULT</span><span> </span><span>10</span>,<span>
</span></span></span><span><span><span>  </span>ammo_refill_interval_seconds<span> </span><span>INT</span><span> </span><span>DEFAULT</span><span> </span><span>2</span><span>
</span></span></span><span><span><span>  </span>);<span>
</span></span></span></code></pre></div><p><strong>Map</strong>:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>map</span>(x<span> </span><span>INT</span>,<span> </span>y<span> </span><span>INT</span>,<span> </span>tile<span> </span><span>CHAR</span>);<span>
</span></span></span></code></pre></div><p><strong>Players and inputs</strong>:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>CREATE</span><span> </span><span>TABLE</span><span> </span>players<span> </span>(<span>
</span></span></span><span><span><span>  </span>id<span> </span><span>INT</span><span> </span><span>REFERENCES</span><span> </span>mobs(id),<span>
</span></span></span><span><span><span>  </span>score<span> </span><span>INT</span><span> </span><span>DEFAULT</span><span> </span><span>0</span>,<span>
</span></span></span><span><span><span>  </span>hp<span> </span><span>INT</span><span> </span><span>DEFAULT</span><span> </span><span>100</span>,<span>
</span></span></span><span><span><span>  </span>ammo<span> </span><span>INT</span><span> </span><span>DEFAULT</span><span> </span><span>10</span>,<span>
</span></span></span><span><span><span>  </span>last_ammo_refill<span> </span><span>int</span><span> </span><span>default</span><span> </span><span>EXTRACT</span>(EPOCH<span> </span><span>FROM</span><span> </span>(now()))::<span>INT</span><span>
</span></span></span><span><span><span></span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>CREATE</span><span> </span><span>TABLE</span><span> </span>inputs(<span>
</span></span></span><span><span><span>  </span>player_id<span> </span><span>INT</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span> </span><span>REFERENCES</span><span> </span>players(id),<span>
</span></span></span><span><span><span>  </span>action<span> </span><span>CHAR</span>(<span>1</span>),<span> </span><span>-- &#39;w&#39;, &#39;a&#39;, &#39;s&#39;, &#39;d&#39;, &#39;x&#39; for shooting
</span></span></span><span><span><span></span><span>  </span><span>timestamp</span><span> </span><span>TIMESTAMP</span><span> </span><span>DEFAULT</span><span> </span>NOW()<span>
</span></span></span><span><span><span></span>);<span>
</span></span></span></code></pre></div><p>Because everything is data, modding a running match is trivial:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>-- Change a setting
</span></span></span><span><span><span></span><span>update</span><span> </span>config<span> </span><span>set</span><span> </span>ammo_max<span> </span><span>=</span><span> </span><span>20</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>-- Add a player
</span></span></span><span><span><span></span><span>insert</span><span> </span><span>into</span><span> </span>players<span> </span><span>values</span><span> </span>(...);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Move forward
</span></span></span><span><span><span></span><span>update</span><span> </span><span>input</span><span> </span><span>set</span><span> </span>action<span> </span><span>=</span><span> </span><span>&#39;w&#39;</span><span> </span><span>where</span><span> </span>player_id<span> </span><span>=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>-- Cheat (pls be smarter about it)
</span></span></span><span><span><span></span><span>update</span><span> </span>players<span> </span><span>set</span><span> </span>hp<span> </span><span>=</span><span> </span><span>100000</span><span> </span><span>where</span><span> </span>player_id<span> </span><span>=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Ban cheaters (that weren&#39;t smart about it)
</span></span></span><span><span><span></span><span>delete</span><span> </span><span>from</span><span> </span>players<span> </span><span>where</span><span> </span>hp<span> </span><span>&gt;</span><span> </span><span>100</span>;<span>
</span></span></span></code></pre></div></section><h2 id="renderer-when-a-view-becomes-your-3d-view">Renderer: When a <code>VIEW</code> becomes your 3D view</h2><section><p>If you squint enough, in DOOM, a 3D (or more correct: 2.5D) view is just a <em>view over 2D state</em> (i.e., the level map and any players/enemies on it).
Well, we’ve got <code>VIEWS</code> in SQL as well. They’re also just views on our (2D) state tables.
What’s stopping us from quite <em>literally</em> building a 3D “view” of our 2D map
using a simple raycasting algorithm?</p><p>The pipeline:</p><ol><li>Send a set of rays from each player’s eye into the world, and see which map tiles are visible</li><li>Check which walls the player sees, rendering them at the correct height and more or less solid based on the distance</li><li>Project mobs into the player’s camera space</li><li>Select sprite LODs based on depth</li><li>Expand sprites into pixels, scaled to screen space</li><li>Occlude against walls and other sprites</li><li>Assemble frame buffer rows with <code>string_agg</code></li><li>Build a minimap reusing the visible tiles calculation from earlier</li><li>Combine the 3D view with minimap and HUD (HP/bullets/players) into a game view</li></ol><p>Let’s take a more in-depth look at steps 2, 7, and 8.</p></section><h3 id="raycasting">Raycasting</h3><section><p>The recursive ray‑marching logic is adapted from <a href="https://www.hey.earth/posts/duckdb-doom">Patrick’s DuckDB DOOM post</a>. Here is a simplified excerpt, adapted for multiplayer:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>CREATE</span><span> </span><span>OR</span><span> </span><span>REPLACE</span><span> </span><span>VIEW</span><span> </span>visible_tiles<span> </span><span>AS</span><span>  
</span></span></span><span><span><span></span><span>WITH</span><span> </span><span>RECURSIVE</span><span> </span>raytrace<span> </span><span>AS</span><span> </span>(<span>  
</span></span></span><span><span><span>  </span><span>-- Starting at the player&#39;s eye ...
</span></span></span><span><span><span></span><span>  </span><span>SELECT</span><span> </span>r.player_id,<span> </span>r.col,<span> </span><span>1</span><span> </span><span>AS</span><span> </span>step_count,<span>  
</span></span></span><span><span><span>         </span>r.player_x<span> </span><span>+</span><span> </span>COS(r.angle)<span>*</span>s.step<span> </span><span>AS</span><span> </span>fx,<span>  
</span></span></span><span><span><span>         </span>r.player_y<span> </span><span>+</span><span> </span>SIN(r.angle)<span>*</span>s.step<span> </span><span>AS</span><span> </span>fy,<span>  
</span></span></span><span><span><span>         </span>r.angle,<span> </span><span>0</span><span> </span><span>AS</span><span> </span>dist<span>  
</span></span></span><span><span><span>  </span><span>FROM</span><span> </span>rays<span> </span>r,<span> </span>settings<span> </span>s<span>  </span><span>-- rays are built in an earlier step
</span></span></span><span><span><span></span><span>  </span><span>UNION</span><span> </span><span>ALL</span><span>  
</span></span></span><span><span><span>  </span><span>-- ... we recursively march along the rays, 1 &#34;step&#34; at a time ...
</span></span></span><span><span><span></span><span>  </span><span>SELECT</span><span> </span>rt.player_id,<span> </span>rt.col,<span> </span>rt.step_count<span> </span><span>+</span><span> </span><span>1</span>,<span>  
</span></span></span><span><span><span>         </span>rt.fx<span> </span><span>+</span><span> </span>COS(rt.angle)<span>*</span>s.step,<span>  
</span></span></span><span><span><span>         </span>rt.fy<span> </span><span>+</span><span> </span>SIN(rt.angle)<span>*</span>s.step,<span>  
</span></span></span><span><span><span>         </span>rt.angle,<span>  
</span></span></span><span><span><span>         </span>step_count<span> </span><span>*</span><span> </span>s.step<span> </span><span>*</span><span> </span>COS(rt.angle<span> </span><span>-</span><span> </span>m.dir)<span> </span><span>AS</span><span> </span>dist<span>  
</span></span></span><span><span><span>  </span><span>FROM</span><span> </span>raytrace<span> </span>rt,<span> </span>settings<span> </span>s,<span> </span>players<span> </span>p,<span> </span>mobs<span> </span>m<span>  
</span></span></span><span><span><span>  </span><span>WHERE</span><span> </span>rt.step_count<span> </span><span>&lt;</span><span> </span>s.max_steps<span>   </span><span>-- ... stopping after our max render distance
</span></span></span><span><span><span></span><span>    </span><span>AND</span><span> </span>rt.player_id<span> </span><span>=</span><span> </span>p.id<span>  
</span></span></span><span><span><span>    </span><span>AND</span><span> </span>m.id<span> </span><span>=</span><span> </span>p.id<span>  
</span></span></span><span><span><span>    </span><span>AND</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span>(<span>  </span><span>-- or if we hit a wall
</span></span></span><span><span><span></span><span>      </span><span>SELECT</span><span> </span><span>1</span><span> </span><span>FROM</span><span> </span><span>map</span><span> </span>m<span>  
</span></span></span><span><span><span>      </span><span>WHERE</span><span> </span>m.x<span> </span><span>=</span><span> </span><span>CAST</span>(rt.fx<span> </span><span>AS</span><span> </span><span>INT</span>)<span> </span><span>AND</span><span> </span>m.y<span> </span><span>=</span><span> </span><span>CAST</span>(rt.fy<span> </span><span>AS</span><span> </span><span>INT</span>)<span>  
</span></span></span><span><span><span>        </span><span>AND</span><span> </span>m.tile<span> </span><span>=</span><span> </span><span>&#39;#&#39;</span>)<span>  </span><span>-- wall
</span></span></span><span><span><span></span>)<span>  
</span></span></span><span><span><span></span><span>-- We then determine per player:
</span></span></span><span><span><span>--  a) which tiles we hit
</span></span></span><span><span><span>--  b) how far away these tiles are
</span></span></span><span><span><span>--  c) the column of the screen each tile should correspond to
</span></span></span><span><span><span></span><span>SELECT</span><span> </span>player_id,<span> </span>tile,<span> </span><span>CAST</span>(fx<span> </span><span>AS</span><span> </span><span>INT</span>)<span> </span><span>AS</span><span> </span>tile_x,<span> </span><span>CAST</span>(fy<span> </span><span>AS</span><span> </span><span>INT</span>)<span> </span><span>AS</span><span> </span>tile_y,<span> </span>col,<span> </span><span>MIN</span>(dist)<span> </span><span>AS</span><span> </span>dist<span>  
</span></span></span><span><span><span></span><span>FROM</span><span> </span>raytrace<span> </span>rt,<span> </span><span>map</span><span> </span>m<span>  
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>m.x<span> </span><span>=</span><span> </span><span>CAST</span>(rt.fx<span> </span><span>AS</span><span> </span><span>INT</span>)<span> </span><span>AND</span><span> </span>m.y<span> </span><span>=</span><span> </span><span>CAST</span>(rt.fy<span> </span><span>AS</span><span> </span><span>INT</span>)<span>  </span><span>-- We might hit the same tile multiple times, so we take the closest hit
</span></span></span><span><span><span></span><span>GROUP</span><span> </span><span>BY</span><span> </span>player_id,<span> </span>tile_x,<span> </span>tile_y,<span> </span>tile,<span> </span>col;<span>  
</span></span></span></code></pre></div><p>And that’s just the <em>first</em> step in the pipeline. For the rest, take a look at <a href="https://github.com/cedardb/DOOMQL/blob/main/renderer.sql">the code</a>.</p></section><h3 id="final-frame-assembly">Final frame assembly</h3><section><p>After all the heavy lifting, the payoff is surprisingly simple:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span>player_id,<span> </span>y,<span> </span>string_agg(ch,<span> </span><span>&#39;&#39;</span><span> </span><span>ORDER</span><span> </span><span>BY</span><span> </span>x)<span> </span><span>AS</span><span> </span><span>row</span><span>  
</span></span></span><span><span><span></span><span>FROM</span><span> </span>framebuffer<span>  
</span></span></span><span><span><span></span><span>GROUP</span><span> </span><span>BY</span><span> </span>player_id,<span> </span>y;<span>  
</span></span></span></code></pre></div><p>This glues together character pixels into text rows.</p></section><h3 id="hud--minimap">HUD + minimap</h3><section><p>The same trick builds the HUD and minimap. Here is the health bar:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>&#39;HP: [&#39;</span><span> </span><span>||</span><span>
</span></span></span><span><span><span></span>repeat(<span>&#39;█&#39;</span>,<span> </span>LEAST(<span>20</span>,<span> </span>ROUND(<span>20</span><span> </span><span>*</span><span> </span>GREATEST(<span>0</span>,<span> </span>LEAST(p.hp,<span>100</span>))::<span>numeric</span><span> </span><span>/</span><span> </span><span>100</span>)::<span>int</span>))<span> </span><span>||</span><span>
</span></span></span><span><span><span></span>repeat(<span>&#39; &#39;</span>,<span> </span>GREATEST(<span>0</span>,<span> </span><span>20</span><span> </span><span>-</span><span> </span>ROUND(<span>20</span><span> </span><span>*</span><span> </span>GREATEST(<span>0</span>,<span> </span>LEAST(p.hp,<span>100</span>))::<span>numeric</span><span> </span><span>/</span><span> </span><span>100</span>)::<span>int</span>))<span> </span><span>||</span><span>
</span></span></span><span><span><span></span><span>&#39;] &#39;</span><span> </span><span>||</span><span> </span>GREATEST(<span>0</span>,<span> </span>p.hp)<span>
</span></span></span></code></pre></div><p>Add ammo dots with <code>repeat(&#39;•&#39;, p.ammo)</code> and you’ve got a HUD entirely in SQL:</p><pre tabindex="0"><code> 1: Lukas      (L) score: 1   HP: [█████████           ] 50    AMMO: ••••••••••
 2: Foobar     (F) score: 0   HP: [████████████████████] 100   AMMO: ••••••••  
</code></pre><p>We can also re-use our earlier <code>visible_tiles</code> view to build a minimap with a view cone:</p><pre tabindex="0"><code>select * from minimap where player_id = 1 order by y;

 player_id | y  |                               row                                
-----------+----+------------------------------------------------------------------
         1 |  0 | ################################################################
         1 |  1 | ################################################################
         1 |  2 | ##.......      #####               #############################
         1 |  3 | ##.....F.      #####               #####                     ###
         1 |  4 | ##.......      #####               #####                     ###
         1 |  5 | ##  .....      #####               #####                     ###
         1 |  6 | ##   ...                                                     ###
         1 |  7 | ##    .L                                                     ###
         1 |  8 | ##             #####               #####                     ###
         1 |  9 | ##             #####               #####                     ###
         1 | 10 | ##             #############  ##########                     ###
         1 | 11 | ##########  ################  ##########                     ###
         1 | 12 | ##########  ################  ##########                     ###
         1 | 13 | ##########  ################  ######################  ##########
         1 | 14 | ####                 #######  ######################  ##########
         1 | 15 | ####                 #######  ######################  ##########
         1 | 16 | ####                 #####             #####                 ###
         1 | 17 | ####                 #####             #####                 ###
         1 | 18 | ####                 #####             #####                 ###
         1 | 19 | ####                 #####             #####                 ###
         1 | 20 | ####                 #####             #####                 ###
         1 | 21 | ####                                   #####                 ###
         1 | 22 | ####                                                         ###
         1 | 23 | ####                 #####                                   ###
         1 | 24 | ####                 #####             #####                 ###
         1 | 25 | ####                 #####             #####                 ###
         1 | 26 | ####                 #####             #####                 ###
         1 | 27 | ####                 #####             #####                 ###
         1 | 28 | ####                 #####             #####                 ###
         1 | 29 | ################################################################
         1 | 30 | ################################################################
         1 | 31 | ################################################################
</code></pre></section><h2 id="the-surprisingly-elegant-game-loop">The surprisingly elegant game loop</h2><section><p>The loop is just a shell script running raw SQL against the database:</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span># Game loop @ 30 ticks per second</span>
</span></span><span><span><span>while</span> true; <span>do</span>
</span></span><span><span>  psql -qtAX -U <span>&#34;</span><span>$DB_USER</span><span>&#34;</span> -d <span>&#34;</span><span>$DB_NAME</span><span>&#34;</span> -h <span>&#34;</span><span>$DB_HOST</span><span>&#34;</span> -p <span>&#34;</span><span>$DB_PORT</span><span>&#34;</span> -f gameloop.sql
</span></span><span><span>  sleep 0.03
</span></span><span><span><span>done</span>
</span></span></code></pre></div><p>Inside <code>gameloop.sql</code>, actions like bullet movement, collisions, kills, and respawns run in a single transaction, which keeps state consistent even if something fails mid-tick.</p><p>Here’s the part processing interactions with bullets:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>-- Process all bullets
</span></span></span><span><span><span></span><span>BEGIN</span><span> </span><span>TRANSACTION</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Move bullets forward
</span></span></span><span><span><span></span><span>UPDATE</span><span> </span>mobs<span> 
</span></span></span><span><span><span></span><span>SET</span><span> </span>x<span> </span><span>=</span><span> </span>x<span> </span><span>+</span><span> </span>cos(dir)<span> </span><span>*</span><span> </span><span>0</span>.<span>5</span>,<span> </span>y<span> </span><span>=</span><span> </span>y<span> </span><span>+</span><span> </span>sin(dir)<span> </span><span>*</span><span> </span><span>0</span>.<span>5</span><span> 
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>kind<span> </span><span>=</span><span> </span><span>&#39;bullet&#39;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Delete bullets that are out of bounds
</span></span></span><span><span><span></span><span>DELETE</span><span> </span><span>FROM</span><span> </span>mobs<span> 
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>(x<span> </span><span>&lt;</span><span> </span><span>0</span><span> 
</span></span></span><span><span><span></span><span>OR</span><span> </span>x<span> </span><span>&gt;=</span><span> </span>(<span>select</span><span> </span><span>max</span>(x)<span> </span><span>from</span><span> </span><span>map</span>)<span> 
</span></span></span><span><span><span></span><span>OR</span><span> </span>y<span> </span><span>&lt;</span><span> </span><span>0</span><span> 
</span></span></span><span><span><span></span><span>OR</span><span> </span>y<span> </span><span>&gt;=</span><span> </span>(<span>select</span><span> </span><span>max</span>(y)<span> </span><span>from</span><span> </span><span>map</span>))<span>
</span></span></span><span><span><span></span><span>AND</span><span> </span>kind<span> </span><span>=</span><span> </span><span>&#39;bullet&#39;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Delete bullets that hit walls
</span></span></span><span><span><span></span><span>DELETE</span><span> </span><span>FROM</span><span> </span>mobs<span> </span>b<span> 
</span></span></span><span><span><span></span><span>WHERE</span><span> </span><span>EXISTS</span><span> 
</span></span></span><span><span><span>    </span>(<span>SELECT</span><span> </span><span>1</span><span> 
</span></span></span><span><span><span>    </span><span>FROM</span><span> </span><span>map</span><span> </span>m<span> 
</span></span></span><span><span><span>    </span><span>WHERE</span><span> </span>m.x<span> </span><span>=</span><span> </span><span>CAST</span>(b.x<span> </span><span>AS</span><span> </span><span>INT</span>)<span> 
</span></span></span><span><span><span>    </span><span>AND</span><span> </span>m.y<span> </span><span>=</span><span> </span><span>CAST</span>(b.y<span> </span><span>AS</span><span> </span><span>INT</span>)<span> 
</span></span></span><span><span><span>    </span><span>AND</span><span> </span>m.tile<span> </span><span>=</span><span> </span><span>&#39;#&#39;</span>)<span> 
</span></span></span><span><span><span></span><span>AND</span><span> </span>kind<span> </span><span>=</span><span> </span><span>&#39;bullet&#39;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Players hit by a bullet loses 50 HP
</span></span></span><span><span><span></span><span>UPDATE</span><span> </span>players<span> </span>p<span> </span><span>SET</span><span> </span>hp<span> </span><span>=</span><span> </span>hp<span> </span><span>-</span><span> </span><span>50</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> </span>collisions<span> </span><span>c</span><span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>p.id<span> </span><span>=</span><span> </span><span>c</span>.player_id;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- If a player has 0 or less HP, the player killing them gets a point
</span></span></span><span><span><span></span><span>UPDATE</span><span> </span>players<span> </span>p<span> </span><span>SET</span><span> </span>score<span> </span><span>=</span><span> </span>score<span> </span><span>+</span><span> </span><span>1</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> </span>collisions<span> </span><span>c</span><span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>p.id<span> </span><span>=</span><span> </span><span>c</span>.bullet_owner<span>
</span></span></span><span><span><span></span><span>AND</span><span> </span><span>EXISTS</span><span> </span>(<span>SELECT</span><span> </span><span>1</span><span> </span><span>FROM</span><span> </span>players<span> </span>p2<span> </span><span>WHERE</span><span> </span>p2.id<span> </span><span>=</span><span> </span><span>c</span>.player_id<span> </span><span>AND</span><span> </span>p2.hp<span> </span><span>&lt;=</span><span> </span><span>0</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Delete bullets that hit players
</span></span></span><span><span><span></span><span>DELETE</span><span> </span><span>FROM</span><span> </span>mobs<span> </span>m<span>
</span></span></span><span><span><span></span><span>USING</span><span> </span>collisions<span> </span><span>c</span><span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>m.id<span> </span><span>=</span><span> </span><span>c</span>.bullet_id;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Respawn players whose HP is 0 or less
</span></span></span><span><span><span></span><span>UPDATE</span><span> </span>mobs<span> </span>m<span>
</span></span></span><span><span><span></span><span>SET</span><span> </span>x<span> </span><span>=</span><span> </span>r.x,<span> </span>y<span> </span><span>=</span><span> </span>r.y,<span> </span>dir<span> </span><span>=</span><span> </span><span>0</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> </span>players<span> </span>p<span>
</span></span></span><span><span><span></span><span>CROSS</span><span> </span><span>JOIN</span><span> </span>(<span>
</span></span></span><span><span><span>  </span><span>SELECT</span><span> </span>x,<span> </span>y<span>
</span></span></span><span><span><span>  </span><span>FROM</span><span> </span><span>map</span><span>
</span></span></span><span><span><span>  </span><span>WHERE</span><span> </span>tile<span> </span><span>=</span><span> </span><span>&#39;R&#39;</span><span>
</span></span></span><span><span><span>  </span><span>ORDER</span><span> </span><span>BY</span><span> </span>random()<span>
</span></span></span><span><span><span>  </span><span>LIMIT</span><span> </span><span>1</span><span>
</span></span></span><span><span><span></span>)<span> </span><span>AS</span><span> </span>r<span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>m.id<span> </span><span>=</span><span> </span>p.id<span>
</span></span></span><span><span><span>  </span><span>AND</span><span> </span>p.hp<span> </span><span>&lt;=</span><span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Reset players&#39; HP to 100 and ammo to 10 after respawn
</span></span></span><span><span><span></span><span>UPDATE</span><span> </span>players<span> </span>p<span> </span><span>SET</span><span>
</span></span></span><span><span><span>  </span>hp<span> </span><span>=</span><span> </span><span>100</span>,<span>
</span></span></span><span><span><span>  </span>ammo<span> </span><span>=</span><span> </span><span>10</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> </span>mobs<span> </span>m<span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>p.id<span> </span><span>=</span><span> </span>m.id<span>
</span></span></span><span><span><span></span><span>AND</span><span> </span>p.hp<span> </span><span>&lt;=</span><span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>COMMIT</span>;<span>
</span></span></span></code></pre></div><p>On my machine, the game loop takes about 1 ms, so we could defintely improve the tick rate.
That might be a way to get the Counterstrike snobs who scoff at everything below 128 Hz.
It would require some refactoring on my part since I tied the movement speed to the game loop - a big no no in game design!</p><p>While only someone insane could think a pure SQL raycasting renderer is a good idea in an actual game, I’ll happily defend this transactional game loop.
I don’t think this part would be much more concise or less brittle in a real game engine.</p></section><h2 id="make-it-multiplayer-in-two-queries">Make it multiplayer in two queries</h2><section><p>The game client’s job description is simple:</p><ol><li>Render</li></ol><div><pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span>full_row<span> </span><span>FROM</span><span> </span>screen<span> </span><span>WHERE</span><span> </span>player_id<span> </span><span>=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span><span> </span><span>ORDER</span><span> </span><span>BY</span><span> </span>y<span>
</span></span></span></code></pre></div><ol start="2"><li>Send input</li></ol><div><pre tabindex="0"><code data-lang="sql"><span><span><span>INSERT</span><span> </span><span>INTO</span><span> </span>inputs(player_id,<span> </span>action)<span>
</span></span></span><span><span><span>    </span><span>VALUES</span><span> </span>(<span>&lt;</span>your_id<span>&gt;</span>,<span> </span><span>&lt;</span>pressed_key<span>&gt;</span>)<span>
</span></span></span><span><span><span>    </span><span>ON</span><span> </span>CONFLICT(player_id)<span>
</span></span></span><span><span><span>    </span><span>DO</span><span> </span><span>UPDATE</span><span> </span><span>SET</span><span> </span>action<span> </span><span>=</span><span> </span>EXCLUDED.action<span>
</span></span></span></code></pre></div><p>The game loop periodically checks the input table and moves all players accordingly - inside a transaction, of course, so we don’t run into any race conditions.</p><p>That’s it (well, plus a one-time “create player” on first connect). The ~150 lines of Python in the client mostly handle keyboard input and reducing terminal flicker.
Bonus: The client provides an observer mode. All it has to do is swap the <code>&lt;player_id&gt;</code> in the render call.</p></section><h2 id="performance">Performance</h2><section><p>At 128 x 64 pixels, a single player view takes ~33 ms on my machine, which is <strong>enough for a breezy ~30 FPS</strong>, compared to DuckDB DOOM’s 8 FPS at just 32 x 16 pixels.
I’m actually quite proud of that performance and quite happy with CedarDB here.
I don’t think any other database system can keep up with that.
Let me know if you find one!</p><p>You might worry that rendering the views of all players and filtering late would be very wasteful.
CedarDB’s query optimizer pushes the <code>where player_id = &lt;...&gt;</code> predicate through view boundaries, avoiding unncessary work.
You can easily check by running:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span><span> </span><span>*</span><span> </span><span>from</span><span> </span>screen<span> </span><span>order</span><span> </span><span>by</span><span> </span>y;<span> </span><span>-- render both users
</span></span></span><span><span><span>-- Time: 57,907 ms (~2x single player 33ms)
</span></span></span></code></pre></div></section><section><p>Because clients send raw SQL as superusers (I didn’t bother setting up any role based access control or row level security, don’t do that!), there’s an <strong>emergent metagame: Cheat creatively and try not to get caught</strong>.</p><p>Low effort:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>update</span><span> </span>players<span> </span><span>set</span><span> </span>score<span> </span><span>=</span><span> </span><span>0</span><span> </span><span>where</span><span> </span>id<span> </span><span>!=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span>;<span>
</span></span></span><span><span><span></span><span>update</span><span> </span>players<span> </span><span>set</span><span> </span>hp<span> </span><span>=</span><span> </span><span>0</span><span> </span><span>where</span><span> </span>id<span> </span><span>!=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span>;<span>
</span></span></span></code></pre></div><p>Mischievous:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>update</span><span> </span>inputs<span> </span><span>set</span><span> </span>action<span> </span><span>=</span><span> </span><span>null</span><span> </span><span>where</span><span> </span>player_id<span> </span><span>!=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span>;<span>
</span></span></span></code></pre></div><p>Steal kills:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>update</span><span> </span>mobs<span> </span><span>set</span><span> </span><span>owner</span><span> </span><span>=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span><span> </span><span>where</span><span> </span>kind<span> </span><span>=</span><span> </span><span>&#39;bullet&#39;</span>;<span>
</span></span></span></code></pre></div><p>Attempted but didn’t work:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>DELETE</span><span> </span><span>FROM</span><span> </span>mobs<span> </span>m<span>
</span></span></span><span><span><span></span><span>USING</span><span> </span>collisions<span> </span><span>c</span><span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span>m.id<span> </span><span>=</span><span> </span><span>c</span>.bullet_id<span> </span><span>AND</span><span> </span><span>c</span>.player_id<span> </span><span>=</span><span> </span><span>&lt;</span>your_id<span>&gt;</span>;<span>
</span></span></span></code></pre></div><p>This doesn’t work because moving bullets, checking for collisions, and respawn happens in the same transaction.
As transactions are atomic, you either see everything being applied at once, or nothing. By the time you see the hit, you’re already dead.
A property that’s very useful for database systems (and not just to prevent cheating).</p></section><h2 id="what-i-learned">What I learned</h2><section><p>I set out to see if I could push Patrick’s demo to an extreme: Doing the entire rendering pipeline in SQL.
And while it works, I have to admit that it is a pretty… bad idea? Fast enough, but horrible to maintain and debug.</p><p>The surprise was how <em>natural</em> it felt to express game state and logic in SQL.
It even felt like accidentally re-invented the <a href="https://en.wikipedia.org/wiki/Entity_component_system">entity-component-system</a> pattern.</p></section><h2 id="try-it-yourself">Try it yourself!</h2><section><p>All the code is on Github: <a href="https://github.com/cedardb/DOOMQL">DOOMQL Repo</a></p><p>Run:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>docker pull cedardb/cedardb:latest
</span></span><span><span>docker run --rm -p 5432:5432 -e <span>CEDAR_PASSWORD</span><span>=</span>postgres --detach cedardb/cedardb:latest
</span></span><span><span><span># Wait a few seconds for CedarDB to start</span>
</span></span><span><span>./server.sh
</span></span><span><span>
</span></span><span><span><span># in a second terminal window, zoom way out to have no line wraping issues</span>
</span></span><span><span>python3 pyclient.py
</span></span></code></pre></div><p>Want to discuss DOOMQL with me or find like-minded database nerds? <a href="https://bonsai.cedardb.com/slack">Join our Community Slack</a></p></section></section></div></div>
  </body>
</html>
