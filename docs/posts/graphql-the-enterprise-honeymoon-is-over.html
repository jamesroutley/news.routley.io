<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnjames.blog/posts/graphql-the-enterprise-honeymoon-is-over">Original</a>
    <h1>GraphQL: The enterprise honeymoon is over</h1>
    
    <div id="readability-page-1" class="page"><article><header><div><p>By <!-- -->John James</p><p>Published on <!-- -->December 14, 2025</p><p>Read time ~3 min</p></div></header><p>I’ve used GraphQL, specifically Apollo Client and Server, for a couple of years in a real enterprise-grade application.</p><p>Not a toy app. Not a greenfield startup. A proper production setup with multiple teams, BFFs, downstream services, observability requirements, and real users.</p><p>And after all that time, I’ve come to a pretty boring conclusion:</p><p>GraphQL solves a real problem, but that problem is far more niche than people admit. In most enterprise setups, it’s already solved elsewhere, and when you add up the tradeoffs, GraphQL often ends up being a net negative.</p><p>This isn’t a “GraphQL bad” post. It’s a “GraphQL after the honeymoon” post.</p><h3>what GraphQL is supposed to solve</h3><p>The main problem GraphQL tries to solve is overfetching.</p><ul><li>the client asks for exactly the fields it needs</li><li>no more, no less</li><li>no wasted bytes</li><li>no backend changes for every new UI requirement</li></ul><p>On paper, that’s great. In practice, things are messier.</p><h3>overfetching is already solved by BFFs</h3><p>Most enterprise frontend architectures already have a BFF (Backend for Frontend).</p><p>That BFF exists specifically to:</p><ul><li>shape data for the UI</li><li>aggregate multiple downstream calls</li><li>hide backend complexity</li><li>return exactly what the UI needs</li></ul><p>If you’re using REST behind a BFF, overfetching is already solvable. The BFF can scope down responses and return only what the UI cares about.</p><p>Yes, GraphQL can also do this. But here’s the part people gloss over.</p><p>So now your GraphQL layer still has to overfetch from downstream REST APIs, then reshape the response. You didn’t eliminate overfetching. You just moved it down a layer.</p><p>There is a case where GraphQL wins here. If multiple pages hit the same endpoint but need slightly different fields, GraphQL lets you scope those differences per query.</p><p>You’re usually talking about saving a handful of fields per request, in exchange for:</p><ul><li>more setup</li><li>more abstraction</li><li>more indirection</li><li>more code to maintain</li></ul><p>That’s a very expensive trade for a few extra kilobytes.</p><h3>implementation time is much higher than REST</h3><p>GraphQL takes significantly longer to implement than a REST BFF.</p><p>With REST, you typically:</p><ul><li>call downstream services</li><li>adapt the response</li><li>return what the UI needs</li></ul><p>With GraphQL, you now have to:</p><ul><li>define a schema</li><li>define types</li><li>define resolvers</li><li>define data sources</li><li>write adapter functions anyway</li><li>keep schema, resolvers, and clients in sync</li></ul><p>GraphQL optimizes consumption at the cost of production speed.</p><h3>observability is worse by default</h3><p>This one doesn’t get talked about enough.</p><ul><li>400 if the query can’t be parsed</li><li>200 with an <code>errors</code> array if something failed during execution</li><li>200 if it succeeded or partially succeeded</li><li>500 if the server is unreachable</li></ul><p>From an observability standpoint, this is painful.</p><p>With REST:</p><ul><li>2XX means success</li><li>4XX means client error</li><li>5XX means server error</li></ul><p>If you filter dashboards by 2XX, you know those requests succeeded.</p><p>Yes, Apollo lets you customize this behavior. But that’s kind of the point. You’re constantly paying a tax in extra configuration, extra conventions, and extra mental overhead just to get back to something REST gives you out of the box.</p><p>This matters when you’re on call, not when you’re reading blog posts.</p><h3>caching sounds amazing until you live with it</h3><p>Apollo’s normalized caching is genuinely impressive.</p><p>In theory. In practice, it’s fragile.</p><p>If you have two queries where only one field differs, Apollo treats them as separate queries. You then have to manually wire things so:</p><ul><li>existing fields come from cache</li><li>only the differing field is fetched</li></ul><p>At that point:</p><ul><li>you still have a roundtrip</li><li>you’ve added more code</li><li>debugging cache issues becomes its own problem</li></ul><p>Meanwhile, REST happily overfetches a few extra fields, caches the whole response, and moves on. Extra kilobytes are cheap. Complexity isn’t.</p><h3>the ID requirement is a leaky abstraction</h3><p>Apollo expects every object to have an <code>id</code> or <code>_id</code> field by default, or you need to configure a custom identifier.</p><p>That assumption does not hold in many enterprise APIs.</p><p>Plenty of APIs:</p><ul><li>don’t return IDs</li><li>don’t have natural unique keys</li><li>aren’t modeled as globally identifiable entities</li></ul><p>So now the BFF has to generate IDs locally just to satisfy the GraphQL client.</p><p>That means:</p><ul><li>more logic</li><li>more fields</li><li>you’re always fetching one extra field anyway</li></ul><p>Which is ironic, considering the original goal was to reduce overfetching.</p><p>REST clients don’t impose this kind of constraint.</p><h3>file uploads and downloads are awkward</h3><p>GraphQL is simply not a good fit for binary data.</p><p>In practice, you end up:</p><ul><li>returning a download URL</li><li>then using REST to fetch the file anyway</li></ul><p>Embedding large payloads like PDFs directly in GraphQL responses leads to bloated responses and worse performance.</p><p>This alone breaks the “single API” story.</p><h3>onboarding is slower</h3><p>Most frontend and full-stack developers are far more experienced with REST than GraphQL.</p><p>Introducing GraphQL means:</p><ul><li>teaching schemas</li><li>teaching resolvers</li><li>teaching query composition</li><li>teaching caching rules</li><li>teaching error semantics</li></ul><p>That learning curve creates friction, especially when teams need to move fast.</p><p>REST is boring, but boring scales extremely well.</p><h3>error handling is harder than it needs to be</h3><p>GraphQL error responses are… weird.</p><p>You have:</p><ul><li>nullable vs non-nullable fields</li><li>partial data</li><li>errors arrays</li><li>extensions with custom status codes</li><li>the need to trace which resolver failed and why</li></ul><p>All of this adds indirection.</p><p>Compare that to a simple REST setup where:</p><ul><li>input validation fails, return a 400</li><li>backend fails, return a 500</li><li>zod error, done</li></ul><p>Simple errors are easier to reason about than elegant ones.</p><h3>the net result</h3><p>GraphQL absolutely has valid use cases.</p><p>But in most enterprise environments:</p><ul><li>you already have BFFs</li><li>downstream services are REST</li><li>overfetching is not your biggest problem</li><li>observability, reliability, and speed matter more</li></ul><p>When you add everything up, GraphQL often ends up solving a narrow problem while introducing a broader set of new ones.</p><p>GraphQL isn’t bad. It’s just niche. And you probably don’t need it.</p><p>Especially if your architecture already solved the problem it was designed for.</p></article></div>
  </body>
</html>
