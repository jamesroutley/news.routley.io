<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/focus-editor/focus">Original</a>
    <h1>Focus: A simple and fast text editor written in Jai</h1>
    
    <div id="readability-page-1" class="page">

<header id="title-block-header">

<p>2023-08-29</p>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#research" id="toc-research">Research</a></li>
<li><a href="#fuse-implementations" id="toc-fuse-implementations">FUSE
implementations</a></li>
<li><a href="#implementation-and-obstacles" id="toc-implementation-and-obstacles">Implementation and
obstacles</a></li>
<li><a href="#usage-example" id="toc-usage-example">Usage
example</a></li>
<li><a href="#learnings-and-further-work" id="toc-learnings-and-further-work">Learnings and further work</a></li>
</ul>
</nav>
<p>Last week, we had “Impossible Stuff Day” at the Recurse Center. It’s
a bit like a one-day hackathon, with the main goal of trying to do
something that’s definitely past the <a href="https://www.recurse.com/self-directives#work-at-the-edge">edge of
one’s abilities</a>, and maybe adjust that edge afterwards.</p>
<p>I set out to access an image as a filesystem. I’d seen similar
projects:</p>
<ul>
<li><a href="https://omar.website/tabfs/">TabFS</a> (mount browser tabs
as a filesystem)</li>
<li><a href="https://github.com/dertuxmalwieder/rssfs">rssfs</a> (RSS
reader as a filesystem)</li>
<li><a href="https://mgree.github.io/ffs/">ffs</a>, the “file
filesystem” (mount semi-structured data as a filesystem)</li>
</ul>
<p>So it was obviously possible. The impossible (to me) aspect was a
combination of having a very fuzzy (at best) idea of where this would be
implemented (something something system calls), and having properly
worked with C more than ten years ago.</p>

<p>I hit the Recurse Center library so I could leaf through thick books
instead of turning my mouse wheel. After some quality time with <a href="https://man7.org/tlpi/">a</a> <a href="https://www.oreilly.com/library/view/advanced-programming-in/9780321638014/">few</a>
<a href="https://www.pearson.com/en-us/subject-catalog/p/unix-programming-environment-the/P200000000349/9780139376818">classics</a>,
I had a very rough idea: there is an abstraction for common filesystem
operations, the <em>virtual file system</em><a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>
(VFS), and a filesystem has to implement that interface. <em>The Linux
Programming Interface</em> had a helpful diagram, roughly like this:</p>
<!--
graph {
  node [shape=box]
  vfs [label="Virtual File System (VFS)"]
  Application -- vfs
  vfs -- {ext2, ext3, Reiserfs, VFAT, NFS}
}
-->
<img src="https://benjaminwuethrich.dev/diagrams/a84f5c0.svg"/>
<p>However, specifics about <em>what</em> exactly makes up the VFS were
a bit more difficult to come by. The Wikipedia page about VFS and a hint
from a <a href="https://leoshimo.com/">fellow Recurser</a> eventually
led me to <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>,
“Filesystem in Userspace”.</p>
<blockquote>
<p><strong>Filesystem in Userspace</strong> (<strong>FUSE</strong>) is a
software interface […] that lets non-privileged users create their own
file systems without editing kernel code.</p>
</blockquote>
<p>Phew <span data-emoji="sweat_smile">😅</span> No kernel
hacking for me!<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>

<p>To just see it in action, jump ahead to <em><a href="#usage-example">Usage Example</a></em>.</p>
<p>There is a <a href="https://github.com/libfuse/libfuse">reference
implementation</a> of FUSE, in the form of a chunky C library.
Apparently, there’s sometimes a bit of confusion around FUSE the
interface and libfuse the implementation, with people referring to both
as just “FUSE”—but the important part is that maybe there’s another
implementation that is more Benjamin-friendly!</p>
<p>At first, I found <a href="https://github.com/hanwen/go-fuse">Go
bindings for libfuse</a>, which already looked better to my <a href="https://go.dev/blog/gopher">Gopher</a> eyes. And a little later, a
from-scratch implementation in pure Go: <a href="https://github.com/bazil/fuse">bazil.org/fuse</a>, via <a href="https://blog.gopheracademy.com/advent-2014/fuse-zipfs/">this blog
post</a> describing <a href="https://github.com/bazil/zipfs"><code>zipfs</code></a>, which
mounts a ZIP archive as a filesystem. I started digging into the
code.</p>
<p>And this is how far I got on the day itself, so it really was
impossible for me! A few people demoed their most excellent projects: a
web server in Zig as a first Zig project; beginnings of a collaborative
editor with video chat; a <a href="https://eieio.games/nonsense/hexagone-converting-hex-to-rgb-with-a-font/">font
that converts hex colours to RGB</a>; building a neural network; coming
up with an image format from scratch; teaching the <a href="https://flipperzero.one/">Flipper Zero</a> to understand more
types of NFC tags…</p>

<p>I started modifying <code>zipfs</code>. My goal was to mount an image
and expose it as a directory tree, with the top-level directories
representing rows of pixels, containing directories representing
individual pixels, and in those directories, there should be files named
<code>r</code>, <code>g</code>, and <code>b</code>, containing RGB
values scaled to 0–255. Something like this, for a 2-by-2 pixel
image:</p>
<pre><code>.
├── row0
│   ├── col0
│   │   ├── b
│   │   ├── g
│   │   └── r
│   └── col1
│       ├── b
│       ├── g
│       └── r
└── row1
    ├── col0
    │   ├── b
    │   ├── g
    │   └── r
    └── col1
        ├── b
        ├── g
        └── r</code></pre>
<p>bazil.org/fuse provides a very nice higher-level abstraction for a
filesystem, where you have to implement a few required interfaces, and
then add more capabilities via implementing more interfaces. The minimal
set looks something like</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>type</span> FS <span>interface</span> <span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    Root<span>()</span> <span>(</span>Node<span>,</span> <span>error</span><span>)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>type</span> Node <span>interface</span> <span>{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    Attr<span>(</span>ctx context<span>.</span>Context<span>,</span> attr <span>*</span>fuse<span>.</span>Attr<span>)</span> <span>error</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Directories and files both implement <code>Node</code>. To enable a
directory to respond to lookup requests, it also has to implement
<code>NodeRequestLookuper</code>:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>type</span> NodeRequestLookuper <span>interface</span> <span>{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    Lookup<span>(</span>ctx context<span>.</span>Context<span>,</span> req <span>*</span>fuse<span>.</span>LookupRequest<span>,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        resp <span>*</span>fuse<span>.</span>LookupResponse<span>)</span> <span>(</span>Node<span>,</span> <span>error</span><span>)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This is where we can “make up” whatever directory structure we want.
We also want directories to be able to handle requests corresponding to
the <code>readdir</code> system call, and return a slice of directory
entries; this is done by implementing
<code>HandleReadDirAller</code>:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>type</span> HandleReadDirAller <span>interface</span> <span>{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    ReadDirAll<span>(</span>ctx context<span>.</span>Context<span>)</span> <span>([]</span>fuse<span>.</span>Dirent<span>,</span> <span>error</span><span>)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Notice the super-strict adherence to the single-method interface Go
naming convention of just appending <code>-er</code>!</p>
<p>Lastly, so we can open files, they have to implement
<code>NodeOpener</code>:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>type</span> NodeOpener <span>interface</span> <span>{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Open<span>(</span>ctx context<span>.</span>Context<span>,</span> req <span>*</span>fuse<span>.</span>OpenRequest<span>,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        resp <span>*</span>fuse<span>.</span>OpenResponse<span>)</span> <span>(</span>Handle<span>,</span> <span>error</span><span>)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>and the returned handle has to implement <code>HandleReader</code> to
actually retrieve file contents:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>type</span> HandleReader <span>interface</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    Read<span>(</span>ctx context<span>.</span>Context<span>,</span> req <span>*</span>fuse<span>.</span>ReadRequest<span>,</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        resp <span>*</span>fuse<span>.</span>ReadResponse<span>)</span> <span>error</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>All these combined are enough for a read-only filesystem.</p>
<p>The implementation reads the image into memory when mounting (error
checks and deferred close calls omitted):</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>func</span> mount<span>(</span>path<span>,</span> mountpoint <span>string</span><span>)</span> <span>error</span> <span>{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    reader<span>,</span> _ <span>:=</span> os<span>.</span>Open<span>(</span>path<span>)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    img<span>,</span> _<span>,</span> _ <span>:=</span> image<span>.</span>Decode<span>(</span>reader<span>)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    c<span>,</span> _ <span>:=</span> fuse<span>.</span>Mount<span>(</span>mountpoint<span>)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    filesys <span>:=</span> <span>&amp;</span>FS<span>{</span>img<span>:</span> img<span>}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span>return</span> fs<span>.</span>Serve<span>(</span>c<span>,</span> filesys<span>)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>And from then on, we can look things up in the image abstraction. For
example, a <code>File</code> has a reference to the image, knows about
its own name, and its pixel coordinates:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>type</span> File <span>struct</span> <span>{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    img  image<span>.</span>Image</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    name <span>string</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    x<span>,</span> y <span>int</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>And when we <code>Open</code> a file, we access the colour value at
those coordinates, and return a handle with a readcloser on a string
containing that value:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>f <span>*</span>File<span>)</span> Open<span>(</span>ctx context<span>.</span>Context<span>,</span> req <span>*</span>fuse<span>.</span>OpenRequest<span>,</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    resp <span>*</span>fuse<span>.</span>OpenResponse<span>)</span> <span>(</span>fs<span>.</span>Handle<span>,</span> <span>error</span><span>)</span> <span>{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    r<span>,</span> g<span>,</span> b<span>,</span> _ <span>:=</span> f<span>.</span>img<span>.</span>At<span>(</span>f<span>.</span>x<span>,</span> f<span>.</span>y<span>).</span>RGBA<span>()</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span>var</span> val <span>uint32</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span>switch</span> f<span>.</span>name <span>{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span>case</span> <span>&#34;r&#34;</span><span>:</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      val <span>=</span> r</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span>case</span> <span>&#34;g&#34;</span><span>:</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      val <span>=</span> g</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span>case</span> <span>&#34;b&#34;</span><span>:</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>      val <span>=</span> b</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span>default</span><span>:</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>nil</span><span>,</span> fmt<span>.</span>Errorf<span>(</span><span>&#34;invalid filename %q&#34;</span><span>,</span> f<span>.</span>name<span>)</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span>// Convert from 0..65535 to 0..255</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    colStr <span>:=</span> strconv<span>.</span>FormatUint<span>(</span><span>uint64</span><span>(</span>val<span>&gt;&gt;</span><span>8</span><span>),</span> <span>10</span><span>)</span> <span>+</span> <span>&#34;</span><span>\n</span><span>&#34;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>&amp;</span>FileHandle<span>{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        r<span>:</span> io<span>.</span>NopCloser<span>(</span>strings<span>.</span>NewReader<span>(</span>colStr<span>)),</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span>},</span> <span>nil</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>It wasn’t smooth sailing, though. For the longest time, all my
filesystem did was telling me <code>Input/output error</code> when
trying to perform any operation on it whatsoever. After a long, long,
time I realized that my directory implementation has to set the
directory mode bit:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>d <span>*</span>Dir<span>)</span> Attr<span>(</span>ctx context<span>.</span>Context<span>,</span> a <span>*</span>fuse<span>.</span>Attr<span>)</span> <span>error</span> <span>{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    a<span>.</span>Mode <span>=</span> iofs<span>.</span>ModeDir <span>|</span> <span>0755</span>  <span>// &lt;-- This one!</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>nil</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This was sufficient for most things to suddenly work!</p>
<p>The only other snag was all files for some reason being empty, even
though all methods were implemented. This one was way sillier because it
has nothing to do with domain knowledge. Instead, my <code>Read</code>
method did this:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>fh <span>*</span>FileHandle<span>)</span> Read<span>(</span>ctx context<span>.</span>Context<span>,</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    req <span>*</span>fuse<span>.</span>ReadRequest<span>,</span> resp <span>*</span>fuse<span>.</span>ReadResponse<span>)</span> <span>error</span> <span>{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span>var</span> val <span>[]</span><span>byte</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    _<span>,</span> err <span>:=</span> fh<span>.</span>r<span>.</span>Read<span>(</span>val<span>)</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    resp<span>.</span>Data <span>=</span> val</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span>return</span> err</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>As it turns out, the <code>io.Reader</code> interface</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Reader <span>interface</span> <span>{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    Read<span>(</span>p <span>[]</span><span>byte</span><span>)</span> <span>(</span>n <span>int</span><span>,</span> err <span>error</span><span>)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>isn’t magically adjusting the byte slice size for you (or allocating
it), so if you give it a nil slice, you get a nil slice back. The fix
was as simple as</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  func (fh *FileHandle) Read(ctx context.Context,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>      req *fuse.ReadRequest, resp *fuse.ReadResponse) error {</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>-     var val []byte</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span>+     val := make([]byte, req.Size)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      _, err := fh.r.Read(val)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>      resp.Data = val</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      return err</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The end results of all this is at <a href="https://github.com/bewuethr/imgfs">bewuethr/imgfs</a>.</p>

<p>Let’s mount this <a href="https://emoji.supply/kitchen/?%F0%9F%AA%84+%F0%9F%90%99=8wxe01">blobtopus</a>
as a filesystem:</p>
<figure>
<img src="https://benjaminwuethrich.dev/images/2023-08-29-blobtopus.webp" alt="Blobtopus"/>
<figcaption aria-hidden="true">Blobtopus</figcaption>
</figure>
<p>Or rather, this 10x10-pixel version of it:</p>
<figure>
<img src="https://benjaminwuethrich.dev/images/2023-08-29-blobtopus-10x10.webp" alt="Blobtopus pixels with coordinates and RGB values"/>
<figcaption aria-hidden="true">Blobtopus pixels with coordinates and RGB
values</figcaption>
</figure>
<p>Coordinates for <em>x</em> increase from left to right, and for
<em>y</em> from top to bottom. Three pixels have their RGB values
labelled, as retrieved with a colour picker.</p>
<p>We create a mount directory, and then mount the image into it:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>mkdir</span> mnt</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>imgfs</span> blobtopus.png mnt</span></code></pre></div>
<p>imgfs supports PNG, JPEG, GIF, and WebP.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>
<code>mnt</code> now contains one directory per pixel row:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>$</span> tree <span>-L</span> 1 mnt</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span>mnt</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span>├──</span> row00</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span>├──</span> row01</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span>├──</span> row02</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span>├──</span> row03</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span>├──</span> row04</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span>├──</span> row05</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span>├──</span> row06</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span>├──</span> row07</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span>├──</span> row08</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span>└──</span> row09</span></code></pre></div>
<p>And each of these contains ten pixel directories (“col” for
“column”):</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>$</span> tree <span>-L</span> 1 mnt/row00</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span>mnt/row00</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>├──</span> col00</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span>├──</span> col01</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span>├──</span> col02</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span>├──</span> col03</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span>├──</span> col04</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span>├──</span> col05</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span>├──</span> col06</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span>├──</span> col07</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span>├──</span> col08</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span>└──</span> col09</span></code></pre></div>
<p>And in each of those, there is one file per RGB component:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>$</span> tree mnt/row00/col00</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>mnt/row00/col00</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>├──</span> b</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span>├──</span> g</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span>└──</span> r</span></code></pre></div>
<p>Now, let’s check the labelled pixels! The pixel at
<em>x</em>/<em>y</em> coordinate (02/01) is in
<code>row01/col02</code>.</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>$</span> head mnt/row01/col02/<span>{r</span><span>,</span><span>g</span><span>,</span><span>b}</span>  <span># Want: (250,231,170)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a> <span>==</span><span>&gt;</span> mnt/row01/col02/r <span>&lt;</span>==</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>250</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row01/col02/g <span>&lt;</span>==</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span>231</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row01/col02/b <span>&lt;</span>==</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span>170</span></span></code></pre></div>
<p>Looking good!</p>
<p>And the other two:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>$</span> head mnt/row03/col06/<span>{r</span><span>,</span><span>g</span><span>,</span><span>b}</span>  <span># Want: (164,93,0)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row03/col06/r <span>&lt;</span>==</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span>164</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row03/col06/g <span>&lt;</span>==</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span>93</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row03/col06/b <span>&lt;</span>==</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span>0</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span>$</span> head mnt/row07/col05/<span>{r</span><span>,</span><span>g</span><span>,</span><span>b}</span>  <span># Want: (255,162,61)</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row07/col05/r <span>&lt;</span>==</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span>255</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row07/col05/g <span>&lt;</span>==</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span>162</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span>==</span><span>&gt;</span> mnt/row07/col05/b <span>&lt;</span>==</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span>61</span></span></code></pre></div>
<p>Ta-daah <span data-emoji="partying_face">🥳</span></p>

<p>The one cool additional thing to do would be to make the filesystem
writeable: updating the colour value in a file would change the pixel on
the actual image. Updating the in-memory image representation would be
straightforward, but continually changing an on-disk image file probably
less so; in-place changes wouldn’t work, so we’d have to create new
images files and rename them.</p>
<p>I certainly learned quite a few things about filesystems and FUSE,
but also feel like I scratched just the surface. The full FUSE API is
huge, and I’ve implemented a fraction of it, using a very high-level
abstraction, at that.</p>
<p>A meta-insight was that designating a chunk of time to doing
something specific makes it easy to get started (you start when
everybody else starts), and the whole thing being timeboxed resulted in
intense focus on the problem, even when not every second was exactly
thrilling.</p>
<p>This was very noticeable when I decided to keep working on this a day
later: I made very little progress, found it difficult to focus, and got
quite frustrated. I didn’t touch the project for the whole weekend, even
though I totally thought I would—and when I got back to it on Monday,
things seemed to fall into place quite easily.</p>
<p>In any case, I’m pretty happy I de-mystified “X as a filesystem” a
bit for myself, and maybe now also for others.</p>




</div>
  </body>
</html>
