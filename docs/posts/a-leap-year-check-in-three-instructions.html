<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hueffner.de/falk/blog/a-leap-year-check-in-three-instructions.html">Original</a>
    <h1>A leap year check in three instructions</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>
      With the following code, we can check whether a year 0 ≤ <i>y</i> ≤ 102499 is a leap year with only about 3 CPU instructions:
    </p>
  
    <pre><code>bool is_leap_year_fast(uint32_t y) {
    return ((y * 1073750999) &amp; 3221352463) &lt;= 126976;
}</code></pre>
      
    <p>How does this work? The answer is surprisingly complex. This article explains it, mostly to have some fun with bit-twiddling; at the end, I&#39;ll briefly discuss the practical use.</p>
      
    <p>This is how a leap year check is typically implemented:</p>

    <pre><code>bool is_leap_year(uint32_t y) {
    if ((y % 4) != 0) return false;
    if ((y % 100) != 0) return true;
    if ((y % 400) == 0) return true;
    return false;
}</code></pre>

    <p>We are using the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>, which extends the Gregorian calendar backward from its introduction in 1582 and includes a year 0. Thus, we don&#39;t need to treat years before 1582 any differently. For simplicity, we ignore negative years and use an unsigned year.</p>

    <h2>Optimizing the standard approach</h2>

    <p>Let&#39;s first do some simple speedups so that we get a good baseline. I&#39;m not sure where to assign credit – these tricks have probably been reinvented independently many times.</p>

    <p>We can replace <code>(y % 100) != 0</code> by <code>(y % 25) != 0</code>: we already know that <code>y</code> is a multiple of 2<sup>2</sup>, so if it is also a multiple of 5<sup>2</sup>, it is a multiple of 2<sup>2</sup> ⋅ 5<sup>2</sup> = 100. Similarly, we can replace <code>(y % 400) == 0</code> by <code>(y % 16) == 0</code>: we already know that <i>y</i> is a multiple of 5<sup>2</sup>, so if it is also a multiple of 2<sup>4</sup>, it is a multiple of 5<sup>2</sup> ⋅ 2<sup>4</sup> = 400.</p>

    <pre><code>bool is_leap_year1(uint32_t y) {
    if ((y % 4) != 0) return false;
    if ((y % 25) != 0) return true;
    if ((y % 16) == 0) return true;
    return false;
}</code></pre>
      
    <p>This is useful because we can now replace modulo by 4 and by 16 with bit masking. There is a further trick well-known to compiler implementors on how to lower the modulo by 25. Compiling <code>(x % 25) != 0</code> with gcc and translating back to C, we get <code>x * 3264175145 &gt; 171798691</code>. With multiplication at a typical latency of 3 cycles and modulo of at least 20 cycles, this is a great improvement. I will only give an intuition on how it works; more details can be found in
    </p><ul>
      <li><a href="https://doi.org/10.1002/spe.2689">Faster remainder by direct computation: Applications to compilers and software libraries</a> paper by Daniel Lemire, Owen Kaser, and Nathan Kurz for lowering modulo by a constant in general;</li>
      <li><a href="https://doi.org/10.1002/spe.3172">Euclidean affine functions and their application to calendar algorithms</a> by Cassio Neri and Lorenz Schneider more specifically for calendar calculations; and</li>
      <li><a href="https://davecturner.github.io/2020/08/07/leapyear-optimization.html">Identifying leap years</a> by David Turner for the leap year check (including formal proofs!).</li>
    </ul>

    <p>Where do the magic numbers come from? We have</p>

    <p><span>2<sup>32</sup> ⋅ 19/25 = 3264175144.96 (exactly).</span>
    </p>

    <p>So by multiplying with 3264175145, we calculate approximately the fractional part of multiplying with (19/25). If this was an exact multiplication, we would get a fractional part of zero for multiples of 25. We multiply with a number that is too high by 0.04 though, so the error can be up to 0.04 ⋅ (2<sup>32</sup> - 1) = 171798691.8, which is where the second magic number comes from.</p>

    <p>This trick doesn&#39;t work quite as nicely for <code>x % 100</code>, where we need one more fixup instruction, so the reduction from <code>y % 100</code> to <code>y % 25</code> was helpful.</p>

    <p>Our leap year check now looks like this:
    </p><pre><code>bool is_leap_year2(uint32_t y) {
    if ((y &amp; 3) != 0) return false;
    if (y * 3264175145u &gt; 171798691u) return true;
    if ((y &amp; 15) == 0) return true;
    return false;
}</code></pre>

    <p>Note that modern compilers like gcc or clang will produce <a href="https://godbolt.org/z/GeK6Trfx6">something</a> like <code>is_leap_year2</code> from <code>is_leap_year1</code>, so there is not much point in doing this in C source, but it might be useful in other programming languages.</p>

    <p>This code typically compiles to branching assembly. In practice, inputs are typically fairly predictable, so that is not necessarily bad. If we want to avoid branch misprediction penalties, at the price of also slowing down the best case, we can shuffle things around a bit and get <a href="https://godbolt.org/z/PWs8saMYd">branchless code</a> (and also a decent code golf candidate):</p>
    <pre><code>bool is_leap_year3(uint32_t y) {
    return !(y &amp; ((y % 25) ? 3 : 15));
}</code></pre>

    <p>If you want to see some more calendar calculation speedups, make sure to check out <a href="https://hueffner.de/falk/blog/Optimizing%20with%20Novel%20Calendrical%20Algorithms">https://jhpratt.dev/blog/optimizing-with-novel-calendrical-algorithms/</a> by Jacob Pratt.

    </p><h2>Finding a bit-twiddling approach</h2>

    <p>Can we improve the leap year calculation by giving up on correctness for all inputs? After all, we typically don&#39;t care whether the year 3584536493 is a leap year; indeed, Python, C#, and Go only support years 0 (or 1) to 9999 (at which point the drift relative to the seasons is already more than 4 days). My thought was that if something shorter exists, it will basically look like some weird hashing using magic constants, so I wanted to try some small forms and guess the constants by brute force. The form <code>(y * f) &lt;= t</code> seems useful but is not powerful enough yet. One of my candidates was adding a mask: <code>((y * f) &amp; m) &lt;= t</code>. Now we have 96 bits to guess, which is not feasible by brute force alone. Let&#39;s use <a href="https://github.com/Z3Prover/z3">z3</a>, a solver that supports bitvector constraints that is perfectly suited for this:</p>

    <pre><code>import z3

BITS = 32
f, m, t, y = z3.BitVecs(&#39;f m t y&#39;, BITS)

def target(y):
    return z3.And((y &amp; 3) == 0, z3.Or(z3.URem(y, 25) != 0, (y &amp; 15) == 0))

def candidate(x):
    return z3.ULE((x * f) &amp; m, t)

solver = z3.Solver()
solver.add(z3.ForAll(y, z3.Implies(z3.ULE(y, 400),
                                   candidate(y) == target(y))))

if solver.check() == z3.sat:
    print(f&#39;found solution: {solver.model()}&#39;)
else:
    print(&#39;no solution found&#39;)
</code></pre>

    <p>In a few seconds, this finds constants that yield the correct result for a nontrivial year range. Extending the range, I eventually found constants that yield the correct result from year 0 up to the year 102499, in about half an hour of computation time, and proved that this is the optimum for 32 bits:</p>

    <pre><code>bool is_leap_year_fast(uint32_t y) {
    const uint32_t f = 1073750999u;
    const uint32_t m = 3221352463u;
    const uint32_t t = 126976u;
    return ((y * f) &amp; m) &lt;= t;
}</code></pre>

    <h2>Explanation</h2>

    <p>How does it work? It seems surprising, almost magic, that we can squeeze all these computations into three instructions. However, the considerations above give us most of the tools to understand it.</p>

    <p>Here&#39;s our constants in binary, with four relevant bit ranges indicated by letters:</p>

    <pre>   <span>A</span>                 <span>D</span>
f: <span>01</span>0000000000000000<span>10001111010111</span>
m: <span>11</span>0000000000000<span>11111</span>00000000<span>1111</span>
t: <span>00</span>0000000000000<span>11111</span>00000000<span>0000</span>
                  <span>B</span>            <span>C</span>
</pre>

    <p>Let&#39;s first consider for the product <i>p</i> := <i>y</i> ⋅ <i>f</i> what the masking with <i>m</i> and comparison with <i>t</i> does. In block <i>A</i>, the bits in <i>t</i> are 0, and therefore, the result is false as soon as any bit in <i>A</i> is set in <i>p</i>. Otherwise, block <i>B</i> becomes relevant. Here all bits in <i>t</i> are 1, so the result is true as soon as any bit in <i>B</i> is unset in <i>p</i>. Otherwise, for block <i>C</i> we require that all bits are unset in <i>p</i>. In this way, a bunch of comparisons of bit ranges are all united into a single <code>&lt;=</code>.</p>

    <p>Thus, we could rewrite <code>is_leap_year_fast</code> as follows:
    </p><pre><code>bool is_leap_year_fast2(uint32_t y) {
    uint32_t p = y * 1073750999u;
    const uint32_t A = 0b11000000000000000000000000000000;
    const uint32_t B = 0b00000000000000011111000000000000;
    const uint32_t C = 0b00000000000000000000000000001111;
    if ((p &amp; A) != 0) return false;
    if ((p &amp; B) != B) return true;
    if ((p &amp; C) == 0) return true;
    return false;
}</code></pre>

    <p>That looks suspiciously like <code>is_leap_year2</code>! And indeed, the three conditions have exactly the same purpose. We&#39;ll show
      </p><ol>
	<li> <code>(p &amp; A) != 0</code> triggers when <code>(y % 4) != 0</code>;</li>
	<li> <code>(p &amp; B) != B</code> triggers when <code>(y % 100) != 0</code>;</li>
	<li> <code>(p &amp; C) == 0</code> triggers when <code>(y % 16) == 0</code> (and therefore <code>(y % 400) == 0</code>, since we already know <i>y</i> is a multiple of 25).</li>
      </ol>

    <h3>Two easy cases: (1) and (3)</h3>
          
    <p>(1): The 1 bit in <i>A</i> in <i>f</i> reproduces the two low bits of <i>y</i> into <i>p</i> at <i>A</i>. This cannot be clobbered by the result of the multiplication with the bits in <i>D</i>: the maximum value we can get is 102499 ⋅ (f &amp; D) = 940428325, which has only 30 bits. Thus, checking that A is zero in p is equivalent to checking whether <i>y</i> is 0 modulo 4.</p>

    <p>(3): Checking that none of the lowest 4 bits is set in <i>p</i> is checking whether <i>p</i> is 0 modulo 16. However, we actually want to check <i>y</i>. This is no problem: It suffices to look only at the lowest 4 bits of <i>f</i>, and <i>f</i> is 1111<sub>2</sub> = 15 there. Multiplying with 15 = 3 ⋅ 5 introduces no additional factor of 2, so divisibility by 16 is unchanged.
    

    </p><h3>The interesting case: (2)</h3>

    <p>Next, let&#39;s try to find out for which numbers <i>p</i> &amp; <i>B</i> ≠ <i>B</i>. For this, the 1 bit in <i>f</i> &amp; <i>A</i> does not play a role, so consider the bits in <i>f</i> &amp; <i>D</i>. They are 10001111010111<sub>2</sub> = 9175. Let&#39;s see for which numbers the test hits.</p>

    <pre><code>&gt;&gt;&gt; B = 0b00000000000000011111000000000000
&gt;&gt;&gt; s = [y for y in range(5000) if ((y * 9175) &amp; B) == B]
&gt;&gt;&gt; for i in range(0, len(s), 16): print(*(f&#39;{n:4d}&#39; for n in s[i:i+16]))
  14   57   71  100  114  157  171  200  214  257  271  300  314  357  371  400
 414  457  471  500  514  557  571  600  614  657  671  700  714  757  771  800
 814  857  871  900  914  957  971 1000 1014 1057 1071 1100 1114 1157 1171 1200
1214 1257 1271 1300 1314 1357 1371 1400 1414 1457 1471 1500 1514 1557 1571 1600
1614 1657 1671 1700 1714 1757 1771 1800 1814 1857 1871 1900 1914 1957 1971 2000
2014 2057 2071 2100 2114 2157 2171 2200 2214 2257 2271 2300 2314 2357 2371 2400
2414 2457 2471 2500 2514 2557 2571 2600 2614 2657 2671 2700 2714 2757 2771 2800
2814 2857 2871 2900 2914 2957 2971 3000 3014 3057 3071 3100 3114 3157 3171 3200
3214 3257 3271 3300 3314 3357 3371 3400 3414 3457 3471 3500 3514 3557 3571 3600
3614 3657 3671 3700 3714 3757 3771 3800 3814 3857 3871 3900 3914 3957 3971 4000
4014 4057 4071 4100 4114 4157 4200 4214 4257 4300 4314 4357 4400 4414 4457 4500
4514 4557 4600 4614 4657 4700 4714 4757 4800 4814 4857 4900 4914 4957
</code></pre>

    <p>Multiples of 100 are here as desired, but also a bunch of other numbers. This is not a problem as long as none of them are a multiple of 4, since those were already filtered out in the previous step. Also, 0 is missing, but that&#39;s not a problem either, since 0 is also a multiple of 400.</p>

    <p>Let&#39;s try to understand the pattern. At first glance, it looks very simple: we have *14, *57, *71, and *00. However, from 4171 on, *71 drops out (did you notice?). We also have new patterns popping up later. Let&#39;s analyze this. The following Python program</p>
<pre><code>def test(y):
    B = 126976
    return ((y * 9175) &amp; B) == B

active = set()
for y in range(120000):
    r = y % 100
    if test(y):
        if r not in active:
            print(f&#39;{y:6}: started *{r:02}&#39;)
            active.add(r)
    else:
        if r in active:
            print(f&#39;{y:6}: stopped *{r:02}&#39;)
            active.remove(r)
</code></pre><p>
outputs
</p><pre><code>    14: started *14
    57: started *57
    71: started *71
   100: started *00
  4171: stopped *71
 32843: started *43
 36914: stopped *14
 65586: started *86
 69657: stopped *57
 98329: started *29
102500: stopped *00
</code></pre>

    <p>So, from 102500 on, we no longer catch multiples of 100, which explains why 102499 is the last number for which <code>is_leap_year_fast</code> returns the correct result. We also see that below that, no number is a multiple of 4 except for the multiples of 100 (conveniently, we can check that knowing only the last two decimal digits). This concludes the proof of condition (2), if we trust this brute-force enumeration; but let&#39;s continue and understand better why we get exactly these numbers.</p>

    <p>Let&#39;s look into why we&#39;re getting the multiples of 100 first. The factor 9175 is close to a multiple of 1/100 in 17-bit fixed point representation:</p>
    <p><span>2<sup>17</sup> ⋅ 7/100 = 9175.04 (exactly).</span>
    </p>

    <p>Multiplying a multiple of 100 by 9175.04 gives an integer (a multiple of 7) at bits 17 and above and 17 zero bits below that. E.g.</p>
    <p><span>9175.04 ⋅ 500 = 10001100000000000000000<sub>2</sub>, with 100011<sub>2</sub> = 35 = 5 ⋅ 7.</span>
    </p>

    <p>Multiplying a multiple of 100 by 9175 gives slightly less:</p>
    <p><span>9175 ⋅ 500 = 10001100000000000000000<sub>2</sub> − 500 ⋅ 0.04 = 10001011111111111101100<sub>2</sub>.</span>
    </p>

    <p>In general, subtracting a little bit from a number ending in a lot of zeroes creates a number that ends in a lot of ones, except at the very end. Here, we check the 5 bits in <i>B</i>. For <i>y</i> a multiple of 100, these are guaranteed be all 1 until the accumulated error reaches the lower end of <i>B</i>, which happens only after <i>y</i> = 2<sup>12</sup> / 0.04 = 102400, so this fits.</p>

    <p>Now where do the other numbers like 14, 57, and 71 come from? Let&#39;s look at it from a different angle. We have 9175 = 2<sup>17</sup> ⋅ 0.06999969482421875 (exactly) and <i>B</i> = 2<sup>17</sup> ⋅ 0.96875, so
    </p><p><span><i>p</i> &amp; <i>B</i> </span>             <span>= <i>B</i></span>
      <span>⇔ {<i>y</i> ⋅ 0.06999969482421875} </span>  <span>≥ 0.96875, where {<i>x</i>} is the fractional part of <i>x</i></span>
      <span>⇔ 6.999969482421875<i>y</i> mod 100 </span> <span>≥ 96.875</span>
    </p>

    <p>This is another way to see why multiples of 100 are accepted: For them, 7<i>y</i> mod 100 is 0, so 6.999969482421875<i>y</i> mod 100 comes out slightly below 100, and drops below 96.875 only after <i>y</i> = (100 − 96.875) / (7 − 6.999969482421875) = 102400.

    </p><p>To understand the other numbers showing up in our sequence, let&#39;s first consider what the solutions would be if we had a clean 7 in this inequality:</p>
    <p><span>7y mod 100 </span> <span>≥ 96.875</span>
      <span>⇔ 7y mod 100 </span> <span>∈ {97, 98, 99}.</span>
    </p>

    <p>To find the solutions to this, we first need the modular inverse of 7 modulo 100, that is, the number <i>x</i> such that 7<i>x</i> mod 100 = 1. We can calculate it by using the extended Euclidean algorithm, or just using <a href="https://www.wolframalpha.com/input?i=modular+inverse+of+7+modulo+100">some online calculator</a>, which tells us the result is 43. Then the solutions are 43 ⋅ 97 (mod 100), 43 ⋅ 98 (mod 100), and 43 ⋅ 99 (mod 100), which is 71, 14, and 57 (mod 100), respectively. This explains why we&#39;re initially seeing numbers of the form *14, *57, and *71. It also explains why we stop seeing e.g. *71 after 4071: While 7 ⋅ 4171 = 29197, we have 6.999969482421875 ⋅ 4171 = 29196.872711181640625, which (modulo 100) is less than 96.875. Similarly, 32843 pops up because the accumulated error (7 − 6.999969482421875) ⋅ 32843 = 1.002288818359375 exceeds one. With a bit more effort here, we could manually reproduce the output of the Python program above and check that none of these numbers is a multiple of 4.</p>

    <h2>Extension to other bitwidths</h2>

    <p>Now that we understand how the trick works, we can try to find parameters for other bitwidths. The variable parts are the location of block <i>B</i> and the fraction of 100 in <i>f</i> &amp; <i>D</i>.</p>

    <pre><code>uint64_t score(uint64_t f, uint64_t m, uint64_t t) {
      for (uint64_t y = 0; ; y++)
          if ((((y * f) &amp; m) &lt;= t) != is_leap_year(y))
              return y;
  }
  
  int main() {
      uint64_t best_score = 0;
      for (int k = 0; k &lt; BITS; k++) {
          for (int k2 = 0; k2 &lt; k; k2++) {
              uint64_t t = (1ULL &lt;&lt; k) - (1ULL &lt;&lt; k2);
              uint64_t m = (0b11ULL &lt;&lt; (BITS - 2)) | t | 0b1111;
              for (int n = 0; n &lt; 100; n++) {
                  uint64_t f = (0b01ULL &lt;&lt; (BITS - 2)) | (((1ULL &lt;&lt; k) * n) / 100);
                  uint64_t new_score = score(f, m, t);
                  if (new_score &gt; best_score) {
                      printf(&#34;%llu %llu %llu: %llu (%d %d %d)\n&#34;,
                             f, m, t, new_score, k, k - k2, n);
                      best_score = new_score;
                  }
              }
          }
      }
      return 0;
  }
  </code></pre>

    <p>For <code>BITS = 64</code>, in about 7 minutes we find <i>f</i> = 4611686019114582671, <i>m</i> = 13835058121854156815, <i>t</i> = 66571993088, which is correct up to <i>y</i> = 5965232499. This is nice because 5965232499 &gt; 2<sup>32</sup>, so any 32-bit year can be tested correctly with this variant.</p>

    <p>Is this the highest we can go with 64 bit? Perhaps there&#39;s some other constants that work even better? I couldn&#39;t immediately find a way to prove it, so I employed the tried-and-true method of getting someone else to do it for me by <a href="https://codegolf.stackexchange.com/q/275505/116815">posting it to the Code Golf StackExchange</a>. Indeed after only 1h user ovs posted a very good result, and two days later user Exalted Toast posted a <a href="https://codegolf.stackexchange.com/a/275541">proof</a> that 5965232499 is indeed the best possible range for 64 bits, also employing the z3 solver.</p>

    <h2>Benchmark</h2>

    <p>Getting meaningful benchmarks is tricky, since the function takes just such a tiny amount of time, and moreover for the branching versions execution time depends on the patterns of the input. Let&#39;s try two extreme cases: always the year 2025, and completely random years. These are the results of the <a href="https://hueffner.de/falk/blog/benchmark.cc">benchmark</a> on an i7-8700K (Coffee Lake, 4.7 GHz), compiled wirh <code>g++ -O3 -fno-tree-vectorize</code>:</p>

    <table>
      <thead>
          <tr>
              <th></th>
              <th>2025 (ns)</th>
              <th>random (ns)</th>
          </tr>
      </thead>
      <tbody>
            <tr>
              <td><code>is_leap_year</code></td>
              <td>0.65</td>
              <td>2.61</td>
            </tr>
            <tr>
              <td><code>is_leap_year2</code></td>
              <td>0.65</td>
              <td>2.75</td>
            </tr>
            <tr>
              <td><code>is_leap_year3</code></td>
              <td>0.67</td>
              <td>0.88</td>
            </tr>
            <tr>
              <td><code>is_leap_year_fast</code></td>
              <td>0.69</td>
              <td>0.69</td>
          </tr>
       </tbody>
    </table>

    <p>Some weird things stand out here:</p>
    <ul>
    <li><code>is_leap_year2</code> is actually marginally slower than <code>is_leap_year</code> in the random case. This is surprising because <code>y % 100</code> needs one instruction more than the trick in <code>is_leap_year2</code>.</li>
    <li><code>is_leap_year3</code> is a bit slower for random data than for the fixed value. This is surprising because it doesn&#39;t do any branching.</li>
    </ul>

    <p>I have no explanation for this other than benchmarking is hard.</p>

    <p>The new function <code>is_leap_year_fast</code> is 3.8 times faster than the standard implementation for random data, and about 6% slower for the perfectly predictable input. Overall, that seems pretty solid.</p>


    <h2>Conclusion</h2>

    <p>So, is this really worthwhile? Should we replace e.g. the <a href="https://github.com/python/cpython/blob/5cdd49b3f4cbdcf0472a65fd0c723912c3d48211/Modules/_datetimemodule.c#L416">CPython datetime implementation</a> with this trick? Well, it depends. Most years being queried in practice will be the current year, or at least fairly predictable, in which case we don&#39;t have a great advantage. To fully justify a change, ideally we would have a benchmark with realistic data that employs a leap year check as a subroutine, rather than just microbenchmarking. I would be happy to hear about any such results!</p>

    
    
  </div></div>
  </body>
</html>
