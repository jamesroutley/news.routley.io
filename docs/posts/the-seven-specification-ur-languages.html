<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/the-seven-specification-ur-languages/">Original</a>
    <h1>The seven specification ur-languages</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                
                    
                        <p>Last week Madhadron’s 2021 piece <a href="https://madhadron.com/programming/seven_ur_languages.html" target="_blank">The seven programming ur-languages</a> went viral. One I saw a lot was “where does TLA+ and Alloy fit into this?”</p>
<p>Hoo boy.</p>
<p>I’ve been <em>dreading</em> this one. You see, TLA+ and Alloy don’t fit into <em>any</em> of the programming ur-languages, because they aren’t programming languages. They are specification languages (SLs) and are designed for modeling systems, not implementing them. While there’s a lot of intermixing, SLs come from a different lineage than PLs and we need to treat them separately. </p>
<p>So, someone has to write “the seven specification ur-languages”, and I really don’t want to be that person for three reasons: </p>
<ol>
<li><em>Taxonomy is a fool’s errand.</em> All taxonomies are broken, full stop. Your categories are gonna be completely wrong and everybody’s going to argue over every single thing. <strong>There is no such thing as a fish.</strong><sup id="fnref:tree"><a href="#fn:tree">1</a></sup></li>
<li><em>I’m not remotely qualified to do this.</em> Sure I’ve toyed with a few different formal specification languages before, but I’ve only been <em>paid</em> to do two of them.<sup id="fnref:minizinc"><a href="#fn:minizinc">2</a></sup> Ideally I’d want to be competent in five or six and also consult several experts before trying to categorizing things. </li>
<li><em>Nothing is easy.</em> At least with programming languages you’ve got a bunch of online docs and “hello world”s for comparisons. Everything in the formal methods world is squirreled away in papers and 60 dollar books.</li>
</ol>
<p>OTOH, a first-draft taxonomy is better than no taxonomy, it’s a topic I’m interested in, and I’ve rabbit-holed much dumber things before. Some caveats before we start:</p>
<ul>
<li>The title just mimics madhadron’s piece. It’s more accurate to call it the seven <em>ur-formalisms</em>, as we’re talking about the mathematical concepts people used to model systems. Most end-state specification languages use several of these ideas in combination. Also it’s not so much “ur-” as “archetype”.</li>
<li>This is just about <em>specification languages</em>, not <em>formal verification</em>. So no Agda, Idris, Lean, or SPARK. That roundup can come some other time.</li>
<li>I spent a day on research and writeup. That really isn’t enough time to either research or explain things well, but I have a lot of other stuff I need to do this week.</li>
<li>I have no idea how this ended up longer than the original piece.</li>
</ul>
<p><img alt="Some of my reference material" src="https://buttondown.imgix.net/images/3bdc5171-8ffe-4623-8f9f-76eefa7cf232.png?w=960&amp;fit=max"/> </p>
<h2>The Seven Specification Ur-Languages</h2>
<h3>1. Guarded Command Language</h3>
<p><a href="https://www.cs.utexas.edu/users/EWD/ewd04xx/EWD472.PDF" target="_blank">Invented by Edsger Dijkstra</a> in 1975, this is basically a way of adding nondeterminism to pseudocode. </p>
<div><pre><span></span><code>if
  :: x &lt; y -&gt; x := y
  :: y &lt; z -&gt; y := z
fi
</code></pre></div>

<p>If only one of the guard clauses is true, then it’s a standard <code>if</code> statement. If more than one is true, one command is selected nondeterministically. Either <code>x := y</code> or <code>y := z</code> will happen, but not both. Multiple commands can have the same guard, which would lead to a random selection.</p>
<p>Dijkstra used this to abstract implementation details from algorithms. Here’s how he defines “Euclid’s Algorithm”, which finds the greatest common denominator of X and Y:</p>
<div><pre><span></span><code>// Euclid&#39;s algorithm
x := X, y := Y
do 
 :: x &gt; y -&gt; x := x - y
 :: y &gt; x -&gt; y := y - x
od
</code></pre></div>

<p>He then showed that how this could refine to multiple different versions of the code.</p>
<p>I don’t think GCL is used by itself much because the most common goal of specification is modeling a concurrent system, and while you can do that with purely nondeterminism primitives, you also want to some concurrency primitives too. But SLs still use GCL as part of their semantics, the most popular of which is <a href="https://spinroot.com/spin/whatispin.html" target="_blank">Promela/SPIN</a>.<sup id="fnref:spin"><a href="#fn:spin">3</a></sup> <a href="https://www.prismmodelchecker.org/" target="_blank">PRISM</a> also uses GCL for probabilistic modeling: each guard is associated with a set of weighted commands, letting you compute the likelihood of reaching any given state.</p>
<h3>2. Relational Algebra</h3>
<p>In math the basic collection type is the set, collections of unordered unique elements. From sets, we build “functions”, a mapping between two sets where each input maps to exactly one output. If we generalize functions, we get <strong>relations</strong>, which map each input to any number of outputs.<sup id="fnref:heterogeneous"><a href="#fn:heterogeneous">4</a></sup> A relational algebra, then, is a collection of rules and operations for manipulating relations, like “lookup”.</p>
<p>The most famous relational algebra by <em>far</em> is Codd’s relational model of databases. But it’s also really prevalent in formal specification because it allows very nicely for manipulations with constraints. For example, take the structure:</p>
<blockquote>
<ul>
<li>Each theatre seat may be sold to at most one customer</li>
<li>Friends are customers</li>
<li>If the show is a premier, all sold seats must be friends of the theatre</li>
</ul>
</blockquote>
<p>Here’s how we can represent that all relationally:</p>
<div><pre><span></span><code>schema BoxOffice {
  types {Status, Customer, Seat}
  vals {
    status: Status
    friends: set of Customer
    seating: Seat -&gt; Maybe Customer
  }
  properties {
    status = &#34;premier&#34; =&gt; range(Seat) subset friends
  }
}
</code></pre></div>

<p>The approach represents statics elegantly but struggles a little with modeling change. We have to do something tricky: first recognize that BoxOffice <em>itself</em> is a type with its own relations, and then define a “change” as a relationship between two BoxOffices.</p>
<div><pre><span></span><code>schema System {
  states: set of BoxOffice
  init: BoxOffice
  purchase: BoxOffice -&gt; BoxOffice
}
properties {
  forall b -&gt; b&#39;: purchase {
    some seat: Seating, c: Customer {
      no b.seating.seat
      b&#39;.seating = b.seating ++ (seat -&gt; c)

      // don&#39;t change anything else
      b&#39;.status = b.status // etc etc etc
    }
  }
}
</code></pre></div>

<p>This example was adapted from <a href="http://www.usingz.com/" target="_blank">Using Z</a> (pg. 179). Z (pronounced Zed) was the first relational specification language, and arguably the first SL to see “significant” use by other people. Nobody uses Z anymore for much the same reasons we don’t use COBOL and ALGOL: we learned lessons and made better languages. </p>
<p>The relational model is good for structure but really benefits from some extra change semantics. One descendant, B (not pronounced Bed but <em>should be</em>), adds state machine semantics. This is later refined with Event-B, which we’ll talk about later. Another descendant, Alloy, used to hew closer to the pure relational model but recently added temporal logic. There was much rejoicing.</p>
<p>Speaking of temporal logic:</p>
<h3>3. Temporal Logic</h3>
<p>You know the usual example of a deductive proof?</p>
<blockquote>
<ul>
<li>All men are mortal</li>
<li>Socrates is a man</li>
<li>Therefore, Socrates is mortal.</li>
</ul>
</blockquote>
<p>This only lets us work with certainties. Philosophers also like to manipulate uncertainties:</p>
<blockquote>
<ul>
<li>AS FAR AS WE KNOW, all men are mortal</li>
<li>WE ARE SURE Socrates is a man</li>
<li>Therefore, Socrates is— AS FAR AS WE KNOW— mortal.</li>
</ul>
</blockquote>
<p>That gives us modal logic, regular logic augmented with “definitely” (□) and “possibly” (◇). There are different interpretations of what “definitely” and “possibly” are actually about, leading to different modal logics. One of these interpretations is that “definitely” means “all the time” and “possibly” means “some of the time”. This gives us some flavor of <strong>temporal logic.</strong></p>
<p>In 1977, <a href="https://en.wikipedia.org/wiki/Amir_Pnueli" target="_blank">Amir Pneuli</a> invented <strong>linear temporal logic</strong> (LTL) and applied it to formal specification. Temporal logics quickly get popular because they are <em>very</em> good at specifying system properties. Here’s how to say “all seats are eventually sold:</p>
<div><pre><span></span><code>sold(seat) = some c: Customer:
  (seat -&gt; c) in seating

property { all s: Seat | ◇sold(s) }
</code></pre></div>

<p>And here’s how to say 1) “eventually we’re sold out” and 2) “all seats are eventually sold <em>and stay sold</em>”:</p>
<div><pre><span></span><code>property { ◇(all s: Seat | sold(s)) }
property {  all s: Seat | ◇□sold(s) }
</code></pre></div>

<p>Because of this flexibility, you often see SLs use one notation for their system modeling language and then use some kind of temporal logic for expressing the properties of the system. SPIN and PRISM both do this: they use GCL for expressing the system and then LTL for expressing the properties of the system.</p>
<p>Other SLs use temporal logic for both modeling and properties. TLA+ is the most famous instance here. But people also write entire systems in LTL (or a sister temporal logic, like <strong>Computation Tree Logic</strong>).</p>
<h3>4. Process Calculi</h3>
<p>(Everything past this point is much shakier ground and why this is a newsletter and not a blog post, despite being 2500+ words.) </p>
<p><strong>Process calculi</strong> are a family of approaches to modeling concurrency as a collection of independent, interacting “processes”. Process here doesn’t mean an OS process, but any kind of computational entity with local state. The goal of the calculus is to come up with rules for how the processes share information, so that we can infer properties about the global system, such as if it can deadlock or not.</p>
<div><pre><span></span><code>mtype = {ok, already_sold, err};

chan buy = [1] of {Seat};
chan resp = [1] of {mtype};

active proctype Customer()
{
  start:
    Seat choice; // arbitrary seat
    buy!choice; // write `choice` to `buy` channel

    do
      :: resp?ok -&gt; break; // read ok from `resp` channel
      :: resp?already_sold -&gt; goto start;  // etc etc
      :: resp?error -&gt; break;
    od
}
</code></pre></div>

<p>(Notice that we don’t need to define the server in the same place, as long as we can define the channels that it uses. This arguably makes processes more composable than raw temporal logic or relational models.)</p>
<p>Process calculi are especially interesting because, unlike prior discussed methods, they’re also used by programming languages! Most famously Tony Hoare’s <a href="http://www.usingcsp.com/cspbook.pdf" target="_blank">Communicating Sequential Processes</a> (CSP) inspired Go channels, while the Actor Model is used in Erlang and <a href="https://www.ponylang.io/" target="_blank">Pony</a>. Even if you aren’t using something with native processes you can often find a framework like <a href="https://akka.io/" target="_blank">Akka</a> which implements a calculus at the library-level.</p>
<p>There’s also a long history of using process calculi for abstract modeling. <a href="https://cocotec.io/fdr/" target="_blank">FDR4</a> directly checks CSP specifications and <a href="https://p-org.github.io/P/" target="_blank">P</a> is based on the actor model. SPIN and <a href="https://www.mcrl2.org/web/user_manual/index.html" target="_blank">mCRL2</a> have their own homegrown calculi.<sup id="fnref:pc"><a href="#fn:pc">5</a></sup> </p>
<h3>5. State machines</h3>
<p>A state machine is a peculiar type of system. System changes are organized into “transitions” between states, which have conditions and effects. If multiple transitions are available, the system can choose which one to take.</p>
<div><pre><span></span><code>state Online {
  on Powerbutton(soft?) {
    if soft? {
      save_everything();
    }
    goto Offline;
  }
}

State Offline {
  on Powerbutton(_) {
    goto Online;
  }
}
</code></pre></div>

<p>Now this looks a whole lot like guarded command language, and you can implement a state machine purely with GCL. The difference is more about the role in modeling. In languages with GCLs, the guarded commands define local nondeterministic procedures, like “add one or decrement one.” In languages with state machines, the state machine decides the <em>overall structure of the system</em>. </p>
<p>State machines are the closest thing FM’s got to a paradigm, and it’s arguably <em>the</em> paradigm. There’s a joke in formal methods that no matter what language you start with, you’re going to end up with a state machine. They just work <em>so well</em> for modeling complex systems, and they implement well, too.</p>
<p>Languages with native state machine syntax include <a href="https://wiki.event-b.org/images/SM%26D-KAR.pdf" target="_blank">Event-B</a> (pg 12), <a href="https://nusmv.fbk.eu/" target="_blank">NuSMV</a>, and <a href="https://p-org.github.io/P/" target="_blank">P</a>. Other SLs might not have syntax but you’ll handroll state machines anyway. There are also formalized extensions of state machines, like <a href="https://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf" target="_blank">Harel statecharts</a> and <a href="https://www.mcrl2.org/web/user_manual/articles/lts.html" target="_blank">Labeled Transition Systems</a>, that add additional features. Statecharts are cool, check em out.</p>
<h3>6. Petri nets</h3>
<p>This is arguably just another extension of state machines, but it evolved separately and is used separately and is worth discussing separately.</p>
<p><a href="http://jklp.org/profession/books/pn/3.html#chapter3" target="_blank"><img alt="An example of a Petri net" src="https://buttondown.imgix.net/images/b8bf86f3-5fd5-403b-ad49-cef7fda52f67.png?w=960&amp;fit=max"/></a></p>
<p>The circles are “places” and the bars are “transitions”. A transition is “live” if every <em>inbound</em> circle has a dot in it. When a live transition “fires”, remove a token from every inbound circle and place a token in every outbound circle. If multiple transitions are live, any of them can fire. It’s a little more complex than that but not <em>much</em> more complex. To my understanding people in process and chemical engineering used Petri nets before they migrated over to CS.</p>
<p>Petri nets can’t model very much. You can add two numbers or compute their minimum but not multiply two numbers or compute their maximum. In other words, they’re not Turing complete. This means that certain properties are decidable! You can algorithmically determine if a net has a <a href="http://jklp.org/profession/books/pn/4.html#4.2.1" target="_blank">token bound</a> or not and <em>in theory</em> even determine if a specific configuration is reachable.<sup id="fnref:reachability"><a href="#fn:reachability">6</a></sup></p>
<p>The problem is that modeling anything with nets is a huge chore, and any addition that makes it less of a chore is <a href="http://jklp.org/profession/books/pn/7.html#7.2" target="_blank">exceedingly likely to make it Turing complete</a>. Nonetheless, there are some popular extensions, the most notable of which are “colored petri nets” where places can hold values besides “number of tokens”. The main tool for that <a href="https://cpntools.org/" target="_blank">CPN Tools</a>. I believe <a href="https://statebox.org/" target="_blank">Statebox</a> is also trying to use Petri nets as a formal modeling tool.</p>
<p>I really like Petri nets. They aren’t very useful for modeling, but they’re a fun puzzle. How do you model <code>$BASIC_SYSTEM</code> with just petri nets? How do you make the graph look nice? I like <a href="http://jklp.org/profession/books/pn/" target="_blank">this book</a> on them.</p>
<h3>7. Diagram-first</h3>
<p>Everything discussed so far was based on mathematical constructs turned into modeling notations. The majority of specification languages were invented elsewhere and used as thinking and communication aides. Almost universally these are diagrammatic notations, and any formal semantics comes later. The <a href="https://www.ias.edu/sites/default/files/library/pdfs/ecp/planningcodingof0103inst.pdf" target="_blank">first flow chart</a> shares very little in common with the notations people converged on <a href="https://web.archive.org/web/20120402204237/http://www.fh-jena.de/~kleine/history/software/IBM-FlowchartingTechniques-GC20-8152-1.pdf" target="_blank">20 years later</a>.</p>
<p>Which brings us to the most popular formal specification language: UML. More people have drawn sequence diagrams than have used all of the other methods, combined. UML wasn’t so much its own language as a compromise between <a href="https://buttondown.email/hillelwayne/archive/why-uml-really-died/" target="_blank">three different diagram notations</a> that tried to guarantee backwards compatibility with all of them. That ones one of the things that ultimately hindered its adoption. <a href="https://sysml.org/" target="_blank">SysML</a> is a project to make something similar to UML that’s grounded in formal semantics.</p>
<p>Similarly, the <a href="https://c4model.com/" target="_blank">C4 architecture model</a> is intended as a means of communicating and documented large scale architecture. Nobody’s trying to formally verify them <em>yet</em> but if it sticks around long enough, that very well may happen.</p>
<h3>Miscellaneous</h3>
<p>Things I left out:</p>
<ul>
<li>Dynamic logic, which is a modal logic that’s not exactly a temporal logic. The only dynamic logic SL I know off the top of my head is <a href="https://keymaerax.org/Xtutorial.html" target="_blank">KeyMaeraX</a>.</li>
<li>SLs that are embedded in a programming language and specifically designed to model systems that will eventually use that language. Examples: <a href="https://github.com/stateright/stateright" target="_blank">Stateright</a> and <a href="https://github.com/awakesecurity/spectacle" target="_blank">Spectacle</a>.</li>
<li><a href="https://github.com/Fault-lang/Fault" target="_blank">Fault</a>, BPMN, VDM, CADP, LOTOS…</li>
<li>How people in hardware do formal methods</li>
<li>Whatever they’re doing in the blockchain space, I know nothing about the blockchain space</li>
</ul>
<h2>What to do with this</h2>
<p>Like with programming, learning SLs that use different mixes of formalisms is a mind-opening experience that will make you better at specification. Unlike with programming, being better at specification <em>isn’t that important</em>. Nobody’s going around telling people that state machines are a dead-end and process calculi are the future. It’s all this mishmash of different ideas slammed together to make something good for modeling real systems. Learn whichever specification language your friends and coworkers already know, and if you’re the first, learn whichever looks the coolest to you. </p>
<p><em>My</em> main takeaway is that I should get around to learning SPIN. </p>
<hr/>
<h3>TLA+ Workshop</h3>
<p><a href="https://www.eventbrite.com/e/software-modeling-with-tla-workshop-tickets-520033412937" target="_blank">This upcoming Monday</a>! Use the code <code>C0MPUT3RTHINGS</code> for 15% off. </p>
<p>(After this week I have one more workshop in June and then I can finally stop pitching this in newsletters. I’m excited to be done. I do not enjoy putting these adverts in my newsletter.)</p>
<hr/>
<h3>Update for the Internets</h3>
<p>This was sent as part of an email newsletter; you can subscribe <a href="https://buttondown.email/hillelwayne/" target="_blank">here</a>.</p>

                    
                

                
            </div></div>
  </body>
</html>
