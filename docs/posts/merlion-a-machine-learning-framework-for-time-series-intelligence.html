<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/salesforce/Merlion">Original</a>
    <h1>Merlion: A Machine Learning Framework for Time Series Intelligence</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/salesforce/Merlion/raw/main/merlion_logo.svg"><img alt="Logo" src="https://github.com/salesforce/Merlion/raw/main/merlion_logo.svg" width="80%"/></a>
</p>
<p><a href="https://github.com/salesforce/Merlion/actions">
  <img alt="Tests" src="https://github.com/salesforce/Merlion/actions/workflows/tests.yml/badge.svg?branch=main"/>
  </a>
  <a href="https://github.com/salesforce/Merlion/actions">
  <img alt="Coverage" src="https://github.com/salesforce/Merlion/raw/badges/coverage.svg"/>
  </a>
  <a href="https://pypi.python.org/pypi/salesforce-merlion" rel="nofollow">
  <img alt="PyPI Version" src="https://camo.githubusercontent.com/7f52dec59ec367ab3a6d475535e677f1ed07be91dd6e3ec13e2af7947119312d/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f73616c6573666f7263652d6d65726c696f6e2e737667" data-canonical-src="https://img.shields.io/pypi/v/salesforce-merlion.svg"/>
  </a>
  <a href="https://opensource.salesforce.com/Merlion/index.html" rel="nofollow">
  <img alt="docs" src="https://github.com/salesforce/Merlion/actions/workflows/docs.yml/badge.svg"/>
  </a>
</p>


<ol dir="auto">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#comparison-with-related-libraries">Comparison with Related Libraries</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#getting-started">Getting Started</a>
<ol dir="auto">
<li><a href="#anomaly-detection">Anomaly Detection</a></li>
<li><a href="#forecasting">Forecasting</a></li>
</ol>
</li>
<li><a href="#evaluation-and-benchmarking">Evaluation and Benchmarking</a></li>
<li><a href="#technical-report-and-citing-merlion">Technical Report and Citing Merlion</a></li>
</ol>

<p dir="auto">Merlion is a Python library for time series intelligence. It provides an end-to-end machine learning framework that
includes loading and transforming data, building and training models, post-processing model outputs, and evaluating
model performance. It supports various time series learning tasks, including forecasting, anomaly detection,
and change point detection for both univariate and multivariate time series. This library aims to provide engineers and
researchers a one-stop solution to rapidly develop models for their specific time series needs, and benchmark them
across multiple time series datasets.</p>
<p dir="auto">Merlion&#39;s key features are</p>
<ul dir="auto">
<li>Standardized and easily extensible data loading &amp; benchmarking for a wide range of forecasting and anomaly
detection datasets. This includes transparent support for custom datasets.</li>
<li>A library of diverse models for anomaly detection, forecasting, and change point detection, all
unified under a shared interface. Models include classic statistical methods, tree ensembles, and deep
learning approaches. Advanced users may fully configure each model as desired.</li>
<li>Abstract <code>DefaultDetector</code> and <code>DefaultForecaster</code> models that are efficient, robustly achieve good performance,
and provide a starting point for new users.</li>
<li>AutoML for automated hyperaparameter tuning and model selection.</li>
<li>Unified API for using a wide range of models to forecast with
<a href="https://opensource.salesforce.com/Merlion/tutorials/forecast/3_ForecastExogenous.html" rel="nofollow">exogenous regressors</a>.</li>
<li>Practical, industry-inspired post-processing rules for anomaly detectors that make anomaly scores more interpretable,
while also reducing the number of false positives.</li>
<li>Easy-to-use ensembles that combine the outputs of multiple models to achieve more robust performance.</li>
<li>Flexible evaluation pipelines that simulate the live deployment &amp; re-training of a model in production,
and evaluate performance on both forecasting and anomaly detection.</li>
<li>Native support for visualizing model predictions, including with a clickable visual UI.</li>
<li>Distributed computation <a href="https://opensource.salesforce.com/Merlion/merlion.spark.html" rel="nofollow">backend</a> using PySpark,
which can be used to serve time series applications at industrial scale.</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Comparison with Related Libraries</h2><a id="user-content-comparison-with-related-libraries" aria-label="Permalink: Comparison with Related Libraries" href="#comparison-with-related-libraries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The table below provides a visual overview of how Merlion&#39;s key features compare to other libraries for time series
anomaly detection and/or forecasting.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th></th>
<th>Merlion</th>
<th>Prophet</th>
<th>Alibi Detect</th>
<th>Kats</th>
<th>darts</th>
<th>statsmodels</th>
<th>nixtla</th>
<th>GluonTS</th>
<th>RRCF</th>
<th>STUMPY</th>
<th>Greykite</th>
<th>pmdarima</th>
</tr>
</thead>
<tbody>
<tr>
<td>Univariate Forecasting</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Multivariate Forecasting</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Univariate Anomaly Detection</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Multivariate Anomaly Detection</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pre Processing</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Post Processing</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>AutoML</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>Ensembles</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Benchmarking</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>Visualization</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">The following features are new in Merlion 2.0:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th></th>
<th>Merlion</th>
<th>Prophet</th>
<th>Alibi Detect</th>
<th>Kats</th>
<th>darts</th>
<th>statsmodels</th>
<th>nixtla</th>
<th>GluonTS</th>
<th>RRCF</th>
<th>STUMPY</th>
<th>Greykite</th>
<th>pmdarima</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exogenous Regressors</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Change Point Detection</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>Clickable Visual UI</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Distributed Backend</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">Merlion consists of two sub-repos: <code>merlion</code> implements the library&#39;s core time series intelligence features,
and <code>ts_datasets</code> provides standardized data loaders for multiple time series datasets. These loaders load
time series as <code>pandas.DataFrame</code> s with accompanying metadata.</p>
<p dir="auto">You can install <code>merlion</code> from PyPI by calling <code>pip install salesforce-merlion</code>. You may install from source by
cloning this repoand calling <code>pip install Merlion/</code>, or <code>pip install -e Merlion/</code> to install in editable mode.
You may install additional dependencies via <code>pip install salesforce-merlion[all]</code>,  or by calling
<code>pip install &#34;Merlion/[all]&#34;</code> if installing from source.
Individually, the optional dependencies include <code>dashboard</code> for a GUI dashboard,
<code>spark</code> for a distributed computation backend with PySpark, and <code>deep-learning</code> for all deep learning models.</p>
<p dir="auto">To install the data loading package <code>ts_datasets</code>, clone this repo and call <code>pip install -e Merlion/ts_datasets/</code>.
This package must be installed in editable mode (i.e. with the <code>-e</code> flag) if you don&#39;t want to manually specify the
root directory of every dataset when initializing its data loader.</p>
<p dir="auto">Note the following external dependencies:</p>
<ol dir="auto">
<li>
<p dir="auto">Some of our forecasting models depend on OpenMP. If using <code>conda</code>, please <code>conda install -c conda-forge lightgbm</code>
before installing our package. This will ensure that OpenMP is configured to work with the <code>lightgbm</code> package
(one of our dependencies) in your <code>conda</code> environment. If using Mac, please install <a href="https://brew.sh/" rel="nofollow">Homebrew</a>
and call <code>brew install libomp</code> so that the OpenMP libary is available for the model.</p>
</li>
<li>
<p dir="auto">Some of our anomaly detection models depend on the Java Development Kit (JDK). For Ubuntu, call
<code>sudo apt-get install openjdk-11-jdk</code>. For Mac OS, install <a href="https://brew.sh/" rel="nofollow">Homebrew</a> and call
<code>brew tap adoptopenjdk/openjdk &amp;&amp; brew install --cask adoptopenjdk11</code>. Also ensure that <code>java</code> can be found
on your <code>PATH</code>, and that the <code>JAVA_HOME</code> environment variable is set.</p>
</li>
</ol>

<p dir="auto">For example code and an introduction to Merlion, see the Jupyter notebooks in
<a href="https://github.com/salesforce/Merlion/tree/main/examples"><code>examples</code></a>, and the guided walkthrough
<a href="https://opensource.salesforce.com/Merlion/tutorials.html" rel="nofollow">here</a>. You may find detailed API documentation (including the
example code) <a href="https://opensource.salesforce.com/Merlion/index.html" rel="nofollow">here</a>. The
<a href="https://arxiv.org/abs/2109.09265" rel="nofollow">technical report</a> outlines Merlion&#39;s overall architecture
and presents experimental results on time series anomaly detection &amp; forecasting for both univariate and multivariate
time series.</p>

<p dir="auto">The easiest way to get started is to use the GUI web-based
<a href="https://opensource.salesforce.com/Merlion/merlion.dashboard.html" rel="nofollow">dashboard</a>.
This dashboard provides a great way to quickly experiment with many models on your own custom datasets.
To use it, install Merlion with the optional <code>dashboard</code> dependency (i.e.
<code>pip install salesforce-merlion[dashboard]</code>), and call <code>python -m merlion.dashboard</code> from the command line.
You can view the dashboard at <a href="http://localhost:8050" rel="nofollow">http://localhost:8050</a>.
Below, we show some screenshots of the dashboard for both anomaly detection and forecasting.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/salesforce/Merlion/raw/main/figures/dashboard_anomaly.png"><img src="https://github.com/salesforce/Merlion/raw/main/figures/dashboard_anomaly.png" alt="anomaly dashboard"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/salesforce/Merlion/raw/main/figures/dashboard_forecast.png"><img src="https://github.com/salesforce/Merlion/raw/main/figures/dashboard_forecast.png" alt="forecast dashboard"/></a></p>
<p dir="auto">To help you get started with using Merlion in your own code, we provide below some minimal examples using Merlion
default models for both anomaly detection and forecasting.</p>

<p dir="auto">Here, we show the code to replicate the results from the anomaly detection dashboard above.
We begin by importing Merlion’s <code>TimeSeries</code> class and the data loader for the Numenta Anomaly Benchmark <code>NAB</code>.
We can then divide a specific time series from this dataset into training and testing splits.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from merlion.utils import TimeSeries
from ts_datasets.anomaly import NAB

# Data loader returns pandas DataFrames, which we convert to Merlion TimeSeries
time_series, metadata = NAB(subset=&#34;realKnownCause&#34;)[3]
train_data = TimeSeries.from_pd(time_series[metadata.trainval])
test_data = TimeSeries.from_pd(time_series[~metadata.trainval])
test_labels = TimeSeries.from_pd(metadata.anomaly[~metadata.trainval])"><pre><span>from</span> <span>merlion</span>.<span>utils</span> <span>import</span> <span>TimeSeries</span>
<span>from</span> <span>ts_datasets</span>.<span>anomaly</span> <span>import</span> <span>NAB</span>

<span># Data loader returns pandas DataFrames, which we convert to Merlion TimeSeries</span>
<span>time_series</span>, <span>metadata</span> <span>=</span> <span>NAB</span>(<span>subset</span><span>=</span><span>&#34;realKnownCause&#34;</span>)[<span>3</span>]
<span>train_data</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>time_series</span>[<span>metadata</span>.<span>trainval</span>])
<span>test_data</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>time_series</span>[<span>~</span><span>metadata</span>.<span>trainval</span>])
<span>test_labels</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>metadata</span>.<span>anomaly</span>[<span>~</span><span>metadata</span>.<span>trainval</span>])</pre></div>
<p dir="auto">We can then initialize and train Merlion’s <code>DefaultDetector</code>, which is an anomaly detection model that
balances performance with efficiency. We also obtain its predictions on the test split.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from merlion.models.defaults import DefaultDetectorConfig, DefaultDetector
model = DefaultDetector(DefaultDetectorConfig())
model.train(train_data=train_data)
test_pred = model.get_anomaly_label(time_series=test_data)"><pre><span>from</span> <span>merlion</span>.<span>models</span>.<span>defaults</span> <span>import</span> <span>DefaultDetectorConfig</span>, <span>DefaultDetector</span>
<span>model</span> <span>=</span> <span>DefaultDetector</span>(<span>DefaultDetectorConfig</span>())
<span>model</span>.<span>train</span>(<span>train_data</span><span>=</span><span>train_data</span>)
<span>test_pred</span> <span>=</span> <span>model</span>.<span>get_anomaly_label</span>(<span>time_series</span><span>=</span><span>test_data</span>)</pre></div>
<p dir="auto">Next, we visualize the model&#39;s predictions.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from merlion.plot import plot_anoms
import matplotlib.pyplot as plt
fig, ax = model.plot_anomaly(time_series=test_data)
plot_anoms(ax=ax, anomaly_labels=test_labels)
plt.show()"><pre><span>from</span> <span>merlion</span>.<span>plot</span> <span>import</span> <span>plot_anoms</span>
<span>import</span> <span>matplotlib</span>.<span>pyplot</span> <span>as</span> <span>plt</span>
<span>fig</span>, <span>ax</span> <span>=</span> <span>model</span>.<span>plot_anomaly</span>(<span>time_series</span><span>=</span><span>test_data</span>)
<span>plot_anoms</span>(<span>ax</span><span>=</span><span>ax</span>, <span>anomaly_labels</span><span>=</span><span>test_labels</span>)
<span>plt</span>.<span>show</span>()</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/salesforce/Merlion/raw/main/figures/anom_example.png"><img src="https://github.com/salesforce/Merlion/raw/main/figures/anom_example.png" alt="anomaly figure"/></a></p>
<p dir="auto">Finally, we can quantitatively evaluate the model. The precision and recall come from the fact that the model
fired 3 alarms, with 2 true positives, 1 false negative, and 1 false positive. We also evaluate the mean time
the model took to detect each anomaly that it correctly detected.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from merlion.evaluate.anomaly import TSADMetric
p = TSADMetric.Precision.value(ground_truth=test_labels, predict=test_pred)
r = TSADMetric.Recall.value(ground_truth=test_labels, predict=test_pred)
f1 = TSADMetric.F1.value(ground_truth=test_labels, predict=test_pred)
mttd = TSADMetric.MeanTimeToDetect.value(ground_truth=test_labels, predict=test_pred)
print(f&#34;Precision: {p:.4f}, Recall: {r:.4f}, F1: {f1:.4f}\n&#34;
      f&#34;Mean Time To Detect: {mttd}&#34;)"><pre><span>from</span> <span>merlion</span>.<span>evaluate</span>.<span>anomaly</span> <span>import</span> <span>TSADMetric</span>
<span>p</span> <span>=</span> <span>TSADMetric</span>.<span>Precision</span>.<span>value</span>(<span>ground_truth</span><span>=</span><span>test_labels</span>, <span>predict</span><span>=</span><span>test_pred</span>)
<span>r</span> <span>=</span> <span>TSADMetric</span>.<span>Recall</span>.<span>value</span>(<span>ground_truth</span><span>=</span><span>test_labels</span>, <span>predict</span><span>=</span><span>test_pred</span>)
<span>f1</span> <span>=</span> <span>TSADMetric</span>.<span>F1</span>.<span>value</span>(<span>ground_truth</span><span>=</span><span>test_labels</span>, <span>predict</span><span>=</span><span>test_pred</span>)
<span>mttd</span> <span>=</span> <span>TSADMetric</span>.<span>MeanTimeToDetect</span>.<span>value</span>(<span>ground_truth</span><span>=</span><span>test_labels</span>, <span>predict</span><span>=</span><span>test_pred</span>)
<span>print</span>(<span>f&#34;Precision: <span><span>{</span><span>p</span>:.4f<span>}</span></span>, Recall: <span><span>{</span><span>r</span>:.4f<span>}</span></span>, F1: <span><span>{</span><span>f1</span>:.4f<span>}</span></span><span>\n</span>&#34;</span>
      <span>f&#34;Mean Time To Detect: <span><span>{</span><span>mttd</span><span>}</span></span>&#34;</span>)</pre></div>
<div data-snippet-clipboard-copy-content="Precision: 0.6667, Recall: 0.6667, F1: 0.6667
Mean Time To Detect: 1 days 10:22:30"><pre><code>Precision: 0.6667, Recall: 0.6667, F1: 0.6667
Mean Time To Detect: 1 days 10:22:30
</code></pre></div>

<p dir="auto">Here, we show the code to replicate the results from the forecasting dashboard above.
We begin by importing Merlion’s <code>TimeSeries</code> class and the data loader for the <code>M4</code> dataset. We can then divide a
specific time series from this dataset into training and testing splits.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from merlion.utils import TimeSeries
from ts_datasets.forecast import M4

# Data loader returns pandas DataFrames, which we convert to Merlion TimeSeries
time_series, metadata = M4(subset=&#34;Hourly&#34;)[0]
train_data = TimeSeries.from_pd(time_series[metadata.trainval])
test_data = TimeSeries.from_pd(time_series[~metadata.trainval])"><pre><span>from</span> <span>merlion</span>.<span>utils</span> <span>import</span> <span>TimeSeries</span>
<span>from</span> <span>ts_datasets</span>.<span>forecast</span> <span>import</span> <span>M4</span>

<span># Data loader returns pandas DataFrames, which we convert to Merlion TimeSeries</span>
<span>time_series</span>, <span>metadata</span> <span>=</span> <span>M4</span>(<span>subset</span><span>=</span><span>&#34;Hourly&#34;</span>)[<span>0</span>]
<span>train_data</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>time_series</span>[<span>metadata</span>.<span>trainval</span>])
<span>test_data</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>time_series</span>[<span>~</span><span>metadata</span>.<span>trainval</span>])</pre></div>
<p dir="auto">We can then initialize and train Merlion’s <code>DefaultForecaster</code>, which is an forecasting model that balances
performance with efficiency. We also obtain its predictions on the test split.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from merlion.models.defaults import DefaultForecasterConfig, DefaultForecaster
model = DefaultForecaster(DefaultForecasterConfig())
model.train(train_data=train_data)
test_pred, test_err = model.forecast(time_stamps=test_data.time_stamps)"><pre><span>from</span> <span>merlion</span>.<span>models</span>.<span>defaults</span> <span>import</span> <span>DefaultForecasterConfig</span>, <span>DefaultForecaster</span>
<span>model</span> <span>=</span> <span>DefaultForecaster</span>(<span>DefaultForecasterConfig</span>())
<span>model</span>.<span>train</span>(<span>train_data</span><span>=</span><span>train_data</span>)
<span>test_pred</span>, <span>test_err</span> <span>=</span> <span>model</span>.<span>forecast</span>(<span>time_stamps</span><span>=</span><span>test_data</span>.<span>time_stamps</span>)</pre></div>
<p dir="auto">Next, we visualize the model’s predictions.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import matplotlib.pyplot as plt
fig, ax = model.plot_forecast(time_series=test_data, plot_forecast_uncertainty=True)
plt.show()"><pre><span>import</span> <span>matplotlib</span>.<span>pyplot</span> <span>as</span> <span>plt</span>
<span>fig</span>, <span>ax</span> <span>=</span> <span>model</span>.<span>plot_forecast</span>(<span>time_series</span><span>=</span><span>test_data</span>, <span>plot_forecast_uncertainty</span><span>=</span><span>True</span>)
<span>plt</span>.<span>show</span>()</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/salesforce/Merlion/raw/main/figures/forecast_example.png"><img src="https://github.com/salesforce/Merlion/raw/main/figures/forecast_example.png" alt="forecast figure"/></a></p>
<p dir="auto">Finally, we quantitatively evaluate the model. sMAPE measures the error of the prediction on a scale of 0 to 100
(lower is better), while MSIS evaluates the quality of the 95% confidence band on a scale of 0 to 100 (lower is better).</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Evaluate the model&#39;s predictions quantitatively
from scipy.stats import norm
from merlion.evaluate.forecast import ForecastMetric

# Compute the sMAPE of the predictions (0 to 100, smaller is better)
smape = ForecastMetric.sMAPE.value(ground_truth=test_data, predict=test_pred)

# Compute the MSIS of the model&#39;s 95% confidence interval (0 to 100, smaller is better)
lb = TimeSeries.from_pd(test_pred.to_pd() + norm.ppf(0.025) * test_err.to_pd().values)
ub = TimeSeries.from_pd(test_pred.to_pd() + norm.ppf(0.975) * test_err.to_pd().values)
msis = ForecastMetric.MSIS.value(ground_truth=test_data, predict=test_pred,
                                 insample=train_data, lb=lb, ub=ub)
print(f&#34;sMAPE: {smape:.4f}, MSIS: {msis:.4f}&#34;)"><pre><span># Evaluate the model&#39;s predictions quantitatively</span>
<span>from</span> <span>scipy</span>.<span>stats</span> <span>import</span> <span>norm</span>
<span>from</span> <span>merlion</span>.<span>evaluate</span>.<span>forecast</span> <span>import</span> <span>ForecastMetric</span>

<span># Compute the sMAPE of the predictions (0 to 100, smaller is better)</span>
<span>smape</span> <span>=</span> <span>ForecastMetric</span>.<span>sMAPE</span>.<span>value</span>(<span>ground_truth</span><span>=</span><span>test_data</span>, <span>predict</span><span>=</span><span>test_pred</span>)

<span># Compute the MSIS of the model&#39;s 95% confidence interval (0 to 100, smaller is better)</span>
<span>lb</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>test_pred</span>.<span>to_pd</span>() <span>+</span> <span>norm</span>.<span>ppf</span>(<span>0.025</span>) <span>*</span> <span>test_err</span>.<span>to_pd</span>().<span>values</span>)
<span>ub</span> <span>=</span> <span>TimeSeries</span>.<span>from_pd</span>(<span>test_pred</span>.<span>to_pd</span>() <span>+</span> <span>norm</span>.<span>ppf</span>(<span>0.975</span>) <span>*</span> <span>test_err</span>.<span>to_pd</span>().<span>values</span>)
<span>msis</span> <span>=</span> <span>ForecastMetric</span>.<span>MSIS</span>.<span>value</span>(<span>ground_truth</span><span>=</span><span>test_data</span>, <span>predict</span><span>=</span><span>test_pred</span>,
                                 <span>insample</span><span>=</span><span>train_data</span>, <span>lb</span><span>=</span><span>lb</span>, <span>ub</span><span>=</span><span>ub</span>)
<span>print</span>(<span>f&#34;sMAPE: <span><span>{</span><span>smape</span>:.4f<span>}</span></span>, MSIS: <span><span>{</span><span>msis</span>:.4f<span>}</span></span>&#34;</span>)</pre></div>
<div data-snippet-clipboard-copy-content="sMAPE: 4.1944, MSIS: 18.9331"><pre><code>sMAPE: 4.1944, MSIS: 18.9331
</code></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Evaluation and Benchmarking</h2><a id="user-content-evaluation-and-benchmarking" aria-label="Permalink: Evaluation and Benchmarking" href="#evaluation-and-benchmarking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">One of Merlion&#39;s key features is an evaluation pipeline that simulates the live deployment
of a model on historical data. This enables you to compare models on the datasets relevant
to them, under the conditions that they may encounter in a production environment. Our
evaluation pipeline proceeds as follows:</p>
<ol dir="auto">
<li>Train an initial model on recent historical training data (designated as the training split of the time series)</li>
<li>At a regular interval (e.g. once per day), retrain the entire model on the most recent data. This can be either the
entire history of the time series, or a more limited window (e.g. 4 weeks).</li>
<li>Obtain the model&#39;s predictions (anomaly scores or forecasts) for the time series values that occur between
re-trainings. You may customize whether this should be done in batch (predicting all values at once),
streaming (updating the model&#39;s internal state after each data point without fully re-training it),
or some intermediate cadence.</li>
<li>Compare the model&#39;s predictions against the ground truth (labeled anomalies for anomaly detection, or the actual
time series values for forecasting), and report quantitative evaluation metrics.</li>
</ol>
<p dir="auto">We provide scripts that allow you to use this pipeline to evaluate arbitrary models on arbitrary datasets.
For example, invoking</p>
<div dir="auto" data-snippet-clipboard-copy-content="python benchmark_anomaly.py --dataset NAB_realAWSCloudwatch --model IsolationForest --retrain_freq 1d"><pre>python benchmark_anomaly.py --dataset NAB_realAWSCloudwatch --model IsolationForest --retrain_freq 1d</pre></div>
<p dir="auto">will evaluate the anomaly detection performance of the <code>IsolationForest</code> (retrained once a day) on the
&#34;realAWSCloudwatch&#34; subset of the NAB dataset.  Similarly, invoking</p>
<div dir="auto" data-snippet-clipboard-copy-content="python benchmark_forecast.py --dataset M4_Hourly --model ETS"><pre>python benchmark_forecast.py --dataset M4_Hourly --model ETS</pre></div>
<p dir="auto">will evaluate the batch forecasting performance (i.e. no retraining) of <code>ETS</code> on the &#34;Hourly&#34; subset of the M4 dataset.
You can find the results produced by running these scripts in the Experiments section of the
<a href="https://arxiv.org/abs/2109.09265" rel="nofollow">technical report</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Technical Report and Citing Merlion</h2><a id="user-content-technical-report-and-citing-merlion" aria-label="Permalink: Technical Report and Citing Merlion" href="#technical-report-and-citing-merlion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can find more details in our technical report: <a href="https://arxiv.org/abs/2109.09265" rel="nofollow">https://arxiv.org/abs/2109.09265</a></p>
<p dir="auto">If you&#39;re using Merlion in your research or applications, please cite using this BibTeX:</p>
<div data-snippet-clipboard-copy-content="@article{bhatnagar2021merlion,
      title={Merlion: A Machine Learning Library for Time Series},
      author={Aadyot Bhatnagar and Paul Kassianik and Chenghao Liu and Tian Lan and Wenzhuo Yang
              and Rowan Cassius and Doyen Sahoo and Devansh Arpit and Sri Subramanian and Gerald Woo
              and Amrita Saha and Arun Kumar Jagota and Gokulakrishnan Gopalakrishnan and Manpreet Singh
              and K C Krithika and Sukumar Maddineni and Daeki Cho and Bo Zong and Yingbo Zhou
              and Caiming Xiong and Silvio Savarese and Steven Hoi and Huan Wang},
      year={2021},
      eprint={2109.09265},
      archivePrefix={arXiv},
      primaryClass={cs.LG}
}"><pre><code>@article{bhatnagar2021merlion,
      title={Merlion: A Machine Learning Library for Time Series},
      author={Aadyot Bhatnagar and Paul Kassianik and Chenghao Liu and Tian Lan and Wenzhuo Yang
              and Rowan Cassius and Doyen Sahoo and Devansh Arpit and Sri Subramanian and Gerald Woo
              and Amrita Saha and Arun Kumar Jagota and Gokulakrishnan Gopalakrishnan and Manpreet Singh
              and K C Krithika and Sukumar Maddineni and Daeki Cho and Bo Zong and Yingbo Zhou
              and Caiming Xiong and Silvio Savarese and Steven Hoi and Huan Wang},
      year={2021},
      eprint={2109.09265},
      archivePrefix={arXiv},
      primaryClass={cs.LG}
}
</code></pre></div>

<p dir="auto">We are striving to leverage the time-series modeling with GPUs to further improve the speed and throughput of Merlion.
Stay tuned ...</p>
</article></div></div>
  </body>
</html>
