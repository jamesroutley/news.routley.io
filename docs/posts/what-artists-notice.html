<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stopa.io/post/294">Original</a>
    <h1>What Artists Notice</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span><hr/><p>Painters at work notice details we’d ignore. From those details they develop delightful insights into reality. What do I mean? Let’s take a gander at Van Eyck’s “Arnolfini Portrait” to find out:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTAxMi0wOTFiNDBmZi00MTdmLTQ0NjktODJmNi1mMDlhZjVjNWZjNDkucG5n" title="Arnolfini Portrait, Jan van Eyck"/><span>Arnolfini Portrait, Jan van Eyck</span></span></p><p>The most whimsical idea starts with <em>what</em> Van Eyck painted. Do you think anyone in the world has paid more attention to this room than Van Eyk has? Look at the prayer beads beside the mirror: </p><h2 id="beads">Beads</h2><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTA2MS1kYjg2MWNiNS1iMzljLTQ0YTUtYmE4Yy1kMTQ0ODg0MjkwNmUucG5n" title="Prayer beads"/><span>Prayer beads</span></span></p><p>Don’t they seem uncannily real? Well, art historians think Van Eyck put them through a magnifying glass to get them this right. A practiced meditator would find it hard to stare at prayer beads for more than a few hours, while Van Eyck must have spent days. </p><p>The more you look, the more details you uncover. Notice how rich the wife’s dress is: the intricate folds, the patterns, the material. I’m not sure anyone but the dressmaker could have scrutinized it with more care. And even the dog is gifted with attention; look at its fur! </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTE3MC1hMDcwYjdmZC03NDZjLTRlMWItOTNmOS1lNzMyYjNmZjJmOGMucG5n" title="The doggo"/><span>The doggo</span></span></p><p>Try it yourself <sup>[<!-- -->1<!-- -->]</sup>. Pick a random spot and zoom into the painting. You’ll discover a world of detail you hadn’t seen. From here, it’s safe to say that at least Van Eyck noticed details we’d ignore.</p><h2 id="monet">Monet</h2><p>But is this true for all painters? Van Eyck was known to bring his paintings to life with layers of detail. How about someone like Monet, who didn’t follow that strategy? Let’s look at his water lilies:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTIyNy03YjVmMmZlMy03Zjc3LTRiNDctYWE0Yy0yODcwYmZjMDVlODcucG5n" title="Water Lilies, Claude Monet"/><span>Water Lilies, Claude Monet</span></span></p><p>You’d be surprised. Monet actually created 250 paintings of water lilies in the <em>same</em> pond, to study the effect of light there. You saw 1 of 250, a devotion that engrossed close to three decades of his life. How much more do you think you’d see in a pond of water lilies, if you spent 30 years looking? </p><p>Our brains ignore details and see the essence of things. We barely notice the prayer beads, and wouldn’t take more than a few glances at the reflection of water lilies. The brush, however, forced Van Eyck and Monet to stop and see more. From there is born the premise that painters notice details we’d ignore.</p><p>Now details by themselves, although interesting, aren’t general. Who cares if Van Eyck was intimately aware of prayer beads or if Monet had a deeper understanding of a pond? Let’s zoom out and see some of the larger implications. Back to the Arnolfini Portrait:</p><h2 id="fruit">Fruit</h2><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTI3Mi1jMGM1YTAwNi02MjhhLTQ2NDEtYjlkNi1iYjhjYTE1ZTQxMDgucG5n" title="What&#39;s up with the fruit?"/><span>What&#39;s up with the fruit?</span></span></p><p>Why is there fruit by the window? How about the clogs? Do you see all the various symmetrical arrangements: the bead and the broom, the grey clogs and the red clogs, the couple’s position? And what about the colors? Why is the husband wearing a dark purple coat, and not a red one? Look at the wife’s gesture. It’s so maidenly, but why?</p><h2 id="subconscious">Subconscious</h2><p>PG originally shared this idea in a masterful essay <sup>[<!-- -->2<!-- -->]</sup>, and I’ll adopt it here. Every painting Van Eyck made had a purpose; to <em>affect</em> his audience. He may have wanted to please, shock, or dazzle; the spectrum of human emotions were fully available to him. This also meant that every painting worked doubly as a test; did it achieve its purpose? The more Van Eyck painted, the more he discovered exactly what worked. </p><p>Slowly but surely details amalgamated into patterns, and Van Eyck began to map our subconscious drivers. He discovered our inborn love of symmetry for example, and used it to masterful advantage throughout the painting. He discovered the gestures that make us feel innocence, and now we can’t help but see it in the wife. <sup>[<!-- -->3<!-- -->]</sup></p><p>When we look at his work, feelings and thoughts burgeon up, but we can’t put our finger on <em>why.</em> Well, Van Eyck could put his finger on why, and there comes the painter’s first insight: <em>they learn what affects humans.</em></p><p>Already we hit an interesting philosophical plane. When you learn what affects humans, you’re bound to ask why. But it gets grander.</p><p>I left the coolest part of this painting last. Look at the mirror:</p><h2 id="mirror">Mirror</h2><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTMyOC04YWEzZTc4NS1jNjAxLTQ3OWMtOTBmYS04MjZiOTEwMjNkYTUucG5n" title="Hacker level 1000"/><span>Hacker level 1000</span></span></p><p>Van Eyk painted the reflection! You can even see two folks peering back at the couple. <sup>[<!-- -->4<!-- -->]</sup> </p><p>Outside the effort this must have taken, imagine what Van Eyck learned. How deeply have you thought about how light reflects in convex mirrors? I’d bet a lot less than Van Eyck after this painting. In fact, some have tried to see just how accurate Van Eyck was, and compared his depiction with what a real convex mirror would have reflected <sup>[<!-- -->5<!-- -->]</sup>: </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTQwOC1iMjU0ZDM4My03MmMyLTRkYjYtYjBlNi1mOWMzMGI2ZjE1OTYucG5n" title="Van Eyck vs reality"/><span>Van Eyck vs reality</span></span></p><p><em>a</em> is Van Eyck’s work, and <em>b,c,d</em> are the mathematically correct versions. The similarity is remarkable. </p><h2 id="nature">Nature</h2><p>Not only did Van Eyck have to learn what affected humans, but the brush forced him to see deeply into the real world. The mirror is just the beginning. Imagine what he learned trying to draw the shadows. What about the chandelier? Here we hit the painter’s second insight: <em>they learn to unravel the secrets of nature.</em></p><p>As a painters master these insights, they take the canvas to heights we couldn’t have imagined before. For example, look at Botticelli’s “The Birth of Venus”</p><h2 id="venus">Venus</h2><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTUwNi0xZjgwY2Y2Mi1mMDBkLTRjNDgtOTdkMy1lYzMxY2YyYzliNTAucG5n" title="Birth of Venus, Sandro Botticelli"/><span>Birth of Venus, Sandro Botticelli</span></span></p><p>Stuff like symmetry here is obvious. But, glance over Venus’ neck:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTU4MS0yMWQ1MzQ4ZC00MWQ4LTQzZDgtODVhMC0wNGJhNTFkMDFkYjUucG5n" title="What’s up with the neck?"/><span>What’s up with the neck?</span></span></p><p>It’s longer than a normal human neck! Or look at her hands and shoulders, a bit lower and longer than normal. Botticelli hacked our minds. He knew what pushed our buttons, so he didn’t just describe reality, he accentuated it. He showed us a view of Venus’s elegance that could only be achieved through painting. <sup>[<!-- -->6<!-- -->]</sup></p><h2 id="redefinition">Redefinition</h2><p>Eventually, painters can eschew reality’s constraints in ground-breaking ways, and show us what our eyes could never see:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTYzMy02ZjVlZmUyNi03ZDUwLTRhZTctYjc1Ny0xNDNmMDZhMjhlYzAucG5n" title="Starry Night, Van Gogh"/><span>Starry Night, Van Gogh</span></span></p><p>These insights touch on what makes painting <em>art.</em> Painting isn’t a rote exercise, but an inquiry into reality and perception. </p><hr/><p>Here’s a jump: I think programmers have a similar experience <sup>[<!-- -->7<!-- -->]</sup>. Programmers at work notice details we’d ignore. From those details they develop delightful insights into reality. </p><p>Now, programming is not as far along as painting yet; our art has just begun. Like painting in the early renaissance, our work is crude, but we’re accruing insight after insight. What are these insights? </p><p>Let’s find out by answering a question: what would a programmer notice if they made an <em>app</em> for painters? We’ll call it pixel.fyi, and we’ll help painters draw stuff online. Here’s our goal:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTY3OC1hNThiZDhkMS1jYzA3LTQ3YjYtOGJiMC04N2VkN2FlOGY0ZGEucG5n" title="The Goal"/><span>The Goal</span></span></p><p>Before we get into what programmers notice, let’s learn what programmers <em>do</em>. Today our devices are so sophisticated that they seem intelligent, as though they “understand” what we want from them. </p><p>However, this intelligence is an illusion built upon illusions, and is perhaps the masterwork of the pioneer programmers of our time. Computers aren’t intelligent. Instead, they do simple things, like add and subtract numbers, <em>very</em> quickly. </p><h2 id="adding-machine">Adding Machine</h2><p>To a get sense, here’s the great-great-grandfather of our modern computer:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTczMC04ZTBhZTZmMi02Y2U5LTQ2NzQtOTlmNC03YTA5NDM4ZjhhYWMucG5n" title="Adding Machine"/><span>Adding Machine</span></span></p><p>Here we have three light switches labeled “1”, “2”, and “3”. We also have three light bulbs labeled “3”, “4”, and “5”. </p><p>Now, would it be possible to wire things up so that if someone turned on our “1” and “2” light switch, the “3” light bulb would turn on? </p><p>It doesn’t seem so difficult, and we’d hardly call it intelligence, but if we did this we would have created a machine that could <em>add</em> 1 and 2! </p><h2 id="speed">Speed</h2><p>That’s cool, but here’s something startling: though crude, our invention adds numbers faster than any human ever could. The answer comes at the speed of light through a wire; this means our machine can make <em>millions</em> of calculations by the time you finish this sentence.</p><h2 id="language">Language</h2><p>Interestingly, our machine also has the same advantage as modern computers, in that the answer comes quickly, and the same disadvantage, in that fundamentally there is no intelligence. </p><p>So what’s the big difference? Our machine is specific; it can <em>only</em> add 1 to 3. Modern computers are general; they can do any computation. Instead of wiring things up a specific way, modern computers let us use a computer language to <em>simulate</em> wiring things up in any way we like. It looks something like this:</p><pre><code><span>if</span><span> light_switch_1 </span><span>is</span><span> on </span><span>and</span><span> light_switch_2 </span><span>is</span><span> on:</span>
<span>  </span><span>turn_on(bulb_3)</span></code></pre><p>With that code, it’s as though we “wired up” our great-great-grandfather machine! </p><p>We come to the essence of what programmers do. They write precise instructions in a computer language, to get computers to solve problems. <em>Precise</em> is the key word here, because at the end of the day it all boils down to switches that turn on and off.</p><p>Okay, back to programmers today. The most whimsical idea starts with <em>what</em> they create. For example, in order for pixel.fyi to work, at the very least we need to let our users draw simple shapes, like circles or squares. </p><h2 id="circles">Circles</h2><p>Well, how would a computer draw a circle? Switches have no concept of “circle”.  Here’s one idea: </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTc3OS1mOTE4YTA2OS1mMmQ3LTQyNTAtYWYwMS1hNTNmMmUzY2M2M2MucG5n" title="Circle"/><span>Circle</span></span></p><p>Let’s imagine the monitor is like a grid, where we can turn each pixel on or off. A circle is really <em>all</em> the pixels that are a specific distance away from a center point. If we could just figure out all the pixels to turn on, we’d have a circle! </p><h2 id="trigonometry">Trigonometry</h2><p>And how do we figure out those pixels? Let’s remember some math:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTgzMC1jY2Y0NDA5ZS0wMzI3LTRjNjktYmFhMi01ODYyMTcxYmMzNWMucG5n" title="Trig"/><span>Trig</span></span></p><p>We could draw a right-angle triangle going from the center to a point on our circle at any particular degree. We can then use trigonometry to find the x and y coordinates for the point! All of a sudden, we have a plan to draw a circle. Here’s how a programmer could express it in a computer language:</p><pre><code><span>radius </span><span>=</span><span> </span><span>20</span>
<span>pixels </span><span>=</span><span> []</span>
<span>for</span><span> degrees </span><span>in</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]:</span>
<span>  x </span><span>=</span><span> radius </span><span>*</span><span> </span><span>cos(degrees)</span>
<span>  y </span><span>=</span><span> radius </span><span>*</span><span> </span><span>sin(degrees)</span>
<span>  </span><span>into(pixels, [x, y])</span>
<span>  </span>
<span>turn_on(pixels)</span></code></pre><p>For every degree between 0 and 360,  we calculate the <code>x</code> and <code>y</code> coordinates, and we have our pixel. We can then <code>turn_on</code>  pixels, and voila, our circle is born! <sup>[<!-- -->8<!-- -->]</sup> Here’s how this would look: </p><h2 id="detail">Detail</h2><p>So what’s the consequence of all of this? Look how much we learned about circles. Not only did we breath life to trigonometry, but we discovered the “essence” of a circle: it’s all the points that are equidistant from a center. And if you think about it, this is the <em>same</em> definition for a sphere! A sphere is all the points that are equidistant from a center in three dimensions. And now for a mind-bender: this must mean that “circle” exists in infinite dimensions; there’s a “4-D circle”, with points equidistant from a center! <sup>[<!-- -->9<!-- -->]</sup></p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTkxOS1iMGRmNjU4Yy1mZDQ2LTRmODUtOTc1My03YWYwMjAxMWY1MjYucG5n" title="4-D Circle?!"/><span>4-D Circle?!</span></span></p><p>Our brains ignore details and see the essence of things. When we look at circles, the only property likely to burgeon up is that they’re round. The computer language however, forced us to see more. Sound familiar? From here is born the premise that programmers notice details we’d ignore.</p><p>Now details by themselves, though interesting, aren’t general. Who cares if we know more about circles than the average person? Well, let’s zoom out to see some of the larger implications. We can kick off with a roundabout journey, and take a look at algebra. </p><h2 id="variables">Variables</h2><p>Do you remember the kind of homework you did in middle school? Stuff like: </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTk4NC02NDZlNGY4Ny03YjRkLTQwZmItODNkYi05NWEzNDVkZTc3MDgucG5n" title="x + 2 = 5"/><span>x + 2 = 5</span></span></p><p>Here,  <code>x</code> is 3. Now, where did <code>x</code> <em>come</em> from? When we write <code>x</code>, we are using the concept of a <em>variable.</em> But variables didn’t always exist! They were only invented in the 16th century.</p><p>What did mathematicians do before? They used words. Instead of <code>x + 2 = 5</code>, they would write: </p><span><blockquote><p>There is such a number, that when you add 2 to it, you get 5. What is this number?</p></blockquote></span><p>You can already get a sense of how annoying this could become. If all you have are sentences, even the area of a triangle can get taxing to describe. With variables, we could write:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjAyOC1iOGQ5ZTdkOC0xM2M2LTRlZWUtOTgwYS04NDAxN2IxODg4MjMucG5n" title="1/2 w * h"/><span>1/2 w * h</span></span></p><p>Without variables, we’d be stuck with:</p><span><blockquote><p>Pick one side of the triangle. Measure this side. Now measure the straight line that connects from the opposite angle, to the side you chose. Multiply these two numbers together, and divide by two to get the area.</p></blockquote></span><p>At some point, problems get so complicated that we can’t solve them with words anymore; no person’s head could fit the space required. That’s where variables come to the rescue. <code>x</code> isn’t just any mundane character, but a shorthand for our brain: what was intractable before can now fit into a middle schooler’s head. </p><p>That&#39;s thrilling and begs the question: what <em>other</em> concepts exist like this that we haven&#39;t discovered yet?</p><h2 id="complications">Complications</h2><p>Programmers think about this question all the time. Why? Let’s look at our code for clues: </p><pre><code><span>radius </span><span>=</span><span> </span><span>20</span>
<span>pixels </span><span>=</span><span> []</span>
<span>for</span><span> degrees </span><span>in</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]:</span>
<span>  x </span><span>=</span><span> radius </span><span>*</span><span> </span><span>cos(degrees)</span>
<span>  y </span><span>=</span><span> radius </span><span>*</span><span> </span><span>sin(degrees)</span>
<span>  </span><span>into(pixels, [x, y])</span>
<!-- -->
<span>turn_on(pixels)</span></code></pre><p>We were a bit mistaken here. We assumed our center was at <code>[0,0]</code>, and our radius was <code>20</code>. What if we wanted to draw <em>another</em> circle, but this time with a center of <code>[5, 5]</code> and a radius of <code>15</code>?</p><p>We could write this: </p><pre><code><span>radius </span><span>=</span><span> </span><span>20</span>
<span>pixels </span><span>=</span><span> []</span>
<span>for</span><span> degrees </span><span>in</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]:</span>
<span>  x </span><span>=</span><span> radius </span><span>*</span><span> </span><span>cos(degrees)</span>
<span>  y </span><span>=</span><span> radius </span><span>*</span><span> </span><span>sin(degrees)</span>
<span>  </span><span>into(pixels, [x, y])</span>
<!-- -->
<span>turn_on(pixels)</span>
<!-- -->
<span>radius_two </span><span>=</span><span> </span><span>15</span>
<span>center_two </span><span>=</span><span> [</span><span>5</span><span>,</span><span>5</span><span>]</span>
<span>pixels_two </span><span>=</span><span> []</span>
<span>for</span><span> degrees </span><span>in</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]:</span>
<span>  x </span><span>=</span><span> center_two.x </span><span>+</span><span> radius_two </span><span>*</span><span> </span><span>cos(degrees)</span>
<span>  y </span><span>=</span><span> center_two.y </span><span>+</span><span> radius_two </span><span>*</span><span> </span><span>sin(degrees)</span>
<span>  </span><span>into(pixels_two, [x, y])</span>
<!-- -->
<span>turn_on(pixels_two)</span></code></pre><p>But already this is getting hard to think about. What if we wanted to draw a hundred different circles? We can’t just keep copying and pasting. We’d barely get to triangles before our program spilled out of our heads.</p><h2 id="snippets">Snippets</h2><p>We’re forced to invent a new concept. Here’s one; what if our language had a “snippet”? A way for us to say <code>draw_circle</code>, with different options for <code>center</code> and <code>radius</code>: </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjA4OC0zOWNjMzE5OS03NmE4LTRiY2UtYjczMi01M2VlMWFjZDdlYzEucG5n" title="draw_circle"/><span>draw_circle</span></span></p><p>This is how it could work:</p><pre><code><span>def</span><span> </span><span>draw_circle</span><span>(</span><span>center</span><span>, </span><span>radius</span><span>):</span>
<span>  pixels </span><span>=</span><span> []</span>
<span>  </span><span>for</span><span> degrees </span><span>in</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]:</span>
<span>    x </span><span>=</span><span> center.x </span><span>+</span><span> radius </span><span>*</span><span> </span><span>cos(degrees)</span>
<span>    y </span><span>=</span><span> center.y </span><span>+</span><span> radius </span><span>*</span><span> </span><span>sin(degrees)</span>
<span>    </span><span>into(pixels, [x, y])</span>
<span>  pixels</span>
<!-- -->
<span>turn_on(draw_circle([</span><span>0</span><span>, </span><span>0</span><span>], </span><span>20</span><span>))</span><span> </span><span># Draws one circle</span>
<span>turn_on(draw_circle([</span><span>5</span><span>, </span><span>5</span><span>], </span><span>15</span><span>))</span><span> </span><span># And another one!</span></code></pre><p><code>def</code> becomes our “snippet” making concept. Whenever we write <code>draw_circle(…)</code>, it’s as though we run the code inside it, with <code>center</code> and <code>radius</code> set differently. </p><p>Just like variables, <code>def</code> gives our minds a shorthand to think with. Now drawing a hundred circles is easy peasy. Not only that, but wherever someone sees <code>draw_circle</code>, they no longer need to think about how it works; if we find a more efficient way to draw a circle for example, we could change our snippet and nobody would be the wiser. <sup>[<!-- -->10<!-- -->]</sup> </p><h2 id="map">Map</h2><p><code>def</code> is just the beginning. Let’s keep going. Look at <code>draw_circle</code> again:</p><pre><code><span>pixels </span><span>=</span><span> []</span>
<span>for</span><span> degrees </span><span>in</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]:</span>
<span>  x </span><span>=</span><span> center.x </span><span>+</span><span> radius </span><span>*</span><span> </span><span>cos(degrees)</span>
<span>  y </span><span>=</span><span> center.y </span><span>+</span><span> radius </span><span>*</span><span> </span><span>sin(degrees)</span>
<span>  </span><span>into(pixels, [x, y])</span>
<span>pixels</span></code></pre><p>We can write it like this, but what’s <em>really</em> going on here? </p><p>If you think about it, we’re <em>transforming</em> one list (of degrees) to another list (of pixels). If we use an analogy in the real world, it could look like an assembly line:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjEzMS1iMjU0ZTRkZi0xODczLTQ3MGEtYjJmMy1iYzc1NzU4MWQyNjkucG5n" title="Assembly Lines"/><span>Assembly Lines</span></span></p><p>There’s one assembly line with <code>degrees</code> and a worker beside it. The worker picks up each <code>degrees</code>, figures out the corresponding pixel, and adds them to the <code>pixel</code> assembly line. </p><p>It took a sentence to explain, but it’s a valuable concept, and we can generalize it. What if we called this <code>map</code> ? A worker “maps” <code>degre``e``s</code> to <code>pixels</code>. Here’s how how our program could look now: </p><pre><code><span>def</span><span> </span><span>draw_circle</span><span>(</span><span>center</span><span>, </span><span>radius</span><span>):</span>
<span>  </span><span>map</span><span> [</span><span>0</span><span>.</span><span>.360</span><span>]: </span>
<span>    degrees </span><span>=&gt;</span>
<span>    [center.x </span><span>+</span><span> radius </span><span>*</span><span> </span><span>cos(degrees)</span><span>, center.y </span><span>+</span><span> radius </span><span>*</span><span> </span><span>sin(degrees)</span><span>]</span></code></pre><p>Now whenever we see <code>map</code>, the assembly line idea pops into our head. Not only does it give us a shorthand, but it opens up a new world; what <em>else</em> goes on in assembly lines, and can we use those concepts to help us think better? <sup>[<!-- -->11<!-- -->]</sup></p><h2 id="logic">Logic</h2><p>Just with circles, we were forced to invent snippets and map. Imagine all that we’d discover if we kept going: what about shadows? what about layers?</p><p>The computer can only understand precise instructions, and there are only so many precise instructions we can keep in our heads. The more complicated the programs we write, the more we’re forced to invent new concepts. From there comes the programmer’s first insight: <em>they learn what helps humans think better.</em></p><p>Already we hit an interesting philosophical plane. When you learn what helps humans think better, you’re bound to ask <em>why.</em> But it gets grander.</p><p>Now as we progress on with pixel.fyi, we’d want to support “undo” and “redo”. If a painter drew a smiley and didn’t like the nose, they should be able to “undo” it: </p><h2 id="undo-redo">Undo / Redo</h2><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjE3Ny1iMDc2MTkzZC1mZDE3LTQ1NmYtOGUzMy0wMzI5OWEzZTNmYTYucG5n" title="Scratch the nose"/><span>Scratch the nose</span></span></p><p>How could we support this? If we just <code>turn_on(draw_circle(...))</code> all over the place, there’s no way for us to know what the last instruction would be. It’s time for us to look for a new concept.</p><h2 id="time">Time</h2><p>Here’s a new idea. What if we kept track of the painting over <em>time</em>? Something like this:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjIwNC1kYzhhZGY1NS03MjAyLTQ1ZTgtYjU2Ni1kZTY5YzEyY2RiMWIucG5n" title="Painting over time"/><span>Painting over time</span></span></p><p>We have a list that represents time. Any change we make creates a new “version” of the painting, and adds it to the list. A painting at a point in time is just all the pixels that are turned on then.</p><p>“Current” points to the version we show our user. When they press “undo” or “redo”, we simply <em>move</em> “current” to another version in our list. </p><p>In our computer language, it could look something like this: </p><pre><code><span>painting </span><span>=</span><span> [[]]</span>
<span>current </span><span>=</span><span> </span><span>0</span>
<!-- -->
<span>def</span><span> </span><span>add_circle</span><span>(</span><span>center</span><span>, </span><span>radius</span><span>):</span>
<span>  last_version </span><span>=</span><span> painting[current]</span>
<span>  new_version </span><span>=</span><span> </span><span>into(last_version, draw_circle(center, radius))</span>
<span>  </span><span>into(painting, new_version)</span>
<span>  current </span><span>=</span><span> current </span><span>+</span><span> </span><span>1</span>
<!-- -->
<span>def</span><span> </span><span>undo</span><span>(): </span>
<span>  current </span><span>=</span><span> current </span><span>-</span><span> </span><span>1</span>
<!-- -->
<span>loop: </span>
<span>  </span><span>turn_off(all_pixels)</span>
<span>  </span><span>turn_on(paintings[current])</span><span>)</span></code></pre><p>This would support undo / redo, but it also opens up some interesting questions.</p><h2 id="identity">Identity</h2><p>First, consider that when we think about a “painting” in real life, we think about it as the end result. But here, we think about a painting as <em>all the versions that existed throughout time.</em>  </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjI1NC05NTdkY2EwMS03YjZiLTRmMDctOTU5MC04OTUxNzI4YzJhZGUucG5n" title="Two views"/><span>Two views</span></span></p><p>It’s convenient to think this way for undo and redo, but isn’t life <em>actually</em> like this? Unfortunately, we are stuck in 3 dimensions and can&#39;t travel through time, but if we could, we would see that identity encompasses time. A painting begun, even if it goes through change after change, is the same painting in the end. That’s the same with people; no cell in your body is existed when you were 5, but you’re still you. </p><h2 id="change">Change</h2><p>Another interesting idea, how <em>does</em> change happen? When we draw, we think we irrevocably modify the canvas. But if we could travel through time, we’d see something different: the canvas would <em>evolve.</em> After all, if you add a nose and go back in time, you’d still see the canvas without the nose, so how could the canvas have been irrevocably modified<em>?</em> </p><p>As it turns out, my friend Dennis <sup>[<!-- -->12<!-- -->]</sup> was so intrigued by this idea that he once explored a 3D animation for it, and it was about painting to boot. Here’s his rendering of a painting that evolves over time:</p><p>So darn interesting. We’ve lived in four dimensions all along but never saw it like this. </p><h2 id="perception">Perception</h2><p>And the insights don’t stop. Remember, this is a <em>multiplayer</em> drawing app. Could “Stopa” and “Joe” draw a shape <em>at the same time?</em> </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjMwOC01N2YyZTVhMC0yOWIxLTQ5ZGQtOWUzMi0xNWQxMGQwZWQ5MWQucG5n" title="Oops"/><span>Oops</span></span></p><p>This couldn’t happen when painting in real life; our hands don’t move fast enough. But a computer moves real fast; it’s certainly possible that Joe sees a blue shape and makes it red, but by the time this completes, Stopa sees the same blue shape and makes it green. </p><p>This problem opens an interesting question about how we perceive <em>anything</em> in life! If your friend is in front of you for example, how do you <em>see</em> them? </p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjM0Mi1lNDE2M2FmZi0xOThkLTRlMmYtOTJiYi01MGYwNTg4NTFjM2YucG5n" title="Perception"/><span>Perception</span></span></p><p>Well, light bounces around the room. Some of it hits your friend and reflects into your eyes. Your eyes then process the light, which activates signals in your brain. Those signals in turn activate more signals, until a thought pops up: “I see my friend”.</p><p>All of this takes time, right? It <em>feels</em> instant, but it takes time for light to move and for signals to activate in your brain. This means then, <em>that everything you see is from the past</em>! </p><p>When you try to solve problems like “Joe and Stopa change the same shape at the same time”, you realize at least computers always see the past. It’s awe-inspiring that our reality works the same. We just experienced a sliver of the programmer’s second insight: <em>they learn to unravel the secrets of nature.</em> <sup>[<!-- -->13<!-- -->]</sup></p><p>As programmer master these insights, they take their work to heights we couldn’t have imagined before. Well, actually we don’t know this quite yet, because we programmers haven’t mastered the insights!</p><h2 id="giotto">Giotto</h2><p>If you paralleled the story of programmers with Renaissance painters, we’d be at the Giotto stage:</p><p><span><img src="http://alok.github.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjM4OS00MjhhZWVmMi1hYTQ0LTQ3ODYtOGZmNC02Mjg2ODI3MDY0MzUucG5n" title="Kiss of Judas, Giotto"/><span>Kiss of Judas, Giotto</span></span></p><p>Giotto was early. Before him, most painters followed strict rules and their work was flat. He questioned assumptions, began to study nature, and made giant leaps in his lifetime <sup>[<!-- -->14<!-- -->]</sup>. Though his own work was still crude, in only a few generations Michelangelo would step on the scene. </p><p>That’s where the best programmers are today. Our work is crude, but we’re questioning assumptions and constantly looking for inspiration from nature. It’s so early that some of the best ideas are prime picking, and the state of the art evolves every year. We can already see astonishing results at the edges, like computers transcribing human speech with better accuracy or self-driving cars whizzing around roads.</p><h2 id="progress">Progress</h2><p>We’re left in an exciting state. I’m curious to know what transcendence will look like in our field. Computers are faster than any natural organ in our body. They need no sleep, can work 24/7, can “distribute” their brains around the world, and run for millennia. What kind of surprises lie ahead for us? What kind of concepts will the Michelangelo programmers of the future be using? </p><p>These insights touch on what makes programming <em>art.</em> Programming isn’t a rote exercise, but an inquiry into reality and perception. </p><hr/><p>Wow, what a journey we just went on.  </p><h2 id="painters-and-programmers">Painters and Programmers</h2><p>We learned that the brush forces the painter to notice details that we’d ignore. The painter’s goal is to affect us, and successive paintings help them unravel our subconscious drivers. Invariably they discover secrets of nature, and eventually transcend it.</p><p>Similarly, the computer language forces the programmer to notice details that we’d ignore. Their goal is to solve hard problems, and successive solutions help them unravel tools for human thought. Invariably they discover secrets of nature, and eventually transcend it.</p><h2 id="writers-and-creators">Writers and Creators</h2><p>It strikes me, that perhaps all creative pursuits are like this. This essay was born from a conversation, where I tried to explain why I found programming so invigorating. I thought I’d start with painting as the metaphor. However, putting words to paper had me discovering details I had ignored. I was plunged into book after book on art and even expanded my thinking on programming. <sup>[<!-- -->15<!-- -->]</sup></p><p>There’s an obvious utility to the output of creation, but even if there wasn’t, I think there would be an overwhelming reason to do it anyway, just for the insights you get. <sup>[<!-- -->16<!-- -->]</sup></p><p>I hope this got you thrilled about the beauty of making things.</p><p>Ernst Gombrich’s “Story of Art” influenced how I saw art throughout the ages. PG is a hero of mine, and his essays on hacking and painting continue to inspire me <sup>[<!-- -->17<!-- -->]</sup>. I am taken by Rich Hickey’s model for programming. His motivations for Clojure largely inspired the “Reality, II” section. <sup>[<!-- -->18<!-- -->]</sup></p><p><em>Thanks to Joe Averbukh, Daniel Woelfel, Nicole Garcia Fischer, Mark Shlick, Lina Wang, Dennis Heihoff, Alex Reichert, Julien Odent, Irakli Popkhadze, Simon Chaffetz, Jacky Wang, Nino Parunashvili, for reviewing drafts of this essay</em></p></span></p></div></div></div></div>
  </body>
</html>
