<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nick-black.com/dankwiki/index.php/Io_uring">Original</a>
    <h1>Io uring</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div><div><div><p><a href="https://commoncog.com/dankwiki/index.php/File:Uring_0.png"><img alt="" src="https://commoncog.com/dankwiki/images/thumb/3/36/Uring_0.png/300px-Uring_0.png" decoding="async" width="300" height="198" srcset="/dankwiki/images/thumb/3/36/Uring_0.png/450px-Uring_0.png 1.5x, /dankwiki/images/thumb/3/36/Uring_0.png/600px-Uring_0.png 2x"/></a></p><div><p>A nice io_uring visualization courtesy Donald Hunter</p></div></div></div>
<p>Introduced in 2019 (kernel 5.1) by Jens Axboe, <tt>io_uring</tt> (henceforth uring) is a system for providing the kernel with a schedule of system calls, and receiving the results as they&#39;re generated. Whereas <a href="https://commoncog.com/dankwiki/index.php/Epoll" title="Epoll">epoll</a> and <a href="https://commoncog.com/dankwiki/index.php/Kqueue" title="Kqueue">kqueue</a> support multiplexing, where you&#39;re told when you can usefully perform a system call using some set of filters, uring allows you to specify the system calls themselves (and dependencies between them), and execute the schedule at the kernel <a rel="nofollow" href="https://en.wikipedia.org/wiki/Dataflow_architecture">dataflow limit</a>. It combines asynchronous I/O, system call polybatching, and flexible buffer management, and is IMHO the most substantial development in the <a href="https://commoncog.com/dankwiki/index.php/Linux_APIs" title="Linux APIs">Linux I/O model</a> since Berkeley sockets (yes, I&#39;m aware Berkeley sockets preceded Linux. Let&#39;s then say that it&#39;s the most substantial development in the UNIX I/O model to originate in Linux):
</p>
<ul><li>Asynchronous I/O without the large copy overheads and restrictions of POSIX AIO</li>
<li>System call batching/linking across distinct system calls</li>
<li>Provide a buffer pool, and they&#39;ll be used as needed</li>
<li>Both polling- and interrupt-driven I/O on the kernel side</li></ul>
<p>The core system calls of uring are wrapped by the C API of <a rel="nofollow" href="https://github.com/axboe/liburing">liburing</a>. Windows added a very similar interface, IoRing, in 2020. In my opinion, uring ought largely displace <a href="https://commoncog.com/dankwiki/index.php/Epoll" title="Epoll">epoll</a> in new Linux code. <a href="https://commoncog.com/dankwiki/index.php/FreeBSD" title="FreeBSD">FreeBSD</a> seems to be sticking with <a href="https://commoncog.com/dankwiki/index.php/Kqueue" title="Kqueue">kqueue</a>, meaning code using uring won&#39;t run there, but neither did epoll (save through FreeBSD&#39;s somewhat dubious Linux compatibility layer). Both the system calls and liburing have fairly comprehensive man page coverage, including the <a rel="nofollow" href="https://www.man7.org/linux/man-pages/man7/io_uring.7.html">io_uring.7</a> top-level page.
</p>
<div id="toc" role="navigation" aria-labelledby="mw-toc-heading"><div lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2></div>
<ul>
<li><a href="#Rings"><span>1</span> <span>Rings</span></a>
<ul>
<li><a href="#System_calls"><span>1.1</span> <span>System calls</span></a></li>
</ul>
</li>
<li><a href="#Setup"><span>2</span> <span>Setup</span></a>
<ul>
<li><a href="#Ring_structure"><span>2.1</span> <span>Ring structure</span></a></li>
<li><a href="#Flags"><span>2.2</span> <span>Flags</span></a></li>
<li><a href="#Kernel_features"><span>2.3</span> <span>Kernel features</span></a></li>
<li><a href="#Registered_resources"><span>2.4</span> <span>Registered resources</span></a>
<ul>
<li><a href="#Buffers"><span>2.4.1</span> <span>Buffers</span></a></li>
<li><a href="#Registered_files"><span>2.4.2</span> <span>Registered files</span></a></li>
<li><a href="#Personalities"><span>2.4.3</span> <span>Personalities</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Submitting_work"><span>3</span> <span>Submitting work</span></a>
<ul>
<li><a href="#The_SQE_structure"><span>3.1</span> <span>The SQE structure</span></a></li>
<li><a href="#Prepping_SQEs"><span>3.2</span> <span>Prepping SQEs</span></a>
<ul>
<li><a href="#User_data"><span>3.2.1</span> <span>User data</span></a></li>
<li><a href="#Opening_and_closing_file_descriptors"><span>3.2.2</span> <span>Opening and closing file descriptors</span></a></li>
<li><a href="#Reading_and_writing_file_descriptors"><span>3.2.3</span> <span>Reading and writing file descriptors</span></a></li>
<li><a href="#Manipulating_directories"><span>3.2.4</span> <span>Manipulating directories</span></a></li>
<li><a href="#Timeouts_and_polling"><span>3.2.5</span> <span>Timeouts and polling</span></a></li>
<li><a href="#Interring_communication"><span>3.2.6</span> <span>Interring communication</span></a></li>
</ul>
</li>
<li><a href="#Linked_operations"><span>3.3</span> <span>Linked operations</span></a></li>
<li><a href="#Sending_it_to_the_kernel"><span>3.4</span> <span>Sending it to the kernel</span></a>
<ul>
<li><a href="#Submission_queue_polling_details"><span>3.4.1</span> <span>Submission queue polling details</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Reaping_completions"><span>4</span> <span>Reaping completions</span></a>
<ul>
<li><a href="#Multishot"><span>4.1</span> <span>Multishot</span></a></li>
</ul>
</li>
<li><a href="#Corner_cases"><span>5</span> <span>Corner cases</span></a>
<ul>
<li><a href="#Single_fd_in_multiple_rings"><span>5.1</span> <span>Single fd in multiple rings</span></a></li>
<li><a href="#Multithreaded_use"><span>5.2</span> <span>Multithreaded use</span></a></li>
<li><a href="#Coexistence_with_epoll/XDP"><span>5.3</span> <span>Coexistence with epoll/XDP</span></a></li>
<li><a href="#Queue_overflows"><span>5.4</span> <span>Queue overflows</span></a></li>
</ul>
</li>
<li><a href="#What&#39;s_missing"><span>6</span> <span>What&#39;s missing</span></a></li>
<li><a href="#External_links"><span>7</span> <span>External links</span></a></li>
</ul>
</div>

<h2><span id="Rings">Rings</span></h2>
<p>Central to every uring are two ringbuffers holding CQEs (Completion Queue Entries) and SQE (Submission Queue Entries) descriptors (as best I can tell, this terminology was borrowed from the <a rel="nofollow" href="https://nvmexpress.org/specifications/">NVMe specification</a>). Note that SQEs are allocated externally to the SQ descriptor ring. SQEs roughly correspond to a single system call: they are tagged with an operation type, and filled in with the values that would traditionally be supplied as arguments to the appropriate function. Userspace is provided references to SQEs on the SQE ring, which it fills in and submits. Submission operates up through a specified SQE, and thus all SQEs before it in the ring must also be ready to go (this is likely the main reason why the SQ holds descriptors to an external ring of SQEs: you can acquire SQEs, and then submit them out of order). The kernel places results in the CQE ring. These rings are shared between kernel- and userspace. The rings must be distinct unless the kernel specifies the <tt>IORING_FEAT_SINGLE_MMAP</tt> feature (see below).
</p><p>uring does not generally make use of <tt>errno</tt>. Synchronous functions return the negative error code as their result. Completion queue entries have the negated error code placed in their <tt>res</tt> fields.
</p><p>CQEs are usually 16 bytes, and SQEs are usually 64 bytes (but see <tt>IORING_SETUP_SQE128</tt> and <tt>IORING_SETUP_CQE32</tt> below). Either way, SQEs are allocated externally to the submission queue, which is merely a ring of 32-bit descriptors.
</p>
<h3><span id="System_calls">System calls</span></h3>
<p>The liburing interface will be sufficient for most users, and it is possible to operate almost wholly without system calls when the system is busy. For the sake of completion, here are the three system calls implementing the uring core (from the kernel&#39;s <tt>io_uring/io_uring.c</tt>):
</p>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_setup</span><span>(</span><span>u32</span><span> </span><span>entries</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_params</span><span> </span><span>*</span><span>p</span><span>);</span>
<span>int</span><span> </span><span>io_uring_enter</span><span>(</span><span>unsigned</span><span> </span><span>fd</span><span>,</span><span> </span><span>u32</span><span> </span><span>to_submit</span><span>,</span><span> </span><span>u32</span><span> </span><span>min_complete</span><span>,</span><span> </span><span>u32</span><span> </span><span>flags</span><span>,</span><span> </span><span>const</span><span> </span><span>void</span><span>*</span><span> </span><span>argp</span><span>,</span><span> </span><span>size_t</span><span> </span><span>argsz</span><span>);</span>
<span>int</span><span> </span><span>io_uring_register</span><span>(</span><span>unsigned</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>opcode</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>arg</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>nr_args</span><span>);</span>
</pre></div>
<p>Note that <tt>io_uring_enter(2)</tt> corresponds more closely to the <tt>io_uring_enter2(3)</tt> wrapper, and indeed <tt>io_uring_enter(3)</tt> is defined in terms of the latter (from liburing&#39;s <tt>src/syscall.c</tt>):
</p>
<div dir="ltr"><pre><span></span><span>static</span><span> </span><span>inline</span><span> </span><span>int</span><span> </span><span>__sys_io_uring_enter2</span><span>(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>to_submit</span><span>,</span>
<span>          </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>min_complete</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>sigset_t</span><span> </span><span>*</span><span>sig</span><span>,</span><span> </span><span>size_t</span><span> </span><span>sz</span><span>){</span><span>                                                                                                                                   </span>
<span>  </span><span>return</span><span> </span><span>(</span><span>int</span><span>)</span><span> </span><span>__do_syscall6</span><span>(</span><span>__NR_io_uring_enter</span><span>,</span><span> </span><span>fd</span><span>,</span><span> </span><span>to_submit</span><span>,</span><span> </span><span>min_complete</span><span>,</span><span> </span><span>flags</span><span>,</span><span> </span><span>sig</span><span>,</span><span> </span><span>sz</span><span>);</span><span>                                                                                           </span>
<span>}</span><span>                                                                                                                                   </span>
<span>                                                                                                                                    </span>
<span>static</span><span> </span><span>inline</span><span> </span><span>int</span><span> </span><span>__sys_io_uring_enter</span><span>(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>to_submit</span><span>,</span><span>                                                     </span>
<span>               </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>min_complete</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>sigset_t</span><span> </span><span>*</span><span>sig</span><span>){</span><span>                                                                                                                                   </span>
<span>  </span><span>return</span><span> </span><span>__sys_io_uring_enter2</span><span>(</span><span>fd</span><span>,</span><span> </span><span>to_submit</span><span>,</span><span> </span><span>min_complete</span><span>,</span><span> </span><span>flags</span><span>,</span><span> </span><span>sig</span><span>,</span><span> </span><span>_NSIG</span><span> </span><span>/</span><span> </span><span>8</span><span>);</span><span>                                                                                                            </span>
<span>}</span>
</pre></div>
<p><tt>io_uring_enter(2)</tt> can both submit SQEs and wait until some number of CQEs are available. Its <tt>flags</tt> parameter is a bitmask over:
</p>
<table>
<tbody><tr>
<th>Flag</th>
<th>Description
</th></tr>
<tr>
<td><tt>IORING_ENTER_GETEVENTS</tt></td>
<td>Wait until at least <tt>min_complete</tt> CQEs are ready before returning.
</td></tr>
<tr>
<td><tt>IORING_ENTER_SQ_WAKEUP</tt></td>
<td>Wake up the kernel thread created when using <tt>IORING_SETUP_SQPOLL</tt>.
</td></tr>
<tr>
<td><tt>IORING_ENTER_SQ_WAIT</tt></td>
<td>Wait until at least one entry is free in the submission ring before returning.
</td></tr>
<tr>
<td><tt>IORING_ENTER_EXT_ARG</tt></td>
<td>(Since Linux 5.11) Interpret <tt>sig</tt> to be a <tt>io_uring_getevents_arg</tt> rather than a pointer to <tt>sigset_t</tt>. This structure can specify both a <tt>sigset_t</tt> and a timeout.
<div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_getevents_arg</span><span> </span><span>{</span>
<span>        </span><span>__u64</span><span>   </span><span>sigmask</span><span>;</span>
<span>        </span><span>__u32</span><span>   </span><span>sigmask_sz</span><span>;</span>
<span>        </span><span>__u32</span><span>   </span><span>pad</span><span>;</span>
<span>        </span><span>__u64</span><span>   </span><span>ts</span><span>;</span>
<span>};</span>
</pre></div>
<p>Is <tt>ts</tt> nanoseconds from now? From the Epoch? Nope! <tt>ns</tt> is actually a <i>pointer</i> to a <tt>__kernel_timespec</tt>, passed to <tt>u64_to_user_ptr()</tt> in the kernel. One of the uglier aspects of uring.
</p>
</td></tr>
<tr>
<td><tt>IORING_ENTER_REGISTERED_RING</tt></td>
<td><tt>ring_fd</tt> is an offset into the registered ring pool rather than a normal file descriptor.
</td></tr>
</tbody></table>
<h2><span id="Setup">Setup</span></h2>
<p>The <tt>io_uring_setup(2)</tt> system call returns a file descriptor, and accepts two parameters, <tt>u32 entries</tt> and <tt>struct io_uring_params *p</tt>:
</p>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_setup</span><span>(</span><span>u32</span><span> </span><span>entries</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_params</span><span> </span><span>*</span><span>p</span><span>);</span>
<span>struct</span><span> </span><span>io_uring_params</span><span> </span><span>{</span><span>                                                                                                            </span>
<span>  </span><span>__u32</span><span> </span><span>sq_entries</span><span>;</span><span>                 </span><span>// number of SQEs, filled by kernel</span>
<span>  </span><span>__u32</span><span> </span><span>cq_entries</span><span>;</span><span>                 </span><span>// see IORING_SETUP_CQSIZE and IORING_SETUP_CLAMP</span>
<span>  </span><span>__u32</span><span> </span><span>flags</span><span>;</span><span>                      </span><span>// see &#34;Flags&#34; below</span>
<span>  </span><span>__u32</span><span> </span><span>sq_thread_cpu</span><span>;</span><span>              </span><span>// see IORING_SETUP_SQ_AFF</span>
<span>  </span><span>__u32</span><span> </span><span>sq_thread_idle</span><span>;</span><span>             </span><span>// see IORING_SETUP_SQPOLL</span>
<span>  </span><span>__u32</span><span> </span><span>features</span><span>;</span><span>                   </span><span>// see &#34;Kernel features&#34; below, filled by kernel</span>
<span>  </span><span>__u32</span><span> </span><span>wq_fd</span><span>;</span><span>                      </span><span>// see IORING_SETUP_ATTACH_WQ</span>
<span>  </span><span>__u32</span><span> </span><span>resv</span><span>[</span><span>3</span><span>];</span><span>                    </span><span>// must be zero</span>
<span>  </span><span>struct</span><span> </span><span>io_sqring_offsets</span><span> </span><span>sq_off</span><span>;</span><span>  </span><span>// see &#34;Ring structure&#34; below, filled by kernel</span>
<span>  </span><span>struct</span><span> </span><span>io_cqring_offsets</span><span> </span><span>cq_off</span><span>;</span><span>  </span><span>// see &#34;Ring structure&#34; below, filled by kernel</span>
<span>};</span>
</pre></div>
<p><tt>resv</tt> must be zeroed out. In the absence of flags, the uring uses interrupt-driven I/O. Calling <tt>close(2)</tt> on the returned descriptor frees all resources associated with the uring.
</p><p><tt>io_uring_setup(2)</tt> is wrapped by liburing&#39;s <tt>io_uring_queue_init(3)</tt> and <tt>io_uring_queue_init_params(3)</tt>. When using these wrappers, <tt>io_uring_queue_exit(3)</tt> should be used to clean up. These wrappers operate on a <tt>struct io_uring</tt>. <tt>io_uring_queue_init(3)</tt> takes an <tt>unsigned flags</tt> argument, which is passed as the <tt>flags</tt> field of <tt>io_uring_params</tt>. <tt>io_uring_queue_init_params(3)</tt> takes a <tt>struct io_uring_params*</tt> argument, which is passed through directly to <tt>io_uring_setup(2)</tt>. It&#39;s best to avoid mixing the low-level API and that provided by liburing.
</p>
<h3><span id="Ring_structure">Ring structure</span></h3>
<p>The details of ring structure are only relevant when using the low-level API, and they are not exposed via liburing. They&#39;re primarily used to prepare the three (or two, see <tt>IORING_FEAT_SINGLE_MMAP</tt>) backing memory maps. You&#39;ll need set these up yourself if you want to use <a href="https://commoncog.com/dankwiki/index.php/Pages" title="Pages">huge pages</a>.
</p>
<div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_sqring_offsets</span><span> </span><span>{</span>
<span>    </span><span>__u32</span><span> </span><span>head</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>tail</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>ring_mask</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>ring_entries</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>flags</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>dropped</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>array</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>resv</span><span>[</span><span>3</span><span>];</span>
<span>};</span>

<span>struct</span><span> </span><span>io_cqring_offsets</span><span> </span><span>{</span>
<span>    </span><span>__u32</span><span> </span><span>head</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>tail</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>ring_mask</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>ring_entries</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>overflow</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>cqes</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>flags</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>resv</span><span>[</span><span>3</span><span>];</span>
<span>};</span>
</pre></div>
<p>As explained in the <tt>io_uring_setup(2)</tt> man page, the submission queue can be mapped thusly:
</p>
<div dir="ltr"><pre><span></span><span>mmap</span><span>(</span><span>0</span><span>,</span><span> </span><span>sq_off</span><span>.</span><span>array</span><span> </span><span>+</span><span> </span><span>sq_entries</span><span> </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>__u32</span><span>),</span><span> </span><span>PROT_READ</span><span>|</span><span>PROT_WRITE</span><span>,</span>
<span>     </span><span>MAP_SHARED</span><span>|</span><span>MAP_POPULATE</span><span>,</span><span> </span><span>ring_fd</span><span>,</span><span> </span><span>IORING_OFF_SQ_RING</span><span>);</span>
</pre></div>
<p>The submission queue contains the internal data structure followed by an array of SQE descriptors. These descriptors are 32 bits each no matter the architecture, implying that they are indices into the SQE map, not pointers. The SQEs are allocated:
</p>
<div dir="ltr"><pre><span></span><span>mmap</span><span>(</span><span>0</span><span>,</span><span> </span><span>sq_entries</span><span> </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span>),</span><span> </span><span>PROT_READ</span><span>|</span><span>PROT_WRITE</span><span>,</span>
<span>     </span><span>MAP_SHARED</span><span>|</span><span>MAP_POPULATE</span><span>,</span><span> </span><span>ring_fd</span><span>,</span><span> </span><span>IORING_OFF_SQES</span><span>);</span>
</pre></div>
<p>and finally the completion queue:
</p>
<div dir="ltr"><pre><span></span><span>mmap</span><span>(</span><span>0</span><span>,</span><span> </span><span>cq_off</span><span>.</span><span>cqes</span><span> </span><span>+</span><span> </span><span>cq_entries</span><span> </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>struct</span><span> </span><span>io_uring_cqe</span><span>),</span><span> </span><span>PROT_READ</span><span>|</span><span>PROT_WRITE</span><span>,</span>
<span>     </span><span>MAP_SHARED</span><span>|</span><span>MAP_POPULATE</span><span>,</span><span> </span><span>ring_fd</span><span>,</span><span> </span><span>IORING_OFF_CQ_RING</span><span>);</span>
</pre></div>
<p>Recall that when the kernel expresses <tt>IORING_FEAT_SINGLE_MMAP</tt>, the submission and completion queues can be allocated in one <tt>mmap(2)</tt> call.
</p>
<h3><span id="Flags">Flags</span></h3>
<p>The <tt>flags</tt> field is set up by the caller, and is a bitmask over:
</p>
<table>
<tbody><tr>
<th>Flag</th>
<th>Kernel version</th>
<th>Description
</th></tr>
<tr>
<td>IORING_SETUP_IOPOLL</td>
<td>5.1</td>
<td>Instruct the kernel to use polled (as opposed to interrupt-driven) I/O. This is intended for block devices, and requires that <tt>O_DIRECT</tt> was provided when the file descriptor was opened.
</td></tr>
<tr>
<td>IORING_SETUP_SQPOLL</td>
<td>5.1 (5.11 for full features)</td>
<td>Create a kernel thread to poll on the submission queue. If the submission queue is kept busy, this thread will reap SQEs without the need for a system call. If enough time goes by without new submissions, the kernel thread goes to sleep, and <tt>io_uring_enter(2)</tt> must be called to wake it.
</td></tr>
<tr>
<td>IORING_SETUP_SQ_AFF</td>
<td>5.1</td>
<td>Only meaningful with <tt>IORING_SETUP_SQPOLL</tt>. The poll thread will be bound to the core specified in <tt>sq_thread_cpu</tt>.
</td></tr>
<tr>
<td>IORING_SETUP_CQSIZE</td>
<td>5.1</td>
<td>Create the completion queue with <tt>cq_entries</tt> entries. This value must be greater than <tt>entries</tt>, and might be rounded up to the next power of 2.
</td></tr>
<tr>
<td>IORING_SETUP_CLAMP</td>
<td>5.1</td>
<td>Clamp <tt>entries</tt> at <tt>IORING_MAX_ENTRIES</tt> and <tt>cq_entries</tt> at <tt>IORING_MAX_CQ_ENTRIES</tt>.
</td></tr>
<tr>
<td>IORING_SETUP_ATTACH_WQ</td>
<td>5.1</td>
<td>Specify a uring in <tt>wq_fd</tt>, and the new uring will share that uring&#39;s worker thread backend.
</td></tr>
<tr>
<td>IORING_SETUP_R_DISABLED</td>
<td>5.10</td>
<td>Start the uring disabled, requiring that it be enabled with <tt>io_uring_register(2)</tt>.
</td></tr>
<tr>
<td>IORING_SETUP_SUBMIT_ALL</td>
<td>5.18</td>
<td>Continue submitting SQEs from a batch even after one results in error.
</td></tr>
<tr>
<td>IORING_SETUP_COOP_TASKRUN</td>
<td>5.19</td>
<td>Don&#39;t interrupt userspace processes to indicate CQE availability. It&#39;s usually desirable to allow events to be processed at arbitrary kernelspace transitions, in which case this flag can be provided to improve performance.
</td></tr>
<tr>
<td>IORING_SETUP_TASKRUN_FLAG</td>
<td>5.19</td>
<td>Requires <tt>IORING_SETUP_COOP_TASKRUN</tt>. When completions are pending awaiting processing, the <tt>IORING_SQ_TASKRUN</tt> flag will be set in the submission ring. This will be checked by <tt>io_uring_peek_cqe()</tt>, which will enter the kernel to process them.
</td></tr>
<tr>
<td>IORING_SETUP_SQE128</td>
<td>5.19</td>
<td>Use 128-byte SQEs, necessary for NVMe passthroughs using <tt>IORING_OP_URING_CMD</tt>.
</td></tr>
<tr>
<td>IORING_SETUP_CQE32</td>
<td>5.19</td>
<td>Use 32-byte CQEs, necessary for NVMe passthroughs using <tt>IORING_OP_URING_CMD</tt>.
</td></tr>
<tr>
<td>IORING_SETUP_SINGLE_ISSUER</td>
<td>6.0</td>
<td>Hint to the kernel that only a single thread will submit requests, allowing for optimizations. This thread must either be the thread which created the ring, or (iff <tt>IORING_SETUP_R_DISABLED</tt> is used) the thread which enables the ring.
</td></tr>
<tr>
<td>IORING_SETUP_DEFER_TASKRUN</td>
<td>6.1</td>
<td>Requires <tt>IORING_SETUP_SINGLE_ISSUER</tt>. Don&#39;t process completions at arbitrary kernel/scheduler transitions, but only <tt>io_uring_enter(2)</tt> when called with <tt>IORING_ENTER_GETEVENTS</tt> by the thread that submitted the SQEs.
</td></tr>
</tbody></table>
<p>When <tt>IORING_SETUP_R_DISABLED</tt> is used, the ring must be enabled before submissions can take place. If using the liburing API, this is done via <tt>io_uring_enable_rings(3)</tt>:
</p>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_enable_rings</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>);</span><span> </span><span>// liburing 2.4</span>
</pre></div>
<h3><span id="Kernel_features">Kernel features</span></h3>
<p>Various functionality was added to the kernel following the initial release of uring, and thus not necessarily available to all kernels supporting the basic system calls. The <tt>__u32 features</tt> field of the <tt>io_uring_params</tt> parameter to <tt>io_uring_setup(2)</tt> is filled in with feature flags by the kernel, a bitmask over:
</p>
<table>
<tbody><tr>
<th>Feature</th>
<th>Kernel version</th>
<th>Description
</th></tr>
<tr>
<td><tt>IORING_FEAT_SINGLE_MMAP</tt></td>
<td>5.4</td>
<td>A single <tt>mmap(2)</tt> can be used for both the submission and completion rings.
</td></tr>
<tr>
<td><tt>IORING_FEAT_NODROP</tt></td>
<td>5.5 (5.19 for full features)</td>
<td>Completion queue events are not dropped. Instead, submitting results in <tt>-EBUSY</tt> until completion reaping yields sufficient room for the overflows. As of 5.19, <tt>io_uring_enter(2)</tt> furthermore returns <tt>-EBADR</tt> rather than waiting for completions.
</td></tr>
<tr>
<td><tt>IORING_FEAT_SUBMIT_STABLE</tt></td>
<td>5.5</td>
<td>Data submitted for async can be mutated following submission, rather than only following completion.
</td></tr>
<tr>
<td><tt>IORING_FEAT_RW_CUR_POS</tt></td>
<td>5.6</td>
<td>Reading and writing can provide -1 for <tt>offset</tt> to indicate the current file position.
</td></tr>
<tr>
<td><tt>IORING_FEAT_CUR_PERSONALITY</tt></td>
<td>5.6</td>
<td>Assume the credentials of the thread calling <tt>io_uring_enter(2)</tt>, rather than the thread which created the uring. Registered personalities can always be used.
</td></tr>
<tr>
<td><tt>IORING_FEAT_FAST_POLL</tt></td>
<td>5.7</td>
<td>Internal polling for data/space readiness is supported.
</td></tr>
<tr>
<td><tt>IORING_FEAT_POLL_32BITS</tt></td>
<td>5.9</td>
<td><tt>IORING_OP_POLL_ADD</tt> accepts all <a href="https://commoncog.com/dankwiki/index.php/Epoll" title="Epoll">epoll</a> flags, including <tt>EPOLLEXCLUSIVE</tt>.
</td></tr>
<tr>
<td><tt>IORING_FEAT_SQPOLL_NONFIXED</tt></td>
<td>5.11</td>
<td><tt>IORING_SETUP_SQPOLL</tt> doesn&#39;t require registered files.
</td></tr>
<tr>
<td><tt>IORING_FEAT_ENTER_EXT_ARG</tt></td>
<td>5.11</td>
<td><tt>io_uring_enter(2)</tt> supports <tt>struct io_uring_getevents_arg</tt>.
</td></tr>
<tr>
<td><tt>IORING_FEAT_NATIVE_WORKERS</tt></td>
<td>5.12</td>
<td>Async helpers use native workers rather than kernel threads.
</td></tr>
<tr>
<td><tt>IORING_FEAT_RSRC_TAGS</tt></td>
<td>5.13</td>
<td>Registered buffers can be updated <i>in partes</i> rather than <i>in toto</i>.
</td></tr>
<tr>
<td><tt>IORING_FEAT_CQE_SKIP</tt></td>
<td>5.17</td>
<td><tt>IOSQE_CQE_SKIP_SUCCESS</tt> can be used to inhibit CQE generation on success.
</td></tr>
<tr>
<td><tt>IORING_FEAT_LINKED_FILE</tt></td>
<td>5.17</td>
<td>Defer file assignment until execution of a given request begins.
</td></tr>
</tbody></table>
<h3><span id="Registered_resources">Registered resources</span></h3>
<h4><span id="Buffers">Buffers</span></h4>
<p>Since Linux 5.7, user-allocated memory can be provided to uring in groups of buffers (each with a group ID), in which each buffer has its own ID. This was done with the <tt>io_uring_prep_provide_buffers(3)</tt> call, operating on an SQE. Since 5.19, the &#34;ringmapped buffers&#34; technique (<tt>io_uring_register_buf_ring(3)</tt>) allows these buffers to be used much more effectively.
</p>
<table>
<tbody><tr>
<th>Flag</th>
<th>Kernel</th>
<th>Description
</th></tr>
<tr>
<td><tt>IORING_REGISTER_BUFFERS</tt></td>
<td>5.1</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_UNREGISTER_BUFFERS</tt></td>
<td>5.1</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_BUFFERS2</tt></td>
<td>5.13</td>
<td><div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_rsrc_register</span><span> </span><span>{</span>
<span>    </span><span>__u32</span><span> </span><span>nr</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>resv</span><span>;</span>
<span>    </span><span>__u64</span><span> </span><span>resv2</span><span>;</span>
<span>    </span><span>__aligned_u64</span><span> </span><span>data</span><span>;</span>
<span>    </span><span>__aligned_u64</span><span> </span><span>tags</span><span>;</span>
<span>};</span>
</pre></div>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_BUFFERS_UPDATE</tt></td>
<td>5.13</td>
<td><div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_rsrc_update2</span><span> </span><span>{</span>
<span>    </span><span>__u32</span><span> </span><span>offset</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>resv</span><span>;</span>
<span>    </span><span>__aligned_u64</span><span> </span><span>data</span><span>;</span>
<span>    </span><span>__aligned_u64</span><span> </span><span>tags</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>nr</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>resv2</span><span>;</span><span>    </span>
<span>};</span>
</pre></div>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_PBUF_RING</tt></td>
<td>5.19</td>
<td><div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_buf_reg</span><span> </span><span>{</span>
<span>    </span><span>__u64</span><span> </span><span>ring_addr</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>ring_entries</span><span>;</span>
<span>    </span><span>__u16</span><span> </span><span>bgid</span><span>;</span>
<span>    </span><span>__u16</span><span> </span><span>pad</span><span>;</span>
<span>    </span><span>__u64</span><span> </span><span>resv</span><span>[</span><span>3</span><span>];</span>
<span>};</span>
</pre></div>
</td></tr>
<tr>
<td><tt>IORING_UNREGISTER_PBUF_RING</tt></td>
<td>5.19</td>
<td>
</td></tr>
</tbody></table>
<h4><span id="Registered_files">Registered files</span></h4>
<p>Registered (sometimes &#34;direct&#34;) descriptors are integers corresponding to private file handle structures internal to the uring, and can be used anywhere uring wants a file descriptor through the <tt>IOSQE_FIXED_FILE</tt> flag. They have less overhead than true file descriptors, which use structures shared among threads. Note that registered files are required for submission queue polling unless the <tt>IORING_FEAT_SQPOLL_NONFIXED</tt> feature flag was returned. Registered files can be passed between rings using <tt>io_uring_prep_msg_ring_fd(3)</tt>.
</p>
<table>
<tbody><tr>
<th>Flag</th>
<th>Kernel</th>
<th>Description
</th></tr>
<tr>
<td><tt>IORING_REGISTER_FILES</tt></td>
<td>5.1</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_UNREGISTER_FILES</tt></td>
<td>5.1</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_FILES2</tt></td>
<td>5.13</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_FILES_UPDATE</tt></td>
<td>5.5 (5.12 for all features)</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_FILES_UPDATE2</tt></td>
<td>5.13</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_REGISTER_FILE_ALLOC_RANGE</tt></td>
<td>6.0</td>
<td><div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_file_index_range</span><span> </span><span>{</span>
<span>    </span><span>__u32</span><span> </span><span>off</span><span>;</span>
<span>    </span><span>__u32</span><span> </span><span>len</span><span>;</span>
<span>    </span><span>__u64</span><span> </span><span>resv</span><span>;</span>
<span>};</span>
</pre></div>
</td></tr>
</tbody></table>
<h4><span id="Personalities">Personalities</span></h4>
<table>
<tbody><tr>
<th>Flag</th>
<th>Kernel</th>
<th>Description
</th></tr>
<tr>
<td><tt>IORING_REGISTER_PERSONALITY</tt></td>
<td>5.6</td>
<td>
</td></tr>
<tr>
<td><tt>IORING_UNREGISTER_PERSONALITY</tt></td>
<td>5.6</td>
<td>
</td></tr>
</tbody></table>
<h2><span id="Submitting_work">Submitting work</span></h2>
<p>Submitting work consists of four steps:
</p>
<ul><li>Acquiring free SQEs</li>
<li>Filling in those SQEs</li>
<li>Placing those SQEs at the tail of the submission queue</li>
<li>Submitting the work, possibly using a system call</li></ul>
<h3><span id="The_SQE_structure">The SQE structure</span></h3>
<p><tt>struct io_uring_sqe</tt> has several large <tt>union</tt>s which I won&#39;t reproduce in full here; consult <tt>liburing.h</tt> if you want the details. The instructive elements include:
</p>
<div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>{</span><span>                                                                                                               </span>
<span>  </span><span>__u8</span><span>  </span><span>opcode</span><span>;</span><span>   </span><span>/* type of operation for this sqe */</span><span>                                                                              </span>
<span>  </span><span>__u8</span><span>  </span><span>flags</span><span>;</span><span>    </span><span>/* IOSQE_ flags */</span><span>                                                                                                </span>
<span>  </span><span>__u16</span><span> </span><span>ioprio</span><span>;</span><span>   </span><span>/* ioprio for the request */</span><span>                                                                                      </span>
<span>  </span><span>__s32</span><span> </span><span>fd</span><span>;</span><span>   </span><span>/* file descriptor to do IO on */</span><span>   </span>
<span>  </span><span>...</span><span> </span><span>various</span><span> </span><span>unions</span><span> </span><span>for</span><span> </span><span>representing</span><span> </span><span>the</span><span> </span><span>request</span><span> </span><span>details</span><span> </span><span>...</span>
<span>};</span>
</pre></div>
<p>Flags can be set on a per-SQE basis using <tt>io_uring_sqe_set_flags(3)</tt>, or writing to the <tt>flags</tt> field directly:
</p>
<div dir="ltr"><pre><span></span><span>static</span><span> </span><span>inline</span>
<span>void</span><span> </span><span>io_uring_sqe_set_flags</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>){</span><span>                                                                                                                                   </span>
<span>  </span><span>sqe</span><span>-&gt;</span><span>flags</span><span> </span><span>=</span><span> </span><span>(</span><span>__u8</span><span>)</span><span> </span><span>flags</span><span>;</span>
<span>}</span>
</pre></div>
<p>The flags are a bitfield over:
</p>
<table>
<tbody><tr>
<th>SQE flag</th>
<th>Description
</th></tr>
<tr>
<td><tt>IOSQE_FIXED_FILE</tt></td>
<td>References a registered descriptor.
</td></tr>
<tr>
<td><tt>IOSQE_IO_DRAIN</tt></td>
<td>Issue after in-flight I/O.
</td></tr>
<tr>
<td><tt>IOSQE_IO_LINK</tt></td>
<td>Links next SQE.
</td></tr>
<tr>
<td><tt>IOSQE_IO_HARDLINK</tt></td>
<td>Same as <tt>IOSQE_IO_HARDLINK</tt>, but a failure does not sever the chain.
</td></tr>
<tr>
<td><tt>IOSQE_ASYNC</tt></td>
<td>Always operate asynchronously.
</td></tr>
<tr>
<td><tt>IOSQE_BUFFER_SELECT</tt></td>
<td>Use a registered buffer.
</td></tr>
<tr>
<td><tt>IOSQE_CQE_SKIP_SUCCESS</tt></td>
<td>Don&#39;t post a CQE on success.
</td></tr>
</tbody></table>
<h3><span id="Prepping_SQEs">Prepping SQEs</span></h3>
<p>Each SQE must be seeded with the object upon which it acts (usually a file descriptor) and any necessary arguments. You&#39;ll usually also use the user data area.
</p>
<h4><span id="User_data">User data</span></h4>
<p>Each SQE provides 64 bits of user-controlled data which will be copied through to any generated CQEs. Since CQEs don&#39;t include the relevant file descriptor, you&#39;ll almost always be encoding some kind of lookup information into this area.
</p>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_sqe_set_data</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>user_data</span><span>);</span>
<span>void</span><span> </span><span>io_uring_sqe_set_data64</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>__u64</span><span> </span><span>data</span><span>);</span>
<span>void</span><span> </span><span>*</span><span>io_uring_cqe_get_data</span><span>(</span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>*</span><span>cqe</span><span>);</span>
<span>__u64</span><span> </span><span>io_uring_cqe_get_data64</span><span>(</span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>*</span><span>cqe</span><span>);</span>
</pre></div>
<p>Here&#39;s an example C++ data type that encodes eight bits as an operation type, eight bits as an index, and forty-eight bits as other data. I typically use something like this to reflect the operation which was used, the index into some relevant data structure, and other information about the operation (perhaps an offset or a length):
</p>
<div dir="ltr"><pre><span></span><span>union</span><span> </span><span>URingCtx</span><span> </span><span>{</span>
<span>  </span><span>struct</span><span> </span><span>rep</span><span> </span><span>{</span>
<span>    </span><span>rep</span><span>(</span><span>uint8_t</span><span> </span><span>op</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>ix</span><span>,</span><span> </span><span>uint64_t</span><span> </span><span>d</span><span>)</span><span>:</span>
<span>      </span><span>type</span><span>(</span><span>static_cast</span><span>&lt;</span><span>URingCtx</span><span>::</span><span>rep</span><span>::</span><span>optype</span><span>&gt;</span><span>(</span><span>op</span><span>)),</span><span> </span><span>idx</span><span>(</span><span>ix</span><span>),</span><span> </span><span>data</span><span>(</span><span>d</span><span>)</span><span>                                                                                                                       </span>
<span>    </span><span>{</span>
<span>      </span><span>if</span><span>(</span><span>type</span><span> </span><span>&gt;=</span><span> </span><span>MAXOP</span><span>){</span>
<span>        </span><span>throw</span><span> </span><span>std</span><span>::</span><span>invalid_argument</span><span>(</span><span>&#34;bad uringctx op&#34;</span><span>);</span>
<span>      </span><span>}</span>
<span>      </span><span>if</span><span>(</span><span>ix</span><span> </span><span>&gt;</span><span> </span><span>MAXIDX</span><span>){</span>
<span>        </span><span>throw</span><span> </span><span>std</span><span>::</span><span>invalid_argument</span><span>(</span><span>&#34;bad uringctx index&#34;</span><span>);</span>
<span>      </span><span>}</span>
<span>      </span><span>if</span><span>(</span><span>d</span><span> </span><span>&gt;</span><span> </span><span>0xffffffffffffull</span><span>){</span>
<span>        </span><span>throw</span><span> </span><span>std</span><span>::</span><span>invalid_argument</span><span>(</span><span>&#34;bad uringctx data&#34;</span><span>);</span>
<span>      </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>enum</span><span> </span><span>optype</span><span>:</span><span> </span><span>uint8_t</span><span> </span><span>{</span>
<span>      </span><span>...</span><span>app</span><span>-</span><span>specific</span><span> </span><span>types</span><span>...</span>
<span>      </span><span>MAXOP</span><span>      </span><span>// shouldn&#39;t be used</span>
<span>    </span><span>}</span><span> </span><span>type</span><span>:</span><span> </span><span>8</span><span>;</span>
<span>    </span><span>uint8_t</span><span> </span><span>idx</span><span>:</span><span> </span><span>8</span><span>;</span>
<span>    </span><span>uint64_t</span><span> </span><span>data</span><span>:</span><span> </span><span>48</span><span>;</span>
<span>  </span><span>}</span><span> </span><span>r</span><span>;</span>
<span>  </span><span>uint64_t</span><span> </span><span>val</span><span>;</span>
<span>  </span><span>static</span><span> </span><span>constexpr</span><span> </span><span>auto</span><span> </span><span>MAXIDX</span><span> </span><span>=</span><span> </span><span>255u</span><span>;</span>
<span>  </span><span>URingCtx</span><span>(</span><span>uint8_t</span><span> </span><span>op</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>idx</span><span>,</span><span> </span><span>uint64_t</span><span> </span><span>d</span><span>)</span><span>:</span>
<span>    </span><span>r</span><span>(</span><span>op</span><span>,</span><span> </span><span>idx</span><span>,</span><span> </span><span>d</span><span>)</span>
<span>  </span><span>{}</span>
<span>  </span><span>URingCtx</span><span>(</span><span>uint64_t</span><span> </span><span>v</span><span>)</span><span>:</span>
<span>    </span><span>URingCtx</span><span>(</span><span>v</span><span> </span><span>&amp;</span><span> </span><span>0xffu</span><span>,</span><span> </span><span>(</span><span>v</span><span> </span><span>&gt;&gt;</span><span> </span><span>8</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0xffu</span><span>,</span><span> </span><span>v</span><span> </span><span>&gt;&gt;</span><span> </span><span>16</span><span>)</span>
<span>  </span><span>{}</span>
<span>};</span>
</pre></div>
<p>The majority of I/O-related system calls have by now a uring equivalent (the one major exception of which I&#39;m aware is directory listing; there seems to be no <tt>readdir(3)</tt>/<tt>getdents(2)</tt>). What follows is an incomplete list.
</p>
<h4><span id="Opening_and_closing_file_descriptors">Opening and closing file descriptors</span></h4>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_prep_openat</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span>
<span>                          </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>mode_t</span><span> </span><span>mode</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_openat_direct</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span>
<span>                                 </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>mode_t</span><span> </span><span>mode</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>file_index</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_openat2</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span>
<span>                           </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>struct</span><span> </span><span>open_how</span><span> </span><span>*</span><span>how</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_openat2_direct</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span>
<span>                                  </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>struct</span><span> </span><span>open_how</span><span> </span><span>*</span><span>how</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>file_index</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_accept</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>struct</span><span> </span><span>sockaddr</span><span> </span><span>*</span><span>addr</span><span>,</span>
<span>                          </span><span>socklen_t</span><span> </span><span>*</span><span>addrlen</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_accept_direct</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>struct</span><span> </span><span>sockaddr</span><span> </span><span>*</span><span>addr</span><span>,</span>
<span>                                 </span><span>socklen_t</span><span> </span><span>*</span><span>addrlen</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>file_index</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_multishot_accept</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>struct</span><span> </span><span>sockaddr</span><span> </span><span>*</span><span>addr</span><span>,</span>
<span>                                    </span><span>socklen_t</span><span> </span><span>*</span><span>addrlen</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_multishot_accept_direct</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>struct</span><span> </span><span>sockaddr</span><span> </span><span>*</span><span>addr</span><span>,</span>
<span>                                           </span><span>socklen_t</span><span> </span><span>*</span><span>addrlen</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_close</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_close_direct</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>file_index</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_socket</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>domain</span><span>,</span><span> </span><span>int</span><span> </span><span>type</span><span>,</span><span>                                                           </span>
<span>                          </span><span>int</span><span> </span><span>protocol</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span><span>                                                                        </span>
<span>void</span><span> </span><span>io_uring_prep_socket_direct</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>domain</span><span>,</span><span> </span><span>int</span><span> </span><span>type</span><span>,</span><span>                                                    </span>
<span>                                 </span><span>int</span><span> </span><span>protocol</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>file_index</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span><span>                                        </span>
<span>void</span><span> </span><span>io_uring_prep_socket_direct_alloc</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>domain</span><span>,</span><span> </span><span>int</span><span> </span><span>type</span><span>,</span><span>                                              </span>
<span>                                       </span><span>int</span><span> </span><span>protocol</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
</pre></div>
<h4><span id="Reading_and_writing_file_descriptors">Reading and writing file descriptors</span></h4>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_prep_send</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>const</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>len</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_send_zc</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>const</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>len</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>int</span><span> </span><span>zc_flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_sendmsg</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>msghdr</span><span> </span><span>*</span><span>msg</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_sendmsg_zc</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>msghdr</span><span> </span><span>*</span><span>msg</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_recv</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>len</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_recv_multishot</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>len</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_recvmsg</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>struct</span><span> </span><span>msghdr</span><span> </span><span>*</span><span>msg</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_recvmsg_multishot</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>struct</span><span> </span><span>msghdr</span><span> </span><span>*</span><span>msg</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_read</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>nbytes</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_read_fixed</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>nbytes</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>,</span><span> </span><span>int</span><span> </span><span>buf_index</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_readv</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>iovec</span><span> </span><span>*</span><span>iovecs</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>nr_vecs</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_readv2</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>iovec</span><span> </span><span>*</span><span>iovecs</span><span>,</span>
<span>                          </span><span>unsigned</span><span> </span><span>nr_vecs</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_shutdown</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>sockfd</span><span>,</span><span> </span><span>int</span><span> </span><span>how</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_splice</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd_in</span><span>,</span><span> </span><span>int64_t</span><span> </span><span>off_in</span><span>,</span><span> </span><span>int</span><span> </span><span>fd_out</span><span>,</span>
<span>                          </span><span>int64_t</span><span> </span><span>off_out</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>nbytes</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>splice_flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_sync_file_range</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>len</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_tee</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd_in</span><span>,</span><span> </span><span>int</span><span> </span><span>fd_out</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>nbytes</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>splice_flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_write</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>nbytes</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_write_fixed</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>void</span><span> </span><span>*</span><span>buf</span><span>,</span>
<span>                               </span><span>unsigned</span><span> </span><span>nbytes</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>,</span><span> </span><span>int</span><span> </span><span>buf_index</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_writev</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>iovec</span><span> </span><span>*</span><span>iovecs</span><span>,</span>
<span>                          </span><span>unsigned</span><span> </span><span>nr_vecs</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_writev2</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>iovec</span><span> </span><span>*</span><span>iovecs</span><span>,</span>
<span>                           </span><span>unsigned</span><span> </span><span>nr_vecs</span><span>,</span><span> </span><span>__u64</span><span> </span><span>offset</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
</pre></div>
<h4><span id="Manipulating_directories">Manipulating directories</span></h4>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_prep_fsync</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_linkat</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>olddirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>oldpath</span><span>,</span>
<span>                          </span><span>int</span><span> </span><span>newdirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>newpath</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_link</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>oldpath</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>newpath</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_mkdirat</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span><span> </span><span>mode_t</span><span> </span><span>mode</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_mkdir</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span><span> </span><span>mode_t</span><span> </span><span>mode</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_rename</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>oldpath</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>newpath</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_renameat</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>olddirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>oldpath</span><span>,</span>
<span>                            </span><span>int</span><span> </span><span>newdirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>newpath</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_statx</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>,</span>
<span>                         </span><span>unsigned</span><span> </span><span>mask</span><span>,</span><span> </span><span>struct</span><span> </span><span>statx</span><span> </span><span>*</span><span>statxbuf</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_symlink</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>target</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>linkpath</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_symlinkat</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>target</span><span>,</span><span> </span><span>int</span><span> </span><span>newdirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>linkpath</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_unlinkat</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>dirfd</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_unlink</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>path</span><span>,</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
</pre></div>
<h4><span id="Timeouts_and_polling">Timeouts and polling</span></h4>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_prep_poll_add</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>poll_mask</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_poll_multishot</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>poll_mask</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_poll_remove</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>__u64</span><span> </span><span>user_data</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_poll_update</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>__u64</span><span> </span><span>old_user_data</span><span>,</span><span> </span><span>__u64</span><span> </span><span>new_user_data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>poll_mask</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_timeout</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>struct</span><span> </span><span>__kernel_timespec</span><span> </span><span>*</span><span>ts</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>count</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_timeout_update</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>struct</span><span> </span><span>__kernel_timespec</span><span> </span><span>*</span><span>ts</span><span>,</span><span> </span><span>__u64</span><span> </span><span>user_data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_timeout_remove</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>__u64</span><span> </span><span>user_data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>flags</span><span>);</span>
</pre></div>
<h4><span id="Interring_communication">Interring communication</span></h4>
<p>All interring messages are prepared using the target uring&#39;s file descriptor, and thus aren&#39;t particularly compatible with the higher-level liburing API. That&#39;s unfortunate, because this functionality is very useful in a multithreaded environment. Note that the ring to which the SQE is submitted can itself be the target of the message!
</p>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_prep_msg_ring</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>len</span><span>,</span><span> </span><span>__u64</span><span> </span><span>data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_msg_ring_cqe_flags</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>len</span><span>,</span><span> </span><span>__u64</span><span> </span><span>data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>cqe_flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_msg_ring_fd</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>int</span><span> </span><span>source_fd</span><span>,</span><span> </span><span>int</span><span> </span><span>target_fd</span><span>,</span><span> </span><span>__u64</span><span> </span><span>data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
<span>void</span><span> </span><span>io_uring_prep_msg_ring_fd_alloc</span><span>(</span><span>struct</span><span> </span><span>io_uring_sqe</span><span> </span><span>*</span><span>sqe</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>,</span><span> </span><span>int</span><span> </span><span>source_fd</span><span>,</span><span> </span><span>__u64</span><span> </span><span>data</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>flags</span><span>);</span>
</pre></div>
<h3><span id="Linked_operations">Linked operations</span></h3>
<p><tt>IOSQE_IO_LINK</tt> (since 5.3) or <tt>IOSQE_IO_HARDLINK</tt> (since 5.5) can be supplied in the <tt>flags</tt> field of an SQE to link with the next SQE. The chain can be arbitrarily long (though it cannot cross submission boundaries), terminating in the first linked SQE without this flag set. Multiple chains can execute in parallel on the kernel side. Unless <tt>HARDLINK</tt> is used, any error terminates a chain; any remaining linked SQEs will be immediately cancelled (short reads/writes are considered errors) with return code <tt>-ECANCELED</tt>.
</p>
<h3><span id="Sending_it_to_the_kernel">Sending it to the kernel</span></h3>
<p>If <tt>IORING_SETUP_SQPOLL</tt> was provided when creating the uring, a thread was spawned to poll the submission queue. If the thread is awake, there is no need to make a system call; the kernel will ingest the SQE as soon as it is written (<tt>io_uring_submit(3)</tt> still must be used, but no system call will be made). This thread goes to sleep after <tt>sq_thread_idle</tt> milliseconds idle, in which case <tt>IORING_SQ_NEED_WAKEUP</tt> will be written to the <tt>flags</tt> field of the submission ring.
</p>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_submit</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>);</span>
<span>int</span><span> </span><span>io_uring_submit_and_wait</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>wait_nr</span><span>);</span>
<span>int</span><span> </span><span>io_uring_submit_and_wait_timeout</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>wait_nr</span><span>,</span>
<span>                                     </span><span>struct</span><span> </span><span>__kernel_timespec</span><span> </span><span>*</span><span>ts</span><span>,</span><span> </span><span>sigset_t</span><span> </span><span>*</span><span>sigmask</span><span>);</span>
</pre></div>
<p>All of these liburing functions call the internal functions <tt>__io_uring_flush_sq()</tt> and <tt>__io_uring_submit()</tt>. The former updates the ring tail with a release-semantics write, while the latter calls <tt>io_uring_enter()</tt> if necessary. Note that timeouts are implemented internally using a SQE, and thus will kick off work if the submission ring is full pursuant to acquiring the entry.
</p>
<h4><span id="Submission_queue_polling_details">Submission queue polling details</span></h4>
<p>Using <tt>IORING_SETUP_SQPOLL</tt> will, by default, create two threads in your process, one named <tt>iou-sqp-TID</tt>, and the other named <tt>iou-wrk-TID</tt>. The former is created the first time work is submitted. The latter is created whenever the uring is enabled (i.e. at creation time, unless <tt>IORING_SETUP_R_DISABLED</tt> is used). Submission queue poll threads can be shared between urings via <tt>IORING_SETUP_ATTACH_WQ</tt> together with the <tt>wq_fd</tt> field of <tt>io_uring_params</tt>.
</p><p>These threads will be started with the same cgroup, CPU affinities, etc. as the calling thread, so watch out if you&#39;ve already bound your thread to some CPU! You will now be competing with the poller threads for those CPUs&#39; cycles, and if you&#39;re all on a single core, things will not go well.
</p>
<h2><span id="Reaping_completions">Reaping completions</span></h2>
<p>Submitted actions result in completion events:
</p>
<div dir="ltr"><pre><span></span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>{</span>
<span>  </span><span>__u64</span><span> </span><span>user_data</span><span>;</span><span>  </span><span>/* sqe-&gt;data submission passed back */</span>
<span>  </span><span>__s32</span><span> </span><span>res</span><span>;</span><span>    </span><span>/* result code for this event */</span>
<span>  </span><span>__u32</span><span> </span><span>flags</span><span>;</span>

<span>  </span><span>/*</span>
<span>   * If the ring is initialized with IORING_SETUP_CQE32, then this field</span>
<span>   * contains 16-bytes of padding, doubling the size of the CQE.</span>
<span>   */</span>
<span>  </span><span>__u64</span><span> </span><span>big_cqe</span><span>[];</span>
<span>};</span>
</pre></div>
<p>Recall that rather than using <tt>errno</tt>, errors are returned as their negative value in <tt>res</tt>.
</p>
<table>
<tbody><tr>
<th>CQE flag</th>
<th>Description
</th></tr>
<tr>
<td><tt>IORING_CQE_F_BUFFER</tt></td>
<td>If set, upper 16 bits of <tt>flags</tt> is the buffer ID
</td></tr>
<tr>
<td><tt>IORING_CQE_F_MORE</tt></td>
<td>The associated multishot SQE will generate more entries
</td></tr>
<tr>
<td><tt>IORING_CQE_F_SOCK_NONEMPTY</tt></td>
<td>There&#39;s more data to receive after this read
</td></tr>
<tr>
<td><tt>IORING_CQE_F_NOTIF</tt></td>
<td>Notification CQE for zero-copy sends
</td></tr>
</tbody></table>
<p>Completions can be detected by four different means:
</p>
<ul><li>Checking the completion queue speculatively. This either means a periodic check, which will suffer latency up to the period, or a busy check, which will churn CPU, but is probably the lowest-latency solution. This is best accomplished with <tt>io_uring_peek_cqe(3)</tt>, perhaps in conjunction with <tt>io_uring_cq_ready(3)</tt> (neither involves a system call).</li></ul>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_peek_cqe</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>);</span>
<span>unsigned</span><span> </span><span>io_uring_cq_ready</span><span>(</span><span>const</span><span> </span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>);</span>
</pre></div>
<ul><li>Waiting on the ring via kernel sleep. Use <tt>io_uring_wait_cqe(3)</tt> (unbounded sleep), <tt>io_uring_wait_cqe_timeout(3)</tt> (bounded sleep), or <tt>io_uring_wait_cqes(3)</tt> (bounded sleep with atomic signal blocking and batch receive). These do not require a system call if they can be immediately satisfied.</li></ul>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_wait_cqe</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>);</span>
<span>int</span><span> </span><span>io_uring_wait_cqe_nr</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>wait_nr</span><span>);</span>
<span>int</span><span> </span><span>io_uring_wait_cqe_timeout</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>,</span>
<span>                       </span><span>struct</span><span> </span><span>__kernel_timespec</span><span> </span><span>*</span><span>ts</span><span>);</span>
<span>int</span><span> </span><span>io_uring_wait_cqes</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>wait_nr</span><span>,</span>
<span>                       </span><span>struct</span><span> </span><span>__kernel_timespec</span><span> </span><span>*</span><span>ts</span><span>,</span><span> </span><span>sigset_t</span><span> </span><span>*</span><span>sigmask</span><span>);</span>
<span>int</span><span> </span><span>io_uring_peek_cqe</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>**</span><span>cqe_ptr</span><span>);</span>
</pre></div>
<ul><li>Using an <a href="https://commoncog.com/dankwiki/index.php/Eventfd" title="Eventfd">eventfd</a> together with <tt>io_uring_register_eventfd(3)</tt>. See below for the full API. This eventfd can be combined with e.g. regular <a href="https://commoncog.com/dankwiki/index.php/Epoll" title="Epoll">epoll</a>.</li>
<li>Using processor-dependent memory watch instructions. On x86, there&#39;s MONITOR+MWAIT, but they require you to be in ring 0, so you&#39;d probably want UMONITOR/UMWAIT. This ought allow a very low-latency wake that consumes very little power.</li></ul>
<p>Once the CQE can be returned to the system, do so with <tt>io_uring_cqe_seen(3)</tt>, or batch it with <tt>io_uring_cq_advance(3)</tt> (the former can mark cq entries as seen out of order).
</p>
<div dir="ltr"><pre><span></span><span>void</span><span> </span><span>io_uring_cqe_seen</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>struct</span><span> </span><span>io_uring_cqe</span><span> </span><span>*</span><span>cqe</span><span>);</span>
<span>void</span><span> </span><span>io_uring_cq_advance</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>nr</span><span>);</span>
</pre></div>
<h3><span id="Multishot">Multishot</span></h3>
<p>It is possible for a single submission to result in multiple completions (e.g. <tt>io_uring_prep_multishot_accept(3)</tt>); this is known as <i>multishot</i>. Errors on a multishot SQE will typically terminate the work request; a multishot SQE will set <tt>IORING_CQE_F_MORE</tt> high in generated CQEs so long as it remains active. A CQE without this flag indicates that the multishot is no longer operational, and must be reposted if further events are desired.
</p>
<h2><span id="Corner_cases">Corner cases</span></h2>
<h3><span id="Single_fd_in_multiple_rings">Single fd in multiple rings</span></h3>
<p>If logically equivalent SQEs are submitted to different rings, only one operation seems to take place when logical. For instance, if two rings have the same socket added for an <tt>accept(2)</tt>, a successful three-way <a href="https://commoncog.com/dankwiki/index.php/TCP" title="TCP">TCP</a> handshake will generate only one CQE, on one of the two rings. Which ring sees the event might be different from connection to connection.
</p>
<h3><span id="Multithreaded_use">Multithreaded use</span></h3>
<p>urings (and especially the <tt>struct io_uring</tt> object of liburing) are <a rel="nofollow" href="https://github.com/axboe/liburing/issues/850#issuecomment-1526163360">not intended for multithreaded use</a> (quoth Axboe, &#34;don&#39;t share a ring between threads&#34;), though they can be used in several threaded paradigms. A single thread submitting and a single thread reaping is definitely supported. Descriptors can be sent among rings with <tt>IORING_OP_MSG_RING</tt>. Multiple submitters definitely must be serialized in userspace.
</p><p>If an op will be completed via a kernel task, the thread that submitted that SQE must remain alive until the op&#39;s completion. It will otherwise error out with <tt>-ECANCELED</tt>. If you must submit the SQE from a thread which will die, consider creating it disabled (see <tt>IORING_SETUP_R_DISABLED</tt>), and enabling it from the thread which will reap the completion event using <tt>IORING_REGISTER_ENABLE_RINGS</tt> with <tt>io_uring_register(2)</tt>.
</p><p>If you can restrict all submissions (<i>and</i> creation/enabling of the uring) to a single thread, use <tt>IORING_SETUP_SINGLE_ISSUER</tt> to enable kernel optimizations. Otherwise, consider using <tt>io_uring_register_ring_fd(3)</tt> (or <tt>io_uring_register(2)</tt> directly) to register the ring descriptor with the ring itself, and thus reduce the overhead of <tt>io_uring_enter(2)</tt>.
</p><p>When <tt>IORING_SETUP_SQPOLL</tt> is used, the kernel poller thread is considered to have performed the submission, providing another possible way around this problem.
</p><p>I am aware of no unannoying way to share some elements between threads in a single uring, while also monitoring distinct urings for each thread.
</p>
<h3><span id="Coexistence_with_epoll.2FXDP"></span><span id="Coexistence_with_epoll/XDP">Coexistence with <a href="https://commoncog.com/dankwiki/index.php/Epoll" title="Epoll">epoll</a>/<a href="https://commoncog.com/dankwiki/index.php/XDP" title="XDP">XDP</a></span></h3>
<p>If you want to monitor both an epoll and a uring in a single thread without busy waiting, you will run into problems. You can&#39;t directly <tt>poll()</tt> a uring for CQE readiness, so it can&#39;t be added to your epoll watchset. If you set a zero timeout, you&#39;re busy waiting; if you set a non-zero timeout, one is dependent on the other&#39;s readiness. There are two solutions:
</p>
<ul><li>Add the epoll fd to your uring with <tt>IORING_OP_POLL_ADD</tt>, and wait only for uring readiness. When you get a CQE for this submitted event, check the epoll.</li>
<li>Register an <a href="https://commoncog.com/dankwiki/index.php/Eventfd" title="Eventfd">eventfd</a> with your uring with <tt>io_uring_register_eventfd(3)</tt>, add that to your epoll, and when you get <tt>POLLIN</tt> for this fd, check the completion ring.</li></ul>
<p>The full API here is:
</p>
<div dir="ltr"><pre><span></span><span>int</span><span> </span><span>io_uring_register_eventfd</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>);</span>
<span>int</span><span> </span><span>io_uring_register_eventfd_async</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>,</span><span> </span><span>int</span><span> </span><span>fd</span><span>);</span>
<span>int</span><span> </span><span>io_uring_unregister_eventfd</span><span>(</span><span>struct</span><span> </span><span>io_uring</span><span> </span><span>*</span><span>ring</span><span>);</span>
</pre></div>
<p><tt>io_uring_register_eventfd_async(3)</tt> only posts to the eventfd for events that completed out-of-line. There is not necessarily a bijection between completion events and posts even with the regular form; multiple CQEs can post only a single event, and spurious posts can occur.
</p><p>Similarly, <a href="https://commoncog.com/dankwiki/index.php/XDP" title="XDP">XDP</a>&#39;s native means of notification is via <tt>poll(2)</tt>; XDP can be unified with uring using either of these two methods.
</p>
<h3><span id="Queue_overflows">Queue overflows</span></h3>
<p>The <tt>io_uring_prep_msg_ring(3)</tt> family of functions will generate a local CQE with the result code <tt>-EOVERFLOW</tt> if it is unable to fill a CQE on the target ring (when the submission and target ring are the same, I assume you get no CQE, but I&#39;m not sure of this).
</p>
<h2><span id="What.27s_missing"></span><span id="What&#39;s_missing">What&#39;s missing</span></h2>
<p>I&#39;d like to see <a href="https://commoncog.com/dankwiki/index.php/Signalfd" title="Signalfd">signalfds</a> and pidfds integrated for purposes of linked operations (you can read from them with the existing infrastructure, but you can&#39;t create them, and thus can&#39;t link their creation to other events).
</p><p>Why is there no <tt>vmsplice(2)</tt> action? How about <tt>fork(2)</tt>/<tt>pthread_create(3)</tt> (or more generally <tt>clone(2)</tt>)? We could have coroutines with I/O.
</p><p>It would be nice to have tight integration with condition variables or even mutex/futex (allow me to submit a request to get a lock, and when i get the CQE, i have that lock). Bonus points if the fast (uncontended) path never needs a system call (like mutexes built atop futexes today).
</p><p>I understand that making huge pages as annoying as possible to use is a central tenet underpinning the entire Linux mission, but it would be great if hugepage-backed urings were only a flag/field away.
</p><p>It&#39;s kind of annoying that chains can&#39;t extend over submissions. If I&#39;ve got a lot of data I need delivered in order, it seems I&#39;m limited to a single chain in-flight at a time, or else I risk out-of-order delivery due to one chain aborting, followed by items from a subsequent chain succeeding.
</p><p>It seems that the obvious next step would be providing small snippets of arbitrary computation to be run in kernelspace, linked with SQEs. Perhaps <a href="https://commoncog.com/dankwiki/index.php/EBPF" title="EBPF">eBPF</a> would be a good starting place.
</p>
<h2><span id="External_links">External links</span></h2>
<ul><li><a rel="nofollow" href="https://kernel.dk/io_uring.pdf">Efficient IO with io_uring</a>, Axboe&#39;s original paper, and <a rel="nofollow" href="https://github.com/axboe/liburing/wiki/io_uring-and-networking-in-2023">io_uring and networking in 2023</a></li>
<li><a rel="nofollow" href="https://unixism.net/loti/index.html">Lord of the io_uring</a> by Shuveb Hussain</li>
<li>Yarden Shafir&#39;s <a rel="nofollow" href="https://windows-internals.com/ioring-vs-io_uring-a-comparison-of-windows-and-linux-implementations/">IoRing vs io_uring: A comparison of Windows and Linux implementations</a> and <a rel="nofollow" href="https://windows-internals.com/i-o-rings-when-one-i-o-operation-is-not-enough/">I/O RingsWhen One I/O is Not Enough</a></li>
<li><a rel="nofollow" href="https://developers.redhat.com/articles/2023/04/12/why-you-should-use-iouring-network-io">why you should use io_uring for network io</a>, Donald Hunter for Redhat 2023-04-12</li>
<li><a rel="nofollow" href="https://learn.microsoft.com/en-us/windows/win32/api/ioringapi/">ioringapi</a> at Microsoft</li>
<li>Jakub Sitnicki of Cloudflare threw &#34;<a rel="nofollow" href="https://blog.cloudflare.com/missing-manuals-io_uring-worker-pool/">Missing Manuals: io_uring worker pool</a>&#34; into the ring 2022-02-04</li>
<li>&#34;<a rel="nofollow" href="https://github.com/axboe/liburing/issues/324">IORING_SETUP_SQPOLL_PERCPU status?</a>&#34; liburing issue 324</li>
<li>&#34;<a rel="nofollow" href="https://github.com/axboe/liburing/issues/345">IORING_SETUP_IOPOLL, IORING_SETUP_SQPOLL impact on TCP read event latency</a>&#34; liburing issue 345</li></ul>
<!-- 
NewPP limit report
Cached time: 20230522195315
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.281 seconds
Real time usage: 0.298 seconds
Preprocessor visited node count: 248/1000000
Postexpand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 28/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 94412/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1420-0!canonical and timestamp 20230522195315 and revision id 10055.
 -->
</div></div></div>
  </body>
</html>
