<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/andyk/recursive_llm">Original</a>
    <h1>Show HN: Recursive LLM Prompts</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">The idea here is to implement recursion using English as the programming language and GPT as the runtime.</p>
<p dir="auto">Basically we come up with a GPT prompt which causes the model to return another slightly updated GPT prompt. More specifically, the prompts contain state and each recursively generated prompt updates that state to be closer to an end goal (i.e., a base case).</p>
<p dir="auto">It’s kind of like traditional recursion in code, but instead of having a function that calls itself with a different set of arguments, there is a prompt that returns itself with specific parts updated to reflect the new arguments.</p>
<p dir="auto">Here is an infinitely recursive fibonacci prompt:</p>
<blockquote>
<p dir="auto">You are a recursive function. Instead of being written in a programming language, you are written in English.  You have variables FIB_INDEX = 2, MINUS_TWO = 0, MINUS_ONE = 1, CURR_VALUE = 1. Output this paragraph but with updated variables to compute the next step of the Fibbonaci sequence.</p>
</blockquote>
<p dir="auto">To “run this program” we can paste it into OpenAI playground, and click run, and then take the result and run that, etc.</p>
<video src="https://user-images.githubusercontent.com/228998/226147800-fff1ba10-118c-47ae-9772-35be5b15e4c0.mp4" data-canonical-src="https://user-images.githubusercontent.com/228998/226147800-fff1ba10-118c-47ae-9772-35be5b15e4c0.mp4" controls="controls" muted="muted">

  </video>
<p dir="auto">In theory, because this does not specify a base case, we could stay in this loop of copying and pasting and running these successive prompts forever, each prompt representing one number in the Fibonacci sequence.</p>
<p dir="auto">In <code>run_recursive_gpt.py</code> we automate this recursion by writing a recursive function in Python that repeatedly calls the OpenAI API with the original and then subsequently generatated prompts until the result satisfies the base case. Here&#39;s the recursive Python function from <a href="https://github.com/andyk/recursive_llm/blob/main/run_recursive_gpt.py">run_recursive_gpt.py</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="def recursively_prompt_llm(prompt, n=1):
    if prompt.startswith(&#34;You are a recursive function&#34;):
        prompt = openai.Completion.create(
            model=&#34;text-davinci-003&#34;,
            prompt=prompt,
            temperature=0,
            max_tokens=2048,
        )[&#34;choices&#34;][0][&#34;text&#34;].strip()
        print(f&#34;response #{n}: {prompt}\n&#34;)
        recursively_prompt_llm(prompt, n + 1)

recursively_prompt_llm(sys.stdin.readline()) "><pre><span>def</span> <span>recursively_prompt_llm</span>(<span>prompt</span>, <span>n</span><span>=</span><span>1</span>):
    <span>if</span> <span>prompt</span>.<span>startswith</span>(<span>&#34;You are a recursive function&#34;</span>):
        <span>prompt</span> <span>=</span> <span>openai</span>.<span>Completion</span>.<span>create</span>(
            <span>model</span><span>=</span><span>&#34;text-davinci-003&#34;</span>,
            <span>prompt</span><span>=</span><span>prompt</span>,
            <span>temperature</span><span>=</span><span>0</span>,
            <span>max_tokens</span><span>=</span><span>2048</span>,
        )[<span>&#34;choices&#34;</span>][<span>0</span>][<span>&#34;text&#34;</span>].<span>strip</span>()
        <span>print</span>(<span>f&#34;response #<span><span>{</span><span>n</span><span>}</span></span>: <span><span>{</span><span>prompt</span><span>}</span></span><span>\n</span>&#34;</span>)
        <span>recursively_prompt_llm</span>(<span>prompt</span>, <span>n</span> <span>+</span> <span>1</span>)

<span>recursively_prompt_llm</span>(<span>sys</span>.<span>stdin</span>.<span>readline</span>()) </pre></div>
<p dir="auto">And here&#39;s what it looks like when you run it:</p>
<video src="https://user-images.githubusercontent.com/228998/226147804-948151a5-f534-4e20-a957-a810c23516aa.mp4" data-canonical-src="https://user-images.githubusercontent.com/228998/226147804-948151a5-f534-4e20-a957-a810c23516aa.mp4" controls="controls" muted="muted">

  </video>
<h2 tabindex="-1" dir="auto"><a id="user-content-big-picture-goal-and-related-work" aria-hidden="true" href="#big-picture-goal-and-related-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Big picture goal and related work</h2>
<p dir="auto">My bigger picture goal here is to explore of using prompts to generate new prompts, and more specifically the case where the prompts contain state and each recursively generated prompt updates that state to be closer to an end goal.</p>
<p dir="auto">This is partly inspired by Patrick H. Winston&#39;s MIT OCW lecture on Cognitive Architectures, in particular <a href="https://www.youtube.com/watch?v=PimSbFGrwXM&amp;t=189s" rel="nofollow">his summary</a> of the historical system from CMU called General Problem Solver (GPS) in which they try to identify a goal and then have the AI evaluate the difference between the current state and the goal and try take steps to bridge the gap.</p>
<p dir="auto">The ability for LLMs to break down problem into sub-steps (a la &#34;Let&#39;s think step by step&#34; [3]) reminded me of this part of Winston&#39;s lecture. And so I wanted to try making a prompt that (1) contains state and (2) can be used to generate another prompt which has updated state.</p>
<p dir="auto">I also want to further explore how (and when) to best leverage what the LLM has memorized. The way humans do math in our heads is an interesting analog: our brain (mind?) uses two types of rules that we have memorized:</p>
<ol dir="auto">
<li>algebraic rules for rewriting (part of) the math problem</li>
<li>atomic rules things like 2+2=4</li>
</ol>
<p dir="auto">So I&#39;m wondering if we could write a &#34;recursive&#34; LLM prompt that achieves a similar thing.</p>
<p dir="auto">This direction of reasoning is inpsired by another classic CMU AI research project called ACT-R [5]. This project, led by John R. Anderson, explored how humans do math in their head and tried to apply those lessons to their AI agent architecture [4].</p>
<p dir="auto">The ACT-R group partnered up with cognitive scientists &amp; neuroscientists and performed FMRIs on students while they were doing math problems.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-observations" aria-hidden="true" href="#observations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Observations</h2>
<p dir="auto">I was a little suprised at how (and how frequently) the model generates incorrect results. E.g., with the Fibonacci sequence prompt, sometimes it skips a number entirely, sometimes it produces a number that is off-by-some but then gets the following number(s) correct. For example, at the very end of the screen capture video above (i.e., &#34;response #16&#34;) it prints 2504 but the correct answer is 2584.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/228998/226428779-845c299c-c158-4634-94d8-cc265aa86f19.png"><img src="https://user-images.githubusercontent.com/228998/226428779-845c299c-c158-4634-94d8-cc265aa86f19.png" alt="wrong-answer-18th-fib-seq"/></a></p>
<p dir="auto">I wonder how much of this is because the model has memorized the Fibonacci sequence. It is possible to have it just return the sequence in a single call, but that isn&#39;t really the point here. Instead this is more an exploration of how to agent-ify the model in the spirit of [1][2] via prompts that generate other prompts.</p>
<p dir="auto">This reminds me a bit of how a CPU works, i.e., as a dumb loop that fetches and executes the next instruction, whatever it may be. Well in this case our &#34;agent&#34; is just a dumb python loop that fetches the next prompt (which is generated by the current prompt) whatever it may be... until it arrives at a prompt that doesn&#39;t lead to another prompt.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-references" aria-hidden="true" href="#references"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">[1] A simple Python implementation of the ReAct pattern for LLMs. Simon Willison. <a href="https://til.simonwillison.net/llms/python-react-pattern" rel="nofollow">https://til.simonwillison.net/llms/python-react-pattern</a></p>
<p dir="auto">[2] ReAct: Synergizing Reasoning and Acting in Language Models. Shunyu Yao et al. <a href="https://react-lm.github.io/" rel="nofollow">https://react-lm.github.io/</a></p>
<p dir="auto">[3] Large Language Models are Zero-Shot Reasoners - <a href="https://arxiv.org/abs/2205.11916" rel="nofollow">https://arxiv.org/abs/2205.11916</a></p>
<p dir="auto">[4] <a href="https://www.amazon.com/Soar-Cognitive-Architecture-MIT-Press/dp/0262538539" rel="nofollow">https://www.amazon.com/Soar-Cognitive-Architecture-MIT-Press/dp/0262538539</a></p>
<p dir="auto">[5] <a href="https://en.wikipedia.org/wiki/ACT-R" rel="nofollow">https://en.wikipedia.org/wiki/ACT-R</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-to-run" aria-hidden="true" href="#to-run"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>To run:</h2>
<div data-snippet-clipboard-copy-content="pip install openai
OPENAI_API_KEY=YOUR_KEY_HERE python run_recursive_gpt.py &lt; prompt_fibonnaci_no_base_case.txt
OPENAI_API_KEY=YOUR_KEY_HERE python run_recursive_gpt.py &lt; prompt_fibonnaci_base_case.txt
OPENAI_API_KEY=YOUR_KEY_HERE python run_recursive_gpt.py &lt; prompt_counting.txt"><pre><code>pip install openai
OPENAI_API_KEY=YOUR_KEY_HERE python run_recursive_gpt.py &lt; prompt_fibonnaci_no_base_case.txt
OPENAI_API_KEY=YOUR_KEY_HERE python run_recursive_gpt.py &lt; prompt_fibonnaci_base_case.txt
OPENAI_API_KEY=YOUR_KEY_HERE python run_recursive_gpt.py &lt; prompt_counting.txt
</code></pre></div>
<p dir="auto">To run without python (more manual process):</p>
<ol dir="auto">
<li>Open <a href="https://beta.openai.com/playground" rel="nofollow">OpenAI Playground</a></li>
<li>Paste the prompt into the model (text-davinci-003&#34;, temperature=0, max_tokens=2048)</li>
<li>Click Submit. The model output should be a new prompt.</li>
<li>Keep running each successive prompt till the base case is hit.</li>
</ol>
</article>
          </div></div>
  </body>
</html>
