<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notso.boringsql.com/posts/time-keepers-pg-cron-pg-timetable/">Original</a>
    <h1>The time keepers: pg_cron and pg_timetable</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Working with PostgreSQL, and virtually any database system, extends far beyond merely inserting and retrieving data. Many application and business processes, maintenance tasks, reporting, and orchestration tasks require the integration of a job scheduler. While third-party tools can drive automation, you can also automate the execution of predefined tasks directly within the database environment. Although system-level cron might be a starting point, the power of the database system lies in its ability to store all the necessary information alongside your data/schema. In this article, we will explore <code>pg_cron</code> and <code>pg_timetable</code> as two distinct PostgreSQL-specific tools for scheduled task automation.</p>
<h2 id="the-many-roles-of-job-scheduling">The Many Roles of Job Scheduling
</h2>
<p>Usually, the first requirement to automate job execution is the optimisation of the PostgreSQL cluster and databases. Except in very low usage scenarios, <strong>routine maintenance</strong> is the foundation of all database deployments. Whether it is VACUUMing, index rebuilding, or updating statistics, these are tasks that you will eventually need to automate to maintain operational efficiency.</p>
<p>Job scheduling is also indispensable for <strong>maintaining data quality</strong>, particularly through operations like refreshing materialised views or batch removal of outdated data from the system. From there, it is just a step to <strong>reporting</strong>, which can involve the automation of generating operational and business reports.</p>
<p>I also believe that databases are an excellent place to <strong>coordinate business processes</strong>. Automating data flows between components, teams, and departments helps create agile systems. As mentioned above, there is no better place to store the description of such automations than alongside your data.</p>
<h2 id="pg-cron-automation-s-first-gear">pg_cron: Automation&#39;s First Gear
</h2>
<p>Traditionally, the role of automation started with operating system tools like cron or Task Scheduler. That&#39;s where <a href="https://github.com/citusdata/pg_cron"><code>pg_cron</code></a> comes in. It&#39;s a PostgreSQL extension that provides the simplicity and familiarity of cron&#39;s scheduling directly within the database environment.</p>
<p>Due to its dependency on a shared library (because of the use of the background worker), it requires a full cluster restart. Nevertheless, due to its popularity, it is available within most managed cloud environments.</p>
<pre data-lang="sql"><code data-lang="sql"><span># requires configuration update in postgresql.conf (or conf.d)
</span><span>shared_preload_libraries = &#39;</span><span>pg_cron</span><span>&#39;
</span><span>
</span><span># add extension as superuser 
</span><span>CREATE EXTENSION pg_cron;
</span></code></pre>
<p>As long as you are familiar with cron-like syntax, you can get started immediately by using commands like:</p>
<pre data-lang="sql"><code data-lang="sql"><span>SELECT </span><span>cron</span><span>.</span><span>schedule</span><span>(&#39;</span><span>30 3 * * 6</span><span>&#39;, $$</span><span>DELETE FROM</span><span> events </span><span>WHERE</span><span> event_time &lt; now() - interval &#39;</span><span>1 week</span><span>&#39;$$);
</span></code></pre>
<p>By default, <code>pg_cron</code> exposes its functionality in the <code>postgres</code> database (configurable), where it expects its metadata tables. Personally, I consider this a drawback, as it makes it less obvious to the casual DBA who might not be aware of the scheduling logic present.</p>
<p>In the same database, you can perform basic monitoring, for example, getting details of running and recently completed jobs:</p>
<pre data-lang="sql"><code data-lang="sql"><span>SELECT </span><span>* </span><span>FROM </span><span>cron</span><span>.</span><span>job_run_details </span><span>ORDER BY</span><span> start_time </span><span>DESC LIMIT </span><span>5</span><span>;
</span></code></pre>
<p>There is no direct support to talk to other PostgreSQL clusters (you would have to facilitate this, for example, using Foreign Data Wrappers).</p>
<p>While cron-like syntax is beneficial for adoption, it is where <code>pg_cron</code> falls short, as it does not support advanced cases like task chaining, dependencies, and triggers.</p>

<p>If <code>pg_cron</code> offers automation in first gear, <code>pg_timetable</code> is where you can go full speed ahead. It not only provides cron-like syntax but elevates it to a whole new level with task chaining, parameter support, multiple execution clients, enhanced scheduling, and much more.</p>
<p>The first difference you might notice is in its distribution. Timetable is not a PostgreSQL extension but a standalone binary (or available as a Docker image) that you have to configure and run. This immediately raises the bar in terms of the infrastructure it requires. On the other hand, not being distributed as an extension makes it compatible with all managed services by default (if you can get the process up and running).</p>
<p>While the basic syntax might be similar to <code>pg_cron</code>:</p>
<pre data-lang="sql"><code data-lang="sql"><span>SELECT </span><span>timetable</span><span>.</span><span>add_job</span><span>(&#39;</span><span>execute-func</span><span>&#39;, &#39;</span><span>5 0 * 8 *</span><span>&#39;, &#39;</span><span>SELECT public.my_func()</span><span>&#39;);
</span></code></pre>
<p>this is not anywhere near the limits of <code>pg_timetable</code>. <code>add_job</code> is a helper function that creates a simple one-task chain. For task execution, it directly supports more options, including built-in tasks (like sending emails if properly configured, downloading files, sleeping, copying files, etc.), external commands, the ability to choose which client should execute the job, concurrency, and more.</p>
<p>In its full definition, <code>add_job</code> is quite powerful (see <a href="https://pg-timetable.readthedocs.io/en/master/basic_jobs.html#add-simple-job">documentation</a> for details):</p>
<pre data-lang="sql"><code data-lang="sql"><span>SELECT </span><span>timetable</span><span>.</span><span>add_job</span><span>(
</span><span>    job_name            =&gt; &#39;</span><span>notify every minute</span><span>&#39;,
</span><span>    job_schedule        =&gt; &#39;</span><span>* * * * *</span><span>&#39;,
</span><span>    job_command         =&gt; &#39;</span><span>SELECT pg_notify($1, $2)</span><span>&#39;,
</span><span>    job_parameters      =&gt; &#39;</span><span>[&#34;TT_CHANNEL&#34;, &#34;Hello World!&#34;]</span><span>&#39;::jsonb,
</span><span>    job_kind            =&gt; &#39;</span><span>SQL</span><span>&#39;::</span><span>timetable</span><span>.</span><span>command_kind</span><span>,
</span><span>    job_client_name     =&gt; </span><span>NULL</span><span>,
</span><span>    job_max_instances   =&gt; </span><span>1</span><span>,
</span><span>    job_live            =&gt; </span><span>TRUE</span><span>,
</span><span>    job_self_destruct   =&gt; </span><span>FALSE</span><span>,
</span><span>    job_ignore_errors   =&gt; </span><span>TRUE
</span><span>) AS chain_id;
</span></code></pre>
<p>The components of <code>pg_timetable</code> consist of the <strong>command</strong> (SQL/program or built-in), <strong>task</strong> controlling the configuration for the command execution (error handling, timeout, or database connection to use), and <strong>chain</strong> which can contain a number of tasks chained together.</p>
<p>The big difference comes in the scheduling options. While <code>pg_cron</code> is limited (as its name suggests) to cron-like syntax, <code>pg_timetable</code> uses it for simple use cases but offers much more. It supports schedules <code>@every</code> and <code>@after</code>, allowing repeated execution and breaking away from the limitations of cron notation as it can go down to custom intervals (including second intervals). Another case is <code>@reboot</code> for instances when the <code>pg_timetable</code> controller reconnects to the database.</p>
<p>The timetable setup manages own schema migrations and stores all the configuration in schema <code>timetable</code> (by default), where you can find the definitions of chains/tasks and relevant auditing information (logs).</p>
<p>And yes, if you have been paying attention, <code>pg_timetable</code> architecture allows for running tasks across multiple PostgreSQL clusters, making it an advanced orchestration tool. The database connection, which can be configured in-place or via a drop-in <a href="https://www.postgresql.org/docs/current/libpq-pgservice.html">connection service file</a>, can be set on a per-task basis.</p>
<p>With chains, the setup can be much more complex:</p>
<pre data-lang="sql"><code data-lang="sql"><span>DO $$
</span><span>DECLARE
</span><span>  v_chain_id </span><span>BIGINT</span><span>;
</span><span>  v_notify_task_id </span><span>BIGINT</span><span>;
</span><span>BEGIN
</span><span>    </span><span>INSERT INTO </span><span>timetable</span><span>.</span><span>chain</span><span> (
</span><span>        chain_name,
</span><span>        run_at,
</span><span>        max_instances,
</span><span>        live)
</span><span>    </span><span>VALUES</span><span> (
</span><span>        &#39;</span><span>Generate Weekly Report</span><span>&#39;,
</span><span>        &#39;</span><span>5 4 * * 1</span><span>&#39;,
</span><span>        </span><span>1</span><span>,
</span><span>        </span><span>TRUE    
</span><span>    )
</span><span>    RETURNING chain_id INTO v_chain_id;
</span><span>
</span><span>    </span><span>INSERT INTO </span><span>timetable</span><span>.</span><span>task</span><span> (
</span><span>        chain_id,       
</span><span>        task_order,     
</span><span>        task_name,      
</span><span>        command,        
</span><span>        database_connection 
</span><span>    )
</span><span>    </span><span>VALUES</span><span> (
</span><span>        v_chain_id,
</span><span>        </span><span>1</span><span>,                                    </span><span>-- task_order
</span><span>        &#39;</span><span>generate_report</span><span>&#39;,                    </span><span>-- task_name
</span><span>        &#39;</span><span>SELECT generate_weekly_report();</span><span>&#39;,   </span><span>-- command
</span><span>        </span><span>NULL                                  </span><span>-- database_connection
</span><span>    );
</span><span>
</span><span>    </span><span>INSERT INTO </span><span>timetable</span><span>.</span><span>task</span><span> (
</span><span>        chain_id,       
</span><span>        task_order,     
</span><span>        task_name,      
</span><span>        command,        
</span><span>        database_connection 
</span><span>    )
</span><span>    </span><span>VALUES</span><span> (
</span><span>        v_chain_id,
</span><span>        </span><span>2</span><span>,                                   </span><span>-- task_order (second task in the chain)
</span><span>        &#39;</span><span>notify_management</span><span>&#39;,                 </span><span>-- task_name
</span><span>        &#39;</span><span>SELECT pg_notify($1, $2)</span><span>&#39;,          </span><span>-- command
</span><span>        &#39;</span><span>service=service_db</span><span>&#39;                 </span><span>-- database_connection
</span><span>    )
</span><span>    RETURNING task_id INTO v_notify_task_id;
</span><span>
</span><span>    </span><span>INSERT INTO </span><span>timetable</span><span>.</span><span>task_parameter</span><span> (task_id, order_id, value) 
</span><span>    </span><span>VALUES
</span><span>        (v_notify_task_id, </span><span>1</span><span>, &#39;</span><span>management_notifications</span><span>&#39;),
</span><span>        (v_notify_task_id, </span><span>2</span><span>, &#39;</span><span>Weekly report</span><span>&#39;);
</span><span>END</span><span>;
</span><span>$$ LANGUAGE plpgsql;
</span></code></pre>
<h2 id="the-comparison">The Comparison
</h2>
<p>When deciding between <code>pg_cron</code> and <code>pg_timetable</code>, it&#39;s essential to consider the specific needs of your use case, as both tools target different scenarios and scales of deployment. Here’s a comparison to help you decide which tool is more suitable for your requirements:</p>
<table><thead><tr><th>Feature</th><th>pg_cron</th><th>pg_timetable</th></tr></thead><tbody>
<tr><td>Distribution</td><td>PostgreSQL extension</td><td>Standalone executable</td></tr>
<tr><td>Scheduling</td><td>Limited (cron-like)</td><td>Extensive (intervals, calendar, custom)</td></tr>
<tr><td>Job Types</td><td>SQL</td><td>SQL, Built-in, Shell</td></tr>
<tr><td>Job Chaining</td><td>No</td><td>Yes</td></tr>
<tr><td>Error Handling</td><td>Basic</td><td>Intermediate</td></tr>
<tr><td>Logging</td><td>Basic</td><td>Intermediate</td></tr>
<tr><td>Dependencies</td><td>No</td><td>Yes</td></tr>
<tr><td>Ease of Use</td><td>Easy</td><td>Moderate</td></tr>
<tr><td>Configuration</td><td>Easy</td><td>Moderate</td></tr>
<tr><td>Orchestration</td><td>Single Cluster</td><td>Advanced (multiple clusters)</td></tr>
</tbody></table>
<h3 id="when-to-use-pg-cron">When to Use <code>pg_cron</code>
</h3>
<ol>
<li>If your requirements are straightforward, such as running maintenance tasks, refreshing materialised views, or generating periodic reports using simple SQL commands, <code>pg_cron</code> is an excellent choice. Its cron-like syntax is familiar and <strong>easy to use</strong>.</li>
<li><code>pg_cron</code> is a PostgreSQL extension, making it <strong>easier to install</strong> and configure within your existing PostgreSQL environment. This makes it ideal for users who prefer minimal setup effort.</li>
<li>When your environment is limited to a <strong>single PostgreSQL cluster</strong>, <code>pg_cron</code> is well-suited for the job. It does not support orchestration across multiple clusters, so it’s best used in environments where all operations are confined to one database cluster.</li>
<li>If <strong>Basic Error Handling and Logging</strong> is sufficient, <code>pg_cron</code> provides the necessary functionalities without additional complexity.</li>
</ol>
<h3 id="when-to-use-pg-timetable">When to Use <code>pg_timetable</code>
</h3>
<ol>
<li>If you need more <strong>advanced scheduling capabilities</strong> and <strong>task depedencies and chaining</strong>, such as task chaining, complex intervals, and custom execution times, <code>pg_timetable</code> is the better choice. It supports extensive scheduling options beyond the typical cron syntax.</li>
<li><code>pg_timetable</code> supports a <strong>variety of job types</strong>, including SQL commands, built-in tasks (like sending emails or downloading files), and shell commands. This makes it ideal for more complex automation needs that go beyond simple SQL execution.</li>
<li>If your environment spans multiple PostgreSQL clusters, <code>pg_timetable</code> can handle <strong>advanced orchestration</strong>, allowing tasks to be executed across different clusters seamlessly.</li>
<li><strong>Intermediate Error Handling and Logging</strong> provides better insights and control over job executions.</li>
<li>Although bit more complex to setup, <code>pg_timetable</code> works as <strong>standalone Service</strong>, which makes it suitable for environments where extensions cannot be installed directly.</li>
</ol>
<p>Choosing between <code>pg_cron</code> and <code>pg_timetable</code> depends on your specific needs. For simpler, single-cluster tasks, <code>pg_cron</code> offers ease of use and straightforward setup. For more complex requirements involving advanced scheduling, task dependencies, and multi-cluster orchestration, <code>pg_timetable</code> provides a more powerful and flexible solution.</p>
<p>By understanding the strengths and limitations of each tool, you can make an informed decision that best suits your database automation needs.</p>
<p>PS: there&#39;s also <a href="https://github.com/pgadmin-org/pgagent">pgAgent</a>, but it is generally not used and does not seem to be actively maintained.</p>

  </div></div>
  </body>
</html>
