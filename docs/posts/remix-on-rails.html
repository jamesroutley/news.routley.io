<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marbiano.dev/into-remix/on-rails">Original</a>
    <h1>Remix: On Rails</h1>
    
    <div id="readability-page-1" class="page"><article><section><p>16 years ago, <a href="https://twitter.com/dhh">David Heinemeier Hansson</a> (DHH) took the stage and delivered one of the most impressive <a href="https://twitter.com/dhh/status/492706473936314369">code demos</a> the world has ever seen. It was not only an impeccable presentation but also a very <em>well-timed </em>one.</p><p>In 2005, developers knew that in order to ship web apps, they needed to deal with a lot of boilerplate code. <strong>Ruby on Rails</strong> came to change all that.</p><p>Last week, <strong>Remix</strong> went <a href="https://github.com/remix-run/remix">open source</a> and the founding team decided to host an event to celebrate it. <a href="https://twitter.com/ryanflorence">Ryan Florence</a> did a <a href="https://youtu.be/wsJaUjd1rUo?t=290">live demo</a> that felt similar to DHH’s one in spirit, as they both seemed to have a similar<em> sense of time</em>.</p><p>I’ve been using Remix for a week now, and the similarities with Rails have only been strengthened. Don’t get me wrong, modern challenges while building websites are not the same. Yet, both frameworks seem to have a lot in common.</p><p>Let’s take a look at some of my <strong>early discoveries.</strong></p><h2>Good primitives</h2><p>In Rails, the building block is a <strong>resource</strong>. It allows developers to build fast and polish later. <strong>Routes are Remix’s primitives</strong>, and while it’s fundamentally a different concept, it is equally productive and oriented towards the same goal.</p><p>The core of the idea is that each route has responsibilities beyond deciding which React component to render. They can load data, respond to user actions, apply visual styles, and many other things. </p><p>It gets fascinating when you start <strong>nesting</strong> those routes, allowing for responsibilities to compound. Suddenly, you are splitting your app in a way that feels cohesive, coherent, and performant. It seems to be taking a page from the code splitting manual and applying it to everyday tasks like fetching data or adding CSS.</p><p>The route is an ambitious primitive, one that could have gone wrong in many ways. But it <em>feels right</em>. The instructions to proceed are simple, and you quickly find yourself on the productive side by building rather than living on the docs.</p><h2>Long live the king</h2><p>With Rails, the default way to render a page is by using <strong>server-side rendering (SSR)</strong>. With it, the responsibility for generating a web page is within the server. Before <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX">AJAX</a> and <a href="https://www.cloudflare.com/learning/performance/static-site-generator">static-site generation</a> became popular, this was the only rendering strategy we needed to think about.</p><p>With the arrival of the <a href="https://jamstack.wtf">Jamstack</a>, the web ecosystem reached a new consensus: server-side rendering was too much of a burden for modern and highly dynamic websites, so it needed to go into <em>oblivion</em>. Even frameworks like <strong>Next.js</strong>, which <a href="https://vercel.com/blog/next">started</a> as a solution for SSR with React, incorporated <a href="https://nextjs.org/blog/next-9-3">newer techniques</a> more in line with the <em>modern narrative</em>.</p><p>Lately, many developers have reached some sort of <em>Jamstack fatigue</em>, mainly because they’ve explored the limits of the paradigm. Techniques like <a href="https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs">incremental static regeneration</a> have emerged to try to increase those limits, but the complexity keeps growing.</p><p>At the same time, exciting ideas have emerged in the SSR camp, aiming to solve a well-known problem: <strong>server latency</strong>. Companies like <a href="https://fly.io">Fly</a> can place your full-stack app (with databases) worldwide, drastically reducing the time a request has to travel to reach the server.</p><p>More interestingly, <a href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing">edge computing</a> has made significant progress, and companies like <strong>Cloudflare</strong> can efficiently <a href="https://workers.cloudflare.com">run your app at the edge</a>, making server latency a thing of the past.</p><p>Remix wants to stand on the shoulders of those giants by offering a server-based solution designed for <em>living on the edge</em>.</p><blockquote><p>We could probably add some SSG functionality very easily, but it’s just not that compelling when you can run your app at the edge for pennies. I mean seriously. You sacrifice so much flexibility when you prerender everything. But when you’re running your app at the edge on CF workers you can have SSG speed without sacrificing the flexibility of SSR.</p></blockquote><p>As it turns out, being edge-friendly is not a happy accident but something considered from the ground up.</p><blockquote><p>Remix is edge native. We built it for the edge by not depending on Node.js. You can deploy your Remix apps anywhere, like Cloudflare Workers.</p></blockquote><p>If we get to a point where SSR can be <em>perceived</em> as fast as static sites, then the gains in flexibility and simplicity will probably outweigh what SSG brings to the table, and the pendulum might swing the other way again. We are not yet there, but Remix is doing its part to help. </p><p>It feels like there’s an <em>SSR renaissance</em> happening.</p><h2>Colocation of concerns</h2><p>Rails is based on a well-known pattern called <a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">MVC</a>. In a nutshell, you have a place to fetch data (a model), one to display that data (a view), and one to coordinate interactions with the browser (a controller). The relationship between the three is managed by following a filename convention. Remix has similar opinions here, only that the convention it uses is a different one: it’s called <a href="https://kentcdodds.com/blog/colocation">colocation</a>.</p><p>Routes have <strong>loaders</strong> to fetch data, <strong>actions</strong> to handle user interactions, and a <strong>React component</strong> for building the user interface. All <em>colocated</em> in the same file.</p><p>Tangentially, it’s pretty clear that while Remix is known as being <em>a React framework</em>, in reality, React’s role is limited to solving one thing: to build user interfaces with its fantastic component model.</p><p>Remix routes also offer convenient ways to manipulate metadata, links, and headers, reinforcing that colocation is a feature and not a bug.</p><h2>To infinity… and beyond</h2><p>Rails has a method called <a href="https://apidock.com/rails/ActionController/MimeResponds/InstanceMethods/respond_to">respond_to</a> that lets you respond to requests in ways that go beyond just HTML pages. JSON, XML, a PDF file, a CSS stylesheet, anything is possible. Remix introduces a modern and convenient way to do a similar thing. It’s called <strong>resource routes</strong>.</p><p>Creating a resource route starts by adding a new route and <em>only</em> writing a loader on it. On that loader, you can define the type and the value of the content you want to respond with. Then it’s simply a matter of accessing the proper URL, and <em>voilà</em>, the resource is there for you to consume.</p><p>It’s a simple idea that opens the door for <strong>creativity</strong>. Here are some clever use cases I found around:</p><ul><li><p><em>Jacob Ebey</em> is <a href="https://www.ebey.me/blog/dynamic-css-with-remix-resource-routes">adding dynamic session-based CSS</a>.</p></li><li><p><em>MapleLeaf</em> is <a href="https://github.com/itsMapleLeaf/remix-tailwind">compiling Tailwind on the fly</a>.</p></li><li><p>Someone on the <a href="https://discord.gg/VBePs6d">Remix discord</a> mentioned using a resource route to decouple data loading, allowing instant page transitions and client-side cache. Neat!</p></li></ul><p>I have plans to explore this topic a whole lot more, so stay tuned for future posts.</p><h2>Learning that scales</h2><p>In the <a href="https://en.wikipedia.org/wiki/Information_Age">Information Age</a>, searching for content has become trivial, but knowing where to spend our finite time is a crucial skill to acquire. In web development, fads come and go pretty quickly, but certain elements are <em>atemporal</em>: those known as <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works">web fundamentals</a>. You typically make an educated guess by betting on those<em> </em>because they tend to scale in your career.</p><p>Rails allows developers to learn about web fundamentals <em>while </em>building websites. Its abstractions are thin enough so that you can see <em>through the glass </em>if you are curious enough. Remix wants to walk in the same direction. As stated on the docs, the API makes working with web fundamentals a <em>convenient</em> thing, but those are not hidden from you at any point.</p><blockquote><p>Web Standards, HTTP, and HTML. These technologies have been around for a long time. They’re solid. Remix embraces them completely. [...] Browsers and HTML got really good in the 20+ years we’ve been using it.</p></blockquote><p>It’s possible that if you started doing web development in the past ten years, you’ve learned that in order to send some form data, you need to follow three basic steps: </p><ol><li><p>Delegate the form submit event to a Javascript function of your own.</p></li><li><p>Inside that function, <em>prevent default behavior</em> from happening.</p></li><li><p>Finally, take care of submitting form data to the proper endpoint.</p></li></ol><p>It’s also possible you don’t know what that default behavior you are canceling in (2) is. It turns out that forms can be sent without JS in a relatively simple way, and it is one of the most basic fundamentals on which a browser is built. That&#39;s what you are canceling. 🤯</p><p>Remix does not only favor this fundamental but even <a href="https://remix.run/docs/en/v1/guides/data-writes">teaches about it</a>. Whenever you need to send a form with Remix, you will not only do that, but you’ll also learn about <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP requests</a> and how to <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data">handle forms</a> with them. This is a fantastic trait, because the framework invites you to discover beyond its abstractions. There are not many of them that can do that by design.</p><p>Let’s review another example. At some point, your app needs something most web apps need: to <strong>fetch</strong> some data from an external source. As we’ve already seen, Remix introduces loaders to do that, but there’s something particularly compelling about their implementation: rather than adding some arbitrary abstraction to handle HTTP requests, they <em>just</em> adopt the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Web Fetch API</a>.</p><p>There’s a similar story for most of Remix core parts. Whenever there’s a web fundamental behind it, you’ll get a clear message about which one it is, where to learn how it works, and the way Remix uses it. <a href="https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement">Progressive enhancement</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">cookies</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">HTTP headers</a>, all concepts you will learn while using the framework.</p><p>If you ever decide to move on from Remix, you will travel with some new tales <em>from the trenches </em><strong>and</strong> a 90L backpack full of web fundamentals.</p><blockquote><p>Get good at Remix, <em>accidentally</em> get good at web development generally.</p></blockquote><h2>Final thoughts</h2><p>Rails and Remix share a similar north star: they are both highly pragmatic with a strong sense of belonging to the web. However, Remix intends to captivate a different audience: it wants to <strong>meet React developers</strong> where they are and take them to the next level by teaching the <strong>fundamentals of the web</strong>.</p><p>Considering that React is currently the most popular front-end framework, it’s pretty exciting to think of an entire class of web developers who are good at React and can also champion for proper use of web fundamentals.</p><p>Remix looks like the pinnacle work of a couple of sharp and seasoned developers that have been around through multiple waves of <em>best practices</em> and <em>modern tools</em>, only to find an intuitive way to <em>remix</em> what’s going on these days with what has always been the <strong>backstory</strong>.</p><p>On a more personal note, Remix achieved something that not many modern web frameworks have been able to. I felt like a <strong>web developer</strong> again. The <a href="https://css-tricks.com/the-great-divide/">great divide</a>, the front &amp; back separation, the myth of the full-stack unicorn… all gone. I was building a website and having fun at it.</p><p>I will be for sure exploring more in-depth concepts and techniques that Remix brings to the table. I’m especially interested in its capabilities for the hybrid nature of blending traditional websites with highly dynamic web apps.</p><p>Good times are coming.</p></section></article></div>
  </body>
</html>
