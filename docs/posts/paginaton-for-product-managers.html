<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://peterlyons.com/problog/2024/07/paginaton-for-product-managers/">Original</a>
    <h1>Paginaton for Product Managers</h1>
    
    <div id="readability-page-1" class="page"><div>
    <header>
      
    </header>
    
<article>
  
  <p>July 27, 2024</p>
  <h2 id="hi-product-managers">Hi product managers</h2>
<p>This post is written primarily for product managers instead of my usual engineering audience. I want to explain why engineers may be reluctant to build traditional numbers-based pagination. By this I mean a list page featuring page numbers counting up from page 1, often including both the total number of pages and links to jump to particular pages. <code>1 2 3 4 5 6 7 8 9 â€¦ 537</code>.</p>
<h2 id="what-exactly-do-we-mean-by-classic-numbered-pages">What exactly do we mean by classic numbered pages?</h2>
<ul>
<li>The page shows some fixed small-to-medium number of items</li>
<li>There&#39;s page numbers starting with 1 and integers ascending from there</li>
<li>You can jump to pages by number with a click
<ul>
<li>You can click directly on the 5 to go to page 5</li>
</ul>
</li>
<li>There might be some indication of the total number of pages</li>
<li>There might be a way to jump directly to the last page
<ul>
<li>Labeled either with its number of just the word &#34;last&#34;</li>
</ul>
</li>
<li>The URL is mostly likely shareable/bookmarkable although not necessarily</li>
</ul>
<h2 id="functional-reasons-engineers-don-t-like-this">Functional reasons engineers don&#39;t like this</h2>
<p><strong>It&#39;s a poor fit for changing data</strong>. Many data sets are now closer to a social media feed with a firehose of records being created at all times so the concept of the &#34;page 3&#34; is kind of stale as soon as the user sees it. If records are being bulk deleted or re-ordered, we can&#39;t easily page through them in a coherent way from both a technical and logical perspective.</p>
<p><strong>Sharing links doesn&#39;t work</strong>. Bookmarking or sharing URLs can&#39;t easily made to show the same data. If the user intent is &#34;ooh look at these cool widgets I found on page 4&#34; and wants to have that be the same when sharing the link, the notion of &#34;page 4&#34; isn&#39;t right and creating a token-based permalink would require a fair bit of machinery.</p>
<p><strong>It&#39;s an inferior approach to discovery</strong>. Relying heavily on paging linearly through a long list of data often means there&#39;s opportunity for better search and browse features and workflows. Maybe higher-quality free text search would work better. (Aside, is any one else stupefied by how utterly bad we are at free text search, like for anything anywhere?). Maybe category-based browsing would help. Maybe curated lists would help. If users are clicking page 8, guaging some piece of data there like the price of an items, then estimating their item might be around page 20, we could probably build a better tool to facilitate their search tactic.</p>
<p><strong>It&#39;s lazy and sad</strong>. I get &#34;contractors built a paginated list page with zero care or thought, emailed us a huge invoice, and bounced&#34; vibes. Don&#39;t let agencies that don&#39;t care about user experience and quality software do work for you!</p>
<h2 id="technical-reasons-engineers-don-t-like-this">Technical reasons engineers don&#39;t like this</h2>
<p><strong>It can be catastrophically slow in most databases</strong>. I think most of the engineering resistance originates here. Most databases cannot perform these queries efficiently. Or at least, the naive implementation cannot - see below for more technical notes. Having to know the total number of results (and therefore pages) means the database usually has to scan every single record. If there are filters in place, and there ususally are, then the database may not be able to use an index for the query and it will have to slowly scan every row and test whether it matches the filters or not. Even if the end user has not specified any filters, there might be system-level filters for things like &#34;is not deleted&#34; or &#34;user has permission to see this&#34; or &#34;is not a draft&#34; etc. Especially as page numbers get higher, even if computing the total number of records/pages has been taken out of scope, the DB will still have to scan every row prior to the current page and the performance nosedives. This can reduce performance across the application as the DB has fewer resources available to serve other queries. Sometimes there are clever ways to implement the queries to avoid the performance problem, but they are definitely not techniques found on the first few pages of google results. They also may not manifest until record counts hit 25K or 100K and the odds of a developer working on a net new app testing that are near zilch.</p>
<h2 id="what-do-we-end-up-implementing">What do we end up implementing?</h2>
<p>We usually end up on a &#34;load more&#34; button, possibly the infinite scroll manifestation.</p>
<h2 id="other-technical-solutions">Other technical solutions</h2>
<p>I think there are ways to implement this with good performance by avoiding SQL <code>OFFSET</code> in favor of carefully-designed <code>WHERE</code> clause using an index, but this post is not about the technical aspect. A web search will show several varieties of alternatives that might be what you need.</p>

</article>
<nav>
  <a href="https://peterlyons.com/problog/"> back to blog index</a>
  <ul>
    
    
  </ul>
</nav>


    
    
  </div></div>
  </body>
</html>
