<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cs.au.dk/~amoeller/spa/">Original</a>
    <h1>Static Program Analysis</h1>
    
    <div id="readability-page-1" class="page">	

<h3>Welcome to the web site for the lecture notes on</h3>

<table summary="">
<tbody><tr>
<td><a href="https://cs.au.dk/~amoeller/spa/spa.pdf"><img src="https://cs.au.dk/~amoeller/spa/spa.png" alt="Static Program analysis" width="200" height="240"/></a></td>
<td>
<p>
<a href="http://cs.au.dk/~amoeller/">Anders Møller</a> and <!--<a href="http://cs.au.dk/~amoeller/mis/">-->Michael I. Schwartzbach<!--</a>--></p>
<p>Last revision: November 2022</p>
<p><a href="https://cs.au.dk/~amoeller/spa/spa.pdf"><img src="https://cs.au.dk/~amoeller/icons/pdf.gif" alt=""/></a> <a href="https://cs.au.dk/~amoeller/spa/spa.pdf">PDF</a></p>
</td>

</tr>
</tbody></table>


<p>
Static program analysis is the art of reasoning about the behavior of computer programs without actually running them.  This is useful not only in optimizing compilers for producing efficient code but also for automatic error detection and other tools that can help programmers. 
</p>
<p>
As known from Turing and Rice, all interesting properties of the behavior of programs written in common programming languages are mathematically undecidable. This means that automated reasoning of software generally must involve approximation. It is also well known that testing may reveal errors but not show their absence. In contrast, static program analysis can - with the right kind of approximations - check all possible executions of the programs and provide guarantees about their properties. The challenge when developing such analyses is how to ensure high precision and efficiency to be practically useful.
</p>
<p>
This teaching material concisely presents the essential principles and algorithms for static program analysis. We emphasize a constraint-based approach where suitable constraint systems conceptually divide analysis into a front-end that generates constraints from program code and a back-end that solves the constraints to produce the analysis results. The style of presentation is intended to be precise but not overly formal. The readers are assumed to be familiar with advanced programming language concepts and the basics of compiler construction.
</p>
<p>
The concepts are explained using a <b>t</b>iny <b>i</b>mperative <b>p</b>rogramming language, TIP, which suffices to illustrate the main challenges that arise with mainstream languages.
</p>

<p>
The lecture notes, slides, implementation, and exercises have been developed since 2008 for our graduate-level course at Aarhus University. We continue to update the material regularly.
Suggestions for improvements are welcome!
</p>

<h2>Contents</h2>
<p>
Topics covered:
</p>
<ul>
<li>type analysis
  <ul>
  <li>the unification solver
  </li></ul>
</li><li>lattices and fixpoints
  <ul>
  <li>fixpoint solvers
  </li></ul>
</li><li>dataflow analysis with monotone frameworks, including 
  <ul>
  <li>sign analysis
  </li><li>live variables analysis, available expressions analysis, very busy expressions analysis, and reaching definitions analysis
  </li><li>initialized variables analysis
  </li><li>constant propagation analysis
  </li><li>interval analysis
  </li></ul>
</li><li>widening and narrowing
</li><li>path sensitive and relational analysis
</li><li>interprocedural analysis
  <ul>
  <li>context-sensitive analysis (incl. call strings, functional approach)
  </li><li>distributive analysis (IFDS and IDE) <img src="https://cs.au.dk/~amoeller/spa/new.gif"/> 
  </li></ul>
</li><li>control flow analysis
  <ul>
  <li>the cubic solver
  </li></ul>
</li><li>pointer analysis, including
  <ul>
  <li>subset-based points-to analysis (Andersen&#39;s analysis)
  </li><li>unification-based points-to analysis (Steensgaard&#39;s analysis)
  </li><li>flow-sensitive points-to analysis
  </li><li>null pointer analysis, strong/weak updates
  </li></ul>
</li><li>the basics of abstract interpretation, relating formal semantics and static analysis 
  <ul>
  <li>collecting semantics
  </li><li>abstraction and concretization
  </li><li>soundness, optimality, and completeness
  </li></ul>
</li></ul>

<p>
The analyses are expressed using different kinds of constraint systems, each with their own constraint solvers:
</p>
<ol>
<li>Unification constraints, with an almost-linear union-find algorithm (for type analysis and Steensgaard&#39;s analysis)
</li><li>Conditional subset constraints, with a cubic-time algorithm (for control flow analysis and Andersen&#39;s analysis)
</li><li>Monotone constraints over lattices, with variations of fixpoint solvers (primarily for the flow-sensitive analyses)
</li></ol>

<p>
<a href="https://cs.au.dk/~amoeller/spa/sol.pdf">Solutions</a> to (some of) the exercises are available to teachers. 
</p><p>
<a href="https://cs.au.dk/~amoeller/spa/spa-coq-formalization.zip">Coq formalizations and proofs</a> (by Zesen Qian and Oskar Haarklou Veileborg)  

</p><h2>Slides</h2>

<p>
Lecture slides:
</p>
<ol>
<li><a href="https://cs.au.dk/~amoeller/spa/1-TIP.pdf">introduction to TIP</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/2-type-analysis.pdf">type analysis and the unification solver</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/3-lattices-and-fixpoints.pdf">lattices and fixpoint solvers</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/4-flow-sensitive-analyses.pdf">examples of flow-sensitive analyses</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/5-widening-and-narrowing.pdf">interval analysis, widening and narrowing</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/6-path-sensitivity.pdf">path sensitivity and relational analysis</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/7-interprocedural-analysis.pdf">interprocedural and context sensitive analysis</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/8-distributive.pdf">distributive analysis (IFDS and IDE)</a> <img src="https://cs.au.dk/~amoeller/spa/new.gif"/> 
</li><li><a href="https://cs.au.dk/~amoeller/spa/9-control-flow-analysis.pdf">control flow analysis and the cubic solver</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/10-pointer-analysis.pdf">pointer analysis</a>
</li><li><a href="https://cs.au.dk/~amoeller/spa/11-abstract-interpretation.pdf">abstract interpretation</a>
</li></ol>
<!--
<p>
(PowerPoint slides are available to teachers by request.)
</p>
-->


<h2>Implementation</h2>

<p>
Most of the algorithms and analyses have been implemented (in Scala):
</p>
<p>
<img src="https://cs.au.dk/~amoeller/icons/package.png" alt=""/>
<a href="https://github.com/cs-au-dk/TIP/">the TIP implementation at github</a> (<a href="https://cs-au-dk.github.io/TIP/docs/scaladoc/tip/">scaladoc</a>)
</p>
<p>
(developed by Anders Møller and Gianluca Mezzetti, with contributions from Erik Krogh Kristensen, Christian Budde Christensen, Coen De Roover, and Quentin Stievenart)
</p>
<p>
The open source version omits certain parts that are left for <a href="https://github.com/cs-au-dk/TIP/wiki/TIP-exercises">exercises</a>.
Solutions for (many of) these programming exercises are available to teachers by request.
</p> 

<p>
See also the C++ implementation, <a href="https://github.com/matthewbdwyer/tipc">tipc</a>, by Matthew Dwyer. 
</p>

<h2>Plans for future revisions</h2>

<p>
Our TODO list:
</p>
<ul>
<li>more about points-to analysis
</li><li>more references to literature
</li><li>sparse analysis
</li><li>more examples of analyses and abstract domains
</li><li>more exercises
</li><li><a href="https://github.com/cs-au-dk/TIP/issues">open TIP implementation issues</a> and <a href="https://github.com/cs-au-dk/TIP/pulls">pull requests</a>
</li><li>...
</li></ul>

<p>
Feel free to <a href="mailto:amoeller@cs.au.dk?subject=Static%20Program%20Analysis">contact the authors</a> if you have any questions or comments to the material.
</p><p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"/></a>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
</p>

<!--
<center class="footer">
   <table border="0" cellpadding="0" cellspacing="0" width="100%">

  <tbody><tr>
    <td bgcolor="#3366cc"><img alt="" height="1" width="1" src="back.gif"></td>
  </tr>
</tbody></table>
  <table bgcolor="#e5ecf9" border="0" cellpadding="2" cellspacing="0" width="100%">
    <tbody><tr>
      <td bgcolor="#e5ecf9" nowrap="nowrap"><table border="0" cellpadding="0" cellspacing="0" width="100%">
          <tbody><tr>
            <td align="right" nowrap="nowrap"><i><a href="mailto:amoeller@cs.au.dk?subject=Static%20Program%20Analysis">Anders Møller & Michael I. Schwartzbach</a></i></td>
          </tr>
      </tbody></table></td>
    </tr>
  </tbody></table>
</center>
-->



</div>
  </body>
</html>
