<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.agwa.name/blog/post/using_sni_proxying_and_ipv6_to_share_port_443">Original</a>
    <h1>Using SNI proxying and IPv6 to share port 443 between webapps</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
My preferred method for deploying webapps is to have the
webapp listen directly on port 443, without any sort of standalone web
server or HTTP reverse proxy in front.  I have had it with standalone web servers:
they&#39;re all over-complicated and I always end up with an awkward
bifurcation of logic between my app&#39;s code and the web server&#39;s
config.  Meanwhile, my preferred language, Go, has a high-quality,
memory-safe HTTPS server in the standard library that is <a href="https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/" rel="external">well
suited for direct exposure on the Internet</a>.
</p>

<p>
However, only one process at a time can listen on a given IP address
and port number.  In a world of ubiquitous IPv6, this wouldn&#39;t be a
problem - each of my servers has literally trillions of IPv6 addresses,
so I could easily dedicate one IPv6 address per webapp.
Unfortunately, IPv6 is not ubiquitous, and due to the shortage of
IPv4 addresses, it would be too expensive to give each app its own
IPv4 address.
</p>

<p>
The conventional solution for this problem is HTTP reverse proxying,
but I want to do better.  I want to be able to act like IPv6 really is
ubiquitous, but continue to support IPv4-only clients with a minimum amount
of complexity and mental overhead.  To accomplish this, I&#39;ve turned to
SNI-based proxying.  
</p>

<p>
I&#39;ve <a href="https://www.agwa.name/blog/post/writing_an_sni_proxy_in_go">written about SNI proxying before</a>, but in a nutshell: a proxy server
can use the first message in a TLS connection (the Client Hello message, which is unencrypted and
contains the server name (SNI) that the client wants to connect to) to decide
where to route the connection.  Here&#39;s how I&#39;m using it:
</p>

<ul><li>My webapps listen on port 443 of a dedicated IPv6 address.  They do not listen on IPv4.</li><li>Each of my servers runs <a href="https://github.com/AGWA/snid" rel="external">snid</a>, a Go daemon which listens on port 443 of the server&#39;s single IPv4 address.</li><li>When snid receives a connection, it peeks at the first TLS message to get the desired server name.  It does a DNS lookup for the server name&#39;s IPv6 address, and proxies the TCP connection there.  To prevent snid from being used as an open proxy, snid only forwards the connection if the IPv6 address in within my server&#39;s IPv6 range.</li><li>The AAAA record for a webapp is the dedicated IPv6 address, and the A record is the shared IPv4 address. Thus, IPv6 clients connect directly to the webapp, while IPv4 clients are proxied via snid.</li></ul> 

<h4>Preserving the Client&#39;s IP Address</h4>

<p>
One of the headaches caused by proxies is that the backend doesn&#39;t
see the client&#39;s IP address - connections appear to be from the proxy
server instead.  With HTTP proxying, this problem is typically solved
by stuffing the client&#39;s IP address in a header field, which is a
<a href="https://adam-p.ca/blog/2022/03/x-forwarded-for/" rel="external">minefield
of security problems</a> that allow client IP addresses to be spoofed
if you&#39;re not careful.  With TCP proxying, a common solution is to use the <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" rel="external">PROXY
protocol</a>, which puts the client&#39;s IP address at the beginning of
the proxied connection.  However, this requires backends to understand
the PROXY protocol.
</p>

<p>
snid can do better.  Since IPv6 addresses are 128 bits long, but IPv4
addresses are only 32 bits, it&#39;s possible to embed IPv4 addresses in
IPv6 addresses.  snid embeds the client&#39;s IP address in the lower 32
bits of the source address which it uses to connect to the backend.
It&#39;s trivial for the backend to translate the source address back to
the IPv4 address, but this is purely a user interface
concern. If a backend doesn&#39;t do the translation, it&#39;s possible for the
human operator to do the translation manually when viewing log entries,
configuring access control, etc.
</p>

<p>
For the IPv6 prefix, I use 64:ff9b:1::/48, which is a non-publicly-routed prefix
<a href="https://datatracker.ietf.org/doc/html/rfc8215" rel="external">reserved for
IPv4/IPv6 translation mechanisms</a>.  For example, the IPv4 address 192.0.2.10
translates to:
</p>

<p><code>64:ff9b:1::c000:20a</code></p><p>Conveniently, it can also be written using embedded IPv4 notation:</p>

<p><code>64:ff9b:1::192.0.2.10</code></p><h4>O(1) Config</h4>

<p>
snid&#39;s configuration is just a few command line arguments.  Here&#39;s the command line
for the instance of snid that&#39;s running on the server that serves www.agwa.name and src.agwa.name:
</p>

<p><kbd><span>
snid -listen tcp:18.220.42.202:443 -mode nat46 -nat46-prefix 64:ff9b:1:: -backend-cidr 2600:1f16:719:be00:5ba7::/80
</span></kbd></p><p>
<code>-listen</code> tells snid to listen on port 443 of 18.220.42.202,
which is the IPv4 address for www.agwa.name and src.agwa.name.
<code>-mode nat46</code> tells snid to forward connections over IPv6,
with the source IPv4 address embedded using the prefix specified by
<code>-nat46-prefix</code>.  <code>-backend-cidr</code> tells snid to only
forward connections to addresses within the 2600:1f16:719:be00:5ba7::/80
subnet, which includes the IPv6 addresses for www.agwa.name and
src.agwa.name (2600:1f16:719:be00:5ba7::2 and 2600:1f16:719:be00:5ba7::1,
respectively).
</p>

<p>
The best thing about snid&#39;s configuration is that I only have to touch it once.
I don&#39;t have to change it when deploying new webapps.  Deploying a new webapp
only requires assigning it an IPv6 address and publishing DNS records for it,
just like it would be in my dream world of ubiquitous IPv6.  I call
this <em>O(1) configuration</em> since it doesn&#39;t get longer or more complex
with the number of webapps I run.
</p>


<h4>Guaranteed Secure</h4>

<p>
HTTP reverse proxying is a minefield of security concerns.  In addition to the
IP address spoofing problems discussed above, you have to contend with
<a href="https://portswigger.net/web-security/request-smuggling" rel="external">request smuggling</a> and <a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" rel="external">HTTP desync</a> vulnerabilities.  This is a class of vulnerability
that will never truly be solved: you can patch vulnerabilities as they&#39;re discovered,
but thanks to the inherent ambiguity in parsing HTTP, you can never be sure there
won&#39;t be more.
</p>

<p>
I don&#39;t have to worry about any of this with snid.  Since snid doesn&#39;t decrypt
the TLS connection (and lacks the necessary keys to do so), proxying with
snid is guaranteed to be secure as long as TLS is secure.  It can harm security
no more than any untrusted router on the Internet can.  This helps put
snid out of my mind so I can forget that it even exists.
</p>


<h4>Compatible with ACME ALPN</h4>

<p>
Since ACME&#39;s <a href="https://datatracker.ietf.org/doc/html/rfc8737" rel="external">TLS-ALPN challenge</a>
uses SNI to convey the hostname being validated, snid will forward TLS-ALPN requests
from the certificate authority to the appropriate backend.
Automatic certificate acquisition, such as with Go&#39;s <a href="https://pkg.go.dev/golang.org/x/crypto/acme/autocert" rel="external">autocert
package</a>, Just Works.
</p>


<h4>What About Encrypted Client Hello?</h4>

<p>
Since the SNI hostname is in plaintext, a network eavesdropper can determine
what hostname a client is connecting to.  This is bad for privacy
and censorship resistance, so there is an <a href="https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-14" rel="external">effort underway to encrypt</a> not just the SNI hostname, but the entire Client Hello message.  How does this affect snid?
</p>

<p>
First, it&#39;s important to note that the destination IP address in the IP
header is always going to be unencrypted, so by putting my webapps on
different IPv6 addresses, I&#39;m giving eavesdroppers the ability to find
out which webapp clients are connecting to, regardless of SNI.
However, a single webapp might handle multiple hostnames, and I&#39;d like
to hide the specific hostname from eavesdroppers, so Encrypted Client
Hello still has some value.  Fortunately, Encrypted Client Hello works
with snid.
</p>

<p>
Encrypted Client Hello doesn&#39;t actually encrypt the initial Client
Hello message.  It&#39;s still sent in the clear, but with a decoy SNI hostname.
The actual Client Hello message, with the true SNI hostname, is encrypted and
placed in an extension of the unencrypted Client Hello.  To make Encrypted
Client Hello work with snid, I just need to ensure that the decoy SNI
hostname resolves to the IPv6 address of the backend server.  snid will
see this hostname and route the connection to the correct backend server,
as usual.  The backend will decrypt the true Encrypted Client Hello
to determine which specific hostname the client wants.
</p>

<p>
For additional detail about this approach, see my <a href="https://news.ycombinator.com/item?id=31136335" rel="external">comment on Hacker News</a>.
</p>


<h4>What About Port 80?</h4>

<p>
Obviously, I can&#39;t proxy unencrypted HTTP traffic using SNI-based proxying.  But at this
point, port 80 exists solely to redirect clients to HTTPS.  To handle
this, I plan to run a tiny, zero-config daemon on port 80 of all IPv4
and IPv6 addresses that will redirect the client to the same URL
but with <code>http://</code> replaced with <code>https://</code>.
(For now, I&#39;m using Apache for this.)
</p>


<h4>Installing snid</h4>

<p>
If you have Go, you can install snid by running:
</p>

<p><kbd><span>go install src.agwa.name/snid@latest</span></kbd></p><p>
You can also download a <a href="https://github.com/AGWA/snid/releases" rel="external">statically-linked binary</a>.
</p>

<p>
See the <a href="https://github.com/AGWA/snid/tree/main/README.md" rel="external">README</a> for the command line usage.
</p>


<h4>Rejected Approach: UNIX Domain Sockets</h4>

<p>
Before settling on the approach described above, I had snid listen on port
443 of all interfaces (both IPv4 and IPv6) and forward connections to a
UNIX domain socket whose path contained the SNI hostname.  For example, connections
to <code>example.com</code> would be forwarded to <code>/var/tls/example.com</code>.  The client&#39;s
IP address was preserved using the PROXY protocol.
</p>

<p>
This had some nice properties.  I could use filesystem permissions to
control who was allowed to create sockets, either by setting permissions
on <code>/var/tls</code>, or by symlinking specific hostnames under <code>/var/tls</code> to other
locations on the filesystem which non-root users could write to.
It felt really elegant that applications could listen
on an SNI hostname rather than on an IP address and port.
</p>

<p>
However, few server applications support the PROXY protocol or
listening on UNIX domain sockets.  I could make sure my
own apps had support, but I really wanted to be able to use off-the-shelf
apps with snid.  I did write an amazing <a href="https://github.com/AGWA/ldpreload#ldpreload-unixbindso" rel="external">LD_PRELOAD library</a> that
intercepts the <code>bind</code> system call and transparently replaces binding
to a TCP port with binding to a UNIX domain socket.  It even intercepts
<code>getpeername</code> and makes it returns the IP address received via the PROXY protocol.
Although this worked with every application I tried it with, it felt like a hack.
</p>

<p>
Additionally, UNIX domain sockets have some annoying semantics: if
the socket file already exists (perhaps because the application crashed
without removing the socket file), you can&#39;t bind to it - even if no
other program is actually bound to it.  But if you remove the socket file,
any program bound to it continues running, completely unaware that it will
never again accept a client.  The semantics of TCP port binding feel
more robust in comparison.
</p>

<p>
For these reasons I switched to the IPv6 approach described above, allowing
me to use standard, unmodified TCP-listening server apps without any hacks that
might compromise robustness.  However, support for UNIX domain sockets
lives on in snid with the <code>-mode unix</code> flag.
</p>


</div></div>
  </body>
</html>
