<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ably.com/blog/redis-keys-do-not-expire-atomically">Original</a>
    <h1>Redis scripts do not expire keys atomically</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main" data-namespace="post">
  <div>
    <article>

      

      <section data-layout="col@sm-down--">
        
      </section>

      <section>
        <div>
          <p>This short post by a member of Ably&#39;s engineering team describes how we resolved a problem that is typical of the challenges we face each week. We thrive on solving hard distributed system problems that are mostly platform agnostic and theoretical in nature, and this is the first post in a long-term series of articles about things we&#39;ve learned recently.</p>
<h2 id="how-we-use-redis-at-ably">How we use Redis at Ably</h2>
<p>Ably is a <a href="https://ably.com/pub-sub-messaging">platform for pub/sub messaging</a>. Publishes are made on named channels, and clients subscribed to a given channel have all messages on that channel delivered to them. We use <a href="https://redis.io/">Redis</a>, a distributed in-memory database for key-based storage, to store various entities such as authentication tokens and ephemeral channel state. It’s a good fit for temporary storage of messages while we process them.</p>
<p>We have billions of active Redis keys at any given time, which are sharded across numerous Redis instances. The sharding strategy places related keys in the same shard so that we can perform operations that update related keys atomically. We use Lua Redis scripts extensively to query and update keys and rely on the <a href="https://redis.io/commands/eval#atomicity-of-scripts">atomicity of script execution</a> to preserve the integrity of values of related keys. That is, either all commands in the script run, or none at all run, and no other commands execute at the same time.</p>
<p>We also use <a href="https://redis.io/commands/expire">expiring keys</a> extensively; the nature of the Ably service is that much of the state of a channel is ephemeral and only retained for a limited period of time (typically 2 minutes). We set keys to have a TTL so they auto-expire.</p>

<p>The integrity of a set of related keys requires that either all keys exist, or none exist. We had assumed that the atomic nature of script execution would also apply to expire operations invoked by a script, but it isn&#39;t in fact true that naively expiring multiple keys in the same script will preserve that integrity.</p>
<p>While expire operations execute atomically within the same script (with no opportunity for intervening operations to occur), nonetheless the timestamps associated with each expire operation are not necessarily the same.</p>
<p>Running <code>TIME</code> shows two different values:</p>
<!--kg-card-begin: markdown--><pre><code>-- time.lua       

local a = redis.call(&#39;time&#39;)       
local b = redis.call(&#39;time&#39;)       
return {a, b}       
</code></pre>
<pre><code>$ ./redis-cli --eval /app/time.lua      

1) 1) &#34;1638280442&#34;     
   2) &#34;996960&#34;     
2) 1) &#34;1638280442&#34;     
   2) &#34;996966&#34;      
</code></pre>
<!--kg-card-end: markdown--><p>Checking the actual expiry time:</p>
<!--kg-card-begin: markdown--><pre><code>-- expire_check.lua     

redis.call(&#39;set&#39;, &#39;foo&#39;, &#39;1&#39;)     
redis.call(&#39;expire&#39;, &#39;foo&#39;, 1)     

-- slow calls...

redis.call(&#39;set&#39;, &#39;bar&#39;, &#39;2&#39;)     
redis.call(&#39;expire&#39;, &#39;bar&#39;, 1)     

local fooExpiry = redis.call(&#39;PEXPIRETIME&#39;, &#39;foo&#39;)     
local barExpiry = redis.call(&#39;PEXPIRETIME&#39;, &#39;bar&#39;)     
return {fooExpiry, barExpiry}     
</code></pre>
<pre><code>$ ./redis-cli --eval /app/expire_check.lua     

1) (integer) 1638280843717     
2) (integer) 1638280843730     
</code></pre>
<!--kg-card-end: markdown--><p>The expire might not be pin-point accurate, and it could be between zero to 1 milliseconds out.</p>
<p>The implication is that there could be times at which some keys have expired, but other related keys have not and this could lead to an inconsistent state.</p>

<p>The solution is to use <code>EXPIREAT</code> to set an absolute expiry time for all related keys, rather than rely on a relative expiry time through the TTL.</p>
<p>The Redis documentation is not clear if multiple key expiry is guaranteed to occur at the same time if keys have the same <code>EXPIREAT</code> setting. To be cautious, we reordered key expiry to ensure that, regardless, we avoid inconsistency.</p>
<!--kg-card-begin: markdown--><pre><code>-- expire_new.lua     

-- Unix time     

local now = redis.call(&#39;time&#39;)[1]     
local expiry = now + 1     
redis.call(&#39;set&#39;, &#39;foo&#39;, &#39;1&#39;)     
redis.call(&#39;expireat&#39;, &#39;foo&#39;, expiry)     

-- slow calls...     

redis.call(&#39;set&#39;, &#39;bar&#39;, &#39;2&#39;)     
redis.call(&#39;expireat&#39;, &#39;bar&#39;, expiry)     
local fooExpiry = redis.call(&#39;PEXPIRETIME&#39;, &#39;foo&#39;)     
local barExpiry = redis.call(&#39;PEXPIRETIME&#39;, &#39;bar&#39;)     
return {now, fooExpiry, barExpiry}     
</code></pre>
<pre><code>$ ./redis-cli --eval /app/expire_new.lua

2) (integer) 1638281266000     
3) (integer) 1638281266000     
</code></pre>
<!--kg-card-end: markdown--><p>This is typical of one of the many engineering problems we troubleshoot and solve each week here at <a href="https://www.ably.com">Ably</a>. </p>
<p>Fancy working with us in the realtime sphere? Our engineers have a range of broad technology skills across infrastructure, security, distributed systems, and beyond. </p>
<p>You can find us on <a href="https://twitter.com/ablyrealtime">Twitter</a> or <a href="https://www.linkedin.com/company/ably-realtime/">LinkedIn</a>, and apply to join us in one of our <a href="http://www.ably.com/careers">open roles</a>.</p>
<!--kg-card-begin: hr--><hr/>
<!--kg-card-end: hr--><h2 id="latest-from-ably-engineering"><strong>Latest from Ably Engineering</strong></h2>

<ul>
<li><a href="https://ably.com/blog/channel-global-decoupling">Channel global decoupling for region discovery</a></li>
<li><a href="https://ably.com/blog/github-repository-audit-tool">Conform and monitor...with humanity</a></li>
<li><a href="https://ably.com/blog/best-practices-for-on-call-processes">Save your engineers&#39; sleep: best practices for on-call processes</a></li>
<li><a href="https://ably.com/blog/how-we-load-tested-control-api">Squid game: how we load-tested Ably’s Control API</a></li>
<li><a href="https://ably.com/blog/migrating-from-node-redis-to-ioredis">Migrating from Node Redis to Ioredis: a slightly bumpy but faster road</a></li>
<li><a href="https://ably.com/blog/no-we-dont-use-kubernetes">No, we don&#39;t use Kubernetes</a></li>
</ul>

        </div>

        <!-- Social share section -->
        
      </section>


      
    </article>
  </div>
</div></div>
  </body>
</html>
