<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cppstories.com/2024/enum-improvements/">Original</a>
    <h1>Enum class improvements for C&#43;&#43;17, C&#43;&#43;20 and C&#43;&#43;23</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p><img src="https://www.cppstories.com/2024/images/enum_improvements.png" alt=""/></p>                
        <p>The evolution of the C++ language continues to bring powerful features that enhance code safety, readability, and maintainability. Among these improvements, we got changes and additions to <code>enum class</code> functionalities across C++17, C++20, and C++23. In this blog post, we’ll explore these advancements, focusing on initialization improvements in C++17, the introduction of the <code>using enum</code> keyword in C++20, and the <code>std::to_underlying</code> utility in C++23.</p>
<p>Let’s go.</p>
<h2 id="enum-class-recap">
Enum Class Recap 
  
<a href="#enum-class-recap" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>Before diving into the enhancements, let’s briefly recap what <code>enum class</code> is. An <code>enum class</code> (scoped enumeration) provides a type-safe way of defining a set of named constants. Unlike traditional (unscoped) enums, <code>enum class</code> does not implicitly convert to integers or other types, preventing accidental misuse. Here’s a basic example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>enum</span> <span>class</span> <span>Color</span> <span>{</span>
</span></span><span><span>    <span>Red</span><span>,</span>
</span></span><span><span>    <span>Green</span><span>,</span>
</span></span><span><span>    <span>Blue</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>    
</span></span><span><span>    <span>Color</span> <span>color</span> <span>=</span> <span>Color</span><span>::</span><span>Red</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>color</span> <span>==</span> <span>Color</span><span>::</span><span>Red</span><span>)</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;The color is red.</span><span>\n</span><span>&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>color</span> <span>=</span> <span>Color</span><span>::</span><span>Blue</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>color</span> <span>==</span> <span>Color</span><span>::</span><span>Blue</span><span>)</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;The color is blue.</span><span>\n</span><span>&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>// std::cout &lt;&lt; color; // error, no matching &lt;&lt; operator
</span></span></span><span><span><span></span>    <span>// int i = color;      // error: cannot convert
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>Run <a href="https://godbolt.org/z/c4P6n8z9Y">@Compiler Explorer</a></p>
<p>Notice the two lines near the end of the <code>main</code> function. You’ll get compiler errors as there’s no implicit conversion to integer types.</p>
<p>As a comparison here’s a similar example, but with unscoped enums:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>enum</span> <span>Color</span> <span>{</span>
</span></span><span><span>    <span>Red</span><span>,</span>
</span></span><span><span>    <span>Green</span><span>,</span>
</span></span><span><span>    <span>Blue</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>    
</span></span><span><span>    <span>Color</span> <span>color</span> <span>=</span> <span>Red</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>color</span> <span>==</span> <span>Red</span><span>)</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;The color is red.</span><span>\n</span><span>&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>color</span> <span>=</span> <span>Blue</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>color</span> <span>==</span> <span>Blue</span><span>)</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;The color is blue.</span><span>\n</span><span>&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>color</span><span>;</span> <span>// fine, prints integer value!
</span></span></span><span><span><span></span>    <span>int</span> <span>i</span> <span>=</span> <span>color</span><span>;</span>      <span>// fine, can convert...
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>Run <a href="https://godbolt.org/z/xaorMje9W">@Compiler Explorer</a></p>
<p>In short, while <code>enum classes</code> give us a separate scope for all of the enum values, they also enforce better type safety. There are no implicit conversions to integral values, and thus, you have better control over your design.</p>
<p>While the basics are simple, let’s now go to several improvements that are handy in the latest C++ revisions.</p>
<h2 id="c17-initialization-with-brace-initialization-from-underlying-type">
C++17: Initialization with Brace Initialization from Underlying Type 
  
<a href="#c17-initialization-with-brace-initialization-from-underlying-type" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>Enum class might sometimes feel too restrictive, and having some conversions might be handy:</p>
<p>In <a href="https://wg21.link/P0138R2">P0138</a> accepted for C++17 we have the following example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>enum</span> <span>class</span> <span>Handle</span> <span>:</span> <span>uint32_t</span> <span>{</span> <span>Invalid</span> <span>=</span> <span>0</span> <span>};</span> 
</span></span><span><span><span>Handle</span> <span>h</span> <span>{</span> <span>42</span> <span>};</span> <span>// OK
</span></span></span></code></pre></div><p>In short, when you use <code>enum class</code> to define strong types, it’s helpful to allow initializing from the underlying type without any errors. This wasn’t possible before C++17.</p>
<p>However, the change was cautious so that enums are still safe - they can be used only for uniform/brace initialization. Have a look at this code:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>enum</span> <span>class</span> <span>Handle</span> <span>:</span> <span>uint32_t</span> <span>{</span> <span>Invalid</span> <span>=</span> <span>0</span> <span>};</span> 
</span></span><span><span>
</span></span><span><span><span>void</span> <span>process</span><span>(</span><span>Handle</span> <span>h</span><span>)</span> <span>{</span>
</span></span><span><span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>    
</span></span><span><span>    <span>Handle</span> <span>h</span> <span>{</span> <span>42</span> <span>};</span> <span>// OK
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// process({10}); // error
</span></span></span><span><span><span></span>    <span>process</span><span>(</span><span>Handle</span><span>{</span><span>10</span><span>});</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>You cannot just pass <code>{10}</code> as the parameter for the <code>process</code> function. You still have to be explicit about the type.</p>
<p>In C++14, you could use <code>process(static_cast&lt;Handle&gt;(10));</code> so, as you can see, the C++17 version is much better.</p>
<h2 id="c20-using-enum">
C++20: Using Enum 
  
<a href="#c20-using-enum" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>C++20 introduced the <code>using enum</code> syntax, which enhances the usability of enums, particularly in contexts where scoped enums are preferred for their type safety. This feature allows you to bring all the enumerators of an enum into the current scope without losing the benefits of scoped enums.</p>
<p>Consider the following example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>enum</span> <span>class</span> <span>ComputeStatus</span> <span>{</span>
</span></span><span><span>    <span>Ok</span><span>,</span>
</span></span><span><span>    <span>Error</span><span>,</span>
</span></span><span><span>    <span>FileError</span><span>,</span>
</span></span><span><span>    <span>NotEnoughMemory</span><span>,</span>
</span></span><span><span>    <span>TimeExceeded</span><span>,</span>
</span></span><span><span>    <span>Unknown</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>In previous C++ versions, using these enumerators required qualifying them with the enum class name:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>ComputeStatus</span> <span>s</span> <span>=</span> <span>ComputeStatus</span><span>::</span><span>NotEnoughMemory</span><span>;</span>
</span></span></code></pre></div><p>C++20 simplifies this with the <code>using enum</code> declaration:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>using</span> <span>enum</span> <span>ComputeStatus</span><span>;</span>
</span></span><span><span>    <span>ComputeStatus</span> <span>s</span> <span>=</span> <span>NotEnoughMemory</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>It’s probably no sense in this silly code above, but how about the following case:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>    
</span></span><span><span>    <span>ComputeStatus</span> <span>s</span> <span>=</span> <span>ComputeStatus</span><span>::</span><span>Ok</span><span>;</span>
</span></span><span><span>    <span>switch</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>case</span> <span>ComputeStatus</span><span>::</span><span>Ok</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;ok&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>ComputeStatus</span><span>::</span><span>Error</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Error&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>ComputeStatus</span><span>::</span><span>FileError</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;FileError&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>ComputeStatus</span><span>::</span><span>NotEnoughMemory</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;NotEnoughMemory&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>ComputeStatus</span><span>::</span><span>TimeExceeded</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Time...&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>default</span><span>:</span> <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;unknown...&#34;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We can convert it into:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>    
</span></span><span><span>    <span>ComputeStatus</span> <span>s</span> <span>=</span> <span>ComputeStatus</span><span>::</span><span>Ok</span><span>;</span>
</span></span><span><span>    <span>switch</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>using</span> <span>enum</span> <span>ComputeStatus</span><span>;</span>	<span>// &lt;&lt; &lt;&lt;
</span></span></span><span><span><span></span>        <span>case</span> <span>Ok</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;ok&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>Error</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Error&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>FileError</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;FileError&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>NotEnoughMemory</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;NotEnoughMemory&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>TimeExceeded</span><span>:</span> 
</span></span><span><span>            <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Time...&#34;</span><span>;</span> <span>break</span><span>;</span>
</span></span><span><span>        <span>default</span><span>:</span> <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;unknown...&#34;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Run <a href="https://godbolt.org/z/fdjEThd8Y">@Compiler Explorer</a></p>
<p>Or have a look at the following example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>struct</span> <span>ComputeEngine</span> <span>{</span>
</span></span><span><span>    <span>enum</span> <span>class</span> <span>ComputeStatus</span> <span>{</span>
</span></span><span><span>        <span>Ok</span><span>,</span>
</span></span><span><span>        <span>Error</span><span>,</span>
</span></span><span><span>        <span>FileError</span><span>,</span>
</span></span><span><span>        <span>NotEnoughMemory</span><span>,</span>
</span></span><span><span>        <span>TimeExceeded</span><span>,</span>
</span></span><span><span>        <span>Unknown</span>
</span></span><span><span>    <span>};</span>
</span></span><span><span>    <span>using</span> <span>enum</span> <span>ComputeStatus</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>    
</span></span><span><span>    <span>ComputeEngine</span><span>::</span><span>ComputeStatus</span> <span>s</span> <span>=</span> <span>ComputeEngine</span><span>::</span><span>Ok</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>You can bring all enumerations into the scope of <code>CompueEngine</code> and still benefit from <code>enum class</code> features.</p>
<p>This C++20 improvement makes the code cleaner and reduces verbosity, especially in cases where multiple enumerators are frequently used within a scope. It allows for a more streamlined and readable approach without sacrificing the type safety provided by scoped enums.</p>
<h2 id="c23-stdto_underlying">
C++23: std::to_underlying 
  
<a href="#c23-stdto_underlying" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>C++23 further enhances enum class usability with the introduction of <code>std::to_underlying</code>, a utility function that converts an enum value to its underlying integral type. This feature addresses the common need to convert enum values to integers for storage, comparison, or interoperability with APIs that expect integral types.</p>
<p>The idea for this appeared in a wonderful book by Scott Meyers - <a href="https://amzn.to/3t5tmS4">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</a>. Finally in C++23 we can enjoy this feature being standardized.</p>
<p>Before C++23, converting an enum to its underlying type required explicit casting:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>enum</span> <span>class</span> <span>Permissions</span> <span>:</span> <span>uint8_t</span> <span>{</span>
</span></span><span><span>    <span>Read</span> <span>=</span> <span>1</span><span>,</span>
</span></span><span><span>    <span>Write</span> <span>=</span> <span>2</span><span>,</span>
</span></span><span><span>    <span>Execute</span> <span>=</span> <span>4</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>uint8_t</span> <span>value</span> <span>=</span> <span>static_cast</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span>(</span><span>Permissions</span><span>::</span><span>Read</span><span>);</span>
</span></span></code></pre></div><p>With <code>std::to_underlying</code>, this conversion becomes more straightforward and expressive:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;type_traits&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>Permissions</span> <span>p</span> <span>=</span> <span>Permissions</span><span>::</span><span>Read</span><span>;</span>
</span></span><span><span>    <span>auto</span> <span>value</span> <span>=</span> <span>std</span><span>::</span><span>to_underlying</span><span>(</span><span>p</span><span>);</span> <span>// C++23
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>The <code>std::to_underlying</code> function improves code readability and reduces the boilerplate associated with type casting. It also clarifies the intent, making it evident that the purpose is to obtain the underlying value of the enum.</p>
<p>Read more in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1682r0.html">P1682R0: std::to_underlying for enumerations</a></p>
<h2 id="future-improvements">
Future improvements 
  
<a href="#future-improvements" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>One important update that we may receive soon is support for C++26 reflections - check out <a href="https://wg21.link/P2996">P2996</a> (the proposal has not been accepted yet, but is expected to be approved soon…). Reflection opens up numerous exciting possibilities, such as the ability to convert enums into strings.</p>
<p>See this example from the proposal:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>E</span><span>&gt;</span>
</span></span><span><span>  <span>requires</span> <span>std</span><span>::</span><span>is_enum_v</span><span>&lt;</span><span>E</span><span>&gt;</span>
</span></span><span><span><span>constexpr</span> <span>std</span><span>::</span><span>string</span> <span>enum_to_string</span><span>(</span><span>E</span> <span>value</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>template</span> <span>for</span> <span>(</span><span>constexpr</span> <span>auto</span> <span>e</span> <span>:</span> <span>std</span><span>::</span><span>meta</span><span>::</span><span>enumerators_of</span><span>(</span><span>^</span><span>E</span><span>))</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>value</span> <span>==</span> <span>[</span><span>:</span><span>e</span><span>:])</span> <span>{</span>
</span></span><span><span>      <span>return</span> <span>std</span><span>::</span><span>string</span><span>(</span><span>std</span><span>::</span><span>meta</span><span>::</span><span>name_of</span><span>(</span><span>e</span><span>));</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>return</span> <span>&#34;&lt;unnamed&gt;&#34;</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>enum</span> <span>Color</span> <span>{</span> <span>red</span><span>,</span> <span>green</span><span>,</span> <span>blue</span> <span>};</span>
</span></span><span><span><span>static_assert</span><span>(</span><span>enum_to_string</span><span>(</span><span>Color</span><span>::</span><span>red</span><span>)</span> <span>==</span> <span>&#34;red&#34;</span><span>);</span>
</span></span><span><span><span>static_assert</span><span>(</span><span>enum_to_string</span><span>(</span><span>Color</span><span>(</span><span>42</span><span>))</span> <span>==</span> <span>&#34;&lt;unnamed&gt;&#34;</span><span>);</span>
</span></span></code></pre></div><p>See at <a href="https://godbolt.org/z/Y5va8MqzG">EDG experimental implementation</a> @CompilerExplorer</p>
<h2 id="summary">
Summary 
  
<a href="#summary" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>In this article, we covered some of the new features introduced in C++17, C++20, and C++23 for enum classes. Enum classes provide type safety, but there are situations where we may need to relax some restrictions and write more concise code. We also explored the potential use case for C++26 reflection.</p>
<h4 id="back-to-you">
Back to you 
    
</h4>

<ul>
<li>Have you tried the latest improvements for <code>enum class</code>?</li>
<li>Do you use <code>enum class</code> for strong types or some other techniques?</li>
</ul>
<p>Share your feedback below in the comments.</p>

      </div></div>
  </body>
</html>
